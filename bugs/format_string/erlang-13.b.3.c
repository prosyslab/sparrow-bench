/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 186 "../include/ei.h"
struct __anonstruct_erlang_pid_30 {
   char node[256] ;
   unsigned int num ;
   unsigned int serial ;
   unsigned int creation ;
};
#line 186 "../include/ei.h"
typedef struct __anonstruct_erlang_pid_30 erlang_pid;
#line 194 "../include/ei.h"
struct __anonstruct_erlang_port_31 {
   char node[256] ;
   unsigned int id ;
   unsigned int creation ;
};
#line 194 "../include/ei.h"
typedef struct __anonstruct_erlang_port_31 erlang_port;
#line 201 "../include/ei.h"
struct __anonstruct_erlang_ref_32 {
   char node[256] ;
   int len ;
   unsigned int n[3] ;
   unsigned int creation ;
};
#line 201 "../include/ei.h"
typedef struct __anonstruct_erlang_ref_32 erlang_ref;
#line 209 "../include/ei.h"
struct __anonstruct_erlang_trace_33 {
   long serial ;
   long prev ;
   erlang_pid from ;
   long label ;
   long flags ;
};
#line 209 "../include/ei.h"
typedef struct __anonstruct_erlang_trace_33 erlang_trace;
#line 218 "../include/ei.h"
struct __anonstruct_erlang_msg_34 {
   long msgtype ;
   erlang_pid from ;
   erlang_pid to ;
   char toname[256] ;
   char cookie[256] ;
   erlang_trace token ;
};
#line 218 "../include/ei.h"
typedef struct __anonstruct_erlang_msg_34 erlang_msg;
#line 44 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eidef.h"
typedef unsigned char uint8;
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 519 "../include/ei.h"
struct bucket_s {
   int rawhash ;
   char const   *key ;
   char keybuf[32] ;
   void const   *value ;
   struct bucket_s *next ;
};
#line 519 "../include/ei.h"
typedef struct bucket_s ei_bucket;
#line 528 "../include/ei.h"
struct __anonstruct_ei_hash_36 {
   ei_bucket **tab ;
   int (*hash)(char const   * ) ;
   int size ;
   int nelem ;
   int npos ;
   ei_bucket *freelist ;
};
#line 528 "../include/ei.h"
typedef struct __anonstruct_ei_hash_36 ei_hash;
#line 561 "../include/ei.h"
union __anonunion_val_37 {
   long i ;
   double f ;
   char *s ;
   void *p ;
};
#line 561 "../include/ei.h"
struct ei_reg_inode {
   int attr ;
   int size ;
   union __anonunion_val_37 val ;
   struct ei_reg_inode *next ;
};
#line 561 "../include/ei.h"
typedef struct ei_reg_inode ei_reg_obj;
#line 573 "../include/ei.h"
struct __anonstruct_ei_reg_38 {
   ei_reg_obj *freelist ;
   ei_hash *tab ;
};
#line 573 "../include/ei.h"
typedef struct __anonstruct_ei_reg_38 ei_reg;
#line 583 "../include/ei.h"
struct ei_reg_tabstat {
   int size ;
   int nelem ;
   int npos ;
   int collisions ;
};
#line 578 "../include/ei.h"
struct ei_reg_stat {
   int attr ;
   int size ;
};
#line 269 "../include/ei.h"
struct ei_cnode_s {
   char thishostname[65] ;
   char thisnodename[129] ;
   char thisalivename[64] ;
   char ei_connect_cookie[513] ;
   short creation ;
   erlang_pid self ;
};
#line 269 "../include/ei.h"
typedef struct ei_cnode_s ei_cnode;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 285 "../include/ei.h"
struct ei_x_buff_TAG {
   char *buff ;
   int buffsz ;
   int index ;
};
#line 285 "../include/ei.h"
typedef struct ei_x_buff_TAG ei_x_buff;
#line 228 "../include/ei.h"
struct __anonstruct_erlang_fun_31 {
   long arity ;
   char module[256] ;
   char md5[16] ;
   long index ;
   long old_index ;
   long uniq ;
   long n_free_vars ;
   erlang_pid pid ;
   long free_var_len ;
   char *free_vars ;
};
#line 228 "../include/ei.h"
typedef struct __anonstruct_erlang_fun_31 erlang_fun;
#line 242 "../include/ei.h"
struct __anonstruct_erlang_big_32 {
   unsigned int arity ;
   int is_neg ;
   void *digits ;
};
#line 242 "../include/ei.h"
typedef struct __anonstruct_erlang_big_32 erlang_big;
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.h"
typedef unsigned int UINT4;
#line 31 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.h"
typedef void *POINTER;
#line 38 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.h"
struct __anonstruct_MD5_CTX_39 {
   UINT4 state[4] ;
   UINT4 count[2] ;
   unsigned char buffer[64] ;
};
#line 38 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.h"
typedef struct __anonstruct_MD5_CTX_39 MD5_CTX;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 67 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 67 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_10 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_10 __annonCompField1 ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_9 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_9 pthread_mutex_t;
#line 106 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_11 {
   char __size[4] ;
   int __align ;
};
#line 106 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_11 pthread_mutexattr_t;
#line 140 "/usr/include/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 144 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 35 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 44 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.h"
struct ei_mutex_s {
   pthread_mutex_t *lock ;
};
#line 44 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.h"
typedef struct ei_mutex_s ei_mutex_t;
#line 49 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
union arg {
   char *s ;
   long l ;
   unsigned long u ;
   double d ;
};
#line 248 "../include/ei.h"
union __anonunion_value_34 {
   long i_val ;
   double d_val ;
   char atom_name[256] ;
   erlang_pid pid ;
   erlang_port port ;
   erlang_ref ref ;
};
#line 248 "../include/ei.h"
struct __anonstruct_ei_term_33 {
   char ei_type ;
   int arity ;
   int size ;
   union __anonunion_value_34 value ;
};
#line 248 "../include/ei.h"
typedef struct __anonstruct_ei_term_33 ei_term;
#line 34 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 264 "../include/ei.h"
struct __anonstruct_ErlConnect_35 {
   char ipadr[4] ;
   char nodename[129] ;
};
#line 264 "../include/ei.h"
typedef struct __anonstruct_ErlConnect_35 ErlConnect;
#line 280 "../include/ei.h"
typedef struct in_addr *Erl_IpAddr;
#line 45 "misc/eidef.h"
typedef unsigned short uint16;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 49 "/usr/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 149 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
struct ei_socket_info_s {
   int socket ;
   int dist_version ;
   ei_cnode cnode ;
   char cookie[513] ;
};
#line 149 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
typedef struct ei_socket_info_s ei_socket_info;
#line 1088 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
union __anonunion_digest_60 {
   char c[16] ;
   unsigned int x[4] ;
};
#line 1132 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
struct __anonstruct_s_61 {
   struct timeval tv ;
   clock_t cpu ;
   pid_t pid ;
   u_long hid ;
   uid_t uid ;
   gid_t gid ;
   struct utsname name ;
};
#line 94 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
typedef unsigned short Uint16;
#line 95 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
typedef unsigned int Uint;
#line 97 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
typedef Uint16 digit_t;
#line 98 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
typedef Uint dsize_t;
#line 106 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c"
typedef socklen_t SocklenType;
#line 100 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
struct call_flags {
   int startp ;
   int cookiep ;
   int modp ;
   int evalp ;
   int randomp ;
   int use_long_name ;
   int debugp ;
   int verbosep ;
   int haltp ;
   char *cookie ;
   char *node ;
   char *hidden ;
   char *apply ;
   char *script ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 356
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 157 "../include/ei.h"
int volatile   *__erl_errno_place(void)  __attribute__((__const__)) ;
#line 452
int ei_get_type_internal(char const   *buf , int const   *index , int *type , int *len ) ;
#line 462
int ei_decode_version(char const   *buf , int *index , int *version ) ;
#line 463
int ei_decode_long(char const   *buf , int *index , long *p ) ;
#line 465
int ei_decode_double(char const   *buf , int *index , double *p ) ;
#line 468
int ei_decode_string(char const   *buf , int *index___0 , char *p ) ;
#line 469
int ei_decode_atom(char const   *buf , int *index___0 , char *p ) ;
#line 470
int ei_decode_binary(char const   *buf , int *index___0 , void *p , long *lenp ) ;
#line 473
int ei_decode_pid(char const   *buf , int *index___0 , erlang_pid *p ) ;
#line 474
int ei_decode_port(char const   *buf , int *index___0 , erlang_port *p ) ;
#line 475
int ei_decode_ref(char const   *buf , int *index___0 , erlang_ref *p ) ;
#line 477
int ei_decode_trace(char const   *buf , int *index , erlang_trace *p ) ;
#line 478
int ei_decode_tuple_header(char const   *buf , int *index , int *arity ) ;
#line 479
int ei_decode_list_header(char const   *buf , int *index , int *arity ) ;
#line 509
int ei_skip_term(char const   *buf , int *index ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 258
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 152 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_internal.h"
int ei_tracelevel  ;
#line 154
void ei_trace_printf(char const   *name , int level , char const   *format  , ...) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.h"
void ei_show_recmsg(FILE *stream , erlang_msg *msg , char *buf ) ;
#line 25
int ei_show_sendmsg(FILE *stream , char const   *header , char const   *msgbuf ) ;
#line 54 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static void show_term(char const   *termbuf , int *index___0 , FILE *stream ) ;
#line 55
static void show_pid(FILE *stream , erlang_pid const   *pid ) ;
#line 56
static void show_trace(FILE *stream , erlang_trace const   *t ) ;
#line 57
static void show_msg(FILE *stream , int direction , erlang_msg const   *msg , char const   *buf ) ;
#line 59
static void ei_efprint(FILE *stream , char const   *termbuf ) ;
#line 60
static int ei_decode_skip_bignum(char const   *buf , int *index___0 , void *p ) ;
#line 61
static int printable_list_p(uint8 const   *buf , int buflen ) ;
#line 70 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
void ei_trace_printf(char const   *name , int level , char const   *format  , ...) 
{ 
  time_t now ;
  char *timestr ;
  char buf[2048] ;
  int len ;
  va_list args ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 78
  __builtin_va_start(args, format);
#line 80
  time(& now);
#line 81
  tmp = ctime((time_t const   *)(& now));
#line 81
  timestr = tmp;
#line 82
  tmp___0 = strlen((char const   *)timestr);
#line 82
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s: %.*s: ",
          name, (int )tmp___0 - 1, timestr);
#line 83
  tmp___1 = strlen((char const   *)(buf));
#line 83
  len = (int )tmp___1;
#line 84
  vsprintf((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)format,
           args);
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\r\n",
          buf);
#line 86
  __builtin_va_end(args);
  }
#line 87
  return;
}
}
#line 112 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
void ei_show_recmsg(FILE *stream , erlang_msg *msg , char *buf ) 
{ 


  {
  {
#line 114
  show_msg(stream, 0, (erlang_msg const   *)msg, (char const   *)buf);
  }
#line 115
  return;
}
}
#line 119 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
int ei_show_sendmsg(FILE *stream , char const   *header , char const   *msgbuf ) 
{ 
  erlang_msg msg ;
  char const   *mbuf ;
  int index___0 ;
  int arity ;
  int version ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 122
  mbuf = (char const   *)((void *)0);
#line 123
  index___0 = 0;
#line 124
  arity = 0;
#line 125
  version = 0;
#line 128
  index___0 = 5;
#line 129
  ei_decode_version(header, & index___0, & version);
#line 130
  ei_decode_tuple_header(header, & index___0, & arity);
#line 131
  ei_decode_long(header, & index___0, & msg.msgtype);
  }
  {
#line 134
  if (msg.msgtype == 2L) {
#line 134
    goto case_2;
  }
#line 140
  if (msg.msgtype == 12L) {
#line 140
    goto case_12;
  }
#line 147
  if (msg.msgtype == 6L) {
#line 147
    goto case_6;
  }
#line 154
  if (msg.msgtype == 16L) {
#line 154
    goto case_16;
  }
#line 163
  if (msg.msgtype == 8L) {
#line 163
    goto case_8;
  }
#line 163
  if (msg.msgtype == 3L) {
#line 163
    goto case_8;
  }
#line 169
  if (msg.msgtype == 18L) {
#line 169
    goto case_18;
  }
#line 169
  if (msg.msgtype == 13L) {
#line 169
    goto case_18;
  }
#line 178
  if (msg.msgtype == 7L) {
#line 178
    goto case_7;
  }
#line 178
  if (msg.msgtype == 4L) {
#line 178
    goto case_7;
  }
#line 178
  if (msg.msgtype == 1L) {
#line 178
    goto case_7;
  }
#line 184
  if (msg.msgtype == 5L) {
#line 184
    goto case_5;
  }
#line 189
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 135
  tmp = ei_decode_atom(header, & index___0, msg.cookie);
  }
#line 135
  if (tmp) {
#line 136
    return (-1);
  } else {
    {
#line 135
    tmp___0 = ei_decode_pid(header, & index___0, & msg.to);
    }
#line 135
    if (tmp___0) {
#line 136
      return (-1);
    }
  }
#line 137
  mbuf = msgbuf;
#line 138
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 141
  tmp___1 = ei_decode_atom(header, & index___0, msg.cookie);
  }
#line 141
  if (tmp___1) {
#line 143
    return (-1);
  } else {
    {
#line 141
    tmp___2 = ei_decode_pid(header, & index___0, & msg.to);
    }
#line 141
    if (tmp___2) {
#line 143
      return (-1);
    } else {
      {
#line 141
      tmp___3 = ei_decode_trace(header, & index___0, & msg.token);
      }
#line 141
      if (tmp___3) {
#line 143
        return (-1);
      }
    }
  }
#line 144
  mbuf = msgbuf;
#line 145
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 148
  tmp___4 = ei_decode_pid(header, & index___0, & msg.from);
  }
#line 148
  if (tmp___4) {
#line 150
    return (-1);
  } else {
    {
#line 148
    tmp___5 = ei_decode_atom(header, & index___0, msg.cookie);
    }
#line 148
    if (tmp___5) {
#line 150
      return (-1);
    } else {
      {
#line 148
      tmp___6 = ei_decode_atom(header, & index___0, msg.toname);
      }
#line 148
      if (tmp___6) {
#line 150
        return (-1);
      }
    }
  }
#line 151
  mbuf = msgbuf;
#line 152
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 155
  tmp___7 = ei_decode_pid(header, & index___0, & msg.from);
  }
#line 155
  if (tmp___7) {
#line 158
    return (-1);
  } else {
    {
#line 155
    tmp___8 = ei_decode_atom(header, & index___0, msg.cookie);
    }
#line 155
    if (tmp___8) {
#line 158
      return (-1);
    } else {
      {
#line 155
      tmp___9 = ei_decode_atom(header, & index___0, msg.toname);
      }
#line 155
      if (tmp___9) {
#line 158
        return (-1);
      } else {
        {
#line 155
        tmp___10 = ei_decode_trace(header, & index___0, & msg.token);
        }
#line 155
        if (tmp___10) {
#line 158
          return (-1);
        }
      }
    }
  }
#line 159
  mbuf = msgbuf;
#line 160
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 164
  tmp___11 = ei_decode_pid(header, & index___0, & msg.from);
  }
#line 164
  if (tmp___11) {
#line 165
    return (-1);
  } else {
    {
#line 164
    tmp___12 = ei_decode_pid(header, & index___0, & msg.to);
    }
#line 164
    if (tmp___12) {
#line 165
      return (-1);
    }
  }
#line 166
  mbuf = header + index___0;
  case_18: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 170
  tmp___13 = ei_decode_pid(header, & index___0, & msg.from);
  }
#line 170
  if (tmp___13) {
#line 172
    return (-1);
  } else {
    {
#line 170
    tmp___14 = ei_decode_pid(header, & index___0, & msg.to);
    }
#line 170
    if (tmp___14) {
#line 172
      return (-1);
    } else {
      {
#line 170
      tmp___15 = ei_decode_trace(header, & index___0, & msg.token);
      }
#line 170
      if (tmp___15) {
#line 172
        return (-1);
      }
    }
  }
#line 173
  mbuf = header + index___0;
#line 174
  goto switch_break;
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 179
  tmp___16 = ei_decode_pid(header, & index___0, & msg.from);
  }
#line 179
  if (tmp___16) {
#line 180
    return (-1);
  } else {
    {
#line 179
    tmp___17 = ei_decode_pid(header, & index___0, & msg.to);
    }
#line 179
    if (tmp___17) {
#line 180
      return (-1);
    }
  }
#line 181
  mbuf = header;
#line 182
  goto switch_break;
  case_5: /* CIL Label */ 
#line 186
  mbuf = header;
#line 187
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 190
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 193
  show_msg(stream, 1, (erlang_msg const   *)(& msg), mbuf);
  }
#line 195
  return (0);
}
}
#line 205 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static void show_msg(FILE *stream , int direction , erlang_msg const   *msg , char const   *buf ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 208
  if (direction) {
    {
#line 208
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-> ");
    }
  } else {
    {
#line 209
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<- ");
    }
  }
  {
#line 212
  if (msg->msgtype == 1L) {
#line 212
    goto case_1;
  }
#line 219
  if (msg->msgtype == 2L) {
#line 219
    goto case_2;
  }
#line 227
  if (msg->msgtype == 3L) {
#line 227
    goto case_3;
  }
#line 237
  if (msg->msgtype == 4L) {
#line 237
    goto case_4;
  }
#line 244
  if (msg->msgtype == 5L) {
#line 244
    goto case_5;
  }
#line 248
  if (msg->msgtype == 6L) {
#line 248
    goto case_6;
  }
#line 256
  if (msg->msgtype == 7L) {
#line 256
    goto case_7;
  }
#line 263
  if (msg->msgtype == 8L) {
#line 263
    goto case_8;
  }
#line 275
  if (msg->msgtype == 13L) {
#line 275
    goto case_13;
  }
#line 287
  if (msg->msgtype == 18L) {
#line 287
    goto case_18;
  }
#line 299
  if (msg->msgtype == 12L) {
#line 299
    goto case_12;
  }
#line 309
  if (msg->msgtype == 16L) {
#line 309
    goto case_16;
  }
#line 319
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 213
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"LINK From: ");
#line 214
  show_pid(stream, & msg->from);
#line 215
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 216
  show_pid(stream, & msg->to);
  }
#line 217
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 220
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"SEND To: ");
#line 221
  show_pid(stream, & msg->to);
#line 222
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   ");
#line 224
  ei_efprint(stream, buf);
  }
#line 225
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 228
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"EXIT From: ");
#line 229
  show_pid(stream, & msg->from);
#line 230
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 231
  show_pid(stream, & msg->to);
#line 233
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   Reason: ");
#line 234
  ei_efprint(stream, buf);
  }
#line 235
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"UNLINK From: ");
#line 239
  show_pid(stream, & msg->from);
#line 240
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 241
  show_pid(stream, & msg->to);
  }
#line 242
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 245
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"NODE_LINK");
  }
#line 246
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 249
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"REG_SEND From: ");
#line 250
  show_pid(stream, & msg->from);
#line 251
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: %s\n   ",
          msg->toname);
#line 253
  ei_efprint(stream, buf);
  }
#line 254
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 257
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"GROUP_LEADER From: ");
#line 258
  show_pid(stream, & msg->from);
#line 259
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 260
  show_pid(stream, & msg->to);
  }
#line 261
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 264
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"EXIT2 From: ");
#line 265
  show_pid(stream, & msg->from);
#line 266
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 267
  show_pid(stream, & msg->to);
#line 269
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   Reason: ");
#line 270
  ei_efprint(stream, buf);
  }
#line 271
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 276
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"EXIT_TT From: ");
#line 277
  show_pid(stream, & msg->from);
#line 278
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 279
  show_pid(stream, & msg->to);
#line 280
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   ");
#line 281
  show_trace(stream, & msg->token);
#line 283
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   Reason: ");
#line 284
  ei_efprint(stream, buf);
  }
#line 285
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 288
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"EXIT2_TT From: ");
#line 289
  show_pid(stream, & msg->from);
#line 290
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: ");
#line 291
  show_pid(stream, & msg->to);
#line 292
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   ");
#line 293
  show_trace(stream, & msg->token);
#line 295
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   Reason: ");
#line 296
  ei_efprint(stream, buf);
  }
#line 297
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 300
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"SEND_TT To: ");
#line 301
  show_pid(stream, & msg->to);
#line 302
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   ");
#line 303
  show_trace(stream, & msg->token);
#line 304
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   ");
#line 306
  ei_efprint(stream, buf);
  }
#line 307
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 310
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"REG_SEND_TT From: ");
#line 311
  show_pid(stream, & msg->from);
#line 312
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" To: %s\n   ",
          msg->toname);
#line 313
  show_trace(stream, & msg->token);
#line 314
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n   ");
#line 316
  ei_efprint(stream, buf);
  }
#line 317
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 320
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Unknown message type: %ld",
          msg->msgtype);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 322
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
  }
#line 323
  return;
}
}
#line 332 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static void ei_efprint(FILE *stream , char const   *termbuf ) 
{ 
  int index___0 ;

  {
  {
#line 334
  index___0 = 0;
#line 335
  show_term(termbuf, & index___0, stream);
  }
#line 336
  return;
}
}
#line 338 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static void show_term(char const   *termbuf , int *index___0 , FILE *stream ) 
{ 
  int type ;
  char smallbuf[512] ;
  int version ;
  long num ;
  double fnum ;
  erlang_pid pid ;
  erlang_port port ;
  erlang_ref ref ;
  int i ;
  int len ;
  char *s ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char atom[256] ;
  long idx ;
  long uniq ;
  char const   *s___0 ;
  char const   *s0 ;
  int n_free ;
  int tmp___2 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 351
  ei_get_type_internal(termbuf, (int const   *)index___0, & type, & len);
  }
  {
#line 354
  if (type == 131) {
#line 354
    goto case_131;
  }
#line 360
  if (type == 100) {
#line 360
    goto case_100;
  }
#line 365
  if (type == 107) {
#line 365
    goto case_107;
  }
#line 393
  if (type == 98) {
#line 393
    goto case_98;
  }
#line 393
  if (type == 97) {
#line 393
    goto case_98;
  }
#line 393
  if (type == 110) {
#line 393
    goto case_98;
  }
#line 402
  if (type == 99) {
#line 402
    goto case_99;
  }
#line 407
  if (type == 103) {
#line 407
    goto case_103;
  }
#line 413
  if (type == 105) {
#line 413
    goto case_105;
  }
#line 413
  if (type == 104) {
#line 413
    goto case_105;
  }
#line 423
  if (type == 108) {
#line 423
    goto case_108;
  }
#line 435
  if (type == 106) {
#line 435
    goto case_106;
  }
#line 441
  if (type == 114) {
#line 441
    goto case_114;
  }
#line 441
  if (type == 101) {
#line 441
    goto case_114;
  }
#line 450
  if (type == 102) {
#line 450
    goto case_102;
  }
#line 455
  if (type == 109) {
#line 455
    goto case_109;
  }
#line 460
  if (type == 111) {
#line 460
    goto case_111;
  }
#line 467
  if (type == 117) {
#line 467
    goto case_117;
  }
#line 489
  goto switch_default;
  case_131: /* CIL Label */ 
  {
#line 356
  ei_decode_version(termbuf, index___0, & version);
#line 357
  show_term(termbuf, index___0, stream);
  }
#line 358
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 361
  ei_decode_atom(termbuf, index___0, smallbuf);
#line 362
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
          smallbuf);
  }
#line 363
  goto switch_break;
  case_107: /* CIL Label */ 
#line 367
  if (len < 512) {
#line 367
    s = smallbuf;
  } else {
    {
#line 368
    tmp = malloc((size_t )(len + 1));
#line 368
    s = (char *)tmp;
    }
#line 368
    if (! s) {
#line 368
      goto switch_break;
    }
  }
  {
#line 370
  ei_decode_string(termbuf, index___0, s);
#line 372
  tmp___0 = printable_list_p((uint8 const   *)((uint8 *)s), len);
  }
#line 372
  if (tmp___0) {
    {
#line 374
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\"%s\"",
            s);
    }
  } else {
    {
#line 377
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"[");
#line 378
    i = 0;
    }
    {
#line 378
    while (1) {
      while_continue: /* CIL Label */ ;
#line 378
      if (! (i < len)) {
#line 378
        goto while_break;
      }
#line 379
      if (i > 0) {
        {
#line 379
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)", ");
        }
      }
      {
#line 380
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d",
              (int )*(s + i));
#line 378
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 382
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"]");
    }
  }
#line 386
  if (s) {
#line 386
    if ((unsigned long )s != (unsigned long )(smallbuf)) {
      {
#line 386
      free((void *)s);
      }
    }
  }
#line 388
  goto switch_break;
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 394
  tmp___1 = ei_decode_long(termbuf, index___0, & num);
  }
#line 394
  if (tmp___1 == 0) {
    {
#line 395
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%ld",
            num);
    }
  } else {
    {
#line 397
    ei_decode_skip_bignum(termbuf, index___0, (void *)0);
#line 398
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Bignum");
    }
  }
#line 400
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 403
  ei_decode_double(termbuf, index___0, & fnum);
#line 404
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%f",
          fnum);
  }
#line 405
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 408
  ei_decode_pid(termbuf, index___0, & pid);
#line 409
  show_pid(stream, (erlang_pid const   *)(& pid));
  }
#line 410
  goto switch_break;
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  {
#line 414
  ei_decode_tuple_header(termbuf, index___0, & len);
#line 415
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"{");
#line 416
  i = 0;
  }
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 416
    if (! (i < len)) {
#line 416
      goto while_break___0;
    }
#line 417
    if (i > 0) {
      {
#line 417
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)", ");
      }
    }
    {
#line 418
    show_term(termbuf, index___0, stream);
#line 416
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 420
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"}");
  }
#line 421
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 424
  ei_decode_list_header(termbuf, index___0, & len);
#line 425
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"[");
#line 426
  i = 0;
  }
  {
#line 426
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 426
    if (! (i < len)) {
#line 426
      goto while_break___1;
    }
#line 427
    if (i > 0) {
      {
#line 427
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)", ");
      }
    }
    {
#line 428
    show_term(termbuf, index___0, stream);
#line 426
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 431
  ei_decode_list_header(termbuf, index___0, & len);
#line 432
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"]");
  }
#line 433
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 436
  ei_decode_list_header(termbuf, index___0, & len);
#line 437
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"[]");
  }
#line 438
  goto switch_break;
  case_114: /* CIL Label */ 
  case_101: /* CIL Label */ 
  {
#line 442
  ei_decode_ref(termbuf, index___0, & ref);
#line 443
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Ref<%s",
          ref.node);
#line 444
  i = 0;
  }
  {
#line 444
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 444
    if (! (i < ref.len)) {
#line 444
      goto while_break___2;
    }
    {
#line 445
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)".%u",
            ref.n[i]);
#line 444
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 447
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)".%u>",
          ref.creation);
  }
#line 448
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 451
  ei_decode_port(termbuf, index___0, & port);
#line 452
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Port<%s.%u.%u>",
          port.node, port.id, port.creation);
  }
#line 453
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 456
  ei_decode_binary(termbuf, index___0, (void *)0, & num);
#line 457
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Bin<%ld>",
          num);
  }
#line 458
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 463
  ei_decode_skip_bignum(termbuf, index___0, (void *)0);
#line 464
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Bignum");
  }
#line 465
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 471
  s___0 = termbuf + *index___0;
#line 471
  s0 = s___0;
#line 474
  s___0 ++;
#line 475
  s___0 += 4;
#line 475
  n_free = ((((int )*((unsigned char *)s___0 + -4) << 24) | ((int )*((unsigned char *)s___0 + -3) << 16)) | ((int )*((unsigned char *)s___0 + -2) << 8)) | (int )*((unsigned char *)s___0 + -1);
#line 476
  *index___0 = (int )((long )*index___0 + (s___0 - s0));
#line 477
  ei_decode_pid(termbuf, index___0, (erlang_pid *)((void *)0));
#line 478
  ei_decode_atom(termbuf, index___0, atom);
#line 479
  ei_decode_long(termbuf, index___0, & idx);
#line 480
  ei_decode_long(termbuf, index___0, & uniq);
#line 481
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Fun<%s.%ld.%ld>",
          atom, idx, uniq);
#line 482
  i = 0;
  }
  {
#line 482
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 482
    if (! (i < n_free)) {
#line 482
      goto while_break___3;
    }
    {
#line 484
    tmp___2 = ei_skip_term(termbuf, index___0);
    }
#line 484
    if (tmp___2 != 0) {
      {
#line 485
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<ERROR> show_msg: unknown type of term !");
      }
    }
#line 482
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 487
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 490
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Unknown<%d.%d>",
          type, len);
  }
#line 494
  return;
#line 495
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 497
  return;
}
}
#line 510 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static void show_pid(FILE *stream , erlang_pid const   *pid ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 512
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"#Pid<%s.%u.%u.%u>",
          pid->node, pid->num, pid->serial, pid->creation);
  }
#line 514
  return;
}
}
#line 516 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static void show_trace(FILE *stream , erlang_trace const   *t ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 518
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Trace: Label: %ld, Flags: 0x%lx serial: %ld, prev: %ld From: ",
          t->label, t->flags, t->serial, t->prev);
#line 521
  show_pid(stream, & t->from);
  }
#line 522
  return;
}
}
#line 542 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static int printable_list_p(uint8 const   *buf , int buflen ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
#line 546
  i = 0;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (i < buflen)) {
#line 546
      goto while_break;
    }
    {
#line 546
    tmp = __ctype_b_loc();
    }
#line 546
    if (! ((int const   )*(*tmp + (int )*(buf + i)) & 16384)) {
#line 546
      return (0);
    }
#line 546
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  return (1);
}
}
#line 564 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/show_msg.c"
static int ei_decode_skip_bignum(char const   *buf , int *index___0 , void *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  long n ;
  int volatile   *tmp ;

  {
#line 566
  s = buf + *index___0;
#line 567
  s0 = s;
#line 570
  s ++;
  {
#line 571
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 571
    goto case_111;
  }
#line 576
  goto switch_default;
  case_111: /* CIL Label */ 
#line 572
  s += 4;
#line 572
  n = (long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 573
  s += n + 1L;
#line 574
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 577
  tmp = __erl_errno_place();
#line 577
  *tmp = (int volatile   )5;
  }
#line 578
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 581
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 583
  return (0);
}
}
#line 401 "../include/ei.h"
int ei_encode_version(char *buf , int *index ) ;
#line 403
int ei_encode_long(char *buf , int *index , long p ) ;
#line 417
int ei_encode_atom(char *buf , int *index___0 , char const   *p ) ;
#line 423
int ei_encode_pid(char *buf , int *index___0 , erlang_pid const   *p ) ;
#line 433
int ei_encode_trace(char *buf , int *index , erlang_trace const   *p ) ;
#line 435
int ei_encode_tuple_header(char *buf , int *index , int arity ) ;
#line 754
int ei_send_reg_encoded(int fd , erlang_pid const   *from , char const   *to , char *msg ,
                        int msglen ) ;
#line 756
int ei_send_reg_encoded_tmo(int fd , erlang_pid const   *from , char const   *to ,
                            char *msg , int msglen , unsigned int ms ) ;
#line 106 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect_int.h"
int ei_distversion(int fd ) ;
#line 107
char const   *ei_getfdcookie(int fd ) ;
#line 24 "misc/ei_trace.h"
erlang_trace *ei_trace(int query , erlang_trace *token ) ;
#line 31 "misc/ei_portio.h"
int ei_writev_fill_t(int fd , struct iovec  const  *iov , int iovcnt , unsigned int ms ) ;
#line 46 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/send_reg.c"
int ei_send_reg_encoded_tmo(int fd , erlang_pid const   *from , char const   *to ,
                            char *msg , int msglen , unsigned int ms ) 
{ 
  char *s ;
  char header[1400] ;
  erlang_trace *token ;
  int index ;
  int res ;
  struct iovec v[2] ;
  int tmp ;
  char const   *tmp___0 ;
  int volatile   *tmp___1 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 51
  token = (erlang_trace *)((void *)0);
#line 52
  index = 5;
#line 61
  tmp = ei_distversion(fd);
  }
#line 61
  if (tmp > 0) {
    {
#line 62
    token = ei_trace(0, (erlang_trace *)((void *)0));
    }
  }
  {
#line 65
  ei_encode_version(header, & index);
  }
#line 66
  if (token) {
    {
#line 67
    ei_encode_tuple_header(header, & index, 5);
#line 68
    ei_encode_long(header, & index, 16L);
    }
  } else {
    {
#line 70
    ei_encode_tuple_header(header, & index, 4);
#line 71
    ei_encode_long(header, & index, 6L);
    }
  }
  {
#line 73
  ei_encode_pid(header, & index, from);
#line 74
  tmp___0 = ei_getfdcookie(fd);
#line 74
  ei_encode_atom(header, & index, tmp___0);
#line 75
  ei_encode_atom(header, & index, to);
  }
#line 77
  if (token) {
    {
#line 77
    ei_encode_trace(header, & index, (erlang_trace const   *)token);
    }
  }
#line 81
  s = header;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    *(s + 0) = (char )((((index + msglen) - 4) >> 24) & 255);
#line 82
    *(s + 1) = (char )((((index + msglen) - 4) >> 16) & 255);
#line 82
    *(s + 2) = (char )((((index + msglen) - 4) >> 8) & 255);
#line 82
    *(s + 3) = (char )(((index + msglen) - 4) & 255);
#line 82
    s += 4;
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    *(s + 0) = (char)112;
#line 83
    s ++;
#line 83
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 86
  if (ei_tracelevel > 0) {
    {
#line 87
    ei_show_sendmsg(stderr, (char const   *)(header), (char const   *)msg);
    }
  }
  {
#line 91
  v[0].iov_base = (void *)(header);
#line 92
  v[0].iov_len = (size_t )index;
#line 93
  v[1].iov_base = (void *)msg;
#line 94
  v[1].iov_len = (size_t )msglen;
#line 96
  res = ei_writev_fill_t(fd, (struct iovec  const  *)(v), 2, ms);
  }
#line 96
  if (res != index + msglen) {
    {
#line 97
    tmp___1 = __erl_errno_place();
    }
#line 97
    if (res == -2) {
#line 97
      *tmp___1 = (int volatile   )110;
    } else {
#line 97
      *tmp___1 = (int volatile   )5;
    }
#line 98
    return (-1);
  }
#line 113
  return (0);
}
}
#line 117 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/send_reg.c"
int ei_send_reg_encoded(int fd , erlang_pid const   *from , char const   *to , char *msg ,
                        int msglen ) 
{ 
  int tmp ;

  {
  {
#line 120
  tmp = ei_send_reg_encoded_tmo(fd, from, to, msg, msglen, 0U);
  }
#line 120
  return (tmp);
}
}
#line 413 "../include/ei.h"
int ei_encode_string(char *buf , int *index___0 , char const   *p ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/eisend.h"
int ei_send_exit(int fd , erlang_pid const   *from , erlang_pid const   *to , char const   *reason ) ;
#line 27
int ei_send_exit_tmo(int fd , erlang_pid const   *from , erlang_pid const   *to ,
                     char const   *reason , unsigned int ms ) ;
#line 29 "misc/ei_portio.h"
int ei_write_fill_t(int fd , char const   *buf , int len , unsigned int ms ) ;
#line 40 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/send_exit.c"
int ei_send_exit(int fd , erlang_pid const   *from , erlang_pid const   *to , char const   *reason ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = ei_send_exit_tmo(fd, from, to, reason, 0U);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/send_exit.c"
int ei_send_exit_tmo(int fd , erlang_pid const   *from , erlang_pid const   *to ,
                     char const   *reason , unsigned int ms ) 
{ 
  char sbuf[2048] ;
  erlang_trace *token ;
  char *dbuf ;
  char *msgbuf ;
  char *s ;
  int index___0 ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp16 ;

  {
  {
#line 51
  token = (erlang_trace *)((void *)0);
#line 52
  dbuf = (char *)((void *)0);
#line 55
  index___0 = 0;
#line 56
  tmp = strlen(reason);
#line 56
  len = (int )(tmp + 1080U);
  }
#line 58
  if (len > 2048) {
    {
#line 59
    tmp___0 = malloc((size_t )len);
#line 59
    dbuf = (char *)tmp___0;
    }
#line 59
    if (! dbuf) {
#line 60
      return (-1);
    }
  }
#line 61
  if (dbuf) {
#line 61
    msgbuf = dbuf;
  } else {
#line 61
    msgbuf = sbuf;
  }
  {
#line 66
  tmp___1 = ei_distversion(fd);
  }
#line 66
  if (tmp___1 > 0) {
    {
#line 66
    token = ei_trace(0, (erlang_trace *)((void *)0));
    }
  }
  {
#line 68
  index___0 = 5;
#line 69
  ei_encode_version(msgbuf, & index___0);
  }
#line 70
  if (token) {
    {
#line 71
    ei_encode_tuple_header(msgbuf, & index___0, 5);
#line 72
    ei_encode_long(msgbuf, & index___0, 13L);
    }
  } else {
    {
#line 75
    ei_encode_tuple_header(msgbuf, & index___0, 4);
#line 76
    ei_encode_long(msgbuf, & index___0, 3L);
    }
  }
  {
#line 78
  ei_encode_pid(msgbuf, & index___0, from);
#line 79
  ei_encode_pid(msgbuf, & index___0, to);
  }
#line 81
  if (token) {
    {
#line 81
    ei_encode_trace(msgbuf, & index___0, (erlang_trace const   *)token);
    }
  }
  {
#line 84
  ei_encode_string(msgbuf, & index___0, reason);
#line 87
  s = msgbuf;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    *(s + 0) = (char )(((index___0 - 4) >> 24) & 255);
#line 88
    *(s + 1) = (char )(((index___0 - 4) >> 16) & 255);
#line 88
    *(s + 2) = (char )(((index___0 - 4) >> 8) & 255);
#line 88
    *(s + 3) = (char )((index___0 - 4) & 255);
#line 88
    s += 4;
#line 88
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    *(s + 0) = (char)112;
#line 89
    s ++;
#line 89
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 92
  if (ei_tracelevel > 1) {
    {
#line 93
    ei_show_sendmsg(stderr, (char const   *)msgbuf, (char const   *)((void *)0));
    }
  }
  {
#line 95
  ei_write_fill_t(fd, (char const   *)msgbuf, index___0, ms);
  }
#line 98
  if (dbuf) {
    {
#line 98
    free((void *)dbuf);
    }
  }
#line 99
  return (0);
}
}
#line 751 "../include/ei.h"
int ei_send_encoded(int fd , erlang_pid const   *to , char *msg , int msglen ) ;
#line 752
int ei_send_encoded_tmo(int fd , erlang_pid const   *to , char *msg , int msglen ,
                        unsigned int ms ) ;
#line 54 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/send.c"
int ei_send_encoded_tmo(int fd , erlang_pid const   *to , char *msg , int msglen ,
                        unsigned int ms ) 
{ 
  char *s ;
  char header[1200] ;
  erlang_trace *token ;
  int index___0 ;
  int res ;
  struct iovec v[2] ;
  int tmp ;
  char const   *tmp___0 ;
  int volatile   *tmp___1 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 58
  token = (erlang_trace *)((void *)0);
#line 59
  index___0 = 5;
#line 67
  tmp = ei_distversion(fd);
  }
#line 67
  if (tmp > 0) {
    {
#line 67
    token = ei_trace(0, (erlang_trace *)((void *)0));
    }
  }
  {
#line 70
  ei_encode_version(header, & index___0);
  }
#line 71
  if (token) {
    {
#line 72
    ei_encode_tuple_header(header, & index___0, 4);
#line 73
    ei_encode_long(header, & index___0, 12L);
    }
  } else {
    {
#line 75
    ei_encode_tuple_header(header, & index___0, 3);
#line 76
    ei_encode_long(header, & index___0, 2L);
    }
  }
  {
#line 78
  tmp___0 = ei_getfdcookie(fd);
#line 78
  ei_encode_atom(header, & index___0, tmp___0);
#line 79
  ei_encode_pid(header, & index___0, to);
  }
#line 81
  if (token) {
    {
#line 81
    ei_encode_trace(header, & index___0, (erlang_trace const   *)token);
    }
  }
#line 85
  s = header;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    *(s + 0) = (char )((((index___0 + msglen) - 4) >> 24) & 255);
#line 86
    *(s + 1) = (char )((((index___0 + msglen) - 4) >> 16) & 255);
#line 86
    *(s + 2) = (char )((((index___0 + msglen) - 4) >> 8) & 255);
#line 86
    *(s + 3) = (char )(((index___0 + msglen) - 4) & 255);
#line 86
    s += 4;
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    *(s + 0) = (char)112;
#line 87
    s ++;
#line 87
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  if (ei_tracelevel > 0) {
    {
#line 92
    ei_show_sendmsg(stderr, (char const   *)(header), (char const   *)msg);
    }
  }
  {
#line 96
  v[0].iov_base = (void *)(header);
#line 97
  v[0].iov_len = (size_t )index___0;
#line 98
  v[1].iov_base = (void *)msg;
#line 99
  v[1].iov_len = (size_t )msglen;
#line 101
  res = ei_writev_fill_t(fd, (struct iovec  const  *)(v), 2, ms);
  }
#line 101
  if (res != index___0 + msglen) {
    {
#line 102
    tmp___1 = __erl_errno_place();
    }
#line 102
    if (res == -2) {
#line 102
      *tmp___1 = (int volatile   )110;
    } else {
#line 102
      *tmp___1 = (int volatile   )5;
    }
#line 103
    return (-1);
  }
#line 119
  return (0);
}
}
#line 122 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/send.c"
int ei_send_encoded(int fd , erlang_pid const   *to , char *msg , int msglen ) 
{ 
  int tmp ;

  {
  {
#line 124
  tmp = ei_send_encoded_tmo(fd, to, msg, msglen, 0U);
  }
#line 124
  return (tmp);
}
}
#line 678 "../include/ei.h"
int ei_reg_tabstat(ei_reg *reg , struct ei_reg_tabstat *obuf ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_tabstat.c"
int ei_reg_tabstat(ei_reg *reg , struct ei_reg_tabstat *obuf ) 
{ 
  ei_hash *tab___0 ;

  {
#line 28
  if (! reg) {
#line 28
    return (-1);
  } else
#line 28
  if (! obuf) {
#line 28
    return (-1);
  }
#line 29
  tab___0 = reg->tab;
#line 31
  obuf->npos = tab___0->npos;
#line 32
  obuf->size = tab___0->size;
#line 33
  obuf->nelem = tab___0->nelem;
#line 34
  obuf->collisions = tab___0->nelem - tab___0->npos;
#line 36
  return (0);
}
}
#line 675 "../include/ei.h"
int ei_reg_stat(ei_reg *reg , char const   *key , struct ei_reg_stat *obuf ) ;
#line 36 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
void *ei_hash_lookup(ei_hash *tab___0 , char const   *key ) ;
#line 27 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_stat.c"
int ei_reg_stat(ei_reg *reg , char const   *key , struct ei_reg_stat *obuf ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 32
  if (! key) {
#line 32
    return (-1);
  } else
#line 32
  if (! obuf) {
#line 32
    return (-1);
  } else
#line 32
  if (! reg) {
#line 32
    return (-1);
  }
  {
#line 33
  tab___0 = reg->tab;
#line 35
  tmp = ei_hash_lookup(tab___0, key);
#line 35
  obj = (ei_reg_obj *)tmp;
  }
#line 35
  if (! obj) {
#line 35
    return (-1);
  }
#line 37
  obuf->attr = obj->attr;
#line 38
  obuf->size = obj->size;
#line 40
  return (0);
}
}
#line 622 "../include/ei.h"
int ei_reg_setsval(ei_reg *reg , char const   *key , char const   *s ) ;
#line 39 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
void *ei_hash_insert(ei_hash *tab___0 , char const   *key , void const   *value ) ;
#line 42 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg.h"
ei_reg_obj *ei_reg_make(ei_reg *reg , int attr ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_sets.c"
int ei_reg_setsval(ei_reg *reg , char const   *key , char const   *s ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 28
  obj = (ei_reg_obj *)((void *)0);
#line 29
  len = 0;
#line 32
  if (! key) {
#line 32
    return (-1);
  } else
#line 32
  if (! reg) {
#line 32
    return (-1);
  }
#line 33
  tab___0 = reg->tab;
#line 34
  if (s) {
    {
#line 34
    tmp = strlen(s);
#line 34
    len = (int )(tmp + 1U);
    }
  }
  {
#line 36
  tmp___0 = ei_hash_lookup(tab___0, key);
#line 36
  obj = (ei_reg_obj *)tmp___0;
  }
#line 36
  if (obj) {
    {
#line 39
    if ((obj->attr & 248) == 16) {
#line 39
      goto case_16;
    }
#line 41
    if ((obj->attr & 248) == 32) {
#line 41
      goto case_32;
    }
#line 43
    if ((obj->attr & 248) == 64) {
#line 43
      goto case_64;
    }
#line 46
    if ((obj->attr & 248) == 128) {
#line 46
      goto case_128;
    }
#line 49
    goto switch_default;
    case_16: /* CIL Label */ 
#line 40
    goto switch_break;
    case_32: /* CIL Label */ 
#line 42
    goto switch_break;
    case_64: /* CIL Label */ 
#line 44
    if (obj->size > 0) {
      {
#line 44
      free((void *)obj->val.s);
      }
    }
#line 45
    goto switch_break;
    case_128: /* CIL Label */ 
#line 47
    if (obj->size > 0) {
      {
#line 47
      free(obj->val.p);
      }
    }
#line 48
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 50
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 56
    obj = ei_reg_make(reg, 64);
    }
#line 56
    if (! obj) {
#line 56
      return (-1);
    }
    {
#line 57
    ei_hash_insert(tab___0, key, (void const   *)obj);
    }
  }
#line 60
  obj->attr = 65;
#line 61
  obj->val.s = (char *)s;
#line 62
  obj->size = len;
#line 64
  return (0);
}
}
#line 623 "../include/ei.h"
int ei_reg_setpval(ei_reg *reg , char const   *key , void const   *p , int size ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_setp.c"
int ei_reg_setpval(ei_reg *reg , char const   *key , void const   *p , int size ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 27
  obj = (ei_reg_obj *)((void *)0);
#line 29
  if (size < 0) {
#line 29
    return (-1);
  }
#line 30
  if (! key) {
#line 30
    return (-1);
  } else
#line 30
  if (! reg) {
#line 30
    return (-1);
  }
  {
#line 31
  tab___0 = reg->tab;
#line 33
  tmp = ei_hash_lookup(tab___0, key);
#line 33
  obj = (ei_reg_obj *)tmp;
  }
#line 33
  if (obj) {
    {
#line 36
    if ((obj->attr & 248) == 16) {
#line 36
      goto case_16;
    }
#line 38
    if ((obj->attr & 248) == 32) {
#line 38
      goto case_32;
    }
#line 40
    if ((obj->attr & 248) == 64) {
#line 40
      goto case_64;
    }
#line 43
    if ((obj->attr & 248) == 128) {
#line 43
      goto case_128;
    }
#line 46
    goto switch_default;
    case_16: /* CIL Label */ 
#line 37
    goto switch_break;
    case_32: /* CIL Label */ 
#line 39
    goto switch_break;
    case_64: /* CIL Label */ 
#line 41
    if (obj->size > 0) {
      {
#line 41
      free((void *)obj->val.s);
      }
    }
#line 42
    goto switch_break;
    case_128: /* CIL Label */ 
#line 44
    if (obj->size > 0) {
      {
#line 44
      free(obj->val.p);
      }
    }
#line 45
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 47
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 53
    obj = ei_reg_make(reg, 128);
    }
#line 53
    if (! obj) {
#line 53
      return (-1);
    }
    {
#line 54
    ei_hash_insert(tab___0, key, (void const   *)obj);
    }
  }
#line 57
  obj->attr = 129;
#line 58
  obj->val.p = (void *)p;
#line 59
  obj->size = size;
#line 61
  return (0);
}
}
#line 620 "../include/ei.h"
int ei_reg_setival(ei_reg *reg , char const   *key , long i ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_seti.c"
int ei_reg_setival(ei_reg *reg , char const   *key , long i ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 28
  obj = (ei_reg_obj *)((void *)0);
#line 30
  if (! key) {
#line 30
    return (-1);
  } else
#line 30
  if (! reg) {
#line 30
    return (-1);
  }
  {
#line 31
  tab___0 = reg->tab;
#line 33
  tmp = ei_hash_lookup(tab___0, key);
#line 33
  obj = (ei_reg_obj *)tmp;
  }
#line 33
  if (obj) {
    {
#line 36
    if ((obj->attr & 248) == 16) {
#line 36
      goto case_16;
    }
#line 38
    if ((obj->attr & 248) == 32) {
#line 38
      goto case_32;
    }
#line 40
    if ((obj->attr & 248) == 64) {
#line 40
      goto case_64;
    }
#line 43
    if ((obj->attr & 248) == 128) {
#line 43
      goto case_128;
    }
#line 46
    goto switch_default;
    case_16: /* CIL Label */ 
#line 37
    goto switch_break;
    case_32: /* CIL Label */ 
#line 39
    goto switch_break;
    case_64: /* CIL Label */ 
#line 41
    if (obj->size > 0) {
      {
#line 41
      free((void *)obj->val.s);
      }
    }
#line 42
    goto switch_break;
    case_128: /* CIL Label */ 
#line 44
    if (obj->size > 0) {
      {
#line 44
      free(obj->val.p);
      }
    }
#line 45
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 47
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 53
    obj = ei_reg_make(reg, 16);
    }
#line 53
    if (! obj) {
#line 53
      return (-1);
    }
    {
#line 54
    ei_hash_insert(tab___0, key, (void const   *)obj);
    }
  }
#line 57
  obj->attr = 17;
#line 58
  obj->val.i = i;
#line 59
  obj->size = 0;
#line 61
  return (0);
}
}
#line 621 "../include/ei.h"
int ei_reg_setfval(ei_reg *reg , char const   *key , double f ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_setf.c"
int ei_reg_setfval(ei_reg *reg , char const   *key , double f ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 27
  obj = (ei_reg_obj *)((void *)0);
#line 29
  if (! key) {
#line 29
    return (-1);
  } else
#line 29
  if (! reg) {
#line 29
    return (-1);
  }
  {
#line 30
  tab___0 = reg->tab;
#line 32
  tmp = ei_hash_lookup(tab___0, key);
#line 32
  obj = (ei_reg_obj *)tmp;
  }
#line 32
  if (obj) {
    {
#line 35
    if ((obj->attr & 248) == 16) {
#line 35
      goto case_16;
    }
#line 37
    if ((obj->attr & 248) == 32) {
#line 37
      goto case_32;
    }
#line 39
    if ((obj->attr & 248) == 64) {
#line 39
      goto case_64;
    }
#line 42
    if ((obj->attr & 248) == 128) {
#line 42
      goto case_128;
    }
#line 45
    goto switch_default;
    case_16: /* CIL Label */ 
#line 36
    goto switch_break;
    case_32: /* CIL Label */ 
#line 38
    goto switch_break;
    case_64: /* CIL Label */ 
#line 40
    if (obj->size > 0) {
      {
#line 40
      free((void *)obj->val.s);
      }
    }
#line 41
    goto switch_break;
    case_128: /* CIL Label */ 
#line 43
    if (obj->size > 0) {
      {
#line 43
      free(obj->val.p);
      }
    }
#line 44
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 46
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 52
    obj = ei_reg_make(reg, 32);
    }
#line 52
    if (! obj) {
#line 52
      return (-1);
    }
    {
#line 53
    ei_hash_insert(tab___0, key, (void const   *)obj);
    }
  }
#line 56
  obj->attr = 33;
#line 57
  obj->val.f = f;
#line 58
  obj->size = 0;
#line 60
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 633 "../include/ei.h"
int ei_reg_setval(ei_reg *reg , char const   *key , int flags  , ...) ;
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_set.c"
int ei_reg_setval(ei_reg *reg , char const   *key , int flags  , ...) 
{ 
  va_list ap ;
  int rval ;
  long i ;
  long tmp ;
  double f ;
  double tmp___0 ;
  char *s ;
  char *tmp___1 ;
  void *p ;
  int len ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 31
  rval = 0;
#line 33
  if (! key) {
#line 33
    return (-1);
  } else
#line 33
  if (! reg) {
#line 33
    return (-1);
  }
  {
#line 35
  __builtin_va_start(ap, flags);
  }
  {
#line 38
  if ((flags & 248) == 16) {
#line 38
    goto case_16;
  }
#line 45
  if ((flags & 248) == 32) {
#line 45
    goto case_32;
  }
#line 52
  if ((flags & 248) == 64) {
#line 52
    goto case_64;
  }
#line 59
  if ((flags & 248) == 128) {
#line 59
    goto case_128;
  }
#line 69
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 41
  tmp = __builtin_va_arg(ap, long );
#line 41
  i = tmp;
#line 42
  rval = ei_reg_setival(reg, key, i);
  }
#line 43
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 48
  tmp___0 = __builtin_va_arg(ap, double );
#line 48
  f = tmp___0;
#line 49
  rval = ei_reg_setfval(reg, key, f);
  }
#line 50
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 55
  tmp___1 = __builtin_va_arg(ap, char *);
#line 55
  s = tmp___1;
#line 56
  rval = ei_reg_setsval(reg, key, (char const   *)s);
  }
#line 57
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 63
  tmp___2 = __builtin_va_arg(ap, void *);
#line 63
  p = tmp___2;
#line 64
  tmp___3 = __builtin_va_arg(ap, int );
#line 64
  len = tmp___3;
#line 65
  rval = ei_reg_setpval(reg, key, (void const   *)p, len);
  }
#line 66
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 70
  rval = -1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 75
  __builtin_va_end(ap);
  }
#line 76
  return (rval);
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 336 "../include/ei.h"
char const   *ei_thisnodename(ei_cnode const   *ec ) ;
#line 437
int ei_encode_list_header(char *buf , int *index , int arity ) ;
#line 686
int ei_reg_restore(int fd , ei_reg *reg , char const   *mntab ) ;
#line 38 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
int ei_hash_foreach(ei_hash *tab___0 , int (*f)(char const   *key , void const   *value ) ) ;
#line 23 "connect/eirecv.h"
int ei_recv_internal(int fd , char **mbufp , int *bufsz , erlang_msg *msg , int *msglenp ,
                     int staticbufp , unsigned int ms ) ;
#line 105 "connect/ei_connect_int.h"
ei_cnode *ei_fd_to_cnode(int fd ) ;
#line 108
short ei_thiscreation(ei_cnode const   *ec ) ;
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_restore.c"
static int mn_start_restore(int fd , erlang_pid const   *self , erlang_pid *mnesia ,
                            char const   *mntab , long *count , long *maxkey , long *maxobj ) 
{ 
  char buf[2048] ;
  char *bufp ;
  char tmpbuf[64] ;
  int index___0 ;
  erlang_msg msg ;
  int arity ;
  int version ;
  int i ;
  int needlink ;
  int needmsg ;
  int msglen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 33
  bufp = buf;
#line 35
  index___0 = 0;
#line 46
  ei_encode_version(buf, & index___0);
#line 47
  ei_encode_tuple_header(buf, & index___0, 2);
#line 48
  ei_encode_pid(buf, & index___0, self);
#line 49
  ei_encode_tuple_header(buf, & index___0, 5);
#line 50
  ei_encode_atom(buf, & index___0, "call");
#line 51
  ei_encode_atom(buf, & index___0, "mnesia_registry");
#line 52
  ei_encode_atom(buf, & index___0, "start_restore");
#line 53
  ei_encode_list_header(buf, & index___0, 2);
#line 54
  ei_encode_atom(buf, & index___0, mntab);
#line 55
  ei_encode_pid(buf, & index___0, self);
#line 56
  ei_encode_list_header(buf, & index___0, 0);
#line 57
  ei_encode_atom(buf, & index___0, "user");
#line 60
  tmp = ei_send_reg_encoded(fd, self, "rex", buf, index___0);
  }
#line 60
  if (tmp) {
#line 60
    return (-1);
  }
#line 63
  needmsg = 1;
#line 63
  needlink = needmsg;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! needlink) {
#line 64
      if (! needmsg) {
#line 64
        goto while_break;
      }
    }
#line 66
    index___0 = 2048;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 67
      i = ei_recv_internal(fd, & bufp, & index___0, & msg, & msglen, 1, 0U);
      }
#line 67
      if (i) {
#line 67
        goto while_break___0;
      }
#line 67
      index___0 = 2048;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 70
    if (i == 1) {
#line 70
      goto case_1;
    }
#line 76
    if (i == 2) {
#line 76
      goto case_2;
    }
#line 102
    goto switch_default;
    case_1: /* CIL Label */ 
#line 72
    if (! needlink) {
#line 72
      return (-1);
    }
#line 73
    needlink = 0;
#line 74
    goto switch_break;
    case_2: /* CIL Label */ 
#line 78
    if (! needmsg) {
#line 78
      return (-1);
    } else {
      {
#line 81
      index___0 = 0;
#line 82
      tmp___0 = ei_decode_version((char const   *)(buf), & index___0, & version);
      }
#line 82
      if (tmp___0) {
#line 95
        return (-1);
      } else {
        {
#line 82
        tmp___1 = ei_decode_tuple_header((char const   *)(buf), & index___0, & arity);
        }
#line 82
        if (tmp___1) {
#line 95
          return (-1);
        } else
#line 82
        if (arity != 2) {
#line 95
          return (-1);
        } else {
          {
#line 82
          tmp___2 = ei_decode_atom((char const   *)(buf), & index___0, tmpbuf);
          }
#line 82
          if (tmp___2) {
#line 95
            return (-1);
          } else {
            {
#line 82
            tmp___3 = strcmp((char const   *)(tmpbuf), "rex");
            }
#line 82
            if (tmp___3) {
#line 95
              return (-1);
            } else {
              {
#line 82
              tmp___4 = ei_decode_tuple_header((char const   *)(buf), & index___0,
                                               & arity);
              }
#line 82
              if (tmp___4) {
#line 95
                return (-1);
              } else
#line 82
              if (arity != 5) {
#line 95
                return (-1);
              } else {
                {
#line 82
                tmp___5 = ei_decode_atom((char const   *)(buf), & index___0, tmpbuf);
                }
#line 82
                if (tmp___5) {
#line 95
                  return (-1);
                } else {
                  {
#line 82
                  tmp___6 = strcmp((char const   *)(tmpbuf), "size");
                  }
#line 82
                  if (tmp___6) {
#line 95
                    return (-1);
                  } else {
                    {
#line 82
                    tmp___7 = ei_decode_pid((char const   *)(buf), & index___0, mnesia);
                    }
#line 82
                    if (tmp___7) {
#line 95
                      return (-1);
                    } else {
                      {
#line 82
                      tmp___8 = ei_decode_long((char const   *)(buf), & index___0,
                                               count);
                      }
#line 82
                      if (tmp___8) {
#line 95
                        return (-1);
                      } else {
                        {
#line 82
                        tmp___9 = ei_decode_long((char const   *)(buf), & index___0,
                                                 maxkey);
                        }
#line 82
                        if (tmp___9) {
#line 95
                          return (-1);
                        } else {
                          {
#line 82
                          tmp___10 = ei_decode_long((char const   *)(buf), & index___0,
                                                    maxobj);
                          }
#line 82
                          if (tmp___10) {
#line 95
                            return (-1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 98
      needmsg = 0;
    }
#line 100
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 103
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (0);
}
}
#line 109 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_restore.c"
static int mn_unlink(int fd ) 
{ 
  erlang_msg msg ;
  char buf[2048] ;
  char *bufp ;
  int index___0 ;
  int msglen ;
  int tmp ;
  void *__cil_tmp8 ;

  {
#line 113
  bufp = buf;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    index___0 = 2048;
#line 120
    tmp = ei_recv_internal(fd, & bufp, & index___0, & msg, & msglen, 1, 0U);
    }
    {
#line 121
    if (tmp == 0) {
#line 121
      goto case_0;
    }
#line 122
    if (tmp == 4) {
#line 122
      goto case_4;
    }
#line 123
    goto switch_default;
    case_0: /* CIL Label */ 
#line 121
    goto while_continue;
    case_4: /* CIL Label */ 
#line 122
    return (0);
    switch_default: /* CIL Label */ 
#line 123
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_restore.c"
static int mn_decode_insert(ei_reg *reg , char const   *msgbuf , int *index___0 ,
                            char *key ) 
{ 
  long keylen ;
  long objlen ;
  long objtype ;
  void *objbuf ;
  long i ;
  double f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 135
  objbuf = (void *)0;
#line 139
  tmp = ei_decode_long(msgbuf, index___0, & keylen);
  }
#line 139
  if (tmp) {
#line 142
    return (-1);
  } else {
    {
#line 139
    tmp___0 = ei_decode_long(msgbuf, index___0, & objlen);
    }
#line 139
    if (tmp___0) {
#line 142
      return (-1);
    } else {
      {
#line 139
      tmp___1 = ei_decode_long(msgbuf, index___0, & objtype);
      }
#line 139
      if (tmp___1) {
#line 142
        return (-1);
      }
    }
  }
  {
#line 146
  tmp___2 = ei_decode_string(msgbuf, index___0, key);
  }
#line 146
  if (tmp___2) {
#line 147
    if (objbuf) {
      {
#line 147
      free(objbuf);
      }
    }
#line 148
    return (-1);
  }
  {
#line 156
  if (((int )objtype & 248) == 16) {
#line 156
    goto case_16;
  }
#line 161
  if (((int )objtype & 248) == 32) {
#line 161
    goto case_32;
  }
#line 166
  if (((int )objtype & 248) == 64) {
#line 166
    goto case_64;
  }
#line 183
  if (((int )objtype & 248) == 128) {
#line 183
    goto case_128;
  }
#line 201
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 157
  tmp___3 = ei_decode_long(msgbuf, index___0, & i);
  }
#line 157
  if (tmp___3) {
#line 157
    return (-1);
  }
  {
#line 158
  ei_reg_setival(reg, (char const   *)key, i);
  }
#line 159
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 162
  tmp___4 = ei_decode_double(msgbuf, index___0, & f);
  }
#line 162
  if (tmp___4) {
#line 162
    return (-1);
  }
  {
#line 163
  ei_reg_setfval(reg, (char const   *)key, f);
  }
#line 164
  goto switch_break;
  case_64: /* CIL Label */ 
#line 167
  objbuf = (void *)0;
#line 168
  if (objlen > 0L) {
    {
#line 169
    objbuf = malloc((size_t )objlen);
    }
#line 169
    if (! objbuf) {
#line 169
      return (-1);
    }
    {
#line 170
    tmp___5 = ei_decode_string(msgbuf, index___0, (char *)objbuf);
    }
#line 170
    if (tmp___5) {
      {
#line 171
      free(objbuf);
      }
#line 172
      return (-1);
    }
    {
#line 174
    ei_reg_setsval(reg, (char const   *)key, (char const   *)objbuf);
    }
  } else {
    {
#line 178
    tmp___6 = ei_decode_long(msgbuf, index___0, & i);
    }
#line 178
    if (tmp___6) {
#line 178
      return (-1);
    }
    {
#line 179
    ei_reg_setsval(reg, (char const   *)key, (char const   *)((void *)0));
    }
  }
#line 181
  goto switch_break;
  case_128: /* CIL Label */ 
#line 184
  objbuf = (void *)0;
#line 185
  if (objlen > 0L) {
    {
#line 186
    objbuf = malloc((size_t )objlen);
    }
#line 186
    if (! objbuf) {
#line 186
      return (-1);
    }
    {
#line 187
    tmp___7 = ei_decode_binary(msgbuf, index___0, objbuf, & i);
    }
#line 187
    if (tmp___7) {
      {
#line 188
      free(objbuf);
      }
#line 189
      return (-1);
    }
    {
#line 192
    ei_reg_setpval(reg, (char const   *)key, (void const   *)objbuf, (int )objlen);
    }
  } else {
    {
#line 196
    tmp___8 = ei_decode_long(msgbuf, index___0, & i);
    }
#line 196
    if (tmp___8) {
#line 196
      return (-1);
    }
    {
#line 197
    ei_reg_setpval(reg, (char const   *)key, (void const   *)((void *)i), 0);
    }
  }
#line 199
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 203
  if (objbuf) {
    {
#line 203
    free(objbuf);
    }
  }
#line 204
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 207
  return (0);
}
}
#line 212 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_restore.c"
static int clean_obj(char const   *key , void const   *p ) 
{ 
  ei_reg_obj *obj ;

  {
#line 214
  obj = (ei_reg_obj *)p;
#line 216
  if (obj) {
#line 216
    obj->attr &= -2;
  }
#line 218
  return (0);
}
}
#line 221 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_restore.c"
int ei_reg_restore(int fd , ei_reg *reg , char const   *mntab ) 
{ 
  int i ;
  int j ;
  char tag[32] ;
  char sbuf[2048] ;
  char *dbuf ;
  char *msgbuf ;
  char *keybuf ;
  erlang_pid self ;
  erlang_pid mnesia ;
  unsigned int tmp ;
  erlang_msg msg ;
  int index___0 ;
  int len ;
  int msglen ;
  int version ;
  int arity ;
  long count ;
  long maxkey ;
  long maxobj ;
  ei_cnode *ec ;
  char const   *tmp___0 ;
  short tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 226
  dbuf = (char *)((void *)0);
#line 227
  msgbuf = (char *)((void *)0);
#line 228
  keybuf = (char *)((void *)0);
#line 230
  mnesia.node[0] = (char )'\000';
#line 230
  tmp = 1U;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (tmp >= 256U) {
#line 230
      goto while_break;
    }
#line 230
    mnesia.node[tmp] = (char)0;
#line 230
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  mnesia.num = 0U;
#line 230
  mnesia.serial = 0U;
#line 230
  mnesia.creation = 0U;
#line 232
  index___0 = 0;
#line 233
  len = 0;
#line 235
  version = 0;
#line 236
  arity = 0;
#line 237
  count = 0L;
#line 238
  maxkey = 0L;
#line 239
  maxobj = 0L;
#line 242
  if (! reg) {
#line 242
    return (-1);
  } else
#line 242
  if (! mntab) {
#line 242
    return (-1);
  }
  {
#line 246
  ec = ei_fd_to_cnode(fd);
  }
#line 246
  if ((unsigned long )ec == (unsigned long )((void *)0)) {
#line 247
    return (-1);
  }
  {
#line 249
  tmp___0 = ei_thisnodename((ei_cnode const   *)ec);
#line 249
  strcpy((char */* __restrict  */)(self.node), (char const   */* __restrict  */)tmp___0);
#line 250
  self.num = (unsigned int )fd;
#line 251
  self.serial = 0U;
#line 252
  tmp___1 = ei_thiscreation((ei_cnode const   *)ec);
#line 252
  self.creation = (unsigned int )tmp___1;
#line 255
  tmp___2 = mn_start_restore(fd, (erlang_pid const   *)(& self), & mnesia, mntab,
                             & count, & maxkey, & maxobj);
  }
#line 255
  if (tmp___2) {
#line 257
    if (mnesia.node[0]) {
      {
#line 257
      ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
                   "bad response from rpc start");
      }
    }
#line 258
    return (-1);
  }
#line 261
  if (count <= 0L) {
    {
#line 262
    ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
                 "nothing to do");
    }
#line 263
    return (0);
  }
#line 267
  len = (int )((maxkey + maxobj) + 512L);
#line 268
  if (len > 2048) {
    {
#line 269
    tmp___3 = malloc((size_t )index___0);
#line 269
    dbuf = (char *)tmp___3;
    }
#line 269
    if (! dbuf) {
      {
#line 270
      ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
                   "cannot allocate space for incoming data");
      }
#line 271
      return (-1);
    }
  }
#line 273
  if (dbuf) {
#line 273
    msgbuf = dbuf;
  } else {
#line 273
    msgbuf = sbuf;
  }
  {
#line 276
  tmp___4 = malloc((size_t )(maxkey + 1L));
#line 276
  keybuf = (char *)tmp___4;
  }
#line 276
  if (! keybuf) {
#line 276
    goto restore_failure;
  }
  {
#line 279
  index___0 = 0;
#line 280
  ei_encode_version(msgbuf, & index___0);
#line 281
  ei_encode_tuple_header(msgbuf, & index___0, 2);
#line 282
  ei_encode_atom(msgbuf, & index___0, "send_records");
#line 283
  ei_encode_pid(msgbuf, & index___0, (erlang_pid const   *)(& self));
#line 284
  tmp___5 = ei_send_encoded(fd, (erlang_pid const   *)(& mnesia), msgbuf, index___0);
  }
#line 284
  if (tmp___5) {
#line 284
    goto restore_failure;
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if (! ((long )i < count)) {
#line 287
      goto while_break___0;
    }
#line 288
    index___0 = len;
    {
#line 289
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 289
      j = ei_recv_internal(fd, & msgbuf, & index___0, & msg, & msglen, 1, 0U);
      }
#line 289
      if (! (j == 0)) {
#line 289
        goto while_break___1;
      }
#line 289
      index___0 = len;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 290
    if (j < 0) {
#line 290
      goto restore_failure;
    }
#line 293
    index___0 = 0;
#line 294
    if (msg.msgtype != 2L) {
#line 300
      goto restore_failure;
    } else {
      {
#line 294
      tmp___6 = ei_decode_version((char const   *)msgbuf, & index___0, & version);
      }
#line 294
      if (tmp___6) {
#line 300
        goto restore_failure;
      } else {
        {
#line 294
        tmp___7 = ei_decode_tuple_header((char const   *)msgbuf, & index___0, & arity);
        }
#line 294
        if (tmp___7) {
#line 300
          goto restore_failure;
        } else
#line 294
        if (arity != 6) {
#line 300
          goto restore_failure;
        } else {
          {
#line 294
          tmp___8 = ei_decode_atom((char const   *)msgbuf, & index___0, tag);
          }
#line 294
          if (tmp___8) {
#line 300
            goto restore_failure;
          } else {
            {
#line 294
            tmp___9 = strcmp((char const   *)(tag), "restore");
            }
#line 294
            if (tmp___9) {
#line 300
              goto restore_failure;
            }
          }
        }
      }
    }
    {
#line 303
    tmp___10 = mn_decode_insert(reg, (char const   *)msgbuf, & index___0, keybuf);
    }
#line 303
    if (tmp___10) {
#line 303
      goto restore_failure;
    }
#line 287
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 307
  tmp___11 = mn_unlink(fd);
  }
#line 307
  if (tmp___11) {
#line 307
    return (-1);
  }
  {
#line 310
  ei_hash_foreach(reg->tab, & clean_obj);
  }
#line 313
  if (keybuf) {
    {
#line 313
    free((void *)keybuf);
    }
  }
#line 314
  if (dbuf) {
    {
#line 314
    free((void *)dbuf);
    }
  }
#line 315
  return (0);
  restore_failure: 
  {
#line 318
  ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
               "restore failure");
  }
#line 319
  if (keybuf) {
    {
#line 319
    free((void *)keybuf);
    }
  }
#line 320
  if (dbuf) {
    {
#line 320
    free((void *)dbuf);
    }
  }
#line 321
  return (-1);
}
}
#line 602 "../include/ei.h"
int ei_reg_resize(ei_reg *reg , int newsize ) ;
#line 42 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
ei_hash *ei_hash_resize(ei_hash *oldtab , int newsize ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_resize.c"
int ei_reg_resize(ei_reg *reg , int newsize ) 
{ 
  ei_hash *newtab ;

  {
#line 26
  newtab = (ei_hash *)((void *)0);
#line 28
  if (! reg) {
#line 28
    return (-1);
  }
#line 29
  if (newsize <= 0) {
#line 29
    return (-1);
  }
  {
#line 31
  newtab = ei_hash_resize(reg->tab, newsize);
  }
#line 31
  if (newtab) {
#line 32
    reg->tab = newtab;
  }
#line 35
  return ((reg->tab)->size);
}
}
#line 687 "../include/ei.h"
int ei_reg_purge(ei_reg *reg ) ;
#line 45 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
void ei_hash_bfree(ei_hash *tab___0 , ei_bucket *b ) ;
#line 44 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg.h"
void ei_reg_free(ei_reg *reg , ei_reg_obj *obj ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_purge.c"
static ei_bucket *do_purge(ei_reg *reg , int i ) 
{ 
  ei_hash *tab___0 ;
  ei_bucket *head ;
  ei_bucket *this ;
  ei_bucket *next ;
  ei_reg_obj *obj ;

  {
#line 26
  tab___0 = reg->tab;
#line 27
  head = *(tab___0->tab + i);
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    this = head;
#line 32
    if (! this) {
#line 32
      goto while_break;
    }
#line 33
    obj = (ei_reg_obj *)this->value;
#line 34
    if (obj->attr & 2) {
      {
#line 35
      head = this->next;
#line 36
      ei_reg_free(reg, obj);
#line 37
      ei_hash_bfree(tab___0, this);
#line 38
      (tab___0->nelem) --;
      }
    } else {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  this = head;
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 45
    if (this) {
#line 45
      if (! this->next) {
#line 45
        goto while_break___0;
      }
    } else {
#line 45
      goto while_break___0;
    }
#line 46
    next = this->next;
#line 47
    obj = (ei_reg_obj *)next->value;
#line 48
    if (obj->attr & 2) {
      {
#line 49
      this->next = next->next;
#line 50
      ei_reg_free(reg, obj);
#line 51
      ei_hash_bfree(tab___0, next);
#line 52
      (tab___0->nelem) --;
      }
    } else {
#line 54
      this = this->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 57
  return (head);
}
}
#line 60 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_purge.c"
int ei_reg_purge(ei_reg *reg ) 
{ 
  ei_hash *tab___0 ;
  int i ;

  {
#line 65
  if (! reg) {
#line 65
    return (-1);
  }
#line 66
  tab___0 = reg->tab;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < tab___0->size)) {
#line 68
      goto while_break;
    }
#line 69
    if (*(tab___0->tab + i)) {
      {
#line 70
      *(tab___0->tab + i) = do_purge(reg, i);
      }
#line 71
      if (! *(tab___0->tab + i)) {
#line 71
        (tab___0->npos) --;
      }
    }
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (0);
}
}
#line 601 "../include/ei.h"
ei_reg *ei_reg_open(int size ) ;
#line 41 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
ei_hash *ei_hash_newtab(int tabsize ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_open.c"
ei_reg *ei_reg_open(int size ) 
{ 
  ei_reg *new ;
  void *tmp ;
  ei_hash *tmp___0 ;

  {
#line 29
  if (size <= 0) {
#line 29
    return ((ei_reg *)((void *)0));
  }
  {
#line 31
  tmp = malloc((size_t )sizeof(*new));
#line 31
  new = (ei_reg *)tmp;
  }
#line 31
  if (! new) {
#line 31
    return ((ei_reg *)((void *)0));
  }
  {
#line 33
  new->freelist = (ei_reg_obj *)((void *)0);
#line 35
  tmp___0 = ei_hash_newtab(size);
#line 35
  new->tab = tmp___0;
  }
#line 35
  if (! tmp___0) {
    {
#line 36
    free((void *)new);
    }
#line 37
    return ((ei_reg *)((void *)0));
  }
#line 40
  return (new);
}
}
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_make.c"
ei_reg_obj *ei_reg_make(ei_reg *reg , int attr ) 
{ 
  ei_reg_obj *new ;
  void *tmp ;

  {
#line 31
  new = (ei_reg_obj *)((void *)0);
#line 33
  if (reg->freelist) {
#line 34
    new = reg->freelist;
#line 35
    reg->freelist = new->next;
  } else {
    {
#line 39
    tmp = malloc((size_t )sizeof(*new));
#line 39
    new = (ei_reg_obj *)tmp;
    }
  }
#line 43
  if (new) {
#line 44
    new->attr = attr | 1;
#line 45
    new->size = 0;
#line 46
    new->next = (struct ei_reg_inode *)((void *)0);
  }
#line 48
  return (new);
}
}
#line 641 "../include/ei.h"
char const   *ei_reg_getsval(ei_reg *reg , char const   *key ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_gets.c"
char const   *ei_reg_getsval(ei_reg *reg , char const   *key ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 27
  obj = (ei_reg_obj *)((void *)0);
#line 29
  if (! key) {
#line 29
    return ((char const   *)((void *)0));
  } else
#line 29
  if (! reg) {
#line 29
    return ((char const   *)((void *)0));
  }
  {
#line 30
  tab___0 = reg->tab;
#line 32
  tmp = ei_hash_lookup(tab___0, key);
#line 32
  obj = (ei_reg_obj *)tmp;
  }
#line 32
  if (obj) {
#line 32
    if (obj->attr & 2) {
#line 35
      return ((char const   *)((void *)0));
    } else
#line 32
    if ((obj->attr & 248) != 64) {
#line 35
      return ((char const   *)((void *)0));
    }
  } else {
#line 35
    return ((char const   *)((void *)0));
  }
#line 37
  return ((char const   *)obj->val.s);
}
}
#line 642 "../include/ei.h"
void const   *ei_reg_getpval(ei_reg *reg , char const   *key , int *size ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_getp.c"
void const   *ei_reg_getpval(ei_reg *reg , char const   *key , int *size ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 29
  if (! key) {
#line 29
    return ((void const   *)((void *)0));
  } else
#line 29
  if (! reg) {
#line 29
    return ((void const   *)((void *)0));
  }
  {
#line 30
  tab___0 = reg->tab;
#line 32
  tmp = ei_hash_lookup(tab___0, key);
#line 32
  obj = (ei_reg_obj *)tmp;
  }
#line 32
  if (obj) {
#line 32
    if (obj->attr & 2) {
#line 35
      return ((void const   *)((void *)0));
    } else
#line 32
    if ((obj->attr & 248) != 128) {
#line 35
      return ((void const   *)((void *)0));
    }
  } else {
#line 35
    return ((void const   *)((void *)0));
  }
#line 37
  if (size) {
#line 37
    *size = obj->size;
  }
#line 38
  return ((void const   *)obj->val.p);
}
}
#line 639 "../include/ei.h"
long ei_reg_getival(ei_reg *reg , char const   *key ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_geti.c"
long ei_reg_getival(ei_reg *reg , char const   *key ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 26
  obj = (ei_reg_obj *)((void *)0);
#line 28
  if (! key) {
#line 28
    return (-1L);
  } else
#line 28
  if (! reg) {
#line 28
    return (-1L);
  }
  {
#line 29
  tab___0 = reg->tab;
#line 30
  tmp = ei_hash_lookup(tab___0, key);
#line 30
  obj = (ei_reg_obj *)tmp;
  }
#line 30
  if (! obj) {
#line 30
    return (-1L);
  }
#line 31
  if (obj->attr & 2) {
#line 31
    return (-1L);
  }
#line 32
  if ((obj->attr & 248) != 16) {
#line 32
    return (-1L);
  }
#line 34
  return (obj->val.i);
}
}
#line 640 "../include/ei.h"
double ei_reg_getfval(ei_reg *reg , char const   *key ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_getf.c"
double ei_reg_getfval(ei_reg *reg , char const   *key ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 26
  obj = (ei_reg_obj *)((void *)0);
#line 28
  if (! key) {
#line 28
    return ((double )-1);
  } else
#line 28
  if (! reg) {
#line 28
    return ((double )-1);
  }
  {
#line 29
  tab___0 = reg->tab;
#line 30
  tmp = ei_hash_lookup(tab___0, key);
#line 30
  obj = (ei_reg_obj *)tmp;
  }
#line 30
  if (! obj) {
#line 30
    return ((double )-1);
  }
#line 31
  if (obj->attr & 2) {
#line 31
    return ((double )-1);
  }
#line 32
  if ((obj->attr & 248) != 32) {
#line 32
    return ((double )-1);
  }
#line 34
  return (obj->val.f);
}
}
#line 658 "../include/ei.h"
int ei_reg_getval(ei_reg *reg , char const   *key , int flags  , ...) ;
#line 35 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_get.c"
int ei_reg_getval(ei_reg *reg , char const   *key , int flags  , ...) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  va_list ap ;
  int rval ;
  int objtype ;
  void *tmp ;
  long *ip ;
  long *tmp___0 ;
  double *fp ;
  double *tmp___1 ;
  char **sp ;
  char **tmp___2 ;
  void **pp ;
  int *size ;
  void **tmp___3 ;
  int *tmp___4 ;

  {
#line 38
  obj = (ei_reg_obj *)((void *)0);
#line 43
  if (! key) {
#line 43
    return (-1);
  } else
#line 43
  if (! reg) {
#line 43
    return (-1);
  }
  {
#line 44
  tab___0 = reg->tab;
#line 45
  tmp = ei_hash_lookup(tab___0, key);
#line 45
  obj = (ei_reg_obj *)tmp;
  }
#line 45
  if (! obj) {
#line 45
    return (-1);
  }
#line 46
  if (obj->attr & 2) {
#line 46
    return (-1);
  }
#line 49
  objtype = obj->attr & 248;
#line 50
  if (flags) {
#line 50
    if (flags != objtype) {
#line 50
      return (-1);
    }
  }
  {
#line 52
  __builtin_va_start(ap, flags);
#line 54
  rval = objtype;
  }
  {
#line 55
  if (rval == 16) {
#line 55
    goto case_16;
  }
#line 62
  if (rval == 32) {
#line 62
    goto case_32;
  }
#line 69
  if (rval == 64) {
#line 69
    goto case_64;
  }
#line 76
  if (rval == 128) {
#line 76
    goto case_128;
  }
#line 85
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 58
  tmp___0 = __builtin_va_arg(ap, long *);
#line 58
  ip = tmp___0;
  }
#line 58
  if (ip) {
#line 59
    *ip = obj->val.i;
  } else {
#line 58
    rval = -1;
  }
#line 60
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 65
  tmp___1 = __builtin_va_arg(ap, double *);
#line 65
  fp = tmp___1;
  }
#line 65
  if (fp) {
#line 66
    *fp = obj->val.f;
  } else {
#line 65
    rval = -1;
  }
#line 67
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 72
  tmp___2 = __builtin_va_arg(ap, char **);
#line 72
  sp = tmp___2;
  }
#line 72
  if (sp) {
#line 73
    *sp = obj->val.s;
  } else {
#line 72
    rval = -1;
  }
#line 74
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 80
  tmp___3 = __builtin_va_arg(ap, void **);
#line 80
  pp = tmp___3;
  }
#line 80
  if (pp) {
#line 81
    *pp = obj->val.p;
  } else {
#line 80
    rval = -1;
  }
  {
#line 82
  tmp___4 = __builtin_va_arg(ap, int *);
#line 82
  size = tmp___4;
  }
#line 82
  if (size) {
#line 82
    *size = obj->size;
  }
#line 83
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 87
  rval = -1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 92
  __builtin_va_end(ap);
  }
#line 93
  return (rval);
}
}
#line 27 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_free.c"
void ei_reg_free(ei_reg *reg , ei_reg_obj *obj ) 
{ 


  {
  {
#line 31
  if ((obj->attr & 248) == 64) {
#line 31
    goto case_64;
  }
#line 35
  if ((obj->attr & 248) == 128) {
#line 35
    goto case_128;
  }
#line 30
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 32
  free((void *)obj->val.s);
  }
#line 33
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 36
  free(obj->val.p);
  }
#line 37
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 43
  obj->next = reg->freelist;
#line 44
  reg->freelist = obj;
#line 46
  return;
}
}
#line 407 "../include/ei.h"
int ei_encode_double(char *buf , int *index___0 , double p ) ;
#line 421
int ei_encode_binary(char *buf , int *index___0 , void const   *p , long len ) ;
#line 685
int ei_reg_dump(int fd , ei_reg *reg , char const   *mntab , int flags ) ;
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dump.c"
static int mn_start_dump(int fd , erlang_pid const   *self , erlang_pid *mnesia ,
                         char const   *mntab ) 
{ 
  char buf[2048] ;
  char *bufp ;
  char tmpbuf[64] ;
  int index___0 ;
  erlang_msg msg ;
  int type ;
  int arity ;
  int version ;
  int msglen ;
  int i ;
  int needlink ;
  int needpid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 34
  bufp = buf;
#line 36
  index___0 = 0;
#line 48
  ei_encode_version(buf, & index___0);
#line 49
  ei_encode_tuple_header(buf, & index___0, 2);
#line 50
  ei_encode_pid(buf, & index___0, self);
#line 51
  ei_encode_tuple_header(buf, & index___0, 5);
#line 52
  ei_encode_atom(buf, & index___0, "call");
#line 53
  ei_encode_atom(buf, & index___0, "mnesia_registry");
#line 54
  ei_encode_atom(buf, & index___0, "start_dump");
#line 55
  ei_encode_list_header(buf, & index___0, 2);
#line 56
  ei_encode_atom(buf, & index___0, mntab);
#line 57
  ei_encode_pid(buf, & index___0, self);
#line 58
  ei_encode_list_header(buf, & index___0, 0);
#line 59
  ei_encode_atom(buf, & index___0, "user");
#line 62
  tmp = ei_send_reg_encoded(fd, self, "rex", buf, index___0);
  }
#line 62
  if (tmp) {
#line 62
    return (-1);
  }
#line 65
  needpid = 1;
#line 65
  needlink = needpid;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! needlink) {
#line 66
      if (! needpid) {
#line 66
        goto while_break;
      }
    }
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 69
      index___0 = 2048;
#line 70
      i = ei_recv_internal(fd, & bufp, & index___0, & msg, & msglen, 1, 0U);
      }
#line 70
      if (i) {
#line 71
        goto while_break___0;
      } else {
#line 70
        goto while_continue___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 75
    if (i == 1) {
#line 75
      goto case_1;
    }
#line 81
    if (i == 2) {
#line 81
      goto case_2;
    }
#line 103
    goto switch_default;
    case_1: /* CIL Label */ 
#line 77
    if (! needlink) {
#line 77
      return (-1);
    }
#line 78
    needlink = 0;
#line 79
    goto switch_break;
    case_2: /* CIL Label */ 
#line 83
    if (! needpid) {
#line 83
      return (-1);
    } else {
      {
#line 86
      index___0 = 0;
#line 87
      tmp___0 = ei_decode_version((char const   *)(buf), & index___0, & version);
      }
#line 87
      if (tmp___0) {
#line 94
        return (-1);
      } else {
        {
#line 87
        tmp___1 = ei_decode_tuple_header((char const   *)(buf), & index___0, & arity);
        }
#line 87
        if (tmp___1) {
#line 94
          return (-1);
        } else
#line 87
        if (arity != 2) {
#line 94
          return (-1);
        } else {
          {
#line 87
          tmp___2 = ei_decode_atom((char const   *)(buf), & index___0, tmpbuf);
          }
#line 87
          if (tmp___2) {
#line 94
            return (-1);
          } else {
            {
#line 87
            tmp___3 = strcmp((char const   *)(tmpbuf), "rex");
            }
#line 87
            if (tmp___3) {
#line 94
              return (-1);
            } else {
              {
#line 87
              tmp___4 = ei_get_type_internal((char const   *)(buf), (int const   *)(& index___0),
                                             & type, & arity);
              }
#line 87
              if (tmp___4) {
#line 94
                return (-1);
              } else
#line 87
              if (type != 103) {
#line 94
                return (-1);
              }
            }
          }
        }
      }
      {
#line 96
      tmp___5 = ei_decode_pid((char const   *)(buf), & index___0, mnesia);
      }
#line 96
      if (tmp___5) {
#line 96
        return (-1);
      }
#line 99
      needpid = 0;
    }
#line 101
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 104
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (0);
}
}
#line 110 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dump.c"
static int mn_send_commit(int fd , erlang_pid *mnesia , erlang_pid *self ) 
{ 
  char buf[2048] ;
  char *bufp ;
  char string[256] ;
  int index___0 ;
  int version ;
  int arity ;
  int msglen ;
  erlang_msg msg ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 113
  bufp = buf;
#line 115
  index___0 = 0;
#line 122
  ei_encode_version(buf, & index___0);
#line 123
  ei_encode_tuple_header(buf, & index___0, 2);
#line 124
  ei_encode_atom(buf, & index___0, "commit");
#line 125
  ei_encode_pid(buf, & index___0, (erlang_pid const   *)self);
#line 128
  tmp = ei_send_encoded(fd, (erlang_pid const   *)mnesia, buf, index___0);
  }
#line 128
  if (tmp) {
#line 128
    return (-1);
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    index___0 = 2048;
#line 133
    i = ei_recv_internal(fd, & bufp, & index___0, & msg, & msglen, 1, 0U);
    }
#line 133
    if (i) {
#line 134
      if (i < 0) {
#line 134
        return (-1);
      } else {
#line 135
        goto while_break;
      }
    } else {
#line 133
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (i == 2) {
    {
#line 139
    index___0 = 0;
#line 140
    tmp___0 = ei_decode_version((char const   *)(buf), & index___0, & version);
    }
#line 140
    if (tmp___0) {
#line 143
      return (-1);
    } else {
      {
#line 140
      tmp___1 = ei_decode_tuple_header((char const   *)(buf), & index___0, & arity);
      }
#line 140
      if (tmp___1) {
#line 143
        return (-1);
      } else {
        {
#line 140
        tmp___2 = ei_decode_atom((char const   *)(buf), & index___0, string);
        }
#line 140
        if (tmp___2) {
#line 143
          return (-1);
        }
      }
    }
    {
#line 145
    tmp___3 = strcmp((char const   *)(string), "ok");
    }
#line 145
    if (! tmp___3) {
#line 145
      return (0);
    }
  }
#line 148
  return (-1);
}
}
#line 151 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dump.c"
static int mn_send_delete(int fd , erlang_pid *mnesia , char const   *key ) 
{ 
  char sbuf[2048] ;
  char *dbuf ;
  char *msgbuf ;
  int index___0 ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 154
  dbuf = (char *)((void *)0);
#line 156
  index___0 = 0;
#line 157
  tmp = strlen(key);
#line 157
  len = (int )(tmp + 32U);
  }
#line 159
  if (len > 2048) {
    {
#line 160
    tmp___0 = malloc((size_t )index___0);
#line 160
    dbuf = (char *)tmp___0;
    }
#line 160
    if (! dbuf) {
#line 161
      return (-1);
    }
  }
#line 162
  if (dbuf) {
#line 162
    msgbuf = dbuf;
  } else {
#line 162
    msgbuf = sbuf;
  }
  {
#line 165
  ei_encode_version(msgbuf, & index___0);
#line 166
  ei_encode_tuple_header(msgbuf, & index___0, 2);
#line 167
  ei_encode_atom(msgbuf, & index___0, "delete");
#line 168
  ei_encode_string(msgbuf, & index___0, key);
#line 171
  tmp___1 = ei_send_encoded(fd, (erlang_pid const   *)mnesia, msgbuf, index___0);
  }
#line 171
  if (tmp___1) {
#line 172
    if (dbuf) {
      {
#line 172
      free((void *)dbuf);
      }
    }
#line 173
    return (-1);
  }
#line 176
  if (dbuf) {
    {
#line 176
    free((void *)dbuf);
    }
  }
#line 177
  return (0);
}
}
#line 180 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dump.c"
static int mn_send_write(int fd , erlang_pid *mnesia , char const   *key , ei_reg_obj *obj ) 
{ 
  char sbuf[2048] ;
  char *dbuf ;
  char *msgbuf ;
  int index___0 ;
  int keylen ;
  size_t tmp ;
  int len ;
  void *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 183
  dbuf = (char *)((void *)0);
#line 185
  index___0 = 0;
#line 186
  tmp = strlen(key);
#line 186
  keylen = (int )(tmp + 1U);
#line 187
  len = (32 + keylen) + obj->size;
  }
#line 189
  if (len > 2048) {
    {
#line 190
    tmp___0 = malloc((size_t )index___0);
#line 190
    dbuf = (char *)tmp___0;
    }
#line 190
    if (! dbuf) {
#line 191
      return (-1);
    }
  }
#line 192
  if (dbuf) {
#line 192
    msgbuf = dbuf;
  } else {
#line 192
    msgbuf = sbuf;
  }
  {
#line 194
  ei_encode_version(msgbuf, & index___0);
#line 195
  ei_encode_tuple_header(msgbuf, & index___0, 6);
#line 196
  ei_encode_atom(msgbuf, & index___0, "write");
#line 197
  ei_encode_string(msgbuf, & index___0, key);
#line 198
  ei_encode_long(msgbuf, & index___0, (long )keylen);
#line 199
  ei_encode_long(msgbuf, & index___0, (long )obj->attr);
#line 200
  ei_encode_long(msgbuf, & index___0, (long )obj->size);
  }
  {
#line 203
  if ((obj->attr & 248) == 16) {
#line 203
    goto case_16;
  }
#line 206
  if ((obj->attr & 248) == 32) {
#line 206
    goto case_32;
  }
#line 209
  if ((obj->attr & 248) == 64) {
#line 209
    goto case_64;
  }
#line 213
  if ((obj->attr & 248) == 128) {
#line 213
    goto case_128;
  }
#line 217
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 204
  ei_encode_long(msgbuf, & index___0, obj->val.i);
  }
#line 205
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 207
  ei_encode_double(msgbuf, & index___0, obj->val.f);
  }
#line 208
  goto switch_break;
  case_64: /* CIL Label */ 
#line 210
  if (obj->size > 0) {
    {
#line 210
    ei_encode_string(msgbuf, & index___0, (char const   *)obj->val.s);
    }
  } else {
    {
#line 211
    ei_encode_long(msgbuf, & index___0, (long )((void *)0));
    }
  }
#line 212
  goto switch_break;
  case_128: /* CIL Label */ 
#line 214
  if (obj->size > 0) {
    {
#line 214
    ei_encode_binary(msgbuf, & index___0, (void const   *)obj->val.p, (long )obj->size);
    }
  } else {
    {
#line 215
    ei_encode_long(msgbuf, & index___0, (long )obj->val.p);
    }
  }
#line 216
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 218
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp___1 = ei_send_encoded(fd, (erlang_pid const   *)mnesia, msgbuf, index___0);
  }
#line 222
  if (tmp___1) {
#line 223
    if (dbuf) {
      {
#line 223
      free((void *)dbuf);
      }
    }
#line 224
    return (-1);
  }
#line 227
  if (dbuf) {
    {
#line 227
    free((void *)dbuf);
    }
  }
#line 228
  return (0);
}
}
#line 231 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dump.c"
static int mn_get_unlink(int fd ) 
{ 
  erlang_msg msg ;
  char buf[2048] ;
  char *bufp ;
  int index___0 ;
  int msglen ;
  int tmp ;
  void *__cil_tmp8 ;

  {
#line 235
  bufp = buf;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    index___0 = 2048;
#line 242
    tmp = ei_recv_internal(fd, & bufp, & index___0, & msg, & msglen, 1, 0U);
    }
    {
#line 243
    if (tmp == 0) {
#line 243
      goto case_0;
    }
#line 244
    if (tmp == 4) {
#line 244
      goto case_4;
    }
#line 245
    goto switch_default;
    case_0: /* CIL Label */ 
#line 243
    goto while_continue;
    case_4: /* CIL Label */ 
#line 244
    return (0);
    switch_default: /* CIL Label */ 
#line 245
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return (0);
}
}
#line 253 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dump.c"
int ei_reg_dump(int fd , ei_reg *reg , char const   *mntab , int flags ) 
{ 
  ei_hash *tab___0 ;
  erlang_pid self ;
  erlang_pid mnesia ;
  ei_bucket *b ;
  ei_reg_obj *obj ;
  char const   *key ;
  ei_cnode *ec ;
  int i ;
  char const   *tmp ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 264
  if (! reg) {
#line 264
    return (-1);
  } else
#line 264
  if (! mntab) {
#line 264
    return (-1);
  }
  {
#line 265
  tab___0 = reg->tab;
#line 269
  ec = ei_fd_to_cnode(fd);
  }
#line 269
  if ((unsigned long )ec == (unsigned long )((void *)0)) {
#line 270
    return (-1);
  }
  {
#line 272
  tmp = ei_thisnodename((ei_cnode const   *)ec);
#line 272
  strcpy((char */* __restrict  */)(self.node), (char const   */* __restrict  */)tmp);
#line 273
  self.num = (unsigned int )fd;
#line 274
  self.serial = 0U;
#line 275
  tmp___0 = ei_thiscreation((ei_cnode const   *)ec);
#line 275
  self.creation = (unsigned int )tmp___0;
#line 277
  tmp___1 = mn_start_dump(fd, (erlang_pid const   *)(& self), & mnesia, mntab);
  }
#line 277
  if (tmp___1) {
#line 277
    return (-1);
  }
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < tab___0->size)) {
#line 280
      goto while_break;
    }
#line 281
    b = *(tab___0->tab + i);
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 282
      if (! b) {
#line 282
        goto while_break___0;
      }
#line 283
      obj = (ei_reg_obj *)b->value;
#line 284
      key = b->key;
#line 286
      if (flags & 1) {
#line 286
        goto _L;
      } else
#line 286
      if (obj->attr & 1) {
        _L: /* CIL Label */ 
#line 287
        if (obj->attr & 2) {
          {
#line 288
          tmp___2 = mn_send_delete(fd, & mnesia, key);
          }
#line 288
          if (tmp___2) {
            {
#line 289
            ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
                         "delete failed");
            }
#line 290
            return (-1);
          }
        } else {
          {
#line 294
          tmp___3 = mn_send_write(fd, & mnesia, key, obj);
          }
#line 294
          if (tmp___3) {
            {
#line 295
            ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
                         "update failed");
            }
#line 296
            return (-1);
          }
        }
      }
#line 300
      b = b->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  tmp___4 = mn_send_commit(fd, & mnesia, & self);
  }
#line 305
  if (tmp___4) {
    {
#line 306
    ei_send_exit(fd, (erlang_pid const   *)(& self), (erlang_pid const   *)(& mnesia),
                 "commit failed");
    }
#line 307
    return (-1);
  }
  {
#line 311
  tmp___5 = mn_get_unlink(fd);
  }
#line 311
  if (tmp___5) {
#line 311
    return (-1);
  }
#line 316
  if (! (flags & 2)) {
    {
#line 316
    ei_reg_purge(reg);
    }
  }
#line 319
  return (0);
}
}
#line 668 "../include/ei.h"
int ei_reg_markdirty(ei_reg *reg , char const   *key ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_dirty.c"
int ei_reg_markdirty(ei_reg *reg , char const   *key ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 28
  if (! key) {
#line 28
    return (-1);
  } else
#line 28
  if (! reg) {
#line 28
    return (-1);
  }
  {
#line 29
  tab___0 = reg->tab;
#line 30
  tmp = ei_hash_lookup(tab___0, key);
#line 30
  obj = (ei_reg_obj *)tmp;
  }
#line 30
  if (! obj) {
#line 30
    return (-1);
  }
#line 33
  obj->attr |= 1;
#line 35
  return (0);
}
}
#line 672 "../include/ei.h"
int ei_reg_delete(ei_reg *reg , char const   *key ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_delete.c"
int ei_reg_delete(ei_reg *reg , char const   *key ) 
{ 
  ei_hash *tab___0 ;
  ei_reg_obj *obj ;
  void *tmp ;

  {
#line 28
  if (! key) {
#line 28
    return (-1);
  } else
#line 28
  if (! reg) {
#line 28
    return (-1);
  }
  {
#line 29
  tab___0 = reg->tab;
#line 30
  tmp = ei_hash_lookup(tab___0, key);
#line 30
  obj = (ei_reg_obj *)tmp;
  }
#line 30
  if (! obj) {
#line 30
    return (-1);
  }
#line 33
  obj->attr |= 3;
#line 35
  return (0);
}
}
#line 603 "../include/ei.h"
int ei_reg_close(ei_reg *reg ) ;
#line 43 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
int ei_hash_freetab(ei_hash *tab___0 , void (*f)(void * ) ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_close.c"
static void obj_free(void *p ) 
{ 
  ei_reg_obj *obj ;

  {
#line 27
  obj = (ei_reg_obj *)p;
#line 29
  if (obj) {
    {
#line 31
    if ((obj->attr & 248) == 64) {
#line 31
      goto case_64;
    }
#line 35
    if ((obj->attr & 248) == 128) {
#line 35
      goto case_128;
    }
#line 30
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 32
    free((void *)obj->val.s);
    }
#line 33
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 36
    free(obj->val.p);
    }
#line 37
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 41
    free((void *)obj);
    }
  }
#line 43
  return;
}
}
#line 47 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/reg_close.c"
int ei_reg_close(ei_reg *reg ) 
{ 
  ei_reg_obj *obj ;
  ei_reg_obj *next ;

  {
#line 51
  if (! reg) {
#line 51
    return (-1);
  }
  {
#line 54
  ei_hash_freetab(reg->tab, & obj_free);
#line 57
  obj = reg->freelist;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! obj) {
#line 58
      goto while_break;
    }
    {
#line 59
    next = obj->next;
#line 60
    free((void *)obj);
#line 61
    obj = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  free((void *)reg);
  }
#line 67
  return (0);
}
}
#line 37 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
char const   *ei_hash_rlookup(ei_hash *tab___0 , void const   *value ) ;
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_rlookup.c"
char const   *ei_hash_rlookup(ei_hash *tab___0 , void const   *value ) 
{ 
  ei_bucket *b ;
  int i ;

  {
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < tab___0->size)) {
#line 34
      goto while_break;
    }
#line 35
    b = *(tab___0->tab + i);
    {
#line 36
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 36
      if (! b) {
#line 36
        goto while_break___0;
      }
#line 37
      if ((unsigned long )b->value == (unsigned long )value) {
#line 37
        return (b->key);
      }
#line 38
      b = b->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return ((char const   *)((void *)0));
}
}
#line 34 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
int ei_isprime(int n ) ;
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_resize.c"
ei_hash *ei_hash_resize(ei_hash *oldtab , int newsize ) 
{ 
  ei_hash *newtab ;
  ei_bucket *b ;
  ei_bucket *next ;
  int i ;
  int h ;
  int tmp ;

  {
#line 30
  newtab = (ei_hash *)((void *)0);
#line 35
  newsize |= 1;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    tmp = ei_isprime(newsize);
    }
#line 36
    if (tmp) {
#line 36
      goto while_break;
    }
#line 36
    newsize += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  if (newsize == oldtab->size) {
#line 38
    return (oldtab);
  }
  {
#line 41
  newtab = ei_hash_newtab(newsize);
  }
#line 41
  if (! newtab) {
#line 41
    return (oldtab);
  }
#line 42
  newtab->hash = oldtab->hash;
#line 46
  i = 0;
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! (i < oldtab->size)) {
#line 46
      goto while_break___0;
    }
#line 47
    b = *(oldtab->tab + i);
    {
#line 48
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 48
      if (! b) {
#line 48
        goto while_break___1;
      }
#line 49
      next = b->next;
#line 50
      h = b->rawhash % newtab->size;
#line 51
      b->next = *(newtab->tab + h);
#line 52
      if (! *(newtab->tab + h)) {
#line 52
        (newtab->npos) ++;
      }
#line 53
      *(newtab->tab + h) = b;
#line 54
      b = next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 46
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 58
  newtab->nelem = oldtab->nelem;
#line 61
  newtab->freelist = oldtab->freelist;
#line 64
  free((void *)oldtab);
  }
#line 66
  return (newtab);
}
}
#line 40 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
void *ei_hash_remove(ei_hash *tab___0 , char const   *key ) ;
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_remove.c"
void ei_hash_bfree(ei_hash *tab___0 , ei_bucket *b ) 
{ 


  {
#line 32
  if (! b) {
#line 32
    return;
  }
#line 35
  if ((unsigned long )b->key != (unsigned long )(b->keybuf)) {
    {
#line 37
    free((void *)b);
    }
  } else {
#line 43
    b->next = tab___0->freelist;
#line 44
    tab___0->freelist = b;
  }
#line 47
  return;
}
}
#line 50 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_remove.c"
void *ei_hash_remove(ei_hash *tab___0 , char const   *key ) 
{ 
  ei_bucket *b ;
  ei_bucket *tmp ;
  void const   *oldval ;
  int h ;
  int rh ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 52
  b = (ei_bucket *)((void *)0);
#line 52
  tmp = (ei_bucket *)((void *)0);
#line 53
  oldval = (void const   *)((void *)0);
#line 56
  rh = (*(tab___0->hash))(key);
#line 57
  h = rh % tab___0->size;
#line 60
  b = *(tab___0->tab + h);
  }
#line 60
  if (b) {
#line 61
    if (rh == b->rawhash) {
      {
#line 61
      tmp___1 = strcmp(key, b->key);
      }
#line 61
      if (tmp___1) {
#line 61
        goto _L;
      } else {
        {
#line 62
        *(tab___0->tab + h) = b->next;
#line 63
        oldval = b->value;
#line 64
        ei_hash_bfree(tab___0, b);
#line 66
        (tab___0->nelem) --;
        }
#line 67
        if (! *(tab___0->tab + h)) {
#line 67
          (tab___0->npos) --;
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 71
      while (1) {
        while_continue: /* CIL Label */ ;
#line 71
        if (! b->next) {
#line 71
          goto while_break;
        }
#line 72
        if (rh == (b->next)->rawhash) {
          {
#line 72
          tmp___0 = strcmp(key, (b->next)->key);
          }
#line 72
          if (! tmp___0) {
            {
#line 73
            tmp = b->next;
#line 74
            b->next = tmp->next;
#line 75
            oldval = tmp->value;
#line 76
            ei_hash_bfree(tab___0, tmp);
#line 78
            (tab___0->nelem) --;
            }
#line 79
            goto while_break;
          }
        }
#line 81
        b = b->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 85
  return ((void *)oldval);
}
}
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 35 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash.h"
int ei_dohash(char const   *key ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_newtab.c"
ei_hash *ei_hash_newtab(int tabsize ) 
{ 
  ei_hash *tab___0 ;
  int bucketpos ;
  int tmp ;
  void *tmp___0 ;

  {
#line 27
  tab___0 = (ei_hash *)((void *)0);
#line 28
  bucketpos = (int )sizeof(*tab___0);
#line 31
  tabsize |= 1;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 32
    tmp = ei_isprime(tabsize);
    }
#line 32
    if (tmp) {
#line 32
      goto while_break;
    }
#line 32
    tabsize += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! ((unsigned int )bucketpos & 7U)) {
#line 37
      goto while_break___0;
    }
#line 37
    bucketpos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 40
  tmp___0 = malloc((size_t )((unsigned long )bucketpos + (unsigned long )tabsize * sizeof(*(tab___0->tab))));
#line 40
  tab___0 = (ei_hash *)tmp___0;
  }
#line 40
  if (tab___0) {
    {
#line 41
    tab___0->tab = (ei_bucket **)((char *)tab___0 + bucketpos);
#line 42
    memset((void *)tab___0->tab, 0, (size_t )((unsigned long )tabsize * sizeof(*(tab___0->tab))));
#line 43
    tab___0->hash = & ei_dohash;
#line 44
    tab___0->size = tabsize;
#line 45
    tab___0->npos = 0;
#line 46
    tab___0->nelem = 0;
#line 47
    tab___0->freelist = (ei_bucket *)((void *)0);
    }
  }
#line 50
  return (tab___0);
}
}
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_lookup.c"
void *ei_hash_lookup(ei_hash *tab___0 , char const   *key ) 
{ 
  int h ;
  int rh ;
  ei_bucket *b ;
  int tmp ;

  {
  {
#line 28
  b = (ei_bucket *)((void *)0);
#line 30
  rh = (*(tab___0->hash))(key);
#line 31
  h = rh % tab___0->size;
#line 33
  b = *(tab___0->tab + h);
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! b) {
#line 34
      goto while_break;
    }
#line 35
    if (rh == b->rawhash) {
      {
#line 35
      tmp = strcmp(key, b->key);
      }
#line 35
      if (! tmp) {
#line 36
        return ((void *)b->value);
      }
    }
#line 37
    b = b->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  return ((void *)0);
}
}
#line 31 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_isprime.c"
static int factor(int n ) ;
#line 31 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_isprime.c"
static int a[6]  = {      0,      4,      1,      2, 
        0,      2};
#line 32 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_isprime.c"
static int m  =    0;
#line 33 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_isprime.c"
static int d  =    0;
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_isprime.c"
static int factor(int n ) 
{ 


  {
#line 35
  if (n) {
#line 36
    m = n;
#line 37
    d = 2;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (d * d <= m)) {
#line 40
      goto while_break;
    }
#line 41
    if (! (m % d)) {
#line 42
      m /= d;
#line 43
      return (d);
    }
#line 45
    d += a[d % 6];
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  n = m;
#line 48
  m = 0;
#line 50
  return (n);
}
}
#line 54 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_isprime.c"
int ei_isprime(int n ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = factor(n);
  }
#line 56
  return (n == tmp);
}
}
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_insert.c"
static ei_bucket *ei_hash_bmalloc(ei_hash *tab___0 ) 
{ 
  ei_bucket *new ;
  void *tmp ;

  {
#line 34
  if (tab___0->freelist) {
#line 35
    new = tab___0->freelist;
#line 36
    tab___0->freelist = new->next;
  } else {
    {
#line 40
    tmp = malloc((size_t )sizeof(*new));
#line 40
    new = (ei_bucket *)tmp;
    }
  }
#line 44
  return (new);
}
}
#line 52 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_insert.c"
void *ei_hash_insert(ei_hash *tab___0 , char const   *key , void const   *value ) 
{ 
  void const   *oldval ;
  ei_bucket *b ;
  int h ;
  int rh ;
  int tmp ;
  int keylen ;
  size_t tmp___0 ;
  int keypos ;
  void *tmp___1 ;

  {
  {
#line 54
  oldval = (void const   *)((void *)0);
#line 55
  b = (ei_bucket *)((void *)0);
#line 58
  rh = (*(tab___0->hash))(key);
#line 59
  h = rh % tab___0->size;
#line 61
  b = *(tab___0->tab + h);
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! b) {
#line 62
      goto while_break;
    }
#line 63
    if (rh == b->rawhash) {
      {
#line 63
      tmp = strcmp(key, b->key);
      }
#line 63
      if (! tmp) {
#line 64
        goto while_break;
      }
    }
#line 65
    b = b->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  if (b) {
#line 70
    oldval = b->value;
#line 71
    b->value = value;
  } else {
    {
#line 74
    tmp___0 = strlen(key);
#line 74
    keylen = (int )tmp___0;
    }
#line 77
    if (keylen < 32) {
      {
#line 80
      b = ei_hash_bmalloc(tab___0);
      }
#line 80
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 80
        return ((void *)0);
      }
#line 81
      b->key = (char const   *)(b->keybuf);
    } else {
#line 85
      keypos = (int )sizeof(*b);
      {
#line 87
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 87
        if (! ((unsigned int )keypos & 7U)) {
#line 87
          goto while_break___0;
        }
#line 87
        keypos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 88
      tmp___1 = malloc((size_t )((keypos + keylen) + 1));
#line 88
      b = (ei_bucket *)tmp___1;
      }
#line 88
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 88
        return ((void *)0);
      }
#line 89
      b->key = (char const   *)((char *)b + keypos);
    }
    {
#line 94
    b->rawhash = rh;
#line 95
    strcpy((char */* __restrict  */)((char *)b->key), (char const   */* __restrict  */)key);
#line 96
    b->value = value;
    }
#line 99
    if (! *(tab___0->tab + h)) {
#line 99
      (tab___0->npos) ++;
    }
#line 100
    (tab___0->nelem) ++;
#line 103
    b->next = *(tab___0->tab + h);
#line 104
    *(tab___0->tab + h) = b;
  }
#line 106
  return ((void *)oldval);
}
}
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_freetab.c"
int ei_hash_freetab(ei_hash *tab___0 , void (*f)(void * ) ) 
{ 
  ei_bucket *b ;
  ei_bucket *next ;
  int i ;

  {
#line 33
  i = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (i < tab___0->size)) {
#line 33
      goto while_break;
    }
#line 34
    b = *(tab___0->tab + i);
    {
#line 35
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 35
      if (! b) {
#line 35
        goto while_break___0;
      }
#line 36
      next = b->next;
#line 38
      if (f) {
        {
#line 38
        (*f)((void *)b->value);
        }
      }
      {
#line 41
      free((void *)b);
#line 42
      b = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 33
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  b = tab___0->freelist;
  {
#line 48
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 48
    if (! b) {
#line 48
      goto while_break___1;
    }
    {
#line 49
    next = b->next;
#line 50
    free((void *)b);
#line 51
    b = next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 55
  free((void *)tab___0);
  }
#line 57
  return (0);
}
}
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_foreach.c"
int ei_hash_foreach(ei_hash *tab___0 , int (*f)(char const   *key , void const   *value ) ) 
{ 
  ei_bucket *b ;
  int i ;
  int r ;

  {
#line 35
  i = 0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < tab___0->size)) {
#line 35
      goto while_break;
    }
#line 36
    b = *(tab___0->tab + i);
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 37
      if (! b) {
#line 37
        goto while_break___0;
      }
#line 38
      if (f) {
        {
#line 38
        r = (*f)(b->key, b->value);
        }
#line 38
        if (r) {
#line 38
          return (r);
        }
      }
#line 39
      b = b->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 35
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return (0);
}
}
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/registry/hash_dohash.c"
int ei_dohash(char const   *key ) 
{ 
  char const   *s ;
  unsigned int h ;
  unsigned int g ;

  {
#line 32
  h = 0U;
#line 35
  s = key;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! *s) {
#line 35
      goto while_break;
    }
#line 36
    h = (h << 4) + (unsigned int )*s;
#line 37
    g = h & 4026531840U;
#line 37
    if (g) {
#line 38
      h ^= g >> 24;
#line 39
      h ^= g;
    }
#line 35
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((int )h);
}
}
#line 451 "../include/ei.h"
int ei_get_type(char const   *buf , int const   *index , int *type , int *len ) ;
#line 31 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/get_type.c"
int ei_get_type(char const   *buf , int const   *index , int *type , int *len ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ei_get_type_internal(buf, index, type, len);
  }
#line 33
  return (tmp);
}
}
#line 109 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/get_type.c"
int ei_get_type_internal(char const   *buf , int const   *index , int *type , int *len ) 
{ 
  char const   *s ;

  {
#line 112
  s = buf + *index;
#line 114
  s ++;
#line 114
  *type = (int )*((unsigned char *)s + -1) & 255;
  {
#line 117
  if (*type == 104) {
#line 117
    goto case_104;
  }
#line 122
  if (*type == 107) {
#line 122
    goto case_107;
  }
#line 122
  if (*type == 100) {
#line 122
    goto case_107;
  }
#line 128
  if (*type == 109) {
#line 128
    goto case_109;
  }
#line 128
  if (*type == 108) {
#line 128
    goto case_109;
  }
#line 128
  if (*type == 105) {
#line 128
    goto case_109;
  }
#line 132
  if (*type == 110) {
#line 132
    goto case_110;
  }
#line 136
  if (*type == 111) {
#line 136
    goto case_111;
  }
#line 140
  goto switch_default;
  case_104: /* CIL Label */ 
#line 118
  s ++;
#line 118
  *len = (int )*((unsigned char *)s + -1) & 255;
#line 119
  goto switch_break;
  case_107: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 123
  s += 2;
#line 123
  *len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 124
  goto switch_break;
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_105: /* CIL Label */ 
#line 129
  s += 4;
#line 129
  *len = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 130
  goto switch_break;
  case_110: /* CIL Label */ 
#line 133
  s ++;
#line 133
  *len = (int )*((unsigned char *)s + -1) & 255;
#line 134
  goto switch_break;
  case_111: /* CIL Label */ 
#line 137
  s += 4;
#line 137
  *len = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 138
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 141
  *len = 0;
#line 142
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 146
  return (0);
}
}
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 333 "../include/ei.h"
int ei_unpublish(ei_cnode *ec ) ;
#line 334
int ei_unpublish_tmo(char const   *alive , unsigned int ms ) ;
#line 338
char const   *ei_thisalivename(ei_cnode const   *ec ) ;
#line 60 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/ei_epmd.h"
int ei_epmd_connect_tmo(struct in_addr *inaddr , unsigned int ms ) ;
#line 28 "misc/ei_portio.h"
int ei_read_fill_t(int fd , char *buf , int len , unsigned int ms ) ;
#line 55 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_unpublish.c"
int ei_unpublish_tmo(char const   *alive , unsigned int ms ) 
{ 
  char buf[512] ;
  char *s ;
  int len ;
  size_t tmp ;
  int fd ;
  int res ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;
  int volatile   *tmp___2 ;
  int volatile   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 58
  s = buf;
#line 59
  tmp = strlen(alive);
#line 59
  len = (int )(1U + tmp);
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    *(s + 0) = (char )((len >> 8) & 255);
#line 62
    *(s + 1) = (char )(len & 255);
#line 62
    s += 2;
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    *(s + 0) = (char)115;
#line 63
    s ++;
#line 63
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 64
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)alive);
#line 67
  fd = ei_epmd_connect_tmo((struct in_addr *)((void *)0), ms);
  }
#line 67
  if (fd < 0) {
#line 67
    return (fd);
  }
  {
#line 69
  res = ei_write_fill_t(fd, (char const   *)(buf), len + 2, ms);
  }
#line 69
  if (res != len + 2) {
    {
#line 70
    close(fd);
#line 71
    tmp___0 = __erl_errno_place();
    }
#line 71
    if (res == -2) {
#line 71
      *tmp___0 = (int volatile   )110;
    } else {
#line 71
      *tmp___0 = (int volatile   )5;
    }
#line 72
    return (-1);
  }
#line 75
  if (ei_tracelevel >= 3) {
    {
#line 75
    ei_trace_printf("ei_unpublish_tmo", 1, "-> STOP %s", alive);
    }
  }
  {
#line 77
  res = ei_read_fill_t(fd, buf, 7, ms);
  }
#line 77
  if (res != 7) {
    {
#line 78
    close(fd);
#line 79
    tmp___1 = __erl_errno_place();
    }
#line 79
    if (res == -2) {
#line 79
      *tmp___1 = (int volatile   )110;
    } else {
#line 79
      *tmp___1 = (int volatile   )5;
    }
#line 80
    return (-1);
  }
  {
#line 82
  close(fd);
#line 83
  buf[7] = (char)0;
#line 85
  tmp___5 = strcmp("STOPPED", (char const   *)(buf));
  }
#line 85
  if (tmp___5) {
    {
#line 89
    tmp___4 = strcmp("NOEXIST", (char const   *)(buf));
    }
#line 89
    if (tmp___4) {
#line 95
      if (ei_tracelevel >= 1) {
        {
#line 95
        ei_trace_printf("ei_unpublish_tmo", 1, "<- unknown (failure)");
        }
      }
      {
#line 96
      tmp___3 = __erl_errno_place();
#line 96
      *tmp___3 = (int volatile   )5;
      }
#line 97
      return (-1);
    } else {
#line 90
      if (ei_tracelevel >= 1) {
        {
#line 90
        ei_trace_printf("ei_unpublish_tmo", 1, "<- NOEXIST (failure)");
        }
      }
      {
#line 91
      tmp___2 = __erl_errno_place();
#line 91
      *tmp___2 = (int volatile   )5;
      }
#line 92
      return (-1);
    }
  } else {
#line 86
    if (ei_tracelevel >= 3) {
      {
#line 86
      ei_trace_printf("ei_unpublish_tmo", 1, "<- STOPPED (success)");
      }
    }
#line 87
    return (0);
  }
#line 99
  return (0);
}
}
#line 103 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_unpublish.c"
int ei_unpublish(ei_cnode *ec ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 105
  tmp = ei_thisalivename((ei_cnode const   *)ec);
#line 105
  tmp___0 = ei_unpublish_tmo(tmp, 0U);
  }
#line 105
  return (tmp___0);
}
}
#line 329 "../include/ei.h"
int ei_publish(ei_cnode *ec , int port ) ;
#line 330
int ei_publish_tmo(ei_cnode *ec , int port , unsigned int ms ) ;
#line 61 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/ei_epmd.h"
int ei_epmd_publish(int port , char const   *alive ) ;
#line 62
int ei_epmd_publish_tmo(int port , char const   *alive , unsigned int ms ) ;
#line 58 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_publish.c"
static int ei_epmd_r3_publish(int port , char const   *alive , unsigned int ms ) 
{ 
  char buf[512] ;
  char *s ;
  int fd ;
  int len ;
  size_t tmp ;
  int res ;
  int creation ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;
  int volatile   *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 61
  s = buf;
#line 63
  tmp = strlen(alive);
#line 63
  len = (int )(tmp + 3U);
#line 66
  s = buf;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    *(s + 0) = (char )((len >> 8) & 255);
#line 67
    *(s + 1) = (char )(len & 255);
#line 67
    s += 2;
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    *(s + 0) = (char)97;
#line 68
    s ++;
#line 68
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 69
    *(s + 0) = (char )((port >> 8) & 255);
#line 69
    *(s + 1) = (char )(port & 255);
#line 69
    s += 2;
#line 69
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 70
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)alive);
#line 72
  fd = ei_epmd_connect_tmo((struct in_addr *)((void *)0), ms);
  }
#line 72
  if (fd < 0) {
#line 72
    return (fd);
  }
  {
#line 74
  res = ei_write_fill_t(fd, (char const   *)(buf), len + 2, ms);
  }
#line 74
  if (res != len + 2) {
    {
#line 75
    close(fd);
#line 76
    tmp___0 = __erl_errno_place();
    }
#line 76
    if (res == -2) {
#line 76
      *tmp___0 = (int volatile   )110;
    } else {
#line 76
      *tmp___0 = (int volatile   )5;
    }
#line 77
    return (-1);
  }
#line 80
  if (ei_tracelevel >= 3) {
    {
#line 80
    ei_trace_printf("ei_epmd_r3_publish", 1, "-> ALIVE_REQ alive=%s port=%d", alive,
                    port);
    }
  }
  {
#line 83
  res = ei_read_fill_t(fd, buf, 3, ms);
  }
#line 83
  if (res != 3) {
    {
#line 84
    close(fd);
#line 85
    tmp___1 = __erl_errno_place();
    }
#line 85
    if (res == -2) {
#line 85
      *tmp___1 = (int volatile   )110;
    } else {
#line 85
      *tmp___1 = (int volatile   )5;
    }
#line 86
    return (-1);
  }
#line 89
  s = buf;
#line 90
  s ++;
#line 90
  res = (int )*((unsigned char *)s + -1) & 255;
#line 90
  if (res != 89) {
#line 91
    if (ei_tracelevel >= 1) {
      {
#line 91
      ei_trace_printf("ei_epmd_r3_publish", 1, "<- ALIVE_NOK result=%d (failure)",
                      res);
      }
    }
    {
#line 93
    close(fd);
#line 94
    tmp___2 = __erl_errno_place();
#line 94
    *tmp___2 = (int volatile   )5;
    }
#line 95
    return (-1);
  }
#line 98
  s += 2;
#line 98
  creation = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 100
  if (ei_tracelevel >= 3) {
    {
#line 100
    ei_trace_printf("ei_epmd_r3_publish", 1, "<- ALIVE_OK creation=%d", creation);
    }
  }
#line 111
  return (fd);
}
}
#line 117 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_publish.c"
static int ei_epmd_r4_publish(int port , char const   *alive , unsigned int ms ) 
{ 
  char buf[512] ;
  char *s ;
  int fd ;
  int elen ;
  int nlen ;
  size_t tmp ;
  int len ;
  int n ;
  int res ;
  int creation ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;
  int volatile   *tmp___2 ;
  int volatile   *tmp___3 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 120
  s = buf;
#line 122
  elen = 0;
#line 123
  tmp = strlen(alive);
#line 123
  nlen = (int )tmp;
#line 124
  len = (elen + nlen) + 13;
#line 128
  s = buf;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    *(s + 0) = (char )((len >> 8) & 255);
#line 129
    *(s + 1) = (char )(len & 255);
#line 129
    s += 2;
#line 129
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 131
    *(s + 0) = (char)120;
#line 131
    s ++;
#line 131
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 132
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 132
    *(s + 0) = (char )((port >> 8) & 255);
#line 132
    *(s + 1) = (char )(port & 255);
#line 132
    s += 2;
#line 132
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 133
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 133
    *(s + 0) = (char)104;
#line 133
    s ++;
#line 133
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 134
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 134
    *(s + 0) = (char)0;
#line 134
    s ++;
#line 134
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 135
    *(s + 0) = (char )((5 >> 8) & 255);
#line 135
    *(s + 1) = (char)5;
#line 135
    s += 2;
#line 135
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 136
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 136
    *(s + 0) = (char )((1 >> 8) & 255);
#line 136
    *(s + 1) = (char)1;
#line 136
    s += 2;
#line 136
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 137
    *(s + 0) = (char )((nlen >> 8) & 255);
#line 137
    *(s + 1) = (char )(nlen & 255);
#line 137
    s += 2;
#line 137
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 138
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)alive);
#line 139
  s += nlen;
  }
  {
#line 140
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 140
    *(s + 0) = (char )((elen >> 8) & 255);
#line 140
    *(s + 1) = (char )(elen & 255);
#line 140
    s += 2;
#line 140
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 143
  fd = ei_epmd_connect_tmo((struct in_addr *)((void *)0), ms);
  }
#line 143
  if (fd < 0) {
#line 143
    return (fd);
  }
  {
#line 145
  res = ei_write_fill_t(fd, (char const   *)(buf), len + 2, ms);
  }
#line 145
  if (res != len + 2) {
    {
#line 146
    close(fd);
#line 147
    tmp___0 = __erl_errno_place();
    }
#line 147
    if (res == -2) {
#line 147
      *tmp___0 = (int volatile   )110;
    } else {
#line 147
      *tmp___0 = (int volatile   )5;
    }
#line 148
    return (-1);
  }
#line 151
  if (ei_tracelevel >= 3) {
    {
#line 151
    ei_trace_printf("ei_epmd_r4_publish", 1, "-> ALIVE2_REQ alive=%s port=%d ntype=%d proto=%d dist-high=%d dist-low=%d",
                    alive, port, 'H', 0, 5, 1);
    }
  }
  {
#line 156
  n = ei_read_fill_t(fd, buf, 4, ms);
  }
#line 156
  if (n != 4) {
#line 157
    if (ei_tracelevel >= 1) {
      {
#line 157
      ei_trace_printf("ei_epmd_r4_publish", 1, "<- CLOSE");
      }
    }
    {
#line 158
    close(fd);
#line 159
    tmp___1 = __erl_errno_place();
    }
#line 159
    if (n == -2) {
#line 159
      *tmp___1 = (int volatile   )110;
    } else {
#line 159
      *tmp___1 = (int volatile   )5;
    }
#line 160
    return (-2);
  }
#line 163
  s = buf;
#line 164
  s ++;
#line 164
  res = (int )*((unsigned char *)s + -1) & 255;
#line 164
  if (res != 121) {
#line 165
    if (ei_tracelevel >= 1) {
      {
#line 165
      ei_trace_printf("ei_epmd_r4_publish", 1, "<- unknown (%d)", res);
      }
    }
#line 166
    if (ei_tracelevel >= 1) {
      {
#line 166
      ei_trace_printf("ei_epmd_r4_publish", 1, "-> CLOSE");
      }
    }
    {
#line 167
    close(fd);
#line 168
    tmp___2 = __erl_errno_place();
#line 168
    *tmp___2 = (int volatile   )5;
    }
#line 169
    return (-1);
  }
#line 172
  if (ei_tracelevel >= 3) {
    {
#line 172
    ei_trace_printf("ei_epmd_r4_publish", 1, "<- ALIVE2_RESP");
    }
  }
#line 174
  s ++;
#line 174
  res = (int )*((unsigned char *)s + -1) & 255;
#line 174
  if (res != 0) {
#line 175
    if (ei_tracelevel >= 1) {
      {
#line 175
      ei_trace_printf("ei_epmd_r4_publish", 1, " result=%d (fail)", res);
      }
    }
    {
#line 176
    close(fd);
#line 177
    tmp___3 = __erl_errno_place();
#line 177
    *tmp___3 = (int volatile   )5;
    }
#line 178
    return (-1);
  }
#line 181
  s += 2;
#line 181
  creation = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 183
  if (ei_tracelevel >= 3) {
    {
#line 183
    ei_trace_printf("ei_epmd_r4_publish", 1, " result=%d (ok) creation=%d", res, creation);
    }
  }
#line 193
  return (fd);
}
}
#line 196 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_publish.c"
int ei_epmd_publish(int port , char const   *alive ) 
{ 
  int tmp ;

  {
  {
#line 198
  tmp = ei_epmd_publish_tmo(port, alive, 0U);
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_publish.c"
int ei_epmd_publish_tmo(int port , char const   *alive , unsigned int ms ) 
{ 
  int i ;

  {
  {
#line 206
  i = ei_epmd_r4_publish(port, alive, ms);
  }
#line 209
  if (i == -2) {
    {
#line 209
    i = ei_epmd_r3_publish(port, alive, ms);
    }
  }
#line 211
  return (i);
}
}
#line 220 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_publish.c"
int ei_publish(ei_cnode *ec , int port ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 222
  tmp = ei_thisalivename((ei_cnode const   *)ec);
#line 222
  tmp___0 = ei_epmd_publish(port, tmp);
  }
#line 222
  return (tmp___0);
}
}
#line 225 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_publish.c"
int ei_publish_tmo(ei_cnode *ec , int port , unsigned int ms ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 227
  tmp = ei_thisalivename((ei_cnode const   *)ec);
#line 227
  tmp___0 = ei_epmd_publish_tmo(port, tmp, ms);
  }
#line 227
  return (tmp___0);
}
}
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 368 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 370
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 63 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/ei_epmd.h"
int ei_epmd_port(struct in_addr *addr , char const   *alive , int *dist ) ;
#line 64
int ei_epmd_port_tmo(struct in_addr *addr , char const   *alive , int *dist , unsigned int ms ) ;
#line 25 "misc/ei_portio.h"
int ei_connect_t(int fd , void *sinp , int sin_siz , unsigned int ms ) ;
#line 63 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_port.c"
static unsigned int epmd_port  =    0U;
#line 61 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_port.c"
int ei_epmd_connect_tmo(struct in_addr *inaddr , unsigned int ms ) 
{ 
  struct sockaddr_in saddr ;
  int sd ;
  int res ;
  char *port_str ;
  char *tmp ;
  int tmp___0 ;
  int volatile   *tmp___1 ;
  int *tmp___2 ;
  int volatile   *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp13 ;

  {
#line 68
  if (epmd_port == 0U) {
    {
#line 69
    tmp = getenv("ERL_EPMD_PORT");
#line 69
    port_str = tmp;
    }
#line 70
    if ((unsigned long )port_str != (unsigned long )((void *)0)) {
      {
#line 70
      tmp___0 = atoi((char const   *)port_str);
#line 70
      epmd_port = (unsigned int )tmp___0;
      }
    } else {
#line 70
      epmd_port = 4369U;
    }
  }
  {
#line 72
  memset((void *)(& saddr), 0, (size_t )sizeof(saddr));
#line 73
  saddr.sin_port = htons((uint16_t )epmd_port);
#line 74
  saddr.sin_family = (sa_family_t )2;
  }
#line 76
  if (! inaddr) {
    {
#line 76
    saddr.sin_addr.s_addr = htonl((in_addr_t )2130706433);
    }
  } else {
    {
#line 77
    memmove((void *)(& saddr.sin_addr), (void const   *)inaddr, (size_t )sizeof(saddr.sin_addr));
    }
  }
  {
#line 79
  sd = socket(2, 1, 0);
  }
#line 79
  if (sd < 0) {
    {
#line 81
    tmp___1 = __erl_errno_place();
#line 81
    tmp___2 = __errno_location();
#line 81
    *tmp___1 = (int volatile   )*tmp___2;
    }
#line 82
    return (-1);
  }
  {
#line 85
  res = ei_connect_t(sd, (void *)((struct sockaddr *)(& saddr)), (int )sizeof(saddr),
                     ms);
  }
#line 85
  if (res < 0) {
    {
#line 87
    tmp___3 = __erl_errno_place();
    }
#line 87
    if (res == -2) {
#line 87
      *tmp___3 = (int volatile   )110;
    } else {
      {
#line 87
      tmp___4 = __errno_location();
#line 87
      *tmp___3 = (int volatile   )*tmp___4;
      }
    }
    {
#line 88
    close(sd);
    }
#line 89
    return (-1);
  }
#line 92
  return (sd);
}
}
#line 96 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_port.c"
static int ei_epmd_r3_port(struct in_addr *addr , char const   *alive , unsigned int ms ) 
{ 
  char buf[512] ;
  char *s ;
  int len ;
  size_t tmp ;
  int fd ;
  int port ;
  int res ;
  int volatile   *tmp___0 ;
  char *tmp___1 ;
  int volatile   *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 100
  s = buf;
#line 101
  tmp = strlen(alive);
#line 101
  len = (int )(tmp + 1U);
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    *(s + 0) = (char )((len >> 8) & 255);
#line 109
    *(s + 1) = (char )(len & 255);
#line 109
    s += 2;
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    *(s + 0) = (char)112;
#line 110
    s ++;
#line 110
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 111
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)alive);
#line 114
  fd = ei_epmd_connect_tmo(addr, ms);
  }
#line 114
  if (fd < 0) {
#line 117
    return (-1);
  }
  {
#line 120
  res = ei_write_fill_t(fd, (char const   *)(buf), len + 2, ms);
  }
#line 120
  if (res != len + 2) {
    {
#line 121
    close(fd);
#line 122
    tmp___0 = __erl_errno_place();
    }
#line 122
    if (res == -2) {
#line 122
      *tmp___0 = (int volatile   )110;
    } else {
#line 122
      *tmp___0 = (int volatile   )5;
    }
#line 123
    return (-1);
  }
#line 134
  if (ei_tracelevel >= 3) {
    {
#line 134
    tmp___1 = inet_ntoa(*addr);
#line 134
    ei_trace_printf("ei_epmd_r3_port", 1, "-> PORT_REQ alive=%s ip=%s", alive, tmp___1);
    }
  }
  {
#line 138
  res = ei_read_fill_t(fd, buf, 2, ms);
  }
#line 138
  if (res != 2) {
#line 139
    if (ei_tracelevel >= 1) {
      {
#line 139
      ei_trace_printf("ei_epmd_r3_port", 1, "<- CLOSE");
      }
    }
    {
#line 140
    close(fd);
#line 141
    tmp___2 = __erl_errno_place();
    }
#line 141
    if (res == -2) {
#line 141
      *tmp___2 = (int volatile   )110;
    } else {
#line 141
      *tmp___2 = (int volatile   )5;
    }
#line 142
    return (-1);
  }
  {
#line 144
  close(fd);
#line 145
  s = buf;
#line 146
  s += 2;
#line 146
  port = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
  }
#line 148
  if (ei_tracelevel >= 3) {
    {
#line 148
    ei_trace_printf("ei_epmd_r3_port", 1, "<- PORT_RESP port=%d", port);
    }
  }
#line 150
  return (port);
}
}
#line 153 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_port.c"
static int ei_epmd_r4_port(struct in_addr *addr , char const   *alive , int *dist ,
                           unsigned int ms ) 
{ 
  char buf[512] ;
  char *s ;
  int len ;
  size_t tmp ;
  int fd ;
  int ntype ;
  int port ;
  int dist_high ;
  int dist_low ;
  int proto ;
  int res ;
  int volatile   *tmp___0 ;
  char *tmp___1 ;
  int volatile   *tmp___2 ;
  int volatile   *tmp___3 ;
  int volatile   *tmp___4 ;
  int volatile   *tmp___5 ;
  int volatile   *tmp___6 ;
  int volatile   *tmp___7 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 157
  s = buf;
#line 158
  tmp = strlen(alive);
#line 158
  len = (int )(tmp + 1U);
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    *(s + 0) = (char )((len >> 8) & 255);
#line 168
    *(s + 1) = (char )(len & 255);
#line 168
    s += 2;
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 169
    *(s + 0) = (char)122;
#line 169
    s ++;
#line 169
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 170
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)alive);
#line 173
  fd = ei_epmd_connect_tmo(addr, ms);
  }
#line 173
  if (fd < 0) {
#line 175
    return (-1);
  }
  {
#line 178
  res = ei_write_fill_t(fd, (char const   *)(buf), len + 2, ms);
  }
#line 178
  if (res != len + 2) {
    {
#line 179
    close(fd);
#line 180
    tmp___0 = __erl_errno_place();
    }
#line 180
    if (res == -2) {
#line 180
      *tmp___0 = (int volatile   )110;
    } else {
#line 180
      *tmp___0 = (int volatile   )5;
    }
#line 181
    return (-1);
  }
#line 192
  if (ei_tracelevel >= 3) {
    {
#line 192
    tmp___1 = inet_ntoa(*addr);
#line 192
    ei_trace_printf("ei_epmd_r4_port", 1, "-> PORT2_REQ alive=%s ip=%s", alive, tmp___1);
    }
  }
  {
#line 197
  res = ei_read_fill_t(fd, buf, 2, ms);
  }
#line 197
  if (res != 2) {
#line 198
    if (ei_tracelevel >= 1) {
      {
#line 198
      ei_trace_printf("ei_epmd_r4_port", 1, "<- CLOSE");
      }
    }
    {
#line 199
    tmp___2 = __erl_errno_place();
    }
#line 199
    if (res == -2) {
#line 199
      *tmp___2 = (int volatile   )110;
    } else {
#line 199
      *tmp___2 = (int volatile   )5;
    }
    {
#line 200
    close(fd);
    }
#line 201
    return (-2);
  }
#line 204
  s = buf;
#line 205
  s ++;
#line 205
  res = (int )*((unsigned char *)s + -1) & 255;
#line 207
  if (res != 119) {
#line 208
    if (ei_tracelevel >= 1) {
      {
#line 208
      ei_trace_printf("ei_epmd_r4_port", 1, "<- unknown (%d)", res);
      }
    }
#line 209
    if (ei_tracelevel >= 1) {
      {
#line 209
      ei_trace_printf("ei_epmd_r4_port", 1, "-> CLOSE");
      }
    }
    {
#line 210
    close(fd);
#line 211
    tmp___3 = __erl_errno_place();
#line 211
    *tmp___3 = (int volatile   )5;
    }
#line 212
    return (-1);
  }
#line 218
  s ++;
#line 218
  res = (int )*((unsigned char *)s + -1) & 255;
#line 218
  if (res) {
#line 220
    if (ei_tracelevel >= 1) {
      {
#line 220
      ei_trace_printf("ei_epmd_r4_port", 1, "<- PORT2_RESP result=%d (failure)", res);
      }
    }
    {
#line 221
    close(fd);
#line 222
    tmp___4 = __erl_errno_place();
#line 222
    *tmp___4 = (int volatile   )5;
    }
#line 223
    return (-1);
  }
#line 226
  if (ei_tracelevel >= 3) {
    {
#line 226
    ei_trace_printf("ei_epmd_r4_port", 1, "<- PORT2_RESP result=%d (ok)", res);
    }
  }
  {
#line 229
  res = ei_read_fill_t(fd, buf, 8, ms);
  }
#line 229
  if (res != 8) {
#line 230
    if (ei_tracelevel >= 1) {
      {
#line 230
      ei_trace_printf("ei_epmd_r4_port", 1, "<- CLOSE");
      }
    }
    {
#line 231
    tmp___5 = __erl_errno_place();
    }
#line 231
    if (res == -2) {
#line 231
      *tmp___5 = (int volatile   )110;
    } else {
#line 231
      *tmp___5 = (int volatile   )5;
    }
    {
#line 232
    close(fd);
    }
#line 233
    return (-1);
  }
  {
#line 236
  close(fd);
#line 237
  s = buf;
#line 239
  s += 2;
#line 239
  port = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 240
  s ++;
#line 240
  ntype = (int )*((unsigned char *)s + -1) & 255;
#line 241
  s ++;
#line 241
  proto = (int )*((unsigned char *)s + -1) & 255;
#line 242
  s += 2;
#line 242
  dist_high = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 243
  s += 2;
#line 243
  dist_low = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
  }
#line 245
  if (ei_tracelevel >= 3) {
    {
#line 245
    ei_trace_printf("ei_epmd_r4_port", 1, "   port=%d ntype=%d proto=%d dist-high=%d dist-low=%d",
                    port, ntype, proto, dist_high, dist_low);
    }
  }
#line 250
  if (0 != proto) {
    {
#line 252
    tmp___6 = __erl_errno_place();
#line 252
    *tmp___6 = (int volatile   )5;
    }
#line 253
    return (-1);
  }
#line 257
  if (5 < dist_low) {
    {
#line 259
    tmp___7 = __erl_errno_place();
#line 259
    *tmp___7 = (int volatile   )5;
    }
#line 260
    return (-1);
  } else
#line 257
  if (1 > dist_high) {
    {
#line 259
    tmp___7 = __erl_errno_place();
#line 259
    *tmp___7 = (int volatile   )5;
    }
#line 260
    return (-1);
  }
#line 265
  if (dist_high > 5) {
#line 265
    *dist = 5;
  } else {
#line 265
    *dist = dist_high;
  }
#line 268
  return (port);
}
}
#line 278 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_port.c"
int ei_epmd_port(struct in_addr *addr , char const   *alive , int *dist ) 
{ 
  int tmp ;

  {
  {
#line 280
  tmp = ei_epmd_port_tmo(addr, alive, dist, 0U);
  }
#line 280
  return (tmp);
}
}
#line 283 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/epmd/epmd_port.c"
int ei_epmd_port_tmo(struct in_addr *addr , char const   *alive , int *dist , unsigned int ms ) 
{ 
  int i ;

  {
  {
#line 289
  i = ei_epmd_r4_port(addr, alive, dist, ms);
  }
#line 292
  if (i == -2) {
    {
#line 293
    *dist = 0;
#line 294
    i = ei_epmd_r3_port(addr, alive, ms);
    }
  }
#line 297
  return (i);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_version.c"
int ei_encode_version(char *buf , int *index ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 26
  s = buf + *index;
#line 27
  s0 = s;
#line 29
  if (! buf) {
#line 29
    s ++;
  } else {
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;
#line 30
      *(s + 0) = (char)-125;
#line 30
      s ++;
#line 30
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 31
  *index = (int )((long )*index + (s - s0));
#line 33
  return (0);
}
}
#line 725 "../include/ei.h"
int ei_encode_ulonglong(char *buf , int *index , unsigned long long p ) ;
#line 727
int ei_x_encode_ulonglong(ei_x_buff *x , unsigned long long n ) ;
#line 29 "misc/ei_x_encode.h"
int x_fix_buff(ei_x_buff *x , int szneeded ) ;
#line 34 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_ulonglong.c"
int ei_x_encode_ulonglong(ei_x_buff *x , unsigned long long n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 36
  i = x->index;
#line 37
  ei_encode_ulonglong((char *)((void *)0), & i, n);
#line 38
  tmp = x_fix_buff(x, i);
  }
#line 38
  if (! tmp) {
#line 39
    return (-1);
  }
  {
#line 40
  tmp___0 = ei_encode_ulonglong(x->buff, & x->index, n);
  }
#line 40
  return (tmp___0);
}
}
#line 50 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_ulonglong.c"
int ei_encode_ulonglong(char *buf , int *index , unsigned long long p ) 
{ 
  char *s ;
  char *s0 ;
  char *arityp ;
  int arity ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 52
  s = buf + *index;
#line 53
  s0 = s;
#line 55
  if (p < 256ULL) {
#line 55
    if (p >= 0ULL) {
#line 56
      if (! buf) {
#line 56
        s += 2;
      } else {
        {
#line 58
        while (1) {
          while_continue: /* CIL Label */ ;
#line 58
          *(s + 0) = (char)97;
#line 58
          s ++;
#line 58
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 59
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 59
          *(s + 0) = (char )((p & 255ULL) & 255ULL);
#line 59
          s ++;
#line 59
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 55
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 61
  if (p <= (unsigned long long )((1 << 27) - 1)) {
#line 62
    if (! buf) {
#line 62
      s += 5;
    } else {
      {
#line 64
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 64
        *(s + 0) = (char)98;
#line 64
        s ++;
#line 64
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 65
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 65
        *(s + 0) = (char )((p >> 24) & 255ULL);
#line 65
        *(s + 1) = (char )((p >> 16) & 255ULL);
#line 65
        *(s + 2) = (char )((p >> 8) & 255ULL);
#line 65
        *(s + 3) = (char )(p & 255ULL);
#line 65
        s += 4;
#line 65
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  } else
#line 69
  if (buf) {
#line 71
    arity = 0;
    {
#line 72
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 72
      *(s + 0) = (char)110;
#line 72
      s ++;
#line 72
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 73
    tmp = s;
#line 73
    s ++;
#line 73
    arityp = tmp;
    {
#line 74
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 74
      *(s + 0) = (char)0;
#line 74
      s ++;
#line 74
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 75
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 75
      if (! p) {
#line 75
        goto while_break___5;
      }
#line 76
      tmp___0 = s;
#line 76
      s ++;
#line 76
      *tmp___0 = (char )(p & 255ULL);
#line 77
      p >>= 8;
#line 78
      arity ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 80
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 80
      *(arityp + 0) = (char )(arity & 255);
#line 80
      arityp ++;
#line 80
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 82
    s += 3;
    {
#line 83
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 83
      if (! p) {
#line 83
        goto while_break___7;
      }
#line 84
      s ++;
#line 85
      p >>= 8;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 90
  *index = (int )((long )*index + (s - s0));
#line 92
  return (0);
}
}
#line 405 "../include/ei.h"
int ei_encode_ulong(char *buf , int *index , unsigned long p ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_ulong.c"
int ei_encode_ulong(char *buf , int *index , unsigned long p ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 26
  s = buf + *index;
#line 27
  s0 = s;
#line 29
  if (p > (unsigned long )((1 << 27) - 1)) {
#line 30
    if (! buf) {
#line 30
      s += 7;
    } else {
      {
#line 32
      while (1) {
        while_continue: /* CIL Label */ ;
#line 32
        *(s + 0) = (char)110;
#line 32
        s ++;
#line 32
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 33
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 33
        *(s + 0) = (char)4;
#line 33
        s ++;
#line 33
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 34
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 34
        *(s + 0) = (char)0;
#line 34
        s ++;
#line 34
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 35
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 35
        *(s + 0) = (char )(p & 255UL);
#line 35
        *(s + 1) = (char )((p >> 8) & 255UL);
#line 35
        *(s + 2) = (char )((p >> 16) & 255UL);
#line 35
        *(s + 3) = (char )((p >> 24) & 255UL);
#line 35
        s += 4;
#line 35
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  } else
#line 38
  if (p < 256UL) {
#line 38
    if (p >= 0UL) {
#line 39
      if (! buf) {
#line 39
        s += 2;
      } else {
        {
#line 41
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 41
          *(s + 0) = (char)97;
#line 41
          s ++;
#line 41
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 42
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 42
          *(s + 0) = (char )((p & 255UL) & 255UL);
#line 42
          s ++;
#line 42
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else {
#line 38
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 46
  if (! buf) {
#line 46
    s += 5;
  } else {
    {
#line 48
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 48
      *(s + 0) = (char)98;
#line 48
      s ++;
#line 48
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 49
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 49
      *(s + 0) = (char )((p >> 24) & 255UL);
#line 49
      *(s + 1) = (char )((p >> 16) & 255UL);
#line 49
      *(s + 2) = (char )((p >> 8) & 255UL);
#line 49
      *(s + 3) = (char )(p & 255UL);
#line 49
      s += 4;
#line 49
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 53
  *index = (int )((long )*index + (s - s0));
#line 55
  return (0);
}
}
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_tuple_header.c"
int ei_encode_tuple_header(char *buf , int *index , int arity ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 25
  s = buf + *index;
#line 26
  s0 = s;
#line 28
  if (arity < 0) {
#line 28
    return (-1);
  }
#line 30
  if (arity <= 255) {
#line 31
    if (! buf) {
#line 31
      s += 2;
    } else {
      {
#line 33
      while (1) {
        while_continue: /* CIL Label */ ;
#line 33
        *(s + 0) = (char)104;
#line 33
        s ++;
#line 33
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 34
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 34
        *(s + 0) = (char )(arity & 255);
#line 34
        s ++;
#line 34
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 38
  if (! buf) {
#line 38
    s += 5;
  } else {
    {
#line 40
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 40
      *(s + 0) = (char)105;
#line 40
      s ++;
#line 40
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 41
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 41
      *(s + 0) = (char )((arity >> 24) & 255);
#line 41
      *(s + 1) = (char )((arity >> 16) & 255);
#line 41
      *(s + 2) = (char )((arity >> 8) & 255);
#line 41
      *(s + 3) = (char )(arity & 255);
#line 41
      s += 4;
#line 41
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 45
  *index = (int )((long )*index + (s - s0));
#line 47
  return (0);
}
}
#line 22 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_trace.c"
int ei_encode_trace(char *buf , int *index , erlang_trace const   *p ) 
{ 


  {
  {
#line 25
  ei_encode_tuple_header(buf, index, 5);
#line 26
  ei_encode_long(buf, index, (long )p->flags);
#line 27
  ei_encode_long(buf, index, (long )p->label);
#line 28
  ei_encode_long(buf, index, (long )p->serial);
#line 29
  ei_encode_pid(buf, index, & p->from);
#line 30
  ei_encode_long(buf, index, (long )p->prev);
  }
#line 34
  return (0);
}
}
#line 414 "../include/ei.h"
int ei_encode_string_len(char *buf , int *index___0 , char const   *p , int len ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_string.c"
int ei_encode_string(char *buf , int *index___0 , char const   *p ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = strlen(p);
#line 27
  tmp___0 = ei_encode_string_len(buf, index___0, p, (int )tmp);
  }
#line 27
  return (tmp___0);
}
}
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_string.c"
int ei_encode_string_len(char *buf , int *index___0 , char const   *p , int len ) 
{ 
  char *s ;
  char *s0 ;
  int i ;

  {
#line 32
  s = buf + *index___0;
#line 33
  s0 = s;
#line 36
  if (len == 0) {
#line 38
    if (! buf) {
#line 39
      s ++;
    } else {
      {
#line 41
      while (1) {
        while_continue: /* CIL Label */ ;
#line 41
        *(s + 0) = (char)106;
#line 41
        s ++;
#line 41
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 44
  if (len <= 65535) {
#line 46
    if (! buf) {
#line 47
      s += 3;
    } else {
      {
#line 49
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 49
        *(s + 0) = (char)107;
#line 49
        s ++;
#line 49
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 50
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 50
        *(s + 0) = (char )((len >> 8) & 255);
#line 50
        *(s + 1) = (char )(len & 255);
#line 50
        s += 2;
#line 50
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 51
      memmove((void *)s, (void const   *)p, (size_t )len);
      }
    }
#line 53
    s += len;
  } else
#line 57
  if (! buf) {
#line 58
    s += (5 + 2 * len) + 1;
  } else {
    {
#line 61
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 61
      *(s + 0) = (char)108;
#line 61
      s ++;
#line 61
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 62
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 62
      *(s + 0) = (char )((len >> 24) & 255);
#line 62
      *(s + 1) = (char )((len >> 16) & 255);
#line 62
      *(s + 2) = (char )((len >> 8) & 255);
#line 62
      *(s + 3) = (char )(len & 255);
#line 62
      s += 4;
#line 62
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 64
    i = 0;
    {
#line 64
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 64
      if (! (i < len)) {
#line 64
        goto while_break___4;
      }
      {
#line 65
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 65
        *(s + 0) = (char)97;
#line 65
        s ++;
#line 65
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 66
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 66
        *(s + 0) = (char )((int const   )*(p + i) & 255);
#line 66
        s ++;
#line 66
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 64
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 68
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 68
      *(s + 0) = (char)106;
#line 68
      s ++;
#line 68
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 73
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 75
  return (0);
}
}
#line 429 "../include/ei.h"
int ei_encode_ref(char *buf , int *index___0 , erlang_ref const   *p ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_ref.c"
int ei_encode_ref(char *buf , int *index___0 , erlang_ref const   *p ) 
{ 
  char *s ;
  char *s0 ;
  int len ;
  size_t tmp ;
  int i ;

  {
  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 28
  tmp = strlen((char const   *)(p->node));
#line 28
  len = (int )tmp;
  }
#line 33
  if (! buf) {
#line 33
    s += ((3 + (3 + len)) + (int )(p->len * 4)) + 1;
  } else {
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      *(s + 0) = (char)114;
#line 35
      s ++;
#line 35
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 38
      *(s + 0) = (char )((p->len >> 8) & 255);
#line 38
      *(s + 1) = (char )(p->len & 255);
#line 38
      s += 2;
#line 38
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 41
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 41
      *(s + 0) = (char)100;
#line 41
      s ++;
#line 41
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 43
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 43
      *(s + 0) = (char )((len >> 8) & 255);
#line 43
      *(s + 1) = (char )(len & 255);
#line 43
      s += 2;
#line 43
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 45
    memmove((void *)s, (void const   *)(p->node), (size_t )len);
#line 46
    s += len;
    }
    {
#line 49
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 49
      *(s + 0) = (char )((p->creation & 3U) & 255U);
#line 49
      s ++;
#line 49
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 50
    i = 0;
    {
#line 50
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 50
      if (! (i < (int )p->len)) {
#line 50
        goto while_break___4;
      }
      {
#line 51
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 51
        *(s + 0) = (char )((p->n[i] >> 24) & 255U);
#line 51
        *(s + 1) = (char )((p->n[i] >> 16) & 255U);
#line 51
        *(s + 2) = (char )((p->n[i] >> 8) & 255U);
#line 51
        *(s + 3) = (char )(p->n[i] & 255U);
#line 51
        s += 4;
#line 51
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 50
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 55
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 57
  return (0);
}
}
#line 427 "../include/ei.h"
int ei_encode_port(char *buf , int *index___0 , erlang_port const   *p ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_port.c"
int ei_encode_port(char *buf , int *index___0 , erlang_port const   *p ) 
{ 
  char *s ;
  char *s0 ;
  int len ;
  size_t tmp ;

  {
  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 28
  tmp = strlen((char const   *)(p->node));
#line 28
  len = (int )tmp;
  }
#line 30
  if (! buf) {
#line 30
    s += 9 + len;
  } else {
    {
#line 32
    while (1) {
      while_continue: /* CIL Label */ ;
#line 32
      *(s + 0) = (char)102;
#line 32
      s ++;
#line 32
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 35
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 35
      *(s + 0) = (char)100;
#line 35
      s ++;
#line 35
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 37
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 37
      *(s + 0) = (char )((len >> 8) & 255);
#line 37
      *(s + 1) = (char )(len & 255);
#line 37
      s += 2;
#line 37
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 39
    memmove((void *)s, (void const   *)(p->node), (size_t )len);
#line 40
    s += len;
    }
    {
#line 43
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 43
      *(s + 0) = (char )(((p->id & 268435455U) >> 24) & 255U);
#line 43
      *(s + 1) = (char )(((p->id & 268435455U) >> 16) & 255U);
#line 43
      *(s + 2) = (char )(((p->id & 268435455U) >> 8) & 255U);
#line 43
      *(s + 3) = (char )((p->id & 268435455U) & 255U);
#line 43
      s += 4;
#line 43
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 44
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 44
      *(s + 0) = (char )((p->creation & 3U) & 255U);
#line 44
      s ++;
#line 44
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 47
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 49
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_pid.c"
int ei_encode_pid(char *buf , int *index___0 , erlang_pid const   *p ) 
{ 
  char *s ;
  char *s0 ;
  int len ;
  size_t tmp ;

  {
  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 28
  tmp = strlen((char const   *)(p->node));
#line 28
  len = (int )tmp;
  }
#line 30
  if (! buf) {
#line 30
    s += 13 + len;
  } else {
    {
#line 32
    while (1) {
      while_continue: /* CIL Label */ ;
#line 32
      *(s + 0) = (char)103;
#line 32
      s ++;
#line 32
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 35
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 35
      *(s + 0) = (char)100;
#line 35
      s ++;
#line 35
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 37
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 37
      *(s + 0) = (char )((len >> 8) & 255);
#line 37
      *(s + 1) = (char )(len & 255);
#line 37
      s += 2;
#line 37
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 39
    memmove((void *)s, (void const   *)(p->node), (size_t )len);
#line 40
    s += len;
    }
    {
#line 43
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 43
      *(s + 0) = (char )(((p->num & 32767U) >> 24) & 255U);
#line 43
      *(s + 1) = (char )(((p->num & 32767U) >> 16) & 255U);
#line 43
      *(s + 2) = (char )(((p->num & 32767U) >> 8) & 255U);
#line 43
      *(s + 3) = (char )((p->num & 32767U) & 255U);
#line 43
      s += 4;
#line 43
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 44
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 44
      *(s + 0) = (char )(((p->serial & 8191U) >> 24) & 255U);
#line 44
      *(s + 1) = (char )(((p->serial & 8191U) >> 16) & 255U);
#line 44
      *(s + 2) = (char )(((p->serial & 8191U) >> 8) & 255U);
#line 44
      *(s + 3) = (char )((p->serial & 8191U) & 255U);
#line 44
      s += 4;
#line 44
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 45
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 45
      *(s + 0) = (char )((p->creation & 3U) & 255U);
#line 45
      s ++;
#line 45
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 48
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 50
  return (0);
}
}
#line 724 "../include/ei.h"
int ei_encode_longlong(char *buf , int *index , long long p ) ;
#line 726
int ei_x_encode_longlong(ei_x_buff *x , long long n ) ;
#line 39 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_longlong.c"
int ei_x_encode_longlong(ei_x_buff *x , long long n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 41
  i = x->index;
#line 42
  ei_encode_longlong((char *)((void *)0), & i, n);
#line 43
  tmp = x_fix_buff(x, i);
  }
#line 43
  if (! tmp) {
#line 44
    return (-1);
  }
  {
#line 45
  tmp___0 = ei_encode_longlong(x->buff, & x->index, n);
  }
#line 45
  return (tmp___0);
}
}
#line 55 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_longlong.c"
int ei_encode_longlong(char *buf , int *index , long long p ) 
{ 
  char *s ;
  char *s0 ;
  unsigned long long up ;
  long long tmp ;
  char *arityp ;
  int arity ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 57
  s = buf + *index;
#line 58
  s0 = s;
#line 60
  if (p < 256LL) {
#line 60
    if (p >= 0LL) {
#line 61
      if (! buf) {
#line 61
        s += 2;
      } else {
        {
#line 63
        while (1) {
          while_continue: /* CIL Label */ ;
#line 63
          *(s + 0) = (char)97;
#line 63
          s ++;
#line 63
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 64
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 64
          *(s + 0) = (char )((p & 255LL) & 255LL);
#line 64
          s ++;
#line 64
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 60
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 66
  if (p <= (long long )((1 << 27) - 1)) {
#line 66
    if (p >= (long long )(- (1 << 27))) {
#line 69
      if (! buf) {
#line 69
        s += 5;
      } else {
        {
#line 71
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 71
          *(s + 0) = (char)98;
#line 71
          s ++;
#line 71
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 72
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 72
          *(s + 0) = (char )((p >> 24) & 255LL);
#line 72
          *(s + 1) = (char )((p >> 16) & 255LL);
#line 72
          *(s + 2) = (char )((p >> 8) & 255LL);
#line 72
          *(s + 3) = (char )(p & 255LL);
#line 72
          s += 4;
#line 72
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 66
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 76
    if (p < 0LL) {
#line 76
      tmp = - p;
    } else {
#line 76
      tmp = p;
    }
#line 76
    up = (unsigned long long )tmp;
#line 77
    if (buf) {
#line 79
      arity = 0;
      {
#line 81
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 81
        *(s + 0) = (char)110;
#line 81
        s ++;
#line 81
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 82
      tmp___0 = s;
#line 82
      s ++;
#line 82
      arityp = tmp___0;
      {
#line 83
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 83
        *(s + 0) = (char )((p < 0LL) & 255);
#line 83
        s ++;
#line 83
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 84
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 84
        if (! up) {
#line 84
          goto while_break___5;
        }
#line 85
        tmp___1 = s;
#line 85
        s ++;
#line 85
        *tmp___1 = (char )(up & 255ULL);
#line 86
        up >>= 8;
#line 87
        arity ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 89
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 89
        *(arityp + 0) = (char )(arity & 255);
#line 89
        arityp ++;
#line 89
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 91
      s += 3;
      {
#line 92
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 92
        if (! up) {
#line 92
          goto while_break___7;
        }
#line 93
        s ++;
#line 94
        up >>= 8;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
#line 99
  *index = (int )((long )*index + (s - s0));
#line 101
  return (0);
}
}
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_long.c"
int ei_encode_long(char *buf , int *index , long p ) 
{ 
  char *s ;
  char *s0 ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 31
  s = buf + *index;
#line 32
  s0 = s;
#line 34
  if (p < 256L) {
#line 34
    if (p >= 0L) {
#line 35
      if (! buf) {
#line 35
        s += 2;
      } else {
        {
#line 37
        while (1) {
          while_continue: /* CIL Label */ ;
#line 37
          *(s + 0) = (char)97;
#line 37
          s ++;
#line 37
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 38
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 38
          *(s + 0) = (char )((p & 255L) & 255L);
#line 38
          s ++;
#line 38
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 34
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 41
  if (p <= (long )((1 << 27) - 1)) {
#line 41
    if (p >= (long )(- (1 << 27))) {
#line 44
      if (! buf) {
#line 44
        s += 5;
      } else {
        {
#line 46
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 46
          *(s + 0) = (char)98;
#line 46
          s ++;
#line 46
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 47
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 47
          *(s + 0) = (char )((p >> 24) & 255L);
#line 47
          *(s + 1) = (char )((p >> 16) & 255L);
#line 47
          *(s + 2) = (char )((p >> 8) & 255L);
#line 47
          *(s + 3) = (char )(p & 255L);
#line 47
          s += 4;
#line 47
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 51
  if (! buf) {
#line 51
    s += 7;
  } else {
    {
#line 53
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 53
      *(s + 0) = (char)110;
#line 53
      s ++;
#line 53
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 54
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 54
      *(s + 0) = (char)4;
#line 54
      s ++;
#line 54
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 55
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 55
      *(s + 0) = (char )((p < 0L) & 255);
#line 55
      s ++;
#line 55
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 56
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 56
      if (p < 0L) {
#line 56
        tmp = - p;
      } else {
#line 56
        tmp = p;
      }
#line 56
      *(s + 0) = (char )(tmp & 255L);
#line 56
      if (p < 0L) {
#line 56
        tmp___0 = - p;
      } else {
#line 56
        tmp___0 = p;
      }
#line 56
      *(s + 1) = (char )((tmp___0 >> 8) & 255L);
#line 56
      if (p < 0L) {
#line 56
        tmp___1 = - p;
      } else {
#line 56
        tmp___1 = p;
      }
#line 56
      *(s + 2) = (char )((tmp___1 >> 16) & 255L);
#line 56
      if (p < 0L) {
#line 56
        tmp___2 = - p;
      } else {
#line 56
        tmp___2 = p;
      }
#line 56
      *(s + 3) = (char )((tmp___2 >> 24) & 255L);
#line 56
      s += 4;
#line 56
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 60
  *index = (int )((long )*index + (s - s0));
#line 62
  return (0);
}
}
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_list_header.c"
int ei_encode_list_header(char *buf , int *index , int arity ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 25
  s = buf + *index;
#line 26
  s0 = s;
#line 28
  if (arity < 0) {
#line 28
    return (-1);
  } else
#line 29
  if (arity > 0) {
#line 30
    if (! buf) {
#line 30
      s += 5;
    } else {
      {
#line 32
      while (1) {
        while_continue: /* CIL Label */ ;
#line 32
        *(s + 0) = (char)108;
#line 32
        s ++;
#line 32
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 33
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 33
        *(s + 0) = (char )((arity >> 24) & 255);
#line 33
        *(s + 1) = (char )((arity >> 16) & 255);
#line 33
        *(s + 2) = (char )((arity >> 8) & 255);
#line 33
        *(s + 3) = (char )(arity & 255);
#line 33
        s += 4;
#line 33
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 38
  if (! buf) {
#line 38
    s ++;
  } else {
    {
#line 39
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 39
      *(s + 0) = (char)106;
#line 39
      s ++;
#line 39
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 42
  *index = (int )((long )*index + (s - s0));
#line 44
  return (0);
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 425 "../include/ei.h"
int ei_encode_fun(char *buf , int *index___0 , erlang_fun const   *p ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_fun.c"
int ei_encode_fun(char *buf , int *index___0 , erlang_fun const   *p ) 
{ 
  int ix ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *size_p ;
  char *s___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int sz ;

  {
#line 26
  ix = *index___0;
#line 28
  if (p->arity == -1L) {
#line 30
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 31
      s = buf + ix;
      {
#line 32
      while (1) {
        while_continue: /* CIL Label */ ;
#line 32
        *(s + 0) = (char)117;
#line 32
        s ++;
#line 32
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 33
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 33
        *(s + 0) = (char )((p->n_free_vars >> 24) & 255L);
#line 33
        *(s + 1) = (char )((p->n_free_vars >> 16) & 255L);
#line 33
        *(s + 2) = (char )((p->n_free_vars >> 8) & 255L);
#line 33
        *(s + 3) = (char )(p->n_free_vars & 255L);
#line 33
        s += 4;
#line 33
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 35
    ix = (int )((unsigned long )ix + (sizeof(char ) + 4UL));
#line 36
    tmp = ei_encode_pid(buf, & ix, & p->pid);
    }
#line 36
    if (tmp < 0) {
#line 37
      return (-1);
    }
    {
#line 38
    tmp___0 = ei_encode_atom(buf, & ix, (char const   *)(p->module));
    }
#line 38
    if (tmp___0 < 0) {
#line 39
      return (-1);
    }
    {
#line 40
    tmp___1 = ei_encode_long(buf, & ix, (long )p->index);
    }
#line 40
    if (tmp___1 < 0) {
#line 41
      return (-1);
    }
    {
#line 42
    tmp___2 = ei_encode_long(buf, & ix, (long )p->uniq);
    }
#line 42
    if (tmp___2 < 0) {
#line 43
      return (-1);
    }
#line 44
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 45
      memcpy((void */* __restrict  */)(buf + ix), (void const   */* __restrict  */)p->free_vars,
             (size_t )p->free_var_len);
      }
    }
#line 46
    ix = (int )((long const   )ix + p->free_var_len);
  } else {
#line 50
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 51
      s___0 = buf + ix;
      {
#line 52
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 52
        *(s___0 + 0) = (char)112;
#line 52
        s___0 ++;
#line 52
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 53
      size_p = s___0;
#line 54
      s___0 += 4;
      {
#line 55
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 55
        *(s___0 + 0) = (char )(p->arity & 255L);
#line 55
        s___0 ++;
#line 55
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 56
      memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)(p->md5),
             (size_t )sizeof(p->md5));
#line 57
      s___0 += sizeof(p->md5);
      }
      {
#line 58
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 58
        *(s___0 + 0) = (char )((p->index >> 24) & 255L);
#line 58
        *(s___0 + 1) = (char )((p->index >> 16) & 255L);
#line 58
        *(s___0 + 2) = (char )((p->index >> 8) & 255L);
#line 58
        *(s___0 + 3) = (char )(p->index & 255L);
#line 58
        s___0 += 4;
#line 58
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 59
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 59
        *(s___0 + 0) = (char )((p->n_free_vars >> 24) & 255L);
#line 59
        *(s___0 + 1) = (char )((p->n_free_vars >> 16) & 255L);
#line 59
        *(s___0 + 2) = (char )((p->n_free_vars >> 8) & 255L);
#line 59
        *(s___0 + 3) = (char )(p->n_free_vars & 255L);
#line 59
        s___0 += 4;
#line 59
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 61
      size_p = (char *)((void *)0);
    }
    {
#line 62
    ix = (int )((unsigned long )ix + (((6UL + sizeof(p->md5)) + 4UL) + 4UL));
#line 63
    tmp___3 = ei_encode_atom(buf, & ix, (char const   *)(p->module));
    }
#line 63
    if (tmp___3 < 0) {
#line 64
      return (-1);
    }
    {
#line 65
    tmp___4 = ei_encode_long(buf, & ix, (long )p->old_index);
    }
#line 65
    if (tmp___4 < 0) {
#line 66
      return (-1);
    }
    {
#line 67
    tmp___5 = ei_encode_long(buf, & ix, (long )p->uniq);
    }
#line 67
    if (tmp___5 < 0) {
#line 68
      return (-1);
    }
    {
#line 69
    tmp___6 = ei_encode_pid(buf, & ix, & p->pid);
    }
#line 69
    if (tmp___6 < 0) {
#line 70
      return (-1);
    }
#line 71
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      {
#line 72
      memcpy((void */* __restrict  */)(buf + ix), (void const   */* __restrict  */)p->free_vars,
             (size_t )p->free_var_len);
      }
    }
#line 73
    ix = (int )((long const   )ix + p->free_var_len);
#line 74
    if ((unsigned long )size_p != (unsigned long )((void *)0)) {
#line 75
      sz = (int )((buf + ix) - size_p);
      {
#line 76
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 76
        *(size_p + 0) = (char )((sz >> 24) & 255);
#line 76
        *(size_p + 1) = (char )((sz >> 16) & 255);
#line 76
        *(size_p + 2) = (char )((sz >> 8) & 255);
#line 76
        *(size_p + 3) = (char )(sz & 255);
#line 76
        size_p += 4;
#line 76
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 79
  *index___0 = ix;
#line 80
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_double.c"
int ei_encode_double(char *buf , int *index___0 , double p ) 
{ 
  char *s ;
  char *s0 ;
  char *__cil_tmp6 ;

  {
#line 27
  s = buf + *index___0;
#line 28
  s0 = s;
#line 30
  if (! buf) {
#line 30
    s ++;
  } else {
    {
#line 32
    while (1) {
      while_continue: /* CIL Label */ ;
#line 32
      *(s + 0) = (char)99;
#line 32
      s ++;
#line 32
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 33
    memset((void *)s, 0, (size_t )31);
#line 34
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%.20e",
            p);
    }
  }
#line 36
  s += 31;
#line 38
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 40
  return (0);
}
}
#line 411 "../include/ei.h"
int ei_encode_char(char *buf , int *index , char p ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_char.c"
int ei_encode_char(char *buf , int *index , char p ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 25
  s = buf + *index;
#line 26
  s0 = s;
#line 28
  if (! buf) {
#line 28
    s += 2;
  } else {
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;
#line 30
      *(s + 0) = (char)97;
#line 30
      s ++;
#line 30
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 31
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 31
      *(s + 0) = (char )(((int )p & 255) & 255);
#line 31
      s ++;
#line 31
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 34
  *index = (int )((long )*index + (s - s0));
#line 36
  return (0);
}
}
#line 409 "../include/ei.h"
int ei_encode_boolean(char *buf , int *index___0 , int p ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_boolean.c"
int ei_encode_boolean(char *buf , int *index___0 , int p ) 
{ 
  char *s ;
  char *s0 ;
  char *val ;
  int len ;
  size_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 31
  if (p) {
#line 31
    val = (char *)"true";
  } else {
#line 31
    val = (char *)"false";
  }
  {
#line 32
  tmp = strlen((char const   *)val);
#line 32
  len = (int )tmp;
  }
#line 34
  if (! buf) {
#line 34
    s += 3;
  } else {
    {
#line 36
    while (1) {
      while_continue: /* CIL Label */ ;
#line 36
      *(s + 0) = (char)100;
#line 36
      s ++;
#line 36
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 37
      *(s + 0) = (char )((len >> 8) & 255);
#line 37
      *(s + 1) = (char )(len & 255);
#line 37
      s += 2;
#line 37
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 39
    memmove((void *)s, (void const   *)val, (size_t )len);
    }
  }
#line 41
  s += len;
#line 43
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 45
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_binary.c"
int ei_encode_binary(char *buf , int *index___0 , void const   *p , long len ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 29
  if (! buf) {
#line 29
    s += 5;
  } else {
    {
#line 31
    while (1) {
      while_continue: /* CIL Label */ ;
#line 31
      *(s + 0) = (char)109;
#line 31
      s ++;
#line 31
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 32
      *(s + 0) = (char )((len >> 24) & 255L);
#line 32
      *(s + 1) = (char )((len >> 16) & 255L);
#line 32
      *(s + 2) = (char )((len >> 8) & 255L);
#line 32
      *(s + 3) = (char )(len & 255L);
#line 32
      s += 4;
#line 32
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 33
    memmove((void *)s, p, (size_t )len);
    }
  }
#line 35
  s += len;
#line 37
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 39
  return (0);
}
}
#line 770 "../include/ei.h"
int ei_encode_big(char *buf , int *index___0 , erlang_big *big ) ;
#line 771
int ei_x_encode_big(ei_x_buff *x , erlang_big *big ) ;
#line 26 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_big.c"
int ei_encode_big(char *buf , int *index___0 , erlang_big *big ) 
{ 
  unsigned char *s ;
  unsigned char *s0 ;
  unsigned int digit_bytes ;
  unsigned int n ;
  int i ;
  unsigned char hi ;
  unsigned char lo ;
  unsigned short *dt ;

  {
#line 27
  s = (unsigned char *)buf + *index___0;
#line 28
  s0 = s;
#line 29
  digit_bytes = big->arity;
#line 30
  n = (digit_bytes + 1U) / 2U;
#line 32
  if (digit_bytes < 256U) {
#line 33
    if (buf) {
      {
#line 34
      while (1) {
        while_continue: /* CIL Label */ ;
#line 34
        *(s + 0) = (unsigned char)110;
#line 34
        s ++;
#line 34
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 35
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 35
        *(s + 0) = (unsigned char )((char )(digit_bytes & 255U));
#line 35
        s ++;
#line 35
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 37
      s += 2;
    }
  } else
#line 40
  if (buf) {
    {
#line 41
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 41
      *(s + 0) = (unsigned char)111;
#line 41
      s ++;
#line 41
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 42
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 42
      *(s + 0) = (unsigned char )((digit_bytes >> 24) & 255U);
#line 42
      *(s + 1) = (unsigned char )((digit_bytes >> 16) & 255U);
#line 42
      *(s + 2) = (unsigned char )((digit_bytes >> 8) & 255U);
#line 42
      *(s + 3) = (unsigned char )(digit_bytes & 255U);
#line 42
      s += 4;
#line 42
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 44
    s += 5;
  }
#line 48
  if (buf) {
#line 51
    dt = (unsigned short *)big->digits;
    {
#line 52
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 52
      *(s + 0) = (unsigned char )((char )(big->is_neg & 255));
#line 52
      s ++;
#line 52
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 54
    i = 0;
    {
#line 54
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 54
      if (! ((unsigned int )i < n)) {
#line 54
        goto while_break___4;
      }
#line 56
      hi = (unsigned char )((int )*(dt + i) >> 8);
#line 57
      lo = (unsigned char )*(dt + i);
#line 59
      *(s + i * 2) = lo;
#line 60
      if ((unsigned int )(i * 2 + 1) < digit_bytes) {
#line 61
        *(s + (i * 2 + 1)) = hi;
      }
#line 54
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 66
    s ++;
  }
#line 69
  s += digit_bytes;
#line 71
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 73
  return (0);
}
}
#line 76 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_big.c"
int ei_x_encode_big(ei_x_buff *x , erlang_big *big ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 77
  i = x->index;
#line 79
  ei_encode_big((char *)((void *)0), & i, big);
#line 80
  tmp = x_fix_buff(x, i);
  }
#line 80
  if (! tmp) {
#line 81
    return (-1);
  }
  {
#line 82
  tmp___0 = ei_encode_big(x->buff, & x->index, big);
  }
#line 82
  return (tmp___0);
}
}
#line 418 "../include/ei.h"
int ei_encode_atom_len(char *buf , int *index___0 , char const   *p , int len ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_atom.c"
int ei_encode_atom(char *buf , int *index___0 , char const   *p ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 26
  tmp = strlen(p);
#line 26
  tmp___0 = ei_encode_atom_len(buf, index___0, p, (int )tmp);
  }
#line 26
  return (tmp___0);
}
}
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/encode/encode_atom.c"
int ei_encode_atom_len(char *buf , int *index___0 , char const   *p , int len ) 
{ 
  char *s ;
  char *s0 ;

  {
#line 31
  s = buf + *index___0;
#line 32
  s0 = s;
#line 35
  if (len > 255) {
#line 36
    len = 255;
  }
#line 38
  if (! buf) {
#line 38
    s += 3;
  } else {
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      *(s + 0) = (char)100;
#line 40
      s ++;
#line 40
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 41
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 41
      *(s + 0) = (char )((len >> 8) & 255);
#line 41
      *(s + 1) = (char )(len & 255);
#line 41
      s += 2;
#line 41
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 43
    memmove((void *)s, (void const   *)p, (size_t )len);
    }
  }
#line 45
  s += len;
#line 47
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 49
  return (0);
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 747 "../include/ei.h"
int ei_receive_encoded(int fd , char **mbufp , int *bufsz , erlang_msg *msg , int *msglen ) ;
#line 749
int ei_receive_encoded_tmo(int fd , char **mbufp , int *bufsz , erlang_msg *msg ,
                           int *msglen , unsigned int ms ) ;
#line 46 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/eirecv.c"
int ei_recv_internal(int fd , char **mbufp , int *bufsz , erlang_msg *msg , int *msglenp ,
                     int staticbufp , unsigned int ms ) 
{ 
  char header[2048] ;
  char *s ;
  char *mbuf ;
  int len ;
  int msglen ;
  int bytesread ;
  int remain ;
  int arity ;
  int version ;
  int index___0 ;
  int i ;
  int res ;
  int show_this_msg ;
  int volatile   *tmp ;
  char tock[4] ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int volatile   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int volatile   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int volatile   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int volatile   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int volatile   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int volatile   *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int volatile   *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int sz ;
  int volatile   *tmp___31 ;
  int volatile   *tmp___32 ;
  void *tmp___33 ;
  int volatile   *tmp___34 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;

  {
  {
#line 53
  s = header;
#line 54
  mbuf = *mbufp;
#line 55
  len = 0;
#line 56
  msglen = 0;
#line 57
  bytesread = 0;
#line 61
  index___0 = 0;
#line 62
  i = 0;
#line 64
  show_this_msg = 0;
#line 67
  res = ei_read_fill_t(fd, header, 4, ms);
  }
#line 67
  if (res != 4) {
    {
#line 69
    tmp = __erl_errno_place();
    }
#line 69
    if (res == -2) {
#line 69
      *tmp = (int volatile   )110;
    } else {
#line 69
      *tmp = (int volatile   )5;
    }
#line 70
    return (-1);
  }
#line 72
  s += 4;
#line 72
  len = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 75
  if (! len) {
    {
#line 76
    tock[0] = (char)0;
#line 76
    tock[1] = (char)0;
#line 76
    tock[2] = (char)0;
#line 76
    tock[3] = (char)0;
#line 77
    ei_write_fill_t(fd, (char const   *)(tock), (int )sizeof(tock), ms);
#line 78
    *msglenp = 0;
    }
#line 79
    return (0);
  }
  {
#line 85
  ei_trace(-1, (erlang_trace *)((void *)0));
  }
#line 88
  if (len > 2048) {
#line 88
    bytesread = 2048;
  } else {
#line 88
    bytesread = len;
  }
  {
#line 89
  i = ei_read_fill_t(fd, header, bytesread, ms);
  }
#line 89
  if (i != bytesread) {
    {
#line 90
    tmp___0 = __erl_errno_place();
    }
#line 90
    if (i == -2) {
#line 90
      *tmp___0 = (int volatile   )110;
    } else {
#line 90
      *tmp___0 = (int volatile   )5;
    }
#line 91
    return (-1);
  }
#line 96
  s = header;
#line 97
  index___0 = 1;
#line 98
  s ++;
#line 98
  if (((int )*((unsigned char *)s + -1) & 255) != 112) {
    {
#line 104
    tmp___1 = __erl_errno_place();
#line 104
    *tmp___1 = (int volatile   )5;
    }
#line 105
    return (-1);
  } else {
    {
#line 98
    tmp___2 = ei_decode_version((char const   *)(header), & index___0, & version);
    }
#line 98
    if (tmp___2) {
      {
#line 104
      tmp___1 = __erl_errno_place();
#line 104
      *tmp___1 = (int volatile   )5;
      }
#line 105
      return (-1);
    } else
#line 98
    if (version != 131) {
      {
#line 104
      tmp___1 = __erl_errno_place();
#line 104
      *tmp___1 = (int volatile   )5;
      }
#line 105
      return (-1);
    } else {
      {
#line 98
      tmp___3 = ei_decode_tuple_header((char const   *)(header), & index___0, & arity);
      }
#line 98
      if (tmp___3) {
        {
#line 104
        tmp___1 = __erl_errno_place();
#line 104
        *tmp___1 = (int volatile   )5;
        }
#line 105
        return (-1);
      } else {
        {
#line 98
        tmp___4 = ei_decode_long((char const   *)(header), & index___0, & msg->msgtype);
        }
#line 98
        if (tmp___4) {
          {
#line 104
          tmp___1 = __erl_errno_place();
#line 104
          *tmp___1 = (int volatile   )5;
          }
#line 105
          return (-1);
        }
      }
    }
  }
  {
#line 109
  if (msg->msgtype == 2L) {
#line 109
    goto case_2;
  }
#line 120
  if (msg->msgtype == 6L) {
#line 120
    goto case_6;
  }
#line 135
  if (msg->msgtype == 7L) {
#line 135
    goto case_7;
  }
#line 135
  if (msg->msgtype == 4L) {
#line 135
    goto case_7;
  }
#line 135
  if (msg->msgtype == 1L) {
#line 135
    goto case_7;
  }
#line 147
  if (msg->msgtype == 8L) {
#line 147
    goto case_8;
  }
#line 147
  if (msg->msgtype == 3L) {
#line 147
    goto case_8;
  }
#line 158
  if (msg->msgtype == 12L) {
#line 158
    goto case_12;
  }
#line 171
  if (msg->msgtype == 16L) {
#line 171
    goto case_16;
  }
#line 186
  if (msg->msgtype == 18L) {
#line 186
    goto case_18;
  }
#line 186
  if (msg->msgtype == 13L) {
#line 186
    goto case_18;
  }
#line 199
  if (msg->msgtype == 5L) {
#line 199
    goto case_5;
  }
#line 203
  goto switch_default;
  case_2: /* CIL Label */ 
#line 110
  if (ei_tracelevel > 0) {
#line 110
    show_this_msg = 1;
  }
  {
#line 111
  tmp___6 = ei_decode_atom((char const   *)(header), & index___0, msg->cookie);
  }
#line 111
  if (tmp___6) {
    {
#line 114
    tmp___5 = __erl_errno_place();
#line 114
    *tmp___5 = (int volatile   )5;
    }
#line 115
    return (-1);
  } else {
    {
#line 111
    tmp___7 = ei_decode_pid((char const   *)(header), & index___0, & msg->to);
    }
#line 111
    if (tmp___7) {
      {
#line 114
      tmp___5 = __erl_errno_place();
#line 114
      *tmp___5 = (int volatile   )5;
      }
#line 115
      return (-1);
    }
  }
#line 118
  goto switch_break;
  case_6: /* CIL Label */ 
#line 121
  if (ei_tracelevel > 0) {
#line 121
    show_this_msg = 1;
  }
  {
#line 122
  tmp___9 = ei_decode_pid((char const   *)(header), & index___0, & msg->from);
  }
#line 122
  if (tmp___9) {
    {
#line 126
    tmp___8 = __erl_errno_place();
#line 126
    *tmp___8 = (int volatile   )5;
    }
#line 127
    return (-1);
  } else {
    {
#line 122
    tmp___10 = ei_decode_atom((char const   *)(header), & index___0, msg->cookie);
    }
#line 122
    if (tmp___10) {
      {
#line 126
      tmp___8 = __erl_errno_place();
#line 126
      *tmp___8 = (int volatile   )5;
      }
#line 127
      return (-1);
    } else {
      {
#line 122
      tmp___11 = ei_decode_atom((char const   *)(header), & index___0, msg->toname);
      }
#line 122
      if (tmp___11) {
        {
#line 126
        tmp___8 = __erl_errno_place();
#line 126
        *tmp___8 = (int volatile   )5;
        }
#line 127
        return (-1);
      }
    }
  }
#line 131
  goto switch_break;
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 136
  if (ei_tracelevel > 1) {
#line 136
    show_this_msg = 1;
  }
  {
#line 137
  tmp___13 = ei_decode_pid((char const   *)(header), & index___0, & msg->from);
  }
#line 137
  if (tmp___13) {
    {
#line 140
    tmp___12 = __erl_errno_place();
#line 140
    *tmp___12 = (int volatile   )5;
    }
#line 141
    return (-1);
  } else {
    {
#line 137
    tmp___14 = ei_decode_pid((char const   *)(header), & index___0, & msg->to);
    }
#line 137
    if (tmp___14) {
      {
#line 140
      tmp___12 = __erl_errno_place();
#line 140
      *tmp___12 = (int volatile   )5;
      }
#line 141
      return (-1);
    }
  }
#line 144
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 148
  if (ei_tracelevel > 1) {
#line 148
    show_this_msg = 1;
  }
  {
#line 149
  tmp___16 = ei_decode_pid((char const   *)(header), & index___0, & msg->from);
  }
#line 149
  if (tmp___16) {
    {
#line 152
    tmp___15 = __erl_errno_place();
#line 152
    *tmp___15 = (int volatile   )5;
    }
#line 153
    return (-1);
  } else {
    {
#line 149
    tmp___17 = ei_decode_pid((char const   *)(header), & index___0, & msg->to);
    }
#line 149
    if (tmp___17) {
      {
#line 152
      tmp___15 = __erl_errno_place();
#line 152
      *tmp___15 = (int volatile   )5;
      }
#line 153
      return (-1);
    }
  }
#line 156
  goto switch_break;
  case_12: /* CIL Label */ 
#line 159
  if (ei_tracelevel > 0) {
#line 159
    show_this_msg = 1;
  }
  {
#line 160
  tmp___19 = ei_decode_atom((char const   *)(header), & index___0, msg->cookie);
  }
#line 160
  if (tmp___19) {
    {
#line 164
    tmp___18 = __erl_errno_place();
#line 164
    *tmp___18 = (int volatile   )5;
    }
#line 165
    return (-1);
  } else {
    {
#line 160
    tmp___20 = ei_decode_pid((char const   *)(header), & index___0, & msg->to);
    }
#line 160
    if (tmp___20) {
      {
#line 164
      tmp___18 = __erl_errno_place();
#line 164
      *tmp___18 = (int volatile   )5;
      }
#line 165
      return (-1);
    } else {
      {
#line 160
      tmp___21 = ei_decode_trace((char const   *)(header), & index___0, & msg->token);
      }
#line 160
      if (tmp___21) {
        {
#line 164
        tmp___18 = __erl_errno_place();
#line 164
        *tmp___18 = (int volatile   )5;
        }
#line 165
        return (-1);
      }
    }
  }
  {
#line 168
  ei_trace(1, & msg->token);
  }
#line 169
  goto switch_break;
  case_16: /* CIL Label */ 
#line 172
  if (ei_tracelevel > 0) {
#line 172
    show_this_msg = 1;
  }
  {
#line 173
  tmp___23 = ei_decode_pid((char const   *)(header), & index___0, & msg->from);
  }
#line 173
  if (tmp___23) {
    {
#line 178
    tmp___22 = __erl_errno_place();
#line 178
    *tmp___22 = (int volatile   )5;
    }
#line 179
    return (-1);
  } else {
    {
#line 173
    tmp___24 = ei_decode_atom((char const   *)(header), & index___0, msg->cookie);
    }
#line 173
    if (tmp___24) {
      {
#line 178
      tmp___22 = __erl_errno_place();
#line 178
      *tmp___22 = (int volatile   )5;
      }
#line 179
      return (-1);
    } else {
      {
#line 173
      tmp___25 = ei_decode_atom((char const   *)(header), & index___0, msg->toname);
      }
#line 173
      if (tmp___25) {
        {
#line 178
        tmp___22 = __erl_errno_place();
#line 178
        *tmp___22 = (int volatile   )5;
        }
#line 179
        return (-1);
      } else {
        {
#line 173
        tmp___26 = ei_decode_trace((char const   *)(header), & index___0, & msg->token);
        }
#line 173
        if (tmp___26) {
          {
#line 178
          tmp___22 = __erl_errno_place();
#line 178
          *tmp___22 = (int volatile   )5;
          }
#line 179
          return (-1);
        }
      }
    }
  }
  {
#line 182
  ei_trace(1, & msg->token);
  }
#line 183
  goto switch_break;
  case_18: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 187
  if (ei_tracelevel > 1) {
#line 187
    show_this_msg = 1;
  }
  {
#line 188
  tmp___28 = ei_decode_pid((char const   *)(header), & index___0, & msg->from);
  }
#line 188
  if (tmp___28) {
    {
#line 192
    tmp___27 = __erl_errno_place();
#line 192
    *tmp___27 = (int volatile   )5;
    }
#line 193
    return (-1);
  } else {
    {
#line 188
    tmp___29 = ei_decode_pid((char const   *)(header), & index___0, & msg->to);
    }
#line 188
    if (tmp___29) {
      {
#line 192
      tmp___27 = __erl_errno_place();
#line 192
      *tmp___27 = (int volatile   )5;
      }
#line 193
      return (-1);
    } else {
      {
#line 188
      tmp___30 = ei_decode_trace((char const   *)(header), & index___0, & msg->token);
      }
#line 188
      if (tmp___30) {
        {
#line 192
        tmp___27 = __erl_errno_place();
#line 192
        *tmp___27 = (int volatile   )5;
        }
#line 193
        return (-1);
      }
    }
  }
  {
#line 196
  ei_trace(1, & msg->token);
  }
#line 197
  goto switch_break;
  case_5: /* CIL Label */ 
#line 200
  if (ei_tracelevel > 1) {
#line 200
    show_this_msg = 1;
  }
#line 201
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 205
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 209
  msglen = len - index___0;
#line 210
  remain = len - bytesread;
#line 216
  if (msglen > *bufsz) {
#line 217
    if (staticbufp) {
#line 218
      sz = 2048;
      {
#line 220
      while (1) {
        while_continue: /* CIL Label */ ;
#line 220
        if (! (remain > 0)) {
#line 220
          goto while_break;
        }
#line 221
        if (remain < sz) {
#line 221
          sz = remain;
        }
        {
#line 222
        i = ei_read_fill_t(fd, header, sz, ms);
        }
#line 222
        if (i <= 0) {
#line 222
          goto while_break;
        }
#line 223
        remain -= i;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 225
      tmp___31 = __erl_errno_place();
#line 225
      *tmp___31 = (int volatile   )90;
      }
#line 226
      return (-1);
    } else {
      {
#line 234
      tmp___33 = realloc((void *)*mbufp, (size_t )msglen);
#line 234
      mbuf = (char *)tmp___33;
      }
#line 234
      if ((unsigned long )mbuf == (unsigned long )((void *)0)) {
        {
#line 236
        tmp___32 = __erl_errno_place();
#line 236
        *tmp___32 = (int volatile   )12;
        }
#line 237
        return (-1);
      }
#line 240
      *mbufp = mbuf;
#line 241
      *bufsz = msglen;
    }
  }
  {
#line 246
  memmove((void *)mbuf, (void const   *)(header + index___0), (size_t )(bytesread - index___0));
#line 249
  *msglenp = msglen;
  }
#line 252
  if (remain > 0) {
    {
#line 253
    i = ei_read_fill_t(fd, (mbuf + bytesread) - index___0, remain, ms);
    }
#line 253
    if (i != remain) {
      {
#line 254
      *msglenp = (bytesread - index___0) + 1;
#line 255
      tmp___34 = __erl_errno_place();
      }
#line 255
      if (i == -2) {
#line 255
        *tmp___34 = (int volatile   )110;
      } else {
#line 255
        *tmp___34 = (int volatile   )5;
      }
#line 256
      return (-1);
    }
  }
#line 260
  if (show_this_msg) {
    {
#line 261
    ei_show_recmsg(stderr, msg, mbuf);
    }
  }
#line 265
  if (msg->msgtype > 10L) {
#line 265
    msg->msgtype -= 10L;
  }
#line 267
  return ((int )msg->msgtype);
}
}
#line 270 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/eirecv.c"
int ei_receive_encoded(int fd , char **mbufp , int *bufsz , erlang_msg *msg , int *msglen ) 
{ 
  int tmp ;

  {
  {
#line 273
  tmp = ei_recv_internal(fd, mbufp, bufsz, msg, msglen, 0, 0U);
  }
#line 273
  return (tmp);
}
}
#line 276 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/eirecv.c"
int ei_receive_encoded_tmo(int fd , char **mbufp , int *bufsz , erlang_msg *msg ,
                           int *msglen , unsigned int ms ) 
{ 
  int tmp ;

  {
  {
#line 278
  tmp = ei_recv_internal(fd, mbufp, bufsz, msg, msglen, 0, ms);
  }
#line 278
  return (tmp);
}
}
#line 44 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.h"
void ei_MD5Init(MD5_CTX *context ) ;
#line 45
void ei_MD5Update(MD5_CTX *context , unsigned char *input , unsigned int inputLen ) ;
#line 46
void ei_MD5Final(unsigned char *digest , MD5_CTX *context ) ;
#line 53 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
static void MD5Transform(UINT4 *state , unsigned char *block ) ;
#line 54
static void Encode(unsigned char *output , UINT4 *input , unsigned int len ) ;
#line 55
static void Decode(UINT4 *output , unsigned char *input , unsigned int len ) ;
#line 57 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
static unsigned char PADDING[64]  = 
#line 57
  {      (unsigned char)128,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 105 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
void ei_MD5Init(MD5_CTX *context ) 
{ 
  UINT4 tmp ;

  {
#line 107
  tmp = (UINT4 )0;
#line 107
  context->count[1] = tmp;
#line 107
  context->count[0] = tmp;
#line 112
  context->state[0] = (UINT4 )1732584193;
#line 113
  context->state[1] = 4023233417U;
#line 114
  context->state[2] = 2562383102U;
#line 115
  context->state[3] = (UINT4 )271733878;
#line 116
  return;
}
}
#line 123 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
void ei_MD5Update(MD5_CTX *context , unsigned char *input , unsigned int inputLen ) 
{ 
  unsigned int i ;
  unsigned int index___0 ;
  unsigned int partLen ;
  UINT4 tmp ;

  {
#line 131
  index___0 = (context->count[0] >> 3) & 63U;
#line 134
  tmp = context->count[0] + (inputLen << 3);
#line 134
  context->count[0] = tmp;
#line 134
  if (tmp < inputLen << 3) {
#line 136
    (context->count[1]) ++;
  }
#line 137
  context->count[1] += inputLen >> 29;
#line 139
  partLen = 64U - index___0;
#line 144
  if (inputLen >= partLen) {
    {
#line 145
    memcpy((void */* __restrict  */)((POINTER )(& context->buffer[index___0])), (void const   */* __restrict  */)((POINTER )input),
           partLen);
#line 147
    MD5Transform((UINT4 *)(context->state), (unsigned char *)(context->buffer));
#line 149
    i = partLen;
    }
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 149
      if (! (i + 63U < inputLen)) {
#line 149
        goto while_break;
      }
      {
#line 150
      MD5Transform((UINT4 *)(context->state), (unsigned char *)(input + i));
#line 149
      i += 64U;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 152
    index___0 = 0U;
  } else {
#line 155
    i = 0U;
  }
  {
#line 160
  memcpy((void */* __restrict  */)((POINTER )(& context->buffer[index___0])), (void const   */* __restrict  */)((POINTER )(input + i)),
         inputLen - i);
  }
#line 161
  return;
}
}
#line 167 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
void ei_MD5Final(unsigned char *digest , MD5_CTX *context ) 
{ 
  unsigned char bits[8] ;
  unsigned int index___0 ;
  unsigned int padLen ;
  void *__cil_tmp6 ;

  {
  {
#line 175
  Encode(bits, context->count, 8U);
#line 180
  index___0 = (context->count[0] >> 3) & 63U;
  }
#line 181
  if (index___0 < 56U) {
#line 181
    padLen = 56U - index___0;
  } else {
#line 181
    padLen = 120U - index___0;
  }
  {
#line 182
  ei_MD5Update(context, PADDING, padLen);
#line 187
  ei_MD5Update(context, bits, 8U);
#line 192
  Encode((unsigned char *)digest, context->state, 16U);
#line 197
  memset((POINTER )context, 0, (size_t )sizeof(*context));
  }
#line 198
  return;
}
}
#line 203 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
static void MD5Transform(UINT4 *state , unsigned char *block ) 
{ 
  UINT4 a___0 ;
  UINT4 b ;
  UINT4 c ;
  UINT4 d___0 ;
  UINT4 x[16] ;
  void *__cil_tmp8 ;

  {
  {
#line 205
  a___0 = *(state + 0);
#line 205
  b = *(state + 1);
#line 205
  c = *(state + 2);
#line 205
  d___0 = *(state + 3);
#line 207
  Decode(x, (unsigned char *)block, 64U);
#line 210
  a___0 += (((b & c) | (~ b & d___0)) + x[0]) + 3614090360U;
#line 210
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 210
  a___0 += b;
#line 211
  d___0 += (((a___0 & b) | (~ a___0 & c)) + x[1]) + 3905402710U;
#line 211
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 211
  d___0 += a___0;
#line 212
  c += (((d___0 & a___0) | (~ d___0 & b)) + x[2]) + 606105819U;
#line 212
  c = (c << 17) | (c >> 15);
#line 212
  c += d___0;
#line 213
  b += (((c & d___0) | (~ c & a___0)) + x[3]) + 3250441966U;
#line 213
  b = (b << 22) | (b >> 10);
#line 213
  b += c;
#line 214
  a___0 += (((b & c) | (~ b & d___0)) + x[4]) + 4118548399U;
#line 214
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 214
  a___0 += b;
#line 215
  d___0 += (((a___0 & b) | (~ a___0 & c)) + x[5]) + 1200080426U;
#line 215
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 215
  d___0 += a___0;
#line 216
  c += (((d___0 & a___0) | (~ d___0 & b)) + x[6]) + 2821735955U;
#line 216
  c = (c << 17) | (c >> 15);
#line 216
  c += d___0;
#line 217
  b += (((c & d___0) | (~ c & a___0)) + x[7]) + 4249261313U;
#line 217
  b = (b << 22) | (b >> 10);
#line 217
  b += c;
#line 218
  a___0 += (((b & c) | (~ b & d___0)) + x[8]) + 1770035416U;
#line 218
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 218
  a___0 += b;
#line 219
  d___0 += (((a___0 & b) | (~ a___0 & c)) + x[9]) + 2336552879U;
#line 219
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 219
  d___0 += a___0;
#line 220
  c += (((d___0 & a___0) | (~ d___0 & b)) + x[10]) + 4294925233U;
#line 220
  c = (c << 17) | (c >> 15);
#line 220
  c += d___0;
#line 221
  b += (((c & d___0) | (~ c & a___0)) + x[11]) + 2304563134U;
#line 221
  b = (b << 22) | (b >> 10);
#line 221
  b += c;
#line 222
  a___0 += (((b & c) | (~ b & d___0)) + x[12]) + 1804603682U;
#line 222
  a___0 = (a___0 << 7) | (a___0 >> 25);
#line 222
  a___0 += b;
#line 223
  d___0 += (((a___0 & b) | (~ a___0 & c)) + x[13]) + 4254626195U;
#line 223
  d___0 = (d___0 << 12) | (d___0 >> 20);
#line 223
  d___0 += a___0;
#line 224
  c += (((d___0 & a___0) | (~ d___0 & b)) + x[14]) + 2792965006U;
#line 224
  c = (c << 17) | (c >> 15);
#line 224
  c += d___0;
#line 225
  b += (((c & d___0) | (~ c & a___0)) + x[15]) + 1236535329U;
#line 225
  b = (b << 22) | (b >> 10);
#line 225
  b += c;
#line 228
  a___0 += (((b & d___0) | (c & ~ d___0)) + x[1]) + 4129170786U;
#line 228
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 228
  a___0 += b;
#line 229
  d___0 += (((a___0 & c) | (b & ~ c)) + x[6]) + 3225465664U;
#line 229
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 229
  d___0 += a___0;
#line 230
  c += (((d___0 & b) | (a___0 & ~ b)) + x[11]) + 643717713U;
#line 230
  c = (c << 14) | (c >> 18);
#line 230
  c += d___0;
#line 231
  b += (((c & a___0) | (d___0 & ~ a___0)) + x[0]) + 3921069994U;
#line 231
  b = (b << 20) | (b >> 12);
#line 231
  b += c;
#line 232
  a___0 += (((b & d___0) | (c & ~ d___0)) + x[5]) + 3593408605U;
#line 232
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 232
  a___0 += b;
#line 233
  d___0 += (((a___0 & c) | (b & ~ c)) + x[10]) + 38016083U;
#line 233
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 233
  d___0 += a___0;
#line 234
  c += (((d___0 & b) | (a___0 & ~ b)) + x[15]) + 3634488961U;
#line 234
  c = (c << 14) | (c >> 18);
#line 234
  c += d___0;
#line 235
  b += (((c & a___0) | (d___0 & ~ a___0)) + x[4]) + 3889429448U;
#line 235
  b = (b << 20) | (b >> 12);
#line 235
  b += c;
#line 236
  a___0 += (((b & d___0) | (c & ~ d___0)) + x[9]) + 568446438U;
#line 236
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 236
  a___0 += b;
#line 237
  d___0 += (((a___0 & c) | (b & ~ c)) + x[14]) + 3275163606U;
#line 237
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 237
  d___0 += a___0;
#line 238
  c += (((d___0 & b) | (a___0 & ~ b)) + x[3]) + 4107603335U;
#line 238
  c = (c << 14) | (c >> 18);
#line 238
  c += d___0;
#line 239
  b += (((c & a___0) | (d___0 & ~ a___0)) + x[8]) + 1163531501U;
#line 239
  b = (b << 20) | (b >> 12);
#line 239
  b += c;
#line 240
  a___0 += (((b & d___0) | (c & ~ d___0)) + x[13]) + 2850285829U;
#line 240
  a___0 = (a___0 << 5) | (a___0 >> 27);
#line 240
  a___0 += b;
#line 241
  d___0 += (((a___0 & c) | (b & ~ c)) + x[2]) + 4243563512U;
#line 241
  d___0 = (d___0 << 9) | (d___0 >> 23);
#line 241
  d___0 += a___0;
#line 242
  c += (((d___0 & b) | (a___0 & ~ b)) + x[7]) + 1735328473U;
#line 242
  c = (c << 14) | (c >> 18);
#line 242
  c += d___0;
#line 243
  b += (((c & a___0) | (d___0 & ~ a___0)) + x[12]) + 2368359562U;
#line 243
  b = (b << 20) | (b >> 12);
#line 243
  b += c;
#line 246
  a___0 += (((b ^ c) ^ d___0) + x[5]) + 4294588738U;
#line 246
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 246
  a___0 += b;
#line 247
  d___0 += (((a___0 ^ b) ^ c) + x[8]) + 2272392833U;
#line 247
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 247
  d___0 += a___0;
#line 248
  c += (((d___0 ^ a___0) ^ b) + x[11]) + 1839030562U;
#line 248
  c = (c << 16) | (c >> 16);
#line 248
  c += d___0;
#line 249
  b += (((c ^ d___0) ^ a___0) + x[14]) + 4259657740U;
#line 249
  b = (b << 23) | (b >> 9);
#line 249
  b += c;
#line 250
  a___0 += (((b ^ c) ^ d___0) + x[1]) + 2763975236U;
#line 250
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 250
  a___0 += b;
#line 251
  d___0 += (((a___0 ^ b) ^ c) + x[4]) + 1272893353U;
#line 251
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 251
  d___0 += a___0;
#line 252
  c += (((d___0 ^ a___0) ^ b) + x[7]) + 4139469664U;
#line 252
  c = (c << 16) | (c >> 16);
#line 252
  c += d___0;
#line 253
  b += (((c ^ d___0) ^ a___0) + x[10]) + 3200236656U;
#line 253
  b = (b << 23) | (b >> 9);
#line 253
  b += c;
#line 254
  a___0 += (((b ^ c) ^ d___0) + x[13]) + 681279174U;
#line 254
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 254
  a___0 += b;
#line 255
  d___0 += (((a___0 ^ b) ^ c) + x[0]) + 3936430074U;
#line 255
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 255
  d___0 += a___0;
#line 256
  c += (((d___0 ^ a___0) ^ b) + x[3]) + 3572445317U;
#line 256
  c = (c << 16) | (c >> 16);
#line 256
  c += d___0;
#line 257
  b += (((c ^ d___0) ^ a___0) + x[6]) + 76029189U;
#line 257
  b = (b << 23) | (b >> 9);
#line 257
  b += c;
#line 258
  a___0 += (((b ^ c) ^ d___0) + x[9]) + 3654602809U;
#line 258
  a___0 = (a___0 << 4) | (a___0 >> 28);
#line 258
  a___0 += b;
#line 259
  d___0 += (((a___0 ^ b) ^ c) + x[12]) + 3873151461U;
#line 259
  d___0 = (d___0 << 11) | (d___0 >> 21);
#line 259
  d___0 += a___0;
#line 260
  c += (((d___0 ^ a___0) ^ b) + x[15]) + 530742520U;
#line 260
  c = (c << 16) | (c >> 16);
#line 260
  c += d___0;
#line 261
  b += (((c ^ d___0) ^ a___0) + x[2]) + 3299628645U;
#line 261
  b = (b << 23) | (b >> 9);
#line 261
  b += c;
#line 264
  a___0 += ((c ^ (b | ~ d___0)) + x[0]) + 4096336452U;
#line 264
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 264
  a___0 += b;
#line 265
  d___0 += ((b ^ (a___0 | ~ c)) + x[7]) + 1126891415U;
#line 265
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 265
  d___0 += a___0;
#line 266
  c += ((a___0 ^ (d___0 | ~ b)) + x[14]) + 2878612391U;
#line 266
  c = (c << 15) | (c >> 17);
#line 266
  c += d___0;
#line 267
  b += ((d___0 ^ (c | ~ a___0)) + x[5]) + 4237533241U;
#line 267
  b = (b << 21) | (b >> 11);
#line 267
  b += c;
#line 268
  a___0 += ((c ^ (b | ~ d___0)) + x[12]) + 1700485571U;
#line 268
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 268
  a___0 += b;
#line 269
  d___0 += ((b ^ (a___0 | ~ c)) + x[3]) + 2399980690U;
#line 269
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 269
  d___0 += a___0;
#line 270
  c += ((a___0 ^ (d___0 | ~ b)) + x[10]) + 4293915773U;
#line 270
  c = (c << 15) | (c >> 17);
#line 270
  c += d___0;
#line 271
  b += ((d___0 ^ (c | ~ a___0)) + x[1]) + 2240044497U;
#line 271
  b = (b << 21) | (b >> 11);
#line 271
  b += c;
#line 272
  a___0 += ((c ^ (b | ~ d___0)) + x[8]) + 1873313359U;
#line 272
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 272
  a___0 += b;
#line 273
  d___0 += ((b ^ (a___0 | ~ c)) + x[15]) + 4264355552U;
#line 273
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 273
  d___0 += a___0;
#line 274
  c += ((a___0 ^ (d___0 | ~ b)) + x[6]) + 2734768916U;
#line 274
  c = (c << 15) | (c >> 17);
#line 274
  c += d___0;
#line 275
  b += ((d___0 ^ (c | ~ a___0)) + x[13]) + 1309151649U;
#line 275
  b = (b << 21) | (b >> 11);
#line 275
  b += c;
#line 276
  a___0 += ((c ^ (b | ~ d___0)) + x[4]) + 4149444226U;
#line 276
  a___0 = (a___0 << 6) | (a___0 >> 26);
#line 276
  a___0 += b;
#line 277
  d___0 += ((b ^ (a___0 | ~ c)) + x[11]) + 3174756917U;
#line 277
  d___0 = (d___0 << 10) | (d___0 >> 22);
#line 277
  d___0 += a___0;
#line 278
  c += ((a___0 ^ (d___0 | ~ b)) + x[2]) + 718787259U;
#line 278
  c = (c << 15) | (c >> 17);
#line 278
  c += d___0;
#line 279
  b += ((d___0 ^ (c | ~ a___0)) + x[9]) + 3951481745U;
#line 279
  b = (b << 21) | (b >> 11);
#line 279
  b += c;
#line 281
  *(state + 0) += a___0;
#line 282
  *(state + 1) += b;
#line 283
  *(state + 2) += c;
#line 284
  *(state + 3) += d___0;
#line 289
  memset((POINTER )(x), 0, (size_t )sizeof(x));
  }
#line 290
  return;
}
}
#line 296 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
static void Encode(unsigned char *output , UINT4 *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 300
  i = 0U;
#line 300
  j = 0U;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (j < len)) {
#line 300
      goto while_break;
    }
#line 301
    *(output + j) = (unsigned char )(*(input + i) & 255U);
#line 302
    *(output + (j + 1U)) = (unsigned char )((*(input + i) >> 8) & 255U);
#line 303
    *(output + (j + 2U)) = (unsigned char )((*(input + i) >> 16) & 255U);
#line 304
    *(output + (j + 3U)) = (unsigned char )((*(input + i) >> 24) & 255U);
#line 300
    i ++;
#line 300
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 312 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/eimd5.c"
static void Decode(UINT4 *output , unsigned char *input , unsigned int len ) 
{ 
  unsigned int i ;
  unsigned int j ;

  {
#line 316
  i = 0U;
#line 316
  j = 0U;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (j < len)) {
#line 316
      goto while_break;
    }
#line 317
    *(output + i) = (((UINT4 )*(input + j) | ((UINT4 )*(input + (j + 1U)) << 8)) | ((UINT4 )*(input + (j + 2U)) << 16)) | ((UINT4 )*(input + (j + 3U)) << 24);
#line 316
    i ++;
#line 316
    j += 4U;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 402 "../include/ei.h"
int ei_x_encode_version(ei_x_buff *x ) ;
#line 404
int ei_x_encode_long(ei_x_buff *x , long n ) ;
#line 406
int ei_x_encode_ulong(ei_x_buff *x , unsigned long n ) ;
#line 408
int ei_x_encode_double(ei_x_buff *x , double dbl ) ;
#line 410
int ei_x_encode_boolean(ei_x_buff *x , int p ) ;
#line 412
int ei_x_encode_char(ei_x_buff *x , char p ) ;
#line 415
int ei_x_encode_string(ei_x_buff *x , char const   *s ) ;
#line 416
int ei_x_encode_string_len(ei_x_buff *x , char const   *s , int len ) ;
#line 419
int ei_x_encode_atom(ei_x_buff *x , char const   *s ) ;
#line 420
int ei_x_encode_atom_len(ei_x_buff *x , char const   *s , int len ) ;
#line 422
int ei_x_encode_binary(ei_x_buff *x , void const   *p , int len ) ;
#line 424
int ei_x_encode_pid(ei_x_buff *x , erlang_pid const   *pid ) ;
#line 426
int ei_x_encode_fun(ei_x_buff *x , erlang_fun const   *fun ) ;
#line 428
int ei_x_encode_port(ei_x_buff *x , erlang_port const   *port ) ;
#line 430
int ei_x_encode_ref(ei_x_buff *x , erlang_ref const   *ref ) ;
#line 434
int ei_x_encode_trace(ei_x_buff *x , erlang_trace const   *trace ) ;
#line 436
int ei_x_encode_tuple_header(ei_x_buff *x , long n ) ;
#line 438
int ei_x_encode_list_header(ei_x_buff *x , long n ) ;
#line 440
int ei_x_encode_empty_list(ei_x_buff *x ) ;
#line 504
int ei_x_new(ei_x_buff *x ) ;
#line 505
int ei_x_new_with_version(ei_x_buff *x ) ;
#line 506
int ei_x_free(ei_x_buff *x ) ;
#line 507
int ei_x_append(ei_x_buff *x , ei_x_buff const   *x2 ) ;
#line 508
int ei_x_append_buf(ei_x_buff *x , char const   *buf , int len ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_malloc.h"
void *ei_malloc(long size ) ;
#line 25
void *ei_realloc(void *orig , long size ) ;
#line 26
void ei_free(void *ptr ) ;
#line 43 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_extra  =    100;
#line 45 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_new(ei_x_buff *x ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 47
  tmp = ei_malloc((long )ei_x_extra);
#line 47
  x->buff = (char *)tmp;
#line 48
  x->buffsz = ei_x_extra;
#line 49
  x->index = 0;
  }
#line 50
  if ((unsigned long )x->buff != (unsigned long )((void *)0)) {
#line 50
    tmp___0 = 0;
  } else {
#line 50
    tmp___0 = -1;
  }
#line 50
  return (tmp___0);
}
}
#line 53 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_new_with_version(ei_x_buff *x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 55
  tmp = ei_x_new(x);
  }
#line 55
  if (tmp < 0) {
#line 56
    return (-1);
  }
  {
#line 57
  tmp___0 = ei_encode_version(x->buff, & x->index);
  }
#line 57
  return (tmp___0);
}
}
#line 60 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_free(ei_x_buff *x ) 
{ 


  {
#line 62
  if ((unsigned long )x->buff == (unsigned long )((void *)0)) {
#line 63
    return (-1);
  }
  {
#line 64
  ei_free((void *)x->buff);
#line 65
  x->buff = (char *)((void *)0);
  }
#line 66
  return (0);
}
}
#line 69 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int x_fix_buff(ei_x_buff *x , int szneeded ) 
{ 
  int sz ;
  void *tmp ;

  {
#line 71
  sz = szneeded + ei_x_extra;
#line 72
  if (sz > x->buffsz) {
    {
#line 73
    sz += ei_x_extra;
#line 74
    x->buffsz = sz;
#line 75
    tmp = ei_realloc((void *)x->buff, (long )sz);
#line 75
    x->buff = (char *)tmp;
    }
  }
#line 77
  return ((unsigned long )x->buff != (unsigned long )((void *)0));
}
}
#line 80 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_append(ei_x_buff *x , ei_x_buff const   *x2 ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = ei_x_append_buf(x, (char const   *)x2->buff, (int )x2->index);
  }
#line 82
  return (tmp);
}
}
#line 85 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_append_buf(ei_x_buff *x , char const   *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 87
  tmp = x_fix_buff(x, x->index + len);
  }
#line 87
  if (! tmp) {
#line 88
    return (-1);
  }
  {
#line 89
  memcpy((void */* __restrict  */)(x->buff + x->index), (void const   */* __restrict  */)buf,
         (size_t )len);
#line 90
  x->index += len;
  }
#line 91
  return (0);
}
}
#line 94 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_string(ei_x_buff *x , char const   *s ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 96
  tmp = strlen(s);
#line 96
  tmp___0 = ei_x_encode_string_len(x, s, (int )tmp);
  }
#line 96
  return (tmp___0);
}
}
#line 99 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_string_len(ei_x_buff *x , char const   *s , int len ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 101
  i = x->index;
#line 102
  ei_encode_string_len((char *)((void *)0), & i, s, len);
#line 103
  tmp = x_fix_buff(x, i);
  }
#line 103
  if (! tmp) {
#line 104
    return (-1);
  }
  {
#line 105
  tmp___0 = ei_encode_string_len(x->buff, & x->index, s, len);
  }
#line 105
  return (tmp___0);
}
}
#line 108 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_binary(ei_x_buff *x , void const   *p , int len ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 110
  i = x->index;
#line 111
  ei_encode_binary((char *)((void *)0), & i, p, (long )len);
#line 112
  tmp = x_fix_buff(x, i);
  }
#line 112
  if (! tmp) {
#line 113
    return (-1);
  }
  {
#line 114
  tmp___0 = ei_encode_binary(x->buff, & x->index, p, (long )len);
  }
#line 114
  return (tmp___0);
}
}
#line 117 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_long(ei_x_buff *x , long n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 119
  i = x->index;
#line 120
  ei_encode_long((char *)((void *)0), & i, n);
#line 121
  tmp = x_fix_buff(x, i);
  }
#line 121
  if (! tmp) {
#line 122
    return (-1);
  }
  {
#line 123
  tmp___0 = ei_encode_long(x->buff, & x->index, n);
  }
#line 123
  return (tmp___0);
}
}
#line 126 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_ulong(ei_x_buff *x , unsigned long n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 128
  i = x->index;
#line 129
  ei_encode_ulong((char *)((void *)0), & i, n);
#line 130
  tmp = x_fix_buff(x, i);
  }
#line 130
  if (! tmp) {
#line 131
    return (-1);
  }
  {
#line 132
  tmp___0 = ei_encode_ulong(x->buff, & x->index, n);
  }
#line 132
  return (tmp___0);
}
}
#line 135 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_char(ei_x_buff *x , char p ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 137
  i = x->index;
#line 138
  ei_encode_char((char *)((void *)0), & i, p);
#line 139
  tmp = x_fix_buff(x, i);
  }
#line 139
  if (! tmp) {
#line 140
    return (-1);
  }
  {
#line 141
  tmp___0 = ei_encode_char(x->buff, & x->index, p);
  }
#line 141
  return (tmp___0);
}
}
#line 144 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_boolean(ei_x_buff *x , int p ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 146
  i = x->index;
#line 147
  ei_encode_boolean((char *)((void *)0), & i, p);
#line 148
  tmp = x_fix_buff(x, i);
  }
#line 148
  if (! tmp) {
#line 149
    return (-1);
  }
  {
#line 150
  tmp___0 = ei_encode_boolean(x->buff, & x->index, p);
  }
#line 150
  return (tmp___0);
}
}
#line 153 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_double(ei_x_buff *x , double dbl ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 155
  i = x->index;
#line 156
  ei_encode_double((char *)((void *)0), & i, dbl);
#line 157
  tmp = x_fix_buff(x, i);
  }
#line 157
  if (! tmp) {
#line 158
    return (-1);
  }
  {
#line 159
  tmp___0 = ei_encode_double(x->buff, & x->index, dbl);
  }
#line 159
  return (tmp___0);
}
}
#line 162 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_list_header(ei_x_buff *x , long n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 164
  i = x->index;
#line 165
  ei_encode_list_header((char *)((void *)0), & i, (int )n);
#line 166
  tmp = x_fix_buff(x, i);
  }
#line 166
  if (! tmp) {
#line 167
    return (-1);
  }
  {
#line 168
  tmp___0 = ei_encode_list_header(x->buff, & x->index, (int )n);
  }
#line 168
  return (tmp___0);
}
}
#line 171 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_empty_list(ei_x_buff *x ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 173
  i = x->index;
#line 174
  ei_encode_list_header((char *)((void *)0), & i, 0);
#line 175
  tmp = x_fix_buff(x, i);
  }
#line 175
  if (! tmp) {
#line 176
    return (-1);
  }
  {
#line 177
  tmp___0 = ei_encode_list_header(x->buff, & x->index, 0);
  }
#line 177
  return (tmp___0);
}
}
#line 180 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_version(ei_x_buff *x ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 182
  i = x->index;
#line 183
  ei_encode_version((char *)((void *)0), & i);
#line 184
  tmp = x_fix_buff(x, i);
  }
#line 184
  if (! tmp) {
#line 185
    return (-1);
  }
  {
#line 186
  tmp___0 = ei_encode_version(x->buff, & x->index);
  }
#line 186
  return (tmp___0);
}
}
#line 189 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_tuple_header(ei_x_buff *x , long n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 191
  i = x->index;
#line 192
  ei_encode_tuple_header((char *)((void *)0), & i, (int )n);
#line 193
  tmp = x_fix_buff(x, i);
  }
#line 193
  if (! tmp) {
#line 194
    return (-1);
  }
  {
#line 195
  tmp___0 = ei_encode_tuple_header(x->buff, & x->index, (int )n);
  }
#line 195
  return (tmp___0);
}
}
#line 198 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_atom(ei_x_buff *x , char const   *s ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 200
  tmp = strlen(s);
#line 200
  tmp___0 = ei_x_encode_atom_len(x, s, (int )tmp);
  }
#line 200
  return (tmp___0);
}
}
#line 203 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_atom_len(ei_x_buff *x , char const   *s , int len ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 205
  i = x->index;
#line 206
  ei_encode_atom_len((char *)((void *)0), & i, s, len);
#line 207
  tmp = x_fix_buff(x, i);
  }
#line 207
  if (! tmp) {
#line 208
    return (-1);
  }
  {
#line 209
  tmp___0 = ei_encode_atom_len(x->buff, & x->index, s, len);
  }
#line 209
  return (tmp___0);
}
}
#line 212 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_pid(ei_x_buff *x , erlang_pid const   *pid ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 214
  i = x->index;
#line 215
  ei_encode_pid((char *)((void *)0), & i, pid);
#line 216
  tmp = x_fix_buff(x, i);
  }
#line 216
  if (! tmp) {
#line 217
    return (-1);
  }
  {
#line 218
  tmp___0 = ei_encode_pid(x->buff, & x->index, pid);
  }
#line 218
  return (tmp___0);
}
}
#line 221 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_fun(ei_x_buff *x , erlang_fun const   *fun ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 223
  i = x->index;
#line 224
  ei_encode_fun((char *)((void *)0), & i, fun);
#line 225
  tmp = x_fix_buff(x, i);
  }
#line 225
  if (! tmp) {
#line 226
    return (-1);
  }
  {
#line 227
  tmp___0 = ei_encode_fun(x->buff, & x->index, fun);
  }
#line 227
  return (tmp___0);
}
}
#line 230 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_ref(ei_x_buff *x , erlang_ref const   *ref ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 232
  i = x->index;
#line 233
  ei_encode_ref((char *)((void *)0), & i, ref);
#line 234
  tmp = x_fix_buff(x, i);
  }
#line 234
  if (! tmp) {
#line 235
    return (-1);
  }
  {
#line 236
  tmp___0 = ei_encode_ref(x->buff, & x->index, ref);
  }
#line 236
  return (tmp___0);
}
}
#line 239 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_port(ei_x_buff *x , erlang_port const   *port ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 241
  i = x->index;
#line 242
  ei_encode_port((char *)((void *)0), & i, port);
#line 243
  tmp = x_fix_buff(x, i);
  }
#line 243
  if (! tmp) {
#line 244
    return (-1);
  }
  {
#line 245
  tmp___0 = ei_encode_port(x->buff, & x->index, port);
  }
#line 245
  return (tmp___0);
}
}
#line 248 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_x_encode.c"
int ei_x_encode_trace(ei_x_buff *x , erlang_trace const   *trace ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 250
  i = x->index;
#line 251
  ei_encode_trace((char *)((void *)0), & i, trace);
#line 252
  tmp = x_fix_buff(x, i);
  }
#line 252
  if (! tmp) {
#line 253
    return (-1);
  }
  {
#line 254
  tmp___0 = ei_encode_trace(x->buff, & x->index, trace);
  }
#line 254
  return (tmp___0);
}
}
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_trace.c"
static erlang_trace save_token  ;
#line 29 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_trace.c"
static int tracing  =    0;
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_trace.c"
static int clock___0  =    0;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_trace.c"
erlang_trace *ei_trace(int query , erlang_trace *token ) 
{ 
  long tmp ;

  {
  {
#line 34
  if (query == -1) {
#line 34
    goto case_neg_1;
  }
#line 38
  if (query == 0) {
#line 38
    goto case_0;
  }
#line 46
  if (query == 1) {
#line 46
    goto case_1;
  }
#line 33
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 35
  tracing = 0;
#line 36
  goto switch_break;
  case_0: /* CIL Label */ 
#line 39
  if (tracing) {
#line 40
    clock___0 ++;
#line 41
    tmp = save_token.serial;
#line 41
    (save_token.serial) ++;
#line 41
    save_token.prev = tmp;
#line 42
    return (& save_token);
  }
#line 44
  goto switch_break;
  case_1: /* CIL Label */ 
#line 47
  tracing = 1;
#line 48
  save_token = *token;
#line 49
  if (save_token.serial > (long )clock___0) {
#line 50
    clock___0 = (int )token->serial;
#line 50
    save_token.prev = (long )clock___0;
  }
#line 51
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 54
  return ((erlang_trace *)((void *)0));
}
}
#line 136 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 143
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 178
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 383 "../include/ei.h"
struct hostent *ei_gethostbyname(char const   *name ) ;
#line 384
struct hostent *ei_gethostbyaddr(char const   *addr , int len , int type ) ;
#line 385
struct hostent *ei_gethostbyname_r(char const   *name , struct hostent *hostp , char *buffer ,
                                   int buflen , int *h_errnop ) ;
#line 390
struct hostent *ei_gethostbyaddr_r(char const   *addr , int length , int type , struct hostent *hostp ,
                                   char *buffer , int buflen , int *h_errnop ) ;
#line 22 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_resolve.h"
void ei_init_resolve(void) ;
#line 59 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_resolve.c"
void ei_init_resolve(void) 
{ 


  {
#line 61
  return;
}
}
#line 579 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_resolve.c"
struct hostent *ei_gethostbyname(char const   *name ) 
{ 
  struct hostent *tmp ;

  {
  {
#line 581
  tmp = gethostbyname(name);
  }
#line 581
  return (tmp);
}
}
#line 584 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_resolve.c"
struct hostent *ei_gethostbyaddr(char const   *addr , int len , int type ) 
{ 
  struct hostent *tmp ;

  {
  {
#line 586
  tmp = gethostbyaddr((void const   *)addr, (__socklen_t )len, type);
  }
#line 586
  return (tmp);
}
}
#line 589 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_resolve.c"
struct hostent *ei_gethostbyaddr_r(char const   *addr , int length , int type , struct hostent *hostp ,
                                   char *buffer , int buflen , int *h_errnop ) 
{ 
  struct hostent *tmp ;

  {
  {
#line 599
  tmp = gethostbyaddr((void const   *)addr, (__socklen_t )length, type);
  }
#line 599
  return (tmp);
}
}
#line 618 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_resolve.c"
struct hostent *ei_gethostbyname_r(char const   *name , struct hostent *hostp , char *buffer ,
                                   int buflen , int *h_errnop ) 
{ 
  struct hostent *result ;

  {
  {
#line 634
  gethostbyname_r((char const   */* __restrict  */)name, (struct hostent */* __restrict  */)hostp,
                  (char */* __restrict  */)buffer, (size_t )buflen, (struct hostent **/* __restrict  */)(& result),
                  (int */* __restrict  */)h_errnop);
  }
#line 636
  return (result);
}
}
#line 468 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
#line 723
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
#line 728
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 732
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
#line 736
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 747
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 1087
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_key_create)(pthread_key_t *__key ,
                                                                                               void (*__destr_function)(void * ) ) ;
#line 1095
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1098
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 68 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.h"
void *ei_m_create(void) ;
#line 69
int ei_m_destroy(void *l ) ;
#line 70
int ei_m_lock(void *l ) ;
#line 71
int ei_m_trylock(void *l ) ;
#line 72
int ei_m_unlock(void *l ) ;
#line 112 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
void *ei_m_create(void) 
{ 
  pthread_mutex_t *l ;
  void *tmp ;

  {
  {
#line 116
  tmp = malloc((size_t )sizeof(*l));
#line 116
  l = (pthread_mutex_t *)tmp;
  }
#line 116
  if (l) {
    {
#line 117
    pthread_mutex_init(l, (pthread_mutexattr_t const   *)((void *)0));
    }
  }
#line 120
  return ((void *)l);
}
}
#line 123 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
int ei_m_destroy(void *l ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 125
  tmp = pthread_mutex_destroy((pthread_mutex_t *)l);
#line 125
  r = tmp;
#line 126
  free(l);
  }
#line 128
  return (r);
}
}
#line 131 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
int ei_m_lock(void *l ) 
{ 
  int tmp ;

  {
  {
#line 133
  tmp = pthread_mutex_lock((pthread_mutex_t *)l);
  }
#line 133
  return (tmp);
}
}
#line 136 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
int ei_m_trylock(void *l ) 
{ 
  int tmp ;

  {
  {
#line 138
  tmp = pthread_mutex_trylock((pthread_mutex_t *)l);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
int ei_m_unlock(void *l ) 
{ 
  int tmp ;

  {
  {
#line 143
  tmp = pthread_mutex_unlock((pthread_mutex_t *)l);
  }
#line 143
  return (tmp);
}
}
#line 154 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
static pthread_key_t erl_errno_key  ;
#line 155 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
static pthread_once_t erl_errno_key_once  =    0;
#line 160 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
static void erl_errno_destroy(void *ptr ) 
{ 


  {
  {
#line 162
  free(ptr);
  }
#line 163
  return;
}
}
#line 169 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
static void erl_errno_key_alloc(void) 
{ 


  {
  {
#line 171
  pthread_key_create(& erl_errno_key, & erl_errno_destroy);
  }
#line 172
  return;
}
}
#line 186 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
static int volatile   use_fallback  =    (int volatile   )0;
#line 187 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
static int volatile   fallback_errno  =    (int volatile   )0;
#line 183
int volatile   *__erl_errno_place(void)  __attribute__((__const__)) ;
#line 183 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_pthreads.c"
int volatile   *__erl_errno_place(void) 
{ 
  int *erl_errno_p ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 189
  if (use_fallback) {
#line 190
    return (& fallback_errno);
  }
  {
#line 194
  tmp = pthread_once(& erl_errno_key_once, & erl_errno_key_alloc);
  }
#line 194
  if (tmp != 0) {
#line 195
    use_fallback = (int volatile   )1;
#line 196
    return (& fallback_errno);
  }
  {
#line 200
  tmp___0 = pthread_getspecific(erl_errno_key);
#line 200
  erl_errno_p = (int *)tmp___0;
  }
#line 200
  if ((unsigned long )erl_errno_p != (unsigned long )((void *)0)) {
#line 201
    return ((int volatile   *)erl_errno_p);
  }
  {
#line 204
  tmp___1 = malloc((size_t )sizeof(int ));
#line 204
  erl_errno_p = (int *)tmp___1;
  }
#line 204
  if ((unsigned long )erl_errno_p == (unsigned long )((void *)0)) {
#line 205
    use_fallback = (int volatile   )1;
#line 206
    return (& fallback_errno);
  }
  {
#line 209
  tmp___2 = pthread_setspecific(erl_errno_key, (void const   *)erl_errno_p);
  }
#line 209
  if (tmp___2 != 0) {
    {
#line 211
    free((void *)erl_errno_p);
    }
#line 212
    return (& fallback_errno);
  } else {
    {
#line 209
    tmp___3 = pthread_getspecific(erl_errno_key);
#line 209
    erl_errno_p = (int *)tmp___3;
    }
#line 209
    if ((unsigned long )erl_errno_p == (unsigned long )((void *)0)) {
      {
#line 211
      free((void *)erl_errno_p);
      }
#line 212
      return (& fallback_errno);
    }
  }
#line 215
  return ((int volatile   *)erl_errno_p);
}
}
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 494 "../include/ei.h"
int ei_print_term(FILE *fp , char const   *buf , int *index___0 ) ;
#line 495
int ei_s_print_term(char **s , char const   *buf , int *index___0 ) ;
#line 772
int ei_decode_big(char const   *buf , int *index___0 , erlang_big *b ) ;
#line 776
erlang_big *ei_alloc_big(unsigned int digit_bytes ) ;
#line 777
void ei_free_big(erlang_big *b ) ;
#line 52 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static int print_string(FILE *fp , ei_x_buff *x , char *s , int len ) ;
#line 53
static int print_term(FILE *fp , ei_x_buff *x , char const   *buf , int *index___0 ) ;
#line 56 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static void xputc(char c , FILE *fp , ei_x_buff *x ) 
{ 


  {
#line 58
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 59
    _IO_putc((int )c, fp);
    }
  } else {
    {
#line 61
    ei_x_append_buf(x, (char const   *)(& c), 1);
    }
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static void xputs(char const   *s , FILE *fp , ei_x_buff *x ) 
{ 
  size_t tmp ;

  {
#line 66
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 67
    fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)fp);
    }
  } else {
    {
#line 69
    tmp = strlen(s);
#line 69
    ei_x_append_buf(x, s, (int )tmp);
    }
  }
#line 70
  return;
}
}
#line 72 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static int xprintf(FILE *fp , ei_x_buff *x , char const   *fmt  , ...) 
{ 
  int r ;
  va_list ap ;
  char tmpbuf[2000] ;
  size_t tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 74
  r = 0;
#line 76
  __builtin_va_start(ap, fmt);
  }
#line 77
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 78
    r = vfprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt,
                 ap);
    }
  } else {
    {
#line 82
    r = vsprintf((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)fmt,
                 ap);
#line 83
    tmp = strlen((char const   *)(tmpbuf));
#line 83
    ei_x_append_buf(x, (char const   *)(tmpbuf), (int )tmp);
    }
  }
  {
#line 85
  __builtin_va_end(ap);
  }
#line 86
  return (r);
}
}
#line 89 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static char *ei_big_to_str(erlang_big *b ) 
{ 
  int buf_len ;
  char *s ;
  char *buf ;
  unsigned short *sp ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 96
  buf_len = (int )((unsigned int )(64 + b->is_neg) + 10U * b->arity);
#line 97
  tmp = malloc((size_t )buf_len);
#line 97
  buf = (char *)tmp;
  }
#line 97
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 97
    return ((char *)((void *)0));
  }
  {
#line 99
  memset((void *)buf, 0, (size_t )buf_len);
#line 101
  s = buf;
  }
#line 102
  if (b->is_neg) {
    {
#line 103
    tmp___0 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"-");
#line 103
    s += tmp___0;
    }
  }
  {
#line 104
  tmp___1 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"#integer(%d) = {",
                    b->arity);
#line 104
  s += tmp___1;
#line 105
  sp = (unsigned short *)b->digits;
#line 105
  i = 0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! ((unsigned int )i < b->arity)) {
#line 105
      goto while_break;
    }
    {
#line 106
    tmp___2 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%d",
                      (int )*(sp + i));
#line 106
    s += tmp___2;
    }
#line 107
    if ((unsigned int )(i + 1) != b->arity) {
      {
#line 108
      tmp___3 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)",");
#line 108
      s += tmp___3;
      }
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  tmp___4 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"}");
#line 110
  s += tmp___4;
  }
#line 111
  return (buf);
}
}
#line 114 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static int print_term(FILE *fp , ei_x_buff *x , char const   *buf , int *index___0 ) 
{ 
  int i ;
  int doquote ;
  int n ;
  int m___0 ;
  int ty ;
  int r ;
  char a___0[256] ;
  char *p ;
  int ch_written ;
  erlang_pid pid ;
  erlang_port port ;
  erlang_ref ref ;
  double d___0 ;
  long l ;
  int tindex ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  erlang_big *b ;
  char *ds ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
#line 119
  ch_written = 0;
#line 126
  tindex = *index___0;
#line 130
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 130
    if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 130
      return (-1);
    }
  }
  {
#line 132
  doquote = 0;
#line 133
  ei_get_type_internal(buf, (int const   *)index___0, & ty, & n);
  }
  {
#line 135
  if (ty == 100) {
#line 135
    goto case_100;
  }
#line 149
  if (ty == 103) {
#line 149
    goto case_103;
  }
#line 154
  if (ty == 102) {
#line 154
    goto case_102;
  }
#line 159
  if (ty == 101) {
#line 159
    goto case_101;
  }
#line 159
  if (ty == 114) {
#line 159
    goto case_101;
  }
#line 170
  if (ty == 106) {
#line 170
    goto case_106;
  }
#line 174
  if (ty == 108) {
#line 174
    goto case_108;
  }
#line 197
  if (ty == 107) {
#line 197
    goto case_107;
  }
#line 208
  if (ty == 105) {
#line 208
    goto case_105;
  }
#line 208
  if (ty == 104) {
#line 208
    goto case_105;
  }
#line 223
  if (ty == 109) {
#line 223
    goto case_109;
  }
#line 246
  if (ty == 98) {
#line 246
    goto case_98;
  }
#line 246
  if (ty == 97) {
#line 246
    goto case_98;
  }
#line 251
  if (ty == 111) {
#line 251
    goto case_111;
  }
#line 251
  if (ty == 110) {
#line 251
    goto case_111;
  }
#line 274
  if (ty == 99) {
#line 274
    goto case_99;
  }
#line 278
  goto switch_default;
  case_100: /* CIL Label */ 
  {
#line 136
  tmp = ei_decode_atom(buf, index___0, a___0);
  }
#line 136
  if (tmp < 0) {
#line 137
    goto err;
  }
  {
#line 138
  tmp___0 = __ctype_b_loc();
  }
#line 138
  if ((int const   )*(*tmp___0 + (int )a___0[0]) & 512) {
#line 138
    tmp___1 = 0;
  } else {
#line 138
    tmp___1 = 1;
  }
#line 138
  doquote = tmp___1;
#line 139
  p = a___0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! doquote) {
#line 139
      if (! ((int )*p != 0)) {
#line 139
        goto while_break;
      }
    } else {
#line 139
      goto while_break;
    }
    {
#line 140
    tmp___2 = __ctype_b_loc();
    }
#line 140
    if ((int const   )*(*tmp___2 + (int )*p) & 8) {
#line 140
      tmp___3 = 0;
    } else
#line 140
    if ((int )*p == 95) {
#line 140
      tmp___3 = 0;
    } else
#line 140
    if ((int )*p == 64) {
#line 140
      tmp___3 = 0;
    } else {
#line 140
      tmp___3 = 1;
    }
#line 140
    doquote = tmp___3;
#line 139
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (doquote) {
    {
#line 142
    xputc((char )'\'', fp, x);
#line 142
    ch_written ++;
    }
  }
  {
#line 144
  xputs((char const   *)(a___0), fp, x);
#line 144
  tmp___4 = strlen((char const   *)(a___0));
#line 144
  ch_written = (int )((size_t )ch_written + tmp___4);
  }
#line 145
  if (doquote) {
    {
#line 146
    xputc((char )'\'', fp, x);
#line 146
    ch_written ++;
    }
  }
#line 148
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 150
  tmp___5 = ei_decode_pid(buf, index___0, & pid);
  }
#line 150
  if (tmp___5 < 0) {
#line 150
    goto err;
  }
  {
#line 151
  tmp___6 = xprintf(fp, x, "<%s.%d.%d>", pid.node, pid.num, pid.serial);
#line 151
  ch_written += tmp___6;
  }
#line 153
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 155
  tmp___7 = ei_decode_port(buf, index___0, & port);
  }
#line 155
  if (tmp___7 < 0) {
#line 155
    goto err;
  }
  {
#line 156
  tmp___8 = xprintf(fp, x, "#Port<%d.%d>", port.id, port.creation);
#line 156
  ch_written += tmp___8;
  }
#line 157
  goto switch_break;
  case_101: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 160
  tmp___9 = ei_decode_ref(buf, index___0, & ref);
  }
#line 160
  if (tmp___9 < 0) {
#line 160
    goto err;
  }
  {
#line 161
  tmp___10 = xprintf(fp, x, "#Ref<");
#line 161
  ch_written += tmp___10;
#line 162
  i = 0;
  }
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 162
    if (! (i < ref.len)) {
#line 162
      goto while_break___0;
    }
    {
#line 163
    tmp___11 = xprintf(fp, x, "%d", ref.n[i]);
#line 163
    ch_written += tmp___11;
    }
#line 164
    if (i < ref.len - 1) {
      {
#line 165
      xputc((char )'.', fp, x);
#line 165
      ch_written ++;
      }
    }
#line 162
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 168
  xputc((char )'>', fp, x);
#line 168
  ch_written ++;
  }
#line 169
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 171
  tmp___12 = ei_decode_list_header(buf, index___0, & n);
  }
#line 171
  if (tmp___12 < 0) {
#line 171
    goto err;
  }
  {
#line 172
  tmp___13 = xprintf(fp, x, "[]");
#line 172
  ch_written += tmp___13;
  }
#line 173
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 175
  tmp___14 = ei_decode_list_header(buf, & tindex, & n);
  }
#line 175
  if (tmp___14 < 0) {
#line 175
    goto err;
  }
  {
#line 176
  xputc((char )'[', fp, x);
#line 176
  ch_written ++;
#line 177
  i = 0;
  }
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 177
    if (! (i < n)) {
#line 177
      goto while_break___1;
    }
    {
#line 178
    r = print_term(fp, x, buf, & tindex);
    }
#line 179
    if (r < 0) {
#line 179
      goto err;
    }
#line 180
    ch_written += r;
#line 181
    if (i < n - 1) {
      {
#line 182
      xputs(", ", fp, x);
#line 182
      ch_written += 2;
      }
    }
#line 177
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 185
  tmp___15 = ei_get_type_internal(buf, (int const   *)(& tindex), & ty, & n);
  }
#line 185
  if (tmp___15 < 0) {
#line 185
    goto err;
  }
#line 186
  if (ty != 106) {
    {
#line 187
    xputs(" | ", fp, x);
#line 187
    ch_written += 3;
#line 188
    r = print_term(fp, x, buf, & tindex);
    }
#line 189
    if (r < 0) {
#line 189
      goto err;
    }
#line 190
    ch_written += r;
  } else {
    {
#line 192
    tmp___16 = ei_decode_list_header(buf, & tindex, & n);
    }
#line 192
    if (tmp___16 < 0) {
#line 192
      goto err;
    }
  }
  {
#line 194
  xputc((char )']', fp, x);
#line 194
  ch_written ++;
#line 195
  *index___0 = tindex;
  }
#line 196
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 198
  tmp___17 = ei_malloc((long )(n + 1));
#line 198
  p = (char *)tmp___17;
  }
#line 199
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 199
    goto err;
  }
  {
#line 200
  tmp___18 = ei_decode_string(buf, index___0, p);
  }
#line 200
  if (tmp___18 < 0) {
    {
#line 201
    ei_free((void *)p);
    }
#line 202
    goto err;
  }
  {
#line 204
  tmp___19 = print_string(fp, x, p, n);
#line 204
  ch_written += tmp___19;
#line 205
  ei_free((void *)p);
  }
#line 206
  goto switch_break;
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  {
#line 209
  tmp___20 = ei_decode_tuple_header(buf, & tindex, & n);
  }
#line 209
  if (tmp___20 < 0) {
#line 209
    goto err;
  }
  {
#line 210
  xputc((char )'{', fp, x);
#line 210
  ch_written ++;
#line 212
  i = 0;
  }
  {
#line 212
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 212
    if (! (i < n)) {
#line 212
      goto while_break___2;
    }
    {
#line 213
    r = print_term(fp, x, buf, & tindex);
    }
#line 214
    if (r < 0) {
#line 214
      goto err;
    }
#line 215
    ch_written += r;
#line 216
    if (i < n - 1) {
      {
#line 217
      xputs(", ", fp, x);
#line 217
      ch_written += 2;
      }
    }
#line 212
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 220
  *index___0 = tindex;
#line 221
  xputc((char )'}', fp, x);
#line 221
  ch_written ++;
  }
#line 222
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 224
  tmp___21 = ei_malloc((long )n);
#line 224
  p = (char *)tmp___21;
  }
#line 225
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 225
    goto err;
  }
  {
#line 226
  tmp___22 = ei_decode_binary(buf, index___0, (void *)p, & l);
  }
#line 226
  if (tmp___22 < 0) {
    {
#line 227
    ei_free((void *)p);
    }
#line 228
    goto err;
  }
  {
#line 230
  tmp___23 = xprintf(fp, x, "#Bin<");
#line 230
  ch_written += tmp___23;
  }
#line 231
  if (l > 30L) {
#line 232
    m___0 = 30;
  } else {
#line 234
    m___0 = (int )l;
  }
#line 235
  m___0 --;
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 236
    if (! (i < m___0)) {
#line 236
      goto while_break___3;
    }
    {
#line 237
    tmp___24 = xprintf(fp, x, "%d,", (int )*(p + i));
#line 237
    ch_written += tmp___24;
#line 236
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 239
  tmp___25 = xprintf(fp, x, "%d", (int )*(p + i));
#line 239
  ch_written += tmp___25;
  }
#line 240
  if (l > 30L) {
    {
#line 241
    tmp___26 = xprintf(fp, x, ",...");
#line 241
    ch_written += tmp___26;
    }
  }
  {
#line 242
  xputc((char )'>', fp, x);
#line 242
  ch_written ++;
#line 243
  ei_free((void *)p);
  }
#line 244
  goto switch_break;
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  {
#line 247
  tmp___27 = ei_decode_long(buf, index___0, & l);
  }
#line 247
  if (tmp___27 < 0) {
#line 247
    goto err;
  }
  {
#line 248
  tmp___28 = xprintf(fp, x, "%ld", l);
#line 248
  ch_written += tmp___28;
  }
#line 249
  goto switch_break;
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 256
  b = ei_alloc_big((unsigned int )n);
#line 257
  tmp___29 = ei_decode_big(buf, index___0, b);
  }
#line 257
  if (tmp___29 < 0) {
    {
#line 258
    ei_free_big(b);
    }
#line 259
    goto err;
  }
  {
#line 262
  ds = ei_big_to_str(b);
  }
#line 262
  if ((unsigned long )ds == (unsigned long )((void *)0)) {
    {
#line 263
    ei_free_big(b);
    }
#line 264
    goto err;
  }
  {
#line 267
  tmp___30 = xprintf(fp, x, (char const   *)ds);
#line 267
  ch_written += tmp___30;
#line 268
  free((void *)ds);
#line 269
  ei_free_big(b);
  }
#line 272
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 275
  tmp___31 = ei_decode_double(buf, index___0, & d___0);
  }
#line 275
  if (tmp___31 < 0) {
#line 275
    goto err;
  }
  {
#line 276
  tmp___32 = xprintf(fp, x, "%f", d___0);
#line 276
  ch_written += tmp___32;
  }
#line 277
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 279
  goto err;
  switch_break: /* CIL Label */ ;
  }
#line 281
  return (ch_written);
  err: 
#line 283
  return (-1);
}
}
#line 286 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
static int print_string(FILE *fp , ei_x_buff *x , char *s , int len ) 
{ 
  int ch_written ;
  int c ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 288
  ch_written = 0;
#line 290
  xputc((char )'\"', fp, x);
#line 291
  ch_written ++;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (len > 0)) {
#line 292
      goto while_break;
    }
#line 293
    c = (int )*s;
#line 294
    if (c >= 32) {
      {
#line 295
      xputc((char )c, fp, x);
#line 295
      ch_written ++;
      }
    } else {
      {
#line 298
      if (c == 10) {
#line 298
        goto case_10;
      }
#line 299
      if (c == 13) {
#line 299
        goto case_13;
      }
#line 300
      if (c == 9) {
#line 300
        goto case_9;
      }
#line 301
      if (c == 11) {
#line 301
        goto case_11;
      }
#line 302
      if (c == 8) {
#line 302
        goto case_8;
      }
#line 303
      if (c == 12) {
#line 303
        goto case_12;
      }
#line 305
      goto switch_default;
      case_10: /* CIL Label */ 
      {
#line 298
      xputs("\\n", fp, x);
#line 298
      ch_written += 2;
      }
#line 298
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 299
      xputs("\\r", fp, x);
#line 299
      ch_written += 2;
      }
#line 299
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 300
      xputs("\\t", fp, x);
#line 300
      ch_written += 2;
      }
#line 300
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 301
      xputs("\\v", fp, x);
#line 301
      ch_written += 2;
      }
#line 301
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 302
      xputs("\\b", fp, x);
#line 302
      ch_written += 2;
      }
#line 302
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 303
      xputs("\\f", fp, x);
#line 303
      ch_written += 2;
      }
#line 303
      goto switch_break;
#line 304
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 306
      tmp = xprintf(fp, x, "\\x%x", c);
#line 306
      ch_written += tmp;
      }
#line 307
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 292
    s ++;
#line 292
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  xputc((char )'\"', fp, x);
#line 311
  ch_written ++;
  }
#line 312
  return (ch_written);
}
}
#line 322 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
int ei_print_term(FILE *fp , char const   *buf , int *index___0 ) 
{ 
  int tmp ;

  {
  {
#line 324
  tmp = print_term(fp, (ei_x_buff *)((void *)0), buf, index___0);
  }
#line 324
  return (tmp);
}
}
#line 327 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_printterm.c"
int ei_s_print_term(char **s , char const   *buf , int *index___0 ) 
{ 
  int r ;
  ei_x_buff x ;
  char *__cil_tmp6 ;

  {
#line 331
  if ((unsigned long )*s != (unsigned long )((void *)0)) {
#line 332
    x.buff = *s;
#line 333
    x.index = 0;
#line 334
    x.buffsz = 8192;
  } else {
    {
#line 336
    ei_x_new(& x);
    }
  }
  {
#line 338
  r = print_term((FILE *)((void *)0), & x, buf, index___0);
#line 339
  ei_x_append_buf(& x, "", 1);
#line 340
  *s = x.buff;
  }
#line 341
  return (r);
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 51 "/usr/include/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 129 "/usr/include/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 357 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.h"
int ei_accept_t(int fd , void *addr , void *addrlen , unsigned int ms ) ;
#line 26
int ei_read_fill(int fd , char *buf , int len ) ;
#line 27
int ei_write_fill(int fd , char const   *buf , int len ) ;
#line 109 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
static int ei_writev_t(int fd , struct iovec *iov , int iovcnt , unsigned int ms ) 
{ 
  int res ;
  fd_set writemask ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 112
  if (ms != 0U) {
#line 115
    tv.tv_sec = (time_t )(ms / 1000U);
#line 116
    ms %= 1000U;
#line 117
    tv.tv_usec = (time_t )(ms * 1000U);
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 118
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writemask.__fds_bits[0]): "memory");
#line 118
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 119
    writemask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 120
    tmp = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& writemask),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    {
#line 121
    if (tmp == -1) {
#line 121
      goto case_neg_1;
    }
#line 123
    if (tmp == 0) {
#line 123
      goto case_0;
    }
#line 125
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 122
    return (-1);
    case_0: /* CIL Label */ 
#line 124
    return (-2);
    switch_default: /* CIL Label */ 
#line 126
    if (! ((writemask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 127
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 131
  res = writev(fd, (struct iovec  const  *)iov, iovcnt);
  }
#line 132
  if (res < 0) {
#line 132
    tmp___0 = -1;
  } else {
#line 132
    tmp___0 = res;
  }
#line 132
  return (tmp___0);
}
}
#line 135 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_writev_fill_t(int fd , struct iovec  const  *iov , int iovcnt , unsigned int ms ) 
{ 
  int i ;
  int done ;
  struct iovec *iov_base ;
  struct iovec *current_iov ;
  int current_iovcnt ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 139
  iov_base = (struct iovec *)((void *)0);
#line 144
  sum = 0;
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < iovcnt)) {
#line 144
      goto while_break;
    }
#line 145
    sum = (int )((size_t const   )sum + (iov + i)->iov_len);
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  if (ms != 0U) {
    {
#line 148
    tmp = fcntl(fd, 3, 0);
#line 148
    fcntl(fd, 4, tmp | 2048);
    }
  }
#line 150
  current_iovcnt = iovcnt;
#line 151
  current_iov = (struct iovec *)iov;
#line 152
  done = 0;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 154
    i = ei_writev_t(fd, current_iov, current_iovcnt, ms);
    }
#line 155
    if (i <= 0) {
#line 156
      if (ms != 0U) {
        {
#line 157
        tmp___0 = fcntl(fd, 3, 0);
#line 157
        fcntl(fd, 4, tmp___0 & -2049);
        }
      }
#line 159
      if ((unsigned long )iov_base != (unsigned long )((void *)0)) {
        {
#line 160
        free((void *)iov_base);
        }
      }
#line 162
      return (i);
    }
#line 164
    done += i;
#line 166
    if (done < sum) {
#line 167
      if ((unsigned long )iov_base == (unsigned long )((void *)0)) {
        {
#line 168
        tmp___1 = malloc((size_t )(sizeof(struct iovec ) * (unsigned long )iovcnt));
#line 168
        iov_base = (struct iovec *)tmp___1;
#line 169
        memcpy((void */* __restrict  */)iov_base, (void const   */* __restrict  */)iov,
               (size_t )(sizeof(struct iovec ) * (unsigned long )iovcnt));
#line 170
        current_iov = iov_base;
        }
      }
      {
#line 172
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 172
        if (! (i > 0)) {
#line 172
          goto while_break___1;
        }
#line 173
        if ((size_t )i < (current_iov + 0)->iov_len) {
#line 174
          (current_iov + 0)->iov_len -= (size_t )i;
#line 175
          i = 0;
        } else {
#line 177
          i = (int )((size_t )i - (current_iov + 0)->iov_len);
#line 178
          current_iov ++;
#line 179
          current_iovcnt --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 183
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  if (ms != 0U) {
    {
#line 187
    tmp___2 = fcntl(fd, 3, 0);
#line 187
    fcntl(fd, 4, tmp___2 & -2049);
    }
  }
#line 189
  if ((unsigned long )iov_base != (unsigned long )((void *)0)) {
    {
#line 190
    free((void *)iov_base);
    }
  }
#line 192
  return (sum);
}
}
#line 198 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_connect_t(int fd , void *sinp , int sin_siz , unsigned int ms ) 
{ 
  int res ;
  int error ;
  int s_res ;
  struct timeval tv ;
  fd_set writefds ;
  fd_set exceptfds ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;

  {
#line 207
  if (ms == 0U) {
    {
#line 208
    res = connect(fd, (struct sockaddr  const  *)sinp, (socklen_t )sin_siz);
    }
#line 209
    if (res < 0) {
#line 209
      tmp = -1;
    } else {
#line 209
      tmp = res;
    }
#line 209
    return (tmp);
  } else {
    {
#line 211
    tmp___0 = fcntl(fd, 3, 0);
#line 211
    fcntl(fd, 4, tmp___0 | 2048);
#line 212
    res = connect(fd, (struct sockaddr  const  *)sinp, (socklen_t )sin_siz);
#line 213
    tmp___1 = __errno_location();
#line 213
    error = *tmp___1;
#line 214
    tmp___2 = fcntl(fd, 3, 0);
#line 214
    fcntl(fd, 4, tmp___2 & -2049);
    }
#line 215
    if (! (res < 0)) {
#line 216
      if (res < 0) {
#line 216
        tmp___3 = -1;
      } else {
#line 216
        tmp___3 = res;
      }
#line 216
      return (tmp___3);
    } else
#line 218
    if (error != 11) {
#line 218
      if (error != 115) {
#line 220
        return (-1);
      } else {
#line 218
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 222
      tv.tv_sec = (long )(ms / 1000U);
#line 223
      ms %= 1000U;
#line 224
      tv.tv_usec = (long )(ms * 1000U);
      {
#line 225
      while (1) {
        while_continue: /* CIL Label */ ;
#line 225
        __asm__  volatile   ("cld; rep; "
                             "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& writefds.__fds_bits[0]): "memory");
#line 225
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 226
      writefds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
      {
#line 227
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 227
        __asm__  volatile   ("cld; rep; "
                             "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& exceptfds.__fds_bits[0]): "memory");
#line 227
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 228
      exceptfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 229
      s_res = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& writefds),
                     (fd_set */* __restrict  */)(& exceptfds), (struct timeval */* __restrict  */)(& tv));
      }
      {
#line 231
      if (s_res == 0) {
#line 231
        goto case_0;
      }
#line 233
      if (s_res == 1) {
#line 233
        goto case_1;
      }
#line 239
      goto switch_default;
      case_0: /* CIL Label */ 
#line 232
      return (-2);
      case_1: /* CIL Label */ 
#line 234
      if ((exceptfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 235
        return (-1);
      } else {
#line 237
        return (0);
      }
      switch_default: /* CIL Label */ 
#line 240
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
}
}
#line 247 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_accept_t(int fd , void *addr , void *addrlen , unsigned int ms ) 
{ 
  int res ;
  fd_set readmask ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 250
  if (ms != 0U) {
#line 253
    tv.tv_sec = (time_t )(ms / 1000U);
#line 254
    ms %= 1000U;
#line 255
    tv.tv_usec = (time_t )(ms * 1000U);
    {
#line 256
    while (1) {
      while_continue: /* CIL Label */ ;
#line 256
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readmask.__fds_bits[0]): "memory");
#line 256
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 257
    readmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 258
    tmp = select(fd + 1, (fd_set */* __restrict  */)(& readmask), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    {
#line 259
    if (tmp == -1) {
#line 259
      goto case_neg_1;
    }
#line 261
    if (tmp == 0) {
#line 261
      goto case_0;
    }
#line 263
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 260
    return (-1);
    case_0: /* CIL Label */ 
#line 262
    return (-2);
    switch_default: /* CIL Label */ 
#line 264
    if (! ((readmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 265
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 269
  tmp___0 = accept(fd, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)addrlen);
#line 269
  res = tmp___0;
  }
#line 270
  if (res < 0) {
#line 270
    tmp___1 = -1;
  } else {
#line 270
    tmp___1 = res;
  }
#line 270
  return (tmp___1);
}
}
#line 275 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
static int ei_read_t(int fd , char *buf , int len , unsigned int ms ) 
{ 
  int res ;
  fd_set readmask ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 278
  if (ms != 0U) {
#line 281
    tv.tv_sec = (time_t )(ms / 1000U);
#line 282
    ms %= 1000U;
#line 283
    tv.tv_usec = (time_t )(ms * 1000U);
    {
#line 284
    while (1) {
      while_continue: /* CIL Label */ ;
#line 284
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readmask.__fds_bits[0]): "memory");
#line 284
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 285
    readmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 286
    tmp = select(fd + 1, (fd_set */* __restrict  */)(& readmask), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    {
#line 287
    if (tmp == -1) {
#line 287
      goto case_neg_1;
    }
#line 289
    if (tmp == 0) {
#line 289
      goto case_0;
    }
#line 291
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 288
    return (-1);
    case_0: /* CIL Label */ 
#line 290
    return (-2);
    switch_default: /* CIL Label */ 
#line 292
    if (! ((readmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 293
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 297
  res = read(fd, (void *)buf, (size_t )len);
  }
#line 298
  if (res < 0) {
#line 298
    tmp___0 = -1;
  } else {
#line 298
    tmp___0 = res;
  }
#line 298
  return (tmp___0);
}
}
#line 301 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
static int ei_write_t(int fd , char const   *buf , int len , unsigned int ms ) 
{ 
  int res ;
  fd_set writemask ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 304
  if (ms != 0U) {
#line 307
    tv.tv_sec = (time_t )(ms / 1000U);
#line 308
    ms %= 1000U;
#line 309
    tv.tv_usec = (time_t )(ms * 1000U);
    {
#line 310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 310
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writemask.__fds_bits[0]): "memory");
#line 310
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 311
    writemask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 312
    tmp = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& writemask),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    {
#line 313
    if (tmp == -1) {
#line 313
      goto case_neg_1;
    }
#line 315
    if (tmp == 0) {
#line 315
      goto case_0;
    }
#line 317
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 314
    return (-1);
    case_0: /* CIL Label */ 
#line 316
    return (-2);
    switch_default: /* CIL Label */ 
#line 318
    if (! ((writemask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 319
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 323
  res = write(fd, (void const   *)buf, (size_t )len);
  }
#line 324
  if (res < 0) {
#line 324
    tmp___0 = -1;
  } else {
#line 324
    tmp___0 = res;
  }
#line 324
  return (tmp___0);
}
}
#line 330 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_read_fill_t(int fd , char *buf , int len , unsigned int ms ) 
{ 
  int i ;
  int got ;

  {
#line 332
  got = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 335
    i = ei_read_t(fd, buf + got, len - got, ms);
    }
#line 336
    if (i <= 0) {
#line 337
      return (i);
    }
#line 338
    got += i;
#line 334
    if (! (got < len)) {
#line 334
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return (len);
}
}
#line 344 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_read_fill(int fd , char *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 346
  tmp = ei_read_fill_t(fd, buf, len, 0U);
  }
#line 346
  return (tmp);
}
}
#line 351 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_write_fill_t(int fd , char const   *buf , int len , unsigned int ms ) 
{ 
  int i ;
  int done ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 353
  done = 0;
#line 354
  if (ms != 0U) {
    {
#line 355
    tmp = fcntl(fd, 3, 0);
#line 355
    fcntl(fd, 4, tmp | 2048);
    }
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    i = ei_write_t(fd, buf + done, len - done, ms);
    }
#line 359
    if (i <= 0) {
#line 360
      if (ms != 0U) {
        {
#line 361
        tmp___0 = fcntl(fd, 3, 0);
#line 361
        fcntl(fd, 4, tmp___0 & -2049);
        }
      }
#line 363
      return (i);
    }
#line 365
    done += i;
#line 357
    if (! (done < len)) {
#line 357
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  if (ms != 0U) {
    {
#line 368
    tmp___1 = fcntl(fd, 3, 0);
#line 368
    fcntl(fd, 4, tmp___1 & -2049);
    }
  }
#line 370
  return (len);
}
}
#line 373 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_portio.c"
int ei_write_fill(int fd , char const   *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 375
  tmp = ei_write_fill_t(fd, buf, len, 0U);
  }
#line 375
  return (tmp);
}
}
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_malloc.c"
void *ei_malloc(long size ) 
{ 
  void *tmp ;

  {
  {
#line 30
  tmp = malloc((size_t )size);
  }
#line 30
  return (tmp);
}
}
#line 33 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_malloc.c"
void *ei_realloc(void *orig , long size ) 
{ 
  void *tmp ;

  {
  {
#line 35
  tmp = realloc(orig, (size_t )size);
  }
#line 35
  return (tmp);
}
}
#line 38 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_malloc.c"
void ei_free(void *ptr ) 
{ 


  {
  {
#line 40
  free(ptr);
  }
#line 41
  return;
}
}
#line 60 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.h"
ei_mutex_t *ei_mutex_create(void) ;
#line 61
int ei_mutex_free(ei_mutex_t *l , int nblock ) ;
#line 62
int ei_mutex_lock(ei_mutex_t *l , int nblock ) ;
#line 63
int ei_mutex_unlock(ei_mutex_t *l ) ;
#line 57 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.c"
ei_mutex_t *ei_mutex_create(void) 
{ 
  ei_mutex_t *l ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 61
  tmp = ei_malloc((long )sizeof(*l));
#line 61
  l = (ei_mutex_t *)tmp;
  }
#line 61
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 61
    return ((ei_mutex_t *)((void *)0));
  }
  {
#line 72
  tmp___0 = ei_m_create();
#line 72
  l->lock = (pthread_mutex_t *)tmp___0;
  }
#line 75
  return (l);
}
}
#line 91 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.c"
int ei_mutex_free(ei_mutex_t *l , int nblock ) 
{ 
  int tmp ;

  {
  {
#line 94
  tmp = ei_mutex_lock(l, nblock);
  }
#line 94
  if (tmp) {
#line 94
    return (-1);
  }
  {
#line 104
  ei_m_destroy((void *)l->lock);
#line 107
  ei_free((void *)l);
  }
#line 109
  return (0);
}
}
#line 127 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.c"
int ei_mutex_lock(ei_mutex_t *l , int nblock ) 
{ 
  int tmp ;

  {
#line 139
  if (nblock) {
    {
#line 140
    tmp = ei_m_trylock((void *)l->lock);
    }
#line 140
    if (tmp < 0) {
#line 140
      return (-1);
    }
  } else {
    {
#line 142
    ei_m_lock((void *)l->lock);
    }
  }
#line 145
  return (0);
}
}
#line 149 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_locking.c"
int ei_mutex_unlock(ei_mutex_t *l ) 
{ 


  {
  {
#line 158
  ei_m_unlock((void *)l->lock);
  }
#line 161
  return (0);
}
}
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 501 "../include/ei.h"
int ei_x_format(ei_x_buff *x , char const   *fmt  , ...) ;
#line 502
int ei_x_format_wo_ver(ei_x_buff *x , char const   *fmt  , ...) ;
#line 56 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int eiformat(char const   **fmt , union arg **args , ei_x_buff *x ) ;
#line 59
static int pformat(char const   **fmt , union arg **args , ei_x_buff *x ) ;
#line 60
static int plist(char const   **fmt , union arg **args , ei_x_buff *x , int size ) ;
#line 61
static int ptuple(char const   **fmt , union arg **args , ei_x_buff *x , int size ) ;
#line 62
static int pquotedatom(char const   **fmt , ei_x_buff *x ) ;
#line 63
static int pdigit(char const   **fmt , ei_x_buff *x ) ;
#line 64
static int patom(char const   **fmt , ei_x_buff *x ) ;
#line 65
static int pstring(char const   **fmt , ei_x_buff *x ) ;
#line 68 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int eiformat(char const   **fmt , union arg **args , ei_x_buff *x ) 
{ 
  char const   *p ;
  int res ;
  ei_x_buff x2 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 70
  p = *fmt;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    tmp = __ctype_b_loc();
    }
#line 74
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 74
      goto while_break;
    }
#line 75
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  if ((int const   )*p == 126) {
#line 77
    goto case_126;
  }
#line 80
  if ((int const   )*p == 91) {
#line 80
    goto case_91;
  }
#line 90
  if ((int const   )*p == 123) {
#line 90
    goto case_123;
  }
#line 100
  if ((int const   )*p == 34) {
#line 100
    goto case_34;
  }
#line 103
  if ((int const   )*p == 39) {
#line 103
    goto case_39;
  }
#line 106
  goto switch_default;
  case_126: /* CIL Label */ 
  {
#line 78
  res = pformat(& p, args, x);
  }
#line 79
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 81
  res = ei_x_new(& x2);
  }
#line 82
  if (res >= 0) {
    {
#line 83
    res = plist(& p, args, & x2, 0);
    }
  }
#line 84
  if (res > 0) {
    {
#line 85
    res = ei_x_encode_list_header(x, (long )res);
    }
  }
#line 86
  if (res >= 0) {
    {
#line 87
    res = ei_x_append(x, (ei_x_buff const   *)(& x2));
    }
  }
  {
#line 88
  ei_x_free(& x2);
  }
#line 89
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 91
  res = ei_x_new(& x2);
  }
#line 92
  if (res >= 0) {
    {
#line 93
    res = ptuple(& p, args, & x2, 0);
    }
  }
#line 94
  if (res >= 0) {
    {
#line 95
    res = ei_x_encode_tuple_header(x, (long )res);
    }
  }
#line 96
  if (res >= 0) {
    {
#line 97
    res = ei_x_append(x, (ei_x_buff const   *)(& x2));
    }
  }
  {
#line 98
  ei_x_free(& x2);
  }
#line 99
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 101
  res = pstring(& p, x);
  }
#line 102
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 104
  res = pquotedatom(& p, x);
  }
#line 105
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 107
  tmp___1 = __ctype_b_loc();
  }
#line 107
  if ((int const   )*(*tmp___1 + (int )*p) & 2048) {
    {
#line 108
    res = pdigit(& p, x);
    }
  } else {
    {
#line 109
    tmp___0 = __ctype_b_loc();
    }
#line 109
    if ((int const   )*(*tmp___0 + (int )*p) & 512) {
      {
#line 110
      res = patom(& p, x);
      }
    } else {
#line 112
      res = -1;
    }
  }
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  *fmt = p;
#line 119
  return (res);
}
}
#line 122 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int patom(char const   **fmt , ei_x_buff *x ) 
{ 
  char const   *start ;
  char c ;
  int len ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
#line 124
  start = *fmt;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp = *fmt;
#line 129
    (*fmt) ++;
#line 129
    c = (char )*tmp;
#line 130
    tmp___0 = __ctype_b_loc();
    }
#line 130
    if (! ((int const   )*(*tmp___0 + (int )c) & 8)) {
#line 130
      if ((int )c == 95) {
#line 131
        goto __Cont;
      } else
#line 130
      if (! ((int )c == 64)) {
#line 133
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  (*fmt) --;
#line 136
  len = (int )(*fmt - start);
#line 138
  if (len > 255) {
#line 139
    len = 255;
  }
  {
#line 140
  tmp___1 = ei_x_encode_atom_len(x, start, len);
  }
#line 140
  return (tmp___1);
}
}
#line 144 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int pdigit(char const   **fmt , ei_x_buff *x ) 
{ 
  char const   *start ;
  char c ;
  int len ;
  int dotp ;
  double d___0 ;
  long l ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 146
  start = *fmt;
#line 148
  dotp = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    tmp = *fmt;
#line 153
    (*fmt) ++;
#line 153
    c = (char )*tmp;
#line 154
    tmp___0 = __ctype_b_loc();
    }
#line 154
    if (! ((int const   )*(*tmp___0 + (int )c) & 2048)) {
#line 156
      if (! dotp) {
#line 156
        if ((int )c == 46) {
#line 157
          dotp = 1;
#line 158
          goto __Cont;
        } else {
#line 160
          goto while_break;
        }
      } else {
#line 160
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  (*fmt) --;
#line 163
  len = (int )(*fmt - start);
#line 164
  if (dotp) {
    {
#line 165
    sscanf((char const   */* __restrict  */)start, (char const   */* __restrict  */)"%lf",
           & d___0);
#line 166
    tmp___1 = ei_x_encode_double(x, d___0);
    }
#line 166
    return (tmp___1);
  } else {
    {
#line 168
    sscanf((char const   */* __restrict  */)start, (char const   */* __restrict  */)"%ld",
           & l);
#line 169
    tmp___2 = ei_x_encode_long(x, l);
    }
#line 169
    return (tmp___2);
  }
}
}
#line 174 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int pstring(char const   **fmt , ei_x_buff *x ) 
{ 
  char const   *start ;
  char c ;
  int res ;
  char const   *tmp ;

  {
#line 176
  (*fmt) ++;
#line 176
  start = *fmt;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    tmp = *fmt;
#line 181
    (*fmt) ++;
#line 181
    c = (char )*tmp;
#line 182
    if ((int )c == 0) {
#line 183
      return (-1);
    }
#line 184
    if ((int )c == 34) {
#line 185
      if ((int const   )*(*fmt - 1) == 92) {
#line 186
        goto __Cont;
      } else {
#line 188
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  res = ei_x_encode_string_len(x, start, (int )((*fmt - start) - 1L));
  }
#line 193
  return (res);
}
}
#line 197 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int pquotedatom(char const   **fmt , ei_x_buff *x ) 
{ 
  char const   *start ;
  char c ;
  int res ;
  char const   *tmp ;

  {
#line 199
  (*fmt) ++;
#line 199
  start = *fmt;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    tmp = *fmt;
#line 204
    (*fmt) ++;
#line 204
    c = (char )*tmp;
#line 205
    if ((int )c == 0) {
#line 206
      return (-1);
    }
#line 207
    if ((int )c == 39) {
#line 208
      if ((int const   )*(*fmt - 1) == 92) {
#line 209
        goto __Cont;
      } else {
#line 211
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 215
  res = ei_x_encode_atom_len(x, start, (int )((*fmt - start) - 1L));
  }
#line 216
  return (res);
}
}
#line 230 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int pformat(char const   **fmt , union arg **args , ei_x_buff *x ) 
{ 
  int res ;
  char const   *tmp ;

  {
#line 232
  res = 0;
#line 233
  (*fmt) ++;
#line 234
  tmp = *fmt;
#line 234
  (*fmt) ++;
  {
#line 235
  if ((int const   )*tmp == 97) {
#line 235
    goto case_97;
  }
#line 239
  if ((int const   )*tmp == 115) {
#line 239
    goto case_115;
  }
#line 243
  if ((int const   )*tmp == 105) {
#line 243
    goto case_105;
  }
#line 247
  if ((int const   )*tmp == 108) {
#line 247
    goto case_108;
  }
#line 251
  if ((int const   )*tmp == 117) {
#line 251
    goto case_117;
  }
#line 256
  if ((int const   )*tmp == 100) {
#line 256
    goto case_100;
  }
#line 256
  if ((int const   )*tmp == 102) {
#line 256
    goto case_100;
  }
#line 260
  goto switch_default;
  case_97: /* CIL Label */ 
  {
#line 236
  res = ei_x_encode_atom(x, (char const   *)(*args)->s);
#line 237
  (*args) ++;
  }
#line 238
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 240
  res = ei_x_encode_string(x, (char const   *)(*args)->s);
#line 241
  (*args) ++;
  }
#line 242
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 244
  res = ei_x_encode_long(x, (*args)->l);
#line 245
  (*args) ++;
  }
#line 246
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 248
  res = ei_x_encode_long(x, (*args)->l);
#line 249
  (*args) ++;
  }
#line 250
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 252
  res = ei_x_encode_ulong(x, (*args)->u);
#line 253
  (*args) ++;
  }
#line 254
  goto switch_break;
  case_100: /* CIL Label */ 
  case_102: /* CIL Label */ 
  {
#line 257
  res = ei_x_encode_double(x, (*args)->d);
#line 258
  (*args) ++;
  }
#line 259
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 261
  res = -1;
#line 262
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 264
  return (res);
}
}
#line 268 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int ptuple(char const   **fmt , union arg **args , ei_x_buff *x , int size ) 
{ 
  int res ;
  char const   *p ;
  char after ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;

  {
#line 270
  res = 0;
#line 271
  p = *fmt;
#line 272
  tmp = p;
#line 272
  p ++;
#line 272
  after = (char )*tmp;
#line 274
  if ((int )after == 125) {
#line 275
    *fmt = p;
#line 276
    return (size);
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 278
    tmp___0 = __ctype_b_loc();
    }
#line 278
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 278
      goto while_break;
    }
#line 279
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  tmp___1 = p;
#line 280
  p ++;
  {
#line 281
  if ((int const   )*tmp___1 == 125) {
#line 281
    goto case_125;
  }
#line 287
  if ((int const   )*tmp___1 == 44) {
#line 287
    goto case_44;
  }
#line 293
  goto switch_default;
  case_125: /* CIL Label */ 
#line 282
  if ((int )after == 44) {
#line 283
    res = -1;
  } else {
#line 285
    res = size;
  }
#line 286
  goto switch_break;
  case_44: /* CIL Label */ 
#line 288
  if ((int )after == 44) {
#line 289
    res = -1;
  } else
#line 288
  if ((int )after == 123) {
#line 289
    res = -1;
  } else {
    {
#line 291
    res = ptuple(& p, args, x, size);
    }
  }
#line 292
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 294
  p --;
#line 295
  res = eiformat(& p, args, x);
  }
#line 296
  if (res >= 0) {
    {
#line 297
    res = ptuple(& p, args, x, size + 1);
    }
  }
#line 298
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 303
  *fmt = p;
#line 304
  return (res);
}
}
#line 308 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int plist(char const   **fmt , union arg **args , ei_x_buff *x , int size ) 
{ 
  int res ;
  char const   *p ;
  char after ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 310
  res = 0;
#line 311
  p = *fmt;
#line 312
  tmp = p;
#line 312
  p ++;
#line 312
  after = (char )*tmp;
#line 314
  if ((int )after == 93) {
#line 315
    p --;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    tmp___0 = __ctype_b_loc();
    }
#line 316
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 316
      goto while_break;
    }
#line 317
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  tmp___1 = p;
#line 318
  p ++;
  {
#line 319
  if ((int const   )*tmp___1 == 93) {
#line 319
    goto case_93;
  }
#line 328
  if ((int const   )*tmp___1 == 124) {
#line 328
    goto case_124;
  }
#line 334
  if ((int const   )*tmp___1 == 44) {
#line 334
    goto case_44;
  }
#line 340
  goto switch_default;
  case_93: /* CIL Label */ 
#line 320
  if ((int )after == 44) {
#line 321
    res = -1;
  } else {
#line 323
    if ((int )after != 124) {
      {
#line 324
      ei_x_encode_empty_list(x);
      }
    }
#line 325
    res = size;
  }
#line 327
  goto switch_break;
  case_124: /* CIL Label */ 
#line 329
  if ((int )after == 124) {
#line 330
    res = -1;
  } else
#line 329
  if ((int )after == 44) {
#line 330
    res = -1;
  } else {
    {
#line 332
    res = plist(& p, args, x, size);
    }
  }
#line 333
  goto switch_break;
  case_44: /* CIL Label */ 
#line 335
  if ((int )after == 124) {
#line 336
    res = -1;
  } else
#line 335
  if ((int )after == 44) {
#line 336
    res = -1;
  } else {
    {
#line 338
    res = plist(& p, args, x, size);
    }
  }
#line 339
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 341
  p --;
#line 342
  res = eiformat(& p, args, x);
#line 343
  size ++;
  }
#line 344
  if (res >= 0) {
#line 345
    if ((int )after == 124) {
      {
#line 346
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 346
        tmp___2 = __ctype_b_loc();
        }
#line 346
        if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 346
          goto while_break___0;
        }
#line 347
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 348
      if ((int const   )*p != 93) {
#line 349
        res = -1;
      }
    } else {
      {
#line 351
      res = plist(& p, args, x, size);
      }
    }
  }
#line 353
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 358
  *fmt = p;
#line 359
  return (res);
}
}
#line 362 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
static int read_args(char const   *fmt , va_list ap , union arg **argp ) 
{ 
  char const   *p ;
  int arg_count ;
  union arg *args ;
  int i ;
  char const   *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  char const   *tmp___10 ;

  {
#line 364
  p = fmt;
#line 365
  arg_count = 0;
#line 367
  i = 0;
#line 371
  *argp = (union arg *)((void *)0);
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! *p) {
#line 373
      goto while_break;
    }
#line 373
    tmp = p;
#line 373
    p ++;
#line 373
    if ((int const   )*tmp == 126) {
#line 373
      arg_count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  if (! arg_count) {
#line 377
    return (0);
  }
  {
#line 381
  tmp___0 = ei_malloc((long )((unsigned long )arg_count * sizeof(union arg )));
#line 381
  args = (union arg *)tmp___0;
  }
#line 383
  if (! args) {
#line 384
    return (-1);
  }
#line 386
  p = fmt;
  {
#line 388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 388
    if (! *p) {
#line 388
      goto while_break___0;
    }
#line 389
    tmp___10 = p;
#line 389
    p ++;
#line 389
    if ((int const   )*tmp___10 == 126) {
#line 390
      if (! *p) {
        {
#line 391
        ei_free((void *)args);
        }
#line 392
        return (-1);
      }
#line 394
      tmp___1 = p;
#line 394
      p ++;
      {
#line 396
      if ((int const   )*tmp___1 == 115) {
#line 396
        goto case_115;
      }
#line 396
      if ((int const   )*tmp___1 == 97) {
#line 396
        goto case_115;
      }
#line 404
      if ((int const   )*tmp___1 == 108) {
#line 404
        goto case_108;
      }
#line 404
      if ((int const   )*tmp___1 == 105) {
#line 404
        goto case_108;
      }
#line 407
      if ((int const   )*tmp___1 == 117) {
#line 407
        goto case_117;
      }
#line 411
      if ((int const   )*tmp___1 == 100) {
#line 411
        goto case_100;
      }
#line 411
      if ((int const   )*tmp___1 == 102) {
#line 411
        goto case_100;
      }
#line 414
      goto switch_default;
      case_115: /* CIL Label */ 
      case_97: /* CIL Label */ 
      {
#line 397
      tmp___2 = i;
#line 397
      i ++;
#line 397
      tmp___3 = __builtin_va_arg(ap, char *);
#line 397
      (args + tmp___2)->s = tmp___3;
      }
#line 398
      goto switch_break;
      case_108: /* CIL Label */ 
      case_105: /* CIL Label */ 
      {
#line 405
      tmp___4 = i;
#line 405
      i ++;
#line 405
      tmp___5 = __builtin_va_arg(ap, long );
#line 405
      (args + tmp___4)->l = tmp___5;
      }
#line 406
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 408
      tmp___6 = i;
#line 408
      i ++;
#line 408
      tmp___7 = __builtin_va_arg(ap, unsigned long );
#line 408
      (args + tmp___6)->u = tmp___7;
      }
#line 409
      goto switch_break;
      case_100: /* CIL Label */ 
      case_102: /* CIL Label */ 
      {
#line 412
      tmp___8 = i;
#line 412
      i ++;
#line 412
      tmp___9 = __builtin_va_arg(ap, double );
#line 412
      (args + tmp___8)->d = tmp___9;
      }
#line 413
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 415
      ei_free((void *)args);
      }
#line 416
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  *argp = args;
#line 421
  return (0);
}
}
#line 424 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
int ei_x_format(ei_x_buff *x , char const   *fmt  , ...) 
{ 
  va_list ap ;
  union arg *args ;
  union arg *saved_args ;
  int res ;

  {
  {
#line 431
  res = ei_x_encode_version(x);
  }
#line 432
  if (res < 0) {
#line 432
    return (res);
  }
  {
#line 434
  __builtin_va_start(ap, fmt);
#line 435
  res = read_args(fmt, ap, & args);
#line 436
  saved_args = args;
#line 437
  __builtin_va_end(ap);
  }
#line 438
  if (res < 0) {
#line 439
    return (-1);
  }
  {
#line 442
  res = eiformat(& fmt, & args, x);
#line 443
  ei_free((void *)saved_args);
  }
#line 445
  return (res);
}
}
#line 448 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_format.c"
int ei_x_format_wo_ver(ei_x_buff *x , char const   *fmt  , ...) 
{ 
  va_list ap ;
  union arg *args ;
  union arg *saved_args ;
  int res ;

  {
  {
#line 455
  __builtin_va_start(ap, fmt);
#line 456
  res = read_args(fmt, ap, & args);
#line 457
  saved_args = args;
#line 458
  __builtin_va_end(ap);
  }
#line 459
  if (res < 0) {
#line 460
    return (-1);
  }
  {
#line 462
  res = eiformat(& fmt, & args, x);
#line 463
  ei_free((void *)saved_args);
  }
#line 465
  return (res);
}
}
#line 487 "../include/ei.h"
int ei_decode_ei_term(char const   *buf , int *index___0 , ei_term *term ) ;
#line 32 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_decode_term.c"
int ei_decode_ei_term(char const   *buf , int *index___0 , ei_term *term ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int len ;
  int i ;
  int n ;
  int sign ;
  char c ;
  double f ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp15 ;

  {
#line 34
  s = buf + *index___0;
#line 34
  s0 = s;
#line 39
  if ((unsigned long )term == (unsigned long )((void *)0)) {
#line 39
    return (-1);
  }
#line 40
  s ++;
#line 40
  tmp = (char )((int )*((unsigned char *)s + -1) & 255);
#line 40
  term->ei_type = tmp;
#line 40
  c = tmp;
  {
#line 42
  if ((int )c == 97) {
#line 42
    goto case_97;
  }
#line 45
  if ((int )c == 98) {
#line 45
    goto case_98;
  }
#line 48
  if ((int )c == 99) {
#line 48
    goto case_99;
  }
#line 54
  if ((int )c == 100) {
#line 54
    goto case_100;
  }
#line 60
  if ((int )c == 101) {
#line 60
    goto case_101;
  }
#line 72
  if ((int )c == 114) {
#line 72
    goto case_114;
  }
#line 91
  if ((int )c == 102) {
#line 91
    goto case_102;
  }
#line 99
  if ((int )c == 103) {
#line 99
    goto case_103;
  }
#line 111
  if ((int )c == 104) {
#line 111
    goto case_104;
  }
#line 114
  if ((int )c == 105) {
#line 114
    goto case_105;
  }
#line 117
  if ((int )c == 106) {
#line 117
    goto case_106;
  }
#line 120
  if ((int )c == 107) {
#line 120
    goto case_107;
  }
#line 123
  if ((int )c == 108) {
#line 123
    goto case_108;
  }
#line 126
  if ((int )c == 109) {
#line 126
    goto case_109;
  }
#line 129
  if ((int )c == 110) {
#line 129
    goto case_110;
  }
#line 143
  if ((int )c == 111) {
#line 143
    goto case_111;
  }
#line 145
  if ((int )c == 112) {
#line 145
    goto case_112;
  }
#line 147
  if ((int )c == 78) {
#line 147
    goto case_78;
  }
#line 149
  if ((int )c == 67) {
#line 149
    goto case_67;
  }
#line 151
  goto switch_default;
  case_97: /* CIL Label */ 
#line 43
  s ++;
#line 43
  term->value.i_val = (long )((int )*((unsigned char *)s + -1) & 255);
#line 44
  goto switch_break;
  case_98: /* CIL Label */ 
#line 46
  s += 4;
#line 46
  term->value.i_val = (long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 47
  goto switch_break;
  case_99: /* CIL Label */ 
#line 49
  if (*(s + 30)) {
#line 49
    return (-1);
  }
  {
#line 50
  tmp___0 = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%lf",
                   & f);
  }
#line 50
  if (tmp___0 != 1) {
#line 50
    return (-1);
  }
#line 51
  s += 31;
#line 52
  term->value.d_val = f;
#line 53
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 55
  s += 2;
#line 55
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 56
  memcpy((void */* __restrict  */)(term->value.atom_name), (void const   */* __restrict  */)s,
         (size_t )len);
#line 57
  term->value.atom_name[len] = (char )'\000';
#line 58
  s += len;
  }
#line 59
  goto switch_break;
  case_101: /* CIL Label */ 
#line 62
  s ++;
#line 62
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 62
    return (-1);
  }
  {
#line 63
  s += 2;
#line 63
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 64
  memcpy((void */* __restrict  */)(term->value.ref.node), (void const   */* __restrict  */)s,
         (size_t )len);
#line 65
  term->value.ref.node[len] = (char )'\000';
#line 66
  s += len;
#line 68
  s += 4;
#line 68
  term->value.ref.n[0] = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 69
  term->value.ref.len = 1;
#line 70
  s ++;
#line 70
  term->value.ref.creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  }
#line 71
  goto switch_break;
  case_114: /* CIL Label */ 
#line 74
  s += 2;
#line 74
  term->value.ref.len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 76
  s ++;
#line 76
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 76
    return (-1);
  }
  {
#line 77
  s += 2;
#line 77
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 78
  memcpy((void */* __restrict  */)(term->value.ref.node), (void const   */* __restrict  */)s,
         (size_t )len);
#line 79
  term->value.ref.node[len] = (char )'\000';
#line 80
  s += len;
#line 82
  s ++;
#line 82
  term->value.ref.creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
#line 84
  i = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (i < term->value.ref.len) {
#line 84
      if (! (i < 3)) {
#line 84
        goto while_break;
      }
    } else {
#line 84
      goto while_break;
    }
#line 85
    s += 4;
#line 85
    term->value.ref.n[i] = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  if (term->value.ref.len > 3) {
#line 88
    s += 4 * (term->value.ref.len - 3);
  }
#line 90
  goto switch_break;
  case_102: /* CIL Label */ 
#line 92
  s ++;
#line 92
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 92
    return (-1);
  }
  {
#line 93
  s += 2;
#line 93
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 94
  memcpy((void */* __restrict  */)(term->value.port.node), (void const   */* __restrict  */)s,
         (size_t )len);
#line 95
  term->value.port.node[len] = (char )'\000';
#line 96
  s += 4;
#line 96
  term->value.port.id = (unsigned int )((((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1)) & 268435455);
#line 97
  s ++;
#line 97
  term->value.port.creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  }
#line 98
  goto switch_break;
  case_103: /* CIL Label */ 
#line 100
  s ++;
#line 100
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 100
    return (-1);
  }
  {
#line 102
  s += 2;
#line 102
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 103
  memcpy((void */* __restrict  */)(term->value.pid.node), (void const   */* __restrict  */)s,
         (size_t )len);
#line 104
  term->value.pid.node[len] = (char )'\000';
#line 105
  s += len;
#line 107
  s += 4;
#line 107
  term->value.pid.num = (unsigned int )((((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1)) & 32767);
#line 108
  s += 4;
#line 108
  term->value.pid.serial = (unsigned int )((((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1)) & 8191);
#line 109
  s ++;
#line 109
  term->value.pid.creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  }
#line 110
  goto switch_break;
  case_104: /* CIL Label */ 
#line 112
  s ++;
#line 112
  term->arity = (int )*((unsigned char *)s + -1) & 255;
#line 113
  goto switch_break;
  case_105: /* CIL Label */ 
#line 115
  s += 4;
#line 115
  term->arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 116
  goto switch_break;
  case_106: /* CIL Label */ 
#line 118
  term->arity = 0;
#line 119
  goto switch_break;
  case_107: /* CIL Label */ 
#line 121
  s += 2;
#line 121
  term->size = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 122
  return (0);
  case_108: /* CIL Label */ 
#line 124
  s += 4;
#line 124
  term->arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 125
  goto switch_break;
  case_109: /* CIL Label */ 
#line 127
  s += 4;
#line 127
  term->size = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 128
  return (0);
  case_110: /* CIL Label */ 
#line 130
  s ++;
#line 130
  tmp___1 = (int )*((unsigned char *)s + -1) & 255;
#line 130
  term->arity = tmp___1;
#line 130
  if (tmp___1 != 4) {
#line 130
    return (-1);
  }
#line 131
  s ++;
#line 131
  sign = (int )*((unsigned char *)s + -1) & 255;
#line 133
  s += 4;
#line 133
  n = ((((int )*((unsigned char *)s + -1) << 24) | ((int )*((unsigned char *)s + -2) << 16)) | ((int )*((unsigned char *)s + -3) << 8)) | (int )*((unsigned char *)s + -4);
#line 134
  if (sign) {
#line 136
    if (n - 1 < 0) {
#line 136
      return (-1);
    }
#line 137
    n = - n;
  } else
#line 140
  if (n < 0) {
#line 140
    return (-1);
  }
#line 142
  goto switch_break;
  case_111: /* CIL Label */ 
#line 144
  return (0);
  case_112: /* CIL Label */ 
#line 146
  return (0);
  case_78: /* CIL Label */ 
#line 148
  return (-1);
  case_67: /* CIL Label */ 
#line 150
  return (-1);
  switch_default: /* CIL Label */ 
#line 152
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 154
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 155
  return (1);
}
}
#line 133 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 298 "../include/ei.h"
int ei_connect_init(ei_cnode *ec , char const   *this_node_name , char const   *cookie ,
                    short creation ) ;
#line 300
int ei_connect_xinit(ei_cnode *ec , char const   *thishostname , char const   *thisalivename ,
                     char const   *thisnodename , Erl_IpAddr thisipaddr , char const   *cookie ,
                     short const   creation ) ;
#line 305
int ei_connect(ei_cnode *ec , char *nodename ) ;
#line 306
int ei_connect_tmo(ei_cnode *ec , char *nodename , unsigned int ms ) ;
#line 307
int ei_xconnect(ei_cnode *ec , Erl_IpAddr adr , char *alivename ) ;
#line 308
int ei_xconnect_tmo(ei_cnode *ec , Erl_IpAddr adr , char *alivename , unsigned int ms ) ;
#line 310
int ei_receive(int fd , unsigned char *bufp , int bufsize ) ;
#line 311
int ei_receive_tmo(int fd , unsigned char *bufp , int bufsize , unsigned int ms ) ;
#line 312
int ei_receive_msg(int fd , erlang_msg *msg , ei_x_buff *x ) ;
#line 313
int ei_receive_msg_tmo(int fd , erlang_msg *msg , ei_x_buff *x , unsigned int ms ) ;
#line 314
int ei_xreceive_msg(int fd , erlang_msg *msg , ei_x_buff *x ) ;
#line 315
int ei_xreceive_msg_tmo(int fd , erlang_msg *msg , ei_x_buff *x , unsigned int ms ) ;
#line 317
int ei_send(int fd , erlang_pid *to , char *buf , int len ) ;
#line 318
int ei_send_tmo(int fd , erlang_pid *to , char *buf , int len , unsigned int ms ) ;
#line 319
int ei_reg_send(ei_cnode *ec , int fd , char *server_name , char *buf , int len ) ;
#line 320
int ei_reg_send_tmo(ei_cnode *ec , int fd , char *server_name , char *buf , int len ,
                    unsigned int ms ) ;
#line 322
int ei_rpc(ei_cnode *ec , int fd , char *mod , char *fun , char const   *inbuf , int inbuflen ,
           ei_x_buff *x ) ;
#line 324
int ei_rpc_to(ei_cnode *ec , int fd , char *mod , char *fun , char const   *buf ,
              int len ) ;
#line 326
int ei_rpc_from(ei_cnode *ec , int fd , int timeout , erlang_msg *msg , ei_x_buff *x ) ;
#line 331
int ei_accept(ei_cnode *ec , int lfd , ErlConnect *conp ) ;
#line 332
int ei_accept_tmo(ei_cnode *ec , int lfd , ErlConnect *conp , unsigned int ms ) ;
#line 337
char const   *ei_thishostname(ei_cnode const   *ec ) ;
#line 340
erlang_pid *ei_self(ei_cnode *ec ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 623 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 692
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 895
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 980
extern long gethostid(void) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 183 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 82 "/usr/include/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 156 "misc/ei_internal.h"
int ei_internal_use_r9_pids_ports(void) ;
#line 109 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect_int.h"
char const   *ei_thiscookie(ei_cnode const   *ec ) ;
#line 111
int ei_do_receive_msg(int fd , int staticbuffer_p , erlang_msg *msg , ei_x_buff *x ,
                      unsigned int ms ) ;
#line 58 "misc/ei_locking.h"
ei_mutex_t *ei_sockets_lock ;
#line 100 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_tracelevel  =    0;
#line 106 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static char *null_cookie  =    (char *)"";
#line 108
static int get_cookie(char *buf , int bufsize ) ;
#line 109
static int get_home(char *buf , int size ) ;
#line 112
static unsigned int gen_challenge(void) ;
#line 113
static void gen_digest(unsigned int challenge , char *cookie , unsigned char *digest ) ;
#line 115
static int send_status(int fd , char *status , unsigned int ms ) ;
#line 116
static int recv_status(int fd , unsigned int ms ) ;
#line 117
static int send_challenge(int fd , char *nodename , unsigned int challenge , unsigned int version ,
                          unsigned int ms ) ;
#line 119
static int recv_challenge(int fd , unsigned int *challenge , unsigned int *version ,
                          unsigned int *flags , ErlConnect *namebuf , unsigned int ms ) ;
#line 122
static int send_challenge_reply(int fd , unsigned char *digest , unsigned int challenge ,
                                unsigned int ms ) ;
#line 124
static int recv_challenge_reply(int fd , unsigned int our_challenge , char *cookie ,
                                unsigned int *her_challenge , unsigned int ms ) ;
#line 128
static int send_challenge_ack(int fd , unsigned char *digest , unsigned int ms ) ;
#line 129
static int recv_challenge_ack(int fd , unsigned int our_challenge , char *cookie ,
                              unsigned int ms ) ;
#line 132
static int send_name(int fd , char *nodename , unsigned int version , unsigned int ms ) ;
#line 136
static int recv_name(int fd , unsigned int *version , unsigned int *flags , ErlConnect *namebuf ,
                     unsigned int ms ) ;
#line 156 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_n_sockets  =    0;
#line 156 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_sz_sockets  =    0;
#line 157 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
ei_socket_info *ei_sockets  =    (ei_socket_info *)((void *)0);
#line 159 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
ei_mutex_t *ei_sockets_lock  =    (ei_mutex_t *)((void *)0);
#line 169 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int put_ei_socket_info(int fd , int dist_version , char *cookie , ei_cnode *ec ) 
{ 
  int i ;
  void *tmp ;

  {
  {
#line 174
  ei_mutex_lock(ei_sockets_lock, 0);
#line 176
  i = 0;
  }
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < ei_n_sockets)) {
#line 176
      goto while_break;
    }
#line 177
    if ((ei_sockets + i)->socket == fd) {
#line 178
      if (dist_version == -1) {
        {
#line 179
        memmove((void *)(ei_sockets + i), (void const   *)(ei_sockets + (i + 1)),
                (size_t )(sizeof(*(ei_sockets + 0)) * (unsigned long )((ei_n_sockets - i) - 1)));
        }
      } else {
        {
#line 182
        (ei_sockets + i)->dist_version = dist_version;
#line 184
        (ei_sockets + i)->cnode = *ec;
#line 185
        strcpy((char */* __restrict  */)((ei_sockets + i)->cookie), (char const   */* __restrict  */)cookie);
        }
      }
      {
#line 188
      ei_mutex_unlock(ei_sockets_lock);
      }
#line 190
      return (0);
    }
#line 176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (ei_n_sockets == ei_sz_sockets) {
    {
#line 194
    ei_sz_sockets += 5;
#line 195
    tmp = realloc((void *)ei_sockets, (size_t )(sizeof(*(ei_sockets + 0)) * (unsigned long )ei_sz_sockets));
#line 195
    ei_sockets = (ei_socket_info *)tmp;
    }
#line 197
    if ((unsigned long )ei_sockets == (unsigned long )((void *)0)) {
      {
#line 198
      ei_n_sockets = 0;
#line 198
      ei_sz_sockets = ei_n_sockets;
#line 200
      ei_mutex_unlock(ei_sockets_lock);
      }
#line 202
      return (-1);
    }
    {
#line 204
    (ei_sockets + ei_n_sockets)->socket = fd;
#line 205
    (ei_sockets + ei_n_sockets)->dist_version = dist_version;
#line 206
    (ei_sockets + i)->cnode = *ec;
#line 207
    strcpy((char */* __restrict  */)((ei_sockets + ei_n_sockets)->cookie), (char const   */* __restrict  */)cookie);
#line 208
    ei_n_sockets ++;
    }
  }
  {
#line 211
  ei_mutex_unlock(ei_sockets_lock);
  }
#line 213
  return (0);
}
}
#line 224 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static ei_socket_info *get_ei_socket_info(int fd ) 
{ 
  int i ;

  {
  {
#line 228
  ei_mutex_lock(ei_sockets_lock, 0);
#line 230
  i = 0;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i < ei_n_sockets)) {
#line 230
      goto while_break;
    }
#line 231
    if ((ei_sockets + i)->socket == fd) {
      {
#line 235
      ei_mutex_unlock(ei_sockets_lock);
      }
#line 237
      return (ei_sockets + i);
    }
#line 230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  ei_mutex_unlock(ei_sockets_lock);
  }
#line 242
  return ((ei_socket_info *)((void *)0));
}
}
#line 245 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
ei_cnode *ei_fd_to_cnode(int fd ) 
{ 
  ei_socket_info *sockinfo ;
  ei_socket_info *tmp ;

  {
  {
#line 247
  tmp = get_ei_socket_info(fd);
#line 247
  sockinfo = tmp;
  }
#line 248
  if ((unsigned long )sockinfo == (unsigned long )((void *)0)) {
#line 248
    return ((ei_cnode *)((void *)0));
  }
#line 249
  return (& sockinfo->cnode);
}
}
#line 256 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_distversion(int fd ) 
{ 
  ei_socket_info *e ;
  ei_socket_info *tmp ;

  {
  {
#line 258
  tmp = get_ei_socket_info(fd);
#line 258
  e = tmp;
  }
#line 259
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 260
    return (-1);
  } else {
#line 262
    return (e->dist_version);
  }
}
}
#line 265 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static char const   *ei_cookie(int fd ) 
{ 
  ei_socket_info *e ;
  ei_socket_info *tmp ;

  {
  {
#line 267
  tmp = get_ei_socket_info(fd);
#line 267
  e = tmp;
  }
#line 268
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 269
    return ((char const   *)((void *)0));
  } else {
#line 271
    return ((char const   *)(e->cookie));
  }
}
}
#line 274 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
char const   *ei_thisnodename(ei_cnode const   *ec ) 
{ 


  {
#line 276
  return ((char const   *)(ec->thisnodename));
}
}
#line 279 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
char const   *ei_thishostname(ei_cnode const   *ec ) 
{ 


  {
#line 281
  return ((char const   *)(ec->thishostname));
}
}
#line 284 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
char const   *ei_thisalivename(ei_cnode const   *ec ) 
{ 


  {
#line 286
  return ((char const   *)(ec->thisalivename));
}
}
#line 289 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
short ei_thiscreation(ei_cnode const   *ec ) 
{ 


  {
#line 291
  return ((short )ec->creation);
}
}
#line 295 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
char const   *ei_thiscookie(ei_cnode const   *ec ) 
{ 


  {
#line 297
  return ((char const   *)(ec->ei_connect_cookie));
}
}
#line 300 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
erlang_pid *ei_self(ei_cnode *ec ) 
{ 


  {
#line 302
  return (& ec->self);
}
}
#line 309 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
char const   *ei_getfdcookie(int fd ) 
{ 
  char const   *r ;
  char const   *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 311
  tmp = ei_cookie(fd);
#line 311
  r = tmp;
  }
#line 312
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 312
    r = "";
  }
#line 313
  return (r);
}
}
#line 331 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int get_int32(unsigned char *s ) 
{ 


  {
#line 333
  return (((((int )*(s + 0) << 24) | ((int )*(s + 1) << 16)) | ((int )*(s + 2) << 8)) | (int )*(s + 3));
}
}
#line 384 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_connect_xinit(ei_cnode *ec , char const   *thishostname , char const   *thisalivename ,
                     char const   *thisnodename , Erl_IpAddr thisipaddr , char const   *cookie ,
                     short const   creation ) 
{ 
  char *dbglevel ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 402
  if ((unsigned long )ei_sockets_lock == (unsigned long )((void *)0)) {
    {
#line 403
    ei_sockets_lock = ei_mutex_create();
    }
  }
#line 407
  ec->creation = (short )creation;
#line 409
  if (cookie) {
    {
#line 410
    tmp = strlen(cookie);
    }
#line 410
    if ((unsigned long )tmp >= sizeof(ec->ei_connect_cookie)) {
#line 411
      if (ei_tracelevel >= 1) {
        {
#line 411
        ei_trace_printf("ei_connect_xinit", 1, "ERROR: Cookie size too large");
        }
      }
#line 413
      return (-1);
    } else {
      {
#line 415
      strcpy((char */* __restrict  */)(ec->ei_connect_cookie), (char const   */* __restrict  */)cookie);
      }
    }
  } else {
    {
#line 417
    tmp___0 = get_cookie(ec->ei_connect_cookie, (int )sizeof(ec->ei_connect_cookie));
    }
#line 417
    if (! tmp___0) {
#line 418
      return (-1);
    }
  }
  {
#line 421
  tmp___1 = strlen(thishostname);
  }
#line 421
  if ((unsigned long )tmp___1 >= sizeof(ec->thishostname)) {
#line 422
    if (ei_tracelevel >= 1) {
      {
#line 422
      ei_trace_printf("ei_connect_xinit", 1, "ERROR: Thishostname too long");
      }
    }
#line 423
    return (-1);
  }
  {
#line 425
  strcpy((char */* __restrict  */)(ec->thishostname), (char const   */* __restrict  */)thishostname);
#line 427
  tmp___2 = strlen(thisalivename);
  }
#line 427
  if ((unsigned long )tmp___2 >= sizeof(ec->thisalivename)) {
#line 428
    if (ei_tracelevel >= 1) {
      {
#line 428
      ei_trace_printf("ei_connect_init", 1, "Thisalivename too long");
      }
    }
#line 429
    return (-1);
  }
  {
#line 432
  strcpy((char */* __restrict  */)(ec->thisalivename), (char const   */* __restrict  */)thisalivename);
#line 434
  tmp___3 = strlen(thisnodename);
  }
#line 434
  if ((unsigned long )tmp___3 >= sizeof(ec->thisnodename)) {
#line 435
    if (ei_tracelevel >= 1) {
      {
#line 435
      ei_trace_printf("ei_connect_init", 1, "Thisnodename too long");
      }
    }
#line 436
    return (-1);
  }
  {
#line 438
  strcpy((char */* __restrict  */)(ec->thisnodename), (char const   */* __restrict  */)thisnodename);
#line 443
  strcpy((char */* __restrict  */)(ec->self.node), (char const   */* __restrict  */)thisnodename);
#line 444
  ec->self.num = 0U;
#line 445
  ec->self.serial = 0U;
#line 446
  ec->self.creation = (unsigned int )creation;
#line 448
  dbglevel = getenv("EI_TRACELEVEL");
  }
#line 448
  if ((unsigned long )dbglevel != (unsigned long )((void *)0)) {
    {
#line 450
    ei_tracelevel = atoi((char const   *)dbglevel);
    }
  } else {
    {
#line 448
    dbglevel = getenv("ERL_DEBUG_DIST");
    }
#line 448
    if ((unsigned long )dbglevel != (unsigned long )((void *)0)) {
      {
#line 450
      ei_tracelevel = atoi((char const   *)dbglevel);
      }
    }
  }
#line 452
  return (0);
}
}
#line 461 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_connect_init(ei_cnode *ec , char const   *this_node_name , char const   *cookie ,
                    short creation ) 
{ 
  struct hostent *hp ;
  char thishostname[65] ;
  char thisnodename[129] ;
  char thisalivename[64] ;
  int *tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *ct ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 476
  if ((unsigned long )ei_sockets_lock == (unsigned long )((void *)0)) {
    {
#line 477
    ei_sockets_lock = ei_mutex_create();
    }
  }
  {
#line 481
  tmp___0 = gethostname(thishostname, (size_t )64);
  }
#line 481
  if (tmp___0 == -1) {
#line 486
    if (ei_tracelevel >= 1) {
      {
#line 486
      tmp = __errno_location();
#line 486
      ei_trace_printf("ei_connect_init", 1, "Failed to get host name: %d", *tmp);
      }
    }
#line 488
    return (-1);
  }
#line 491
  if ((unsigned long )this_node_name == (unsigned long )((void *)0)) {
    {
#line 492
    tmp___1 = getpid();
#line 492
    sprintf((char */* __restrict  */)(thisalivename), (char const   */* __restrict  */)"c%d",
            tmp___1);
    }
  } else {
    {
#line 494
    strcpy((char */* __restrict  */)(thisalivename), (char const   */* __restrict  */)this_node_name);
    }
  }
  {
#line 496
  hp = ei_gethostbyname((char const   *)(thishostname));
  }
#line 496
  if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
    {
#line 499
    hp = ei_gethostbyname("localhost");
    }
#line 499
    if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
#line 508
      if (ei_tracelevel >= 1) {
        {
#line 508
        tmp___2 = __h_errno_location();
#line 508
        ei_trace_printf("ei_connect_init", 1, "Can\'t get ip address for host %s: %d",
                        thishostname, *tmp___2);
        }
      }
#line 512
      return (-1);
    }
  }
  {
#line 517
  tmp___3 = strcmp((char const   *)hp->h_name, "localhost");
  }
#line 517
  if (tmp___3 == 0) {
    {
#line 519
    ct = strchr((char const   *)(thishostname), '.');
    }
#line 519
    if ((unsigned long )ct != (unsigned long )((void *)0)) {
#line 519
      *ct = (char )'\000';
    }
    {
#line 520
    sprintf((char */* __restrict  */)(thisnodename), (char const   */* __restrict  */)"%s@%s",
            this_node_name, thishostname);
    }
  } else {
    {
#line 523
    ct = strchr((char const   *)hp->h_name, '.');
    }
#line 523
    if ((unsigned long )ct != (unsigned long )((void *)0)) {
#line 523
      *ct = (char )'\000';
    }
    {
#line 524
    strcpy((char */* __restrict  */)(thishostname), (char const   */* __restrict  */)hp->h_name);
#line 525
    sprintf((char */* __restrict  */)(thisnodename), (char const   */* __restrict  */)"%s@%s",
            this_node_name, hp->h_name);
    }
  }
  {
#line 528
  tmp___4 = ei_connect_xinit(ec, (char const   *)(thishostname), (char const   *)(thisalivename),
                             (char const   *)(thisnodename), (struct in_addr *)*(hp->h_addr_list),
                             cookie, (short const   )creation);
  }
#line 528
  return (tmp___4);
}
}
#line 537 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int cnct(uint16 port , struct in_addr *ip_addr , int addr_len , unsigned int ms ) 
{ 
  int s ;
  int res ;
  struct sockaddr_in iserv_addr ;
  int volatile   *tmp ;
  int *tmp___0 ;
  int volatile   *tmp___1 ;

  {
  {
#line 542
  s = socket(2, 1, 0);
  }
#line 542
  if (s < 0) {
    {
#line 543
    tmp = __erl_errno_place();
#line 543
    tmp___0 = __errno_location();
#line 543
    *tmp = (int volatile   )*tmp___0;
    }
#line 544
    return (-1);
  }
  {
#line 547
  memset((void *)((char *)(& iserv_addr)), 0, (size_t )sizeof(struct sockaddr_in ));
#line 548
  memcpy((void */* __restrict  */)((char *)(& iserv_addr.sin_addr)), (void const   */* __restrict  */)((char *)ip_addr),
         (size_t )addr_len);
#line 549
  iserv_addr.sin_family = (sa_family_t )2;
#line 550
  iserv_addr.sin_port = htons(port);
#line 552
  res = ei_connect_t(s, (void *)((struct sockaddr *)(& iserv_addr)), (int )sizeof(iserv_addr),
                     ms);
  }
#line 552
  if (res < 0) {
    {
#line 554
    tmp___1 = __erl_errno_place();
    }
#line 554
    if (res == -2) {
#line 554
      *tmp___1 = (int volatile   )110;
    } else {
#line 554
      *tmp___1 = (int volatile   )5;
    }
    {
#line 555
    close(s);
    }
#line 556
    return (-1);
  }
#line 559
  return (s);
}
}
#line 568 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_connect_tmo(ei_cnode *ec , char *nodename , unsigned int ms ) 
{ 
  char *hostname ;
  char alivename[8192] ;
  struct hostent *hp ;
  struct hostent host ;
  char buffer[1024] ;
  int ei_h_errno ;
  char thishostname[65] ;
  int volatile   *tmp ;
  char *ct ;
  int tmp___0 ;
  int tmp___1 ;
  int volatile   *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 580
  hostname = strchr((char const   *)nodename, '@');
  }
#line 580
  if (hostname) {
    {
#line 584
    strncpy((char */* __restrict  */)(alivename), (char const   */* __restrict  */)nodename,
            (size_t )(hostname - nodename));
#line 585
    alivename[hostname - nodename] = (char)0;
#line 586
    hostname ++;
    }
  } else {
#line 581
    if (ei_tracelevel >= 1) {
      {
#line 581
      ei_trace_printf("ei_connect", 1, "Node name has no @ in name");
      }
    }
#line 582
    return (-1);
  }
  {
#line 590
  hp = ei_gethostbyname_r((char const   *)hostname, & host, buffer, 1024, & ei_h_errno);
  }
#line 591
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 593
    tmp___0 = gethostname(thishostname, (size_t )64);
    }
#line 593
    if (tmp___0 < 0) {
#line 594
      if (ei_tracelevel >= 1) {
        {
#line 594
        ei_trace_printf("ei_connect_tmo", 1, "Failed to get name of this host");
        }
      }
      {
#line 596
      tmp = __erl_errno_place();
#line 596
      *tmp = (int volatile   )113;
      }
#line 597
      return (-1);
    } else {
      {
#line 601
      ct = strchr((char const   *)(thishostname), '.');
      }
#line 601
      if ((unsigned long )ct != (unsigned long )((void *)0)) {
#line 601
        *ct = (char )'\000';
      }
    }
    {
#line 603
    tmp___1 = strcmp((char const   *)hostname, (char const   *)(thishostname));
    }
#line 603
    if (tmp___1 == 0) {
      {
#line 605
      hp = ei_gethostbyname_r("localhost", & host, buffer, 1024, & ei_h_errno);
      }
    }
#line 606
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 607
      if (ei_tracelevel >= 1) {
        {
#line 607
        ei_trace_printf("ei_connect", 1, "Can\'t find host for %s: %d\n", nodename,
                        ei_h_errno);
        }
      }
      {
#line 609
      tmp___2 = __erl_errno_place();
#line 609
      *tmp___2 = (int volatile   )113;
      }
#line 610
      return (-1);
    }
  }
  {
#line 640
  tmp___3 = ei_xconnect_tmo(ec, (Erl_IpAddr )*(hp->h_addr_list), alivename, ms);
  }
#line 640
  return (tmp___3);
}
}
#line 643 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_connect(ei_cnode *ec , char *nodename ) 
{ 
  int tmp ;

  {
  {
#line 645
  tmp = ei_connect_tmo(ec, nodename, 0U);
  }
#line 645
  return (tmp);
}
}
#line 655 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_xconnect_tmo(ei_cnode *ec , Erl_IpAddr adr , char *alivename , unsigned int ms ) 
{ 
  struct in_addr *ip_addr ;
  int rport ;
  int sockd ;
  int one ;
  int dist ;
  ErlConnect her_name ;
  unsigned int her_flags ;
  unsigned int her_version ;
  int volatile   *tmp ;
  unsigned int our_challenge ;
  unsigned int her_challenge ;
  unsigned char our_digest[16] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int volatile   *tmp___5 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 657
  ip_addr = adr;
#line 658
  rport = 0;
#line 660
  one = 1;
#line 661
  dist = 0;
#line 665
  tmp = __erl_errno_place();
#line 665
  *tmp = (int volatile   )5;
  }
#line 667
  if (ei_tracelevel >= 3) {
    {
#line 667
    ei_trace_printf("ei_xconnect", 1, "-> CONNECT attempt to connect to %s", alivename);
    }
  }
  {
#line 670
  rport = ei_epmd_port_tmo(ip_addr, (char const   *)alivename, & dist, ms);
  }
#line 670
  if (rport < 0) {
#line 671
    if (ei_tracelevel >= 1) {
      {
#line 671
      ei_trace_printf("ei_xconnect", 1, "-> CONNECT can\'t get remote port");
      }
    }
#line 673
    return (-3);
  }
  {
#line 677
  sockd = cnct((uint16 )rport, ip_addr, (int )sizeof(struct in_addr ), ms);
  }
#line 677
  if (sockd < 0) {
#line 678
    if (ei_tracelevel >= 1) {
      {
#line 678
      ei_trace_printf("ei_xconnect", 1, "-> CONNECT socket connect failed");
      }
    }
#line 680
    return (-4);
  }
#line 683
  if (ei_tracelevel >= 3) {
    {
#line 683
    ei_trace_printf("ei_xconnect", 1, "-> CONNECT connected to remote");
    }
  }
#line 686
  if (dist <= 4) {
#line 687
    if (ei_tracelevel >= 1) {
      {
#line 687
      ei_trace_printf("ei_xconnect", 1, "-> CONNECT remote version not compatible");
      }
    }
#line 688
    goto error;
  } else {
    {
#line 694
    tmp___0 = send_name(sockd, ec->thisnodename, (unsigned int )dist, ms);
    }
#line 694
    if (tmp___0) {
#line 695
      goto error;
    }
    {
#line 696
    tmp___1 = recv_status(sockd, ms);
    }
#line 696
    if (tmp___1) {
#line 697
      goto error;
    }
    {
#line 698
    tmp___2 = recv_challenge(sockd, & her_challenge, & her_version, & her_flags, & her_name,
                             ms);
    }
#line 698
    if (tmp___2) {
#line 700
      goto error;
    }
    {
#line 701
    our_challenge = gen_challenge();
#line 702
    gen_digest(her_challenge, ec->ei_connect_cookie, (unsigned char *)(our_digest));
#line 703
    tmp___3 = send_challenge_reply(sockd, (unsigned char *)(our_digest), our_challenge,
                                   ms);
    }
#line 703
    if (tmp___3) {
#line 704
      goto error;
    }
    {
#line 705
    tmp___4 = recv_challenge_ack(sockd, our_challenge, ec->ei_connect_cookie, ms);
    }
#line 705
    if (tmp___4) {
#line 707
      goto error;
    }
    {
#line 708
    put_ei_socket_info(sockd, dist, null_cookie, ec);
    }
  }
  {
#line 711
  setsockopt(sockd, 6, 1, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
#line 712
  setsockopt(sockd, 1, 9, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
  }
#line 714
  if (ei_tracelevel >= 3) {
    {
#line 714
    ei_trace_printf("ei_xconnect", 1, "-> CONNECT (ok) remote = %s", alivename);
    }
  }
  {
#line 716
  tmp___5 = __erl_errno_place();
#line 716
  *tmp___5 = (int volatile   )0;
  }
#line 717
  return (sockd);
  error: 
#line 720
  if (ei_tracelevel >= 1) {
    {
#line 720
    ei_trace_printf("ei_xconnect", 1, "-> CONNECT failed");
    }
  }
  {
#line 721
  close(sockd);
  }
#line 722
  return (-1);
}
}
#line 725 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_xconnect(ei_cnode *ec , Erl_IpAddr adr , char *alivename ) 
{ 
  int tmp ;

  {
  {
#line 727
  tmp = ei_xconnect_tmo(ec, adr, alivename, 0U);
  }
#line 727
  return (tmp);
}
}
#line 746 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_accept(ei_cnode *ec , int lfd , ErlConnect *conp ) 
{ 
  int tmp ;

  {
  {
#line 748
  tmp = ei_accept_tmo(ec, lfd, conp, 0U);
  }
#line 748
  return (tmp);
}
}
#line 751 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_accept_tmo(ei_cnode *ec , int lfd , ErlConnect *conp , unsigned int ms ) 
{ 
  int fd ;
  struct sockaddr_in cli_addr ;
  int cli_addr_len ;
  unsigned int her_version ;
  unsigned int her_flags ;
  ErlConnect her_name ;
  int volatile   *tmp ;
  int volatile   *tmp___0 ;
  int tmp___1 ;
  unsigned int our_challenge ;
  unsigned int her_challenge ;
  unsigned char our_digest[16] ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int volatile   *tmp___6 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 755
  cli_addr_len = (int )sizeof(struct sockaddr_in );
#line 759
  tmp = __erl_errno_place();
#line 759
  *tmp = (int volatile   )5;
  }
#line 761
  if (ei_tracelevel >= 3) {
    {
#line 761
    ei_trace_printf("ei_accept", 1, "<- ACCEPT waiting for connection");
    }
  }
  {
#line 763
  fd = ei_accept_t(lfd, (void *)((struct sockaddr *)(& cli_addr)), (void *)(& cli_addr_len),
                   ms);
  }
#line 763
  if (fd < 0) {
#line 765
    if (ei_tracelevel >= 1) {
      {
#line 765
      ei_trace_printf("ei_accept", 1, "<- ACCEPT socket accept failed");
      }
    }
    {
#line 766
    tmp___0 = __erl_errno_place();
    }
#line 766
    if (fd == -2) {
#line 766
      *tmp___0 = (int volatile   )110;
    } else {
#line 766
      *tmp___0 = (int volatile   )5;
    }
#line 767
    goto error;
  }
#line 770
  if (ei_tracelevel >= 3) {
    {
#line 770
    ei_trace_printf("ei_accept", 1, "<- ACCEPT connected to remote");
    }
  }
  {
#line 772
  tmp___1 = recv_name(fd, & her_version, & her_flags, & her_name, ms);
  }
#line 772
  if (tmp___1) {
#line 773
    if (ei_tracelevel >= 1) {
      {
#line 773
      ei_trace_printf("ei_accept", 1, "<- ACCEPT initial ident failed");
      }
    }
#line 774
    goto error;
  }
#line 777
  if (her_version <= 4U) {
#line 778
    if (ei_tracelevel >= 1) {
      {
#line 778
      ei_trace_printf("ei_accept", 1, "<- ACCEPT remote version not compatible");
      }
    }
#line 779
    goto error;
  } else {
    {
#line 786
    tmp___2 = send_status(fd, (char *)"ok", ms);
    }
#line 786
    if (tmp___2) {
#line 787
      goto error;
    }
    {
#line 788
    our_challenge = gen_challenge();
#line 789
    tmp___3 = send_challenge(fd, ec->thisnodename, our_challenge, her_version, ms);
    }
#line 789
    if (tmp___3) {
#line 791
      goto error;
    }
    {
#line 792
    tmp___4 = recv_challenge_reply(fd, our_challenge, ec->ei_connect_cookie, & her_challenge,
                                   ms);
    }
#line 792
    if (tmp___4) {
#line 795
      goto error;
    }
    {
#line 796
    gen_digest(her_challenge, ec->ei_connect_cookie, (unsigned char *)(our_digest));
#line 797
    tmp___5 = send_challenge_ack(fd, (unsigned char *)(our_digest), ms);
    }
#line 797
    if (tmp___5) {
#line 798
      goto error;
    }
    {
#line 799
    put_ei_socket_info(fd, (int )her_version, null_cookie, ec);
    }
  }
#line 801
  if (conp) {
#line 802
    *conp = her_name;
  }
#line 804
  if (ei_tracelevel >= 3) {
    {
#line 804
    ei_trace_printf("ei_accept", 1, "<- ACCEPT (ok) remote = %s", her_name.nodename);
    }
  }
  {
#line 806
  tmp___6 = __erl_errno_place();
#line 806
  *tmp___6 = (int volatile   )0;
  }
#line 807
  return (fd);
  error: 
#line 810
  if (ei_tracelevel >= 1) {
    {
#line 810
    ei_trace_printf("ei_accept", 1, "<- ACCEPT failed");
    }
  }
  {
#line 811
  close(fd);
  }
#line 812
  return (-1);
}
}
#line 821 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_receive_tmo(int fd , unsigned char *bufp , int bufsize , unsigned int ms ) 
{ 
  int len ;
  unsigned char fourbyte[4] ;
  int res ;
  int volatile   *tmp ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;
  int volatile   *tmp___2 ;
  void *__cil_tmp12 ;

  {
  {
#line 824
  fourbyte[0] = (unsigned char)0;
#line 824
  fourbyte[1] = (unsigned char)0;
#line 824
  fourbyte[2] = (unsigned char)0;
#line 824
  fourbyte[3] = (unsigned char)0;
#line 827
  res = ei_read_fill_t(fd, (char *)bufp, 4, ms);
  }
#line 827
  if (res != 4) {
    {
#line 828
    tmp = __erl_errno_place();
    }
#line 828
    if (res == -2) {
#line 828
      *tmp = (int volatile   )110;
    } else {
#line 828
      *tmp = (int volatile   )5;
    }
#line 829
    return (-1);
  }
  {
#line 833
  len = get_int32(bufp);
  }
#line 833
  if (len == 0) {
    {
#line 835
    ei_write_fill_t(fd, (char const   *)((char *)(fourbyte)), 4, ms);
#line 837
    tmp___0 = __erl_errno_place();
#line 837
    *tmp___0 = (int volatile   )11;
    }
#line 838
    return (0);
  } else
#line 840
  if (len > bufsize) {
    {
#line 843
    tmp___1 = __erl_errno_place();
#line 843
    *tmp___1 = (int volatile   )90;
    }
#line 844
    return (-1);
  } else {
    {
#line 846
    res = ei_read_fill_t(fd, (char *)bufp, len, ms);
    }
#line 846
    if (res != len) {
      {
#line 848
      tmp___2 = __erl_errno_place();
      }
#line 848
      if (res == -2) {
#line 848
        *tmp___2 = (int volatile   )110;
      } else {
#line 848
        *tmp___2 = (int volatile   )5;
      }
#line 849
      return (-1);
    }
  }
#line 852
  return (len);
}
}
#line 856 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_receive(int fd , unsigned char *bufp , int bufsize ) 
{ 
  int tmp ;

  {
  {
#line 858
  tmp = ei_receive_tmo(fd, bufp, bufsize, 0U);
  }
#line 858
  return (tmp);
}
}
#line 861 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_reg_send_tmo(ei_cnode *ec , int fd , char *server_name , char *buf , int len ,
                    unsigned int ms ) 
{ 
  erlang_pid *self ;
  erlang_pid *tmp ;
  int tmp___0 ;

  {
  {
#line 864
  tmp = ei_self(ec);
#line 864
  self = tmp;
#line 865
  self->num = (unsigned int )fd;
#line 868
  tmp___0 = ei_send_reg_encoded_tmo(fd, (erlang_pid const   *)self, (char const   *)server_name,
                                    buf, len, ms);
  }
#line 868
  return (tmp___0);
}
}
#line 872 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_reg_send(ei_cnode *ec , int fd , char *server_name , char *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 874
  tmp = ei_reg_send_tmo(ec, fd, server_name, buf, len, 0U);
  }
#line 874
  return (tmp);
}
}
#line 880 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_send_tmo(int fd , erlang_pid *to , char *buf , int len , unsigned int ms ) 
{ 
  int tmp ;

  {
  {
#line 883
  tmp = ei_send_encoded_tmo(fd, (erlang_pid const   *)to, buf, len, ms);
  }
#line 883
  return (tmp);
}
}
#line 886 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_send(int fd , erlang_pid *to , char *buf , int len ) 
{ 
  int tmp ;

  {
  {
#line 888
  tmp = ei_send_tmo(fd, to, buf, len, 0U);
  }
#line 888
  return (tmp);
}
}
#line 898 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_do_receive_msg(int fd , int staticbuffer_p , erlang_msg *msg , ei_x_buff *x ,
                      unsigned int ms ) 
{ 
  int msglen ;
  int i ;
  int volatile   *tmp ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;

  {
  {
#line 904
  i = ei_recv_internal(fd, & x->buff, & x->buffsz, msg, & msglen, staticbuffer_p,
                       ms);
  }
#line 904
  if (! i) {
    {
#line 906
    tmp = __erl_errno_place();
#line 906
    *tmp = (int volatile   )11;
    }
#line 907
    return (0);
  }
#line 909
  if (i < 0) {
#line 911
    return (-1);
  }
#line 913
  if (staticbuffer_p) {
#line 913
    if (msglen > x->buffsz) {
      {
#line 915
      tmp___0 = __erl_errno_place();
#line 915
      *tmp___0 = (int volatile   )90;
      }
#line 916
      return (-1);
    }
  }
#line 918
  x->index = x->buffsz;
  {
#line 927
  if (msg->msgtype == 5L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 8L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 3L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 7L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 4L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 1L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 6L) {
#line 927
    goto case_5;
  }
#line 927
  if (msg->msgtype == 2L) {
#line 927
    goto case_5;
  }
#line 930
  goto switch_default;
  case_5: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 928
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 938
  tmp___1 = __erl_errno_place();
#line 938
  *tmp___1 = (int volatile   )5;
  }
#line 939
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 944 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_receive_msg(int fd , erlang_msg *msg , ei_x_buff *x ) 
{ 
  int tmp ;

  {
  {
#line 946
  tmp = ei_do_receive_msg(fd, 1, msg, x, 0U);
  }
#line 946
  return (tmp);
}
}
#line 949 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_xreceive_msg(int fd , erlang_msg *msg , ei_x_buff *x ) 
{ 
  int tmp ;

  {
  {
#line 951
  tmp = ei_do_receive_msg(fd, 0, msg, x, 0U);
  }
#line 951
  return (tmp);
}
}
#line 954 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_receive_msg_tmo(int fd , erlang_msg *msg , ei_x_buff *x , unsigned int ms ) 
{ 
  int tmp ;

  {
  {
#line 956
  tmp = ei_do_receive_msg(fd, 1, msg, x, ms);
  }
#line 956
  return (tmp);
}
}
#line 959 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_xreceive_msg_tmo(int fd , erlang_msg *msg , ei_x_buff *x , unsigned int ms ) 
{ 
  int tmp ;

  {
  {
#line 961
  tmp = ei_do_receive_msg(fd, 0, msg, x, ms);
  }
#line 961
  return (tmp);
}
}
#line 972 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_rpc_to(ei_cnode *ec , int fd , char *mod , char *fun , char const   *buf ,
              int len ) 
{ 
  ei_x_buff x ;
  erlang_pid *self ;
  erlang_pid *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 977
  tmp = ei_self(ec);
#line 977
  self = tmp;
#line 978
  self->num = (unsigned int )fd;
#line 981
  ei_x_new_with_version(& x);
#line 982
  ei_x_encode_tuple_header(& x, 2L);
#line 984
  self->num = (unsigned int )fd;
#line 985
  ei_x_encode_pid(& x, (erlang_pid const   *)self);
#line 987
  ei_x_encode_tuple_header(& x, 5L);
#line 988
  ei_x_encode_atom(& x, "call");
#line 989
  ei_x_encode_atom(& x, (char const   *)mod);
#line 990
  ei_x_encode_atom(& x, (char const   *)fun);
#line 991
  ei_x_append_buf(& x, buf, len);
#line 992
  ei_x_encode_atom(& x, "user");
#line 995
  ei_send_reg_encoded(fd, (erlang_pid const   *)self, "rex", x.buff, x.index);
#line 996
  ei_x_free(& x);
  }
#line 998
  return (0);
}
}
#line 1006 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_rpc_from(ei_cnode *ec , int fd , int timeout , erlang_msg *msg , ei_x_buff *x ) 
{ 
  fd_set readmask ;
  struct timeval tv ;
  struct timeval *t ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int volatile   *tmp___0 ;
  int volatile   *tmp___1 ;
  int tmp___2 ;
  int volatile   *tmp___3 ;

  {
#line 1011
  t = (struct timeval *)((void *)0);
#line 1013
  if (timeout >= 0) {
#line 1014
    tv.tv_sec = (__time_t )(timeout / 1000);
#line 1015
    tv.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 1016
    t = & tv;
  }
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1019
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readmask.__fds_bits[0]): "memory");
#line 1019
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1020
  readmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 1022
  tmp = select(fd + 1, (fd_set */* __restrict  */)(& readmask), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)t);
  }
  {
#line 1023
  if (tmp == -1) {
#line 1023
    goto case_neg_1;
  }
#line 1027
  if (tmp == 0) {
#line 1027
    goto case_0;
  }
#line 1031
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 1024
  tmp___0 = __erl_errno_place();
#line 1024
  *tmp___0 = (int volatile   )5;
  }
#line 1025
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 1028
  tmp___1 = __erl_errno_place();
#line 1028
  *tmp___1 = (int volatile   )110;
  }
#line 1029
  return (-5);
  switch_default: /* CIL Label */ 
#line 1032
  if ((readmask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 1033
    tmp___2 = ei_xreceive_msg(fd, msg, x);
    }
#line 1033
    return (tmp___2);
  } else {
    {
#line 1035
    tmp___3 = __erl_errno_place();
#line 1035
    *tmp___3 = (int volatile   )5;
    }
#line 1036
    return (-1);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1046 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
int ei_rpc(ei_cnode *ec , int fd , char *mod , char *fun , char const   *inbuf , int inbuflen ,
           ei_x_buff *x ) 
{ 
  int i ;
  int index___0 ;
  ei_term t ;
  erlang_msg msg ;
  char rex[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp17 ;

  {
  {
#line 1054
  tmp = ei_rpc_to(ec, fd, mod, fun, inbuf, inbuflen);
  }
#line 1054
  if (tmp < 0) {
#line 1055
    return (-1);
  }
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1058
    i = ei_rpc_from(ec, fd, -1, & msg, x);
    }
#line 1058
    if (! (i == 0)) {
#line 1058
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1061
  if (i == -1) {
#line 1061
    return (-1);
  }
  {
#line 1063
  index___0 = 0;
#line 1064
  tmp___0 = ei_decode_version((char const   *)x->buff, & index___0, & i);
  }
#line 1064
  if (tmp___0 < 0) {
#line 1066
    return (-1);
  } else {
    {
#line 1064
    tmp___1 = ei_decode_ei_term((char const   *)x->buff, & index___0, & t);
    }
#line 1064
    if (tmp___1 < 0) {
#line 1066
      return (-1);
    }
  }
#line 1069
  if ((int )t.ei_type == 104) {
#line 1069
    if (t.arity == 2) {
      {
#line 1070
      tmp___2 = ei_decode_atom((char const   *)x->buff, & index___0, rex);
      }
#line 1070
      if (tmp___2 < 0) {
#line 1071
        return (-1);
      }
    }
  }
  {
#line 1073
  x->index -= index___0;
#line 1074
  memmove((void *)x->buff, (void const   *)(x->buff + index___0), (size_t )x->index);
  }
#line 1075
  return (0);
}
}
#line 1085 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static unsigned int md_32(char *string , int length ) 
{ 
  MD5_CTX ctx ;
  union __anonunion_digest_60 digest ;

  {
  {
#line 1092
  ei_MD5Init(& ctx);
#line 1093
  ei_MD5Update(& ctx, (unsigned char *)string, (unsigned int )length);
#line 1095
  ei_MD5Final((unsigned char *)((unsigned char *)(digest.c)), & ctx);
  }
#line 1096
  return (((digest.x[0] ^ digest.x[1]) ^ digest.x[2]) ^ digest.x[3]);
}
}
#line 1130 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static unsigned int gen_challenge(void) 
{ 
  struct __anonstruct_s_61 s ;
  long tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 1142
  gettimeofday((struct timeval */* __restrict  */)(& s.tv), (__timezone_ptr_t )0);
#line 1143
  uname(& s.name);
#line 1144
  s.cpu = clock();
#line 1145
  s.pid = getpid();
#line 1146
  tmp = gethostid();
#line 1146
  s.hid = (u_long )tmp;
#line 1147
  s.uid = getuid();
#line 1148
  s.gid = getgid();
#line 1150
  tmp___0 = md_32((char *)(& s), (int )sizeof(s));
  }
#line 1150
  return (tmp___0);
}
}
#line 1154 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static void gen_digest(unsigned int challenge , char *cookie , unsigned char *digest ) 
{ 
  MD5_CTX c ;
  char chbuf[21] ;
  size_t tmp ;
  size_t tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1161
  sprintf((char */* __restrict  */)(chbuf), (char const   */* __restrict  */)"%u",
          challenge);
#line 1162
  ei_MD5Init(& c);
#line 1163
  tmp = strlen((char const   *)cookie);
#line 1163
  ei_MD5Update(& c, (unsigned char *)cookie, tmp);
#line 1165
  tmp___0 = strlen((char const   *)(chbuf));
#line 1165
  ei_MD5Update(& c, (unsigned char *)(chbuf), tmp___0);
#line 1167
  ei_MD5Final(digest, & c);
  }
#line 1168
  return;
}
}
#line 1173
static char *hex(char *digest , char *buff ) ;
#line 1173 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static char tab[17]  = 
#line 1173
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 1171 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static char *hex(char *digest , char *buff ) 
{ 
  unsigned char *d___0 ;
  char *p ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 1174
  d___0 = (unsigned char *)digest;
#line 1176
  p = (char *)buff;
#line 1179
  i = 0;
  {
#line 1179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1179
    if (! ((unsigned long )i < sizeof(digest))) {
#line 1179
      goto while_break;
    }
#line 1180
    tmp = p;
#line 1180
    p ++;
#line 1180
    *tmp = tab[(int )*d___0 >> 4];
#line 1181
    tmp___0 = p;
#line 1181
    p ++;
#line 1181
    tmp___1 = d___0;
#line 1181
    d___0 ++;
#line 1181
    *tmp___0 = tab[(int )*tmp___1 & 15];
#line 1179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1183
  *p = (char )'\000';
#line 1184
  return ((char *)buff);
}
}
#line 1187 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int read_2byte_package(int fd , char **buf , int *buflen , int *is_static ,
                              unsigned int ms ) 
{ 
  unsigned char nbuf[2] ;
  unsigned char *x ;
  unsigned int len ;
  int res ;
  int volatile   *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int volatile   *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int volatile   *tmp___5 ;
  int volatile   *tmp___6 ;
  void *__cil_tmp18 ;

  {
  {
#line 1191
  x = nbuf;
#line 1195
  res = ei_read_fill_t(fd, (char *)(nbuf), 2, ms);
  }
#line 1195
  if (res != 2) {
    {
#line 1196
    tmp = __erl_errno_place();
    }
#line 1196
    if (res == -2) {
#line 1196
      *tmp = (int volatile   )110;
    } else {
#line 1196
      *tmp = (int volatile   )5;
    }
#line 1197
    return (-1);
  }
#line 1199
  x += 2;
#line 1199
  len = (unsigned int )((((int )*(x + -2) << 8) | (int )*(x + -1)) & 65535);
#line 1201
  if (len > (unsigned int )*buflen) {
#line 1202
    if (*is_static) {
      {
#line 1203
      tmp___1 = malloc(len);
#line 1203
      tmp___0 = (char *)tmp___1;
      }
#line 1204
      if (! tmp___0) {
        {
#line 1205
        tmp___2 = __erl_errno_place();
#line 1205
        *tmp___2 = (int volatile   )12;
        }
#line 1206
        return (-1);
      }
#line 1208
      *buf = tmp___0;
#line 1209
      *is_static = 0;
#line 1210
      *buflen = (int )len;
    } else {
      {
#line 1212
      tmp___4 = realloc((void *)*buf, len);
#line 1212
      tmp___3 = (char *)tmp___4;
      }
#line 1213
      if (! tmp___3) {
        {
#line 1214
        tmp___5 = __erl_errno_place();
#line 1214
        *tmp___5 = (int volatile   )12;
        }
#line 1215
        return (-1);
      }
#line 1217
      *buf = tmp___3;
#line 1218
      *buflen = (int )len;
    }
  }
  {
#line 1221
  res = ei_read_fill_t(fd, *buf, (int )len, ms);
  }
#line 1221
  if ((unsigned int )res != len) {
    {
#line 1222
    tmp___6 = __erl_errno_place();
    }
#line 1222
    if (res == -2) {
#line 1222
      *tmp___6 = (int volatile   )110;
    } else {
#line 1222
      *tmp___6 = (int volatile   )5;
    }
#line 1223
    return (-1);
  }
#line 1225
  return ((int )len);
}
}
#line 1229 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int send_status(int fd , char *status , unsigned int ms ) 
{ 
  char *buf ;
  char *s ;
  char dbuf[100] ;
  int siz ;
  size_t tmp ;
  int res ;
  void *tmp___0 ;
  int volatile   *tmp___1 ;
  size_t tmp___2 ;
  int volatile   *tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1233
  tmp = strlen((char const   *)status);
#line 1233
  siz = (int )((tmp + 1U) + 2U);
  }
#line 1236
  if (siz > 100) {
    {
#line 1236
    tmp___0 = malloc((size_t )siz);
#line 1236
    buf = (char *)tmp___0;
    }
  } else {
#line 1236
    buf = dbuf;
  }
#line 1237
  if (! buf) {
    {
#line 1238
    tmp___1 = __erl_errno_place();
#line 1238
    *tmp___1 = (int volatile   )12;
    }
#line 1239
    return (-1);
  }
#line 1241
  s = buf;
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    *(s + 0) = (char )(((siz - 2) >> 8) & 255);
#line 1242
    *(s + 1) = (char )((siz - 2) & 255);
#line 1242
    s += 2;
#line 1242
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1243
    *(s + 0) = (char)115;
#line 1243
    s ++;
#line 1243
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1244
  tmp___2 = strlen((char const   *)status);
#line 1244
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)status, tmp___2);
#line 1245
  res = ei_write_fill_t(fd, (char const   *)buf, siz, ms);
  }
#line 1245
  if (res != siz) {
#line 1246
    if (ei_tracelevel >= 1) {
      {
#line 1246
      ei_trace_printf("send_status", 1, "-> SEND_STATUS socket write failed");
      }
    }
#line 1247
    if ((unsigned long )buf != (unsigned long )(dbuf)) {
      {
#line 1248
      free((void *)buf);
      }
    }
    {
#line 1249
    tmp___3 = __erl_errno_place();
    }
#line 1249
    if (res == -2) {
#line 1249
      *tmp___3 = (int volatile   )110;
    } else {
#line 1249
      *tmp___3 = (int volatile   )5;
    }
#line 1250
    return (-1);
  }
#line 1252
  if (ei_tracelevel >= 3) {
    {
#line 1252
    ei_trace_printf("send_status", 1, "-> SEND_STATUS (%s)", status);
    }
  }
#line 1254
  if ((unsigned long )buf != (unsigned long )(dbuf)) {
    {
#line 1255
    free((void *)buf);
    }
  }
#line 1256
  return (0);
}
}
#line 1259 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int recv_status(int fd , unsigned int ms ) 
{ 
  char dbuf[100] ;
  char *buf ;
  int is_static ;
  int buflen ;
  int rlen ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1262
  buf = dbuf;
#line 1263
  is_static = 1;
#line 1264
  buflen = 100;
#line 1267
  rlen = read_2byte_package(fd, & buf, & buflen, & is_static, ms);
  }
#line 1267
  if (rlen <= 0) {
#line 1268
    if (ei_tracelevel >= 1) {
      {
#line 1268
      ei_trace_printf("recv_status", 1, "<- RECV_STATUS socket read failed (%d)",
                      rlen);
      }
    }
#line 1270
    goto error;
  }
#line 1272
  if (rlen == 3) {
#line 1272
    if ((int )*(buf + 0) == 115) {
#line 1272
      if ((int )*(buf + 1) == 111) {
#line 1272
        if ((int )*(buf + 2) == 107) {
#line 1274
          if (! is_static) {
            {
#line 1275
            free((void *)buf);
            }
          }
#line 1276
          if (ei_tracelevel >= 3) {
            {
#line 1276
            ei_trace_printf("recv_status", 1, "<- RECV_STATUS (ok)");
            }
          }
#line 1277
          return (0);
        }
      }
    }
  }
  error: 
#line 1280
  if (! is_static) {
    {
#line 1281
    free((void *)buf);
    }
  }
#line 1282
  return (-1);
}
}
#line 1287 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int send_name_or_challenge(int fd , char *nodename , int f_chall , unsigned int challenge ,
                                  unsigned int version , unsigned int ms ) 
{ 
  char *buf ;
  unsigned char *s ;
  char dbuf[100] ;
  int siz ;
  size_t tmp ;
  char const   *function[2] ;
  int res ;
  void *tmp___0 ;
  int volatile   *tmp___1 ;
  size_t tmp___2 ;
  int volatile   *tmp___3 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 1296
  tmp = strlen((char const   *)nodename);
#line 1296
  siz = (int )(9U + tmp);
#line 1297
  function[0] = "SEND_NAME";
#line 1297
  function[1] = "SEND_CHALLENGE";
  }
#line 1300
  if (f_chall) {
#line 1301
    siz += 4;
  }
#line 1302
  if (siz > 100) {
    {
#line 1302
    tmp___0 = malloc((size_t )siz);
#line 1302
    buf = (char *)tmp___0;
    }
  } else {
#line 1302
    buf = dbuf;
  }
#line 1303
  if (! buf) {
    {
#line 1304
    tmp___1 = __erl_errno_place();
#line 1304
    *tmp___1 = (int volatile   )12;
    }
#line 1305
    return (-1);
  }
#line 1307
  s = (unsigned char *)buf;
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1308
    *(s + 0) = (unsigned char )(((siz - 2) >> 8) & 255);
#line 1308
    *(s + 1) = (unsigned char )((siz - 2) & 255);
#line 1308
    s += 2;
#line 1308
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1309
    *(s + 0) = (unsigned char)110;
#line 1309
    s ++;
#line 1309
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1310
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1310
    *(s + 0) = (unsigned char )((version >> 8) & 255U);
#line 1310
    *(s + 1) = (unsigned char )(version & 255U);
#line 1310
    s += 2;
#line 1310
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1311
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1311
    *(s + 0) = (unsigned char )((404 >> 24) & 255);
#line 1311
    *(s + 1) = (unsigned char )((404 >> 16) & 255);
#line 1311
    *(s + 2) = (unsigned char )((404 >> 8) & 255);
#line 1311
    *(s + 3) = (unsigned char)148;
#line 1311
    s += 4;
#line 1311
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1315
  if (f_chall) {
    {
#line 1316
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1316
      *(s + 0) = (unsigned char )((challenge >> 24) & 255U);
#line 1316
      *(s + 1) = (unsigned char )((challenge >> 16) & 255U);
#line 1316
      *(s + 2) = (unsigned char )((challenge >> 8) & 255U);
#line 1316
      *(s + 3) = (unsigned char )(challenge & 255U);
#line 1316
      s += 4;
#line 1316
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1317
  tmp___2 = strlen((char const   *)nodename);
#line 1317
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)nodename, tmp___2);
#line 1319
  res = ei_write_fill_t(fd, (char const   *)buf, siz, ms);
  }
#line 1319
  if (res != siz) {
#line 1320
    if (ei_tracelevel >= 1) {
      {
#line 1320
      ei_trace_printf("send_name_or_challenge", 1, "-> %s socket write failed", function[f_chall]);
      }
    }
#line 1322
    if ((unsigned long )buf != (unsigned long )(dbuf)) {
      {
#line 1323
      free((void *)buf);
      }
    }
    {
#line 1324
    tmp___3 = __erl_errno_place();
    }
#line 1324
    if (res == -2) {
#line 1324
      *tmp___3 = (int volatile   )110;
    } else {
#line 1324
      *tmp___3 = (int volatile   )5;
    }
#line 1325
    return (-1);
  }
#line 1328
  if ((unsigned long )buf != (unsigned long )(dbuf)) {
    {
#line 1329
    free((void *)buf);
    }
  }
#line 1330
  return (0);
}
}
#line 1333 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int recv_challenge(int fd , unsigned int *challenge , unsigned int *version ,
                          unsigned int *flags , ErlConnect *namebuf , unsigned int ms ) 
{ 
  char dbuf[100] ;
  char *buf ;
  int is_static ;
  int buflen ;
  int rlen ;
  char *s ;
  struct sockaddr_in sin ;
  socklen_t sin_len ;
  char tag ;
  int volatile   *tmp ;
  int volatile   *tmp___0 ;
  int tmp___1 ;
  int volatile   *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int volatile   *tmp___5 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 1338
  buf = dbuf;
#line 1339
  is_static = 1;
#line 1340
  buflen = 100;
#line 1344
  sin_len = (socklen_t )sizeof(sin);
#line 1347
  tmp = __erl_errno_place();
#line 1347
  *tmp = (int volatile   )5;
#line 1349
  rlen = read_2byte_package(fd, & buf, & buflen, & is_static, ms);
  }
#line 1349
  if (rlen <= 0) {
#line 1350
    if (ei_tracelevel >= 1) {
      {
#line 1350
      ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE socket read failed (%d)",
                      rlen);
      }
    }
#line 1352
    goto error;
  }
#line 1354
  if (rlen - 11 > 128) {
#line 1355
    if (ei_tracelevel >= 1) {
      {
#line 1355
      ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE nodename too long (%d)",
                      rlen - 11);
      }
    }
#line 1357
    goto error;
  }
#line 1359
  s = buf;
#line 1360
  s ++;
#line 1360
  tag = (char )((int )*((unsigned char *)s + -1) & 255);
#line 1360
  if ((int )tag != 110) {
#line 1361
    if (ei_tracelevel >= 1) {
      {
#line 1361
      ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE incorrect tag, expected \'n\' got \'%c\' (%u)",
                      (int )tag, (int )tag);
      }
    }
#line 1364
    goto error;
  }
#line 1366
  s += 2;
#line 1366
  *version = (unsigned int )((((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535);
#line 1367
  s += 4;
#line 1367
  *flags = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 1368
  s += 4;
#line 1368
  *challenge = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 1370
  if (! (*flags & 4U)) {
#line 1371
    if (ei_tracelevel >= 1) {
      {
#line 1371
      ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE peer cannot handle extended references");
      }
    }
#line 1373
    goto error;
  }
#line 1376
  if (! (*flags & 256U)) {
    {
#line 1376
    tmp___1 = ei_internal_use_r9_pids_ports();
    }
#line 1376
    if (! tmp___1) {
#line 1378
      if (ei_tracelevel >= 1) {
        {
#line 1378
        ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE peer cannot handle extended pids and ports");
        }
      }
      {
#line 1380
      tmp___0 = __erl_errno_place();
#line 1380
      *tmp___0 = (int volatile   )5;
      }
#line 1381
      goto error;
    }
  }
  {
#line 1385
  tmp___4 = getpeername(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sin)),
                        (socklen_t */* __restrict  */)(& sin_len));
  }
#line 1385
  if (tmp___4 < 0) {
#line 1386
    if (ei_tracelevel >= 1) {
      {
#line 1386
      ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE can\'t get peername");
      }
    }
    {
#line 1387
    tmp___2 = __erl_errno_place();
#line 1387
    tmp___3 = __errno_location();
#line 1387
    *tmp___2 = (int volatile   )*tmp___3;
    }
#line 1388
    goto error;
  }
  {
#line 1390
  memcpy((void */* __restrict  */)(namebuf->ipadr), (void const   */* __restrict  */)(& sin.sin_addr.s_addr),
         (size_t )sizeof(sin.sin_addr.s_addr));
#line 1392
  memcpy((void */* __restrict  */)(namebuf->nodename), (void const   */* __restrict  */)s,
         (size_t )(rlen - 11));
#line 1393
  namebuf->nodename[rlen - 11] = (char )'\000';
  }
#line 1394
  if (! is_static) {
    {
#line 1395
    free((void *)buf);
    }
  }
#line 1396
  if (ei_tracelevel >= 3) {
    {
#line 1396
    ei_trace_printf("recv_challenge", 1, "<- RECV_CHALLENGE (ok) node = %s, version = %u, flags = %u, challenge = %d",
                    namebuf->nodename, *version, *flags, *challenge);
    }
  }
  {
#line 1405
  tmp___5 = __erl_errno_place();
#line 1405
  *tmp___5 = (int volatile   )0;
  }
#line 1406
  return (0);
  error: 
#line 1408
  if (! is_static) {
    {
#line 1409
    free((void *)buf);
    }
  }
#line 1410
  return (-1);
}
}
#line 1413 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int send_challenge_reply(int fd , unsigned char *digest , unsigned int challenge ,
                                unsigned int ms ) 
{ 
  char *s ;
  char buf[100] ;
  int siz ;
  int res ;
  int volatile   *tmp ;
  char buffer[33] ;
  char *tmp___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1418
  siz = 23;
#line 1421
  s = buf;
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    *(s + 0) = (char )(((siz - 2) >> 8) & 255);
#line 1422
    *(s + 1) = (char )((siz - 2) & 255);
#line 1422
    s += 2;
#line 1422
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1423
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1423
    *(s + 0) = (char)114;
#line 1423
    s ++;
#line 1423
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1424
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1424
    *(s + 0) = (char )((challenge >> 24) & 255U);
#line 1424
    *(s + 1) = (char )((challenge >> 16) & 255U);
#line 1424
    *(s + 2) = (char )((challenge >> 8) & 255U);
#line 1424
    *(s + 3) = (char )(challenge & 255U);
#line 1424
    s += 4;
#line 1424
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1425
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)digest, (size_t )16);
#line 1427
  res = ei_write_fill_t(fd, (char const   *)(buf), siz, ms);
  }
#line 1427
  if (res != siz) {
#line 1428
    if (ei_tracelevel >= 1) {
      {
#line 1428
      ei_trace_printf("send_challenge_reply", 1, "-> SEND_CHALLENGE_REPLY socket write failed");
      }
    }
    {
#line 1430
    tmp = __erl_errno_place();
    }
#line 1430
    if (res == -2) {
#line 1430
      *tmp = (int volatile   )110;
    } else {
#line 1430
      *tmp = (int volatile   )5;
    }
#line 1431
    return (-1);
  }
#line 1434
  if (ei_tracelevel >= 3) {
#line 1436
    if (ei_tracelevel >= 3) {
      {
#line 1436
      tmp___0 = hex((char *)((char *)digest), (char *)(buffer));
#line 1436
      ei_trace_printf("send_challenge_reply", 1, "-> SEND_CHALLENGE_REPLY (ok) challenge = %d, digest = %s",
                      challenge, tmp___0);
      }
    }
  }
#line 1440
  return (0);
}
}
#line 1443 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int recv_challenge_reply(int fd , unsigned int our_challenge , char *cookie ,
                                unsigned int *her_challenge , unsigned int ms ) 
{ 
  char dbuf[100] ;
  char *buf ;
  int is_static ;
  int buflen ;
  int rlen ;
  char *s ;
  char tag ;
  char her_digest[16] ;
  char expected_digest[16] ;
  int volatile   *tmp ;
  int tmp___0 ;
  char buffer[33] ;
  char *tmp___1 ;
  int volatile   *tmp___2 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 1450
  buf = dbuf;
#line 1451
  is_static = 1;
#line 1452
  buflen = 100;
#line 1458
  tmp = __erl_errno_place();
#line 1458
  *tmp = (int volatile   )5;
#line 1460
  rlen = read_2byte_package(fd, & buf, & buflen, & is_static, ms);
  }
#line 1460
  if (rlen != 21) {
#line 1461
    if (ei_tracelevel >= 1) {
      {
#line 1461
      ei_trace_printf("recv_challenge_reply", 1, "<- RECV_CHALLENGE_REPLY socket read failed (%d)",
                      rlen);
      }
    }
#line 1463
    goto error;
  }
#line 1466
  s = buf;
#line 1467
  s ++;
#line 1467
  tag = (char )((int )*((unsigned char *)s + -1) & 255);
#line 1467
  if ((int )tag != 114) {
#line 1468
    if (ei_tracelevel >= 1) {
      {
#line 1468
      ei_trace_printf("recv_challenge_reply", 1, "<- RECV_CHALLENGE_REPLY incorrect tag, expected \'r\' got \'%c\' (%u)",
                      (int )tag, (int )tag);
      }
    }
#line 1471
    goto error;
  }
  {
#line 1473
  s += 4;
#line 1473
  *her_challenge = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 1474
  memcpy((void */* __restrict  */)(her_digest), (void const   */* __restrict  */)s,
         (size_t )16);
#line 1475
  gen_digest(our_challenge, cookie, (unsigned char *)((unsigned char *)(expected_digest)));
#line 1476
  tmp___0 = memcmp((void const   *)(her_digest), (void const   *)(expected_digest),
                   (size_t )16);
  }
#line 1476
  if (tmp___0) {
#line 1477
    if (ei_tracelevel >= 1) {
      {
#line 1477
      ei_trace_printf("recv_challenge_reply", 1, "<- RECV_CHALLENGE_REPLY authorization failure");
      }
    }
#line 1479
    goto error;
  }
#line 1481
  if (! is_static) {
    {
#line 1482
    free((void *)buf);
    }
  }
#line 1485
  if (ei_tracelevel >= 3) {
#line 1487
    if (ei_tracelevel >= 3) {
      {
#line 1487
      tmp___1 = hex((char *)(her_digest), (char *)(buffer));
#line 1487
      ei_trace_printf("recv_challenge_reply", 1, "<- RECV_CHALLENGE_REPLY (ok) challenge = %u, digest = %s",
                      *her_challenge, tmp___1);
      }
    }
  }
  {
#line 1491
  tmp___2 = __erl_errno_place();
#line 1491
  *tmp___2 = (int volatile   )0;
  }
#line 1492
  return (0);
  error: 
#line 1495
  if (! is_static) {
    {
#line 1496
    free((void *)buf);
    }
  }
#line 1497
  return (-1);
}
}
#line 1500 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int send_challenge_ack(int fd , unsigned char *digest , unsigned int ms ) 
{ 
  char *s ;
  char buf[100] ;
  int siz ;
  int res ;
  int volatile   *tmp ;
  char buffer[33] ;
  char *tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1504
  siz = 19;
#line 1507
  s = buf;
  {
#line 1509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1509
    *(s + 0) = (char )(((siz - 2) >> 8) & 255);
#line 1509
    *(s + 1) = (char )((siz - 2) & 255);
#line 1509
    s += 2;
#line 1509
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1510
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1510
    *(s + 0) = (char)97;
#line 1510
    s ++;
#line 1510
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1511
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)digest, (size_t )16);
#line 1513
  res = ei_write_fill_t(fd, (char const   *)(buf), siz, ms);
  }
#line 1513
  if (res != siz) {
#line 1514
    if (ei_tracelevel >= 1) {
      {
#line 1514
      ei_trace_printf("recv_challenge_reply", 1, "-> SEND_CHALLENGE_ACK socket write failed");
      }
    }
    {
#line 1516
    tmp = __erl_errno_place();
    }
#line 1516
    if (res == -2) {
#line 1516
      *tmp = (int volatile   )110;
    } else {
#line 1516
      *tmp = (int volatile   )5;
    }
#line 1517
    return (-1);
  }
#line 1520
  if (ei_tracelevel >= 3) {
#line 1522
    if (ei_tracelevel >= 3) {
      {
#line 1522
      tmp___0 = hex((char *)((char *)digest), (char *)(buffer));
#line 1522
      ei_trace_printf("recv_challenge_reply", 1, "-> SEND_CHALLENGE_ACK (ok) digest = %s",
                      tmp___0);
      }
    }
  }
#line 1526
  return (0);
}
}
#line 1529 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int recv_challenge_ack(int fd , unsigned int our_challenge , char *cookie ,
                              unsigned int ms ) 
{ 
  char dbuf[100] ;
  char *buf ;
  int is_static ;
  int buflen ;
  int rlen ;
  char *s ;
  char tag ;
  char her_digest[16] ;
  char expected_digest[16] ;
  int volatile   *tmp ;
  int tmp___0 ;
  char buffer[33] ;
  char *tmp___1 ;
  int volatile   *tmp___2 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 1534
  buf = dbuf;
#line 1535
  is_static = 1;
#line 1536
  buflen = 100;
#line 1542
  tmp = __erl_errno_place();
#line 1542
  *tmp = (int volatile   )5;
#line 1544
  rlen = read_2byte_package(fd, & buf, & buflen, & is_static, ms);
  }
#line 1544
  if (rlen != 17) {
#line 1545
    if (ei_tracelevel >= 1) {
      {
#line 1545
      ei_trace_printf("recv_challenge_ack", 1, "<- RECV_CHALLENGE_ACK socket read failed (%d)",
                      rlen);
      }
    }
#line 1547
    goto error;
  }
#line 1550
  s = buf;
#line 1551
  s ++;
#line 1551
  tag = (char )((int )*((unsigned char *)s + -1) & 255);
#line 1551
  if ((int )tag != 97) {
#line 1552
    if (ei_tracelevel >= 1) {
      {
#line 1552
      ei_trace_printf("recv_challenge_ack", 1, "<- RECV_CHALLENGE_ACK incorrect tag, expected \'a\' got \'%c\' (%u)",
                      (int )tag, (int )tag);
      }
    }
#line 1555
    goto error;
  }
  {
#line 1557
  memcpy((void */* __restrict  */)(her_digest), (void const   */* __restrict  */)s,
         (size_t )16);
#line 1558
  gen_digest(our_challenge, cookie, (unsigned char *)((unsigned char *)(expected_digest)));
#line 1559
  tmp___0 = memcmp((void const   *)(her_digest), (void const   *)(expected_digest),
                   (size_t )16);
  }
#line 1559
  if (tmp___0) {
#line 1560
    if (ei_tracelevel >= 1) {
      {
#line 1560
      ei_trace_printf("recv_challenge_ack", 1, "<- RECV_CHALLENGE_ACK authorization failure");
      }
    }
#line 1562
    goto error;
  }
#line 1564
  if (! is_static) {
    {
#line 1565
    free((void *)buf);
    }
  }
#line 1567
  if (ei_tracelevel >= 3) {
#line 1569
    if (ei_tracelevel >= 3) {
      {
#line 1569
      tmp___1 = hex((char *)(her_digest), (char *)(buffer));
#line 1569
      ei_trace_printf("recv_challenge_ack", 1, "<- RECV_CHALLENGE_ACK (ok) digest = %s",
                      tmp___1);
      }
    }
  }
  {
#line 1572
  tmp___2 = __erl_errno_place();
#line 1572
  *tmp___2 = (int volatile   )0;
  }
#line 1573
  return (0);
  error: 
#line 1576
  if (! is_static) {
    {
#line 1577
    free((void *)buf);
    }
  }
#line 1578
  return (-1);
}
}
#line 1581 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int send_name(int fd , char *nodename , unsigned int version , unsigned int ms ) 
{ 
  int tmp ;

  {
  {
#line 1583
  tmp = send_name_or_challenge(fd, nodename, 0, 0U, version, ms);
  }
#line 1583
  return (tmp);
}
}
#line 1586 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int send_challenge(int fd , char *nodename , unsigned int challenge , unsigned int version ,
                          unsigned int ms ) 
{ 
  int tmp ;

  {
  {
#line 1589
  tmp = send_name_or_challenge(fd, nodename, 1, challenge, version, ms);
  }
#line 1589
  return (tmp);
}
}
#line 1592 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int recv_name(int fd , unsigned int *version , unsigned int *flags , ErlConnect *namebuf ,
                     unsigned int ms ) 
{ 
  char dbuf[100] ;
  char *buf ;
  int is_static ;
  int buflen ;
  int rlen ;
  char *s ;
  struct sockaddr_in sin ;
  socklen_t sin_len ;
  char tag ;
  int volatile   *tmp ;
  int volatile   *tmp___0 ;
  int tmp___1 ;
  int volatile   *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int volatile   *tmp___5 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 1597
  buf = dbuf;
#line 1598
  is_static = 1;
#line 1599
  buflen = 100;
#line 1603
  sin_len = (socklen_t )sizeof(sin);
#line 1606
  tmp = __erl_errno_place();
#line 1606
  *tmp = (int volatile   )5;
#line 1608
  rlen = read_2byte_package(fd, & buf, & buflen, & is_static, ms);
  }
#line 1608
  if (rlen <= 0) {
#line 1609
    if (ei_tracelevel >= 1) {
      {
#line 1609
      ei_trace_printf("recv_name", 1, "<- RECV_NAME socket read failed (%d)", rlen);
      }
    }
#line 1610
    goto error;
  }
#line 1612
  if (rlen - 7 > 128) {
#line 1613
    if (ei_tracelevel >= 1) {
      {
#line 1613
      ei_trace_printf("recv_name", 1, "<- RECV_NAME nodename too long (%d)", rlen - 7);
      }
    }
#line 1614
    goto error;
  }
#line 1616
  s = buf;
#line 1617
  s ++;
#line 1617
  tag = (char )((int )*((unsigned char *)s + -1) & 255);
#line 1618
  if ((int )tag != 110) {
#line 1619
    if (ei_tracelevel >= 1) {
      {
#line 1619
      ei_trace_printf("recv_name", 1, "<- RECV_NAME incorrect tag, expected \'n\' got \'%c\' (%u)",
                      (int )tag, (int )tag);
      }
    }
#line 1621
    goto error;
  }
#line 1623
  s += 2;
#line 1623
  *version = (unsigned int )((((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535);
#line 1624
  s += 4;
#line 1624
  *flags = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 1626
  if (! (*flags & 4U)) {
#line 1627
    if (ei_tracelevel >= 1) {
      {
#line 1627
      ei_trace_printf("recv_name", 1, "<- RECV_NAME peer cannot handleextended references");
      }
    }
#line 1629
    goto error;
  }
#line 1632
  if (! (*flags & 256U)) {
    {
#line 1632
    tmp___1 = ei_internal_use_r9_pids_ports();
    }
#line 1632
    if (! tmp___1) {
#line 1634
      if (ei_tracelevel >= 1) {
        {
#line 1634
        ei_trace_printf("recv_name", 1, "<- RECV_NAME peer cannot handle extended pids and ports");
        }
      }
      {
#line 1636
      tmp___0 = __erl_errno_place();
#line 1636
      *tmp___0 = (int volatile   )5;
      }
#line 1637
      goto error;
    }
  }
  {
#line 1640
  tmp___4 = getpeername(fd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& sin)),
                        (socklen_t */* __restrict  */)(& sin_len));
  }
#line 1640
  if (tmp___4 < 0) {
#line 1641
    if (ei_tracelevel >= 1) {
      {
#line 1641
      ei_trace_printf("recv_name", 1, "<- RECV_NAME can\'t get peername");
      }
    }
    {
#line 1642
    tmp___2 = __erl_errno_place();
#line 1642
    tmp___3 = __errno_location();
#line 1642
    *tmp___2 = (int volatile   )*tmp___3;
    }
#line 1643
    goto error;
  }
  {
#line 1645
  memcpy((void */* __restrict  */)(namebuf->ipadr), (void const   */* __restrict  */)(& sin.sin_addr.s_addr),
         (size_t )sizeof(sin.sin_addr.s_addr));
#line 1647
  memcpy((void */* __restrict  */)(namebuf->nodename), (void const   */* __restrict  */)s,
         (size_t )(rlen - 7));
#line 1648
  namebuf->nodename[rlen - 7] = (char )'\000';
  }
#line 1649
  if (! is_static) {
    {
#line 1650
    free((void *)buf);
    }
  }
#line 1651
  if (ei_tracelevel >= 3) {
    {
#line 1651
    ei_trace_printf("recv_name", 1, "<- RECV_NAME (ok) node = %s, version = %u, flags = %u",
                    namebuf->nodename, *version, *flags);
    }
  }
  {
#line 1654
  tmp___5 = __erl_errno_place();
#line 1654
  *tmp___5 = (int volatile   )0;
  }
#line 1655
  return (0);
  error: 
#line 1658
  if (! is_static) {
    {
#line 1659
    free((void *)buf);
    }
  }
#line 1660
  return (-1);
}
}
#line 1672 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int get_home(char *buf , int size ) 
{ 
  char *homedrive ;
  char *homepath ;
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1681
  homedrive = (char *)"";
#line 1682
  homepath = getenv("HOME");
  }
#line 1685
  if (! homedrive) {
#line 1686
    *(buf + 0) = (char )'.';
#line 1687
    *(buf + 1) = (char )'\000';
#line 1688
    return (1);
  } else
#line 1685
  if (! homepath) {
#line 1686
    *(buf + 0) = (char )'.';
#line 1687
    *(buf + 1) = (char )'\000';
#line 1688
    return (1);
  } else {
    {
#line 1689
    tmp = strlen((char const   *)homedrive);
#line 1689
    tmp___0 = strlen((char const   *)homepath);
    }
#line 1689
    if (tmp + tmp___0 < (size_t )(size - 1)) {
      {
#line 1690
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)homedrive);
#line 1691
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)homepath);
      }
#line 1692
      return (1);
    }
  }
#line 1695
  return (0);
}
}
#line 1699 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/connect/ei_connect.c"
static int get_cookie(char *buf , int bufsize ) 
{ 
  char fname[(1024UL + sizeof("/.erlang.cookie")) + 1UL] ;
  int fd ;
  int len ;
  unsigned char next_c ;
  int tmp ;
  ssize_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1706
  tmp = get_home(fname, 1025);
  }
#line 1706
  if (! tmp) {
    {
#line 1707
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<ERROR> get_cookie: too long path to home");
    }
#line 1708
    return (0);
  }
  {
#line 1711
  strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)"/.erlang.cookie");
#line 1712
  fd = open((char const   *)(fname), 0, 511);
  }
#line 1712
  if (fd < 0) {
    {
#line 1713
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<ERROR> get_cookie: can\'t open cookie file");
    }
#line 1714
    return (0);
  }
  {
#line 1717
  len = read(fd, (void *)buf, (size_t )(bufsize - 1));
  }
#line 1717
  if (len < 0) {
    {
#line 1718
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<ERROR> get_cookie: reading cookie file");
#line 1719
    close(fd);
    }
#line 1720
    return (0);
  }
  {
#line 1724
  tmp___0 = read(fd, (void *)(& next_c), (size_t )1);
  }
#line 1724
  if (tmp___0 > 0) {
    {
#line 1724
    tmp___1 = __ctype_b_loc();
    }
#line 1724
    if (! ((int const   )*(*tmp___1 + (int )next_c) & 8192)) {
      {
#line 1725
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<ERROR> get_cookie: cookie in %s is too long",
              fname);
#line 1726
      close(fd);
      }
#line 1727
      return (0);
    }
  }
  {
#line 1730
  close(fd);
#line 1733
  *(buf + len) = (char )'\000';
#line 1734
  tmp___2 = strcspn((char const   *)buf, "\r\n");
#line 1734
  len = (int )tmp___2;
#line 1735
  *(buf + len) = (char )'\000';
  }
#line 1737
  return (1);
}
}
#line 342 "../include/ei.h"
void ei_set_compat_rel(unsigned int rel ) ;
#line 26 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_compat.c"
static unsigned int compat_rel  =    ~ 0U;
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_compat.c"
void ei_set_compat_rel(unsigned int rel ) 
{ 


  {
#line 31
  if (compat_rel == 4294967295U) {
#line 32
    compat_rel = rel;
  }
#line 33
  return;
}
}
#line 35 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/misc/ei_compat.c"
int ei_internal_use_r9_pids_ports(void) 
{ 


  {
#line 38
  return (compat_rel < 10U);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_version.c"
int ei_decode_version(char const   *buf , int *index , int *version ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int v ;

  {
#line 26
  s = buf + *index;
#line 27
  s0 = s;
#line 30
  s ++;
#line 30
  v = (int )*((unsigned char *)s + -1) & 255;
#line 31
  if (version) {
#line 31
    *version = v;
  }
#line 32
  if (v != 131) {
#line 33
    return (-1);
  }
#line 35
  *index = (int )((long )*index + (s - s0));
#line 37
  return (0);
}
}
#line 723 "../include/ei.h"
int ei_decode_ulonglong(char const   *buf , int *index , unsigned long long *p ) ;
#line 30 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_ulonglong.c"
int ei_decode_ulonglong(char const   *buf , int *index , unsigned long long *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  unsigned long long n ;
  int arity ;
  int sn ;
  int sign ;
  int i ;

  {
#line 32
  s = buf + *index;
#line 33
  s0 = s;
#line 38
  s ++;
  {
#line 39
  if (((int )*((unsigned char *)s + -1) & 255) == 97) {
#line 39
    goto case_97;
  }
#line 43
  if (((int )*((unsigned char *)s + -1) & 255) == 98) {
#line 43
    goto case_98;
  }
#line 49
  if (((int )*((unsigned char *)s + -1) & 255) == 110) {
#line 49
    goto case_110;
  }
#line 53
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 53
    goto case_111;
  }
#line 75
  goto switch_default;
  case_97: /* CIL Label */ 
#line 40
  s ++;
#line 40
  n = (unsigned long long )((int )*((unsigned char *)s + -1) & 255);
#line 41
  goto switch_break;
  case_98: /* CIL Label */ 
#line 44
  s += 4;
#line 44
  sn = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 45
  if (sn < 0) {
#line 45
    return (-1);
  }
#line 46
  n = (unsigned long long )sn;
#line 47
  goto switch_break;
  case_110: /* CIL Label */ 
#line 50
  s ++;
#line 50
  arity = (int )*((unsigned char *)s + -1) & 255;
#line 51
  goto decode_big;
  case_111: /* CIL Label */ 
#line 54
  s += 4;
#line 54
  arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  decode_big: 
#line 58
  s ++;
#line 58
  sign = (int )*((unsigned char *)s + -1) & 255;
#line 60
  n = 0ULL;
#line 62
  if (sign) {
#line 62
    return (-1);
  }
#line 65
  i = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < arity)) {
#line 65
      goto while_break;
    }
#line 66
    if (i < 8) {
#line 67
      s ++;
#line 67
      n |= (unsigned long long )((int )*((unsigned char *)s + -1) & 255) << i * 8;
    } else {
#line 68
      s ++;
#line 68
      if (((int )*((unsigned char *)s + -1) & 255) != 0) {
#line 69
        return (-1);
      }
    }
#line 65
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 76
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 79
  if (p) {
#line 79
    *p = n;
  }
#line 80
  *index = (int )((long )*index + (s - s0));
#line 82
  return (0);
}
}
#line 464 "../include/ei.h"
int ei_decode_ulong(char const   *buf , int *index , unsigned long *p ) ;
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_ulong.c"
int ei_decode_ulong(char const   *buf , int *index , unsigned long *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  unsigned long n ;
  long sn ;
  int arity ;
  int sign ;
  int i ;

  {
#line 26
  s = buf + *index;
#line 27
  s0 = s;
#line 32
  s ++;
  {
#line 33
  if (((int )*((unsigned char *)s + -1) & 255) == 97) {
#line 33
    goto case_97;
  }
#line 37
  if (((int )*((unsigned char *)s + -1) & 255) == 98) {
#line 37
    goto case_98;
  }
#line 43
  if (((int )*((unsigned char *)s + -1) & 255) == 110) {
#line 43
    goto case_110;
  }
#line 47
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 47
    goto case_111;
  }
#line 69
  goto switch_default;
  case_97: /* CIL Label */ 
#line 34
  s ++;
#line 34
  n = (unsigned long )((int )*((unsigned char *)s + -1) & 255);
#line 35
  goto switch_break;
  case_98: /* CIL Label */ 
#line 38
  s += 4;
#line 38
  sn = (long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 39
  if (sn < 0L) {
#line 39
    return (-1);
  }
#line 40
  n = (unsigned long )sn;
#line 41
  goto switch_break;
  case_110: /* CIL Label */ 
#line 44
  s ++;
#line 44
  arity = (int )*((unsigned char *)s + -1) & 255;
#line 45
  goto decode_big;
  case_111: /* CIL Label */ 
#line 48
  s += 4;
#line 48
  arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  decode_big: 
#line 52
  s ++;
#line 52
  sign = (int )*((unsigned char *)s + -1) & 255;
#line 54
  n = 0UL;
#line 56
  if (sign) {
#line 56
    return (-1);
  }
#line 59
  i = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (i < arity)) {
#line 59
      goto while_break;
    }
#line 60
    if (i < 4) {
#line 61
      s ++;
#line 61
      n |= (unsigned long )(((int )*((unsigned char *)s + -1) & 255) << i * 8);
    } else {
#line 62
      s ++;
#line 62
      if (((int )*((unsigned char *)s + -1) & 255) != 0) {
#line 63
        return (-1);
      }
    }
#line 59
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 70
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 73
  if (p) {
#line 73
    *p = n;
  }
#line 74
  *index = (int )((long )*index + (s - s0));
#line 76
  return (0);
}
}
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_tuple_header.c"
int ei_decode_tuple_header(char const   *buf , int *index , int *arity ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int i ;

  {
#line 25
  s = buf + *index;
#line 26
  s0 = s;
#line 29
  s ++;
#line 29
  i = (int )*((unsigned char *)s + -1) & 255;
  {
#line 30
  if (i == 104) {
#line 30
    goto case_104;
  }
#line 35
  if (i == 105) {
#line 35
    goto case_105;
  }
#line 40
  goto switch_default;
  case_104: /* CIL Label */ 
#line 31
  if (arity) {
#line 31
    s ++;
#line 31
    *arity = (int )*((unsigned char *)s + -1) & 255;
  } else {
#line 32
    s ++;
  }
#line 33
  goto switch_break;
  case_105: /* CIL Label */ 
#line 36
  if (arity) {
#line 36
    s += 4;
#line 36
    *arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  } else {
#line 37
    s += 4;
  }
#line 38
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 41
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 44
  *index = (int )((long )*index + (s - s0));
#line 46
  return (0);
}
}
#line 22 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_trace.c"
int ei_decode_trace(char const   *buf , int *index , erlang_trace *p ) 
{ 
  int arity ;
  int tindex ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 24
  arity = 0;
#line 25
  tindex = *index;
#line 30
  tmp = ei_decode_tuple_header(buf, & tindex, & arity);
  }
#line 30
  if (tmp) {
#line 36
    return (-1);
  } else
#line 30
  if (arity != 5) {
#line 36
    return (-1);
  } else {
    {
#line 30
    tmp___0 = ei_decode_long(buf, & tindex, & p->flags);
    }
#line 30
    if (tmp___0) {
#line 36
      return (-1);
    } else {
      {
#line 30
      tmp___1 = ei_decode_long(buf, & tindex, & p->label);
      }
#line 30
      if (tmp___1) {
#line 36
        return (-1);
      } else {
        {
#line 30
        tmp___2 = ei_decode_long(buf, & tindex, & p->serial);
        }
#line 30
        if (tmp___2) {
#line 36
          return (-1);
        } else {
          {
#line 30
          tmp___3 = ei_decode_pid(buf, & tindex, & p->from);
          }
#line 30
          if (tmp___3) {
#line 36
            return (-1);
          } else {
            {
#line 30
            tmp___4 = ei_decode_long(buf, & tindex, & p->prev);
            }
#line 30
            if (tmp___4) {
#line 36
              return (-1);
            }
          }
        }
      }
    }
  }
#line 40
  *index = tindex;
#line 42
  return (0);
}
}
#line 27 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_string.c"
int ei_decode_string(char const   *buf , int *index___0 , char *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int len ;
  int i ;
  int etype ;

  {
#line 29
  s = buf + *index___0;
#line 30
  s0 = s;
#line 35
  s ++;
  {
#line 36
  if (((int )*((unsigned char *)s + -1) & 255) == 107) {
#line 36
    goto case_107;
  }
#line 46
  if (((int )*((unsigned char *)s + -1) & 255) == 108) {
#line 46
    goto case_108;
  }
#line 73
  if (((int )*((unsigned char *)s + -1) & 255) == 106) {
#line 73
    goto case_106;
  }
#line 77
  goto switch_default;
  case_107: /* CIL Label */ 
#line 37
  s += 2;
#line 37
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 39
  if (p) {
    {
#line 40
    memmove((void *)p, (void const   *)s, (size_t )len);
#line 41
    *(p + len) = (char)0;
    }
  }
#line 43
  s += len;
#line 44
  goto switch_break;
  case_108: /* CIL Label */ 
#line 52
  s += 4;
#line 52
  len = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 53
  if (p) {
#line 54
    i = 0;
    {
#line 54
    while (1) {
      while_continue: /* CIL Label */ ;
#line 54
      if (! (i < len)) {
#line 54
        goto while_break;
      }
#line 55
      s ++;
#line 55
      etype = (int )*((unsigned char *)s + -1) & 255;
#line 55
      if (etype != 97) {
#line 56
        *(p + i) = (char)0;
#line 57
        return (-1);
      }
#line 59
      s ++;
#line 59
      *(p + i) = (char )((int )*((unsigned char *)s + -1) & 255);
#line 54
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 61
    *(p + i) = (char)0;
  } else {
#line 64
    i = 0;
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! (i < len)) {
#line 64
        goto while_break___0;
      }
#line 65
      s ++;
#line 65
      etype = (int )*((unsigned char *)s + -1) & 255;
#line 65
      if (etype != 97) {
#line 65
        return (-1);
      }
#line 66
      s ++;
#line 64
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 70
  s ++;
#line 70
  etype = (int )*((unsigned char *)s + -1) & 255;
#line 70
  if (etype != 106) {
#line 70
    return (-1);
  }
#line 71
  goto switch_break;
  case_106: /* CIL Label */ 
#line 74
  if (p) {
#line 74
    *(p + 0) = (char)0;
  }
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 78
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 82
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 84
  return (0);
}
}
#line 471 "../include/ei.h"
int ei_decode_fun(char const   *buf , int *index___0 , erlang_fun *p ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_skip.c"
int ei_skip_term(char const   *buf , int *index ) 
{ 
  int i ;
  int n ;
  int ty ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 29
  ei_get_type_internal(buf, (int const   *)index, & ty, & n);
  }
  {
#line 31
  if (ty == 100) {
#line 31
    goto case_100;
  }
#line 35
  if (ty == 103) {
#line 35
    goto case_103;
  }
#line 38
  if (ty == 102) {
#line 38
    goto case_102;
  }
#line 42
  if (ty == 101) {
#line 42
    goto case_101;
  }
#line 42
  if (ty == 114) {
#line 42
    goto case_101;
  }
#line 45
  if (ty == 106) {
#line 45
    goto case_106;
  }
#line 48
  if (ty == 108) {
#line 48
    goto case_108;
  }
#line 58
  if (ty == 107) {
#line 58
    goto case_107;
  }
#line 62
  if (ty == 105) {
#line 62
    goto case_105;
  }
#line 62
  if (ty == 104) {
#line 62
    goto case_105;
  }
#line 67
  if (ty == 109) {
#line 67
    goto case_109;
  }
#line 72
  if (ty == 98) {
#line 72
    goto case_98;
  }
#line 72
  if (ty == 97) {
#line 72
    goto case_98;
  }
#line 76
  if (ty == 111) {
#line 76
    goto case_111;
  }
#line 76
  if (ty == 110) {
#line 76
    goto case_111;
  }
#line 79
  if (ty == 99) {
#line 79
    goto case_99;
  }
#line 82
  if (ty == 117) {
#line 82
    goto case_117;
  }
#line 85
  goto switch_default;
  case_100: /* CIL Label */ 
  {
#line 33
  tmp = ei_decode_atom(buf, index, (char *)((void *)0));
  }
#line 33
  if (tmp < 0) {
#line 33
    return (-1);
  }
#line 34
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 36
  tmp___0 = ei_decode_pid(buf, index, (erlang_pid *)((void *)0));
  }
#line 36
  if (tmp___0 < 0) {
#line 36
    return (-1);
  }
#line 37
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 39
  tmp___1 = ei_decode_port(buf, index, (erlang_port *)((void *)0));
  }
#line 39
  if (tmp___1 < 0) {
#line 39
    return (-1);
  }
#line 40
  goto switch_break;
  case_101: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 43
  tmp___2 = ei_decode_ref(buf, index, (erlang_ref *)((void *)0));
  }
#line 43
  if (tmp___2 < 0) {
#line 43
    return (-1);
  }
#line 44
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 46
  tmp___3 = ei_decode_list_header(buf, index, & n);
  }
#line 46
  if (tmp___3 < 0) {
#line 46
    return (-1);
  }
#line 47
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 49
  tmp___4 = ei_decode_list_header(buf, index, & n);
  }
#line 49
  if (tmp___4 < 0) {
#line 49
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < n)) {
#line 50
      goto while_break;
    }
    {
#line 51
    ei_skip_term(buf, index);
#line 50
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  tmp___5 = ei_get_type_internal(buf, (int const   *)index, & ty, & n);
  }
#line 52
  if (tmp___5 < 0) {
#line 52
    return (-1);
  }
#line 53
  if (ty != 106) {
    {
#line 54
    ei_skip_term(buf, index);
    }
  } else {
    {
#line 56
    tmp___6 = ei_decode_list_header(buf, index, & n);
    }
#line 56
    if (tmp___6 < 0) {
#line 56
      return (-1);
    }
  }
#line 57
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 59
  tmp___7 = ei_decode_string(buf, index, (char *)((void *)0));
  }
#line 59
  if (tmp___7 < 0) {
#line 59
    return (-1);
  }
#line 60
  goto switch_break;
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  {
#line 63
  tmp___8 = ei_decode_tuple_header(buf, index, & n);
  }
#line 63
  if (tmp___8 < 0) {
#line 63
    return (-1);
  }
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (! (i < n)) {
#line 64
      goto while_break___0;
    }
    {
#line 65
    ei_skip_term(buf, index);
#line 64
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 66
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 68
  tmp___9 = ei_decode_binary(buf, index, (void *)0, (long *)((void *)0));
  }
#line 68
  if (tmp___9 < 0) {
#line 69
    return (-1);
  }
#line 70
  goto switch_break;
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  {
#line 73
  tmp___10 = ei_decode_long(buf, index, (long *)((void *)0));
  }
#line 73
  if (tmp___10 < 0) {
#line 73
    return (-1);
  }
#line 74
  goto switch_break;
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 77
  tmp___11 = ei_decode_big(buf, index, (erlang_big *)((void *)0));
  }
#line 77
  if (tmp___11 < 0) {
#line 77
    return (-1);
  }
#line 78
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 80
  tmp___12 = ei_decode_double(buf, index, (double *)((void *)0));
  }
#line 80
  if (tmp___12 < 0) {
#line 80
    return (-1);
  }
#line 81
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 83
  tmp___13 = ei_decode_fun(buf, index, (erlang_fun *)((void *)0));
  }
#line 83
  if (tmp___13 < 0) {
#line 83
    return (-1);
  }
#line 84
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 86
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 88
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_ref.c"
int ei_decode_ref(char const   *buf , int *index___0 , erlang_ref *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int count ;
  int len ;
  int i ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 30
  s ++;
  {
#line 31
  if (((int )*((unsigned char *)s + -1) & 255) == 101) {
#line 31
    goto case_101;
  }
#line 57
  if (((int )*((unsigned char *)s + -1) & 255) == 114) {
#line 57
    goto case_114;
  }
#line 91
  goto switch_default;
  case_101: /* CIL Label */ 
#line 34
  s ++;
#line 34
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 34
    return (-1);
  }
#line 36
  s += 2;
#line 36
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 38
  if (p) {
    {
#line 39
    memmove((void *)(p->node), (void const   *)s, (size_t )len);
#line 40
    p->node[len] = (char)0;
    }
  }
#line 42
  s += len;
#line 45
  if (p) {
#line 46
    s += 4;
#line 46
    p->n[0] = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 47
    p->len = 1;
#line 48
    s ++;
#line 48
    p->creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  } else {
#line 50
    s += 5;
  }
#line 52
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 54
  return (0);
#line 55
  goto switch_break;
  case_114: /* CIL Label */ 
#line 59
  s += 2;
#line 59
  count = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 60
  if (p) {
#line 60
    p->len = count;
  }
#line 63
  s ++;
#line 63
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 63
    return (-1);
  }
#line 64
  s += 2;
#line 64
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 66
  if (p) {
    {
#line 67
    memmove((void *)(p->node), (void const   *)s, (size_t )len);
#line 68
    p->node[len] = (char)0;
    }
  }
#line 70
  s += len;
#line 73
  if (p) {
#line 74
    s ++;
#line 74
    p->creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  } else {
#line 76
    s ++;
  }
#line 79
  if (p) {
#line 80
    i = 0;
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (i < count) {
#line 80
        if (! (i < 3)) {
#line 80
          goto while_break;
        }
      } else {
#line 80
        goto while_break;
      }
#line 81
      s += 4;
#line 81
      p->n[i] = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 80
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 84
    s += 4 * count;
  }
#line 86
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 88
  return (0);
#line 89
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 92
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 94
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_port.c"
int ei_decode_port(char const   *buf , int *index___0 , erlang_port *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int len ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 30
  s ++;
#line 30
  if (((int )*((unsigned char *)s + -1) & 255) != 102) {
#line 30
    return (-1);
  }
#line 33
  s ++;
#line 33
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 33
    return (-1);
  }
#line 35
  s += 2;
#line 35
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 37
  if (p) {
    {
#line 38
    memmove((void *)(p->node), (void const   *)s, (size_t )len);
#line 39
    p->node[len] = (char)0;
    }
  }
#line 41
  s += len;
#line 44
  if (p) {
#line 45
    s += 4;
#line 45
    p->id = (unsigned int )((((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1)) & 268435455);
#line 46
    s ++;
#line 46
    p->creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  } else {
#line 48
    s += 5;
  }
#line 50
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 52
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_pid.c"
int ei_decode_pid(char const   *buf , int *index___0 , erlang_pid *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int len ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 30
  s ++;
#line 30
  if (((int )*((unsigned char *)s + -1) & 255) != 103) {
#line 30
    return (-1);
  }
#line 33
  s ++;
#line 33
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 33
    return (-1);
  }
#line 35
  s += 2;
#line 35
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 37
  if (p) {
    {
#line 38
    memmove((void *)(p->node), (void const   *)s, (size_t )len);
#line 39
    p->node[len] = (char)0;
    }
  }
#line 41
  s += len;
#line 44
  if (p) {
#line 45
    s += 4;
#line 45
    p->num = (unsigned int )((((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1)) & 32767);
#line 46
    s += 4;
#line 46
    p->serial = (unsigned int )((((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1)) & 8191);
#line 47
    s ++;
#line 47
    p->creation = (unsigned int )(((int )*((unsigned char *)s + -1) & 255) & 3);
  } else {
#line 49
    s += 9;
  }
#line 51
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 53
  return (0);
}
}
#line 722 "../include/ei.h"
int ei_decode_longlong(char const   *buf , int *index , long long *p ) ;
#line 38 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_longlong.c"
int ei_decode_longlong(char const   *buf , int *index , long long *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  long long n ;
  int arity ;
  int sign ;
  int i ;
  unsigned long long u ;

  {
#line 40
  s = buf + *index;
#line 41
  s0 = s;
#line 45
  s ++;
  {
#line 46
  if (((int )*((unsigned char *)s + -1) & 255) == 97) {
#line 46
    goto case_97;
  }
#line 50
  if (((int )*((unsigned char *)s + -1) & 255) == 98) {
#line 50
    goto case_98;
  }
#line 54
  if (((int )*((unsigned char *)s + -1) & 255) == 110) {
#line 54
    goto case_110;
  }
#line 58
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 58
    goto case_111;
  }
#line 92
  goto switch_default;
  case_97: /* CIL Label */ 
#line 47
  s ++;
#line 47
  n = (long long )((int )*((unsigned char *)s + -1) & 255);
#line 48
  goto switch_break;
  case_98: /* CIL Label */ 
#line 51
  s += 4;
#line 51
  n = (long long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 52
  goto switch_break;
  case_110: /* CIL Label */ 
#line 55
  s ++;
#line 55
  arity = (int )*((unsigned char *)s + -1) & 255;
#line 56
  goto decode_big;
  case_111: /* CIL Label */ 
#line 59
  s += 4;
#line 59
  arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  decode_big: 
#line 63
  s ++;
#line 63
  sign = (int )*((unsigned char *)s + -1) & 255;
#line 65
  u = 0ULL;
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < arity)) {
#line 68
      goto while_break;
    }
#line 69
    if (i < 8) {
#line 71
      s ++;
#line 71
      u |= (unsigned long long )((int )*((unsigned char *)s + -1) & 255) << i * 8;
    } else {
#line 72
      s ++;
#line 72
      if (((int )*((unsigned char *)s + -1) & 255) != 0) {
#line 73
        return (-1);
      }
    }
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if (sign) {
#line 79
    if (u > 0x8000000000000000ULL) {
#line 80
      return (-1);
    }
#line 82
    n = - ((long long )u);
  } else {
#line 84
    if (u > 9223372036854775807ULL) {
#line 85
      return (-1);
    }
#line 87
    n = (long long )u;
  }
#line 90
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 93
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 96
  if (p) {
#line 96
    *p = n;
  }
#line 97
  *index = (int )((long )*index + (s - s0));
#line 99
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_long.c"
int ei_decode_long(char const   *buf , int *index , long *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  long n ;
  int arity ;
  int sign ;
  int i ;
  unsigned long u ;

  {
#line 26
  s = buf + *index;
#line 27
  s0 = s;
#line 31
  s ++;
  {
#line 32
  if (((int )*((unsigned char *)s + -1) & 255) == 97) {
#line 32
    goto case_97;
  }
#line 36
  if (((int )*((unsigned char *)s + -1) & 255) == 98) {
#line 36
    goto case_98;
  }
#line 40
  if (((int )*((unsigned char *)s + -1) & 255) == 110) {
#line 40
    goto case_110;
  }
#line 44
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 44
    goto case_111;
  }
#line 77
  goto switch_default;
  case_97: /* CIL Label */ 
#line 33
  s ++;
#line 33
  n = (long )((int )*((unsigned char *)s + -1) & 255);
#line 34
  goto switch_break;
  case_98: /* CIL Label */ 
#line 37
  s += 4;
#line 37
  n = (long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 38
  goto switch_break;
  case_110: /* CIL Label */ 
#line 41
  s ++;
#line 41
  arity = (int )*((unsigned char *)s + -1) & 255;
#line 42
  goto decode_big;
  case_111: /* CIL Label */ 
#line 45
  s += 4;
#line 45
  arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  decode_big: 
#line 49
  s ++;
#line 49
  sign = (int )*((unsigned char *)s + -1) & 255;
#line 51
  u = 0UL;
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < arity)) {
#line 54
      goto while_break;
    }
#line 55
    if (i < 4) {
#line 56
      s ++;
#line 56
      u |= (unsigned long )(((int )*((unsigned char *)s + -1) & 255) << i * 8);
    } else {
#line 57
      s ++;
#line 57
      if (((int )*((unsigned char *)s + -1) & 255) != 0) {
#line 58
        return (-1);
      }
    }
#line 54
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  if (sign) {
#line 64
    if (u > 2147483648UL) {
#line 65
      return (-1);
    }
#line 67
    n = - ((long )u);
  } else {
#line 69
    if (u > 2147483647UL) {
#line 70
      return (-1);
    }
#line 72
    n = (long )u;
  }
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 78
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 81
  if (p) {
#line 81
    *p = n;
  }
#line 82
  *index = (int )((long )*index + (s - s0));
#line 84
  return (0);
}
}
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_list_header.c"
int ei_decode_list_header(char const   *buf , int *index , int *arity ) 
{ 
  char const   *s ;
  char const   *s0 ;

  {
#line 25
  s = buf + *index;
#line 26
  s0 = s;
#line 28
  s ++;
  {
#line 29
  if (((int )*((unsigned char *)s + -1) & 255) == 106) {
#line 29
    goto case_106;
  }
#line 33
  if (((int )*((unsigned char *)s + -1) & 255) == 108) {
#line 33
    goto case_108;
  }
#line 38
  goto switch_default;
  case_106: /* CIL Label */ 
#line 30
  if (arity) {
#line 30
    *arity = 0;
  }
#line 31
  goto switch_break;
  case_108: /* CIL Label */ 
#line 34
  if (arity) {
#line 34
    s += 4;
#line 34
    *arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  } else {
#line 35
    s += 4;
  }
#line 36
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 39
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 42
  *index = (int )((long )*index + (s - s0));
#line 44
  return (0);
}
}
#line 738 "../include/ei.h"
int ei_decode_intlist(char const   *buf , int *index , long *a___0 , int *count ) ;
#line 27 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_intlist.c"
int ei_decode_intlist(char const   *buf , int *index , long *a___0 , int *count ) 
{ 
  unsigned char const   *s ;
  unsigned char const   *s0 ;
  int idx ;
  int len ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  s = (unsigned char const   *)(buf + *index);
#line 30
  s0 = s;
#line 35
  s ++;
  {
#line 36
  if (((int )*((unsigned char *)s + -1) & 255) == 107) {
#line 36
    goto case_107;
  }
#line 49
  if (((int )*((unsigned char *)s + -1) & 255) == 108) {
#line 49
    goto case_108;
  }
#line 74
  goto switch_default;
  case_107: /* CIL Label */ 
#line 37
  s += 2;
#line 37
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 40
  if (a___0) {
#line 41
    i = 0;
    {
#line 41
    while (1) {
      while_continue: /* CIL Label */ ;
#line 41
      if (! (i < len)) {
#line 41
        goto while_break;
      }
#line 42
      *(a___0 + i) = (long )*(s + i);
#line 41
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 45
  if (count) {
#line 45
    *count = len;
  }
#line 46
  s += len;
#line 47
  goto switch_break;
  case_108: /* CIL Label */ 
#line 50
  s += 4;
#line 50
  len = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 51
  idx = 0;
#line 53
  if (a___0) {
#line 54
    i = 0;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (! (i < len)) {
#line 54
        goto while_break___0;
      }
      {
#line 55
      tmp = ei_decode_long((char const   *)((char *)s), & idx, a___0 + i);
      }
#line 55
      if (tmp < 0) {
#line 56
        if (count) {
#line 56
          *count = i;
        }
#line 57
        return (-1);
      }
#line 54
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 62
    i = 0;
    {
#line 62
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 62
      if (! (i < len)) {
#line 62
        goto while_break___1;
      }
      {
#line 63
      tmp___0 = ei_decode_long((char const   *)((char *)s), & idx, (long *)((void *)0));
      }
#line 63
      if (tmp___0 < 0) {
#line 64
        if (count) {
#line 64
          *count = i;
        }
#line 65
        return (-1);
      }
#line 62
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 70
  if (count) {
#line 70
    *count = len;
  }
#line 71
  s += idx;
#line 72
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 75
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 79
  *index = (int )((long )*index + (s - s0));
#line 81
  return (0);
}
}
#line 472 "../include/ei.h"
void free_fun(erlang_fun *f ) ;
#line 28 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_fun.c"
int ei_decode_fun(char const   *buf , int *index___0 , erlang_fun *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int i ;
  int ix ;
  int ix0 ;
  int n ;
  erlang_pid *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long *tmp___3 ;
  int tmp___4 ;
  long *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  long *tmp___11 ;
  int tmp___12 ;
  long *tmp___13 ;
  int tmp___14 ;
  erlang_pid *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;

  {
#line 30
  s = buf + *index___0;
#line 31
  s0 = s;
#line 34
  s ++;
  {
#line 35
  if (((int )*((unsigned char *)s + -1) & 255) == 117) {
#line 35
    goto case_117;
  }
#line 70
  if (((int )*((unsigned char *)s + -1) & 255) == 112) {
#line 70
    goto case_112;
  }
#line 114
  goto switch_default;
  case_117: /* CIL Label */ 
#line 37
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 37
    p->arity = -1L;
  }
#line 39
  s += 4;
#line 39
  n = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 41
  ix = 0;
#line 42
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 42
    tmp = (erlang_pid *)((void *)0);
  } else {
#line 42
    tmp = & p->pid;
  }
  {
#line 42
  tmp___0 = ei_decode_pid(s, & ix, tmp);
  }
#line 42
  if (tmp___0 < 0) {
#line 43
    return (-1);
  }
#line 45
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 45
    tmp___1 = (char *)((void *)0);
  } else {
#line 45
    tmp___1 = p->module;
  }
  {
#line 45
  tmp___2 = ei_decode_atom(s, & ix, tmp___1);
  }
#line 45
  if (tmp___2 < 0) {
#line 46
    return (-1);
  }
#line 48
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 48
    tmp___3 = (long *)((void *)0);
  } else {
#line 48
    tmp___3 = & p->index;
  }
  {
#line 48
  tmp___4 = ei_decode_long(s, & ix, tmp___3);
  }
#line 48
  if (tmp___4 < 0) {
#line 49
    return (-1);
  }
#line 51
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 51
    tmp___5 = (long *)((void *)0);
  } else {
#line 51
    tmp___5 = & p->uniq;
  }
  {
#line 51
  tmp___6 = ei_decode_long(s, & ix, tmp___5);
  }
#line 51
  if (tmp___6 < 0) {
#line 52
    return (-1);
  }
#line 54
  ix0 = ix;
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < n)) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___7 = ei_skip_term(s, & ix);
    }
#line 56
    if (tmp___7 < 0) {
#line 57
      return (-1);
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 60
    p->n_free_vars = (long )n;
#line 61
    p->free_var_len = (long )(ix - ix0);
#line 62
    tmp___8 = ei_malloc((long )(ix - ix0));
#line 62
    p->free_vars = (char *)tmp___8;
    }
#line 63
    if (! p->free_vars) {
#line 63
      return (-1);
    }
    {
#line 64
    memcpy((void */* __restrict  */)p->free_vars, (void const   */* __restrict  */)(s + ix0),
           (size_t )(ix - ix0));
    }
  }
#line 66
  s += ix;
#line 67
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 68
  return (0);
#line 69
  goto switch_break;
  case_112: /* CIL Label */ 
#line 72
  s += 4;
#line 72
  n = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 74
  s ++;
#line 74
  i = (int )*((unsigned char *)s + -1) & 255;
#line 75
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 75
    p->arity = (long )i;
  }
#line 77
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 77
    memcpy((void */* __restrict  */)(p->md5), (void const   */* __restrict  */)s,
           (size_t )16);
    }
  }
#line 78
  s += 16;
#line 80
  s += 4;
#line 80
  i = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 81
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 81
    p->index = (long )i;
  }
#line 83
  s += 4;
#line 83
  i = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
#line 84
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 84
    p->n_free_vars = (long )i;
  }
#line 86
  ix = 0;
#line 87
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 87
    tmp___9 = (char *)((void *)0);
  } else {
#line 87
    tmp___9 = p->module;
  }
  {
#line 87
  tmp___10 = ei_decode_atom(s, & ix, tmp___9);
  }
#line 87
  if (tmp___10 < 0) {
#line 88
    return (-1);
  }
#line 90
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 90
    tmp___11 = (long *)((void *)0);
  } else {
#line 90
    tmp___11 = & p->old_index;
  }
  {
#line 90
  tmp___12 = ei_decode_long(s, & ix, tmp___11);
  }
#line 90
  if (tmp___12 < 0) {
#line 91
    return (-1);
  }
#line 93
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 93
    tmp___13 = (long *)((void *)0);
  } else {
#line 93
    tmp___13 = & p->uniq;
  }
  {
#line 93
  tmp___14 = ei_decode_long(s, & ix, tmp___13);
  }
#line 93
  if (tmp___14 < 0) {
#line 94
    return (-1);
  }
#line 96
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 96
    tmp___15 = (erlang_pid *)((void *)0);
  } else {
#line 96
    tmp___15 = & p->pid;
  }
  {
#line 96
  tmp___16 = ei_decode_pid(s, & ix, tmp___15);
  }
#line 96
  if (tmp___16 < 0) {
#line 97
    return (-1);
  }
#line 99
  s += ix;
#line 100
  n = (int )(((long )n - (s - s0)) + 1L);
#line 101
  if (n < 0) {
#line 101
    return (-1);
  }
#line 102
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 103
    p->free_var_len = (long )n;
#line 104
    if (n > 0) {
      {
#line 105
      tmp___17 = malloc((size_t )n);
#line 105
      p->free_vars = (char *)tmp___17;
      }
#line 106
      if (! p->free_vars) {
#line 106
        return (-1);
      }
      {
#line 107
      memcpy((void */* __restrict  */)p->free_vars, (void const   */* __restrict  */)s,
             (size_t )n);
      }
    }
  }
#line 110
  s += n;
#line 111
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 112
  return (0);
#line 113
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 115
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 117
  return (0);
}
}
#line 119 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_fun.c"
void free_fun(erlang_fun *f ) 
{ 


  {
#line 121
  if (f->free_var_len > 0L) {
    {
#line 122
    ei_free((void *)f->free_vars);
    }
  }
#line 123
  return;
}
}
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_double.c"
int ei_decode_double(char const   *buf , int *index , double *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  double f ;
  int tmp ;
  char *__cil_tmp8 ;

  {
#line 27
  s = buf + *index;
#line 28
  s0 = s;
#line 31
  s ++;
#line 31
  if (((int )*((unsigned char *)s + -1) & 255) != 99) {
#line 31
    return (-1);
  }
  {
#line 33
  tmp = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%lf",
               & f);
  }
#line 33
  if (tmp != 1) {
#line 33
    return (-1);
  }
#line 35
  s += 31;
#line 36
  if (p) {
#line 36
    *p = f;
  }
#line 37
  *index = (int )((long )*index + (s - s0));
#line 38
  return (0);
}
}
#line 467 "../include/ei.h"
int ei_decode_char(char const   *buf , int *index , char *p ) ;
#line 23 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_char.c"
int ei_decode_char(char const   *buf , int *index , char *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  long n ;
  int arity ;
  int sign ;
  int i ;
  char const   *tmp ;

  {
#line 25
  s = buf + *index;
#line 26
  s0 = s;
#line 30
  s ++;
  {
#line 31
  if (((int )*((unsigned char *)s + -1) & 255) == 97) {
#line 31
    goto case_97;
  }
#line 35
  if (((int )*((unsigned char *)s + -1) & 255) == 98) {
#line 35
    goto case_98;
  }
#line 41
  if (((int )*((unsigned char *)s + -1) & 255) == 110) {
#line 41
    goto case_110;
  }
#line 44
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 44
    goto case_111;
  }
#line 61
  goto switch_default;
  case_97: /* CIL Label */ 
#line 32
  s ++;
#line 32
  n = (long )((int )*((unsigned char *)s + -1) & 255);
#line 33
  goto switch_break;
  case_98: /* CIL Label */ 
#line 36
  s += 4;
#line 36
  n = (long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 37
  if (n < 0L) {
#line 38
    return (-1);
  } else
#line 37
  if (n > 255L) {
#line 38
    return (-1);
  }
#line 39
  goto switch_break;
  case_110: /* CIL Label */ 
#line 42
  s ++;
#line 42
  arity = (int )*((unsigned char *)s + -1) & 255;
#line 43
  goto decode_big;
  case_111: /* CIL Label */ 
#line 45
  s += 4;
#line 45
  arity = ((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1);
  decode_big: 
#line 48
  s ++;
#line 48
  sign = (int )*((unsigned char *)s + -1) & 255;
#line 51
  if (sign) {
#line 51
    return (-1);
  }
#line 53
  s ++;
#line 53
  n = (long )((int )*((unsigned char *)s + -1) & 255);
#line 55
  i = 1;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < arity)) {
#line 55
      goto while_break;
    }
#line 56
    tmp = s;
#line 56
    s ++;
#line 56
    if ((int const   )*tmp != 0) {
#line 56
      return (-1);
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 62
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 65
  if (p) {
#line 65
    *p = (char )n;
  }
#line 66
  *index = (int )((long )*index + (s - s0));
#line 68
  return (0);
}
}
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 466 "../include/ei.h"
int ei_decode_boolean(char const   *buf , int *index___0 , int *p ) ;
#line 25 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_boolean.c"
int ei_decode_boolean(char const   *buf , int *index___0 , int *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int len ;
  int t ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 27
  s = buf + *index___0;
#line 28
  s0 = s;
#line 32
  s ++;
#line 32
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 32
    return (-1);
  }
#line 34
  s += 2;
#line 34
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
  {
#line 37
  if (len == 4) {
#line 37
    goto case_4;
  }
#line 43
  if (len == 5) {
#line 43
    goto case_5;
  }
#line 48
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 39
  tmp = strncmp((char const   *)((char *)s), "true", (size_t )4);
  }
#line 39
  if (tmp) {
#line 39
    return (-1);
  }
#line 40
  t = 1;
#line 41
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 44
  tmp___0 = strncmp((char const   *)((char *)s), "false", (size_t )5);
  }
#line 44
  if (tmp___0) {
#line 44
    return (-1);
  }
#line 45
  t = 0;
#line 46
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 49
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 52
  s += len;
#line 53
  if (p) {
#line 53
    *p = t;
  }
#line 54
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 56
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_binary.c"
int ei_decode_binary(char const   *buf , int *index___0 , void *p , long *lenp ) 
{ 
  char const   *s ;
  char const   *s0 ;
  long len ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 30
  s ++;
#line 30
  if (((int )*((unsigned char *)s + -1) & 255) != 109) {
#line 30
    return (-1);
  }
#line 32
  s += 4;
#line 32
  len = (long )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 33
  if (p) {
    {
#line 33
    memmove(p, (void const   *)s, (size_t )len);
    }
  }
#line 34
  s += len;
#line 36
  if (lenp) {
#line 36
    *lenp = len;
  }
#line 37
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 39
  return (0);
}
}
#line 773 "../include/ei.h"
int ei_big_comp(erlang_big *x , erlang_big *y ) ;
#line 774
int ei_big_to_double(erlang_big *b , double *resp ) ;
#line 775
int ei_small_to_big(int s , erlang_big *b ) ;
#line 26 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
int ei_decode_big(char const   *buf , int *index___0 , erlang_big *b ) 
{ 
  unsigned int digit_bytes ;
  unsigned char const   *s ;
  unsigned char const   *s0 ;
  unsigned short *dt ;
  unsigned int n ;
  int i ;

  {
#line 28
  s = (unsigned char const   *)((unsigned char *)buf + *index___0);
#line 29
  s0 = s;
#line 31
  s ++;
  {
#line 32
  if (((int )*((unsigned char *)s + -1) & 255) == 110) {
#line 32
    goto case_110;
  }
#line 35
  if (((int )*((unsigned char *)s + -1) & 255) == 111) {
#line 35
    goto case_111;
  }
#line 38
  goto switch_default;
  case_110: /* CIL Label */ 
#line 33
  s ++;
#line 33
  digit_bytes = (unsigned int )((int )*((unsigned char *)s + -1) & 255);
#line 34
  goto switch_break;
  case_111: /* CIL Label */ 
#line 36
  s += 4;
#line 36
  digit_bytes = (unsigned int )(((((int )*((unsigned char *)s + -4) << 24) | ((int )*((unsigned char *)s + -3) << 16)) | ((int )*((unsigned char *)s + -2) << 8)) | (int )*((unsigned char *)s + -1));
#line 37
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 39
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 41
  if (b) {
#line 42
    dt = (unsigned short *)b->digits;
#line 43
    n = (digit_bytes + 1U) / 2U;
#line 46
    if (digit_bytes != b->arity) {
#line 47
      return (-1);
    }
#line 50
    s ++;
#line 50
    b->is_neg = (int )*((unsigned char *)s + -1) & 255;
#line 52
    i = 0;
    {
#line 52
    while (1) {
      while_continue: /* CIL Label */ ;
#line 52
      if (! ((unsigned int )i < n)) {
#line 52
        goto while_break;
      }
#line 53
      *(dt + i) = (unsigned short )*(s + i * 2);
#line 54
      if ((unsigned int )(i * 2 + 1) < digit_bytes) {
#line 55
        *(dt + i) = (unsigned short )((int )*(dt + i) | ((int )((unsigned short )*(s + (i * 2 + 1))) << 8));
      }
#line 52
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 59
    s ++;
  }
#line 62
  s += digit_bytes;
#line 64
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 66
  return (0);
}
}
#line 69 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
erlang_big *ei_alloc_big(unsigned int digit_bytes ) 
{ 
  erlang_big *b ;
  unsigned int n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 71
  n = (digit_bytes + 1U) / 2U;
#line 73
  tmp = malloc((size_t )sizeof(erlang_big ));
#line 73
  b = (erlang_big *)tmp;
  }
#line 73
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 73
    return ((erlang_big *)((void *)0));
  }
  {
#line 74
  memset((void *)b, 0, (size_t )sizeof(erlang_big ));
#line 75
  tmp___0 = malloc(2U * n);
#line 75
  b->digits = tmp___0;
  }
#line 75
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 76
    free((void *)b);
    }
#line 77
    return ((erlang_big *)0);
  }
  {
#line 80
  b->arity = digit_bytes;
#line 81
  memset(b->digits, 0, 2U * n);
  }
#line 82
  return (b);
}
}
#line 85 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
void ei_free_big(erlang_big *b ) 
{ 


  {
#line 87
  if (! b) {
#line 87
    return;
  }
#line 88
  if (b->digits) {
    {
#line 88
    free(b->digits);
    }
  }
  {
#line 89
  free((void *)b);
  }
#line 90
  return;
}
}
#line 100 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
static int I_comp(digit_t *x , dsize_t xl , digit_t *y , dsize_t yl ) 
{ 
  int tmp ;

  {
#line 102
  if (xl < yl) {
#line 103
    return (-1);
  } else
#line 104
  if (xl > yl) {
#line 105
    return (1);
  } else {
#line 107
    if ((unsigned long )x == (unsigned long )y) {
#line 107
      return (0);
    }
#line 108
    x += xl - 1U;
#line 109
    y += yl - 1U;
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 110
      if (xl > 0U) {
#line 110
        if (! ((int )*x == (int )*y)) {
#line 110
          goto while_break;
        }
      } else {
#line 110
        goto while_break;
      }
#line 111
      x --;
#line 112
      y --;
#line 113
      xl --;
    }
    while_break: /* CIL Label */ ;
    }
#line 115
    if (xl == 0U) {
#line 115
      return (0);
    }
#line 116
    if ((int )*x < (int )*y) {
#line 116
      tmp = -1;
    } else {
#line 116
      tmp = 1;
    }
#line 116
    return (tmp);
  }
}
}
#line 120 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
int ei_big_comp(erlang_big *x , erlang_big *y ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 122
  if (x->is_neg == y->is_neg) {
    {
#line 123
    tmp = I_comp((digit_t *)x->digits, (x->arity + 1U) / 2U, (digit_t *)y->digits,
                 (y->arity + 1U) / 2U);
#line 123
    c = tmp;
    }
#line 124
    if (x->is_neg) {
#line 125
      return (- c);
    } else {
#line 127
      return (c);
    }
  } else {
#line 129
    if (x->is_neg) {
#line 129
      tmp___0 = -1;
    } else {
#line 129
      tmp___0 = 1;
    }
#line 129
    return (tmp___0);
  }
}
}
#line 165 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
static int volatile   erl_fp_exception  ;
#line 170 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
static void unmask_fpe(void) 
{ 
  unsigned short cw ;

  {
#line 173
  __asm__  volatile   ("fstcw %0": "=m" (cw));
#line 174
  cw = (unsigned short )((int )cw & -14);
#line 175
  __asm__  volatile   ("fldcw %0": : "m" (cw));
#line 176
  return;
}
}
#line 178 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
static void erts_restore_x87(void) 
{ 


  {
  {
#line 180
  __asm__  volatile   ("fninit":);
#line 181
  unmask_fpe();
  }
#line 182
  return;
}
}
#line 184 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
static int erts_check_x87(double f ) 
{ 


  {
#line 186
  __asm__  volatile   ("fwait": "=m" (erl_fp_exception): "m" (f));
#line 187
  if (! erl_fp_exception) {
#line 188
    return (0);
  }
  {
#line 189
  erts_restore_x87();
  }
#line 190
  return (1);
}
}
#line 247 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
int ei_big_to_double(erlang_big *b , double *resp ) 
{ 
  double d___0 ;
  double d_base ;
  digit_t *s ;
  dsize_t xl ;
  short xsgn ;
  int old_erl_fp_exception ;
  digit_t ds ;
  double d_next ;
  int tmp ;
  dsize_t tmp___0 ;
  char *__cil_tmp13 ;

  {
#line 287
  d___0 = 0.0;
#line 288
  d_base = 1.0;
#line 290
  s = (digit_t *)b->digits;
#line 291
  xl = (b->arity + 1U) / 2U;
#line 292
  xsgn = (short )b->is_neg;
#line 293
  old_erl_fp_exception = (int )erl_fp_exception;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    erl_fp_exception = (int volatile   )0;
#line 295
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    tmp___0 = xl;
#line 296
    xl --;
#line 296
    if (! tmp___0) {
#line 296
      goto while_break___0;
    }
#line 297
    ds = *s;
#line 298
    d_next = (double )ds * d_base + d___0;
    {
#line 300
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 300
      tmp = erts_check_x87(d_next);
      }
#line 300
      if (tmp) {
        {
#line 300
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 300
          erl_fp_exception = (int volatile   )old_erl_fp_exception;
#line 300
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r\n### fp exception ###\r\n");
        }
#line 300
        return (-1);
      }
#line 300
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 301
    s ++;
#line 302
    d___0 = d_next;
#line 303
    d_base *= (double )(1 << 16);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 311
  if (xsgn) {
#line 311
    *resp = - d___0;
  } else {
#line 311
    *resp = d___0;
  }
  {
#line 312
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 312
    erts_check_x87(*resp);
    }
#line 312
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 313
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 313
    erl_fp_exception = (int volatile   )old_erl_fp_exception;
#line 313
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 314
  return (0);
}
}
#line 318 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_big.c"
int ei_small_to_big(int s , erlang_big *b ) 
{ 
  digit_t *d___0 ;
  unsigned int n ;

  {
#line 321
  n = (b->arity + 1U) / 2U;
#line 323
  if (n < 2U) {
#line 323
    return (-1);
  }
#line 325
  b->is_neg = s < 0;
#line 326
  d___0 = (digit_t *)b->digits;
#line 327
  *(d___0 + 0) = (digit_t )(s & ((1 << 16) - 1));
#line 328
  *(d___0 + 1) = (digit_t )(s >> 16);
#line 330
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/decode/decode_atom.c"
int ei_decode_atom(char const   *buf , int *index___0 , char *p ) 
{ 
  char const   *s ;
  char const   *s0 ;
  int len ;

  {
#line 26
  s = buf + *index___0;
#line 27
  s0 = s;
#line 30
  s ++;
#line 30
  if (((int )*((unsigned char *)s + -1) & 255) != 100) {
#line 30
    return (-1);
  }
#line 32
  s += 2;
#line 32
  len = (((int )*((unsigned char *)s + -2) << 8) | (int )*((unsigned char *)s + -1)) & 65535;
#line 34
  if (p) {
    {
#line 35
    memmove((void *)p, (void const   *)s, (size_t )len);
#line 36
    *(p + len) = (char)0;
    }
  }
#line 38
  s += len;
#line 39
  *index___0 = (int )((long )*index___0 + (s - s0));
#line 41
  return (0);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 115 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 119
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 366 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 43 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.h"
int erl_start_sys(ei_cnode *ec , char *alive , Erl_IpAddr adr , int flags , char *erl ,
                  char **args ) ;
#line 111 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c"
static struct in_addr *get_addr(char const   *hostname , struct in_addr *oaddr ) ;
#line 113
static int wait_for_erlang(int sockd , int magic , struct timeval *timeout ) ;
#line 125
static int exec_erlang(ei_cnode *ec , char *alive , Erl_IpAddr adr , int flags , char *erl ,
                       char **args , int port ) ;
#line 142 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c"
int erl_start_sys(ei_cnode *ec , char *alive , Erl_IpAddr adr , int flags , char *erl ,
                  char **args ) 
{ 
  struct timeval timeout ;
  struct sockaddr_in addr ;
  SocklenType namelen ;
  int port ;
  int sockd ;
  int one ;
  int pid ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;
  __pid_t tmp___3 ;

  {
  {
#line 149
  sockd = 0;
#line 150
  one = 1;
#line 154
  pid = 0;
#line 156
  r = 0;
#line 158
  sockd = socket(2, 1, 0);
  }
#line 158
  if (sockd < 0) {
#line 160
    r = -99;
#line 161
    goto done;
  } else {
    {
#line 158
    tmp = setsockopt(sockd, 1, 2, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
    }
#line 158
    if (tmp < 0) {
#line 160
      r = -99;
#line 161
      goto done;
    }
  }
  {
#line 164
  memset((void *)(& addr), 0, (size_t )sizeof(addr));
#line 165
  addr.sin_family = (sa_family_t )2;
#line 166
  addr.sin_addr.s_addr = htonl((in_addr_t )0);
#line 167
  addr.sin_port = (in_port_t )0;
#line 169
  tmp___0 = bind(sockd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                 (socklen_t )sizeof(addr));
  }
#line 169
  if (tmp___0 < 0) {
#line 170
    return (-99);
  }
  {
#line 172
  namelen = (SocklenType )sizeof(addr);
#line 173
  tmp___1 = getsockname(sockd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                        (socklen_t */* __restrict  */)(& namelen));
  }
#line 173
  if (tmp___1 < 0) {
#line 174
    return (-99);
  }
  {
#line 176
  tmp___2 = ntohs(addr.sin_port);
#line 176
  port = (int )tmp___2;
#line 178
  listen(sockd, 5);
#line 199
  pid = fork();
  }
  {
#line 200
  if (pid == -1) {
#line 200
    goto case_neg_1;
  }
#line 204
  if (pid == 0) {
#line 204
    goto case_0;
  }
#line 213
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 201
  r = -99;
#line 202
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 206
  exec_erlang(ec, alive, adr, flags, erl, args, port);
#line 210
  exit(1);
  }
#line 211
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 217
  timeout.tv_usec = (__suseconds_t )0;
#line 218
  timeout.tv_sec = (__time_t )10;
#line 219
  r = wait_for_erlang(sockd, pid, & timeout);
  }
#line 219
  if (r == -5) {
    {
#line 221
    kill(pid, 2);
#line 222
    sleep(1U);
#line 223
    tmp___3 = waitpid(pid, (int *)((void *)0), 1);
    }
#line 223
    if (tmp___3 != pid) {
      {
#line 225
      kill(pid, 9);
#line 226
      sleep(1U);
#line 227
      waitpid(pid, (int *)((void *)0), 1);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
  done: 
#line 238
  if (sockd) {
    {
#line 238
    close(sockd);
    }
  }
#line 240
  return (r);
}
}
#line 485 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c"
static int exec_erlang(ei_cnode *ec , char *alive , Erl_IpAddr adr , int flags , char *erl ,
                       char **args , int port ) 
{ 
  int fd ;
  int len ;
  int l ;
  int i ;
  char **s ;
  char *argv[4] ;
  char argbuf[8192] ;
  struct in_addr myaddr ;
  struct in_addr *hisaddr ;
  char const   *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  __pid_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char debugfile[4097] ;
  char *home ;
  char *tmp___12 ;
  time_t t ;
  time_t tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 499
  hisaddr = adr;
#line 501
  tmp = ei_thishostname((ei_cnode const   *)ec);
#line 501
  get_addr(tmp, & myaddr);
  }
#line 505
  if (flags & 64) {
#line 505
    goto _L;
  } else
#line 505
  if (hisaddr->s_addr != myaddr.s_addr) {
    _L: /* CIL Label */ 
    {
#line 506
    argv[0] = (char *)"/usr/bin/rsh";
#line 507
    tmp___0 = inet_ntoa(*hisaddr);
#line 507
    tmp___1 = strlen((char const   *)tmp___0);
#line 507
    len = (int )tmp___1;
#line 508
    tmp___2 = malloc((size_t )(len + 1));
#line 508
    argv[1] = (char *)tmp___2;
#line 509
    tmp___3 = inet_ntoa(*hisaddr);
#line 509
    strcpy((char */* __restrict  */)argv[1], (char const   */* __restrict  */)tmp___3);
    }
  } else {
#line 513
    argv[0] = (char *)"sh";
#line 514
    argv[1] = (char *)"-c";
  }
#line 516
  argv[2] = argbuf;
#line 517
  argv[3] = (char *)((void *)0);
#line 519
  len = 0;
#line 520
  argbuf[0] = (char)0;
#line 522
  if (erl) {
#line 522
    tmp___4 = (char const   *)erl;
  } else {
#line 522
    tmp___4 = "erl";
  }
  {
#line 522
  sprintf((char */* __restrict  */)(argbuf), (char const   */* __restrict  */)"exec %s ",
          tmp___4);
#line 523
  tmp___5 = strlen((char const   *)(argbuf));
#line 523
  len = (int )tmp___5;
  }
#line 527
  if (flags & 4) {
#line 527
    tmp___6 = "-name";
  } else {
#line 527
    tmp___6 = "-sname";
  }
  {
#line 527
  sprintf((char */* __restrict  */)(& argbuf[len]), (char const   */* __restrict  */)"-noinput %s %s ",
          tmp___6, alive);
#line 530
  tmp___7 = strlen((char const   *)(argbuf));
#line 530
  len = (int )tmp___7;
#line 534
  tmp___8 = getpid();
#line 534
  tmp___9 = inet_ntoa(myaddr);
#line 534
  sprintf((char */* __restrict  */)(& argbuf[len]), (char const   */* __restrict  */)"-s erl_reply reply %s %d %d ",
          tmp___9, port, tmp___8);
#line 540
  tmp___10 = strlen((char const   *)(argbuf));
#line 540
  len = (int )tmp___10;
#line 544
  l = 0;
#line 544
  s = args;
  }
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (s) {
#line 544
      if (! *s) {
#line 544
        goto while_break;
      }
    } else {
#line 544
      goto while_break;
    }
    {
#line 544
    tmp___11 = strlen((char const   *)*s);
#line 544
    l = (int )((size_t )l + (tmp___11 + 1U));
#line 544
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  if ((len + l) + 1 > 8192) {
#line 546
    return (-52);
  } else {
#line 548
    s = args;
    {
#line 548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 548
      if (s) {
#line 548
        if (! *s) {
#line 548
          goto while_break___0;
        }
      } else {
#line 548
        goto while_break___0;
      }
      {
#line 549
      strcat((char */* __restrict  */)(argbuf), (char const   */* __restrict  */)" ");
#line 550
      strcat((char */* __restrict  */)(argbuf), (char const   */* __restrict  */)*s);
#line 548
      s ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 552
    len += l + 1;
  }
#line 555
  if (flags & 32) {
    {
#line 556
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: %s %s %s\n",
            argv[0], argv[1], argv[2]);
    }
  }
#line 560
  i = 0;
  {
#line 560
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 560
    if (! (i < 64)) {
#line 560
      goto while_break___1;
    }
    {
#line 560
    close(i);
#line 560
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 563
  if (flags & 16) {
    {
#line 565
    tmp___12 = getenv("HOME");
#line 565
    home = tmp___12;
#line 566
    sprintf((char */* __restrict  */)(debugfile), (char const   */* __restrict  */)"%s/%s.%s",
            home, ".erl_start.out", alive);
#line 567
    fd = open((char const   *)(debugfile), 1089, 420);
    }
#line 567
    if (fd >= 0) {
      {
#line 568
      tmp___13 = time((time_t *)((void *)0));
#line 568
      t = tmp___13;
#line 569
      dup2(fd, 1);
#line 570
      dup2(fd, 2);
#line 571
      tmp___14 = ctime((time_t const   *)(& t));
#line 571
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n===== Log started ======\n%s \n",
              tmp___14);
#line 572
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: %s %s %s\n",
              argv[0], argv[1], argv[2]);
      }
    }
  }
  {
#line 577
  execvp((char const   *)argv[0], (char * const  *)(argv));
  }
#line 579
  if (flags & 16) {
    {
#line 580
    tmp___15 = __errno_location();
#line 580
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: exec failed: (%d) %s %s %s\n",
            *tmp___15, argv[0], argv[1], argv[2]);
    }
  }
#line 586
  return (-99);
}
}
#line 624 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c"
static int wait_for_erlang(int sockd , int magic , struct timeval *timeout ) 
{ 
  struct timeval to ;
  struct timeval stop_time ;
  struct timeval now ;
  fd_set rdset ;
  int fd ;
  int n ;
  int i ;
  char buf[16] ;
  struct sockaddr_in peer ;
  SocklenType len ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  void *__cil_tmp17 ;

  {
  {
#line 634
  len = (SocklenType )sizeof(peer);
#line 637
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 638
  stop_time.tv_sec = now.tv_sec + timeout->tv_sec;
#line 639
  stop_time.tv_usec = now.tv_usec + timeout->tv_usec;
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (stop_time.tv_usec > 1000000L)) {
#line 640
      goto while_break;
    }
#line 641
    (stop_time.tv_sec) ++;
#line 642
    stop_time.tv_usec -= 1000000L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 651
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 652
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 652
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rdset.__fds_bits[0]): "memory");
#line 652
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 653
    rdset.__fds_bits[sockd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockd % (8 * (int )sizeof(__fd_mask ));
#line 656
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 657
    to.tv_sec = stop_time.tv_sec - now.tv_sec;
#line 658
    to.tv_usec = stop_time.tv_usec - now.tv_usec;
    }
    {
#line 659
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 659
      if (to.tv_usec <= 0L) {
#line 659
        if (! (to.tv_sec >= 0L)) {
#line 659
          goto while_break___2;
        }
      } else {
#line 659
        goto while_break___2;
      }
#line 660
      to.tv_usec += 1000000L;
#line 661
      (to.tv_sec) --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 663
    if (to.tv_sec < 0L) {
#line 663
      return (-5);
    }
    {
#line 669
    i = select(sockd + 1, (fd_set */* __restrict  */)(& rdset), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
    }
    {
#line 670
    if (i == -1) {
#line 670
      goto case_neg_1;
    }
#line 674
    if (i == 0) {
#line 674
      goto case_0;
    }
#line 683
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 671
    return (-99);
#line 672
    goto switch_break;
    case_0: /* CIL Label */ 
#line 680
    return (-5);
#line 681
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 689
    if ((rdset.__fds_bits[sockd / (8 * (int )sizeof(__fd_mask ))] & (1L << sockd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 690
      fd = accept(sockd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& peer)),
                  (socklen_t */* __restrict  */)(& len));
      }
#line 690
      if (fd < 0) {
#line 691
        return (-99);
      }
      {
#line 698
      n = read(fd, (void *)(buf), (size_t )16);
      }
#line 698
      if (n >= 0) {
#line 698
        buf[n] = (char)0;
      }
      {
#line 699
      close(fd);
#line 706
      tmp = atoi((char const   *)(buf));
      }
#line 706
      if (tmp == magic) {
#line 706
        return (0);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 712
  return (-99);
}
}
#line 716 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_start.c"
static struct in_addr *get_addr(char const   *hostname , struct in_addr *oaddr ) 
{ 
  struct hostent *hp ;
  char buf[1024] ;
  struct hostent host ;
  int herror___0 ;
  void *__cil_tmp7 ;

  {
  {
#line 725
  hp = ei_gethostbyname_r(hostname, & host, buf, 1024, & herror___0);
  }
#line 730
  if (hp) {
    {
#line 731
    memmove((void *)oaddr, (void const   *)*(hp->h_addr_list + 0), (size_t )sizeof(*oaddr));
    }
#line 732
    return (oaddr);
  }
#line 734
  return ((struct in_addr *)((void *)0));
}
}
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 117 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static void usage_arg(char const   *progname , char const   *switchname ) ;
#line 118
static void usage_error(char const   *progname , char const   *switchname ) ;
#line 119
static void usage(char const   *progname ) ;
#line 120
static int get_module(char **mbuf , char **mname ) ;
#line 121
static struct hostent *get_hostent(char *host ) ;
#line 122
static int do_connect(ei_cnode *ec , char *nodename , struct call_flags *flags ) ;
#line 123
static int read_stdin(char **buf ) ;
#line 124
static void split_apply_string(char *str , char **mod , char **fun , char **args ) ;
#line 138 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int fd ;
  int creation ;
  struct hostent *hp ;
  char host_name[65] ;
  char nodename[129] ;
  char *p ;
  char *ct ;
  int modsize ;
  char *host ;
  char *module ;
  char *modname ;
  struct call_flags flags ;
  char *progname ;
  ei_cnode ec ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  time_t tmp___23 ;
  time_t tmp___24 ;
  void *tmp___25 ;
  __pid_t tmp___26 ;
  int tmp___27 ;
  char h_hostname[65] ;
  char h_nodename[129] ;
  char *h_alivename ;
  struct in_addr h_ipadr ;
  char *ct___0 ;
  int volatile   *tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  int i___0 ;
  char *p___0 ;
  ei_x_buff reply ;
  void *tmp___31 ;
  char fname[256] ;
  int i___1 ;
  char *p___1 ;
  ei_x_buff reply___0 ;
  void *tmp___32 ;
  int tmp___33 ;
  int i___2 ;
  char *p___2 ;
  ei_x_buff reply___1 ;
  void *tmp___34 ;
  int tmp___35 ;
  char *evalbuf ;
  int len ;
  int i___3 ;
  char *p___3 ;
  ei_x_buff reply___2 ;
  void *tmp___36 ;
  int tmp___37 ;
  char *mod ;
  char *fun ;
  char *args ;
  ei_x_buff e ;
  ei_x_buff reply___3 ;
  int tmp___38 ;
  int i___4 ;
  int tmp___39 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;

  {
#line 143
  i = 1;
#line 147
  p = (char *)((void *)0);
#line 148
  ct = (char *)((void *)0);
#line 149
  modsize = 0;
#line 150
  host = (char *)((void *)0);
#line 151
  module = (char *)((void *)0);
#line 152
  modname = (char *)((void *)0);
#line 153
  flags.startp = 0;
#line 153
  flags.cookiep = 0;
#line 153
  flags.modp = 0;
#line 153
  flags.evalp = 0;
#line 153
  flags.randomp = 0;
#line 153
  flags.use_long_name = 0;
#line 153
  flags.debugp = 0;
#line 153
  flags.verbosep = 0;
#line 153
  flags.haltp = 0;
#line 153
  flags.cookie = (char *)0;
#line 153
  flags.node = (char *)0;
#line 153
  flags.hidden = (char *)0;
#line 153
  flags.apply = (char *)0;
#line 153
  flags.script = (char *)0;
#line 154
  progname = *(argv + 0);
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < argc)) {
#line 158
      goto while_break;
    }
#line 159
    if ((int )*(*(argv + i) + 0) != 45) {
      {
#line 160
      usage_error((char const   *)progname, (char const   *)*(argv + i));
      }
    }
    {
#line 163
    tmp___15 = strcmp((char const   *)*(argv + i), "-sname");
    }
#line 163
    if (tmp___15 == 0) {
#line 164
      if (i + 1 >= argc) {
        {
#line 165
        usage_arg((char const   *)progname, "-sname ");
        }
      }
      {
#line 168
      tmp = strlen((char const   *)*(argv + (i + 1)));
#line 168
      tmp___0 = malloc(tmp + 1U);
#line 168
      flags.node = (char *)tmp___0;
#line 169
      strcpy((char */* __restrict  */)flags.node, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 170
      i ++;
#line 171
      flags.use_long_name = 0;
      }
    } else {
      {
#line 172
      tmp___14 = strcmp((char const   *)*(argv + i), "-name");
      }
#line 172
      if (tmp___14 == 0) {
#line 173
        if (i + 1 >= argc) {
          {
#line 174
          usage_arg((char const   *)progname, "-name ");
          }
        }
        {
#line 177
        tmp___1 = strlen((char const   *)*(argv + (i + 1)));
#line 177
        tmp___2 = malloc(tmp___1 + 1U);
#line 177
        flags.node = (char *)tmp___2;
#line 178
        strcpy((char */* __restrict  */)flags.node, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 179
        i ++;
#line 180
        flags.use_long_name = 1;
        }
      } else {
        {
#line 182
        tmp___3 = strlen((char const   *)*(argv + i));
        }
#line 182
        if (tmp___3 != 2U) {
          {
#line 183
          usage_error((char const   *)progname, (char const   *)*(argv + i));
          }
        }
        {
#line 187
        if ((int )*(*(argv + i) + 1) == 115) {
#line 187
          goto case_115;
        }
#line 190
        if ((int )*(*(argv + i) + 1) == 113) {
#line 190
          goto case_113;
        }
#line 193
        if ((int )*(*(argv + i) + 1) == 118) {
#line 193
          goto case_118;
        }
#line 196
        if ((int )*(*(argv + i) + 1) == 100) {
#line 196
          goto case_100;
        }
#line 199
        if ((int )*(*(argv + i) + 1) == 114) {
#line 199
          goto case_114;
        }
#line 202
        if ((int )*(*(argv + i) + 1) == 101) {
#line 202
          goto case_101;
        }
#line 205
        if ((int )*(*(argv + i) + 1) == 109) {
#line 205
          goto case_109;
        }
#line 208
        if ((int )*(*(argv + i) + 1) == 99) {
#line 208
          goto case_99;
        }
#line 217
        if ((int )*(*(argv + i) + 1) == 110) {
#line 217
          goto case_110;
        }
#line 226
        if ((int )*(*(argv + i) + 1) == 104) {
#line 226
          goto case_104;
        }
#line 234
        if ((int )*(*(argv + i) + 1) == 120) {
#line 234
          goto case_120;
        }
#line 242
        if ((int )*(*(argv + i) + 1) == 97) {
#line 242
          goto case_97;
        }
#line 250
        if ((int )*(*(argv + i) + 1) == 63) {
#line 250
          goto case_63;
        }
#line 252
        goto switch_default;
        case_115: /* CIL Label */ 
#line 188
        flags.startp = 1;
#line 189
        goto switch_break;
        case_113: /* CIL Label */ 
#line 191
        flags.haltp = 1;
#line 192
        goto switch_break;
        case_118: /* CIL Label */ 
#line 194
        flags.verbosep = 1;
#line 195
        goto switch_break;
        case_100: /* CIL Label */ 
#line 197
        flags.debugp = 1;
#line 198
        goto switch_break;
        case_114: /* CIL Label */ 
#line 200
        flags.randomp = 1;
#line 201
        goto switch_break;
        case_101: /* CIL Label */ 
#line 203
        flags.evalp = 1;
#line 204
        goto switch_break;
        case_109: /* CIL Label */ 
#line 206
        flags.modp = 1;
#line 207
        goto switch_break;
        case_99: /* CIL Label */ 
#line 209
        if (i + 1 >= argc) {
          {
#line 210
          usage_arg((char const   *)progname, "-c ");
          }
        }
        {
#line 212
        flags.cookiep = 1;
#line 213
        tmp___4 = strlen((char const   *)*(argv + (i + 1)));
#line 213
        tmp___5 = malloc(tmp___4 + 1U);
#line 213
        flags.cookie = (char *)tmp___5;
#line 214
        strcpy((char */* __restrict  */)flags.cookie, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 215
        i ++;
        }
#line 216
        goto switch_break;
        case_110: /* CIL Label */ 
#line 218
        if (i + 1 >= argc) {
          {
#line 219
          usage_arg((char const   *)progname, "-n ");
          }
        }
        {
#line 221
        tmp___6 = strlen((char const   *)*(argv + (i + 1)));
#line 221
        tmp___7 = malloc(tmp___6 + 1U);
#line 221
        flags.node = (char *)tmp___7;
#line 222
        strcpy((char */* __restrict  */)flags.node, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 223
        flags.use_long_name = 1;
#line 224
        i ++;
        }
#line 225
        goto switch_break;
        case_104: /* CIL Label */ 
#line 227
        if (i + 1 >= argc) {
          {
#line 228
          usage_arg((char const   *)progname, "-h ");
          }
        }
        {
#line 230
        tmp___8 = strlen((char const   *)*(argv + (i + 1)));
#line 230
        tmp___9 = malloc(tmp___8 + 1U);
#line 230
        flags.hidden = (char *)tmp___9;
#line 231
        strcpy((char */* __restrict  */)flags.hidden, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 232
        i ++;
        }
#line 233
        goto switch_break;
        case_120: /* CIL Label */ 
#line 235
        if (i + 1 >= argc) {
          {
#line 236
          usage_arg((char const   *)progname, "-x ");
          }
        }
        {
#line 238
        tmp___10 = strlen((char const   *)*(argv + (i + 1)));
#line 238
        tmp___11 = malloc(tmp___10 + 1U);
#line 238
        flags.script = (char *)tmp___11;
#line 239
        strcpy((char */* __restrict  */)flags.script, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 240
        i ++;
        }
#line 241
        goto switch_break;
        case_97: /* CIL Label */ 
#line 243
        if (i + 1 >= argc) {
          {
#line 244
          usage_arg((char const   *)progname, "-a ");
          }
        }
        {
#line 246
        tmp___12 = strlen((char const   *)*(argv + (i + 1)));
#line 246
        tmp___13 = malloc(tmp___12 + 1U);
#line 246
        flags.apply = (char *)tmp___13;
#line 247
        strcpy((char */* __restrict  */)flags.apply, (char const   */* __restrict  */)*(argv + (i + 1)));
#line 248
        i ++;
        }
#line 249
        goto switch_break;
        case_63: /* CIL Label */ 
        {
#line 251
        usage((char const   *)progname);
        }
        switch_default: /* CIL Label */ 
        {
#line 253
        usage_error((char const   *)progname, (char const   *)*(argv + i));
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 256
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if (flags.modp) {
#line 264
    if (flags.evalp) {
      {
#line 265
      usage((char const   *)progname);
      }
    }
  }
#line 271
  if (flags.modp) {
    {
#line 272
    modsize = get_module(& module, & modname);
    }
  }
#line 275
  if (flags.verbosep) {
#line 275
    goto _L;
  } else
#line 275
  if (flags.debugp) {
    _L: /* CIL Label */ 
#line 276
    if (flags.apply) {
#line 276
      tmp___16 = (char const   *)flags.apply;
    } else {
#line 276
      tmp___16 = "";
    }
#line 276
    if (modname) {
#line 276
      tmp___17 = (char const   *)modname;
    } else {
#line 276
      tmp___17 = "";
    }
#line 276
    if (flags.debugp) {
#line 276
      tmp___18 = "debugp";
    } else {
#line 276
      tmp___18 = "";
    }
#line 276
    if (flags.verbosep) {
#line 276
      tmp___19 = "verbosep";
    } else {
#line 276
      tmp___19 = "";
    }
#line 276
    if (flags.startp) {
#line 276
      tmp___20 = "startp";
    } else {
#line 276
      tmp___20 = "";
    }
#line 276
    if (flags.cookie) {
#line 276
      tmp___21 = (char const   *)flags.cookie;
    } else {
#line 276
      tmp___21 = "";
    }
#line 276
    if (flags.node) {
#line 276
      tmp___22 = (char const   *)flags.node;
    } else {
#line 276
      tmp___22 = "";
    }
    {
#line 276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: node = %s\nCookie = %s\nflags = %s %s %s\nmodule: name = %s , size = %d\napply = %s\n",
            tmp___22, tmp___21, tmp___20, tmp___19, tmp___18, tmp___17, modsize, tmp___16);
    }
  }
#line 293
  if ((unsigned long )flags.node == (unsigned long )((void *)0)) {
    {
#line 294
    usage((char const   *)progname);
    }
  }
#line 297
  if (! flags.cookiep) {
#line 298
    flags.cookie = (char *)((void *)0);
  }
  {
#line 302
  tmp___23 = time((time_t *)((void *)0));
#line 302
  creation = (int )(tmp___23 % 3L + 1L);
  }
#line 304
  if ((unsigned long )flags.hidden == (unsigned long )((void *)0)) {
#line 306
    if (flags.randomp) {
      {
#line 306
      tmp___24 = time((time_t *)((void *)0));
#line 306
      i = (int )(tmp___24 % 997L);
      }
    } else {
#line 306
      i = 17;
    }
    {
#line 308
    tmp___25 = malloc((size_t )5);
#line 308
    flags.hidden = (char *)tmp___25;
    }
#line 313
    if (i < 0) {
      {
#line 313
      tmp___26 = getpid();
#line 313
      tmp___27 = tmp___26;
      }
    } else {
#line 313
      tmp___27 = i;
    }
    {
#line 313
    sprintf((char */* __restrict  */)flags.hidden, (char const   */* __restrict  */)"c%d",
            tmp___27);
    }
  }
  {
#line 321
  h_alivename = flags.hidden;
#line 333
  gethostname(h_hostname, (size_t )64);
#line 334
  hp = ei_gethostbyname((char const   *)(h_hostname));
  }
#line 334
  if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
    {
#line 335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: can\'t resolve hostname %s\n",
            h_hostname);
#line 336
    exit(1);
    }
  }
#line 339
  if (flags.use_long_name == 0) {
    {
#line 339
    ct___0 = strchr((char const   *)hp->h_name, '.');
    }
#line 339
    if ((unsigned long )ct___0 != (unsigned long )((void *)0)) {
#line 340
      *ct___0 = (char )'\000';
    }
  }
  {
#line 342
  strcpy((char */* __restrict  */)(h_hostname), (char const   */* __restrict  */)hp->h_name);
#line 343
  memcpy((void */* __restrict  */)(& h_ipadr.s_addr), (void const   */* __restrict  */)*(hp->h_addr_list),
         (size_t )sizeof(struct in_addr ));
#line 344
  sprintf((char */* __restrict  */)(h_nodename), (char const   */* __restrict  */)"%s@%s",
          h_alivename, h_hostname);
#line 346
  tmp___29 = ei_connect_xinit(& ec, (char const   *)(h_hostname), (char const   *)h_alivename,
                              (char const   *)(h_nodename), & h_ipadr, (char const   *)flags.cookie,
                              (short const   )((short )creation));
  }
#line 346
  if (tmp___29 < 0) {
    {
#line 349
    tmp___28 = __erl_errno_place();
#line 349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: can\'t create C node %s; %d\n",
            h_nodename, *tmp___28);
#line 351
    exit(1);
    }
  }
  {
#line 355
  p = strchr((char const   *)flags.node, '@');
  }
#line 355
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 356
    tmp___30 = ei_thishostname((ei_cnode const   *)(& ec));
#line 356
    strcpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)tmp___30);
#line 357
    host = host_name;
    }
  } else {
#line 359
    *p = (char)0;
#line 360
    host = p + 1;
  }
  {
#line 367
  hp = get_hostent(host);
  }
#line 367
  if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: can\'t get_hostent(%s)\n",
            host);
#line 369
    exit(1);
    }
  }
#line 372
  if (flags.use_long_name == 0) {
    {
#line 372
    ct = strchr((char const   *)hp->h_name, '.');
    }
#line 372
    if ((unsigned long )ct != (unsigned long )((void *)0)) {
#line 373
      *ct = (char )'\000';
    }
  }
  {
#line 375
  strcpy((char */* __restrict  */)(host_name), (char const   */* __restrict  */)hp->h_name);
#line 376
  sprintf((char */* __restrict  */)(nodename), (char const   */* __restrict  */)"%s@%s",
          flags.node, host_name);
  }
#line 382
  if (flags.startp) {
#line 382
    if (! flags.haltp) {
      {
#line 383
      fd = do_connect(& ec, nodename, & flags);
      }
    } else {
#line 382
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 384
    fd = ei_connect(& ec, nodename);
    }
#line 384
    if (fd < 0) {
#line 387
      if (flags.haltp) {
        {
#line 388
        exit(0);
        }
      } else {
        {
#line 390
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: failed to connect to node %s\n",
                nodename);
#line 392
        exit(1);
        }
      }
    }
  }
#line 397
  if (fd) {
#line 397
    if (flags.haltp) {
      {
#line 398
      i___0 = 0;
#line 402
      ei_encode_list_header((char *)((void *)0), & i___0, 0);
#line 404
      tmp___31 = malloc((size_t )i___0);
#line 404
      p___0 = (char *)tmp___31;
#line 405
      i___0 = 0;
#line 407
      ei_encode_list_header(p___0, & i___0, 0);
#line 409
      ei_x_new_with_version(& reply);
#line 412
      ei_rpc(& ec, fd, (char *)"erlang", (char *)"halt", (char const   *)p___0, i___0,
             & reply);
#line 413
      free((void *)p___0);
#line 414
      ei_x_free(& reply);
#line 415
      exit(0);
      }
    }
  }
#line 418
  if (flags.verbosep) {
    {
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: we are now connected to node \"%s\"\n",
            nodename);
    }
  }
#line 426
  if (flags.modp) {
#line 426
    if ((unsigned long )modname != (unsigned long )((void *)0)) {
      {
#line 429
      strcpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)modname);
#line 430
      strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)".erl");
#line 437
      i___1 = 0;
#line 441
      ei_encode_list_header((char *)((void *)0), & i___1, 2);
#line 442
      ei_encode_string((char *)((void *)0), & i___1, (char const   *)(fname));
#line 443
      ei_encode_binary((char *)((void *)0), & i___1, (void const   *)module, (long )modsize);
#line 444
      ei_encode_list_header((char *)((void *)0), & i___1, 0);
#line 446
      tmp___32 = malloc((size_t )i___1);
#line 446
      p___1 = (char *)tmp___32;
#line 447
      i___1 = 0;
#line 449
      ei_encode_list_header(p___1, & i___1, 2);
#line 450
      ei_encode_string(p___1, & i___1, (char const   *)(fname));
#line 451
      ei_encode_binary(p___1, & i___1, (void const   *)module, (long )modsize);
#line 452
      ei_encode_list_header(p___1, & i___1, 0);
#line 454
      ei_x_new_with_version(& reply___0);
#line 456
      tmp___33 = ei_rpc(& ec, fd, (char *)"file", (char *)"write_file", (char const   *)p___1,
                        i___1, & reply___0);
      }
#line 456
      if (tmp___33 < 0) {
        {
#line 457
        free((void *)p___1);
#line 458
        ei_x_free(& reply___0);
#line 459
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: can\'t write to source file %s\n",
                fname);
#line 461
        exit(1);
        }
      }
      {
#line 463
      free((void *)p___1);
#line 464
      ei_x_free(& reply___0);
#line 470
      i___2 = 0;
#line 474
      ei_encode_list_header((char *)((void *)0), & i___2, 2);
#line 475
      ei_encode_atom((char *)((void *)0), & i___2, (char const   *)(fname));
#line 476
      ei_encode_list_header((char *)((void *)0), & i___2, 0);
#line 477
      ei_encode_list_header((char *)((void *)0), & i___2, 0);
#line 479
      tmp___34 = malloc((size_t )i___2);
#line 479
      p___2 = (char *)tmp___34;
#line 480
      i___2 = 0;
#line 482
      ei_encode_list_header(p___2, & i___2, 2);
#line 483
      ei_encode_atom(p___2, & i___2, (char const   *)(fname));
#line 484
      ei_encode_list_header(p___2, & i___2, 0);
#line 485
      ei_encode_list_header(p___2, & i___2, 0);
#line 487
      ei_x_new_with_version(& reply___1);
#line 491
      tmp___35 = ei_rpc(& ec, fd, (char *)"c", (char *)"c", (char const   *)p___2,
                        i___2, & reply___1);
      }
#line 491
      if (tmp___35 < 0) {
        {
#line 492
        free((void *)p___2);
#line 493
        ei_x_free(& reply___1);
#line 494
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: can\'t compile file %s\n",
                fname);
        }
      }
      {
#line 496
      free((void *)p___2);
#line 503
      ei_x_free(& reply___1);
      }
    }
  }
#line 510
  if (flags.evalp) {
    {
#line 514
    len = read_stdin(& evalbuf);
#line 516
    i___3 = 0;
#line 520
    ei_encode_list_header((char *)((void *)0), & i___3, 1);
#line 521
    ei_encode_binary((char *)((void *)0), & i___3, (void const   *)evalbuf, (long )len);
#line 522
    ei_encode_list_header((char *)((void *)0), & i___3, 0);
#line 524
    tmp___36 = malloc((size_t )i___3);
#line 524
    p___3 = (char *)tmp___36;
#line 525
    i___3 = 0;
#line 527
    ei_encode_list_header(p___3, & i___3, 1);
#line 528
    ei_encode_binary(p___3, & i___3, (void const   *)evalbuf, (long )len);
#line 529
    ei_encode_list_header(p___3, & i___3, 0);
#line 531
    ei_x_new_with_version(& reply___2);
#line 535
    tmp___37 = ei_rpc(& ec, fd, (char *)"lib", (char *)"eval_str", (char const   *)p___3,
                      i___3, & reply___2);
    }
#line 535
    if (tmp___37 < 0) {
      {
#line 536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: evaluating input failed: %s\n",
              evalbuf);
#line 538
      free((void *)p___3);
#line 539
      free((void *)evalbuf);
#line 540
      ei_x_free(& reply___2);
#line 541
      exit(1);
      }
    }
    {
#line 543
    i___3 = 0;
#line 544
    ei_print_term(stdout, (char const   *)reply___2.buff, & i___3);
#line 545
    free((void *)p___3);
#line 546
    free((void *)evalbuf);
#line 547
    ei_x_free(& reply___2);
    }
  }
#line 553
  if ((unsigned long )flags.apply != (unsigned long )((void *)0)) {
    {
#line 557
    split_apply_string(flags.apply, & mod, & fun, & args);
    }
#line 558
    if (flags.verbosep) {
      {
#line 559
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: module = %s, function = %s, args = %s\n",
              mod, fun, args);
      }
    }
    {
#line 563
    ei_x_new(& e);
#line 565
    tmp___38 = ei_x_format_wo_ver(& e, (char const   *)args);
    }
#line 565
    if (tmp___38 < 0) {
      {
#line 567
      exit(-1);
      }
    }
    {
#line 570
    ei_x_new_with_version(& reply___3);
#line 572
    tmp___39 = ei_rpc(& ec, fd, mod, fun, (char const   *)e.buff, e.index, & reply___3);
    }
#line 572
    if (tmp___39 < 0) {
      {
#line 574
      ei_x_free(& e);
#line 575
      ei_x_free(& reply___3);
#line 576
      exit(-1);
      }
    } else {
      {
#line 578
      i___4 = 0;
#line 579
      ei_print_term(stdout, (char const   *)reply___3.buff, & i___4);
#line 580
      ei_x_free(& e);
#line 581
      ei_x_free(& reply___3);
      }
    }
  }
#line 585
  return (0);
}
}
#line 599 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static struct hostent *get_hostent(char *host ) 
{ 
  struct in_addr ip_addr ;
  int b1 ;
  int b2 ;
  int b3 ;
  int b4 ;
  long addr ;
  int tmp ;
  in_addr_t tmp___0 ;
  struct hostent *tmp___1 ;
  unsigned short const   **tmp___2 ;
  struct hostent *tmp___3 ;
  char *__cil_tmp13 ;

  {
  {
#line 601
  tmp___2 = __ctype_b_loc();
  }
#line 601
  if ((int const   )*(*tmp___2 + (int )*host) & 2048) {
    {
#line 607
    tmp = sscanf((char const   */* __restrict  */)host, (char const   */* __restrict  */)"%d.%d.%d.%d",
                 & b1, & b2, & b3, & b4);
    }
#line 607
    if (tmp != 4) {
#line 608
      return ((struct hostent *)((void *)0));
    }
    {
#line 610
    tmp___0 = inet_addr((char const   *)host);
#line 610
    addr = (long )tmp___0;
#line 611
    ip_addr.s_addr = htonl((uint32_t )addr);
#line 613
    tmp___1 = ei_gethostbyaddr((char const   *)((char *)(& ip_addr)), (int )sizeof(struct in_addr ),
                               2);
    }
#line 613
    return (tmp___1);
  }
  {
#line 616
  tmp___3 = ei_gethostbyname((char const   *)host);
  }
#line 616
  return (tmp___3);
}
}
#line 625 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static int do_connect(ei_cnode *ec , char *nodename , struct call_flags *flags ) 
{ 
  int fd ;
  int start_flags ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char alive[64] ;
  char *hostname ;
  struct hostent *h ;
  char *cookieargs[3] ;
  char **args ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 631
  if (flags->use_long_name) {
#line 631
    tmp = 4;
  } else {
#line 631
    tmp = 0;
  }
#line 631
  if (flags->verbosep) {
#line 631
    tmp___0 = 32;
  } else {
#line 631
    tmp___0 = 0;
  }
#line 631
  if (flags->debugp) {
#line 631
    tmp___1 = 16;
  } else {
#line 631
    tmp___1 = 0;
  }
  {
#line 631
  start_flags = ((1 | tmp) | tmp___0) | tmp___1;
#line 636
  fd = ei_connect(ec, nodename);
  }
#line 636
  if (fd >= 0) {
#line 638
    if (flags->verbosep) {
      {
#line 639
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: now connected to node %s\n",
              nodename);
      }
    }
  } else {
#line 648
    cookieargs[0] = (char *)"-setcookie";
#line 649
    cookieargs[1] = flags->cookie;
#line 650
    cookieargs[2] = (char *)((void *)0);
#line 652
    if (flags->cookie) {
#line 652
      args = cookieargs;
    } else {
#line 652
      args = (char **)((void *)0);
    }
    {
#line 654
    hostname = strrchr((char const   *)nodename, '@');
    }
#line 654
    if (! hostname) {
#line 655
      return (-52);
    }
    {
#line 657
    strncpy((char */* __restrict  */)(alive), (char const   */* __restrict  */)nodename,
            (size_t )(hostname - nodename));
#line 658
    alive[hostname - nodename] = (char)0;
#line 659
    hostname ++;
#line 661
    h = ei_gethostbyname((char const   *)hostname);
#line 664
    r = erl_start_sys(ec, alive, (Erl_IpAddr )*(h->h_addr_list + 0), start_flags,
                      flags->script, args);
    }
#line 664
    if (r < 0) {
      {
#line 666
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: unable to start node, error = %d\n",
              r);
#line 667
      exit(1);
      }
    }
    {
#line 670
    fd = ei_connect(ec, nodename);
    }
#line 670
    if (fd >= 0) {
#line 672
      if (flags->verbosep) {
        {
#line 673
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: now connected to node \"%s\"\n",
                nodename);
        }
      }
    } else {
      {
#line 679
      if (fd == -2) {
#line 679
        goto case_neg_2;
      }
#line 682
      if (fd == -4) {
#line 682
        goto case_neg_4;
      }
#line 685
      if (fd == -3) {
#line 685
        goto case_neg_3;
      }
#line 688
      if (fd == -5) {
#line 688
        goto case_neg_5;
      }
#line 691
      goto switch_default;
      case_neg_2: /* CIL Label */ 
      {
#line 680
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: no epmd running\n");
#line 681
      exit(1);
      }
      case_neg_4: /* CIL Label */ 
      {
#line 683
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: connect failed\n");
#line 684
      exit(1);
      }
      case_neg_3: /* CIL Label */ 
      {
#line 686
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: node is not running\n");
#line 687
      exit(1);
      }
      case_neg_5: /* CIL Label */ 
      {
#line 689
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: connect timed out\n");
#line 690
      exit(1);
      }
      switch_default: /* CIL Label */ 
      {
#line 692
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: error during connect\n");
#line 693
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 698
  return (fd);
}
}
#line 704 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static void split_apply_string(char *str , char **mod , char **fun , char **args ) 
{ 
  char *begin ;
  char *start ;
  char *empty_list ;
  int len ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned short const   **tmp___7 ;
  void *tmp___8 ;
  unsigned short const   **tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 709
  begin = str;
#line 710
  start = (char *)"start";
#line 711
  empty_list = (char *)"[]";
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 714
    tmp = __ctype_b_loc();
    }
#line 714
    if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 714
      goto while_break;
    }
#line 714
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 715
  if ((int )*str == 0) {
    {
#line 716
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: wrong format of apply string (1)\n");
#line 717
    exit(1);
    }
  }
  {
#line 720
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 720
    tmp___0 = __ctype_b_loc();
    }
#line 720
    if ((int const   )*(*tmp___0 + (int )*str) & 8192) {
#line 720
      goto while_break___0;
    } else
#line 720
    if (! ((int )*str != 0)) {
#line 720
      goto while_break___0;
    }
#line 720
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 721
  len = (int )(str - begin);
#line 722
  tmp___1 = calloc((size_t )(len + 1), (size_t )sizeof(char ));
#line 722
  *mod = (char *)tmp___1;
#line 723
  memcpy((void */* __restrict  */)*mod, (void const   */* __restrict  */)begin, (size_t )len);
  }
  {
#line 725
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 725
    tmp___2 = __ctype_b_loc();
    }
#line 725
    if (! ((int const   )*(*tmp___2 + (int )*str) & 8192)) {
#line 725
      goto while_break___1;
    }
#line 725
    str ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 726
  if ((int )*str == 0) {
    {
#line 727
    tmp___3 = strlen((char const   *)start);
#line 727
    tmp___4 = calloc(tmp___3 + 1U, (size_t )sizeof(char ));
#line 727
    *fun = (char *)tmp___4;
#line 728
    strcpy((char */* __restrict  */)*fun, (char const   */* __restrict  */)start);
#line 729
    tmp___5 = strlen((char const   *)empty_list);
#line 729
    tmp___6 = calloc(tmp___5 + 1U, (size_t )sizeof(char ));
#line 729
    *args = (char *)tmp___6;
#line 730
    strcpy((char */* __restrict  */)*args, (char const   */* __restrict  */)empty_list);
    }
#line 731
    return;
  }
#line 733
  begin = str;
  {
#line 734
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 734
    tmp___7 = __ctype_b_loc();
    }
#line 734
    if ((int const   )*(*tmp___7 + (int )*str) & 8192) {
#line 734
      goto while_break___2;
    } else
#line 734
    if (! ((int )*str != 0)) {
#line 734
      goto while_break___2;
    }
#line 734
    str ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 735
  len = (int )(str - begin);
#line 736
  tmp___8 = calloc((size_t )(len + 1), (size_t )sizeof(char ));
#line 736
  *fun = (char *)tmp___8;
#line 737
  memcpy((void */* __restrict  */)*fun, (void const   */* __restrict  */)begin, (size_t )len);
  }
  {
#line 739
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 739
    tmp___9 = __ctype_b_loc();
    }
#line 739
    if (! ((int const   )*(*tmp___9 + (int )*str) & 8192)) {
#line 739
      goto while_break___3;
    }
#line 739
    str ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 740
  if ((int )*str == 0) {
    {
#line 741
    tmp___10 = strlen((char const   *)empty_list);
#line 741
    tmp___11 = calloc(tmp___10 + 1U, (size_t )sizeof(char ));
#line 741
    *args = (char *)tmp___11;
#line 742
    strcpy((char */* __restrict  */)*args, (char const   */* __restrict  */)empty_list);
    }
#line 743
    return;
  }
  {
#line 746
  tmp___12 = strlen((char const   *)str);
#line 746
  tmp___13 = calloc(tmp___12 + 1U, (size_t )sizeof(char ));
#line 746
  *args = (char *)tmp___13;
#line 747
  strcpy((char */* __restrict  */)*args, (char const   */* __restrict  */)str);
  }
#line 749
  return;
}
}
#line 758 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static int read_stdin(char **buf ) 
{ 
  int bsize ;
  int len ;
  int i ;
  char *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 760
  bsize = 8192;
#line 761
  len = 0;
#line 763
  tmp___0 = malloc((size_t )bsize);
#line 763
  tmp = (char *)tmp___0;
  }
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 766
    i = read(0, (void *)(tmp + len), (size_t )(bsize - len));
    }
#line 766
    if (i < 0) {
      {
#line 767
      tmp___1 = __errno_location();
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"erl_call: can\'t read stdin, errno = %d",
              *tmp___1);
#line 768
      exit(1);
      }
    } else
#line 769
    if (i == 0) {
#line 770
      goto while_break;
    } else {
#line 772
      len += i;
#line 773
      if (len + 50 > bsize) {
        {
#line 774
        bsize = len * 2;
#line 775
        tmp___2 = realloc((void *)tmp, (size_t )bsize);
#line 775
        tmp = (char *)tmp___2;
        }
      } else {
#line 777
        goto while_continue;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  *buf = tmp;
#line 782
  return (len);
}
}
#line 789 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static int get_module(char **mbuf , char **mname ) 
{ 
  char *tmp ;
  int len ;
  int i ;
  char *start ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 794
  len = read_stdin(mbuf);
#line 798
  tmp = strstr((char const   *)*mbuf, "-module(");
  }
#line 798
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 800
    tmp___0 = strlen("-module(");
#line 800
    tmp += tmp___0;
    }
    {
#line 801
    while (1) {
      while_continue: /* CIL Label */ ;
#line 801
      if (! ((int )*tmp == 32)) {
#line 801
        goto while_break;
      }
#line 801
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 802
    start = tmp;
    {
#line 803
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 804
      tmp___1 = __ctype_b_loc();
      }
#line 804
      if ((int const   )*(*tmp___1 + (int )*tmp) & 8) {
#line 805
        tmp ++;
#line 806
        goto while_continue___0;
      } else
#line 804
      if ((int )*tmp == 95) {
#line 805
        tmp ++;
#line 806
        goto while_continue___0;
      } else {
#line 808
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 811
    i = (int )(tmp - start);
#line 812
    tmp___2 = calloc((size_t )(i + 1), (size_t )sizeof(char ));
#line 812
    *mname = (char *)tmp___2;
#line 813
    memcpy((void */* __restrict  */)*mname, (void const   */* __restrict  */)start,
           (size_t )i);
    }
  }
  {
#line 815
  free((void *)mbuf);
  }
#line 817
  return (len);
}
}
#line 828 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static void usage_noexit(char const   *progname ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 829
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUsage: %s [-[demqrsv]] [-c Cookie] [-h HiddenName] \n",
          progname);
#line 830
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"            [-x ErlScript] [-a [Mod [Fun [Args]]]]\n");
#line 831
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"            (-n Node | -sname Node | -name Node)\n\n");
#line 835
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  where: -a  apply(Mod,Fun,Args) (e.g -a \'erlang length [[a,b,c]]\'\n");
#line 837
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -c  cookie string; by default read from ~/.erlang.cookie\n");
#line 838
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -d  direct Erlang output to ~/.erl_call.out.<Nodename>\n");
#line 839
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -e  evaluate contents of standard input (e.g echo \"X=1,Y=2,{X,Y}.\"|erl_call -e ...)\n");
#line 840
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -h  specify a name for the erl_call client node\n");
#line 841
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -m  read and compile Erlang module from stdin\n");
#line 842
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -n  name of Erlang node, same as -name\n");
#line 843
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -name  name of Erlang node, expanded to a fully qualified\n");
#line 844
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -sname name of Erlang node, short form will be used\n");
#line 845
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -q  halt the Erlang node (overrides the -s switch)\n");
#line 846
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -r  use a random name for the erl_call client node\n");
#line 847
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -s  start a new Erlang node if necessary\n");
#line 848
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -v  verbose mode, i.e print some information on stderr\n");
#line 849
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"         -x  use specified erl start script, default is erl\n");
  }
#line 850
  return;
}
}
#line 852 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static void usage_arg(char const   *progname , char const   *switchname ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 853
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing argument(s) for \'%s\'.\n",
          switchname);
#line 854
  usage_noexit(progname);
#line 855
  exit(1);
  }
}
}
#line 858 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static void usage_error(char const   *progname , char const   *switchname ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 859
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal argument \'%s\'.\n",
          switchname);
#line 860
  usage_noexit(progname);
#line 861
  exit(1);
  }
}
}
#line 864 "/home/wslee/benchmarks/erlang-13.b.3-dfsg/lib/erl_interface/src/prog/erl_call.c"
static void usage(char const   *progname ) 
{ 


  {
  {
#line 865
  usage_noexit(progname);
#line 866
  exit(0);
  }
}
}
