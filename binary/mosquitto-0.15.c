/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 101 "./mosquitto.h"
struct mosquitto_message {
   uint16_t mid ;
   char *topic ;
   uint8_t *payload ;
   uint32_t payloadlen ;
   int qos ;
   _Bool retain ;
};
#line 110
struct mosquitto;
#line 49 "./mosquitto_internal.h"
enum mosquitto_msg_direction {
    mosq_md_in = 0,
    mosq_md_out = 1
} ;
#line 54
enum mosquitto_msg_state {
    mosq_ms_invalid = 0,
    mosq_ms_wait_puback = 1,
    mosq_ms_wait_pubrec = 2,
    mosq_ms_wait_pubrel = 3,
    mosq_ms_wait_pubcomp = 4
} ;
#line 62
enum mosquitto_client_state {
    mosq_cs_new = 0,
    mosq_cs_connected = 1,
    mosq_cs_disconnecting = 2
} ;
#line 68 "./mosquitto_internal.h"
struct _mosquitto_packet {
   uint8_t command ;
   uint8_t have_remaining ;
   uint8_t remaining_count ;
   uint16_t mid ;
   uint32_t remaining_mult ;
   uint32_t remaining_length ;
   uint32_t packet_length ;
   uint32_t to_process ;
   uint32_t pos ;
   uint8_t *payload ;
   struct _mosquitto_packet *next ;
};
#line 82 "./mosquitto_internal.h"
struct mosquitto_message_all {
   struct mosquitto_message_all *next ;
   time_t timestamp ;
   enum mosquitto_msg_direction direction ;
   enum mosquitto_msg_state state ;
   _Bool dup ;
   struct mosquitto_message msg ;
};
#line 101 "./mosquitto_internal.h"
struct mosquitto {
   int sock ;
   char *address ;
   char *id ;
   char *username ;
   char *password ;
   uint16_t keepalive ;
   _Bool clean_session ;
   enum mosquitto_client_state state ;
   time_t last_msg_in ;
   time_t last_msg_out ;
   uint16_t last_mid ;
   struct _mosquitto_packet in_packet ;
   struct _mosquitto_packet *out_packet ;
   struct mosquitto_message *will ;
   void *obj ;
   _Bool in_callback ;
   unsigned int message_retry ;
   time_t last_retry_check ;
   struct mosquitto_message_all *messages ;
   int log_priorities ;
   int log_destinations ;
   void (*on_connect)(void *obj , int rc ) ;
   void (*on_disconnect)(void *obj ) ;
   void (*on_publish)(void *obj , uint16_t mid ) ;
   void (*on_message)(void *obj , struct mosquitto_message  const  *message ) ;
   void (*on_subscribe)(void *obj , uint16_t mid , int qos_count , uint8_t const   *granted_qos ) ;
   void (*on_unsubscribe)(void *obj , uint16_t mid ) ;
   char *host ;
   int port ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_24 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_24 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 33 "./read_handle.h"
struct _mosquitto_db;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 39 "./memory_mosq.h"
void *_mosquitto_calloc(size_t nmemb , size_t size ) ;
#line 40
void _mosquitto_free(void *mem ) ;
#line 41
void *_mosquitto_malloc(size_t size ) ;
#line 47
char *_mosquitto_strdup(char const   *s ) ;
#line 53 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/will_mosq.c"
int _mosquitto_will_set(struct mosquitto *mosq , _Bool will , char const   *topic___0 ,
                        uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                        _Bool retain___0 ) 
{ 
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 55
  rc = 0;
#line 57
  if (! mosq) {
#line 57
    return (3);
  } else
#line 57
  if (will) {
#line 57
    if (! topic___0) {
#line 57
      return (3);
    }
  }
#line 58
  if (payloadlen > 268435455U) {
#line 58
    return (9);
  }
#line 60
  if (mosq->will) {
#line 61
    if ((mosq->will)->topic) {
      {
#line 62
      _mosquitto_free((void *)(mosq->will)->topic);
#line 63
      (mosq->will)->topic = (char *)((void *)0);
      }
    }
#line 65
    if ((mosq->will)->payload) {
      {
#line 66
      _mosquitto_free((void *)(mosq->will)->payload);
#line 67
      (mosq->will)->payload = (uint8_t *)((void *)0);
      }
    }
    {
#line 69
    _mosquitto_free((void *)mosq->will);
#line 70
    mosq->will = (struct mosquitto_message *)((void *)0);
    }
  }
#line 73
  if (will) {
    {
#line 74
    tmp = _mosquitto_calloc((size_t )1, sizeof(struct mosquitto_message ));
#line 74
    mosq->will = (struct mosquitto_message *)tmp;
    }
#line 75
    if (! mosq->will) {
#line 75
      return (1);
    }
    {
#line 76
    (mosq->will)->topic = _mosquitto_strdup(topic___0);
    }
#line 77
    if (! (mosq->will)->topic) {
#line 78
      rc = 1;
#line 79
      goto cleanup;
    }
#line 81
    (mosq->will)->payloadlen = payloadlen;
#line 82
    if ((mosq->will)->payloadlen > 0U) {
#line 83
      if (! payload) {
#line 84
        rc = 3;
#line 85
        goto cleanup;
      }
      {
#line 87
      tmp___0 = _mosquitto_malloc(sizeof(uint8_t ) * (unsigned long )(mosq->will)->payloadlen);
#line 87
      (mosq->will)->payload = (uint8_t *)tmp___0;
      }
#line 88
      if (! (mosq->will)->payload) {
#line 89
        rc = 1;
#line 90
        goto cleanup;
      }
      {
#line 93
      memcpy((void */* __restrict  */)(mosq->will)->payload, (void const   */* __restrict  */)payload,
             (size_t )payloadlen);
      }
    }
#line 95
    (mosq->will)->qos = qos___0;
#line 96
    (mosq->will)->retain = retain___0;
  }
#line 99
  return (0);
  cleanup: 
#line 102
  if (mosq->will) {
#line 103
    if ((mosq->will)->topic) {
      {
#line 103
      _mosquitto_free((void *)(mosq->will)->topic);
      }
    }
#line 104
    if ((mosq->will)->payload) {
      {
#line 104
      _mosquitto_free((void *)(mosq->will)->payload);
      }
    }
  }
  {
#line 106
  _mosquitto_free((void *)mosq->will);
#line 107
  mosq->will = (struct mosquitto_message *)((void *)0);
  }
#line 109
  return (rc);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 67 "./net_mosq.h"
int _mosquitto_socket_close(struct mosquitto *mosq ) ;
#line 40 "./send_mosq.h"
int _mosquitto_send_pingreq(struct mosquitto *mosq ) ;
#line 34 "./util_mosq.h"
int _mosquitto_packet_alloc(struct _mosquitto_packet *packet ) ;
#line 35
void _mosquitto_check_keepalive(struct mosquitto *mosq ) ;
#line 36
int _mosquitto_fix_sub_topic(char **subtopic ) ;
#line 37
uint16_t _mosquitto_mid_generate(struct mosquitto *mosq ) ;
#line 38
int _mosquitto_topic_wildcard_len_check(char const   *str ) ;
#line 44 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c"
int _mosquitto_packet_alloc(struct _mosquitto_packet *packet ) 
{ 
  uint8_t remaining_bytes[5] ;
  uint8_t byte ;
  uint32_t remaining_length ;
  int i ;
  void *tmp ;

  {
#line 50
  if (! packet) {
    {
#line 50
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c",
                  50U, "_mosquitto_packet_alloc");
    }
  }
#line 52
  remaining_length = packet->remaining_length;
#line 53
  packet->payload = (uint8_t *)((void *)0);
#line 54
  packet->remaining_count = (uint8_t )0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    byte = (uint8_t )(remaining_length % 128U);
#line 57
    remaining_length /= 128U;
#line 59
    if (remaining_length > 0U) {
#line 60
      byte = (uint8_t )((int )byte | 128);
    }
#line 62
    remaining_bytes[packet->remaining_count] = byte;
#line 63
    packet->remaining_count = (uint8_t )((int )packet->remaining_count + 1);
#line 55
    if (remaining_length > 0U) {
#line 55
      if (! ((int )packet->remaining_count < 5)) {
#line 55
        goto while_break;
      }
    } else {
#line 55
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if ((int )packet->remaining_count == 5) {
#line 65
    return (9);
  }
  {
#line 66
  packet->packet_length = (packet->remaining_length + 1U) + (uint32_t )packet->remaining_count;
#line 67
  tmp = _mosquitto_malloc(sizeof(uint8_t ) * (unsigned long )packet->packet_length);
#line 67
  packet->payload = (uint8_t *)tmp;
  }
#line 68
  if (! packet->payload) {
#line 68
    return (1);
  }
#line 70
  *(packet->payload + 0) = packet->command;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! (i < (int )packet->remaining_count)) {
#line 71
      goto while_break___0;
    }
#line 72
    *(packet->payload + (i + 1)) = remaining_bytes[i];
#line 71
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 74
  packet->pos = (uint32_t )(1 + (int )packet->remaining_count);
#line 76
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c"
void _mosquitto_check_keepalive(struct mosquitto *mosq ) 
{ 
  time_t tmp ;

  {
#line 81
  if (! mosq) {
    {
#line 81
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c",
                  81U, "_mosquitto_check_keepalive");
    }
  }
#line 93
  if (mosq->sock != -1) {
    {
#line 93
    tmp = time((time_t *)((void *)0));
    }
#line 93
    if (tmp - mosq->last_msg_out >= (time_t )mosq->keepalive) {
#line 94
      if ((unsigned int )mosq->state == 1U) {
        {
#line 95
        _mosquitto_send_pingreq(mosq);
        }
      } else {
        {
#line 104
        _mosquitto_socket_close(mosq);
        }
      }
    }
  }
#line 107
  return;
}
}
#line 112 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c"
int _mosquitto_fix_sub_topic(char **subtopic ) 
{ 
  char *fixed ;
  char *token ;
  char *saveptr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 114
  fixed = (char *)((void *)0);
#line 116
  saveptr = (char *)((void *)0);
#line 118
  if (! subtopic) {
    {
#line 118
    __assert_fail("subtopic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c",
                  118U, "_mosquitto_fix_sub_topic");
    }
  }
#line 119
  if (! *subtopic) {
    {
#line 119
    __assert_fail("*subtopic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c",
                  119U, "_mosquitto_fix_sub_topic");
    }
  }
  {
#line 123
  tmp = strlen((char const   *)*subtopic);
#line 123
  tmp___0 = _mosquitto_calloc(tmp + 2UL, (size_t )1);
#line 123
  fixed = (char *)tmp___0;
  }
#line 124
  if (! fixed) {
#line 124
    return (1);
  }
#line 126
  if ((int )*(*subtopic + 0) == 47) {
#line 127
    *(fixed + 0) = (char )'/';
  }
  {
#line 129
  token = strtok_r((char */* __restrict  */)*subtopic, (char const   */* __restrict  */)"/",
                   (char **/* __restrict  */)(& saveptr));
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! token) {
#line 130
      goto while_break;
    }
    {
#line 131
    strcat((char */* __restrict  */)fixed, (char const   */* __restrict  */)token);
#line 132
    strcat((char */* __restrict  */)fixed, (char const   */* __restrict  */)"/");
#line 133
    token = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/",
                     (char **/* __restrict  */)(& saveptr));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp___1 = strlen((char const   *)fixed);
#line 136
  *(fixed + (tmp___1 - 1UL)) = (char )'\000';
#line 137
  _mosquitto_free((void *)*subtopic);
#line 138
  *subtopic = fixed;
  }
#line 139
  return (0);
}
}
#line 142 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c"
uint16_t _mosquitto_mid_generate(struct mosquitto *mosq ) 
{ 


  {
#line 144
  if (! mosq) {
    {
#line 144
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c",
                  144U, "_mosquitto_mid_generate");
    }
  }
#line 146
  mosq->last_mid = (uint16_t )((int )mosq->last_mid + 1);
#line 147
  if ((int )mosq->last_mid == 0) {
#line 147
    mosq->last_mid = (uint16_t )((int )mosq->last_mid + 1);
  }
#line 149
  return (mosq->last_mid);
}
}
#line 156 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/util_mosq.c"
int _mosquitto_topic_wildcard_len_check(char const   *str ) 
{ 
  int len ;

  {
#line 158
  len = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (str) {
#line 159
      if (! *(str + 0)) {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
#line 160
    if ((int const   )*(str + 0) == 43) {
#line 161
      return (3);
    } else
#line 160
    if ((int const   )*(str + 0) == 35) {
#line 161
      return (3);
    }
#line 163
    len ++;
#line 164
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if (len > 65535) {
#line 166
    return (3);
  }
#line 168
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 241 "./mosquitto.h"
int mosquitto_log_init(struct mosquitto *mosq , int priorities , int destinations ) ;
#line 38 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/logging_mosq.c"
int mosquitto_log_init(struct mosquitto *mosq , int priorities , int destinations ) 
{ 


  {
#line 40
  if (! mosq) {
    {
#line 40
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/logging_mosq.c",
                  40U, "mosquitto_log_init");
    }
  }
#line 42
  mosq->log_priorities = priorities;
#line 43
  mosq->log_destinations = destinations;
#line 45
  return (0);
}
}
#line 48 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/logging_mosq.c"
int _mosquitto_log_printf(struct mosquitto *mosq , int priority , char const   *fmt 
                          , ...) 
{ 
  va_list va ;
  char *s ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 54
  if (! mosq) {
    {
#line 54
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/logging_mosq.c",
                  54U, "_mosquitto_log_printf");
    }
  }
#line 55
  if (! fmt) {
    {
#line 55
    __assert_fail("fmt", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/logging_mosq.c",
                  55U, "_mosquitto_log_printf");
    }
  }
#line 57
  if (mosq->log_priorities & priority) {
#line 57
    if (mosq->log_destinations != 0) {
      {
#line 58
      tmp = strlen(fmt);
#line 58
      len = (int )(tmp + 500UL);
#line 59
      tmp___0 = _mosquitto_malloc((unsigned long )len * sizeof(char ));
#line 59
      s = (char *)tmp___0;
      }
#line 60
      if (! s) {
#line 60
        return (1);
      }
      {
#line 62
      __builtin_va_start(va, fmt);
#line 63
      vsnprintf((char */* __restrict  */)s, (size_t )len, (char const   */* __restrict  */)fmt,
                va);
#line 64
      __builtin_va_end(va);
#line 65
      *(s + (len - 1)) = (char )'\000';
      }
#line 67
      if (mosq->log_destinations & 4) {
        {
#line 68
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
                s);
#line 69
        fflush(stdout);
        }
      }
#line 71
      if (mosq->log_destinations & 8) {
        {
#line 72
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
                s);
#line 73
        fflush(stderr);
        }
      }
      {
#line 75
      _mosquitto_free((void *)s);
      }
    }
  }
#line 78
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 35 "./read_handle.h"
int _mosquitto_packet_handle(struct mosquitto *mosq ) ;
#line 61 "./net_mosq.h"
void _mosquitto_net_init(void) ;
#line 62
void _mosquitto_net_cleanup(void) ;
#line 64
void _mosquitto_packet_cleanup(struct _mosquitto_packet *packet ) ;
#line 65
int _mosquitto_packet_queue(struct mosquitto *mosq , struct _mosquitto_packet *packet ) ;
#line 66
int _mosquitto_socket_connect(struct mosquitto *mosq , char const   *host , uint16_t port ) ;
#line 69
int _mosquitto_read_byte(struct _mosquitto_packet *packet , uint8_t *byte ) ;
#line 70
int _mosquitto_read_bytes(struct _mosquitto_packet *packet , uint8_t *bytes , uint32_t count ) ;
#line 71
int _mosquitto_read_string(struct _mosquitto_packet *packet , char **str ) ;
#line 72
int _mosquitto_read_uint16(struct _mosquitto_packet *packet , uint16_t *word ) ;
#line 74
void _mosquitto_write_byte(struct _mosquitto_packet *packet , uint8_t byte ) ;
#line 75
void _mosquitto_write_bytes(struct _mosquitto_packet *packet , uint8_t const   *bytes ,
                            uint32_t count ) ;
#line 76
void _mosquitto_write_string(struct _mosquitto_packet *packet , char const   *str ,
                             uint16_t length ) ;
#line 77
void _mosquitto_write_uint16(struct _mosquitto_packet *packet , uint16_t word ) ;
#line 79
ssize_t _mosquitto_net_read(struct mosquitto *mosq , void *buf , size_t count ) ;
#line 80
ssize_t _mosquitto_net_write(struct mosquitto *mosq , void *buf , size_t count ) ;
#line 82
int _mosquitto_packet_write(struct mosquitto *mosq ) ;
#line 86
int _mosquitto_packet_read(struct mosquitto *mosq ) ;
#line 77 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_net_init(void) 
{ 


  {
#line 88
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_net_cleanup(void) 
{ 


  {
#line 95
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_packet_cleanup(struct _mosquitto_packet *packet ) 
{ 


  {
#line 99
  if (! packet) {
#line 99
    return;
  }
#line 102
  packet->command = (uint8_t )0;
#line 103
  packet->have_remaining = (uint8_t )0;
#line 104
  packet->remaining_count = (uint8_t )0;
#line 105
  packet->remaining_mult = (uint32_t )1;
#line 106
  packet->remaining_length = (uint32_t )0;
#line 107
  if (packet->payload) {
    {
#line 107
    _mosquitto_free((void *)packet->payload);
    }
  }
#line 108
  packet->payload = (uint8_t *)((void *)0);
#line 109
  packet->to_process = (uint32_t )0;
#line 110
  packet->pos = (uint32_t )0;
#line 111
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_packet_queue(struct mosquitto *mosq , struct _mosquitto_packet *packet ) 
{ 
  struct _mosquitto_packet *tail ;
  int tmp ;

  {
#line 117
  if (! mosq) {
    {
#line 117
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  117U, "_mosquitto_packet_queue");
    }
  }
#line 118
  if (! packet) {
    {
#line 118
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  118U, "_mosquitto_packet_queue");
    }
  }
#line 120
  packet->pos = (uint32_t )0;
#line 121
  packet->to_process = packet->packet_length;
#line 123
  packet->next = (struct _mosquitto_packet *)((void *)0);
#line 124
  if (mosq->out_packet) {
#line 125
    tail = mosq->out_packet;
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! tail->next) {
#line 126
        goto while_break;
      }
#line 127
      tail = tail->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 129
    tail->next = packet;
  } else {
#line 131
    mosq->out_packet = packet;
  }
#line 136
  if ((int )mosq->in_callback == 0) {
    {
#line 137
    tmp = _mosquitto_packet_write(mosq);
    }
#line 137
    return (tmp);
  } else {
#line 139
    return (0);
  }
}
}
#line 148 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_socket_close(struct mosquitto *mosq ) 
{ 
  int rc ;

  {
#line 150
  rc = 0;
#line 152
  if (! mosq) {
    {
#line 152
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  152U, "_mosquitto_socket_close");
    }
  }
#line 154
  if (mosq->sock != -1) {
    {
#line 155
    rc = close(mosq->sock);
#line 156
    mosq->sock = -1;
    }
  }
#line 159
  return (rc);
}
}
#line 166 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_socket_connect(struct mosquitto *mosq , char const   *host , uint16_t port ) 
{ 
  int sock ;
  int opt ;
  struct addrinfo hints ;
  struct addrinfo *ainfo ;
  struct addrinfo *rp ;
  int s ;
  int tmp ;
  int tmp___0 ;

  {
#line 168
  sock = -1;
#line 180
  if (! mosq) {
#line 180
    return (3);
  } else
#line 180
  if (! host) {
#line 180
    return (3);
  } else
#line 180
  if (! port) {
#line 180
    return (3);
  }
  {
#line 182
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 183
  hints.ai_family = 0;
#line 184
  hints.ai_flags = 32;
#line 185
  hints.ai_socktype = 1;
#line 187
  s = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)((void *)0),
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& ainfo));
  }
#line 188
  if (s) {
#line 188
    return (13);
  }
#line 190
  rp = ainfo;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 190
      goto while_break;
    }
    {
#line 191
    sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    }
#line 192
    if (sock == -1) {
#line 192
      goto __Cont;
    }
#line 194
    if (rp->ai_family == 2) {
      {
#line 195
      ((struct sockaddr_in *)rp->ai_addr)->sin_port = htons(port);
      }
    } else
#line 196
    if (rp->ai_family == 10) {
      {
#line 197
      ((struct sockaddr_in6 *)rp->ai_addr)->sin6_port = htons(port);
      }
    } else {
#line 199
      goto __Cont;
    }
    {
#line 201
    tmp = connect(sock, (struct sockaddr  const  *)rp->ai_addr, rp->ai_addrlen);
    }
#line 201
    if (tmp != -1) {
#line 202
      goto while_break;
    }
    {
#line 208
    close(sock);
    }
    __Cont: /* CIL Label */ 
#line 190
    rp = rp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (! rp) {
#line 211
    return (14);
  }
  {
#line 213
  freeaddrinfo(ainfo);
#line 234
  opt = fcntl(sock, 3, 0);
  }
#line 235
  if (opt == -1) {
    {
#line 242
    close(sock);
    }
#line 243
    return (14);
  } else {
    {
#line 235
    tmp___0 = fcntl(sock, 4, opt | 2048);
    }
#line 235
    if (tmp___0 == -1) {
      {
#line 242
      close(sock);
      }
#line 243
      return (14);
    }
  }
#line 259
  mosq->sock = sock;
#line 261
  return (0);
}
}
#line 264 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_read_byte(struct _mosquitto_packet *packet , uint8_t *byte ) 
{ 


  {
#line 266
  if (! packet) {
    {
#line 266
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  266U, "_mosquitto_read_byte");
    }
  }
#line 267
  if (packet->pos + 1U > packet->remaining_length) {
#line 267
    return (2);
  }
#line 269
  *byte = *(packet->payload + packet->pos);
#line 270
  (packet->pos) ++;
#line 272
  return (0);
}
}
#line 275 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_write_byte(struct _mosquitto_packet *packet , uint8_t byte ) 
{ 


  {
#line 277
  if (! packet) {
    {
#line 277
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  277U, "_mosquitto_write_byte");
    }
  }
#line 278
  if (! (packet->pos + 1U <= packet->packet_length)) {
    {
#line 278
    __assert_fail("packet->pos+1 <= packet->packet_length", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  278U, "_mosquitto_write_byte");
    }
  }
#line 280
  *(packet->payload + packet->pos) = byte;
#line 281
  (packet->pos) ++;
#line 282
  return;
}
}
#line 284 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_read_bytes(struct _mosquitto_packet *packet , uint8_t *bytes , uint32_t count ) 
{ 


  {
#line 286
  if (! packet) {
    {
#line 286
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  286U, "_mosquitto_read_bytes");
    }
  }
#line 287
  if (packet->pos + count > packet->remaining_length) {
#line 287
    return (2);
  }
  {
#line 289
  memcpy((void */* __restrict  */)bytes, (void const   */* __restrict  */)(packet->payload + packet->pos),
         (size_t )count);
#line 290
  packet->pos += count;
  }
#line 292
  return (0);
}
}
#line 295 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_write_bytes(struct _mosquitto_packet *packet , uint8_t const   *bytes ,
                            uint32_t count ) 
{ 


  {
#line 297
  if (! packet) {
    {
#line 297
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  297U, "_mosquitto_write_bytes");
    }
  }
#line 298
  if (! (packet->pos + count <= packet->packet_length)) {
    {
#line 298
    __assert_fail("packet->pos+count <= packet->packet_length", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  298U, "_mosquitto_write_bytes");
    }
  }
  {
#line 300
  memcpy((void */* __restrict  */)(packet->payload + packet->pos), (void const   */* __restrict  */)bytes,
         (size_t )count);
#line 301
  packet->pos += count;
  }
#line 302
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_read_string(struct _mosquitto_packet *packet , char **str ) 
{ 
  uint16_t len ;
  int rc ;
  void *tmp ;

  {
#line 309
  if (! packet) {
    {
#line 309
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  309U, "_mosquitto_read_string");
    }
  }
  {
#line 310
  rc = _mosquitto_read_uint16(packet, & len);
  }
#line 311
  if (rc) {
#line 311
    return (rc);
  }
#line 313
  if (packet->pos + (uint32_t )len > packet->remaining_length) {
#line 313
    return (2);
  }
  {
#line 315
  tmp = _mosquitto_calloc((size_t )((int )len + 1), sizeof(char ));
#line 315
  *str = (char *)tmp;
  }
#line 316
  if (*str) {
    {
#line 317
    memcpy((void */* __restrict  */)*str, (void const   */* __restrict  */)(packet->payload + packet->pos),
           (size_t )len);
#line 318
    packet->pos += (uint32_t )len;
    }
  } else {
#line 320
    return (1);
  }
#line 323
  return (0);
}
}
#line 326 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_write_string(struct _mosquitto_packet *packet , char const   *str ,
                             uint16_t length ) 
{ 


  {
#line 328
  if (! packet) {
    {
#line 328
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  328U, "_mosquitto_write_string");
    }
  }
  {
#line 329
  _mosquitto_write_uint16(packet, length);
#line 330
  _mosquitto_write_bytes(packet, (uint8_t const   *)((uint8_t *)str), (uint32_t )length);
  }
#line 331
  return;
}
}
#line 333 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_read_uint16(struct _mosquitto_packet *packet , uint16_t *word ) 
{ 
  uint8_t msb ;
  uint8_t lsb ;

  {
#line 337
  if (! packet) {
    {
#line 337
    __assert_fail("packet", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  337U, "_mosquitto_read_uint16");
    }
  }
#line 338
  if (packet->pos + 2U > packet->remaining_length) {
#line 338
    return (2);
  }
#line 340
  msb = *(packet->payload + packet->pos);
#line 341
  (packet->pos) ++;
#line 342
  lsb = *(packet->payload + packet->pos);
#line 343
  (packet->pos) ++;
#line 345
  *word = (uint16_t )(((int )msb << 8) + (int )lsb);
#line 347
  return (0);
}
}
#line 350 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
void _mosquitto_write_uint16(struct _mosquitto_packet *packet , uint16_t word ) 
{ 


  {
  {
#line 352
  _mosquitto_write_byte(packet, (uint8_t )(((int )word & 65280) >> 8));
#line 353
  _mosquitto_write_byte(packet, (uint8_t )((int )word & 255));
  }
#line 354
  return;
}
}
#line 356 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
ssize_t _mosquitto_net_read(struct mosquitto *mosq , void *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
#line 362
  if (! mosq) {
    {
#line 362
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  362U, "_mosquitto_net_read");
    }
  }
  {
#line 385
  tmp = read(mosq->sock, buf, count);
  }
#line 385
  return (tmp);
}
}
#line 395 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
ssize_t _mosquitto_net_write(struct mosquitto *mosq , void *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
#line 401
  if (! mosq) {
    {
#line 401
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c",
                  401U, "_mosquitto_net_write");
    }
  }
  {
#line 422
  tmp = write(mosq->sock, (void const   *)buf, count);
  }
#line 422
  return (tmp);
}
}
#line 432 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_packet_write(struct mosquitto *mosq ) 
{ 
  ssize_t write_length ;
  struct _mosquitto_packet *packet ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 437
  if (! mosq) {
#line 437
    return (3);
  }
#line 438
  if (mosq->sock == -1) {
#line 438
    return (4);
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! mosq->out_packet) {
#line 440
      goto while_break;
    }
#line 441
    packet = mosq->out_packet;
    {
#line 443
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 443
      if (! (packet->to_process > 0U)) {
#line 443
        goto while_break___0;
      }
      {
#line 444
      write_length = _mosquitto_net_write(mosq, (void *)(packet->payload + packet->pos),
                                          (size_t )packet->to_process);
      }
#line 445
      if (write_length > 0L) {
#line 449
        packet->to_process = (uint32_t )((ssize_t )packet->to_process - write_length);
#line 450
        packet->pos = (uint32_t )((ssize_t )packet->pos + write_length);
      } else {
        {
#line 455
        tmp___0 = __errno_location();
        }
#line 455
        if (*tmp___0 == 11) {
#line 456
          return (0);
        } else {
          {
#line 455
          tmp___1 = __errno_location();
          }
#line 455
          if (*tmp___1 == 11) {
#line 456
            return (0);
          } else {
            {
#line 458
            tmp = __errno_location();
            }
            {
#line 459
            if (*tmp == 104) {
#line 459
              goto case_104;
            }
#line 461
            goto switch_default;
            case_104: /* CIL Label */ 
#line 460
            return (7);
            switch_default: /* CIL Label */ 
#line 462
            return (14);
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 471
    if (((int )packet->command & 246) == 48) {
#line 471
      if (mosq->on_publish) {
        {
#line 473
        mosq->in_callback = (_Bool)1;
#line 474
        (*(mosq->on_publish))(mosq->obj, packet->mid);
#line 475
        mosq->in_callback = (_Bool)0;
        }
      }
    }
    {
#line 480
    mosq->out_packet = packet->next;
#line 481
    _mosquitto_packet_cleanup(packet);
#line 482
    _mosquitto_free((void *)packet);
#line 484
    mosq->last_msg_out = time((time_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return (0);
}
}
#line 492 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/net_mosq.c"
int _mosquitto_packet_read(struct mosquitto *mosq ) 
{ 
  uint8_t byte ;
  ssize_t read_length ;
  int rc ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 497
  rc = 0;
#line 505
  if (! mosq) {
#line 505
    return (3);
  }
#line 506
  if (mosq->sock == -1) {
#line 506
    return (4);
  }
#line 521
  if (! mosq->in_packet.command) {
    {
#line 522
    read_length = _mosquitto_net_read(mosq, (void *)(& byte), (size_t )1);
    }
#line 523
    if (read_length == 1L) {
#line 524
      mosq->in_packet.command = byte;
    } else {
#line 531
      if (read_length == 0L) {
#line 531
        return (7);
      }
      {
#line 535
      tmp___0 = __errno_location();
      }
#line 535
      if (*tmp___0 == 11) {
#line 536
        return (0);
      } else {
        {
#line 535
        tmp___1 = __errno_location();
        }
#line 535
        if (*tmp___1 == 11) {
#line 536
          return (0);
        } else {
          {
#line 538
          tmp = __errno_location();
          }
          {
#line 539
          if (*tmp == 104) {
#line 539
            goto case_104;
          }
#line 541
          goto switch_default;
          case_104: /* CIL Label */ 
#line 540
          return (7);
          switch_default: /* CIL Label */ 
#line 542
          return (14);
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 547
  if (! mosq->in_packet.have_remaining) {
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 553
      read_length = _mosquitto_net_read(mosq, (void *)(& byte), (size_t )1);
      }
#line 554
      if (read_length == 1L) {
#line 555
        mosq->in_packet.remaining_count = (uint8_t )((int )mosq->in_packet.remaining_count + 1);
#line 559
        if ((int )mosq->in_packet.remaining_count > 4) {
#line 559
          return (2);
        }
#line 564
        mosq->in_packet.remaining_length += (uint32_t )((int )byte & 127) * mosq->in_packet.remaining_mult;
#line 565
        mosq->in_packet.remaining_mult *= 128U;
      } else {
#line 567
        if (read_length == 0L) {
#line 567
          return (7);
        }
        {
#line 571
        tmp___3 = __errno_location();
        }
#line 571
        if (*tmp___3 == 11) {
#line 572
          return (0);
        } else {
          {
#line 571
          tmp___4 = __errno_location();
          }
#line 571
          if (*tmp___4 == 11) {
#line 572
            return (0);
          } else {
            {
#line 574
            tmp___2 = __errno_location();
            }
            {
#line 575
            if (*tmp___2 == 104) {
#line 575
              goto case_104___0;
            }
#line 577
            goto switch_default___0;
            case_104___0: /* CIL Label */ 
#line 576
            return (7);
            switch_default___0: /* CIL Label */ 
#line 578
            return (14);
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
      }
#line 552
      if (! (((int )byte & 128) != 0)) {
#line 552
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 584
    if (mosq->in_packet.remaining_length > 0U) {
      {
#line 585
      tmp___5 = _mosquitto_malloc((unsigned long )mosq->in_packet.remaining_length * sizeof(uint8_t ));
#line 585
      mosq->in_packet.payload = (uint8_t *)tmp___5;
      }
#line 586
      if (! mosq->in_packet.payload) {
#line 586
        return (1);
      }
#line 587
      mosq->in_packet.to_process = mosq->in_packet.remaining_length;
    }
#line 589
    mosq->in_packet.have_remaining = (uint8_t )1;
  }
  {
#line 591
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 591
    if (! (mosq->in_packet.to_process > 0U)) {
#line 591
      goto while_break___0;
    }
    {
#line 592
    read_length = _mosquitto_net_read(mosq, (void *)(mosq->in_packet.payload + mosq->in_packet.pos),
                                      (size_t )mosq->in_packet.to_process);
    }
#line 593
    if (read_length > 0L) {
#line 597
      mosq->in_packet.to_process = (uint32_t )((ssize_t )mosq->in_packet.to_process - read_length);
#line 598
      mosq->in_packet.pos = (uint32_t )((ssize_t )mosq->in_packet.pos + read_length);
    } else {
      {
#line 603
      tmp___7 = __errno_location();
      }
#line 603
      if (*tmp___7 == 11) {
#line 604
        return (0);
      } else {
        {
#line 603
        tmp___8 = __errno_location();
        }
#line 603
        if (*tmp___8 == 11) {
#line 604
          return (0);
        } else {
          {
#line 606
          tmp___6 = __errno_location();
          }
          {
#line 607
          if (*tmp___6 == 104) {
#line 607
            goto case_104___1;
          }
#line 609
          goto switch_default___1;
          case_104___1: /* CIL Label */ 
#line 608
          return (7);
          switch_default___1: /* CIL Label */ 
#line 610
          return (14);
          switch_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 617
  mosq->in_packet.pos = (uint32_t )0;
#line 622
  rc = _mosquitto_packet_handle(mosq);
#line 626
  _mosquitto_packet_cleanup(& mosq->in_packet);
#line 628
  mosq->last_msg_in = time((time_t *)((void *)0));
  }
#line 629
  return (rc);
}
}
#line 36 "./messages_mosq.h"
void _mosquitto_message_cleanup(struct mosquitto_message_all **message___0 ) ;
#line 37
int _mosquitto_message_delete(struct mosquitto *mosq , uint16_t mid , enum mosquitto_msg_direction dir ) ;
#line 39
int _mosquitto_message_remove(struct mosquitto *mosq , uint16_t mid , enum mosquitto_msg_direction dir ,
                              struct mosquitto_message_all **message___0 ) ;
#line 41
int _mosquitto_message_update(struct mosquitto *mosq , uint16_t mid , enum mosquitto_msg_direction dir ,
                              enum mosquitto_msg_state state ) ;
#line 37 "./read_handle.h"
int _mosquitto_handle_pingreq(struct mosquitto *mosq ) ;
#line 38
int _mosquitto_handle_pingresp(struct mosquitto *mosq ) ;
#line 39
int _mosquitto_handle_pubackcomp(struct mosquitto *mosq , char const   *type ) ;
#line 41
int _mosquitto_handle_pubrec(struct mosquitto *mosq ) ;
#line 42
int _mosquitto_handle_pubrel(struct _mosquitto_db *db , struct mosquitto *mosq ) ;
#line 43
int _mosquitto_handle_suback(struct mosquitto *mosq ) ;
#line 44
int _mosquitto_handle_unsuback(struct mosquitto *mosq ) ;
#line 41 "./send_mosq.h"
int _mosquitto_send_pingresp(struct mosquitto *mosq ) ;
#line 43
int _mosquitto_send_pubcomp(struct mosquitto *mosq , uint16_t mid ) ;
#line 46
int _mosquitto_send_pubrel(struct mosquitto *mosq , uint16_t mid , _Bool dup___0 ) ;
#line 47 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_pingreq(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
#line 49
  if (! mosq) {
    {
#line 49
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  49U, "_mosquitto_handle_pingreq");
    }
  }
  {
#line 58
  _mosquitto_log_printf(mosq, 16, "Received PINGREQ");
#line 60
  tmp = _mosquitto_send_pingresp(mosq);
  }
#line 60
  return (tmp);
}
}
#line 63 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_pingresp(struct mosquitto *mosq ) 
{ 


  {
#line 65
  if (! mosq) {
    {
#line 65
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  65U, "_mosquitto_handle_pingresp");
    }
  }
  {
#line 74
  _mosquitto_log_printf(mosq, 16, "Received PINGRESP");
  }
#line 76
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_pubackcomp(struct mosquitto *mosq , char const   *type ) 
{ 
  uint16_t mid ;
  int rc ;
  int tmp ;

  {
#line 84
  if (! mosq) {
    {
#line 84
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  84U, "_mosquitto_handle_pubackcomp");
    }
  }
  {
#line 90
  rc = _mosquitto_read_uint16(& mosq->in_packet, & mid);
  }
#line 91
  if (rc) {
#line 91
    return (rc);
  }
  {
#line 100
  _mosquitto_log_printf(mosq, 16, "Received %s (Mid: %d)", type, (int )mid);
#line 102
  tmp = _mosquitto_message_delete(mosq, mid, (enum mosquitto_msg_direction )1);
  }
#line 102
  if (! tmp) {
#line 104
    if (mosq->on_publish) {
      {
#line 105
      mosq->in_callback = (_Bool)1;
#line 106
      (*(mosq->on_publish))(mosq->obj, mid);
#line 107
      mosq->in_callback = (_Bool)0;
      }
    }
  }
#line 112
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_pubrec(struct mosquitto *mosq ) 
{ 
  uint16_t mid ;
  int rc ;

  {
#line 120
  if (! mosq) {
    {
#line 120
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  120U, "_mosquitto_handle_pubrec");
    }
  }
  {
#line 126
  rc = _mosquitto_read_uint16(& mosq->in_packet, & mid);
  }
#line 127
  if (rc) {
#line 127
    return (rc);
  }
  {
#line 133
  _mosquitto_log_printf(mosq, 16, "Received PUBREC (Mid: %d)", (int )mid);
#line 135
  rc = _mosquitto_message_update(mosq, mid, (enum mosquitto_msg_direction )1, (enum mosquitto_msg_state )4);
  }
#line 137
  if (rc) {
#line 137
    return (rc);
  }
  {
#line 138
  rc = _mosquitto_send_pubrel(mosq, mid, (_Bool)0);
  }
#line 139
  if (rc) {
#line 139
    return (rc);
  }
#line 141
  return (0);
}
}
#line 144 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_pubrel(struct _mosquitto_db *db , struct mosquitto *mosq ) 
{ 
  uint16_t mid ;
  struct mosquitto_message_all *message___0 ;
  int rc ;
  int tmp ;

  {
#line 148
  message___0 = (struct mosquitto_message_all *)((void *)0);
#line 152
  if (! mosq) {
    {
#line 152
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  152U, "_mosquitto_handle_pubrel");
    }
  }
  {
#line 158
  rc = _mosquitto_read_uint16(& mosq->in_packet, & mid);
  }
#line 159
  if (rc) {
#line 159
    return (rc);
  }
  {
#line 165
  _mosquitto_log_printf(mosq, 16, "Received PUBREL (Mid: %d)", (int )mid);
#line 167
  tmp = _mosquitto_message_remove(mosq, mid, (enum mosquitto_msg_direction )0, & message___0);
  }
#line 167
  if (! tmp) {
#line 170
    if (mosq->on_message) {
      {
#line 171
      mosq->in_callback = (_Bool)1;
#line 172
      (*(mosq->on_message))(mosq->obj, (struct mosquitto_message  const  *)(& message___0->msg));
#line 173
      mosq->in_callback = (_Bool)0;
      }
    } else {
      {
#line 175
      _mosquitto_message_cleanup(& message___0);
      }
    }
  }
  {
#line 179
  rc = _mosquitto_send_pubcomp(mosq, mid);
  }
#line 180
  if (rc) {
#line 180
    return (rc);
  }
#line 182
  return (0);
}
}
#line 185 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_suback(struct mosquitto *mosq ) 
{ 
  uint16_t mid ;
  uint8_t *granted_qos ;
  int qos_count ;
  int i ;
  int rc ;
  void *tmp ;

  {
#line 190
  i = 0;
#line 193
  if (! mosq) {
    {
#line 193
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  193U, "_mosquitto_handle_suback");
    }
  }
  {
#line 197
  _mosquitto_log_printf(mosq, 16, "Received SUBACK");
#line 199
  rc = _mosquitto_read_uint16(& mosq->in_packet, & mid);
  }
#line 200
  if (rc) {
#line 200
    return (rc);
  }
  {
#line 202
  qos_count = (int )(mosq->in_packet.remaining_length - mosq->in_packet.pos);
#line 203
  tmp = _mosquitto_malloc((unsigned long )qos_count * sizeof(uint8_t ));
#line 203
  granted_qos = (uint8_t *)tmp;
  }
#line 204
  if (! granted_qos) {
#line 204
    return (1);
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (mosq->in_packet.pos < mosq->in_packet.remaining_length)) {
#line 205
      goto while_break;
    }
    {
#line 206
    rc = _mosquitto_read_byte(& mosq->in_packet, granted_qos + i);
    }
#line 207
    if (rc) {
      {
#line 208
      _mosquitto_free((void *)granted_qos);
      }
#line 209
      return (rc);
    }
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if (mosq->on_subscribe) {
    {
#line 215
    mosq->in_callback = (_Bool)1;
#line 216
    (*(mosq->on_subscribe))(mosq->obj, mid, qos_count, (uint8_t const   *)granted_qos);
#line 217
    mosq->in_callback = (_Bool)0;
    }
  }
  {
#line 220
  _mosquitto_free((void *)granted_qos);
  }
#line 222
  return (0);
}
}
#line 225 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c"
int _mosquitto_handle_unsuback(struct mosquitto *mosq ) 
{ 
  uint16_t mid ;
  int rc ;

  {
#line 230
  if (! mosq) {
    {
#line 230
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_shared.c",
                  230U, "_mosquitto_handle_unsuback");
    }
  }
  {
#line 239
  _mosquitto_log_printf(mosq, 16, "Received UNSUBACK");
#line 241
  rc = _mosquitto_read_uint16(& mosq->in_packet, & mid);
  }
#line 242
  if (rc) {
#line 242
    return (rc);
  }
#line 244
  if (mosq->on_unsubscribe) {
    {
#line 245
    mosq->in_callback = (_Bool)1;
#line 246
    (*(mosq->on_unsubscribe))(mosq->obj, mid);
#line 247
    mosq->in_callback = (_Bool)0;
    }
  }
#line 251
  return (0);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 151 "./mosquitto.h"
void mosquitto_lib_version(int *major , int *minor , int *revision ) ;
#line 164
int mosquitto_lib_init(void) ;
#line 177
int mosquitto_lib_cleanup(void) ;
#line 196
struct mosquitto *mosquitto_new(char const   *id , void *obj ) ;
#line 209
void mosquitto_destroy(struct mosquitto *mosq ) ;
#line 268
int mosquitto_will_set(struct mosquitto *mosq , _Bool will , char const   *topic___0 ,
                       uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                       _Bool retain___0 ) ;
#line 293
int mosquitto_username_pw_set(struct mosquitto *mosq , char const   *username___1 ,
                              char const   *password___1 ) ;
#line 322
int mosquitto_connect(struct mosquitto *mosq , char const   *host , int port , int keepalive ,
                      _Bool clean_session ) ;
#line 345
int mosquitto_reconnect(struct mosquitto *mosq ) ;
#line 360
int mosquitto_disconnect(struct mosquitto *mosq ) ;
#line 395
int mosquitto_publish(struct mosquitto *mosq , uint16_t *mid , char const   *topic___0 ,
                      uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                      _Bool retain___0 ) ;
#line 417
int mosquitto_subscribe(struct mosquitto *mosq , uint16_t *mid , char const   *sub ,
                        int qos___0 ) ;
#line 438
int mosquitto_unsubscribe(struct mosquitto *mosq , uint16_t *mid , char const   *sub ) ;
#line 503
int mosquitto_loop(struct mosquitto *mosq , int timeout ) ;
#line 517
int mosquitto_socket(struct mosquitto *mosq ) ;
#line 545
int mosquitto_loop_read(struct mosquitto *mosq ) ;
#line 573
int mosquitto_loop_write(struct mosquitto *mosq ) ;
#line 595
int mosquitto_loop_misc(struct mosquitto *mosq ) ;
#line 618
void mosquitto_connect_callback_set(struct mosquitto *mosq , void (*on_connect)(void * ,
                                                                                int  ) ) ;
#line 634
void mosquitto_disconnect_callback_set(struct mosquitto *mosq , void (*on_disconnect)(void * ) ) ;
#line 651
void mosquitto_publish_callback_set(struct mosquitto *mosq , void (*on_publish)(void * ,
                                                                                uint16_t  ) ) ;
#line 673
void mosquitto_message_callback_set(struct mosquitto *mosq , void (*on_message)(void * ,
                                                                                struct mosquitto_message  const  * ) ) ;
#line 693
void mosquitto_subscribe_callback_set(struct mosquitto *mosq , void (*on_subscribe)(void * ,
                                                                                    uint16_t  ,
                                                                                    int  ,
                                                                                    uint8_t const   * ) ) ;
#line 710
void mosquitto_unsubscribe_callback_set(struct mosquitto *mosq , void (*on_unsubscribe)(void * ,
                                                                                        uint16_t  ) ) ;
#line 35 "./messages_mosq.h"
void _mosquitto_message_cleanup_all(struct mosquitto *mosq ) ;
#line 38
void _mosquitto_message_queue(struct mosquitto *mosq , struct mosquitto_message_all *message___0 ) ;
#line 40
void _mosquitto_message_retry_check(struct mosquitto *mosq ) ;
#line 38 "./send_mosq.h"
int _mosquitto_send_connect(struct mosquitto *mosq , uint16_t keepalive , _Bool clean_session ) ;
#line 39
int _mosquitto_send_disconnect(struct mosquitto *mosq ) ;
#line 44
int _mosquitto_send_publish(struct mosquitto *mosq , uint16_t mid , char const   *topic___0 ,
                            uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                            _Bool retain___0 , _Bool dup___0 ) ;
#line 47
int _mosquitto_send_subscribe(struct mosquitto *mosq , uint16_t *mid , _Bool dup___0 ,
                              char const   *topic___0 , uint8_t topic_qos___0 ) ;
#line 48
int _mosquitto_send_unsubscribe(struct mosquitto *mosq , uint16_t *mid , _Bool dup___0 ,
                                char const   *topic___0 ) ;
#line 62 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_lib_version(int *major , int *minor , int *revision ) 
{ 


  {
#line 64
  if (major) {
#line 64
    *major = 0;
  }
#line 65
  if (minor) {
#line 65
    *minor = 15;
  }
#line 66
  if (revision) {
#line 66
    *revision = 0;
  }
#line 67
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_lib_init(void) 
{ 


  {
  {
#line 71
  _mosquitto_net_init();
  }
#line 73
  return (0);
}
}
#line 76 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_lib_cleanup(void) 
{ 


  {
  {
#line 78
  _mosquitto_net_cleanup();
  }
#line 80
  return (0);
}
}
#line 83 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
struct mosquitto *mosquitto_new(char const   *id , void *obj ) 
{ 
  struct mosquitto *mosq ;
  void *tmp ;

  {
#line 85
  mosq = (struct mosquitto *)((void *)0);
#line 87
  if (! id) {
#line 87
    return ((struct mosquitto *)((void *)0));
  }
  {
#line 89
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct mosquitto ));
#line 89
  mosq = (struct mosquitto *)tmp;
  }
#line 90
  if (mosq) {
#line 91
    if (obj) {
#line 92
      mosq->obj = obj;
    } else {
#line 94
      mosq->obj = (void *)mosq;
    }
    {
#line 96
    mosq->sock = -1;
#line 97
    mosq->keepalive = (uint16_t )60;
#line 98
    mosq->message_retry = 20U;
#line 99
    mosq->last_retry_check = (time_t )0;
#line 100
    mosq->id = _mosquitto_strdup(id);
#line 101
    mosq->username = (char *)((void *)0);
#line 102
    mosq->password = (char *)((void *)0);
#line 103
    mosq->in_packet.payload = (uint8_t *)((void *)0);
#line 104
    _mosquitto_packet_cleanup(& mosq->in_packet);
#line 105
    mosq->out_packet = (struct _mosquitto_packet *)((void *)0);
#line 106
    mosq->last_msg_in = time((time_t *)((void *)0));
#line 107
    mosq->last_msg_out = time((time_t *)((void *)0));
#line 108
    mosq->last_mid = (uint16_t )0;
#line 109
    mosq->state = (enum mosquitto_client_state )0;
#line 110
    mosq->messages = (struct mosquitto_message_all *)((void *)0);
#line 111
    mosq->will = (struct mosquitto_message *)((void *)0);
#line 112
    mosq->on_connect = (void (*)(void *obj , int rc ))((void *)0);
#line 113
    mosq->on_publish = (void (*)(void *obj , uint16_t mid ))((void *)0);
#line 114
    mosq->on_message = (void (*)(void *obj , struct mosquitto_message  const  *message ))((void *)0);
#line 115
    mosq->on_subscribe = (void (*)(void *obj , uint16_t mid , int qos_count , uint8_t const   *granted_qos ))((void *)0);
#line 116
    mosq->on_unsubscribe = (void (*)(void *obj , uint16_t mid ))((void *)0);
#line 117
    mosq->log_destinations = 0;
#line 118
    mosq->log_priorities = 15;
#line 119
    mosq->host = (char *)((void *)0);
#line 120
    mosq->port = 1883;
#line 121
    mosq->in_callback = (_Bool)0;
    }
  }
#line 126
  return (mosq);
}
}
#line 129 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_will_set(struct mosquitto *mosq , _Bool will , char const   *topic___0 ,
                       uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                       _Bool retain___0 ) 
{ 
  int tmp ;

  {
#line 131
  if (! mosq) {
#line 131
    return (3);
  }
  {
#line 132
  tmp = _mosquitto_will_set(mosq, will, topic___0, payloadlen, payload, qos___0, retain___0);
  }
#line 132
  return (tmp);
}
}
#line 135 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_username_pw_set(struct mosquitto *mosq , char const   *username___1 ,
                              char const   *password___1 ) 
{ 


  {
#line 137
  if (! mosq) {
#line 137
    return (3);
  }
#line 139
  if (username___1) {
    {
#line 140
    mosq->username = _mosquitto_strdup(username___1);
    }
#line 141
    if (! mosq->username) {
#line 141
      return (1);
    }
#line 142
    if (mosq->password) {
      {
#line 143
      _mosquitto_free((void *)mosq->password);
#line 144
      mosq->password = (char *)((void *)0);
      }
    }
#line 146
    if (password___1) {
      {
#line 147
      mosq->password = _mosquitto_strdup(password___1);
      }
#line 148
      if (! mosq->password) {
        {
#line 149
        _mosquitto_free((void *)mosq->username);
#line 150
        mosq->username = (char *)((void *)0);
        }
#line 151
        return (1);
      }
    }
  } else {
#line 155
    if (mosq->username) {
      {
#line 156
      _mosquitto_free((void *)mosq->username);
#line 157
      mosq->username = (char *)((void *)0);
      }
    }
#line 159
    if (mosq->password) {
      {
#line 160
      _mosquitto_free((void *)mosq->password);
#line 161
      mosq->password = (char *)((void *)0);
      }
    }
  }
#line 164
  return (0);
}
}
#line 168 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_destroy(struct mosquitto *mosq ) 
{ 


  {
#line 170
  if (mosq->id) {
    {
#line 170
    _mosquitto_free((void *)mosq->id);
    }
  }
  {
#line 171
  _mosquitto_message_cleanup_all(mosq);
  }
#line 172
  if (mosq->will) {
#line 173
    if ((mosq->will)->topic) {
      {
#line 173
      _mosquitto_free((void *)(mosq->will)->topic);
      }
    }
#line 174
    if ((mosq->will)->payload) {
      {
#line 174
      _mosquitto_free((void *)(mosq->will)->payload);
      }
    }
    {
#line 175
    _mosquitto_free((void *)mosq->will);
    }
  }
#line 177
  if (mosq->host) {
    {
#line 178
    _mosquitto_free((void *)mosq->host);
    }
  }
  {
#line 191
  _mosquitto_free((void *)mosq);
  }
#line 192
  return;
}
}
#line 194 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_socket(struct mosquitto *mosq ) 
{ 


  {
#line 196
  if (! mosq) {
#line 196
    return (3);
  }
#line 197
  return (mosq->sock);
}
}
#line 200 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_connect(struct mosquitto *mosq , char const   *host , int port , int keepalive ,
                      _Bool clean_session ) 
{ 
  int tmp ;

  {
#line 202
  if (! mosq) {
#line 202
    return (3);
  }
#line 203
  if (! host) {
#line 203
    return (3);
  } else
#line 203
  if (port <= 0) {
#line 203
    return (3);
  }
#line 205
  if (mosq->host) {
    {
#line 205
    _mosquitto_free((void *)mosq->host);
    }
  }
  {
#line 206
  mosq->host = _mosquitto_strdup(host);
  }
#line 207
  if (! mosq->host) {
#line 207
    return (1);
  }
  {
#line 208
  mosq->port = port;
#line 210
  mosq->keepalive = (uint16_t )keepalive;
#line 211
  mosq->clean_session = clean_session;
#line 213
  tmp = mosquitto_reconnect(mosq);
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_reconnect(struct mosquitto *mosq ) 
{ 
  int rc ;
  int tmp ;

  {
#line 219
  if (! mosq) {
#line 219
    return (3);
  }
#line 220
  if (! mosq->host) {
#line 220
    return (3);
  } else
#line 220
  if (mosq->port <= 0) {
#line 220
    return (3);
  }
  {
#line 222
  rc = _mosquitto_socket_connect(mosq, (char const   *)mosq->host, (uint16_t )mosq->port);
  }
#line 223
  if (rc) {
#line 224
    return (rc);
  }
  {
#line 227
  tmp = _mosquitto_send_connect(mosq, mosq->keepalive, mosq->clean_session);
  }
#line 227
  return (tmp);
}
}
#line 230 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_disconnect(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
#line 232
  if (! mosq) {
#line 232
    return (3);
  }
#line 233
  if (mosq->sock == -1) {
#line 233
    return (4);
  }
  {
#line 235
  mosq->state = (enum mosquitto_client_state )2;
#line 237
  tmp = _mosquitto_send_disconnect(mosq);
  }
#line 237
  return (tmp);
}
}
#line 240 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_publish(struct mosquitto *mosq , uint16_t *mid , char const   *topic___0 ,
                      uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                      _Bool retain___0 ) 
{ 
  struct mosquitto_message_all *message___0 ;
  uint16_t local_mid ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 245
  if (! mosq) {
#line 245
    return (3);
  } else
#line 245
  if (! topic___0) {
#line 245
    return (3);
  } else
#line 245
  if (qos___0 < 0) {
#line 245
    return (3);
  } else
#line 245
  if (qos___0 > 2) {
#line 245
    return (3);
  }
#line 246
  if (payloadlen > 268435455U) {
#line 246
    return (9);
  }
  {
#line 248
  tmp = _mosquitto_topic_wildcard_len_check(topic___0);
  }
#line 248
  if (tmp != 0) {
#line 249
    return (3);
  }
  {
#line 252
  local_mid = _mosquitto_mid_generate(mosq);
  }
#line 253
  if (mid) {
#line 254
    *mid = local_mid;
  }
#line 257
  if (qos___0 == 0) {
    {
#line 258
    tmp___0 = _mosquitto_send_publish(mosq, local_mid, topic___0, payloadlen, payload,
                                      qos___0, retain___0, (_Bool)0);
    }
#line 258
    return (tmp___0);
  } else {
    {
#line 260
    tmp___1 = _mosquitto_calloc((size_t )1, sizeof(struct mosquitto_message_all ));
#line 260
    message___0 = (struct mosquitto_message_all *)tmp___1;
    }
#line 261
    if (! message___0) {
#line 261
      return (1);
    }
    {
#line 263
    message___0->next = (struct mosquitto_message_all *)((void *)0);
#line 264
    message___0->timestamp = time((time_t *)((void *)0));
#line 265
    message___0->direction = (enum mosquitto_msg_direction )1;
    }
#line 266
    if (qos___0 == 1) {
#line 267
      message___0->state = (enum mosquitto_msg_state )1;
    } else
#line 268
    if (qos___0 == 2) {
#line 269
      message___0->state = (enum mosquitto_msg_state )2;
    }
    {
#line 271
    message___0->msg.mid = local_mid;
#line 272
    message___0->msg.topic = _mosquitto_strdup(topic___0);
    }
#line 273
    if (! message___0->msg.topic) {
      {
#line 274
      _mosquitto_message_cleanup(& message___0);
      }
#line 275
      return (1);
    }
#line 277
    if (payloadlen) {
      {
#line 278
      message___0->msg.payloadlen = payloadlen;
#line 279
      tmp___2 = _mosquitto_malloc((unsigned long )payloadlen * sizeof(uint8_t ));
#line 279
      message___0->msg.payload = (uint8_t *)tmp___2;
      }
#line 280
      if (! message___0->msg.payload) {
        {
#line 281
        _mosquitto_message_cleanup(& message___0);
        }
#line 282
        return (1);
      }
      {
#line 284
      memcpy((void */* __restrict  */)message___0->msg.payload, (void const   */* __restrict  */)payload,
             (unsigned long )payloadlen * sizeof(uint8_t ));
      }
    } else {
#line 286
      message___0->msg.payloadlen = (uint32_t )0;
#line 287
      message___0->msg.payload = (uint8_t *)((void *)0);
    }
    {
#line 289
    message___0->msg.qos = qos___0;
#line 290
    message___0->msg.retain = retain___0;
#line 291
    message___0->dup = (_Bool)0;
#line 293
    _mosquitto_message_queue(mosq, message___0);
#line 294
    tmp___3 = _mosquitto_send_publish(mosq, message___0->msg.mid, (char const   *)message___0->msg.topic,
                                      message___0->msg.payloadlen, (uint8_t const   *)message___0->msg.payload,
                                      message___0->msg.qos, message___0->msg.retain,
                                      message___0->dup);
    }
#line 294
    return (tmp___3);
  }
}
}
#line 298 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_subscribe(struct mosquitto *mosq , uint16_t *mid , char const   *sub ,
                        int qos___0 ) 
{ 
  int tmp ;

  {
#line 300
  if (! mosq) {
#line 300
    return (3);
  }
#line 301
  if (mosq->sock == -1) {
#line 301
    return (4);
  }
  {
#line 303
  tmp = _mosquitto_send_subscribe(mosq, mid, (_Bool)0, sub, (uint8_t )qos___0);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_unsubscribe(struct mosquitto *mosq , uint16_t *mid , char const   *sub ) 
{ 
  int tmp ;

  {
#line 308
  if (! mosq) {
#line 308
    return (3);
  }
#line 309
  if (mosq->sock == -1) {
#line 309
    return (4);
  }
  {
#line 311
  tmp = _mosquitto_send_unsubscribe(mosq, mid, (_Bool)0, sub);
  }
#line 311
  return (tmp);
}
}
#line 335 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_loop(struct mosquitto *mosq , int timeout ) 
{ 
  struct timeval local_timeout ;
  fd_set readfds ;
  fd_set writefds ;
  int fdcount ;
  int rc ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;

  {
#line 346
  if (! mosq) {
#line 346
    return (3);
  }
#line 347
  if (mosq->sock == -1) {
#line 347
    return (4);
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 349
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  readfds.__fds_bits[mosq->sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << mosq->sock % (8 * (int )sizeof(__fd_mask ));
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 351
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds.__fds_bits[0]): "memory");
#line 351
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 352
  if (mosq->out_packet) {
#line 353
    writefds.__fds_bits[mosq->sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << mosq->sock % (8 * (int )sizeof(__fd_mask ));
  }
#line 359
  if (timeout >= 0) {
#line 360
    local_timeout.tv_sec = (__time_t )(timeout / 1000);
#line 364
    local_timeout.tv_usec = ((__time_t )timeout - local_timeout.tv_sec * 1000L) * 1000L;
  } else {
#line 367
    local_timeout.tv_sec = (__time_t )1;
#line 371
    local_timeout.tv_usec = (__suseconds_t )0;
  }
  {
#line 378
  fdcount = select(mosq->sock + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& local_timeout));
  }
#line 380
  if (fdcount == -1) {
#line 384
    return (14);
  } else {
#line 386
    if ((readfds.__fds_bits[mosq->sock / (8 * (int )sizeof(__fd_mask ))] & (1L << mosq->sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 387
      rc = mosquitto_loop_read(mosq);
      }
#line 388
      if (rc) {
        {
#line 389
        _mosquitto_socket_close(mosq);
        }
#line 390
        if ((unsigned int )mosq->state == 2U) {
#line 391
          rc = 0;
        }
#line 393
        if (mosq->on_disconnect) {
          {
#line 394
          mosq->in_callback = (_Bool)1;
#line 395
          (*(mosq->on_disconnect))(mosq->obj);
#line 396
          mosq->in_callback = (_Bool)0;
          }
        }
#line 398
        return (rc);
      }
    }
#line 401
    if ((writefds.__fds_bits[mosq->sock / (8 * (int )sizeof(__fd_mask ))] & (1L << mosq->sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 402
      rc = mosquitto_loop_write(mosq);
      }
#line 403
      if (rc) {
        {
#line 404
        _mosquitto_socket_close(mosq);
        }
#line 405
        if ((unsigned int )mosq->state == 2U) {
#line 406
          rc = 0;
        }
#line 408
        if (mosq->on_disconnect) {
          {
#line 409
          mosq->in_callback = (_Bool)1;
#line 410
          (*(mosq->on_disconnect))(mosq->obj);
#line 411
          mosq->in_callback = (_Bool)0;
          }
        }
#line 413
        return (rc);
      }
    }
  }
  {
#line 417
  mosquitto_loop_misc(mosq);
  }
#line 419
  return (0);
}
}
#line 422 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_loop_misc(struct mosquitto *mosq ) 
{ 
  time_t tmp ;

  {
#line 424
  if (! mosq) {
#line 424
    return (3);
  }
  {
#line 426
  _mosquitto_check_keepalive(mosq);
#line 427
  tmp = time((time_t *)((void *)0));
  }
#line 427
  if (mosq->last_retry_check + 1L < tmp) {
    {
#line 428
    _mosquitto_message_retry_check(mosq);
#line 429
    mosq->last_retry_check = time((time_t *)((void *)0));
    }
  }
#line 431
  return (0);
}
}
#line 434 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_loop_read(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
  {
#line 436
  tmp = _mosquitto_packet_read(mosq);
  }
#line 436
  return (tmp);
}
}
#line 439 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
int mosquitto_loop_write(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
  {
#line 441
  tmp = _mosquitto_packet_write(mosq);
  }
#line 441
  return (tmp);
}
}
#line 444 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_connect_callback_set(struct mosquitto *mosq , void (*on_connect)(void * ,
                                                                                int  ) ) 
{ 


  {
#line 446
  mosq->on_connect = on_connect;
#line 447
  return;
}
}
#line 449 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_disconnect_callback_set(struct mosquitto *mosq , void (*on_disconnect)(void * ) ) 
{ 


  {
#line 451
  mosq->on_disconnect = on_disconnect;
#line 452
  return;
}
}
#line 454 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_publish_callback_set(struct mosquitto *mosq , void (*on_publish)(void * ,
                                                                                uint16_t  ) ) 
{ 


  {
#line 456
  mosq->on_publish = on_publish;
#line 457
  return;
}
}
#line 459 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_message_callback_set(struct mosquitto *mosq , void (*on_message)(void * ,
                                                                                struct mosquitto_message  const  * ) ) 
{ 


  {
#line 461
  mosq->on_message = on_message;
#line 462
  return;
}
}
#line 464 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_subscribe_callback_set(struct mosquitto *mosq , void (*on_subscribe)(void * ,
                                                                                    uint16_t  ,
                                                                                    int  ,
                                                                                    uint8_t const   * ) ) 
{ 


  {
#line 466
  mosq->on_subscribe = on_subscribe;
#line 467
  return;
}
}
#line 469 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/mosquitto.c"
void mosquitto_unsubscribe_callback_set(struct mosquitto *mosq , void (*on_unsubscribe)(void * ,
                                                                                        uint16_t  ) ) 
{ 


  {
#line 471
  mosq->on_unsubscribe = on_unsubscribe;
#line 472
  return;
}
}
#line 34 "./send_mosq.h"
int _mosquitto_send_simple_command(struct mosquitto *mosq , uint8_t command ) ;
#line 35
int _mosquitto_send_command_with_mid(struct mosquitto *mosq , uint8_t command , uint16_t mid ,
                                     _Bool dup___0 ) ;
#line 36
int _mosquitto_send_real_publish(struct mosquitto *mosq , uint16_t mid , char const   *topic___0 ,
                                 uint32_t payloadlen , uint8_t const   *payload ,
                                 int qos___0 , _Bool retain___0 , _Bool dup___0 ) ;
#line 42
int _mosquitto_send_puback(struct mosquitto *mosq , uint16_t mid ) ;
#line 45
int _mosquitto_send_pubrec(struct mosquitto *mosq , uint16_t mid ) ;
#line 46 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_pingreq(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
#line 48
  if (! mosq) {
    {
#line 48
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  48U, "_mosquitto_send_pingreq");
    }
  }
  {
#line 52
  _mosquitto_log_printf(mosq, 16, "Sending PINGREQ");
#line 54
  tmp = _mosquitto_send_simple_command(mosq, (uint8_t )192);
  }
#line 54
  return (tmp);
}
}
#line 57 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_pingresp(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
#line 62
  if (mosq) {
    {
#line 62
    _mosquitto_log_printf(mosq, 16, "Sending PINGRESP");
    }
  }
  {
#line 64
  tmp = _mosquitto_send_simple_command(mosq, (uint8_t )208);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_puback(struct mosquitto *mosq , uint16_t mid ) 
{ 
  int tmp ;

  {
#line 72
  if (mosq) {
    {
#line 72
    _mosquitto_log_printf(mosq, 16, "Sending PUBACK (Mid: %d)", (int )mid);
    }
  }
  {
#line 74
  tmp = _mosquitto_send_command_with_mid(mosq, (uint8_t )64, mid, (_Bool)0);
  }
#line 74
  return (tmp);
}
}
#line 77 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_pubcomp(struct mosquitto *mosq , uint16_t mid ) 
{ 
  int tmp ;

  {
#line 82
  if (mosq) {
    {
#line 82
    _mosquitto_log_printf(mosq, 16, "Sending PUBCOMP (Mid: %d)", (int )mid);
    }
  }
  {
#line 84
  tmp = _mosquitto_send_command_with_mid(mosq, (uint8_t )112, mid, (_Bool)0);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_publish(struct mosquitto *mosq , uint16_t mid , char const   *topic___0 ,
                            uint32_t payloadlen , uint8_t const   *payload , int qos___0 ,
                            _Bool retain___0 , _Bool dup___0 ) 
{ 
  int tmp ;

  {
#line 92
  if (! mosq) {
    {
#line 92
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  92U, "_mosquitto_send_publish");
    }
  }
#line 93
  if (! topic___0) {
    {
#line 93
    __assert_fail("topic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  93U, "_mosquitto_send_publish");
    }
  }
#line 95
  if (mosq->sock == -1) {
#line 95
    return (4);
  }
  {
#line 108
  _mosquitto_log_printf(mosq, 16, "Sending PUBLISH (d%d, q%d, r%d, m%d, \'%s\', ... (%ld bytes))",
                        (int )dup___0, qos___0, (int )retain___0, (int )mid, topic___0,
                        (long )payloadlen);
#line 110
  tmp = _mosquitto_send_real_publish(mosq, mid, topic___0, payloadlen, payload, qos___0,
                                     retain___0, dup___0);
  }
#line 110
  return (tmp);
}
}
#line 113 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_pubrec(struct mosquitto *mosq , uint16_t mid ) 
{ 
  int tmp ;

  {
#line 118
  if (mosq) {
    {
#line 118
    _mosquitto_log_printf(mosq, 16, "Sending PUBREC (Mid: %d)", (int )mid);
    }
  }
  {
#line 120
  tmp = _mosquitto_send_command_with_mid(mosq, (uint8_t )80, mid, (_Bool)0);
  }
#line 120
  return (tmp);
}
}
#line 123 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_pubrel(struct mosquitto *mosq , uint16_t mid , _Bool dup___0 ) 
{ 
  int tmp ;

  {
#line 128
  if (mosq) {
    {
#line 128
    _mosquitto_log_printf(mosq, 16, "Sending PUBREL (Mid: %d)", (int )mid);
    }
  }
  {
#line 130
  tmp = _mosquitto_send_command_with_mid(mosq, (uint8_t )98, mid, dup___0);
  }
#line 130
  return (tmp);
}
}
#line 134 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_command_with_mid(struct mosquitto *mosq , uint8_t command , uint16_t mid ,
                                     _Bool dup___0 ) 
{ 
  struct _mosquitto_packet *packet ;
  int rc ;
  void *tmp ;
  int tmp___0 ;

  {
#line 136
  packet = (struct _mosquitto_packet *)((void *)0);
#line 139
  if (! mosq) {
    {
#line 139
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  139U, "_mosquitto_send_command_with_mid");
    }
  }
  {
#line 140
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct _mosquitto_packet ));
#line 140
  packet = (struct _mosquitto_packet *)tmp;
  }
#line 141
  if (! packet) {
#line 141
    return (1);
  }
#line 143
  packet->command = command;
#line 144
  if (dup___0) {
#line 145
    packet->command = (uint8_t )((int )packet->command | 8);
  }
  {
#line 147
  packet->remaining_length = (uint32_t )2;
#line 148
  rc = _mosquitto_packet_alloc(packet);
  }
#line 149
  if (rc) {
    {
#line 150
    _mosquitto_free((void *)packet);
    }
#line 151
    return (rc);
  }
  {
#line 154
  *(packet->payload + packet->pos) = (uint8_t )(((int )mid & 65280) >> 8);
#line 155
  *(packet->payload + (packet->pos + 1U)) = (uint8_t )((int )mid & 255);
#line 157
  tmp___0 = _mosquitto_packet_queue(mosq, packet);
  }
#line 157
  return (tmp___0);
}
}
#line 161 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_simple_command(struct mosquitto *mosq , uint8_t command ) 
{ 
  struct _mosquitto_packet *packet ;
  int rc ;
  void *tmp ;
  int tmp___0 ;

  {
#line 163
  packet = (struct _mosquitto_packet *)((void *)0);
#line 166
  if (! mosq) {
    {
#line 166
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  166U, "_mosquitto_send_simple_command");
    }
  }
  {
#line 167
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct _mosquitto_packet ));
#line 167
  packet = (struct _mosquitto_packet *)tmp;
  }
#line 168
  if (! packet) {
#line 168
    return (1);
  }
  {
#line 170
  packet->command = command;
#line 171
  packet->remaining_length = (uint32_t )0;
#line 173
  rc = _mosquitto_packet_alloc(packet);
  }
#line 174
  if (rc) {
    {
#line 175
    _mosquitto_free((void *)packet);
    }
#line 176
    return (rc);
  }
  {
#line 179
  tmp___0 = _mosquitto_packet_queue(mosq, packet);
  }
#line 179
  return (tmp___0);
}
}
#line 182 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c"
int _mosquitto_send_real_publish(struct mosquitto *mosq , uint16_t mid , char const   *topic___0 ,
                                 uint32_t payloadlen , uint8_t const   *payload ,
                                 int qos___0 , _Bool retain___0 , _Bool dup___0 ) 
{ 
  struct _mosquitto_packet *packet ;
  int packetlen ;
  int rc ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 184
  packet = (struct _mosquitto_packet *)((void *)0);
#line 188
  if (! mosq) {
    {
#line 188
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  188U, "_mosquitto_send_real_publish");
    }
  }
#line 189
  if (! topic___0) {
    {
#line 189
    __assert_fail("topic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_mosq.c",
                  189U, "_mosquitto_send_real_publish");
    }
  }
  {
#line 191
  tmp = strlen(topic___0);
#line 191
  packetlen = (int )((2UL + tmp) + (size_t )payloadlen);
  }
#line 192
  if (qos___0 > 0) {
#line 192
    packetlen += 2;
  }
  {
#line 193
  tmp___0 = _mosquitto_calloc((size_t )1, sizeof(struct _mosquitto_packet ));
#line 193
  packet = (struct _mosquitto_packet *)tmp___0;
  }
#line 194
  if (! packet) {
#line 194
    return (1);
  }
  {
#line 196
  packet->mid = mid;
#line 197
  packet->command = (uint8_t )(((48 | (((int )dup___0 & 1) << 3)) | (qos___0 << 1)) | (int )retain___0);
#line 198
  packet->remaining_length = (uint32_t )packetlen;
#line 199
  rc = _mosquitto_packet_alloc(packet);
  }
#line 200
  if (rc) {
    {
#line 201
    _mosquitto_free((void *)packet);
    }
#line 202
    return (rc);
  }
  {
#line 205
  tmp___1 = strlen(topic___0);
#line 205
  _mosquitto_write_string(packet, topic___0, (uint16_t )tmp___1);
  }
#line 206
  if (qos___0 > 0) {
    {
#line 207
    _mosquitto_write_uint16(packet, mid);
    }
  }
#line 211
  if (payloadlen) {
    {
#line 212
    _mosquitto_write_bytes(packet, payload, payloadlen);
    }
  }
  {
#line 215
  tmp___2 = _mosquitto_packet_queue(mosq, packet);
  }
#line 215
  return (tmp___2);
}
}
#line 36 "./read_handle.h"
int _mosquitto_handle_connack(struct mosquitto *mosq ) ;
#line 38 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_client.c"
int _mosquitto_handle_connack(struct mosquitto *mosq ) 
{ 
  uint8_t byte ;
  uint8_t result ;
  int rc ;

  {
#line 44
  if (! mosq) {
    {
#line 44
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle_client.c",
                  44U, "_mosquitto_handle_connack");
    }
  }
  {
#line 50
  _mosquitto_log_printf(mosq, 16, "Received CONNACK");
#line 51
  rc = _mosquitto_read_byte(& mosq->in_packet, & byte);
  }
#line 52
  if (rc) {
#line 52
    return (rc);
  }
  {
#line 53
  rc = _mosquitto_read_byte(& mosq->in_packet, & result);
  }
#line 54
  if (rc) {
#line 54
    return (rc);
  }
#line 55
  if (mosq->on_connect) {
    {
#line 56
    mosq->in_callback = (_Bool)1;
#line 57
    (*(mosq->on_connect))(mosq->obj, (int )result);
#line 58
    mosq->in_callback = (_Bool)0;
    }
  }
  {
#line 61
  if ((int )result == 0) {
#line 61
    goto case_0;
  }
#line 68
  if ((int )result == 5) {
#line 68
    goto case_5;
  }
#line 68
  if ((int )result == 4) {
#line 68
    goto case_5;
  }
#line 68
  if ((int )result == 3) {
#line 68
    goto case_5;
  }
#line 68
  if ((int )result == 2) {
#line 68
    goto case_5;
  }
#line 68
  if ((int )result == 1) {
#line 68
    goto case_5;
  }
#line 70
  goto switch_default;
  case_0: /* CIL Label */ 
#line 62
  mosq->state = (enum mosquitto_client_state )1;
#line 63
  return (0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 69
  return (5);
  switch_default: /* CIL Label */ 
#line 71
  return (2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 46 "./memory_mosq.h"
void *_mosquitto_realloc(void *ptr , size_t size ) ;
#line 52 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/memory_mosq.c"
void *_mosquitto_calloc(size_t nmemb , size_t size ) 
{ 
  void *mem ;
  void *tmp ;

  {
  {
#line 54
  tmp = calloc(nmemb, size);
#line 54
  mem = tmp;
  }
#line 63
  return (mem);
}
}
#line 66 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/memory_mosq.c"
void _mosquitto_free(void *mem ) 
{ 


  {
  {
#line 71
  free(mem);
  }
#line 72
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/memory_mosq.c"
void *_mosquitto_malloc(size_t size ) 
{ 
  void *mem ;
  void *tmp ;

  {
  {
#line 76
  tmp = malloc(size);
#line 76
  mem = tmp;
  }
#line 85
  return (mem);
}
}
#line 100 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/memory_mosq.c"
void *_mosquitto_realloc(void *ptr , size_t size ) 
{ 
  void *mem ;

  {
  {
#line 108
  mem = realloc(ptr, size);
  }
#line 117
  return (mem);
}
}
#line 120 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/memory_mosq.c"
char *_mosquitto_strdup(char const   *s ) 
{ 
  char *str ;
  char *tmp ;

  {
  {
#line 122
  tmp = strdup(s);
#line 122
  str = tmp;
  }
#line 131
  return (str);
}
}
#line 40 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c"
int _mosquitto_send_connect(struct mosquitto *mosq , uint16_t keepalive , _Bool clean_session ) 
{ 
  struct _mosquitto_packet *packet ;
  int payloadlen ;
  uint8_t will ;
  uint8_t byte ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 42
  packet = (struct _mosquitto_packet *)((void *)0);
#line 44
  will = (uint8_t )0;
#line 48
  if (! mosq) {
    {
#line 48
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  48U, "_mosquitto_send_connect");
    }
  }
#line 49
  if (! mosq->id) {
    {
#line 49
    __assert_fail("mosq->id", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  49U, "_mosquitto_send_connect");
    }
  }
  {
#line 51
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct _mosquitto_packet ));
#line 51
  packet = (struct _mosquitto_packet *)tmp;
  }
#line 52
  if (! packet) {
#line 52
    return (1);
  }
  {
#line 54
  tmp___0 = strlen((char const   *)mosq->id);
#line 54
  payloadlen = (int )(2UL + tmp___0);
  }
#line 55
  if (mosq->will) {
#line 56
    will = (uint8_t )1;
#line 57
    if (! (mosq->will)->topic) {
      {
#line 57
      __assert_fail("mosq->will->topic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                    57U, "_mosquitto_send_connect");
      }
    }
    {
#line 59
    tmp___1 = strlen((char const   *)(mosq->will)->topic);
#line 59
    payloadlen = (int )((size_t )payloadlen + (((2UL + tmp___1) + 2UL) + (size_t )(mosq->will)->payloadlen));
    }
  }
#line 61
  if (mosq->username) {
    {
#line 62
    tmp___2 = strlen((char const   *)mosq->username);
#line 62
    payloadlen = (int )((size_t )payloadlen + (2UL + tmp___2));
    }
#line 63
    if (mosq->password) {
      {
#line 64
      tmp___3 = strlen((char const   *)mosq->password);
#line 64
      payloadlen = (int )((size_t )payloadlen + (2UL + tmp___3));
      }
    }
  }
  {
#line 68
  packet->command = (uint8_t )16;
#line 69
  packet->remaining_length = (uint32_t )(12 + payloadlen);
#line 70
  rc = _mosquitto_packet_alloc(packet);
  }
#line 71
  if (rc) {
    {
#line 72
    _mosquitto_free((void *)packet);
    }
#line 73
    return (rc);
  }
  {
#line 77
  tmp___4 = strlen("MQIsdp");
#line 77
  _mosquitto_write_string(packet, "MQIsdp", (uint16_t )tmp___4);
#line 78
  _mosquitto_write_byte(packet, (uint8_t )3);
#line 79
  byte = (uint8_t )(((int )clean_session & 1) << 1);
  }
#line 80
  if (will) {
#line 81
    byte = (uint8_t )((((int )byte | (((int )(mosq->will)->retain & 1) << 5)) | (((mosq->will)->qos & 3) << 3)) | (((int )will & 1) << 2));
  }
#line 83
  if (mosq->username) {
#line 84
    byte = (uint8_t )((int )byte | (1 << 7));
#line 85
    if (mosq->password) {
#line 86
      byte = (uint8_t )((int )byte | (1 << 6));
    }
  }
  {
#line 89
  _mosquitto_write_byte(packet, byte);
#line 90
  _mosquitto_write_uint16(packet, keepalive);
#line 93
  tmp___5 = strlen((char const   *)mosq->id);
#line 93
  _mosquitto_write_string(packet, (char const   *)mosq->id, (uint16_t )tmp___5);
  }
#line 94
  if (will) {
    {
#line 95
    tmp___6 = strlen((char const   *)(mosq->will)->topic);
#line 95
    _mosquitto_write_string(packet, (char const   *)(mosq->will)->topic, (uint16_t )tmp___6);
#line 96
    _mosquitto_write_string(packet, (char const   *)(mosq->will)->payload, (uint16_t )(mosq->will)->payloadlen);
    }
  }
#line 98
  if (mosq->username) {
    {
#line 99
    tmp___7 = strlen((char const   *)mosq->username);
#line 99
    _mosquitto_write_string(packet, (char const   *)mosq->username, (uint16_t )tmp___7);
    }
#line 100
    if (mosq->password) {
      {
#line 101
      tmp___8 = strlen((char const   *)mosq->password);
#line 101
      _mosquitto_write_string(packet, (char const   *)mosq->password, (uint16_t )tmp___8);
      }
    }
  }
  {
#line 105
  mosq->keepalive = keepalive;
#line 106
  tmp___9 = _mosquitto_packet_queue(mosq, packet);
  }
#line 106
  return (tmp___9);
}
}
#line 109 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c"
int _mosquitto_send_disconnect(struct mosquitto *mosq ) 
{ 
  int tmp ;

  {
#line 111
  if (! mosq) {
    {
#line 111
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  111U, "_mosquitto_send_disconnect");
    }
  }
  {
#line 112
  tmp = _mosquitto_send_simple_command(mosq, (uint8_t )224);
  }
#line 112
  return (tmp);
}
}
#line 115 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c"
int _mosquitto_send_subscribe(struct mosquitto *mosq , uint16_t *mid , _Bool dup___0 ,
                              char const   *topic___0 , uint8_t topic_qos___0 ) 
{ 
  struct _mosquitto_packet *packet ;
  uint32_t packetlen ;
  uint16_t local_mid ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 118
  packet = (struct _mosquitto_packet *)((void *)0);
#line 123
  if (! mosq) {
    {
#line 123
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  123U, "_mosquitto_send_subscribe");
    }
  }
#line 124
  if (! topic___0) {
    {
#line 124
    __assert_fail("topic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  124U, "_mosquitto_send_subscribe");
    }
  }
  {
#line 126
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct _mosquitto_packet ));
#line 126
  packet = (struct _mosquitto_packet *)tmp;
  }
#line 127
  if (! packet) {
#line 127
    return (1);
  }
  {
#line 129
  tmp___0 = strlen(topic___0);
#line 129
  packetlen = (uint32_t )((4UL + tmp___0) + 1UL);
#line 131
  packet->command = (uint8_t )((128 | ((int )dup___0 << 3)) | (1 << 1));
#line 132
  packet->remaining_length = packetlen;
#line 133
  rc = _mosquitto_packet_alloc(packet);
  }
#line 134
  if (rc) {
    {
#line 135
    _mosquitto_free((void *)packet);
    }
#line 136
    return (rc);
  }
  {
#line 140
  local_mid = _mosquitto_mid_generate(mosq);
  }
#line 141
  if (mid) {
#line 141
    *mid = local_mid;
  }
  {
#line 142
  _mosquitto_write_uint16(packet, local_mid);
#line 145
  tmp___1 = strlen(topic___0);
#line 145
  _mosquitto_write_string(packet, topic___0, (uint16_t )tmp___1);
#line 146
  _mosquitto_write_byte(packet, topic_qos___0);
#line 148
  tmp___2 = _mosquitto_packet_queue(mosq, packet);
  }
#line 148
  return (tmp___2);
}
}
#line 152 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c"
int _mosquitto_send_unsubscribe(struct mosquitto *mosq , uint16_t *mid , _Bool dup___0 ,
                                char const   *topic___0 ) 
{ 
  struct _mosquitto_packet *packet ;
  uint32_t packetlen ;
  uint16_t local_mid ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 155
  packet = (struct _mosquitto_packet *)((void *)0);
#line 160
  if (! mosq) {
    {
#line 160
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  160U, "_mosquitto_send_unsubscribe");
    }
  }
#line 161
  if (! topic___0) {
    {
#line 161
    __assert_fail("topic", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/send_client_mosq.c",
                  161U, "_mosquitto_send_unsubscribe");
    }
  }
  {
#line 163
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct _mosquitto_packet ));
#line 163
  packet = (struct _mosquitto_packet *)tmp;
  }
#line 164
  if (! packet) {
#line 164
    return (1);
  }
  {
#line 166
  tmp___0 = strlen(topic___0);
#line 166
  packetlen = (uint32_t )(4UL + tmp___0);
#line 168
  packet->command = (uint8_t )((160 | ((int )dup___0 << 3)) | (1 << 1));
#line 169
  packet->remaining_length = packetlen;
#line 170
  rc = _mosquitto_packet_alloc(packet);
  }
#line 171
  if (rc) {
    {
#line 172
    _mosquitto_free((void *)packet);
    }
#line 173
    return (rc);
  }
  {
#line 177
  local_mid = _mosquitto_mid_generate(mosq);
  }
#line 178
  if (mid) {
#line 178
    *mid = local_mid;
  }
  {
#line 179
  _mosquitto_write_uint16(packet, local_mid);
#line 182
  tmp___1 = strlen(topic___0);
#line 182
  _mosquitto_write_string(packet, topic___0, (uint16_t )tmp___1);
#line 184
  tmp___2 = _mosquitto_packet_queue(mosq, packet);
  }
#line 184
  return (tmp___2);
}
}
#line 40 "./read_handle.h"
int _mosquitto_handle_publish(struct mosquitto *mosq ) ;
#line 44 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle.c"
int _mosquitto_packet_handle(struct mosquitto *mosq ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 46
  if (! mosq) {
    {
#line 46
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle.c",
                  46U, "_mosquitto_packet_handle");
    }
  }
  {
#line 49
  if (((int )mosq->in_packet.command & 240) == 192) {
#line 49
    goto case_192;
  }
#line 51
  if (((int )mosq->in_packet.command & 240) == 208) {
#line 51
    goto case_208;
  }
#line 53
  if (((int )mosq->in_packet.command & 240) == 64) {
#line 53
    goto case_64;
  }
#line 55
  if (((int )mosq->in_packet.command & 240) == 112) {
#line 55
    goto case_112;
  }
#line 57
  if (((int )mosq->in_packet.command & 240) == 48) {
#line 57
    goto case_48;
  }
#line 59
  if (((int )mosq->in_packet.command & 240) == 80) {
#line 59
    goto case_80;
  }
#line 61
  if (((int )mosq->in_packet.command & 240) == 96) {
#line 61
    goto case_96;
  }
#line 63
  if (((int )mosq->in_packet.command & 240) == 32) {
#line 63
    goto case_32;
  }
#line 65
  if (((int )mosq->in_packet.command & 240) == 144) {
#line 65
    goto case_144;
  }
#line 67
  if (((int )mosq->in_packet.command & 240) == 176) {
#line 67
    goto case_176;
  }
#line 69
  goto switch_default;
  case_192: /* CIL Label */ 
  {
#line 50
  tmp = _mosquitto_handle_pingreq(mosq);
  }
#line 50
  return (tmp);
  case_208: /* CIL Label */ 
  {
#line 52
  tmp___0 = _mosquitto_handle_pingresp(mosq);
  }
#line 52
  return (tmp___0);
  case_64: /* CIL Label */ 
  {
#line 54
  tmp___1 = _mosquitto_handle_pubackcomp(mosq, "PUBACK");
  }
#line 54
  return (tmp___1);
  case_112: /* CIL Label */ 
  {
#line 56
  tmp___2 = _mosquitto_handle_pubackcomp(mosq, "PUBCOMP");
  }
#line 56
  return (tmp___2);
  case_48: /* CIL Label */ 
  {
#line 58
  tmp___3 = _mosquitto_handle_publish(mosq);
  }
#line 58
  return (tmp___3);
  case_80: /* CIL Label */ 
  {
#line 60
  tmp___4 = _mosquitto_handle_pubrec(mosq);
  }
#line 60
  return (tmp___4);
  case_96: /* CIL Label */ 
  {
#line 62
  tmp___5 = _mosquitto_handle_pubrel((struct _mosquitto_db *)((void *)0), mosq);
  }
#line 62
  return (tmp___5);
  case_32: /* CIL Label */ 
  {
#line 64
  tmp___6 = _mosquitto_handle_connack(mosq);
  }
#line 64
  return (tmp___6);
  case_144: /* CIL Label */ 
  {
#line 66
  tmp___7 = _mosquitto_handle_suback(mosq);
  }
#line 66
  return (tmp___7);
  case_176: /* CIL Label */ 
  {
#line 68
  tmp___8 = _mosquitto_handle_unsuback(mosq);
  }
#line 68
  return (tmp___8);
  switch_default: /* CIL Label */ 
  {
#line 71
  _mosquitto_log_printf(mosq, 8, "Error: Unrecognised command %d\n", (int )mosq->in_packet.command & 240);
  }
#line 72
  return (2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 76 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle.c"
int _mosquitto_handle_publish(struct mosquitto *mosq ) 
{ 
  uint8_t header ;
  struct mosquitto_message_all *message___0 ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 80
  rc = 0;
#line 82
  if (! mosq) {
    {
#line 82
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/read_handle.c",
                  82U, "_mosquitto_handle_publish");
    }
  }
  {
#line 84
  tmp = _mosquitto_calloc((size_t )1, sizeof(struct mosquitto_message_all ));
#line 84
  message___0 = (struct mosquitto_message_all *)tmp;
  }
#line 85
  if (! message___0) {
#line 85
    return (1);
  }
  {
#line 87
  header = mosq->in_packet.command;
#line 89
  message___0->direction = (enum mosquitto_msg_direction )0;
#line 90
  message___0->dup = (_Bool )(((int )header & 8) >> 3);
#line 91
  message___0->msg.qos = ((int )header & 6) >> 1;
#line 92
  message___0->msg.retain = (_Bool )((int )header & 1);
#line 94
  rc = _mosquitto_read_string(& mosq->in_packet, & message___0->msg.topic);
  }
#line 95
  if (rc) {
    {
#line 96
    _mosquitto_message_cleanup(& message___0);
    }
#line 97
    return (rc);
  }
  {
#line 99
  rc = _mosquitto_fix_sub_topic(& message___0->msg.topic);
  }
#line 100
  if (rc) {
    {
#line 101
    _mosquitto_message_cleanup(& message___0);
    }
#line 102
    return (rc);
  }
  {
#line 104
  tmp___0 = strlen((char const   *)message___0->msg.topic);
  }
#line 104
  if (! tmp___0) {
    {
#line 105
    _mosquitto_message_cleanup(& message___0);
    }
#line 106
    return (2);
  }
#line 109
  if (message___0->msg.qos > 0) {
    {
#line 110
    rc = _mosquitto_read_uint16(& mosq->in_packet, & message___0->msg.mid);
    }
#line 111
    if (rc) {
      {
#line 112
      _mosquitto_message_cleanup(& message___0);
      }
#line 113
      return (rc);
    }
  }
#line 117
  message___0->msg.payloadlen = mosq->in_packet.remaining_length - mosq->in_packet.pos;
#line 118
  if (message___0->msg.payloadlen) {
    {
#line 119
    tmp___1 = _mosquitto_calloc((size_t )(message___0->msg.payloadlen + 1U), sizeof(uint8_t ));
#line 119
    message___0->msg.payload = (uint8_t *)tmp___1;
#line 120
    _mosquitto_read_bytes(& mosq->in_packet, message___0->msg.payload, message___0->msg.payloadlen);
    }
#line 121
    if (rc) {
      {
#line 122
      _mosquitto_message_cleanup(& message___0);
      }
#line 123
      return (rc);
    }
  }
  {
#line 126
  _mosquitto_log_printf(mosq, 16, "Received PUBLISH (d%d, q%d, r%d, m%d, \'%s\', ... (%ld bytes))",
                        (int )message___0->dup, message___0->msg.qos, (int )message___0->msg.retain,
                        (int )message___0->msg.mid, message___0->msg.topic, (long )message___0->msg.payloadlen);
#line 131
  message___0->timestamp = time((time_t *)((void *)0));
  }
  {
#line 133
  if (message___0->msg.qos == 0) {
#line 133
    goto case_0;
  }
#line 141
  if (message___0->msg.qos == 1) {
#line 141
    goto case_1;
  }
#line 150
  if (message___0->msg.qos == 2) {
#line 150
    goto case_2;
  }
#line 155
  goto switch_default;
  case_0: /* CIL Label */ 
#line 134
  if (mosq->on_message) {
    {
#line 135
    mosq->in_callback = (_Bool)1;
#line 136
    (*(mosq->on_message))(mosq->obj, (struct mosquitto_message  const  *)(& message___0->msg));
#line 137
    mosq->in_callback = (_Bool)0;
    }
  }
  {
#line 139
  _mosquitto_message_cleanup(& message___0);
  }
#line 140
  return (0);
  case_1: /* CIL Label */ 
  {
#line 142
  rc = _mosquitto_send_puback(mosq, message___0->msg.mid);
  }
#line 143
  if (mosq->on_message) {
    {
#line 144
    mosq->in_callback = (_Bool)1;
#line 145
    (*(mosq->on_message))(mosq->obj, (struct mosquitto_message  const  *)(& message___0->msg));
#line 146
    mosq->in_callback = (_Bool)0;
    }
  }
  {
#line 148
  _mosquitto_message_cleanup(& message___0);
  }
#line 149
  return (rc);
  case_2: /* CIL Label */ 
  {
#line 151
  rc = _mosquitto_send_pubrec(mosq, message___0->msg.mid);
#line 152
  message___0->state = (enum mosquitto_msg_state )3;
#line 153
  _mosquitto_message_queue(mosq, message___0);
  }
#line 154
  return (rc);
  switch_default: /* CIL Label */ 
#line 156
  return (2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 458 "./mosquitto.h"
int mosquitto_message_copy(struct mosquitto_message *dst , struct mosquitto_message  const  *src ) ;
#line 471
void mosquitto_message_free(struct mosquitto_message **message___0 ) ;
#line 723
void mosquitto_message_retry_set(struct mosquitto *mosq , unsigned int message_retry ) ;
#line 40 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
void _mosquitto_message_cleanup(struct mosquitto_message_all **message___0 ) 
{ 
  struct mosquitto_message_all *msg ;

  {
#line 44
  if (! message___0) {
#line 44
    return;
  } else
#line 44
  if (! *message___0) {
#line 44
    return;
  }
#line 46
  msg = *message___0;
#line 48
  if (msg->msg.topic) {
    {
#line 48
    _mosquitto_free((void *)msg->msg.topic);
    }
  }
#line 49
  if (msg->msg.payload) {
    {
#line 49
    _mosquitto_free((void *)msg->msg.payload);
    }
  }
  {
#line 50
  _mosquitto_free((void *)msg);
  }
#line 51
  return;
}
}
#line 53 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
void _mosquitto_message_cleanup_all(struct mosquitto *mosq ) 
{ 
  struct mosquitto_message_all *tmp ;

  {
#line 57
  if (! mosq) {
    {
#line 57
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  57U, "_mosquitto_message_cleanup_all");
    }
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! mosq->messages) {
#line 59
      goto while_break;
    }
    {
#line 60
    tmp = (mosq->messages)->next;
#line 61
    _mosquitto_message_cleanup(& mosq->messages);
#line 62
    mosq->messages = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 66 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
int mosquitto_message_copy(struct mosquitto_message *dst , struct mosquitto_message  const  *src ) 
{ 
  void *tmp ;

  {
#line 68
  if (! dst) {
#line 68
    return (3);
  } else
#line 68
  if (! src) {
#line 68
    return (3);
  }
  {
#line 70
  dst->mid = (uint16_t )src->mid;
#line 71
  dst->topic = _mosquitto_strdup((char const   *)src->topic);
  }
#line 72
  if (! dst->topic) {
#line 72
    return (1);
  }
#line 73
  dst->qos = (int )src->qos;
#line 74
  dst->retain = (_Bool )src->retain;
#line 75
  if (src->payloadlen) {
    {
#line 76
    tmp = _mosquitto_malloc((size_t )src->payloadlen);
#line 76
    dst->payload = (uint8_t *)tmp;
    }
#line 77
    if (! dst->payload) {
      {
#line 78
      _mosquitto_free((void *)dst->topic);
      }
#line 79
      return (1);
    }
    {
#line 81
    memcpy((void */* __restrict  */)dst->payload, (void const   */* __restrict  */)src->payload,
           (size_t )src->payloadlen);
#line 82
    dst->payloadlen = (uint32_t )src->payloadlen;
    }
  } else {
#line 84
    dst->payloadlen = (uint32_t )0;
#line 85
    dst->payload = (uint8_t *)((void *)0);
  }
#line 87
  return (0);
}
}
#line 90 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
int _mosquitto_message_delete(struct mosquitto *mosq , uint16_t mid , enum mosquitto_msg_direction dir ) 
{ 
  struct mosquitto_message_all *message___0 ;
  int rc ;

  {
#line 94
  if (! mosq) {
    {
#line 94
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  94U, "_mosquitto_message_delete");
    }
  }
  {
#line 96
  rc = _mosquitto_message_remove(mosq, mid, dir, & message___0);
  }
#line 97
  if (rc == 0) {
    {
#line 98
    _mosquitto_message_cleanup(& message___0);
    }
  }
#line 100
  return (rc);
}
}
#line 103 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
void mosquitto_message_free(struct mosquitto_message **message___0 ) 
{ 
  struct mosquitto_message *msg ;

  {
#line 107
  if (! message___0) {
#line 107
    return;
  } else
#line 107
  if (! *message___0) {
#line 107
    return;
  }
#line 109
  msg = *message___0;
#line 111
  if (msg->topic) {
    {
#line 111
    _mosquitto_free((void *)msg->topic);
    }
  }
#line 112
  if (msg->payload) {
    {
#line 112
    _mosquitto_free((void *)msg->payload);
    }
  }
  {
#line 113
  _mosquitto_free((void *)msg);
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
void _mosquitto_message_queue(struct mosquitto *mosq , struct mosquitto_message_all *message___0 ) 
{ 
  struct mosquitto_message_all *tail ;

  {
#line 120
  if (! mosq) {
    {
#line 120
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  120U, "_mosquitto_message_queue");
    }
  }
#line 121
  if (! message___0) {
    {
#line 121
    __assert_fail("message", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  121U, "_mosquitto_message_queue");
    }
  }
#line 123
  message___0->next = (struct mosquitto_message_all *)((void *)0);
#line 124
  if (mosq->messages) {
#line 125
    tail = mosq->messages;
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! tail->next) {
#line 126
        goto while_break;
      }
#line 127
      tail = tail->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 129
    tail->next = message___0;
  } else {
#line 131
    mosq->messages = message___0;
  }
#line 133
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
int _mosquitto_message_remove(struct mosquitto *mosq , uint16_t mid , enum mosquitto_msg_direction dir ,
                              struct mosquitto_message_all **message___0 ) 
{ 
  struct mosquitto_message_all *cur ;
  struct mosquitto_message_all *prev ;

  {
#line 137
  prev = (struct mosquitto_message_all *)((void *)0);
#line 138
  if (! mosq) {
    {
#line 138
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  138U, "_mosquitto_message_remove");
    }
  }
#line 139
  if (! message___0) {
    {
#line 139
    __assert_fail("message", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  139U, "_mosquitto_message_remove");
    }
  }
#line 141
  cur = mosq->messages;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! cur) {
#line 142
      goto while_break;
    }
#line 143
    if ((int )cur->msg.mid == (int )mid) {
#line 143
      if ((unsigned int )cur->direction == (unsigned int )dir) {
#line 144
        if (prev) {
#line 145
          prev->next = cur->next;
        } else {
#line 147
          mosq->messages = cur->next;
        }
#line 149
        *message___0 = cur;
#line 150
        return (0);
      }
    }
#line 152
    prev = cur;
#line 153
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return (6);
}
}
#line 158 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
void _mosquitto_message_retry_check(struct mosquitto *mosq ) 
{ 
  struct mosquitto_message_all *message___0 ;
  time_t now ;
  time_t tmp ;

  {
  {
#line 161
  tmp = time((time_t *)((void *)0));
#line 161
  now = tmp;
  }
#line 162
  if (! mosq) {
    {
#line 162
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  162U, "_mosquitto_message_retry_check");
    }
  }
#line 164
  message___0 = mosq->messages;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! message___0) {
#line 165
      goto while_break;
    }
#line 166
    if (message___0->timestamp + (time_t )mosq->message_retry < now) {
      {
#line 169
      if ((unsigned int )message___0->state == 2U) {
#line 169
        goto case_2;
      }
#line 169
      if ((unsigned int )message___0->state == 1U) {
#line 169
        goto case_2;
      }
#line 174
      if ((unsigned int )message___0->state == 3U) {
#line 174
        goto case_3;
      }
#line 178
      if ((unsigned int )message___0->state == 4U) {
#line 178
        goto case_4;
      }
#line 182
      goto switch_default;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 170
      message___0->timestamp = now;
#line 171
      message___0->dup = (_Bool)1;
#line 172
      _mosquitto_send_publish(mosq, message___0->msg.mid, (char const   *)message___0->msg.topic,
                              message___0->msg.payloadlen, (uint8_t const   *)message___0->msg.payload,
                              message___0->msg.qos, message___0->msg.retain, message___0->dup);
      }
#line 173
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 175
      message___0->timestamp = now;
#line 176
      _mosquitto_send_pubrec(mosq, message___0->msg.mid);
      }
#line 177
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 179
      message___0->timestamp = now;
#line 180
      _mosquitto_send_pubrel(mosq, message___0->msg.mid, (_Bool)1);
      }
#line 181
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 183
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 186
    message___0 = message___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
void mosquitto_message_retry_set(struct mosquitto *mosq , unsigned int message_retry ) 
{ 


  {
#line 192
  if (! mosq) {
    {
#line 192
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  192U, "mosquitto_message_retry_set");
    }
  }
#line 193
  if (mosq) {
#line 193
    mosq->message_retry = message_retry;
  }
#line 194
  return;
}
}
#line 196 "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c"
int _mosquitto_message_update(struct mosquitto *mosq , uint16_t mid , enum mosquitto_msg_direction dir ,
                              enum mosquitto_msg_state state ) 
{ 
  struct mosquitto_message_all *message___0 ;

  {
#line 199
  if (! mosq) {
    {
#line 199
    __assert_fail("mosq", "/home/wheatley/newnew/temp/mosquitto-0.15/lib/messages_mosq.c",
                  199U, "_mosquitto_message_update");
    }
  }
#line 201
  message___0 = mosq->messages;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! message___0) {
#line 202
      goto while_break;
    }
#line 203
    if ((int )message___0->msg.mid == (int )mid) {
#line 203
      if ((unsigned int )message___0->direction == (unsigned int )dir) {
        {
#line 204
        message___0->state = state;
#line 205
        message___0->timestamp = time((time_t *)((void *)0));
        }
#line 206
        return (0);
      }
    }
#line 208
    message___0 = message___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (6);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 427
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen )  __asm__("__xpg_strerror_r")  ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 44 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
static char **topics  =    (char **)((void *)0);
#line 45 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
static int topic_count  =    0;
#line 46 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
static int topic_qos  =    0;
#line 47 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
static char *username  =    (char *)((void *)0);
#line 48 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
static char *password  =    (char *)((void *)0);
#line 49 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
int verbose  =    0;
#line 50 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
_Bool quiet  =    (_Bool)0;
#line 52 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
void my_message_callback(void *obj , struct mosquitto_message  const  *message___0 ) 
{ 


  {
#line 54
  if (verbose) {
#line 55
    if (message___0->payloadlen) {
      {
#line 56
      printf((char const   */* __restrict  */)"%s %s\n", message___0->topic, message___0->payload);
      }
    } else {
      {
#line 58
      printf((char const   */* __restrict  */)"%s (null)\n", message___0->topic);
      }
    }
    {
#line 60
    fflush(stdout);
    }
  } else
#line 62
  if (message___0->payloadlen) {
    {
#line 63
    printf((char const   */* __restrict  */)"%s\n", message___0->payload);
#line 64
    fflush(stdout);
    }
  }
#line 67
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
void my_connect_callback(void *obj , int result ) 
{ 
  struct mosquitto *mosq ;
  int i ;

  {
#line 71
  mosq = (struct mosquitto *)obj;
#line 74
  if (! result) {
#line 75
    i = 0;
    {
#line 75
    while (1) {
      while_continue: /* CIL Label */ ;
#line 75
      if (! (i < topic_count)) {
#line 75
        goto while_break;
      }
      {
#line 76
      mosquitto_subscribe(mosq, (uint16_t *)((void *)0), (char const   *)*(topics + i),
                          topic_qos);
#line 75
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 80
    if (result == 1) {
#line 80
      goto case_1;
    }
#line 83
    if (result == 2) {
#line 83
      goto case_2;
    }
#line 86
    if (result == 3) {
#line 86
      goto case_3;
    }
#line 89
    if (result == 4) {
#line 89
      goto case_4;
    }
#line 92
    if (result == 5) {
#line 92
      goto case_5;
    }
#line 95
    goto switch_default;
    case_1: /* CIL Label */ 
#line 81
    if (! quiet) {
      {
#line 81
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection Refused: unacceptable protocol version\n");
      }
    }
#line 82
    goto switch_break;
    case_2: /* CIL Label */ 
#line 84
    if (! quiet) {
      {
#line 84
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection Refused: identifier rejected\n");
      }
    }
#line 85
    goto switch_break;
    case_3: /* CIL Label */ 
#line 87
    if (! quiet) {
      {
#line 87
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection Refused: broker unavailable\n");
      }
    }
#line 88
    goto switch_break;
    case_4: /* CIL Label */ 
#line 90
    if (! quiet) {
      {
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection Refused: bad user name or password\n");
      }
    }
#line 91
    goto switch_break;
    case_5: /* CIL Label */ 
#line 93
    if (! quiet) {
      {
#line 93
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection Refused: not authorised\n");
      }
    }
#line 94
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 96
    if (! quiet) {
      {
#line 96
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Connection Refused: unknown reason\n");
      }
    }
#line 97
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 100
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
void my_subscribe_callback(void *obj , uint16_t mid , int qos_count , uint8_t const   *granted_qos ) 
{ 
  int i ;

  {
#line 106
  if (! quiet) {
    {
#line 106
    printf((char const   */* __restrict  */)"Subscribed (mid: %d): %d", (int )mid,
           (int const   )*(granted_qos + 0));
    }
  }
#line 107
  i = 1;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < qos_count)) {
#line 107
      goto while_break;
    }
#line 108
    if (! quiet) {
      {
#line 108
      printf((char const   */* __restrict  */)", %d", (int const   )*(granted_qos + i));
      }
    }
#line 107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  if (! quiet) {
    {
#line 110
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 111
  return;
}
}
#line 113 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
void print_usage(void) 
{ 


  {
  {
#line 115
  printf((char const   */* __restrict  */)"mosquitto_sub is a simple mqtt client that will subscribe to a single topic and print all messages it receives.\n\n");
#line 116
  printf((char const   */* __restrict  */)"Usage: mosquitto_sub [-c] [-h host] [-k keepalive] [-p port] [-q qos] [-v] -t topic ...\n");
#line 117
  printf((char const   */* __restrict  */)"                     [-i id] [-I id_prefix]\n");
#line 118
  printf((char const   */* __restrict  */)"                     [-d] [--quiet]\n");
#line 119
  printf((char const   */* __restrict  */)"                     [-u username [-P password]]\n");
#line 120
  printf((char const   */* __restrict  */)"                     [--will-topic [--will-payload payload] [--will-qos qos] [--will-retain]]\n\n");
#line 121
  printf((char const   */* __restrict  */)" -c : disable \'clean session\' (store subscription and pending messages when client disconnects).\n");
#line 122
  printf((char const   */* __restrict  */)" -d : enable debug messages.\n");
#line 123
  printf((char const   */* __restrict  */)" -h : mqtt host to connect to. Defaults to localhost.\n");
#line 124
  printf((char const   */* __restrict  */)" -i : id to use for this client. Defaults to mosquitto_sub_ appended with the process id.\n");
#line 125
  printf((char const   */* __restrict  */)" -I : define the client id as id_prefix appended with the process id. Useful for when the\n");
#line 126
  printf((char const   */* __restrict  */)"      broker is using the clientid_prefixes option.\n");
#line 127
  printf((char const   */* __restrict  */)" -k : keep alive in seconds for this client. Defaults to 60.\n");
#line 128
  printf((char const   */* __restrict  */)" -p : network port to connect to. Defaults to 1883.\n");
#line 129
  printf((char const   */* __restrict  */)" -q : quality of service level to use for the subscription. Defaults to 0.\n");
#line 130
  printf((char const   */* __restrict  */)" -t : mqtt topic to subscribe to. May be repeated multiple times.\n");
#line 131
  printf((char const   */* __restrict  */)" -u : provide a username (requires MQTT 3.1 broker)\n");
#line 132
  printf((char const   */* __restrict  */)" -v : print published messages verbosely.\n");
#line 133
  printf((char const   */* __restrict  */)" -P : provide a password (requires MQTT 3.1 broker)\n");
#line 134
  printf((char const   */* __restrict  */)" --quiet : don\'t print error messages.\n");
#line 135
  printf((char const   */* __restrict  */)" --will-payload : payload for the client Will, which is sent by the broker in case of\n");
#line 136
  printf((char const   */* __restrict  */)"                  unexpected disconnection. If not given and will-topic is set, a zero\n");
#line 137
  printf((char const   */* __restrict  */)"                  length message will be sent.\n");
#line 138
  printf((char const   */* __restrict  */)" --will-qos : QoS level for the client Will.\n");
#line 139
  printf((char const   */* __restrict  */)" --will-retain : if given, make the client Will retained.\n");
#line 140
  printf((char const   */* __restrict  */)" --will-topic : the topic on which to publish the client Will.\n");
#line 141
  printf((char const   */* __restrict  */)"\nSee http://mosquitto.org/ for more information.\n\n");
  }
#line 142
  return;
}
}
#line 144 "/home/wheatley/newnew/temp/mosquitto-0.15/client/sub_client.c"
int main(int argc , char **argv ) 
{ 
  char *id ;
  char *id_prefix ;
  int i ;
  char *host ;
  int port ;
  int keepalive ;
  _Bool clean_session ;
  _Bool debug ;
  struct mosquitto *mosq ;
  int rc ;
  char hostname[21] ;
  char err[1024] ;
  uint8_t *will_payload ;
  long will_payloadlen ;
  int will_qos ;
  _Bool will_retain ;
  char *will_topic ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  void *tmp___31 ;
  __pid_t tmp___32 ;
  size_t tmp___33 ;
  void *tmp___34 ;
  __pid_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;

  {
#line 146
  id = (char *)((void *)0);
#line 147
  id_prefix = (char *)((void *)0);
#line 149
  host = (char *)"localhost";
#line 150
  port = 1883;
#line 151
  keepalive = 60;
#line 152
  clean_session = (_Bool)1;
#line 153
  debug = (_Bool)0;
#line 154
  mosq = (struct mosquitto *)((void *)0);
#line 159
  will_payload = (uint8_t *)((void *)0);
#line 160
  will_payloadlen = 0L;
#line 161
  will_qos = 0;
#line 162
  will_retain = (_Bool)0;
#line 163
  will_topic = (char *)((void *)0);
#line 165
  i = 1;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < argc)) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___28 = strcmp((char const   *)*(argv + i), "-p");
    }
#line 166
    if (tmp___28) {
      {
#line 166
      tmp___29 = strcmp((char const   *)*(argv + i), "--port");
      }
#line 166
      if (tmp___29) {
        {
#line 180
        tmp___26 = strcmp((char const   *)*(argv + i), "-c");
        }
#line 180
        if (tmp___26) {
          {
#line 180
          tmp___27 = strcmp((char const   *)*(argv + i), "--disable-clean-session");
          }
#line 180
          if (tmp___27) {
            {
#line 182
            tmp___24 = strcmp((char const   *)*(argv + i), "-d");
            }
#line 182
            if (tmp___24) {
              {
#line 182
              tmp___25 = strcmp((char const   *)*(argv + i), "--debug");
              }
#line 182
              if (tmp___25) {
                {
#line 184
                tmp___22 = strcmp((char const   *)*(argv + i), "-h");
                }
#line 184
                if (tmp___22) {
                  {
#line 184
                  tmp___23 = strcmp((char const   *)*(argv + i), "--host");
                  }
#line 184
                  if (tmp___23) {
                    {
#line 193
                    tmp___20 = strcmp((char const   *)*(argv + i), "-i");
                    }
#line 193
                    if (tmp___20) {
                      {
#line 193
                      tmp___21 = strcmp((char const   *)*(argv + i), "--id");
                      }
#line 193
                      if (tmp___21) {
                        {
#line 207
                        tmp___18 = strcmp((char const   *)*(argv + i), "-I");
                        }
#line 207
                        if (tmp___18) {
                          {
#line 207
                          tmp___19 = strcmp((char const   *)*(argv + i), "--id-prefix");
                          }
#line 207
                          if (tmp___19) {
                            {
#line 221
                            tmp___16 = strcmp((char const   *)*(argv + i), "-k");
                            }
#line 221
                            if (tmp___16) {
                              {
#line 221
                              tmp___17 = strcmp((char const   *)*(argv + i), "--keepalive");
                              }
#line 221
                              if (tmp___17) {
                                {
#line 235
                                tmp___14 = strcmp((char const   *)*(argv + i), "-q");
                                }
#line 235
                                if (tmp___14) {
                                  {
#line 235
                                  tmp___15 = strcmp((char const   *)*(argv + i), "--qos");
                                  }
#line 235
                                  if (tmp___15) {
                                    {
#line 249
                                    tmp___13 = strcmp((char const   *)*(argv + i),
                                                      "--quiet");
                                    }
#line 249
                                    if (tmp___13) {
                                      {
#line 251
                                      tmp___11 = strcmp((char const   *)*(argv + i),
                                                        "-t");
                                      }
#line 251
                                      if (tmp___11) {
                                        {
#line 251
                                        tmp___12 = strcmp((char const   *)*(argv + i),
                                                          "--topic");
                                        }
#line 251
                                        if (tmp___12) {
                                          {
#line 262
                                          tmp___9 = strcmp((char const   *)*(argv + i),
                                                           "-u");
                                          }
#line 262
                                          if (tmp___9) {
                                            {
#line 262
                                            tmp___10 = strcmp((char const   *)*(argv + i),
                                                              "--username");
                                            }
#line 262
                                            if (tmp___10) {
                                              {
#line 271
                                              tmp___7 = strcmp((char const   *)*(argv + i),
                                                               "-v");
                                              }
#line 271
                                              if (tmp___7) {
                                                {
#line 271
                                                tmp___8 = strcmp((char const   *)*(argv + i),
                                                                 "--verbose");
                                                }
#line 271
                                                if (tmp___8) {
                                                  {
#line 273
                                                  tmp___5 = strcmp((char const   *)*(argv + i),
                                                                   "-P");
                                                  }
#line 273
                                                  if (tmp___5) {
                                                    {
#line 273
                                                    tmp___6 = strcmp((char const   *)*(argv + i),
                                                                     "--pw");
                                                    }
#line 273
                                                    if (tmp___6) {
                                                      {
#line 282
                                                      tmp___4 = strcmp((char const   *)*(argv + i),
                                                                       "--will-payload");
                                                      }
#line 282
                                                      if (tmp___4) {
                                                        {
#line 292
                                                        tmp___3 = strcmp((char const   *)*(argv + i),
                                                                         "--will-qos");
                                                        }
#line 292
                                                        if (tmp___3) {
                                                          {
#line 305
                                                          tmp___2 = strcmp((char const   *)*(argv + i),
                                                                           "--will-retain");
                                                          }
#line 305
                                                          if (tmp___2) {
                                                            {
#line 307
                                                            tmp___1 = strcmp((char const   *)*(argv + i),
                                                                             "--will-topic");
                                                            }
#line 307
                                                            if (tmp___1) {
                                                              {
#line 317
                                                              fprintf((FILE */* __restrict  */)stderr,
                                                                      (char const   */* __restrict  */)"Error: Unknown option \'%s\'.\n",
                                                                      *(argv + i));
#line 318
                                                              print_usage();
                                                              }
#line 319
                                                              return (1);
                                                            } else {
#line 308
                                                              if (i == argc - 1) {
                                                                {
#line 309
                                                                fprintf((FILE */* __restrict  */)stderr,
                                                                        (char const   */* __restrict  */)"Error: --will-topic argument given but no will topic specified.\n\n");
#line 310
                                                                print_usage();
                                                                }
#line 311
                                                                return (1);
                                                              } else {
#line 313
                                                                will_topic = *(argv + (i + 1));
                                                              }
#line 315
                                                              i ++;
                                                            }
                                                          } else {
#line 306
                                                            will_retain = (_Bool)1;
                                                          }
                                                        } else {
#line 293
                                                          if (i == argc - 1) {
                                                            {
#line 294
                                                            fprintf((FILE */* __restrict  */)stderr,
                                                                    (char const   */* __restrict  */)"Error: --will-qos argument given but no will QoS specified.\n\n");
#line 295
                                                            print_usage();
                                                            }
#line 296
                                                            return (1);
                                                          } else {
                                                            {
#line 298
                                                            will_qos = atoi((char const   *)*(argv + (i + 1)));
                                                            }
#line 299
                                                            if (will_qos < 0) {
                                                              {
#line 300
                                                              fprintf((FILE */* __restrict  */)stderr,
                                                                      (char const   */* __restrict  */)"Error: Invalid will QoS %d.\n\n",
                                                                      will_qos);
                                                              }
#line 301
                                                              return (1);
                                                            } else
#line 299
                                                            if (will_qos > 2) {
                                                              {
#line 300
                                                              fprintf((FILE */* __restrict  */)stderr,
                                                                      (char const   */* __restrict  */)"Error: Invalid will QoS %d.\n\n",
                                                                      will_qos);
                                                              }
#line 301
                                                              return (1);
                                                            }
                                                          }
#line 304
                                                          i ++;
                                                        }
                                                      } else {
#line 283
                                                        if (i == argc - 1) {
                                                          {
#line 284
                                                          fprintf((FILE */* __restrict  */)stderr,
                                                                  (char const   */* __restrict  */)"Error: --will-payload argument given but no will payload specified.\n\n");
#line 285
                                                          print_usage();
                                                          }
#line 286
                                                          return (1);
                                                        } else {
                                                          {
#line 288
                                                          will_payload = (uint8_t *)*(argv + (i + 1));
#line 289
                                                          tmp___0 = strlen((char const   *)((char *)will_payload));
#line 289
                                                          will_payloadlen = (long )tmp___0;
                                                          }
                                                        }
#line 291
                                                        i ++;
                                                      }
                                                    } else {
                                                      _L: /* CIL Label */ 
#line 274
                                                      if (i == argc - 1) {
                                                        {
#line 275
                                                        fprintf((FILE */* __restrict  */)stderr,
                                                                (char const   */* __restrict  */)"Error: -P argument given but no password specified.\n\n");
#line 276
                                                        print_usage();
                                                        }
#line 277
                                                        return (1);
                                                      } else {
#line 279
                                                        password = *(argv + (i + 1));
                                                      }
#line 281
                                                      i ++;
                                                    }
                                                  } else {
#line 273
                                                    goto _L;
                                                  }
                                                } else {
#line 272
                                                  verbose = 1;
                                                }
                                              } else {
#line 272
                                                verbose = 1;
                                              }
                                            } else {
                                              _L___0: /* CIL Label */ 
#line 263
                                              if (i == argc - 1) {
                                                {
#line 264
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Error: -u argument given but no username specified.\n\n");
#line 265
                                                print_usage();
                                                }
#line 266
                                                return (1);
                                              } else {
#line 268
                                                username = *(argv + (i + 1));
                                              }
#line 270
                                              i ++;
                                            }
                                          } else {
#line 262
                                            goto _L___0;
                                          }
                                        } else {
                                          _L___1: /* CIL Label */ 
#line 252
                                          if (i == argc - 1) {
                                            {
#line 253
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"Error: -t argument given but no topic specified.\n\n");
#line 254
                                            print_usage();
                                            }
#line 255
                                            return (1);
                                          } else {
                                            {
#line 257
                                            topic_count ++;
#line 258
                                            tmp = realloc((void *)topics, (unsigned long )topic_count * sizeof(char *));
#line 258
                                            topics = (char **)tmp;
#line 259
                                            *(topics + (topic_count - 1)) = *(argv + (i + 1));
                                            }
                                          }
#line 261
                                          i ++;
                                        }
                                      } else {
#line 251
                                        goto _L___1;
                                      }
                                    } else {
#line 250
                                      quiet = (_Bool)1;
                                    }
                                  } else {
                                    _L___2: /* CIL Label */ 
#line 236
                                    if (i == argc - 1) {
                                      {
#line 237
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -q argument given but no QoS specified.\n\n");
#line 238
                                      print_usage();
                                      }
#line 239
                                      return (1);
                                    } else {
                                      {
#line 241
                                      topic_qos = atoi((char const   *)*(argv + (i + 1)));
                                      }
#line 242
                                      if (topic_qos < 0) {
                                        {
#line 243
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid QoS given: %d\n",
                                                topic_qos);
#line 244
                                        print_usage();
                                        }
#line 245
                                        return (1);
                                      } else
#line 242
                                      if (topic_qos > 2) {
                                        {
#line 243
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid QoS given: %d\n",
                                                topic_qos);
#line 244
                                        print_usage();
                                        }
#line 245
                                        return (1);
                                      }
                                    }
#line 248
                                    i ++;
                                  }
                                } else {
#line 235
                                  goto _L___2;
                                }
                              } else {
                                _L___3: /* CIL Label */ 
#line 222
                                if (i == argc - 1) {
                                  {
#line 223
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -k argument given but no keepalive specified.\n\n");
#line 224
                                  print_usage();
                                  }
#line 225
                                  return (1);
                                } else {
                                  {
#line 227
                                  keepalive = atoi((char const   *)*(argv + (i + 1)));
                                  }
#line 228
                                  if (keepalive > 65535) {
                                    {
#line 229
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid keepalive given: %d\n",
                                            keepalive);
#line 230
                                    print_usage();
                                    }
#line 231
                                    return (1);
                                  }
                                }
#line 234
                                i ++;
                              }
                            } else {
#line 221
                              goto _L___3;
                            }
                          } else {
                            _L___4: /* CIL Label */ 
#line 208
                            if (id) {
                              {
#line 209
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -i and -I argument cannot be used together.\n\n");
#line 210
                              print_usage();
                              }
#line 211
                              return (1);
                            }
#line 213
                            if (i == argc - 1) {
                              {
#line 214
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -I argument given but no id prefix specified.\n\n");
#line 215
                              print_usage();
                              }
#line 216
                              return (1);
                            } else {
#line 218
                              id_prefix = *(argv + (i + 1));
                            }
#line 220
                            i ++;
                          }
                        } else {
#line 207
                          goto _L___4;
                        }
                      } else {
                        _L___5: /* CIL Label */ 
#line 194
                        if (id_prefix) {
                          {
#line 195
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -i and -I argument cannot be used together.\n\n");
#line 196
                          print_usage();
                          }
#line 197
                          return (1);
                        }
#line 199
                        if (i == argc - 1) {
                          {
#line 200
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -i argument given but no id specified.\n\n");
#line 201
                          print_usage();
                          }
#line 202
                          return (1);
                        } else {
#line 204
                          id = *(argv + (i + 1));
                        }
#line 206
                        i ++;
                      }
                    } else {
#line 193
                      goto _L___5;
                    }
                  } else {
                    _L___6: /* CIL Label */ 
#line 185
                    if (i == argc - 1) {
                      {
#line 186
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -h argument given but no host specified.\n\n");
#line 187
                      print_usage();
                      }
#line 188
                      return (1);
                    } else {
#line 190
                      host = *(argv + (i + 1));
                    }
#line 192
                    i ++;
                  }
                } else {
#line 184
                  goto _L___6;
                }
              } else {
#line 183
                debug = (_Bool)1;
              }
            } else {
#line 183
              debug = (_Bool)1;
            }
          } else {
#line 181
            clean_session = (_Bool)0;
          }
        } else {
#line 181
          clean_session = (_Bool)0;
        }
      } else {
        _L___7: /* CIL Label */ 
#line 167
        if (i == argc - 1) {
          {
#line 168
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: -p argument given but no port specified.\n\n");
#line 169
          print_usage();
          }
#line 170
          return (1);
        } else {
          {
#line 172
          port = atoi((char const   *)*(argv + (i + 1)));
          }
#line 173
          if (port < 1) {
            {
#line 174
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid port given: %d\n",
                    port);
#line 175
            print_usage();
            }
#line 176
            return (1);
          } else
#line 173
          if (port > 65535) {
            {
#line 174
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid port given: %d\n",
                    port);
#line 175
            print_usage();
            }
#line 176
            return (1);
          }
        }
#line 179
        i ++;
      }
    } else {
#line 166
      goto _L___7;
    }
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if ((int )clean_session == 0) {
#line 322
    if (id_prefix) {
#line 322
      goto _L___8;
    } else
#line 322
    if (! id) {
      _L___8: /* CIL Label */ 
#line 323
      if (! quiet) {
        {
#line 323
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must provide a client id if you are using the -c option.\n");
        }
      }
#line 324
      return (1);
    }
  }
#line 326
  if (id_prefix) {
    {
#line 327
    tmp___30 = strlen((char const   *)id_prefix);
#line 327
    tmp___31 = malloc(tmp___30 + 10UL);
#line 327
    id = (char *)tmp___31;
    }
#line 328
    if (! id) {
#line 329
      if (! quiet) {
        {
#line 329
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory.\n");
        }
      }
#line 330
      return (1);
    }
    {
#line 332
    tmp___32 = getpid();
#line 332
    tmp___33 = strlen((char const   *)id_prefix);
#line 332
    snprintf((char */* __restrict  */)id, tmp___33 + 10UL, (char const   */* __restrict  */)"%s%d",
             id_prefix, tmp___32);
    }
  } else
#line 333
  if (! id) {
    {
#line 334
    tmp___34 = malloc((size_t )30);
#line 334
    id = (char *)tmp___34;
    }
#line 335
    if (! id) {
#line 336
      if (! quiet) {
        {
#line 336
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory.\n");
        }
      }
#line 337
      return (1);
    }
    {
#line 339
    memset((void *)(hostname), 0, (size_t )21);
#line 340
    gethostname(hostname, (size_t )20);
#line 341
    tmp___35 = getpid();
#line 341
    snprintf((char */* __restrict  */)id, (size_t )23, (char const   */* __restrict  */)"mosq_sub_%d_%s",
             tmp___35, hostname);
    }
  }
#line 344
  if (topic_count == 0) {
    {
#line 345
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: You must specify a topic to subscribe to.\n");
#line 346
    print_usage();
    }
#line 347
    return (1);
  }
#line 349
  if (will_payload) {
#line 349
    if (! will_topic) {
      {
#line 350
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Will payload given, but no will topic given.\n");
#line 351
      print_usage();
      }
#line 352
      return (1);
    }
  }
#line 354
  if (will_retain) {
#line 354
    if (! will_topic) {
      {
#line 355
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Will retain given, but no will topic given.\n");
#line 356
      print_usage();
      }
#line 357
      return (1);
    }
  }
#line 359
  if (password) {
#line 359
    if (! username) {
#line 360
      if (! quiet) {
        {
#line 360
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Not using password since username not set.\n");
        }
      }
    }
  }
  {
#line 362
  mosquitto_lib_init();
#line 363
  mosq = mosquitto_new((char const   *)id, (void *)0);
  }
#line 364
  if (! mosq) {
#line 365
    if (! quiet) {
      {
#line 365
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory.\n");
      }
    }
#line 366
    return (1);
  }
#line 368
  if (debug) {
    {
#line 369
    mosquitto_log_init(mosq, 31, 8);
    }
  }
#line 372
  if (will_topic) {
    {
#line 372
    tmp___36 = mosquitto_will_set(mosq, (_Bool)1, (char const   *)will_topic, (uint32_t )will_payloadlen,
                                  (uint8_t const   *)will_payload, will_qos, will_retain);
    }
#line 372
    if (tmp___36) {
#line 373
      if (! quiet) {
        {
#line 373
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Problem setting will.\n");
        }
      }
#line 374
      return (1);
    }
  }
#line 376
  if (username) {
    {
#line 376
    tmp___37 = mosquitto_username_pw_set(mosq, (char const   *)username, (char const   *)password);
    }
#line 376
    if (tmp___37) {
#line 377
      if (! quiet) {
        {
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Problem setting username and password.\n");
        }
      }
#line 378
      return (1);
    }
  }
  {
#line 380
  mosquitto_connect_callback_set(mosq, & my_connect_callback);
#line 381
  mosquitto_message_callback_set(mosq, & my_message_callback);
  }
#line 382
  if (debug) {
    {
#line 383
    mosquitto_subscribe_callback_set(mosq, & my_subscribe_callback);
    }
  }
  {
#line 386
  rc = mosquitto_connect(mosq, (char const   *)host, port, keepalive, clean_session);
  }
#line 387
  if (rc) {
#line 388
    if (! quiet) {
#line 389
      if (rc == 14) {
        {
#line 391
        tmp___38 = __errno_location();
#line 391
        strerror_r(*tmp___38, err, (size_t )1024);
#line 395
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s\n",
                err);
        }
      } else {
        {
#line 397
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to connect (%d).\n",
                rc);
        }
      }
    }
#line 400
    return (rc);
  }
  {
#line 403
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 404
    rc = mosquitto_loop(mosq, -1);
    }
#line 403
    if (! (rc == 0)) {
#line 403
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 407
  mosquitto_destroy(mosq);
#line 408
  mosquitto_lib_cleanup();
  }
#line 410
  return (rc);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 56 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static char *topic  =    (char *)((void *)0);
#line 57 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static char *message  =    (char *)((void *)0);
#line 58 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static long msglen  =    0L;
#line 59 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static int qos  =    0;
#line 60 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static int retain  =    0;
#line 61 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static int mode  =    0;
#line 62 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static int status  =    0;
#line 63 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static uint16_t mid_sent  =    (uint16_t )0;
#line 64 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static _Bool connected  =    (_Bool)1;
#line 65 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static char *username___0  =    (char *)((void *)0);
#line 66 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static char *password___0  =    (char *)((void *)0);
#line 67 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static _Bool disconnect_sent  =    (_Bool)0;
#line 68 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
static _Bool quiet___0  =    (_Bool)0;
#line 135 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
void my_disconnect_callback(void *obj ) 
{ 


  {
#line 137
  connected = (_Bool)0;
#line 138
  return;
}
}
#line 140 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
void my_publish_callback(void *obj , uint16_t mid ) 
{ 
  struct mosquitto *mosq ;

  {
#line 142
  mosq = (struct mosquitto *)obj;
#line 144
  if (mode != 2) {
#line 144
    if ((int )disconnect_sent == 0) {
      {
#line 145
      mosquitto_disconnect(mosq);
#line 146
      disconnect_sent = (_Bool)1;
      }
    }
  }
#line 148
  return;
}
}
#line 150 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
int load_stdin(void) 
{ 
  long pos ;
  long rlen ;
  char buf[1024] ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 152
  pos = 0L;
#line 155
  mode = 3;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp___1 = feof(stdin);
    }
#line 157
    if (tmp___1) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )1024, (FILE */* __restrict  */)stdin);
#line 158
    rlen = (long )tmp;
#line 159
    tmp___0 = realloc((void *)message, (size_t )(pos + rlen));
#line 159
    message = (char *)tmp___0;
    }
#line 160
    if (! message) {
#line 161
      if (! quiet___0) {
        {
#line 161
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory.\n");
        }
      }
#line 162
      return (1);
    }
    {
#line 164
    memcpy((void */* __restrict  */)(message + pos), (void const   */* __restrict  */)(buf),
           (size_t )rlen);
#line 165
    pos += rlen;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  msglen = pos;
#line 169
  if (! msglen) {
#line 170
    if (! quiet___0) {
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Zero length input.\n");
      }
    }
#line 171
    return (1);
  }
#line 174
  return (0);
}
}
#line 177 "/home/wheatley/newnew/temp/mosquitto-0.15/client/pub_client.c"
int load_file(char const   *filename ) 
{ 
  long pos ;
  long rlen ;
  FILE *fptr ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 180
  fptr = (FILE *)((void *)0);
#line 182
  fptr = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
  }
#line 183
  if (! fptr) {
#line 184
    if (! quiet___0) {
      {
#line 184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unable to open file \"%s\".\n",
              filename);
      }
    }
#line 185
    return (1);
  }
  {
#line 187
  mode = 4;
#line 188
  fseek(fptr, 0L, 2);
#line 189
  msglen = ftell(fptr);
  }
#line 190
  if (msglen > 268435455L) {
    {
#line 191
    fclose(fptr);
    }
#line 192
    if (! quiet___0) {
      {
#line 192
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: File \"%s\" is too large (>268,435,455 bytes).\n",
              filename);
      }
    }
#line 193
    return (1);
  }
#line 195
  if (msglen == 0L) {
    {
#line 196
    fclose(fptr);
    }
#line 197
    if (! quiet___0) {
      {
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: File \"%s\" is empty.\n",
              filename);
      }
    }
#line 198
    return (1);
  }
  {
#line 200
  fseek(fptr, 0L, 0);
#line 201
  tmp = malloc((size_t )msglen);
#line 201
  message = (char *)tmp;
  }
#line 202
  if (! message) {
    {
#line 203
    fclose(fptr);
    }
#line 204
    if (! quiet___0) {
      {
#line 204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Out of memory.\n");
      }
    }
#line 205
    return (1);
  }
#line 207
  pos = 0L;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (pos < msglen)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp___0 = fread((void */* __restrict  */)(message + pos), sizeof(char ), (size_t )(msglen - pos),
                    (FILE */* __restrict  */)fptr);
#line 209
    rlen = (long )tmp___0;
#line 210
    pos += rlen;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  fclose(fptr);
  }
#line 213
  return (0);
}
}
