/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 98 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
struct regexbuf;
#line 98 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
typedef struct regexbuf regex_t;
#line 291 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
struct regexbuf {
   unsigned char *buf ;
   unsigned char *bufend ;
   unsigned int min_length_match ;
   unsigned char *musthave ;
   unsigned char max_paren_level ;
   unsigned char max_lpc_l ;
   unsigned char max_lpc_c ;
   unsigned char paren_info_required ;
   unsigned int anchor_to_start_of_line : 1 ;
   unsigned int fold_acase : 1 ;
   unsigned int fold_kcase : 1 ;
};
#line 18 "/home/wheatley/newnew/temp/lookup-1.08b/lib/virtfile.h"
typedef long fileloc;
#line 52 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct flags {
   unsigned int word : 1 ;
   unsigned int fuzz : 1 ;
   unsigned int fold : 1 ;
   unsigned int highlight : 1 ;
   unsigned int filter : 1 ;
   unsigned int modify : 1 ;
   unsigned int autokana : 1 ;
   unsigned int tag : 1 ;
   unsigned int display : 1 ;
   unsigned int glob : 1 ;
   unsigned int debug : 1 ;
   unsigned int regex_debug : 1 ;
   unsigned int cmd_debug : 1 ;
   unsigned int verbose : 1 ;
   unsigned int hl_style : 4 ;
};
#line 106
struct fileinfo;
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct__modify__29 {
   unsigned char const   *pattern ;
   regex_t regex ;
   unsigned char const   *replacement ;
   unsigned int global ;
};
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct__filter__30 {
   unsigned char const   *pattern ;
   regex_t regex ;
   unsigned char const   *name ;
   unsigned int negative : 1 ;
};
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct_onefile_28 {
   struct __anonstruct__modify__29 _modify_ ;
   struct __anonstruct__filter__30 _filter_ ;
   unsigned char const   *_tag_ ;
   unsigned char const   *_highlight_tag_ ;
};
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct__combo__31 {
   unsigned char const   *name ;
   unsigned char entries ;
   unsigned char entry[10] ;
};
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
union __anonunion_onefile_or_combo_27 {
   struct __anonstruct_onefile_28 onefile ;
   struct __anonstruct__combo__31 _combo_ ;
};
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct slot_info {
   struct flags default_flag ;
   struct flags current_flag ;
   unsigned char const   *prompt_format ;
   struct fileinfo *file ;
   union __anonunion_onefile_or_combo_27 onefile_or_combo ;
};
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct_count_32 {
   unsigned long checked ;
   unsigned long matched ;
   unsigned long printed ;
   unsigned long nonword ;
   unsigned long filtered ;
};
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct_array_34 {
   struct slot_info  const  *slot ;
   fileloc line ;
};
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct_list_33 {
   struct __anonstruct_array_34 *array ;
   unsigned int size ;
   unsigned int used ;
   unsigned int overflow ;
};
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct_search_35 {
   unsigned char const   *pattern ;
   regex_t regex ;
   unsigned char not ;
};
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct __anonstruct_spinner_36 {
   unsigned char const   *chars ;
   unsigned short interval ;
   unsigned char char_count ;
};
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct lookup {
   struct flags flag ;
   unsigned char cmdstart_char ;
   unsigned char percent ;
   long max_lines_to_print ;
   long lines_to_print_this_time ;
   unsigned char const   *prompt_format ;
   struct slot_info *slot_info[10] ;
   unsigned int slots ;
   struct slot_info *default_slot ;
   struct slot_info *slot ;
   unsigned char const   *where ;
   char const   *prog ;
   char const   *prog_short ;
   struct __anonstruct_count_32 count ;
   struct __anonstruct_list_33 list ;
   struct __anonstruct_search_35 search[10] ;
   int patterns ;
   struct __anonstruct_spinner_36 spinner ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 54 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
enum __anonenum_type_39 {
    UNSIGNED_LONG = 0,
    SIGNED_LONG = 1
} ;
#line 54 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
struct __anonstruct_symtab_38 {
   unsigned char const   *name ;
   unsigned char namelen ;
   enum __anonenum_type_39 type ;
   void *pointer ;
};
#line 73
enum prec {
    P_EQUAL = 0,
    P_BOOL = 1,
    P_PLUS = 2,
    P_MULT = 3,
    P_HIGH = 4
} ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 338 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
enum __anonenum_mode_29 {
    ASCII = 0,
    KATAKANA = 1,
    _X_ = 2,
    JIS208 = 3,
    JIS212 = 4
} ;
#line 55 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.h"
struct romaji2kana_info {
   unsigned short k_buf_used ;
   unsigned short modified ;
};
#line 82 "/home/wheatley/newnew/temp/lookup-1.08b/lib/std_romaji.c"
struct __anonstruct_last_forced_25 {
   unsigned char *start ;
   unsigned char *orig ;
   unsigned char *new ;
   unsigned int orig_len ;
   unsigned int new_len ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/home/wheatley/newnew/temp/lookup-1.08b/lib/virtfile.h"
struct __anonstruct_VirtFile_29 {
   int fd ;
   char const   *filename ;
   fileloc length ;
};
#line 23 "/home/wheatley/newnew/temp/lookup-1.08b/lib/virtfile.h"
typedef struct __anonstruct_VirtFile_29 VirtFile;
#line 63 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
typedef unsigned long IndexOffset;
#line 70 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
typedef unsigned long TextOffset;
#line 124 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
struct __anonstruct_hi_31 {
   unsigned char first_lo ;
   unsigned char end_lo ;
   IndexOffset listcount ;
   IndexOffset shifted_lo ;
};
#line 124 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
struct index {
   unsigned int magic ;
   unsigned short version_major ;
   unsigned short version_minor ;
   unsigned int indexsize ;
   unsigned int linecount ;
   unsigned int limitcount ;
   FILE *FileP ;
   time_t st__mtime ;
   struct __anonstruct_hi_31 hi[128] ;
};
#line 154 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
typedef unsigned short elementcount;
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
struct fullindex_entry {
   unsigned int count ;
   unsigned int count2 ;
   TextOffset lastentered ;
   int mem_needed ;
   unsigned char *listptr ;
};
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
struct fullindex {
   struct fullindex_entry char_info[128][128] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 43 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.h"
typedef void (*romaji_converter_t)(unsigned char *buffer , unsigned char const   *bufend ,
                                   unsigned char **cursorloc , unsigned char const   **eol ,
                                   int force );
#line 135 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
struct history_struct {
   struct history_struct *h_prev ;
   struct history_struct *h_next ;
   unsigned char const   *h_text ;
};
#line 755
enum jis_mode {
    ascii = 0,
    roman = 0,
    jis78 = 1,
    jis83 = 1,
    jis90 = 1,
    hw_kata = 2
} ;
#line 767
enum hi_bit_mode {
    EUC = 0,
    SJIS = 1
} ;
#line 784 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
struct __anonstruct_escape_29 {
   unsigned char const   *string ;
   enum jis_mode mode ;
   int marker ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h"
typedef long MemLoc;
#line 25 "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h"
struct __anonstruct_MemItem_29 {
   FILE *fp ;
   unsigned char *data ;
   MemLoc start ;
   MemLoc end ;
   MemLoc loc ;
   unsigned int datalen ;
};
#line 25 "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h"
typedef struct __anonstruct_MemItem_29 MemItem;
#line 31 "/home/wheatley/newnew/temp/lookup-1.08b/lib/loadfile.h"
struct fileinfo {
   VirtFile *v ;
   char const   *short_filename ;
   struct index  const  *index ;
   char const   *indexfile ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 223 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
struct __anonstruct_matched_paren_t_29 {
   unsigned char const   *match_start ;
   unsigned char const   *match_end ;
};
#line 223 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
typedef struct __anonstruct_matched_paren_t_29 matched_paren_t;
#line 261 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
enum __anonenum_is_xterm_44 {
    unchecked = 0,
    yes = 1,
    no = 2
} ;
#line 1692 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
struct command {
   unsigned int flags ;
   unsigned char const   *usage ;
   unsigned char const   *help ;
   unsigned char const   *pattern ;
   int (*function)(void) ;
   regex_t compiled ;
};
#line 54 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
struct __anonstruct_romaji1_25 {
   unsigned char const   romaji[1] ;
   unsigned char const   kana[2] ;
   unsigned char const   flags ;
};
#line 69 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
struct __anonstruct_romaji2_26 {
   unsigned char const   romaji[2] ;
   unsigned char const   kana[4] ;
   unsigned char const   flags ;
};
#line 171 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
struct __anonstruct_romaji3_27 {
   unsigned char const   romaji[3] ;
   unsigned char const   kana[4] ;
   unsigned char const   flags ;
};
#line 311 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
struct regex_stats {
   int states_pushed ;
   int states_popped ;
   int max_state_depth ;
   int parens_pushed ;
   int parens_popped ;
   int parens_entered ;
   int parens_saved ;
   int cycles ;
   int matches ;
   int failures ;
   int tests ;
};
#line 338 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
enum TYPE {
    UNUSED = 0,
    EXACT1 = 1,
    EXACT2 = 2,
    EITHER_EXACT_2 = 3,
    EXACT3 = 4,
    EXACT_ICASE_ASCII = 5,
    EXACT_ICASE_KANA = 6,
    ANY_CHAR = 7,
    ANY_ASCII = 8,
    ANY_MULTIBYTE = 9,
    ANY_KATAKANA = 10,
    ANY_NONKATAKANA = 11,
    ANY_HIRAGANA = 12,
    ANY_NONHIRAGANA = 13,
    ANY_KANJI = 14,
    ANY_NONKANJI = 15,
    CLASS = 16,
    count_ok_limit = 17,
    REGEX_MATCH = 18,
    REGEX_MATCH_NOTE_WORD = 19,
    WORD_BOUNDARY = 20,
    START_OF_LINE = 21,
    END_OF_LINE = 22,
    JUMP = 23,
    PUSH = 24,
    PUSH_JUMP = 25,
    SAVE_OPEN_PAREN = 26,
    SAVE_CLOSE_PAREN = 27,
    SAVE_CLOSE_PAREN_PUSH_JUMP = 28,
    PUSH_SAVE_OPEN_PAREN = 29,
    MATCH_PREV_PAREN = 30,
    OPEN_PAREN = 31,
    ALT = 32
} ;
#line 991 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
struct dynamic_string {
   unsigned char *buf ;
   unsigned short buf_used ;
   unsigned short buf_length ;
};
#line 1024 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
struct __anonstruct_paren_info_27 {
   struct intermediate *paren ;
   unsigned char level ;
   unsigned char max_internal_level ;
   char real ;
};
#line 1024 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
struct class {
   char inverted ;
   unsigned char ascii[128] ;
   struct dynamic_string euc2 ;
   struct dynamic_string euc3 ;
};
#line 1024 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
union __anonunion_u_26 {
   struct intermediate *alt ;
   struct __anonstruct_paren_info_27 paren_info ;
   unsigned char exact[4] ;
   struct class *class ;
   unsigned int prev_paren_to_match ;
};
#line 1024 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
struct intermediate {
   enum TYPE type ;
   unsigned char count ;
   struct intermediate *next ;
   struct intermediate  const  *parent ;
   struct intermediate *nextalt ;
   unsigned int regex_bytes_needed ;
   unsigned int min_match_len ;
   int must_match ;
   union __anonunion_u_26 u ;
};
#line 3316 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
struct statestruct {
   unsigned char const   *b ;
   unsigned char const   *line ;
   short highest_paren_seen ;
   unsigned char pushed_paren_count ;
   unsigned char pushed_paren_start ;
};
#line 31 "/home/wheatley/newnew/temp/lookup-1.08b/lib/euc.h"
unsigned char const   euc_info[256] ;
#line 23 "/home/wheatley/newnew/temp/lookup-1.08b/lib/euc.c"
unsigned char const   euc_info[256]  = 
#line 23 "/home/wheatley/newnew/temp/lookup-1.08b/lib/euc.c"
  {      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )((2 << 2) | 2),      (unsigned char const   )((3 << 2) | 3), 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )((1 << 2) | 2), 
        (unsigned char const   )((1 << 2) | 2),      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 52 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.h"
int outputf(char const   *fmt  , ...) ;
#line 96
void volatile   die(char const   *fmt  , ...) ;
#line 240 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct lookup lookup ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 14 "/home/wheatley/newnew/temp/lookup-1.08b/eval.h"
int eval(unsigned char const   *expression_string ) ;
#line 25
int eval_error_val ;
#line 26
unsigned char const   *eval_errstr[7] ;
#line 27 "/home/wheatley/newnew/temp/lookup-1.08b/eval.h"
unsigned char const   *eval_error_loc  ;
#line 32 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
static jmp_buf top_level  ;
#line 34 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
unsigned char const   *eval_errstr[7]  = {      (unsigned char const   *)"ok",      (unsigned char const   *)"syntax error",      (unsigned char const   *)"division by zero",      (unsigned char const   *)"end of string unexpected", 
        (unsigned char const   *)"unknown symbol",      (unsigned char const   *)"unmatched close paren",      (unsigned char const   *)"unmatched open paren"};
#line 47 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
int eval_error_val  =    0;
#line 50 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
static unsigned char const   *str  ;
#line 51 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
static unsigned long true  =    1UL;
#line 52 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
static unsigned long false  =    0UL;
#line 54 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
static struct __anonstruct_symtab_38 symtab[7]  = {      {(unsigned char const   *)"checked", (unsigned char )(sizeof("checked") - 1UL),
      (enum __anonenum_type_39 )0, (void *)(& lookup.count.checked)}, 
        {(unsigned char const   *)"matched", (unsigned char )(sizeof("matched") - 1UL),
      (enum __anonenum_type_39 )0, (void *)(& lookup.count.matched)}, 
        {(unsigned char const   *)"printed", (unsigned char )(sizeof("printed") - 1UL),
      (enum __anonenum_type_39 )0, (void *)(& lookup.count.printed)}, 
        {(unsigned char const   *)"nonword", (unsigned char )(sizeof("nonword") - 1UL),
      (enum __anonenum_type_39 )0, (void *)(& lookup.count.nonword)}, 
        {(unsigned char const   *)"filtered", (unsigned char )(sizeof("filtered") - 1UL),
      (enum __anonenum_type_39 )0, (void *)(& lookup.count.filtered)}, 
        {(unsigned char const   *)"true", (unsigned char )(sizeof("true") - 1UL), (enum __anonenum_type_39 )0,
      (void *)(& true)}, 
        {(unsigned char const   *)"false", (unsigned char )(sizeof("false") - 1UL), (enum __anonenum_type_39 )0,
      (void *)(& false)}};
#line 76 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
static int evaluate(int level , enum prec plevel , int doit ) 
{ 
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int i ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int val2 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 78
  val = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((int const   )*(str + 0) == 32)) {
#line 81
      if (! ((int const   )*(str + 0) == 9)) {
#line 81
        goto while_break;
      }
    }
#line 82
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (lookup.flag.debug) {
    {
#line 86
    outputf("EVALU: level %d, plevel %d, val %2d, doit %d: {%s}\n", level, (unsigned int )plevel,
            val, doit, str);
    }
  }
  {
#line 92
  if ((int const   )*(str + 0) == 0) {
#line 92
    goto case_0;
  }
#line 95
  if ((int const   )*(str + 0) == 40) {
#line 95
    goto case_40;
  }
#line 103
  if ((int const   )*(str + 0) == 41) {
#line 103
    goto case_41;
  }
#line 106
  if ((int const   )*(str + 0) == 33) {
#line 106
    goto case_33;
  }
#line 111
  if ((int const   )*(str + 0) == 45) {
#line 111
    goto case_45;
  }
#line 116
  if ((int const   )*(str + 0) == 43) {
#line 116
    goto case_43;
  }
#line 122
  if ((int const   )*(str + 0) == 57) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 56) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 55) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 54) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 53) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 52) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 51) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 50) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 49) {
#line 122
    goto case_57;
  }
#line 122
  if ((int const   )*(str + 0) == 48) {
#line 122
    goto case_57;
  }
#line 127
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 93
  longjmp((struct __jmp_buf_tag *)(top_level), 3);
  }
  case_40: /* CIL Label */ 
  {
#line 96
  str ++;
#line 97
  val = evaluate(level + 1, (enum prec )0, doit);
  }
#line 98
  if ((int const   )*str != 41) {
    {
#line 99
    longjmp((struct __jmp_buf_tag *)(top_level), 6);
    }
  }
#line 100
  str ++;
#line 101
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 104
  longjmp((struct __jmp_buf_tag *)(top_level), 5);
  }
  case_33: /* CIL Label */ 
  {
#line 107
  str ++;
#line 108
  tmp = evaluate(level + 1, (enum prec )4, doit);
  }
#line 108
  if (tmp) {
#line 108
    tmp___0 = 0;
  } else {
#line 108
    tmp___0 = 1;
  }
#line 108
  val = tmp___0;
#line 109
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 112
  str ++;
#line 113
  tmp___1 = evaluate(level + 1, (enum prec )4, doit);
#line 113
  val = - tmp___1;
  }
#line 114
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 117
  str ++;
#line 118
  val = evaluate(level + 1, (enum prec )4, doit);
  }
#line 119
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 123
  val = (int )((int const   )*(str + 0) - 48);
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 124
    str ++;
#line 124
    if (((int const   )*(str + 0) & -128) == 0) {
      {
#line 124
      tmp___2 = __ctype_b_loc();
      }
#line 124
      if ((int const   )*(*tmp___2 + (int )*(str + 0)) & 2048) {
#line 124
        tmp___3 = 1;
      } else {
#line 124
        tmp___3 = 0;
      }
    } else {
#line 124
      tmp___3 = 0;
    }
#line 124
    if (! tmp___3) {
#line 124
      goto while_break___0;
    }
#line 125
    val = val * 10 + (int )((int const   )*(str + 0) - 48);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 126
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 128
  if (! (((int const   )*(str + 0) & -128) == 0)) {
    {
#line 129
    longjmp((struct __jmp_buf_tag *)(top_level), 1);
    }
  } else {
    {
#line 128
    tmp___6 = __ctype_b_loc();
    }
#line 128
    if ((int const   )*(*tmp___6 + (int )*(str + 0)) & 1024) {
#line 133
      i = 0;
      {
#line 133
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 133
        if (! ((unsigned long )i < sizeof(symtab) / sizeof(symtab[0]))) {
#line 133
          goto while_break___1;
        }
        {
#line 134
        tmp___4 = __ctype_b_loc();
        }
#line 134
        if (! ((int const   )*(*tmp___4 + (int )*(str + symtab[i].namelen)) & 8)) {
          {
#line 134
          tmp___5 = strncmp((char const   *)str, (char const   *)symtab[i].name, (size_t )symtab[i].namelen);
          }
#line 134
          if (tmp___5 == 0) {
#line 136
            goto while_break___1;
          }
        }
#line 133
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 138
      if ((unsigned long )i >= sizeof(symtab) / sizeof(symtab[0])) {
        {
#line 139
        longjmp((struct __jmp_buf_tag *)(top_level), 4);
        }
      }
#line 140
      str += (int )symtab[i].namelen;
      {
#line 144
      if ((unsigned int )symtab[i].type == 0U) {
#line 144
        goto case_0___0;
      }
#line 147
      if ((unsigned int )symtab[i].type == 1U) {
#line 147
        goto case_1;
      }
#line 142
      goto switch_default___0;
      switch_default___0: /* CIL Label */ 
      {
#line 143
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 143
        die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/eval.c",
            143);
        }
#line 143
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      case_0___0: /* CIL Label */ 
#line 145
      val = (int )*((unsigned long *)symtab[i].pointer);
#line 146
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 148
      val = (int )*((long *)symtab[i].pointer);
#line 149
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 129
      longjmp((struct __jmp_buf_tag *)(top_level), 1);
      }
    }
  }
#line 152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  again: 
  {
#line 157
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 157
    if (! ((int const   )*(str + 0) == 32)) {
#line 157
      if (! ((int const   )*(str + 0) == 9)) {
#line 157
        goto while_break___3;
      }
    }
#line 158
    str ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 163
  if (lookup.flag.debug) {
    {
#line 164
    outputf("EVALU: level %d, plevel %d, val %2d, doit %d: {%s}\n", level, (unsigned int )plevel,
            val, doit, str);
    }
  }
  {
#line 176
  if ((int const   )*(str + 0) == 41) {
#line 176
    goto case_41___0;
  }
#line 180
  if ((int const   )*(str + 0) == 0) {
#line 180
    goto case_0___1;
  }
#line 183
  if ((int const   )*(str + 0) == 42) {
#line 183
    goto case_42;
  }
#line 190
  if ((int const   )*(str + 0) == 47) {
#line 190
    goto case_47;
  }
#line 202
  if ((int const   )*(str + 0) == 43) {
#line 202
    goto case_43___0;
  }
#line 209
  if ((int const   )*(str + 0) == 45) {
#line 209
    goto case_45___0;
  }
#line 216
  if ((int const   )*(str + 0) == 38) {
#line 216
    goto case_38;
  }
#line 226
  if ((int const   )*(str + 0) == 124) {
#line 226
    goto case_124;
  }
#line 236
  if ((int const   )*(str + 0) == 61) {
#line 236
    goto case_61;
  }
#line 245
  if ((int const   )*(str + 0) == 33) {
#line 245
    goto case_33___0;
  }
#line 172
  goto syntax_error;
  syntax_error: 
  switch_default___1: /* CIL Label */ 
  {
#line 174
  longjmp((struct __jmp_buf_tag *)(top_level), 1);
  }
  case_41___0: /* CIL Label */ 
#line 177
  if (level == 0) {
    {
#line 178
    longjmp((struct __jmp_buf_tag *)(top_level), 6);
    }
  }
  case_0___1: /* CIL Label */ 
#line 181
  return (val);
  case_42: /* CIL Label */ 
#line 184
  if ((unsigned int )plevel > 3U) {
#line 185
    return (val);
  }
#line 186
  str ++;
#line 187
  if ((unsigned int )plevel < 3U) {
#line 187
    tmp___7 = 3;
  } else {
#line 187
    tmp___7 = 4;
  }
  {
#line 187
  tmp___8 = evaluate(level + 1, (enum prec )tmp___7, doit);
#line 187
  val *= tmp___8;
  }
#line 188
  goto switch_break___1;
  case_47: /* CIL Label */ 
#line 191
  if ((unsigned int )plevel > 3U) {
#line 192
    return (val);
  }
#line 193
  str ++;
#line 194
  if ((unsigned int )plevel < 3U) {
#line 194
    tmp___9 = 3;
  } else {
#line 194
    tmp___9 = 4;
  }
  {
#line 194
  val2 = evaluate(level + 1, (enum prec )tmp___9, doit);
  }
#line 195
  if (doit) {
#line 196
    if (val2 == 0) {
      {
#line 197
      longjmp((struct __jmp_buf_tag *)(top_level), 2);
      }
    }
#line 198
    val /= val2;
  }
#line 200
  goto switch_break___1;
  case_43___0: /* CIL Label */ 
#line 203
  if ((unsigned int )plevel > 2U) {
#line 204
    return (val);
  }
#line 205
  str ++;
#line 206
  if ((unsigned int )plevel < 2U) {
#line 206
    tmp___10 = 2;
  } else {
#line 206
    tmp___10 = 3;
  }
  {
#line 206
  tmp___11 = evaluate(level + 1, (enum prec )tmp___10, doit);
#line 206
  val += tmp___11;
  }
#line 207
  goto switch_break___1;
  case_45___0: /* CIL Label */ 
#line 210
  if ((unsigned int )plevel > 2U) {
#line 211
    return (val);
  }
#line 212
  str ++;
#line 213
  if ((unsigned int )plevel < 2U) {
#line 213
    tmp___12 = 2;
  } else {
#line 213
    tmp___12 = 3;
  }
  {
#line 213
  tmp___13 = evaluate(level + 1, (enum prec )tmp___12, doit);
#line 213
  val -= tmp___13;
  }
#line 214
  goto switch_break___1;
  case_38: /* CIL Label */ 
#line 217
  if ((unsigned int )plevel > 1U) {
#line 218
    return (val);
  }
#line 219
  str ++;
#line 220
  if ((int const   )*(str + 0) == 38) {
#line 221
    str ++;
  }
#line 222
  if (doit) {
#line 222
    if (val) {
#line 222
      tmp___14 = 1;
    } else {
#line 222
      tmp___14 = 0;
    }
  } else {
#line 222
    tmp___14 = 0;
  }
#line 222
  if ((unsigned int )plevel < 1U) {
#line 222
    tmp___15 = 1;
  } else {
#line 222
    tmp___15 = 2;
  }
  {
#line 222
  val2 = evaluate(level + 1, (enum prec )tmp___15, tmp___14);
  }
#line 223
  if (val) {
#line 223
    if (val2) {
#line 223
      tmp___16 = 1;
    } else {
#line 223
      tmp___16 = 0;
    }
  } else {
#line 223
    tmp___16 = 0;
  }
#line 223
  val = tmp___16;
#line 224
  goto switch_break___1;
  case_124: /* CIL Label */ 
#line 227
  if ((unsigned int )plevel > 1U) {
#line 228
    return (val);
  }
#line 229
  str ++;
#line 230
  if ((int const   )*(str + 0) == 124) {
#line 231
    str ++;
  }
#line 232
  if (doit) {
#line 232
    if (! val) {
#line 232
      tmp___17 = 1;
    } else {
#line 232
      tmp___17 = 0;
    }
  } else {
#line 232
    tmp___17 = 0;
  }
#line 232
  if ((unsigned int )plevel < 1U) {
#line 232
    tmp___18 = 1;
  } else {
#line 232
    tmp___18 = 2;
  }
  {
#line 232
  val2 = evaluate(level + 1, (enum prec )tmp___18, tmp___17);
  }
#line 233
  if (val) {
#line 233
    tmp___19 = 1;
  } else
#line 233
  if (val2) {
#line 233
    tmp___19 = 1;
  } else {
#line 233
    tmp___19 = 0;
  }
#line 233
  val = tmp___19;
#line 234
  goto switch_break___1;
  case_61: /* CIL Label */ 
#line 237
  if ((unsigned int )plevel > 0U) {
#line 238
    return (val);
  }
#line 239
  str ++;
#line 240
  if ((int const   )*(str + 0) == 61) {
#line 241
    str ++;
  }
  {
#line 242
  tmp___20 = evaluate(level + 1, (enum prec )0, doit);
#line 242
  val = val == tmp___20;
  }
#line 243
  goto switch_break___1;
  case_33___0: /* CIL Label */ 
#line 246
  if ((int const   )*(str + 1) != 61) {
#line 247
    goto syntax_error;
  }
#line 248
  if ((unsigned int )plevel > 0U) {
#line 249
    return (val);
  }
  {
#line 250
  str += 2;
#line 251
  tmp___21 = evaluate(level + 1, (enum prec )0, doit);
#line 251
  val = val != tmp___21;
  }
#line 252
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 255
  goto again;
}
}
#line 259 "/home/wheatley/newnew/temp/lookup-1.08b/eval.c"
int eval(unsigned char const   *expression_string ) 
{ 
  int tmp ;

  {
  {
#line 261
  str = expression_string;
#line 262
  eval_error_val = _setjmp((struct __jmp_buf_tag *)(top_level));
  }
#line 263
  if (eval_error_val) {
#line 265
    eval_error_loc = str;
#line 266
    return (0);
  }
  {
#line 268
  tmp = evaluate(0, (enum prec )0, 1);
  }
#line 268
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 44 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.h"
void output_pager_reset_more(void) ;
#line 45
int output_pager_transparent(int t ) ;
#line 46
unsigned int output_pager_lines(unsigned int new___1 ) ;
#line 47
unsigned int output_pager_columns(unsigned int new___1 ) ;
#line 48
int output_pager_status(int want ) ;
#line 51
void flush_output(void) ;
#line 53
int output(char const   *string ) ;
#line 54
unsigned int (*_output_char_function)(unsigned char  ) ;
#line 55
unsigned long select_output_style(unsigned long mods ) ;
#line 56
void show_output_style(void) ;
#line 57
int set_extra_output_file(int fd ) ;
#line 98
void warn(char const   *fmt  , ...) ;
#line 100
void output_buffer(unsigned char const   *start , unsigned char const   *end ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 34 "/home/wheatley/newnew/temp/lookup-1.08b/lib/input.h"
__inline static unsigned char next_raw_input_byte(void) 
{ 
  unsigned char c ;

  {
  {
#line 38
  read(0, (void *)(& c), (size_t )1);
  }
#line 39
  return (c);
}
}
#line 46
extern int ( /* missing proto */  set_tty_state_to_cbreak)() ;
#line 48
extern int ( /* missing proto */  reset_tty_state)() ;
#line 42 "/home/wheatley/newnew/temp/lookup-1.08b/lib/input.h"
__inline static unsigned char next_cooked_input_byte(void) 
{ 
  unsigned char c ;

  {
  {
#line 46
  set_tty_state_to_cbreak();
#line 47
  c = next_raw_input_byte();
#line 48
  reset_tty_state();
  }
#line 49
  return (c);
}
}
#line 52 "/home/wheatley/newnew/temp/lookup-1.08b/lib/input.h"
__inline static int flush_pending_input(void) 
{ 


  {
#line 55
  return (0);
}
}
#line 27 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned char outbuf[512]  ;
#line 28 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned char *nextout  =    & outbuf[0];
#line 34 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned char const   *jis_start_208  =    (unsigned char const   *)"\033$B";
#line 35 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned char const   *jis_start_212  =    (unsigned char const   *)"\033$(D";
#line 36 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned char const   *jis_start_ASCII  =    (unsigned char const   *)"\033(B";
#line 37 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned char const   *jis_start_kana  =    (unsigned char const   *)"\033(I";
#line 39 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int flush_on_newline  =    1;
#line 40 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static int output_fd  =    1;
#line 41 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned long output_style  =    2179588UL;
#line 48 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static int extra_fd  =    -3;
#line 50 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static void nondisplayable3(unsigned char a , unsigned char b , unsigned char c ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  {
#line 58
  if ((output_style & 61440UL) == 4096UL) {
#line 58
    goto case_4096;
  }
#line 61
  if ((output_style & 61440UL) == 8192UL) {
#line 61
    goto case_8192;
  }
#line 67
  if ((output_style & 61440UL) == 16384UL) {
#line 67
    goto case_16384;
  }
#line 71
  if ((output_style & 61440UL) == 32768UL) {
#line 71
    goto case_32768;
  }
#line 54
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 55
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         55);
    }
#line 55
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  goto switch_break;
  case_4096: /* CIL Label */ 
#line 59
  goto switch_break;
  case_8192: /* CIL Label */ 
#line 62
  tmp = nextout;
#line 62
  nextout ++;
#line 62
  *tmp = a;
#line 63
  tmp___0 = nextout;
#line 63
  nextout ++;
#line 63
  *tmp___0 = b;
#line 64
  tmp___1 = nextout;
#line 64
  nextout ++;
#line 64
  *tmp___1 = c;
#line 65
  goto switch_break;
  case_16384: /* CIL Label */ 
  {
#line 68
  outputf("\\%03\\%03\\%03", (int )a, (int )b, (int )c);
  }
#line 69
  goto switch_break;
  case_32768: /* CIL Label */ 
  {
#line 72
  output("\241\372");
  }
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static void flush_raw_output(void) 
{ 
  unsigned int len ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 79
  len = (unsigned int )(nextout - outbuf);
#line 80
  if (len != 0U) {
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
#line 82
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    if (output_fd >= 0) {
      {
#line 84
      tmp = write(output_fd, (void const   *)(outbuf), (size_t )len);
      }
#line 84
      if (tmp < 0L) {
#line 86
        output_fd = -1;
        {
#line 87
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 87
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 89
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 89
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 90
    if (extra_fd >= 0) {
      {
#line 91
      tmp___0 = write(extra_fd, (void const   *)(outbuf), (size_t )len);
      }
#line 91
      if (tmp___0 < 0L) {
#line 93
        extra_fd = -1;
        {
#line 94
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 94
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 96
    nextout = outbuf;
  }
#line 98
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static int column  ;
#line 105 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static int line  ;
#line 106
unsigned int (*_real_output_char_function)(unsigned char  ) ;
#line 108 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned int screen_height  =    20U;
#line 109 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned int screen_width  =    80U;
#line 128 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned int pager_status  =    2U;
#line 156
unsigned int volatile   apply_regex_abort ;
#line 134 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
__inline static void more(void) 
{ 
  char const   *note ;
  unsigned int len ;
  int i ;
  size_t tmp ;
  unsigned char tmp___0 ;

  {
#line 140
  if ((unsigned long )screen_width > sizeof("--MORE [space=more, return=one more line, (c)ontinue, (q)uit]--")) {
#line 141
    note = "--MORE [space=more, return=one more line, (c)ontinue, (q)uit]--";
  } else
#line 142
  if ((unsigned long )screen_width > sizeof("--MORE [space,return,c,q]--")) {
#line 143
    note = "--MORE [space,return,c,q]--";
  } else {
#line 145
    note = "-MORE-";
  }
  {
#line 146
  tmp = strlen(note);
#line 146
  len = (unsigned int )tmp;
#line 148
  i = 0;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((unsigned int )i < len)) {
#line 148
      goto while_break;
    }
    {
#line 149
    (*_real_output_char_function)((unsigned char )*(note + i));
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  flush_pending_input();
#line 152
  flush_raw_output();
  }
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 157
    tmp___0 = next_cooked_input_byte();
    }
    {
#line 162
    if ((int )tmp___0 == 10) {
#line 162
      goto case_10;
    }
#line 162
    if ((int )tmp___0 == 13) {
#line 162
      goto case_10;
    }
#line 163
    if ((int )tmp___0 == 32) {
#line 163
      goto case_32;
    }
#line 164
    if ((int )tmp___0 == 99) {
#line 164
      goto case_99;
    }
#line 167
    if ((int )tmp___0 == 113) {
#line 167
      goto case_113;
    }
#line 167
    if ((int )tmp___0 == 0) {
#line 167
      goto case_113;
    }
#line 159
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 160
    goto __Cont;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 162
    line = (int )(screen_height - 1U);
#line 162
    goto switch_break;
    case_32: /* CIL Label */ 
#line 163
    line = 0;
#line 163
    goto switch_break;
    case_99: /* CIL Label */ 
#line 164
    line = 0;
#line 164
    pager_status |= 4U;
#line 164
    goto switch_break;
    case_113: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 167
    line = 0;
#line 168
    pager_status &= 4294967293U;
#line 169
    apply_regex_abort = (unsigned int volatile   )1;
#line 169
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 171
    goto while_break___0;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 175
    if (! ((unsigned int )i < len)) {
#line 175
      goto while_break___1;
    }
    {
#line 177
    (*_real_output_char_function)((unsigned char )'\b');
#line 178
    (*_real_output_char_function)((unsigned char )' ');
#line 179
    (*_real_output_char_function)((unsigned char )'\b');
#line 175
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 238
static void pager_output_char_function(unsigned char c ) ;
#line 238 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static int mcount  =    0;
#line 184 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static void pager_output_char_function(unsigned char c ) 
{ 
  unsigned int column_increment ;
  int logging_on ;
  int old_extra_fd ;
  int tmp ;

  {
#line 187
  if ((int )c != 0) {
#line 187
    if (! (pager_status & 3U)) {
#line 188
      return;
    }
  }
#line 190
  if (pager_status & 4U) {
    {
#line 192
    (*_real_output_char_function)(c);
    }
#line 193
    return;
  }
#line 196
  if ((unsigned int )line == screen_height) {
#line 196
    if (column > 0) {
#line 196
      goto _L;
    } else
#line 196
    if ((int )c >= 27) {
#line 196
      goto _L;
    } else {
#line 196
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 196
  if ((unsigned int )line > screen_height) {
    _L: /* CIL Label */ 
#line 199
    logging_on = extra_fd >= 0;
#line 202
    if (logging_on) {
      {
#line 204
      flush_raw_output();
#line 205
      old_extra_fd = extra_fd;
#line 206
      extra_fd = -3;
      }
    }
    {
#line 209
    more();
    }
#line 211
    if (logging_on) {
      {
#line 213
      flush_raw_output();
#line 214
      extra_fd = old_extra_fd;
      }
    }
#line 218
    if (! (pager_status & 3U)) {
#line 219
      return;
    }
  }
#line 222
  if ((int )c == 10) {
#line 222
    goto _L___1;
  } else
#line 222
  if ((int )c == 13) {
    _L___1: /* CIL Label */ 
#line 222
    if ((unsigned int )column == screen_width) {
#line 226
      column = 0;
    } else {
      {
#line 228
      column_increment = (*_real_output_char_function)(c);
      }
    }
  } else {
    {
#line 228
    column_increment = (*_real_output_char_function)(c);
    }
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((unsigned int )column >= screen_width)) {
#line 230
      goto while_break;
    }
#line 232
    line ++;
#line 233
    column = (int )((unsigned int )column - screen_width);
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (! (pager_status & 8U)) {
#line 240
    if ((int )c == 27) {
#line 241
      pager_status &= 4294967263U;
#line 241
      pager_status |= 16U;
    } else
#line 242
    if ((int )c == 91) {
#line 242
      if (pager_status & 16U) {
#line 243
        pager_status |= 32U;
#line 243
        pager_status &= 4294967279U;
#line 244
        mcount = 0;
      } else {
#line 242
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 246
    if (pager_status & 32U) {
#line 246
      if ((int )c != 10) {
#line 246
        if ((int )c != 13) {
#line 247
          tmp = mcount;
#line 247
          mcount ++;
#line 247
          if (tmp > 20) {
#line 248
            pager_status &= 4294967247U;
          } else
#line 247
          if ((int )c == 109) {
#line 248
            pager_status &= 4294967247U;
          }
        } else {
#line 246
          goto _L___3;
        }
      } else {
#line 246
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 256
      if ((int )c == 10) {
#line 256
        goto case_10;
      }
#line 259
      if ((int )c == 13) {
#line 259
        goto case_13;
      }
#line 263
      if ((int )c == 8) {
#line 263
        goto case_8;
      }
#line 252
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 253
      column = (int )((unsigned int )column + column_increment);
#line 254
      goto switch_break;
      case_10: /* CIL Label */ 
#line 257
      line ++;
      case_13: /* CIL Label */ 
#line 260
      pager_status &= 4294967247U;
#line 261
      column = 0;
#line 262
      goto switch_break;
      case_8: /* CIL Label */ 
#line 264
      if (column > 0) {
#line 265
        column --;
      }
#line 266
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 269
  return;
}
}
#line 271 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void output_pager_reset_more(void) 
{ 


  {
#line 273
  line = 0;
#line 274
  pager_status &= 4294967291U;
#line 275
  pager_status |= 2U;
#line 276
  return;
}
}
#line 278 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int output_pager_transparent(int t ) 
{ 
  int was ;
  int tmp ;

  {
#line 280
  if (pager_status & 8U) {
#line 280
    tmp = 1;
  } else {
#line 280
    tmp = 0;
  }
#line 280
  was = tmp;
#line 281
  if (t) {
#line 282
    pager_status |= 8U;
  } else {
#line 284
    pager_status &= 4294967287U;
  }
#line 285
  return (was);
}
}
#line 288 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned int output_pager_lines(unsigned int new___1 ) 
{ 
  unsigned int old ;

  {
#line 290
  old = screen_height;
#line 291
  if (new___1) {
#line 292
    screen_height = new___1;
  }
#line 293
  return (old);
}
}
#line 296 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned int output_pager_columns(unsigned int new___1 ) 
{ 
  unsigned int old ;

  {
#line 298
  old = screen_width;
#line 299
  if (new___1) {
#line 300
    screen_width = new___1;
  }
#line 301
  return (old);
}
}
#line 314 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned int output_euc_as_simple_euc(unsigned char c ) 
{ 
  unsigned int retval ;
  unsigned char *tmp ;

  {
#line 316
  retval = 0U;
#line 318
  if ((int )c != 0) {
#line 321
    if ((int )c != 143) {
#line 321
      if ((int )c >= 32) {
#line 322
        retval = 1U;
      }
    }
#line 324
    tmp = nextout;
#line 324
    nextout ++;
#line 324
    *tmp = c;
#line 325
    if ((int )c == 10) {
#line 325
      if (flush_on_newline) {
        {
#line 326
        flush_raw_output();
        }
      } else {
#line 325
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 325
    if ((unsigned long )nextout >= (unsigned long )(& outbuf[500])) {
      {
#line 326
      flush_raw_output();
      }
    }
  }
#line 328
  return (retval);
}
}
#line 337
static unsigned int output_euc_as_jis(unsigned char c ) ;
#line 337 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned char hi  =    (unsigned char)0;
#line 338 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static enum __anonenum_mode_29 mode  =    (enum __anonenum_mode_29 )0;
#line 375 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned char mid  =    (unsigned char)0;
#line 335 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned int output_euc_as_jis(unsigned char c ) 
{ 
  unsigned int retval ;
  unsigned char const   *ptr ;
  unsigned char *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char a ;
  unsigned char b ;
  unsigned char const   *ptr___0 ;
  unsigned char *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char const   *ptr___1 ;
  unsigned char *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char const   *ptr___2 ;
  unsigned char *tmp___9 ;
  unsigned char const   *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;

  {
#line 339
  retval = 0U;
#line 341
  if (((int )c & 128) == 0) {
#line 343
    if ((unsigned int )mode != 0U) {
#line 345
      ptr = jis_start_ASCII;
      {
#line 346
      while (1) {
        while_continue: /* CIL Label */ ;
#line 346
        if (! *ptr) {
#line 346
          goto while_break;
        }
#line 347
        tmp = nextout;
#line 347
        nextout ++;
#line 347
        tmp___0 = ptr;
#line 347
        ptr ++;
#line 347
        *tmp = (unsigned char )*tmp___0;
      }
      while_break: /* CIL Label */ ;
      }
#line 348
      mode = (enum __anonenum_mode_29 )0;
    }
#line 351
    if ((int )c == 0) {
#line 352
      return (0U);
    }
#line 354
    tmp___1 = nextout;
#line 354
    nextout ++;
#line 354
    *tmp___1 = c;
#line 356
    if ((int )c >= 32) {
#line 357
      retval = 1U;
    }
#line 360
    if ((int )c == 10) {
#line 360
      if (flush_on_newline) {
        {
#line 361
        flush_raw_output();
        }
      } else {
#line 360
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 360
    if ((unsigned long )nextout >= (unsigned long )(& outbuf[500])) {
      {
#line 361
      flush_raw_output();
      }
    }
#line 362
    return (retval);
  }
#line 366
  if ((int )hi == 0) {
#line 369
    hi = c;
#line 370
    return (0U);
  }
#line 373
  if ((int )hi == 143) {
#line 376
    if ((int )mid == 0) {
#line 379
      mid = c;
#line 380
      return (0U);
    }
#line 384
    if (output_style & 2097152UL) {
      {
#line 386
      a = hi;
#line 386
      b = mid;
#line 387
      mid = (unsigned char)0;
#line 387
      hi = mid;
#line 388
      nondisplayable3(a, b, c);
      }
    } else {
#line 390
      if ((unsigned int )mode != 4U) {
#line 392
        ptr___0 = jis_start_212;
        {
#line 393
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 393
          if (! *ptr___0) {
#line 393
            goto while_break___0;
          }
#line 394
          tmp___2 = nextout;
#line 394
          nextout ++;
#line 394
          tmp___3 = ptr___0;
#line 394
          ptr___0 ++;
#line 394
          *tmp___2 = (unsigned char )*tmp___3;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 395
        mode = (enum __anonenum_mode_29 )4;
      }
#line 398
      tmp___4 = nextout;
#line 398
      nextout ++;
#line 398
      *tmp___4 = (unsigned char )((int )mid & 127);
#line 399
      tmp___5 = nextout;
#line 399
      nextout ++;
#line 399
      *tmp___5 = (unsigned char )((int )c & 127);
#line 400
      mid = (unsigned char)0;
#line 400
      hi = mid;
#line 402
      retval = 2U;
    }
  } else
#line 405
  if ((int )hi == 142) {
#line 407
    if ((unsigned int )mode != 1U) {
#line 409
      ptr___1 = jis_start_kana;
      {
#line 410
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (! *ptr___1) {
#line 410
          goto while_break___1;
        }
#line 411
        tmp___6 = nextout;
#line 411
        nextout ++;
#line 411
        tmp___7 = ptr___1;
#line 411
        ptr___1 ++;
#line 411
        *tmp___6 = (unsigned char )*tmp___7;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 412
      mode = (enum __anonenum_mode_29 )1;
    }
#line 415
    tmp___8 = nextout;
#line 415
    nextout ++;
#line 415
    *tmp___8 = (unsigned char )((int )c & 127);
#line 416
    hi = (unsigned char)0;
#line 418
    retval = 1U;
  } else {
#line 422
    if ((unsigned int )mode != 3U) {
#line 424
      ptr___2 = jis_start_208;
      {
#line 425
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 425
        if (! *ptr___2) {
#line 425
          goto while_break___2;
        }
#line 426
        tmp___9 = nextout;
#line 426
        nextout ++;
#line 426
        tmp___10 = ptr___2;
#line 426
        ptr___2 ++;
#line 426
        *tmp___9 = (unsigned char )*tmp___10;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 427
      mode = (enum __anonenum_mode_29 )3;
    }
#line 430
    tmp___11 = nextout;
#line 430
    nextout ++;
#line 430
    *tmp___11 = (unsigned char )((int )hi & 127);
#line 431
    tmp___12 = nextout;
#line 431
    nextout ++;
#line 431
    *tmp___12 = (unsigned char )((int )c & 127);
#line 432
    hi = (unsigned char)0;
#line 434
    retval = 2U;
  }
#line 437
  if ((unsigned long )nextout >= (unsigned long )(& outbuf[500])) {
    {
#line 438
    flush_raw_output();
    }
  }
#line 439
  return (retval);
}
}
#line 444
static unsigned int output_euc_as_sjis(unsigned char c ) ;
#line 444 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned char hi___0  =    (unsigned char)0;
#line 472 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned char mid___0  =    (unsigned char)0;
#line 442 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static unsigned int output_euc_as_sjis(unsigned char c ) 
{ 
  unsigned int retval ;
  unsigned char *tmp ;
  unsigned char a ;
  unsigned char b ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 445
  retval = 0U;
#line 447
  if (((int )c & 128) == 0) {
#line 449
    if ((int )c == 0) {
#line 450
      return (0U);
    }
#line 451
    tmp = nextout;
#line 451
    nextout ++;
#line 451
    *tmp = c;
#line 453
    if ((int )c >= 32) {
#line 454
      retval = 1U;
    }
#line 457
    if ((int )c == 10) {
#line 457
      if (flush_on_newline) {
        {
#line 458
        flush_raw_output();
        }
      } else {
#line 457
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 457
    if ((unsigned long )nextout >= (unsigned long )(& outbuf[500])) {
      {
#line 458
      flush_raw_output();
      }
    }
#line 459
    return (retval);
  }
#line 463
  if ((int )hi___0 == 0) {
#line 466
    hi___0 = c;
#line 467
    return (0U);
  }
#line 470
  if ((int )hi___0 == 143) {
#line 473
    if ((int )mid___0 == 0) {
#line 476
      mid___0 = c;
#line 477
      return (0U);
    }
    {
#line 484
    a = hi___0;
#line 484
    b = mid___0;
#line 485
    mid___0 = (unsigned char)0;
#line 485
    hi___0 = mid___0;
#line 486
    nondisplayable3(a, b, c);
    }
  } else
#line 488
  if ((int )hi___0 == 142) {
#line 491
    tmp___0 = nextout;
#line 491
    nextout ++;
#line 491
    *tmp___0 = c;
#line 492
    hi___0 = (unsigned char)0;
#line 494
    retval = 1U;
  } else {
#line 498
    hi___0 = (unsigned char )((int )hi___0 & 127);
#line 499
    c = (unsigned char )((int )c & 127);
#line 500
    tmp___1 = nextout;
#line 500
    nextout ++;
#line 500
    if ((int )hi___0 < 95) {
#line 500
      tmp___2 = 112;
    } else {
#line 500
      tmp___2 = 176;
    }
#line 500
    *tmp___1 = (unsigned char )((((int )hi___0 + 1) >> 1) + tmp___2);
#line 501
    tmp___3 = nextout;
#line 501
    nextout ++;
#line 501
    if ((int )hi___0 & 1) {
#line 501
      if ((int )c > 95) {
#line 501
        tmp___4 = 32;
      } else {
#line 501
        tmp___4 = 31;
      }
#line 501
      tmp___5 = tmp___4;
    } else {
#line 501
      tmp___5 = 126;
    }
#line 501
    *tmp___3 = (unsigned char )((int )c + tmp___5);
#line 502
    hi___0 = (unsigned char)0;
#line 504
    retval = 2U;
  }
#line 507
  if ((unsigned long )nextout >= (unsigned long )(& outbuf[500])) {
    {
#line 508
    flush_raw_output();
    }
  }
#line 509
  return (retval);
}
}
#line 514 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned int (*_output_char_function)(unsigned char  )  =    & output_euc_as_jis;
#line 516 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int output(char const   *string ) 
{ 
  unsigned char *ptr ;
  unsigned char *tmp ;

  {
#line 518
  ptr = (unsigned char *)string;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! *ptr) {
#line 519
      goto while_break;
    }
    {
#line 520
    tmp = ptr;
#line 520
    ptr ++;
#line 520
    (*_output_char_function)(*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 525 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void output_buffer(unsigned char const   *start , unsigned char const   *end ) 
{ 
  unsigned char const   *tmp ;

  {
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 527
      goto while_break;
    }
    {
#line 528
    tmp = start;
#line 528
    start ++;
#line 528
    (*_output_char_function)((unsigned char )*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  return;
}
}
#line 532 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void flush_output(void) 
{ 


  {
  {
#line 534
  (*_output_char_function)((unsigned char)0);
#line 535
  flush_raw_output();
  }
#line 536
  return;
}
}
#line 635 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
static int vfcnprintf(unsigned int (*function)(unsigned char  ) , char const   *fmt ,
                      va_list ap ) 
{ 
  unsigned char C ;
  unsigned int bytes_out ;
  unsigned char const   *format ;
  unsigned char c ;
  unsigned char const   *fstart ;
  unsigned int argsneeded ;
  int islong ;
  int arg1 ;
  int arg2 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char c___0 ;
  unsigned char c___1 ;
  unsigned int tmp___5 ;
  unsigned char c___2 ;
  unsigned char c___3 ;
  unsigned char const   *tmp___6 ;
  unsigned char c___4 ;
  unsigned char f[128] ;
  unsigned char b[128] ;
  unsigned char *ptr ;
  int value ;
  int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char c___5 ;
  unsigned char f___0[128] ;
  unsigned char b___0[128] ;
  unsigned char *ptr___0 ;
  long value___0 ;
  long tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char c___6 ;
  unsigned char f___1[128] ;
  unsigned char b___1[128] ;
  unsigned char *ptr___1 ;
  double value___1 ;
  double tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char c___7 ;
  char temp_error_buff[20] ;
  char const   *str___0 ;
  char const   *tmp___19 ;
  int errval ;
  int tmp___20 ;
  int *tmp___21 ;
  unsigned char c___8 ;
  char const   *tmp___22 ;
  int leftadjust ;
  int minfieldwidth ;
  char const   *strmax ;
  char const   *ptr___2 ;
  unsigned char const   *tmp___23 ;
  unsigned char const   *tmp___24 ;
  unsigned short const   **tmp___25 ;
  int tmp___26 ;
  int num ;
  unsigned char const   *tmp___27 ;
  unsigned short const   **tmp___28 ;
  int len ;
  unsigned char c___9 ;
  unsigned char c___10 ;
  char const   *tmp___29 ;
  unsigned char c___11 ;
  int tmp___30 ;
  unsigned char const   *tmp___31 ;

  {
#line 639
  bytes_out = 0U;
#line 640
  format = (unsigned char const   *)fmt;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    tmp___31 = format;
#line 657
    format ++;
#line 657
    C = (unsigned char )*tmp___31;
#line 657
    if (! ((int )C != 0)) {
#line 657
      goto while_break;
    }
#line 657
    if ((int )C != 37) {
      {
#line 658
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 658
        c = C;
#line 658
        if (function) {
          {
#line 658
          (*function)(c);
          }
        }
#line 658
        bytes_out ++;
#line 658
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 660
      fstart = format;
#line 661
      argsneeded = 0U;
#line 662
      islong = 0;
#line 665
      if ((int const   )*format == 45) {
#line 666
        format ++;
      }
#line 668
      if ((int const   )*format == 42) {
#line 669
        format ++;
#line 670
        argsneeded ++;
      } else {
        {
#line 671
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 671
          if (((int const   )*format & -128) == 0) {
            {
#line 671
            tmp = __ctype_b_loc();
            }
#line 671
            if (! ((int const   )*(*tmp + (int )*format) & 2048)) {
#line 671
              goto while_break___1;
            }
          } else {
#line 671
            goto while_break___1;
          }
#line 672
          format ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 674
      if ((int const   )*format == 46) {
#line 676
        format ++;
#line 677
        if ((int const   )*format == 42) {
#line 678
          format ++;
#line 679
          argsneeded ++;
        } else {
          {
#line 680
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 680
            if (((int const   )*format & -128) == 0) {
              {
#line 680
              tmp___0 = __ctype_b_loc();
              }
#line 680
              if (! ((int const   )*(*tmp___0 + (int )*format) & 2048)) {
#line 680
                goto while_break___2;
              }
            } else {
#line 680
              goto while_break___2;
            }
#line 681
            format ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 684
      if ((int const   )*format == 108) {
#line 685
        islong = 1;
#line 686
        format ++;
      }
#line 692
      if (argsneeded) {
        {
#line 694
        tmp___1 = __builtin_va_arg(ap, int );
#line 694
        arg1 = tmp___1;
        }
#line 695
        if (argsneeded == 2U) {
          {
#line 696
          tmp___2 = __builtin_va_arg(ap, int );
#line 696
          arg2 = tmp___2;
          }
        }
      }
#line 721
      tmp___3 = format;
#line 721
      format ++;
      {
#line 723
      if ((int const   )*tmp___3 == 37) {
#line 723
        goto case_37;
      }
#line 724
      if ((int const   )*tmp___3 == 99) {
#line 724
        goto case_99;
      }
#line 734
      if ((int const   )*tmp___3 == 117) {
#line 734
        goto case_117;
      }
#line 734
      if ((int const   )*tmp___3 == 111) {
#line 734
        goto case_117;
      }
#line 734
      if ((int const   )*tmp___3 == 120) {
#line 734
        goto case_117;
      }
#line 734
      if ((int const   )*tmp___3 == 100) {
#line 734
        goto case_117;
      }
#line 743
      if ((int const   )*tmp___3 == 85) {
#line 743
        goto case_85;
      }
#line 743
      if ((int const   )*tmp___3 == 79) {
#line 743
        goto case_85;
      }
#line 743
      if ((int const   )*tmp___3 == 88) {
#line 743
        goto case_85;
      }
#line 743
      if ((int const   )*tmp___3 == 68) {
#line 743
        goto case_85;
      }
#line 749
      if ((int const   )*tmp___3 == 103) {
#line 749
        goto case_103;
      }
#line 749
      if ((int const   )*tmp___3 == 71) {
#line 749
        goto case_103;
      }
#line 749
      if ((int const   )*tmp___3 == 101) {
#line 749
        goto case_103;
      }
#line 749
      if ((int const   )*tmp___3 == 69) {
#line 749
        goto case_103;
      }
#line 749
      if ((int const   )*tmp___3 == 102) {
#line 749
        goto case_103;
      }
#line 749
      if ((int const   )*tmp___3 == 70) {
#line 749
        goto case_103;
      }
#line 757
      if ((int const   )*tmp___3 == 78) {
#line 757
        goto case_78;
      }
#line 757
      if ((int const   )*tmp___3 == 110) {
#line 757
        goto case_78;
      }
#line 757
      if ((int const   )*tmp___3 == 115) {
#line 757
        goto case_78;
      }
#line 726
      goto switch_default;
      case_37: /* CIL Label */ 
      {
#line 723
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 723
        c___0 = (unsigned char )'%';
#line 723
        if (function) {
          {
#line 723
          (*function)(c___0);
          }
        }
#line 723
        bytes_out ++;
#line 723
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 723
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 724
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 724
        tmp___5 = __builtin_va_arg(ap, unsigned int );
#line 724
        c___1 = (unsigned char )tmp___5;
        }
#line 724
        if (function) {
          {
#line 724
          (*function)(c___1);
          }
        }
#line 724
        bytes_out ++;
#line 724
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 724
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 727
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 727
        c___2 = (unsigned char )'?';
#line 727
        if (function) {
          {
#line 727
          (*function)(c___2);
          }
        }
#line 727
        bytes_out ++;
#line 727
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 728
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 728
        if (! ((unsigned long )fstart < (unsigned long )format)) {
#line 728
          goto while_break___6;
        }
        {
#line 729
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 729
          tmp___6 = fstart;
#line 729
          fstart ++;
#line 729
          c___3 = (unsigned char )*tmp___6;
#line 729
          if (function) {
            {
#line 729
            (*function)(c___3);
            }
          }
#line 729
          bytes_out ++;
#line 729
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 730
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 730
        c___4 = (unsigned char )'?';
#line 730
        if (function) {
          {
#line 730
          (*function)(c___4);
          }
        }
#line 730
        bytes_out ++;
#line 730
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 731
      goto switch_break;
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 735
      if (! islong) {
        {
#line 737
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 737
          ptr = f;
#line 737
          tmp___8 = __builtin_va_arg(ap, int );
#line 737
          value = tmp___8;
#line 737
          tmp___9 = ptr;
#line 737
          ptr ++;
#line 737
          *tmp___9 = (unsigned char )'%';
          }
          {
#line 737
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 737
            if (! ((unsigned long )fstart < (unsigned long )format)) {
#line 737
              goto while_break___10;
            }
#line 737
            tmp___10 = ptr;
#line 737
            ptr ++;
#line 737
            *tmp___10 = (unsigned char )*fstart;
#line 737
            fstart ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 737
          *ptr = (unsigned char)0;
          {
#line 737
          if (argsneeded == 0U) {
#line 737
            goto case_0;
          }
#line 737
          if (argsneeded == 1U) {
#line 737
            goto case_1;
          }
#line 737
          if (argsneeded == 2U) {
#line 737
            goto case_2;
          }
#line 737
          goto switch_break___0;
          case_0: /* CIL Label */ 
          {
#line 737
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)(f),
                  value);
          }
#line 737
          goto switch_break___0;
          case_1: /* CIL Label */ 
          {
#line 737
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)(f),
                  arg1, value);
          }
#line 737
          goto switch_break___0;
          case_2: /* CIL Label */ 
          {
#line 737
          sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)(f),
                  arg1, arg2, value);
          }
#line 737
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 737
          ptr = b;
          {
#line 737
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 737
            if (! *ptr) {
#line 737
              goto while_break___11;
            }
            {
#line 737
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 737
              c___5 = *ptr;
#line 737
              if (function) {
                {
#line 737
                (*function)(c___5);
                }
              }
#line 737
              bytes_out ++;
#line 737
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 737
            ptr ++;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 737
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 738
        goto switch_break;
      }
      case_85: /* CIL Label */ 
      case_79: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_68: /* CIL Label */ 
      {
#line 744
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 744
        ptr___0 = f___0;
#line 744
        tmp___12 = __builtin_va_arg(ap, long );
#line 744
        value___0 = tmp___12;
#line 744
        tmp___13 = ptr___0;
#line 744
        ptr___0 ++;
#line 744
        *tmp___13 = (unsigned char )'%';
        }
        {
#line 744
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 744
          if (! ((unsigned long )fstart < (unsigned long )format)) {
#line 744
            goto while_break___14;
          }
#line 744
          tmp___14 = ptr___0;
#line 744
          ptr___0 ++;
#line 744
          *tmp___14 = (unsigned char )*fstart;
#line 744
          fstart ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 744
        *ptr___0 = (unsigned char)0;
        {
#line 744
        if (argsneeded == 0U) {
#line 744
          goto case_0___0;
        }
#line 744
        if (argsneeded == 1U) {
#line 744
          goto case_1___0;
        }
#line 744
        if (argsneeded == 2U) {
#line 744
          goto case_2___0;
        }
#line 744
        goto switch_break___1;
        case_0___0: /* CIL Label */ 
        {
#line 744
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)(f___0),
                value___0);
        }
#line 744
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
        {
#line 744
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)(f___0),
                arg1, value___0);
        }
#line 744
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
        {
#line 744
        sprintf((char */* __restrict  */)(b___0), (char const   */* __restrict  */)(f___0),
                arg1, arg2, value___0);
        }
#line 744
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 744
        ptr___0 = b___0;
        {
#line 744
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 744
          if (! *ptr___0) {
#line 744
            goto while_break___15;
          }
          {
#line 744
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 744
            c___6 = *ptr___0;
#line 744
            if (function) {
              {
#line 744
              (*function)(c___6);
              }
            }
#line 744
            bytes_out ++;
#line 744
            goto while_break___16;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 744
          ptr___0 ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 744
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 745
      goto switch_break;
      case_103: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_70: /* CIL Label */ 
      {
#line 750
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 750
        ptr___1 = f___1;
#line 750
        tmp___16 = __builtin_va_arg(ap, double );
#line 750
        value___1 = tmp___16;
#line 750
        tmp___17 = ptr___1;
#line 750
        ptr___1 ++;
#line 750
        *tmp___17 = (unsigned char )'%';
        }
        {
#line 750
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 750
          if (! ((unsigned long )fstart < (unsigned long )format)) {
#line 750
            goto while_break___18;
          }
#line 750
          tmp___18 = ptr___1;
#line 750
          ptr___1 ++;
#line 750
          *tmp___18 = (unsigned char )*fstart;
#line 750
          fstart ++;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 750
        *ptr___1 = (unsigned char)0;
        {
#line 750
        if (argsneeded == 0U) {
#line 750
          goto case_0___1;
        }
#line 750
        if (argsneeded == 1U) {
#line 750
          goto case_1___1;
        }
#line 750
        if (argsneeded == 2U) {
#line 750
          goto case_2___1;
        }
#line 750
        goto switch_break___2;
        case_0___1: /* CIL Label */ 
        {
#line 750
        sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)(f___1),
                value___1);
        }
#line 750
        goto switch_break___2;
        case_1___1: /* CIL Label */ 
        {
#line 750
        sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)(f___1),
                arg1, value___1);
        }
#line 750
        goto switch_break___2;
        case_2___1: /* CIL Label */ 
        {
#line 750
        sprintf((char */* __restrict  */)(b___1), (char const   */* __restrict  */)(f___1),
                arg1, arg2, value___1);
        }
#line 750
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 750
        ptr___1 = b___1;
        {
#line 750
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 750
          if (! *ptr___1) {
#line 750
            goto while_break___19;
          }
          {
#line 750
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 750
            c___7 = *ptr___1;
#line 750
            if (function) {
              {
#line 750
              (*function)(c___7);
              }
            }
#line 750
            bytes_out ++;
#line 750
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
#line 750
          ptr___1 ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 750
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 751
      goto switch_break;
      case_78: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_115: /* CIL Label */ 
#line 762
      if ((int const   )*(format + -1) == 115) {
        {
#line 763
        tmp___19 = __builtin_va_arg(ap, char const   *);
#line 763
        str___0 = tmp___19;
        }
      } else {
#line 767
        if ((int const   )*(format + -1) == 78) {
          {
#line 768
          tmp___20 = __builtin_va_arg(ap, int );
#line 768
          errval = tmp___20;
          }
        } else {
          {
#line 770
          tmp___21 = __errno_location();
#line 770
          errval = *tmp___21;
          }
        }
#line 772
        if (errval >= 0) {
#line 772
          if (errval < sys_nerr) {
#line 773
            str___0 = (char const   *)sys_errlist[errval];
          } else {
            {
#line 776
            sprintf((char */* __restrict  */)(temp_error_buff), (char const   */* __restrict  */)"#%d",
                    errval);
#line 777
            str___0 = (char const   *)(temp_error_buff);
            }
          }
        } else {
          {
#line 776
          sprintf((char */* __restrict  */)(temp_error_buff), (char const   */* __restrict  */)"#%d",
                  errval);
#line 777
          str___0 = (char const   *)(temp_error_buff);
          }
        }
      }
#line 781
      if ((int const   )*(format + -2) == 37) {
        {
#line 784
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 784
          if (! *str___0) {
#line 784
            goto while_break___21;
          }
          {
#line 785
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 785
            tmp___22 = str___0;
#line 785
            str___0 ++;
#line 785
            c___8 = (unsigned char )*tmp___22;
#line 785
            if (function) {
              {
#line 785
              (*function)(c___8);
              }
            }
#line 785
            bytes_out ++;
#line 785
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
        }
        while_break___21: /* CIL Label */ ;
        }
      } else {
#line 790
        leftadjust = 0;
#line 791
        minfieldwidth = 0;
#line 792
        strmax = str___0 + 32767;
#line 795
        if ((int const   )*fstart == 45) {
#line 796
          tmp___23 = fstart;
#line 796
          fstart ++;
#line 796
          leftadjust = (int )*tmp___23;
        }
#line 797
        if ((int const   )*fstart == 42) {
#line 799
          fstart ++;
#line 800
          minfieldwidth = arg1;
#line 800
          if (minfieldwidth < 0) {
#line 801
            leftadjust = ! leftadjust;
#line 802
            minfieldwidth = - minfieldwidth;
          }
        } else {
          {
#line 805
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 805
            if (((int const   )*fstart & -128) == 0) {
              {
#line 805
              tmp___25 = __ctype_b_loc();
              }
#line 805
              if (! ((int const   )*(*tmp___25 + (int )*fstart) & 2048)) {
#line 805
                goto while_break___23;
              }
            } else {
#line 805
              goto while_break___23;
            }
#line 806
            tmp___24 = fstart;
#line 806
            fstart ++;
#line 806
            minfieldwidth = minfieldwidth * 10 + (int )((int const   )*tmp___24 - 48);
          }
          while_break___23: /* CIL Label */ ;
          }
        }
#line 808
        if ((int const   )*fstart == 46) {
#line 810
          fstart ++;
#line 811
          if ((int const   )*fstart == 42) {
#line 813
            if (argsneeded == 1U) {
#line 813
              tmp___26 = arg1;
            } else {
#line 813
              tmp___26 = arg2;
            }
#line 813
            strmax = str___0 + tmp___26;
#line 814
            fstart ++;
          } else {
#line 816
            num = 0;
            {
#line 817
            while (1) {
              while_continue___24: /* CIL Label */ ;
#line 817
              if (((int const   )*fstart & -128) == 0) {
                {
#line 817
                tmp___28 = __ctype_b_loc();
                }
#line 817
                if (! ((int const   )*(*tmp___28 + (int )*fstart) & 2048)) {
#line 817
                  goto while_break___24;
                }
              } else {
#line 817
                goto while_break___24;
              }
#line 818
              tmp___27 = fstart;
#line 818
              fstart ++;
#line 818
              num = num * 10 + (int )((int const   )*tmp___27 - 48);
            }
            while_break___24: /* CIL Label */ ;
            }
#line 819
            strmax = str___0 + num;
          }
        }
        {
#line 823
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 823
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 825
        if (! leftadjust) {
#line 828
          ptr___2 = str___0;
          {
#line 828
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 828
            if (*ptr___2) {
#line 828
              if (! ((unsigned long )ptr___2 < (unsigned long )strmax)) {
#line 828
                goto while_break___26;
              }
            } else {
#line 828
              goto while_break___26;
            }
#line 828
            ptr___2 ++;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 830
          len = (int )(ptr___2 - str___0);
          {
#line 831
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 831
            if (! (len < minfieldwidth)) {
#line 831
              goto while_break___27;
            }
            {
#line 833
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 833
              c___9 = (unsigned char )' ';
#line 833
              if (function) {
                {
#line 833
                (*function)(c___9);
                }
              }
#line 833
              bytes_out ++;
#line 833
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
#line 834
            minfieldwidth --;
          }
          while_break___27: /* CIL Label */ ;
          }
        }
#line 838
        ptr___2 = str___0;
        {
#line 839
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 839
          if (*ptr___2) {
#line 839
            if (! ((unsigned long )ptr___2 < (unsigned long )strmax)) {
#line 839
              goto while_break___29;
            }
          } else {
#line 839
            goto while_break___29;
          }
          {
#line 840
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 840
            tmp___29 = ptr___2;
#line 840
            ptr___2 ++;
#line 840
            c___10 = (unsigned char )*tmp___29;
#line 840
            if (function) {
              {
#line 840
              (*function)(c___10);
              }
            }
#line 840
            bytes_out ++;
#line 840
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
        }
        while_break___29: /* CIL Label */ ;
        }
#line 841
        minfieldwidth = (int )((long )minfieldwidth - (ptr___2 - str___0));
        {
#line 842
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 842
          tmp___30 = minfieldwidth;
#line 842
          minfieldwidth --;
#line 842
          if (! (tmp___30 > 0)) {
#line 842
            goto while_break___31;
          }
          {
#line 843
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 843
            c___11 = (unsigned char )' ';
#line 843
            if (function) {
              {
#line 843
              (*function)(c___11);
              }
            }
#line 843
            bytes_out ++;
#line 843
            goto while_break___32;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
        while_break___31: /* CIL Label */ ;
        }
      }
#line 845
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 849
  return ((int )bytes_out);
}
}
#line 853 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int outputf(char const   *fmt  , ...) 
{ 
  va_list ap ;
  int tmp ;

  {
  {
#line 856
  __builtin_va_start(ap, fmt);
#line 857
  tmp = vfcnprintf(_output_char_function, fmt, ap);
  }
#line 857
  return (tmp);
}
}
#line 860 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void warn(char const   *fmt  , ...) 
{ 
  unsigned int fd ;
  va_list ap ;
  unsigned int old_status ;

  {
  {
#line 862
  fd = (unsigned int )output_fd;
#line 865
  old_status = pager_status;
#line 866
  pager_status |= 1U;
#line 869
  __builtin_va_start(ap, fmt);
#line 870
  flush_output();
#line 871
  output_fd = 2;
#line 873
  vfcnprintf(_output_char_function, fmt, ap);
#line 875
  flush_output();
#line 876
  output_fd = (int )fd;
#line 879
  pager_status = old_status;
  }
#line 881
  return;
}
}
#line 883 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void volatile   die(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 887
  pager_status |= 1U;
#line 890
  __builtin_va_start(ap, fmt);
#line 891
  flush_output();
#line 892
  output_fd = 2;
#line 894
  vfcnprintf(_output_char_function, fmt, ap);
#line 895
  flush_output();
#line 896
  exit(1);
  }
}
}
#line 902 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned int (*_real_output_char_function)(unsigned char  )  =    (unsigned int (*)(unsigned char  ))0;
#line 909 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int output_pager_status(int want ) 
{ 
  int was ;

  {
#line 911
  was = (unsigned long )_real_output_char_function != (unsigned long )((unsigned int (*)(unsigned char  ))0);
#line 912
  if (want >= 0) {
#line 912
    if (was != want) {
#line 914
      if (want) {
#line 915
        _real_output_char_function = _output_char_function;
#line 916
        _output_char_function = (unsigned int (*)(unsigned char  ))(& pager_output_char_function);
#line 918
        column = 0;
#line 918
        line = column;
      } else {
#line 920
        _output_char_function = _real_output_char_function;
#line 921
        _real_output_char_function = (unsigned int (*)(unsigned char  ))0;
      }
    }
  }
#line 924
  return (was);
}
}
#line 928 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
unsigned long select_output_style(unsigned long mods ) 
{ 
  unsigned int (**function_pointer)(unsigned char  ) ;
  unsigned int (**tmp)(unsigned char  ) ;
  unsigned long old_output_style ;

  {
#line 930
  if (_real_output_char_function) {
#line 930
    tmp = & _real_output_char_function;
  } else {
#line 930
    tmp = & _output_char_function;
  }
#line 930
  function_pointer = tmp;
#line 935
  old_output_style = output_style;
#line 937
  if (mods == 0UL) {
#line 938
    return (output_style);
  }
#line 944
  if (mods & 7UL) {
#line 944
    output_style = (output_style & 0xfffffffffffffff8UL) | (mods & 7UL);
  }
#line 945
  if (mods & 36UL) {
#line 945
    output_style = (output_style & 0xffffffffffffffdbUL) | (mods & 36UL);
  }
#line 946
  if (mods & 768UL) {
#line 946
    output_style = (output_style & 0xfffffffffffffcffUL) | (mods & 768UL);
  }
#line 947
  if (mods & 61440UL) {
#line 947
    output_style = (output_style & 0xffffffffffff0fffUL) | (mods & 61440UL);
  }
#line 948
  if (mods & 3145728UL) {
#line 948
    output_style = (output_style & 0xffffffffffcfffffUL) | (mods & 3145728UL);
  }
#line 949
  if (mods & 458752UL) {
#line 949
    output_style = (output_style & 0xfffffffffff8ffffUL) | (mods & 458752UL);
  }
  {
#line 953
  if ((output_style & 7UL) == 2UL) {
#line 953
    goto case_2;
  }
#line 956
  if ((output_style & 7UL) == 1UL) {
#line 956
    goto case_1;
  }
#line 959
  if ((output_style & 7UL) == 4UL) {
#line 959
    goto case_4;
  }
#line 952
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 952
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         952);
    }
#line 952
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 952
  goto switch_break;
  case_2: /* CIL Label */ 
#line 954
  *function_pointer = & output_euc_as_sjis;
#line 955
  goto switch_break;
  case_1: /* CIL Label */ 
#line 957
  *function_pointer = & output_euc_as_simple_euc;
#line 958
  goto switch_break;
  case_4: /* CIL Label */ 
#line 960
  *function_pointer = & output_euc_as_jis;
  {
#line 966
  if ((output_style & 36UL) == 4UL) {
#line 966
    goto case_4___0;
  }
#line 969
  if ((output_style & 36UL) == 20UL) {
#line 969
    goto case_20;
  }
#line 972
  if ((output_style & 36UL) == 36UL) {
#line 972
    goto case_36;
  }
#line 963
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
  {
#line 964
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 964
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 965
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 967
  jis_start_208 = (unsigned char const   *)"\033$@";
#line 968
  goto switch_break___0;
  case_20: /* CIL Label */ 
#line 970
  jis_start_208 = (unsigned char const   *)"\033$B";
#line 971
  goto switch_break___0;
  case_36: /* CIL Label */ 
#line 973
  jis_start_208 = (unsigned char const   *)"\033$2\033$B";
#line 974
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 981
  if ((output_style & 768UL) == 256UL) {
#line 981
    goto case_256;
  }
#line 984
  if ((output_style & 768UL) == 512UL) {
#line 984
    goto case_512;
  }
#line 978
  goto switch_default___1;
  switch_default___1: /* CIL Label */ 
  {
#line 979
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 979
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 980
  goto switch_break___1;
  case_256: /* CIL Label */ 
#line 982
  jis_start_ASCII = (unsigned char const   *)"\033(J";
#line 983
  goto switch_break___1;
  case_512: /* CIL Label */ 
#line 985
  jis_start_ASCII = (unsigned char const   *)"\033(B";
#line 986
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 988
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 991
  if ((output_style & 458752UL) != 65536UL) {
    {
#line 992
    warn("[half-width katakana support not implemented]\n");
    }
  }
#line 994
  return (old_output_style);
}
}
#line 997 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void show_output_style(void) 
{ 
  int is_sjis ;
  int has_212_support ;

  {
#line 999
  is_sjis = 0;
#line 1000
  has_212_support = 0;
  {
#line 1004
  if ((output_style & 7UL) == 2UL) {
#line 1004
    goto case_2;
  }
#line 1005
  if ((output_style & 7UL) == 1UL) {
#line 1005
    goto case_1;
  }
#line 1007
  if ((output_style & 7UL) == 4UL) {
#line 1007
    goto case_4;
  }
#line 1003
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1003
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         1003);
    }
#line 1003
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1004
  output("Shift JIS");
#line 1004
  is_sjis = 1;
  }
#line 1004
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1005
  output("EUC");
  }
#line 1005
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1011
  if ((output_style & 36UL) == 4UL) {
#line 1011
    goto case_4___0;
  }
#line 1012
  if ((output_style & 36UL) == 20UL) {
#line 1012
    goto case_20;
  }
#line 1013
  if ((output_style & 36UL) == 36UL) {
#line 1013
    goto case_36;
  }
#line 1010
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1010
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1010
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         1010);
    }
#line 1010
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1010
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 1011
  output("JIS (1978");
  }
#line 1011
  goto switch_break___0;
  case_20: /* CIL Label */ 
  {
#line 1012
  output("JIS (1983");
  }
#line 1012
  goto switch_break___0;
  case_36: /* CIL Label */ 
  {
#line 1013
  output("JIS (1990");
  }
#line 1013
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1018
  if ((output_style & 768UL) == 256UL) {
#line 1018
    goto case_256;
  }
#line 1019
  if ((output_style & 768UL) == 512UL) {
#line 1019
    goto case_512;
  }
#line 1017
  goto switch_default___1;
  switch_default___1: /* CIL Label */ 
  {
#line 1017
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1017
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         1017);
    }
#line 1017
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1017
  goto switch_break___1;
  case_256: /* CIL Label */ 
  {
#line 1018
  output(", roman)");
  }
#line 1018
  goto switch_break___1;
  case_512: /* CIL Label */ 
  {
#line 1019
  output(", ASCII)");
  }
#line 1019
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1021
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1027
  if ((output_style & 3145728UL) == 1048576UL) {
#line 1027
    goto case_1048576;
  }
#line 1028
  if ((output_style & 3145728UL) == 2097152UL) {
#line 1028
    goto case_2097152;
  }
#line 1026
  goto switch_default___2;
  switch_default___2: /* CIL Label */ 
  {
#line 1026
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1026
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         1026);
    }
#line 1026
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1026
  goto switch_break___2;
  case_1048576: /* CIL Label */ 
  {
#line 1027
  outputf(" (X212");
#line 1027
  has_212_support = 1;
  }
#line 1027
  goto switch_break___2;
  case_2097152: /* CIL Label */ 
  {
#line 1028
  outputf(" (!X212");
  }
#line 1028
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 1034
  if ((output_style & 458752UL) == 65536UL) {
#line 1034
    goto case_65536;
  }
#line 1035
  if ((output_style & 458752UL) == 131072UL) {
#line 1035
    goto case_131072;
  }
#line 1036
  if ((output_style & 458752UL) == 262144UL) {
#line 1036
    goto case_262144;
  }
#line 1033
  goto switch_default___3;
  switch_default___3: /* CIL Label */ 
  {
#line 1033
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1033
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
         1033);
    }
#line 1033
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1033
  goto switch_break___3;
  case_65536: /* CIL Label */ 
  {
#line 1034
  output(", hwk");
  }
#line 1034
  goto switch_break___3;
  case_131072: /* CIL Label */ 
  {
#line 1035
  output(", !hwk");
  }
#line 1035
  goto switch_break___3;
  case_262144: /* CIL Label */ 
  {
#line 1036
  output(", hwk converted");
  }
#line 1036
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1039
  if (is_sjis) {
#line 1039
    goto _L;
  } else
#line 1039
  if (! has_212_support) {
    _L: /* CIL Label */ 
    {
#line 1040
    output(", unsupported ");
    }
    {
#line 1043
    if ((output_style & 61440UL) == 4096UL) {
#line 1043
      goto case_4096;
    }
#line 1044
    if ((output_style & 61440UL) == 8192UL) {
#line 1044
      goto case_8192;
    }
#line 1045
    if ((output_style & 61440UL) == 16384UL) {
#line 1045
      goto case_16384;
    }
#line 1046
    if ((output_style & 61440UL) == 32768UL) {
#line 1046
      goto case_32768;
    }
#line 1042
    goto switch_default___4;
    switch_default___4: /* CIL Label */ 
    {
#line 1042
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1042
      warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c",
           1042);
      }
#line 1042
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1042
    goto switch_break___4;
    case_4096: /* CIL Label */ 
    {
#line 1043
    output("stripped");
    }
#line 1043
    goto switch_break___4;
    case_8192: /* CIL Label */ 
    {
#line 1044
    output("passed");
    }
#line 1044
    goto switch_break___4;
    case_16384: /* CIL Label */ 
    {
#line 1045
    output("as codes");
    }
#line 1045
    goto switch_break___4;
    case_32768: /* CIL Label */ 
    {
#line 1046
    output("marked");
    }
    switch_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1049
  (*_output_char_function)((unsigned char )')');
  }
#line 1050
  return;
}
}
#line 1052 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int set_extra_output_file(int fd ) 
{ 
  int old ;

  {
#line 1054
  old = extra_fd;
#line 1055
  if (fd != -2) {
#line 1056
    extra_fd = fd;
  }
#line 1057
  return (old);
}
}
#line 1060 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
int set_normal_output_file(int fd ) 
{ 
  int old ;

  {
#line 1062
  old = output_fd;
#line 1063
  if (fd != -2) {
#line 1064
    output_fd = fd;
  }
#line 1065
  return (old);
}
}
#line 1069 "/home/wheatley/newnew/temp/lookup-1.08b/lib/output.c"
void outchar(unsigned char c ) 
{ 


  {
  {
#line 1071
  (*_output_char_function)(c);
  }
#line 1072
  return;
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 74 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.h"
int romaji2kana(unsigned char const   *r , unsigned char const   *r_end , unsigned char *k ,
                unsigned int k_buf_len , struct romaji2kana_info *info ) ;
#line 78 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.h"
char const   *std_romaji_allowed_nonletters(char const   *new___1 ) ;
#line 79
void std_romaji_converter(unsigned char const   *start_of_line___0 , unsigned char const   *bufend ,
                          unsigned char **dot_p , unsigned char const   **eol_p ,
                          int force , int eat_leading_slash ) ;
#line 8 "/home/wheatley/newnew/temp/lookup-1.08b/lib/xmalloc.h"
extern void *xmalloc(unsigned int len ) ;
#line 45 "/home/wheatley/newnew/temp/lookup-1.08b/lib/std_romaji.c"
static char const   *allowed_nonletters_in_romaji  =    "-^\'";
#line 47 "/home/wheatley/newnew/temp/lookup-1.08b/lib/std_romaji.c"
char const   *std_romaji_allowed_nonletters(char const   *new___1 ) 
{ 
  char const   *old ;

  {
#line 50
  old = allowed_nonletters_in_romaji;
#line 51
  allowed_nonletters_in_romaji = new___1;
#line 52
  return (old);
}
}
#line 55 "/home/wheatley/newnew/temp/lookup-1.08b/lib/std_romaji.c"
int std_romaji_toggled_force  =    1;
#line 82 "/home/wheatley/newnew/temp/lookup-1.08b/lib/std_romaji.c"
static struct __anonstruct_last_forced_25 last_forced  ;
#line 69 "/home/wheatley/newnew/temp/lookup-1.08b/lib/std_romaji.c"
void std_romaji_converter(unsigned char const   *start_of_line___0 , unsigned char const   *bufend ,
                          unsigned char **dot_p , unsigned char const   **eol_p ,
                          int force , int eat_leading_slash ) 
{ 
  unsigned char *dot___0 ;
  unsigned char const   *end_of_line___0 ;
  unsigned char *ptr ;
  int len_delta ;
  unsigned char *temp_ptr ;
  unsigned int temp_len ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned char kana[400] ;
  unsigned int romaji_len ;
  unsigned int kana_len ;
  int len_delta___0 ;
  unsigned char *romaji_end ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 77
  dot___0 = *dot_p;
#line 78
  end_of_line___0 = *eol_p;
#line 79
  ptr = dot___0 + -1;
#line 90
  if (std_romaji_toggled_force) {
#line 90
    if (force) {
#line 90
      if ((unsigned long )(last_forced.start + last_forced.new_len) == (unsigned long )dot___0) {
        {
#line 93
        tmp = strncmp((char const   *)((void *)last_forced.start), (char const   *)((void *)last_forced.new),
                      (size_t )last_forced.new_len);
        }
#line 93
        if (! tmp) {
#line 97
          len_delta = (int )(last_forced.orig_len - last_forced.new_len);
#line 98
          if (len_delta) {
#line 98
            if ((unsigned long )dot___0 != (unsigned long )end_of_line___0) {
              {
#line 100
              bcopy((void const   *)((char *)dot___0), (void *)((char *)(dot___0 + len_delta)),
                    (size_t )((int )(end_of_line___0 - (unsigned char const   *)dot___0)));
              }
            }
          }
          {
#line 107
          bcopy((void const   *)((char *)last_forced.orig), (void *)((char *)last_forced.start),
                (size_t )((int )last_forced.orig_len));
#line 112
          *eol_p += len_delta;
#line 113
          *dot_p += len_delta;
#line 116
          temp_ptr = last_forced.orig;
#line 117
          last_forced.orig = last_forced.new;
#line 118
          last_forced.new = temp_ptr;
#line 120
          temp_len = last_forced.orig_len;
#line 121
          last_forced.orig_len = last_forced.new_len;
#line 122
          last_forced.new_len = temp_len;
          }
#line 124
          return;
        }
      }
    }
  }
#line 132
  if ((unsigned long )dot___0 == (unsigned long )start_of_line___0) {
#line 133
    return;
  } else
#line 132
  if (! (((int )*(dot___0 + -1) & -128) == 0)) {
#line 133
    return;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if ((unsigned long )ptr != (unsigned long )start_of_line___0) {
#line 140
      if (((int )*ptr & -128) == 0) {
        {
#line 140
        tmp___0 = __ctype_b_loc();
        }
#line 140
        if (! ((int const   )*(*tmp___0 + (int )*ptr) & 8)) {
          {
#line 140
          tmp___1 = index(allowed_nonletters_in_romaji, (int )*ptr);
          }
#line 140
          if (! tmp___1) {
#line 140
            goto while_break;
          }
        }
      } else {
#line 140
        goto while_break;
      }
    } else {
#line 140
      goto while_break;
    }
#line 144
    ptr --;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (! force) {
#line 148
    if ((unsigned long )ptr > (unsigned long )start_of_line___0) {
#line 148
      if ((int )*(ptr + -1) == 92) {
#line 149
        return;
      }
    }
  }
#line 152
  if (force) {
#line 152
    goto _L___1;
  } else
#line 152
  if (! (((int )*ptr & -128) == 0)) {
#line 152
    goto _L___1;
  } else
#line 152
  if ((int )*ptr == 47) {
    _L___1: /* CIL Label */ 
#line 170
    if (! force) {
#line 170
      if ((int )*(dot___0 + -1) == 110) {
#line 172
        romaji_end = dot___0 - 1;
      } else
#line 170
      if ((int )*(dot___0 + -1) == 78) {
#line 172
        romaji_end = dot___0 - 1;
      } else
#line 170
      if ((int )*(dot___0 + -1) == 104) {
#line 172
        romaji_end = dot___0 - 1;
      } else
#line 170
      if ((int )*(dot___0 + -1) == 72) {
#line 172
        romaji_end = dot___0 - 1;
      } else {
#line 170
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 173
    if (! force) {
#line 173
      if ((int )*(dot___0 + -1) == 121) {
#line 173
        goto _L;
      } else
#line 173
      if ((int )*(dot___0 + -1) == 89) {
        _L: /* CIL Label */ 
#line 173
        if ((unsigned long )(dot___0 + -2) >= (unsigned long )start_of_line___0) {
#line 173
          if ((int )*(dot___0 + -2) == 110) {
#line 178
            romaji_end = dot___0 - 2;
          } else
#line 173
          if ((int )*(dot___0 + -2) == 78) {
#line 178
            romaji_end = dot___0 - 2;
          } else
#line 173
          if ((int )*(dot___0 + -2) == 104) {
#line 178
            romaji_end = dot___0 - 2;
          } else
#line 173
          if ((int )*(dot___0 + -2) == 72) {
#line 178
            romaji_end = dot___0 - 2;
          } else {
#line 180
            romaji_end = dot___0;
          }
        } else {
#line 180
          romaji_end = dot___0;
        }
      } else {
#line 180
        romaji_end = dot___0;
      }
    } else {
#line 180
      romaji_end = dot___0;
    }
#line 182
    if (((int )*ptr & -128) == 0) {
#line 184
      if ((int )*ptr == 47) {
#line 185
        ptr ++;
      }
#line 186
      if ((unsigned long )ptr == (unsigned long )romaji_end) {
#line 187
        return;
      }
    } else {
#line 197
      ptr --;
#line 198
      if ((unsigned long )(ptr + 2) == (unsigned long )romaji_end) {
#line 199
        return;
      }
    }
    {
#line 202
    tmp___2 = romaji2kana((unsigned char const   *)ptr, (unsigned char const   *)romaji_end,
                          kana, (unsigned int )sizeof(kana), (struct romaji2kana_info *)0);
    }
#line 202
    if (tmp___2 < 0) {
#line 203
      return;
    }
    {
#line 206
    tmp___3 = strlen((char const   *)((void *)(kana)));
#line 206
    kana_len = (unsigned int )tmp___3;
    }
#line 213
    if (kana_len) {
#line 213
      if (eat_leading_slash) {
#line 213
        if (! (((int )kana[0] & -128) == 0)) {
#line 213
          if ((unsigned long )ptr > (unsigned long )start_of_line___0) {
#line 213
            if ((int )*(ptr + -1) == 47) {
#line 213
              if ((unsigned long )ptr == (unsigned long )start_of_line___0) {
#line 220
                ptr --;
              } else
#line 213
              if ((int )*(ptr + -2) != 92) {
#line 220
                ptr --;
              }
            }
          }
        }
      }
    }
#line 223
    romaji_len = (unsigned int )(romaji_end - ptr);
#line 224
    len_delta___0 = (int )(kana_len - romaji_len);
#line 227
    if ((unsigned long )(end_of_line___0 + len_delta___0) >= (unsigned long )bufend) {
#line 228
      return;
    }
#line 230
    if (std_romaji_toggled_force) {
#line 230
      if (force) {
#line 233
        if (last_forced.orig) {
          {
#line 234
          free((void *)last_forced.orig);
          }
        }
        {
#line 235
        last_forced.orig_len = romaji_len;
#line 236
        tmp___4 = xmalloc(last_forced.orig_len + 1U);
#line 236
        last_forced.orig = (unsigned char *)tmp___4;
#line 237
        strcpy((char */* __restrict  */)((void *)last_forced.orig), (char const   */* __restrict  */)((void *)ptr));
        }
#line 239
        if (last_forced.new) {
          {
#line 240
          free((void *)last_forced.new);
          }
        }
        {
#line 241
        last_forced.new_len = kana_len;
#line 242
        tmp___5 = xmalloc(last_forced.new_len + 1U);
#line 242
        last_forced.new = (unsigned char *)tmp___5;
#line 243
        strcpy((char */* __restrict  */)((void *)last_forced.new), (char const   */* __restrict  */)((void *)(kana)));
#line 244
        last_forced.start = ptr;
        }
      }
    }
#line 251
    if (len_delta___0) {
#line 251
      if ((unsigned long )romaji_end != (unsigned long )end_of_line___0) {
        {
#line 252
        bcopy((void const   *)((char *)romaji_end), (void *)((char *)(romaji_end + len_delta___0)),
              (size_t )((int )(end_of_line___0 - (unsigned char const   *)romaji_end)));
        }
      }
    }
    {
#line 258
    bcopy((void const   *)((char *)(kana)), (void *)((char *)ptr), (size_t )((int )kana_len));
#line 261
    end_of_line___0 += len_delta___0;
#line 262
    dot___0 += len_delta___0;
    }
  }
#line 265
  *dot_p = dot___0;
#line 266
  *eol_p = end_of_line___0;
#line 267
  return;
}
}
#line 459 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 56 "/home/wheatley/newnew/temp/lookup-1.08b/lib/packed_list.h"
__inline static unsigned int write_packed_value(unsigned char **ptr , unsigned long value ) 
{ 
  unsigned char const   *optr ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 59
  optr = (unsigned char const   *)*ptr;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (value > (unsigned long )((1 << 7) - 1))) {
#line 60
      goto while_break;
    }
#line 61
    tmp = *ptr;
#line 61
    (*ptr) ++;
#line 61
    *tmp = (unsigned char )((value & (unsigned long )((1 << 7) - 1)) | (unsigned long )(1 << 7));
#line 62
    value >>= 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  tmp___0 = *ptr;
#line 64
  (*ptr) ++;
#line 64
  *tmp___0 = (unsigned char )value;
#line 65
  return ((unsigned int )(*ptr - (unsigned char *)optr));
}
}
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lib/packed_list.h"
__inline static unsigned int bytes_required_for_packed_value(unsigned long value ) 
{ 
  unsigned int bytes ;

  {
#line 156
  bytes = 1U;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (value > (unsigned long )((1 << 7) - 1))) {
#line 157
      goto while_break;
    }
#line 158
    bytes ++;
#line 159
    value >>= 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (bytes);
}
}
#line 53 "/home/wheatley/newnew/temp/lookup-1.08b/lib/virtfile.h"
extern unsigned char const   *VirtPos2Str(VirtFile *v , fileloc start , unsigned int *pCount ) ;
#line 58
extern long filesize(char const   *filename ) ;
#line 263 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
struct index *create_index(VirtFile *v , unsigned int percent , unsigned int flags___0 ) ;
#line 272
int is_index_file(char const   *filename ) ;
#line 273
struct index *read_index_file(char const   *filename , int try , unsigned int flags___0 ) ;
#line 274
struct index *mem_read_index_file(char const   *filename ) ;
#line 275
int write_index_file(char const   *filename , struct index  const  *i ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 36 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
static unsigned int line_count  ;
#line 43 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
static void SCAN_TEXT(VirtFile *v , void (*enter)(unsigned char hi , unsigned char lo ,
                                                  TextOffset val ) , unsigned int flags___0 ,
                      char const   *msg ) 
{ 
  unsigned int lastpercent ;
  fileloc pos ;
  fileloc end ;
  TextOffset value ;
  unsigned char const   *strptr ;
  unsigned char const   *strend ;
  unsigned int linelen ;
  int percent ;
  unsigned char c ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 49
  lastpercent = 0U;
#line 50
  pos = (fileloc )0;
#line 50
  end = v->length;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (pos < end)) {
#line 52
      goto while_break;
    }
#line 55
    value = (TextOffset )pos;
#line 68
    percent = (int )((100L * pos) / end);
#line 69
    if ((unsigned int )percent != lastpercent) {
      {
#line 70
      lastpercent = (unsigned int )percent;
#line 70
      outputf("[%s] %s %02d%% \r", v->filename, msg, lastpercent);
#line 72
      flush_output();
      }
    }
    {
#line 76
    strptr = VirtPos2Str(v, pos, & linelen);
    }
#line 76
    if ((unsigned long )strptr == (unsigned long )((void *)0)) {
#line 77
      goto while_break;
    }
#line 78
    line_count ++;
#line 79
    strend = strptr + linelen;
#line 80
    pos += (fileloc )(linelen + 1U);
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! ((unsigned long )strptr < (unsigned long )strend)) {
#line 83
        goto while_break___0;
      }
#line 85
      tmp = strptr;
#line 85
      strptr ++;
#line 85
      c = (unsigned char )*tmp;
#line 87
      if ((int )c == 165) {
        {
#line 89
        tmp___0 = strptr;
#line 89
        strptr ++;
#line 89
        (*enter)((unsigned char)36, (unsigned char )((int const   )*tmp___0 & 127),
                 value);
        }
      } else
#line 90
      if ((int )c & 128) {
        {
#line 92
        tmp___1 = strptr;
#line 92
        strptr ++;
#line 92
        (*enter)((unsigned char )((int )c & 127), (unsigned char )((int const   )*tmp___1 & 127),
                 value);
        }
      } else {
        {
#line 93
        tmp___6 = __ctype_b_loc();
        }
#line 93
        if ((int const   )*(*tmp___6 + (int )c) & 8) {
          {
#line 95
          tmp___5 = __ctype_b_loc();
          }
#line 95
          if ((int const   )*(*tmp___5 + (int )c) & 256) {
            {
#line 95
            tmp___3 = tolower((int )c);
#line 95
            tmp___4 = tmp___3;
            }
          } else {
#line 95
            tmp___4 = (int )c;
          }
          {
#line 95
          (*enter)((unsigned char)0, (unsigned char )tmp___4, value);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
struct fullindex *fullindex  ;
#line 116 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
static void enter1(unsigned char hi___1 , unsigned char lo , TextOffset data ) 
{ 
  struct fullindex_entry *p ;
  unsigned int diff ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 119
  p = & fullindex->char_info[hi___1][lo];
#line 122
  if (p->count == 0U) {
#line 123
    diff = (unsigned int )data;
  } else
#line 124
  if (p->lastentered == data) {
#line 125
    return;
  } else {
#line 127
    diff = (unsigned int )(data - p->lastentered);
  }
  {
#line 129
  tmp = bytes_required_for_packed_value((unsigned long )diff);
#line 129
  p->mem_needed = (int )((unsigned int )p->mem_needed + tmp);
#line 130
  p->lastentered = data;
  }
#line 131
  if (p->count != 65534U) {
#line 132
    tmp___0 = p->count;
#line 132
    (p->count) ++;
#line 132
    if (tmp___0 == 4294967295U) {
      {
#line 133
      die("count overflow at %s line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c",
          133);
      }
    }
  }
#line 134
  return;
}
}
#line 137 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
static void enter2(unsigned char hi___1 , unsigned char lo , TextOffset data ) 
{ 
  struct fullindex_entry *p ;
  unsigned int diff ;
  unsigned int tmp ;

  {
#line 140
  p = & fullindex->char_info[hi___1][lo];
#line 144
  if (p->count == 65535U) {
#line 145
    return;
  }
#line 147
  if (p->count2 == 0U) {
#line 148
    diff = (unsigned int )data;
  } else
#line 149
  if (p->lastentered == data) {
#line 150
    return;
  } else {
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 152
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 153
    diff = (unsigned int )(data - p->lastentered);
  }
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 162
  p->lastentered = data;
#line 164
  (p->count) --;
#line 165
  (p->count2) ++;
#line 166
  tmp = write_packed_value(& p->listptr, (unsigned long )diff);
#line 166
  p->mem_needed = (int )((unsigned int )p->mem_needed - tmp);
  }
  {
#line 167
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 167
    if (! (p->mem_needed >= 0)) {
      {
#line 167
      die("\nassert(p->mem_needed >= 0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c",
          167);
      }
    }
#line 167
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 176 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
struct index *create_index(VirtFile *v , unsigned int percent , unsigned int flags___0 ) 
{ 
  unsigned int hi___1 ;
  unsigned int lo ;
  struct index index___0 ;
  struct index *indexp ;
  unsigned char *freemem ;
  void *tmp ;
  unsigned char tmp___0 ;
  unsigned int count ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  void *tmp___5 ;
  unsigned int count___0 ;
  unsigned int count___1 ;
  IndexOffset thisCountPtr ;
  IndexOffset thisListPtr ;
  elementcount count___2 ;

  {
  {
#line 185
  tmp = xmalloc((unsigned int )sizeof(*fullindex));
#line 185
  fullindex = (struct fullindex *)tmp;
#line 186
  bzero((void *)fullindex, sizeof(*fullindex));
#line 192
  line_count = 0U;
#line 193
  SCAN_TEXT(v, & enter1, flags___0, "index (first pass): ");
#line 194
  index___0.linecount = line_count;
#line 197
  index___0.limitcount = (index___0.linecount * percent) / 100U;
  }
#line 198
  if (index___0.limitcount > 65534U) {
#line 199
    index___0.limitcount = 65534U;
  }
#line 207
  index___0.indexsize = (unsigned int )sizeof(index___0);
#line 209
  hi___1 = 0U;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (hi___1 < 128U)) {
#line 209
      goto while_break;
    }
#line 212
    lo = 0U;
    {
#line 212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 212
      if (! (lo < 128U)) {
#line 212
        goto while_break___0;
      }
#line 213
      if (fullindex->char_info[hi___1][lo].count != 0U) {
#line 214
        goto while_break___0;
      }
#line 212
      lo ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 217
    if (lo >= 128U) {
#line 218
      tmp___0 = (unsigned char)0;
#line 218
      index___0.hi[hi___1].end_lo = tmp___0;
#line 218
      index___0.hi[hi___1].first_lo = tmp___0;
#line 219
      goto __Cont;
    }
#line 223
    index___0.hi[hi___1].first_lo = (unsigned char )lo;
    {
#line 223
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 223
      if (! (lo < 128U)) {
#line 223
        goto while_break___1;
      }
#line 225
      count = fullindex->char_info[hi___1][lo].count;
#line 226
      if (count == 0U) {
#line 227
        goto __Cont___0;
      }
#line 230
      index___0.hi[hi___1].end_lo = (unsigned char )lo;
#line 232
      if (count < index___0.limitcount) {
#line 233
        if (count != 0U) {
#line 235
          if (flags___0 & 4U) {
#line 237
            if (hi___1) {
#line 237
              tmp___1 = lo | 128U;
            } else {
#line 237
              tmp___1 = lo;
            }
#line 237
            if (hi___1) {
#line 237
              tmp___2 = hi___1 | 128U;
            } else {
#line 237
              tmp___2 = (unsigned int )' ';
            }
            {
#line 237
            outputf("%d times [%c%c] %d bytes]\n", count, tmp___2, tmp___1, fullindex->char_info[hi___1][lo].mem_needed);
            }
          }
#line 241
          index___0.indexsize += (unsigned int )fullindex->char_info[hi___1][lo].mem_needed;
        }
      } else {
#line 245
        if (flags___0 & 2U) {
#line 246
          if (hi___1) {
#line 246
            tmp___3 = lo | 128U;
          } else {
#line 246
            tmp___3 = lo;
          }
#line 246
          if (hi___1) {
#line 246
            tmp___4 = hi___1 | 128U;
          } else {
#line 246
            tmp___4 = (unsigned int )' ';
          }
          {
#line 246
          outputf("[%c%c:%d/%d]", tmp___4, tmp___3, count, fullindex->char_info[hi___1][lo].mem_needed);
          }
        }
#line 250
        fullindex->char_info[hi___1][lo].count = (unsigned int )((elementcount )(~ 0));
#line 251
        fullindex->char_info[hi___1][lo].mem_needed = 0;
      }
      __Cont___0: /* CIL Label */ 
#line 223
      lo ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 255
    index___0.hi[hi___1].end_lo = (unsigned char )((int )index___0.hi[hi___1].end_lo + 1);
#line 258
    index___0.indexsize = (unsigned int )((unsigned long )index___0.indexsize + (unsigned long )((int )index___0.hi[hi___1].end_lo - (int )index___0.hi[hi___1].first_lo) * (sizeof(elementcount ) + sizeof(IndexOffset )));
    __Cont: /* CIL Label */ 
#line 209
    hi___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if (flags___0 & 2U) {
    {
#line 262
    (*_output_char_function)((unsigned char )'\n');
    }
  }
  {
#line 264
  tmp___5 = xmalloc(index___0.indexsize);
#line 264
  indexp = (struct index *)tmp___5;
#line 265
  *indexp = index___0;
#line 266
  freemem = (unsigned char *)(indexp + 1);
#line 269
  hi___1 = 0U;
  }
  {
#line 269
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 269
    if (! (hi___1 < 128U)) {
#line 269
      goto while_break___2;
    }
#line 271
    if ((int )index___0.hi[hi___1].end_lo != 0) {
#line 272
      count___0 = (unsigned int )((int )index___0.hi[hi___1].end_lo - (int )index___0.hi[hi___1].first_lo);
#line 273
      indexp->hi[hi___1].shifted_lo = (IndexOffset )((unsigned char const   *)freemem - (unsigned char const   *)indexp);
#line 274
      freemem += sizeof(IndexOffset ) * (unsigned long )count___0;
    }
#line 269
    hi___1 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 279
  hi___1 = 0U;
  {
#line 279
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 279
    if (! (hi___1 < 128U)) {
#line 279
      goto while_break___3;
    }
#line 281
    if ((int )index___0.hi[hi___1].end_lo != 0) {
#line 282
      count___1 = (unsigned int )((int )index___0.hi[hi___1].end_lo - (int )index___0.hi[hi___1].first_lo);
#line 283
      indexp->hi[hi___1].listcount = (IndexOffset )((unsigned char const   *)freemem - (unsigned char const   *)indexp);
#line 284
      freemem += sizeof(elementcount ) * (unsigned long )count___1;
    }
#line 279
    hi___1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 289
  hi___1 = 0U;
  {
#line 289
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 289
    if (! (hi___1 < 128U)) {
#line 289
      goto while_break___4;
    }
#line 294
    if ((int )index___0.hi[hi___1].end_lo == 0) {
#line 295
      goto __Cont___1;
    }
#line 297
    thisCountPtr = indexp->hi[hi___1].listcount;
#line 298
    thisListPtr = indexp->hi[hi___1].shifted_lo;
#line 301
    lo = (unsigned int )index___0.hi[hi___1].first_lo;
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if (! (lo < (unsigned int )index___0.hi[hi___1].end_lo)) {
#line 301
        goto while_break___5;
      }
#line 304
      count___2 = (elementcount )fullindex->char_info[hi___1][lo].count;
#line 305
      *((elementcount *)((unsigned char const   *)indexp + thisCountPtr)) = count___2;
#line 309
      if (count___2) {
#line 309
        if ((int )count___2 != 65535) {
#line 310
          *((IndexOffset *)((unsigned char const   *)indexp + thisListPtr)) = (IndexOffset )((unsigned char const   *)freemem - (unsigned char const   *)indexp);
#line 312
          fullindex->char_info[hi___1][lo].listptr = freemem;
#line 313
          freemem += fullindex->char_info[hi___1][lo].mem_needed;
        }
      }
#line 317
      thisListPtr += sizeof(IndexOffset );
#line 318
      thisCountPtr += sizeof(elementcount );
#line 321
      fullindex->char_info[hi___1][lo].lastentered = (TextOffset )0;
#line 301
      lo ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    __Cont___1: /* CIL Label */ 
#line 289
    hi___1 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 326
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 326
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 333
  SCAN_TEXT(v, & enter2, flags___0, "index (final pass): ");
#line 336
  output("                                            \r");
#line 338
  free((void *)fullindex);
#line 339
  indexp->magic = 1784969216U;
#line 340
  indexp->version_major = (unsigned short)1;
#line 341
  indexp->version_minor = (unsigned short)2;
  }
#line 342
  return (indexp);
}
}
#line 345 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
int write_index_file(char const   *filename , struct index  const  *i ) 
{ 
  int fd ;
  int iserror ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 350
  fd = open(filename, 577, 292);
  }
#line 350
  if (fd < 0) {
#line 351
    return (fd);
  }
  {
#line 352
  tmp = write(fd, (void const   *)((void *)i), (size_t )i->indexsize);
#line 352
  iserror = tmp != (ssize_t )i->indexsize;
#line 353
  tmp___0 = close(fd);
#line 353
  iserror |= tmp___0 != 0;
  }
#line 355
  return (iserror);
}
}
#line 361 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
struct index *read_index_file(char const   *filename , int try , unsigned int flags___0 ) 
{ 
  struct index *index___0 ;
  long size ;
  long tmp ;
  int fd ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 363
  index___0 = (struct index *)0;
#line 364
  tmp = filesize(filename);
#line 364
  size = tmp;
  }
#line 366
  if (size < 0L) {
#line 366
    if (try) {
#line 367
      return ((struct index *)0);
    }
  }
#line 368
  if (size >= 0L) {
    {
#line 369
    tmp___0 = open(filename, 0);
#line 369
    fd = tmp___0;
#line 370
    tmp___1 = xmalloc((unsigned int )size);
#line 370
    index___0 = (struct index *)tmp___1;
#line 371
    read(fd, (void *)index___0, (size_t )size);
#line 372
    close(fd);
    }
  }
#line 375
  if ((unsigned long )index___0 == (unsigned long )((struct index *)0)) {
#line 377
    if (! try) {
      {
#line 378
      outputf("[open of \"%s\" failed: %n]\n", filename);
      }
    }
#line 379
    return ((struct index *)0);
  }
#line 382
  index___0->FileP = (FILE *)((void *)0);
#line 384
  if (size != (long )index___0->indexsize) {
    {
#line 385
    warn("<warning, index seems corrupt: size is %ld, index says %d>\n", size, index___0->indexsize);
    }
  } else
#line 387
  if (index___0->magic != 1784969216U) {
    {
#line 388
    warn("<warning, index file magic is wrong>\n");
    }
  } else
#line 389
  if ((int )index___0->version_major != 1) {
    {
#line 390
    warn("<warning, index version major is wrong (%d != %d)>\n", (int )index___0->version_major,
         1);
    }
  } else
#line 392
  if ((int )index___0->version_minor != 2) {
    {
#line 393
    warn("<warning, index version minor is wrong (%d != %d)>\n", (int )index___0->version_minor,
         2);
    }
  }
#line 396
  return (index___0);
}
}
#line 399 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
struct index *mem_read_index_file(char const   *filename ) 
{ 
  FILE *fp ;
  struct index *index___0 ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 404
  fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 404
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 405
    return ((struct index *)((void *)0));
  }
  {
#line 407
  tmp = xmalloc((unsigned int )sizeof(struct index ));
#line 407
  index___0 = (struct index *)tmp;
#line 408
  tmp___0 = fread((void */* __restrict  */)index___0, sizeof(struct index ), (size_t )1,
                  (FILE */* __restrict  */)fp);
  }
#line 408
  if (tmp___0 != 1UL) {
    {
#line 409
    die("bad fread of index header: %n\n");
    }
  }
#line 411
  index___0->FileP = fp;
#line 413
  if (index___0->magic != 1784969216U) {
    {
#line 414
    warn("<warning, index file magic is wrong>\n");
    }
  } else
#line 415
  if ((int )index___0->version_major != 1) {
    {
#line 416
    warn("<warning, index version major is wrong (%d != %d)>\n", (int )index___0->version_major,
         1);
    }
  } else
#line 418
  if ((int )index___0->version_minor != 2) {
    {
#line 419
    warn("<warning, index version minor is wrong (%d != %d)>\n", (int )index___0->version_minor,
         2);
    }
  }
#line 422
  return (index___0);
}
}
#line 428 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.c"
int is_index_file(char const   *filename ) 
{ 
  int fd ;
  struct index head ;
  struct stat statbuf ;
  int i ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  {
#line 433
  i = 0;
#line 435
  fd = open(filename, 0);
  }
#line 435
  if (fd < 0) {
#line 436
    return (0);
  }
  {
#line 438
  tmp___0 = fstat(fd, & statbuf);
  }
#line 438
  if (tmp___0) {
    {
#line 439
    tmp = read(fd, (void *)(& head), sizeof(head));
#line 439
    i = (int )tmp;
    }
  }
  {
#line 441
  close(fd);
  }
#line 443
  if ((unsigned long )i != sizeof(head)) {
#line 444
    return (0);
  }
#line 446
  if (head.magic != 1784969216U) {
#line 447
    return (0);
  }
#line 449
  if ((__off_t )head.indexsize != statbuf.st_size) {
#line 450
    return (0);
  }
#line 452
  return (1);
}
}
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 20 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.h"
unsigned char *readline(unsigned char const   *prompt ) ;
#line 28
void add_history(unsigned char const   *text ) ;
#line 36
int jreadline_auto_romaji ;
#line 54
romaji_converter_t set_romaji_converter(void (*new___1)(unsigned char *buffer , unsigned char const   *bufend ,
                                                        unsigned char **cursorloc ,
                                                        unsigned char const   **eol ,
                                                        int force ) ) ;
#line 63
int (*jreadline_access)(unsigned char *line , unsigned char **dot , unsigned char **eol ) ;
#line 72
unsigned char const   *jreadline_mod_prompt(unsigned char const   *new___1 ) ;
#line 75
unsigned char const   *jreadline_last_prompt ;
#line 100
unsigned int jreadline_highbit_input(unsigned int selection ) ;
#line 7 "/home/wheatley/newnew/temp/lookup-1.08b/lib/strsave.h"
extern unsigned char *strsave(unsigned char const   * ) ;
#line 68 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static unsigned char start_of_line[201]  ;
#line 69 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static unsigned char *dot  =    start_of_line;
#line 70 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static unsigned char *end_of_line  =    start_of_line;
#line 100 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
__inline static int char_size(unsigned char *ptr ) 
{ 
  int size ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  size = (int )((int const   )euc_info[*ptr] & 3);
#line 105
  if (size == 0) {
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    return (1);
  }
#line 113
  return (size);
}
}
#line 119 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
__inline static int prev_char_size(unsigned char *mark ) 
{ 
  unsigned char *ptr ;
  int lastsize ;

  {
#line 122
  lastsize = 1;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  ptr = start_of_line;
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )ptr < (unsigned long )mark)) {
#line 125
      goto while_break___0;
    }
    {
#line 125
    lastsize = char_size(ptr);
#line 125
    ptr += lastsize;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 127
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 127
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 128
  return (lastsize);
}
}
#line 145 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static struct history_struct history_head  =    {& history_head, & history_head, (unsigned char const   *)0};
#line 151 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static struct history_struct *current_history_ptr  ;
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
unsigned char const   *jreadline_last_prompt  =    (unsigned char const   *)((void *)"> ");
#line 155 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
unsigned char const   *jreadline_mod_prompt(unsigned char const   *new___1 ) 
{ 
  unsigned char const   *old ;

  {
#line 158
  old = jreadline_last_prompt;
#line 159
  jreadline_last_prompt = new___1;
#line 160
  return (old);
}
}
#line 168 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void add_history(unsigned char const   *text ) 
{ 
  struct history_struct *new___1 ;
  void *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 173
  tmp = xmalloc((unsigned int )sizeof(struct history_struct ));
#line 173
  new___1 = (struct history_struct *)tmp;
#line 174
  tmp___0 = strsave((unsigned char const   *)((void *)text));
#line 174
  new___1->h_text = (unsigned char const   *)tmp___0;
#line 177
  new___1->h_prev = history_head.h_prev;
#line 178
  (new___1->h_prev)->h_next = new___1;
#line 179
  history_head.h_prev = new___1;
#line 180
  (history_head.h_prev)->h_next = & history_head;
  }
#line 181
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static unsigned int jreadline_active  ;
#line 184 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static unsigned int waiting_for_input  ;
#line 185 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static unsigned int jreadline_display_width  =    80U;
#line 201
static void update_display(int newline ) ;
#line 201 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int printed_last_time  =    0;
#line 199 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static void update_display(int newline ) 
{ 
  int text_len ;
  int prompt_len ;
  size_t tmp ;
  int total_len ;
  int starting_index ;
  int ending_index ;
  int len_printed_before_dot ;
  int len_printed_after_dot ;
  int printed_this_time ;
  int dot_index ;
  int print_only_until_dot ;
  unsigned int available_width ;
  int i ;
  int i___0 ;
  unsigned char c ;
  unsigned char const   *this_start ;
  unsigned char const   *this_end ;
  int tmp___0 ;
  unsigned char c___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *this_start___0 ;
  unsigned char const   *this_end___0 ;
  unsigned char c___1 ;
  unsigned char const   *tmp___2 ;
  int needed ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 202
  text_len = (int )(end_of_line - start_of_line);
#line 203
  tmp = strlen((char const   *)((void *)jreadline_last_prompt));
#line 203
  prompt_len = (int )tmp;
#line 204
  total_len = prompt_len + text_len;
#line 210
  dot_index = (int )((long )prompt_len + (dot - start_of_line));
#line 211
  print_only_until_dot = 0;
  }
#line 213
  if ((unsigned int )total_len < jreadline_display_width - 2U) {
#line 215
    starting_index = 0;
#line 216
    ending_index = total_len;
  } else {
#line 220
    available_width = jreadline_display_width - 1U;
#line 222
    ending_index = (int )((unsigned int )dot_index + available_width / 2U);
#line 223
    if (ending_index > total_len) {
#line 224
      ending_index = total_len;
    }
#line 226
    starting_index = (int )((unsigned int )ending_index - (available_width - 2U));
#line 227
    if (starting_index < 0) {
#line 228
      starting_index = 0;
    }
#line 229
    if (starting_index > 0) {
#line 232
      starting_index += 2;
#line 233
      available_width -= 2U;
#line 242
      if (starting_index < prompt_len) {
#line 248
        i = 0;
        {
#line 249
        while (1) {
          while_continue: /* CIL Label */ ;
#line 249
          if (! (i < starting_index)) {
#line 249
            goto while_break;
          }
#line 251
          if ((int const   )*(jreadline_last_prompt + i) & 128) {
#line 258
            i += 2;
          } else {
#line 261
            i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 263
        starting_index = i;
      } else {
#line 271
        i___0 = 0;
        {
#line 273
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 273
          if (! (prompt_len + i___0 < starting_index)) {
#line 273
            goto while_break___0;
          }
#line 275
          c = start_of_line[i___0];
#line 276
          if ((int )c & 128) {
#line 283
            i___0 += 2;
          } else {
#line 286
            i___0 ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 288
        starting_index = prompt_len + i___0;
      }
    }
#line 291
    ending_index = (int )((unsigned int )starting_index + available_width);
#line 292
    if (ending_index > total_len) {
#line 293
      ending_index = total_len;
    } else {
#line 295
      ending_index -= 2;
    }
  }
  {
#line 298
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 298
    if (! (dot_index >= starting_index)) {
      {
#line 298
      warn("\nassert(dot_index >= starting_index) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c",
           298);
      }
    }
#line 298
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 299
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 299
    if (! (dot_index <= ending_index)) {
      {
#line 299
      warn("\nassert(dot_index <= ending_index) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c",
           299);
      }
    }
#line 299
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 301
  output_pager_transparent(1);
  }
  again: 
  {
#line 304
  (*_output_char_function)((unsigned char )'\r');
#line 305
  len_printed_after_dot = 0;
  }
#line 306
  if (starting_index == 0) {
#line 307
    len_printed_before_dot = 0;
  } else {
    {
#line 310
    len_printed_before_dot = 2;
#line 311
    output("\241\304");
    }
  }
#line 315
  if (starting_index < prompt_len) {
#line 317
    this_start = jreadline_last_prompt + starting_index;
#line 317
    if (prompt_len < ending_index) {
#line 317
      tmp___0 = prompt_len;
    } else {
#line 317
      tmp___0 = ending_index;
    }
#line 317
    this_end = jreadline_last_prompt + tmp___0;
    {
#line 321
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 321
      if (! ((unsigned long )this_start < (unsigned long )this_end)) {
#line 321
        goto while_break___3;
      }
#line 323
      c___0 = (unsigned char )*this_start;
#line 324
      if (! ((int )c___0 & 128)) {
        {
#line 326
        (*_output_char_function)(c___0);
#line 327
        this_start ++;
#line 328
        len_printed_before_dot ++;
        }
      } else {
#line 332
        if ((unsigned long )(this_start + 2) > (unsigned long )this_end) {
#line 333
          goto while_break___3;
        }
        {
#line 334
        (*_output_char_function)(c___0);
#line 335
        this_start ++;
#line 340
        tmp___1 = this_start;
#line 340
        this_start ++;
#line 340
        (*_output_char_function)((unsigned char )*tmp___1);
#line 341
        len_printed_before_dot += 2;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 345
    if ((unsigned long )this_start > (unsigned long )this_end) {
#line 346
      len_printed_before_dot = (int )((long )len_printed_before_dot + (this_start - this_end));
    }
  }
#line 349
  if (ending_index > prompt_len) {
#line 351
    this_end___0 = (unsigned char const   *)(start_of_line + (ending_index - prompt_len));
#line 355
    if (starting_index <= prompt_len) {
#line 356
      this_start___0 = (unsigned char const   *)(start_of_line);
    } else {
#line 358
      this_start___0 = (unsigned char const   *)(start_of_line + (starting_index - prompt_len));
    }
    {
#line 360
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 360
      if (! ((unsigned long )this_start___0 < (unsigned long )this_end___0)) {
#line 360
        goto while_break___4;
      }
#line 362
      c___1 = (unsigned char )*this_start___0;
#line 363
      if (! ((int )c___1 & 128)) {
        {
#line 365
        (*_output_char_function)(c___1);
        }
#line 366
        if ((unsigned long )this_start___0 < (unsigned long )dot) {
#line 367
          len_printed_before_dot ++;
        } else {
#line 369
          len_printed_after_dot ++;
        }
#line 370
        this_start___0 ++;
      } else {
#line 374
        if ((unsigned long )(this_start___0 + 2) > (unsigned long )this_end___0) {
#line 375
          goto while_break___4;
        }
        {
#line 376
        (*_output_char_function)(c___1);
        }
#line 377
        if ((unsigned long )this_start___0 < (unsigned long )dot) {
#line 378
          len_printed_before_dot += 2;
        } else {
#line 380
          len_printed_after_dot += 2;
        }
        {
#line 381
        this_start___0 ++;
#line 387
        tmp___2 = this_start___0;
#line 387
        this_start___0 ++;
#line 387
        (*_output_char_function)((unsigned char )*tmp___2);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 392
  if (print_only_until_dot) {
#line 393
    goto done;
  }
#line 395
  if (ending_index != total_len) {
    {
#line 397
    output("\241\304");
#line 398
    len_printed_after_dot += 2;
    }
  }
#line 401
  printed_this_time = len_printed_before_dot + len_printed_after_dot;
#line 402
  if (printed_this_time < printed_last_time) {
#line 404
    if ((unsigned int )printed_last_time < jreadline_display_width) {
#line 404
      tmp___3 = (unsigned int )printed_last_time;
    } else {
#line 404
      tmp___3 = jreadline_display_width;
    }
#line 404
    needed = (int )(tmp___3 - (unsigned int )printed_this_time);
#line 406
    len_printed_after_dot += needed;
    {
#line 407
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 407
      tmp___4 = needed;
#line 407
      needed --;
#line 407
      if (! tmp___4) {
#line 407
        goto while_break___5;
      }
      {
#line 408
      (*_output_char_function)((unsigned char )' ');
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 410
  printed_last_time = printed_this_time;
#line 412
  if (len_printed_after_dot) {
#line 412
    if (! newline) {
#line 414
      if (len_printed_after_dot > len_printed_before_dot) {
#line 416
        ending_index = dot_index;
#line 417
        print_only_until_dot = 1;
#line 418
        goto again;
      } else {
        {
#line 420
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 420
          tmp___5 = len_printed_after_dot;
#line 420
          len_printed_after_dot --;
#line 420
          if (! tmp___5) {
#line 420
            goto while_break___6;
          }
          {
#line 421
          (*_output_char_function)((unsigned char )'\b');
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
  }
  done: 
#line 426
  if (newline) {
    {
#line 427
    (*_output_char_function)((unsigned char )'\n');
    }
  } else {
    {
#line 429
    flush_output();
    }
  }
  {
#line 431
  output_pager_transparent(0);
  }
#line 432
  return;
}
}
#line 434 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
unsigned int set_jreadline_width(unsigned int new___1 ) 
{ 
  unsigned int old ;

  {
#line 436
  old = jreadline_display_width;
#line 437
  jreadline_display_width = new___1;
#line 438
  if (waiting_for_input) {
    {
#line 439
    update_display(0);
    }
  }
#line 440
  return (old);
}
}
#line 458 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
int (*jreadline_access)(unsigned char *line , unsigned char **dot , unsigned char **eol )  =    (int (*)(unsigned char *line ,
            unsigned char **dot , unsigned char **eol ))0;
#line 461 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
int jreadline_auto_romaji  =    0;
#line 463 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static void (*romaji_converter)(unsigned char *buffer , unsigned char const   *bufend ,
                                unsigned char **cursorloc , unsigned char const   **eol ,
                                int force )  ;
#line 465 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
romaji_converter_t set_romaji_converter(void (*new___1)(unsigned char *buffer , unsigned char const   *bufend ,
                                                        unsigned char **cursorloc ,
                                                        unsigned char const   **eol ,
                                                        int force ) ) 
{ 
  void (*old)(unsigned char *buffer , unsigned char const   *bufend , unsigned char **cursorloc ,
              unsigned char const   **eol , int force ) ;

  {
#line 467
  old = romaji_converter;
#line 468
  romaji_converter = new___1;
#line 469
  return (old);
}
}
#line 482 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_convert_romaji(unsigned char c ) 
{ 


  {
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (romaji_converter) {
      {
#line 484
      (*romaji_converter)(start_of_line, (unsigned char const   *)(& start_of_line[sizeof(start_of_line)]),
                          & dot, (unsigned char const   **)(& end_of_line), 1);
      }
    }
#line 484
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  return (1);
}
}
#line 490 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_ring_bell(unsigned char c ) 
{ 


  {
  {
#line 492
  (*_output_char_function)((unsigned char )'\a');
#line 493
  flush_output();
  }
#line 494
  return (1);
}
}
#line 498 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_next_history_line(unsigned char c ) 
{ 
  int i ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 500
  if ((unsigned long )current_history_ptr->h_next == (unsigned long )(& history_head)) {
    {
#line 501
    bind_ring_bell(c);
    }
  } else {
#line 504
    i = 0;
#line 505
    current_history_ptr = current_history_ptr->h_next;
#line 511
    dot = start_of_line;
    {
#line 512
    while (1) {
      while_continue: /* CIL Label */ ;
#line 512
      tmp___0 = i;
#line 512
      i ++;
#line 512
      c = (unsigned char )*(current_history_ptr->h_text + tmp___0);
#line 512
      if (! ((int )c != 0)) {
#line 512
        goto while_break;
      }
#line 513
      tmp = dot;
#line 513
      dot ++;
#line 513
      *tmp = c;
    }
    while_break: /* CIL Label */ ;
    }
#line 515
    end_of_line = dot;
  }
#line 517
  return (1);
}
}
#line 521 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_previous_history_line(unsigned char c ) 
{ 
  int i ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 523
  if ((unsigned long )current_history_ptr->h_prev == (unsigned long )(& history_head)) {
    {
#line 524
    bind_ring_bell(c);
    }
  } else {
#line 527
    i = 0;
#line 529
    current_history_ptr = current_history_ptr->h_prev;
#line 535
    dot = start_of_line;
    {
#line 536
    while (1) {
      while_continue: /* CIL Label */ ;
#line 536
      tmp___0 = i;
#line 536
      i ++;
#line 536
      c = (unsigned char )*(current_history_ptr->h_text + tmp___0);
#line 536
      if (! ((int )c != 0)) {
#line 536
        goto while_break;
      }
#line 537
      tmp = dot;
#line 537
      dot ++;
#line 537
      *tmp = c;
    }
    while_break: /* CIL Label */ ;
    }
#line 538
    end_of_line = dot;
  }
#line 541
  return (1);
}
}
#line 545 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_redraw(unsigned char c ) 
{ 


  {
  {
#line 547
  update_display(1);
  }
#line 548
  return (1);
}
}
#line 552 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_EOL(unsigned char c ) 
{ 


  {
#line 554
  return (3);
}
}
#line 558 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int at_EOF(void) 
{ 


  {
#line 560
  if (end_of_line - start_of_line == 0L) {
#line 561
    return (2);
  } else {
#line 563
    return (3);
  }
}
}
#line 567 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_delete_char_backward(unsigned char c ) 
{ 
  unsigned int size ;
  int tmp ;

  {
#line 569
  if (! (! ((unsigned long )dot == (unsigned long )(start_of_line)))) {
    {
#line 570
    bind_ring_bell(c);
    }
  } else {
    {
#line 573
    tmp = prev_char_size(dot);
#line 573
    size = (unsigned int )tmp;
    }
#line 579
    if (! ((unsigned long )dot == (unsigned long )end_of_line)) {
      {
#line 580
      bcopy((void const   *)((char *)dot), (void *)((char *)(dot - size)), (size_t )((int )(end_of_line - dot)));
      }
    }
#line 581
    dot -= size;
#line 582
    end_of_line -= size;
  }
#line 584
  return (1);
}
}
#line 588 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_delete_char_forward(unsigned char c ) 
{ 
  int tmp ;
  unsigned int size ;
  int tmp___0 ;

  {
#line 590
  if (! (! ((unsigned long )dot == (unsigned long )end_of_line))) {
    {
#line 591
    tmp = bind_delete_char_backward(c);
    }
#line 591
    return (tmp);
  } else {
    {
#line 594
    tmp___0 = char_size(dot);
#line 594
    size = (unsigned int )tmp___0;
#line 596
    bcopy((void const   *)((char *)(dot + size)), (void *)((char *)dot), (size_t )((int )(end_of_line - dot)));
#line 597
    end_of_line -= size;
    }
  }
#line 599
  return (1);
}
}
#line 606 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_delete_char_forward_or_EOF(unsigned char c ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 608
  if (! ((unsigned long )dot == (unsigned long )end_of_line)) {
    {
#line 609
    tmp = bind_delete_char_forward(c);
    }
#line 609
    return (tmp);
  } else
#line 610
  if (! ((unsigned long )dot == (unsigned long )(start_of_line))) {
    {
#line 611
    tmp___0 = bind_delete_char_backward(c);
    }
#line 611
    return (tmp___0);
  } else {
    {
#line 613
    tmp___1 = at_EOF();
    }
#line 613
    return (tmp___1);
  }
}
}
#line 617 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_forward_character(unsigned char c ) 
{ 
  int tmp ;

  {
#line 619
  if (! (! ((unsigned long )dot == (unsigned long )end_of_line))) {
    {
#line 620
    bind_ring_bell(c);
    }
  } else {
    {
#line 622
    tmp = char_size(dot);
#line 622
    dot += tmp;
    }
  }
#line 623
  return (1);
}
}
#line 627 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_backward_character(unsigned char c ) 
{ 
  int tmp ;

  {
#line 629
  if (! (! ((unsigned long )dot == (unsigned long )(start_of_line)))) {
    {
#line 630
    bind_ring_bell(c);
    }
  } else {
    {
#line 632
    tmp = prev_char_size(dot);
#line 632
    dot -= tmp;
    }
  }
#line 633
  return (1);
}
}
#line 637 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_self_insert(unsigned char c ) 
{ 
  int length ;
  unsigned char *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 639
  if (! (end_of_line - start_of_line < 200L)) {
    {
#line 640
    bind_ring_bell(c);
    }
  } else {
#line 644
    length = (int )(end_of_line - dot);
#line 645
    if (length > 0) {
      {
#line 646
      bcopy((void const   *)((char *)dot), (void *)((char *)(dot + 1)), (size_t )length);
      }
    }
#line 649
    tmp = dot;
#line 649
    dot ++;
#line 649
    *tmp = c;
#line 652
    end_of_line ++;
#line 655
    if (jreadline_auto_romaji) {
#line 655
      if (((int )c & -128) == 0) {
        {
#line 655
        tmp___0 = __ctype_b_loc();
        }
#line 655
        if (! ((int const   )*(*tmp___0 + (int )c) & 8192)) {
          {
#line 656
          while (1) {
            while_continue: /* CIL Label */ ;
#line 656
            if (romaji_converter) {
              {
#line 656
              (*romaji_converter)(start_of_line, (unsigned char const   *)(& start_of_line[sizeof(start_of_line)]),
                                  & dot, (unsigned char const   **)(& end_of_line),
                                  0);
              }
            }
#line 656
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 659
  return (1);
}
}
#line 663 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_self_insert2(unsigned char c1 , unsigned char c2 ) 
{ 
  int length ;

  {
#line 665
  if (! (end_of_line - start_of_line < 199L)) {
    {
#line 666
    bind_ring_bell(c1);
    }
  } else {
#line 670
    length = (int )(end_of_line - dot);
#line 671
    if (length > 0) {
      {
#line 672
      bcopy((void const   *)((char *)dot), (void *)((char *)(dot + 2)), (size_t )length);
      }
    }
#line 675
    *(dot + 0) = c1;
#line 676
    *(dot + 1) = c2;
#line 677
    dot += 2;
#line 680
    end_of_line += 2;
  }
#line 682
  return (1);
}
}
#line 712 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_tab(unsigned char c ) 
{ 
  int tmp ;

  {
  {
#line 714
  tmp = bind_self_insert((unsigned char )' ');
  }
#line 714
  return (tmp);
}
}
#line 718 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_end_of_line(unsigned char c ) 
{ 


  {
#line 720
  dot = end_of_line;
#line 721
  return (1);
}
}
#line 725 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_kill_to_end(unsigned char c ) 
{ 


  {
#line 727
  end_of_line = dot;
#line 728
  return (1);
}
}
#line 732 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_start_of_line(unsigned char c ) 
{ 


  {
#line 734
  dot = start_of_line;
#line 735
  return (1);
}
}
#line 739 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_kill_to_start(unsigned char c ) 
{ 
  int len ;

  {
#line 741
  len = (int )(end_of_line - dot);
#line 743
  if (len == 0) {
#line 744
    dot = start_of_line;
#line 744
    end_of_line = dot;
  } else {
    {
#line 747
    bcopy((void const   *)((char *)dot), (void *)((char *)(start_of_line)), (size_t )len);
#line 748
    dot = start_of_line;
#line 749
    end_of_line = dot + len;
    }
  }
#line 751
  return (1);
}
}
#line 755 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static enum jis_mode jis_mode  ;
#line 767 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static enum hi_bit_mode hi_bit_mode  =    (enum hi_bit_mode )0;
#line 772 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
unsigned int jreadline_highbit_input(unsigned int selection ) 
{ 
  unsigned int old ;
  int tmp ;

  {
#line 774
  if ((unsigned int )hi_bit_mode == 0U) {
#line 774
    tmp = 1;
  } else {
#line 774
    tmp = 2;
  }
#line 774
  old = (unsigned int )tmp;
#line 775
  if (selection == 1U) {
#line 776
    hi_bit_mode = (enum hi_bit_mode )0;
  } else
#line 777
  if (selection == 2U) {
#line 778
    hi_bit_mode = (enum hi_bit_mode )1;
  }
#line 779
  return (old);
}
}
#line 782 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int bind_have_escape(unsigned char x ) 
{ 
  struct __anonstruct_escape_29 escape[7] ;
  int i ;
  int j ;
  int count ;
  unsigned char c ;
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 784
  escape[0].string = (unsigned char const   *)"$@";
#line 784
  escape[0].mode = (enum jis_mode )1;
#line 784
  escape[0].marker = 0;
#line 784
  escape[1].string = (unsigned char const   *)"$B";
#line 784
  escape[1].mode = (enum jis_mode )1;
#line 784
  escape[1].marker = 0;
#line 784
  escape[2].string = (unsigned char const   *)"$&@\033$B";
#line 784
  escape[2].mode = (enum jis_mode )1;
#line 784
  escape[2].marker = 0;
#line 784
  escape[3].string = (unsigned char const   *)"(J";
#line 784
  escape[3].mode = (enum jis_mode )0;
#line 784
  escape[3].marker = 0;
#line 784
  escape[4].string = (unsigned char const   *)"(H";
#line 784
  escape[4].mode = (enum jis_mode )0;
#line 784
  escape[4].marker = 0;
#line 784
  escape[5].string = (unsigned char const   *)"(B";
#line 784
  escape[5].mode = (enum jis_mode )0;
#line 784
  escape[5].marker = 0;
#line 784
  escape[6].string = (unsigned char const   *)"(I";
#line 784
  escape[6].mode = (enum jis_mode )2;
#line 784
  escape[6].marker = 0;
#line 804
  j = 0;
#line 806
  i = 0;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! ((unsigned long )i < sizeof(escape) / sizeof(escape[0]))) {
#line 806
      goto while_break;
    }
#line 807
    escape[i].marker = 1;
#line 806
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 809
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 811
    tmp = next_raw_input_byte();
#line 811
    c = tmp;
#line 813
    i = 0;
#line 813
    count = i;
    }
    {
#line 813
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 813
      if (! ((unsigned long )i < sizeof(escape) / sizeof(escape[0]))) {
#line 813
        goto while_break___1;
      }
#line 814
      if (escape[i].marker) {
#line 816
        if ((int const   )*(escape[i].string + j) != (int const   )c) {
#line 817
          escape[i].marker = 0;
        } else
#line 818
        if ((int const   )*(escape[i].string + (j + 1)) == 0) {
#line 820
          jis_mode = escape[i].mode;
#line 821
          return (1);
        } else {
#line 823
          count ++;
        }
      }
#line 813
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 825
    j ++;
#line 809
    if (! count) {
#line 809
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 828
  tmp___0 = bind_ring_bell((unsigned char)0);
  }
#line 828
  return (tmp___0);
}
}
#line 832 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int (*bind_action[32])(unsigned char c )  = 
#line 832
  {      & bind_convert_romaji,      & bind_start_of_line,      & bind_backward_character,      & bind_ring_bell, 
        & bind_delete_char_forward_or_EOF,      & bind_end_of_line,      & bind_forward_character,      & bind_delete_char_forward, 
        & bind_delete_char_backward,      & bind_tab,      & bind_EOL,      & bind_kill_to_end, 
        & bind_redraw,      & bind_EOL,      & bind_next_history_line,      & bind_ring_bell, 
        & bind_previous_history_line,      & bind_ring_bell,      & bind_redraw,      & bind_ring_bell, 
        & bind_ring_bell,      & bind_kill_to_start,      & bind_ring_bell,      & bind_ring_bell, 
        & bind_ring_bell,      & bind_ring_bell,      & bind_ring_bell,      & bind_have_escape, 
        & bind_ring_bell,      & bind_ring_bell,      & bind_ring_bell,      & bind_ring_bell};
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigsetmask)(int __mask )  __attribute__((__deprecated__)) ;
#line 882 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static jmp_buf top_level___0  ;
#line 884 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_int)(int  )  ;
#line 885 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_quit)(int  )  ;
#line 886 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_ill)(int  )  ;
#line 887 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_fpe)(int  )  ;
#line 888 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_bus)(int  )  ;
#line 889 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_segv)(int  )  ;
#line 891 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
void (*sig_tstp)(int  )  ;
#line 894 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static void release_signals(void) 
{ 


  {
  {
#line 896
  signal(2, sig_int);
#line 897
  signal(3, sig_quit);
#line 898
  signal(4, sig_ill);
#line 899
  signal(8, sig_fpe);
#line 900
  signal(7, sig_bus);
#line 901
  signal(11, sig_segv);
#line 903
  signal(20, sig_tstp);
  }
#line 905
  return;
}
}
#line 909
static int signal_handler(int sig , int code ) ;
#line 912 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static void grab_signals(void) 
{ 


  {
  {
#line 914
  sig_int = signal(2, (void (*)(int  ))((void *)(& signal_handler)));
#line 915
  sig_quit = signal(3, (void (*)(int  ))((void *)(& signal_handler)));
#line 916
  sig_ill = signal(4, (void (*)(int  ))((void *)(& signal_handler)));
#line 917
  sig_fpe = signal(8, (void (*)(int  ))((void *)(& signal_handler)));
#line 918
  sig_bus = signal(7, (void (*)(int  ))((void *)(& signal_handler)));
#line 919
  sig_segv = signal(11, (void (*)(int  ))((void *)(& signal_handler)));
#line 921
  sig_tstp = signal(20, (void (*)(int  ))((void *)(& signal_handler)));
  }
#line 923
  return;
}
}
#line 929 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
static int signal_handler(int sig , int code ) 
{ 
  __pid_t tmp ;

  {
  {
#line 932
  reset_tty_state();
#line 933
  release_signals();
#line 935
  tmp = getpid();
#line 935
  kill(tmp, sig);
#line 937
  sigsetmask(0);
  }
#line 942
  if (sig == 20) {
    {
#line 944
    update_display(0);
#line 945
    set_tty_state_to_cbreak();
#line 946
    grab_signals();
    }
#line 947
    return (0);
  }
  {
#line 950
  longjmp((struct __jmp_buf_tag *)(top_level___0), 1);
  }
#line 951
  return (0);
}
}
#line 959 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jreadline.c"
unsigned char *readline(unsigned char const   *prompt ) 
{ 
  int action ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
#line 961
  action = 1;
#line 967
  dot = start_of_line;
#line 967
  end_of_line = dot;
#line 970
  current_history_ptr = & history_head;
#line 972
  if (prompt) {
#line 972
    jreadline_last_prompt = prompt;
  } else {
#line 972
    jreadline_last_prompt = (unsigned char const   *)((void *)"");
  }
  {
#line 975
  jreadline_active = 1U;
#line 978
  set_tty_state_to_cbreak();
#line 981
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(top_level___0));
  }
#line 981
  if (tmp___0) {
    {
#line 982
    jreadline_active = 0U;
#line 983
    tmp = strsave((unsigned char const   *)"");
    }
#line 983
    return (tmp);
  }
  {
#line 985
  grab_signals();
#line 988
  jis_mode = (enum jis_mode )0;
  }
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 989
    if (! (action == 1)) {
#line 989
      goto while_break;
    }
    {
#line 994
    tmp___1 = flush_pending_input();
    }
#line 994
    if (! tmp___1) {
#line 996
      if (jreadline_access) {
        {
#line 997
        (*jreadline_access)(start_of_line, & dot, & end_of_line);
        }
      }
      {
#line 998
      update_display(0);
      }
    }
    {
#line 1001
    c1 = next_raw_input_byte();
    }
    use_c1: 
#line 1011
    if ((int )c1 & 128) {
#line 1014
      if ((unsigned int )hi_bit_mode == 0U) {
        {
#line 1016
        c2 = next_raw_input_byte();
        }
#line 1016
        if (((int )c2 & 128) == 0) {
          {
#line 1017
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1017
            c1 = c2;
#line 1017
            goto use_c1;
#line 1017
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 1030
        if ((int )c1 == 142) {
          {
#line 1032
          action = bind_self_insert2(c1, c2);
          }
        } else {
          {
#line 1034
          action = bind_self_insert2(c1, c2);
          }
        }
      } else
#line 1037
      if ((int )c1 >= 161) {
#line 1037
        if ((int )c1 <= 223) {
          {
#line 1039
          action = bind_self_insert2((unsigned char)142, c1);
          }
        } else {
#line 1037
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1041
        c2 = next_raw_input_byte();
        }
#line 1041
        if ((int )c2 < 64) {
          {
#line 1042
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1042
            c1 = c2;
#line 1042
            goto use_c1;
#line 1042
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1045
        if ((int )c2 < 159) {
#line 1045
          if ((int )c2 > 127) {
#line 1045
            tmp___2 = 32;
          } else {
#line 1045
            tmp___2 = 31;
          }
#line 1045
          tmp___3 = tmp___2;
        } else {
#line 1045
          tmp___3 = 126;
        }
#line 1045
        if ((int )c1 < 160) {
#line 1045
          tmp___4 = 112;
        } else {
#line 1045
          tmp___4 = 176;
        }
        {
#line 1045
        action = bind_self_insert2((unsigned char )(((((int )c1 - tmp___4) << 1) - ((int )c2 < 159)) | 128),
                                   (unsigned char )(((int )c2 - tmp___3) | 128));
        }
      }
    } else
#line 1051
    if ((int )c1 == 127) {
      {
#line 1052
      action = bind_delete_char_backward(c1);
      }
    } else
#line 1053
    if ((unsigned long )c1 < sizeof(bind_action) / sizeof(bind_action[0])) {
      {
#line 1055
      jis_mode = (enum jis_mode )0;
#line 1056
      action = (*(bind_action[(int )c1]))(c1);
      }
    } else
#line 1058
    if ((unsigned int )jis_mode == 0U) {
      {
#line 1059
      action = bind_self_insert(c1);
      }
    } else
#line 1060
    if ((unsigned int )jis_mode == 2U) {
      {
#line 1061
      bind_self_insert2((unsigned char)142, (unsigned char )((int )c1 | 128));
      }
    } else {
      {
#line 1063
      c2 = next_raw_input_byte();
#line 1069
      bind_self_insert2((unsigned char )((int )c1 | 128), (unsigned char )((int )c2 | 128));
      }
    }
#line 1071
    *end_of_line = (unsigned char)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1072
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1072
    if (! (action == 1)) {
#line 1072
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1080
  if (jreadline_auto_romaji) {
#line 1082
    tmp___5 = end_of_line;
#line 1082
    end_of_line ++;
#line 1082
    *tmp___5 = (unsigned char )'x';
#line 1083
    dot = end_of_line;
#line 1083
    *dot = (unsigned char )'\000';
    {
#line 1084
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1084
      if (romaji_converter) {
        {
#line 1084
        (*romaji_converter)(start_of_line, (unsigned char const   *)(& start_of_line[sizeof(start_of_line)]),
                            & dot, (unsigned char const   **)(& end_of_line), 0);
        }
      }
#line 1084
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1085
    end_of_line --;
#line 1085
    dot = end_of_line;
#line 1085
    *dot = (unsigned char )'\000';
  }
  {
#line 1089
  update_display(1);
#line 1091
  reset_tty_state();
#line 1093
  release_signals();
#line 1096
  jreadline_active = 0U;
  }
#line 1097
  if (action == 2) {
#line 1097
    tmp___7 = (unsigned char *)((void *)0);
  } else {
    {
#line 1097
    tmp___6 = strsave((unsigned char const   *)(start_of_line));
#line 1097
    tmp___7 = tmp___6;
    }
  }
#line 1097
  return (tmp___7);
}
}
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 38 "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h"
__inline static void FillMemPage(MemItem *m , MemLoc start ) 
{ 
  void *tmp ;
  MemLoc tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 41
  if (! m->data) {
#line 42
    if (! m->datalen) {
#line 43
      m->datalen = 512U;
    }
    {
#line 44
    tmp = xmalloc(m->datalen);
#line 44
    m->data = (unsigned char *)tmp;
    }
  }
  {
#line 46
  tmp___0 = start;
#line 46
  m->start = tmp___0;
#line 46
  tmp___1 = fseek(m->fp, tmp___0, 0);
  }
#line 46
  if (tmp___1 != 0) {
    {
#line 47
    die("Bad fseek to %ld (fp=%x) at %s line %d: %n\n", (unsigned int )m->start, m->fp,
        "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h", 48);
    }
  }
  {
#line 50
  tmp___2 = fread((void */* __restrict  */)m->data, (size_t )1, (size_t )m->datalen,
                  (FILE */* __restrict  */)m->fp);
#line 50
  m->end = (MemLoc )((size_t )start + tmp___2);
  }
#line 51
  return;
}
}
#line 56 "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h"
__inline static unsigned char GetMemByte(MemItem *m ) 
{ 
  MemLoc tmp ;

  {
#line 59
  if (! m->data) {
    {
#line 60
    FillMemPage(m, m->loc);
    }
  } else
#line 59
  if (m->loc < m->start) {
    {
#line 60
    FillMemPage(m, m->loc);
    }
  } else
#line 59
  if (m->loc >= m->end) {
    {
#line 60
    FillMemPage(m, m->loc);
    }
  }
#line 61
  tmp = m->loc;
#line 61
  (m->loc) ++;
#line 61
  return (*(m->data + (tmp - m->start)));
}
}
#line 67 "/home/wheatley/newnew/temp/lookup-1.08b/lib/MemItem.h"
__inline static void SetMem(MemItem *m , FILE *fp , MemLoc loc ) 
{ 
  MemLoc tmp ;

  {
  {
#line 70
  m->fp = fp;
#line 71
  tmp = loc;
#line 71
  m->loc = tmp;
#line 71
  FillMemPage(m, tmp);
  }
#line 72
  return;
}
}
#line 75 "/home/wheatley/newnew/temp/lookup-1.08b/lib/packed_list.h"
__inline static unsigned long read_packed_value(unsigned char const   **pptr ) 
{ 
  unsigned char c ;
  unsigned long value ;
  unsigned int shift ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 82
  tmp = *pptr;
#line 82
  (*pptr) ++;
#line 82
  c = (unsigned char )*tmp;
#line 82
  if (((int )c & (1 << 7)) == 0) {
#line 83
    return ((unsigned long )c);
  }
#line 85
  value = (unsigned long )((int )c & ((1 << 7) - 1));
#line 86
  shift = 7U;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    tmp___0 = *pptr;
#line 87
    (*pptr) ++;
#line 87
    c = (unsigned char )*tmp___0;
#line 87
    if (! ((int )c & (1 << 7))) {
#line 87
      goto while_break;
    }
#line 88
    value |= (unsigned long )(((int )c & ((1 << 7) - 1)) << shift);
#line 89
    shift += 7U;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  value |= (unsigned long )((int )c << shift);
#line 93
  return (value);
}
}
#line 115 "/home/wheatley/newnew/temp/lookup-1.08b/lib/packed_list.h"
__inline static unsigned long mem_read_packed_value(MemItem *mem ) 
{ 
  unsigned char c ;
  unsigned long value ;
  unsigned int shift ;

  {
  {
#line 122
  c = GetMemByte(mem);
  }
#line 122
  if (((int )c & (1 << 7)) == 0) {
#line 123
    return ((unsigned long )c);
  }
#line 125
  value = (unsigned long )((int )c & ((1 << 7) - 1));
#line 126
  shift = 7U;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 127
    c = GetMemByte(mem);
    }
#line 127
    if (! ((int )c & (1 << 7))) {
#line 127
      goto while_break;
    }
#line 128
    value |= (unsigned long )(((int )c & ((1 << 7) - 1)) << shift);
#line 129
    shift += 7U;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  value |= (unsigned long )((int )c << shift);
#line 133
  return (value);
}
}
#line 176 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
__inline static int get_index_count(struct index  const  *i , unsigned char hi___1 ,
                                    unsigned char lo , elementcount *dest ) 
{ 


  {
#line 181
  if ((int )lo < (int )i->hi[hi___1].first_lo) {
#line 182
    return (0);
  } else
#line 181
  if ((int )lo >= (int )i->hi[hi___1].end_lo) {
#line 182
    return (0);
  }
#line 184
  *dest = *((elementcount *)((unsigned char const   *)i + i->hi[hi___1].listcount) + ((int )lo - (int )i->hi[hi___1].first_lo));
#line 186
  return (1);
}
}
#line 196 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
__inline static int mem_get_index_count(struct index  const  *i , unsigned char hi___1 ,
                                        unsigned char lo , elementcount *dest ) 
{ 
  long loc ;
  int tmp ;

  {
#line 204
  if ((int )lo < (int )i->hi[hi___1].first_lo) {
#line 205
    return (0);
  } else
#line 204
  if ((int )lo >= (int )i->hi[hi___1].end_lo) {
#line 205
    return (0);
  }
  {
#line 208
  loc = (long )((elementcount *)((unsigned char const   *)0 + i->hi[hi___1].listcount) + ((int )lo - (int )i->hi[hi___1].first_lo));
#line 211
  tmp = fseek((FILE *)i->FileP, loc, 0);
  }
#line 211
  if (tmp != 0) {
    {
#line 212
    die("bad fseek to %ld (fp=%x) at %s line %d, returned %ld: %n\n", loc, i->FileP,
        "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h", 213);
    }
  }
  {
#line 215
  fread((void */* __restrict  */)dest, sizeof(elementcount ), (size_t )1, (FILE */* __restrict  */)i->FileP);
  }
#line 216
  return (1);
}
}
#line 220 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
__inline static int get_index_list(struct index  const  *i , unsigned char hi___1 ,
                                   unsigned char lo , unsigned char const   **dest ) 
{ 
  IndexOffset listoffset ;

  {
#line 227
  if ((int )lo < (int )i->hi[hi___1].first_lo) {
#line 228
    return (0);
  } else
#line 227
  if ((int )lo >= (int )i->hi[hi___1].end_lo) {
#line 228
    return (0);
  } else {
#line 230
    listoffset = *((IndexOffset *)((unsigned char const   *)i + i->hi[hi___1].shifted_lo) + ((int )lo - (int )i->hi[hi___1].first_lo));
#line 233
    *dest = (unsigned char const   *)((unsigned char *)((unsigned char const   *)i + listoffset));
#line 234
    return (1);
  }
}
}
#line 238 "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h"
__inline static int mem_get_index_list(struct index  const  *i , unsigned char hi___1 ,
                                       unsigned char lo , IndexOffset *dest ) 
{ 
  long loc ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 245
  if ((int )lo < (int )i->hi[hi___1].first_lo) {
#line 246
    return (0);
  } else
#line 245
  if ((int )lo >= (int )i->hi[hi___1].end_lo) {
#line 246
    return (0);
  } else {
    {
#line 248
    loc = (long )((IndexOffset *)((unsigned char const   *)0 + i->hi[hi___1].shifted_lo) + ((int )lo - (int )i->hi[hi___1].first_lo));
#line 251
    tmp = fseek((FILE *)i->FileP, loc, 0);
    }
#line 251
    if (tmp != 0) {
      {
#line 252
      die("bad fseek to %ld (fp=%x) at %s line %d, returned %ld: %n\n", loc, i->FileP,
          "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h", 253);
      }
    }
    {
#line 255
    tmp___0 = fread((void */* __restrict  */)dest, sizeof(*dest), (size_t )1, (FILE */* __restrict  */)i->FileP);
    }
#line 255
    if (tmp___0 != 1UL) {
      {
#line 256
      die("bad read from fp=%x at %s line %d: %n\n", i->FileP, "/home/wheatley/newnew/temp/lookup-1.08b/lib/index.h",
          257);
      }
    }
#line 258
    return (1);
  }
}
}
#line 104 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
int regcomp(regex_t *r , unsigned char const   *pattern , unsigned int flags___0 ) ;
#line 201
unsigned int regexec(regex_t const   *r , unsigned char const   *line___1 , unsigned int len ) ;
#line 211
unsigned char const   *regexec_match_start ;
#line 212
unsigned char const   *regexec_match_end ;
#line 219
int regexec_match_at_start_of_word ;
#line 220
int regexec_match_at_end_of_word ;
#line 245
unsigned int regexec_setflags(unsigned int flags___0 ) ;
#line 258
void regfree(regex_t *r ) ;
#line 266
unsigned char const   *regmusthave(regex_t const   *r ) ;
#line 277
unsigned char const   *regcomp_error_report(void) ;
#line 283
void showregex(regex_t const   *r ) ;
#line 20 "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.h"
unsigned int apply_substitution(regex_t const   *compiled , unsigned char **new___1 ,
                                unsigned int *matchcount , unsigned char const   *str___0 ,
                                unsigned int str_len , unsigned char const   *replace ,
                                unsigned int count ) ;
#line 247 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
unsigned char const   *current_log_file ;
#line 260
void output_line(struct slot_info  const  *slot , unsigned char const   *line___1 ,
                 unsigned int length ) ;
#line 261
void apply_regex(void) ;
#line 41 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
static unsigned char *new  =    (unsigned char *)0;
#line 101 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
static char const   *styles[12]  = 
#line 101
  {      "\033[7m",      "\033[1m",      "\033[4m",      "\033[5m", 
        "\033[31m",      "\033[32m",      "\033[33m",      "\033[34m", 
        "\033[35m",      "\033[36m",      "\033[37m",      "\033[30m"};
#line 35 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
void output_line(struct slot_info  const  *slot , unsigned char const   *line___1 ,
                 unsigned int length ) 
{ 
  int retval ;
  int tmp ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  int log_fd ;
  int tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned char const   *lineend ;
  unsigned char const   *tmp___5 ;
  char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (slot->current_flag.modify) {
#line 44
    if (new) {
      {
#line 45
      free((void *)new);
      }
    }
#line 47
    if (slot->onefile_or_combo.onefile._modify_.global) {
#line 47
      tmp = 1000;
    } else {
#line 47
      tmp = 1;
    }
    {
#line 47
    tmp___0 = apply_substitution(& slot->onefile_or_combo.onefile._modify_.regex,
                                 & new, (unsigned int *)0, line___1, length, (unsigned char const   *)slot->onefile_or_combo.onefile._modify_.replacement,
                                 (unsigned int )tmp);
#line 47
    retval = (int )tmp___0;
    }
#line 50
    if (retval != 0) {
#line 51
      new = (unsigned char *)0;
    } else {
      {
#line 53
      line___1 = (unsigned char const   *)new;
#line 53
      tmp___1 = strlen((char const   *)((void *)line___1));
#line 53
      length = (unsigned int )tmp___1;
      }
    }
  }
#line 56
  if (slot->current_flag.tag) {
    {
#line 58
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 58
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 59
    output((char const   *)slot->onefile_or_combo.onefile._tag_);
    }
  }
#line 65
  if ((int const   )*(line___1 + 0) == 9) {
#line 65
    if (lookup.spinner.interval) {
      {
#line 74
      tmp___2 = set_extra_output_file(-2);
#line 74
      log_fd = tmp___2;
      }
#line 75
      if ((unsigned long )current_log_file == (unsigned long )((unsigned char const   *)0)) {
        {
#line 76
        (*_output_char_function)((unsigned char )' ');
        }
      } else {
        {
#line 78
        flush_output();
#line 79
        set_extra_output_file(-3);
#line 80
        (*_output_char_function)((unsigned char )' ');
#line 81
        flush_output();
#line 82
        set_extra_output_file(log_fd);
        }
      }
    }
  }
#line 93
  if (! slot->current_flag.highlight) {
#line 93
    goto _L;
  } else {
    {
#line 93
    tmp___9 = regexec((regex_t const   *)(& lookup.search[0].regex), line___1, length);
    }
#line 93
    if (tmp___9) {
#line 93
      if ((unsigned long )regexec_match_start == (unsigned long )regexec_match_end) {
        _L: /* CIL Label */ 
        {
#line 97
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 97
          tmp___4 = length;
#line 97
          length --;
#line 97
          if (! tmp___4) {
#line 97
            goto while_break___1;
          }
          {
#line 98
          tmp___3 = line___1;
#line 98
          line___1 ++;
#line 98
          (*_output_char_function)((unsigned char )*tmp___3);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 100
        lineend = line___1 + length;
        {
#line 103
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 103
          if (! ((unsigned long )line___1 < (unsigned long )regexec_match_start)) {
#line 103
            goto while_break___2;
          }
          {
#line 104
          tmp___5 = line___1;
#line 104
          line___1 ++;
#line 104
          (*_output_char_function)((unsigned char )*tmp___5);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 106
        output_pager_transparent(1);
        }
#line 108
        if (lookup.flag.hl_style == 12U) {
#line 108
          tmp___6 = (char const   *)(lookup.slot)->onefile_or_combo.onefile._highlight_tag_;
        } else {
#line 108
          tmp___6 = styles[lookup.flag.hl_style];
        }
        {
#line 108
        output(tmp___6);
#line 112
        output_pager_transparent(0);
        }
        {
#line 114
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 114
          if (! ((unsigned long )regexec_match_start < (unsigned long )regexec_match_end)) {
#line 114
            goto while_break___3;
          }
          {
#line 115
          tmp___7 = regexec_match_start;
#line 115
          regexec_match_start ++;
#line 115
          (*_output_char_function)((unsigned char )*tmp___7);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 117
        output_pager_transparent(1);
        }
#line 118
        if (lookup.flag.hl_style != 12U) {
          {
#line 119
          output("\033[0m");
          }
        } else {
          {
#line 121
          outputf("</%s", (lookup.slot)->onefile_or_combo.onefile._highlight_tag_ + 1);
          }
        }
        {
#line 123
        output_pager_transparent(0);
        }
        {
#line 125
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 125
          if (! ((unsigned long )regexec_match_end < (unsigned long )lineend)) {
#line 125
            goto while_break___4;
          }
          {
#line 126
          tmp___8 = regexec_match_end;
#line 126
          regexec_match_end ++;
#line 126
          (*_output_char_function)((unsigned char )*tmp___8);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else {
#line 93
      goto _L;
    }
  }
  {
#line 129
  (*_output_char_function)((unsigned char )'\n');
  }
#line 130
  return;
}
}
#line 135 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
__inline static void save_to_list(fileloc line___1 , struct slot_info  const  *slot ) 
{ 
  unsigned int tmp ;

  {
#line 138
  if (lookup.list.used >= lookup.list.size) {
#line 139
    (lookup.list.overflow) ++;
  } else {
#line 142
    (lookup.list.array + lookup.list.used)->slot = slot;
#line 143
    tmp = lookup.list.used;
#line 143
    (lookup.list.used) ++;
#line 143
    (lookup.list.array + tmp)->line = line___1;
  }
#line 145
  return;
}
}
#line 153 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
static int matchedline(struct slot_info  const  *slot , unsigned char const   *line___1 ,
                       fileloc loc , unsigned int length ) 
{ 
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
#line 159
  (lookup.count.matched) ++;
#line 162
  if (slot->current_flag.filter) {
    {
#line 162
    tmp = regexec(& slot->onefile_or_combo.onefile._filter_.regex, line___1, length);
    }
#line 162
    if (slot->onefile_or_combo.onefile._filter_.negative != (unsigned int const   )tmp) {
#line 165
      (lookup.count.filtered) ++;
#line 166
      if (! lookup.count.nonword) {
#line 169
        if (lookup.count.filtered == 1UL) {
#line 171
          lookup.spinner.chars = (unsigned char const   *)"\250\241\241\277\250\242\241\300\241\373";
#line 172
          lookup.spinner.char_count = (unsigned char)5;
        }
        {
#line 175
        save_to_list(loc, slot);
        }
      }
#line 177
      return (0);
    }
  }
#line 181
  if (slot->current_flag.word) {
#line 181
    if (regexec_match_at_start_of_word) {
#line 181
      if (! regexec_match_at_end_of_word) {
#line 181
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 184
      tmp___0 = lookup.count.nonword;
#line 184
      (lookup.count.nonword) ++;
#line 184
      if (tmp___0 == 0UL) {
#line 187
        lookup.list.used = 0U;
#line 187
        lookup.list.overflow = lookup.list.used;
#line 189
        lookup.spinner.chars = (unsigned char const   *)"\250\241\241\277\250\242\241\300\241\375";
#line 190
        lookup.spinner.char_count = (unsigned char)5;
      }
      {
#line 193
      save_to_list(loc, slot);
      }
#line 194
      return (0);
    }
  }
#line 197
  if (lookup.lines_to_print_this_time) {
#line 197
    (lookup.lines_to_print_this_time) --;
#line 197
    if (! lookup.lines_to_print_this_time) {
#line 199
      if (slot->current_flag.display) {
        {
#line 200
        output("\242\343search aborted: matched-line count over limit\242\344\n");
        }
      }
#line 201
      return (1);
    }
  }
#line 204
  (lookup.count.printed) ++;
#line 205
  if (slot->current_flag.display) {
    {
#line 206
    output_line(slot, line___1, length);
    }
  }
#line 207
  return (0);
}
}
#line 290 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
unsigned int volatile   apply_regex_abort  =    (unsigned int volatile   )0;
#line 303 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
static MemItem mem_packed_list_ptr[10]  ;
#line 292 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
static int apply_regex_to_file(struct slot_info  const  *slot ) 
{ 
  unsigned int charcount[10] ;
  unsigned int spinner_position ;
  int till_next_spinner ;
  unsigned char const   *packed_list_ptr[10] ;
  fileloc current_line[10] ;
  int used ;
  int ret ;
  int i ;
  unsigned char HI[10] ;
  unsigned char LO[10] ;
  unsigned int pat_index ;
  unsigned char const   *list ;
  unsigned int first_pattern_flags ;
  unsigned int nonfirst_pattern_flags ;
  unsigned int generic_flags ;
  int MemIndex ;
  int tmp ;
  unsigned int these_flags ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char hi___1 ;
  unsigned char lo ;
  elementcount count ;
  int res ;
  unsigned int tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  IndexOffset io ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  fileloc line___1 ;
  fileloc end ;
  unsigned int len ;
  unsigned int _length_ ;
  VirtFile *v ;
  fileloc pos ;
  unsigned char const   *_text_ ;
  unsigned char const   *tmp___16 ;
  int _i_ ;
  int log_fd ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int holdsmax ;
  fileloc max ;
  fileloc startmax ;
  unsigned long tmp___20 ;
  unsigned long tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long tmp___23 ;
  unsigned int len___0 ;
  unsigned int _length____0 ;
  VirtFile *v___0 ;
  fileloc pos___0 ;
  unsigned char const   *_text____0 ;
  unsigned char const   *tmp___24 ;
  int _i____0 ;
  int log_fd___0 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;

  {
#line 297
  spinner_position = 0U;
#line 298
  till_next_spinner = 0;
#line 307
  used = 0;
#line 314
  pat_index = 0U;
#line 315
  list = (unsigned char const   *)0;
#line 321
  generic_flags = 0U;
#line 322
  MemIndex = (unsigned long )((slot->file)->index)->FileP != (unsigned long )((void *)0);
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 326
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 327
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 327
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 329
  if (slot->current_flag.fuzz) {
#line 330
    generic_flags |= 256U;
  }
#line 332
  if (slot->current_flag.fold) {
#line 333
    generic_flags |= 12U;
  }
#line 335
  if (lookup.flag.regex_debug) {
#line 336
    generic_flags |= 1U;
  }
#line 338
  if (slot->current_flag.word) {
#line 338
    tmp = 128;
  } else {
#line 338
    tmp = 16;
  }
#line 338
  first_pattern_flags = (32U | generic_flags) | (unsigned int )tmp;
#line 342
  nonfirst_pattern_flags = generic_flags | 16U;
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 345
    if (! (i < 10)) {
#line 345
      goto while_break___3;
    }
    {
#line 346
    regfree(& lookup.search[i].regex);
#line 345
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 348
  i = 0;
  {
#line 348
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 348
    if (! (i < lookup.patterns)) {
#line 348
      goto while_break___4;
    }
#line 350
    if (i == 0) {
#line 350
      tmp___0 = first_pattern_flags;
    } else {
#line 350
      tmp___0 = nonfirst_pattern_flags;
    }
#line 350
    these_flags = tmp___0;
#line 352
    if (! lookup.search[i].not) {
#line 353
      these_flags |= 32U;
    }
    {
#line 355
    ret = regcomp(& lookup.search[i].regex, lookup.search[i].pattern, these_flags);
    }
#line 357
    if (ret == 13) {
      {
#line 358
      ret = regcomp(& lookup.search[i].regex, lookup.search[i].pattern, these_flags | 64U);
      }
    }
#line 361
    if (lookup.flag.debug) {
#line 363
      if (lookup.search[i].not) {
#line 363
        tmp___1 = "NOT ";
      } else {
#line 363
        tmp___1 = "";
      }
      {
#line 363
      outputf("pattern: %s>> %s <<\n", tmp___1, lookup.search[i].pattern);
#line 365
      showregex((regex_t const   *)(& lookup.search[i].regex));
      }
    }
#line 368
    if (ret != 0) {
#line 370
      if (lookup.flag.debug) {
        {
#line 371
        outputf("[bad regcomp returns %d]\n", ret);
        }
      }
      {
#line 372
      tmp___2 = regcomp_error_report();
#line 372
      output((char const   *)tmp___2);
      }
#line 373
      return (1);
    }
#line 348
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 401
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 401
    if (! (used < 10)) {
#line 401
      goto while_break___5;
    }
    {
#line 407
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 407
      if (! ((unsigned long )list == (unsigned long )((unsigned char const   *)0))) {
#line 407
        if (! ((int const   )*(list + 0) == 0)) {
#line 407
          goto while_break___6;
        }
      }
#line 409
      if (pat_index >= (unsigned int )lookup.patterns) {
#line 411
        list = (unsigned char const   *)0;
#line 412
        goto while_break___6;
      }
      {
#line 414
      tmp___3 = pat_index;
#line 414
      pat_index ++;
#line 414
      list = regmusthave((regex_t const   *)(& lookup.search[tmp___3].regex));
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 416
    if ((unsigned long )list == (unsigned long )((unsigned char const   *)0)) {
#line 417
      goto while_break___5;
    }
#line 420
    if ((int const   )*(list + 0) & 128) {
#line 421
      tmp___4 = list;
#line 421
      list ++;
#line 421
      hi___1 = (unsigned char )((int const   )*tmp___4 & 127);
#line 422
      tmp___5 = list;
#line 422
      list ++;
#line 422
      lo = (unsigned char )((int const   )*tmp___5 & 127);
#line 423
      if ((int )hi___1 == 37) {
#line 424
        hi___1 = (unsigned char)36;
      }
    } else {
      {
#line 426
      hi___1 = (unsigned char)0;
#line 427
      tmp___6 = list;
#line 427
      list ++;
#line 427
      lo = (unsigned char )*tmp___6;
#line 428
      tmp___8 = __ctype_b_loc();
      }
#line 428
      if ((int const   )*(*tmp___8 + (int )lo) & 256) {
        {
#line 429
        tmp___7 = tolower((int )lo);
#line 429
        lo = (unsigned char )tmp___7;
        }
      }
    }
#line 433
    i = 0;
    {
#line 433
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 433
      if (! (i < used)) {
#line 433
        goto while_break___7;
      }
#line 434
      if ((int )LO[i] == (int )lo) {
#line 434
        if ((int )HI[i] == (int )hi___1) {
#line 435
          goto while_break___7;
        }
      }
#line 433
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 436
    if (i < used) {
#line 439
      goto while_continue___5;
    }
#line 443
    if (MemIndex) {
      {
#line 444
      res = mem_get_index_count((slot->file)->index, hi___1, lo, & count);
      }
    } else {
      {
#line 446
      res = get_index_count((slot->file)->index, hi___1, lo, & count);
      }
    }
#line 448
    if (! res) {
#line 448
      goto _L___0;
    } else
#line 448
    if ((int )count == 0) {
      _L___0: /* CIL Label */ 
#line 450
      if ((int )hi___1 != 0) {
#line 450
        goto _L;
      } else {
        {
#line 450
        tmp___11 = __ctype_b_loc();
        }
#line 450
        if ((int const   )*(*tmp___11 + (int )lo) & 8) {
          _L: /* CIL Label */ 
#line 452
          if (lookup.flag.debug) {
#line 454
            if (hi___1) {
#line 454
              tmp___9 = (int )lo | 128;
            } else {
#line 454
              tmp___9 = (int )lo;
            }
#line 454
            if (hi___1) {
#line 454
              tmp___10 = (int )hi___1 | 128;
            } else {
#line 454
              tmp___10 = (int )hi___1;
            }
            {
#line 454
            outputf("Character [%c%c] not in index; apparently no lines in the file contain it.\n",
                    tmp___10, tmp___9);
            }
          }
#line 459
          return (0);
        }
      }
#line 462
      goto while_continue___5;
    }
#line 466
    if ((int )count == 65535) {
#line 467
      goto while_continue___5;
    }
#line 471
    if (MemIndex) {
      {
#line 473
      res = mem_get_index_list((slot->file)->index, hi___1, lo, & io);
#line 474
      SetMem(& mem_packed_list_ptr[used], (FILE *)((slot->file)->index)->FileP, (MemLoc )io);
      }
    } else {
      {
#line 476
      res = get_index_list((slot->file)->index, hi___1, lo, & packed_list_ptr[used]);
      }
    }
#line 480
    if (! res) {
      {
#line 481
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 481
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 483
    HI[used] = hi___1;
#line 484
    LO[used] = lo;
#line 485
    charcount[used] = (unsigned int )count;
#line 492
    current_line[used] = (fileloc )0;
#line 493
    if (MemIndex) {
#line 493
      if (charcount[used] == 0U) {
#line 493
        tmp___13 = 0xffffffffffffffffUL;
      } else {
        {
#line 493
        (charcount[used]) --;
#line 493
        tmp___12 = mem_read_packed_value(& mem_packed_list_ptr[used]);
#line 493
        tmp___13 = (unsigned long )current_line[used] + tmp___12;
        }
      }
#line 493
      current_line[used] = (fileloc )tmp___13;
    } else {
#line 493
      if (charcount[used] == 0U) {
#line 493
        tmp___15 = 0xffffffffffffffffUL;
      } else {
        {
#line 493
        (charcount[used]) --;
#line 493
        tmp___14 = read_packed_value(& packed_list_ptr[used]);
#line 493
        tmp___15 = (unsigned long )current_line[used] + tmp___14;
        }
      }
#line 493
      current_line[used] = (fileloc )tmp___15;
    }
#line 494
    used ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 498
  if (used) {
#line 498
    if (lookup.flag.debug) {
      {
#line 500
      output("looking for lines with characters [");
#line 501
      i = 0;
      }
      {
#line 501
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 501
        if (! (i < used)) {
#line 501
          goto while_break___9;
        }
#line 503
        if ((int )HI[i] == 0) {
          {
#line 504
          (*_output_char_function)(LO[i]);
          }
        } else {
          {
#line 507
          (*_output_char_function)((unsigned char )((int )HI[i] | 128));
#line 508
          (*_output_char_function)((unsigned char )((int )LO[i] | 128));
          }
        }
#line 501
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 511
      output("]\n");
      }
    }
  }
#line 514
  if (used == 0) {
#line 517
    line___1 = (fileloc )0;
#line 518
    end = ((slot->file)->v)->length;
#line 520
    if (lookup.flag.debug) {
      {
#line 521
      output("[checking all lines]\n");
      }
    }
    {
#line 523
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 523
      if (! (line___1 < end)) {
#line 523
        goto while_break___10;
      }
      {
#line 526
      v = (slot->file)->v;
#line 526
      pos = line___1;
#line 526
      tmp___16 = VirtPos2Str(v, pos, & _length_);
#line 526
      _text_ = tmp___16;
#line 526
      len = _length_;
#line 526
      (lookup.count.checked) ++;
      }
#line 526
      if (lookup.spinner.interval) {
#line 526
        till_next_spinner --;
#line 526
        if (till_next_spinner < 0) {
#line 526
          log_fd = 0;
#line 526
          if ((unsigned long )current_log_file != (unsigned long )((unsigned char const   *)0)) {
            {
#line 526
            log_fd = set_extra_output_file(-2);
#line 526
            flush_output();
#line 526
            set_extra_output_file(-3);
            }
          }
#line 526
          spinner_position ++;
#line 526
          if (spinner_position >= (unsigned int )lookup.spinner.char_count) {
#line 526
            spinner_position = 0U;
          }
          {
#line 526
          (*_output_char_function)((unsigned char )*(lookup.spinner.chars + spinner_position * 2U));
#line 526
          (*_output_char_function)((unsigned char )*(lookup.spinner.chars + (spinner_position * 2U + 1U)));
#line 526
          (*_output_char_function)((unsigned char )'\r');
#line 526
          flush_output();
          }
#line 526
          if ((unsigned long )current_log_file != (unsigned long )((unsigned char const   *)0)) {
            {
#line 526
            set_extra_output_file(log_fd);
            }
          }
#line 526
          till_next_spinner = (int )lookup.spinner.interval;
        }
      }
#line 526
      _i_ = 0;
      {
#line 526
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 526
        if (! (_i_ < lookup.patterns)) {
#line 526
          goto while_break___11;
        }
        {
#line 526
        tmp___17 = regexec((regex_t const   *)(& lookup.search[_i_].regex), _text_,
                           _length_);
        }
#line 526
        if (tmp___17) {
#line 526
          tmp___18 = 0;
        } else {
#line 526
          tmp___18 = 1;
        }
#line 526
        if (tmp___18 != (int )lookup.search[_i_].not) {
#line 526
          if (apply_regex_abort) {
#line 526
            return (1);
          } else {
#line 526
            goto fail526;
          }
        }
#line 526
        _i_ ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 526
      if (apply_regex_abort) {
#line 526
        return (1);
      }
      {
#line 526
      tmp___19 = matchedline(slot, _text_, pos, _length_);
      }
#line 526
      if (tmp___19 == 1) {
#line 526
        return (0);
      }
      fail526: 
#line 527
      line___1 += (fileloc )(len + 1U);
    }
    while_break___10: /* CIL Label */ ;
    }
  } else {
    {
#line 530
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 536
      holdsmax = 0;
#line 539
      i = 1;
      {
#line 539
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 539
        if (! (i < used)) {
#line 539
          goto while_break___13;
        }
#line 540
        if (current_line[i] > current_line[holdsmax]) {
#line 541
          holdsmax = i;
        }
#line 539
        i ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 543
      max = current_line[holdsmax];
#line 543
      startmax = max;
#line 545
      i = 0;
      {
#line 545
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 545
        if (! (i < used)) {
#line 545
          goto while_break___14;
        }
#line 547
        if (apply_regex_abort) {
#line 548
          return (1);
        }
#line 549
        if (i == holdsmax) {
#line 550
          goto __Cont;
        }
        {
#line 552
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 552
          if (! (current_line[i] < max)) {
#line 552
            goto while_break___15;
          }
#line 554
          if (MemIndex) {
#line 554
            if (charcount[i] == 0U) {
#line 554
              tmp___21 = 0xffffffffffffffffUL;
            } else {
              {
#line 554
              (charcount[i]) --;
#line 554
              tmp___20 = mem_read_packed_value(& mem_packed_list_ptr[i]);
#line 554
              tmp___21 = (unsigned long )current_line[i] + tmp___20;
              }
            }
#line 554
            current_line[i] = (fileloc )tmp___21;
          } else {
#line 554
            if (charcount[i] == 0U) {
#line 554
              tmp___23 = 0xffffffffffffffffUL;
            } else {
              {
#line 554
              (charcount[i]) --;
#line 554
              tmp___22 = read_packed_value(& packed_list_ptr[i]);
#line 554
              tmp___23 = (unsigned long )current_line[i] + tmp___22;
              }
            }
#line 554
            current_line[i] = (fileloc )tmp___23;
          }
#line 554
          if (current_line[i] == -1L) {
#line 557
            return (0);
          }
        }
        while_break___15: /* CIL Label */ ;
        }
#line 561
        if (current_line[i] > max) {
#line 562
          holdsmax = i;
#line 562
          max = current_line[holdsmax];
        }
        __Cont: /* CIL Label */ 
#line 545
        i ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 566
      if (startmax == max) {
        {
#line 570
        v___0 = (slot->file)->v;
#line 570
        pos___0 = max;
#line 570
        tmp___24 = VirtPos2Str(v___0, pos___0, & _length____0);
#line 570
        _text____0 = tmp___24;
#line 570
        len___0 = _length____0;
#line 570
        (lookup.count.checked) ++;
        }
#line 570
        if (lookup.spinner.interval) {
#line 570
          till_next_spinner --;
#line 570
          if (till_next_spinner < 0) {
#line 570
            log_fd___0 = 0;
#line 570
            if ((unsigned long )current_log_file != (unsigned long )((unsigned char const   *)0)) {
              {
#line 570
              log_fd___0 = set_extra_output_file(-2);
#line 570
              flush_output();
#line 570
              set_extra_output_file(-3);
              }
            }
#line 570
            spinner_position ++;
#line 570
            if (spinner_position >= (unsigned int )lookup.spinner.char_count) {
#line 570
              spinner_position = 0U;
            }
            {
#line 570
            (*_output_char_function)((unsigned char )*(lookup.spinner.chars + spinner_position * 2U));
#line 570
            (*_output_char_function)((unsigned char )*(lookup.spinner.chars + (spinner_position * 2U + 1U)));
#line 570
            (*_output_char_function)((unsigned char )'\r');
#line 570
            flush_output();
            }
#line 570
            if ((unsigned long )current_log_file != (unsigned long )((unsigned char const   *)0)) {
              {
#line 570
              set_extra_output_file(log_fd___0);
              }
            }
#line 570
            till_next_spinner = (int )lookup.spinner.interval;
          }
        }
#line 570
        _i____0 = 0;
        {
#line 570
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 570
          if (! (_i____0 < lookup.patterns)) {
#line 570
            goto while_break___16;
          }
          {
#line 570
          tmp___25 = regexec((regex_t const   *)(& lookup.search[_i____0].regex),
                             _text____0, _length____0);
          }
#line 570
          if (tmp___25) {
#line 570
            tmp___26 = 0;
          } else {
#line 570
            tmp___26 = 1;
          }
#line 570
          if (tmp___26 != (int )lookup.search[_i____0].not) {
#line 570
            if (apply_regex_abort) {
#line 570
              return (1);
            } else {
#line 570
              goto fail570;
            }
          }
#line 570
          _i____0 ++;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 570
        if (apply_regex_abort) {
#line 570
          return (1);
        }
        {
#line 570
        tmp___27 = matchedline(slot, _text____0, pos___0, _length____0);
        }
#line 570
        if (tmp___27 == 1) {
#line 570
          return (0);
        }
        fail570: 
#line 573
        i = 0;
        {
#line 573
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 573
          if (! (i < used)) {
#line 573
            goto while_break___17;
          }
          {
#line 574
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 574
            if (! (current_line[i] == max)) {
              {
#line 574
              warn("\nassert(current_line[i] == max) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c",
                   574);
              }
            }
#line 574
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 575
          if (MemIndex) {
#line 575
            if (charcount[i] == 0U) {
#line 575
              tmp___29 = 0xffffffffffffffffUL;
            } else {
              {
#line 575
              (charcount[i]) --;
#line 575
              tmp___28 = mem_read_packed_value(& mem_packed_list_ptr[i]);
#line 575
              tmp___29 = (unsigned long )current_line[i] + tmp___28;
              }
            }
#line 575
            current_line[i] = (fileloc )tmp___29;
          } else {
#line 575
            if (charcount[i] == 0U) {
#line 575
              tmp___31 = 0xffffffffffffffffUL;
            } else {
              {
#line 575
              (charcount[i]) --;
#line 575
              tmp___30 = read_packed_value(& packed_list_ptr[i]);
#line 575
              tmp___31 = (unsigned long )current_line[i] + tmp___30;
              }
            }
#line 575
            current_line[i] = (fileloc )tmp___31;
          }
#line 575
          if (current_line[i] == -1L) {
#line 577
            return (0);
          }
#line 573
          i ++;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 582
  return (0);
}
}
#line 585 "/home/wheatley/newnew/temp/lookup-1.08b/apply_regex.c"
void apply_regex(void) 
{ 
  unsigned int old_regexec_flags ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int i ;
  struct slot_info *slot ;
  int tmp___1 ;

  {
#line 587
  if (lookup.flag.regex_debug) {
#line 587
    tmp = 2;
  } else {
#line 587
    tmp = 0;
  }
  {
#line 587
  tmp___0 = regexec_setflags((unsigned int )tmp);
#line 587
  old_regexec_flags = tmp___0;
  }
#line 596
  if (lookup.max_lines_to_print) {
#line 596
    lookup.lines_to_print_this_time = lookup.max_lines_to_print + 1L;
  } else {
#line 596
    lookup.lines_to_print_this_time = 0L;
  }
#line 599
  lookup.spinner.chars = (unsigned char const   *)"\250\241\241\277\250\242\241\300";
#line 600
  lookup.spinner.char_count = (unsigned char)4;
#line 602
  lookup.count.filtered = 0UL;
#line 603
  lookup.count.checked = 0UL;
#line 604
  lookup.count.matched = 0UL;
#line 605
  lookup.count.printed = 0UL;
#line 606
  lookup.count.nonword = 0UL;
#line 607
  lookup.list.overflow = 0U;
#line 608
  apply_regex_abort = (unsigned int volatile   )0;
#line 609
  lookup.list.used = 0U;
#line 611
  if (! ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0))) {
    {
#line 612
    apply_regex_to_file((struct slot_info  const  *)lookup.slot);
    }
  } else {
#line 616
    i = 0U;
    {
#line 616
    while (1) {
      while_continue: /* CIL Label */ ;
#line 616
      if (! (i < (unsigned int )(lookup.slot)->onefile_or_combo._combo_.entries)) {
#line 616
        goto while_break;
      }
#line 618
      slot = lookup.slot_info[(lookup.slot)->onefile_or_combo._combo_.entry[i]];
      {
#line 621
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 621
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 625
      slot->current_flag.word = (lookup.slot)->current_flag.word & slot->default_flag.word;
#line 626
      slot->current_flag.fold = (lookup.slot)->current_flag.fold & slot->default_flag.fold;
#line 627
      slot->current_flag.highlight = (lookup.slot)->current_flag.highlight & slot->default_flag.highlight;
#line 628
      slot->current_flag.filter = (lookup.slot)->current_flag.filter & slot->default_flag.filter;
#line 629
      slot->current_flag.modify = (lookup.slot)->current_flag.modify & slot->default_flag.modify;
#line 630
      slot->current_flag.display = (lookup.slot)->current_flag.display & slot->default_flag.display;
      {
#line 633
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 633
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 634
      if ((unsigned long )slot->onefile_or_combo.onefile._tag_ == (unsigned long )((unsigned char const   *)0)) {
#line 634
        slot->current_flag.tag = 0U;
      } else {
#line 634
        if ((lookup.slot)->current_flag.tag) {
#line 634
          tmp___1 = 1;
        } else
#line 634
        if (slot->default_flag.tag) {
#line 634
          tmp___1 = 1;
        } else {
#line 634
          tmp___1 = 0;
        }
#line 634
        slot->current_flag.tag = (unsigned int )tmp___1;
      }
      {
#line 636
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 636
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 638
      apply_regex_to_file((struct slot_info  const  *)slot);
#line 616
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 642
  regexec_setflags(old_regexec_flags);
  }
#line 644
  if (apply_regex_abort) {
    {
#line 645
    output_pager_reset_more();
#line 646
    output("<<aborted>>\n");
    }
  }
#line 648
  return;
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 45 "/home/wheatley/newnew/temp/lookup-1.08b/lib/virtfile.h"
extern VirtFile *OpenVertFile(char const   *filename ) ;
#line 45 "/home/wheatley/newnew/temp/lookup-1.08b/lib/loadfile.h"
struct fileinfo *loadfile(char const   *filename , unsigned int percent , unsigned int flags___0 ) ;
#line 64
char *indexfile_name(char const   *datafile_name ) ;
#line 45 "/home/wheatley/newnew/temp/lookup-1.08b/lib/loadfile.c"
char *indexfile_name(char const   *datafile_name ) 
{ 
  char *indexname ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 47
  tmp = strlen((char const   *)((void *)datafile_name));
#line 47
  tmp___0 = strlen(".jin");
#line 47
  tmp___1 = xmalloc((unsigned int )((tmp + tmp___0) + 2UL));
#line 47
  indexname = (char *)tmp___1;
#line 49
  strcpy((char */* __restrict  */)indexname, (char const   */* __restrict  */)datafile_name);
#line 50
  strcat((char */* __restrict  */)indexname, (char const   */* __restrict  */)".jin");
  }
#line 51
  return (indexname);
}
}
#line 62 "/home/wheatley/newnew/temp/lookup-1.08b/lib/loadfile.c"
struct fileinfo *loadfile(char const   *filename , unsigned int percent , unsigned int flags___0 ) 
{ 
  struct fileinfo *info ;
  void *tmp ;
  struct stat statbuf ;
  int tmp___0 ;
  char *tmp___1 ;
  char *name ;
  char *tmp___2 ;
  int just_try ;
  struct index *tmp___3 ;
  struct index *tmp___4 ;
  struct index *i ;
  char *name___0 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 65
  tmp = xmalloc((unsigned int )sizeof(struct fileinfo ));
#line 65
  info = (struct fileinfo *)tmp;
#line 70
  tmp___0 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& statbuf));
  }
#line 70
  if (tmp___0 < 0) {
    {
#line 71
    warn("[can\'t stat \"%s\": %n]\n", filename);
    }
#line 72
    return ((struct fileinfo *)0);
  }
#line 75
  if (statbuf.st_size == 0L) {
    {
#line 76
    warn("[warning: file \"%s\" is empty]\n", filename);
    }
  }
  {
#line 79
  info->v = OpenVertFile(filename);
#line 82
  tmp___1 = rindex((char const   *)((void *)(info->v)->filename), '/');
#line 82
  info->short_filename = (char const   *)tmp___1;
  }
#line 83
  if ((unsigned long )info->short_filename == (unsigned long )((char const   *)0)) {
#line 84
    info->short_filename = (info->v)->filename;
  } else {
#line 86
    (info->short_filename) ++;
  }
#line 88
  if (flags___0 & 655360U) {
    {
#line 90
    tmp___2 = indexfile_name(filename);
#line 90
    name = tmp___2;
#line 91
    just_try = (int )(flags___0 & 524288U);
    }
#line 92
    if (flags___0 & 262144U) {
      {
#line 93
      tmp___3 = read_index_file((char const   *)name, just_try, flags___0);
#line 93
      info->index = (struct index  const  *)tmp___3;
      }
    } else {
      {
#line 95
      tmp___4 = mem_read_index_file((char const   *)name);
#line 95
      info->index = (struct index  const  *)tmp___4;
      }
    }
#line 97
    if ((unsigned long )info->index == (unsigned long )((struct index  const  *)0)) {
#line 99
      if (flags___0 & 524288U) {
        {
#line 101
        free((void *)name);
        }
#line 102
        goto build_index;
      }
      {
#line 104
      warn("[error: couldn\'t read \"%s\": %n]\n", name);
#line 105
      free((void *)name);
#line 106
      free((void *)info);
      }
#line 107
      return ((struct fileinfo *)0);
    }
#line 109
    info->indexfile = (char const   *)name;
#line 110
    if ((info->index)->st__mtime != (time_t const   )statbuf.st_mtim.tv_sec) {
      {
#line 111
      warn("<WARNING, [%s] has been updated since index was written>\n", filename);
      }
    }
  } else {
    build_index: 
    {
#line 117
    i = create_index(info->v, percent, flags___0);
#line 118
    i->st__mtime = statbuf.st_mtim.tv_sec;
#line 119
    i->FileP = (FILE *)((void *)0);
#line 120
    info->index = (struct index  const  *)i;
    }
  }
#line 123
  if (flags___0 & 65536U) {
    {
#line 125
    tmp___5 = indexfile_name(filename);
#line 125
    name___0 = tmp___5;
#line 126
    tmp___6 = write_index_file((char const   *)name___0, info->index);
    }
#line 126
    if (tmp___6 != 0) {
      {
#line 128
      warn("[error: couldn\'t write \"%s\": %n]\n", name___0);
#line 129
      free((void *)name___0);
      }
    } else {
      {
#line 133
      warn("[wrote index file \"%s\"]\n", name___0);
#line 134
      info->indexfile = (char const   *)name___0;
      }
    }
  }
#line 137
  return (info);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 24 "/home/wheatley/newnew/temp/lookup-1.08b/lib/fuzzkana.h"
unsigned int fuzzkana(unsigned char const   *in , unsigned char *out , unsigned int out_size ,
                      unsigned int flags___0 ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 240 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
struct lookup lookup  ;
#line 241
char const   *expand_filename_tilde(char const   *filename ) ;
#line 242
unsigned char const   *gen_prompt(unsigned char const   *template , int showerror ) ;
#line 243
int slot_num(struct slot_info *s ) ;
#line 244
int load_file(char const   *filename , unsigned int flag ) ;
#line 245
void process_input_line(unsigned char *input , int forced_search ) ;
#line 246
int exit_program_now ;
#line 250
int cmd_list_size(unsigned char const   *spec ) ;
#line 251
int cmd_show(void) ;
#line 253
int cmd_version(void) ;
#line 254
int parse_command(unsigned char const   *line___1 , unsigned int len , unsigned int accept ,
                  unsigned int skip ) ;
#line 255
int quick_command(unsigned char const   *str___0 ) ;
#line 256
int read_commands_from_file(char const   *file , unsigned int accept , unsigned int skip ) ;
#line 257
int cmd_log(int closelog , int append , unsigned char const   *File ) ;
#line 31 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
int UseNoMemIndex  =    0;
#line 41 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static char const   *new___0  =    (char const   *)0;
#line 33 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
char const   *expand_filename_tilde(char const   *filename ) 
{ 
  unsigned char const   *home ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 36
  tmp = getenv("HOME");
#line 36
  home = (unsigned char const   *)tmp;
  }
#line 37
  if ((unsigned long )home == (unsigned long )((unsigned char const   *)0)) {
#line 38
    return (filename);
  } else
#line 37
  if ((int const   )*(filename + 0) != 126) {
#line 38
    return (filename);
  } else
#line 37
  if ((int const   )*(filename + 1) != 47) {
#line 38
    return (filename);
  } else {
#line 42
    if (new___0) {
      {
#line 43
      free((void *)new___0);
      }
    }
    {
#line 49
    tmp___0 = strlen((char const   *)((void *)home));
#line 49
    tmp___1 = strlen((char const   *)((void *)((unsigned char const   *)filename)));
#line 49
    tmp___2 = xmalloc((unsigned int )(tmp___0 + tmp___1));
#line 49
    new___0 = (char const   *)tmp___2;
#line 50
    strcpy((char */* __restrict  */)((void *)((unsigned char *)new___0)), (char const   */* __restrict  */)((void *)home));
#line 51
    strcat((char */* __restrict  */)((void *)((unsigned char *)new___0)), (char const   */* __restrict  */)((void *)((unsigned char const   *)(filename + 1))));
    }
#line 52
    return (new___0);
  }
}
}
#line 57 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
unsigned char const   *current_log_file  =    (unsigned char const   *)0;
#line 68 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int in_command  ;
#line 97
__inline static unsigned char *mygetline(unsigned char const   *prompt ) ;
#line 97 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static unsigned char *lastline  =    (unsigned char *)0;
#line 97 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static unsigned char *line___0  =    (unsigned char *)0;
#line 79 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
__inline static unsigned char *mygetline(unsigned char const   *prompt ) 
{ 
  int log_fd ;
  int normal_fd ;
  int tmp ;
  int tmp___0 ;

  {
#line 99
  log_fd = 0;
#line 101
  if (line___0) {
    {
#line 102
    free((void *)line___0);
    }
  }
#line 104
  jreadline_auto_romaji = (int )(lookup.default_slot)->default_flag.autokana;
#line 105
  apply_regex_abort = (unsigned int volatile   )0;
#line 108
  if ((unsigned long )current_log_file != (unsigned long )((unsigned char const   *)0)) {
    {
#line 109
    log_fd = set_extra_output_file(-2);
#line 110
    flush_output();
#line 111
    set_extra_output_file(-3);
    }
  }
  {
#line 115
  output_pager_reset_more();
#line 116
  line___0 = readline(prompt);
#line 120
  output_pager_reset_more();
  }
#line 123
  if ((unsigned long )current_log_file != (unsigned long )((unsigned char const   *)0)) {
    {
#line 124
    tmp = set_normal_output_file(log_fd);
#line 124
    normal_fd = tmp;
#line 128
    outputf("%s%s\n", jreadline_last_prompt, line___0);
#line 129
    flush_output();
#line 130
    set_normal_output_file(normal_fd);
#line 131
    set_extra_output_file(log_fd);
    }
  }
#line 136
  if (line___0) {
#line 136
    if (*line___0) {
#line 136
      if (lastline) {
        {
#line 136
        tmp___0 = strcmp((char const   *)((void *)((unsigned char const   *)lastline)),
                         (char const   *)((void *)((unsigned char const   *)line___0)));
        }
#line 136
        if (tmp___0) {
#line 136
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 138
        if (lastline) {
          {
#line 139
          free((void *)lastline);
          }
        }
        {
#line 140
        lastline = strsave((unsigned char const   *)line___0);
#line 141
        add_history((unsigned char const   *)line___0);
        }
      }
    }
  }
#line 143
  return (line___0);
}
}
#line 148 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int sighandler(int sig ) 
{ 
  unsigned int volatile   tmp ;

  {
#line 151
  tmp = apply_regex_abort;
#line 151
  apply_regex_abort += (unsigned int volatile   )1;
#line 151
  if (tmp > (unsigned int volatile   )2) {
    {
#line 152
    exit(1);
    }
  }
#line 153
  return (0);
}
}
#line 163
static void romaji_converter___0(unsigned char *start_of_line___0 , unsigned char const   *bufend ,
                                 unsigned char **dot_p , unsigned char const   **eol_p ,
                                 int force ) ;
#line 163 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static char const   *allowed  =    (char const   *)0;
#line 156 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static void romaji_converter___0(unsigned char *start_of_line___0 , unsigned char const   *bufend ,
                                 unsigned char **dot_p , unsigned char const   **eol_p ,
                                 int force ) 
{ 
  unsigned char *dot___0 ;
  unsigned char *slwp ;
  int eat_leading_slash ;
  unsigned char c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned char *this_regex ;
  unsigned char *ptr ;

  {
#line 160
  dot___0 = *dot_p;
#line 161
  slwp = start_of_line___0;
#line 162
  eat_leading_slash = ! force;
#line 172
  if ((int )*(slwp + 0) == 43) {
#line 173
    slwp ++;
  }
#line 174
  if ((int )*(slwp + 0) == 33) {
    {
#line 177
    while (1) {
      while_continue: /* CIL Label */ ;
#line 177
      slwp ++;
#line 177
      c = *(slwp + 0);
#line 177
      if ((unsigned long )slwp < (unsigned long )dot___0) {
#line 177
        if (((int )c & -128) == 0) {
          {
#line 177
          tmp = __ctype_b_loc();
          }
#line 177
          if ((int const   )*(*tmp + (int )c) & 1024) {
#line 177
            tmp___0 = 1;
          } else {
#line 177
            tmp___0 = 0;
          }
        } else {
#line 177
          tmp___0 = 0;
        }
      } else {
#line 177
        tmp___0 = 0;
      }
#line 177
      if (! tmp___0) {
#line 177
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 179
    if ((int )c == 33) {
#line 180
      slwp ++;
    }
  }
#line 182
  if ((unsigned long )slwp >= (unsigned long )dot___0) {
#line 183
    return;
  }
#line 185
  if (! force) {
#line 191
    this_regex = slwp;
#line 195
    if ((int )*(this_regex + 0) == (int )lookup.cmdstart_char) {
#line 196
      return;
    }
#line 198
    ptr = dot___0 - 1;
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! ((unsigned long )ptr > (unsigned long )(slwp + 3))) {
#line 198
        goto while_break___0;
      }
#line 200
      if ((int )*(ptr + -1) != 124) {
#line 201
        goto __Cont;
      }
#line 202
      if ((int )*(ptr + -2) == 124) {
#line 202
        if ((int )*(ptr + -3) != 92) {
#line 204
          this_regex = ptr;
#line 205
          goto while_break___0;
        }
      }
#line 207
      if ((int )*(ptr + -2) == 33) {
#line 207
        if ((int )*(ptr + -3) == 124) {
#line 207
          if ((unsigned long )(ptr + -4) >= (unsigned long )start_of_line___0) {
#line 207
            if ((int )*(ptr + -4) != 92) {
#line 210
              this_regex = ptr;
#line 211
              goto while_break___0;
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 198
      ptr --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 219
    if ((int )*(this_regex + 0) == 61) {
#line 220
      return;
    }
#line 222
    if ((int )*(this_regex + 0) == 91) {
#line 222
      goto _L;
    } else
#line 222
    if ((int )*(this_regex + 0) == 47) {
      _L: /* CIL Label */ 
      {
#line 224
      allowed = std_romaji_allowed_nonletters("-^\'*?+.[]<>\\$ \t");
      }
#line 226
      if ((int )*(this_regex + 0) == 91) {
        {
#line 228
        *(this_regex + 0) = (unsigned char )'/';
#line 229
        std_romaji_converter((unsigned char const   *)start_of_line___0, bufend, dot_p,
                             eol_p, force, 0);
#line 230
        *(this_regex + 0) = (unsigned char )'[';
        }
#line 231
        goto done;
      }
      {
#line 235
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 235
        dot___0 --;
#line 235
        if (! ((unsigned long )dot___0 > (unsigned long )this_regex)) {
#line 235
          goto while_break___1;
        }
#line 236
        if ((int )*dot___0 == 47) {
#line 237
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 238
      if ((unsigned long )dot___0 == (unsigned long )this_regex) {
#line 239
        eat_leading_slash = 0;
      }
    }
  }
  {
#line 243
  std_romaji_converter((unsigned char const   *)start_of_line___0, bufend, dot_p,
                       eol_p, force, eat_leading_slash);
  }
  done: 
#line 246
  if (allowed) {
    {
#line 247
    std_romaji_allowed_nonletters(allowed);
    }
  }
#line 248
  return;
}
}
#line 250 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int check_commandline_status(unsigned char *line___1 , unsigned char **p_dot ,
                                    unsigned char **p_eol ) 
{ 
  int old_in_command ;
  unsigned char const   *eol ;
  unsigned char c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 253
  old_in_command = in_command;
#line 254
  eol = (unsigned char const   *)*p_eol;
#line 256
  if ((int )*(line___1 + 0) == 43) {
#line 257
    line___1 ++;
  }
#line 259
  if ((int )*(line___1 + 0) == 33) {
    {
#line 262
    while (1) {
      while_continue: /* CIL Label */ ;
#line 262
      line___1 ++;
#line 262
      c = *(line___1 + 0);
#line 262
      if ((unsigned long )line___1 < (unsigned long )eol) {
#line 262
        if (((int )c & -128) == 0) {
          {
#line 262
          tmp = __ctype_b_loc();
          }
#line 262
          if ((int const   )*(*tmp + (int )c) & 1024) {
#line 262
            tmp___0 = 1;
          } else {
#line 262
            tmp___0 = 0;
          }
        } else {
#line 262
          tmp___0 = 0;
        }
      } else {
#line 262
        tmp___0 = 0;
      }
#line 262
      if (! tmp___0) {
#line 262
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 264
    if ((int )c == 33) {
#line 265
      line___1 ++;
    }
  }
#line 267
  if ((unsigned long )line___1 >= (unsigned long )eol) {
#line 268
    in_command = 0;
  } else {
#line 270
    in_command = (int )*(line___1 + 0) == (int )lookup.cmdstart_char;
  }
#line 272
  if (in_command != old_in_command) {
    {
#line 277
    tmp___1 = gen_prompt(lookup.prompt_format, 0);
#line 277
    jreadline_mod_prompt(tmp___1);
    }
#line 278
    return (1);
  }
#line 280
  return (0);
}
}
#line 291 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static unsigned char const   *prompt_errors[6]  = {      (unsigned char const   *)"ok",      (unsigned char const   *)"unmatched open paren",      (unsigned char const   *)"unmatched close paren",      (unsigned char const   *)"unexpected end-of-string", 
        (unsigned char const   *)"expected open paren or quote",      (unsigned char const   *)"prompt too large"};
#line 307 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int skip_parens(unsigned char const   *template , unsigned char const   *tend ) 
{ 
  unsigned char const   *orig ;
  unsigned char c ;
  int level ;

  {
#line 309
  orig = template;
#line 313
  level = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! ((unsigned long )template < (unsigned long )tend)) {
#line 313
      goto while_break;
    }
#line 315
    c = (unsigned char )*template;
#line 315
    if ((int )c == 92) {
#line 316
      template ++;
    } else
#line 317
    if ((int )c == 40) {
#line 318
      level ++;
    } else
#line 319
    if ((int )c == 41) {
#line 320
      if (level == 0) {
#line 321
        return ((int )(template - orig));
      }
#line 322
      if (level == 0) {
#line 323
        return (-2);
      }
#line 324
      level --;
    }
#line 313
    template ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return (-1);
}
}
#line 330 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static unsigned char *do_prompt_buf  ;
#line 331 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int do_prompt_len  ;
#line 332 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int do_prompt_use_command  ;
#line 334 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int do_create_prompt(unsigned char const   *template , unsigned char const   *tend ) 
{ 
  unsigned char c ;
  unsigned char const   *orig_buf ;
  int not ;
  unsigned char const   *temp ;
  int tmp ;
  unsigned char *tmp___0 ;
  int len ;
  int doit ;
  unsigned char temp_buf[3] ;
  unsigned char match ;
  unsigned char const   *tmp___1 ;
  int retval ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 337
  orig_buf = (unsigned char const   *)do_prompt_buf;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! ((unsigned long )template < (unsigned long )tend)) {
#line 339
      goto while_break;
    }
#line 345
    c = (unsigned char )*template;
#line 345
    if ((int )c != 37) {
#line 347
      if ((int )c == 92) {
#line 349
        template ++;
#line 349
        if ((unsigned long )template >= (unsigned long )tend) {
#line 350
          return (-3);
        }
#line 351
        c = (unsigned char )*template;
      }
#line 353
      tmp = do_prompt_len;
#line 353
      do_prompt_len --;
#line 353
      if (tmp == 0) {
#line 354
        return (-5);
      }
#line 355
      tmp___0 = do_prompt_buf;
#line 355
      do_prompt_buf ++;
#line 355
      *tmp___0 = c;
#line 356
      template ++;
#line 357
      goto while_continue;
    }
#line 360
    temp = template;
#line 361
    template ++;
#line 361
    c = (unsigned char )*template;
#line 363
    not = 0;
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      if (! ((int )c == 33)) {
#line 364
        goto while_break___0;
      }
#line 366
      not = ! not;
#line 367
      template ++;
#line 367
      c = (unsigned char )*template;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 370
    if ((unsigned long )template >= (unsigned long )tend) {
#line 371
      return (-3);
    }
    {
#line 424
    if ((int )c == 35) {
#line 424
      goto case_35;
    }
#line 431
    if ((int )c == 110) {
#line 431
      goto case_110;
    }
#line 442
    if ((int )c == 78) {
#line 442
      goto case_78;
    }
#line 453
    if ((int )c == 119) {
#line 453
      goto case_119;
    }
#line 457
    if ((int )c == 87) {
#line 457
      goto case_87;
    }
#line 461
    if ((int )c == 100) {
#line 461
      goto case_100;
    }
#line 465
    if ((int )c == 102) {
#line 465
      goto case_102;
    }
#line 469
    if ((int )c == 70) {
#line 469
      goto case_70;
    }
#line 475
    if ((int )c == 77) {
#line 475
      goto case_77;
    }
#line 481
    if ((int )c == 67) {
#line 481
      goto case_67;
    }
#line 486
    if ((int )c == 99) {
#line 486
      goto case_99;
    }
#line 490
    if ((int )c == 83) {
#line 490
      goto case_83;
    }
#line 496
    if ((int )c == 48) {
#line 496
      goto case_48;
    }
#line 501
    if ((int )c == 108) {
#line 501
      goto case_108;
    }
#line 509
    if ((int )c == 76) {
#line 509
      goto case_76;
    }
#line 420
    goto switch_default;
    do_flag: 
    {
#line 379
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 379
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 381
    if ((int const   )*(template + 1) == 39) {
#line 381
      goto _L;
    } else
#line 381
    if ((int const   )*(template + 1) == 34) {
      _L: /* CIL Label */ 
#line 383
      match = (unsigned char )*(template + 1);
#line 384
      template += 2;
#line 384
      temp = template;
      {
#line 385
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 385
        if ((unsigned long )template < (unsigned long )tend) {
#line 385
          if (! ((int const   )*template != (int const   )match)) {
#line 385
            goto while_break___2;
          }
        } else {
#line 385
          goto while_break___2;
        }
#line 386
        template ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 387
      tmp___1 = template;
#line 387
      template ++;
#line 387
      if ((unsigned long )tmp___1 >= (unsigned long )tend) {
#line 388
        return (-3);
      }
#line 389
      if (doit) {
#line 390
        len = (int )((template - temp) - 1L);
#line 391
        goto dump_temp_with_len;
      }
    } else
#line 393
    if ((int const   )*(template + 1) != 40) {
#line 394
      return (-4);
    } else {
      {
#line 395
      len = skip_parens(template + 2, tend);
      }
#line 395
      if (len < 0) {
#line 396
        return (len);
      } else {
#line 399
        if (doit) {
          {
#line 401
          tmp___2 = do_create_prompt(template + 2, template + (2 + len));
#line 401
          retval = tmp___2;
          }
#line 403
          if (retval < 0) {
#line 404
            return (retval);
          }
        }
#line 406
        template += (2 + len) + 1;
      }
    }
#line 408
    goto switch_break;
    dump_temp: 
    {
#line 411
    tmp___3 = strlen((char const   *)((void *)temp));
#line 411
    len = (int )tmp___3;
    }
    dump_temp_with_len: 
    {
#line 413
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 413
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 414
    do_prompt_len -= len;
#line 414
    if (do_prompt_len < 0) {
#line 415
      return (-5);
    }
    {
#line 416
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 416
      tmp___6 = len;
#line 416
      len --;
#line 416
      if (! (tmp___6 > 0)) {
#line 416
        goto while_break___4;
      }
#line 417
      tmp___4 = do_prompt_buf;
#line 417
      do_prompt_buf ++;
#line 417
      tmp___5 = temp;
#line 417
      temp ++;
#line 417
      *tmp___4 = (unsigned char )*tmp___5;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 418
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 421
    template ++;
#line 421
    len = (int )(template - temp);
#line 422
    goto dump_temp_with_len;
    case_35: /* CIL Label */ 
    {
#line 425
    template ++;
#line 426
    tmp___7 = slot_num(lookup.default_slot);
#line 426
    temp_buf[0] = (unsigned char )(48 + tmp___7);
#line 427
    temp = (unsigned char const   *)(temp_buf);
#line 428
    len = 1;
    }
#line 429
    goto dump_temp_with_len;
    case_110: /* CIL Label */ 
#line 432
    template ++;
#line 433
    if ((unsigned long )(lookup.default_slot)->file == (unsigned long )((struct fileinfo *)0)) {
      {
#line 434
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 434
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 435
      temp = (lookup.default_slot)->onefile_or_combo._combo_.name;
    } else {
      {
#line 437
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 437
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 438
      temp = (unsigned char const   *)((lookup.default_slot)->file)->short_filename;
    }
#line 440
    goto dump_temp;
    case_78: /* CIL Label */ 
#line 443
    template ++;
#line 444
    if ((unsigned long )(lookup.default_slot)->file == (unsigned long )((struct fileinfo *)0)) {
      {
#line 445
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 445
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 446
      temp = (lookup.default_slot)->onefile_or_combo._combo_.name;
    } else {
      {
#line 448
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 448
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 449
      temp = (unsigned char const   *)(((lookup.default_slot)->file)->v)->filename;
    }
#line 451
    goto dump_temp;
    case_119: /* CIL Label */ 
#line 454
    doit = (lookup.default_slot)->default_flag.word != (unsigned int )not;
#line 455
    goto do_flag;
    case_87: /* CIL Label */ 
#line 458
    doit = (lookup.default_slot)->default_flag.glob != (unsigned int )not;
#line 459
    goto do_flag;
    case_100: /* CIL Label */ 
#line 462
    doit = (lookup.default_slot)->default_flag.display != (unsigned int )not;
#line 463
    goto do_flag;
    case_102: /* CIL Label */ 
#line 466
    doit = (lookup.default_slot)->default_flag.fuzz != (unsigned int )not;
#line 467
    goto do_flag;
    case_70: /* CIL Label */ 
#line 470
    if ((lookup.default_slot)->default_flag.filter != (unsigned int )not) {
#line 470
      if ((unsigned long )(lookup.default_slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 470
        tmp___8 = 1;
      } else
#line 470
      if ((lookup.default_slot)->onefile_or_combo.onefile._filter_.pattern) {
#line 470
        tmp___8 = 1;
      } else {
#line 470
        tmp___8 = 0;
      }
    } else {
#line 470
      tmp___8 = 0;
    }
#line 470
    doit = tmp___8;
#line 473
    goto do_flag;
    case_77: /* CIL Label */ 
#line 476
    if ((lookup.default_slot)->default_flag.modify != (unsigned int )not) {
#line 476
      if ((unsigned long )(lookup.default_slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 476
        tmp___9 = 1;
      } else
#line 476
      if ((lookup.default_slot)->onefile_or_combo.onefile._modify_.pattern) {
#line 476
        tmp___9 = 1;
      } else {
#line 476
        tmp___9 = 0;
      }
    } else {
#line 476
      tmp___9 = 0;
    }
#line 476
    doit = tmp___9;
#line 479
    goto do_flag;
    case_67: /* CIL Label */ 
#line 482
    doit = in_command != not;
#line 483
    do_prompt_use_command = 1;
#line 484
    goto do_flag;
    case_99: /* CIL Label */ 
#line 487
    doit = (lookup.default_slot)->default_flag.fold != (unsigned int )not;
#line 488
    goto do_flag;
    case_83: /* CIL Label */ 
#line 491
    template ++;
#line 492
    temp = (unsigned char const   *)(& lookup.cmdstart_char);
#line 493
    len = 1;
#line 494
    goto dump_temp_with_len;
    case_48: /* CIL Label */ 
#line 497
    template ++;
#line 498
    temp = (unsigned char const   *)lookup.prog_short;
#line 499
    goto dump_temp;
    case_108: /* CIL Label */ 
#line 503
    doit = ! (! current_log_file) != not;
#line 507
    goto do_flag;
    case_76: /* CIL Label */ 
#line 510
    template ++;
#line 512
    if (current_log_file) {
#line 513
      temp = current_log_file;
#line 514
      goto dump_temp;
    }
#line 517
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return ((int )(do_prompt_buf - (unsigned char *)orig_buf));
}
}
#line 525 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static unsigned char buffer[100]  ;
#line 523 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
unsigned char const   *gen_prompt(unsigned char const   *template , int showerror ) 
{ 
  int i ;
  size_t tmp ;
  unsigned char const   *tmp___0 ;

  {
  {
#line 528
  do_prompt_use_command = 0;
#line 529
  do_prompt_buf = buffer;
#line 530
  do_prompt_len = (int )sizeof(buffer);
#line 531
  tmp = strlen((char const   *)((void *)template));
#line 531
  i = do_create_prompt(template, template + tmp);
  }
#line 532
  if (i < 0) {
#line 534
    if (showerror) {
#line 535
      if ((unsigned long )((unsigned int )(- i)) > sizeof(prompt_errors) / sizeof(prompt_errors[0])) {
#line 535
        tmp___0 = (unsigned char const   *)"???";
      } else {
#line 535
        tmp___0 = prompt_errors[- i];
      }
      {
#line 535
      warn("(prompt spec error: %s)\n", tmp___0);
      }
    }
#line 538
    jreadline_access = (int (*)(unsigned char *line , unsigned char **dot , unsigned char **eol ))0;
#line 539
    return (template);
  }
#line 541
  buffer[i] = (unsigned char )'\000';
#line 542
  if (do_prompt_use_command) {
#line 542
    jreadline_access = & check_commandline_status;
  } else {
#line 542
    jreadline_access = (int (*)(unsigned char *line , unsigned char **dot , unsigned char **eol ))0;
  }
#line 543
  return ((unsigned char const   *)(buffer));
}
}
#line 547 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static char **temp_memory  =    (char **)0;
#line 554 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static void *temp_malloc(unsigned int size ) 
{ 
  char **mem ;
  void *tmp ;

  {
  {
#line 556
  tmp = xmalloc((unsigned int )((unsigned long )size + sizeof(mem)));
#line 556
  mem = (char **)tmp;
#line 557
  *((char ***)mem) = temp_memory;
#line 558
  temp_memory = mem;
  }
#line 559
  return ((void *)(mem + 1));
}
}
#line 565 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static void free_temp_memory(void) 
{ 
  char *tmp ;

  {
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! temp_memory) {
#line 567
      goto while_break;
    }
    {
#line 569
    tmp = (char *)temp_memory;
#line 570
    temp_memory = (char **)*temp_memory;
#line 571
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 573
  return;
}
}
#line 578 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
__inline static int prepare_line(int print_only , unsigned char *line___1 , unsigned int len ,
                                 int not ) 
{ 
  int convert_from_romaji ;
  unsigned char *new___1 ;
  void *tmp ;
  unsigned char *dest ;
  unsigned char c ;
  int is_word ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  struct romaji2kana_info info ;
  unsigned char *kana ;
  int error ;
  int tmp___12 ;
  void *tmp___13 ;
  unsigned char const   *ptr ;
  unsigned int buflen ;
  unsigned int tmp___14 ;
  unsigned char *Fuzz ;
  void *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 581
  convert_from_romaji = 0;
#line 583
  if (lookup.patterns >= 10) {
    {
#line 585
    outputf("maximum of %d regexes per line\n", 10);
    }
#line 586
    return (0);
  }
#line 590
  if ((int )*(line___1 + 0) == 61) {
#line 591
    line___1 ++;
#line 592
    len --;
  } else
#line 593
  if ((int )*(line___1 + 0) == 91) {
#line 594
    *(line___1 + 0) = (unsigned char )'<';
#line 595
    if ((int )*(line___1 + (len - 1U)) == 93) {
#line 596
      *(line___1 + (len - 1U)) = (unsigned char )'>';
    }
#line 597
    convert_from_romaji = 1;
  } else
#line 598
  if ((int )*(line___1 + 0) == 47) {
#line 599
    convert_from_romaji = 1;
#line 600
    line___1 ++;
#line 601
    len --;
  }
#line 604
  if ((int )*(line___1 + 0) == 0) {
    {
#line 606
    output("\242\343no pattern!\242\344\n");
    }
#line 607
    return (0);
  }
#line 610
  if ((lookup.slot)->current_flag.glob) {
    {
#line 612
    tmp = temp_malloc(len * 2U);
#line 612
    new___1 = (unsigned char *)tmp;
#line 613
    dest = new___1;
    }
#line 614
    if ((lookup.slot)->current_flag.word) {
#line 614
      tmp___0 = 1;
    } else
#line 614
    if ((int )*(line___1 + 0) == 60) {
#line 614
      tmp___0 = 1;
    } else
#line 614
    if ((int )*(line___1 + 0) == 91) {
#line 614
      tmp___0 = 1;
    } else {
#line 614
      tmp___0 = 0;
    }
#line 614
    is_word = tmp___0;
    {
#line 617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 617
      tmp___11 = line___1;
#line 617
      line___1 ++;
#line 617
      c = *tmp___11;
#line 617
      if (! c) {
#line 617
        goto while_break;
      }
#line 618
      if ((int )c == 46) {
#line 618
        goto _L;
      } else
#line 618
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 619
        tmp___1 = dest;
#line 619
        dest ++;
#line 619
        *tmp___1 = (unsigned char )'\\';
#line 620
        tmp___2 = dest;
#line 620
        dest ++;
#line 620
        *tmp___2 = c;
      } else
#line 621
      if ((int )c == 42) {
#line 626
        if (! is_word) {
#line 627
          tmp___3 = dest;
#line 627
          dest ++;
#line 627
          *tmp___3 = (unsigned char )'.';
        } else {
#line 629
          tmp___4 = dest;
#line 629
          dest ++;
#line 629
          *tmp___4 = (unsigned char )'\\';
#line 630
          tmp___5 = dest;
#line 630
          dest ++;
#line 630
          *tmp___5 = (unsigned char )'S';
        }
#line 632
        tmp___6 = dest;
#line 632
        dest ++;
#line 632
        *tmp___6 = (unsigned char )'*';
        {
#line 637
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 637
          if (! ((int )*line___1 == 42)) {
#line 637
            goto while_break___0;
          }
#line 638
          line___1 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 640
      if ((int )c == 63) {
#line 642
        if (! is_word) {
#line 643
          tmp___7 = dest;
#line 643
          dest ++;
#line 643
          *tmp___7 = (unsigned char )'.';
        } else {
#line 645
          tmp___8 = dest;
#line 645
          dest ++;
#line 645
          *tmp___8 = (unsigned char )'\\';
#line 646
          tmp___9 = dest;
#line 646
          dest ++;
#line 646
          *tmp___9 = (unsigned char )'S';
        }
      } else {
#line 649
        tmp___10 = dest;
#line 649
        dest ++;
#line 649
        *tmp___10 = c;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 652
    *dest = (unsigned char )'\000';
#line 653
    line___1 = new___1;
  }
#line 657
  if (convert_from_romaji) {
    {
#line 661
    tmp___12 = romaji2kana((unsigned char const   *)line___1, (unsigned char const   *)(line___1 + len),
                           (unsigned char *)0, 0U, & info);
#line 661
    error = tmp___12;
    }
#line 663
    if (error < 0) {
      {
#line 665
      outputf("\242\343romaji2kana returns %d\242\344\n", error);
      }
#line 666
      return (0);
    }
#line 669
    if (info.modified) {
      {
#line 672
      tmp___13 = temp_malloc((unsigned int )info.k_buf_used);
#line 672
      kana = (unsigned char *)tmp___13;
#line 673
      error = romaji2kana((unsigned char const   *)line___1, (unsigned char const   *)(line___1 + len),
                          kana, (unsigned int )info.k_buf_used, (struct romaji2kana_info *)0);
      }
#line 674
      if (error) {
        {
#line 676
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 676
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 677
        outputf("\242\343bad kana conversion %d\241\310%s\241\311\242\344\n", error,
                kana);
        }
#line 679
        return (0);
      }
#line 681
      line___1 = kana;
    }
#line 684
    if ((lookup.slot)->current_flag.fuzz) {
#line 689
      ptr = (unsigned char const   *)(line___1 + 1);
      {
#line 690
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 690
        if (! *ptr) {
#line 690
          goto while_break___2;
        }
#line 691
        if ((int const   )*(ptr + -1) >= 128) {
#line 691
          if ((int const   )*ptr == 42) {
#line 692
            goto while_break___2;
          } else
#line 691
          if ((int const   )*ptr == 43) {
#line 692
            goto while_break___2;
          } else
#line 691
          if ((int const   )*ptr == 63) {
#line 692
            goto while_break___2;
          }
        }
#line 693
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 695
      if (! *ptr) {
        {
#line 696
        tmp___14 = fuzzkana((unsigned char const   *)line___1, (unsigned char *)0,
                            0U, 7U);
#line 696
        buflen = tmp___14;
        }
        {
#line 698
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 698
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 699
        tmp___15 = temp_malloc(buflen);
#line 699
        Fuzz = (unsigned char *)tmp___15;
#line 699
        fuzzkana((unsigned char const   *)line___1, Fuzz, buflen, 7U);
#line 700
        line___1 = Fuzz;
        }
      }
    }
  }
#line 705
  if (print_only) {
#line 707
    if (not) {
#line 707
      tmp___16 = " not";
    } else {
#line 707
      tmp___16 = "";
    }
#line 707
    if (lookup.patterns) {
#line 707
      tmp___17 = "and";
    } else {
#line 707
      tmp___17 = "a match is";
    }
    {
#line 707
    outputf("%s%s\241\310%s\241\311\n", tmp___17, tmp___16, line___1);
    }
  } else {
#line 712
    lookup.search[lookup.patterns].pattern = (unsigned char const   *)line___1;
#line 713
    lookup.search[lookup.patterns].not = (unsigned char )not;
  }
#line 715
  (lookup.patterns) ++;
#line 716
  return (1);
}
}
#line 720 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static void volatile   usage(void) 
{ 


  {
  {
#line 722
  warn("usage: %s [FLAGS] [FILES...]\n", lookup.prog);
#line 723
  output("  -help                :: report this list.\n  -version             :: show program version string and exit.\n  -verbose             :: turn index-creation verbosity on\n  -debug               :: turn on general debugging flag\n  -writeindex          :: create indices for FILES and exit.\n  -percent #           :: parameter for created indices.\n  -jis | -euc | -sjis  :: select encoding.\n  -norc                :: (this is the default for a server)\n  -rc FILE             :: use FILE as the rc file.\n  -noindex             :: don\'t load FILE\'s precomputed index\n  -cmddebug            :: turn on command debugging flag\n  -regexdebug          :: turn on regex debugging flag\n");
#line 751
  exit(1);
  }
}
}
#line 771 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
int get_window_size_bsd(int signum ) 
{ 
  struct winsize w ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 775
  tmp___0 = ioctl(2, 21523UL, & w);
  }
#line 775
  if (tmp___0 == 0) {
#line 775
    if ((int )w.ws_row > 0) {
      {
#line 778
      output_pager_columns((unsigned int )w.ws_col);
      }
#line 779
      if ((int )w.ws_row < 5) {
#line 779
        tmp = (int )w.ws_row;
      } else {
#line 779
        tmp = (int )w.ws_row - 2;
      }
      {
#line 779
      output_pager_lines((unsigned int )tmp);
#line 782
      set_jreadline_width((int )w.ws_col);
      }
    }
  }
  {
#line 787
  signal(28, (void (*)(int  ))(& get_window_size_bsd));
  }
#line 789
  return (0);
}
}
#line 796 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
int slot_num(struct slot_info *s ) 
{ 
  unsigned int i ;

  {
#line 799
  i = 0U;
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! (i < lookup.slots)) {
#line 799
      goto while_break;
    }
#line 800
    if ((unsigned long )lookup.slot_info[i] == (unsigned long )s) {
#line 801
      return ((int )i);
    }
#line 799
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 802
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 803
  return (-1);
}
}
#line 806 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
int exit_program_now  =    0;
#line 808 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
void process_input_line(unsigned char *input , int forced_search ) 
{ 
  int left_side_is_not ;
  int print_only ;
  int len ;
  size_t tmp ;
  int value ;
  int i ;
  int value___0 ;
  unsigned char c ;
  int count ;
  int error ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  unsigned char *ptr ;
  int right_side_is_not ;
  unsigned char *nextstart ;
  int tmp___12 ;
  char const   *tmp___13 ;

  {
#line 810
  left_side_is_not = 0;
#line 811
  print_only = 0;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 817
  if ((int )*(input + 0) == 63) {
#line 817
    if ((int )*(input + 1) == 0) {
      {
#line 819
      outputf("Command indicator is\241\310%c\241\311; use\241\310%chelp\241\311for help.\n",
              (int )lookup.cmdstart_char, (int )lookup.cmdstart_char);
      }
#line 821
      return;
    }
  }
#line 828
  if ((int )*(input + 0) == 43) {
#line 830
    input ++;
#line 831
    print_only = 1;
  }
  {
#line 834
  tmp = strlen((char const   *)((void *)((unsigned char const   *)input)));
#line 834
  len = (int )tmp;
  }
#line 834
  if (len == 0) {
#line 835
    return;
  }
#line 837
  lookup.slot = lookup.default_slot;
#line 840
  if (len > 2) {
#line 840
    if ((int )*(input + (len - 2)) == 44) {
#line 840
      if ((int )*(input + (len - 1)) >= 48) {
#line 840
        if ((int )*(input + (len - 1)) <= 57) {
#line 842
          value = (int )*(input + (len - 1)) - 48;
#line 843
          if ((unsigned int )value >= lookup.slots) {
            {
#line 845
            outputf("Nothing loaded to slot #%d.\n", value);
            }
#line 846
            return;
          }
#line 848
          len -= 2;
#line 849
          lookup.slot = lookup.slot_info[value];
          {
#line 850
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 850
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 840
          goto _L___2;
        }
      } else {
#line 840
        goto _L___2;
      }
    } else {
#line 840
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 854
    i = 2;
    {
#line 854
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 854
      if (! (i < len)) {
#line 854
        goto while_break___2;
      }
#line 855
      if ((int )*(input + i) == 44) {
#line 855
        if ((int )*(input + (i + 1)) >= 48) {
#line 855
          if ((int )*(input + (i + 1)) <= 57) {
#line 855
            if ((int )*(input + (i + 2)) == 124) {
#line 855
              if ((int )*(input + (i + 3)) == 124) {
#line 855
                goto _L;
              } else
#line 855
              if ((int )*(input + (i + 3)) == 33) {
#line 855
                if ((int )*(input + (i + 4)) == 124) {
                  _L: /* CIL Label */ 
#line 860
                  value___0 = (int )*(input + (i + 1)) - 48;
#line 861
                  if ((unsigned int )value___0 >= lookup.slots) {
#line 862
                    goto __Cont;
                  }
                  {
#line 863
                  lookup.slot = lookup.slot_info[value___0];
#line 864
                  len -= 2;
#line 865
                  bcopy((void const   *)((char *)(input + (i + 2))), (void *)((char *)(input + i)),
                        (size_t )((len - i) + 1));
                  }
#line 866
                  goto while_break___2;
                }
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 854
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 871
  (lookup.slot)->current_flag = (lookup.slot)->default_flag;
#line 877
  if ((int )*(input + 0) == 33) {
#line 880
    count = 0;
#line 881
    error = 0;
    {
#line 883
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 883
      len --;
#line 883
      input ++;
#line 883
      c = *(input + 0);
#line 883
      if (! error) {
#line 883
        if (((int )c & -128) == 0) {
          {
#line 883
          tmp___0 = __ctype_b_loc();
          }
#line 883
          if ((int const   )*(*tmp___0 + (int )c) & 1024) {
#line 883
            tmp___1 = 1;
          } else {
#line 883
            tmp___1 = 0;
          }
        } else {
#line 883
          tmp___1 = 0;
        }
      } else {
#line 883
        tmp___1 = 0;
      }
#line 883
      if (! tmp___1) {
#line 883
        goto while_break___3;
      }
#line 885
      count ++;
      {
#line 892
      if ((int )c == 119) {
#line 892
        goto case_119;
      }
#line 895
      if ((int )c == 87) {
#line 895
        goto case_87;
      }
#line 898
      if ((int )c == 77) {
#line 898
        goto case_77;
      }
#line 902
      if ((int )c == 70) {
#line 902
        goto case_70;
      }
#line 906
      if ((int )c == 116) {
#line 906
        goto case_116;
      }
#line 910
      if ((int )c == 99) {
#line 910
        goto case_99;
      }
#line 913
      if ((int )c == 100) {
#line 913
        goto case_100;
      }
#line 916
      if ((int )c == 102) {
#line 916
        goto case_102;
      }
#line 919
      if ((int )c == 114) {
#line 919
        goto case_114;
      }
#line 922
      if ((int )c == 104) {
#line 922
        goto case_104;
      }
#line 888
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 889
      outputf("unknown !-code \241\310%c\241\311; use !? for list.\n", (int )c);
#line 890
      error = 1;
      }
#line 891
      goto switch_break;
      case_119: /* CIL Label */ 
#line 893
      (lookup.slot)->current_flag.word ^= 1U;
#line 894
      goto switch_break;
      case_87: /* CIL Label */ 
#line 896
      (lookup.slot)->current_flag.glob ^= 1U;
#line 897
      goto switch_break;
      case_77: /* CIL Label */ 
#line 899
      if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 900
        (lookup.slot)->current_flag.modify ^= 1U;
      } else
#line 899
      if ((lookup.slot)->onefile_or_combo.onefile._modify_.pattern) {
#line 900
        (lookup.slot)->current_flag.modify ^= 1U;
      }
#line 901
      goto switch_break;
      case_70: /* CIL Label */ 
#line 903
      if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 904
        (lookup.slot)->current_flag.filter ^= 1U;
      } else
#line 903
      if ((lookup.slot)->onefile_or_combo.onefile._filter_.pattern) {
#line 904
        (lookup.slot)->current_flag.filter ^= 1U;
      }
#line 905
      goto switch_break;
      case_116: /* CIL Label */ 
#line 907
      if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 908
        (lookup.slot)->current_flag.tag ^= 1U;
      } else
#line 907
      if ((lookup.slot)->onefile_or_combo.onefile._tag_) {
#line 908
        (lookup.slot)->current_flag.tag ^= 1U;
      }
#line 909
      goto switch_break;
      case_99: /* CIL Label */ 
#line 911
      (lookup.slot)->current_flag.fold ^= 1U;
#line 912
      goto switch_break;
      case_100: /* CIL Label */ 
#line 914
      (lookup.slot)->current_flag.display ^= 1U;
#line 915
      goto switch_break;
      case_102: /* CIL Label */ 
#line 917
      (lookup.slot)->current_flag.fuzz ^= 1U;
#line 918
      goto switch_break;
      case_114: /* CIL Label */ 
#line 920
      (lookup.slot)->current_flag.fuzz = 0U;
#line 921
      goto switch_break;
      case_104: /* CIL Label */ 
#line 923
      (lookup.slot)->current_flag.highlight ^= 1U;
#line 924
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 928
    if ((int )c == 63) {
#line 930
      if ((lookup.slot)->default_flag.word) {
#line 930
        tmp___2 = "\247\267";
      } else {
#line 930
        tmp___2 = "  ";
      }
#line 930
      if ((lookup.slot)->default_flag.modify) {
#line 930
        tmp___3 = "\247\267";
      } else {
#line 930
        tmp___3 = "  ";
      }
#line 930
      if ((lookup.slot)->default_flag.filter) {
#line 930
        tmp___4 = "\247\267";
      } else {
#line 930
        tmp___4 = "  ";
      }
      {
#line 930
      outputf("\250\256\250\254\250\270\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\270\250\254\250\257\n\250\255 F\250\242toggle filtration           \250\242%s\250\255\n\250\255 M\250\242toggle modification         \250\242%s\250\255\n\250\255 w\250\242toggle word-preference mode \250\242%s\250\255\n",
              tmp___4, tmp___3, tmp___2);
      }
#line 938
      if ((lookup.slot)->default_flag.glob) {
#line 938
        tmp___5 = "\247\267";
      } else {
#line 938
        tmp___5 = "  ";
      }
#line 938
      if ((lookup.slot)->default_flag.fuzz) {
#line 938
        tmp___6 = "\247\267";
      } else {
#line 938
        tmp___6 = "  ";
      }
#line 938
      if ((lookup.slot)->default_flag.fold) {
#line 938
        tmp___7 = "\247\267";
      } else {
#line 938
        tmp___7 = "  ";
      }
      {
#line 938
      outputf("\250\255 c\250\242toggle case folding         \250\242%s\250\255\n\250\255 f\250\242toggle fuzzification        \250\242%s\250\255\n\250\255 r\250\242raw (force fuzzification off)   \250\255\n\250\255 W\250\242toggle wildcard-pattern mode\250\242%s\250\255\n",
              tmp___7, tmp___6, tmp___5);
      }
#line 946
      if ((lookup.slot)->default_flag.tag) {
#line 946
        tmp___8 = "\247\267";
      } else {
#line 946
        tmp___8 = "  ";
      }
#line 946
      if ((lookup.slot)->default_flag.display) {
#line 946
        tmp___9 = "\247\267";
      } else {
#line 946
        tmp___9 = "  ";
      }
#line 946
      if ((lookup.slot)->default_flag.highlight) {
#line 946
        tmp___10 = "\247\267";
      } else {
#line 946
        tmp___10 = "  ";
      }
      {
#line 946
      outputf("\250\255 h\250\242toggle match highlighting   \250\242%s\250\255\n\250\255 t\250\242toggle tagging              \250\242%s\250\255\n\250\255 d\250\242toggle displaying           \250\242%s\250\255\n\250\261\250\254\250\272\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\272\250\254\250\260\n",
              tmp___10, tmp___9, tmp___8);
      }
#line 954
      return;
    }
#line 956
    if (error) {
#line 957
      return;
    }
#line 959
    if (count == 0) {
#line 962
      (lookup.slot)->current_flag.fuzz ^= 1U;
    }
#line 965
    if ((int )c == 33) {
#line 967
      input ++;
#line 968
      len --;
    }
  }
  {
#line 972
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 972
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 973
  if (len == 0) {
#line 974
    return;
  }
#line 980
  if (! forced_search) {
#line 980
    if ((int )*(input + 0) == (int )lookup.cmdstart_char) {
      {
#line 983
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 983
        if (! ((int )*input == (int )lookup.cmdstart_char)) {
#line 983
          goto while_break___5;
        }
#line 984
        input ++;
#line 985
        len --;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 989
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 989
        if (! ((int )*input == 32)) {
#line 989
          goto while_break___6;
        }
#line 990
        input ++;
#line 991
        len --;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 994
      if (len) {
        {
#line 994
        tmp___11 = parse_command((unsigned char const   *)input, (unsigned int )len,
                                 1U, 0U);
        }
#line 994
        if (tmp___11 == 12) {
          {
#line 995
          outputf("unknown command\241\310%s\241\311\n", input);
          }
        }
      }
#line 996
      return;
    }
  }
#line 999
  *(input + len) = (unsigned char )'\000';
#line 1000
  lookup.patterns = 0;
#line 1001
  left_side_is_not = 0;
  {
#line 1003
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1003
    if (! input) {
#line 1003
      goto while_break___7;
    }
#line 1005
    ptr = input;
#line 1006
    right_side_is_not = 0;
#line 1007
    nextstart = (unsigned char *)0;
    {
#line 1009
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1009
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1011
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1011
      if (! ((int )*(ptr + 0) != 0)) {
#line 1011
        goto while_break___9;
      }
#line 1013
      if ((int )*(ptr + 0) == 92) {
#line 1013
        if ((int )*(ptr + 1) != 0) {
#line 1014
          ptr += 2;
        } else {
#line 1013
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1015
      if ((int )*(ptr + 0) == 124) {
#line 1015
        if ((int )*(ptr + 1) == 124) {
#line 1016
          nextstart = ptr + 2;
#line 1017
          *(ptr + 0) = (unsigned char )'\000';
#line 1018
          goto while_break___9;
        } else {
#line 1015
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1019
      if ((int )*(ptr + 0) == 124) {
#line 1019
        if ((int )*(ptr + 1) == 33) {
#line 1019
          if ((int )*(ptr + 2) == 124) {
#line 1020
            nextstart = ptr + 3;
#line 1021
            right_side_is_not = 1;
#line 1022
            *(ptr + 0) = (unsigned char )'\000';
#line 1023
            goto while_break___9;
          } else {
#line 1025
            ptr ++;
          }
        } else {
#line 1025
          ptr ++;
        }
      } else {
#line 1025
        ptr ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1029
    if ((unsigned long )input == (unsigned long )ptr) {
      {
#line 1031
      outputf("empty regex clause before\241\310%s\241\311.\n", input);
      }
#line 1032
      return;
    }
#line 1035
    if (nextstart) {
#line 1035
      if ((int )*nextstart == 0) {
        {
#line 1037
        outputf("expected regex after final\241\310|%s\241\311, aborting\n", ptr + 1);
        }
#line 1039
        return;
      }
    }
    {
#line 1043
    tmp___12 = prepare_line(print_only, input, (unsigned int )(ptr - input), left_side_is_not);
    }
#line 1043
    if (! tmp___12) {
#line 1044
      return;
    }
#line 1046
    input = nextstart;
#line 1047
    left_side_is_not = right_side_is_not;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1050
  if (lookup.patterns == 0) {
    {
#line 1052
    output("no patterns!\n");
    }
#line 1053
    return;
  }
#line 1056
  if (print_only) {
#line 1057
    return;
  }
  {
#line 1059
  apply_regex();
#line 1060
  free_temp_memory();
  }
#line 1062
  if (! apply_regex_abort) {
#line 1062
    if ((lookup.slot)->current_flag.display) {
#line 1064
      if (! lookup.count.printed) {
#line 1064
        if (lookup.count.nonword) {
          {
#line 1066
          output("\242\343no whole words found, non-words shown here\242\344\n");
#line 1067
          cmd_show();
#line 1068
          lookup.count.printed += (unsigned long )lookup.list.used;
          }
#line 1069
          if (lookup.count.filtered) {
            {
#line 1071
            outputf("\242\343additionally, %ld ", lookup.count.filtered);
            }
#line 1072
            if (! ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0))) {
#line 1072
              if ((unsigned long )(lookup.slot)->onefile_or_combo.onefile._filter_.name != (unsigned long )((unsigned char const   *)0)) {
                {
#line 1073
                outputf("\241\310%s\241\311", (lookup.slot)->onefile_or_combo.onefile._filter_.name);
                }
              }
            }
            {
#line 1074
            output("filtered and discarded\242\344\n");
            }
          }
#line 1076
          return;
        }
      }
#line 1078
      if (lookup.list.used == 1U) {
#line 1078
        if (lookup.count.filtered + lookup.count.nonword == 1UL) {
          {
#line 1081
          cmd_show();
#line 1082
          lookup.count.printed += (unsigned long )lookup.list.used;
          }
#line 1083
          return;
        }
      }
    }
  }
#line 1087
  if (lookup.count.filtered) {
#line 1087
    goto _L___5;
  } else
#line 1087
  if (lookup.count.nonword) {
    _L___5: /* CIL Label */ 
#line 1089
    if (lookup.flag.debug) {
      {
#line 1090
      outputf("[%ld checked; %ld matched; %ld filtered; %ld nonword; %ld printed]\n",
              lookup.count.checked, lookup.count.matched, lookup.count.filtered, lookup.count.nonword,
              lookup.count.printed);
      }
    }
    {
#line 1096
    output("\242\343elided: ");
    }
#line 1097
    if (lookup.count.filtered) {
#line 1099
      if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
        {
#line 1100
        outputf("%ld filtered", lookup.count.filtered);
        }
      } else
#line 1099
      if ((unsigned long )(lookup.slot)->onefile_or_combo.onefile._filter_.name == (unsigned long )((unsigned char const   *)0)) {
        {
#line 1100
        outputf("%ld filtered", lookup.count.filtered);
        }
      } else {
        {
#line 1102
        outputf("%ld\241\310%s\241\311filtered", lookup.count.filtered, (lookup.slot)->onefile_or_combo.onefile._filter_.name);
        }
      }
    }
#line 1106
    if (lookup.count.nonword) {
#line 1107
      if (lookup.count.filtered) {
#line 1107
        tmp___13 = "; ";
      } else {
#line 1107
        tmp___13 = "";
      }
      {
#line 1107
      outputf("%s%ld nonword", tmp___13, lookup.count.nonword);
      }
    }
#line 1110
    if (! lookup.list.used) {
      {
#line 1111
      outputf("\242\344\n");
      }
    } else {
      {
#line 1114
      outputf(" (use\241\310%cshow\241\311to display", (int )lookup.cmdstart_char);
      }
#line 1115
      if (lookup.list.overflow) {
        {
#line 1116
        outputf(" first %d", lookup.list.used);
        }
      }
      {
#line 1117
      outputf(")\242\344\n");
      }
    }
  }
#line 1120
  return;
}
}
#line 1127 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
int load_file(char const   *filename , unsigned int flag ) 
{ 
  char const   *action ;
  struct fileinfo *fileinfo ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1129
  action = "load";
#line 1130
  fileinfo = (struct fileinfo *)0;
#line 1133
  i = 0;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! ((unsigned int )i < lookup.slots)) {
#line 1133
      goto while_break;
    }
#line 1134
    if (! ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0))) {
      {
#line 1134
      tmp = strcmp((char const   *)((void *)((unsigned char const   *)filename)),
                   (char const   *)((void *)((unsigned char const   *)(((lookup.slot_info[i])->file)->v)->filename)));
      }
#line 1134
      if (! tmp) {
#line 1137
        fileinfo = (lookup.slot_info[i])->file;
#line 1138
        action = "link";
#line 1139
        goto while_break;
      }
    }
#line 1133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  if ((unsigned long )fileinfo == (unsigned long )((struct fileinfo *)0)) {
#line 1144
    if (lookup.slots >= 10U) {
      {
#line 1146
      outputf("%scan\'t load [%s] (too many loaded files, max is %d)\n", lookup.where,
              filename, 10);
      }
#line 1148
      return (-1);
    }
#line 1151
    if (UseNoMemIndex) {
#line 1152
      flag |= 262144U;
    }
    {
#line 1154
    fileinfo = loadfile(filename, (unsigned int )lookup.percent, flag);
    }
#line 1154
    if ((unsigned long )fileinfo == (unsigned long )((struct fileinfo *)0)) {
#line 1155
      return (-1);
    }
#line 1156
    if (flag & 65536U) {
#line 1157
      return (0);
    }
#line 1158
    if (lookup.flag.verbose) {
      {
#line 1159
      outputf("loaded \"%s\".\n", filename);
      }
    }
  }
  {
#line 1162
  tmp___0 = xmalloc((unsigned int )sizeof(struct slot_info ));
#line 1162
  lookup.slot_info[lookup.slots] = (struct slot_info *)tmp___0;
#line 1163
  bzero((void *)lookup.slot_info[lookup.slots], sizeof(struct slot_info ));
#line 1164
  (lookup.slot_info[lookup.slots])->file = fileinfo;
#line 1165
  (lookup.slot_info[lookup.slots])->default_flag = lookup.flag;
#line 1166
  (lookup.slot_info[lookup.slots])->default_flag.filter = 0U;
#line 1167
  (lookup.slot_info[lookup.slots])->default_flag.modify = 0U;
  }
#line 1168
  if (lookup.flag.verbose) {
    {
#line 1169
    outputf("\r%sed \"%s\" to slot %d\n", action, filename, lookup.slots);
    }
  }
#line 1170
  tmp___1 = lookup.slots;
#line 1170
  (lookup.slots) ++;
#line 1170
  return ((int )tmp___1);
}
}
#line 1173 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
__inline static void startup(int argc , char const   **argv ) 
{ 
  unsigned int cmd_line_loadfile_flags ;
  char const   *rc_file_name ;
  unsigned char const   *encoding ;
  unsigned int read_rc_skip_mask ;
  int read_rc ;
  char const   *ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   **tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int i ;
  int file_must_be_found ;
  unsigned char *tmp___21 ;

  {
#line 1175
  cmd_line_loadfile_flags = 0U;
#line 1176
  rc_file_name = (char const   *)0;
#line 1177
  encoding = (unsigned char const   *)0;
#line 1178
  read_rc_skip_mask = 0U;
#line 1181
  read_rc = 1;
#line 1186
  if ((unsigned long )*(argv + 0) == (unsigned long )((char const   *)0)) {
#line 1187
    lookup.prog_short = "lookup";
#line 1187
    lookup.prog = lookup.prog_short;
  } else {
#line 1190
    lookup.prog = *(argv + 0);
#line 1191
    lookup.prog_short = lookup.prog;
#line 1191
    ptr = lookup.prog_short;
    {
#line 1191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1191
      if (! *ptr) {
#line 1191
        goto while_break;
      }
#line 1192
      if ((int const   )*ptr == 47) {
#line 1193
        lookup.prog_short = ptr + 1;
      }
#line 1191
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1196
  lookup.where = (unsigned char const   *)"commandline: ";
  {
#line 1198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1198
    argv ++;
#line 1198
    argc --;
#line 1198
    if (argc > 0) {
#line 1198
      if ((int const   )*(*(argv + 0) + 0) == 45) {
#line 1198
        tmp___17 = 1;
      } else {
#line 1198
        tmp___17 = 0;
      }
    } else {
#line 1198
      tmp___17 = 0;
    }
#line 1198
    if (! tmp___17) {
#line 1198
      goto while_break___0;
    }
    {
#line 1200
    tmp___16 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                      (char const   *)((void *)((unsigned char const   *)"-help")));
    }
#line 1200
    if (tmp___16) {
      {
#line 1202
      tmp___15 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                        (char const   *)((void *)((unsigned char const   *)"-verbose")));
      }
#line 1202
      if (tmp___15) {
        {
#line 1209
        tmp___14 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                          (char const   *)((void *)((unsigned char const   *)"-debug")));
        }
#line 1209
        if (tmp___14) {
          {
#line 1211
          tmp___12 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                            (char const   *)((void *)((unsigned char const   *)"-v")));
          }
#line 1211
          if (tmp___12) {
            {
#line 1211
            tmp___13 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                              (char const   *)((void *)((unsigned char const   *)"-version")));
            }
#line 1211
            if (tmp___13) {
              {
#line 1215
              tmp___10 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                (char const   *)((void *)((unsigned char const   *)"-writeindex")));
              }
#line 1215
              if (tmp___10) {
                {
#line 1215
                tmp___11 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                  (char const   *)((void *)((unsigned char const   *)"-write")));
                }
#line 1215
                if (tmp___11) {
                  {
#line 1220
                  tmp___9 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                   (char const   *)((void *)((unsigned char const   *)"-rc")));
                  }
#line 1220
                  if (tmp___9) {
                    {
#line 1228
                    tmp___8 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                     (char const   *)((void *)((unsigned char const   *)"-percent")));
                    }
#line 1228
                    if (tmp___8) {
                      {
#line 1236
                      tmp___7 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                       (char const   *)((void *)((unsigned char const   *)"-jis")));
                      }
#line 1236
                      if (tmp___7) {
                        {
#line 1238
                        tmp___6 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                         (char const   *)((void *)((unsigned char const   *)"-euc")));
                        }
#line 1238
                        if (tmp___6) {
                          {
#line 1240
                          tmp___5 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                           (char const   *)((void *)((unsigned char const   *)"-sjis")));
                          }
#line 1240
                          if (tmp___5) {
                            {
#line 1242
                            tmp___4 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                             (char const   *)((void *)((unsigned char const   *)"-noindex")));
                            }
#line 1242
                            if (tmp___4) {
                              {
#line 1244
                              tmp___3 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                               (char const   *)((void *)((unsigned char const   *)"-regexdebug")));
                              }
#line 1244
                              if (tmp___3) {
                                {
#line 1246
                                tmp___2 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                                 (char const   *)((void *)((unsigned char const   *)"-cmddebug")));
                                }
#line 1246
                                if (tmp___2) {
                                  {
#line 1248
                                  tmp___1 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                                   (char const   *)((void *)((unsigned char const   *)"-nomem")));
                                  }
#line 1248
                                  if (tmp___1) {
                                    {
#line 1250
                                    tmp___0 = strcmp((char const   *)((void *)((unsigned char const   *)*argv)),
                                                     (char const   *)((void *)((unsigned char const   *)"-norc")));
                                    }
#line 1250
                                    if (tmp___0) {
                                      {
#line 1263
                                      warn("%s: unknown flag \"%s\".\n", lookup.prog,
                                           *argv);
#line 1264
                                      usage();
                                      }
                                    } else {
#line 1251
                                      read_rc = 0;
                                    }
                                  } else {
#line 1249
                                    UseNoMemIndex = 1;
                                  }
                                } else {
#line 1247
                                  lookup.flag.cmd_debug = 1U;
                                }
                              } else {
#line 1245
                                lookup.flag.regex_debug = 1U;
                              }
                            } else {
#line 1243
                              cmd_line_loadfile_flags |= 131072U;
                            }
                          } else {
#line 1241
                            encoding = (unsigned char const   *)"encode sjis";
                          }
                        } else {
#line 1239
                          encoding = (unsigned char const   *)"encode euc";
                        }
                      } else {
#line 1237
                        encoding = (unsigned char const   *)"encode jis";
                      }
                    } else {
#line 1229
                      argc --;
#line 1229
                      if (argc > 0) {
                        {
#line 1230
                        argv ++;
#line 1230
                        tmp = atoi(*(argv + 0));
#line 1230
                        lookup.percent = (unsigned char )tmp;
                        }
                      } else {
                        {
#line 1232
                        warn("%s: expected arg to -percent\n", lookup.prog);
#line 1233
                        usage();
                        }
                      }
                    }
                  } else {
#line 1221
                    argc --;
#line 1221
                    if (argc <= 0) {
                      {
#line 1222
                      warn("%s: expected filename arg to %s\n", lookup.prog, *(argv + 0));
#line 1223
                      usage();
                      }
                    }
#line 1225
                    argv ++;
#line 1225
                    rc_file_name = *(argv + 0);
#line 1226
                    read_rc = 1;
                  }
                } else {
#line 1217
                  cmd_line_loadfile_flags |= 65536U;
#line 1218
                  lookup.flag.verbose = 1U;
                }
              } else {
#line 1217
                cmd_line_loadfile_flags |= 65536U;
#line 1218
                lookup.flag.verbose = 1U;
              }
            } else {
              {
#line 1212
              cmd_version();
#line 1213
              exit(0);
              }
            }
          } else {
            {
#line 1212
            cmd_version();
#line 1213
            exit(0);
            }
          }
        } else {
#line 1210
          lookup.flag.debug = 1U;
        }
      } else {
#line 1204
        cmd_line_loadfile_flags |= 4U;
      }
    } else {
      {
#line 1201
      usage();
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1268
  if (encoding) {
    {
#line 1270
    quick_command(encoding);
#line 1271
    read_rc_skip_mask = 128U;
    }
  }
#line 1275
  if (argc) {
#line 1280
    if ((cmd_line_loadfile_flags & 196608U) == 0U) {
#line 1283
      cmd_line_loadfile_flags |= 524288U;
    }
    {
#line 1286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1286
      tmp___20 = argc;
#line 1286
      argc --;
#line 1286
      if (! (tmp___20 > 0)) {
#line 1286
        goto while_break___1;
      }
      {
#line 1287
      tmp___18 = argv;
#line 1287
      argv ++;
#line 1287
      tmp___19 = load_file(*(tmp___18 + 0), cmd_line_loadfile_flags);
      }
#line 1287
      if (tmp___19 < 0) {
        {
#line 1288
        die("exiting");
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1292
  if (cmd_line_loadfile_flags & 65536U) {
    {
#line 1293
    exit(0);
    }
  }
  {
#line 1298
  cmd_list_size((unsigned char const   *)"100");
#line 1299
  lookup.flag.verbose = 1U;
  }
#line 1307
  if (read_rc) {
#line 1310
    file_must_be_found = 1;
#line 1311
    if ((unsigned long )rc_file_name == (unsigned long )((char const   *)0)) {
      {
#line 1313
      rc_file_name = expand_filename_tilde("~/.lookup");
      }
#line 1314
      if ((int const   )*(rc_file_name + 0) == 126) {
#line 1315
        rc_file_name += 2;
      }
#line 1316
      file_must_be_found = 0;
    }
#line 1318
    if (lookup.slots != 0U) {
#line 1319
      read_rc_skip_mask |= 64U;
    }
    {
#line 1321
    i = read_commands_from_file(rc_file_name, 17U, read_rc_skip_mask);
    }
#line 1323
    if (file_must_be_found) {
#line 1323
      if (i == 1) {
        {
#line 1324
        die("%s: startup file \"%s\" not found.\n", lookup.prog, rc_file_name);
        }
      }
    }
#line 1326
    if (i != 0) {
#line 1326
      if (i != 1) {
        {
#line 1327
        die("aborting");
        }
      }
    }
  }
#line 1331
  if (lookup.slots == 0U) {
    {
#line 1332
    die("%s: no files specified\n", lookup.prog);
    }
  }
#line 1336
  if ((unsigned long )lookup.prompt_format == (unsigned long )((unsigned char const   *)0)) {
    {
#line 1337
    tmp___21 = strsave((unsigned char const   *)"%C(%0 command)%!C(search [%n])> ");
#line 1337
    lookup.prompt_format = (unsigned char const   *)tmp___21;
    }
  }
#line 1341
  if ((unsigned long )lookup.default_slot == (unsigned long )((struct slot_info *)0)) {
#line 1342
    lookup.default_slot = lookup.slot_info[0];
  }
  {
#line 1344
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1344
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1345
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1345
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1348
  set_romaji_converter(& romaji_converter___0);
#line 1349
  signal(2, (void (*)(int  ))(& sighandler));
#line 1352
  lookup.where = (unsigned char const   *)"";
  }
#line 1353
  return;
}
}
#line 1505
int main(int argc , char const   **argv ) ;
#line 1505 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
static int abort_count  =    0;
#line 1470 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.c"
int main(int argc , char const   **argv ) 
{ 
  unsigned char const   *prompt_format ;
  unsigned char const   *tmp ;
  unsigned char *input ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1473
  get_window_size_bsd(0);
#line 1476
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"start \n");
#line 1478
  lookup.flag.fuzz = 1U;
#line 1479
  lookup.flag.fold = 1U;
#line 1480
  lookup.flag.display = 1U;
#line 1481
  lookup.flag.autokana = 1U;
#line 1482
  lookup.cmdstart_char = (unsigned char )' ';
#line 1484
  lookup.spinner.interval = (unsigned short)200;
#line 1486
  lookup.max_lines_to_print = 100L;
#line 1487
  lookup.percent = (unsigned char)100;
#line 1489
  startup(argc, argv);
  }
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1506
    if ((lookup.default_slot)->prompt_format) {
#line 1506
      tmp = (lookup.default_slot)->prompt_format;
    } else {
#line 1506
      tmp = lookup.prompt_format;
    }
#line 1506
    prompt_format = tmp;
#line 1510
    in_command = 0;
    {
#line 1511
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1511
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1512
    tmp___0 = gen_prompt(prompt_format, 1);
#line 1512
    input = mygetline(tmp___0);
    }
#line 1515
    if (apply_regex_abort) {
#line 1517
      tmp___1 = abort_count;
#line 1517
      abort_count ++;
#line 1517
      if (tmp___1 == 2) {
        {
#line 1518
        output("  \242\252  \242\250one more to abort\242\250  \242\253\n");
        }
      } else
#line 1519
      if (abort_count >= 3) {
        {
#line 1521
        output("  \242\250abort\242\250\n");
        }
#line 1522
        goto while_break___0;
      }
#line 1524
      goto __Cont;
    }
#line 1526
    abort_count = 0;
#line 1528
    if ((unsigned long )input == (unsigned long )((unsigned char *)0)) {
#line 1529
      goto while_break___0;
    } else
#line 1530
    if ((int )*(input + 0) != 0) {
      {
#line 1531
      process_input_line(input, 0);
      }
    }
    __Cont: /* CIL Label */ 
#line 1503
    if (! (! exit_program_now)) {
#line 1503
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1538
  tmp___2 = set_extra_output_file(-2);
  }
#line 1538
  if (tmp___2 >= 0) {
    {
#line 1540
    lookup.flag.verbose = 1U;
#line 1541
    cmd_log(1, 0, (unsigned char const   *)0);
    }
  }
#line 1545
  return (0);
}
}
#line 106 "/home/wheatley/newnew/temp/lookup-1.08b/lib/kanaid.h"
unsigned long _KID[86] ;
#line 20 "/home/wheatley/newnew/temp/lookup-1.08b/lib/kanaid.c"
unsigned long _KID[86]  = 
#line 20 "/home/wheatley/newnew/temp/lookup-1.08b/lib/kanaid.c"
  {      6291457UL,      4194305UL,      6291458UL,      4194306UL, 
        6291460UL,      4194308UL,      6291464UL,      37748744UL, 
        6291472UL,      37748752UL,      33UL,      65UL, 
        34UL,      66UL,      36UL,      68UL, 
        40UL,      72UL,      48UL,      80UL, 
        129UL,      257UL,      130UL,      33554690UL, 
        132UL,      33554692UL,      136UL,      264UL, 
        144UL,      272UL,      513UL,      1025UL, 
        514UL,      33555458UL,      2097668UL,      516UL, 
        33555460UL,      520UL,      1032UL,      528UL, 
        1040UL,      2049UL,      2050UL,      2052UL, 
        2056UL,      2064UL,      4097UL,      8193UL, 
        16385UL,      4098UL,      8194UL,      16386UL, 
        4100UL,      8196UL,      16388UL,      4104UL, 
        8200UL,      16392UL,      4112UL,      8208UL, 
        16400UL,      32769UL,      32770UL,      32772UL, 
        32776UL,      32784UL,      2162689UL,      65537UL, 
        2162692UL,      65540UL,      2162704UL,      65552UL, 
        131073UL,      131074UL,      131076UL,      131080UL, 
        131088UL,      2359297UL,      262145UL,      16777216UL, 
        50331648UL,      34078720UL,      1048576UL,      8388612UL, 
        10485793UL,      10485800UL};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 231 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
matched_paren_t *regexec_paren_info ;
#line 232
unsigned int regexec_paren_info_size ;
#line 235
unsigned int regexec_paren_info_used ;
#line 275
unsigned char const   *regcomp_eptr ;
#line 252 "/home/wheatley/newnew/temp/lookup-1.08b/lookup.h"
int cmd_output_encoding(unsigned char const   *main_style , unsigned char const   *jis_year ,
                        unsigned char const   *jis_english , unsigned char const   *other ) ;
#line 265
extern char const   version_string[] ;
#line 266
extern char const   version_date[] ;
#line 267
extern char const   compile_date[] ;
#line 268
extern char const   author_name[] ;
#line 269
extern char const   contact_addr[] ;
#line 41 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static unsigned int interpret_boolean(unsigned char const   *str___0 ) 
{ 


  {
#line 43
  if ((int const   )*(str___0 + 0) == 48) {
#line 44
    return (0U);
  } else
#line 43
  if ((int const   )*(str___0 + 1) == 102) {
#line 44
    return (0U);
  } else
#line 43
  if ((int const   )*(str___0 + 1) == 70) {
#line 44
    return (0U);
  }
#line 45
  if ((int const   )*(str___0 + 0) == 49) {
#line 46
    return (1U);
  } else
#line 45
  if ((int const   )*(str___0 + 1) == 110) {
#line 46
    return (1U);
  } else
#line 45
  if ((int const   )*(str___0 + 1) == 78) {
#line 46
    return (1U);
  }
  {
#line 47
  die("<don\'t know what to do with [%s]>\n", str___0);
  }
#line 48
  return (0U);
}
}
#line 92 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_debug_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 92
  when = (unsigned char const   *)"is";
#line 92
  if (bool) {
    {
#line 92
    lookup.flag.debug = interpret_boolean(bool);
    }
#line 92
    if (! lookup.flag.verbose) {
#line 92
      return (0);
    }
#line 92
    when = (unsigned char const   *)"now";
  }
#line 92
  if (lookup.flag.debug) {
#line 92
    tmp = "on";
  } else {
#line 92
    tmp = "off";
  }
  {
#line 92
  outputf("%s %s %s.\n", "general debugging", when, tmp);
  }
#line 92
  return (0);
}
}
#line 93 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_regex_debug_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 93
  when = (unsigned char const   *)"is";
#line 93
  if (bool) {
    {
#line 93
    lookup.flag.regex_debug = interpret_boolean(bool);
    }
#line 93
    if (! lookup.flag.verbose) {
#line 93
      return (0);
    }
#line 93
    when = (unsigned char const   *)"now";
  }
#line 93
  if (lookup.flag.regex_debug) {
#line 93
    tmp = "on";
  } else {
#line 93
    tmp = "off";
  }
  {
#line 93
  outputf("%s %s %s.\n", "regex debugging", when, tmp);
  }
#line 93
  return (0);
}
}
#line 94 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_cmd_debug_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 94
  when = (unsigned char const   *)"is";
#line 94
  if (bool) {
    {
#line 94
    lookup.flag.cmd_debug = interpret_boolean(bool);
    }
#line 94
    if (! lookup.flag.verbose) {
#line 94
      return (0);
    }
#line 94
    when = (unsigned char const   *)"now";
  }
#line 94
  if (lookup.flag.cmd_debug) {
#line 94
    tmp = "on";
  } else {
#line 94
    tmp = "off";
  }
  {
#line 94
  outputf("%s %s %s.\n", "command debugging", when, tmp);
  }
#line 94
  return (0);
}
}
#line 96 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_word_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 96
  when = (unsigned char const   *)"is";
#line 96
  if (bool) {
    {
#line 96
    lookup.flag.word = interpret_boolean(bool);
    }
#line 96
    if (! lookup.flag.verbose) {
#line 96
      return (0);
    }
#line 96
    when = (unsigned char const   *)"now";
  }
#line 96
  if (lookup.flag.word) {
#line 96
    tmp = "on";
  } else {
#line 96
    tmp = "off";
  }
  {
#line 96
  outputf("%s %s %s.\n", "word preference mode", when, tmp);
  }
#line 96
  return (0);
}
}
#line 96 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_word_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 96
  when = (unsigned char const   *)"is";
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if (bool) {
    {
#line 96
    (lookup.slot)->default_flag.word = interpret_boolean(bool);
    }
#line 96
    if (! lookup.flag.verbose) {
#line 96
      return (0);
    }
#line 96
    when = (unsigned char const   *)"now";
  }
#line 96
  if ((lookup.slot)->default_flag.word) {
#line 96
    tmp = "on";
  } else {
#line 96
    tmp = "off";
  }
  {
#line 96
  tmp___0 = slot_num(lookup.slot);
#line 96
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "word preference mode", when, tmp);
  }
#line 96
  return (0);
}
}
#line 97 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_glob_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 97
  when = (unsigned char const   *)"is";
#line 97
  if (bool) {
    {
#line 97
    lookup.flag.glob = interpret_boolean(bool);
    }
#line 97
    if (! lookup.flag.verbose) {
#line 97
      return (0);
    }
#line 97
    when = (unsigned char const   *)"now";
  }
#line 97
  if (lookup.flag.glob) {
#line 97
    tmp = "on";
  } else {
#line 97
    tmp = "off";
  }
  {
#line 97
  outputf("%s %s %s.\n", "wildcard-pattern mode", when, tmp);
  }
#line 97
  return (0);
}
}
#line 97 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_glob_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 97
  when = (unsigned char const   *)"is";
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (bool) {
    {
#line 97
    (lookup.slot)->default_flag.glob = interpret_boolean(bool);
    }
#line 97
    if (! lookup.flag.verbose) {
#line 97
      return (0);
    }
#line 97
    when = (unsigned char const   *)"now";
  }
#line 97
  if ((lookup.slot)->default_flag.glob) {
#line 97
    tmp = "on";
  } else {
#line 97
    tmp = "off";
  }
  {
#line 97
  tmp___0 = slot_num(lookup.slot);
#line 97
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "wildcard-pattern mode", when, tmp);
  }
#line 97
  return (0);
}
}
#line 98 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_fold_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 98
  when = (unsigned char const   *)"is";
#line 98
  if (bool) {
    {
#line 98
    lookup.flag.fold = interpret_boolean(bool);
    }
#line 98
    if (! lookup.flag.verbose) {
#line 98
      return (0);
    }
#line 98
    when = (unsigned char const   *)"now";
  }
#line 98
  if (lookup.flag.fold) {
#line 98
    tmp = "on";
  } else {
#line 98
    tmp = "off";
  }
  {
#line 98
  outputf("%s %s %s.\n", "case folding", when, tmp);
  }
#line 98
  return (0);
}
}
#line 98 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_fold_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 98
  when = (unsigned char const   *)"is";
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (bool) {
    {
#line 98
    (lookup.slot)->default_flag.fold = interpret_boolean(bool);
    }
#line 98
    if (! lookup.flag.verbose) {
#line 98
      return (0);
    }
#line 98
    when = (unsigned char const   *)"now";
  }
#line 98
  if ((lookup.slot)->default_flag.fold) {
#line 98
    tmp = "on";
  } else {
#line 98
    tmp = "off";
  }
  {
#line 98
  tmp___0 = slot_num(lookup.slot);
#line 98
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "case folding", when, tmp);
  }
#line 98
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_display_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 99
  when = (unsigned char const   *)"is";
#line 99
  if (bool) {
    {
#line 99
    lookup.flag.display = interpret_boolean(bool);
    }
#line 99
    if (! lookup.flag.verbose) {
#line 99
      return (0);
    }
#line 99
    when = (unsigned char const   *)"now";
  }
#line 99
  if (lookup.flag.display) {
#line 99
    tmp = "on";
  } else {
#line 99
    tmp = "off";
  }
  {
#line 99
  outputf("%s %s %s.\n", "matching-line display", when, tmp);
  }
#line 99
  return (0);
}
}
#line 99 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_display_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 99
  when = (unsigned char const   *)"is";
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  if (bool) {
    {
#line 99
    (lookup.slot)->default_flag.display = interpret_boolean(bool);
    }
#line 99
    if (! lookup.flag.verbose) {
#line 99
      return (0);
    }
#line 99
    when = (unsigned char const   *)"now";
  }
#line 99
  if ((lookup.slot)->default_flag.display) {
#line 99
    tmp = "on";
  } else {
#line 99
    tmp = "off";
  }
  {
#line 99
  tmp___0 = slot_num(lookup.slot);
#line 99
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "matching-line display", when, tmp);
  }
#line 99
  return (0);
}
}
#line 100 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_fuzz_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 100
  when = (unsigned char const   *)"is";
#line 100
  if (bool) {
    {
#line 100
    lookup.flag.fuzz = interpret_boolean(bool);
    }
#line 100
    if (! lookup.flag.verbose) {
#line 100
      return (0);
    }
#line 100
    when = (unsigned char const   *)"now";
  }
#line 100
  if (lookup.flag.fuzz) {
#line 100
    tmp = "on";
  } else {
#line 100
    tmp = "off";
  }
  {
#line 100
  outputf("%s %s %s.\n", "fuzzification", when, tmp);
  }
#line 100
  return (0);
}
}
#line 100 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_fuzz_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 100
  when = (unsigned char const   *)"is";
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  if (bool) {
    {
#line 100
    (lookup.slot)->default_flag.fuzz = interpret_boolean(bool);
    }
#line 100
    if (! lookup.flag.verbose) {
#line 100
      return (0);
    }
#line 100
    when = (unsigned char const   *)"now";
  }
#line 100
  if ((lookup.slot)->default_flag.fuzz) {
#line 100
    tmp = "on";
  } else {
#line 100
    tmp = "off";
  }
  {
#line 100
  tmp___0 = slot_num(lookup.slot);
#line 100
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "fuzzification", when, tmp);
  }
#line 100
  return (0);
}
}
#line 101 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_highlight_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 101
  when = (unsigned char const   *)"is";
#line 101
  if (bool) {
    {
#line 101
    lookup.flag.highlight = interpret_boolean(bool);
    }
#line 101
    if (! lookup.flag.verbose) {
#line 101
      return (0);
    }
#line 101
    when = (unsigned char const   *)"now";
  }
#line 101
  if (lookup.flag.highlight) {
#line 101
    tmp = "on";
  } else {
#line 101
    tmp = "off";
  }
  {
#line 101
  outputf("%s %s %s.\n", "highlighting", when, tmp);
  }
#line 101
  return (0);
}
}
#line 101 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_highlight_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 101
  when = (unsigned char const   *)"is";
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (bool) {
    {
#line 101
    (lookup.slot)->default_flag.highlight = interpret_boolean(bool);
    }
#line 101
    if (! lookup.flag.verbose) {
#line 101
      return (0);
    }
#line 101
    when = (unsigned char const   *)"now";
  }
#line 101
  if ((lookup.slot)->default_flag.highlight) {
#line 101
    tmp = "on";
  } else {
#line 101
    tmp = "off";
  }
  {
#line 101
  tmp___0 = slot_num(lookup.slot);
#line 101
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "highlighting", when, tmp);
  }
#line 101
  return (0);
}
}
#line 102 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_default_autokana_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;

  {
#line 102
  when = (unsigned char const   *)"is";
#line 102
  if (bool) {
    {
#line 102
    lookup.flag.autokana = interpret_boolean(bool);
    }
#line 102
    if (! lookup.flag.verbose) {
#line 102
      return (0);
    }
#line 102
    when = (unsigned char const   *)"now";
  }
#line 102
  if (lookup.flag.autokana) {
#line 102
    tmp = "on";
  } else {
#line 102
    tmp = "off";
  }
  {
#line 102
  outputf("%s %s %s.\n", "auto-kana", when, tmp);
  }
#line 102
  return (0);
}
}
#line 102 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_local_autokana_flag(unsigned char const   *bool ) 
{ 
  unsigned char const   *when ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 102
  when = (unsigned char const   *)"is";
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (bool) {
    {
#line 102
    (lookup.slot)->default_flag.autokana = interpret_boolean(bool);
    }
#line 102
    if (! lookup.flag.verbose) {
#line 102
      return (0);
    }
#line 102
    when = (unsigned char const   *)"now";
  }
#line 102
  if ((lookup.slot)->default_flag.autokana) {
#line 102
    tmp = "on";
  } else {
#line 102
    tmp = "off";
  }
  {
#line 102
  tmp___0 = slot_num(lookup.slot);
#line 102
  outputf("slot #%d\'s %s %s %s.\n", tmp___0, "auto-kana", when, tmp);
  }
#line 102
  return (0);
}
}
#line 110 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int set_verbose_flag(unsigned char const   *bool ) 
{ 
  char const   *tmp ;

  {
#line 112
  if (bool) {
    {
#line 114
    lookup.flag.verbose = interpret_boolean(bool);
    }
#line 115
    return (0);
  }
#line 117
  if (lookup.flag.verbose) {
#line 117
    tmp = "on";
  } else {
#line 117
    tmp = "off";
  }
  {
#line 117
  outputf("verbosity is %s.\n", tmp);
  }
#line 118
  return (0);
}
}
#line 124 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_load(char const   *filename ) 
{ 
  int slotnum ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 126
  tmp = expand_filename_tilde(filename);
#line 126
  tmp___0 = load_file(tmp, 524288U);
#line 126
  slotnum = tmp___0;
  }
#line 130
  if (slotnum >= 0) {
#line 132
    lookup.slot = lookup.slot_info[slotnum];
#line 133
    return (0);
  }
#line 135
  return (1);
}
}
#line 138 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int cmd_log(int closelog , int append , unsigned char const   *File ) 
{ 
  int fd ;
  int tmp ;
  char const   *file ;
  int flags___0 ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int normal_fd ;
  int tmp___2 ;
  unsigned char *tmp___3 ;

  {
  {
#line 143
  tmp = set_extra_output_file(-2);
#line 143
  fd = tmp;
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 149
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 149
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 151
  if (closelog) {
#line 154
    if (! (fd >= 0)) {
#line 156
      if (lookup.flag.verbose) {
        {
#line 157
        outputf("%sno log file to close\n", lookup.where);
        }
      }
    } else {
      {
#line 159
      flush_output();
#line 160
      close(fd);
#line 161
      set_extra_output_file(-3);
      }
#line 162
      if (lookup.flag.verbose) {
        {
#line 163
        outputf("%swrote log file\241\310%s\241\311\n", lookup.where, current_log_file);
        }
      }
      {
#line 165
      free((void *)current_log_file);
#line 166
      current_log_file = (unsigned char const   *)0;
      }
    }
#line 168
    return (0);
  }
#line 171
  if (File) {
#line 174
    file = (char const   *)File;
#line 175
    if (append) {
#line 175
      tmp___0 = 1024;
    } else {
#line 175
      tmp___0 = 512;
    }
#line 175
    flags___0 = 65 | tmp___0;
#line 177
    if (fd >= 0) {
      {
#line 179
      outputf("%salready logging to\241\310%s\241\311\n", lookup.where, current_log_file);
      }
#line 181
      return (1);
    }
    {
#line 183
    file = expand_filename_tilde(file);
#line 184
    fd = open(file, flags___0, 420);
    }
#line 184
    if (fd < 0) {
      {
#line 186
      outputf("%sbad open of\241\310%s\241\311: %n", lookup.where, file);
      }
#line 187
      return (1);
    }
#line 189
    if (lookup.flag.verbose) {
#line 190
      if (append) {
#line 190
        tmp___1 = "append";
      } else {
#line 190
        tmp___1 = "logg";
      }
      {
#line 190
      outputf("%soutput now %sing to\241\310%s\241\311\n", lookup.where, tmp___1,
              file);
      }
    }
    {
#line 192
    flush_output();
    }
#line 200
    if (append) {
      {
#line 202
      tmp___2 = set_normal_output_file(fd);
#line 202
      normal_fd = tmp___2;
#line 203
      output("\n---------------------------------------------------\n");
#line 204
      flush_output();
#line 205
      set_normal_output_file(normal_fd);
      }
    }
    {
#line 207
    set_extra_output_file(fd);
#line 208
    tmp___3 = strsave((unsigned char const   *)file);
#line 208
    current_log_file = (unsigned char const   *)tmp___3;
    }
#line 209
    return (0);
  }
#line 213
  if (! (fd >= 0)) {
    {
#line 214
    output("output not currently logged.\n");
    }
  } else {
    {
#line 216
    outputf("output currently logged to\241\310%s\241\311\n", current_log_file);
    }
  }
#line 218
  return (0);
}
}
#line 224 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_prompt(int local , unsigned char const   *new_prompt ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if ((unsigned long )new_prompt == (unsigned long )((unsigned char const   *)0)) {
#line 230
    if (! local) {
      {
#line 231
      outputf("prompt format is\241\310%s\241\311\n", lookup.prompt_format);
      }
    } else
#line 232
    if ((lookup.slot)->prompt_format) {
      {
#line 233
      outputf("local prompt format for selected slot is\241\310%s\241\311\n", (lookup.slot)->prompt_format);
      }
    } else {
      {
#line 236
      outputf("no local prompt for selected slot.\n");
      }
    }
  } else
#line 240
  if (local) {
#line 242
    if ((lookup.slot)->prompt_format) {
      {
#line 243
      free((void *)(lookup.slot)->prompt_format);
      }
    }
    {
#line 244
    tmp = strsave(new_prompt);
#line 244
    (lookup.slot)->prompt_format = (unsigned char const   *)tmp;
    }
  } else {
#line 248
    if (lookup.prompt_format) {
      {
#line 249
      free((void *)lookup.prompt_format);
      }
    }
    {
#line 250
    tmp___0 = strsave(new_prompt);
#line 250
    lookup.prompt_format = (unsigned char const   *)tmp___0;
    }
  }
#line 253
  return (0);
}
}
#line 261
static int cmd_clear(void) ;
#line 261 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static enum __anonenum_is_xterm_44 is_xterm  =    (enum __anonenum_is_xterm_44 )0;
#line 259 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_clear(void) 
{ 
  unsigned char const   *term ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 263
  if ((unsigned int )is_xterm == 0U) {
    {
#line 266
    tmp = getenv("TERM");
#line 266
    term = (unsigned char const   *)tmp;
    }
#line 267
    if (term) {
      {
#line 267
      tmp___0 = strncmp((char const   *)((void *)term), (char const   *)((void *)((unsigned char const   *)"kterm")),
                        (size_t )5);
      }
#line 267
      if (tmp___0 == 0) {
#line 271
        is_xterm = (enum __anonenum_is_xterm_44 )1;
      } else {
        {
#line 267
        tmp___1 = strncmp((char const   *)((void *)term), (char const   *)((void *)((unsigned char const   *)"xterm")),
                          (size_t )5);
        }
#line 267
        if (tmp___1 == 0) {
#line 271
          is_xterm = (enum __anonenum_is_xterm_44 )1;
        } else {
          {
#line 267
          tmp___2 = strncmp((char const   *)((void *)term), (char const   *)((void *)((unsigned char const   *)"vt100")),
                            (size_t )5);
          }
#line 267
          if (tmp___2 == 0) {
#line 271
            is_xterm = (enum __anonenum_is_xterm_44 )1;
          } else {
#line 273
            is_xterm = (enum __anonenum_is_xterm_44 )2;
          }
        }
      }
    } else {
#line 273
      is_xterm = (enum __anonenum_is_xterm_44 )2;
    }
  }
#line 277
  if ((unsigned int )is_xterm == 1U) {
    {
#line 279
    output_pager_transparent(1);
#line 280
    output("\033[H\033[2J");
#line 281
    output_pager_transparent(0);
#line 282
    output_pager_reset_more();
#line 283
    flush_output();
    }
  } else {
    {
#line 285
    flush_output();
#line 286
    system("clear");
    }
  }
#line 289
  return (0);
}
}
#line 293 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_toggle_filter(unsigned char const   *bool ) 
{ 
  char const   *when ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 295
  when = "";
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if (! ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0))) {
#line 299
    if ((unsigned long )(lookup.slot)->onefile_or_combo.onefile._filter_.pattern == (unsigned long )((unsigned char const   *)0)) {
      {
#line 300
      outputf("%sno filter installed.\n", lookup.where);
      }
#line 301
      if (bool) {
#line 301
        tmp = 1;
      } else {
#line 301
        tmp = 0;
      }
#line 301
      return (tmp);
    }
  }
#line 304
  if (bool) {
    {
#line 306
    (lookup.slot)->default_flag.filter = interpret_boolean(bool);
    }
#line 307
    if (! lookup.flag.verbose) {
#line 308
      return (0);
    }
#line 309
    when = "now ";
  }
  {
#line 312
  output("filter ");
  }
#line 314
  if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
    {
#line 316
    tmp___0 = slot_num(lookup.slot);
    }
#line 316
    if ((lookup.slot)->default_flag.filter) {
#line 316
      tmp___1 = "on";
    } else {
#line 316
      tmp___1 = "off";
    }
    {
#line 316
    outputf("flag is %s for combo slot #%d.\n", tmp___1, tmp___0);
    }
  } else {
#line 320
    if ((lookup.slot)->onefile_or_combo.onefile._filter_.name) {
      {
#line 321
      outputf("(\241\310%s\241\311) ", (lookup.slot)->onefile_or_combo.onefile._filter_.name);
      }
    }
#line 322
    if ((lookup.slot)->onefile_or_combo.onefile._filter_.negative) {
#line 322
      tmp___2 = "!";
    } else {
#line 322
      tmp___2 = "";
    }
#line 322
    if ((lookup.slot)->default_flag.filter) {
#line 322
      tmp___3 = "en";
    } else {
#line 322
      tmp___3 = "dis";
    }
    {
#line 322
    outputf("(%s%sabled): %s\241\310%s\241\311\n", when, tmp___3, tmp___2, (lookup.slot)->onefile_or_combo.onefile._filter_.pattern);
    }
#line 326
    if ((lookup.slot)->default_flag.filter) {
#line 327
      if (lookup.list.size == 0U) {
        {
#line 328
        outputf("%snote: no filtered lines will be saved (change with \"set filter list\").\n",
                lookup.where);
        }
      } else {
        {
#line 331
        outputf("(first %d filtered lines will be saved each time).\n", lookup.list.size);
        }
      }
    }
  }
#line 335
  return (0);
}
}
#line 341 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_filter(unsigned char const   *filter_regex , unsigned char const   *filter_name ,
                      int is_negative , int is_case_insensitive ) 
{ 
  unsigned int flags___0 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 344
  flags___0 = 64U;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
    {
#line 350
    outputf("%sslot is a combo; no filter allowed.\n", lookup.where);
    }
#line 351
    return (1);
  }
#line 354
  if (is_case_insensitive) {
#line 355
    flags___0 |= 12U;
  }
#line 357
  if ((lookup.slot)->onefile_or_combo.onefile._filter_.name) {
    {
#line 359
    free((void *)(lookup.slot)->onefile_or_combo.onefile._filter_.name);
#line 360
    (lookup.slot)->onefile_or_combo.onefile._filter_.name = (unsigned char const   *)0;
    }
  }
#line 362
  if ((lookup.slot)->onefile_or_combo.onefile._filter_.pattern) {
    {
#line 364
    free((void *)(lookup.slot)->onefile_or_combo.onefile._filter_.pattern);
#line 365
    (lookup.slot)->onefile_or_combo.onefile._filter_.pattern = (unsigned char const   *)0;
#line 366
    regfree(& (lookup.slot)->onefile_or_combo.onefile._filter_.regex);
    }
  }
  {
#line 369
  tmp___0 = regcomp(& (lookup.slot)->onefile_or_combo.onefile._filter_.regex, filter_regex,
                    flags___0);
  }
#line 369
  if (tmp___0 != 0) {
    {
#line 372
    tmp = regcomp_error_report();
#line 372
    outputf("%s%s.\n", lookup.where, (unsigned char *)tmp);
    }
#line 374
    return (1);
  }
#line 376
  if (filter_name) {
    {
#line 376
    tmp___1 = strsave(filter_name);
#line 376
    (lookup.slot)->onefile_or_combo.onefile._filter_.name = (unsigned char const   *)tmp___1;
    }
  } else {
#line 376
    (lookup.slot)->onefile_or_combo.onefile._filter_.name = (unsigned char const   *)0;
  }
  {
#line 377
  tmp___2 = strsave(filter_regex);
#line 377
  (lookup.slot)->onefile_or_combo.onefile._filter_.pattern = (unsigned char const   *)tmp___2;
#line 378
  (lookup.slot)->onefile_or_combo.onefile._filter_.negative = (unsigned int )is_negative;
#line 379
  (lookup.slot)->default_flag.filter = 1U;
  }
#line 380
  return (0);
}
}
#line 384 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int cmd_list_size(unsigned char const   *spec ) 
{ 
  char const   *when ;
  int length ;
  int tmp ;
  void *mem ;

  {
#line 386
  when = "is";
#line 388
  if (spec) {
    {
#line 390
    tmp = atoi((char const   *)spec);
#line 390
    length = tmp;
    }
#line 391
    if ((unsigned int )length != lookup.list.size) {
#line 393
      mem = (void *)0;
#line 394
      if (length) {
        {
#line 396
        mem = xmalloc((unsigned int )((unsigned long )length * sizeof(*(lookup.list.array + 0))));
        }
#line 397
        if ((unsigned long )mem == (unsigned long )((void *)0)) {
          {
#line 399
          outputf("%scan\'t allocate memory for filter list of length %d.\n", lookup.where,
                  length);
          }
#line 401
          return (1);
        }
      }
#line 405
      if (lookup.list.array) {
        {
#line 406
        free((void *)lookup.list.array);
        }
      }
#line 407
      lookup.list.array = (struct __anonstruct_array_34 *)mem;
#line 408
      lookup.list.size = (unsigned int )length;
#line 409
      lookup.list.used = 0U;
    }
#line 412
    if (! lookup.flag.verbose) {
#line 413
      return (0);
    }
#line 414
    when = "now";
  }
  {
#line 416
  outputf("maximum filter list size %s: %d.\n", when, lookup.list.size);
  }
#line 417
  if (lookup.list.used) {
    {
#line 418
    outputf("current lines held: %d.\n", lookup.list.used);
    }
  }
#line 419
  return (0);
}
}
#line 422 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_limit(unsigned char const   *spec ) 
{ 
  char const   *when ;
  int value ;
  int tmp ;

  {
#line 424
  when = "is";
#line 426
  if (spec) {
    {
#line 428
    tmp = atoi((char const   *)spec);
#line 428
    value = tmp;
    }
#line 430
    if (value < 0) {
      {
#line 432
      outputf("%slimit of %d makes no sense.\n", lookup.where, value);
      }
#line 434
      return (1);
    }
#line 437
    lookup.max_lines_to_print = (long )value;
#line 438
    if (! lookup.flag.verbose) {
#line 439
      return (0);
    }
#line 440
    when = "now";
  }
#line 442
  if (lookup.max_lines_to_print == 0L) {
    {
#line 443
    outputf("line-per-search limit %s disabled.\n", when);
    }
  } else {
    {
#line 445
    outputf("line-per-search limit %s %ld.\n", when, lookup.max_lines_to_print);
    }
  }
#line 448
  return (0);
}
}
#line 451 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_do_search(unsigned char const   *search ) 
{ 
  unsigned char *copy ;
  int clear_slot_when_done ;

  {
#line 454
  clear_slot_when_done = 0;
#line 456
  if ((unsigned long )lookup.slot == (unsigned long )((struct slot_info *)0)) {
#line 458
    if (lookup.default_slot) {
#line 460
      lookup.slot = lookup.default_slot;
#line 461
      clear_slot_when_done = 0;
    } else {
      {
#line 463
      outputf("%sno files loaded.\n", lookup.where);
      }
#line 464
      return (1);
    }
  }
  {
#line 468
  copy = strsave(search);
#line 469
  process_input_line(copy, 1);
#line 470
  free((void *)copy);
  }
#line 471
  if (clear_slot_when_done) {
#line 472
    lookup.slot = (struct slot_info *)0;
  }
#line 473
  return (0);
}
}
#line 476 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_if(unsigned char const   *expr , unsigned char const   *command___0 ) 
{ 
  int value ;
  int tmp ;
  unsigned char const   *tmp___0 ;
  int length ;
  size_t tmp___1 ;
  unsigned char *writable ;
  void *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 478
  tmp = eval(expr);
#line 478
  value = tmp;
  }
#line 479
  if (eval_error_val != 0) {
    {
#line 481
    outputf("ERROR: %s\nAT-----", expr);
    }
    {
#line 482
    while (1) {
      while_continue: /* CIL Label */ ;
#line 482
      tmp___0 = expr;
#line 482
      expr ++;
#line 482
      if (! ((unsigned long )tmp___0 < (unsigned long )eval_error_loc)) {
#line 482
        goto while_break;
      }
      {
#line 483
      (*_output_char_function)((unsigned char )'-');
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 484
    outputf("^\n%sexpression: [%s]\n", lookup.where, eval_errstr[eval_error_val]);
    }
#line 486
    return (1);
  }
#line 488
  if (value) {
    {
#line 489
    tmp___1 = strlen((char const   *)((void *)command___0));
#line 489
    length = (int )(tmp___1 + 1UL);
#line 490
    tmp___2 = xmalloc((unsigned int )length);
#line 490
    writable = (unsigned char *)tmp___2;
#line 491
    bcopy((void const   *)((char *)command___0), (void *)((char *)writable), (size_t )length);
#line 492
    tmp___3 = strlen((char const   *)((void *)((unsigned char const   *)writable)));
#line 492
    parse_command((unsigned char const   *)writable, (unsigned int )tmp___3, 17U,
                  0U);
#line 493
    free((void *)writable);
    }
  }
#line 495
  return (0);
}
}
#line 498 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_msg(unsigned char const   *msg ) 
{ 
  int log_fd ;
  int tmp ;

  {
#line 503
  if ((int const   )*(msg + 0) == 9) {
#line 503
    if (lookup.spinner.interval) {
      {
#line 512
      tmp = set_extra_output_file(-2);
#line 512
      log_fd = tmp;
      }
#line 513
      if ((unsigned long )current_log_file == (unsigned long )((unsigned char const   *)0)) {
        {
#line 514
        (*_output_char_function)((unsigned char )' ');
        }
      } else {
        {
#line 516
        flush_output();
#line 517
        set_extra_output_file(-3);
#line 518
        (*_output_char_function)((unsigned char )' ');
#line 519
        flush_output();
#line 520
        set_extra_output_file(log_fd);
        }
      }
    }
  }
  {
#line 525
  output((char const   *)msg);
#line 526
  (*_output_char_function)((unsigned char )'\n');
  }
#line 527
  return (0);
}
}
#line 530 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_exit(void) 
{ 


  {
#line 532
  exit_program_now = 1;
#line 533
  return (0);
}
}
#line 536 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_tag(unsigned char const   *boolean , unsigned char const   *tag ) 
{ 
  char const   *when ;
  unsigned char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
#line 538
  when = "is";
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  if (tag) {
#line 544
    if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
      {
#line 545
      outputf("%sMay not set a tag string for a combo slot.\n", lookup.where);
      }
#line 547
      return (1);
    } else {
#line 549
      if ((lookup.slot)->onefile_or_combo.onefile._tag_) {
        {
#line 550
        free((void *)(lookup.slot)->onefile_or_combo.onefile._tag_);
        }
      }
      {
#line 551
      tmp = strsave(tag);
#line 551
      (lookup.slot)->onefile_or_combo.onefile._tag_ = (unsigned char const   *)tmp;
#line 552
      when = "now";
      }
    }
  }
#line 556
  if (boolean) {
#line 558
    if (! ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0))) {
#line 558
      if ((unsigned long )(lookup.slot)->onefile_or_combo.onefile._tag_ == (unsigned long )((unsigned char const   *)0)) {
        {
#line 560
        outputf("%sno tag string to toggle.\n", lookup.where);
        }
#line 561
        return (0);
      }
    }
    {
#line 563
    (lookup.slot)->default_flag.tag = interpret_boolean(boolean);
#line 564
    when = "now";
    }
  }
#line 567
  if (tag) {
#line 567
    goto _L;
  } else
#line 567
  if (boolean) {
    _L: /* CIL Label */ 
#line 567
    if (! lookup.flag.verbose) {
#line 568
      return (0);
    }
  }
#line 571
  if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 572
    if ((lookup.slot)->default_flag.tag) {
#line 572
      tmp___0 = "on";
    } else {
#line 572
      tmp___0 = "off";
    }
    {
#line 572
    tmp___1 = slot_num(lookup.slot);
#line 572
    outputf("tag mode for combo #%d %s %s.\n", tmp___1, when, tmp___0);
    }
  } else
#line 574
  if ((unsigned long )(lookup.slot)->onefile_or_combo.onefile._tag_ == (unsigned long )((unsigned char const   *)0)) {
    {
#line 575
    tmp___2 = slot_num(lookup.slot);
#line 575
    outputf("there is no tag for file #%d.\n", tmp___2);
    }
  } else {
#line 577
    if ((lookup.slot)->default_flag.tag) {
#line 577
      tmp___3 = "enabled";
    } else {
#line 577
      tmp___3 = "disabled";
    }
    {
#line 577
    tmp___4 = slot_num(lookup.slot);
#line 577
    outputf("tag for file #%d %s\241\310%s\241\311(%s).\n", tmp___4, when, (lookup.slot)->onefile_or_combo.onefile._tag_,
            tmp___3);
    }
  }
#line 580
  return (0);
}
}
#line 584 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_spinner(unsigned char const   *spec ) 
{ 
  char const   *when ;
  int tmp ;

  {
#line 587
  when = "is";
#line 588
  if (spec) {
    {
#line 590
    tmp = atoi((char const   *)spec);
#line 590
    lookup.spinner.interval = (unsigned short )tmp;
    }
#line 591
    if (! lookup.flag.verbose) {
#line 592
      return (0);
    }
#line 593
    when = "now";
  }
#line 595
  if ((int )lookup.spinner.interval == 0) {
    {
#line 596
    outputf("spinner %s disabled.\n", when);
    }
  } else {
    {
#line 598
    outputf("spinner %s set to: %d.\n", when, (int )lookup.spinner.interval);
    }
  }
#line 602
  return (0);
}
}
#line 606 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int cmd_show(void) 
{ 
  int i ;
  unsigned int old_regexec_flags ;
  int tmp ;
  unsigned int tmp___0 ;
  struct slot_info  const  *slot ;
  unsigned char const   *line___1 ;
  unsigned int len ;

  {
#line 609
  if (lookup.list.size == 0U) {
    {
#line 610
    output("the save list is disabled (its size is zero).\n");
    }
  } else
#line 611
  if (lookup.list.used == 0U) {
    {
#line 612
    output("there are currently no saved lines.\n");
    }
  } else {
#line 615
    if (lookup.flag.regex_debug) {
#line 615
      tmp = 2;
    } else {
#line 615
      tmp = 0;
    }
    {
#line 615
    tmp___0 = regexec_setflags((unsigned int )tmp);
#line 615
    old_regexec_flags = tmp___0;
#line 617
    i = 0;
    }
    {
#line 617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 617
      if (! ((unsigned int )i < lookup.list.used)) {
#line 617
        goto while_break;
      }
      {
#line 619
      slot = (lookup.list.array + i)->slot;
#line 622
      line___1 = VirtPos2Str((slot->file)->v, (lookup.list.array + i)->line, & len);
#line 623
      output_line(slot, line___1, len);
#line 617
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 626
    regexec_setflags(old_regexec_flags);
    }
  }
#line 628
  return (0);
}
}
#line 631 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static void add_combo_slot(struct slot_info *parent , unsigned int parent_slot_num ,
                           unsigned int new_slot_num ) 
{ 
  unsigned int i ;
  unsigned char tmp ;

  {
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 639
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 640
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 640
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 642
  i = 0U;
  {
#line 642
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 642
    if (! (i < (unsigned int )parent->onefile_or_combo._combo_.entries)) {
#line 642
      goto while_break___2;
    }
#line 643
    if ((unsigned int )parent->onefile_or_combo._combo_.entry[i] == new_slot_num) {
#line 645
      if (lookup.flag.verbose) {
        {
#line 646
        outputf(" (%d)", new_slot_num);
        }
      }
#line 647
      return;
    }
#line 642
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 655
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 655
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 657
  tmp = parent->onefile_or_combo._combo_.entries;
#line 657
  parent->onefile_or_combo._combo_.entries = (unsigned char )((int )parent->onefile_or_combo._combo_.entries + 1);
#line 657
  parent->onefile_or_combo._combo_.entry[tmp] = (unsigned char )new_slot_num;
#line 658
  if (lookup.flag.verbose) {
    {
#line 659
    outputf(" %d", new_slot_num);
    }
  }
#line 660
  return;
}
}
#line 662 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_combine(unsigned char const   *name , int num , unsigned char const   *new_nums ) 
{ 
  int parent_slot_num ;
  struct slot_info *slot ;
  unsigned int new_num_list[10] ;
  unsigned int new_num_next ;
  unsigned int new_num_seen[10] ;
  char const   *what ;
  int i ;
  int new_num ;
  unsigned short const   **tmp ;
  unsigned char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned int tmp___2 ;
  unsigned short const   **tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned char *tmp___6 ;
  int new_num___0 ;
  unsigned int j ;
  int new_new_num ;

  {
#line 667
  new_num_next = 0U;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  i = 0;
  {
#line 674
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 674
    if (! (i < 10)) {
#line 674
      goto while_break___0;
    }
#line 675
    new_num_seen[i] = 0U;
#line 674
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 678
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 680
    new_num = 0;
    {
#line 682
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 682
      if (*new_nums) {
        {
#line 682
        tmp = __ctype_b_loc();
        }
#line 682
        if ((int const   )*(*tmp + (int )*new_nums) & 2048) {
#line 682
          goto while_break___2;
        }
      } else {
#line 682
        goto while_break___2;
      }
#line 683
      new_nums ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 684
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 684
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 685
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 685
      tmp___1 = __ctype_b_loc();
      }
#line 685
      if (! ((int const   )*(*tmp___1 + (int )*new_nums) & 2048)) {
#line 685
        goto while_break___4;
      }
#line 686
      tmp___0 = new_nums;
#line 686
      new_nums ++;
#line 686
      new_num = new_num * 10 + (int )((int const   )*tmp___0 - 48);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 688
    if ((unsigned int )new_num >= lookup.slots) {
      {
#line 690
      outputf("%sno such slot #%d\n", lookup.where, new_num);
      }
#line 691
      return (1);
    }
#line 693
    if (! new_num_seen[new_num]) {
      {
#line 695
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 695
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 696
      new_num_seen[new_num] = 0U;
#line 697
      tmp___2 = new_num_next;
#line 697
      new_num_next ++;
#line 697
      new_num_list[tmp___2] = (unsigned int )new_num;
    }
    {
#line 700
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 700
      if (*new_nums) {
        {
#line 700
        tmp___3 = __ctype_b_loc();
        }
#line 700
        if ((int const   )*(*tmp___3 + (int )*new_nums) & 2048) {
#line 700
          goto while_break___6;
        }
      } else {
#line 700
        goto while_break___6;
      }
#line 701
      new_nums ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 678
    if (! *new_nums) {
#line 678
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 704
  if (num >= 0) {
#line 707
    what = "adding to";
#line 708
    if ((unsigned int )num > lookup.slots) {
      {
#line 710
      outputf("%sno previous combo in slot %d!\n", lookup.where, num);
      }
#line 711
      return (1);
    } else
#line 708
    if (! ((unsigned long )(lookup.slot_info[num])->file == (unsigned long )((struct fileinfo *)0))) {
      {
#line 710
      outputf("%sno previous combo in slot %d!\n", lookup.where, num);
      }
#line 711
      return (1);
    }
    {
#line 713
    slot = lookup.slot_info[num];
#line 714
    lookup.slot = slot;
#line 715
    parent_slot_num = slot_num(slot);
    }
  } else {
#line 720
    what = "creating";
#line 721
    if (lookup.slots >= 10U) {
      {
#line 723
      outputf("%scan\'t combine (too many loaded slots, max is %d)\n", lookup.where,
              10);
      }
#line 725
      return (1);
    }
    {
#line 727
    tmp___4 = xmalloc((unsigned int )sizeof(struct slot_info ));
#line 727
    slot = (struct slot_info *)tmp___4;
#line 728
    bzero((void *)slot, sizeof(struct slot_info ));
    }
#line 739
    if (! name) {
#line 740
      name = (unsigned char const   *)"combo";
    }
#line 741
    parent_slot_num = (int )lookup.slots;
#line 742
    tmp___5 = lookup.slots;
#line 742
    (lookup.slots) ++;
#line 742
    lookup.slot_info[tmp___5] = slot;
#line 743
    slot->default_flag.word = 1U;
#line 744
    slot->default_flag.fuzz = 1U;
#line 745
    slot->default_flag.fold = 1U;
#line 746
    slot->default_flag.highlight = 1U;
#line 747
    slot->default_flag.filter = 1U;
#line 748
    slot->default_flag.modify = 1U;
#line 749
    slot->default_flag.autokana = lookup.flag.autokana;
#line 750
    slot->default_flag.tag = 1U;
#line 751
    slot->default_flag.display = 1U;
#line 752
    lookup.slot = slot;
  }
  {
#line 755
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 755
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 757
  if (lookup.flag.verbose) {
    {
#line 758
    outputf("%s combo slot #%d", what, parent_slot_num);
    }
  }
#line 760
  if (name) {
#line 762
    if (slot->onefile_or_combo._combo_.name) {
      {
#line 763
      free((void *)slot->onefile_or_combo._combo_.name);
      }
    }
    {
#line 764
    tmp___6 = strsave(name);
#line 764
    slot->onefile_or_combo._combo_.name = (unsigned char const   *)tmp___6;
#line 765
    outputf("(%s)", name);
    }
  }
  {
#line 767
  (*_output_char_function)((unsigned char )':');
#line 771
  i = 0;
  }
  {
#line 771
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 771
    if (! ((unsigned int )i < new_num_next)) {
#line 771
      goto while_break___8;
    }
#line 773
    new_num___0 = (int )new_num_list[i];
#line 774
    if (! ((unsigned long )(lookup.slot_info[new_num___0])->file == (unsigned long )((struct fileinfo *)0))) {
      {
#line 775
      add_combo_slot(slot, (unsigned int )parent_slot_num, (unsigned int )new_num___0);
      }
    } else {
#line 780
      j = 0U;
      {
#line 780
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 780
        if (! (j < (unsigned int )(lookup.slot_info[new_num___0])->onefile_or_combo._combo_.entries)) {
#line 780
          goto while_break___9;
        }
#line 782
        new_new_num = (int )(lookup.slot_info[new_num___0])->onefile_or_combo._combo_.entry[j];
        {
#line 783
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 783
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 784
        if (! new_num_seen[new_new_num]) {
          {
#line 785
          add_combo_slot(slot, (unsigned int )parent_slot_num, (unsigned int )new_new_num);
          }
        }
#line 780
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 771
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 789
  if (lookup.flag.verbose) {
    {
#line 790
    (*_output_char_function)((unsigned char )'\n');
    }
  }
#line 791
  return (0);
}
}
#line 794 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_toggle_modify(unsigned char const   *bool ) 
{ 
  char const   *when ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 796
  when = "";
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  if (! ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0))) {
#line 800
    if ((unsigned long )(lookup.slot)->onefile_or_combo.onefile._modify_.pattern == (unsigned long )((unsigned char const   *)0)) {
      {
#line 802
      outputf("%sno modification installed.\n", lookup.where);
      }
#line 803
      if (bool) {
#line 803
        tmp = 1;
      } else {
#line 803
        tmp = 0;
      }
#line 803
      return (tmp);
    }
  }
#line 806
  if (bool) {
    {
#line 808
    (lookup.slot)->default_flag.modify = interpret_boolean(bool);
    }
#line 809
    if (! lookup.flag.verbose) {
#line 810
      return (0);
    }
#line 811
    when = "now ";
  }
  {
#line 813
  output("modify ");
  }
#line 814
  if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
    {
#line 816
    tmp___0 = slot_num(lookup.slot);
    }
#line 816
    if ((lookup.slot)->default_flag.modify) {
#line 816
      tmp___1 = "on";
    } else {
#line 816
      tmp___1 = "off";
    }
    {
#line 816
    outputf("flag is %s for combo slot #%d.\n", tmp___1, tmp___0);
    }
  } else {
#line 820
    if ((lookup.slot)->default_flag.modify) {
#line 820
      tmp___2 = "en";
    } else {
#line 820
      tmp___2 = "dis";
    }
    {
#line 820
    outputf("(%s%sabled):\241\310%s\241\311with ", when, tmp___2, (lookup.slot)->onefile_or_combo.onefile._modify_.pattern);
    }
#line 823
    if ((int const   )*((lookup.slot)->onefile_or_combo.onefile._modify_.replacement + 0) == 0) {
      {
#line 824
      output("nothing\n");
      }
    } else {
      {
#line 826
      outputf("\241\310%s\241\311\n", (lookup.slot)->onefile_or_combo.onefile._modify_.replacement);
      }
    }
  }
#line 828
  return (0);
}
}
#line 831 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_modify(unsigned char const   *pattern , unsigned char const   *replacement ,
                      int is_case_insensitive , int is_global ) 
{ 
  int i ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;

  {
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  if ((unsigned long )(lookup.slot)->file == (unsigned long )((struct fileinfo *)0)) {
    {
#line 840
    outputf("%sslot is a combo; no modify allowed.\n", lookup.where);
    }
#line 841
    return (1);
  }
  {
#line 844
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 844
    if (! pattern) {
      {
#line 844
      die("\nassert(pattern) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
          844);
      }
    }
#line 844
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 845
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 845
    if (! replacement) {
      {
#line 845
      die("\nassert(replacement) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
          845);
      }
    }
#line 845
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 847
  if (lookup.slots == 0U) {
    {
#line 849
    outputf("%sno loaded file for modification.\n", lookup.where);
    }
#line 850
    return (1);
  }
#line 853
  if ((lookup.slot)->onefile_or_combo.onefile._modify_.pattern) {
    {
#line 855
    free((void *)(lookup.slot)->onefile_or_combo.onefile._modify_.pattern);
#line 856
    regfree(& (lookup.slot)->onefile_or_combo.onefile._modify_.regex);
#line 857
    free((void *)(lookup.slot)->onefile_or_combo.onefile._modify_.replacement);
    }
  }
#line 859
  tmp = (unsigned char const   *)0;
#line 859
  (lookup.slot)->onefile_or_combo.onefile._modify_.replacement = tmp;
#line 859
  (lookup.slot)->onefile_or_combo.onefile._modify_.pattern = tmp;
#line 861
  if (is_case_insensitive) {
#line 861
    tmp___0 = 12;
  } else {
#line 861
    tmp___0 = 0;
  }
  {
#line 861
  i = regcomp(& (lookup.slot)->onefile_or_combo.onefile._modify_.regex, pattern, (unsigned int )(64 | tmp___0));
  }
#line 865
  if (i != 0) {
    {
#line 867
    tmp___1 = regcomp_error_report();
#line 867
    outputf("%s%s.\n", lookup.where, (unsigned char *)tmp___1);
    }
#line 869
    return (1);
  }
  {
#line 871
  tmp___2 = strsave(pattern);
#line 871
  (lookup.slot)->onefile_or_combo.onefile._modify_.pattern = (unsigned char const   *)tmp___2;
#line 872
  tmp___3 = strsave(replacement);
#line 872
  (lookup.slot)->onefile_or_combo.onefile._modify_.replacement = (unsigned char const   *)tmp___3;
#line 873
  (lookup.slot)->onefile_or_combo.onefile._modify_.global = (unsigned int )is_global;
#line 874
  (lookup.slot)->default_flag.modify = 1U;
  }
#line 875
  return (0);
}
}
#line 881 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_select(unsigned char const   *number , char const   *name , int use_default ) 
{ 
  char const   *when ;
  struct slot_info *selected ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int value ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;

  {
#line 883
  when = "is";
#line 884
  selected = (struct slot_info *)0;
#line 886
  if (name) {
    {
#line 889
    name = expand_filename_tilde(name);
#line 890
    i = 0;
    }
    {
#line 890
    while (1) {
      while_continue: /* CIL Label */ ;
#line 890
      if ((unsigned int )i < lookup.slots) {
#line 890
        if (! (! selected)) {
#line 890
          goto while_break;
        }
      } else {
#line 890
        goto while_break;
      }
#line 891
      if ((lookup.slot_info[i])->file) {
        {
#line 891
        tmp = strcmp((char const   *)((void *)((unsigned char const   *)((lookup.slot_info[i])->file)->short_filename)),
                     (char const   *)((void *)((unsigned char const   *)name)));
        }
#line 891
        if (tmp) {
          {
#line 891
          tmp___0 = strcmp((char const   *)((void *)((unsigned char const   *)(((lookup.slot_info[i])->file)->v)->filename)),
                           (char const   *)((void *)((unsigned char const   *)name)));
          }
#line 891
          if (tmp___0) {
#line 891
            goto _L;
          } else {
#line 897
            selected = lookup.slot_info[i];
#line 898
            goto while_break;
          }
        } else {
#line 897
          selected = lookup.slot_info[i];
#line 898
          goto while_break;
        }
      } else
      _L: /* CIL Label */ 
#line 891
      if ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0)) {
        {
#line 891
        tmp___1 = strcmp((char const   *)((void *)(lookup.slot_info[i])->onefile_or_combo._combo_.name),
                         (char const   *)((void *)((unsigned char const   *)name)));
        }
#line 891
        if (! tmp___1) {
#line 897
          selected = lookup.slot_info[i];
#line 898
          goto while_break;
        }
      }
#line 890
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 901
    if ((unsigned long )selected == (unsigned long )((struct slot_info *)0)) {
      {
#line 903
      outputf("%sno\241\310%s\241\311slot loaded.\n", lookup.where, name);
      }
#line 904
      return (1);
    }
  } else
#line 906
  if (number) {
    {
#line 907
    tmp___2 = atoi((char const   *)number);
#line 907
    value = (unsigned int )tmp___2;
    }
#line 908
    if (value >= lookup.slots) {
      {
#line 910
      outputf("%sno such slot #%d loaded.\n", lookup.where, value);
      }
#line 912
      return (1);
    }
#line 914
    selected = lookup.slot_info[value];
  } else
#line 915
  if (use_default) {
#line 916
    if ((unsigned long )lookup.default_slot == (unsigned long )((struct slot_info *)0)) {
      {
#line 918
      outputf("%sno default file to use\n", lookup.where);
      }
#line 919
      return (1);
    }
#line 921
    selected = lookup.default_slot;
  }
#line 924
  if (selected) {
#line 926
    lookup.slot = selected;
#line 927
    if ((unsigned long )lookup.default_slot == (unsigned long )selected) {
#line 928
      when = "already";
    } else {
#line 931
      lookup.default_slot = selected;
#line 932
      when = "now";
    }
#line 934
    if (! lookup.flag.verbose) {
#line 935
      return (0);
    }
  }
#line 938
  if ((unsigned long )lookup.slot == (unsigned long )((struct slot_info *)0)) {
#line 940
    if (lookup.default_slot) {
#line 940
      tmp___3 = "selected";
    } else {
#line 940
      tmp___3 = "loaded";
    }
    {
#line 940
    outputf("%sno file %s.\n", lookup.where, tmp___3);
    }
#line 942
    return (1);
  }
#line 945
  if ((unsigned long )(lookup.default_slot)->file == (unsigned long )((struct fileinfo *)0)) {
#line 945
    tmp___4 = (char const   *)(lookup.default_slot)->onefile_or_combo._combo_.name;
  } else {
#line 945
    tmp___4 = (((lookup.default_slot)->file)->v)->filename;
  }
  {
#line 945
  tmp___5 = slot_num(lookup.default_slot);
#line 945
  outputf("default slot %s #%d (%s).\n", when, tmp___5, tmp___4);
  }
#line 950
  return (0);
}
}
#line 958
static int cmd_list_files(int help ) ;
#line 958 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static char LINE[105]  = 
#line 958
  {      (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\250',      (char )'\254',      (char )'\250',      (char )'\254', 
        (char )'\000'};
#line 953 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_list_files(int help ) 
{ 
  int i ;
  int extra ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int tmp___2 ;
  char buf1[12] ;
  char buf2[10] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int j ;
  char const   *tmp___8 ;

  {
  {
#line 962
  tmp___2 = output_pager_columns(0U);
  }
#line 962
  if (tmp___2) {
    {
#line 962
    tmp___0 = output_pager_columns(0U);
#line 962
    tmp___1 = (unsigned long )tmp___0 - sizeof("\250\254\250\263\250\254\250\254\250\254\250\254\250\254\250\270\250\254\250\254\250\263\250\254\250\254\250\254\250\263");
    }
  } else {
#line 962
    tmp___1 = 0UL;
  }
#line 962
  extra = (int )tmp___1;
#line 965
  if (lookup.slots == 0U) {
    {
#line 967
    outputf("%sno files loaded\n", lookup.where);
    }
#line 968
    return (1);
  }
#line 971
  if (extra <= 0) {
#line 972
    extra = 0;
  } else {
#line 975
    if ((unsigned long )extra < sizeof(LINE) - 1UL) {
#line 975
      extra = extra;
    } else {
#line 975
      extra = (int )(sizeof(LINE) - 1UL);
    }
#line 976
    extra &= -2;
  }
#line 979
  if (! help) {
    {
#line 980
    outputf("\250\256\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254\250\254%.*s\n",
            extra, LINE);
#line 981
    outputf("\250\255%s\'s \"Lookup\", %s (%s).\n\250\262", author_name, version_string,
            version_date);
    }
  } else {
    {
#line 984
    output("      +-------------F: has filter; #: but disabled (!F!, filter)\n      |+------------M: has modify; %: but disabled (!M!, modify)\n      ||+-----------w: word-preference mode (!w!, word)\n      |||+----------c: case folding (!c!, fold)\n      ||||+---------f: fuzz mode (!f!, fuzz)\n      |||||+--------h: highlight mode (!h!, highlight)\n      ||||||+-------t: has tag; @:but disabled (!T!, tag)\n      |||||||+------d: will display (!d!, display)\n      ||||||||  +---a: automatic kana conversion (=, autokana)\n      ||||||||  |+--P: slot has local prompt (local prompt)\n      ||||||||  ||+-I: file loaded with precomputed-index\n      FMwcfhtd  aPI\n\250\256");
    }
  }
  {
#line 1001
  outputf("\250\254\250\263\250\254\250\254\250\254\250\254\250\254\250\270\250\254\250\254\250\263\250\254\250\254\250\254\250\263%.*s\n",
          extra, LINE);
#line 1002
  i = 0;
  }
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! ((unsigned int )i < lookup.slots)) {
#line 1002
      goto while_break;
    }
#line 1006
    if ((lookup.slot_info[i])->default_flag.filter) {
#line 1006
      buf1[0] = (char )'F';
    } else {
#line 1006
      if (! ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0))) {
#line 1006
        if ((lookup.slot_info[i])->onefile_or_combo.onefile._filter_.pattern) {
#line 1006
          tmp___3 = '#';
        } else {
#line 1006
          tmp___3 = ' ';
        }
      } else {
#line 1006
        tmp___3 = ' ';
      }
#line 1006
      buf1[0] = (char )tmp___3;
    }
#line 1010
    if ((lookup.slot_info[i])->default_flag.modify) {
#line 1010
      buf1[1] = (char )'M';
    } else {
#line 1010
      if (! ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0))) {
#line 1010
        if ((lookup.slot_info[i])->onefile_or_combo.onefile._modify_.pattern) {
#line 1010
          tmp___4 = '%';
        } else {
#line 1010
          tmp___4 = ' ';
        }
      } else {
#line 1010
        tmp___4 = ' ';
      }
#line 1010
      buf1[1] = (char )tmp___4;
    }
#line 1014
    if ((lookup.slot_info[i])->default_flag.word) {
#line 1014
      buf1[2] = (char )'w';
    } else {
#line 1014
      buf1[2] = (char )' ';
    }
#line 1015
    if ((lookup.slot_info[i])->default_flag.fold) {
#line 1015
      buf1[3] = (char )'c';
    } else {
#line 1015
      buf1[3] = (char )' ';
    }
#line 1016
    if ((lookup.slot_info[i])->default_flag.fuzz) {
#line 1016
      buf1[4] = (char )'f';
    } else {
#line 1016
      buf1[4] = (char )' ';
    }
#line 1017
    if ((lookup.slot_info[i])->default_flag.glob) {
#line 1017
      buf1[5] = (char )'W';
    } else {
#line 1017
      buf1[5] = (char )' ';
    }
#line 1018
    if ((lookup.slot_info[i])->default_flag.highlight) {
#line 1018
      buf1[6] = (char )'h';
    } else {
#line 1018
      buf1[6] = (char )' ';
    }
#line 1019
    if ((lookup.slot_info[i])->default_flag.tag) {
#line 1019
      buf1[7] = (char )'t';
    } else {
#line 1019
      if (! ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0))) {
#line 1019
        if ((lookup.slot_info[i])->onefile_or_combo.onefile._tag_) {
#line 1019
          tmp___5 = '@';
        } else {
#line 1019
          tmp___5 = ' ';
        }
      } else {
#line 1019
        tmp___5 = ' ';
      }
#line 1019
      buf1[7] = (char )tmp___5;
    }
#line 1022
    if ((lookup.slot_info[i])->default_flag.display) {
#line 1022
      buf1[8] = (char )'d';
    } else {
#line 1022
      buf1[8] = (char )' ';
    }
#line 1023
    buf1[9] = (char )' ';
#line 1024
    buf1[10] = (char )'\000';
#line 1026
    if ((lookup.slot_info[i])->default_flag.autokana) {
#line 1026
      buf2[0] = (char )'a';
    } else {
#line 1026
      buf2[0] = (char )' ';
    }
#line 1027
    if ((lookup.slot_info[i])->prompt_format) {
#line 1027
      buf2[1] = (char )'P';
    } else {
#line 1027
      buf2[1] = (char )' ';
    }
#line 1028
    if (! ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0))) {
#line 1028
      if (((lookup.slot_info[i])->file)->indexfile) {
#line 1028
        if ((unsigned long )(((lookup.slot_info[i])->file)->index)->FileP != (unsigned long )((void *)0)) {
#line 1028
          tmp___6 = 'i';
        } else {
#line 1028
          tmp___6 = 'I';
        }
#line 1028
        buf2[2] = (char )tmp___6;
      } else {
#line 1028
        buf2[2] = (char )' ';
      }
    } else {
#line 1028
      buf2[2] = (char )' ';
    }
#line 1032
    buf2[3] = (char )' ';
#line 1034
    if ((int )buf2[3] == 58) {
#line 1035
      buf2[3] = (char )' ';
    }
#line 1037
    buf2[4] = (char )'\000';
#line 1039
    if ((unsigned long )lookup.slot_info[i] == (unsigned long )lookup.default_slot) {
#line 1039
      tmp___7 = '*';
    } else {
#line 1039
      tmp___7 = ' ';
    }
    {
#line 1039
    outputf("\250\255%c%d\250\255%s\250\242%s\250\255", tmp___7, i, buf1, buf2);
    }
#line 1042
    if (! ((unsigned long )(lookup.slot_info[i])->file == (unsigned long )((struct fileinfo *)0))) {
      {
#line 1043
      outputf("%5dk\250\255%s\n", ((((lookup.slot_info[i])->file)->v)->length + 1023L) / 1024L,
              (((lookup.slot_info[i])->file)->v)->filename);
      }
    } else {
      {
#line 1049
      outputf(" combo\250\255%s (", (lookup.slot_info[i])->onefile_or_combo._combo_.name);
#line 1050
      j = 0U;
      }
      {
#line 1050
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1050
        if (! (j < (unsigned int )(lookup.slot_info[i])->onefile_or_combo._combo_.entries)) {
#line 1050
          goto while_break___0;
        }
#line 1051
        if (j) {
#line 1051
          tmp___8 = ", ";
        } else {
#line 1051
          tmp___8 = "";
        }
        {
#line 1051
        outputf("%s#%d", tmp___8, (int )(lookup.slot_info[i])->onefile_or_combo._combo_.entry[j]);
#line 1050
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1053
      output(")\n");
      }
    }
#line 1002
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1056
  outputf("\250\261\250\254\250\265\250\254\250\254\250\254\250\254\250\254\250\272\250\254\250\254\250\265\250\254\250\254\250\254\250\265%.*s\n\n",
          extra, LINE);
  }
#line 1057
  return (0);
}
}
#line 1060 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_source(char const   *filename ) 
{ 
  int tmp ;

  {
  {
#line 1062
  filename = expand_filename_tilde(filename);
#line 1063
  tmp = read_commands_from_file(filename, 17U, 0U);
  }
  {
#line 1065
  if (tmp == 0) {
#line 1065
    goto case_0;
  }
#line 1067
  if (tmp == 1) {
#line 1067
    goto case_1;
  }
#line 1063
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1066
  return (0);
  case_1: /* CIL Label */ 
  {
#line 1068
  outputf("%sfile\241\310%s\241\311not found.\n", lookup.where, filename);
  }
#line 1069
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1071
  return (1);
}
}
#line 1074 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_stats(void) 
{ 
  char const   *tmp ;

  {
#line 1076
  if (lookup.count.checked == 1UL) {
#line 1076
    tmp = "";
  } else {
#line 1076
    tmp = "s";
  }
  {
#line 1076
  outputf("%ld line%s checked, %ld matched", lookup.count.checked, tmp, lookup.count.matched);
  }
#line 1080
  if (lookup.count.matched) {
#line 1082
    if (lookup.count.filtered) {
      {
#line 1083
      outputf(", %ld filtered", lookup.count.filtered);
      }
    }
#line 1084
    if (lookup.count.nonword) {
      {
#line 1085
      outputf(", %ld non-word", lookup.count.nonword);
      }
    }
    {
#line 1086
    outputf(", %ld printed", lookup.count.printed);
    }
  }
  {
#line 1088
  output(".\n");
  }
#line 1089
  return (0);
}
}
#line 1097 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int describe(unsigned char c1 , unsigned char c2 ) 
{ 
  unsigned char k1 ;
  unsigned char k2 ;
  unsigned char j1 ;
  unsigned char j2 ;
  unsigned char C1 ;
  unsigned char C2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1100
  C1 = (unsigned char )((int )c1 | 128);
#line 1101
  C2 = (unsigned char )((int )c2 | 128);
#line 1102
  c1 = (unsigned char )((int )c1 & 127);
#line 1103
  c2 = (unsigned char )((int )c2 & 127);
#line 1105
  outputf("\241\310%c%c\241\311as  EUC  is 0x%02x%02x (%3d %3d; \\%03o \\%03o)\n",
          (int )C1, (int )C2, (int )C1, (int )C2, (int )C1, (int )C2, (int )C1, (int )C2);
#line 1108
  outputf("      as  JIS  is 0x%02x%02x (%3d %3d; \\%03o \\%03o \"%c%c\")\n", (int )c1,
          (int )c2, (int )c1, (int )c2, (int )c1, (int )c2, (int )c1, (int )c2);
#line 1111
  k1 = (unsigned char )((int )c1 - 32);
#line 1112
  k2 = (unsigned char )((int )c2 - 32);
#line 1113
  outputf("      as KUTEN is   %02d%02d ( 0x%02x%02x; \\%03o \\%03o)\n", (int )k1,
          (int )k2, (int )k1, (int )k2, (int )k1, (int )k2);
  }
#line 1116
  if ((int )c1 < 95) {
#line 1116
    tmp = 112;
  } else {
#line 1116
    tmp = 176;
  }
#line 1116
  j1 = (unsigned char )((((int )c1 + 1) >> 1U) + tmp);
#line 1117
  if ((int )c1 & 1) {
#line 1117
    if ((int )c2 > 95) {
#line 1117
      tmp___0 = 32;
    } else {
#line 1117
      tmp___0 = 31;
    }
#line 1117
    tmp___1 = tmp___0;
  } else {
#line 1117
    tmp___1 = 126;
  }
  {
#line 1117
  j2 = (unsigned char )((int )c2 + tmp___1);
#line 1119
  outputf("      as S-JIS is 0x%02x%02x (%3d %3d; \\%03o \\%03o)\n", (int )j1, (int )j2,
          (int )j1, (int )j2, (int )j1, (int )j2);
  }
#line 1121
  return (0);
}
}
#line 1124 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_describe_ascii(unsigned int base , unsigned char const   *text ) 
{ 
  unsigned int num ;
  unsigned char c ;
  unsigned char const   *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1127
  num = 0U;
  {
#line 1130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1130
    tmp = text;
#line 1130
    text ++;
#line 1130
    c = (unsigned char )*tmp;
#line 1130
    if (! c) {
#line 1130
      goto while_break;
    }
#line 1132
    if ((int )c >= 97) {
#line 1132
      if ((int )c <= 102) {
#line 1133
        num = ((num * base + (unsigned int )c) - 97U) + 10U;
      } else {
#line 1132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1134
    if ((int )c >= 65) {
#line 1134
      if ((int )c <= 70) {
#line 1135
        num = ((num * base + (unsigned int )c) - 65U) + 10U;
      } else {
#line 1137
        num = (num * base + (unsigned int )c) - 48U;
      }
    } else {
#line 1137
      num = (num * base + (unsigned int )c) - 48U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1140
  outputf("ASCII \\%03o %d 0x%02x", num, num, num);
  }
#line 1141
  if ((num & 4294967168U) == 0U) {
    {
#line 1141
    tmp___0 = __ctype_b_loc();
    }
#line 1141
    if ((int const   )*(*tmp___0 + (int )num) & 16384) {
      {
#line 1142
      outputf(": \"%c\"", num);
      }
    }
  }
  {
#line 1143
  outputf("\n");
  }
#line 1144
  return (0);
}
}
#line 1151 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_describe_raw(unsigned char const   *text ) 
{ 
  unsigned int c1 ;
  unsigned int c2 ;
  int len ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  unsigned char byte2[16] ;
  unsigned char byte2___0[7] ;
  unsigned char byte2___1[6] ;
  unsigned char byte2___2[4] ;

  {
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (! *text) {
#line 1154
      goto while_break;
    }
    {
#line 1169
    if (((int const   )euc_info[*text] & 3) == 2) {
#line 1169
      goto case_2;
    }
#line 1175
    if (((int const   )euc_info[*text] & 3) == 1) {
#line 1175
      goto case_1;
    }
#line 1160
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1162
    len = (int )((int const   )euc_info[*text] & 3);
#line 1163
    outputf("%d-byte character: ", len);
    }
    {
#line 1164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1164
      tmp___0 = len;
#line 1164
      len --;
#line 1164
      if (! tmp___0) {
#line 1164
        goto while_break___0;
      }
      {
#line 1165
      tmp = text;
#line 1165
      text ++;
#line 1165
      outputf("0x%02x", (int const   )*tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1166
    goto while_continue;
    case_2: /* CIL Label */ 
#line 1170
    c1 = (unsigned int )*(text + 0);
#line 1171
    c2 = (unsigned int )*(text + 1);
#line 1172
    text += 2;
#line 1173
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1176
    c1 = (unsigned int )*(text + 0);
#line 1177
    text ++;
#line 1182
    if (c1 >= 65U) {
#line 1182
      if (c1 <= 90U) {
#line 1183
        c2 = 193U + (c1 - 65U);
#line 1184
        c1 = 163U;
      } else {
#line 1182
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1185
    if (c1 >= 97U) {
#line 1185
      if (c1 <= 122U) {
#line 1186
        c2 = 225U + (c1 - 97U);
#line 1187
        c1 = 163U;
      } else {
#line 1185
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1188
    if (c1 >= 48U) {
#line 1188
      if (c1 <= 57U) {
#line 1189
        c2 = 176U + (c1 - 48U);
#line 1190
        c1 = 163U;
      } else {
#line 1188
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1191
    if (c1 >= 32U) {
#line 1191
      if (c1 <= 47U) {
#line 1192
        byte2[0] = (unsigned char)161;
#line 1192
        byte2[1] = (unsigned char)170;
#line 1192
        byte2[2] = (unsigned char)201;
#line 1192
        byte2[3] = (unsigned char)244;
#line 1192
        byte2[4] = (unsigned char)240;
#line 1192
        byte2[5] = (unsigned char)243;
#line 1192
        byte2[6] = (unsigned char)245;
#line 1192
        byte2[7] = (unsigned char)199;
#line 1192
        byte2[8] = (unsigned char)202;
#line 1192
        byte2[9] = (unsigned char)203;
#line 1192
        byte2[10] = (unsigned char)246;
#line 1192
        byte2[11] = (unsigned char)220;
#line 1192
        byte2[12] = (unsigned char)164;
#line 1192
        byte2[13] = (unsigned char)221;
#line 1192
        byte2[14] = (unsigned char)163;
#line 1192
        byte2[15] = (unsigned char)191;
#line 1211
        c2 = (unsigned int )byte2[c1 - 32U];
#line 1212
        c1 = 161U;
      } else {
#line 1191
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1213
    if (c1 >= 58U) {
#line 1213
      if (c1 <= 64U) {
#line 1214
        byte2___0[0] = (unsigned char)167;
#line 1214
        byte2___0[1] = (unsigned char)168;
#line 1214
        byte2___0[2] = (unsigned char)227;
#line 1214
        byte2___0[3] = (unsigned char)225;
#line 1214
        byte2___0[4] = (unsigned char)228;
#line 1214
        byte2___0[5] = (unsigned char)169;
#line 1214
        byte2___0[6] = (unsigned char)247;
#line 1223
        c2 = (unsigned int )byte2___0[c1 - 58U];
#line 1224
        c1 = 161U;
      } else {
#line 1213
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1225
    if (c1 >= 91U) {
#line 1225
      if (c1 <= 96U) {
#line 1226
        byte2___1[0] = (unsigned char)206;
#line 1226
        byte2___1[1] = (unsigned char)239;
#line 1226
        byte2___1[2] = (unsigned char)207;
#line 1226
        byte2___1[3] = (unsigned char)176;
#line 1226
        byte2___1[4] = (unsigned char)178;
#line 1226
        byte2___1[5] = (unsigned char)198;
#line 1234
        c2 = (unsigned int )byte2___1[c1 - 91U];
#line 1235
        c1 = 161U;
      } else {
#line 1225
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1236
    if (c1 >= 123U) {
#line 1236
      if (c1 <= 126U) {
#line 1237
        byte2___2[0] = (unsigned char)208;
#line 1237
        byte2___2[1] = (unsigned char)195;
#line 1237
        byte2___2[2] = (unsigned char)209;
#line 1237
        byte2___2[3] = (unsigned char)193;
#line 1243
        c2 = (unsigned int )byte2___2[c1 - 123U];
#line 1244
        c1 = 161U;
      } else {
        {
#line 1246
        outputf("ascii character %d\n", c1);
        }
#line 1247
        goto while_continue;
      }
    } else {
      {
#line 1246
      outputf("ascii character %d\n", c1);
      }
#line 1247
      goto while_continue;
    }
#line 1250
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1252
    describe((unsigned char )c1, (unsigned char )c2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1254
  return (0);
}
}
#line 1260 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_describe_kuten(unsigned char const   *code ) 
{ 
  unsigned int c1 ;
  unsigned int c2 ;
  int tmp ;

  {
#line 1264
  c1 = (unsigned int )(((int const   )*(code + 0) - 48) * 10 + ((int const   )*(code + 1) - 48));
#line 1265
  c2 = (unsigned int )(((int const   )*(code + 2) - 48) * 10 + ((int const   )*(code + 3) - 48));
#line 1266
  if (c1 > 85U) {
    {
#line 1267
    warn("invalid KUTEN value %02d%02d\n", c1, c2);
    }
#line 1268
    return (1);
  } else
#line 1266
  if (c2 > 94U) {
    {
#line 1267
    warn("invalid KUTEN value %02d%02d\n", c1, c2);
    }
#line 1268
    return (1);
  } else
#line 1266
  if (c1 >= 9U) {
#line 1266
    if (c1 <= 15U) {
      {
#line 1267
      warn("invalid KUTEN value %02d%02d\n", c1, c2);
      }
#line 1268
      return (1);
    }
  }
  {
#line 1270
  c1 = (c1 | 128U) + 32U;
#line 1271
  c2 = (c2 | 128U) + 32U;
#line 1272
  tmp = describe((unsigned char )c1, (unsigned char )c2);
  }
#line 1272
  return (tmp);
}
}
#line 1286 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_describe_encoding(unsigned char const   *type , unsigned char const   *code ) 
{ 
  unsigned int c1 ;
  unsigned int c2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1293
  if ((int const   )*(code + 0) >= 97) {
#line 1293
    tmp___0 = (10 + (int )*(code + 0)) - 97;
  } else {
#line 1293
    if ((int const   )*(code + 0) >= 65) {
#line 1293
      tmp = (10 + (int )*(code + 0)) - 65;
    } else {
#line 1293
      tmp = (int )((int const   )*(code + 0) - 48);
    }
#line 1293
    tmp___0 = tmp;
  }
#line 1293
  if ((int const   )*(code + 1) >= 97) {
#line 1293
    tmp___2 = (10 + (int )*(code + 1)) - 97;
  } else {
#line 1293
    if ((int const   )*(code + 1) >= 65) {
#line 1293
      tmp___1 = (10 + (int )*(code + 1)) - 65;
    } else {
#line 1293
      tmp___1 = (int )((int const   )*(code + 1) - 48);
    }
#line 1293
    tmp___2 = tmp___1;
  }
#line 1293
  c1 = (unsigned int )((tmp___0 << 4) | tmp___2);
#line 1294
  if ((int const   )*(code + 2) >= 97) {
#line 1294
    tmp___4 = (10 + (int )*(code + 2)) - 97;
  } else {
#line 1294
    if ((int const   )*(code + 2) >= 65) {
#line 1294
      tmp___3 = (10 + (int )*(code + 2)) - 65;
    } else {
#line 1294
      tmp___3 = (int )((int const   )*(code + 2) - 48);
    }
#line 1294
    tmp___4 = tmp___3;
  }
#line 1294
  if ((int const   )*(code + 3) >= 97) {
#line 1294
    tmp___6 = (10 + (int )*(code + 3)) - 97;
  } else {
#line 1294
    if ((int const   )*(code + 3) >= 65) {
#line 1294
      tmp___5 = (10 + (int )*(code + 3)) - 65;
    } else {
#line 1294
      tmp___5 = (int )((int const   )*(code + 3) - 48);
    }
#line 1294
    tmp___6 = tmp___5;
  }
#line 1294
  c2 = (unsigned int )((tmp___4 << 4) | tmp___6);
#line 1296
  if (! type) {
#line 1297
    type = (unsigned char const   *)"JIS";
  }
  {
#line 1306
  if ((int const   )*(type + 0) == 74) {
#line 1306
    goto case_74;
  }
#line 1306
  if ((int const   )*(type + 0) == 106) {
#line 1306
    goto case_74;
  }
#line 1306
  if ((int const   )*(type + 0) == 0) {
#line 1306
    goto case_74;
  }
#line 1317
  if ((int const   )*(type + 0) == 69) {
#line 1317
    goto case_69;
  }
#line 1317
  if ((int const   )*(type + 0) == 101) {
#line 1317
    goto case_69;
  }
#line 1326
  if ((int const   )*(type + 0) == 83) {
#line 1326
    goto case_83;
  }
#line 1326
  if ((int const   )*(type + 0) == 115) {
#line 1326
    goto case_83;
  }
#line 1301
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1302
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1302);
    }
#line 1302
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  goto switch_break;
  case_74: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1307
  if (code) {
#line 1307
    if (c1 < 31U) {
#line 1307
      goto _L;
    } else
#line 1307
    if (c1 > 126U) {
#line 1307
      goto _L;
    } else
#line 1307
    if (c2 < 32U) {
#line 1307
      goto _L;
    } else
#line 1307
    if (c2 > 126U) {
      _L: /* CIL Label */ 
#line 1308
      type = (unsigned char const   *)"JIS";
      invalid: 
      {
#line 1310
      warn("invalid %s value 0x%02x%02x\n", type, c1, c2);
      }
#line 1311
      return (1);
    }
  }
#line 1314
  goto switch_break;
  case_69: /* CIL Label */ 
  case_101: /* CIL Label */ 
#line 1318
  if (code) {
#line 1318
    if (c1 < 161U) {
#line 1319
      type = (unsigned char const   *)"EUC";
#line 1320
      goto invalid;
    } else
#line 1318
    if (c1 > 254U) {
#line 1319
      type = (unsigned char const   *)"EUC";
#line 1320
      goto invalid;
    } else
#line 1318
    if (c2 < 161U) {
#line 1319
      type = (unsigned char const   *)"EUC";
#line 1320
      goto invalid;
    } else
#line 1318
    if (c2 > 254U) {
#line 1319
      type = (unsigned char const   *)"EUC";
#line 1320
      goto invalid;
    }
  }
#line 1323
  goto switch_break;
  case_83: /* CIL Label */ 
  case_115: /* CIL Label */ 
#line 1327
  if (code) {
#line 1327
    if (c1 < 129U) {
#line 1329
      type = (unsigned char const   *)"SJIS";
#line 1330
      goto invalid;
    } else
#line 1327
    if (c1 > 239U) {
#line 1329
      type = (unsigned char const   *)"SJIS";
#line 1330
      goto invalid;
    } else
#line 1327
    if (c1 > 159U) {
#line 1327
      if (c1 < 224U) {
#line 1329
        type = (unsigned char const   *)"SJIS";
#line 1330
        goto invalid;
      } else {
#line 1327
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1327
    if (c2 < 64U) {
#line 1329
      type = (unsigned char const   *)"SJIS";
#line 1330
      goto invalid;
    } else
#line 1327
    if (c2 > 252U) {
#line 1329
      type = (unsigned char const   *)"SJIS";
#line 1330
      goto invalid;
    } else
#line 1327
    if (c2 > 126U) {
#line 1327
      if (c2 < 128U) {
#line 1329
        type = (unsigned char const   *)"SJIS";
#line 1330
        goto invalid;
      }
    }
  }
#line 1332
  if (c1 < 160U) {
#line 1332
    tmp___7 = 112;
  } else {
#line 1332
    tmp___7 = 176;
  }
#line 1332
  c1 = ((c1 - (unsigned int )tmp___7) << 1) - (unsigned int )(c2 < 159U);
#line 1333
  if (c2 < 159U) {
#line 1333
    if (c2 > 127U) {
#line 1333
      tmp___8 = 32;
    } else {
#line 1333
      tmp___8 = 31;
    }
#line 1333
    tmp___9 = tmp___8;
  } else {
#line 1333
    tmp___9 = 126;
  }
#line 1333
  c2 -= (unsigned int )tmp___9;
#line 1334
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1336
  describe((unsigned char )c1, (unsigned char )c2);
  }
#line 1338
  return (0);
}
}
#line 1341 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_describe_jis_string(unsigned char const   *str___0 ) 
{ 
  unsigned int c1 ;
  unsigned int c2 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! *str___0) {
#line 1346
      goto while_break;
    }
#line 1348
    tmp = str___0;
#line 1348
    str___0 ++;
#line 1348
    c1 = (unsigned int )*tmp;
#line 1349
    tmp___0 = str___0;
#line 1349
    str___0 ++;
#line 1349
    c2 = (unsigned int )*tmp___0;
#line 1351
    if (c1 < 31U) {
      {
#line 1352
      warn("invalid JIS value 0x%02x%02x\n", c1, c2);
      }
#line 1353
      return (1);
    } else
#line 1351
    if (c1 > 126U) {
      {
#line 1352
      warn("invalid JIS value 0x%02x%02x\n", c1, c2);
      }
#line 1353
      return (1);
    } else
#line 1351
    if (c2 < 32U) {
      {
#line 1352
      warn("invalid JIS value 0x%02x%02x\n", c1, c2);
      }
#line 1353
      return (1);
    } else
#line 1351
    if (c2 > 126U) {
      {
#line 1352
      warn("invalid JIS value 0x%02x%02x\n", c1, c2);
      }
#line 1353
      return (1);
    }
    {
#line 1355
    describe((unsigned char )c1, (unsigned char )c2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1358
  return (0);
}
}
#line 1362 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static void show_output_style_spec(void) 
{ 
  unsigned int output_style___0 ;
  unsigned long tmp ;

  {
  {
#line 1364
  tmp = select_output_style(0UL);
#line 1364
  output_style___0 = (unsigned int )tmp;
  }
  {
#line 1368
  if ((output_style___0 & 7U) == 2U) {
#line 1368
    goto case_2;
  }
#line 1369
  if ((output_style___0 & 7U) == 1U) {
#line 1369
    goto case_1;
  }
#line 1371
  if ((output_style___0 & 7U) == 4U) {
#line 1371
    goto case_4;
  }
#line 1367
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1367
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1367
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1367);
    }
#line 1367
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1367
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1368
  output("sjis");
  }
#line 1368
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1369
  output("euc");
  }
#line 1369
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1375
  if ((output_style___0 & 36U) == 4U) {
#line 1375
    goto case_4___0;
  }
#line 1376
  if ((output_style___0 & 36U) == 20U) {
#line 1376
    goto case_20;
  }
#line 1377
  if ((output_style___0 & 36U) == 36U) {
#line 1377
    goto case_36;
  }
#line 1374
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1374
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1374
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1374);
    }
#line 1374
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1374
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 1375
  output("jis78");
  }
#line 1375
  goto switch_break___0;
  case_20: /* CIL Label */ 
  {
#line 1376
  output("jis83");
  }
#line 1376
  goto switch_break___0;
  case_36: /* CIL Label */ 
  {
#line 1377
  output("jis90");
  }
#line 1377
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1382
  if ((output_style___0 & 768U) == 256U) {
#line 1382
    goto case_256;
  }
#line 1383
  if ((output_style___0 & 768U) == 512U) {
#line 1383
    goto case_512;
  }
#line 1381
  goto switch_default___1;
  switch_default___1: /* CIL Label */ 
  {
#line 1381
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1381
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1381);
    }
#line 1381
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1381
  goto switch_break___1;
  case_256: /* CIL Label */ 
  {
#line 1382
  output("-roman");
  }
#line 1382
  goto switch_break___1;
  case_512: /* CIL Label */ 
  {
#line 1383
  output("-ascii");
  }
#line 1383
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1385
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1391
  if ((output_style___0 & 3145728U) == 1048576U) {
#line 1391
    goto case_1048576;
  }
#line 1392
  if ((output_style___0 & 3145728U) == 2097152U) {
#line 1392
    goto case_2097152;
  }
#line 1390
  goto switch_default___2;
  switch_default___2: /* CIL Label */ 
  {
#line 1390
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1390
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1390);
    }
#line 1390
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1390
  goto switch_break___2;
  case_1048576: /* CIL Label */ 
  {
#line 1391
  outputf("-212");
  }
#line 1391
  goto switch_break___2;
  case_2097152: /* CIL Label */ 
  {
#line 1392
  outputf("-no212");
  }
#line 1392
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 1398
  if ((output_style___0 & 458752U) == 65536U) {
#line 1398
    goto case_65536;
  }
#line 1399
  if ((output_style___0 & 458752U) == 131072U) {
#line 1399
    goto case_131072;
  }
#line 1400
  if ((output_style___0 & 458752U) == 262144U) {
#line 1400
    goto case_262144;
  }
#line 1397
  goto switch_default___3;
  switch_default___3: /* CIL Label */ 
  {
#line 1397
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1397
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1397);
    }
#line 1397
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1397
  goto switch_break___3;
  case_65536: /* CIL Label */ 
  {
#line 1398
  output("-hwk");
  }
#line 1398
  goto switch_break___3;
  case_131072: /* CIL Label */ 
  {
#line 1399
  output("-nohwk");
  }
#line 1399
  goto switch_break___3;
  case_262144: /* CIL Label */ 
  {
#line 1400
  output("-foldhwk");
  }
#line 1400
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
  {
#line 1405
  if ((output_style___0 & 61440U) == 8192U) {
#line 1405
    goto case_8192;
  }
#line 1406
  if ((output_style___0 & 61440U) == 4096U) {
#line 1406
    goto case_4096;
  }
#line 1407
  if ((output_style___0 & 61440U) == 16384U) {
#line 1407
    goto case_16384;
  }
#line 1408
  if ((output_style___0 & 61440U) == 32768U) {
#line 1408
    goto case_32768;
  }
#line 1404
  goto switch_default___4;
  switch_default___4: /* CIL Label */ 
  {
#line 1404
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 1404
    warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
         1404);
    }
#line 1404
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1404
  goto switch_break___4;
  case_8192: /* CIL Label */ 
  {
#line 1405
  output("-disp");
  }
#line 1405
  goto switch_break___4;
  case_4096: /* CIL Label */ 
  {
#line 1406
  output("-nodisp");
  }
#line 1406
  goto switch_break___4;
  case_16384: /* CIL Label */ 
  {
#line 1407
  output("-code");
  }
#line 1407
  goto switch_break___4;
  case_32768: /* CIL Label */ 
  {
#line 1408
  output("-mark");
  }
  switch_break___4: /* CIL Label */ ;
  }
#line 1410
  return;
}
}
#line 1413 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int cmd_output_encoding(unsigned char const   *main_style , unsigned char const   *jis_year ,
                        unsigned char const   *jis_english , unsigned char const   *other ) 
{ 
  char const   *when ;
  unsigned char c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned char const   *start ;
  unsigned int len ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___14 ;

  {
#line 1419
  when = "is";
#line 1421
  if (main_style) {
#line 1423
    if ((int const   )*(main_style + 0) == 101) {
      {
#line 1424
      select_output_style(1UL);
      }
    } else
#line 1423
    if ((int const   )*(main_style + 0) == 69) {
      {
#line 1424
      select_output_style(1UL);
      }
    } else
#line 1425
    if ((int const   )*(main_style + 0) == 115) {
      {
#line 1426
      select_output_style(2UL);
      }
    } else
#line 1425
    if ((int const   )*(main_style + 0) == 83) {
      {
#line 1426
      select_output_style(2UL);
      }
    } else
#line 1427
    if ((int const   )*(main_style + 0) == 106) {
#line 1427
      goto _L;
    } else
#line 1427
    if ((int const   )*(main_style + 0) == 106) {
      _L: /* CIL Label */ 
#line 1429
      if (! jis_year) {
        {
#line 1430
        select_output_style(4UL);
        }
      } else
#line 1431
      if ((int const   )*(jis_year + 0) == 55) {
        {
#line 1432
        select_output_style(4UL);
        }
      } else
#line 1433
      if ((int const   )*(jis_year + 0) == 56) {
        {
#line 1434
        select_output_style(20UL);
        }
      } else
#line 1435
      if ((int const   )*(jis_year + 0) == 57) {
        {
#line 1436
        select_output_style(36UL);
        }
      } else {
        {
#line 1438
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1438
          die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
              1438);
          }
#line 1438
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1440
      if (jis_english) {
#line 1442
        if ((int const   )*(jis_english + 0) == 97) {
          {
#line 1443
          select_output_style(512UL);
          }
        } else
#line 1442
        if ((int const   )*(jis_english + 0) == 65) {
          {
#line 1443
          select_output_style(512UL);
          }
        } else
#line 1444
        if ((int const   )*(jis_english + 0) == 114) {
          {
#line 1445
          select_output_style(256UL);
          }
        } else
#line 1444
        if ((int const   )*(jis_english + 0) == 82) {
          {
#line 1445
          select_output_style(256UL);
          }
        } else {
          {
#line 1447
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 1447
            die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
                1447);
            }
#line 1447
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    } else {
      {
#line 1451
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1451
        die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
            1451);
        }
#line 1451
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 1455
  if (other) {
    {
#line 1458
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1458
      c = (unsigned char )*other;
#line 1458
      if (c) {
        {
#line 1458
        tmp = __ctype_b_loc();
        }
#line 1458
        if ((int const   )*(*tmp + (int )c) & 8) {
#line 1458
          tmp___0 = 0;
        } else {
#line 1458
          tmp___0 = 1;
        }
      } else {
#line 1458
        tmp___0 = 0;
      }
#line 1458
      if (! tmp___0) {
#line 1458
        goto while_break___2;
      }
#line 1459
      other ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1460
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1462
      start = other;
      {
#line 1465
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1465
        c = (unsigned char )*other;
#line 1465
        if (c) {
          {
#line 1465
          tmp___1 = __ctype_b_loc();
          }
#line 1465
          if ((int const   )*(*tmp___1 + (int )c) & 8) {
#line 1465
            tmp___2 = 1;
          } else {
#line 1465
            tmp___2 = 0;
          }
        } else {
#line 1465
          tmp___2 = 0;
        }
#line 1465
        if (! tmp___2) {
#line 1465
          goto while_break___4;
        }
#line 1466
        other ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1467
      len = (unsigned int )(other - start);
#line 1468
      tmp___12 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"")),
                         (size_t )len);
      }
#line 1468
      if (tmp___12) {
        {
#line 1469
        tmp___11 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"212")),
                           (size_t )len);
        }
#line 1469
        if (tmp___11) {
          {
#line 1471
          tmp___10 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"no212")),
                             (size_t )len);
          }
#line 1471
          if (tmp___10) {
            {
#line 1473
            tmp___9 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"hwk")),
                              (size_t )len);
            }
#line 1473
            if (tmp___9) {
              {
#line 1475
              tmp___8 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"nohwk")),
                                (size_t )len);
              }
#line 1475
              if (tmp___8) {
                {
#line 1477
                tmp___7 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"foldhwk")),
                                  (size_t )len);
                }
#line 1477
                if (tmp___7) {
                  {
#line 1479
                  tmp___6 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"disp")),
                                    (size_t )len);
                  }
#line 1479
                  if (tmp___6) {
                    {
#line 1481
                    tmp___5 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"nodisp")),
                                      (size_t )len);
                    }
#line 1481
                    if (tmp___5) {
                      {
#line 1483
                      tmp___4 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"code")),
                                        (size_t )len);
                      }
#line 1483
                      if (tmp___4) {
                        {
#line 1485
                        tmp___3 = strncmp((char const   *)((void *)start), (char const   *)((void *)((unsigned char const   *)"mark")),
                                          (size_t )len);
                        }
#line 1485
                        if (tmp___3) {
                          {
#line 1488
                          while (1) {
                            while_continue___5: /* CIL Label */ ;
                            {
#line 1488
                            warn("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
                                 1488);
                            }
#line 1488
                            goto while_break___5;
                          }
                          while_break___5: /* CIL Label */ ;
                          }
                        } else {
                          {
#line 1486
                          select_output_style(32768UL);
                          }
                        }
                      } else {
                        {
#line 1484
                        select_output_style(16384UL);
                        }
                      }
                    } else {
                      {
#line 1482
                      select_output_style(4096UL);
                      }
                    }
                  } else {
                    {
#line 1480
                    select_output_style(8192UL);
                    }
                  }
                } else {
                  {
#line 1478
                  select_output_style(262144UL);
                  }
                }
              } else {
                {
#line 1476
                select_output_style(131072UL);
                }
              }
            } else {
              {
#line 1474
              select_output_style(65536UL);
              }
            }
          } else {
            {
#line 1472
            select_output_style(2097152UL);
            }
          }
        } else {
          {
#line 1470
          select_output_style(1048576UL);
          }
        }
      }
      {
#line 1490
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1490
        c = (unsigned char )*other;
#line 1490
        if (c) {
          {
#line 1490
          tmp___13 = __ctype_b_loc();
          }
#line 1490
          if ((int const   )*(*tmp___13 + (int )c) & 8) {
#line 1490
            tmp___14 = 0;
          } else {
#line 1490
            tmp___14 = 1;
          }
        } else {
#line 1490
          tmp___14 = 0;
        }
#line 1490
        if (! tmp___14) {
#line 1490
          goto while_break___6;
        }
#line 1491
        other ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1460
      if (! ((int )c != 0)) {
#line 1460
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1495
  if (main_style) {
#line 1495
    goto _L___0;
  } else
#line 1495
  if (other) {
    _L___0: /* CIL Label */ 
#line 1497
    if (! lookup.flag.verbose) {
#line 1498
      return (0);
    }
#line 1499
    when = "now";
  }
  {
#line 1501
  outputf("Output encoding %s ", when);
#line 1502
  show_output_style();
#line 1503
  output(".\nAn exact specifier string would be ``");
#line 1504
  show_output_style_spec();
#line 1505
  output("\'\'.\n");
  }
#line 1507
  return (0);
}
}
#line 1510 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_input_encoding(unsigned char const   *arg ) 
{ 
  char const   *when ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1515
  when = "is";
#line 1516
  if (arg) {
#line 1517
    if ((int const   )*(arg + 0) == 101) {
      {
#line 1518
      jreadline_highbit_input(1U);
      }
    } else
#line 1517
    if ((int const   )*(arg + 0) == 69) {
      {
#line 1518
      jreadline_highbit_input(1U);
      }
    } else {
      {
#line 1520
      jreadline_highbit_input(2U);
      }
    }
#line 1521
    if (! lookup.flag.verbose) {
#line 1522
      return (0);
    }
#line 1523
    when = "now";
  }
  {
#line 1525
  tmp___1 = jreadline_highbit_input(3U);
  }
#line 1525
  if (tmp___1 == 1U) {
#line 1525
    tmp___0 = "EUC";
  } else {
#line 1525
    tmp___0 = "SJIS";
  }
  {
#line 1525
  outputf("High-bit input encoding %s %s.\n", when, tmp___0);
  }
#line 1529
  return (0);
}
}
#line 1533 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_encoding(unsigned char const   *arg ) 
{ 


  {
#line 1538
  if (arg) {
#line 1540
    if ((int const   )*(arg + 0) == 101) {
      {
#line 1542
      cmd_input_encoding((unsigned char const   *)"euc");
#line 1543
      cmd_output_encoding((unsigned char const   *)"euc", (unsigned char const   *)0,
                          (unsigned char const   *)0, (unsigned char const   *)0);
      }
    } else
#line 1540
    if ((int const   )*(arg + 0) == 69) {
      {
#line 1542
      cmd_input_encoding((unsigned char const   *)"euc");
#line 1543
      cmd_output_encoding((unsigned char const   *)"euc", (unsigned char const   *)0,
                          (unsigned char const   *)0, (unsigned char const   *)0);
      }
    } else
#line 1544
    if ((int const   )*(arg + 0) == 115) {
      {
#line 1545
      cmd_input_encoding((unsigned char const   *)"sjis");
#line 1546
      cmd_output_encoding((unsigned char const   *)"sjis", (unsigned char const   *)0,
                          (unsigned char const   *)0, (unsigned char const   *)0);
      }
    } else
#line 1544
    if ((int const   )*(arg + 0) == 83) {
      {
#line 1545
      cmd_input_encoding((unsigned char const   *)"sjis");
#line 1546
      cmd_output_encoding((unsigned char const   *)"sjis", (unsigned char const   *)0,
                          (unsigned char const   *)0, (unsigned char const   *)0);
      }
    } else {
#line 1548
      if (lookup.flag.verbose) {
        {
#line 1549
        cmd_input_encoding((unsigned char const   *)0);
        }
      }
      {
#line 1550
      cmd_output_encoding((unsigned char const   *)"jis", (unsigned char const   *)0,
                          (unsigned char const   *)0, (unsigned char const   *)0);
      }
    }
  } else {
    {
#line 1553
    cmd_input_encoding((unsigned char const   *)0);
#line 1554
    cmd_output_encoding((unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)0,
                        (unsigned char const   *)0);
    }
  }
#line 1557
  return (0);
}
}
#line 1560 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_cmdchar(unsigned char const   *arg ) 
{ 
  char const   *when ;

  {
#line 1562
  when = "is";
#line 1563
  if (arg) {
#line 1565
    lookup.cmdstart_char = (unsigned char )*arg;
#line 1566
    if (! lookup.flag.verbose) {
#line 1567
      return (0);
    }
#line 1568
    when = "now";
  }
  {
#line 1570
  outputf("command start char %s\241\310%c\241\311.\n", when, (int )lookup.cmdstart_char);
  }
#line 1572
  return (0);
}
}
#line 1575 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int cmd_version(void) 
{ 


  {
  {
#line 1577
  outputf("%s: %s, %s (compiled %s)\n", (unsigned char *)lookup.prog, version_string,
          version_date, compile_date);
#line 1583
  outputf("Author: %s\nComments and questions to: %s\n", author_name, contact_addr);
  }
#line 1585
  return (0);
}
}
#line 1588 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_pager(unsigned char const   *boolean , unsigned char const   *width_str ,
                     unsigned char const   *height_str ) 
{ 
  char const   *when ;
  unsigned int tmp ;
  int height ;
  int tmp___0 ;
  int width ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 1593
  when = "is";
#line 1594
  if (boolean) {
    {
#line 1596
    tmp = interpret_boolean(boolean);
#line 1596
    output_pager_status((int )tmp);
    }
#line 1597
    if (! lookup.flag.verbose) {
#line 1598
      return (0);
    }
#line 1599
    when = "now";
  } else
#line 1600
  if (height_str) {
    {
#line 1601
    tmp___0 = atoi((char const   *)height_str);
#line 1601
    height = tmp___0;
#line 1602
    output_pager_lines((unsigned int )height);
    }
#line 1604
    if (width_str) {
      {
#line 1606
      tmp___1 = atoi((char const   *)width_str);
#line 1606
      width = tmp___1;
#line 1607
      set_jreadline_width(width);
#line 1608
      output_pager_columns((unsigned int )width);
      }
    }
#line 1610
    if (! lookup.flag.verbose) {
#line 1611
      return (0);
    }
#line 1612
    when = "now";
  }
  {
#line 1614
  tmp___2 = output_pager_lines(0U);
#line 1614
  tmp___3 = output_pager_columns(0U);
#line 1614
  tmp___6 = output_pager_status(-1);
  }
#line 1614
  if (tmp___6) {
#line 1614
    tmp___5 = "on";
  } else {
#line 1614
    tmp___5 = "off";
  }
  {
#line 1614
  outputf("pager %s %s (screen registered as %dx%d).\n", when, tmp___5, tmp___3, tmp___2);
  }
#line 1620
  return (0);
}
}
#line 1627 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_set_highlighting_style(unsigned char const   *style ) 
{ 
  char const   *when ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
#line 1629
  when = "is";
#line 1630
  if (style) {
    {
#line 1632
    tmp___10 = strcmp((char const   *)style, "black");
    }
#line 1632
    if (tmp___10 == 0) {
#line 1633
      lookup.flag.hl_style = 11U;
    } else {
      {
#line 1634
      tmp___9 = strcmp((char const   *)style, "red");
      }
#line 1634
      if (tmp___9 == 0) {
#line 1635
        lookup.flag.hl_style = 4U;
      } else {
        {
#line 1636
        tmp___8 = strcmp((char const   *)style, "green");
        }
#line 1636
        if (tmp___8 == 0) {
#line 1637
          lookup.flag.hl_style = 5U;
        } else {
          {
#line 1638
          tmp___7 = strcmp((char const   *)style, "yellow");
          }
#line 1638
          if (tmp___7 == 0) {
#line 1639
            lookup.flag.hl_style = 6U;
          } else {
            {
#line 1640
            tmp___6 = strcmp((char const   *)style, "blue");
            }
#line 1640
            if (tmp___6 == 0) {
#line 1641
              lookup.flag.hl_style = 7U;
            } else {
              {
#line 1642
              tmp___5 = strcmp((char const   *)style, "purple");
              }
#line 1642
              if (tmp___5 == 0) {
#line 1643
                lookup.flag.hl_style = 8U;
              } else {
                {
#line 1644
                tmp___4 = strcmp((char const   *)style, "cyan");
                }
#line 1644
                if (tmp___4 == 0) {
#line 1645
                  lookup.flag.hl_style = 9U;
                } else {
                  {
#line 1646
                  tmp___3 = strcmp((char const   *)style, "white");
                  }
#line 1646
                  if (tmp___3 == 0) {
#line 1647
                    lookup.flag.hl_style = 10U;
                  } else {
                    {
#line 1648
                    tmp___2 = strcmp((char const   *)style, "bold");
                    }
#line 1648
                    if (tmp___2 == 0) {
#line 1649
                      lookup.flag.hl_style = 1U;
                    } else {
                      {
#line 1650
                      tmp___1 = strcmp((char const   *)style, "blink");
                      }
#line 1650
                      if (tmp___1 == 0) {
#line 1651
                        lookup.flag.hl_style = 3U;
                      } else {
                        {
#line 1652
                        tmp___0 = strcmp((char const   *)style, "under");
                        }
#line 1652
                        if (tmp___0 == 0) {
#line 1653
                          lookup.flag.hl_style = 2U;
                        } else
#line 1654
                        if ((int const   )*(style + 0) != 60) {
#line 1655
                          lookup.flag.hl_style = 0U;
                        } else {
#line 1658
                          lookup.flag.hl_style = 12U;
#line 1660
                          if ((lookup.slot)->onefile_or_combo.onefile._highlight_tag_) {
                            {
#line 1661
                            free((void *)(lookup.slot)->onefile_or_combo.onefile._highlight_tag_);
                            }
                          }
                          {
#line 1662
                          tmp = strsave(style);
#line 1662
                          (lookup.slot)->onefile_or_combo.onefile._highlight_tag_ = (unsigned char const   *)tmp;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1665
    if (! lookup.flag.verbose) {
#line 1666
      return (0);
    }
#line 1667
    when = "now";
  }
#line 1670
  if (lookup.flag.hl_style == 12U) {
#line 1670
    tmp___12 = (char const   *)(lookup.slot)->onefile_or_combo.onefile._highlight_tag_;
  } else {
#line 1670
    if (lookup.flag.hl_style == 1U) {
#line 1670
      tmp___11 = "bold";
    } else {
#line 1670
      tmp___11 = "inverse";
    }
#line 1670
    tmp___12 = tmp___11;
  }
#line 1670
  if ((lookup.slot)->default_flag.highlight) {
#line 1670
    tmp___13 = "on";
  } else {
#line 1670
    tmp___13 = "off";
  }
  {
#line 1670
  outputf("highlighting (which is %s for the current slot) %s %s.\n", tmp___13, when,
          tmp___12);
  }
#line 1676
  return (0);
}
}
#line 1682 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_error(char const   *error , unsigned char const   *command___0 ) 
{ 


  {
  {
#line 1684
  outputf("%s%s to\241\310%s\241\311command.\n", lookup.where, error, command___0);
  }
#line 1685
  return (1);
}
}
#line 1704 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static matched_paren_t cmd_paren_info[9]  ;
#line 1705 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static unsigned char *cmd_paren[9]  ;
#line 1707
static int cmd_help(unsigned char const   *str___0 ) ;
#line 11 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func3_(void) 
{ 
  int tmp ;

  {
  {
#line 13
  tmp = cmd_do_search((unsigned char const   *)cmd_paren[0]);
  }
#line 13
  return (tmp);
}
}
#line 17 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func4_(void) 
{ 
  int tmp ;

  {
  {
#line 19
  tmp = cmd_set_local_autokana_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 19
  return (tmp);
}
}
#line 23 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func5_(void) 
{ 
  int tmp ;

  {
  {
#line 25
  tmp = cmd_set_default_autokana_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 25
  return (tmp);
}
}
#line 29 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func7_(void) 
{ 
  int tmp ;

  {
  {
#line 31
  tmp = cmd_cmdchar((unsigned char const   *)cmd_paren[2]);
  }
#line 31
  return (tmp);
}
}
#line 35 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func8_(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = cmd_set_default_cmd_debug_flag((unsigned char const   *)cmd_paren[2]);
  }
#line 37
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func9_(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 43
  if (cmd_paren[4]) {
    {
#line 43
    tmp = atoi((char const   *)cmd_paren[4]);
#line 43
    tmp___0 = tmp;
    }
  } else {
#line 43
    tmp___0 = -1;
  }
  {
#line 43
  tmp___1 = cmd_combine((unsigned char const   *)cmd_paren[3], tmp___0, (unsigned char const   *)cmd_paren[5]);
  }
#line 43
  return (tmp___1);
}
}
#line 47 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func10_(void) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = cmd_set_default_debug_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 49
  return (tmp);
}
}
#line 53 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func11_(void) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = cmd_describe_raw((unsigned char const   *)cmd_paren[1]);
  }
#line 55
  return (tmp);
}
}
#line 59 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func12_(void) 
{ 
  int tmp ;

  {
  {
#line 61
  tmp = cmd_describe_raw((unsigned char const   *)cmd_paren[0]);
  }
#line 61
  return (tmp);
}
}
#line 65 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func13_(void) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = cmd_describe_kuten((unsigned char const   *)cmd_paren[1]);
  }
#line 67
  return (tmp);
}
}
#line 71 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func14_(void) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = cmd_describe_ascii(8U, (unsigned char const   *)cmd_paren[1]);
  }
#line 73
  return (tmp);
}
}
#line 77 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func15_(void) 
{ 
  int tmp ;

  {
  {
#line 79
  tmp = cmd_describe_ascii(10U, (unsigned char const   *)cmd_paren[0]);
  }
#line 79
  return (tmp);
}
}
#line 83 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func16_(void) 
{ 
  int tmp ;

  {
  {
#line 85
  tmp = cmd_describe_ascii(16U, (unsigned char const   *)cmd_paren[0]);
  }
#line 85
  return (tmp);
}
}
#line 89 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func17_(void) 
{ 
  int tmp ;

  {
  {
#line 91
  tmp = cmd_describe_encoding((unsigned char const   *)cmd_paren[0], (unsigned char const   *)cmd_paren[2]);
  }
#line 91
  return (tmp);
}
}
#line 95 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func18_(void) 
{ 
  int tmp ;

  {
  {
#line 97
  tmp = cmd_describe_jis_string((unsigned char const   *)cmd_paren[1]);
  }
#line 97
  return (tmp);
}
}
#line 101 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func19_(void) 
{ 
  int tmp ;

  {
  {
#line 103
  tmp = cmd_set_local_display_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 103
  return (tmp);
}
}
#line 107 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func20_(void) 
{ 
  int tmp ;

  {
  {
#line 109
  tmp = cmd_set_default_display_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 109
  return (tmp);
}
}
#line 113 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func21_(void) 
{ 
  int tmp ;

  {
  {
#line 115
  tmp = cmd_encoding((unsigned char const   *)cmd_paren[1]);
  }
#line 115
  return (tmp);
}
}
#line 119 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func22_(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 121
  if (cmd_paren[1]) {
#line 121
    tmp = 1;
  } else {
#line 121
    tmp = 0;
  }
  {
#line 121
  tmp___0 = cmd_list_files(tmp);
  }
#line 121
  return (tmp___0);
}
}
#line 125 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func23_(void) 
{ 
  int tmp ;

  {
  {
#line 127
  tmp = cmd_filter((unsigned char const   *)cmd_paren[4], (unsigned char const   *)cmd_paren[1],
                   (int )*(cmd_paren[2] + 0) == 33, (int )*(cmd_paren[5] + 0) == 105);
  }
#line 127
  return (tmp);
}
}
#line 131 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func24_(void) 
{ 
  int tmp ;

  {
  {
#line 133
  tmp = cmd_toggle_filter((unsigned char const   *)cmd_paren[0]);
  }
#line 133
  return (tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func25_(void) 
{ 
  int tmp ;

  {
  {
#line 139
  tmp = cmd_set_local_fold_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 139
  return (tmp);
}
}
#line 143 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func26_(void) 
{ 
  int tmp ;

  {
  {
#line 145
  tmp = cmd_set_default_fold_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 145
  return (tmp);
}
}
#line 149 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func27_(void) 
{ 
  int tmp ;

  {
  {
#line 151
  tmp = cmd_set_local_fuzz_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 151
  return (tmp);
}
}
#line 155 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func28_(void) 
{ 
  int tmp ;

  {
  {
#line 157
  tmp = cmd_set_default_fuzz_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 157
  return (tmp);
}
}
#line 161 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func29_(void) 
{ 
  int tmp ;

  {
  {
#line 163
  tmp = cmd_help((unsigned char const   *)cmd_paren[0]);
  }
#line 163
  return (tmp);
}
}
#line 167 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func30_(void) 
{ 
  int tmp ;

  {
  {
#line 169
  tmp = cmd_set_local_highlight_flag((unsigned char const   *)cmd_paren[2]);
  }
#line 169
  return (tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func31_(void) 
{ 
  int tmp ;

  {
  {
#line 175
  tmp = cmd_set_highlighting_style((unsigned char const   *)cmd_paren[3]);
  }
#line 175
  return (tmp);
}
}
#line 179 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func32_(void) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = cmd_if((unsigned char const   *)cmd_paren[0], (unsigned char const   *)cmd_paren[1]);
  }
#line 181
  return (tmp);
}
}
#line 185 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func33_(void) 
{ 
  int tmp ;

  {
  {
#line 187
  tmp = cmd_set_default_highlight_flag((unsigned char const   *)cmd_paren[2]);
  }
#line 187
  return (tmp);
}
}
#line 191 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func34_(void) 
{ 
  int tmp ;

  {
  {
#line 193
  tmp = cmd_input_encoding((unsigned char const   *)cmd_paren[1]);
  }
#line 193
  return (tmp);
}
}
#line 197 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func35_(void) 
{ 
  int tmp ;

  {
  {
#line 199
  tmp = cmd_set_limit((unsigned char const   *)cmd_paren[1]);
  }
#line 199
  return (tmp);
}
}
#line 203 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func36_(void) 
{ 
  int tmp ;

  {
#line 205
  if (cmd_paren[2]) {
    {
#line 205
    warn("flags no longer need for \'load\' command\n");
    }
  } else
#line 205
  if (cmd_paren[3]) {
    {
#line 205
    warn("flags no longer need for \'load\' command\n");
    }
  }
  {
#line 205
  tmp = cmd_load((char const   *)cmd_paren[7]);
  }
#line 205
  return (tmp);
}
}
#line 209 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func37_(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 211
  if (cmd_paren[4]) {
#line 211
    tmp = 1;
  } else {
#line 211
    tmp = 0;
  }
#line 211
  if (cmd_paren[1]) {
#line 211
    tmp___0 = 1;
  } else {
#line 211
    tmp___0 = 0;
  }
  {
#line 211
  tmp___1 = cmd_log(tmp___0, tmp, (unsigned char const   *)cmd_paren[6]);
  }
#line 211
  return (tmp___1);
}
}
#line 215 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func38_(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 217
  if ((int )*(cmd_paren[3] + 0) == 103) {
#line 217
    tmp = 1;
  } else
#line 217
  if ((int )*(cmd_paren[3] + 1) == 103) {
#line 217
    tmp = 1;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  if ((int )*(cmd_paren[3] + 0) == 105) {
#line 217
    tmp___0 = 1;
  } else
#line 217
  if ((int )*(cmd_paren[3] + 1) == 105) {
#line 217
    tmp___0 = 1;
  } else {
#line 217
    tmp___0 = 0;
  }
  {
#line 217
  tmp___1 = cmd_modify((unsigned char const   *)cmd_paren[1], (unsigned char const   *)cmd_paren[2],
                       tmp___0, tmp);
  }
#line 217
  return (tmp___1);
}
}
#line 221 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func39_(void) 
{ 
  int tmp ;

  {
  {
#line 223
  tmp = cmd_toggle_modify((unsigned char const   *)cmd_paren[0]);
  }
#line 223
  return (tmp);
}
}
#line 227 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func40_(void) 
{ 
  int tmp ;

  {
  {
#line 229
  tmp = cmd_msg((unsigned char const   *)cmd_paren[0]);
  }
#line 229
  return (tmp);
}
}
#line 233 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func41_(void) 
{ 
  int tmp ;

  {
  {
#line 235
  tmp = cmd_output_encoding((unsigned char const   *)cmd_paren[1], (unsigned char const   *)cmd_paren[2],
                            (unsigned char const   *)cmd_paren[4], (unsigned char const   *)cmd_paren[5]);
  }
#line 235
  return (tmp);
}
}
#line 239 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func42_(void) 
{ 
  int tmp ;

  {
  {
#line 241
  tmp = cmd_pager((unsigned char const   *)cmd_paren[1], (unsigned char const   *)cmd_paren[3],
                  (unsigned char const   *)cmd_paren[4]);
  }
#line 241
  return (tmp);
}
}
#line 245 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func43_(void) 
{ 
  int tmp ;

  {
  {
#line 247
  tmp = cmd_set_prompt(1, (unsigned char const   *)cmd_paren[2]);
  }
#line 247
  return (tmp);
}
}
#line 251 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func44_(void) 
{ 
  int tmp ;

  {
  {
#line 253
  tmp = cmd_set_prompt(0, (unsigned char const   *)cmd_paren[2]);
  }
#line 253
  return (tmp);
}
}
#line 257 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func45_(void) 
{ 
  int tmp ;

  {
  {
#line 259
  tmp = cmd_set_default_regex_debug_flag((unsigned char const   *)cmd_paren[1]);
  }
#line 259
  return (tmp);
}
}
#line 263 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func46_(void) 
{ 
  int tmp ;

  {
  {
#line 265
  tmp = cmd_list_size((unsigned char const   *)cmd_paren[4]);
  }
#line 265
  return (tmp);
}
}
#line 269 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func47_(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 271
  if (cmd_paren[1]) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
  {
#line 271
  tmp___0 = cmd_select((unsigned char const   *)cmd_paren[3], (char const   *)cmd_paren[6],
                       tmp);
  }
#line 271
  return (tmp___0);
}
}
#line 275 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func49_(void) 
{ 
  int tmp ;

  {
  {
#line 277
  tmp = cmd_source((char const   *)cmd_paren[1]);
  }
#line 277
  return (tmp);
}
}
#line 281 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func50_(void) 
{ 
  int tmp ;

  {
  {
#line 283
  tmp = cmd_set_spinner((unsigned char const   *)cmd_paren[1]);
  }
#line 283
  return (tmp);
}
}
#line 287 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func52_(void) 
{ 
  int tmp ;

  {
  {
#line 289
  tmp = cmd_tag((unsigned char const   *)cmd_paren[0], (unsigned char const   *)cmd_paren[3]);
  }
#line 289
  return (tmp);
}
}
#line 293 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func53_(void) 
{ 
  int tmp ;

  {
  {
#line 295
  tmp = set_verbose_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 295
  return (tmp);
}
}
#line 299 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func55_(void) 
{ 
  int tmp ;

  {
  {
#line 301
  tmp = cmd_set_local_word_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 301
  return (tmp);
}
}
#line 305 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func56_(void) 
{ 
  int tmp ;

  {
  {
#line 307
  tmp = cmd_set_default_word_flag((unsigned char const   *)cmd_paren[0]);
  }
#line 307
  return (tmp);
}
}
#line 311 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func57_(void) 
{ 
  int tmp ;

  {
  {
#line 313
  tmp = cmd_set_local_glob_flag((unsigned char const   *)cmd_paren[2]);
  }
#line 313
  return (tmp);
}
}
#line 317 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func58_(void) 
{ 
  int tmp ;

  {
  {
#line 319
  tmp = cmd_set_default_glob_flag((unsigned char const   *)cmd_paren[2]);
  }
#line 319
  return (tmp);
}
}
#line 323 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func60_(void) 
{ 
  int tmp ;

  {
  {
#line 325
  tmp = cmd_error("expecting argument", (unsigned char const   *)cmd_paren[0]);
  }
#line 325
  return (tmp);
}
}
#line 329 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static int _func61_(void) 
{ 
  int tmp ;

  {
  {
#line 331
  tmp = cmd_error("argument error", (unsigned char const   *)cmd_paren[1]);
  }
#line 331
  return (tmp);
}
}
#line 334 "/home/wheatley/newnew/temp/lookup-1.08b/commands.h"
static struct command command[61]  = 
#line 334
  {      {16U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*#",
      (int (*)(void))0, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                         (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         0U, 0U, 0U}}, 
        {16U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*$",
      (int (*)(void))0, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                         (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         0U, 0U, 0U}}, 
        {16U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*([+!=].*)",
      & _func3_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"[default] autokana [on|1|off|0]", (unsigned char const   *)"Turns automatic romaji conversion on or off, or reports current status.",
      (unsigned char const   *)"^\\s*default\\s*autokana>\\s*(on|1|off|0)?\\s*$",
      & _func4_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*autokana>\\s*(on|1|off|0)?\\s*$",
      & _func5_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"clear|cls", (unsigned char const   *)"clear the screen",
      (unsigned char const   *)"^\\s*(clear|cls)\\s*$", & cmd_clear, {(unsigned char *)0,
                                                                      (unsigned char *)0,
                                                                      0U, (unsigned char *)0,
                                                                      (unsigned char)0,
                                                                      (unsigned char)0,
                                                                      (unsigned char)0,
                                                                      (unsigned char)0,
                                                                      0U, 0U, 0U}}, 
        {1U,
      (unsigned char const   *)"cmdchar [\'bytechar\']", (unsigned char const   *)"set the this-is-a-command character",
      (unsigned char const   *)"^\\s*cmd(char)?\\s*(\'(\\a)\')?\\s*$", & _func7_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"command debug [on|1|off|0]", (unsigned char const   *)"Turns command debugging on or off, or reports current status.",
      (unsigned char const   *)"^\\s*c(om(mand)?)?>\\s*debug>\\s*(on|1|off|0)?\\s*$",
      & _func8_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  0U, 0U, 0U}}, 
        {65U, (unsigned char const   *)"combine> [\"name\"] [num =] num [num....]", (unsigned char const   *)"Combines previously-loaded slots to one new slot.",
      (unsigned char const   *)"^\\s*comb(o|ine)\\s*(([\"\'])(.*)\\3\\s*=?)?\\s*(\\d+\\s*\\+?=)?\\s*((#?\\s*\\d+\\s*,?\\s*)+)\\s*$",
      & _func9_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"debug [on|1|off|0]", (unsigned char const   *)"Turns debugging on or off, or reports current status.",
      (unsigned char const   *)"^\\s*debug>\\s*(on|1|off|0)?\\s*$", & _func10_, {(unsigned char *)0,
                                                                                 (unsigned char *)0,
                                                                                 0U,
                                                                                 (unsigned char *)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U}}, 
        {1U,
      (unsigned char const   *)"describe \"string\"|character|[kuten|euc|jis|sjis|ascii]code",
      (unsigned char const   *)"describes the encodings for the character(s) indicated",
      (unsigned char const   *)"^\\s*describe>\\s*([\'\"])(.*)\\1\\s*$", & _func11_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe>\\s*(\\A+|[!-~])\\s*$",
      & _func12_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe>\\s*(kuten>\\s*)?(\\d\\d\\d\\d)\\s*$",
      & _func13_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe\\s*ascii\\s*(\\\\|0)([0-7]+)\\s*$",
      & _func14_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe\\s*ascii\\s*(\\d+)\\s*$",
      & _func15_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe\\s*ascii\\s*(0[xX])?([0-9a-f][0-9a-f])\\s*$",
      & _func16_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe>\\s*(sjis>|jis>|euc>)?\\s*(0[xX])?(<[0-9a-f][0-9a-f][0-9a-f][0-9a-f]>)\\s*$",
      & _func17_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*describe>\\s*(\\$@|\\$B|\\$@\\$B)?(([!-~][!-~])+)(\\(\\$@|\\$B|\\$@\\$B|\\$\\(D|\\(J|\\(H|\\(B|\\(I)?\\s*$",
      & _func18_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"[default] display [on|1|off|0]", (unsigned char const   *)"Turns display of matching lines on or off.",
      (unsigned char const   *)"^\\s*display>\\s*(on|1|off|0)?\\s*$", & _func19_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*display>\\s*(on|1|off|0)?\\s*$",
      & _func20_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {129U, (unsigned char const   *)"encoding (euc|jis|sjis)", (unsigned char const   *)"set the input/output encoding-method",
      (unsigned char const   *)"^\\s*encod(e|ing)>\\s*(euc|jis|sjis)?\\s*$", & _func21_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"files|slots [-]", (unsigned char const   *)"list what files are loaded into what slots.",
      (unsigned char const   *)"^\\s*(slot|file)s?>\\s*(-|-?(help|long))?\\s*$", & _func22_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {65U, (unsigned char const   *)"filter [\"name\"] [!] /regex/[i]", (unsigned char const   *)"set the filter for the selected file.",
      (unsigned char const   *)"^\\s*filter>\\s*(\"([^\"]*)\")?\\s*(!?)\\s*(\\S)(.+)\\4(i?)\\s*$",
      & _func23_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"filter [on|1|off|0]", (unsigned char const   *)"turn the filter (for the selected file) on or off, or report its status",
      (unsigned char const   *)"^\\s*filter>\\s*(on|1|off|0)?\\s*$", & _func24_, {(unsigned char *)0,
                                                                                  (unsigned char *)0,
                                                                                  0U,
                                                                                  (unsigned char *)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U}}, 
        {321U,
      (unsigned char const   *)"[default] fold [on|1|off|0]", (unsigned char const   *)"Turns case folding on or off, or reports current status.",
      (unsigned char const   *)"^\\s*fold>\\s*(on|1|off|0)?\\s*$", & _func25_, {(unsigned char *)0,
                                                                                (unsigned char *)0,
                                                                                0U,
                                                                                (unsigned char *)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                0U,
                                                                                0U,
                                                                                0U}}, 
        {1U,
      (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*fold>\\s*(on|1|off|0)?\\s*$",
      & _func26_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"[default] fuzz [on|1|off|0]", (unsigned char const   *)"Turns fuzzification on or off, or reports current status.",
      (unsigned char const   *)"^\\s*fuzz>\\s*(on|1|off|0)?\\s*$", & _func27_, {(unsigned char *)0,
                                                                                (unsigned char *)0,
                                                                                0U,
                                                                                (unsigned char *)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                0U,
                                                                                0U,
                                                                                0U}}, 
        {1U,
      (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*fuzz>\\s*(on|1|off|0)?\\s*$",
      & _func28_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"help [string]", (unsigned char const   *)"list help",
      (unsigned char const   *)"^\\s*help\\s*(.*\\S)?\\s*$", & _func29_, {(unsigned char *)0,
                                                                          (unsigned char *)0,
                                                                          0U, (unsigned char *)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          0U, 0U,
                                                                          0U}}, 
        {321U, (unsigned char const   *)"[default] highlight [on|1|off|0]", (unsigned char const   *)"Turns highlighting on or off, or reports current status.",
      (unsigned char const   *)"^\\s*h(igh)?l(ight)?>\\s*(on|1|off|0)?\\s*$", & _func30_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"highlight [bold|inverse|blink|under|<___>|black|red|green|yellow|blue|purple|cyan|white]",
      (unsigned char const   *)"Sets the highlighting style (bold, inverse[standout], or to a given HTML tag)",
      (unsigned char const   *)"^\\s*h(igh)?l(ight)?>\\s*(style)?\\s*(red|green|yellow|blue|purple|cyan|white|bold|inverse|standout|blink|under|\\<([a-zA-Z]+)\\>)?\\s*$",
      & _func31_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"Runs command only if EXPR is true.", (unsigned char const   *)"if {expr} command",
      (unsigned char const   *)"^\\s*if\\s*{([^}]*)}\\s*(.*)\\s*$", & _func32_, {(unsigned char *)0,
                                                                                 (unsigned char *)0,
                                                                                 0U,
                                                                                 (unsigned char *)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 (unsigned char)0,
                                                                                 0U,
                                                                                 0U,
                                                                                 0U}}, 
        {1U,
      (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*h(igh)?l(ight)?>\\s*(on|1|off|0)?\\s*$",
      & _func33_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {129U, (unsigned char const   *)"input encoding [euc|sjis]", (unsigned char const   *)"report or set the input encoding-method for 8-bit bytes (JIS always OK)",
      (unsigned char const   *)"^\\s*input\\s*(encoding)?>\\s*(euc|sjis)?\\s*$", & _func34_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"limit [ <value> ]", (unsigned char const   *)"set the maximum number of lines to print during any one command.",
      (unsigned char const   *)"^\\s*limit\\s*(=?\\s*(\\d+))?\\s*$", & _func35_, {(unsigned char *)0,
                                                                                  (unsigned char *)0,
                                                                                  0U,
                                                                                  (unsigned char *)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U}}, 
        {65U,
      (unsigned char const   *)"load \"file\"", (unsigned char const   *)"load a file (and read or compute its index as needed)",
      (unsigned char const   *)"^\\s*(fast)?load>\\s*(-?(now)|-?(w(hen)?n(eeded)?))?\\s*([\'\"]?)(\\S+)\\7\\s*$",
      & _func36_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"log [- | [+]\"file\"]", (unsigned char const   *)"log output to a file",
      (unsigned char const   *)"^\\s*log>\\s*((-|<off>)|((<to>)?\\s*(\\+)?\\s*([\'\"]?)(.+)\\6))?\\s*$",
      & _func37_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"modify /regex/replace/[ig]", (unsigned char const   *)"sets the modify regular expression and replacement for the selected file.",
      (unsigned char const   *)"^\\s*modify>\\s*(\\S)(.+)\\1(.*)\\1([ig]?)\\s*$",
      & _func38_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"modify [on|1|off|0]", (unsigned char const   *)"sets the modify filter on or off (for the indicated file)",
      (unsigned char const   *)"^\\s*modify>\\s*(on|1|off|0)?\\s*$", & _func39_, {(unsigned char *)0,
                                                                                  (unsigned char *)0,
                                                                                  0U,
                                                                                  (unsigned char *)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0U,
                                                                                  0U,
                                                                                  0U}}, 
        {1U,
      (unsigned char const   *)"msg ....", (unsigned char const   *)"prints a message to the screen",
      (unsigned char const   *)"^\\s*msg\\s*(.*)\\s*$", & _func40_, {(unsigned char *)0,
                                                                     (unsigned char *)0,
                                                                     0U, (unsigned char *)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     (unsigned char)0,
                                                                     0U, 0U, 0U}}, 
        {129U,
      (unsigned char const   *)"output encoding [euc|sjis|jis|...]", (unsigned char const   *)"report or set the output encoding-method",
      (unsigned char const   *)"^\\s*output>\\s*(encoding>)?\\s*(euc|sjis|jis-?(78|83|90)?(-(ascii|roman))?)?((<(212|no212|hwk|nohwk|foldhwk|disp|nodisp|code|mark)>|[-,\\s]+)*)\\s*$",
      & _func41_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"pager [boolean | [W x] H]", (unsigned char const   *)"configure (width x height) or toggle the output pager",
      (unsigned char const   *)"^\\s*pager>\\s*((on|1|off|0)|(([1-9]\\d*\\s*[,x])?\\s*([1-9]\\d*)))?\\s*$",
      & _func42_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {257U, (unsigned char const   *)"[local] prompt \"string\"", (unsigned char const   *)"set the prompt format string",
      (unsigned char const   *)"^\\s*local\\s*prompt>\\s*(([\'\"])(.+)\\2)?\\s*$",
      & _func43_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*prompt>\\s*(([\'\"])(.+)\\2)?\\s*$",
      & _func44_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"regex debug [on|1|off|0]", (unsigned char const   *)"Turns regex debugging on or off, or reports current status.",
      (unsigned char const   *)"^\\s*r(egex)?\\s*debug>\\s*(on|1|off|0)?\\s*$", & _func45_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"saved list size [ <value> ]", (unsigned char const   *)"set the number of elided lines to remember for the \"show\" command.",
      (unsigned char const   *)"^\\s*saved?\\s*(list)?\\s*(size|len(gth)?)?\\s*(=?\\s*(\\d+))?\\s*$",
      & _func46_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {65U, (unsigned char const   *)"select [ num | name | . ]", (unsigned char const   *)"sets the default file",
      (unsigned char const   *)"^\\s*select>\\s*((\\.)|(#?\\s*(\\d+))|(([\"\']?)(.+)\\6))?\\s*$",
      & _func47_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"show", (unsigned char const   *)"show the lines filtered by the last search, if any",
      (unsigned char const   *)"^\\s*show\\s*$", & cmd_show, {(unsigned char *)0,
                                                              (unsigned char *)0,
                                                              0U, (unsigned char *)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              (unsigned char)0, (unsigned char)0,
                                                              0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"source \"filename\"", (unsigned char const   *)"load commands from a file",
      (unsigned char const   *)"^\\s*source>\\s*([\'\"]?)(.+)\\1\\s*$", & _func49_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"spinner [ <value> ]", (unsigned char const   *)"sets the spinner to move each <value> lines checked (0 to disable)",
      (unsigned char const   *)"^\\s*spinner\\s*(=?\\s*(\\d+))?\\s*$", & _func50_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"stats", (unsigned char const   *)"reports stats about the last search",
      (unsigned char const   *)"^\\s*stats?\\s*$", & cmd_stats, {(unsigned char *)0,
                                                                 (unsigned char *)0,
                                                                 0U, (unsigned char *)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"tag [boolean] [\"string\"]", (unsigned char const   *)"set, toggle, or report the tag for the slot.",
      (unsigned char const   *)"^\\s*tag>\\s*(on|1|off|0)?\\s*(([\'\"])(.*)\\3)?\\s*$",
      & _func52_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"verbose [on|1|off|0]", (unsigned char const   *)"Turns verbosity on or off, or reports current status.",
      (unsigned char const   *)"^\\s*verbose>\\s*(on|1|off|0)?\\s*$", & _func53_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"version", (unsigned char const   *)"report the version number",
      (unsigned char const   *)"^\\s*version\\s*$", & cmd_version, {(unsigned char *)0,
                                                                    (unsigned char *)0,
                                                                    0U, (unsigned char *)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    (unsigned char)0,
                                                                    0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"[default] word [on|1|off|0]", (unsigned char const   *)"Turns word-preference mode on or off, or reports current status.",
      (unsigned char const   *)"^\\s*word>\\s*(on|1|off|0)?\\s*$", & _func55_, {(unsigned char *)0,
                                                                                (unsigned char *)0,
                                                                                0U,
                                                                                (unsigned char *)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                (unsigned char)0,
                                                                                0U,
                                                                                0U,
                                                                                0U}}, 
        {1U,
      (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*word>\\s*(on|1|off|0)?\\s*$",
      & _func56_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {321U, (unsigned char const   *)"[default] wildcard [on|1|off|0]", (unsigned char const   *)"Selects wildcard \"glob\" patterns instead of regular expression patterns.",
      (unsigned char const   *)"^\\s*(glob|wild(card)?)>\\s*(on|1|off|0)?\\s*$", & _func57_,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*default\\s*(glob|wild(card)?)>\\s*(on|1|off|0)?\\s*$",
      & _func58_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)"exit|quit|bye|leave|done", (unsigned char const   *)"Exits the program",
      (unsigned char const   *)"^\\s*(exit|quit|bye|leave|done)\\s*$", & cmd_exit,
      {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0, (unsigned char)0,
       (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*(load|describe|source)\\s*$",
      & _func60_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}, 
        {1U, (unsigned char const   *)0, (unsigned char const   *)0, (unsigned char const   *)"^\\s*(default|local)?\\s*(autokana|cmdchar|debug|describe|encoding|files?|filter|fold|fuzz|help|highlight\\s*(style)?|input\\s*(encoding)?|limit|load|modify|output\\s*(encoding)?|pager|prompt|r(egex)?\\s*debug|saved?\\s*(list)?\\s*(size|len(gth)?)?|select|show|source|spinner|stats?|verbose|version|word|exit|quit|bye|leave|done|combine|combo|tag).*\\s*$",
      & _func61_, {(unsigned char *)0, (unsigned char *)0, 0U, (unsigned char *)0,
                   (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                   0U, 0U, 0U}}};
#line 1712 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
static int cmd_help(unsigned char const   *str___0 ) 
{ 
  regex_t regex ;
  int cmd ;
  int count ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int len ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned int tmp___4 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 1717
  if ((unsigned long )str___0 == (unsigned long )((unsigned char const   *)0)) {
#line 1719
    cmd = 0;
    {
#line 1719
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1719
      if (! ((unsigned long )cmd < sizeof(command) / sizeof(command[0]))) {
#line 1719
        goto while_break;
      }
#line 1720
      if (command[cmd].usage) {
#line 1720
        if (command[cmd].help) {
          {
#line 1721
          outputf("%s\n  %s\n", command[cmd].usage, command[cmd].help);
          }
        }
      }
#line 1719
      cmd ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1722
    return (0);
  }
  {
#line 1727
  tmp___0 = regcomp(& regex, str___0, 12U);
  }
#line 1727
  if (tmp___0 != 0) {
    {
#line 1729
    tmp = regcomp_error_report();
#line 1729
    outputf("%s%s.\n", lookup.where, (unsigned char *)tmp);
    }
#line 1731
    return (1);
  }
#line 1733
  cmd = 0;
#line 1733
  count = cmd;
  {
#line 1733
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1733
    if (! ((unsigned long )cmd < sizeof(command) / sizeof(command[0]))) {
#line 1733
      goto while_break___0;
    }
#line 1735
    if (command[cmd].usage) {
#line 1735
      if (command[cmd].help) {
        {
#line 1735
        tmp___3 = strlen((char const   *)((void *)command[cmd].usage));
#line 1735
        tmp___4 = regexec((regex_t const   *)(& regex), command[cmd].usage, (unsigned int )tmp___3);
        }
#line 1735
        if (tmp___4) {
#line 1735
          goto _L;
        } else {
          {
#line 1735
          tmp___5 = strlen((char const   *)((void *)command[cmd].help));
#line 1735
          tmp___6 = regexec((regex_t const   *)(& regex), command[cmd].help, (unsigned int )tmp___5);
          }
#line 1735
          if (tmp___6) {
            _L: /* CIL Label */ 
#line 1739
            tmp___2 = count;
#line 1739
            count ++;
#line 1739
            if (tmp___2 == 0) {
              {
#line 1741
              tmp___1 = output_pager_columns(0U);
#line 1741
              len = (int )tmp___1;
              }
              {
#line 1742
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1742
                len -= 2;
#line 1742
                if (! (len > 0)) {
#line 1742
                  goto while_break___1;
                }
                {
#line 1743
                output("\250\241");
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 1744
              (*_output_char_function)((unsigned char )'\n');
              }
            }
            {
#line 1746
            outputf("%s\n  %s\n", command[cmd].usage, command[cmd].help);
            }
          }
        }
      }
    }
#line 1733
    cmd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1749
  regfree(& regex);
  }
#line 1750
  if (count == 0) {
    {
#line 1751
    outputf("%snothing appropriate\n", lookup.where);
    }
  }
#line 1752
  return (0);
}
}
#line 1761 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int parse_command(unsigned char const   *line___1 , unsigned int len , unsigned int accept ,
                  unsigned int skip ) 
{ 
  int cmd ;
  int matches ;
  matched_paren_t *prev_regexec_paren_info ;
  unsigned int prev_regexec_paren_info_size ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  int paren ;
  int cmd_result ;
  char const   *tmp___1 ;
  unsigned char const   *start ;
  unsigned char const   *end ;
  unsigned char *dest ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char const   *tmp___4 ;

  {
#line 1765
  if (lookup.flag.cmd_debug) {
    {
#line 1766
    outputf("parsing\241\310%.*s\241\311accept=%x, skip=%x.\n", (int )len, line___1,
            accept, skip);
    }
  }
#line 1769
  cmd = 0;
  {
#line 1769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1769
    if (! ((unsigned long )cmd < sizeof(command) / sizeof(command[0]))) {
#line 1769
      goto while_break;
    }
#line 1776
    if ((command[cmd].flags & accept) == 0U) {
#line 1777
      goto __Cont;
    }
#line 1780
    if ((command[cmd].flags & 4096U) == 0U) {
      {
#line 1782
      tmp = regcomp(& command[cmd].compiled, command[cmd].pattern, 76U);
#line 1782
      i = tmp;
      }
#line 1784
      if (i != 0) {
        {
#line 1786
        outputf("%sbad compile\241\310%s\241\311at\241\310%s\241\311%d.\n", lookup.where,
                command[cmd].pattern, regcomp_eptr, i);
        }
      }
      {
#line 1790
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1790
        if (! (i == 0)) {
          {
#line 1790
          die("\nassert(i == REGCOMP_SUCCESS) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/commands.c",
              1790);
          }
        }
#line 1790
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1791
      if (lookup.flag.cmd_debug) {
        {
#line 1792
        outputf("compiled\241\310%s\241\311\n", command[cmd].pattern);
        }
      }
#line 1793
      command[cmd].flags |= 4096U;
    }
    {
#line 1797
    prev_regexec_paren_info = regexec_paren_info;
#line 1798
    prev_regexec_paren_info_size = regexec_paren_info_size;
#line 1799
    regexec_paren_info = cmd_paren_info;
#line 1800
    regexec_paren_info_size = (unsigned int )(sizeof(cmd_paren_info) / sizeof(cmd_paren_info[0]));
#line 1802
    tmp___0 = regexec((regex_t const   *)(& command[cmd].compiled), line___1, len);
#line 1802
    matches = (int )tmp___0;
#line 1804
    regexec_paren_info = prev_regexec_paren_info;
#line 1805
    regexec_paren_info_size = prev_regexec_paren_info_size;
    }
#line 1807
    if (matches) {
#line 1810
      if (lookup.flag.cmd_debug) {
        {
#line 1811
        outputf("matches regex\241\310%s\241\311\n", command[cmd].pattern);
        }
      }
#line 1813
      if (command[cmd].flags & skip) {
#line 1815
        if (lookup.flag.debug) {
          {
#line 1816
          warn("skipping command [%.*s]\n", (int )len, line___1);
          }
        }
#line 1817
        return (13);
      }
#line 1820
      if ((unsigned long )command[cmd].function == (unsigned long )((int (*)(void))0)) {
#line 1821
        return (10);
      }
#line 1823
      if ((unsigned long )lookup.slot == (unsigned long )((struct slot_info *)0)) {
#line 1823
        if (command[cmd].flags & 256U) {
#line 1825
          if (lookup.default_slot) {
#line 1825
            tmp___1 = "selected";
          } else {
#line 1825
            tmp___1 = "loaded";
          }
          {
#line 1825
          outputf("%sno file %s.\n", lookup.where, tmp___1);
          }
#line 1827
          return (1);
        }
      }
#line 1830
      paren = 0;
      {
#line 1830
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1830
        if (! ((unsigned long )paren < sizeof(cmd_paren_info) / sizeof(cmd_paren_info[0]))) {
#line 1830
          goto while_break___1;
        }
#line 1832
        if ((unsigned int )paren >= regexec_paren_info_used) {
#line 1835
          cmd_paren[paren] = (unsigned char *)0;
        } else
#line 1832
        if ((unsigned long )cmd_paren_info[paren].match_start == (unsigned long )((unsigned char const   *)0)) {
#line 1835
          cmd_paren[paren] = (unsigned char *)0;
        } else
#line 1832
        if ((unsigned long )cmd_paren_info[paren].match_end == (unsigned long )((unsigned char const   *)0)) {
#line 1835
          cmd_paren[paren] = (unsigned char *)0;
        } else {
          {
#line 1838
          start = cmd_paren_info[paren].match_start;
#line 1839
          end = cmd_paren_info[paren].match_end;
#line 1840
          tmp___2 = xmalloc((unsigned int )((end - start) + 1L));
#line 1840
          dest = (unsigned char *)tmp___2;
#line 1841
          cmd_paren[paren] = dest;
          }
          {
#line 1842
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1842
            if (! ((unsigned long )start < (unsigned long )end)) {
#line 1842
              goto while_break___2;
            }
#line 1843
            tmp___3 = dest;
#line 1843
            dest ++;
#line 1843
            tmp___4 = start;
#line 1843
            start ++;
#line 1843
            *tmp___3 = (unsigned char )*tmp___4;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1844
          *dest = (unsigned char )'\000';
        }
#line 1847
        if (lookup.flag.cmd_debug) {
#line 1849
          if (cmd_paren[paren]) {
            {
#line 1850
            outputf("paren \\%d is [%s]\n", paren + 1, cmd_paren[paren]);
            }
          } else {
            {
#line 1853
            outputf("paren \\%d is empty\n", paren + 1);
            }
          }
        }
#line 1830
        paren ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1858
      cmd_result = (*(command[cmd].function))();
#line 1860
      paren = 0;
      }
      {
#line 1860
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1860
        if (! ((unsigned long )paren < sizeof(cmd_paren_info) / sizeof(cmd_paren_info[0]))) {
#line 1860
          goto while_break___3;
        }
#line 1861
        if (cmd_paren[paren]) {
          {
#line 1863
          free((void *)cmd_paren[paren]);
#line 1864
          cmd_paren[paren] = (unsigned char *)0;
          }
        }
#line 1860
        paren ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1867
      if (cmd_result != 0) {
#line 1868
        return (11);
      }
#line 1869
      return (10);
    }
    __Cont: /* CIL Label */ 
#line 1769
    cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1873
  return (12);
}
}
#line 1876 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int quick_command(unsigned char const   *str___0 ) 
{ 
  int retval ;
  int old_verbose ;
  size_t tmp ;

  {
  {
#line 1878
  old_verbose = (int )lookup.flag.verbose;
#line 1879
  lookup.flag.verbose = 0U;
#line 1880
  tmp = strlen((char const   *)((void *)str___0));
#line 1880
  retval = parse_command(str___0, (unsigned int )tmp, 1U, 0U);
#line 1881
  lookup.flag.verbose = (unsigned int )old_verbose;
  }
#line 1882
  return (retval);
}
}
#line 1886 "/home/wheatley/newnew/temp/lookup-1.08b/commands.c"
int read_commands_from_file(char const   *file , unsigned int accept , unsigned int skip ) 
{ 
  FILE *fp ;
  unsigned char line___1[20480] ;
  int len ;
  int linenum ;
  unsigned char const   *old_where ;
  struct slot_info *old_slot ;
  int retval ;
  size_t tmp ;
  void *tmp___0 ;
  int i ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1891
  linenum = 0;
#line 1892
  old_where = lookup.where;
#line 1894
  retval = 0;
#line 1897
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 1897
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
#line 1898
    return (1);
  }
  {
#line 1900
  tmp = strlen((char const   *)((void *)((unsigned char const   *)file)));
#line 1900
  tmp___0 = xmalloc((unsigned int )(tmp + 20UL));
#line 1900
  lookup.where = (unsigned char const   *)tmp___0;
#line 1907
  old_slot = lookup.slot;
#line 1908
  lookup.slot = (struct slot_info *)0;
  }
  {
#line 1911
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1911
    tmp___2 = fgets((char */* __restrict  */)((char *)(line___1)), (int )sizeof(line___1),
                    (FILE */* __restrict  */)fp);
    }
#line 1911
    if (! tmp___2) {
#line 1911
      goto while_break;
    }
    {
#line 1914
    linenum ++;
#line 1916
    sprintf((char */* __restrict  */)((void *)lookup.where), (char const   */* __restrict  */)"\"%s\" line %d: ",
            file, linenum);
#line 1919
    tmp___1 = strlen((char const   *)((void *)((unsigned char const   *)(line___1))));
#line 1919
    len = (int )tmp___1;
    }
#line 1920
    if (len > 0) {
#line 1920
      if ((int )line___1[len - 1] == 10) {
#line 1921
        len --;
#line 1921
        line___1[len] = (unsigned char )'\000';
      } else {
#line 1920
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1923
    if (len == 20479) {
      {
#line 1925
      outputf("%sline too long for internal buffer.\n", lookup.where);
#line 1927
      retval = 2;
      }
#line 1928
      goto while_break;
    }
    {
#line 1932
    i = parse_command((unsigned char const   *)(line___1), (unsigned int )len, accept,
                      skip);
    }
#line 1934
    if (i == 12) {
      {
#line 1936
      outputf("%sunknown command:\n   \241\310%s\241\311\n", lookup.where, line___1);
#line 1938
      retval = 2;
      }
#line 1939
      goto while_break;
    } else
#line 1940
    if (i == 11) {
#line 1941
      retval = 3;
#line 1942
      goto while_break;
    } else
#line 1943
    if (exit_program_now) {
#line 1944
      exit_program_now = 0;
#line 1945
      goto while_break;
    } else
#line 1946
    if (apply_regex_abort) {
#line 1947
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1949
  fclose(fp);
#line 1950
  free((void *)lookup.where);
#line 1951
  lookup.where = old_where;
#line 1952
  lookup.slot = old_slot;
  }
#line 1953
  return (0);
}
}
#line 21 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.h"
unsigned int r2k_setmode(unsigned int newmode ) ;
#line 45
char const   *r2k_setpass(char const   *new___1 ) ;
#line 46
char const   *r2k_setomit(char const   *new___1 ) ;
#line 47
char const   *r2k_setlongvowel(char const   *new___1 ) ;
#line 49
unsigned int r2k_setflag(unsigned int new___1 ) ;
#line 54 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static struct __anonstruct_romaji1_25 romaji1[8]  = 
#line 54 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
  {      {{(unsigned char const   )'a'}, {(unsigned char const   )'\244', (unsigned char const   )'\242'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'e'}, {(unsigned char const   )'\244', (unsigned char const   )'\250'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'h'}, {(unsigned char const   )'\244', (unsigned char const   )'\246'},
      (unsigned char const   )4}, 
        {{(unsigned char const   )'i'}, {(unsigned char const   )'\244', (unsigned char const   )'\244'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'m'}, {(unsigned char const   )'\244', (unsigned char const   )'\363'},
      (unsigned char const   )8}, 
        {{(unsigned char const   )'n'}, {(unsigned char const   )'\244', (unsigned char const   )'\363'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'o'}, {(unsigned char const   )'\244', (unsigned char const   )'\252'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'u'}, {(unsigned char const   )'\244', (unsigned char const   )'\246'},
      (unsigned char const   )128}};
#line 69 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static struct __anonstruct_romaji2_26 romaji2[95]  = 
#line 69
  {      {{(unsigned char const   )'b', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\320',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'b', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\331',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'b', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\323',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'b', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\334',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'b', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\326',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\253',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\263',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\257',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\300',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\307',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\302',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\311',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\305',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'f', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\325',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\241'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'f', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\325',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\247'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'f', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\325',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\243'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'f', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\325',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\251'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'f', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\325',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\254',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\262',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\256',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\264',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\260',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\317',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\330',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\322',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\333',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\325',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\270',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\343'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\270',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\247'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\270',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\270',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\347'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\270',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\345'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\253',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\261',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\255',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\263',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\257',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'l', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\351',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'l', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\354',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'l', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\352',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'l', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\355',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'l', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\353',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\336',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\341',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\337',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\342',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\340',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\312',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\315',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\313',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\316',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\314',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\321',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\332',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\324',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\335',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\327',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\351',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\354',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\352',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\355',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\353',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\265',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\273',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\267',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\275',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\271',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\277',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\306',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\301',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\310',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\304',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'v', (unsigned char const   )'a'}, {(unsigned char const   )'\245',
                                                                   (unsigned char const   )'\364',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\241'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'v', (unsigned char const   )'e'}, {(unsigned char const   )'\245',
                                                                   (unsigned char const   )'\364',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\247'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'v', (unsigned char const   )'i'}, {(unsigned char const   )'\245',
                                                                   (unsigned char const   )'\364',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\243'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'v', (unsigned char const   )'o'}, {(unsigned char const   )'\245',
                                                                   (unsigned char const   )'\364',
                                                                   (unsigned char const   )'\244',
                                                                   (unsigned char const   )'\251'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'v', (unsigned char const   )'u'}, {(unsigned char const   )'\245',
                                                                   (unsigned char const   )'\364',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'w', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\357',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'w', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\361',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'w', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\360',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'w', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\362',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\241',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\247',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\243',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\251',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\245',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'y', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\344',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'y', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\350',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'y', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\346',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'a'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\266',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'e'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\274',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'i'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\270',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'o'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\276',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'u'}, {(unsigned char const   )'\244',
                                                                   (unsigned char const   )'\272',
                                                                   (unsigned char const   )'\000'},
      (unsigned char const   )128}};
#line 171 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static struct __anonstruct_romaji3_27 romaji3[65]  = 
#line 171
  {      {{(unsigned char const   )'b', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\323', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'b', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\323', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'b', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\323', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'h', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'h', (unsigned char const   )'e'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\247'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'h', (unsigned char const   )'i'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'h', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'c', (unsigned char const   )'h', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\302', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'y', (unsigned char const   )'e'},
      {(unsigned char const   )'\244', (unsigned char const   )'\302', (unsigned char const   )'\244',
       (unsigned char const   )'\247'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'y', (unsigned char const   )'i'},
      {(unsigned char const   )'\244', (unsigned char const   )'\307', (unsigned char const   )'\244',
       (unsigned char const   )'\243'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\302', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\302', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'z', (unsigned char const   )'i'},
      {(unsigned char const   )'\244', (unsigned char const   )'\302', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'d', (unsigned char const   )'z', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\305', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\256', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\256', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'g', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\256', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\322', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\322', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'h', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\322', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'j', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\255', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\255', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'k', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\255', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\337', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\337', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'m', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\337', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\313', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\313', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'n', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\313', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\324', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\324', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'p', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\324', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\352', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\352', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'r', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\352', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'h', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'h', (unsigned char const   )'i'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'h', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'h', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'y', (unsigned char const   )'i'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'s', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\267', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'s', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\304', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'y', (unsigned char const   )'e'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\247'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'y', (unsigned char const   )'i'},
      {(unsigned char const   )'\244', (unsigned char const   )'\306', (unsigned char const   )'\244',
       (unsigned char const   )'\243'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\301', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'t', (unsigned char const   )'z', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\305', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'k', (unsigned char const   )'a'},
      {(unsigned char const   )'\245', (unsigned char const   )'\365', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'k', (unsigned char const   )'e'},
      {(unsigned char const   )'\245', (unsigned char const   )'\366', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'t', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\303', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'w', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\356', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\343', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\347', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'x', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\345', (unsigned char const   )'\000'},
      (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'y', (unsigned char const   )'a'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\343'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'y', (unsigned char const   )'e'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\247'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'y', (unsigned char const   )'o'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\347'}, (unsigned char const   )128}, 
        {{(unsigned char const   )'z', (unsigned char const   )'y', (unsigned char const   )'u'},
      {(unsigned char const   )'\244', (unsigned char const   )'\270', (unsigned char const   )'\244',
       (unsigned char const   )'\345'}, (unsigned char const   )128}};
#line 243 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static unsigned int mode___0  =    0U;
#line 245 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
unsigned int r2k_setmode(unsigned int newmode ) 
{ 
  unsigned int oldmode ;

  {
#line 247
  oldmode = mode___0;
#line 248
  mode___0 = newmode;
#line 249
  return (oldmode);
}
}
#line 259 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static unsigned int flags  =    7U;
#line 261 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
unsigned int r2k_setflag(unsigned int new___1 ) 
{ 
  unsigned int old ;

  {
#line 263
  old = flags;
#line 264
  flags = new___1;
#line 265
  return (old);
}
}
#line 268 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static char const   *romaji2kana_pass  =    "\t ";
#line 268 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static char const   *romaji2kana_omit  =    "\'";
#line 268 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
static char const   *romaji2kana_longvowel  =    "-^";
#line 273 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
char const   *r2k_setpass(char const   *new___1 ) 
{ 
  char const   *old ;

  {
#line 275
  old = romaji2kana_pass;
#line 276
  if (new___1) {
#line 277
    romaji2kana_pass = new___1;
  }
#line 278
  return (old);
}
}
#line 281 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
char const   *r2k_setomit(char const   *new___1 ) 
{ 
  char const   *old ;

  {
#line 283
  old = romaji2kana_omit;
#line 284
  if (new___1) {
#line 285
    romaji2kana_omit = new___1;
  }
#line 286
  return (old);
}
}
#line 289 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
char const   *r2k_setlongvowel(char const   *new___1 ) 
{ 
  char const   *old ;

  {
#line 291
  old = romaji2kana_longvowel;
#line 292
  if (new___1) {
#line 293
    romaji2kana_longvowel = new___1;
  }
#line 294
  return (old);
}
}
#line 301 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
__inline static char const   *is_char_in_string(char const   *str___0 , char const   c ) 
{ 


  {
#line 304
  if (str___0) {
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      if (! *(str___0 + 0)) {
#line 304
        goto while_break;
      }
#line 304
      if ((int const   )*(str___0 + 0) == (int const   )c) {
#line 305
        return (str___0);
      } else {
#line 307
        str___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 308
  return ((char const   *)0);
}
}
#line 324 "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c"
int romaji2kana(unsigned char const   *r , unsigned char const   *r_end , unsigned char *k ,
                unsigned int k_buf_len , struct romaji2kana_info *info ) 
{ 
  unsigned char const   *orig_k ;
  unsigned char last_hi ;
  unsigned char last_lo ;
  unsigned int badtranscount ;
  unsigned int modified ;
  unsigned int searchflags ;
  unsigned char bite[3] ;
  int bite_size ;
  int upper ;
  unsigned char value ;
  unsigned char value___0 ;
  unsigned char value___1 ;
  unsigned char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned char value___2 ;
  unsigned char value___3 ;
  unsigned char low ;
  unsigned char value___4 ;
  unsigned char value___5 ;
  char const   *tmp___2 ;
  unsigned char value___6 ;
  unsigned short const   **tmp___4 ;
  unsigned char value___7 ;
  unsigned char value___8 ;
  unsigned short const   **tmp___6 ;
  unsigned char value___9 ;
  unsigned short const   **tmp___7 ;
  char const   *tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  unsigned short const   **tmp___22 ;
  unsigned char const   *kana ;
  unsigned int max_kana_len ;
  int i ;
  int i___0 ;
  int i___1 ;
  unsigned short const   **tmp___23 ;
  unsigned char value___10 ;
  unsigned char const   *tmp___24 ;
  unsigned int hi___1 ;
  unsigned int lo ;
  unsigned char value___11 ;
  unsigned char value___12 ;
  unsigned char value___13 ;

  {
#line 330
  orig_k = (unsigned char const   *)k;
#line 331
  last_hi = (unsigned char)0;
#line 331
  last_lo = (unsigned char)0;
#line 332
  badtranscount = 0U;
#line 333
  modified = 0U;
#line 334
  searchflags = flags | 128U;
#line 336
  if ((unsigned long )r == (unsigned long )((unsigned char const   *)0)) {
#line 337
    return (-1);
  } else
#line 336
  if ((int const   )*r == 0) {
#line 337
    return (-1);
  } else
#line 336
  if (k) {
#line 336
    if (k_buf_len < 3U) {
#line 337
      return (-1);
    }
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! ((unsigned long )r < (unsigned long )r_end)) {
#line 358
      goto while_break;
    }
#line 364
    if (! (((int const   )*(r + 0) & -128) == 0)) {
#line 366
      if ((searchflags & 2U) == 0U) {
#line 367
        badtranscount ++;
      }
      {
#line 368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 368
        last_hi = (unsigned char )*(r + 0);
#line 368
        value = last_hi;
#line 368
        if (orig_k) {
#line 368
          if (k_buf_len == 0U) {
#line 368
            return (-2);
          }
#line 368
          k_buf_len --;
#line 368
          *k = value;
        }
#line 368
        k ++;
#line 368
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 369
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 369
        last_lo = (unsigned char )*(r + 1);
#line 369
        value___0 = last_lo;
#line 369
        if (orig_k) {
#line 369
          if (k_buf_len == 0U) {
#line 369
            return (-2);
          }
#line 369
          k_buf_len --;
#line 369
          *k = value___0;
        }
#line 369
        k ++;
#line 369
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 370
      r += 2;
#line 371
      goto while_continue;
    }
    {
#line 375
    tmp___0 = is_char_in_string(romaji2kana_pass, (char const   )*(r + 0));
    }
#line 375
    if (tmp___0) {
      {
#line 377
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 377
        tmp = r;
#line 377
        r ++;
#line 377
        value___1 = (unsigned char )*tmp;
#line 377
        if (orig_k) {
#line 377
          if (k_buf_len == 0U) {
#line 377
            return (-2);
          }
#line 377
          k_buf_len --;
#line 377
          *k = value___1;
        }
#line 377
        k ++;
#line 377
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 378
      last_hi = (unsigned char)0;
#line 379
      goto while_continue;
    }
    {
#line 383
    tmp___1 = is_char_in_string(romaji2kana_omit, (char const   )*(r + 0));
    }
#line 383
    if (tmp___1) {
#line 385
      modified = 1U;
#line 386
      last_hi = (unsigned char)0;
#line 387
      r ++;
#line 388
      goto while_continue;
    }
    {
#line 396
    tmp___2 = is_char_in_string(romaji2kana_longvowel, (char const   )*(r + 0));
    }
#line 396
    if (tmp___2) {
#line 401
      if ((int )last_hi == 165) {
        {
#line 403
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 403
          value___2 = (unsigned char )*((unsigned char const   *)"\241\274" + 0);
#line 403
          if (orig_k) {
#line 403
            if (k_buf_len == 0U) {
#line 403
              return (-2);
            }
#line 403
            k_buf_len --;
#line 403
            *k = value___2;
          }
#line 403
          k ++;
#line 403
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 404
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 404
          value___3 = (unsigned char )*((unsigned char const   *)"\241\274" + 1);
#line 404
          if (orig_k) {
#line 404
            if (k_buf_len == 0U) {
#line 404
              return (-2);
            }
#line 404
            k_buf_len --;
#line 404
            *k = value___3;
          }
#line 404
          k ++;
#line 404
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 405
        r ++;
#line 406
        last_hi = (unsigned char)0;
#line 407
        goto while_continue;
      }
#line 410
      if ((int )last_hi == 164) {
#line 412
        low = (unsigned char)0;
        {
#line 415
        if ((_KID[(int )last_lo - 161] & 31UL) == 1UL) {
#line 415
          goto case_1;
        }
#line 416
        if ((_KID[(int )last_lo - 161] & 31UL) == 2UL) {
#line 416
          goto case_2;
        }
#line 417
        if ((_KID[(int )last_lo - 161] & 31UL) == 4UL) {
#line 417
          goto case_4;
        }
#line 418
        if ((_KID[(int )last_lo - 161] & 31UL) == 8UL) {
#line 418
          goto case_8;
        }
#line 419
        if ((_KID[(int )last_lo - 161] & 31UL) == 16UL) {
#line 419
          goto case_16;
        }
#line 413
        goto switch_break;
        case_1: /* CIL Label */ 
#line 415
        low = (unsigned char )*((unsigned char const   *)"\244\242" + 1);
#line 415
        goto switch_break;
        case_2: /* CIL Label */ 
#line 416
        low = (unsigned char )*((unsigned char const   *)"\244\244" + 1);
#line 416
        goto switch_break;
        case_4: /* CIL Label */ 
#line 417
        low = (unsigned char )*((unsigned char const   *)"\244\246" + 1);
#line 417
        goto switch_break;
        case_8: /* CIL Label */ 
#line 418
        low = (unsigned char )*((unsigned char const   *)"\244\250" + 1);
#line 418
        goto switch_break;
        case_16: /* CIL Label */ 
#line 419
        low = (unsigned char )*((unsigned char const   *)"\244\252" + 1);
#line 419
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 421
        if (low) {
          {
#line 422
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 422
            value___4 = (unsigned char)164;
#line 422
            if (orig_k) {
#line 422
              if (k_buf_len == 0U) {
#line 422
                return (-2);
              }
#line 422
              k_buf_len --;
#line 422
              *k = value___4;
            }
#line 422
            k ++;
#line 422
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 423
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 423
            value___5 = low;
#line 423
            if (orig_k) {
#line 423
              if (k_buf_len == 0U) {
#line 423
                return (-2);
              }
#line 423
              k_buf_len --;
#line 423
              *k = value___5;
            }
#line 423
            k ++;
#line 423
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 424
          r ++;
#line 425
          last_hi = (unsigned char)0;
#line 426
          goto while_continue;
        }
      }
    }
#line 436
    if ((unsigned long )(r + 1) < (unsigned long )r_end) {
      {
#line 436
      tmp___7 = __ctype_b_loc();
      }
#line 436
      if ((int const   )*(*tmp___7 + (int )*(r + 1)) & 1024) {
#line 436
        if (((int const   )*(r + 1) & -128) == 0) {
          {
#line 436
          tmp___8 = is_char_in_string("aeiouAEIOU", (char const   )*(r + 0));
          }
#line 436
          if (! tmp___8) {
            {
#line 436
            tmp___12 = __ctype_b_loc();
            }
#line 436
            if ((int const   )*(*tmp___12 + (int )*(r + 0)) & 256) {
#line 436
              tmp___11 = (int const   )*(r + 0);
            } else {
              {
#line 436
              tmp___10 = tolower((int )*(r + 0));
#line 436
              tmp___11 = (int const   )tmp___10;
              }
            }
            {
#line 436
            tmp___16 = __ctype_b_loc();
            }
#line 436
            if ((int const   )*(*tmp___16 + (int )*(r + 1)) & 256) {
#line 436
              tmp___15 = (int const   )*(r + 1);
            } else {
              {
#line 436
              tmp___14 = tolower((int )*(r + 1));
#line 436
              tmp___15 = (int const   )tmp___14;
              }
            }
#line 436
            if (tmp___11 == tmp___15) {
#line 441
              if ((int const   )*(r + 0) == 110) {
#line 441
                goto _L;
              } else
#line 441
              if ((int const   )*(r + 0) == 78) {
                _L: /* CIL Label */ 
                {
#line 443
                while (1) {
                  while_continue___7: /* CIL Label */ ;
                  {
#line 443
                  tmp___4 = __ctype_b_loc();
                  }
#line 443
                  if ((int const   )*(*tmp___4 + (int )*(r + 0)) & 256) {
#line 443
                    last_hi = (unsigned char)165;
                  } else {
#line 443
                    last_hi = (unsigned char)164;
                  }
#line 443
                  value___6 = last_hi;
#line 443
                  if (orig_k) {
#line 443
                    if (k_buf_len == 0U) {
#line 443
                      return (-2);
                    }
#line 443
                    k_buf_len --;
#line 443
                    *k = value___6;
                  }
#line 443
                  k ++;
#line 443
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
                {
#line 444
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 444
                  last_lo = (unsigned char )*((unsigned char const   *)"\244\363" + 1);
#line 444
                  value___7 = last_lo;
#line 444
                  if (orig_k) {
#line 444
                    if (k_buf_len == 0U) {
#line 444
                      return (-2);
                    }
#line 444
                    k_buf_len --;
#line 444
                    *k = value___7;
                  }
#line 444
                  k ++;
#line 444
                  goto while_break___8;
                }
                while_break___8: /* CIL Label */ ;
                }
              } else {
                {
#line 446
                while (1) {
                  while_continue___9: /* CIL Label */ ;
                  {
#line 446
                  tmp___6 = __ctype_b_loc();
                  }
#line 446
                  if ((int const   )*(*tmp___6 + (int )*(r + 0)) & 256) {
#line 446
                    last_hi = (unsigned char)165;
                  } else {
#line 446
                    last_hi = (unsigned char)164;
                  }
#line 446
                  value___8 = last_hi;
#line 446
                  if (orig_k) {
#line 446
                    if (k_buf_len == 0U) {
#line 446
                      return (-2);
                    }
#line 446
                    k_buf_len --;
#line 446
                    *k = value___8;
                  }
#line 446
                  k ++;
#line 446
                  goto while_break___9;
                }
                while_break___9: /* CIL Label */ ;
                }
                {
#line 447
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 447
                  last_lo = (unsigned char )*((unsigned char const   *)"\245\303" + 1);
#line 447
                  value___9 = last_lo;
#line 447
                  if (orig_k) {
#line 447
                    if (k_buf_len == 0U) {
#line 447
                      return (-2);
                    }
#line 447
                    k_buf_len --;
#line 447
                    *k = value___9;
                  }
#line 447
                  k ++;
#line 447
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
              }
#line 449
              r ++;
#line 450
              goto while_continue;
            }
          }
        }
      }
    }
    {
#line 465
    tmp___17 = __ctype_b_loc();
#line 465
    upper = (int )((int const   )*(*tmp___17 + (int )*(r + 0)) & 256);
#line 467
    bite_size = 0;
    }
    {
#line 467
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 467
      if ((unsigned long )bite_size < sizeof(bite)) {
#line 467
        if ((unsigned long )(r + bite_size) < (unsigned long )r_end) {
#line 467
          if (((int const   )*(r + bite_size) & -128) == 0) {
            {
#line 467
            tmp___21 = __ctype_b_loc();
            }
#line 467
            if ((int const   )*(*tmp___21 + (int )*(r + bite_size)) & 1024) {
#line 467
              if (! (mode___0 != 0U)) {
                {
#line 467
                tmp___22 = __ctype_b_loc();
                }
#line 467
                if (! (upper == (int )((int const   )*(*tmp___22 + (int )*(r + bite_size)) & 256))) {
#line 467
                  goto while_break___11;
                }
              }
            } else {
#line 467
              goto while_break___11;
            }
          } else {
#line 467
            goto while_break___11;
          }
        } else {
#line 467
          goto while_break___11;
        }
      } else {
#line 467
        goto while_break___11;
      }
      {
#line 473
      tmp___20 = __ctype_b_loc();
      }
#line 473
      if ((int const   )*(*tmp___20 + (int )*(r + bite_size)) & 256) {
        {
#line 473
        tmp___19 = tolower((int )*(r + bite_size));
#line 473
        bite[bite_size] = (unsigned char )tmp___19;
        }
      } else {
#line 473
        bite[bite_size] = (unsigned char )*(r + bite_size);
      }
#line 467
      bite_size ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 513
    if (bite_size == 3) {
#line 513
      goto case_3;
    }
#line 518
    if (bite_size == 2) {
#line 518
      goto case_2___0;
    }
#line 522
    if (bite_size == 1) {
#line 522
      goto case_1___0;
    }
#line 525
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 513
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 513
      i = 0;
      {
#line 513
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 513
        if (! ((unsigned long )i < sizeof(romaji3) / sizeof(romaji3[0]))) {
#line 513
          goto while_break___13;
        }
#line 513
        if ((int const   )romaji3[i].romaji[0] == (int const   )bite[0]) {
#line 513
          if ((int const   )romaji3[i].romaji[1] == (int const   )bite[1]) {
#line 513
            if ((int const   )romaji3[i].romaji[2] == (int const   )bite[2]) {
#line 513
              if ((unsigned int )romaji3[i].flags & searchflags) {
#line 513
                kana = romaji3[i].kana;
#line 513
                max_kana_len = (unsigned int )sizeof(romaji3[0].kana);
#line 513
                r += sizeof(romaji3[0].romaji);
#line 513
                goto copy_matched_kana;
              }
            }
          }
        }
#line 513
        if ((int const   )romaji3[i].romaji[0] > (int const   )bite[0]) {
#line 513
          goto while_break___13;
        }
#line 513
        i ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 513
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    case_2___0: /* CIL Label */ 
    {
#line 518
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 518
      i___0 = 0;
      {
#line 518
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 518
        if (! ((unsigned long )i___0 < sizeof(romaji2) / sizeof(romaji2[0]))) {
#line 518
          goto while_break___15;
        }
#line 518
        if ((int const   )romaji2[i___0].romaji[0] == (int const   )bite[0]) {
#line 518
          if ((int const   )romaji2[i___0].romaji[1] == (int const   )bite[1]) {
#line 518
            if ((unsigned int )romaji2[i___0].flags & searchflags) {
#line 518
              kana = romaji2[i___0].kana;
#line 518
              max_kana_len = (unsigned int )sizeof(romaji2[0].kana);
#line 518
              r += sizeof(romaji2[0].romaji);
#line 518
              goto copy_matched_kana;
            }
          }
        }
#line 518
        if ((int const   )romaji2[i___0].romaji[0] > (int const   )bite[0]) {
#line 518
          goto while_break___15;
        }
#line 518
        i___0 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 518
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    case_1___0: /* CIL Label */ 
    {
#line 522
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 522
      i___1 = 0;
      {
#line 522
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 522
        if (! ((unsigned long )i___1 < sizeof(romaji1) / sizeof(romaji1[0]))) {
#line 522
          goto while_break___17;
        }
#line 522
        if ((int const   )romaji1[i___1].romaji[0] == (int const   )bite[0]) {
#line 522
          if ((unsigned int )romaji1[i___1].flags & searchflags) {
#line 522
            kana = romaji1[i___1].kana;
#line 522
            max_kana_len = (unsigned int )sizeof(romaji1[0].kana);
#line 522
            r += sizeof(romaji1[0].romaji);
#line 522
            goto copy_matched_kana;
          }
        }
#line 522
        if ((int const   )romaji1[i___1].romaji[0] > (int const   )bite[0]) {
#line 522
          goto while_break___17;
        }
#line 522
        i___1 ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 522
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    switch_default: /* CIL Label */ 
#line 527
    if ((searchflags & 1U) == 0U) {
#line 528
      badtranscount ++;
    } else {
      {
#line 527
      tmp___23 = __ctype_b_loc();
      }
#line 527
      if ((int const   )*(*tmp___23 + (int )*r) & 1024) {
#line 528
        badtranscount ++;
      }
    }
    {
#line 529
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 529
      tmp___24 = r;
#line 529
      r ++;
#line 529
      value___10 = (unsigned char )*tmp___24;
#line 529
      if (orig_k) {
#line 529
        if (k_buf_len == 0U) {
#line 529
          return (-2);
        }
#line 529
        k_buf_len --;
#line 529
        *k = value___10;
      }
#line 529
      k ++;
#line 529
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 530
    last_hi = (unsigned char)0;
#line 531
    goto switch_break___0;
    copy_matched_kana: 
    {
#line 534
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 534
      if (max_kana_len) {
#line 534
        if (! *(kana + 0)) {
#line 534
          goto while_break___19;
        }
      } else {
#line 534
        goto while_break___19;
      }
#line 536
      hi___1 = (unsigned int )*(kana + 0);
#line 536
      lo = (unsigned int )*(kana + 1);
      {
#line 537
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 537
        if (! (hi___1 == 164U)) {
#line 537
          if (! (hi___1 == 165U)) {
            {
#line 537
            die("\nassert(hi == KID_HIRA_HI || hi == KID_KATA_HI) failed \"%s\" line %d.\n",
                "/home/wheatley/newnew/temp/lookup-1.08b/lib/romaji2kana.c", 537);
            }
          }
        }
#line 537
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 538
      if (hi___1 == 164U) {
#line 540
        if (mode___0 == 1U) {
#line 541
          hi___1 = 164U;
        } else
#line 542
        if (mode___0 == 2U) {
#line 543
          hi___1 = 165U;
        } else
#line 545
        if (upper) {
#line 545
          hi___1 = 165U;
        } else {
#line 545
          hi___1 = 164U;
        }
      }
#line 547
      last_hi = (unsigned char )hi___1;
#line 548
      last_lo = (unsigned char )lo;
#line 549
      modified = 1U;
      {
#line 550
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 550
        value___11 = (unsigned char )hi___1;
#line 550
        if (orig_k) {
#line 550
          if (k_buf_len == 0U) {
#line 550
            return (-2);
          }
#line 550
          k_buf_len --;
#line 550
          *k = value___11;
        }
#line 550
        k ++;
#line 550
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 551
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 551
        value___12 = (unsigned char )lo;
#line 551
        if (orig_k) {
#line 551
          if (k_buf_len == 0U) {
#line 551
            return (-2);
          }
#line 551
          k_buf_len --;
#line 551
          *k = value___12;
        }
#line 551
        k ++;
#line 551
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 553
      max_kana_len -= 2U;
#line 554
      kana += 2;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 556
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 559
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 559
    value___13 = (unsigned char)0;
#line 559
    if (orig_k) {
#line 559
      if (k_buf_len == 0U) {
#line 559
        return (-2);
      }
#line 559
      k_buf_len --;
#line 559
      *k = value___13;
    }
#line 559
    k ++;
#line 559
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 561
  if ((unsigned long )info != (unsigned long )((struct romaji2kana_info *)0)) {
#line 563
    info->k_buf_used = (unsigned short )(k - (unsigned char *)orig_k);
#line 564
    info->modified = (unsigned short )modified;
  }
#line 574
  return ((int )badtranscount);
}
}
#line 53 "/home/wheatley/newnew/temp/lookup-1.08b/lib/fuzzkana.c"
unsigned int fuzzkana(unsigned char const   *in , unsigned char *out , unsigned int out_size ,
                      unsigned int flags___0 ) 
{ 
  unsigned char const   *orig_out ;
  unsigned char const   *out_end ;
  unsigned char hi___1 ;
  unsigned char lo ;
  int just_want_size ;
  int do_voiced ;
  int do_vowels ;
  int do_tsu ;
  int do_repeat ;
  unsigned int next_id ;
  unsigned int vsound ;
  unsigned int id ;
  unsigned char value ;
  unsigned char *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char value___0 ;
  unsigned char *tmp___1 ;
  unsigned char value___1 ;
  unsigned char *tmp___2 ;
  unsigned char const   *str___0 ;
  char const   *tmp___3 ;
  unsigned char value___2 ;
  unsigned char const   *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char const   *str___1 ;
  char const   *tmp___6 ;
  unsigned char value___3 ;
  unsigned char const   *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char const   *str___2 ;
  char const   *tmp___9 ;
  unsigned char value___4 ;
  unsigned char const   *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char const   *str___3 ;
  char const   *tmp___12 ;
  unsigned char value___5 ;
  unsigned char const   *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char value___6 ;
  unsigned char *tmp___15 ;
  unsigned char value___7 ;
  unsigned char *tmp___16 ;
  unsigned char const   *str___4 ;
  unsigned char value___8 ;
  unsigned char const   *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char const   *str___5 ;
  unsigned char value___9 ;
  unsigned char const   *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char const   *str___6 ;
  unsigned char value___10 ;
  unsigned char const   *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char const   *str___7 ;
  unsigned char value___11 ;
  unsigned char const   *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char const   *str___8 ;
  unsigned char value___12 ;
  unsigned char const   *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char const   *str___9 ;
  unsigned char value___13 ;
  unsigned char const   *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char const   *str___10 ;
  unsigned char value___14 ;
  unsigned char const   *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char const   *str___11 ;
  unsigned char value___15 ;
  unsigned char const   *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char const   *str___12 ;
  unsigned char value___16 ;
  unsigned char const   *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char const   *str___13 ;
  unsigned char value___17 ;
  unsigned char const   *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned int next_is_small_tsu ;
  unsigned char const   *str___14 ;
  unsigned char value___18 ;
  unsigned char const   *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char const   *tmp___39 ;
  unsigned char value___19 ;
  unsigned char *tmp___40 ;

  {
#line 58
  orig_out = (unsigned char const   *)out;
#line 59
  out_end = (unsigned char const   *)(out + out_size);
#line 61
  just_want_size = (unsigned long )out == (unsigned long )((unsigned char *)0);
#line 62
  do_voiced = (int )(flags___0 & 4U);
#line 63
  do_vowels = (int )(flags___0 & 1U);
#line 64
  do_tsu = (int )(flags___0 & 2U);
#line 66
  do_repeat = (int )(flags___0 & 8U);
#line 69
  if ((unsigned long )in == (unsigned long )((unsigned char const   *)0)) {
#line 70
    return (0U);
  } else
#line 69
  if ((int const   )*in == 0) {
#line 70
    return (0U);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    tmp___39 = in;
#line 100
    in ++;
#line 100
    hi___1 = (unsigned char )*tmp___39;
#line 100
    if (! ((int )hi___1 != 0)) {
#line 100
      goto while_break;
    }
#line 107
    if (! ((int )hi___1 & 128)) {
      {
#line 109
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 109
        value = hi___1;
#line 109
        if (just_want_size) {
#line 109
          out ++;
        } else {
#line 109
          if ((unsigned long )out >= (unsigned long )out_end) {
#line 109
            return (0U);
          }
#line 109
          tmp = out;
#line 109
          out ++;
#line 109
          *tmp = value;
        }
#line 109
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 110
      goto while_continue;
    }
#line 113
    tmp___0 = in;
#line 113
    in ++;
#line 113
    lo = (unsigned char )*tmp___0;
#line 117
    if ((int )hi___1 == 165) {
#line 117
      if ((int )lo >= 161) {
#line 117
        if (! ((int )lo <= 246)) {
#line 117
          goto _L___2;
        }
      } else {
#line 117
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 117
    if ((int )hi___1 == 164) {
#line 117
      if ((int )lo >= 161) {
#line 117
        if (! ((int )lo <= 246)) {
#line 117
          goto _L___0;
        }
      } else {
#line 117
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 120
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 120
        value___0 = hi___1;
#line 120
        if (just_want_size) {
#line 120
          out ++;
        } else {
#line 120
          if ((unsigned long )out >= (unsigned long )out_end) {
#line 120
            return (0U);
          }
#line 120
          tmp___1 = out;
#line 120
          out ++;
#line 120
          *tmp___1 = value___0;
        }
#line 120
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 121
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 121
        value___1 = lo;
#line 121
        if (just_want_size) {
#line 121
          out ++;
        } else {
#line 121
          if ((unsigned long )out >= (unsigned long )out_end) {
#line 121
            return (0U);
          }
#line 121
          tmp___2 = out;
#line 121
          out ++;
#line 121
          *tmp___2 = value___1;
        }
#line 121
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 139
      goto while_continue;
    }
#line 142
    id = (unsigned int )_KID[(int )lo - 161];
#line 145
    if (do_voiced) {
#line 145
      if (id & 33554432U) {
        {
#line 154
        if (id == 50331648U) {
#line 154
          goto case_50331648;
        }
#line 154
        if (id == 37748744U) {
#line 154
          goto case_50331648;
        }
#line 158
        if (id == 34078720U) {
#line 158
          goto case_34078720;
        }
#line 158
        if (id == 37748752U) {
#line 158
          goto case_34078720;
        }
#line 163
        if (id == 33555458U) {
#line 163
          goto case_33555458;
        }
#line 163
        if (id == 33554690U) {
#line 163
          goto case_33555458;
        }
#line 168
        if (id == 33554692U) {
#line 168
          goto case_33554692;
        }
#line 168
        if (id == 33555460U) {
#line 168
          goto case_33554692;
        }
#line 149
        goto switch_default;
        switch_default: /* CIL Label */ 
        {
#line 150
        die("oops, %02x %02x -> id is %x\n", (int )hi___1, (int )lo, id);
        }
#line 151
        goto switch_break;
        case_50331648: /* CIL Label */ 
        case_37748744: /* CIL Label */ 
        {
#line 155
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 155
          if ((int )hi___1 == 164) {
#line 155
            if ((int )lo >= 161) {
#line 155
              if ((int )lo <= 246) {
#line 155
                tmp___3 = "[\244\250\244\361]";
              } else {
#line 155
                tmp___3 = "[\245\250\245\361]";
              }
            } else {
#line 155
              tmp___3 = "[\245\250\245\361]";
            }
          } else {
#line 155
            tmp___3 = "[\245\250\245\361]";
          }
#line 155
          str___0 = (unsigned char const   *)tmp___3;
          {
#line 155
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 155
            if (! *str___0) {
#line 155
              goto while_break___4;
            }
            {
#line 155
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 155
              tmp___4 = str___0;
#line 155
              str___0 ++;
#line 155
              value___2 = (unsigned char )*tmp___4;
#line 155
              if (just_want_size) {
#line 155
                out ++;
              } else {
#line 155
                if ((unsigned long )out >= (unsigned long )out_end) {
#line 155
                  return (0U);
                }
#line 155
                tmp___5 = out;
#line 155
                out ++;
#line 155
                *tmp___5 = value___2;
              }
#line 155
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 155
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 156
        goto switch_break;
        case_34078720: /* CIL Label */ 
        case_37748752: /* CIL Label */ 
        {
#line 159
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 159
          if ((int )hi___1 == 164) {
#line 159
            if ((int )lo >= 161) {
#line 159
              if ((int )lo <= 246) {
#line 159
                tmp___6 = "[\244\252\244\362]";
              } else {
#line 159
                tmp___6 = "[\245\252\245\362]";
              }
            } else {
#line 159
              tmp___6 = "[\245\252\245\362]";
            }
          } else {
#line 159
            tmp___6 = "[\245\252\245\362]";
          }
#line 159
          str___1 = (unsigned char const   *)tmp___6;
          {
#line 159
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 159
            if (! *str___1) {
#line 159
              goto while_break___7;
            }
            {
#line 159
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 159
              tmp___7 = str___1;
#line 159
              str___1 ++;
#line 159
              value___3 = (unsigned char )*tmp___7;
#line 159
              if (just_want_size) {
#line 159
                out ++;
              } else {
#line 159
                if ((unsigned long )out >= (unsigned long )out_end) {
#line 159
                  return (0U);
                }
#line 159
                tmp___8 = out;
#line 159
                out ++;
#line 159
                *tmp___8 = value___3;
              }
#line 159
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 159
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 160
        goto switch_break;
        case_33555458: /* CIL Label */ 
        case_33554690: /* CIL Label */ 
        {
#line 164
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 164
          if ((int )hi___1 == 164) {
#line 164
            if ((int )lo >= 161) {
#line 164
              if ((int )lo <= 246) {
#line 164
                tmp___9 = "[\244\270\244\302]";
              } else {
#line 164
                tmp___9 = "[\245\270\245\302]";
              }
            } else {
#line 164
              tmp___9 = "[\245\270\245\302]";
            }
          } else {
#line 164
            tmp___9 = "[\245\270\245\302]";
          }
#line 164
          str___2 = (unsigned char const   *)tmp___9;
          {
#line 164
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 164
            if (! *str___2) {
#line 164
              goto while_break___10;
            }
            {
#line 164
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 164
              tmp___10 = str___2;
#line 164
              str___2 ++;
#line 164
              value___4 = (unsigned char )*tmp___10;
#line 164
              if (just_want_size) {
#line 164
                out ++;
              } else {
#line 164
                if ((unsigned long )out >= (unsigned long )out_end) {
#line 164
                  return (0U);
                }
#line 164
                tmp___11 = out;
#line 164
                out ++;
#line 164
                *tmp___11 = value___4;
              }
#line 164
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
#line 164
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 165
        goto switch_break;
        case_33554692: /* CIL Label */ 
        case_33555460: /* CIL Label */ 
        {
#line 169
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 169
          if ((int )hi___1 == 164) {
#line 169
            if ((int )lo >= 161) {
#line 169
              if ((int )lo <= 246) {
#line 169
                tmp___12 = "[\244\305\244\272]";
              } else {
#line 169
                tmp___12 = "[\245\305\245\272]";
              }
            } else {
#line 169
              tmp___12 = "[\245\305\245\272]";
            }
          } else {
#line 169
            tmp___12 = "[\245\305\245\272]";
          }
#line 169
          str___3 = (unsigned char const   *)tmp___12;
          {
#line 169
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 169
            if (! *str___3) {
#line 169
              goto while_break___13;
            }
            {
#line 169
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 169
              tmp___13 = str___3;
#line 169
              str___3 ++;
#line 169
              value___5 = (unsigned char )*tmp___13;
#line 169
              if (just_want_size) {
#line 169
                out ++;
              } else {
#line 169
                if ((unsigned long )out >= (unsigned long )out_end) {
#line 169
                  return (0U);
                }
#line 169
                tmp___14 = out;
#line 169
                out ++;
#line 169
                *tmp___14 = value___5;
              }
#line 169
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
          }
          while_break___13: /* CIL Label */ ;
          }
#line 169
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 170
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 145
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 174
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 174
        value___6 = hi___1;
#line 174
        if (just_want_size) {
#line 174
          out ++;
        } else {
#line 174
          if ((unsigned long )out >= (unsigned long )out_end) {
#line 174
            return (0U);
          }
#line 174
          tmp___15 = out;
#line 174
          out ++;
#line 174
          *tmp___15 = value___6;
        }
#line 174
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 175
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 175
        value___7 = lo;
#line 175
        if (just_want_size) {
#line 175
          out ++;
        } else {
#line 175
          if ((unsigned long )out >= (unsigned long )out_end) {
#line 175
            return (0U);
          }
#line 175
          tmp___16 = out;
#line 175
          out ++;
#line 175
          *tmp___16 = value___7;
        }
#line 175
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 178
    vsound = id & 31U;
    {
#line 192
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 192
      if (! ((int const   )*(in + 0) & 128)) {
#line 192
        next_id = 0U;
      } else
#line 192
      if ((int const   )*(in + 0) == 161) {
#line 192
        if ((int const   )*(in + 1) == 188) {
#line 192
          next_id = vsound | 4194304U;
        } else {
#line 192
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 192
      if ((int const   )*(in + 0) == 165) {
#line 192
        if ((int const   )*(in + 1) >= 161) {
#line 192
          if ((int const   )*(in + 1) <= 246) {
#line 192
            next_id = (unsigned int )_KID[(int const   )*(in + 1) - 161];
          } else {
#line 192
            goto _L___5;
          }
        } else {
#line 192
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 192
      if ((int const   )*(in + 0) == 164) {
#line 192
        if ((int const   )*(in + 1) >= 161) {
#line 192
          if ((int const   )*(in + 1) <= 246) {
#line 192
            next_id = (unsigned int )_KID[(int const   )*(in + 1) - 161];
          } else {
#line 192
            next_id = 0U;
          }
        } else {
#line 192
          next_id = 0U;
        }
      } else {
#line 192
        next_id = 0U;
      }
#line 192
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 201
    if (do_vowels) {
#line 207
      if (vsound) {
#line 207
        if ((next_id & 2162688U) != 2162688U) {
#line 214
          if ((int )hi___1 == 164) {
#line 214
            if ((int )lo >= 161) {
#line 214
              if ((int )lo <= 246) {
                {
#line 217
                if (vsound == 1U) {
#line 217
                  goto case_1;
                }
#line 218
                if (vsound == 2U) {
#line 218
                  goto case_2;
                }
#line 219
                if (vsound == 4U) {
#line 219
                  goto case_4;
                }
#line 220
                if (vsound == 16U) {
#line 220
                  goto case_16;
                }
#line 221
                if (vsound == 8U) {
#line 221
                  goto case_8;
                }
#line 216
                goto switch_default___0;
                switch_default___0: /* CIL Label */ 
                {
#line 216
                while (1) {
                  while_continue___18: /* CIL Label */ ;
                  {
#line 216
                  die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/fuzzkana.c",
                      216);
                  }
#line 216
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
#line 216
                goto switch_break___0;
                case_1: /* CIL Label */ 
                {
#line 217
                while (1) {
                  while_continue___19: /* CIL Label */ ;
#line 217
                  str___4 = (unsigned char const   *)"[\244\241\244\242\241\274]*";
                  {
#line 217
                  while (1) {
                    while_continue___20: /* CIL Label */ ;
#line 217
                    if (! *str___4) {
#line 217
                      goto while_break___20;
                    }
                    {
#line 217
                    while (1) {
                      while_continue___21: /* CIL Label */ ;
#line 217
                      tmp___17 = str___4;
#line 217
                      str___4 ++;
#line 217
                      value___8 = (unsigned char )*tmp___17;
#line 217
                      if (just_want_size) {
#line 217
                        out ++;
                      } else {
#line 217
                        if ((unsigned long )out >= (unsigned long )out_end) {
#line 217
                          return (0U);
                        }
#line 217
                        tmp___18 = out;
#line 217
                        out ++;
#line 217
                        *tmp___18 = value___8;
                      }
#line 217
                      goto while_break___21;
                    }
                    while_break___21: /* CIL Label */ ;
                    }
                  }
                  while_break___20: /* CIL Label */ ;
                  }
#line 217
                  goto while_break___19;
                }
                while_break___19: /* CIL Label */ ;
                }
#line 217
                goto switch_break___0;
                case_2: /* CIL Label */ 
                {
#line 218
                while (1) {
                  while_continue___22: /* CIL Label */ ;
#line 218
                  str___5 = (unsigned char const   *)"[\244\243\244\244\241\274]*";
                  {
#line 218
                  while (1) {
                    while_continue___23: /* CIL Label */ ;
#line 218
                    if (! *str___5) {
#line 218
                      goto while_break___23;
                    }
                    {
#line 218
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 218
                      tmp___19 = str___5;
#line 218
                      str___5 ++;
#line 218
                      value___9 = (unsigned char )*tmp___19;
#line 218
                      if (just_want_size) {
#line 218
                        out ++;
                      } else {
#line 218
                        if ((unsigned long )out >= (unsigned long )out_end) {
#line 218
                          return (0U);
                        }
#line 218
                        tmp___20 = out;
#line 218
                        out ++;
#line 218
                        *tmp___20 = value___9;
                      }
#line 218
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
                  while_break___23: /* CIL Label */ ;
                  }
#line 218
                  goto while_break___22;
                }
                while_break___22: /* CIL Label */ ;
                }
#line 218
                goto switch_break___0;
                case_4: /* CIL Label */ 
                {
#line 219
                while (1) {
                  while_continue___25: /* CIL Label */ ;
#line 219
                  str___6 = (unsigned char const   *)"[\244\245\244\246\241\274]*";
                  {
#line 219
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 219
                    if (! *str___6) {
#line 219
                      goto while_break___26;
                    }
                    {
#line 219
                    while (1) {
                      while_continue___27: /* CIL Label */ ;
#line 219
                      tmp___21 = str___6;
#line 219
                      str___6 ++;
#line 219
                      value___10 = (unsigned char )*tmp___21;
#line 219
                      if (just_want_size) {
#line 219
                        out ++;
                      } else {
#line 219
                        if ((unsigned long )out >= (unsigned long )out_end) {
#line 219
                          return (0U);
                        }
#line 219
                        tmp___22 = out;
#line 219
                        out ++;
#line 219
                        *tmp___22 = value___10;
                      }
#line 219
                      goto while_break___27;
                    }
                    while_break___27: /* CIL Label */ ;
                    }
                  }
                  while_break___26: /* CIL Label */ ;
                  }
#line 219
                  goto while_break___25;
                }
                while_break___25: /* CIL Label */ ;
                }
#line 219
                goto switch_break___0;
                case_16: /* CIL Label */ 
                {
#line 220
                while (1) {
                  while_continue___28: /* CIL Label */ ;
#line 220
                  str___7 = (unsigned char const   *)"[\244\245\244\246\244\252\244\251\244\362\241\274]*";
                  {
#line 220
                  while (1) {
                    while_continue___29: /* CIL Label */ ;
#line 220
                    if (! *str___7) {
#line 220
                      goto while_break___29;
                    }
                    {
#line 220
                    while (1) {
                      while_continue___30: /* CIL Label */ ;
#line 220
                      tmp___23 = str___7;
#line 220
                      str___7 ++;
#line 220
                      value___11 = (unsigned char )*tmp___23;
#line 220
                      if (just_want_size) {
#line 220
                        out ++;
                      } else {
#line 220
                        if ((unsigned long )out >= (unsigned long )out_end) {
#line 220
                          return (0U);
                        }
#line 220
                        tmp___24 = out;
#line 220
                        out ++;
#line 220
                        *tmp___24 = value___11;
                      }
#line 220
                      goto while_break___30;
                    }
                    while_break___30: /* CIL Label */ ;
                    }
                  }
                  while_break___29: /* CIL Label */ ;
                  }
#line 220
                  goto while_break___28;
                }
                while_break___28: /* CIL Label */ ;
                }
#line 220
                vsound |= 4U;
#line 220
                goto switch_break___0;
                case_8: /* CIL Label */ 
                {
#line 221
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 221
                  str___8 = (unsigned char const   *)"[\244\247\244\250\244\361\241\274]*";
                  {
#line 221
                  while (1) {
                    while_continue___32: /* CIL Label */ ;
#line 221
                    if (! *str___8) {
#line 221
                      goto while_break___32;
                    }
                    {
#line 221
                    while (1) {
                      while_continue___33: /* CIL Label */ ;
#line 221
                      tmp___25 = str___8;
#line 221
                      str___8 ++;
#line 221
                      value___12 = (unsigned char )*tmp___25;
#line 221
                      if (just_want_size) {
#line 221
                        out ++;
                      } else {
#line 221
                        if ((unsigned long )out >= (unsigned long )out_end) {
#line 221
                          return (0U);
                        }
#line 221
                        tmp___26 = out;
#line 221
                        out ++;
#line 221
                        *tmp___26 = value___12;
                      }
#line 221
                      goto while_break___33;
                    }
                    while_break___33: /* CIL Label */ ;
                    }
                  }
                  while_break___32: /* CIL Label */ ;
                  }
#line 221
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
#line 221
                goto switch_break___0;
                switch_break___0: /* CIL Label */ ;
                }
              } else {
#line 214
                goto _L___8;
              }
            } else {
#line 214
              goto _L___8;
            }
          } else {
            _L___8: /* CIL Label */ 
            {
#line 226
            if (vsound == 1U) {
#line 226
              goto case_1___0;
            }
#line 227
            if (vsound == 2U) {
#line 227
              goto case_2___0;
            }
#line 228
            if (vsound == 4U) {
#line 228
              goto case_4___0;
            }
#line 229
            if (vsound == 16U) {
#line 229
              goto case_16___0;
            }
#line 230
            if (vsound == 8U) {
#line 230
              goto case_8___0;
            }
#line 225
            goto switch_default___1;
            switch_default___1: /* CIL Label */ 
            {
#line 225
            while (1) {
              while_continue___34: /* CIL Label */ ;
              {
#line 225
              die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/fuzzkana.c",
                  225);
              }
#line 225
              goto while_break___34;
            }
            while_break___34: /* CIL Label */ ;
            }
#line 225
            goto switch_break___1;
            case_1___0: /* CIL Label */ 
            {
#line 226
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 226
              str___9 = (unsigned char const   *)"[\245\241\245\242\241\274]*";
              {
#line 226
              while (1) {
                while_continue___36: /* CIL Label */ ;
#line 226
                if (! *str___9) {
#line 226
                  goto while_break___36;
                }
                {
#line 226
                while (1) {
                  while_continue___37: /* CIL Label */ ;
#line 226
                  tmp___27 = str___9;
#line 226
                  str___9 ++;
#line 226
                  value___13 = (unsigned char )*tmp___27;
#line 226
                  if (just_want_size) {
#line 226
                    out ++;
                  } else {
#line 226
                    if ((unsigned long )out >= (unsigned long )out_end) {
#line 226
                      return (0U);
                    }
#line 226
                    tmp___28 = out;
#line 226
                    out ++;
#line 226
                    *tmp___28 = value___13;
                  }
#line 226
                  goto while_break___37;
                }
                while_break___37: /* CIL Label */ ;
                }
              }
              while_break___36: /* CIL Label */ ;
              }
#line 226
              goto while_break___35;
            }
            while_break___35: /* CIL Label */ ;
            }
#line 226
            goto switch_break___1;
            case_2___0: /* CIL Label */ 
            {
#line 227
            while (1) {
              while_continue___38: /* CIL Label */ ;
#line 227
              str___10 = (unsigned char const   *)"[\245\243\245\244\241\274]*";
              {
#line 227
              while (1) {
                while_continue___39: /* CIL Label */ ;
#line 227
                if (! *str___10) {
#line 227
                  goto while_break___39;
                }
                {
#line 227
                while (1) {
                  while_continue___40: /* CIL Label */ ;
#line 227
                  tmp___29 = str___10;
#line 227
                  str___10 ++;
#line 227
                  value___14 = (unsigned char )*tmp___29;
#line 227
                  if (just_want_size) {
#line 227
                    out ++;
                  } else {
#line 227
                    if ((unsigned long )out >= (unsigned long )out_end) {
#line 227
                      return (0U);
                    }
#line 227
                    tmp___30 = out;
#line 227
                    out ++;
#line 227
                    *tmp___30 = value___14;
                  }
#line 227
                  goto while_break___40;
                }
                while_break___40: /* CIL Label */ ;
                }
              }
              while_break___39: /* CIL Label */ ;
              }
#line 227
              goto while_break___38;
            }
            while_break___38: /* CIL Label */ ;
            }
#line 227
            goto switch_break___1;
            case_4___0: /* CIL Label */ 
            {
#line 228
            while (1) {
              while_continue___41: /* CIL Label */ ;
#line 228
              str___11 = (unsigned char const   *)"[\245\245\245\246\241\274]*";
              {
#line 228
              while (1) {
                while_continue___42: /* CIL Label */ ;
#line 228
                if (! *str___11) {
#line 228
                  goto while_break___42;
                }
                {
#line 228
                while (1) {
                  while_continue___43: /* CIL Label */ ;
#line 228
                  tmp___31 = str___11;
#line 228
                  str___11 ++;
#line 228
                  value___15 = (unsigned char )*tmp___31;
#line 228
                  if (just_want_size) {
#line 228
                    out ++;
                  } else {
#line 228
                    if ((unsigned long )out >= (unsigned long )out_end) {
#line 228
                      return (0U);
                    }
#line 228
                    tmp___32 = out;
#line 228
                    out ++;
#line 228
                    *tmp___32 = value___15;
                  }
#line 228
                  goto while_break___43;
                }
                while_break___43: /* CIL Label */ ;
                }
              }
              while_break___42: /* CIL Label */ ;
              }
#line 228
              goto while_break___41;
            }
            while_break___41: /* CIL Label */ ;
            }
#line 228
            goto switch_break___1;
            case_16___0: /* CIL Label */ 
            {
#line 229
            while (1) {
              while_continue___44: /* CIL Label */ ;
#line 229
              str___12 = (unsigned char const   *)"[\245\245\245\246\245\252\245\251\245\362\241\274]*";
              {
#line 229
              while (1) {
                while_continue___45: /* CIL Label */ ;
#line 229
                if (! *str___12) {
#line 229
                  goto while_break___45;
                }
                {
#line 229
                while (1) {
                  while_continue___46: /* CIL Label */ ;
#line 229
                  tmp___33 = str___12;
#line 229
                  str___12 ++;
#line 229
                  value___16 = (unsigned char )*tmp___33;
#line 229
                  if (just_want_size) {
#line 229
                    out ++;
                  } else {
#line 229
                    if ((unsigned long )out >= (unsigned long )out_end) {
#line 229
                      return (0U);
                    }
#line 229
                    tmp___34 = out;
#line 229
                    out ++;
#line 229
                    *tmp___34 = value___16;
                  }
#line 229
                  goto while_break___46;
                }
                while_break___46: /* CIL Label */ ;
                }
              }
              while_break___45: /* CIL Label */ ;
              }
#line 229
              goto while_break___44;
            }
            while_break___44: /* CIL Label */ ;
            }
#line 229
            vsound |= 4U;
#line 229
            goto switch_break___1;
            case_8___0: /* CIL Label */ 
            {
#line 230
            while (1) {
              while_continue___47: /* CIL Label */ ;
#line 230
              str___13 = (unsigned char const   *)"[\245\247\245\250\245\361\241\274]*";
              {
#line 230
              while (1) {
                while_continue___48: /* CIL Label */ ;
#line 230
                if (! *str___13) {
#line 230
                  goto while_break___48;
                }
                {
#line 230
                while (1) {
                  while_continue___49: /* CIL Label */ ;
#line 230
                  tmp___35 = str___13;
#line 230
                  str___13 ++;
#line 230
                  value___17 = (unsigned char )*tmp___35;
#line 230
                  if (just_want_size) {
#line 230
                    out ++;
                  } else {
#line 230
                    if ((unsigned long )out >= (unsigned long )out_end) {
#line 230
                      return (0U);
                    }
#line 230
                    tmp___36 = out;
#line 230
                    out ++;
#line 230
                    *tmp___36 = value___17;
                  }
#line 230
                  goto while_break___49;
                }
                while_break___49: /* CIL Label */ ;
                }
              }
              while_break___48: /* CIL Label */ ;
              }
#line 230
              goto while_break___47;
            }
            while_break___47: /* CIL Label */ ;
            }
#line 230
            goto switch_break___1;
            switch_break___1: /* CIL Label */ ;
            }
          }
          {
#line 243
          while (1) {
            while_continue___50: /* CIL Label */ ;
#line 243
            if (next_id & 4194304U) {
#line 243
              if (! (next_id & vsound)) {
#line 243
                goto while_break___50;
              }
            } else {
#line 243
              goto while_break___50;
            }
#line 245
            in += 2;
            {
#line 246
            while (1) {
              while_continue___51: /* CIL Label */ ;
#line 246
              if (! ((int const   )*(in + 0) & 128)) {
#line 246
                next_id = 0U;
              } else
#line 246
              if ((int const   )*(in + 0) == 161) {
#line 246
                if ((int const   )*(in + 1) == 188) {
#line 246
                  next_id = vsound | 4194304U;
                } else {
#line 246
                  goto _L___11;
                }
              } else
              _L___11: /* CIL Label */ 
#line 246
              if ((int const   )*(in + 0) == 165) {
#line 246
                if ((int const   )*(in + 1) >= 161) {
#line 246
                  if ((int const   )*(in + 1) <= 246) {
#line 246
                    next_id = (unsigned int )_KID[(int const   )*(in + 1) - 161];
                  } else {
#line 246
                    goto _L___10;
                  }
                } else {
#line 246
                  goto _L___10;
                }
              } else
              _L___10: /* CIL Label */ 
#line 246
              if ((int const   )*(in + 0) == 164) {
#line 246
                if ((int const   )*(in + 1) >= 161) {
#line 246
                  if ((int const   )*(in + 1) <= 246) {
#line 246
                    next_id = (unsigned int )_KID[(int const   )*(in + 1) - 161];
                  } else {
#line 246
                    next_id = 0U;
                  }
                } else {
#line 246
                  next_id = 0U;
                }
              } else {
#line 246
                next_id = 0U;
              }
#line 246
              goto while_break___51;
            }
            while_break___51: /* CIL Label */ ;
            }
          }
          while_break___50: /* CIL Label */ ;
          }
        }
      }
    }
#line 251
    if (do_tsu) {
#line 253
      next_is_small_tsu = (unsigned int )((next_id & 2097668U) == 2097668U);
#line 268
      if (next_is_small_tsu) {
#line 268
        goto _L___12;
      } else
#line 268
      if (vsound) {
#line 268
        if (next_id & 312992U) {
#line 268
          if (! (next_id & 2097152U)) {
            _L___12: /* CIL Label */ 
            {
#line 272
            while (1) {
              while_continue___52: /* CIL Label */ ;
#line 272
              str___14 = (unsigned char const   *)"\244\303?";
              {
#line 272
              while (1) {
                while_continue___53: /* CIL Label */ ;
#line 272
                if (! *str___14) {
#line 272
                  goto while_break___53;
                }
                {
#line 272
                while (1) {
                  while_continue___54: /* CIL Label */ ;
#line 272
                  tmp___37 = str___14;
#line 272
                  str___14 ++;
#line 272
                  value___18 = (unsigned char )*tmp___37;
#line 272
                  if (just_want_size) {
#line 272
                    out ++;
                  } else {
#line 272
                    if ((unsigned long )out >= (unsigned long )out_end) {
#line 272
                      return (0U);
                    }
#line 272
                    tmp___38 = out;
#line 272
                    out ++;
#line 272
                    *tmp___38 = value___18;
                  }
#line 272
                  goto while_break___54;
                }
                while_break___54: /* CIL Label */ ;
                }
              }
              while_break___53: /* CIL Label */ ;
              }
#line 272
              goto while_break___52;
            }
            while_break___52: /* CIL Label */ ;
            }
#line 273
            if (next_is_small_tsu) {
#line 274
              in += 2;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  while (1) {
    while_continue___55: /* CIL Label */ ;
#line 278
    value___19 = (unsigned char)0;
#line 278
    if (just_want_size) {
#line 278
      out ++;
    } else {
#line 278
      if ((unsigned long )out >= (unsigned long )out_end) {
#line 278
        return (0U);
      }
#line 278
      tmp___40 = out;
#line 278
      out ++;
#line 278
      *tmp___40 = value___19;
    }
#line 278
    goto while_break___55;
  }
  while_break___55: /* CIL Label */ ;
  }
#line 279
  return ((unsigned int )(out - (unsigned char *)orig_out));
}
}
#line 29 "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.h"
unsigned char *sub(unsigned char const   *str___0 , unsigned int stringlen , unsigned char const   *pattern ,
                   unsigned char const   *replace , unsigned int flags___0 , unsigned int times ) ;
#line 19 "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.c"
static unsigned int _apply_substitution(regex_t const   *compiled , unsigned char **new___1 ,
                                        unsigned char **new_end_match , unsigned char const   *str___0 ,
                                        unsigned int str_len , unsigned char const   *startsearch ,
                                        unsigned char const   *replace ) 
{ 
  unsigned char *nptr ;
  unsigned char *new_end ;
  unsigned int required_len ;
  unsigned char const   *ptr ;
  int i ;
  unsigned int tmp ;
  unsigned char c ;
  unsigned short const   **tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  unsigned char const   *sptr ;
  unsigned char *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char c___0 ;
  unsigned char *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *sptr___0 ;
  unsigned char *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char const   *tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned char const   *sptr___1 ;
  unsigned char *tmp___12 ;
  unsigned char const   *tmp___13 ;
  unsigned char const   *sptr___2 ;
  unsigned char *tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned char *tmp___16 ;

  {
#line 30
  ptr = replace;
#line 33
  if (regexec_paren_info_size < (unsigned int )compiled->max_paren_level) {
#line 34
    return (100U);
  }
  {
#line 37
  tmp = regexec(compiled, startsearch, (unsigned int )((long )str_len - (startsearch - str___0)));
#line 37
  i = (int )tmp;
  }
#line 37
  if (i == 0) {
#line 38
    return (101U);
  }
#line 41
  required_len = (unsigned int )(((str___0 + str_len) + (regexec_match_start - str___0)) - regexec_match_end);
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! *ptr) {
#line 53
      goto while_break;
    }
#line 56
    if ((int const   )*ptr != 92) {
      regular: 
#line 60
      required_len ++;
#line 61
      ptr ++;
#line 62
      goto while_continue;
    }
#line 66
    ptr ++;
#line 66
    c = (unsigned char )*ptr;
#line 69
    if ((int )c == 38) {
#line 71
      required_len = (unsigned int )((long )required_len + (regexec_match_end - regexec_match_start));
#line 72
      ptr ++;
#line 73
      goto while_continue;
    }
#line 78
    if (! (((int )c & -128) == 0)) {
#line 79
      goto regular;
    } else {
      {
#line 78
      tmp___0 = __ctype_b_loc();
      }
#line 78
      if ((int const   )*(*tmp___0 + (int )c) & 2048) {
#line 78
        if ((int )c == 48) {
#line 79
          goto regular;
        }
      } else {
#line 79
        goto regular;
      }
    }
#line 80
    ptr ++;
#line 82
    c = (unsigned char )((int )c - 49);
#line 83
    if ((unsigned int )c >= regexec_paren_info_used) {
#line 84
      goto while_continue;
    }
#line 85
    if ((unsigned long )(regexec_paren_info + c)->match_end == (unsigned long )((unsigned char const   *)0)) {
#line 87
      goto while_continue;
    } else
#line 85
    if ((unsigned long )(regexec_paren_info + c)->match_start == (unsigned long )((unsigned char const   *)0)) {
#line 87
      goto while_continue;
    }
#line 89
    required_len = (unsigned int )((long )required_len + ((regexec_paren_info + c)->match_end - (regexec_paren_info + c)->match_start));
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  required_len ++;
#line 95
  tmp___2 = xmalloc(required_len);
#line 95
  tmp___1 = (unsigned char *)tmp___2;
#line 95
  *new___1 = tmp___1;
#line 95
  nptr = tmp___1;
#line 96
  new_end = nptr + required_len;
#line 98
  ptr = replace;
  }
#line 102
  if ((unsigned long )regexec_match_start != (unsigned long )str___0) {
#line 104
    sptr = str___0;
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (! ((unsigned long )sptr != (unsigned long )regexec_match_start)) {
#line 105
        goto while_break___0;
      }
#line 106
      tmp___3 = nptr;
#line 106
      nptr ++;
#line 106
      tmp___4 = sptr;
#line 106
      sptr ++;
#line 106
      *tmp___3 = (unsigned char )*tmp___4;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 112
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 112
    if (! *ptr) {
#line 112
      goto while_break___1;
    }
    {
#line 115
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 115
      if (! ((unsigned long )nptr < (unsigned long )new_end)) {
        {
#line 115
        die("\nassert(nptr < new_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.c",
            115);
        }
      }
#line 115
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 117
    if ((int const   )*ptr != 92) {
#line 119
      tmp___5 = nptr;
#line 119
      nptr ++;
#line 119
      tmp___6 = ptr;
#line 119
      ptr ++;
#line 119
      *tmp___5 = (unsigned char )*tmp___6;
#line 120
      goto while_continue___1;
    }
#line 123
    ptr ++;
#line 123
    c___0 = (unsigned char )*ptr;
#line 127
    if ((int )c___0 == 38) {
#line 128
      sptr___0 = regexec_match_start;
      {
#line 129
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 129
        if (! ((unsigned long )sptr___0 < (unsigned long )regexec_match_end)) {
#line 129
          goto while_break___3;
        }
#line 130
        tmp___7 = nptr;
#line 130
        nptr ++;
#line 130
        tmp___8 = sptr___0;
#line 130
        sptr___0 ++;
#line 130
        *tmp___7 = (unsigned char )*tmp___8;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 131
      ptr ++;
#line 132
      goto while_continue___1;
    }
#line 136
    if (! (((int )c___0 & -128) == 0)) {
#line 136
      goto _L;
    } else {
      {
#line 136
      tmp___11 = __ctype_b_loc();
      }
#line 136
      if ((int const   )*(*tmp___11 + (int )c___0) & 2048) {
#line 136
        if ((int )c___0 == 48) {
          _L: /* CIL Label */ 
#line 138
          tmp___9 = nptr;
#line 138
          nptr ++;
#line 138
          tmp___10 = ptr;
#line 138
          ptr ++;
#line 138
          *tmp___9 = (unsigned char )*tmp___10;
#line 140
          goto while_continue___1;
        }
      } else {
#line 136
        goto _L;
      }
    }
#line 142
    c___0 = (unsigned char )((int )c___0 - 49);
#line 143
    ptr ++;
#line 145
    if ((unsigned long )(regexec_paren_info + c___0)->match_end != (unsigned long )((unsigned char const   *)0)) {
#line 145
      if ((unsigned long )(regexec_paren_info + c___0)->match_start != (unsigned long )((unsigned char const   *)0)) {
#line 148
        sptr___1 = (regexec_paren_info + c___0)->match_start;
        {
#line 149
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 149
          if (! ((unsigned long )sptr___1 < (unsigned long )(regexec_paren_info + c___0)->match_end)) {
#line 149
            goto while_break___4;
          }
#line 150
          tmp___12 = nptr;
#line 150
          nptr ++;
#line 150
          tmp___13 = sptr___1;
#line 150
          sptr___1 ++;
#line 150
          *tmp___12 = (unsigned char )*tmp___13;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 155
  *new_end_match = nptr;
#line 159
  if ((unsigned long )regexec_match_end < (unsigned long )(str___0 + str_len)) {
#line 161
    sptr___2 = regexec_match_end;
    {
#line 162
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 162
      if (! ((unsigned long )sptr___2 < (unsigned long )(str___0 + str_len))) {
#line 162
        goto while_break___5;
      }
#line 163
      tmp___14 = nptr;
#line 163
      nptr ++;
#line 163
      tmp___15 = sptr___2;
#line 163
      sptr___2 ++;
#line 163
      *tmp___14 = (unsigned char )*tmp___15;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 167
  tmp___16 = nptr;
#line 167
  nptr ++;
#line 167
  *tmp___16 = (unsigned char )'\000';
  {
#line 168
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 168
    if (! ((unsigned long )nptr == (unsigned long )new_end)) {
      {
#line 168
      die("\nassert(nptr == new_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.c",
          168);
      }
    }
#line 168
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 169
  return (0U);
}
}
#line 172 "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.c"
unsigned int apply_substitution(regex_t const   *compiled , unsigned char **new___1 ,
                                unsigned int *matchcount , unsigned char const   *str___0 ,
                                unsigned int str_len , unsigned char const   *replace ,
                                unsigned int count ) 
{ 
  unsigned char *old ;
  unsigned char *new_end_match ;
  unsigned int dummy ;
  int i ;
  unsigned int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 186
  if ((unsigned long )matchcount == (unsigned long )((unsigned int *)0)) {
#line 187
    matchcount = & dummy;
  }
  {
#line 189
  tmp = _apply_substitution(compiled, new___1, & new_end_match, str___0, str_len,
                            str___0, replace);
#line 189
  i = (int )tmp;
#line 191
  *matchcount = 0U;
  }
#line 192
  if (i != 0) {
#line 193
    return ((unsigned int )i);
  }
#line 195
  (*matchcount) ++;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    count --;
#line 196
    if (count) {
#line 196
      if (! ((int )*new_end_match != 0)) {
#line 196
        goto while_break;
      }
    } else {
#line 196
      goto while_break;
    }
    {
#line 197
    old = *new___1;
#line 198
    tmp___0 = strlen((char const   *)((void *)*new___1));
#line 198
    tmp___1 = _apply_substitution(compiled, new___1, & new_end_match, (unsigned char const   *)*new___1,
                                  (unsigned int )tmp___0, (unsigned char const   *)new_end_match,
                                  replace);
#line 198
    i = (int )tmp___1;
    }
#line 201
    if (i != 0) {
#line 202
      goto while_break;
    }
    {
#line 203
    (*matchcount) ++;
#line 204
    free((void *)old);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (0U);
}
}
#line 209 "/home/wheatley/newnew/temp/lookup-1.08b/lib/replace.c"
unsigned char *sub(unsigned char const   *str___0 , unsigned int stringlen , unsigned char const   *pattern ,
                   unsigned char const   *replace , unsigned int flags___0 , unsigned int times ) 
{ 
  regex_t R ;
  unsigned char *new___1 ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 218
  new___1 = (unsigned char *)0;
#line 219
  tmp = regcomp(& R, pattern, flags___0);
#line 219
  i = tmp;
  }
#line 222
  if (i == 13) {
#line 222
    if (! (flags___0 & 64U)) {
      {
#line 224
      i = regcomp(& R, pattern, flags___0 | 64U);
      }
    }
  }
#line 227
  if (i != 0) {
#line 228
    return ((unsigned char *)0);
  }
  {
#line 230
  tmp___0 = apply_substitution((regex_t const   *)(& R), & new___1, (unsigned int *)0,
                               str___0, stringlen, replace, times);
  }
#line 230
  if (tmp___0 != 0U) {
#line 233
    new___1 = (unsigned char *)0;
  }
  {
#line 235
  regfree(& R);
  }
#line 236
  return (new___1);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 211 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
unsigned char const   *regexec_match_start  ;
#line 212 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
unsigned char const   *regexec_match_end  ;
#line 219 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
int regexec_match_at_start_of_word  ;
#line 220 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
int regexec_match_at_end_of_word  ;
#line 251
void (*regex_memory_error)(void) ;
#line 274
unsigned int regcomp_error ;
#line 275 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
unsigned char const   *regcomp_eptr  ;
#line 276 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
unsigned char const   *regcomp_last_pattern  ;
#line 311 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.h"
struct regex_stats regex_stats  ;
#line 328
void regex_reset_stats(void) ;
#line 165 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
void regex_reset_stats(void) 
{ 


  {
  {
#line 166
  bzero((void *)(& regex_stats), sizeof(regex_stats));
  }
#line 167
  return;
}
}
#line 208 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static unsigned char const   *onebyte_char_in_string(unsigned char byte0 ,
                                                              unsigned char const   *string_start ,
                                                              unsigned char const   *string_end ) 
{ 
  unsigned int len ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((unsigned long )string_start < (unsigned long )string_end)) {
#line 213
      goto while_break;
    }
#line 215
    len = (unsigned int )((int const   )euc_info[*(string_start + 0)] & 3);
#line 216
    if (len == 0U) {
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 218
        die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
            218);
        }
#line 218
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 219
      len = 1U;
    }
#line 221
    if (1U == len) {
#line 221
      if ((int )byte0 == (int )*(string_start + 0)) {
#line 222
        return (string_start);
      }
    }
#line 223
    string_start += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return ((unsigned char const   *)0);
}
}
#line 233 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static unsigned char const   *twobyte_char_in_string(unsigned char byte0 ,
                                                              unsigned char byte1 ,
                                                              unsigned char const   *string_start ,
                                                              unsigned char const   *string_end ) 
{ 
  unsigned int len ;

  {
#line 239
  if ((unsigned long )string_start == (unsigned long )string_end) {
#line 240
    return ((unsigned char const   *)0);
  }
#line 242
  string_end --;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! ((unsigned long )string_start < (unsigned long )string_end)) {
#line 243
      goto while_break;
    }
#line 245
    len = (unsigned int )((int const   )euc_info[*(string_start + 0)] & 3);
#line 246
    if (len == 0U) {
      {
#line 248
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 248
        die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
            248);
        }
#line 248
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 249
      len = 1U;
    }
#line 253
    if (2U == len) {
#line 253
      if ((int )byte1 == (int )*(string_start + 1)) {
#line 253
        if ((int )byte0 == (int )*(string_start + 0)) {
#line 254
          return (string_start);
        }
      }
    }
#line 255
    string_start += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return ((unsigned char const   *)0);
}
}
#line 265 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static unsigned char const   *threebyte_char_in_string(unsigned char byte0 ,
                                                                unsigned char byte1 ,
                                                                unsigned char byte2 ,
                                                                unsigned char const   *string_start ,
                                                                unsigned char const   *string_end ) 
{ 
  unsigned int len ;

  {
#line 272
  if ((unsigned long )string_start == (unsigned long )string_end) {
#line 273
    return ((unsigned char const   *)0);
  }
#line 275
  string_end -= 2;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! ((unsigned long )string_start < (unsigned long )string_end)) {
#line 276
      goto while_break;
    }
#line 278
    len = (unsigned int )((int const   )euc_info[*(string_start + 0)] & 3);
#line 279
    if (len == 0U) {
      {
#line 281
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 281
        die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
            281);
        }
#line 281
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 282
      len = 1U;
    }
#line 286
    if (3U == len) {
#line 286
      if ((int )byte2 == (int )*(string_start + 2)) {
#line 286
        if ((int )byte1 == (int )*(string_start + 1)) {
#line 286
          if ((int )byte0 == (int )*(string_start + 0)) {
#line 288
            return (string_start);
          }
        }
      }
    }
#line 289
    string_start += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return ((unsigned char const   *)0);
}
}
#line 860 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static char **temp_memory___0  =    (char **)0;
#line 866 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
void (*regex_memory_error)(void)  =    (void (*)(void))0;
#line 868 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void *xmalloc___0(unsigned int size ) 
{ 
  void *mem ;
  void *tmp ;

  {
  {
#line 870
  tmp = malloc((size_t )size);
#line 870
  mem = tmp;
  }
#line 871
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 872
    if (regex_memory_error) {
      {
#line 873
      (*regex_memory_error)();
      }
    }
    {
#line 874
    die("[regex package out of memory]\n");
    }
  }
#line 876
  return (mem);
}
}
#line 883 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void *regex_malloc(unsigned int size ) 
{ 
  char **mem ;
  void *tmp ;

  {
  {
#line 886
  tmp = xmalloc___0((unsigned int )((unsigned long )size + sizeof(mem)));
#line 886
  mem = (char **)tmp;
#line 887
  *((char ***)mem) = temp_memory___0;
#line 888
  temp_memory___0 = mem;
  }
#line 889
  return ((void *)(mem + 1));
}
}
#line 896 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void regex_free_temp_memory(void) 
{ 
  char *tmp ;

  {
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! temp_memory___0) {
#line 899
      goto while_break;
    }
    {
#line 901
    tmp = (char *)temp_memory___0;
#line 902
    temp_memory___0 = (char **)*temp_memory___0;
#line 903
    free((void *)tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 905
  return;
}
}
#line 912 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int regcomp_flags  ;
#line 920 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned char jregex_part_of_word[256]  ;
#line 928 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned char case_translation[256]  ;
#line 949
__inline static void regex_init(void) ;
#line 949 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static int init_done  =    0;
#line 946 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static void regex_init(void) 
{ 
  int i ;

  {
#line 952
  if (init_done) {
#line 953
    return;
  }
#line 956
  i = 0;
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    if (! ((unsigned long )i < sizeof(jregex_part_of_word) / sizeof(jregex_part_of_word[0]))) {
#line 956
      goto while_break;
    }
#line 957
    jregex_part_of_word[i] = (unsigned char)0;
#line 956
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  i = 'a';
  {
#line 959
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 959
    if (! (i <= 122)) {
#line 959
      goto while_break___0;
    }
#line 960
    jregex_part_of_word[i] = (unsigned char)1;
#line 959
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 961
  i = 'A';
  {
#line 961
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 961
    if (! (i <= 90)) {
#line 961
      goto while_break___1;
    }
#line 962
    jregex_part_of_word[i] = (unsigned char)1;
#line 961
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 963
  i = '0';
  {
#line 963
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 963
    if (! (i <= 57)) {
#line 963
      goto while_break___2;
    }
#line 964
    jregex_part_of_word[i] = (unsigned char)1;
#line 963
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 965
  jregex_part_of_word['_'] = (unsigned char)1;
#line 967
  jregex_part_of_word[163] = (unsigned char)1;
#line 970
  jregex_part_of_word[164] = (unsigned char)2;
#line 971
  jregex_part_of_word[165] = (unsigned char)2;
#line 972
  jregex_part_of_word[161] = (unsigned char)2;
#line 974
  i = 176;
  {
#line 974
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 974
    if (! (i <= 244)) {
#line 974
      goto while_break___3;
    }
#line 975
    jregex_part_of_word[i] = (unsigned char)2;
#line 974
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 981
  i = 0;
  {
#line 981
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 981
    if (! ((unsigned long )i < sizeof(case_translation) / sizeof(case_translation[0]))) {
#line 981
      goto while_break___4;
    }
#line 982
    case_translation[i] = (unsigned char )i;
#line 981
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 983
  i = 'A';
  {
#line 983
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 983
    if (! (i <= 90)) {
#line 983
      goto while_break___5;
    }
#line 984
    case_translation[i] = (unsigned char )(97 + (i - 65));
#line 983
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 985
  case_translation[165] = (unsigned char)164;
#line 987
  init_done = 1;
#line 988
  return;
}
}
#line 999 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static void add_char_to_string(unsigned char const   *char_ptr , struct dynamic_string *dstr ) 
{ 
  unsigned int char_len ;
  unsigned char *old ;
  void *tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;

  {
#line 1002
  char_len = (unsigned int )((int const   )euc_info[*(char_ptr + 0)] & 3);
#line 1003
  if ((unsigned int )dstr->buf_used + char_len > (unsigned int )dstr->buf_length) {
    {
#line 1005
    old = dstr->buf;
#line 1006
    dstr->buf_length = (unsigned short )((int )dstr->buf_length + 32);
#line 1007
    tmp = regex_malloc((unsigned int )dstr->buf_length);
#line 1007
    dstr->buf = (unsigned char *)tmp;
#line 1008
    bcopy((void const   *)old, (void *)dstr->buf, (size_t )dstr->buf_used);
    }
  }
#line 1010
  tmp___0 = dstr->buf_used;
#line 1010
  dstr->buf_used = (unsigned short )((int )dstr->buf_used + 1);
#line 1010
  *(dstr->buf + tmp___0) = (unsigned char )*(char_ptr + 0);
#line 1011
  if (char_len > 1U) {
#line 1013
    tmp___1 = dstr->buf_used;
#line 1013
    dstr->buf_used = (unsigned short )((int )dstr->buf_used + 1);
#line 1013
    *(dstr->buf + tmp___1) = (unsigned char )*(char_ptr + 1);
#line 1014
    if (char_len > 2U) {
#line 1015
      tmp___2 = dstr->buf_used;
#line 1015
      dstr->buf_used = (unsigned short )((int )dstr->buf_used + 1);
#line 1015
      *(dstr->buf + tmp___2) = (unsigned char )*(char_ptr + 2);
    }
  }
#line 1017
  return;
}
}
#line 1100 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int paren_level  ;
#line 1101 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int paren_levels_finished  ;
#line 1102 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static int highest_prev_to_match  ;
#line 1134 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static double max_lpc  ;
#line 1135 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int max_lpc_l  ;
#line 1135 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int max_lpc_c  ;
#line 1142 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static enum TYPE this_regex_match  ;
#line 1149 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned int regcomp_error  =    0U;
#line 1168 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static struct intermediate *new_comp_struct(void) 
{ 
  struct intermediate *ptr ;
  void *tmp ;

  {
  {
#line 1171
  tmp = regex_malloc((unsigned int )sizeof(struct intermediate ));
#line 1171
  ptr = (struct intermediate *)tmp;
#line 1172
  bzero((void *)ptr, sizeof(struct intermediate ));
  }
#line 1173
  return (ptr);
}
}
#line 1176 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static int next_quoted_character(unsigned char const   **ptr_p , unsigned char *out ) 
{ 
  int len ;
  unsigned int num ;

  {
#line 1185
  if ((int const   )*(*ptr_p) == 92) {
#line 1187
    (*ptr_p) ++;
#line 1190
    if ((int const   )*(*ptr_p + 0) >= 48) {
#line 1190
      if ((int const   )*(*ptr_p + 0) <= 55) {
#line 1190
        if ((int const   )*(*ptr_p + 1) >= 48) {
#line 1190
          if ((int const   )*(*ptr_p + 1) <= 55) {
#line 1192
            num = (unsigned int )(((int const   )*(*ptr_p + 0) - 48) * 8 + ((int const   )*(*ptr_p + 1) - 48));
#line 1193
            if ((int const   )*(*ptr_p + 2) >= 48) {
#line 1193
              if ((int const   )*(*ptr_p + 2) <= 55) {
#line 1194
                num = num * 8U + (unsigned int )((int const   )*(*ptr_p + 2) - 48);
#line 1195
                (*ptr_p) ++;
              }
            }
#line 1197
            *ptr_p += 2;
#line 1198
            if (num > 255U) {
              {
#line 1199
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1199
                regcomp_error = 15U;
#line 1199
                regcomp_eptr = *ptr_p;
#line 1199
                return (0);
#line 1199
                goto while_break;
              }
              while_break: /* CIL Label */ ;
              }
            }
#line 1200
            *(out + 0) = (unsigned char )num;
#line 1201
            return (1);
          }
        }
      }
    }
    {
#line 1206
    if ((int const   )*(*ptr_p) == 116) {
#line 1206
      goto case_116;
    }
#line 1207
    if ((int const   )*(*ptr_p) == 110) {
#line 1207
      goto case_110;
    }
#line 1208
    if ((int const   )*(*ptr_p) == 114) {
#line 1208
      goto case_114;
    }
#line 1209
    if ((int const   )*(*ptr_p) == 102) {
#line 1209
      goto case_102;
    }
#line 1204
    goto switch_break;
    case_116: /* CIL Label */ 
#line 1206
    (*ptr_p) ++;
#line 1206
    *(out + 0) = (unsigned char )'\t';
#line 1206
    return (1);
    case_110: /* CIL Label */ 
#line 1207
    (*ptr_p) ++;
#line 1207
    *(out + 0) = (unsigned char )'\n';
#line 1207
    return (1);
    case_114: /* CIL Label */ 
#line 1208
    (*ptr_p) ++;
#line 1208
    *(out + 0) = (unsigned char )'\r';
#line 1208
    return (1);
    case_102: /* CIL Label */ 
#line 1209
    (*ptr_p) ++;
#line 1209
    *(out + 0) = (unsigned char )'\f';
#line 1209
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 1213
  len = (int )((int const   )euc_info[*(*ptr_p + 0)] & 3);
  {
#line 1218
  if (len == 3) {
#line 1218
    goto case_3;
  }
#line 1220
  if (len == 2) {
#line 1220
    goto case_2;
  }
#line 1222
  if (len == 1) {
#line 1222
    goto case_1;
  }
#line 1215
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1216
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1216
    regcomp_error = 16U;
#line 1216
    regcomp_eptr = *ptr_p;
#line 1216
    return (0);
#line 1216
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  case_3: /* CIL Label */ 
#line 1219
  *(out + 2) = (unsigned char )*(*ptr_p + 2);
  case_2: /* CIL Label */ 
#line 1221
  *(out + 1) = (unsigned char )*(*ptr_p + 1);
  case_1: /* CIL Label */ 
#line 1223
  *(out + 0) = (unsigned char )*(*ptr_p + 0);
  switch_break___0: /* CIL Label */ ;
  }
#line 1225
  *ptr_p += len;
#line 1226
  return (len);
}
}
#line 1236 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static unsigned char const   *nab_class(struct intermediate *inter , unsigned char const   *p ) 
{ 
  unsigned char current[3] ;
  int char1_count ;
  int char2_count ;
  int char3_count ;
  int lastascii ;
  int ascii ;
  unsigned char const   *pat ;
  struct class *class ;
  void *tmp ;
  unsigned int i ;
  struct class *tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned int start ;
  unsigned int end ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned char const   *tmp___14 ;
  unsigned char const   *tmp___15 ;
  unsigned short const   **tmp___16 ;

  {
  {
#line 1240
  char1_count = 0;
#line 1241
  char2_count = 0;
#line 1242
  char3_count = 0;
#line 1243
  lastascii = -1;
#line 1244
  ascii = 0;
#line 1246
  tmp = regex_malloc((unsigned int )sizeof(struct class ));
#line 1246
  class = (struct class *)tmp;
#line 1249
  inter->type = (enum TYPE )16;
#line 1250
  inter->must_match = 1;
#line 1251
  tmp___0 = class;
#line 1251
  inter->u.class = tmp___0;
#line 1251
  bzero((void *)tmp___0, sizeof(struct class ));
  }
#line 1254
  if ((int const   )*p == 94) {
#line 1256
    class->inverted = (char)1;
#line 1257
    p ++;
  }
#line 1259
  pat = p;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1267
    if ((int const   )*(p + 0) == 92) {
      {
#line 1271
      if ((int const   )*(p + 1) == 100) {
#line 1271
        goto case_100;
      }
#line 1279
      if ((int const   )*(p + 1) == 119) {
#line 1279
        goto case_119;
      }
#line 1289
      if ((int const   )*(p + 1) == 115) {
#line 1289
        goto case_115;
      }
#line 1269
      goto switch_break;
      case_100: /* CIL Label */ 
#line 1272
      i = (unsigned int )'0';
      {
#line 1272
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1272
        if (! (i <= 57U)) {
#line 1272
          goto while_break___0;
        }
#line 1273
        class->ascii[i] = (unsigned char)1;
#line 1272
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1274
      char1_count += 10;
#line 1275
      p += 2;
#line 1276
      lastascii = -1;
#line 1277
      goto __Cont;
      case_119: /* CIL Label */ 
#line 1280
      i = 0U;
      {
#line 1280
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1280
        if (! (i < 127U)) {
#line 1280
          goto while_break___1;
        }
#line 1281
        if (jregex_part_of_word[i]) {
#line 1282
          char1_count ++;
#line 1283
          class->ascii[i] = (unsigned char)1;
        }
#line 1280
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1285
      p += 2;
#line 1286
      lastascii = -1;
#line 1287
      goto __Cont;
      case_115: /* CIL Label */ 
#line 1290
      tmp___4 = (unsigned char)1;
#line 1290
      class->ascii[' '] = tmp___4;
#line 1290
      tmp___3 = tmp___4;
#line 1290
      class->ascii['\f'] = tmp___3;
#line 1290
      tmp___2 = tmp___3;
#line 1290
      class->ascii['\r'] = tmp___2;
#line 1290
      tmp___1 = tmp___2;
#line 1290
      class->ascii['\n'] = tmp___1;
#line 1290
      class->ascii['\t'] = tmp___1;
#line 1295
      char1_count += 5;
#line 1296
      lastascii = -1;
#line 1297
      p += 2;
#line 1298
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1302
    if (lastascii != -1) {
#line 1302
      if ((int const   )*(p + 0) == 45) {
#line 1305
        p ++;
#line 1306
        if ((int const   )*p == 0) {
          {
#line 1307
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1307
            regcomp_error = 16U;
#line 1307
            regcomp_eptr = p;
#line 1307
            return ((unsigned char const   *)0);
#line 1307
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1308
        tmp___5 = next_quoted_character(& p, current);
        }
#line 1308
        if (tmp___5 != 1) {
          {
#line 1309
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1309
            regcomp_error = 14U;
#line 1309
            regcomp_eptr = p;
#line 1309
            return ((unsigned char const   *)0);
#line 1309
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 1310
        if ((int )current[0] >= 128) {
          {
#line 1311
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1311
            regcomp_error = 16U;
#line 1311
            regcomp_eptr = p;
#line 1311
            return ((unsigned char const   *)0);
#line 1311
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 1313
        if ((int )((unsigned char )lastascii) < (int )current[0]) {
#line 1313
          start = (unsigned int )lastascii;
        } else {
#line 1313
          start = (unsigned int )current[0];
        }
#line 1315
        if ((int )((unsigned char )lastascii) > (int )current[0]) {
#line 1315
          end = (unsigned int )lastascii;
        } else {
#line 1315
          end = (unsigned int )current[0];
        }
#line 1318
        i = start;
        {
#line 1318
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1318
          if (! (i <= end)) {
#line 1318
            goto while_break___5;
          }
#line 1320
          char1_count ++;
#line 1321
          class->ascii[i] = (unsigned char)1;
#line 1322
          if (regcomp_flags & 4U) {
            {
#line 1324
            tmp___9 = __ctype_b_loc();
            }
#line 1324
            if ((int const   )*(*tmp___9 + (int )i) & 512) {
              {
#line 1325
              tmp___6 = toupper((int )i);
#line 1325
              class->ascii[tmp___6] = (unsigned char)1;
              }
            } else {
              {
#line 1326
              tmp___8 = __ctype_b_loc();
              }
#line 1326
              if ((int const   )*(*tmp___8 + (int )i) & 256) {
                {
#line 1327
                tmp___7 = tolower((int )i);
#line 1327
                class->ascii[tmp___7] = (unsigned char)1;
                }
              }
            }
          }
#line 1318
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1330
        lastascii = -1;
#line 1331
        goto __Cont;
      }
    }
#line 1334
    if ((int const   )*p == 0) {
      {
#line 1335
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1335
        regcomp_error = 4U;
#line 1335
        regcomp_eptr = p;
#line 1335
        return ((unsigned char const   *)0);
#line 1335
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1337
    tmp___10 = next_quoted_character(& p, current);
    }
    {
#line 1342
    if (tmp___10 == 1) {
#line 1342
      goto case_1;
    }
#line 1356
    if (tmp___10 == 2) {
#line 1356
      goto case_2;
    }
#line 1372
    if (tmp___10 == 3) {
#line 1372
      goto case_3;
    }
#line 1339
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1340
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1340
      regcomp_error = 16U;
#line 1340
      regcomp_eptr = p;
#line 1340
      return ((unsigned char const   *)0);
#line 1340
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    case_1: /* CIL Label */ 
#line 1343
    if ((int )current[0] & 128) {
      {
#line 1344
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1344
        regcomp_error = 16U;
#line 1344
        regcomp_eptr = p;
#line 1344
        return ((unsigned char const   *)0);
#line 1344
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 1345
    char1_count ++;
#line 1346
    lastascii = (int )current[0];
#line 1346
    ascii = lastascii;
#line 1346
    class->ascii[ascii] = (unsigned char)1;
#line 1347
    if (regcomp_flags & 4U) {
      {
#line 1349
      tmp___13 = __ctype_b_loc();
      }
#line 1349
      if ((int const   )*(*tmp___13 + (int )current[0]) & 256) {
        {
#line 1350
        ascii = tolower((int )current[0]);
#line 1350
        class->ascii[ascii] = (unsigned char)1;
        }
      } else {
        {
#line 1351
        tmp___12 = __ctype_b_loc();
        }
#line 1351
        if ((int const   )*(*tmp___12 + (int )current[0]) & 512) {
          {
#line 1352
          tmp___11 = toupper((int )current[0]);
#line 1352
          class->ascii[tmp___11] = (unsigned char)1;
          }
        }
      }
    }
#line 1354
    goto __Cont;
    case_2: /* CIL Label */ 
#line 1358
    if (regcomp_flags & 8U) {
#line 1358
      if ((int )current[0] == 165) {
#line 1361
        current[0] = (unsigned char)164;
      }
    }
    {
#line 1363
    tmp___14 = twobyte_char_in_string(current[0], current[1], (unsigned char const   *)class->euc2.buf,
                                      (unsigned char const   *)(class->euc2.buf + (int )class->euc2.buf_used));
    }
#line 1363
    if (! tmp___14) {
      {
#line 1366
      char2_count ++;
#line 1367
      add_char_to_string((unsigned char const   *)(current), & class->euc2);
      }
    }
#line 1369
    lastascii = -1;
#line 1370
    goto __Cont;
    case_3: /* CIL Label */ 
    {
#line 1373
    tmp___15 = threebyte_char_in_string(current[0], current[1], current[3], (unsigned char const   *)class->euc2.buf,
                                        (unsigned char const   *)(class->euc2.buf + (int )class->euc2.buf_used));
    }
#line 1373
    if (! tmp___15) {
      {
#line 1376
      char3_count ++;
#line 1377
      add_char_to_string((unsigned char const   *)(current), & class->euc3);
      }
    }
#line 1379
    lastascii = -1;
#line 1380
    goto __Cont;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1263
    if (*p) {
#line 1263
      if (! ((int const   )*p != 93)) {
#line 1263
        goto while_break;
      }
    } else {
#line 1263
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1385
  if ((int const   )*p == 0) {
    {
#line 1386
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1386
      regcomp_error = 4U;
#line 1386
      regcomp_eptr = pat;
#line 1386
      return ((unsigned char const   *)0);
#line 1386
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 1388
  p ++;
#line 1391
  if (! (char2_count * 2 == (int )class->euc2.buf_used)) {
    {
#line 1394
    outputf("char2_count=%d, class->euc2.buf_used = %d\n", char2_count, (int )class->euc2.buf_used);
#line 1396
    outputf("char3_count=%d, class->euc3.buf_used = %d\n", char3_count, (int )class->euc3.buf_used);
    }
  } else
#line 1391
  if (! (char3_count * 2 == (int )class->euc3.buf_used)) {
    {
#line 1394
    outputf("char2_count=%d, class->euc2.buf_used = %d\n", char2_count, (int )class->euc2.buf_used);
#line 1396
    outputf("char3_count=%d, class->euc3.buf_used = %d\n", char3_count, (int )class->euc3.buf_used);
    }
  }
  {
#line 1401
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1401
    if (! (char2_count * 2 == (int )class->euc2.buf_used)) {
      {
#line 1401
      die("\nassert(char2_count * 2 == class->euc2.buf_used) failed \"%s\" line %d.\n",
          "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 1401);
      }
    }
#line 1401
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1402
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1402
    if (! (char3_count * 2 == (int )class->euc3.buf_used)) {
      {
#line 1402
      die("\nassert(char3_count * 2 == class->euc3.buf_used) failed \"%s\" line %d.\n",
          "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 1402);
      }
    }
#line 1402
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1404
  if ((char1_count + char2_count) + char3_count == 0) {
    {
#line 1405
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1405
      regcomp_error = 10U;
#line 1405
      regcomp_eptr = pat;
#line 1405
      return ((unsigned char const   *)0);
#line 1405
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 1407
  if (class->inverted) {
#line 1408
    inter->min_match_len = 1U;
  } else
#line 1407
  if (char1_count) {
#line 1408
    inter->min_match_len = 1U;
  } else
#line 1409
  if (char2_count) {
#line 1410
    inter->min_match_len = 2U;
  } else {
#line 1412
    inter->min_match_len = 3U;
  }
#line 1414
  inter->regex_bytes_needed = (unsigned int )((134 + char2_count * 2) + char3_count * 3);
#line 1420
  if (! class->inverted) {
#line 1420
    if (char1_count == 0) {
#line 1420
      if (char3_count == 0) {
#line 1420
        if (char2_count == 2) {
#line 1426
          if (! (regcomp_flags & 8U)) {
#line 1426
            goto _L;
          } else
#line 1426
          if ((int )*(class->euc2.buf + 0) != 164) {
#line 1426
            if ((int )*(class->euc2.buf + 0) != 165) {
#line 1426
              if ((int )*(class->euc2.buf + 2) != 164) {
#line 1426
                if ((int )*(class->euc2.buf + 2) != 165) {
                  _L: /* CIL Label */ 
#line 1432
                  inter->type = (enum TYPE )3;
#line 1433
                  inter->u.exact[0] = *(class->euc2.buf + 0);
#line 1434
                  inter->u.exact[1] = *(class->euc2.buf + 1);
#line 1435
                  inter->u.exact[2] = *(class->euc2.buf + 2);
#line 1436
                  inter->u.exact[3] = *(class->euc2.buf + 3);
#line 1437
                  inter->regex_bytes_needed = 5U;
                }
              }
            }
          }
        } else {
#line 1420
          goto _L___2;
        }
      } else {
#line 1420
        goto _L___2;
      }
    } else {
#line 1420
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1440
  if (! class->inverted) {
#line 1440
    if ((char1_count + char3_count) + char2_count == 1) {
#line 1443
      if (char1_count == 1) {
#line 1445
        if (regcomp_flags & 4U) {
          {
#line 1445
          tmp___16 = __ctype_b_loc();
          }
#line 1445
          if ((int const   )*(*tmp___16 + ascii) & 1024) {
#line 1446
            inter->type = (enum TYPE )5;
          } else {
#line 1448
            inter->type = (enum TYPE )1;
          }
        } else {
#line 1448
          inter->type = (enum TYPE )1;
        }
#line 1449
        inter->u.exact[0] = (unsigned char )ascii;
#line 1450
        inter->regex_bytes_needed = 2U;
      } else
#line 1452
      if (char2_count == 1) {
#line 1454
        if (regcomp_flags & 8U) {
#line 1454
          if ((int )*(class->euc2.buf + 0) == 164) {
#line 1456
            inter->type = (enum TYPE )6;
          } else {
#line 1458
            inter->type = (enum TYPE )2;
          }
        } else {
#line 1458
          inter->type = (enum TYPE )2;
        }
#line 1459
        inter->u.exact[0] = *(class->euc2.buf + 0);
#line 1460
        inter->u.exact[1] = *(class->euc2.buf + 1);
#line 1461
        inter->regex_bytes_needed = 3U;
      } else
#line 1463
      if (char3_count == 1) {
#line 1465
        inter->type = (enum TYPE )4;
#line 1466
        inter->u.exact[0] = *(class->euc3.buf + 0);
#line 1467
        inter->u.exact[1] = *(class->euc3.buf + 1);
#line 1468
        inter->u.exact[2] = *(class->euc3.buf + 2);
#line 1469
        inter->regex_bytes_needed = 4U;
      } else {
        {
#line 1471
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 1471
          die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
              1471);
          }
#line 1471
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
  }
#line 1476
  return (p);
}
}
#line 1479 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static int set_mustmatch(struct intermediate *i ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1481
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1482
  if ((unsigned long )i->next == (unsigned long )((struct intermediate *)0)) {
#line 1483
    return (i->must_match);
  } else {
    {
#line 1485
    tmp = set_mustmatch(i->next);
#line 1485
    tmp___0 = i->must_match | tmp;
#line 1485
    i->must_match = tmp___0;
    }
#line 1485
    return (tmp___0);
  }
}
}
#line 1491
static struct intermediate *nibble_from_pattern(unsigned char const   **pp ) ;
#line 1493 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static struct intermediate *nibble_list(unsigned char const   **pp , struct intermediate  const  *parent ) 
{ 
  unsigned char const   *start_PAT ;
  struct intermediate *listhead ;
  struct intermediate *lastlist ;
  struct intermediate *alt ;
  struct intermediate *lastalt ;
  struct intermediate *to_be_returned ;
  struct intermediate *new___1 ;
  struct intermediate *ptr ;
  struct intermediate *tmp ;

  {
#line 1496
  start_PAT = *pp;
#line 1497
  listhead = (struct intermediate *)0;
#line 1500
  alt = (struct intermediate *)0;
#line 1506
  to_be_returned = (struct intermediate *)0;
  {
#line 1524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1529
    if ((int const   )*(*pp + 0) == 124) {
      {
#line 1530
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1530
        regcomp_error = 11U;
#line 1530
        regcomp_eptr = *pp;
#line 1530
        return ((struct intermediate *)0);
#line 1530
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1532
    if ((int const   )*(*pp + 0) == 41) {
#line 1539
      if (alt) {
#line 1539
        if (listhead) {
          {
#line 1540
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1540
            set_mustmatch(listhead);
            }
#line 1540
            if (alt->min_match_len > listhead->min_match_len) {
#line 1540
              alt->min_match_len = listhead->min_match_len;
            }
#line 1540
            alt->regex_bytes_needed += listhead->regex_bytes_needed + 6U;
#line 1540
            alt->must_match &= listhead->must_match;
#line 1540
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 1542
      if ((unsigned long )parent == (unsigned long )((struct intermediate  const  *)0)) {
        {
#line 1543
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1543
          regcomp_error = 6U;
#line 1543
          regcomp_eptr = *pp;
#line 1543
          return ((struct intermediate *)0);
#line 1543
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1546
      if (parent->u.paren_info.real) {
#line 1547
        paren_levels_finished = (unsigned int )((int const   )parent->u.paren_info.level + 1);
      }
#line 1550
      if ((unsigned long )to_be_returned == (unsigned long )((struct intermediate *)0)) {
        {
#line 1553
        to_be_returned = new_comp_struct();
#line 1554
        to_be_returned->type = (enum TYPE )0;
        }
      }
#line 1556
      (*pp) ++;
#line 1557
      return (to_be_returned);
    }
#line 1561
    if ((int const   )*(*pp + 0) == 36) {
#line 1561
      if ((int const   )*(*pp + 1) == 0) {
#line 1561
        if (alt) {
#line 1568
          if (listhead) {
            {
#line 1569
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 1569
              set_mustmatch(listhead);
              }
#line 1569
              if (alt->min_match_len > listhead->min_match_len) {
#line 1569
                alt->min_match_len = listhead->min_match_len;
              }
#line 1569
              alt->regex_bytes_needed += listhead->regex_bytes_needed + 6U;
#line 1569
              alt->must_match &= listhead->must_match;
#line 1569
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1571
          if ((unsigned long )parent != (unsigned long )((struct intermediate  const  *)0)) {
#line 1572
            return (to_be_returned);
          } else {
#line 1575
            lastlist = alt;
#line 1576
            listhead = to_be_returned;
#line 1577
            alt = (struct intermediate *)0;
          }
        }
      }
    }
    {
#line 1583
    new___1 = nibble_from_pattern(pp);
    }
#line 1583
    if ((unsigned long )new___1 == (unsigned long )((struct intermediate *)0)) {
#line 1584
      return ((struct intermediate *)0);
    }
#line 1585
    if (alt) {
#line 1585
      new___1->parent = (struct intermediate  const  *)alt;
    } else {
#line 1585
      new___1->parent = parent;
    }
#line 1587
    if (alt) {
#line 1587
      if ((unsigned int )new___1->type == (unsigned int )this_regex_match) {
#line 1587
        goto _L;
      } else
#line 1587
      if ((unsigned int )new___1->type == 1U) {
#line 1587
        if ((int )new___1->u.exact[0] == 10) {
          _L: /* CIL Label */ 
#line 1590
          if (listhead) {
            {
#line 1591
            while (1) {
              while_continue___4: /* CIL Label */ ;
              {
#line 1591
              set_mustmatch(listhead);
              }
#line 1591
              if (alt->min_match_len > listhead->min_match_len) {
#line 1591
                alt->min_match_len = listhead->min_match_len;
              }
#line 1591
              alt->regex_bytes_needed += listhead->regex_bytes_needed + 6U;
#line 1591
              alt->must_match &= listhead->must_match;
#line 1591
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 1592
          listhead = to_be_returned;
#line 1593
          lastlist = alt;
#line 1594
          alt = (struct intermediate *)0;
        }
      }
    }
#line 1597
    if ((unsigned long )listhead == (unsigned long )((struct intermediate *)0)) {
#line 1599
      lastlist = new___1;
#line 1599
      listhead = lastlist;
#line 1600
      if (alt) {
#line 1602
        lastalt->nextalt = listhead;
#line 1603
        lastalt = new___1;
      }
    } else {
#line 1606
      if (regcomp_flags & 256U) {
#line 1617
        if ((unsigned int )lastlist->type == 2U) {
#line 1617
          if ((unsigned int )new___1->type == 2U) {
#line 1617
            if ((int )lastlist->u.exact[0] >= 176) {
#line 1617
              if ((int )new___1->u.exact[0] == (int )lastlist->u.exact[0]) {
#line 1617
                if ((int )new___1->u.exact[1] == (int )lastlist->u.exact[1]) {
#line 1617
                  goto _L___0;
                } else {
#line 1617
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 1617
              if ((int )new___1->u.exact[0] == (int )*((unsigned char *)"\241\271" + 0)) {
#line 1617
                if ((int )new___1->u.exact[1] == (int )*((unsigned char *)"\241\271" + 1)) {
                  _L___0: /* CIL Label */ 
#line 1624
                  new___1->type = (enum TYPE )3;
#line 1625
                  new___1->u.exact[0] = lastlist->u.exact[0];
#line 1626
                  new___1->u.exact[1] = lastlist->u.exact[1];
#line 1627
                  new___1->u.exact[2] = (unsigned char )*("\241\271" + 0);
#line 1628
                  new___1->u.exact[3] = (unsigned char )*("\241\271" + 1);
#line 1629
                  new___1->regex_bytes_needed = 5U;
                }
              }
            }
          }
        }
      }
#line 1632
      lastlist->next = new___1;
#line 1633
      lastlist = new___1;
#line 1634
      listhead->regex_bytes_needed += new___1->regex_bytes_needed;
#line 1635
      listhead->min_match_len += new___1->min_match_len;
#line 1636
      listhead->must_match |= new___1->must_match;
    }
#line 1639
    if ((unsigned int )new___1->type == (unsigned int )this_regex_match) {
#line 1641
      if (parent) {
        {
#line 1642
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1642
          regcomp_error = 5U;
#line 1642
          regcomp_eptr = start_PAT - 1;
#line 1642
          return ((struct intermediate *)0);
#line 1642
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 1643
      set_mustmatch(to_be_returned);
      }
#line 1644
      return (to_be_returned);
    }
#line 1647
    if ((unsigned long )to_be_returned == (unsigned long )((struct intermediate *)0)) {
#line 1648
      to_be_returned = listhead;
    }
#line 1650
    if ((int const   )*(*pp + 0) == 124) {
#line 1655
      if ((unsigned long )alt != (unsigned long )((struct intermediate *)0)) {
        {
#line 1658
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1658
          set_mustmatch(listhead);
          }
#line 1658
          if (alt->min_match_len > listhead->min_match_len) {
#line 1658
            alt->min_match_len = listhead->min_match_len;
          }
#line 1658
          alt->regex_bytes_needed += listhead->regex_bytes_needed + 6U;
#line 1658
          alt->must_match &= listhead->must_match;
#line 1658
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
        {
#line 1677
        alt = new_comp_struct();
#line 1678
        alt->type = (enum TYPE )32;
#line 1679
        alt->parent = parent;
        }
#line 1686
        if ((unsigned long )to_be_returned == (unsigned long )listhead) {
#line 1687
          to_be_returned = alt;
        }
        {
#line 1691
        set_mustmatch(listhead);
#line 1692
        tmp = listhead;
#line 1692
        alt->u.alt = tmp;
#line 1692
        lastalt = tmp;
#line 1695
        ptr = listhead;
        }
        {
#line 1695
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1695
          if (! ptr) {
#line 1695
            goto while_break___7;
          }
#line 1696
          ptr->parent = (struct intermediate  const  *)alt;
#line 1695
          ptr = ptr->next;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1698
        alt->min_match_len = listhead->min_match_len;
#line 1699
        alt->regex_bytes_needed = listhead->regex_bytes_needed;
#line 1700
        alt->must_match = listhead->must_match;
      }
#line 1703
      listhead = (struct intermediate *)0;
#line 1704
      (*pp) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1715 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static struct intermediate *nibble_from_pattern(unsigned char const   **pp ) 
{ 
  unsigned char this[3] ;
  struct intermediate *new___1 ;
  struct intermediate *tmp ;
  unsigned int tmp___0 ;
  struct intermediate *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int inverted ;
  unsigned short const   **tmp___3 ;
  unsigned char class[5] ;
  int i ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char const   *tmp___10 ;
  int tmp___11 ;
  unsigned char c ;
  int tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned char hi___1 ;

  {
  {
#line 1719
  tmp = new_comp_struct();
#line 1719
  new___1 = tmp;
  }
  {
#line 1729
  if ((int const   )*(*pp + 0) == 0) {
#line 1729
    goto case_0;
  }
#line 1736
  if ((int const   )*(*pp + 0) == 41) {
#line 1736
    goto case_41;
  }
#line 1736
  if ((int const   )*(*pp + 0) == 124) {
#line 1736
    goto case_41;
  }
#line 1740
  if ((int const   )*(*pp + 0) == 46) {
#line 1740
    goto case_46;
  }
#line 1748
  if ((int const   )*(*pp + 0) == 62) {
#line 1748
    goto case_62;
  }
#line 1748
  if ((int const   )*(*pp + 0) == 60) {
#line 1748
    goto case_62;
  }
#line 1756
  if ((int const   )*(*pp + 0) == 36) {
#line 1756
    goto case_36;
  }
#line 1763
  if ((int const   )*(*pp + 0) == 94) {
#line 1763
    goto case_94;
  }
#line 1772
  if ((int const   )*(*pp + 0) == 63) {
#line 1772
    goto case_63;
  }
#line 1772
  if ((int const   )*(*pp + 0) == 43) {
#line 1772
    goto case_63;
  }
#line 1772
  if ((int const   )*(*pp + 0) == 42) {
#line 1772
    goto case_63;
  }
#line 1777
  if ((int const   )*(*pp + 0) == 91) {
#line 1777
    goto case_91;
  }
#line 1782
  if ((int const   )*(*pp + 0) == 40) {
#line 1782
    goto case_40;
  }
#line 1824
  if ((int const   )*(*pp + 0) == 92) {
#line 1824
    goto case_92;
  }
#line 1727
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1730
  new___1->type = this_regex_match;
#line 1731
  new___1->regex_bytes_needed = 1U;
#line 1732
  new___1->min_match_len = 0U;
#line 1733
  return (new___1);
  case_41: /* CIL Label */ 
  case_124: /* CIL Label */ 
  {
#line 1737
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1737
    die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
        1737);
    }
#line 1737
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1738
  goto switch_break;
  case_46: /* CIL Label */ 
#line 1741
  new___1->type = (enum TYPE )7;
#line 1742
  new___1->regex_bytes_needed = 1U;
#line 1743
  new___1->min_match_len = 1U;
#line 1744
  (*pp) ++;
#line 1745
  goto allow_starplus;
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
#line 1749
  (*pp) ++;
  word_boundary: 
#line 1751
  new___1->type = (enum TYPE )20;
#line 1752
  new___1->must_match = 1;
#line 1753
  new___1->regex_bytes_needed = 1U;
#line 1754
  return (new___1);
  case_36: /* CIL Label */ 
#line 1757
  new___1->type = (enum TYPE )22;
#line 1758
  new___1->must_match = 1;
#line 1759
  new___1->regex_bytes_needed = 1U;
#line 1760
  (*pp) ++;
#line 1761
  return (new___1);
  case_94: /* CIL Label */ 
#line 1764
  new___1->type = (enum TYPE )21;
#line 1765
  new___1->must_match = 1;
#line 1766
  new___1->regex_bytes_needed = 1U;
#line 1767
  (*pp) ++;
#line 1768
  return (new___1);
  case_63: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  {
#line 1774
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1774
    regcomp_error = 7U;
#line 1774
    regcomp_eptr = *pp;
#line 1774
    return ((struct intermediate *)0);
#line 1774
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  case_91: /* CIL Label */ 
  {
#line 1778
  *pp = nab_class(new___1, *pp + 1);
  }
#line 1778
  if ((unsigned long )*pp == (unsigned long )((unsigned char const   *)0)) {
#line 1779
    return ((struct intermediate *)0);
  }
#line 1780
  goto allow_starplus;
  case_40: /* CIL Label */ 
#line 1783
  (*pp) ++;
#line 1785
  if ((int const   )*(*pp + 0) != 63) {
#line 1787
    new___1->u.paren_info.real = (char)1;
  } else
#line 1785
  if ((int const   )*(*pp + 1) != 58) {
#line 1787
    new___1->u.paren_info.real = (char)1;
  } else {
#line 1789
    *pp += 2;
#line 1790
    new___1->u.paren_info.real = (char)0;
  }
#line 1792
  new___1->type = (enum TYPE )31;
#line 1794
  if (new___1->u.paren_info.real) {
#line 1795
    tmp___0 = paren_level;
#line 1795
    paren_level ++;
#line 1795
    new___1->u.paren_info.level = (unsigned char )tmp___0;
  }
  {
#line 1800
  tmp___1 = nibble_list(pp, (struct intermediate  const  *)new___1);
#line 1800
  new___1->u.paren_info.paren = tmp___1;
  }
#line 1800
  if ((unsigned long )tmp___1 == (unsigned long )((struct intermediate *)0)) {
#line 1801
    return ((struct intermediate *)0);
  }
#line 1804
  new___1->must_match = (new___1->u.paren_info.paren)->must_match;
#line 1805
  new___1->min_match_len = (new___1->u.paren_info.paren)->min_match_len;
#line 1806
  new___1->regex_bytes_needed = (new___1->u.paren_info.paren)->regex_bytes_needed;
#line 1809
  if (new___1->u.paren_info.real) {
#line 1811
    new___1->u.paren_info.max_internal_level = (unsigned char )(paren_level - 1U);
#line 1818
    if (regcomp_flags & 64U) {
#line 1819
      new___1->regex_bytes_needed += 4U;
    }
  }
#line 1822
  goto allow_starplus;
  case_92: /* CIL Label */ 
#line 1826
  if ((int const   )*(*pp + 1) != 48) {
    {
#line 1826
    tmp___2 = __ctype_b_loc();
    }
#line 1826
    if ((int const   )*(*tmp___2 + (int )*(*pp + 1)) & 2048) {
#line 1826
      if ((int const   )*(*pp + 2) >= 48) {
#line 1826
        if (! ((int const   )*(*pp + 2) <= 55)) {
#line 1826
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1830
        if ((regcomp_flags & 64U) == 0U) {
          {
#line 1832
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1832
            regcomp_error = 13U;
#line 1832
            regcomp_eptr = *pp;
#line 1832
            return ((struct intermediate *)0);
#line 1832
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1835
        new___1->type = (enum TYPE )30;
#line 1836
        new___1->u.prev_paren_to_match = (unsigned int )(((int const   )*(*pp + 1) - 48) - 1);
#line 1837
        if (new___1->u.prev_paren_to_match > paren_levels_finished) {
          {
#line 1838
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1838
            regcomp_error = 12U;
#line 1838
            regcomp_eptr = *pp;
#line 1838
            return ((struct intermediate *)0);
#line 1838
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 1840
        if ((int )new___1->u.prev_paren_to_match > highest_prev_to_match) {
#line 1841
          highest_prev_to_match = (int )new___1->u.prev_paren_to_match;
        }
#line 1843
        new___1->regex_bytes_needed = 2U;
#line 1844
        new___1->min_match_len = 0U;
#line 1845
        new___1->must_match = 1;
#line 1846
        *pp += 2;
#line 1847
        goto allow_starplus;
      }
    }
  }
  {
#line 1854
  if ((int const   )*(*pp + 1) == 98) {
#line 1854
    goto case_98;
  }
#line 1861
  if ((int const   )*(*pp + 1) == 67) {
#line 1861
    goto case_67;
  }
#line 1861
  if ((int const   )*(*pp + 1) == 75) {
#line 1861
    goto case_67;
  }
#line 1861
  if ((int const   )*(*pp + 1) == 72) {
#line 1861
    goto case_67;
  }
#line 1861
  if ((int const   )*(*pp + 1) == 97) {
#line 1861
    goto case_67;
  }
#line 1876
  if ((int const   )*(*pp + 1) == 99) {
#line 1876
    goto case_99;
  }
#line 1876
  if ((int const   )*(*pp + 1) == 107) {
#line 1876
    goto case_99;
  }
#line 1876
  if ((int const   )*(*pp + 1) == 104) {
#line 1876
    goto case_99;
  }
#line 1876
  if ((int const   )*(*pp + 1) == 65) {
#line 1876
    goto case_99;
  }
#line 1894
  if ((int const   )*(*pp + 1) == 83) {
#line 1894
    goto case_83;
  }
#line 1894
  if ((int const   )*(*pp + 1) == 87) {
#line 1894
    goto case_83;
  }
#line 1894
  if ((int const   )*(*pp + 1) == 68) {
#line 1894
    goto case_83;
  }
#line 1894
  if ((int const   )*(*pp + 1) == 115) {
#line 1894
    goto case_83;
  }
#line 1894
  if ((int const   )*(*pp + 1) == 119) {
#line 1894
    goto case_83;
  }
#line 1894
  if ((int const   )*(*pp + 1) == 100) {
#line 1894
    goto case_83;
  }
#line 1852
  goto switch_break___0;
  case_98: /* CIL Label */ 
#line 1855
  *pp += 2;
#line 1856
  goto word_boundary;
  case_67: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_97: /* CIL Label */ 
  {
#line 1863
  if ((int const   )*(*pp + 1) == 97) {
#line 1863
    goto case_97___0;
  }
#line 1864
  if ((int const   )*(*pp + 1) == 72) {
#line 1864
    goto case_72___0;
  }
#line 1865
  if ((int const   )*(*pp + 1) == 75) {
#line 1865
    goto case_75___0;
  }
#line 1866
  if ((int const   )*(*pp + 1) == 67) {
#line 1866
    goto case_67___0;
  }
#line 1862
  goto switch_break___1;
  case_97___0: /* CIL Label */ 
#line 1863
  new___1->type = (enum TYPE )8;
#line 1863
  goto switch_break___1;
  case_72___0: /* CIL Label */ 
#line 1864
  new___1->type = (enum TYPE )13;
#line 1864
  goto switch_break___1;
  case_75___0: /* CIL Label */ 
#line 1865
  new___1->type = (enum TYPE )11;
#line 1865
  goto switch_break___1;
  case_67___0: /* CIL Label */ 
#line 1866
  new___1->type = (enum TYPE )15;
#line 1866
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1868
  new___1->regex_bytes_needed = 1U;
#line 1869
  new___1->min_match_len = 1U;
#line 1870
  *pp += 2;
#line 1871
  goto allow_starplus;
  case_99: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_65: /* CIL Label */ 
  {
#line 1878
  if ((int const   )*(*pp + 1) == 65) {
#line 1878
    goto case_65___0;
  }
#line 1879
  if ((int const   )*(*pp + 1) == 104) {
#line 1879
    goto case_104___0;
  }
#line 1880
  if ((int const   )*(*pp + 1) == 107) {
#line 1880
    goto case_107___0;
  }
#line 1881
  if ((int const   )*(*pp + 1) == 99) {
#line 1881
    goto case_99___0;
  }
#line 1877
  goto switch_break___2;
  case_65___0: /* CIL Label */ 
#line 1878
  new___1->type = (enum TYPE )9;
#line 1878
  goto switch_break___2;
  case_104___0: /* CIL Label */ 
#line 1879
  new___1->type = (enum TYPE )12;
#line 1879
  goto switch_break___2;
  case_107___0: /* CIL Label */ 
#line 1880
  new___1->type = (enum TYPE )10;
#line 1880
  goto switch_break___2;
  case_99___0: /* CIL Label */ 
#line 1881
  new___1->type = (enum TYPE )14;
#line 1881
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1883
  new___1->regex_bytes_needed = 1U;
#line 1884
  new___1->min_match_len = 2U;
#line 1885
  *pp += 2;
#line 1886
  goto allow_starplus;
  case_83: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_100: /* CIL Label */ 
  {
#line 1898
  tmp___3 = __ctype_b_loc();
#line 1898
  inverted = (int )((int const   )*(*tmp___3 + (int )*(*pp + 1)) & 256);
#line 1900
  i = 0;
  }
#line 1901
  if (inverted) {
#line 1902
    tmp___4 = i;
#line 1902
    i ++;
#line 1902
    class[tmp___4] = (unsigned char )'^';
  }
#line 1904
  tmp___5 = i;
#line 1904
  i ++;
#line 1904
  class[tmp___5] = (unsigned char )'\\';
#line 1905
  tmp___6 = i;
#line 1905
  i ++;
#line 1905
  if (inverted) {
    {
#line 1905
    tmp___7 = tolower((int )*(*pp + 1));
#line 1905
    class[tmp___6] = (unsigned char )tmp___7;
    }
  } else {
#line 1905
    class[tmp___6] = (unsigned char )*(*pp + 1);
  }
  {
#line 1906
  tmp___8 = i;
#line 1906
  i ++;
#line 1906
  class[tmp___8] = (unsigned char )']';
#line 1907
  tmp___9 = i;
#line 1907
  i ++;
#line 1907
  class[tmp___9] = (unsigned char )'\000';
#line 1908
  tmp___10 = nab_class(new___1, (unsigned char const   *)(class));
  }
#line 1908
  if ((unsigned long )tmp___10 == (unsigned long )((unsigned char const   *)0)) {
#line 1909
    return ((struct intermediate *)0);
  }
#line 1911
  new___1->min_match_len = 1U;
#line 1912
  *pp += 2;
#line 1913
  goto allow_starplus;
  switch_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1919
  tmp___11 = next_quoted_character(pp, this);
  }
  {
#line 1924
  if (tmp___11 == 1) {
#line 1924
    goto case_1;
  }
#line 1943
  if (tmp___11 == 2) {
#line 1943
    goto case_2;
  }
#line 1963
  if (tmp___11 == 3) {
#line 1963
    goto case_3;
  }
#line 1921
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 1922
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1922
    regcomp_error = 16U;
#line 1922
    regcomp_eptr = *pp;
#line 1922
    return ((struct intermediate *)0);
#line 1922
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  case_1: /* CIL Label */ 
#line 1926
  c = this[0];
#line 1928
  if (regcomp_flags & 4U) {
#line 1928
    if (((int )c & -128) == 0) {
      {
#line 1928
      tmp___14 = __ctype_b_loc();
      }
#line 1928
      if ((int const   )*(*tmp___14 + (int )c) & 1024) {
        {
#line 1931
        new___1->type = (enum TYPE )5;
#line 1932
        tmp___13 = __ctype_b_loc();
        }
#line 1932
        if ((int const   )*(*tmp___13 + (int )c) & 256) {
          {
#line 1933
          tmp___12 = tolower((int )c);
#line 1933
          c = (unsigned char )tmp___12;
          }
        }
      } else {
#line 1935
        new___1->type = (enum TYPE )1;
      }
    } else {
#line 1935
      new___1->type = (enum TYPE )1;
    }
  } else {
#line 1935
    new___1->type = (enum TYPE )1;
  }
#line 1937
  new___1->u.exact[0] = c;
#line 1939
  new___1->min_match_len = 1U;
#line 1940
  new___1->regex_bytes_needed = 2U;
#line 1941
  goto switch_break___3;
  case_2: /* CIL Label */ 
#line 1945
  hi___1 = this[0];
#line 1948
  if (regcomp_flags & 8U) {
#line 1948
    if ((int )hi___1 == 164) {
#line 1951
      new___1->type = (enum TYPE )6;
#line 1952
      hi___1 = (unsigned char)164;
    } else
#line 1948
    if ((int )hi___1 == 165) {
#line 1951
      new___1->type = (enum TYPE )6;
#line 1952
      hi___1 = (unsigned char)164;
    } else {
#line 1954
      new___1->type = (enum TYPE )2;
    }
  } else {
#line 1954
    new___1->type = (enum TYPE )2;
  }
#line 1956
  new___1->u.exact[0] = hi___1;
#line 1957
  new___1->u.exact[1] = this[1];
#line 1959
  new___1->min_match_len = 2U;
#line 1960
  new___1->regex_bytes_needed = 3U;
#line 1961
  goto switch_break___3;
  case_3: /* CIL Label */ 
#line 1964
  new___1->type = (enum TYPE )4;
#line 1965
  new___1->u.exact[0] = this[0];
#line 1966
  new___1->u.exact[1] = this[1];
#line 1967
  new___1->u.exact[2] = this[2];
#line 1968
  new___1->min_match_len = 3U;
#line 1969
  new___1->regex_bytes_needed = 4U;
#line 1970
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1973
  goto allow_starplus;
  allow_starplus: 
  {
#line 1991
  if ((int const   )*(*pp + 0) == 43) {
#line 1991
    goto case_43___0;
  }
#line 2000
  if ((int const   )*(*pp + 0) == 42) {
#line 2000
    goto case_42___0;
  }
#line 2011
  if ((int const   )*(*pp + 0) == 63) {
#line 2011
    goto case_63___0;
  }
#line 2019
  goto switch_default___0;
  case_43___0: /* CIL Label */ 
#line 1991
  new___1->count = (unsigned char)2;
#line 1992
  (*pp) ++;
#line 1993
  if ((unsigned int )new___1->type == 31U) {
#line 1994
    if (new___1->min_match_len == 0U) {
      {
#line 1995
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1995
        regcomp_error = 8U;
#line 1995
        regcomp_eptr = *pp;
#line 1995
        return ((struct intermediate *)0);
#line 1995
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1996
    new___1->regex_bytes_needed += 7U;
  }
#line 1998
  goto switch_break___4;
  case_42___0: /* CIL Label */ 
#line 2000
  new___1->count = (unsigned char)3;
#line 2001
  (*pp) ++;
#line 2002
  if ((unsigned int )new___1->type == 31U) {
#line 2003
    if (new___1->min_match_len == 0U) {
      {
#line 2004
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2004
        regcomp_error = 9U;
#line 2004
        regcomp_eptr = *pp;
#line 2004
        return ((struct intermediate *)0);
#line 2004
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 2005
    new___1->regex_bytes_needed += 10U;
  }
#line 2007
  new___1->min_match_len = 0U;
#line 2008
  new___1->must_match = 0;
#line 2009
  goto switch_break___4;
  case_63___0: /* CIL Label */ 
#line 2011
  new___1->count = (unsigned char)1;
#line 2012
  (*pp) ++;
#line 2013
  new___1->min_match_len = 0U;
#line 2014
  new___1->must_match = 0;
#line 2015
  if ((unsigned int )new___1->type == 31U) {
#line 2016
    new___1->regex_bytes_needed += 6U;
  }
#line 2017
  goto switch_break___4;
  switch_default___0: /* CIL Label */ 
#line 2020
  new___1->count = (unsigned char)0;
#line 2021
  if ((unsigned int )new___1->type == 31U) {
#line 2022
    new___1->regex_bytes_needed += 4U;
  }
#line 2023
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 2027
  if (new___1->min_match_len != 0U) {
#line 2028
    new___1->must_match = 1;
  }
#line 2030
  return (new___1);
}
}
#line 2035
static void write_regex_buffer(struct intermediate  const  *inter , unsigned char **bb ,
                               int noomit , unsigned char **musthave ) ;
#line 2050 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static void write_regex_buffer_for_class(struct intermediate  const  *inter ,
                                                  unsigned char **bb ) 
{ 
  struct class  const  *class ;
  unsigned int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 2054
  class = (struct class  const  *)inter->u.class;
#line 2062
  tmp = *bb;
#line 2062
  (*bb) ++;
#line 2062
  *tmp = (unsigned char )((16 << 2) | (int )inter->count);
#line 2063
  tmp___0 = *bb;
#line 2063
  (*bb) ++;
#line 2063
  *tmp___0 = (unsigned char )class->inverted;
  {
#line 2064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2064
    *(*bb + 0) = (unsigned char )((int )((short )class->euc2.buf_used) >> 8);
#line 2064
    *(*bb + 1) = (unsigned char )((int )((short )class->euc2.buf_used) & 255);
#line 2064
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2065
  *bb += 2;
  {
#line 2066
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2066
    *(*bb + 0) = (unsigned char )((int )((short )class->euc3.buf_used) >> 8);
#line 2066
    *(*bb + 1) = (unsigned char )((int )((short )class->euc3.buf_used) & 255);
#line 2066
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2067
  *bb += 2;
#line 2069
  i = 0U;
  {
#line 2069
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2069
    if (! ((unsigned long )i < sizeof(class->ascii))) {
#line 2069
      goto while_break___1;
    }
#line 2070
    tmp___1 = *bb;
#line 2070
    (*bb) ++;
#line 2070
    *tmp___1 = class->ascii[i];
#line 2069
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2072
  i = 0U;
  {
#line 2072
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2072
    if (! (i < (unsigned int )class->euc2.buf_used)) {
#line 2072
      goto while_break___2;
    }
#line 2073
    tmp___2 = *bb;
#line 2073
    (*bb) ++;
#line 2073
    *tmp___2 = *(class->euc2.buf + i);
#line 2072
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2075
  i = 0U;
  {
#line 2075
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2075
    if (! (i < (unsigned int )class->euc3.buf_used)) {
#line 2075
      goto while_break___3;
    }
#line 2076
    tmp___3 = *bb;
#line 2076
    (*bb) ++;
#line 2076
    *tmp___3 = *(class->euc3.buf + i);
#line 2075
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2078
  return;
}
}
#line 2080 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static unsigned char *consolidate_musthave(unsigned char *range1_start ,
                                                    unsigned char const   *range1_end ,
                                                    unsigned char const   *range2_start ,
                                                    unsigned char const   *range2_end ) 
{ 
  unsigned char *dest ;
  unsigned char *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char const   *tmp___7 ;

  {
#line 2086
  dest = range1_start;
  {
#line 2093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2093
    if (! ((unsigned long )range1_start < (unsigned long )range1_end)) {
#line 2093
      goto while_break;
    }
    {
#line 2102
    if (((int const   )euc_info[*(range1_start + 0)] & 3) == 1) {
#line 2102
      goto case_1;
    }
#line 2109
    if (((int const   )euc_info[*(range1_start + 0)] & 3) == 2) {
#line 2109
      goto case_2;
    }
#line 2119
    if (((int const   )euc_info[*(range1_start + 0)] & 3) == 3) {
#line 2119
      goto case_3;
    }
#line 2097
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 2098
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2098
      die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
          2098);
      }
#line 2098
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2099
    range1_start ++;
#line 2100
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2103
    tmp___0 = onebyte_char_in_string(*(range1_start + 0), range2_start, range2_end);
    }
#line 2103
    if (tmp___0) {
#line 2105
      tmp = dest;
#line 2105
      dest ++;
#line 2105
      *tmp = *(range1_start + 0);
    }
#line 2106
    range1_start ++;
#line 2107
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2110
    tmp___3 = twobyte_char_in_string(*(range1_start + 0), *(range1_start + 1), range2_start,
                                     range2_end);
    }
#line 2110
    if (tmp___3) {
#line 2113
      tmp___1 = dest;
#line 2113
      dest ++;
#line 2113
      *tmp___1 = *(range1_start + 0);
#line 2114
      tmp___2 = dest;
#line 2114
      dest ++;
#line 2114
      *tmp___2 = *(range1_start + 1);
    }
#line 2116
    range1_start += 2;
#line 2117
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 2120
    tmp___7 = threebyte_char_in_string(*(range1_start + 0), *(range1_start + 1), *(range1_start + 2),
                                       range2_start, range2_end);
    }
#line 2120
    if (tmp___7) {
#line 2124
      tmp___4 = dest;
#line 2124
      dest ++;
#line 2124
      *tmp___4 = *(range1_start + 0);
#line 2125
      tmp___5 = dest;
#line 2125
      dest ++;
#line 2125
      *tmp___5 = *(range1_start + 1);
#line 2126
      tmp___6 = dest;
#line 2126
      dest ++;
#line 2126
      *tmp___6 = *(range1_start + 2);
    }
#line 2128
    range1_start += 3;
#line 2129
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2137
  return (dest);
}
}
#line 2164 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void write_regex_buffer_for_alt(struct intermediate  const  *inter , unsigned char **bb ,
                                       int noomit , unsigned char **musthave ) 
{ 
  unsigned char *push ;
  unsigned char *jump ;
  unsigned char *musthave_base ;
  unsigned char *tmp ;
  unsigned char *musthave_altbase ;
  unsigned char *tmp___0 ;
  unsigned char const   *p1 ;
  unsigned char *p1___0 ;

  {
#line 2170
  jump = (unsigned char *)0;
#line 2171
  if (musthave) {
#line 2171
    tmp = *musthave;
  } else {
#line 2171
    tmp = (unsigned char *)0;
  }
#line 2171
  musthave_base = tmp;
#line 2175
  if ((unsigned long )inter->nextalt == (unsigned long )((struct intermediate */* const  */)0)) {
    {
#line 2176
    write_regex_buffer(inter, bb, noomit, musthave);
    }
#line 2177
    return;
  }
  {
#line 2181
  push = *bb;
#line 2182
  *bb += 3;
#line 2185
  write_regex_buffer(inter, bb, noomit, musthave);
  }
#line 2187
  if (musthave) {
#line 2187
    musthave_altbase = *musthave;
  } else {
#line 2187
    musthave_altbase = (unsigned char *)0;
  }
#line 2189
  if (! noomit) {
#line 2192
    tmp___0 = *bb;
#line 2192
    (*bb) ++;
#line 2192
    *tmp___0 = (unsigned char )((unsigned int )this_regex_match << 2);
  } else {
#line 2195
    jump = *bb;
#line 2196
    *bb += 3;
  }
#line 2200
  *push = (unsigned char )(24 << 2);
  {
#line 2201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2201
    *((push + 1) + 0) = (unsigned char )((int )((short )(*bb - push)) >> 8);
#line 2201
    *((push + 1) + 1) = (unsigned char )((int )((short )(*bb - push)) & 255);
#line 2201
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2204
  write_regex_buffer_for_alt((struct intermediate  const  *)inter->nextalt, bb, noomit,
                             musthave);
  }
#line 2206
  if (noomit) {
#line 2209
    *jump = (unsigned char )(23 << 2);
    {
#line 2210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2210
      *((jump + 1) + 0) = (unsigned char )((int )((short )(*bb - jump)) >> 8);
#line 2210
      *((jump + 1) + 1) = (unsigned char )((int )((short )(*bb - jump)) & 255);
#line 2210
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2221
  if (musthave_base) {
#line 2224
    if (regcomp_flags & 1U) {
      {
#line 2227
      output("intersection of [");
#line 2228
      p1 = (unsigned char const   *)musthave_base;
      }
      {
#line 2228
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2228
        if (! ((unsigned long )p1 < (unsigned long )musthave_altbase)) {
#line 2228
          goto while_break___1;
        }
#line 2229
        if (*p1) {
          {
#line 2229
          (*_output_char_function)((unsigned char )*p1);
          }
        }
#line 2228
        p1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2230
      output("] and [");
#line 2232
      p1 = (unsigned char const   *)musthave_altbase;
      }
      {
#line 2232
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2232
        if (! ((unsigned long )p1 < (unsigned long )*musthave)) {
#line 2232
          goto while_break___2;
        }
#line 2233
        if (*p1) {
          {
#line 2233
          (*_output_char_function)((unsigned char )*p1);
          }
        }
#line 2232
        p1 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2234
      output("] yields ");
      }
    }
    {
#line 2238
    *musthave = consolidate_musthave(musthave_base, (unsigned char const   *)musthave_altbase,
                                     (unsigned char const   *)musthave_altbase, (unsigned char const   *)*musthave);
    }
#line 2241
    if (regcomp_flags & 1U) {
      {
#line 2243
      (*_output_char_function)((unsigned char )'[');
#line 2244
      p1___0 = musthave_base;
      }
      {
#line 2244
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2244
        if (! ((unsigned long )p1___0 < (unsigned long )*musthave)) {
#line 2244
          goto while_break___3;
        }
#line 2245
        if (*p1___0) {
          {
#line 2245
          (*_output_char_function)(*p1___0);
          }
        }
#line 2244
        p1___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 2246
      output("]\n");
      }
    }
  }
#line 2250
  return;
}
}
#line 2262 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void write_regex_buffer(struct intermediate  const  *inter , unsigned char **bb ,
                               int noomit , unsigned char **musthave ) 
{ 
  int must_not_omit ;
  int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  int real ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *push_loc ;
  unsigned char *mark1_loc ;
  unsigned char *jump_loc ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned int l ;
  unsigned int c ;
  double lpc ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *marker ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *marker___0 ;
  unsigned char *base ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned int l___0 ;
  unsigned int c___0 ;
  double lpc___0 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char *tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned char *tmp___41 ;
  unsigned char *tmp___42 ;
  unsigned char *tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;

  {
  {
#line 2268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2268
    if (! ((unsigned long )inter != (unsigned long )((struct intermediate  const  *)0))) {
      {
#line 2268
      die("\nassert(inter != 0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
          2268);
      }
    }
#line 2268
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2270
    if (! inter) {
#line 2270
      goto while_break___0;
    }
#line 2278
    if (noomit) {
#line 2278
      tmp = 1;
    } else
#line 2278
    if (! (regcomp_flags & 16U)) {
#line 2278
      tmp = 1;
    } else
#line 2278
    if (inter->next) {
#line 2278
      if ((inter->next)->must_match) {
#line 2278
        tmp = 1;
      } else {
#line 2278
        tmp = 0;
      }
    } else {
#line 2278
      tmp = 0;
    }
#line 2278
    must_not_omit = tmp;
#line 2285
    if (! must_not_omit) {
#line 2285
      if (! inter->must_match) {
#line 2287
        tmp___0 = *bb;
#line 2287
        (*bb) ++;
#line 2287
        *tmp___0 = (unsigned char )((unsigned int )this_regex_match << 2);
#line 2288
        return;
      }
    }
    {
#line 2297
    if ((unsigned int const   )inter->type == 0U) {
#line 2297
      goto case_0;
    }
#line 2304
    if ((unsigned int const   )inter->type == 21U) {
#line 2304
      goto case_21;
    }
#line 2304
    if ((unsigned int const   )inter->type == 22U) {
#line 2304
      goto case_21;
    }
#line 2304
    if ((unsigned int const   )inter->type == 20U) {
#line 2304
      goto case_21;
    }
#line 2304
    if ((unsigned int const   )inter->type == 19U) {
#line 2304
      goto case_21;
    }
#line 2304
    if ((unsigned int const   )inter->type == 18U) {
#line 2304
      goto case_21;
    }
#line 2317
    if ((unsigned int const   )inter->type == 15U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 14U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 13U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 12U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 11U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 10U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 9U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 8U) {
#line 2317
      goto case_15;
    }
#line 2317
    if ((unsigned int const   )inter->type == 7U) {
#line 2317
      goto case_15;
    }
#line 2321
    if ((unsigned int const   )inter->type == 31U) {
#line 2321
      goto case_31;
    }
#line 2499
    if ((unsigned int const   )inter->type == 16U) {
#line 2499
      goto case_16;
    }
#line 2505
    if ((unsigned int const   )inter->type == 5U) {
#line 2505
      goto case_5;
    }
#line 2505
    if ((unsigned int const   )inter->type == 1U) {
#line 2505
      goto case_5;
    }
#line 2513
    if ((unsigned int const   )inter->type == 6U) {
#line 2513
      goto case_6;
    }
#line 2513
    if ((unsigned int const   )inter->type == 2U) {
#line 2513
      goto case_6;
    }
#line 2523
    if ((unsigned int const   )inter->type == 4U) {
#line 2523
      goto case_4;
    }
#line 2535
    if ((unsigned int const   )inter->type == 3U) {
#line 2535
      goto case_3___0;
    }
#line 2543
    if ((unsigned int const   )inter->type == 32U) {
#line 2543
      goto case_32;
    }
#line 2558
    if ((unsigned int const   )inter->type == 30U) {
#line 2558
      goto case_30;
    }
#line 2293
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 2294
    outputf("<<unknown type %d at line %d>>\n", (unsigned int const   )inter->type,
            2294);
    }
#line 2295
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2298
    goto switch_break;
    case_21: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_18: /* CIL Label */ 
#line 2306
    tmp___1 = *bb;
#line 2306
    (*bb) ++;
#line 2306
    *tmp___1 = (unsigned char )((unsigned int const   )inter->type << 2);
#line 2307
    goto switch_break;
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 2318
    tmp___2 = *bb;
#line 2318
    (*bb) ++;
#line 2318
    *tmp___2 = (unsigned char )(((unsigned int const   )inter->type << 2) | (unsigned int const   )inter->count);
#line 2319
    goto switch_break;
    case_31: /* CIL Label */ 
#line 2327
    if (inter->u.paren_info.real) {
#line 2327
      if (regcomp_flags & 64U) {
#line 2327
        tmp___3 = 1;
      } else {
#line 2327
        tmp___3 = 0;
      }
    } else {
#line 2327
      tmp___3 = 0;
    }
#line 2327
    real = tmp___3;
    {
#line 2334
    if ((int const   )inter->count == 0) {
#line 2334
      goto case_0___0;
    }
#line 2349
    if ((int const   )inter->count == 3) {
#line 2349
      goto case_3;
    }
#line 2410
    if ((int const   )inter->count == 1) {
#line 2410
      goto case_1;
    }
#line 2447
    if ((int const   )inter->count == 2) {
#line 2447
      goto case_2;
    }
#line 2332
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 2335
    if (real) {
#line 2335
      tmp___4 = *bb;
#line 2335
      (*bb) ++;
#line 2335
      *tmp___4 = (unsigned char )(26 << 2);
#line 2335
      tmp___5 = *bb;
#line 2335
      (*bb) ++;
#line 2335
      *tmp___5 = (unsigned char )inter->u.paren_info.level;
    }
    {
#line 2340
    write_regex_buffer((struct intermediate  const  *)inter->u.paren_info.paren, bb,
                       must_not_omit, musthave);
    }
#line 2343
    if (real) {
#line 2343
      tmp___6 = *bb;
#line 2343
      (*bb) ++;
#line 2343
      *tmp___6 = (unsigned char )(27 << 2);
#line 2343
      tmp___7 = *bb;
#line 2343
      (*bb) ++;
#line 2343
      *tmp___7 = (unsigned char )inter->u.paren_info.level;
    }
#line 2347
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 2357
    push_loc = *bb;
#line 2361
    tmp___8 = *bb;
#line 2361
    (*bb) ++;
#line 2361
    *tmp___8 = (unsigned char )(24 << 2);
#line 2362
    *bb += 2;
#line 2364
    mark1_loc = *bb;
#line 2366
    if (real) {
#line 2366
      mark1_loc = *bb;
#line 2366
      tmp___9 = *bb;
#line 2366
      (*bb) ++;
#line 2366
      *tmp___9 = (unsigned char )(26 << 2);
#line 2366
      tmp___10 = *bb;
#line 2366
      (*bb) ++;
#line 2366
      *tmp___10 = (unsigned char )inter->u.paren_info.level;
    }
    {
#line 2373
    write_regex_buffer((struct intermediate  const  *)inter->u.paren_info.paren, bb,
                       must_not_omit, (unsigned char **)0);
    }
#line 2377
    if (real) {
#line 2379
      l = (unsigned int )(((int const   )inter->u.paren_info.max_internal_level - (int const   )inter->u.paren_info.level) + 1);
#line 2381
      c = (inter->u.paren_info.paren)->min_match_len;
#line 2382
      lpc = (double )l / (double )c;
#line 2383
      jump_loc = *bb;
#line 2384
      tmp___11 = *bb;
#line 2384
      (*bb) ++;
#line 2384
      *tmp___11 = (unsigned char )(28 << 2);
#line 2385
      tmp___12 = *bb;
#line 2385
      (*bb) ++;
#line 2385
      *tmp___12 = (unsigned char )l;
#line 2386
      tmp___13 = *bb;
#line 2386
      (*bb) ++;
#line 2386
      *tmp___13 = (unsigned char )inter->u.paren_info.level;
#line 2388
      if (lpc > max_lpc) {
#line 2390
        max_lpc = lpc;
#line 2391
        max_lpc_l = l;
#line 2392
        max_lpc_c = c;
      }
    } else {
#line 2398
      jump_loc = *bb;
#line 2399
      tmp___14 = *bb;
#line 2399
      (*bb) ++;
#line 2399
      *tmp___14 = (unsigned char )(25 << 2);
    }
    {
#line 2401
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2401
      *(*bb + 0) = (unsigned char )((int )((short )(mark1_loc - jump_loc)) >> 8);
#line 2401
      *(*bb + 1) = (unsigned char )((int )((short )(mark1_loc - jump_loc)) & 255);
#line 2401
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2402
    *bb += 2;
    {
#line 2405
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2405
      *((push_loc + 1) + 0) = (unsigned char )((int )((short )(*bb - push_loc)) >> 8);
#line 2405
      *((push_loc + 1) + 1) = (unsigned char )((int )((short )(*bb - push_loc)) & 255);
#line 2405
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2407
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 2416
    marker = *bb;
#line 2420
    if (real) {
#line 2422
      *(*bb) = (unsigned char )(29 << 2);
#line 2423
      *bb += 3;
#line 2424
      tmp___15 = *bb;
#line 2424
      (*bb) ++;
#line 2424
      *tmp___15 = (unsigned char )inter->u.paren_info.level;
    } else {
#line 2429
      *(*bb) = (unsigned char )(24 << 2);
#line 2430
      *bb += 3;
    }
    {
#line 2434
    write_regex_buffer((struct intermediate  const  *)inter->u.paren_info.paren, bb,
                       must_not_omit, (unsigned char **)0);
    }
#line 2437
    if (real) {
#line 2437
      tmp___16 = *bb;
#line 2437
      (*bb) ++;
#line 2437
      *tmp___16 = (unsigned char )(27 << 2);
#line 2437
      tmp___17 = *bb;
#line 2437
      (*bb) ++;
#line 2437
      *tmp___17 = (unsigned char )inter->u.paren_info.level;
    }
    {
#line 2443
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2443
      *((marker + 1) + 0) = (unsigned char )((int )((short )(*bb - marker)) >> 8);
#line 2443
      *((marker + 1) + 1) = (unsigned char )((int )((short )(*bb - marker)) & 255);
#line 2443
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2444
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 2454
    marker___0 = *bb;
#line 2457
    if (real) {
#line 2457
      tmp___18 = *bb;
#line 2457
      (*bb) ++;
#line 2457
      *tmp___18 = (unsigned char )(26 << 2);
#line 2457
      tmp___19 = *bb;
#line 2457
      (*bb) ++;
#line 2457
      *tmp___19 = (unsigned char )inter->u.paren_info.level;
    }
    {
#line 2463
    write_regex_buffer((struct intermediate  const  *)inter->u.paren_info.paren, bb,
                       must_not_omit, musthave);
#line 2466
    base = *bb;
    }
#line 2468
    if (real) {
#line 2470
      l___0 = (unsigned int )(((int const   )inter->u.paren_info.max_internal_level - (int const   )inter->u.paren_info.level) + 1);
#line 2472
      c___0 = (inter->u.paren_info.paren)->min_match_len;
#line 2473
      lpc___0 = (double )l___0 / (double )c___0;
#line 2474
      tmp___20 = *bb;
#line 2474
      (*bb) ++;
#line 2474
      *tmp___20 = (unsigned char )(28 << 2);
#line 2475
      tmp___21 = *bb;
#line 2475
      (*bb) ++;
#line 2475
      *tmp___21 = (unsigned char )l___0;
#line 2476
      tmp___22 = *bb;
#line 2476
      (*bb) ++;
#line 2476
      *tmp___22 = (unsigned char )inter->u.paren_info.level;
#line 2478
      if (lpc___0 > max_lpc) {
#line 2480
        max_lpc = lpc___0;
#line 2481
        max_lpc_l = l___0;
#line 2482
        max_lpc_c = c___0;
      }
    } else {
#line 2488
      tmp___23 = *bb;
#line 2488
      (*bb) ++;
#line 2488
      *tmp___23 = (unsigned char )(25 << 2);
    }
    {
#line 2491
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2491
      *(*bb + 0) = (unsigned char )((int )((short )(marker___0 - base)) >> 8);
#line 2491
      *(*bb + 1) = (unsigned char )((int )((short )(marker___0 - base)) & 255);
#line 2491
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2492
    *bb += 2;
#line 2493
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2496
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 2501
    write_regex_buffer_for_class(inter, bb);
    }
#line 2502
    goto switch_break;
    case_5: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 2506
    tmp___24 = *bb;
#line 2506
    (*bb) ++;
#line 2506
    *tmp___24 = (unsigned char )(((unsigned int const   )inter->type << 2) | (unsigned int const   )inter->count);
#line 2507
    tmp___25 = *bb;
#line 2507
    (*bb) ++;
#line 2507
    *tmp___25 = inter->u.exact[0];
#line 2508
    if (musthave) {
#line 2508
      if (! ((int const   )inter->count & 1)) {
#line 2509
        tmp___26 = *musthave;
#line 2509
        (*musthave) ++;
#line 2509
        *tmp___26 = inter->u.exact[0];
      }
    }
#line 2510
    goto switch_break;
    case_6: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
#line 2514
    tmp___27 = *bb;
#line 2514
    (*bb) ++;
#line 2514
    *tmp___27 = (unsigned char )(((unsigned int const   )inter->type << 2) | (unsigned int const   )inter->count);
#line 2515
    tmp___28 = *bb;
#line 2515
    (*bb) ++;
#line 2515
    *tmp___28 = inter->u.exact[0];
#line 2516
    tmp___29 = *bb;
#line 2516
    (*bb) ++;
#line 2516
    *tmp___29 = inter->u.exact[1];
#line 2517
    if (musthave) {
#line 2517
      if (! ((int const   )inter->count & 1)) {
#line 2518
        tmp___30 = *musthave;
#line 2518
        (*musthave) ++;
#line 2518
        *tmp___30 = inter->u.exact[0];
#line 2519
        tmp___31 = *musthave;
#line 2519
        (*musthave) ++;
#line 2519
        *tmp___31 = inter->u.exact[1];
      }
    }
#line 2521
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2524
    tmp___32 = *bb;
#line 2524
    (*bb) ++;
#line 2524
    *tmp___32 = (unsigned char )(((unsigned int const   )inter->type << 2) | (unsigned int const   )inter->count);
#line 2525
    tmp___33 = *bb;
#line 2525
    (*bb) ++;
#line 2525
    *tmp___33 = inter->u.exact[0];
#line 2526
    tmp___34 = *bb;
#line 2526
    (*bb) ++;
#line 2526
    *tmp___34 = inter->u.exact[1];
#line 2527
    tmp___35 = *bb;
#line 2527
    (*bb) ++;
#line 2527
    *tmp___35 = inter->u.exact[2];
#line 2528
    if (musthave) {
#line 2528
      if (! ((int const   )inter->count & 1)) {
#line 2529
        tmp___36 = *musthave;
#line 2529
        (*musthave) ++;
#line 2529
        *tmp___36 = inter->u.exact[0];
#line 2530
        tmp___37 = *musthave;
#line 2530
        (*musthave) ++;
#line 2530
        *tmp___37 = inter->u.exact[1];
#line 2531
        tmp___38 = *musthave;
#line 2531
        (*musthave) ++;
#line 2531
        *tmp___38 = inter->u.exact[2];
      }
    }
#line 2533
    goto switch_break;
    case_3___0: /* CIL Label */ 
#line 2536
    tmp___39 = *bb;
#line 2536
    (*bb) ++;
#line 2536
    *tmp___39 = (unsigned char )(((unsigned int const   )inter->type << 2) | (unsigned int const   )inter->count);
#line 2537
    tmp___40 = *bb;
#line 2537
    (*bb) ++;
#line 2537
    *tmp___40 = inter->u.exact[0];
#line 2538
    tmp___41 = *bb;
#line 2538
    (*bb) ++;
#line 2538
    *tmp___41 = inter->u.exact[1];
#line 2539
    tmp___42 = *bb;
#line 2539
    (*bb) ++;
#line 2539
    *tmp___42 = inter->u.exact[2];
#line 2540
    tmp___43 = *bb;
#line 2540
    (*bb) ++;
#line 2540
    *tmp___43 = inter->u.exact[3];
#line 2541
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 2553
    write_regex_buffer_for_alt((struct intermediate  const  *)inter->u.alt, bb, must_not_omit,
                               musthave);
    }
#line 2556
    goto switch_break;
    case_30: /* CIL Label */ 
#line 2559
    tmp___44 = *bb;
#line 2559
    (*bb) ++;
#line 2559
    *tmp___44 = (unsigned char )(30 << 2);
#line 2560
    tmp___45 = *bb;
#line 2560
    (*bb) ++;
#line 2560
    *tmp___45 = (unsigned char )inter->u.prev_paren_to_match;
#line 2561
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2563
    inter = (struct intermediate  const  *)inter->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2565
  return;
}
}
#line 2571 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void show_intermediate_pattern(struct intermediate  const  *inter , unsigned int level ) 
{ 
  unsigned int i ;
  char const   *countmemo ;
  unsigned int i___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  struct intermediate *ptr ;

  {
#line 2574
  if ((unsigned long )inter == (unsigned long )((struct intermediate  const  *)0)) {
#line 2576
    i = 0U;
    {
#line 2576
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2576
      if (! (i < level)) {
#line 2576
        goto while_break;
      }
      {
#line 2577
      (*_output_char_function)((unsigned char )'|');
#line 2576
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2578
    output(" <<NULL>>\n");
    }
#line 2579
    return;
  }
  {
#line 2582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2582
    if (! inter) {
#line 2582
      goto while_break___0;
    }
#line 2587
    i___0 = 0U;
    {
#line 2587
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2587
      if (! (i___0 < level)) {
#line 2587
        goto while_break___1;
      }
      {
#line 2588
      (*_output_char_function)((unsigned char )(48U + i___0));
#line 2587
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2590
    if (inter->must_match) {
#line 2590
      tmp = '!';
    } else {
#line 2590
      tmp = ' ';
    }
    {
#line 2590
    outputf("[%c r=%02d m=%02d] ", tmp, inter->regex_bytes_needed, inter->min_match_len);
    }
    {
#line 2595
    if ((int const   )inter->count == 0) {
#line 2595
      goto case_0;
    }
#line 2596
    if ((int const   )inter->count == 3) {
#line 2596
      goto case_3;
    }
#line 2597
    if ((int const   )inter->count == 1) {
#line 2597
      goto case_1;
    }
#line 2598
    if ((int const   )inter->count == 2) {
#line 2598
      goto case_2;
    }
#line 2599
    goto switch_default;
    case_0: /* CIL Label */ 
#line 2595
    countmemo = "";
#line 2595
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2596
    countmemo = " (*)";
#line 2596
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2597
    countmemo = " (?)";
#line 2597
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2598
    countmemo = " (+)";
#line 2598
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2599
    countmemo = "????????????";
#line 2599
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2608
    if ((unsigned int const   )inter->type == 0U) {
#line 2608
      goto case_0___0;
    }
#line 2609
    if ((unsigned int const   )inter->type == 18U) {
#line 2609
      goto case_18;
    }
#line 2610
    if ((unsigned int const   )inter->type == 19U) {
#line 2610
      goto case_19;
    }
#line 2612
    if ((unsigned int const   )inter->type == 7U) {
#line 2612
      goto case_7;
    }
#line 2613
    if ((unsigned int const   )inter->type == 8U) {
#line 2613
      goto case_8;
    }
#line 2614
    if ((unsigned int const   )inter->type == 9U) {
#line 2614
      goto case_9;
    }
#line 2615
    if ((unsigned int const   )inter->type == 10U) {
#line 2615
      goto case_10;
    }
#line 2616
    if ((unsigned int const   )inter->type == 11U) {
#line 2616
      goto case_11;
    }
#line 2617
    if ((unsigned int const   )inter->type == 12U) {
#line 2617
      goto case_12;
    }
#line 2618
    if ((unsigned int const   )inter->type == 13U) {
#line 2618
      goto case_13;
    }
#line 2619
    if ((unsigned int const   )inter->type == 14U) {
#line 2619
      goto case_14;
    }
#line 2620
    if ((unsigned int const   )inter->type == 15U) {
#line 2620
      goto case_15;
    }
#line 2621
    if ((unsigned int const   )inter->type == 20U) {
#line 2621
      goto case_20;
    }
#line 2622
    if ((unsigned int const   )inter->type == 22U) {
#line 2622
      goto case_22;
    }
#line 2623
    if ((unsigned int const   )inter->type == 21U) {
#line 2623
      goto case_21;
    }
#line 2625
    if ((unsigned int const   )inter->type == 31U) {
#line 2625
      goto case_31;
    }
#line 2636
    if ((unsigned int const   )inter->type == 30U) {
#line 2636
      goto case_30;
    }
#line 2642
    if ((unsigned int const   )inter->type == 16U) {
#line 2642
      goto case_16;
    }
#line 2666
    if ((unsigned int const   )inter->type == 1U) {
#line 2666
      goto case_1___0;
    }
#line 2670
    if ((unsigned int const   )inter->type == 5U) {
#line 2670
      goto case_5;
    }
#line 2674
    if ((unsigned int const   )inter->type == 2U) {
#line 2674
      goto case_2___0;
    }
#line 2679
    if ((unsigned int const   )inter->type == 3U) {
#line 2679
      goto case_3___0;
    }
#line 2685
    if ((unsigned int const   )inter->type == 6U) {
#line 2685
      goto case_6;
    }
#line 2690
    if ((unsigned int const   )inter->type == 4U) {
#line 2690
      goto case_4;
    }
#line 2696
    if ((unsigned int const   )inter->type == 32U) {
#line 2696
      goto case_32;
    }
#line 2604
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2605
    outputf("<<unknown type %d at line %d>>\n", (unsigned int const   )inter->type,
            2605);
    }
#line 2606
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 2608
    output("<nothing>\n");
    }
#line 2608
    goto switch_break___0;
    case_18: /* CIL Label */ 
    {
#line 2609
    output("regex match\n");
    }
#line 2609
    goto switch_break___0;
    case_19: /* CIL Label */ 
    {
#line 2611
    output("regex match (note word)\n");
    }
#line 2611
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 2612
    outputf("any char%s\n", countmemo);
    }
#line 2612
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 2613
    outputf("any ASCII%s\n", countmemo);
    }
#line 2613
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 2614
    outputf("any multibyte%s\n", countmemo);
    }
#line 2614
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 2615
    outputf("any katakana%s\n", countmemo);
    }
#line 2615
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 2616
    outputf("any non-katakana%s\n", countmemo);
    }
#line 2616
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 2617
    outputf("any hiragana%s\n", countmemo);
    }
#line 2617
    goto switch_break___0;
    case_13: /* CIL Label */ 
    {
#line 2618
    outputf("any non-hiragana%s\n", countmemo);
    }
#line 2618
    goto switch_break___0;
    case_14: /* CIL Label */ 
    {
#line 2619
    outputf("any kanji%s\n", countmemo);
    }
#line 2619
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 2620
    outputf("any non-kanji%s\n", countmemo);
    }
#line 2620
    goto switch_break___0;
    case_20: /* CIL Label */ 
    {
#line 2621
    output("word boundary\n");
    }
#line 2621
    goto switch_break___0;
    case_22: /* CIL Label */ 
    {
#line 2622
    output("end of line\n");
    }
#line 2622
    goto switch_break___0;
    case_21: /* CIL Label */ 
    {
#line 2623
    output("start of line\n");
    }
#line 2623
    goto switch_break___0;
    case_31: /* CIL Label */ 
    {
#line 2627
    outputf("group [level %u - %u]%s\n", (int const   )inter->u.paren_info.level,
            (int const   )inter->u.paren_info.max_internal_level, countmemo);
#line 2632
    show_intermediate_pattern((struct intermediate  const  *)inter->u.paren_info.paren,
                              level + 1U);
    }
#line 2633
    goto switch_break___0;
    case_30: /* CIL Label */ 
    {
#line 2637
    outputf("match previous paren group %d\n", inter->u.prev_paren_to_match);
    }
#line 2639
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 2644
    if ((inter->u.class)->inverted) {
      {
#line 2645
      output("inverted ");
      }
    }
    {
#line 2646
    outputf("class%s\241\326", countmemo);
#line 2648
    i___0 = 0U;
    }
    {
#line 2648
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2648
      if (! (i___0 < 128U)) {
#line 2648
        goto while_break___2;
      }
#line 2650
      if ((inter->u.class)->ascii[i___0]) {
        {
#line 2651
        tmp___0 = __ctype_b_loc();
        }
#line 2651
        if ((int const   )*(*tmp___0 + (int )i___0) & 16384) {
          {
#line 2652
          (*_output_char_function)((unsigned char )i___0);
          }
        } else {
          {
#line 2654
          outputf("\\%03o", i___0);
          }
        }
      }
#line 2648
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2657
    i___0 = 0U;
    {
#line 2657
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2657
      if (! (i___0 < (unsigned int )(inter->u.class)->euc2.buf_used)) {
#line 2657
        goto while_break___3;
      }
      {
#line 2658
      (*_output_char_function)(*((inter->u.class)->euc2.buf + i___0));
#line 2657
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2660
    i___0 = 0U;
    {
#line 2660
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2660
      if (! (i___0 < (unsigned int )(inter->u.class)->euc3.buf_used)) {
#line 2660
        goto while_break___4;
      }
      {
#line 2661
      (*_output_char_function)(*((inter->u.class)->euc3.buf + i___0));
#line 2660
      i___0 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2662
    output("\241\327\n");
    }
#line 2664
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 2667
    outputf("exact1\241\326%c\241\327%s\n", (int )inter->u.exact[0], countmemo);
    }
#line 2668
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 2671
    outputf("ignore-case ascii\241\326%c\241\327%s\n", (int )inter->u.exact[0], countmemo);
    }
#line 2672
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 2675
    outputf("exact2\241\326%c%c\241\327%s\n", (int )inter->u.exact[0], (int )inter->u.exact[1],
            countmemo);
    }
#line 2677
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 2680
    outputf("exact2\241\326%c%c\241\327*or*\241\326%c%c\241\327%s\n", (int )inter->u.exact[0],
            (int )inter->u.exact[1], (int )inter->u.exact[2], (int )inter->u.exact[3],
            countmemo);
    }
#line 2683
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 2686
    outputf("kana (ignore case)\241\326%c%c\241\327%s\n", (int )inter->u.exact[0],
            (int )inter->u.exact[1], countmemo);
    }
#line 2688
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 2691
    outputf("exact3\241\326%c%c%c\241\327%s\n", (int )inter->u.exact[0], (int )inter->u.exact[1],
            (int )inter->u.exact[2], countmemo);
    }
#line 2693
    goto switch_break___0;
    case_32: /* CIL Label */ 
    {
#line 2698
    ptr = (struct intermediate *)inter->u.alt;
#line 2699
    output("start of alternatives\n");
    }
    {
#line 2700
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 2702
      show_intermediate_pattern((struct intermediate  const  *)ptr, level + 1U);
#line 2703
      i___0 = 0U;
      }
      {
#line 2703
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2703
        if (! (i___0 < level)) {
#line 2703
          goto while_break___6;
        }
        {
#line 2704
        (*_output_char_function)((unsigned char )'|');
#line 2703
        i___0 ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2705
      if ((unsigned long )ptr->nextalt == (unsigned long )((struct intermediate *)0)) {
#line 2706
        goto while_break___5;
      }
      {
#line 2707
      output("---------------------\n");
#line 2708
      ptr = ptr->nextalt;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 2710
    output("end of alternatives\n");
    }
#line 2711
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2714
    inter = (struct intermediate  const  *)inter->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2716
  return;
}
}
#line 2724 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
int regcomp(regex_t *r , unsigned char const   *pattern , unsigned int flags___0 ) 
{ 
  struct intermediate  const  *compiled ;
  unsigned char const   *orig_pattern ;
  int retval ;
  struct intermediate *tmp ;
  unsigned char *buffer___0 ;
  void *tmp___0 ;
  unsigned char *musthave ;
  unsigned char **mh_ptr ;
  struct intermediate  const  *ptr ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *ptr___0 ;
  unsigned char *dest ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char const   *tmp___12 ;
  unsigned char const   *tmp___13 ;

  {
#line 2728
  orig_pattern = pattern;
#line 2731
  regcomp_last_pattern = pattern;
#line 2733
  if ((unsigned long )pattern == (unsigned long )((unsigned char const   *)0)) {
#line 2734
    regcomp_error = 2U;
#line 2734
    return ((int )regcomp_error);
  } else
#line 2733
  if ((unsigned long )r == (unsigned long )((regex_t *)0)) {
#line 2734
    regcomp_error = 2U;
#line 2734
    return ((int )regcomp_error);
  }
  {
#line 2736
  bzero((void *)r, sizeof(*r));
#line 2738
  regex_init();
#line 2739
  regcomp_flags = flags___0;
#line 2740
  regcomp_error = 0U;
#line 2743
  paren_levels_finished = 0U;
#line 2743
  paren_level = paren_levels_finished;
#line 2744
  highest_prev_to_match = -1;
#line 2745
  max_lpc_l = 0U;
#line 2745
  max_lpc_c = max_lpc_l;
#line 2745
  max_lpc = (double )max_lpc_c;
  }
#line 2748
  if (flags___0 & 128U) {
#line 2748
    this_regex_match = (enum TYPE )19;
  } else {
#line 2748
    this_regex_match = (enum TYPE )18;
  }
#line 2752
  if (flags___0 & 1U) {
    {
#line 2752
    outputf("FLAGS %x PATTERN %s\n", flags___0, pattern);
    }
  }
#line 2755
  if ((int const   )*(pattern + 0) == 0) {
#line 2756
    regcomp_error = 3U;
#line 2756
    return ((int )regcomp_error);
  }
  {
#line 2758
  tmp = nibble_list(& pattern, (struct intermediate  const  *)0);
#line 2758
  compiled = (struct intermediate  const  *)tmp;
  }
#line 2760
  if (regcomp_error) {
#line 2761
    retval = (int )regcomp_error;
  } else
#line 2762
  if ((unsigned long )compiled == (unsigned long )((struct intermediate  const  *)0)) {
#line 2763
    retval = 1;
  } else {
    {
#line 2770
    tmp___0 = xmalloc___0((unsigned int )compiled->regex_bytes_needed);
#line 2770
    buffer___0 = (unsigned char *)tmp___0;
#line 2771
    mh_ptr = (unsigned char **)0;
    }
#line 2777
    if ((unsigned int const   )compiled->type == 21U) {
#line 2778
      r->anchor_to_start_of_line = 1U;
    } else
#line 2779
    if ((unsigned int const   )compiled->type == 32U) {
#line 2781
      ptr = (struct intermediate  const  *)compiled->u.alt;
#line 2782
      r->anchor_to_start_of_line = 1U;
      {
#line 2783
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2783
        if (! ptr) {
#line 2783
          goto while_break;
        }
#line 2784
        if ((unsigned int const   )ptr->type != 21U) {
#line 2785
          r->anchor_to_start_of_line = 0U;
#line 2786
          goto while_break;
        }
#line 2788
        ptr = (struct intermediate  const  *)ptr->nextalt;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2792
    if (flags___0 & 1U) {
      {
#line 2792
      show_intermediate_pattern(compiled, 1U);
      }
    }
#line 2795
    if (flags___0 & 4U) {
#line 2795
      r->fold_acase = 1U;
    } else {
#line 2795
      r->fold_acase = 0U;
    }
#line 2796
    if (flags___0 & 8U) {
#line 2796
      r->fold_kcase = 1U;
    } else {
#line 2796
      r->fold_kcase = 0U;
    }
#line 2798
    if ((flags___0 & 32U) == 0U) {
#line 2799
      r->musthave = (unsigned char *)0;
    } else {
      {
#line 2801
      tmp___1 = strlen((char const   *)((void *)orig_pattern));
#line 2801
      tmp___2 = xmalloc___0((unsigned int )tmp___1 + 1U);
#line 2801
      r->musthave = (unsigned char *)tmp___2;
#line 2802
      musthave = r->musthave;
#line 2803
      mh_ptr = & musthave;
      }
    }
    {
#line 2806
    r->buf = buffer___0;
#line 2807
    write_regex_buffer(compiled, & buffer___0, 0, mh_ptr);
#line 2808
    r->bufend = buffer___0;
#line 2809
    r->min_length_match = (unsigned int )compiled->min_match_len;
#line 2812
    r->max_paren_level = (unsigned char )paren_level;
#line 2813
    r->max_lpc_l = (unsigned char )max_lpc_l;
#line 2814
    r->max_lpc_c = (unsigned char )max_lpc_c;
#line 2815
    r->paren_info_required = (unsigned char )(highest_prev_to_match + 1);
    }
    {
#line 2816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2816
      if (! ((int )r->paren_info_required == 0)) {
#line 2816
        if (! (flags___0 & 64U)) {
          {
#line 2816
          die("\nassert(r->paren_info_required == 0 || (flags & REGCOMP_SAVE_MATCHED_PAREN_INFO)) failed \"%s\" line %d.\n",
              "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 2817);
          }
        }
      }
#line 2816
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2821
    if (r->musthave) {
#line 2821
      if ((unsigned long )r->musthave != (unsigned long )musthave) {
#line 2823
        start = r->musthave;
#line 2824
        end = musthave;
#line 2825
        ptr___0 = start + ((int const   )euc_info[*(start + 0)] & 3);
#line 2826
        dest = ptr___0;
        {
#line 2828
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2828
          if (! ((unsigned long )ptr___0 < (unsigned long )end)) {
#line 2828
            goto while_break___1;
          }
          {
#line 2836
          if (((int const   )euc_info[*(ptr___0 + 0)] & 3) == 1) {
#line 2836
            goto case_1;
          }
#line 2842
          if (((int const   )euc_info[*(ptr___0 + 0)] & 3) == 2) {
#line 2842
            goto case_2;
          }
#line 2851
          if (((int const   )euc_info[*(ptr___0 + 0)] & 3) == 3) {
#line 2851
            goto case_3;
          }
#line 2830
          goto switch_default;
          switch_default: /* CIL Label */ 
          {
#line 2831
          warn("[internal error %s:%d; width=%d, first byte=\\%03o]\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
               2832, (int const   )euc_info[*(ptr___0 + 0)] & 3, (int )*(ptr___0 + 0));
          }
#line 2833
          if ((int const   )euc_info[*(ptr___0 + 0)] & 3) {
#line 2833
            tmp___3 = (int const   )euc_info[*(ptr___0 + 0)] & 3;
          } else {
#line 2833
            tmp___3 = (int const   )1;
          }
#line 2833
          ptr___0 += tmp___3;
#line 2834
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 2837
          tmp___5 = onebyte_char_in_string(*(ptr___0 + 0), (unsigned char const   *)start,
                                           (unsigned char const   *)dest);
          }
#line 2837
          if (! tmp___5) {
#line 2838
            tmp___4 = dest;
#line 2838
            dest ++;
#line 2838
            *tmp___4 = *(ptr___0 + 0);
          }
#line 2839
          ptr___0 ++;
#line 2840
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 2843
          tmp___8 = twobyte_char_in_string(*(ptr___0 + 0), *(ptr___0 + 1), (unsigned char const   *)start,
                                           (unsigned char const   *)dest);
          }
#line 2843
          if (! tmp___8) {
#line 2845
            tmp___6 = dest;
#line 2845
            dest ++;
#line 2845
            *tmp___6 = *(ptr___0 + 0);
#line 2846
            tmp___7 = dest;
#line 2846
            dest ++;
#line 2846
            *tmp___7 = *(ptr___0 + 1);
          }
#line 2848
          ptr___0 += 2;
#line 2849
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 2852
          tmp___12 = threebyte_char_in_string(*(ptr___0 + 0), *(ptr___0 + 1), *(ptr___0 + 2),
                                              (unsigned char const   *)start, (unsigned char const   *)dest);
          }
#line 2852
          if (! tmp___12) {
#line 2855
            tmp___9 = dest;
#line 2855
            dest ++;
#line 2855
            *tmp___9 = *(ptr___0 + 0);
#line 2856
            tmp___10 = dest;
#line 2856
            dest ++;
#line 2856
            *tmp___10 = *(ptr___0 + 1);
#line 2857
            tmp___11 = dest;
#line 2857
            dest ++;
#line 2857
            *tmp___11 = *(ptr___0 + 2);
          }
#line 2859
          ptr___0 += 3;
#line 2860
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2862
        musthave = dest;
      }
    }
#line 2864
    if (r->musthave) {
#line 2865
      *musthave = (unsigned char)0;
    }
#line 2866
    retval = 0;
  }
#line 2869
  if (flags___0 & 1U) {
    {
#line 2869
    tmp___13 = regcomp_error_report();
#line 2869
    output((char const   *)tmp___13);
    }
  }
  {
#line 2872
  regex_free_temp_memory();
  }
#line 2873
  return (retval);
}
}
#line 2876 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
char const   *regcomp_errstr[17]  = 
#line 2876
  {      "success",      "internal error",      "invalid data",      "empty pattern", 
        "unmatched [",      "unmatched open paren",      "unmatched close paren",      "misused +,*, or ?", 
        "object of + could be empty",      "object of * could be empty",      "empty class",      "misused |", 
        "nonexistent paren\'ed expression",      "need SAVE_PAREN_INFO with this pattern",      "Japanese character in class range",      "invalid octal value", 
        "corrupted text"};
#line 2899 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned char *report  =    (unsigned char *)0;
#line 2897 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned char const   *regcomp_error_report(void) 
{ 
  int pat_len ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *str___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int i ;
  int tmp___10 ;

  {
#line 2900
  if (regcomp_last_pattern) {
    {
#line 2900
    tmp = strlen((char const   *)((void *)regcomp_last_pattern));
#line 2900
    tmp___0 = tmp;
    }
  } else {
#line 2900
    tmp___0 = (size_t )0;
  }
#line 2900
  pat_len = (int )tmp___0;
#line 2903
  if (report) {
    {
#line 2905
    free((void *)report);
#line 2906
    report = (unsigned char *)0;
    }
  }
  {
#line 2917
  if (regcomp_error == 0U) {
#line 2917
    goto case_0;
  }
#line 2923
  if (regcomp_error == 2U) {
#line 2923
    goto case_2;
  }
#line 2929
  if (regcomp_error == 3U) {
#line 2929
    goto case_3;
  }
#line 2945
  if (regcomp_error == 10U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 15U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 11U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 16U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 13U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 12U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 9U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 8U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 1U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 14U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 4U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 7U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 6U) {
#line 2945
    goto case_10;
  }
#line 2945
  if (regcomp_error == 5U) {
#line 2945
    goto case_10;
  }
#line 2911
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 2912
  str___0 = "regcomp\241\326%s\241\327returns error code %d.\n";
#line 2913
  tmp___1 = strlen((char const   *)((void *)str___0));
#line 2913
  tmp___2 = xmalloc___0((unsigned int )(((tmp___1 + (size_t )pat_len) + 10UL) + 1UL));
#line 2913
  report = (unsigned char *)tmp___2;
#line 2914
  sprintf(report, str___0, regcomp_last_pattern, regcomp_error);
  }
#line 2915
  return ((unsigned char const   *)report);
  case_0: /* CIL Label */ 
  {
#line 2918
  str___0 = "regcomp\241\326%s\241\327returns success\n";
#line 2919
  tmp___3 = strlen((char const   *)((void *)str___0));
#line 2919
  tmp___4 = xmalloc___0((unsigned int )((tmp___3 + (size_t )pat_len) + 1UL));
#line 2919
  report = (unsigned char *)tmp___4;
#line 2920
  sprintf(report, str___0, regcomp_last_pattern);
  }
#line 2921
  return ((unsigned char const   *)report);
  case_2: /* CIL Label */ 
  {
#line 2924
  str___0 = "regcomp (pat=0x%00000008x) barfs on bad data\n";
#line 2925
  tmp___5 = strlen((char const   *)((void *)str___0));
#line 2925
  tmp___6 = xmalloc___0((unsigned int )(tmp___5 + 1UL));
#line 2925
  report = (unsigned char *)tmp___6;
#line 2926
  sprintf(report, str___0, regcomp_last_pattern);
  }
#line 2927
  return ((unsigned char const   *)report);
  case_3: /* CIL Label */ 
#line 2930
  return ((unsigned char const   *)"regcomp barfs on empty pattern\n");
  case_10: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 2946
  str___0 = "regcomp error: %s\n pattern\241\326%s\241\327\n";
#line 2948
  tmp___7 = strlen((char const   *)((void *)str___0));
#line 2948
  tmp___8 = strlen((char const   *)((void *)regcomp_errstr[regcomp_error]));
#line 2948
  tmp___9 = xmalloc___0((unsigned int )(((((tmp___7 + tmp___8) + (size_t )pat_len) + 20UL) + (size_t )pat_len) + 1UL));
#line 2948
  report = (unsigned char *)tmp___9;
#line 2951
  sprintf(report, str___0, regcomp_errstr[regcomp_error], regcomp_last_pattern);
  }
#line 2952
  if (regcomp_eptr - regcomp_last_pattern <= (long )pat_len) {
    {
#line 2954
    i = (int )(regcomp_eptr - regcomp_last_pattern);
#line 2955
    strcat((char */* __restrict  */)report, (char const   */* __restrict  */)"  before --");
    }
    {
#line 2956
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2956
      tmp___10 = i;
#line 2956
      i --;
#line 2956
      if (! (tmp___10 > 0)) {
#line 2956
        goto while_break;
      }
      {
#line 2957
      strcat((char */* __restrict  */)report, (char const   */* __restrict  */)"-");
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2958
    strcat((char */* __restrict  */)report, (char const   */* __restrict  */)"^\n");
    }
  }
#line 2960
  return ((unsigned char const   *)report);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2969 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
void regfree(regex_t *r ) 
{ 
  unsigned char *tmp ;

  {
#line 2971
  if (r) {
#line 2973
    if (r->buf) {
      {
#line 2974
      free((void *)r->buf);
      }
    }
#line 2975
    if (r->musthave) {
      {
#line 2976
      free((void *)r->musthave);
      }
    }
#line 2977
    tmp = (unsigned char *)0;
#line 2977
    r->musthave = tmp;
#line 2977
    r->buf = tmp;
  }
#line 2979
  return;
}
}
#line 2981 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned char const   *regmusthave(regex_t const   *r ) 
{ 


  {
#line 2983
  return ((unsigned char const   *)r->musthave);
}
}
#line 2990 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void showbuf(unsigned char const   *origb , unsigned char const   *b , unsigned char const   *b_end ,
                    char const   *margin ) 
{ 
  enum TYPE type ;
  unsigned char count ;
  int i ;
  int inverted ;
  unsigned short euc2_len ;
  unsigned short euc3_len ;
  char const   *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned short tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned short tmp___4 ;

  {
  {
#line 2996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2996
    if (! ((unsigned long )b < (unsigned long )b_end)) {
#line 2996
      goto while_break;
    }
#line 2998
    type = (enum TYPE )((int const   )*b >> 2);
#line 2999
    count = (unsigned char )((int const   )*b & (int const   )((1 << 2) - 1));
#line 3001
    if (margin) {
      {
#line 3002
      output(margin);
      }
    }
    {
#line 3003
    outputf("  %3ld ", b - origb);
#line 3004
    b ++;
    }
    {
#line 3012
    if ((unsigned int )type == 19U) {
#line 3012
      goto case_19;
    }
#line 3016
    if ((unsigned int )type == 18U) {
#line 3016
      goto case_18;
    }
#line 3020
    if ((unsigned int )type == 5U) {
#line 3020
      goto case_5;
    }
#line 3025
    if ((unsigned int )type == 1U) {
#line 3025
      goto case_1;
    }
#line 3030
    if ((unsigned int )type == 7U) {
#line 3030
      goto case_7;
    }
#line 3031
    if ((unsigned int )type == 8U) {
#line 3031
      goto case_8;
    }
#line 3032
    if ((unsigned int )type == 9U) {
#line 3032
      goto case_9;
    }
#line 3033
    if ((unsigned int )type == 10U) {
#line 3033
      goto case_10;
    }
#line 3034
    if ((unsigned int )type == 11U) {
#line 3034
      goto case_11;
    }
#line 3035
    if ((unsigned int )type == 12U) {
#line 3035
      goto case_12;
    }
#line 3036
    if ((unsigned int )type == 13U) {
#line 3036
      goto case_13;
    }
#line 3037
    if ((unsigned int )type == 14U) {
#line 3037
      goto case_14;
    }
#line 3038
    if ((unsigned int )type == 15U) {
#line 3038
      goto case_15;
    }
#line 3040
    if ((unsigned int )type == 6U) {
#line 3040
      goto case_6;
    }
#line 3045
    if ((unsigned int )type == 2U) {
#line 3045
      goto case_2;
    }
#line 3050
    if ((unsigned int )type == 3U) {
#line 3050
      goto case_3;
    }
#line 3055
    if ((unsigned int )type == 4U) {
#line 3055
      goto case_4;
    }
#line 3060
    if ((unsigned int )type == 16U) {
#line 3060
      goto case_16;
    }
#line 3090
    if ((unsigned int )type == 20U) {
#line 3090
      goto case_20;
    }
#line 3091
    if ((unsigned int )type == 21U) {
#line 3091
      goto case_21;
    }
#line 3092
    if ((unsigned int )type == 22U) {
#line 3092
      goto case_22;
    }
#line 3094
    if ((unsigned int )type == 24U) {
#line 3094
      goto case_24;
    }
#line 3100
    if ((unsigned int )type == 23U) {
#line 3100
      goto case_23;
    }
#line 3106
    if ((unsigned int )type == 25U) {
#line 3106
      goto case_25;
    }
#line 3113
    if ((unsigned int )type == 28U) {
#line 3113
      goto case_28;
    }
#line 3120
    if ((unsigned int )type == 29U) {
#line 3120
      goto case_29;
    }
#line 3127
    if ((unsigned int )type == 26U) {
#line 3127
      goto case_26;
    }
#line 3132
    if ((unsigned int )type == 27U) {
#line 3132
      goto case_27;
    }
#line 3137
    if ((unsigned int )type == 30U) {
#line 3137
      goto case_30;
    }
#line 3008
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 3009
    outputf("unknown code [%x|%x]", (unsigned int )type, (int )count);
    }
#line 3010
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 3013
    output("match (note word)");
    }
#line 3014
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 3017
    output("match");
    }
#line 3018
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 3021
    outputf("exact ascii (ignore case) [%c] ", (int const   )*b);
#line 3022
    b ++;
    }
#line 3023
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 3026
    outputf("exact1\241\326%c\241\327", (int const   )*b);
#line 3027
    b ++;
    }
#line 3028
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 3030
    output("ANY CHAR ");
    }
#line 3030
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 3031
    output("ANY ASCII");
    }
#line 3031
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 3032
    output("ANY MULTIBYTE");
    }
#line 3032
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 3033
    output("ANY KATAKANA");
    }
#line 3033
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 3034
    output("ANY NON-KATAKANA");
    }
#line 3034
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 3035
    output("ANY HIRAGANA");
    }
#line 3035
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 3036
    output("ANY NON-HIRAGANA");
    }
#line 3036
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 3037
    output("ANY KANJI");
    }
#line 3037
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 3038
    output("ANY NON-KANJI");
    }
#line 3038
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 3041
    outputf("exact kana (ignore case) \241\326%c%c\241\327", (int const   )*(b + 0),
            (int const   )*(b + 1));
#line 3042
    b += 2;
    }
#line 3043
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 3046
    outputf("exact2 \241\326%c%c\241\327", (int const   )*(b + 0), (int const   )*(b + 1));
#line 3047
    b += 2;
    }
#line 3048
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 3051
    outputf("exact2 \241\326%c%c\241\327*or*\241\326%c%c\241\327", (int const   )*(b + 0),
            (int const   )*(b + 1), (int const   )*(b + 2), (int const   )*(b + 3));
#line 3052
    b += 4;
    }
#line 3053
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3056
    outputf("exact3 \241\326%c%c%c\241\327", (int const   )*(b + 0), (int const   )*(b + 1),
            (int const   )*(b + 3));
#line 3057
    b += 3;
    }
#line 3058
    goto switch_break;
    case_16: /* CIL Label */ 
#line 3063
    inverted = (int )*(b + 0);
#line 3064
    euc2_len = (unsigned short )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)));
#line 3065
    euc3_len = (unsigned short )((short )(((int const   )*((b + 3) + 0) << 8) | (int const   )*((b + 3) + 1)));
#line 3067
    if (inverted) {
#line 3067
      tmp = "inverted ";
    } else {
#line 3067
      tmp = "";
    }
    {
#line 3067
    outputf("%sclass\241\326", tmp);
#line 3069
    b += 5;
#line 3070
    i = 0;
    }
    {
#line 3070
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3070
      if (! (i < 128)) {
#line 3070
        goto while_break___0;
      }
#line 3072
      if (*(b + i)) {
        {
#line 3074
        tmp___0 = __ctype_b_loc();
        }
#line 3074
        if ((int const   )*(*tmp___0 + i) & 16384) {
          {
#line 3075
          (*_output_char_function)((unsigned char )i);
          }
        } else {
          {
#line 3077
          outputf("\\%03o", i);
          }
        }
      }
#line 3070
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3080
    b += 128;
    {
#line 3082
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3082
      tmp___2 = euc2_len;
#line 3082
      euc2_len = (unsigned short )((int )euc2_len - 1);
#line 3082
      if (! ((int )tmp___2 != 0)) {
#line 3082
        goto while_break___1;
      }
      {
#line 3083
      tmp___1 = b;
#line 3083
      b ++;
#line 3083
      (*_output_char_function)((unsigned char )*tmp___1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3084
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3084
      tmp___4 = euc3_len;
#line 3084
      euc3_len = (unsigned short )((int )euc3_len - 1);
#line 3084
      if (! ((int )tmp___4 != 0)) {
#line 3084
        goto while_break___2;
      }
      {
#line 3085
      tmp___3 = b;
#line 3085
      b ++;
#line 3085
      (*_output_char_function)((unsigned char )*tmp___3);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3086
    output("\241\327");
    }
#line 3088
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 3090
    output("word boundary");
    }
#line 3090
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 3091
    output("start of line");
    }
#line 3091
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 3092
    output("end of line");
    }
#line 3092
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 3095
    outputf("push %ld", ((b - 1) - origb) + (long )((short )(((int const   )*(b + 0) << 8) | (int const   )*(b + 1))));
#line 3097
    b += 2;
    }
#line 3098
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 3101
    outputf("jump to %ld", ((b - 1) - origb) + (long )((short )(((int const   )*(b + 0) << 8) | (int const   )*(b + 1))));
#line 3103
    b += 2;
    }
#line 3104
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 3107
    outputf("pushjump to %ld", ((b - 1) - origb) + (long )((short )(((int const   )*(b + 0) << 8) | (int const   )*(b + 1))));
#line 3109
    b += 2;
    }
#line 3110
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 3114
    outputf("save close paren %d, count of %d, pushjump to %ld", (int const   )*(b + 1),
            (int const   )*(b + 0), ((b - 1) - origb) + (long )((short )(((int const   )*((b + 2) + 0) << 8) | (int const   )*((b + 2) + 1))));
#line 3117
    b += 4;
    }
#line 3118
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 3121
    outputf("push to %ld, save open paren %d", ((b - 1) - origb) + (long )((short )(((int const   )*(b + 0) << 8) | (int const   )*(b + 1))),
            (int const   )*(b + 2));
#line 3124
    b += 3;
    }
#line 3125
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 3128
    outputf("save open paren %d", (int const   )*(b + 0));
#line 3129
    b ++;
    }
#line 3130
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 3133
    outputf("save close paren %d", (int const   )*(b + 0));
#line 3134
    b ++;
    }
#line 3135
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 3138
    outputf("match paren group %d", (int const   )*(b + 0));
#line 3139
    b ++;
    }
#line 3140
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3144
    if ((unsigned int )type < 17U) {
      {
#line 3147
      if ((int )count == 0) {
#line 3147
        goto case_0;
      }
#line 3148
      if ((int )count == 1) {
#line 3148
        goto case_1___0;
      }
#line 3149
      if ((int )count == 2) {
#line 3149
        goto case_2___0;
      }
#line 3150
      if ((int )count == 3) {
#line 3150
        goto case_3___0;
      }
#line 3146
      goto switch_default___0;
      switch_default___0: /* CIL Label */ 
      {
#line 3146
      outputf("<<count %x>>", (int const   )*(b + -1));
      }
#line 3146
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 3147
      output("  ");
      }
#line 3147
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 3148
      output(" ?");
      }
#line 3148
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 3149
      output(" +");
      }
#line 3149
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      {
#line 3150
      output(" *");
      }
#line 3150
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 3152
    (*_output_char_function)((unsigned char )'\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3154
  return;
}
}
#line 3156 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
void showregex(regex_t const   *r ) 
{ 


  {
  {
#line 3159
  outputf("Minimum length match: %d\n", r->min_length_match);
  }
#line 3160
  if (r->anchor_to_start_of_line) {
    {
#line 3161
    output("START OF LINE ONLY\n");
    }
  }
#line 3162
  if (r->musthave) {
    {
#line 3163
    outputf("A line must have [%s]\n", r->musthave);
    }
  }
  {
#line 3165
  outputf("Max paren level %d, max lpc is %d/%d.\n", (int const   )r->max_paren_level,
          (int const   )r->max_lpc_l, (int const   )r->max_lpc_c);
  }
#line 3167
  if (r->paren_info_required) {
    {
#line 3168
    outputf("requires paren info for %d parens\n", (int const   )r->paren_info_required);
    }
  }
  {
#line 3170
  showbuf((unsigned char const   *)r->buf, (unsigned char const   *)r->buf, (unsigned char const   *)r->bufend,
          "");
  }
#line 3171
  return;
}
}
#line 3185 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned int special_debug  ;
#line 3187 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int regexec_flags  =    0U;
#line 3190 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned int regexec_setflags(unsigned int flags___0 ) 
{ 
  unsigned int old ;

  {
#line 3192
  old = regexec_flags;
#line 3193
  regexec_flags = flags___0;
#line 3194
  return (old);
}
}
#line 3204 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned int regexec_paren_info_used  =    0U;
#line 3209 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
matched_paren_t default_regexec_paren_info[10]  ;
#line 3210 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
matched_paren_t *regexec_paren_info  =    & default_regexec_paren_info[0];
#line 3211 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned int regexec_paren_info_size  =    10U;
#line 3218 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static void report_new_pareninfo(char const   *message , unsigned int num ) 
{ 


  {
#line 3220
  if ((unsigned long )message == (unsigned long )((char const   *)0)) {
#line 3221
    message = "";
  }
#line 3222
  if (num >= regexec_paren_info_size) {
    {
#line 3223
    outputf("paren_info[%d] %s OUT OF RANGE (%d)\n", num, message, regexec_paren_info_size);
    }
  } else
#line 3225
  if ((unsigned long )(regexec_paren_info + num)->match_start == (unsigned long )((unsigned char const   *)0)) {
    {
#line 3227
    outputf("paren_info[%d] %s <undefined>\n", num, message);
    }
  } else
#line 3225
  if ((unsigned long )(regexec_paren_info + num)->match_end == (unsigned long )((unsigned char const   *)0)) {
    {
#line 3227
    outputf("paren_info[%d] %s <undefined>\n", num, message);
    }
  } else {
    {
#line 3229
    outputf("paren_info[%d] %s, now [%.*s]\n", num, message, (int )((regexec_paren_info + num)->match_end - (regexec_paren_info + num)->match_start),
            (regexec_paren_info + num)->match_start);
    }
  }
#line 3233
  return;
}
}
#line 3243 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
__inline static int word_boundary(unsigned char const   *line___1 ) 
{ 
  unsigned int l ;
  unsigned int c ;
  unsigned char c2 ;

  {
#line 3245
  l = (unsigned int )*(line___1 + 0);
#line 3246
  c = (unsigned int )*(line___1 + -1);
#line 3248
  if (c & 128U) {
#line 3251
    c2 = (unsigned char )c;
#line 3252
    c = (unsigned int )*(line___1 + -2);
#line 3254
    if (c == 161U) {
#line 3254
      if (l == 165U) {
#line 3254
        if ((int )c2 == 188) {
#line 3257
          return (0);
        }
      }
    }
#line 3259
    if (l == 161U) {
#line 3259
      if (c == 161U) {
#line 3259
        if ((int )c2 == 188) {
#line 3262
          return (0);
        }
      }
    }
  }
#line 3264
  return ((int )jregex_part_of_word[c] != (int )jregex_part_of_word[l]);
}
}
#line 3315 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int maxstates  =    0U;
#line 3316 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static struct statestruct *statestack_start  =    (struct statestruct *)0;
#line 3316 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static struct statestruct *statestack_end  ;
#line 3333 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned int parenstate_size  =    0U;
#line 3334 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned char const   **parenstate_base  =    (unsigned char const   **)0;
#line 3336 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
static unsigned char const   **parenstate_end  ;
#line 3273 "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c"
unsigned int regexec(regex_t const   *r , unsigned char const   *line___1 , unsigned int len ) 
{ 
  unsigned char const   *b ;
  unsigned char const   *orig_line ;
  unsigned char const   *end_of_line___0 ;
  unsigned char llm ;
  int tmp ;
  unsigned char const   *longest_match_so_far ;
  unsigned char const   *latest_start ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *line_head ;
  struct statestruct *state ;
  unsigned int maxstates_wanted ;
  short highest_paren_seen ;
  unsigned char const   **parenstate ;
  unsigned char const   **max_parenstate ;
  unsigned int max_parenstates_needed ;
  void *tmp___1 ;
  void *tmp___2 ;
  int i ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned char const   *b_if_match ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int i___0 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  unsigned int Len ;
  int tmp___61 ;
  unsigned int Len___0 ;
  int tmp___62 ;
  unsigned int Len___1 ;
  int tmp___63 ;
  int tmp___64 ;
  unsigned int Len___2 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  unsigned short euc2_length ;
  unsigned short euc3_length ;
  unsigned char c ;
  unsigned int Len___3 ;
  int inverted ;
  int foldkana ;
  int tmp___115 ;
  unsigned char const   *tmp___116 ;
  unsigned char const   *tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  unsigned short euc2_length___0 ;
  unsigned short euc3_length___0 ;
  unsigned char c___0 ;
  unsigned int Len___4 ;
  int inverted___0 ;
  int foldkana___0 ;
  int tmp___121 ;
  int tmp___122 ;
  unsigned char const   *tmp___123 ;
  unsigned char const   *tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  unsigned short euc2_length___1 ;
  unsigned short euc3_length___1 ;
  unsigned char c___1 ;
  unsigned int Len___5 ;
  int inverted___1 ;
  int foldkana___1 ;
  int tmp___127 ;
  unsigned char const   *tmp___128 ;
  unsigned char const   *tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  unsigned char const   *tmp___134 ;
  unsigned char const   *tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  unsigned short euc2_length___2 ;
  unsigned short euc3_length___2 ;
  unsigned char c___2 ;
  unsigned int Len___6 ;
  int inverted___2 ;
  int foldkana___2 ;
  int tmp___138 ;
  int tmp___139 ;
  unsigned char const   *tmp___140 ;
  unsigned char const   *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  unsigned char const   *tmp___145 ;
  unsigned char const   *tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  unsigned int level ;
  unsigned int Len___7 ;
  unsigned char const   *A ;
  unsigned char const   *A_end ;
  unsigned char const   *B ;
  unsigned short const   **tmp___152 ;
  int tmp___154 ;
  int tmp___155 ;
  unsigned short const   **tmp___156 ;
  int tmp___158 ;
  int tmp___159 ;
  unsigned short const   **tmp___160 ;
  unsigned short const   **tmp___161 ;
  unsigned int level___0 ;
  unsigned int level___1 ;
  unsigned int count ;
  unsigned int start ;
  unsigned int _count ;
  unsigned int _start ;
  unsigned int _end_ ;
  unsigned int _num_ ;
  unsigned int tmp___162 ;
  unsigned int level___2 ;
  int old_highest_paren_seen ;
  int _count___0 ;
  unsigned int _end ;
  unsigned int _num____0 ;
  unsigned int _num____1 ;
  int tmp___163 ;
  int tmp___164 ;

  {
#line 3276
  b = (unsigned char const   *)r->buf;
#line 3277
  orig_line = line___1;
#line 3278
  end_of_line___0 = line___1 + len;
#line 3284
  if (regexec_flags & 512U) {
#line 3284
    tmp = 1;
  } else {
#line 3284
    tmp = 0;
  }
#line 3284
  llm = (unsigned char )tmp;
#line 3285
  longest_match_so_far = (unsigned char const   *)0;
#line 3305
  if (r->anchor_to_start_of_line) {
#line 3305
    tmp___0 = line___1;
  } else {
#line 3305
    tmp___0 = end_of_line___0 - r->min_length_match;
  }
#line 3305
  latest_start = tmp___0;
#line 3313
  line_head = line___1;
#line 3329
  maxstates_wanted = 2U * len + 10U;
#line 3332
  highest_paren_seen = (short)-1;
#line 3342
  if (r->max_lpc_l) {
#line 3345
    max_parenstates_needed = 2U + 2U * ((((len + (unsigned int )r->max_lpc_c) - 1U) / (unsigned int )r->max_lpc_c) * (unsigned int )r->max_lpc_l);
#line 3347
    if (max_parenstates_needed > parenstate_size) {
#line 3349
      if (parenstate_base) {
        {
#line 3350
        free((void *)parenstate_base);
        }
      }
      {
#line 3351
      parenstate_size = max_parenstates_needed;
#line 3352
      tmp___1 = xmalloc___0((unsigned int )(sizeof(unsigned char *) * (unsigned long )parenstate_size));
#line 3352
      parenstate_base = (unsigned char const   **)tmp___1;
#line 3354
      parenstate_end = parenstate_base + parenstate_size;
      }
    }
#line 3357
    parenstate = parenstate_base;
  }
#line 3360
  max_parenstate = parenstate_base;
#line 3401
  if (maxstates_wanted > maxstates) {
#line 3404
    if (statestack_start) {
      {
#line 3405
      free((void *)statestack_start);
      }
    }
    {
#line 3406
    maxstates = maxstates_wanted;
#line 3407
    tmp___2 = xmalloc___0((unsigned int )(sizeof(struct statestruct ) * (unsigned long )maxstates));
#line 3407
    statestack_start = (struct statestruct *)tmp___2;
#line 3409
    statestack_end = statestack_start + maxstates;
    }
  }
#line 3412
  state = statestack_start + 0;
#line 3608
  regexec_match_start = line___1;
#line 3612
  if ((unsigned long )regexec_paren_info == (unsigned long )((matched_paren_t *)0)) {
#line 3613
    regexec_paren_info_size = 0U;
  } else {
#line 3616
    if (regexec_paren_info_size < (unsigned int )r->max_paren_level) {
#line 3616
      tmp___3 = regexec_paren_info_size;
    } else {
#line 3616
      tmp___3 = (unsigned int )r->max_paren_level;
    }
#line 3616
    i = (int )tmp___3;
    {
#line 3618
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3618
      tmp___4 = i;
#line 3618
      i --;
#line 3618
      if (! (tmp___4 > 0)) {
#line 3618
        goto while_break;
      }
#line 3619
      (regexec_paren_info + i)->match_end = (unsigned char const   *)0;
#line 3620
      if (regexec_flags & 2U) {
        {
#line 3620
        report_new_pareninfo("init", (unsigned int )i);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3624
  if ((unsigned int )r->paren_info_required > regexec_paren_info_size) {
#line 3625
    return (0U);
  }
#line 3628
  if (! r->anchor_to_start_of_line) {
#line 3628
    latest_start = end_of_line___0;
  }
  {
#line 3634
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3638
    (regex_stats.cycles) ++;
#line 3639
    if (regexec_flags & 2U) {
      {
#line 3639
      outputf("%ld -----------------------------: [%.*s]\n", state - statestack_start,
              (int )(end_of_line___0 - line___1), line___1);
#line 3639
      showbuf((unsigned char const   *)r->buf, b, (unsigned char const   *)r->bufend,
              ">>> ");
      }
    }
    {
#line 3649
    if ((int const   )*(b + 0) == (int const   )(19 << 2)) {
#line 3649
      goto case_exp;
    }
#line 3662
    if ((int const   )*(b + 0) == (int const   )(18 << 2)) {
#line 3662
      goto case_exp___0;
    }
#line 3702
    if ((int const   )*(b + 0) == (int const   )(1 << 2)) {
#line 3702
      goto case_exp___1;
    }
#line 3702
    if ((int const   )*(b + 0) == (int const   )((1 << 2) | 1)) {
#line 3702
      goto case_exp___2;
    }
#line 3702
    if ((int const   )*(b + 0) == (int const   )((1 << 2) | 2)) {
#line 3702
      goto case_exp___3;
    }
#line 3702
    if ((int const   )*(b + 0) == (int const   )((1 << 2) | 3)) {
#line 3702
      goto case_exp___4;
    }
#line 3708
    if ((int const   )*(b + 0) == (int const   )(5 << 2)) {
#line 3708
      goto case_exp___5;
    }
#line 3708
    if ((int const   )*(b + 0) == (int const   )((5 << 2) | 1)) {
#line 3708
      goto case_exp___6;
    }
#line 3708
    if ((int const   )*(b + 0) == (int const   )((5 << 2) | 2)) {
#line 3708
      goto case_exp___7;
    }
#line 3708
    if ((int const   )*(b + 0) == (int const   )((5 << 2) | 3)) {
#line 3708
      goto case_exp___8;
    }
#line 3714
    if ((int const   )*(b + 0) == (int const   )(2 << 2)) {
#line 3714
      goto case_exp___9;
    }
#line 3714
    if ((int const   )*(b + 0) == (int const   )((2 << 2) | 1)) {
#line 3714
      goto case_exp___10;
    }
#line 3714
    if ((int const   )*(b + 0) == (int const   )((2 << 2) | 2)) {
#line 3714
      goto case_exp___11;
    }
#line 3714
    if ((int const   )*(b + 0) == (int const   )((2 << 2) | 3)) {
#line 3714
      goto case_exp___12;
    }
#line 3720
    if ((int const   )*(b + 0) == (int const   )(3 << 2)) {
#line 3720
      goto case_exp___13;
    }
#line 3720
    if ((int const   )*(b + 0) == (int const   )((3 << 2) | 1)) {
#line 3720
      goto case_exp___14;
    }
#line 3720
    if ((int const   )*(b + 0) == (int const   )((3 << 2) | 2)) {
#line 3720
      goto case_exp___15;
    }
#line 3720
    if ((int const   )*(b + 0) == (int const   )((3 << 2) | 3)) {
#line 3720
      goto case_exp___16;
    }
#line 3727
    if ((int const   )*(b + 0) == (int const   )(6 << 2)) {
#line 3727
      goto case_exp___17;
    }
#line 3727
    if ((int const   )*(b + 0) == (int const   )((6 << 2) | 1)) {
#line 3727
      goto case_exp___18;
    }
#line 3727
    if ((int const   )*(b + 0) == (int const   )((6 << 2) | 2)) {
#line 3727
      goto case_exp___19;
    }
#line 3727
    if ((int const   )*(b + 0) == (int const   )((6 << 2) | 3)) {
#line 3727
      goto case_exp___20;
    }
#line 3734
    if ((int const   )*(b + 0) == (int const   )(4 << 2)) {
#line 3734
      goto case_exp___21;
    }
#line 3734
    if ((int const   )*(b + 0) == (int const   )((4 << 2) | 1)) {
#line 3734
      goto case_exp___22;
    }
#line 3734
    if ((int const   )*(b + 0) == (int const   )((4 << 2) | 2)) {
#line 3734
      goto case_exp___23;
    }
#line 3734
    if ((int const   )*(b + 0) == (int const   )((4 << 2) | 3)) {
#line 3734
      goto case_exp___24;
    }
#line 3742
    if ((int const   )*(b + 0) == (int const   )(7 << 2)) {
#line 3742
      goto case_exp___25;
    }
#line 3742
    if ((int const   )*(b + 0) == (int const   )((7 << 2) | 1)) {
#line 3742
      goto case_exp___26;
    }
#line 3742
    if ((int const   )*(b + 0) == (int const   )((7 << 2) | 2)) {
#line 3742
      goto case_exp___27;
    }
#line 3742
    if ((int const   )*(b + 0) == (int const   )((7 << 2) | 3)) {
#line 3742
      goto case_exp___28;
    }
#line 3748
    if ((int const   )*(b + 0) == (int const   )(8 << 2)) {
#line 3748
      goto case_exp___29;
    }
#line 3748
    if ((int const   )*(b + 0) == (int const   )((8 << 2) | 1)) {
#line 3748
      goto case_exp___30;
    }
#line 3748
    if ((int const   )*(b + 0) == (int const   )((8 << 2) | 2)) {
#line 3748
      goto case_exp___31;
    }
#line 3748
    if ((int const   )*(b + 0) == (int const   )((8 << 2) | 3)) {
#line 3748
      goto case_exp___32;
    }
#line 3754
    if ((int const   )*(b + 0) == (int const   )(9 << 2)) {
#line 3754
      goto case_exp___33;
    }
#line 3754
    if ((int const   )*(b + 0) == (int const   )((9 << 2) | 1)) {
#line 3754
      goto case_exp___34;
    }
#line 3754
    if ((int const   )*(b + 0) == (int const   )((9 << 2) | 2)) {
#line 3754
      goto case_exp___35;
    }
#line 3754
    if ((int const   )*(b + 0) == (int const   )((9 << 2) | 3)) {
#line 3754
      goto case_exp___36;
    }
#line 3760
    if ((int const   )*(b + 0) == (int const   )(10 << 2)) {
#line 3760
      goto case_exp___37;
    }
#line 3760
    if ((int const   )*(b + 0) == (int const   )((10 << 2) | 1)) {
#line 3760
      goto case_exp___38;
    }
#line 3760
    if ((int const   )*(b + 0) == (int const   )((10 << 2) | 2)) {
#line 3760
      goto case_exp___39;
    }
#line 3760
    if ((int const   )*(b + 0) == (int const   )((10 << 2) | 3)) {
#line 3760
      goto case_exp___40;
    }
#line 3768
    if ((int const   )*(b + 0) == (int const   )(11 << 2)) {
#line 3768
      goto case_exp___41;
    }
#line 3768
    if ((int const   )*(b + 0) == (int const   )((11 << 2) | 1)) {
#line 3768
      goto case_exp___42;
    }
#line 3768
    if ((int const   )*(b + 0) == (int const   )((11 << 2) | 2)) {
#line 3768
      goto case_exp___43;
    }
#line 3768
    if ((int const   )*(b + 0) == (int const   )((11 << 2) | 3)) {
#line 3768
      goto case_exp___44;
    }
#line 3777
    if ((int const   )*(b + 0) == (int const   )(12 << 2)) {
#line 3777
      goto case_exp___45;
    }
#line 3777
    if ((int const   )*(b + 0) == (int const   )((12 << 2) | 1)) {
#line 3777
      goto case_exp___46;
    }
#line 3777
    if ((int const   )*(b + 0) == (int const   )((12 << 2) | 2)) {
#line 3777
      goto case_exp___47;
    }
#line 3777
    if ((int const   )*(b + 0) == (int const   )((12 << 2) | 3)) {
#line 3777
      goto case_exp___48;
    }
#line 3783
    if ((int const   )*(b + 0) == (int const   )(13 << 2)) {
#line 3783
      goto case_exp___49;
    }
#line 3783
    if ((int const   )*(b + 0) == (int const   )((13 << 2) | 1)) {
#line 3783
      goto case_exp___50;
    }
#line 3783
    if ((int const   )*(b + 0) == (int const   )((13 << 2) | 2)) {
#line 3783
      goto case_exp___51;
    }
#line 3783
    if ((int const   )*(b + 0) == (int const   )((13 << 2) | 3)) {
#line 3783
      goto case_exp___52;
    }
#line 3789
    if ((int const   )*(b + 0) == (int const   )(14 << 2)) {
#line 3789
      goto case_exp___53;
    }
#line 3789
    if ((int const   )*(b + 0) == (int const   )((14 << 2) | 1)) {
#line 3789
      goto case_exp___54;
    }
#line 3789
    if ((int const   )*(b + 0) == (int const   )((14 << 2) | 2)) {
#line 3789
      goto case_exp___55;
    }
#line 3789
    if ((int const   )*(b + 0) == (int const   )((14 << 2) | 3)) {
#line 3789
      goto case_exp___56;
    }
#line 3796
    if ((int const   )*(b + 0) == (int const   )(15 << 2)) {
#line 3796
      goto case_exp___57;
    }
#line 3796
    if ((int const   )*(b + 0) == (int const   )((15 << 2) | 1)) {
#line 3796
      goto case_exp___58;
    }
#line 3796
    if ((int const   )*(b + 0) == (int const   )((15 << 2) | 2)) {
#line 3796
      goto case_exp___59;
    }
#line 3796
    if ((int const   )*(b + 0) == (int const   )((15 << 2) | 3)) {
#line 3796
      goto case_exp___60;
    }
#line 3803
    if ((int const   )*(b + 0) == (int const   )(16 << 2)) {
#line 3803
      goto case_exp___61;
    }
#line 3803
    if ((int const   )*(b + 0) == (int const   )((16 << 2) | 1)) {
#line 3803
      goto case_exp___62;
    }
#line 3803
    if ((int const   )*(b + 0) == (int const   )((16 << 2) | 2)) {
#line 3803
      goto case_exp___63;
    }
#line 3803
    if ((int const   )*(b + 0) == (int const   )((16 << 2) | 3)) {
#line 3803
      goto case_exp___64;
    }
#line 3830
    if ((int const   )*(b + 0) == (int const   )(20 << 2)) {
#line 3830
      goto case_exp___65;
    }
#line 3838
    if ((int const   )*(b + 0) == (int const   )(21 << 2)) {
#line 3838
      goto case_exp___66;
    }
#line 3844
    if ((int const   )*(b + 0) == (int const   )(22 << 2)) {
#line 3844
      goto case_exp___67;
    }
#line 3850
    if ((int const   )*(b + 0) == (int const   )(24 << 2)) {
#line 3850
      goto case_exp___68;
    }
#line 3855
    if ((int const   )*(b + 0) == (int const   )(23 << 2)) {
#line 3855
      goto case_exp___69;
    }
#line 3859
    if ((int const   )*(b + 0) == (int const   )(25 << 2)) {
#line 3859
      goto case_exp___70;
    }
#line 3866
    if ((int const   )*(b + 0) == (int const   )(30 << 2)) {
#line 3866
      goto case_exp___71;
    }
#line 3930
    if ((int const   )*(b + 0) == (int const   )(26 << 2)) {
#line 3930
      goto case_exp___72;
    }
#line 3950
    if ((int const   )*(b + 0) == (int const   )(29 << 2)) {
#line 3950
      goto case_exp___73;
    }
#line 3973
    if ((int const   )*(b + 0) == (int const   )(28 << 2)) {
#line 3973
      goto case_exp___74;
    }
#line 4000
    if ((int const   )*(b + 0) == (int const   )(27 << 2)) {
#line 4000
      goto case_exp___75;
    }
#line 3698
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 3651
    if (llm) {
#line 3651
      if ((unsigned long )line___1 <= (unsigned long )longest_match_so_far) {
#line 3652
        goto nomatch;
      }
    }
#line 3654
    if ((unsigned long )orig_line != (unsigned long )end_of_line___0) {
#line 3654
      if ((unsigned long )regexec_match_start == (unsigned long )orig_line) {
#line 3654
        if (jregex_part_of_word[*(regexec_match_start + 0)]) {
#line 3654
          tmp___6 = 1;
        } else {
#line 3654
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 3654
      if ((unsigned long )regexec_match_start >= (unsigned long )end_of_line___0) {
#line 3654
        if (jregex_part_of_word[*(end_of_line___0 + -1)]) {
#line 3654
          tmp___6 = 1;
        } else {
#line 3654
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 3654
        tmp___5 = word_boundary(regexec_match_start);
        }
#line 3654
        if (tmp___5) {
#line 3654
          tmp___6 = 1;
        } else {
#line 3654
          tmp___6 = 0;
        }
      }
    } else {
#line 3654
      tmp___6 = 0;
    }
#line 3654
    regexec_match_at_start_of_word = tmp___6;
#line 3656
    if ((unsigned long )orig_line != (unsigned long )end_of_line___0) {
#line 3656
      if ((unsigned long )line___1 == (unsigned long )orig_line) {
#line 3656
        if (jregex_part_of_word[*(line___1 + 0)]) {
#line 3656
          tmp___8 = 1;
        } else {
#line 3656
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 3656
      if ((unsigned long )line___1 >= (unsigned long )end_of_line___0) {
#line 3656
        if (jregex_part_of_word[*(end_of_line___0 + -1)]) {
#line 3656
          tmp___8 = 1;
        } else {
#line 3656
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 3656
        tmp___7 = word_boundary(line___1);
        }
#line 3656
        if (tmp___7) {
#line 3656
          tmp___8 = 1;
        } else {
#line 3656
          tmp___8 = 0;
        }
      }
    } else {
#line 3656
      tmp___8 = 0;
    }
#line 3656
    regexec_match_at_end_of_word = tmp___8;
    case_exp___0: /* CIL Label */ 
#line 3664
    if (llm) {
#line 3664
      if ((unsigned long )line___1 <= (unsigned long )longest_match_so_far) {
#line 3665
        if (regexec_flags & 2U) {
          {
#line 3665
          outputf("** pattern matches, but is too short **\n");
          }
        }
#line 3669
        goto nomatch;
      }
    }
#line 3671
    longest_match_so_far = line___1;
#line 3674
    if (regexec_flags & 2U) {
      {
#line 3674
      outputf("*** pattern matches [llm=%d]***\n", (int )llm);
      }
    }
#line 3678
    regexec_match_end = line___1;
#line 3682
    regexec_paren_info_used = (unsigned int )((int )highest_paren_seen + 1);
#line 3683
    if (regexec_flags & 2U) {
      {
#line 3683
      outputf("regexec_paren_info_used is %d\n", regexec_paren_info_used);
#line 3683
      i___0 = 0;
      }
      {
#line 3683
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3683
        if (! ((unsigned int )i___0 < regexec_paren_info_used)) {
#line 3683
          goto while_break___1;
        }
        {
#line 3683
        report_new_pareninfo("return", (unsigned int )i___0);
#line 3683
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3693
    if (llm) {
#line 3694
      goto nomatch;
    }
#line 3696
    return (1U);
    switch_default: /* CIL Label */ 
    {
#line 3699
    outputf("<<unknown code @%ld[%x]>>\n", b - (unsigned char const   *)r->buf, (int const   )*(b + 0));
    }
#line 3700
    return (0U);
    case_exp___1: /* CIL Label */ 
#line 3702
    (regex_stats.tests) ++;
#line 3702
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3702
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3702
        tmp___9 = 1;
      } else {
#line 3702
        tmp___9 = 0;
      }
    } else {
#line 3702
      tmp___9 = 0;
    }
#line 3702
    if (! tmp___9) {
#line 3702
      goto nomatch;
    }
#line 3702
    b_if_match = (b + 1) + 1;
#line 3702
    line___1 ++;
#line 3702
    goto match;
    case_exp___2: /* CIL Label */ 
#line 3702
    b_if_match = (b + 1) + 1;
#line 3702
    (regex_stats.tests) ++;
#line 3702
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3702
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3702
        tmp___10 = 1;
      } else {
#line 3702
        tmp___10 = 0;
      }
    } else {
#line 3702
      tmp___10 = 0;
    }
#line 3702
    if (tmp___10) {
      {
#line 3702
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3702
        state->highest_paren_seen = highest_paren_seen;
#line 3702
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3702
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3702
          (regex_stats.states_pushed) ++;
#line 3702
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3702
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3702
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3702
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3702
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3706);
              }
            }
#line 3702
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 3702
          if (regexec_flags & 2U) {
            {
#line 3702
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3702
          state->b = b_if_match;
#line 3702
          state->line = line___1;
#line 3702
          state ++;
#line 3702
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3702
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3702
      line___1 ++;
    } else {
#line 3702
      (regex_stats.states_pushed) ++;
#line 3702
      (regex_stats.states_popped) ++;
    }
#line 3702
    goto match;
    case_exp___3: /* CIL Label */ 
#line 3702
    (regex_stats.tests) ++;
#line 3702
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3702
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3702
        tmp___11 = 1;
      } else {
#line 3702
        tmp___11 = 0;
      }
    } else {
#line 3702
      tmp___11 = 0;
    }
#line 3702
    if (! tmp___11) {
#line 3702
      goto nomatch;
    }
#line 3702
    b_if_match = (b + 1) + 1;
    {
#line 3702
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3702
      line___1 ++;
#line 3702
      (regex_stats.tests) ++;
#line 3702
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3702
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3702
          tmp___12 = 1;
        } else {
#line 3702
          tmp___12 = 0;
        }
      } else {
#line 3702
        tmp___12 = 0;
      }
#line 3702
      if (! tmp___12) {
#line 3702
        goto while_break___5;
      }
      {
#line 3702
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3702
        state->highest_paren_seen = highest_paren_seen;
#line 3702
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3702
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 3702
          (regex_stats.states_pushed) ++;
#line 3702
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3702
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3702
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 3702
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3702
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3706);
              }
            }
#line 3702
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 3702
          if (regexec_flags & 2U) {
            {
#line 3702
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3702
          state->b = b_if_match;
#line 3702
          state->line = line___1;
#line 3702
          state ++;
#line 3702
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 3702
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 3702
    (regex_stats.states_pushed) ++;
#line 3702
    (regex_stats.states_popped) ++;
#line 3702
    goto match;
    case_exp___4: /* CIL Label */ 
#line 3702
    (regex_stats.states_pushed) ++;
#line 3702
    (regex_stats.states_popped) ++;
#line 3702
    b_if_match = (b + 1) + 1;
#line 3702
    (regex_stats.tests) ++;
#line 3702
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3702
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3702
        tmp___14 = 1;
      } else {
#line 3702
        tmp___14 = 0;
      }
    } else {
#line 3702
      tmp___14 = 0;
    }
#line 3702
    if (tmp___14) {
      {
#line 3702
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 3702
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 3702
          state->highest_paren_seen = highest_paren_seen;
#line 3702
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3702
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 3702
            (regex_stats.states_pushed) ++;
#line 3702
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3702
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3702
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 3702
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3702
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3706);
                }
              }
#line 3702
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 3702
            if (regexec_flags & 2U) {
              {
#line 3702
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3702
            state->b = b_if_match;
#line 3702
            state->line = line___1;
#line 3702
            state ++;
#line 3702
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 3702
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 3702
        line___1 ++;
#line 3702
        (regex_stats.tests) ++;
#line 3702
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3702
          if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3702
            tmp___13 = 1;
          } else {
#line 3702
            tmp___13 = 0;
          }
        } else {
#line 3702
          tmp___13 = 0;
        }
#line 3702
        if (! tmp___13) {
#line 3702
          goto while_break___9;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 3702
    goto match;
    case_exp___5: /* CIL Label */ 
#line 3708
    (regex_stats.tests) ++;
#line 3708
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3708
      if ((int const   )*(b + 1) == (int const   )case_translation[*(line___1 + 0)]) {
#line 3708
        tmp___15 = 1;
      } else {
#line 3708
        tmp___15 = 0;
      }
    } else {
#line 3708
      tmp___15 = 0;
    }
#line 3708
    if (! tmp___15) {
#line 3708
      goto nomatch;
    }
#line 3708
    b_if_match = (b + 1) + 1;
#line 3708
    line___1 ++;
#line 3708
    goto match;
    case_exp___6: /* CIL Label */ 
#line 3708
    b_if_match = (b + 1) + 1;
#line 3708
    (regex_stats.tests) ++;
#line 3708
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3708
      if ((int const   )*(b + 1) == (int const   )case_translation[*(line___1 + 0)]) {
#line 3708
        tmp___16 = 1;
      } else {
#line 3708
        tmp___16 = 0;
      }
    } else {
#line 3708
      tmp___16 = 0;
    }
#line 3708
    if (tmp___16) {
      {
#line 3708
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 3708
        state->highest_paren_seen = highest_paren_seen;
#line 3708
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3708
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 3708
          (regex_stats.states_pushed) ++;
#line 3708
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3708
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3708
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 3708
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3708
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3712);
              }
            }
#line 3708
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 3708
          if (regexec_flags & 2U) {
            {
#line 3708
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3708
          state->b = b_if_match;
#line 3708
          state->line = line___1;
#line 3708
          state ++;
#line 3708
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 3708
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 3708
      line___1 ++;
    } else {
#line 3708
      (regex_stats.states_pushed) ++;
#line 3708
      (regex_stats.states_popped) ++;
    }
#line 3708
    goto match;
    case_exp___7: /* CIL Label */ 
#line 3708
    (regex_stats.tests) ++;
#line 3708
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3708
      if ((int const   )*(b + 1) == (int const   )case_translation[*(line___1 + 0)]) {
#line 3708
        tmp___17 = 1;
      } else {
#line 3708
        tmp___17 = 0;
      }
    } else {
#line 3708
      tmp___17 = 0;
    }
#line 3708
    if (! tmp___17) {
#line 3708
      goto nomatch;
    }
#line 3708
    b_if_match = (b + 1) + 1;
    {
#line 3708
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 3708
      line___1 ++;
#line 3708
      (regex_stats.tests) ++;
#line 3708
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3708
        if ((int const   )*(b + 1) == (int const   )case_translation[*(line___1 + 0)]) {
#line 3708
          tmp___18 = 1;
        } else {
#line 3708
          tmp___18 = 0;
        }
      } else {
#line 3708
        tmp___18 = 0;
      }
#line 3708
      if (! tmp___18) {
#line 3708
        goto while_break___16;
      }
      {
#line 3708
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 3708
        state->highest_paren_seen = highest_paren_seen;
#line 3708
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3708
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 3708
          (regex_stats.states_pushed) ++;
#line 3708
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3708
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3708
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 3708
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3708
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3712);
              }
            }
#line 3708
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 3708
          if (regexec_flags & 2U) {
            {
#line 3708
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3708
          state->b = b_if_match;
#line 3708
          state->line = line___1;
#line 3708
          state ++;
#line 3708
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
#line 3708
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
#line 3708
    (regex_stats.states_pushed) ++;
#line 3708
    (regex_stats.states_popped) ++;
#line 3708
    goto match;
    case_exp___8: /* CIL Label */ 
#line 3708
    (regex_stats.states_pushed) ++;
#line 3708
    (regex_stats.states_popped) ++;
#line 3708
    b_if_match = (b + 1) + 1;
#line 3708
    (regex_stats.tests) ++;
#line 3708
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3708
      if ((int const   )*(b + 1) == (int const   )case_translation[*(line___1 + 0)]) {
#line 3708
        tmp___20 = 1;
      } else {
#line 3708
        tmp___20 = 0;
      }
    } else {
#line 3708
      tmp___20 = 0;
    }
#line 3708
    if (tmp___20) {
      {
#line 3708
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 3708
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 3708
          state->highest_paren_seen = highest_paren_seen;
#line 3708
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3708
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 3708
            (regex_stats.states_pushed) ++;
#line 3708
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3708
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3708
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 3708
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3708
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3712);
                }
              }
#line 3708
              goto while_break___23;
            }
            while_break___23: /* CIL Label */ ;
            }
#line 3708
            if (regexec_flags & 2U) {
              {
#line 3708
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3708
            state->b = b_if_match;
#line 3708
            state->line = line___1;
#line 3708
            state ++;
#line 3708
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 3708
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 3708
        line___1 ++;
#line 3708
        (regex_stats.tests) ++;
#line 3708
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3708
          if ((int const   )*(b + 1) == (int const   )case_translation[*(line___1 + 0)]) {
#line 3708
            tmp___19 = 1;
          } else {
#line 3708
            tmp___19 = 0;
          }
        } else {
#line 3708
          tmp___19 = 0;
        }
#line 3708
        if (! tmp___19) {
#line 3708
          goto while_break___20;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
    }
#line 3708
    goto match;
    case_exp___9: /* CIL Label */ 
#line 3714
    (regex_stats.tests) ++;
#line 3714
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3714
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3714
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3714
          tmp___21 = 1;
        } else {
#line 3714
          tmp___21 = 0;
        }
      } else {
#line 3714
        tmp___21 = 0;
      }
    } else {
#line 3714
      tmp___21 = 0;
    }
#line 3714
    if (! tmp___21) {
#line 3714
      goto nomatch;
    }
#line 3714
    b_if_match = (b + 1) + 2;
#line 3714
    line___1 += 2;
#line 3714
    goto match;
    case_exp___10: /* CIL Label */ 
#line 3714
    b_if_match = (b + 1) + 2;
#line 3714
    (regex_stats.tests) ++;
#line 3714
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3714
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3714
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3714
          tmp___22 = 1;
        } else {
#line 3714
          tmp___22 = 0;
        }
      } else {
#line 3714
        tmp___22 = 0;
      }
    } else {
#line 3714
      tmp___22 = 0;
    }
#line 3714
    if (tmp___22) {
      {
#line 3714
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 3714
        state->highest_paren_seen = highest_paren_seen;
#line 3714
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3714
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 3714
          (regex_stats.states_pushed) ++;
#line 3714
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3714
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3714
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 3714
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3714
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3718);
              }
            }
#line 3714
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 3714
          if (regexec_flags & 2U) {
            {
#line 3714
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3714
          state->b = b_if_match;
#line 3714
          state->line = line___1;
#line 3714
          state ++;
#line 3714
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 3714
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 3714
      line___1 += 2;
    } else {
#line 3714
      (regex_stats.states_pushed) ++;
#line 3714
      (regex_stats.states_popped) ++;
    }
#line 3714
    goto match;
    case_exp___11: /* CIL Label */ 
#line 3714
    (regex_stats.tests) ++;
#line 3714
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3714
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3714
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3714
          tmp___23 = 1;
        } else {
#line 3714
          tmp___23 = 0;
        }
      } else {
#line 3714
        tmp___23 = 0;
      }
    } else {
#line 3714
      tmp___23 = 0;
    }
#line 3714
    if (! tmp___23) {
#line 3714
      goto nomatch;
    }
#line 3714
    b_if_match = (b + 1) + 2;
    {
#line 3714
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 3714
      line___1 += 2;
#line 3714
      (regex_stats.tests) ++;
#line 3714
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3714
        if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3714
          if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3714
            tmp___24 = 1;
          } else {
#line 3714
            tmp___24 = 0;
          }
        } else {
#line 3714
          tmp___24 = 0;
        }
      } else {
#line 3714
        tmp___24 = 0;
      }
#line 3714
      if (! tmp___24) {
#line 3714
        goto while_break___27;
      }
      {
#line 3714
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 3714
        state->highest_paren_seen = highest_paren_seen;
#line 3714
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3714
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 3714
          (regex_stats.states_pushed) ++;
#line 3714
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3714
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3714
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 3714
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3714
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3718);
              }
            }
#line 3714
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
#line 3714
          if (regexec_flags & 2U) {
            {
#line 3714
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3714
          state->b = b_if_match;
#line 3714
          state->line = line___1;
#line 3714
          state ++;
#line 3714
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 3714
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
    }
    while_break___27: /* CIL Label */ ;
    }
#line 3714
    (regex_stats.states_pushed) ++;
#line 3714
    (regex_stats.states_popped) ++;
#line 3714
    goto match;
    case_exp___12: /* CIL Label */ 
#line 3714
    (regex_stats.states_pushed) ++;
#line 3714
    (regex_stats.states_popped) ++;
#line 3714
    b_if_match = (b + 1) + 2;
#line 3714
    (regex_stats.tests) ++;
#line 3714
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3714
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3714
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3714
          tmp___26 = 1;
        } else {
#line 3714
          tmp___26 = 0;
        }
      } else {
#line 3714
        tmp___26 = 0;
      }
    } else {
#line 3714
      tmp___26 = 0;
    }
#line 3714
    if (tmp___26) {
      {
#line 3714
      while (1) {
        while_continue___31: /* CIL Label */ ;
        {
#line 3714
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 3714
          state->highest_paren_seen = highest_paren_seen;
#line 3714
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3714
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 3714
            (regex_stats.states_pushed) ++;
#line 3714
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3714
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3714
            while (1) {
              while_continue___34: /* CIL Label */ ;
#line 3714
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3714
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3718);
                }
              }
#line 3714
              goto while_break___34;
            }
            while_break___34: /* CIL Label */ ;
            }
#line 3714
            if (regexec_flags & 2U) {
              {
#line 3714
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3714
            state->b = b_if_match;
#line 3714
            state->line = line___1;
#line 3714
            state ++;
#line 3714
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 3714
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
#line 3714
        line___1 += 2;
#line 3714
        (regex_stats.tests) ++;
#line 3714
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3714
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3714
            if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3714
              tmp___25 = 1;
            } else {
#line 3714
              tmp___25 = 0;
            }
          } else {
#line 3714
            tmp___25 = 0;
          }
        } else {
#line 3714
          tmp___25 = 0;
        }
#line 3714
        if (! tmp___25) {
#line 3714
          goto while_break___31;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
    }
#line 3714
    goto match;
    case_exp___13: /* CIL Label */ 
#line 3720
    (regex_stats.tests) ++;
#line 3720
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3720
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___27 = 1;
        } else {
#line 3720
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 3720
      if ((int const   )*(b + 4) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___27 = 1;
        } else {
#line 3720
          tmp___27 = 0;
        }
      } else {
#line 3720
        tmp___27 = 0;
      }
    } else {
#line 3720
      tmp___27 = 0;
    }
#line 3720
    if (! tmp___27) {
#line 3720
      goto nomatch;
    }
#line 3720
    b_if_match = (b + 1) + 4;
#line 3720
    line___1 += 2;
#line 3720
    goto match;
    case_exp___14: /* CIL Label */ 
#line 3720
    b_if_match = (b + 1) + 4;
#line 3720
    (regex_stats.tests) ++;
#line 3720
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3720
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___28 = 1;
        } else {
#line 3720
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 3720
      if ((int const   )*(b + 4) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___28 = 1;
        } else {
#line 3720
          tmp___28 = 0;
        }
      } else {
#line 3720
        tmp___28 = 0;
      }
    } else {
#line 3720
      tmp___28 = 0;
    }
#line 3720
    if (tmp___28) {
      {
#line 3720
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 3720
        state->highest_paren_seen = highest_paren_seen;
#line 3720
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3720
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 3720
          (regex_stats.states_pushed) ++;
#line 3720
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3720
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3720
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 3720
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3720
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3725);
              }
            }
#line 3720
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 3720
          if (regexec_flags & 2U) {
            {
#line 3720
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3720
          state->b = b_if_match;
#line 3720
          state->line = line___1;
#line 3720
          state ++;
#line 3720
          goto while_break___36;
        }
        while_break___36: /* CIL Label */ ;
        }
#line 3720
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 3720
      line___1 += 2;
    } else {
#line 3720
      (regex_stats.states_pushed) ++;
#line 3720
      (regex_stats.states_popped) ++;
    }
#line 3720
    goto match;
    case_exp___15: /* CIL Label */ 
#line 3720
    (regex_stats.tests) ++;
#line 3720
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3720
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___29 = 1;
        } else {
#line 3720
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 3720
      if ((int const   )*(b + 4) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___29 = 1;
        } else {
#line 3720
          tmp___29 = 0;
        }
      } else {
#line 3720
        tmp___29 = 0;
      }
    } else {
#line 3720
      tmp___29 = 0;
    }
#line 3720
    if (! tmp___29) {
#line 3720
      goto nomatch;
    }
#line 3720
    b_if_match = (b + 1) + 4;
    {
#line 3720
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 3720
      line___1 += 2;
#line 3720
      (regex_stats.tests) ++;
#line 3720
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3720
        if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3720
          if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3720
            tmp___30 = 1;
          } else {
#line 3720
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 3720
        if ((int const   )*(b + 4) == (int const   )*(line___1 + 1)) {
#line 3720
          if ((int const   )*(b + 3) == (int const   )*(line___1 + 0)) {
#line 3720
            tmp___30 = 1;
          } else {
#line 3720
            tmp___30 = 0;
          }
        } else {
#line 3720
          tmp___30 = 0;
        }
      } else {
#line 3720
        tmp___30 = 0;
      }
#line 3720
      if (! tmp___30) {
#line 3720
        goto while_break___38;
      }
      {
#line 3720
      while (1) {
        while_continue___39: /* CIL Label */ ;
#line 3720
        state->highest_paren_seen = highest_paren_seen;
#line 3720
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3720
        while (1) {
          while_continue___40: /* CIL Label */ ;
#line 3720
          (regex_stats.states_pushed) ++;
#line 3720
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3720
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3720
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 3720
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3720
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3725);
              }
            }
#line 3720
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 3720
          if (regexec_flags & 2U) {
            {
#line 3720
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3720
          state->b = b_if_match;
#line 3720
          state->line = line___1;
#line 3720
          state ++;
#line 3720
          goto while_break___40;
        }
        while_break___40: /* CIL Label */ ;
        }
#line 3720
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
    }
    while_break___38: /* CIL Label */ ;
    }
#line 3720
    (regex_stats.states_pushed) ++;
#line 3720
    (regex_stats.states_popped) ++;
#line 3720
    goto match;
    case_exp___16: /* CIL Label */ 
#line 3720
    (regex_stats.states_pushed) ++;
#line 3720
    (regex_stats.states_popped) ++;
#line 3720
    b_if_match = (b + 1) + 4;
#line 3720
    (regex_stats.tests) ++;
#line 3720
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3720
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___32 = 1;
        } else {
#line 3720
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 3720
      if ((int const   )*(b + 4) == (int const   )*(line___1 + 1)) {
#line 3720
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 0)) {
#line 3720
          tmp___32 = 1;
        } else {
#line 3720
          tmp___32 = 0;
        }
      } else {
#line 3720
        tmp___32 = 0;
      }
    } else {
#line 3720
      tmp___32 = 0;
    }
#line 3720
    if (tmp___32) {
      {
#line 3720
      while (1) {
        while_continue___42: /* CIL Label */ ;
        {
#line 3720
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 3720
          state->highest_paren_seen = highest_paren_seen;
#line 3720
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3720
          while (1) {
            while_continue___44: /* CIL Label */ ;
#line 3720
            (regex_stats.states_pushed) ++;
#line 3720
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3720
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3720
            while (1) {
              while_continue___45: /* CIL Label */ ;
#line 3720
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3720
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3725);
                }
              }
#line 3720
              goto while_break___45;
            }
            while_break___45: /* CIL Label */ ;
            }
#line 3720
            if (regexec_flags & 2U) {
              {
#line 3720
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3720
            state->b = b_if_match;
#line 3720
            state->line = line___1;
#line 3720
            state ++;
#line 3720
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
#line 3720
          goto while_break___43;
        }
        while_break___43: /* CIL Label */ ;
        }
#line 3720
        line___1 += 2;
#line 3720
        (regex_stats.tests) ++;
#line 3720
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3720
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3720
            if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3720
              tmp___31 = 1;
            } else {
#line 3720
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 3720
          if ((int const   )*(b + 4) == (int const   )*(line___1 + 1)) {
#line 3720
            if ((int const   )*(b + 3) == (int const   )*(line___1 + 0)) {
#line 3720
              tmp___31 = 1;
            } else {
#line 3720
              tmp___31 = 0;
            }
          } else {
#line 3720
            tmp___31 = 0;
          }
        } else {
#line 3720
          tmp___31 = 0;
        }
#line 3720
        if (! tmp___31) {
#line 3720
          goto while_break___42;
        }
      }
      while_break___42: /* CIL Label */ ;
      }
    }
#line 3720
    goto match;
    case_exp___17: /* CIL Label */ 
#line 3727
    (regex_stats.tests) ++;
#line 3727
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3727
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3727
        if ((int const   )*(line___1 + 0) == 164) {
#line 3727
          tmp___33 = 1;
        } else
#line 3727
        if ((int const   )*(line___1 + 0) == 165) {
#line 3727
          tmp___33 = 1;
        } else {
#line 3727
          tmp___33 = 0;
        }
      } else {
#line 3727
        tmp___33 = 0;
      }
    } else {
#line 3727
      tmp___33 = 0;
    }
#line 3727
    if (! tmp___33) {
#line 3727
      goto nomatch;
    }
#line 3727
    b_if_match = (b + 1) + 2;
#line 3727
    line___1 += 2;
#line 3727
    goto match;
    case_exp___18: /* CIL Label */ 
#line 3727
    b_if_match = (b + 1) + 2;
#line 3727
    (regex_stats.tests) ++;
#line 3727
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3727
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3727
        if ((int const   )*(line___1 + 0) == 164) {
#line 3727
          tmp___34 = 1;
        } else
#line 3727
        if ((int const   )*(line___1 + 0) == 165) {
#line 3727
          tmp___34 = 1;
        } else {
#line 3727
          tmp___34 = 0;
        }
      } else {
#line 3727
        tmp___34 = 0;
      }
    } else {
#line 3727
      tmp___34 = 0;
    }
#line 3727
    if (tmp___34) {
      {
#line 3727
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 3727
        state->highest_paren_seen = highest_paren_seen;
#line 3727
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3727
        while (1) {
          while_continue___47: /* CIL Label */ ;
#line 3727
          (regex_stats.states_pushed) ++;
#line 3727
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3727
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3727
          while (1) {
            while_continue___48: /* CIL Label */ ;
#line 3727
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3727
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3732);
              }
            }
#line 3727
            goto while_break___48;
          }
          while_break___48: /* CIL Label */ ;
          }
#line 3727
          if (regexec_flags & 2U) {
            {
#line 3727
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3727
          state->b = b_if_match;
#line 3727
          state->line = line___1;
#line 3727
          state ++;
#line 3727
          goto while_break___47;
        }
        while_break___47: /* CIL Label */ ;
        }
#line 3727
        goto while_break___46;
      }
      while_break___46: /* CIL Label */ ;
      }
#line 3727
      line___1 += 2;
    } else {
#line 3727
      (regex_stats.states_pushed) ++;
#line 3727
      (regex_stats.states_popped) ++;
    }
#line 3727
    goto match;
    case_exp___19: /* CIL Label */ 
#line 3727
    (regex_stats.tests) ++;
#line 3727
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3727
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3727
        if ((int const   )*(line___1 + 0) == 164) {
#line 3727
          tmp___35 = 1;
        } else
#line 3727
        if ((int const   )*(line___1 + 0) == 165) {
#line 3727
          tmp___35 = 1;
        } else {
#line 3727
          tmp___35 = 0;
        }
      } else {
#line 3727
        tmp___35 = 0;
      }
    } else {
#line 3727
      tmp___35 = 0;
    }
#line 3727
    if (! tmp___35) {
#line 3727
      goto nomatch;
    }
#line 3727
    b_if_match = (b + 1) + 2;
    {
#line 3727
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 3727
      line___1 += 2;
#line 3727
      (regex_stats.tests) ++;
#line 3727
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3727
        if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3727
          if ((int const   )*(line___1 + 0) == 164) {
#line 3727
            tmp___36 = 1;
          } else
#line 3727
          if ((int const   )*(line___1 + 0) == 165) {
#line 3727
            tmp___36 = 1;
          } else {
#line 3727
            tmp___36 = 0;
          }
        } else {
#line 3727
          tmp___36 = 0;
        }
      } else {
#line 3727
        tmp___36 = 0;
      }
#line 3727
      if (! tmp___36) {
#line 3727
        goto while_break___49;
      }
      {
#line 3727
      while (1) {
        while_continue___50: /* CIL Label */ ;
#line 3727
        state->highest_paren_seen = highest_paren_seen;
#line 3727
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3727
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 3727
          (regex_stats.states_pushed) ++;
#line 3727
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3727
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3727
          while (1) {
            while_continue___52: /* CIL Label */ ;
#line 3727
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3727
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3732);
              }
            }
#line 3727
            goto while_break___52;
          }
          while_break___52: /* CIL Label */ ;
          }
#line 3727
          if (regexec_flags & 2U) {
            {
#line 3727
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3727
          state->b = b_if_match;
#line 3727
          state->line = line___1;
#line 3727
          state ++;
#line 3727
          goto while_break___51;
        }
        while_break___51: /* CIL Label */ ;
        }
#line 3727
        goto while_break___50;
      }
      while_break___50: /* CIL Label */ ;
      }
    }
    while_break___49: /* CIL Label */ ;
    }
#line 3727
    (regex_stats.states_pushed) ++;
#line 3727
    (regex_stats.states_popped) ++;
#line 3727
    goto match;
    case_exp___20: /* CIL Label */ 
#line 3727
    (regex_stats.states_pushed) ++;
#line 3727
    (regex_stats.states_popped) ++;
#line 3727
    b_if_match = (b + 1) + 2;
#line 3727
    (regex_stats.tests) ++;
#line 3727
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3727
      if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3727
        if ((int const   )*(line___1 + 0) == 164) {
#line 3727
          tmp___38 = 1;
        } else
#line 3727
        if ((int const   )*(line___1 + 0) == 165) {
#line 3727
          tmp___38 = 1;
        } else {
#line 3727
          tmp___38 = 0;
        }
      } else {
#line 3727
        tmp___38 = 0;
      }
    } else {
#line 3727
      tmp___38 = 0;
    }
#line 3727
    if (tmp___38) {
      {
#line 3727
      while (1) {
        while_continue___53: /* CIL Label */ ;
        {
#line 3727
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 3727
          state->highest_paren_seen = highest_paren_seen;
#line 3727
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3727
          while (1) {
            while_continue___55: /* CIL Label */ ;
#line 3727
            (regex_stats.states_pushed) ++;
#line 3727
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3727
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3727
            while (1) {
              while_continue___56: /* CIL Label */ ;
#line 3727
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3727
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3732);
                }
              }
#line 3727
              goto while_break___56;
            }
            while_break___56: /* CIL Label */ ;
            }
#line 3727
            if (regexec_flags & 2U) {
              {
#line 3727
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3727
            state->b = b_if_match;
#line 3727
            state->line = line___1;
#line 3727
            state ++;
#line 3727
            goto while_break___55;
          }
          while_break___55: /* CIL Label */ ;
          }
#line 3727
          goto while_break___54;
        }
        while_break___54: /* CIL Label */ ;
        }
#line 3727
        line___1 += 2;
#line 3727
        (regex_stats.tests) ++;
#line 3727
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3727
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3727
            if ((int const   )*(line___1 + 0) == 164) {
#line 3727
              tmp___37 = 1;
            } else
#line 3727
            if ((int const   )*(line___1 + 0) == 165) {
#line 3727
              tmp___37 = 1;
            } else {
#line 3727
              tmp___37 = 0;
            }
          } else {
#line 3727
            tmp___37 = 0;
          }
        } else {
#line 3727
          tmp___37 = 0;
        }
#line 3727
        if (! tmp___37) {
#line 3727
          goto while_break___53;
        }
      }
      while_break___53: /* CIL Label */ ;
      }
    }
#line 3727
    goto match;
    case_exp___21: /* CIL Label */ 
#line 3734
    (regex_stats.tests) ++;
#line 3734
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3734
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3734
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 2)) {
#line 3734
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3734
            tmp___39 = 1;
          } else {
#line 3734
            tmp___39 = 0;
          }
        } else {
#line 3734
          tmp___39 = 0;
        }
      } else {
#line 3734
        tmp___39 = 0;
      }
    } else {
#line 3734
      tmp___39 = 0;
    }
#line 3734
    if (! tmp___39) {
#line 3734
      goto nomatch;
    }
#line 3734
    b_if_match = (b + 1) + 3;
#line 3734
    line___1 += 3;
#line 3734
    goto match;
    case_exp___22: /* CIL Label */ 
#line 3734
    b_if_match = (b + 1) + 3;
#line 3734
    (regex_stats.tests) ++;
#line 3734
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3734
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3734
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 2)) {
#line 3734
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3734
            tmp___40 = 1;
          } else {
#line 3734
            tmp___40 = 0;
          }
        } else {
#line 3734
          tmp___40 = 0;
        }
      } else {
#line 3734
        tmp___40 = 0;
      }
    } else {
#line 3734
      tmp___40 = 0;
    }
#line 3734
    if (tmp___40) {
      {
#line 3734
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 3734
        state->highest_paren_seen = highest_paren_seen;
#line 3734
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3734
        while (1) {
          while_continue___58: /* CIL Label */ ;
#line 3734
          (regex_stats.states_pushed) ++;
#line 3734
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3734
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3734
          while (1) {
            while_continue___59: /* CIL Label */ ;
#line 3734
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3734
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3740);
              }
            }
#line 3734
            goto while_break___59;
          }
          while_break___59: /* CIL Label */ ;
          }
#line 3734
          if (regexec_flags & 2U) {
            {
#line 3734
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3734
          state->b = b_if_match;
#line 3734
          state->line = line___1;
#line 3734
          state ++;
#line 3734
          goto while_break___58;
        }
        while_break___58: /* CIL Label */ ;
        }
#line 3734
        goto while_break___57;
      }
      while_break___57: /* CIL Label */ ;
      }
#line 3734
      line___1 += 3;
    } else {
#line 3734
      (regex_stats.states_pushed) ++;
#line 3734
      (regex_stats.states_popped) ++;
    }
#line 3734
    goto match;
    case_exp___23: /* CIL Label */ 
#line 3734
    (regex_stats.tests) ++;
#line 3734
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3734
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3734
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 2)) {
#line 3734
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3734
            tmp___41 = 1;
          } else {
#line 3734
            tmp___41 = 0;
          }
        } else {
#line 3734
          tmp___41 = 0;
        }
      } else {
#line 3734
        tmp___41 = 0;
      }
    } else {
#line 3734
      tmp___41 = 0;
    }
#line 3734
    if (! tmp___41) {
#line 3734
      goto nomatch;
    }
#line 3734
    b_if_match = (b + 1) + 3;
    {
#line 3734
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 3734
      line___1 += 3;
#line 3734
      (regex_stats.tests) ++;
#line 3734
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3734
        if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3734
          if ((int const   )*(b + 3) == (int const   )*(line___1 + 2)) {
#line 3734
            if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3734
              tmp___42 = 1;
            } else {
#line 3734
              tmp___42 = 0;
            }
          } else {
#line 3734
            tmp___42 = 0;
          }
        } else {
#line 3734
          tmp___42 = 0;
        }
      } else {
#line 3734
        tmp___42 = 0;
      }
#line 3734
      if (! tmp___42) {
#line 3734
        goto while_break___60;
      }
      {
#line 3734
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 3734
        state->highest_paren_seen = highest_paren_seen;
#line 3734
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3734
        while (1) {
          while_continue___62: /* CIL Label */ ;
#line 3734
          (regex_stats.states_pushed) ++;
#line 3734
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3734
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3734
          while (1) {
            while_continue___63: /* CIL Label */ ;
#line 3734
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3734
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3740);
              }
            }
#line 3734
            goto while_break___63;
          }
          while_break___63: /* CIL Label */ ;
          }
#line 3734
          if (regexec_flags & 2U) {
            {
#line 3734
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3734
          state->b = b_if_match;
#line 3734
          state->line = line___1;
#line 3734
          state ++;
#line 3734
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
#line 3734
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
    }
    while_break___60: /* CIL Label */ ;
    }
#line 3734
    (regex_stats.states_pushed) ++;
#line 3734
    (regex_stats.states_popped) ++;
#line 3734
    goto match;
    case_exp___24: /* CIL Label */ 
#line 3734
    (regex_stats.states_pushed) ++;
#line 3734
    (regex_stats.states_popped) ++;
#line 3734
    b_if_match = (b + 1) + 3;
#line 3734
    (regex_stats.tests) ++;
#line 3734
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3734
      if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3734
        if ((int const   )*(b + 3) == (int const   )*(line___1 + 2)) {
#line 3734
          if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3734
            tmp___44 = 1;
          } else {
#line 3734
            tmp___44 = 0;
          }
        } else {
#line 3734
          tmp___44 = 0;
        }
      } else {
#line 3734
        tmp___44 = 0;
      }
    } else {
#line 3734
      tmp___44 = 0;
    }
#line 3734
    if (tmp___44) {
      {
#line 3734
      while (1) {
        while_continue___64: /* CIL Label */ ;
        {
#line 3734
        while (1) {
          while_continue___65: /* CIL Label */ ;
#line 3734
          state->highest_paren_seen = highest_paren_seen;
#line 3734
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3734
          while (1) {
            while_continue___66: /* CIL Label */ ;
#line 3734
            (regex_stats.states_pushed) ++;
#line 3734
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3734
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3734
            while (1) {
              while_continue___67: /* CIL Label */ ;
#line 3734
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3734
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3740);
                }
              }
#line 3734
              goto while_break___67;
            }
            while_break___67: /* CIL Label */ ;
            }
#line 3734
            if (regexec_flags & 2U) {
              {
#line 3734
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3734
            state->b = b_if_match;
#line 3734
            state->line = line___1;
#line 3734
            state ++;
#line 3734
            goto while_break___66;
          }
          while_break___66: /* CIL Label */ ;
          }
#line 3734
          goto while_break___65;
        }
        while_break___65: /* CIL Label */ ;
        }
#line 3734
        line___1 += 3;
#line 3734
        (regex_stats.tests) ++;
#line 3734
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3734
          if ((int const   )*(b + 1) == (int const   )*(line___1 + 0)) {
#line 3734
            if ((int const   )*(b + 3) == (int const   )*(line___1 + 2)) {
#line 3734
              if ((int const   )*(b + 2) == (int const   )*(line___1 + 1)) {
#line 3734
                tmp___43 = 1;
              } else {
#line 3734
                tmp___43 = 0;
              }
            } else {
#line 3734
              tmp___43 = 0;
            }
          } else {
#line 3734
            tmp___43 = 0;
          }
        } else {
#line 3734
          tmp___43 = 0;
        }
#line 3734
        if (! tmp___43) {
#line 3734
          goto while_break___64;
        }
      }
      while_break___64: /* CIL Label */ ;
      }
    }
#line 3734
    goto match;
    case_exp___25: /* CIL Label */ 
#line 3742
    (regex_stats.tests) ++;
#line 3742
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3742
      if ((int const   )*(line___1 + 0) != 10) {
#line 3742
        tmp___45 = 1;
      } else {
#line 3742
        tmp___45 = 0;
      }
    } else {
#line 3742
      tmp___45 = 0;
    }
#line 3742
    if (! tmp___45) {
#line 3742
      goto nomatch;
    }
#line 3742
    b_if_match = (b + 1) + 0;
#line 3742
    if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3742
      tmp___46 = (int const   )euc_info[*(line___1 + 0)] & 3;
    } else {
#line 3742
      tmp___46 = (int const   )1;
    }
#line 3742
    line___1 += tmp___46;
#line 3742
    goto match;
    case_exp___26: /* CIL Label */ 
#line 3742
    b_if_match = (b + 1) + 0;
#line 3742
    (regex_stats.tests) ++;
#line 3742
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3742
      if ((int const   )*(line___1 + 0) != 10) {
#line 3742
        tmp___48 = 1;
      } else {
#line 3742
        tmp___48 = 0;
      }
    } else {
#line 3742
      tmp___48 = 0;
    }
#line 3742
    if (tmp___48) {
      {
#line 3742
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 3742
        state->highest_paren_seen = highest_paren_seen;
#line 3742
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3742
        while (1) {
          while_continue___69: /* CIL Label */ ;
#line 3742
          (regex_stats.states_pushed) ++;
#line 3742
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3742
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3742
          while (1) {
            while_continue___70: /* CIL Label */ ;
#line 3742
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3742
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3746);
              }
            }
#line 3742
            goto while_break___70;
          }
          while_break___70: /* CIL Label */ ;
          }
#line 3742
          if (regexec_flags & 2U) {
            {
#line 3742
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3742
          state->b = b_if_match;
#line 3742
          state->line = line___1;
#line 3742
          state ++;
#line 3742
          goto while_break___69;
        }
        while_break___69: /* CIL Label */ ;
        }
#line 3742
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
#line 3742
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3742
        tmp___47 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3742
        tmp___47 = (int const   )1;
      }
#line 3742
      line___1 += tmp___47;
    } else {
#line 3742
      (regex_stats.states_pushed) ++;
#line 3742
      (regex_stats.states_popped) ++;
    }
#line 3742
    goto match;
    case_exp___27: /* CIL Label */ 
#line 3742
    (regex_stats.tests) ++;
#line 3742
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3742
      if ((int const   )*(line___1 + 0) != 10) {
#line 3742
        tmp___49 = 1;
      } else {
#line 3742
        tmp___49 = 0;
      }
    } else {
#line 3742
      tmp___49 = 0;
    }
#line 3742
    if (! tmp___49) {
#line 3742
      goto nomatch;
    }
#line 3742
    b_if_match = (b + 1) + 0;
    {
#line 3742
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 3742
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3742
        tmp___50 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3742
        tmp___50 = (int const   )1;
      }
#line 3742
      line___1 += tmp___50;
#line 3742
      (regex_stats.tests) ++;
#line 3742
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3742
        if ((int const   )*(line___1 + 0) != 10) {
#line 3742
          tmp___51 = 1;
        } else {
#line 3742
          tmp___51 = 0;
        }
      } else {
#line 3742
        tmp___51 = 0;
      }
#line 3742
      if (! tmp___51) {
#line 3742
        goto while_break___71;
      }
      {
#line 3742
      while (1) {
        while_continue___72: /* CIL Label */ ;
#line 3742
        state->highest_paren_seen = highest_paren_seen;
#line 3742
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3742
        while (1) {
          while_continue___73: /* CIL Label */ ;
#line 3742
          (regex_stats.states_pushed) ++;
#line 3742
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3742
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3742
          while (1) {
            while_continue___74: /* CIL Label */ ;
#line 3742
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3742
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3746);
              }
            }
#line 3742
            goto while_break___74;
          }
          while_break___74: /* CIL Label */ ;
          }
#line 3742
          if (regexec_flags & 2U) {
            {
#line 3742
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3742
          state->b = b_if_match;
#line 3742
          state->line = line___1;
#line 3742
          state ++;
#line 3742
          goto while_break___73;
        }
        while_break___73: /* CIL Label */ ;
        }
#line 3742
        goto while_break___72;
      }
      while_break___72: /* CIL Label */ ;
      }
    }
    while_break___71: /* CIL Label */ ;
    }
#line 3742
    (regex_stats.states_pushed) ++;
#line 3742
    (regex_stats.states_popped) ++;
#line 3742
    goto match;
    case_exp___28: /* CIL Label */ 
#line 3742
    (regex_stats.states_pushed) ++;
#line 3742
    (regex_stats.states_popped) ++;
#line 3742
    b_if_match = (b + 1) + 0;
#line 3742
    (regex_stats.tests) ++;
#line 3742
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3742
      if ((int const   )*(line___1 + 0) != 10) {
#line 3742
        tmp___54 = 1;
      } else {
#line 3742
        tmp___54 = 0;
      }
    } else {
#line 3742
      tmp___54 = 0;
    }
#line 3742
    if (tmp___54) {
      {
#line 3742
      while (1) {
        while_continue___75: /* CIL Label */ ;
        {
#line 3742
        while (1) {
          while_continue___76: /* CIL Label */ ;
#line 3742
          state->highest_paren_seen = highest_paren_seen;
#line 3742
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3742
          while (1) {
            while_continue___77: /* CIL Label */ ;
#line 3742
            (regex_stats.states_pushed) ++;
#line 3742
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3742
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3742
            while (1) {
              while_continue___78: /* CIL Label */ ;
#line 3742
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3742
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3746);
                }
              }
#line 3742
              goto while_break___78;
            }
            while_break___78: /* CIL Label */ ;
            }
#line 3742
            if (regexec_flags & 2U) {
              {
#line 3742
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3742
            state->b = b_if_match;
#line 3742
            state->line = line___1;
#line 3742
            state ++;
#line 3742
            goto while_break___77;
          }
          while_break___77: /* CIL Label */ ;
          }
#line 3742
          goto while_break___76;
        }
        while_break___76: /* CIL Label */ ;
        }
#line 3742
        if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3742
          tmp___52 = (int const   )euc_info[*(line___1 + 0)] & 3;
        } else {
#line 3742
          tmp___52 = (int const   )1;
        }
#line 3742
        line___1 += tmp___52;
#line 3742
        (regex_stats.tests) ++;
#line 3742
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3742
          if ((int const   )*(line___1 + 0) != 10) {
#line 3742
            tmp___53 = 1;
          } else {
#line 3742
            tmp___53 = 0;
          }
        } else {
#line 3742
          tmp___53 = 0;
        }
#line 3742
        if (! tmp___53) {
#line 3742
          goto while_break___75;
        }
      }
      while_break___75: /* CIL Label */ ;
      }
    }
#line 3742
    goto match;
    case_exp___29: /* CIL Label */ 
#line 3748
    (regex_stats.tests) ++;
#line 3748
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3748
      if (((int const   )*(line___1 + 0) & 128) == 0) {
#line 3748
        if ((int const   )*(line___1 + 0) != 10) {
#line 3748
          tmp___55 = 1;
        } else {
#line 3748
          tmp___55 = 0;
        }
      } else {
#line 3748
        tmp___55 = 0;
      }
    } else {
#line 3748
      tmp___55 = 0;
    }
#line 3748
    if (! tmp___55) {
#line 3748
      goto nomatch;
    }
#line 3748
    b_if_match = (b + 1) + 0;
#line 3748
    line___1 ++;
#line 3748
    goto match;
    case_exp___30: /* CIL Label */ 
#line 3748
    b_if_match = (b + 1) + 0;
#line 3748
    (regex_stats.tests) ++;
#line 3748
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3748
      if (((int const   )*(line___1 + 0) & 128) == 0) {
#line 3748
        if ((int const   )*(line___1 + 0) != 10) {
#line 3748
          tmp___56 = 1;
        } else {
#line 3748
          tmp___56 = 0;
        }
      } else {
#line 3748
        tmp___56 = 0;
      }
    } else {
#line 3748
      tmp___56 = 0;
    }
#line 3748
    if (tmp___56) {
      {
#line 3748
      while (1) {
        while_continue___79: /* CIL Label */ ;
#line 3748
        state->highest_paren_seen = highest_paren_seen;
#line 3748
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3748
        while (1) {
          while_continue___80: /* CIL Label */ ;
#line 3748
          (regex_stats.states_pushed) ++;
#line 3748
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3748
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3748
          while (1) {
            while_continue___81: /* CIL Label */ ;
#line 3748
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3748
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3752);
              }
            }
#line 3748
            goto while_break___81;
          }
          while_break___81: /* CIL Label */ ;
          }
#line 3748
          if (regexec_flags & 2U) {
            {
#line 3748
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3748
          state->b = b_if_match;
#line 3748
          state->line = line___1;
#line 3748
          state ++;
#line 3748
          goto while_break___80;
        }
        while_break___80: /* CIL Label */ ;
        }
#line 3748
        goto while_break___79;
      }
      while_break___79: /* CIL Label */ ;
      }
#line 3748
      line___1 ++;
    } else {
#line 3748
      (regex_stats.states_pushed) ++;
#line 3748
      (regex_stats.states_popped) ++;
    }
#line 3748
    goto match;
    case_exp___31: /* CIL Label */ 
#line 3748
    (regex_stats.tests) ++;
#line 3748
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3748
      if (((int const   )*(line___1 + 0) & 128) == 0) {
#line 3748
        if ((int const   )*(line___1 + 0) != 10) {
#line 3748
          tmp___57 = 1;
        } else {
#line 3748
          tmp___57 = 0;
        }
      } else {
#line 3748
        tmp___57 = 0;
      }
    } else {
#line 3748
      tmp___57 = 0;
    }
#line 3748
    if (! tmp___57) {
#line 3748
      goto nomatch;
    }
#line 3748
    b_if_match = (b + 1) + 0;
    {
#line 3748
    while (1) {
      while_continue___82: /* CIL Label */ ;
#line 3748
      line___1 ++;
#line 3748
      (regex_stats.tests) ++;
#line 3748
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3748
        if (((int const   )*(line___1 + 0) & 128) == 0) {
#line 3748
          if ((int const   )*(line___1 + 0) != 10) {
#line 3748
            tmp___58 = 1;
          } else {
#line 3748
            tmp___58 = 0;
          }
        } else {
#line 3748
          tmp___58 = 0;
        }
      } else {
#line 3748
        tmp___58 = 0;
      }
#line 3748
      if (! tmp___58) {
#line 3748
        goto while_break___82;
      }
      {
#line 3748
      while (1) {
        while_continue___83: /* CIL Label */ ;
#line 3748
        state->highest_paren_seen = highest_paren_seen;
#line 3748
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3748
        while (1) {
          while_continue___84: /* CIL Label */ ;
#line 3748
          (regex_stats.states_pushed) ++;
#line 3748
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3748
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3748
          while (1) {
            while_continue___85: /* CIL Label */ ;
#line 3748
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3748
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3752);
              }
            }
#line 3748
            goto while_break___85;
          }
          while_break___85: /* CIL Label */ ;
          }
#line 3748
          if (regexec_flags & 2U) {
            {
#line 3748
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3748
          state->b = b_if_match;
#line 3748
          state->line = line___1;
#line 3748
          state ++;
#line 3748
          goto while_break___84;
        }
        while_break___84: /* CIL Label */ ;
        }
#line 3748
        goto while_break___83;
      }
      while_break___83: /* CIL Label */ ;
      }
    }
    while_break___82: /* CIL Label */ ;
    }
#line 3748
    (regex_stats.states_pushed) ++;
#line 3748
    (regex_stats.states_popped) ++;
#line 3748
    goto match;
    case_exp___32: /* CIL Label */ 
#line 3748
    (regex_stats.states_pushed) ++;
#line 3748
    (regex_stats.states_popped) ++;
#line 3748
    b_if_match = (b + 1) + 0;
#line 3748
    (regex_stats.tests) ++;
#line 3748
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3748
      if (((int const   )*(line___1 + 0) & 128) == 0) {
#line 3748
        if ((int const   )*(line___1 + 0) != 10) {
#line 3748
          tmp___60 = 1;
        } else {
#line 3748
          tmp___60 = 0;
        }
      } else {
#line 3748
        tmp___60 = 0;
      }
    } else {
#line 3748
      tmp___60 = 0;
    }
#line 3748
    if (tmp___60) {
      {
#line 3748
      while (1) {
        while_continue___86: /* CIL Label */ ;
        {
#line 3748
        while (1) {
          while_continue___87: /* CIL Label */ ;
#line 3748
          state->highest_paren_seen = highest_paren_seen;
#line 3748
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3748
          while (1) {
            while_continue___88: /* CIL Label */ ;
#line 3748
            (regex_stats.states_pushed) ++;
#line 3748
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3748
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3748
            while (1) {
              while_continue___89: /* CIL Label */ ;
#line 3748
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3748
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3752);
                }
              }
#line 3748
              goto while_break___89;
            }
            while_break___89: /* CIL Label */ ;
            }
#line 3748
            if (regexec_flags & 2U) {
              {
#line 3748
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3748
            state->b = b_if_match;
#line 3748
            state->line = line___1;
#line 3748
            state ++;
#line 3748
            goto while_break___88;
          }
          while_break___88: /* CIL Label */ ;
          }
#line 3748
          goto while_break___87;
        }
        while_break___87: /* CIL Label */ ;
        }
#line 3748
        line___1 ++;
#line 3748
        (regex_stats.tests) ++;
#line 3748
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3748
          if (((int const   )*(line___1 + 0) & 128) == 0) {
#line 3748
            if ((int const   )*(line___1 + 0) != 10) {
#line 3748
              tmp___59 = 1;
            } else {
#line 3748
              tmp___59 = 0;
            }
          } else {
#line 3748
            tmp___59 = 0;
          }
        } else {
#line 3748
          tmp___59 = 0;
        }
#line 3748
        if (! tmp___59) {
#line 3748
          goto while_break___86;
        }
      }
      while_break___86: /* CIL Label */ ;
      }
    }
#line 3748
    goto match;
    case_exp___33: /* CIL Label */ 
#line 3754
    (regex_stats.tests) ++;
#line 3754
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3754
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3754
        Len = (unsigned int )((int const   )euc_info[*(line___1 + 0)] & 3);
      } else {
#line 3754
        Len = 1U;
      }
#line 3754
      if (Len > 1U) {
#line 3754
        tmp___61 = 1;
      } else {
#line 3754
        tmp___61 = 0;
      }
    } else {
#line 3754
      tmp___61 = 0;
    }
#line 3754
    if (! tmp___61) {
#line 3754
      goto nomatch;
    }
#line 3754
    b_if_match = (b + 1) + 0;
#line 3754
    line___1 += Len;
#line 3754
    goto match;
    case_exp___34: /* CIL Label */ 
#line 3754
    b_if_match = (b + 1) + 0;
#line 3754
    (regex_stats.tests) ++;
#line 3754
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3754
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3754
        Len___0 = (unsigned int )((int const   )euc_info[*(line___1 + 0)] & 3);
      } else {
#line 3754
        Len___0 = 1U;
      }
#line 3754
      if (Len___0 > 1U) {
#line 3754
        tmp___62 = 1;
      } else {
#line 3754
        tmp___62 = 0;
      }
    } else {
#line 3754
      tmp___62 = 0;
    }
#line 3754
    if (tmp___62) {
      {
#line 3754
      while (1) {
        while_continue___90: /* CIL Label */ ;
#line 3754
        state->highest_paren_seen = highest_paren_seen;
#line 3754
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3754
        while (1) {
          while_continue___91: /* CIL Label */ ;
#line 3754
          (regex_stats.states_pushed) ++;
#line 3754
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3754
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3754
          while (1) {
            while_continue___92: /* CIL Label */ ;
#line 3754
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3754
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3758);
              }
            }
#line 3754
            goto while_break___92;
          }
          while_break___92: /* CIL Label */ ;
          }
#line 3754
          if (regexec_flags & 2U) {
            {
#line 3754
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3754
          state->b = b_if_match;
#line 3754
          state->line = line___1;
#line 3754
          state ++;
#line 3754
          goto while_break___91;
        }
        while_break___91: /* CIL Label */ ;
        }
#line 3754
        goto while_break___90;
      }
      while_break___90: /* CIL Label */ ;
      }
#line 3754
      line___1 += Len___0;
    } else {
#line 3754
      (regex_stats.states_pushed) ++;
#line 3754
      (regex_stats.states_popped) ++;
    }
#line 3754
    goto match;
    case_exp___35: /* CIL Label */ 
#line 3754
    (regex_stats.tests) ++;
#line 3754
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3754
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3754
        Len___1 = (unsigned int )((int const   )euc_info[*(line___1 + 0)] & 3);
      } else {
#line 3754
        Len___1 = 1U;
      }
#line 3754
      if (Len___1 > 1U) {
#line 3754
        tmp___63 = 1;
      } else {
#line 3754
        tmp___63 = 0;
      }
    } else {
#line 3754
      tmp___63 = 0;
    }
#line 3754
    if (! tmp___63) {
#line 3754
      goto nomatch;
    }
#line 3754
    b_if_match = (b + 1) + 0;
    {
#line 3754
    while (1) {
      while_continue___93: /* CIL Label */ ;
#line 3754
      line___1 += Len___1;
#line 3754
      (regex_stats.tests) ++;
#line 3754
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3754
        if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3754
          Len___1 = (unsigned int )((int const   )euc_info[*(line___1 + 0)] & 3);
        } else {
#line 3754
          Len___1 = 1U;
        }
#line 3754
        if (Len___1 > 1U) {
#line 3754
          tmp___64 = 1;
        } else {
#line 3754
          tmp___64 = 0;
        }
      } else {
#line 3754
        tmp___64 = 0;
      }
#line 3754
      if (! tmp___64) {
#line 3754
        goto while_break___93;
      }
      {
#line 3754
      while (1) {
        while_continue___94: /* CIL Label */ ;
#line 3754
        state->highest_paren_seen = highest_paren_seen;
#line 3754
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3754
        while (1) {
          while_continue___95: /* CIL Label */ ;
#line 3754
          (regex_stats.states_pushed) ++;
#line 3754
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3754
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3754
          while (1) {
            while_continue___96: /* CIL Label */ ;
#line 3754
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3754
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3758);
              }
            }
#line 3754
            goto while_break___96;
          }
          while_break___96: /* CIL Label */ ;
          }
#line 3754
          if (regexec_flags & 2U) {
            {
#line 3754
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3754
          state->b = b_if_match;
#line 3754
          state->line = line___1;
#line 3754
          state ++;
#line 3754
          goto while_break___95;
        }
        while_break___95: /* CIL Label */ ;
        }
#line 3754
        goto while_break___94;
      }
      while_break___94: /* CIL Label */ ;
      }
    }
    while_break___93: /* CIL Label */ ;
    }
#line 3754
    (regex_stats.states_pushed) ++;
#line 3754
    (regex_stats.states_popped) ++;
#line 3754
    goto match;
    case_exp___36: /* CIL Label */ 
#line 3754
    (regex_stats.states_pushed) ++;
#line 3754
    (regex_stats.states_popped) ++;
#line 3754
    b_if_match = (b + 1) + 0;
#line 3754
    (regex_stats.tests) ++;
#line 3754
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3754
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3754
        Len___2 = (unsigned int )((int const   )euc_info[*(line___1 + 0)] & 3);
      } else {
#line 3754
        Len___2 = 1U;
      }
#line 3754
      if (Len___2 > 1U) {
#line 3754
        tmp___66 = 1;
      } else {
#line 3754
        tmp___66 = 0;
      }
    } else {
#line 3754
      tmp___66 = 0;
    }
#line 3754
    if (tmp___66) {
      {
#line 3754
      while (1) {
        while_continue___97: /* CIL Label */ ;
        {
#line 3754
        while (1) {
          while_continue___98: /* CIL Label */ ;
#line 3754
          state->highest_paren_seen = highest_paren_seen;
#line 3754
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3754
          while (1) {
            while_continue___99: /* CIL Label */ ;
#line 3754
            (regex_stats.states_pushed) ++;
#line 3754
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3754
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3754
            while (1) {
              while_continue___100: /* CIL Label */ ;
#line 3754
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3754
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3758);
                }
              }
#line 3754
              goto while_break___100;
            }
            while_break___100: /* CIL Label */ ;
            }
#line 3754
            if (regexec_flags & 2U) {
              {
#line 3754
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3754
            state->b = b_if_match;
#line 3754
            state->line = line___1;
#line 3754
            state ++;
#line 3754
            goto while_break___99;
          }
          while_break___99: /* CIL Label */ ;
          }
#line 3754
          goto while_break___98;
        }
        while_break___98: /* CIL Label */ ;
        }
#line 3754
        line___1 += Len___2;
#line 3754
        (regex_stats.tests) ++;
#line 3754
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3754
          if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3754
            Len___2 = (unsigned int )((int const   )euc_info[*(line___1 + 0)] & 3);
          } else {
#line 3754
            Len___2 = 1U;
          }
#line 3754
          if (Len___2 > 1U) {
#line 3754
            tmp___65 = 1;
          } else {
#line 3754
            tmp___65 = 0;
          }
        } else {
#line 3754
          tmp___65 = 0;
        }
#line 3754
        if (! tmp___65) {
#line 3754
          goto while_break___97;
        }
      }
      while_break___97: /* CIL Label */ ;
      }
    }
#line 3754
    goto match;
    case_exp___37: /* CIL Label */ 
#line 3760
    (regex_stats.tests) ++;
#line 3760
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3760
      if ((int const   )*(line___1 + 0) == 165) {
#line 3760
        tmp___67 = 1;
      } else
#line 3760
      if ((int const   )*(line___1 + 0) == 161) {
#line 3760
        if ((int const   )*(line___1 + 1) == 188) {
#line 3760
          tmp___67 = 1;
        } else {
#line 3760
          tmp___67 = 0;
        }
      } else {
#line 3760
        tmp___67 = 0;
      }
    } else {
#line 3760
      tmp___67 = 0;
    }
#line 3760
    if (! tmp___67) {
#line 3760
      goto nomatch;
    }
#line 3760
    b_if_match = (b + 1) + 0;
#line 3760
    line___1 += 2;
#line 3760
    goto match;
    case_exp___38: /* CIL Label */ 
#line 3760
    b_if_match = (b + 1) + 0;
#line 3760
    (regex_stats.tests) ++;
#line 3760
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3760
      if ((int const   )*(line___1 + 0) == 165) {
#line 3760
        tmp___68 = 1;
      } else
#line 3760
      if ((int const   )*(line___1 + 0) == 161) {
#line 3760
        if ((int const   )*(line___1 + 1) == 188) {
#line 3760
          tmp___68 = 1;
        } else {
#line 3760
          tmp___68 = 0;
        }
      } else {
#line 3760
        tmp___68 = 0;
      }
    } else {
#line 3760
      tmp___68 = 0;
    }
#line 3760
    if (tmp___68) {
      {
#line 3760
      while (1) {
        while_continue___101: /* CIL Label */ ;
#line 3760
        state->highest_paren_seen = highest_paren_seen;
#line 3760
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3760
        while (1) {
          while_continue___102: /* CIL Label */ ;
#line 3760
          (regex_stats.states_pushed) ++;
#line 3760
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3760
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3760
          while (1) {
            while_continue___103: /* CIL Label */ ;
#line 3760
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3760
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3766);
              }
            }
#line 3760
            goto while_break___103;
          }
          while_break___103: /* CIL Label */ ;
          }
#line 3760
          if (regexec_flags & 2U) {
            {
#line 3760
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3760
          state->b = b_if_match;
#line 3760
          state->line = line___1;
#line 3760
          state ++;
#line 3760
          goto while_break___102;
        }
        while_break___102: /* CIL Label */ ;
        }
#line 3760
        goto while_break___101;
      }
      while_break___101: /* CIL Label */ ;
      }
#line 3760
      line___1 += 2;
    } else {
#line 3760
      (regex_stats.states_pushed) ++;
#line 3760
      (regex_stats.states_popped) ++;
    }
#line 3760
    goto match;
    case_exp___39: /* CIL Label */ 
#line 3760
    (regex_stats.tests) ++;
#line 3760
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3760
      if ((int const   )*(line___1 + 0) == 165) {
#line 3760
        tmp___69 = 1;
      } else
#line 3760
      if ((int const   )*(line___1 + 0) == 161) {
#line 3760
        if ((int const   )*(line___1 + 1) == 188) {
#line 3760
          tmp___69 = 1;
        } else {
#line 3760
          tmp___69 = 0;
        }
      } else {
#line 3760
        tmp___69 = 0;
      }
    } else {
#line 3760
      tmp___69 = 0;
    }
#line 3760
    if (! tmp___69) {
#line 3760
      goto nomatch;
    }
#line 3760
    b_if_match = (b + 1) + 0;
    {
#line 3760
    while (1) {
      while_continue___104: /* CIL Label */ ;
#line 3760
      line___1 += 2;
#line 3760
      (regex_stats.tests) ++;
#line 3760
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3760
        if ((int const   )*(line___1 + 0) == 165) {
#line 3760
          tmp___70 = 1;
        } else
#line 3760
        if ((int const   )*(line___1 + 0) == 161) {
#line 3760
          if ((int const   )*(line___1 + 1) == 188) {
#line 3760
            tmp___70 = 1;
          } else {
#line 3760
            tmp___70 = 0;
          }
        } else {
#line 3760
          tmp___70 = 0;
        }
      } else {
#line 3760
        tmp___70 = 0;
      }
#line 3760
      if (! tmp___70) {
#line 3760
        goto while_break___104;
      }
      {
#line 3760
      while (1) {
        while_continue___105: /* CIL Label */ ;
#line 3760
        state->highest_paren_seen = highest_paren_seen;
#line 3760
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3760
        while (1) {
          while_continue___106: /* CIL Label */ ;
#line 3760
          (regex_stats.states_pushed) ++;
#line 3760
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3760
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3760
          while (1) {
            while_continue___107: /* CIL Label */ ;
#line 3760
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3760
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3766);
              }
            }
#line 3760
            goto while_break___107;
          }
          while_break___107: /* CIL Label */ ;
          }
#line 3760
          if (regexec_flags & 2U) {
            {
#line 3760
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3760
          state->b = b_if_match;
#line 3760
          state->line = line___1;
#line 3760
          state ++;
#line 3760
          goto while_break___106;
        }
        while_break___106: /* CIL Label */ ;
        }
#line 3760
        goto while_break___105;
      }
      while_break___105: /* CIL Label */ ;
      }
    }
    while_break___104: /* CIL Label */ ;
    }
#line 3760
    (regex_stats.states_pushed) ++;
#line 3760
    (regex_stats.states_popped) ++;
#line 3760
    goto match;
    case_exp___40: /* CIL Label */ 
#line 3760
    (regex_stats.states_pushed) ++;
#line 3760
    (regex_stats.states_popped) ++;
#line 3760
    b_if_match = (b + 1) + 0;
#line 3760
    (regex_stats.tests) ++;
#line 3760
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3760
      if ((int const   )*(line___1 + 0) == 165) {
#line 3760
        tmp___72 = 1;
      } else
#line 3760
      if ((int const   )*(line___1 + 0) == 161) {
#line 3760
        if ((int const   )*(line___1 + 1) == 188) {
#line 3760
          tmp___72 = 1;
        } else {
#line 3760
          tmp___72 = 0;
        }
      } else {
#line 3760
        tmp___72 = 0;
      }
    } else {
#line 3760
      tmp___72 = 0;
    }
#line 3760
    if (tmp___72) {
      {
#line 3760
      while (1) {
        while_continue___108: /* CIL Label */ ;
        {
#line 3760
        while (1) {
          while_continue___109: /* CIL Label */ ;
#line 3760
          state->highest_paren_seen = highest_paren_seen;
#line 3760
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3760
          while (1) {
            while_continue___110: /* CIL Label */ ;
#line 3760
            (regex_stats.states_pushed) ++;
#line 3760
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3760
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3760
            while (1) {
              while_continue___111: /* CIL Label */ ;
#line 3760
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3760
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3766);
                }
              }
#line 3760
              goto while_break___111;
            }
            while_break___111: /* CIL Label */ ;
            }
#line 3760
            if (regexec_flags & 2U) {
              {
#line 3760
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3760
            state->b = b_if_match;
#line 3760
            state->line = line___1;
#line 3760
            state ++;
#line 3760
            goto while_break___110;
          }
          while_break___110: /* CIL Label */ ;
          }
#line 3760
          goto while_break___109;
        }
        while_break___109: /* CIL Label */ ;
        }
#line 3760
        line___1 += 2;
#line 3760
        (regex_stats.tests) ++;
#line 3760
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3760
          if ((int const   )*(line___1 + 0) == 165) {
#line 3760
            tmp___71 = 1;
          } else
#line 3760
          if ((int const   )*(line___1 + 0) == 161) {
#line 3760
            if ((int const   )*(line___1 + 1) == 188) {
#line 3760
              tmp___71 = 1;
            } else {
#line 3760
              tmp___71 = 0;
            }
          } else {
#line 3760
            tmp___71 = 0;
          }
        } else {
#line 3760
          tmp___71 = 0;
        }
#line 3760
        if (! tmp___71) {
#line 3760
          goto while_break___108;
        }
      }
      while_break___108: /* CIL Label */ ;
      }
    }
#line 3760
    goto match;
    case_exp___41: /* CIL Label */ 
#line 3768
    (regex_stats.tests) ++;
#line 3768
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3768
      if ((int const   )*(line___1 + 0) == 165) {
#line 3768
        tmp___73 = 0;
      } else
#line 3768
      if ((int const   )*(line___1 + 0) == 161) {
#line 3768
        if ((int const   )*(line___1 + 1) == 188) {
#line 3768
          tmp___73 = 0;
        } else {
#line 3768
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 3768
      if ((int const   )*(line___1 + 0) != 10) {
#line 3768
        tmp___73 = 1;
      } else {
#line 3768
        tmp___73 = 0;
      }
    } else {
#line 3768
      tmp___73 = 0;
    }
#line 3768
    if (! tmp___73) {
#line 3768
      goto nomatch;
    }
#line 3768
    b_if_match = (b + 1) + 0;
#line 3768
    if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3768
      tmp___74 = (int const   )euc_info[*(line___1 + 0)] & 3;
    } else {
#line 3768
      tmp___74 = (int const   )1;
    }
#line 3768
    line___1 += tmp___74;
#line 3768
    goto match;
    case_exp___42: /* CIL Label */ 
#line 3768
    b_if_match = (b + 1) + 0;
#line 3768
    (regex_stats.tests) ++;
#line 3768
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3768
      if ((int const   )*(line___1 + 0) == 165) {
#line 3768
        tmp___76 = 0;
      } else
#line 3768
      if ((int const   )*(line___1 + 0) == 161) {
#line 3768
        if ((int const   )*(line___1 + 1) == 188) {
#line 3768
          tmp___76 = 0;
        } else {
#line 3768
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 3768
      if ((int const   )*(line___1 + 0) != 10) {
#line 3768
        tmp___76 = 1;
      } else {
#line 3768
        tmp___76 = 0;
      }
    } else {
#line 3768
      tmp___76 = 0;
    }
#line 3768
    if (tmp___76) {
      {
#line 3768
      while (1) {
        while_continue___112: /* CIL Label */ ;
#line 3768
        state->highest_paren_seen = highest_paren_seen;
#line 3768
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3768
        while (1) {
          while_continue___113: /* CIL Label */ ;
#line 3768
          (regex_stats.states_pushed) ++;
#line 3768
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3768
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3768
          while (1) {
            while_continue___114: /* CIL Label */ ;
#line 3768
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3768
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3775);
              }
            }
#line 3768
            goto while_break___114;
          }
          while_break___114: /* CIL Label */ ;
          }
#line 3768
          if (regexec_flags & 2U) {
            {
#line 3768
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3768
          state->b = b_if_match;
#line 3768
          state->line = line___1;
#line 3768
          state ++;
#line 3768
          goto while_break___113;
        }
        while_break___113: /* CIL Label */ ;
        }
#line 3768
        goto while_break___112;
      }
      while_break___112: /* CIL Label */ ;
      }
#line 3768
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3768
        tmp___75 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3768
        tmp___75 = (int const   )1;
      }
#line 3768
      line___1 += tmp___75;
    } else {
#line 3768
      (regex_stats.states_pushed) ++;
#line 3768
      (regex_stats.states_popped) ++;
    }
#line 3768
    goto match;
    case_exp___43: /* CIL Label */ 
#line 3768
    (regex_stats.tests) ++;
#line 3768
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3768
      if ((int const   )*(line___1 + 0) == 165) {
#line 3768
        tmp___77 = 0;
      } else
#line 3768
      if ((int const   )*(line___1 + 0) == 161) {
#line 3768
        if ((int const   )*(line___1 + 1) == 188) {
#line 3768
          tmp___77 = 0;
        } else {
#line 3768
          goto _L___11;
        }
      } else
      _L___11: /* CIL Label */ 
#line 3768
      if ((int const   )*(line___1 + 0) != 10) {
#line 3768
        tmp___77 = 1;
      } else {
#line 3768
        tmp___77 = 0;
      }
    } else {
#line 3768
      tmp___77 = 0;
    }
#line 3768
    if (! tmp___77) {
#line 3768
      goto nomatch;
    }
#line 3768
    b_if_match = (b + 1) + 0;
    {
#line 3768
    while (1) {
      while_continue___115: /* CIL Label */ ;
#line 3768
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3768
        tmp___78 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3768
        tmp___78 = (int const   )1;
      }
#line 3768
      line___1 += tmp___78;
#line 3768
      (regex_stats.tests) ++;
#line 3768
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3768
        if ((int const   )*(line___1 + 0) == 165) {
#line 3768
          tmp___79 = 0;
        } else
#line 3768
        if ((int const   )*(line___1 + 0) == 161) {
#line 3768
          if ((int const   )*(line___1 + 1) == 188) {
#line 3768
            tmp___79 = 0;
          } else {
#line 3768
            goto _L___12;
          }
        } else
        _L___12: /* CIL Label */ 
#line 3768
        if ((int const   )*(line___1 + 0) != 10) {
#line 3768
          tmp___79 = 1;
        } else {
#line 3768
          tmp___79 = 0;
        }
      } else {
#line 3768
        tmp___79 = 0;
      }
#line 3768
      if (! tmp___79) {
#line 3768
        goto while_break___115;
      }
      {
#line 3768
      while (1) {
        while_continue___116: /* CIL Label */ ;
#line 3768
        state->highest_paren_seen = highest_paren_seen;
#line 3768
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3768
        while (1) {
          while_continue___117: /* CIL Label */ ;
#line 3768
          (regex_stats.states_pushed) ++;
#line 3768
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3768
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3768
          while (1) {
            while_continue___118: /* CIL Label */ ;
#line 3768
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3768
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3775);
              }
            }
#line 3768
            goto while_break___118;
          }
          while_break___118: /* CIL Label */ ;
          }
#line 3768
          if (regexec_flags & 2U) {
            {
#line 3768
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3768
          state->b = b_if_match;
#line 3768
          state->line = line___1;
#line 3768
          state ++;
#line 3768
          goto while_break___117;
        }
        while_break___117: /* CIL Label */ ;
        }
#line 3768
        goto while_break___116;
      }
      while_break___116: /* CIL Label */ ;
      }
    }
    while_break___115: /* CIL Label */ ;
    }
#line 3768
    (regex_stats.states_pushed) ++;
#line 3768
    (regex_stats.states_popped) ++;
#line 3768
    goto match;
    case_exp___44: /* CIL Label */ 
#line 3768
    (regex_stats.states_pushed) ++;
#line 3768
    (regex_stats.states_popped) ++;
#line 3768
    b_if_match = (b + 1) + 0;
#line 3768
    (regex_stats.tests) ++;
#line 3768
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3768
      if ((int const   )*(line___1 + 0) == 165) {
#line 3768
        tmp___82 = 0;
      } else
#line 3768
      if ((int const   )*(line___1 + 0) == 161) {
#line 3768
        if ((int const   )*(line___1 + 1) == 188) {
#line 3768
          tmp___82 = 0;
        } else {
#line 3768
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 3768
      if ((int const   )*(line___1 + 0) != 10) {
#line 3768
        tmp___82 = 1;
      } else {
#line 3768
        tmp___82 = 0;
      }
    } else {
#line 3768
      tmp___82 = 0;
    }
#line 3768
    if (tmp___82) {
      {
#line 3768
      while (1) {
        while_continue___119: /* CIL Label */ ;
        {
#line 3768
        while (1) {
          while_continue___120: /* CIL Label */ ;
#line 3768
          state->highest_paren_seen = highest_paren_seen;
#line 3768
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3768
          while (1) {
            while_continue___121: /* CIL Label */ ;
#line 3768
            (regex_stats.states_pushed) ++;
#line 3768
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3768
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3768
            while (1) {
              while_continue___122: /* CIL Label */ ;
#line 3768
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3768
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3775);
                }
              }
#line 3768
              goto while_break___122;
            }
            while_break___122: /* CIL Label */ ;
            }
#line 3768
            if (regexec_flags & 2U) {
              {
#line 3768
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3768
            state->b = b_if_match;
#line 3768
            state->line = line___1;
#line 3768
            state ++;
#line 3768
            goto while_break___121;
          }
          while_break___121: /* CIL Label */ ;
          }
#line 3768
          goto while_break___120;
        }
        while_break___120: /* CIL Label */ ;
        }
#line 3768
        if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3768
          tmp___80 = (int const   )euc_info[*(line___1 + 0)] & 3;
        } else {
#line 3768
          tmp___80 = (int const   )1;
        }
#line 3768
        line___1 += tmp___80;
#line 3768
        (regex_stats.tests) ++;
#line 3768
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3768
          if ((int const   )*(line___1 + 0) == 165) {
#line 3768
            tmp___81 = 0;
          } else
#line 3768
          if ((int const   )*(line___1 + 0) == 161) {
#line 3768
            if ((int const   )*(line___1 + 1) == 188) {
#line 3768
              tmp___81 = 0;
            } else {
#line 3768
              goto _L___13;
            }
          } else
          _L___13: /* CIL Label */ 
#line 3768
          if ((int const   )*(line___1 + 0) != 10) {
#line 3768
            tmp___81 = 1;
          } else {
#line 3768
            tmp___81 = 0;
          }
        } else {
#line 3768
          tmp___81 = 0;
        }
#line 3768
        if (! tmp___81) {
#line 3768
          goto while_break___119;
        }
      }
      while_break___119: /* CIL Label */ ;
      }
    }
#line 3768
    goto match;
    case_exp___45: /* CIL Label */ 
#line 3777
    (regex_stats.tests) ++;
#line 3777
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3777
      if ((int const   )*(line___1 + 0) == 164) {
#line 3777
        tmp___83 = 1;
      } else {
#line 3777
        tmp___83 = 0;
      }
    } else {
#line 3777
      tmp___83 = 0;
    }
#line 3777
    if (! tmp___83) {
#line 3777
      goto nomatch;
    }
#line 3777
    b_if_match = (b + 1) + 0;
#line 3777
    line___1 += 2;
#line 3777
    goto match;
    case_exp___46: /* CIL Label */ 
#line 3777
    b_if_match = (b + 1) + 0;
#line 3777
    (regex_stats.tests) ++;
#line 3777
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3777
      if ((int const   )*(line___1 + 0) == 164) {
#line 3777
        tmp___84 = 1;
      } else {
#line 3777
        tmp___84 = 0;
      }
    } else {
#line 3777
      tmp___84 = 0;
    }
#line 3777
    if (tmp___84) {
      {
#line 3777
      while (1) {
        while_continue___123: /* CIL Label */ ;
#line 3777
        state->highest_paren_seen = highest_paren_seen;
#line 3777
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3777
        while (1) {
          while_continue___124: /* CIL Label */ ;
#line 3777
          (regex_stats.states_pushed) ++;
#line 3777
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3777
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3777
          while (1) {
            while_continue___125: /* CIL Label */ ;
#line 3777
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3777
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3781);
              }
            }
#line 3777
            goto while_break___125;
          }
          while_break___125: /* CIL Label */ ;
          }
#line 3777
          if (regexec_flags & 2U) {
            {
#line 3777
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3777
          state->b = b_if_match;
#line 3777
          state->line = line___1;
#line 3777
          state ++;
#line 3777
          goto while_break___124;
        }
        while_break___124: /* CIL Label */ ;
        }
#line 3777
        goto while_break___123;
      }
      while_break___123: /* CIL Label */ ;
      }
#line 3777
      line___1 += 2;
    } else {
#line 3777
      (regex_stats.states_pushed) ++;
#line 3777
      (regex_stats.states_popped) ++;
    }
#line 3777
    goto match;
    case_exp___47: /* CIL Label */ 
#line 3777
    (regex_stats.tests) ++;
#line 3777
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3777
      if ((int const   )*(line___1 + 0) == 164) {
#line 3777
        tmp___85 = 1;
      } else {
#line 3777
        tmp___85 = 0;
      }
    } else {
#line 3777
      tmp___85 = 0;
    }
#line 3777
    if (! tmp___85) {
#line 3777
      goto nomatch;
    }
#line 3777
    b_if_match = (b + 1) + 0;
    {
#line 3777
    while (1) {
      while_continue___126: /* CIL Label */ ;
#line 3777
      line___1 += 2;
#line 3777
      (regex_stats.tests) ++;
#line 3777
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3777
        if ((int const   )*(line___1 + 0) == 164) {
#line 3777
          tmp___86 = 1;
        } else {
#line 3777
          tmp___86 = 0;
        }
      } else {
#line 3777
        tmp___86 = 0;
      }
#line 3777
      if (! tmp___86) {
#line 3777
        goto while_break___126;
      }
      {
#line 3777
      while (1) {
        while_continue___127: /* CIL Label */ ;
#line 3777
        state->highest_paren_seen = highest_paren_seen;
#line 3777
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3777
        while (1) {
          while_continue___128: /* CIL Label */ ;
#line 3777
          (regex_stats.states_pushed) ++;
#line 3777
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3777
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3777
          while (1) {
            while_continue___129: /* CIL Label */ ;
#line 3777
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3777
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3781);
              }
            }
#line 3777
            goto while_break___129;
          }
          while_break___129: /* CIL Label */ ;
          }
#line 3777
          if (regexec_flags & 2U) {
            {
#line 3777
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3777
          state->b = b_if_match;
#line 3777
          state->line = line___1;
#line 3777
          state ++;
#line 3777
          goto while_break___128;
        }
        while_break___128: /* CIL Label */ ;
        }
#line 3777
        goto while_break___127;
      }
      while_break___127: /* CIL Label */ ;
      }
    }
    while_break___126: /* CIL Label */ ;
    }
#line 3777
    (regex_stats.states_pushed) ++;
#line 3777
    (regex_stats.states_popped) ++;
#line 3777
    goto match;
    case_exp___48: /* CIL Label */ 
#line 3777
    (regex_stats.states_pushed) ++;
#line 3777
    (regex_stats.states_popped) ++;
#line 3777
    b_if_match = (b + 1) + 0;
#line 3777
    (regex_stats.tests) ++;
#line 3777
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3777
      if ((int const   )*(line___1 + 0) == 164) {
#line 3777
        tmp___88 = 1;
      } else {
#line 3777
        tmp___88 = 0;
      }
    } else {
#line 3777
      tmp___88 = 0;
    }
#line 3777
    if (tmp___88) {
      {
#line 3777
      while (1) {
        while_continue___130: /* CIL Label */ ;
        {
#line 3777
        while (1) {
          while_continue___131: /* CIL Label */ ;
#line 3777
          state->highest_paren_seen = highest_paren_seen;
#line 3777
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3777
          while (1) {
            while_continue___132: /* CIL Label */ ;
#line 3777
            (regex_stats.states_pushed) ++;
#line 3777
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3777
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3777
            while (1) {
              while_continue___133: /* CIL Label */ ;
#line 3777
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3777
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3781);
                }
              }
#line 3777
              goto while_break___133;
            }
            while_break___133: /* CIL Label */ ;
            }
#line 3777
            if (regexec_flags & 2U) {
              {
#line 3777
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3777
            state->b = b_if_match;
#line 3777
            state->line = line___1;
#line 3777
            state ++;
#line 3777
            goto while_break___132;
          }
          while_break___132: /* CIL Label */ ;
          }
#line 3777
          goto while_break___131;
        }
        while_break___131: /* CIL Label */ ;
        }
#line 3777
        line___1 += 2;
#line 3777
        (regex_stats.tests) ++;
#line 3777
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3777
          if ((int const   )*(line___1 + 0) == 164) {
#line 3777
            tmp___87 = 1;
          } else {
#line 3777
            tmp___87 = 0;
          }
        } else {
#line 3777
          tmp___87 = 0;
        }
#line 3777
        if (! tmp___87) {
#line 3777
          goto while_break___130;
        }
      }
      while_break___130: /* CIL Label */ ;
      }
    }
#line 3777
    goto match;
    case_exp___49: /* CIL Label */ 
#line 3783
    (regex_stats.tests) ++;
#line 3783
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3783
      if ((int const   )*(line___1 + 0) != 164) {
#line 3783
        if ((int const   )*(line___1 + 0) != 10) {
#line 3783
          tmp___89 = 1;
        } else {
#line 3783
          tmp___89 = 0;
        }
      } else {
#line 3783
        tmp___89 = 0;
      }
    } else {
#line 3783
      tmp___89 = 0;
    }
#line 3783
    if (! tmp___89) {
#line 3783
      goto nomatch;
    }
#line 3783
    b_if_match = (b + 1) + 0;
#line 3783
    if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3783
      tmp___90 = (int const   )euc_info[*(line___1 + 0)] & 3;
    } else {
#line 3783
      tmp___90 = (int const   )1;
    }
#line 3783
    line___1 += tmp___90;
#line 3783
    goto match;
    case_exp___50: /* CIL Label */ 
#line 3783
    b_if_match = (b + 1) + 0;
#line 3783
    (regex_stats.tests) ++;
#line 3783
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3783
      if ((int const   )*(line___1 + 0) != 164) {
#line 3783
        if ((int const   )*(line___1 + 0) != 10) {
#line 3783
          tmp___92 = 1;
        } else {
#line 3783
          tmp___92 = 0;
        }
      } else {
#line 3783
        tmp___92 = 0;
      }
    } else {
#line 3783
      tmp___92 = 0;
    }
#line 3783
    if (tmp___92) {
      {
#line 3783
      while (1) {
        while_continue___134: /* CIL Label */ ;
#line 3783
        state->highest_paren_seen = highest_paren_seen;
#line 3783
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3783
        while (1) {
          while_continue___135: /* CIL Label */ ;
#line 3783
          (regex_stats.states_pushed) ++;
#line 3783
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3783
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3783
          while (1) {
            while_continue___136: /* CIL Label */ ;
#line 3783
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3783
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3787);
              }
            }
#line 3783
            goto while_break___136;
          }
          while_break___136: /* CIL Label */ ;
          }
#line 3783
          if (regexec_flags & 2U) {
            {
#line 3783
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3783
          state->b = b_if_match;
#line 3783
          state->line = line___1;
#line 3783
          state ++;
#line 3783
          goto while_break___135;
        }
        while_break___135: /* CIL Label */ ;
        }
#line 3783
        goto while_break___134;
      }
      while_break___134: /* CIL Label */ ;
      }
#line 3783
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3783
        tmp___91 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3783
        tmp___91 = (int const   )1;
      }
#line 3783
      line___1 += tmp___91;
    } else {
#line 3783
      (regex_stats.states_pushed) ++;
#line 3783
      (regex_stats.states_popped) ++;
    }
#line 3783
    goto match;
    case_exp___51: /* CIL Label */ 
#line 3783
    (regex_stats.tests) ++;
#line 3783
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3783
      if ((int const   )*(line___1 + 0) != 164) {
#line 3783
        if ((int const   )*(line___1 + 0) != 10) {
#line 3783
          tmp___93 = 1;
        } else {
#line 3783
          tmp___93 = 0;
        }
      } else {
#line 3783
        tmp___93 = 0;
      }
    } else {
#line 3783
      tmp___93 = 0;
    }
#line 3783
    if (! tmp___93) {
#line 3783
      goto nomatch;
    }
#line 3783
    b_if_match = (b + 1) + 0;
    {
#line 3783
    while (1) {
      while_continue___137: /* CIL Label */ ;
#line 3783
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3783
        tmp___94 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3783
        tmp___94 = (int const   )1;
      }
#line 3783
      line___1 += tmp___94;
#line 3783
      (regex_stats.tests) ++;
#line 3783
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3783
        if ((int const   )*(line___1 + 0) != 164) {
#line 3783
          if ((int const   )*(line___1 + 0) != 10) {
#line 3783
            tmp___95 = 1;
          } else {
#line 3783
            tmp___95 = 0;
          }
        } else {
#line 3783
          tmp___95 = 0;
        }
      } else {
#line 3783
        tmp___95 = 0;
      }
#line 3783
      if (! tmp___95) {
#line 3783
        goto while_break___137;
      }
      {
#line 3783
      while (1) {
        while_continue___138: /* CIL Label */ ;
#line 3783
        state->highest_paren_seen = highest_paren_seen;
#line 3783
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3783
        while (1) {
          while_continue___139: /* CIL Label */ ;
#line 3783
          (regex_stats.states_pushed) ++;
#line 3783
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3783
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3783
          while (1) {
            while_continue___140: /* CIL Label */ ;
#line 3783
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3783
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3787);
              }
            }
#line 3783
            goto while_break___140;
          }
          while_break___140: /* CIL Label */ ;
          }
#line 3783
          if (regexec_flags & 2U) {
            {
#line 3783
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3783
          state->b = b_if_match;
#line 3783
          state->line = line___1;
#line 3783
          state ++;
#line 3783
          goto while_break___139;
        }
        while_break___139: /* CIL Label */ ;
        }
#line 3783
        goto while_break___138;
      }
      while_break___138: /* CIL Label */ ;
      }
    }
    while_break___137: /* CIL Label */ ;
    }
#line 3783
    (regex_stats.states_pushed) ++;
#line 3783
    (regex_stats.states_popped) ++;
#line 3783
    goto match;
    case_exp___52: /* CIL Label */ 
#line 3783
    (regex_stats.states_pushed) ++;
#line 3783
    (regex_stats.states_popped) ++;
#line 3783
    b_if_match = (b + 1) + 0;
#line 3783
    (regex_stats.tests) ++;
#line 3783
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3783
      if ((int const   )*(line___1 + 0) != 164) {
#line 3783
        if ((int const   )*(line___1 + 0) != 10) {
#line 3783
          tmp___98 = 1;
        } else {
#line 3783
          tmp___98 = 0;
        }
      } else {
#line 3783
        tmp___98 = 0;
      }
    } else {
#line 3783
      tmp___98 = 0;
    }
#line 3783
    if (tmp___98) {
      {
#line 3783
      while (1) {
        while_continue___141: /* CIL Label */ ;
        {
#line 3783
        while (1) {
          while_continue___142: /* CIL Label */ ;
#line 3783
          state->highest_paren_seen = highest_paren_seen;
#line 3783
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3783
          while (1) {
            while_continue___143: /* CIL Label */ ;
#line 3783
            (regex_stats.states_pushed) ++;
#line 3783
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3783
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3783
            while (1) {
              while_continue___144: /* CIL Label */ ;
#line 3783
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3783
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3787);
                }
              }
#line 3783
              goto while_break___144;
            }
            while_break___144: /* CIL Label */ ;
            }
#line 3783
            if (regexec_flags & 2U) {
              {
#line 3783
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3783
            state->b = b_if_match;
#line 3783
            state->line = line___1;
#line 3783
            state ++;
#line 3783
            goto while_break___143;
          }
          while_break___143: /* CIL Label */ ;
          }
#line 3783
          goto while_break___142;
        }
        while_break___142: /* CIL Label */ ;
        }
#line 3783
        if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3783
          tmp___96 = (int const   )euc_info[*(line___1 + 0)] & 3;
        } else {
#line 3783
          tmp___96 = (int const   )1;
        }
#line 3783
        line___1 += tmp___96;
#line 3783
        (regex_stats.tests) ++;
#line 3783
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3783
          if ((int const   )*(line___1 + 0) != 164) {
#line 3783
            if ((int const   )*(line___1 + 0) != 10) {
#line 3783
              tmp___97 = 1;
            } else {
#line 3783
              tmp___97 = 0;
            }
          } else {
#line 3783
            tmp___97 = 0;
          }
        } else {
#line 3783
          tmp___97 = 0;
        }
#line 3783
        if (! tmp___97) {
#line 3783
          goto while_break___141;
        }
      }
      while_break___141: /* CIL Label */ ;
      }
    }
#line 3783
    goto match;
    case_exp___53: /* CIL Label */ 
#line 3789
    (regex_stats.tests) ++;
#line 3789
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3789
      if ((int const   )*(line___1 + 0) >= 176) {
#line 3789
        if ((int const   )*(line___1 + 0) <= 244) {
#line 3789
          tmp___99 = 1;
        } else {
#line 3789
          tmp___99 = 0;
        }
      } else {
#line 3789
        tmp___99 = 0;
      }
    } else {
#line 3789
      tmp___99 = 0;
    }
#line 3789
    if (! tmp___99) {
#line 3789
      goto nomatch;
    }
#line 3789
    b_if_match = (b + 1) + 0;
#line 3789
    line___1 += 2;
#line 3789
    goto match;
    case_exp___54: /* CIL Label */ 
#line 3789
    b_if_match = (b + 1) + 0;
#line 3789
    (regex_stats.tests) ++;
#line 3789
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3789
      if ((int const   )*(line___1 + 0) >= 176) {
#line 3789
        if ((int const   )*(line___1 + 0) <= 244) {
#line 3789
          tmp___100 = 1;
        } else {
#line 3789
          tmp___100 = 0;
        }
      } else {
#line 3789
        tmp___100 = 0;
      }
    } else {
#line 3789
      tmp___100 = 0;
    }
#line 3789
    if (tmp___100) {
      {
#line 3789
      while (1) {
        while_continue___145: /* CIL Label */ ;
#line 3789
        state->highest_paren_seen = highest_paren_seen;
#line 3789
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3789
        while (1) {
          while_continue___146: /* CIL Label */ ;
#line 3789
          (regex_stats.states_pushed) ++;
#line 3789
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3789
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3789
          while (1) {
            while_continue___147: /* CIL Label */ ;
#line 3789
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3789
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3794);
              }
            }
#line 3789
            goto while_break___147;
          }
          while_break___147: /* CIL Label */ ;
          }
#line 3789
          if (regexec_flags & 2U) {
            {
#line 3789
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3789
          state->b = b_if_match;
#line 3789
          state->line = line___1;
#line 3789
          state ++;
#line 3789
          goto while_break___146;
        }
        while_break___146: /* CIL Label */ ;
        }
#line 3789
        goto while_break___145;
      }
      while_break___145: /* CIL Label */ ;
      }
#line 3789
      line___1 += 2;
    } else {
#line 3789
      (regex_stats.states_pushed) ++;
#line 3789
      (regex_stats.states_popped) ++;
    }
#line 3789
    goto match;
    case_exp___55: /* CIL Label */ 
#line 3789
    (regex_stats.tests) ++;
#line 3789
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3789
      if ((int const   )*(line___1 + 0) >= 176) {
#line 3789
        if ((int const   )*(line___1 + 0) <= 244) {
#line 3789
          tmp___101 = 1;
        } else {
#line 3789
          tmp___101 = 0;
        }
      } else {
#line 3789
        tmp___101 = 0;
      }
    } else {
#line 3789
      tmp___101 = 0;
    }
#line 3789
    if (! tmp___101) {
#line 3789
      goto nomatch;
    }
#line 3789
    b_if_match = (b + 1) + 0;
    {
#line 3789
    while (1) {
      while_continue___148: /* CIL Label */ ;
#line 3789
      line___1 += 2;
#line 3789
      (regex_stats.tests) ++;
#line 3789
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3789
        if ((int const   )*(line___1 + 0) >= 176) {
#line 3789
          if ((int const   )*(line___1 + 0) <= 244) {
#line 3789
            tmp___102 = 1;
          } else {
#line 3789
            tmp___102 = 0;
          }
        } else {
#line 3789
          tmp___102 = 0;
        }
      } else {
#line 3789
        tmp___102 = 0;
      }
#line 3789
      if (! tmp___102) {
#line 3789
        goto while_break___148;
      }
      {
#line 3789
      while (1) {
        while_continue___149: /* CIL Label */ ;
#line 3789
        state->highest_paren_seen = highest_paren_seen;
#line 3789
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3789
        while (1) {
          while_continue___150: /* CIL Label */ ;
#line 3789
          (regex_stats.states_pushed) ++;
#line 3789
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3789
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3789
          while (1) {
            while_continue___151: /* CIL Label */ ;
#line 3789
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3789
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3794);
              }
            }
#line 3789
            goto while_break___151;
          }
          while_break___151: /* CIL Label */ ;
          }
#line 3789
          if (regexec_flags & 2U) {
            {
#line 3789
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3789
          state->b = b_if_match;
#line 3789
          state->line = line___1;
#line 3789
          state ++;
#line 3789
          goto while_break___150;
        }
        while_break___150: /* CIL Label */ ;
        }
#line 3789
        goto while_break___149;
      }
      while_break___149: /* CIL Label */ ;
      }
    }
    while_break___148: /* CIL Label */ ;
    }
#line 3789
    (regex_stats.states_pushed) ++;
#line 3789
    (regex_stats.states_popped) ++;
#line 3789
    goto match;
    case_exp___56: /* CIL Label */ 
#line 3789
    (regex_stats.states_pushed) ++;
#line 3789
    (regex_stats.states_popped) ++;
#line 3789
    b_if_match = (b + 1) + 0;
#line 3789
    (regex_stats.tests) ++;
#line 3789
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3789
      if ((int const   )*(line___1 + 0) >= 176) {
#line 3789
        if ((int const   )*(line___1 + 0) <= 244) {
#line 3789
          tmp___104 = 1;
        } else {
#line 3789
          tmp___104 = 0;
        }
      } else {
#line 3789
        tmp___104 = 0;
      }
    } else {
#line 3789
      tmp___104 = 0;
    }
#line 3789
    if (tmp___104) {
      {
#line 3789
      while (1) {
        while_continue___152: /* CIL Label */ ;
        {
#line 3789
        while (1) {
          while_continue___153: /* CIL Label */ ;
#line 3789
          state->highest_paren_seen = highest_paren_seen;
#line 3789
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3789
          while (1) {
            while_continue___154: /* CIL Label */ ;
#line 3789
            (regex_stats.states_pushed) ++;
#line 3789
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3789
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3789
            while (1) {
              while_continue___155: /* CIL Label */ ;
#line 3789
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3789
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3794);
                }
              }
#line 3789
              goto while_break___155;
            }
            while_break___155: /* CIL Label */ ;
            }
#line 3789
            if (regexec_flags & 2U) {
              {
#line 3789
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3789
            state->b = b_if_match;
#line 3789
            state->line = line___1;
#line 3789
            state ++;
#line 3789
            goto while_break___154;
          }
          while_break___154: /* CIL Label */ ;
          }
#line 3789
          goto while_break___153;
        }
        while_break___153: /* CIL Label */ ;
        }
#line 3789
        line___1 += 2;
#line 3789
        (regex_stats.tests) ++;
#line 3789
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3789
          if ((int const   )*(line___1 + 0) >= 176) {
#line 3789
            if ((int const   )*(line___1 + 0) <= 244) {
#line 3789
              tmp___103 = 1;
            } else {
#line 3789
              tmp___103 = 0;
            }
          } else {
#line 3789
            tmp___103 = 0;
          }
        } else {
#line 3789
          tmp___103 = 0;
        }
#line 3789
        if (! tmp___103) {
#line 3789
          goto while_break___152;
        }
      }
      while_break___152: /* CIL Label */ ;
      }
    }
#line 3789
    goto match;
    case_exp___57: /* CIL Label */ 
#line 3796
    (regex_stats.tests) ++;
#line 3796
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3796
      if ((int const   )*(line___1 + 0) < 176) {
#line 3796
        if ((int const   )*(line___1 + 0) != 10) {
#line 3796
          tmp___105 = 1;
        } else {
#line 3796
          goto _L___15;
        }
      } else
      _L___15: /* CIL Label */ 
#line 3796
      if ((int const   )*(line___1 + 0) > 244) {
#line 3796
        tmp___105 = 1;
      } else {
#line 3796
        tmp___105 = 0;
      }
    } else {
#line 3796
      tmp___105 = 0;
    }
#line 3796
    if (! tmp___105) {
#line 3796
      goto nomatch;
    }
#line 3796
    b_if_match = (b + 1) + 0;
#line 3796
    if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3796
      tmp___106 = (int const   )euc_info[*(line___1 + 0)] & 3;
    } else {
#line 3796
      tmp___106 = (int const   )1;
    }
#line 3796
    line___1 += tmp___106;
#line 3796
    goto match;
    case_exp___58: /* CIL Label */ 
#line 3796
    b_if_match = (b + 1) + 0;
#line 3796
    (regex_stats.tests) ++;
#line 3796
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3796
      if ((int const   )*(line___1 + 0) < 176) {
#line 3796
        if ((int const   )*(line___1 + 0) != 10) {
#line 3796
          tmp___108 = 1;
        } else {
#line 3796
          goto _L___16;
        }
      } else
      _L___16: /* CIL Label */ 
#line 3796
      if ((int const   )*(line___1 + 0) > 244) {
#line 3796
        tmp___108 = 1;
      } else {
#line 3796
        tmp___108 = 0;
      }
    } else {
#line 3796
      tmp___108 = 0;
    }
#line 3796
    if (tmp___108) {
      {
#line 3796
      while (1) {
        while_continue___156: /* CIL Label */ ;
#line 3796
        state->highest_paren_seen = highest_paren_seen;
#line 3796
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3796
        while (1) {
          while_continue___157: /* CIL Label */ ;
#line 3796
          (regex_stats.states_pushed) ++;
#line 3796
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3796
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3796
          while (1) {
            while_continue___158: /* CIL Label */ ;
#line 3796
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3796
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3801);
              }
            }
#line 3796
            goto while_break___158;
          }
          while_break___158: /* CIL Label */ ;
          }
#line 3796
          if (regexec_flags & 2U) {
            {
#line 3796
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3796
          state->b = b_if_match;
#line 3796
          state->line = line___1;
#line 3796
          state ++;
#line 3796
          goto while_break___157;
        }
        while_break___157: /* CIL Label */ ;
        }
#line 3796
        goto while_break___156;
      }
      while_break___156: /* CIL Label */ ;
      }
#line 3796
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3796
        tmp___107 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3796
        tmp___107 = (int const   )1;
      }
#line 3796
      line___1 += tmp___107;
    } else {
#line 3796
      (regex_stats.states_pushed) ++;
#line 3796
      (regex_stats.states_popped) ++;
    }
#line 3796
    goto match;
    case_exp___59: /* CIL Label */ 
#line 3796
    (regex_stats.tests) ++;
#line 3796
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3796
      if ((int const   )*(line___1 + 0) < 176) {
#line 3796
        if ((int const   )*(line___1 + 0) != 10) {
#line 3796
          tmp___109 = 1;
        } else {
#line 3796
          goto _L___17;
        }
      } else
      _L___17: /* CIL Label */ 
#line 3796
      if ((int const   )*(line___1 + 0) > 244) {
#line 3796
        tmp___109 = 1;
      } else {
#line 3796
        tmp___109 = 0;
      }
    } else {
#line 3796
      tmp___109 = 0;
    }
#line 3796
    if (! tmp___109) {
#line 3796
      goto nomatch;
    }
#line 3796
    b_if_match = (b + 1) + 0;
    {
#line 3796
    while (1) {
      while_continue___159: /* CIL Label */ ;
#line 3796
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3796
        tmp___110 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3796
        tmp___110 = (int const   )1;
      }
#line 3796
      line___1 += tmp___110;
#line 3796
      (regex_stats.tests) ++;
#line 3796
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3796
        if ((int const   )*(line___1 + 0) < 176) {
#line 3796
          if ((int const   )*(line___1 + 0) != 10) {
#line 3796
            tmp___111 = 1;
          } else {
#line 3796
            goto _L___18;
          }
        } else
        _L___18: /* CIL Label */ 
#line 3796
        if ((int const   )*(line___1 + 0) > 244) {
#line 3796
          tmp___111 = 1;
        } else {
#line 3796
          tmp___111 = 0;
        }
      } else {
#line 3796
        tmp___111 = 0;
      }
#line 3796
      if (! tmp___111) {
#line 3796
        goto while_break___159;
      }
      {
#line 3796
      while (1) {
        while_continue___160: /* CIL Label */ ;
#line 3796
        state->highest_paren_seen = highest_paren_seen;
#line 3796
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3796
        while (1) {
          while_continue___161: /* CIL Label */ ;
#line 3796
          (regex_stats.states_pushed) ++;
#line 3796
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3796
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3796
          while (1) {
            while_continue___162: /* CIL Label */ ;
#line 3796
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3796
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3801);
              }
            }
#line 3796
            goto while_break___162;
          }
          while_break___162: /* CIL Label */ ;
          }
#line 3796
          if (regexec_flags & 2U) {
            {
#line 3796
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3796
          state->b = b_if_match;
#line 3796
          state->line = line___1;
#line 3796
          state ++;
#line 3796
          goto while_break___161;
        }
        while_break___161: /* CIL Label */ ;
        }
#line 3796
        goto while_break___160;
      }
      while_break___160: /* CIL Label */ ;
      }
    }
    while_break___159: /* CIL Label */ ;
    }
#line 3796
    (regex_stats.states_pushed) ++;
#line 3796
    (regex_stats.states_popped) ++;
#line 3796
    goto match;
    case_exp___60: /* CIL Label */ 
#line 3796
    (regex_stats.states_pushed) ++;
#line 3796
    (regex_stats.states_popped) ++;
#line 3796
    b_if_match = (b + 1) + 0;
#line 3796
    (regex_stats.tests) ++;
#line 3796
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3796
      if ((int const   )*(line___1 + 0) < 176) {
#line 3796
        if ((int const   )*(line___1 + 0) != 10) {
#line 3796
          tmp___114 = 1;
        } else {
#line 3796
          goto _L___20;
        }
      } else
      _L___20: /* CIL Label */ 
#line 3796
      if ((int const   )*(line___1 + 0) > 244) {
#line 3796
        tmp___114 = 1;
      } else {
#line 3796
        tmp___114 = 0;
      }
    } else {
#line 3796
      tmp___114 = 0;
    }
#line 3796
    if (tmp___114) {
      {
#line 3796
      while (1) {
        while_continue___163: /* CIL Label */ ;
        {
#line 3796
        while (1) {
          while_continue___164: /* CIL Label */ ;
#line 3796
          state->highest_paren_seen = highest_paren_seen;
#line 3796
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3796
          while (1) {
            while_continue___165: /* CIL Label */ ;
#line 3796
            (regex_stats.states_pushed) ++;
#line 3796
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3796
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3796
            while (1) {
              while_continue___166: /* CIL Label */ ;
#line 3796
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3796
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3801);
                }
              }
#line 3796
              goto while_break___166;
            }
            while_break___166: /* CIL Label */ ;
            }
#line 3796
            if (regexec_flags & 2U) {
              {
#line 3796
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3796
            state->b = b_if_match;
#line 3796
            state->line = line___1;
#line 3796
            state ++;
#line 3796
            goto while_break___165;
          }
          while_break___165: /* CIL Label */ ;
          }
#line 3796
          goto while_break___164;
        }
        while_break___164: /* CIL Label */ ;
        }
#line 3796
        if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3796
          tmp___112 = (int const   )euc_info[*(line___1 + 0)] & 3;
        } else {
#line 3796
          tmp___112 = (int const   )1;
        }
#line 3796
        line___1 += tmp___112;
#line 3796
        (regex_stats.tests) ++;
#line 3796
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3796
          if ((int const   )*(line___1 + 0) < 176) {
#line 3796
            if ((int const   )*(line___1 + 0) != 10) {
#line 3796
              tmp___113 = 1;
            } else {
#line 3796
              goto _L___19;
            }
          } else
          _L___19: /* CIL Label */ 
#line 3796
          if ((int const   )*(line___1 + 0) > 244) {
#line 3796
            tmp___113 = 1;
          } else {
#line 3796
            tmp___113 = 0;
          }
        } else {
#line 3796
          tmp___113 = 0;
        }
#line 3796
        if (! tmp___113) {
#line 3796
          goto while_break___163;
        }
      }
      while_break___163: /* CIL Label */ ;
      }
    }
#line 3796
    goto match;
    case_exp___61: /* CIL Label */ 
#line 3803
    euc2_length = (unsigned short )((short )(((int const   )*((b + 2) + 0) << 8) | (int const   )*((b + 2) + 1)));
#line 3803
    euc3_length = (unsigned short )((short )(((int const   )*((b + 4) + 0) << 8) | (int const   )*((b + 4) + 1)));
#line 3803
    inverted = (int )*(b + 1);
#line 3803
    foldkana = (int )r->fold_kcase;
#line 3803
    (regex_stats.tests) ++;
#line 3803
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3803
      c = (unsigned char )*(line___1 + 0);
#line 3803
      Len___3 = (unsigned int )((int const   )euc_info[c] & 3);
#line 3803
      if (Len___3 == 1U) {
#line 3803
        if (*((b + 6) + c)) {
#line 3803
          tmp___118 = 1;
        } else {
#line 3803
          goto _L___23;
        }
      } else
      _L___23: /* CIL Label */ 
#line 3803
      if (Len___3 == 2U) {
#line 3803
        if (euc2_length) {
#line 3803
          if (foldkana) {
#line 3803
            tmp___115 = (int )case_translation[c];
          } else {
#line 3803
            tmp___115 = (int )c;
          }
          {
#line 3803
          tmp___116 = twobyte_char_in_string((unsigned char )tmp___115, (unsigned char )*(line___1 + 1),
                                             (b + 6) + 128, ((b + 6) + 128) + (int )euc2_length);
          }
#line 3803
          if (tmp___116) {
#line 3803
            tmp___118 = 1;
          } else {
#line 3803
            goto _L___22;
          }
        } else {
#line 3803
          goto _L___22;
        }
      } else
      _L___22: /* CIL Label */ 
#line 3803
      if (Len___3 == 3U) {
#line 3803
        if (euc3_length) {
          {
#line 3803
          tmp___117 = threebyte_char_in_string(c, (unsigned char )*(line___1 + 1),
                                               (unsigned char )*(line___1 + 2), ((b + 6) + 128) + (int )euc2_length,
                                               (((b + 6) + 128) + (int )euc2_length) + (int )euc3_length);
          }
#line 3803
          if (tmp___117) {
#line 3803
            tmp___118 = 1;
          } else {
#line 3803
            tmp___118 = 0;
          }
        } else {
#line 3803
          tmp___118 = 0;
        }
      } else {
#line 3803
        tmp___118 = 0;
      }
#line 3803
      if (tmp___118 == ! inverted) {
#line 3803
        tmp___119 = 1;
      } else {
#line 3803
        tmp___119 = 0;
      }
    } else {
#line 3803
      tmp___119 = 0;
    }
#line 3803
    if (! tmp___119) {
#line 3803
      goto nomatch;
    }
#line 3803
    b_if_match = (b + 1) + ((133 + (int )euc2_length) + (int )euc3_length);
#line 3803
    if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3803
      tmp___120 = (int const   )euc_info[*(line___1 + 0)] & 3;
    } else {
#line 3803
      tmp___120 = (int const   )1;
    }
#line 3803
    line___1 += tmp___120;
#line 3803
    goto match;
    case_exp___62: /* CIL Label */ 
#line 3803
    euc2_length___0 = (unsigned short )((short )(((int const   )*((b + 2) + 0) << 8) | (int const   )*((b + 2) + 1)));
#line 3803
    euc3_length___0 = (unsigned short )((short )(((int const   )*((b + 4) + 0) << 8) | (int const   )*((b + 4) + 1)));
#line 3803
    inverted___0 = (int )*(b + 1);
#line 3803
    foldkana___0 = (int )r->fold_kcase;
#line 3803
    b_if_match = (b + 1) + ((133 + (int )euc2_length___0) + (int )euc3_length___0);
#line 3803
    (regex_stats.tests) ++;
#line 3803
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3803
      c___0 = (unsigned char )*(line___1 + 0);
#line 3803
      Len___4 = (unsigned int )((int const   )euc_info[c___0] & 3);
#line 3803
      if (Len___4 == 1U) {
#line 3803
        if (*((b + 6) + c___0)) {
#line 3803
          tmp___125 = 1;
        } else {
#line 3803
          goto _L___26;
        }
      } else
      _L___26: /* CIL Label */ 
#line 3803
      if (Len___4 == 2U) {
#line 3803
        if (euc2_length___0) {
#line 3803
          if (foldkana___0) {
#line 3803
            tmp___122 = (int )case_translation[c___0];
          } else {
#line 3803
            tmp___122 = (int )c___0;
          }
          {
#line 3803
          tmp___123 = twobyte_char_in_string((unsigned char )tmp___122, (unsigned char )*(line___1 + 1),
                                             (b + 6) + 128, ((b + 6) + 128) + (int )euc2_length___0);
          }
#line 3803
          if (tmp___123) {
#line 3803
            tmp___125 = 1;
          } else {
#line 3803
            goto _L___25;
          }
        } else {
#line 3803
          goto _L___25;
        }
      } else
      _L___25: /* CIL Label */ 
#line 3803
      if (Len___4 == 3U) {
#line 3803
        if (euc3_length___0) {
          {
#line 3803
          tmp___124 = threebyte_char_in_string(c___0, (unsigned char )*(line___1 + 1),
                                               (unsigned char )*(line___1 + 2), ((b + 6) + 128) + (int )euc2_length___0,
                                               (((b + 6) + 128) + (int )euc2_length___0) + (int )euc3_length___0);
          }
#line 3803
          if (tmp___124) {
#line 3803
            tmp___125 = 1;
          } else {
#line 3803
            tmp___125 = 0;
          }
        } else {
#line 3803
          tmp___125 = 0;
        }
      } else {
#line 3803
        tmp___125 = 0;
      }
#line 3803
      if (tmp___125 == ! inverted___0) {
#line 3803
        tmp___126 = 1;
      } else {
#line 3803
        tmp___126 = 0;
      }
    } else {
#line 3803
      tmp___126 = 0;
    }
#line 3803
    if (tmp___126) {
      {
#line 3803
      while (1) {
        while_continue___167: /* CIL Label */ ;
#line 3803
        state->highest_paren_seen = highest_paren_seen;
#line 3803
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3803
        while (1) {
          while_continue___168: /* CIL Label */ ;
#line 3803
          (regex_stats.states_pushed) ++;
#line 3803
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3803
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3803
          while (1) {
            while_continue___169: /* CIL Label */ ;
#line 3803
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3803
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3828);
              }
            }
#line 3803
            goto while_break___169;
          }
          while_break___169: /* CIL Label */ ;
          }
#line 3803
          if (regexec_flags & 2U) {
            {
#line 3803
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3803
          state->b = b_if_match;
#line 3803
          state->line = line___1;
#line 3803
          state ++;
#line 3803
          goto while_break___168;
        }
        while_break___168: /* CIL Label */ ;
        }
#line 3803
        goto while_break___167;
      }
      while_break___167: /* CIL Label */ ;
      }
#line 3803
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3803
        tmp___121 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3803
        tmp___121 = (int const   )1;
      }
#line 3803
      line___1 += tmp___121;
    } else {
#line 3803
      (regex_stats.states_pushed) ++;
#line 3803
      (regex_stats.states_popped) ++;
    }
#line 3803
    goto match;
    case_exp___63: /* CIL Label */ 
#line 3803
    euc2_length___1 = (unsigned short )((short )(((int const   )*((b + 2) + 0) << 8) | (int const   )*((b + 2) + 1)));
#line 3803
    euc3_length___1 = (unsigned short )((short )(((int const   )*((b + 4) + 0) << 8) | (int const   )*((b + 4) + 1)));
#line 3803
    inverted___1 = (int )*(b + 1);
#line 3803
    foldkana___1 = (int )r->fold_kcase;
#line 3803
    (regex_stats.tests) ++;
#line 3803
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3803
      c___1 = (unsigned char )*(line___1 + 0);
#line 3803
      Len___5 = (unsigned int )((int const   )euc_info[c___1] & 3);
#line 3803
      if (Len___5 == 1U) {
#line 3803
        if (*((b + 6) + c___1)) {
#line 3803
          tmp___130 = 1;
        } else {
#line 3803
          goto _L___29;
        }
      } else
      _L___29: /* CIL Label */ 
#line 3803
      if (Len___5 == 2U) {
#line 3803
        if (euc2_length___1) {
#line 3803
          if (foldkana___1) {
#line 3803
            tmp___127 = (int )case_translation[c___1];
          } else {
#line 3803
            tmp___127 = (int )c___1;
          }
          {
#line 3803
          tmp___128 = twobyte_char_in_string((unsigned char )tmp___127, (unsigned char )*(line___1 + 1),
                                             (b + 6) + 128, ((b + 6) + 128) + (int )euc2_length___1);
          }
#line 3803
          if (tmp___128) {
#line 3803
            tmp___130 = 1;
          } else {
#line 3803
            goto _L___28;
          }
        } else {
#line 3803
          goto _L___28;
        }
      } else
      _L___28: /* CIL Label */ 
#line 3803
      if (Len___5 == 3U) {
#line 3803
        if (euc3_length___1) {
          {
#line 3803
          tmp___129 = threebyte_char_in_string(c___1, (unsigned char )*(line___1 + 1),
                                               (unsigned char )*(line___1 + 2), ((b + 6) + 128) + (int )euc2_length___1,
                                               (((b + 6) + 128) + (int )euc2_length___1) + (int )euc3_length___1);
          }
#line 3803
          if (tmp___129) {
#line 3803
            tmp___130 = 1;
          } else {
#line 3803
            tmp___130 = 0;
          }
        } else {
#line 3803
          tmp___130 = 0;
        }
      } else {
#line 3803
        tmp___130 = 0;
      }
#line 3803
      if (tmp___130 == ! inverted___1) {
#line 3803
        tmp___131 = 1;
      } else {
#line 3803
        tmp___131 = 0;
      }
    } else {
#line 3803
      tmp___131 = 0;
    }
#line 3803
    if (! tmp___131) {
#line 3803
      goto nomatch;
    }
#line 3803
    b_if_match = (b + 1) + ((133 + (int )euc2_length___1) + (int )euc3_length___1);
    {
#line 3803
    while (1) {
      while_continue___170: /* CIL Label */ ;
#line 3803
      if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3803
        tmp___132 = (int const   )euc_info[*(line___1 + 0)] & 3;
      } else {
#line 3803
        tmp___132 = (int const   )1;
      }
#line 3803
      line___1 += tmp___132;
#line 3803
      (regex_stats.tests) ++;
#line 3803
      if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3803
        c___1 = (unsigned char )*(line___1 + 0);
#line 3803
        Len___5 = (unsigned int )((int const   )euc_info[c___1] & 3);
#line 3803
        if (Len___5 == 1U) {
#line 3803
          if (*((b + 6) + c___1)) {
#line 3803
            tmp___136 = 1;
          } else {
#line 3803
            goto _L___32;
          }
        } else
        _L___32: /* CIL Label */ 
#line 3803
        if (Len___5 == 2U) {
#line 3803
          if (euc2_length___1) {
#line 3803
            if (foldkana___1) {
#line 3803
              tmp___133 = (int )case_translation[c___1];
            } else {
#line 3803
              tmp___133 = (int )c___1;
            }
            {
#line 3803
            tmp___134 = twobyte_char_in_string((unsigned char )tmp___133, (unsigned char )*(line___1 + 1),
                                               (b + 6) + 128, ((b + 6) + 128) + (int )euc2_length___1);
            }
#line 3803
            if (tmp___134) {
#line 3803
              tmp___136 = 1;
            } else {
#line 3803
              goto _L___31;
            }
          } else {
#line 3803
            goto _L___31;
          }
        } else
        _L___31: /* CIL Label */ 
#line 3803
        if (Len___5 == 3U) {
#line 3803
          if (euc3_length___1) {
            {
#line 3803
            tmp___135 = threebyte_char_in_string(c___1, (unsigned char )*(line___1 + 1),
                                                 (unsigned char )*(line___1 + 2),
                                                 ((b + 6) + 128) + (int )euc2_length___1,
                                                 (((b + 6) + 128) + (int )euc2_length___1) + (int )euc3_length___1);
            }
#line 3803
            if (tmp___135) {
#line 3803
              tmp___136 = 1;
            } else {
#line 3803
              tmp___136 = 0;
            }
          } else {
#line 3803
            tmp___136 = 0;
          }
        } else {
#line 3803
          tmp___136 = 0;
        }
#line 3803
        if (tmp___136 == ! inverted___1) {
#line 3803
          tmp___137 = 1;
        } else {
#line 3803
          tmp___137 = 0;
        }
      } else {
#line 3803
        tmp___137 = 0;
      }
#line 3803
      if (! tmp___137) {
#line 3803
        goto while_break___170;
      }
      {
#line 3803
      while (1) {
        while_continue___171: /* CIL Label */ ;
#line 3803
        state->highest_paren_seen = highest_paren_seen;
#line 3803
        state->pushed_paren_count = (unsigned char)0;
        {
#line 3803
        while (1) {
          while_continue___172: /* CIL Label */ ;
#line 3803
          (regex_stats.states_pushed) ++;
#line 3803
          if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3803
            regex_stats.max_state_depth = (int )(state - statestack_start);
          }
          {
#line 3803
          while (1) {
            while_continue___173: /* CIL Label */ ;
#line 3803
            if (! ((unsigned long )state < (unsigned long )statestack_end)) {
              {
#line 3803
              die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                  3828);
              }
            }
#line 3803
            goto while_break___173;
          }
          while_break___173: /* CIL Label */ ;
          }
#line 3803
          if (regexec_flags & 2U) {
            {
#line 3803
            outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                    line___1 - orig_line);
            }
          }
#line 3803
          state->b = b_if_match;
#line 3803
          state->line = line___1;
#line 3803
          state ++;
#line 3803
          goto while_break___172;
        }
        while_break___172: /* CIL Label */ ;
        }
#line 3803
        goto while_break___171;
      }
      while_break___171: /* CIL Label */ ;
      }
    }
    while_break___170: /* CIL Label */ ;
    }
#line 3803
    (regex_stats.states_pushed) ++;
#line 3803
    (regex_stats.states_popped) ++;
#line 3803
    goto match;
    case_exp___64: /* CIL Label */ 
#line 3803
    euc2_length___2 = (unsigned short )((short )(((int const   )*((b + 2) + 0) << 8) | (int const   )*((b + 2) + 1)));
#line 3803
    euc3_length___2 = (unsigned short )((short )(((int const   )*((b + 4) + 0) << 8) | (int const   )*((b + 4) + 1)));
#line 3803
    inverted___2 = (int )*(b + 1);
#line 3803
    foldkana___2 = (int )r->fold_kcase;
#line 3803
    (regex_stats.states_pushed) ++;
#line 3803
    (regex_stats.states_popped) ++;
#line 3803
    b_if_match = (b + 1) + ((133 + (int )euc2_length___2) + (int )euc3_length___2);
#line 3803
    (regex_stats.tests) ++;
#line 3803
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3803
      c___2 = (unsigned char )*(line___1 + 0);
#line 3803
      Len___6 = (unsigned int )((int const   )euc_info[c___2] & 3);
#line 3803
      if (Len___6 == 1U) {
#line 3803
        if (*((b + 6) + c___2)) {
#line 3803
          tmp___147 = 1;
        } else {
#line 3803
          goto _L___38;
        }
      } else
      _L___38: /* CIL Label */ 
#line 3803
      if (Len___6 == 2U) {
#line 3803
        if (euc2_length___2) {
#line 3803
          if (foldkana___2) {
#line 3803
            tmp___144 = (int )case_translation[c___2];
          } else {
#line 3803
            tmp___144 = (int )c___2;
          }
          {
#line 3803
          tmp___145 = twobyte_char_in_string((unsigned char )tmp___144, (unsigned char )*(line___1 + 1),
                                             (b + 6) + 128, ((b + 6) + 128) + (int )euc2_length___2);
          }
#line 3803
          if (tmp___145) {
#line 3803
            tmp___147 = 1;
          } else {
#line 3803
            goto _L___37;
          }
        } else {
#line 3803
          goto _L___37;
        }
      } else
      _L___37: /* CIL Label */ 
#line 3803
      if (Len___6 == 3U) {
#line 3803
        if (euc3_length___2) {
          {
#line 3803
          tmp___146 = threebyte_char_in_string(c___2, (unsigned char )*(line___1 + 1),
                                               (unsigned char )*(line___1 + 2), ((b + 6) + 128) + (int )euc2_length___2,
                                               (((b + 6) + 128) + (int )euc2_length___2) + (int )euc3_length___2);
          }
#line 3803
          if (tmp___146) {
#line 3803
            tmp___147 = 1;
          } else {
#line 3803
            tmp___147 = 0;
          }
        } else {
#line 3803
          tmp___147 = 0;
        }
      } else {
#line 3803
        tmp___147 = 0;
      }
#line 3803
      if (tmp___147 == ! inverted___2) {
#line 3803
        tmp___148 = 1;
      } else {
#line 3803
        tmp___148 = 0;
      }
    } else {
#line 3803
      tmp___148 = 0;
    }
#line 3803
    if (tmp___148) {
      {
#line 3803
      while (1) {
        while_continue___174: /* CIL Label */ ;
        {
#line 3803
        while (1) {
          while_continue___175: /* CIL Label */ ;
#line 3803
          state->highest_paren_seen = highest_paren_seen;
#line 3803
          state->pushed_paren_count = (unsigned char)0;
          {
#line 3803
          while (1) {
            while_continue___176: /* CIL Label */ ;
#line 3803
            (regex_stats.states_pushed) ++;
#line 3803
            if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3803
              regex_stats.max_state_depth = (int )(state - statestack_start);
            }
            {
#line 3803
            while (1) {
              while_continue___177: /* CIL Label */ ;
#line 3803
              if (! ((unsigned long )state < (unsigned long )statestack_end)) {
                {
#line 3803
                die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3828);
                }
              }
#line 3803
              goto while_break___177;
            }
            while_break___177: /* CIL Label */ ;
            }
#line 3803
            if (regexec_flags & 2U) {
              {
#line 3803
              outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, b_if_match - (unsigned char const   *)r->buf,
                      line___1 - orig_line);
              }
            }
#line 3803
            state->b = b_if_match;
#line 3803
            state->line = line___1;
#line 3803
            state ++;
#line 3803
            goto while_break___176;
          }
          while_break___176: /* CIL Label */ ;
          }
#line 3803
          goto while_break___175;
        }
        while_break___175: /* CIL Label */ ;
        }
#line 3803
        if ((int const   )euc_info[*(line___1 + 0)] & 3) {
#line 3803
          tmp___138 = (int const   )euc_info[*(line___1 + 0)] & 3;
        } else {
#line 3803
          tmp___138 = (int const   )1;
        }
#line 3803
        line___1 += tmp___138;
#line 3803
        (regex_stats.tests) ++;
#line 3803
        if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3803
          c___2 = (unsigned char )*(line___1 + 0);
#line 3803
          Len___6 = (unsigned int )((int const   )euc_info[c___2] & 3);
#line 3803
          if (Len___6 == 1U) {
#line 3803
            if (*((b + 6) + c___2)) {
#line 3803
              tmp___142 = 1;
            } else {
#line 3803
              goto _L___35;
            }
          } else
          _L___35: /* CIL Label */ 
#line 3803
          if (Len___6 == 2U) {
#line 3803
            if (euc2_length___2) {
#line 3803
              if (foldkana___2) {
#line 3803
                tmp___139 = (int )case_translation[c___2];
              } else {
#line 3803
                tmp___139 = (int )c___2;
              }
              {
#line 3803
              tmp___140 = twobyte_char_in_string((unsigned char )tmp___139, (unsigned char )*(line___1 + 1),
                                                 (b + 6) + 128, ((b + 6) + 128) + (int )euc2_length___2);
              }
#line 3803
              if (tmp___140) {
#line 3803
                tmp___142 = 1;
              } else {
#line 3803
                goto _L___34;
              }
            } else {
#line 3803
              goto _L___34;
            }
          } else
          _L___34: /* CIL Label */ 
#line 3803
          if (Len___6 == 3U) {
#line 3803
            if (euc3_length___2) {
              {
#line 3803
              tmp___141 = threebyte_char_in_string(c___2, (unsigned char )*(line___1 + 1),
                                                   (unsigned char )*(line___1 + 2),
                                                   ((b + 6) + 128) + (int )euc2_length___2,
                                                   (((b + 6) + 128) + (int )euc2_length___2) + (int )euc3_length___2);
              }
#line 3803
              if (tmp___141) {
#line 3803
                tmp___142 = 1;
              } else {
#line 3803
                tmp___142 = 0;
              }
            } else {
#line 3803
              tmp___142 = 0;
            }
          } else {
#line 3803
            tmp___142 = 0;
          }
#line 3803
          if (tmp___142 == ! inverted___2) {
#line 3803
            tmp___143 = 1;
          } else {
#line 3803
            tmp___143 = 0;
          }
        } else {
#line 3803
          tmp___143 = 0;
        }
#line 3803
        if (! tmp___143) {
#line 3803
          goto while_break___174;
        }
      }
      while_break___174: /* CIL Label */ ;
      }
    }
#line 3803
    goto match;
    case_exp___65: /* CIL Label */ 
#line 3832
    (regex_stats.tests) ++;
#line 3832
    if ((unsigned long )orig_line != (unsigned long )end_of_line___0) {
#line 3832
      if ((unsigned long )line___1 == (unsigned long )orig_line) {
#line 3832
        if (jregex_part_of_word[*(line___1 + 0)]) {
#line 3832
          tmp___150 = 1;
        } else {
#line 3832
          goto _L___40;
        }
      } else
      _L___40: /* CIL Label */ 
#line 3832
      if ((unsigned long )line___1 >= (unsigned long )end_of_line___0) {
#line 3832
        if (jregex_part_of_word[*(end_of_line___0 + -1)]) {
#line 3832
          tmp___150 = 1;
        } else {
#line 3832
          goto _L___39;
        }
      } else {
        _L___39: /* CIL Label */ 
        {
#line 3832
        tmp___149 = word_boundary(line___1);
        }
#line 3832
        if (tmp___149) {
#line 3832
          tmp___150 = 1;
        } else {
#line 3832
          tmp___150 = 0;
        }
      }
    } else {
#line 3832
      tmp___150 = 0;
    }
#line 3832
    if (! tmp___150) {
#line 3833
      goto nomatch;
    }
#line 3834
    b_if_match = b + 1;
#line 3835
    goto match;
    case_exp___66: /* CIL Label */ 
#line 3839
    (regex_stats.tests) ++;
#line 3839
    if (! ((unsigned long )line___1 == (unsigned long )orig_line)) {
#line 3840
      goto nomatch;
    }
#line 3841
    b_if_match = b + 1;
#line 3842
    goto match;
    case_exp___67: /* CIL Label */ 
#line 3845
    (regex_stats.tests) ++;
#line 3845
    if (! ((unsigned long )line___1 >= (unsigned long )end_of_line___0)) {
#line 3845
      if ((int const   )*(line___1 + 0) != 10) {
#line 3845
        tmp___151 = 1;
      } else {
#line 3845
        tmp___151 = 0;
      }
    } else {
#line 3845
      tmp___151 = 0;
    }
#line 3845
    if (tmp___151) {
#line 3846
      goto nomatch;
    }
#line 3847
    b_if_match = b + 1;
#line 3848
    goto match;
    case_exp___68: /* CIL Label */ 
    {
#line 3851
    while (1) {
      while_continue___178: /* CIL Label */ ;
#line 3851
      state->highest_paren_seen = highest_paren_seen;
#line 3851
      state->pushed_paren_count = (unsigned char)0;
      {
#line 3851
      while (1) {
        while_continue___179: /* CIL Label */ ;
#line 3851
        (regex_stats.states_pushed) ++;
#line 3851
        if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3851
          regex_stats.max_state_depth = (int )(state - statestack_start);
        }
        {
#line 3851
        while (1) {
          while_continue___180: /* CIL Label */ ;
#line 3851
          if (! ((unsigned long )state < (unsigned long )statestack_end)) {
            {
#line 3851
            die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                3851);
            }
          }
#line 3851
          goto while_break___180;
        }
        while_break___180: /* CIL Label */ ;
        }
#line 3851
        if (regexec_flags & 2U) {
          {
#line 3851
          outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, (b + (int )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)))) - (unsigned char const   *)r->buf,
                  line___1 - orig_line);
          }
        }
#line 3851
        state->b = b + (int )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)));
#line 3851
        state->line = line___1;
#line 3851
        state ++;
#line 3851
        goto while_break___179;
      }
      while_break___179: /* CIL Label */ ;
      }
#line 3851
      goto while_break___178;
    }
    while_break___178: /* CIL Label */ ;
    }
#line 3852
    b += 3;
#line 3853
    goto __Cont;
    case_exp___69: /* CIL Label */ 
#line 3856
    b += (int )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)));
#line 3857
    goto __Cont;
    case_exp___70: /* CIL Label */ 
    {
#line 3860
    while (1) {
      while_continue___181: /* CIL Label */ ;
#line 3860
      state->highest_paren_seen = highest_paren_seen;
#line 3860
      state->pushed_paren_count = (unsigned char)0;
      {
#line 3860
      while (1) {
        while_continue___182: /* CIL Label */ ;
#line 3860
        (regex_stats.states_pushed) ++;
#line 3860
        if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3860
          regex_stats.max_state_depth = (int )(state - statestack_start);
        }
        {
#line 3860
        while (1) {
          while_continue___183: /* CIL Label */ ;
#line 3860
          if (! ((unsigned long )state < (unsigned long )statestack_end)) {
            {
#line 3860
            die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                3860);
            }
          }
#line 3860
          goto while_break___183;
        }
        while_break___183: /* CIL Label */ ;
        }
#line 3860
        if (regexec_flags & 2U) {
          {
#line 3860
          outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, ((b + 1) + 2) - (unsigned char const   *)r->buf,
                  line___1 - orig_line);
          }
        }
#line 3860
        state->b = (b + 1) + 2;
#line 3860
        state->line = line___1;
#line 3860
        state ++;
#line 3860
        goto while_break___182;
      }
      while_break___182: /* CIL Label */ ;
      }
#line 3860
      goto while_break___181;
    }
    while_break___181: /* CIL Label */ ;
    }
#line 3861
    b += (int )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)));
#line 3862
    goto __Cont;
    case_exp___71: /* CIL Label */ 
#line 3868
    level = (unsigned int )*(b + 1);
    {
#line 3870
    while (1) {
      while_continue___184: /* CIL Label */ ;
#line 3870
      if (! (level < regexec_paren_info_size)) {
        {
#line 3870
        die("\nassert(level < regexec_paren_info_size) failed \"%s\" line %d.\n",
            "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 3870);
        }
      }
#line 3870
      goto while_break___184;
    }
    while_break___184: /* CIL Label */ ;
    }
#line 3871
    if (level > (unsigned int )highest_paren_seen) {
#line 3874
      goto nomatch;
    } else
#line 3871
    if ((unsigned long )(regexec_paren_info + level)->match_start == (unsigned long )((unsigned char const   *)0)) {
#line 3874
      goto nomatch;
    } else
#line 3871
    if ((unsigned long )(regexec_paren_info + level)->match_end == (unsigned long )((unsigned char const   *)0)) {
#line 3874
      goto nomatch;
    }
#line 3875
    Len___7 = (unsigned int )((regexec_paren_info + level)->match_end - (regexec_paren_info + level)->match_start);
#line 3877
    if (Len___7 != 0U) {
#line 3879
      A = line___1;
#line 3880
      A_end = A + Len___7;
#line 3881
      B = (regexec_paren_info + level)->match_start;
#line 3884
      if ((unsigned long )A_end > (unsigned long )end_of_line___0) {
#line 3885
        goto nomatch;
      }
#line 3887
      if (regexec_flags & 2U) {
        {
#line 3887
        outputf("content len is %d, strings are [%.*s] [%.*s]\n", Len___7, (int )Len___7,
                A, (int )Len___7, B);
        }
      }
      {
#line 3891
      while (1) {
        while_continue___185: /* CIL Label */ ;
#line 3893
        if (((int const   )*A & -128) == 0) {
#line 3895
          if (r->fold_acase == 0U) {
#line 3895
            goto _L___41;
          } else {
            {
#line 3895
            tmp___161 = __ctype_b_loc();
            }
#line 3895
            if ((int const   )*(*tmp___161 + (int )*A) & 1024) {
#line 3900
              if (! (((int const   )*B & -128) == 0)) {
#line 3901
                goto nomatch;
              } else {
                {
#line 3900
                tmp___152 = __ctype_b_loc();
                }
#line 3900
                if (! ((int const   )*(*tmp___152 + (int )*B) & 1024)) {
#line 3901
                  goto nomatch;
                }
              }
              {
#line 3902
              tmp___156 = __ctype_b_loc();
              }
#line 3902
              if ((int const   )*(*tmp___156 + (int )*B) & 512) {
#line 3902
                tmp___155 = (int const   )*B;
              } else {
                {
#line 3902
                tmp___154 = tolower((int )*B);
#line 3902
                tmp___155 = (int const   )tmp___154;
                }
              }
              {
#line 3902
              tmp___160 = __ctype_b_loc();
              }
#line 3902
              if ((int const   )*(*tmp___160 + (int )*A) & 512) {
#line 3902
                tmp___159 = (int const   )*A;
              } else {
                {
#line 3902
                tmp___158 = tolower((int )*A);
#line 3902
                tmp___159 = (int const   )tmp___158;
                }
              }
#line 3902
              if (tmp___155 != tmp___159) {
#line 3904
                goto nomatch;
              }
            } else
            _L___41: /* CIL Label */ 
#line 3897
            if ((int const   )*A != (int const   )*B) {
#line 3898
              goto nomatch;
            }
          }
#line 3906
          A ++;
#line 3907
          B ++;
        } else {
#line 3909
          if (r->fold_kcase == 0U) {
#line 3909
            goto _L___43;
          } else
#line 3909
          if ((int const   )*(A + 0) != 164) {
#line 3909
            if ((int const   )*(A + 0) != 165) {
              _L___43: /* CIL Label */ 
#line 3913
              if ((int const   )*(A + 0) != (int const   )*(B + 0)) {
#line 3914
                goto nomatch;
              } else
#line 3913
              if ((int const   )*(A + 1) != (int const   )*(B + 1)) {
#line 3914
                goto nomatch;
              }
            } else {
#line 3909
              goto _L___44;
            }
          } else
          _L___44: /* CIL Label */ 
#line 3916
          if ((int const   )*(B + 0) != 164) {
#line 3916
            if ((int const   )*(B + 0) != 165) {
#line 3918
              goto nomatch;
            } else {
#line 3916
              goto _L___42;
            }
          } else
          _L___42: /* CIL Label */ 
#line 3916
          if ((int const   )*(A + 1) != (int const   )*(B + 1)) {
#line 3918
            goto nomatch;
          }
#line 3920
          A += 2;
#line 3921
          B += 2;
        }
#line 3891
        if (! ((unsigned long )A < (unsigned long )A_end)) {
#line 3891
          goto while_break___185;
        }
      }
      while_break___185: /* CIL Label */ ;
      }
#line 3924
      line___1 += Len___7;
    }
#line 3926
    b_if_match = (b + 1) + 1;
#line 3927
    goto match;
    case_exp___72: /* CIL Label */ 
#line 3932
    level___0 = (unsigned int )*(b + 1);
#line 3933
    (regex_stats.parens_entered) ++;
#line 3934
    if (level___0 < regexec_paren_info_size) {
#line 3936
      (regexec_paren_info + level___0)->match_start = line___1;
#line 3937
      (regexec_paren_info + level___0)->match_end = (unsigned char const   *)0;
#line 3938
      if ((int )level___0 > (int )highest_paren_seen) {
#line 3939
        highest_paren_seen = (short )level___0;
      }
#line 3940
      if (regexec_flags & 2U) {
        {
#line 3940
        outputf("highest_paren_seen now %d\n", (int )highest_paren_seen);
#line 3940
        report_new_pareninfo("open", level___0);
        }
      }
    }
#line 3946
    b_if_match = (b + 1) + 1;
#line 3947
    goto match;
    case_exp___73: /* CIL Label */ 
#line 3952
    level___1 = (unsigned int )*(b + 3);
    {
#line 3954
    while (1) {
      while_continue___186: /* CIL Label */ ;
#line 3954
      state->highest_paren_seen = highest_paren_seen;
#line 3954
      state->pushed_paren_count = (unsigned char)0;
      {
#line 3954
      while (1) {
        while_continue___187: /* CIL Label */ ;
#line 3954
        (regex_stats.states_pushed) ++;
#line 3954
        if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3954
          regex_stats.max_state_depth = (int )(state - statestack_start);
        }
        {
#line 3954
        while (1) {
          while_continue___188: /* CIL Label */ ;
#line 3954
          if (! ((unsigned long )state < (unsigned long )statestack_end)) {
            {
#line 3954
            die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                3954);
            }
          }
#line 3954
          goto while_break___188;
        }
        while_break___188: /* CIL Label */ ;
        }
#line 3954
        if (regexec_flags & 2U) {
          {
#line 3954
          outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, (b + (int )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)))) - (unsigned char const   *)r->buf,
                  line___1 - orig_line);
          }
        }
#line 3954
        state->b = b + (int )((short )(((int const   )*((b + 1) + 0) << 8) | (int const   )*((b + 1) + 1)));
#line 3954
        state->line = line___1;
#line 3954
        state ++;
#line 3954
        goto while_break___187;
      }
      while_break___187: /* CIL Label */ ;
      }
#line 3954
      goto while_break___186;
    }
    while_break___186: /* CIL Label */ ;
    }
#line 3956
    (regex_stats.parens_entered) ++;
#line 3957
    if (level___1 < regexec_paren_info_size) {
#line 3959
      (regexec_paren_info + level___1)->match_start = line___1;
#line 3960
      (regexec_paren_info + level___1)->match_end = (unsigned char const   *)0;
#line 3961
      if ((int )level___1 > (int )highest_paren_seen) {
#line 3962
        highest_paren_seen = (short )level___1;
      }
#line 3963
      if (regexec_flags & 2U) {
        {
#line 3963
        outputf("highest_paren_seen now %d\n", (int )highest_paren_seen);
#line 3963
        report_new_pareninfo("open2", level___1);
        }
      }
    }
#line 3969
    b_if_match = b + 4;
#line 3970
    goto match;
    case_exp___74: /* CIL Label */ 
#line 3975
    count = (unsigned int )*(b + 1);
#line 3976
    start = (unsigned int )*(b + 2);
#line 3978
    (regex_stats.parens_saved) ++;
#line 3979
    if (start < regexec_paren_info_size) {
#line 3981
      (regexec_paren_info + start)->match_end = line___1;
#line 3982
      if (start > (unsigned int )highest_paren_seen) {
#line 3983
        highest_paren_seen = (short )start;
      }
#line 3985
      if (regexec_flags & 2U) {
        {
#line 3985
        outputf("highest_paren_seen now %d\n", (int )highest_paren_seen);
#line 3985
        report_new_pareninfo("set1", start);
        }
      }
    }
    {
#line 3992
    while (1) {
      while_continue___189: /* CIL Label */ ;
#line 3992
      _count = count;
#line 3992
      _start = start;
#line 3992
      state->highest_paren_seen = highest_paren_seen;
#line 3992
      if (_start >= regexec_paren_info_size) {
#line 3992
        state->pushed_paren_count = (unsigned char)0;
      } else {
#line 3992
        _end_ = _start + _count;
#line 3992
        if (_end_ > regexec_paren_info_size) {
#line 3992
          _count -= _end_ - regexec_paren_info_size;
        }
#line 3992
        state->pushed_paren_start = (unsigned char )_start;
#line 3992
        state->pushed_paren_count = (unsigned char )_count;
        {
#line 3992
        while (1) {
          while_continue___190: /* CIL Label */ ;
          {
#line 3992
          while (1) {
            while_continue___191: /* CIL Label */ ;
#line 3992
            tmp___162 = start;
#line 3992
            start ++;
#line 3992
            _num_ = tmp___162;
#line 3992
            (regex_stats.parens_pushed) ++;
#line 3992
            if (regexec_flags & 2U) {
              {
#line 3992
              outputf("push_paren_state #%ld (%d) %lx\n", parenstate - parenstate_base,
                      _num_, (unsigned long )(regexec_paren_info + _num_)->match_start);
#line 3992
              report_new_pareninfo("push", _num_);
              }
            }
            {
#line 3992
            while (1) {
              while_continue___192: /* CIL Label */ ;
#line 3992
              if (! r->max_lpc_l) {
                {
#line 3992
                die("\nassert(r->max_lpc_l) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                    3993);
                }
              }
#line 3992
              goto while_break___192;
            }
            while_break___192: /* CIL Label */ ;
            }
            {
#line 3992
            while (1) {
              while_continue___193: /* CIL Label */ ;
#line 3992
              if (! ((unsigned long )parenstate < (unsigned long )parenstate_end)) {
                {
#line 3992
                die("\nassert(parenstate < parenstate_end) failed \"%s\" line %d.\n",
                    "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 3993);
                }
              }
#line 3992
              goto while_break___193;
            }
            while_break___193: /* CIL Label */ ;
            }
#line 3992
            *(parenstate + 0) = (regexec_paren_info + _num_)->match_start;
#line 3992
            *(parenstate + 1) = (regexec_paren_info + _num_)->match_end;
#line 3992
            parenstate += 2;
#line 3992
            if ((unsigned long )parenstate > (unsigned long )max_parenstate) {
#line 3992
              max_parenstate = parenstate;
            }
#line 3992
            (regexec_paren_info + _num_)->match_end = (unsigned char const   *)0;
#line 3992
            goto while_break___191;
          }
          while_break___191: /* CIL Label */ ;
          }
#line 3992
          _count --;
#line 3992
          if (! _count) {
#line 3992
            goto while_break___190;
          }
        }
        while_break___190: /* CIL Label */ ;
        }
      }
      {
#line 3992
      while (1) {
        while_continue___194: /* CIL Label */ ;
#line 3992
        (regex_stats.states_pushed) ++;
#line 3992
        if (state - statestack_start > (long )regex_stats.max_state_depth) {
#line 3992
          regex_stats.max_state_depth = (int )(state - statestack_start);
        }
        {
#line 3992
        while (1) {
          while_continue___195: /* CIL Label */ ;
#line 3992
          if (! ((unsigned long )state < (unsigned long )statestack_end)) {
            {
#line 3992
            die("\nassert(state < statestack_end) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                3993);
            }
          }
#line 3992
          goto while_break___195;
        }
        while_break___195: /* CIL Label */ ;
        }
#line 3992
        if (regexec_flags & 2U) {
          {
#line 3992
          outputf("state #%ld now <%ld,%ld>\n", state - statestack_start, (((b + 1) + 2) + 2) - (unsigned char const   *)r->buf,
                  line___1 - orig_line);
          }
        }
#line 3992
        state->b = ((b + 1) + 2) + 2;
#line 3992
        state->line = line___1;
#line 3992
        state ++;
#line 3992
        goto while_break___194;
      }
      while_break___194: /* CIL Label */ ;
      }
#line 3992
      goto while_break___189;
    }
    while_break___189: /* CIL Label */ ;
    }
#line 3995
    b += (int )((short )(((int const   )*((((b + 1) + 1) + 1) + 0) << 8) | (int const   )*((((b + 1) + 1) + 1) + 1)));
#line 3997
    goto __Cont;
    case_exp___75: /* CIL Label */ 
#line 4002
    level___2 = (unsigned int )*(b + 1);
#line 4003
    (regex_stats.parens_saved) ++;
#line 4004
    if (level___2 < regexec_paren_info_size) {
#line 4006
      (regexec_paren_info + level___2)->match_end = line___1;
#line 4007
      if (level___2 > (unsigned int )highest_paren_seen) {
#line 4008
        highest_paren_seen = (short )level___2;
      }
#line 4009
      if (regexec_flags & 2U) {
        {
#line 4009
        outputf("highest_paren_seen now %d\n", (int )highest_paren_seen);
#line 4009
        report_new_pareninfo("set2", level___2);
        }
      }
    }
#line 4015
    b_if_match = (b + 1) + 1;
#line 4016
    goto match;
    switch_break: /* CIL Label */ ;
    }
    {
#line 4021
    while (1) {
      while_continue___196: /* CIL Label */ ;
      {
#line 4021
      die("\nassert(0) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
          4021);
      }
#line 4021
      goto while_break___196;
    }
    while_break___196: /* CIL Label */ ;
    }
    match: 
#line 4024
    (regex_stats.matches) ++;
#line 4025
    if (regexec_flags & 2U) {
      {
#line 4025
      output("<match>\n");
      }
    }
#line 4027
    b = b_if_match;
#line 4028
    goto __Cont;
    nomatch: 
#line 4031
    (regex_stats.failures) ++;
#line 4036
    if (state - statestack_start > 0L) {
#line 4039
      old_highest_paren_seen = (int )highest_paren_seen;
      {
#line 4042
      while (1) {
        while_continue___197: /* CIL Label */ ;
        {
#line 4042
        while (1) {
          while_continue___198: /* CIL Label */ ;
#line 4042
          state --;
#line 4042
          b = state->b;
#line 4042
          line___1 = state->line;
#line 4042
          (regex_stats.states_popped) ++;
#line 4042
          goto while_break___198;
        }
        while_break___198: /* CIL Label */ ;
        }
#line 4042
        highest_paren_seen = state->highest_paren_seen;
#line 4042
        if (state->pushed_paren_count) {
#line 4042
          _count___0 = (int )state->pushed_paren_count;
#line 4042
          _end = (unsigned int )(((int )state->pushed_paren_start + _count___0) - 1);
#line 4042
          if (_end >= regexec_paren_info_size) {
#line 4042
            _count___0 = (int )((unsigned int )_count___0 - (_end - regexec_paren_info_size));
#line 4042
            _end = regexec_paren_info_size;
          }
#line 4042
          if (_count___0 > 0) {
            {
#line 4042
            while (1) {
              while_continue___199: /* CIL Label */ ;
#line 4042
              _num____0 = _end;
#line 4042
              (regex_stats.parens_popped) ++;
#line 4042
              parenstate -= 2;
              {
#line 4042
              while (1) {
                while_continue___200: /* CIL Label */ ;
#line 4042
                if (! r->max_lpc_l) {
                  {
#line 4042
                  die("\nassert(r->max_lpc_l) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                      4042);
                  }
                }
#line 4042
                goto while_break___200;
              }
              while_break___200: /* CIL Label */ ;
              }
              {
#line 4042
              while (1) {
                while_continue___201: /* CIL Label */ ;
#line 4042
                if (! ((unsigned long )parenstate >= (unsigned long )parenstate_base)) {
                  {
#line 4042
                  die("\nassert(parenstate >= parenstate_base) failed \"%s\" line %d.\n",
                      "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 4042);
                  }
                }
#line 4042
                goto while_break___201;
              }
              while_break___201: /* CIL Label */ ;
              }
#line 4042
              (regexec_paren_info + _num____0)->match_start = *(parenstate + 0);
#line 4042
              (regexec_paren_info + _num____0)->match_end = *(parenstate + 1);
#line 4042
              if (regexec_flags & 2U) {
                {
#line 4042
                outputf("pop_paren_state #%ld (%d) %lx\n", parenstate - parenstate_base,
                        _num____0, (unsigned long )*(parenstate + 0));
#line 4042
                report_new_pareninfo("pop", _num____0);
                }
              }
#line 4042
              goto while_break___199;
            }
            while_break___199: /* CIL Label */ ;
            }
            {
#line 4042
            while (1) {
              while_continue___202: /* CIL Label */ ;
#line 4042
              _count___0 --;
#line 4042
              if (! (_count___0 > 0)) {
#line 4042
                goto while_break___202;
              }
              {
#line 4042
              while (1) {
                while_continue___203: /* CIL Label */ ;
#line 4042
                _end --;
#line 4042
                _num____1 = _end;
#line 4042
                (regex_stats.parens_popped) ++;
#line 4042
                parenstate -= 2;
                {
#line 4042
                while (1) {
                  while_continue___204: /* CIL Label */ ;
#line 4042
                  if (! r->max_lpc_l) {
                    {
#line 4042
                    die("\nassert(r->max_lpc_l) failed \"%s\" line %d.\n", "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c",
                        4042);
                    }
                  }
#line 4042
                  goto while_break___204;
                }
                while_break___204: /* CIL Label */ ;
                }
                {
#line 4042
                while (1) {
                  while_continue___205: /* CIL Label */ ;
#line 4042
                  if (! ((unsigned long )parenstate >= (unsigned long )parenstate_base)) {
                    {
#line 4042
                    die("\nassert(parenstate >= parenstate_base) failed \"%s\" line %d.\n",
                        "/home/wheatley/newnew/temp/lookup-1.08b/lib/jregex.c", 4042);
                    }
                  }
#line 4042
                  goto while_break___205;
                }
                while_break___205: /* CIL Label */ ;
                }
#line 4042
                (regexec_paren_info + _num____1)->match_start = *(parenstate + 0);
#line 4042
                (regexec_paren_info + _num____1)->match_end = *(parenstate + 1);
#line 4042
                if (regexec_flags & 2U) {
                  {
#line 4042
                  outputf("pop_paren_state #%ld (%d) %lx\n", parenstate - parenstate_base,
                          _num____1, (unsigned long )*(parenstate + 0));
#line 4042
                  report_new_pareninfo("pop", _num____1);
                  }
                }
#line 4042
                goto while_break___203;
              }
              while_break___203: /* CIL Label */ ;
              }
            }
            while_break___202: /* CIL Label */ ;
            }
          }
        }
#line 4042
        goto while_break___197;
      }
      while_break___197: /* CIL Label */ ;
      }
#line 4045
      if (old_highest_paren_seen != (int )highest_paren_seen) {
        {
#line 4047
        while (1) {
          while_continue___206: /* CIL Label */ ;
#line 4047
          if (! (old_highest_paren_seen > (int )highest_paren_seen)) {
#line 4047
            goto while_break___206;
          }
#line 4048
          if (regexec_flags & 2U) {
            {
#line 4048
            report_new_pareninfo("flushing", (unsigned int )old_highest_paren_seen);
            }
          }
#line 4051
          tmp___163 = old_highest_paren_seen;
#line 4051
          old_highest_paren_seen --;
#line 4051
          (regexec_paren_info + tmp___163)->match_start = (unsigned char const   *)0;
        }
        while_break___206: /* CIL Label */ ;
        }
      }
#line 4060
      if (special_debug) {
        {
#line 4061
        outputf("popping state #%ld (total %ld): [%.*s|%s] regex %d.\n", state - statestack_start,
                regex_stats.states_popped, line___1 - orig_line, orig_line, line___1,
                b - (unsigned char const   *)r->buf);
        }
      } else
#line 4072
      if (regexec_flags & 2U) {
        {
#line 4073
        outputf("++abort, popping state #%ld (total %ld popped)++: <%ld, %ld, p%d>\n",
                state - statestack_start, regex_stats.states_popped, b - (unsigned char const   *)r->buf,
                line___1 - orig_line, (int )highest_paren_seen);
        }
      }
    } else {
#line 4096
      if (llm) {
#line 4096
        if ((unsigned long )longest_match_so_far != (unsigned long )((unsigned char const   *)0)) {
#line 4097
          return (1U);
        }
      }
#line 4101
      if ((int const   )euc_info[*(line_head + 0)] & 3) {
#line 4101
        tmp___164 = (int const   )euc_info[*(line_head + 0)] & 3;
      } else {
#line 4101
        tmp___164 = (int const   )1;
      }
#line 4101
      line_head += tmp___164;
#line 4105
      if ((unsigned long )line_head > (unsigned long )latest_start) {
#line 4106
        if (regexec_flags & 2U) {
          {
#line 4106
          output("*** regex failed ***\n");
          }
        }
#line 4108
        return (0U);
      }
#line 4110
      (regex_stats.states_pushed) ++;
#line 4111
      (regex_stats.states_popped) ++;
#line 4113
      line___1 = line_head;
#line 4114
      b = (unsigned char const   *)r->buf;
#line 4116
      if (regexec_flags & 2U) {
        {
#line 4116
        outputf("++abort, moving along line: line=%lx, latest=%lx, end=%lx++\n", (long )line___1,
                (long )latest_start, (long )end_of_line___0);
        }
      }
#line 4121
      highest_paren_seen = (short)-1;
#line 4125
      regexec_match_start = line___1;
    }
#line 4128
    goto __Cont;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
