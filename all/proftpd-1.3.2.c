/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.2.4/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.2.4/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 80 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 150 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 20 "/usr/include/asm/types.h"
typedef unsigned int __u32;
#line 33 "/usr/include/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 38 "/usr/include/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
struct _cap_struct;
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
typedef struct _cap_struct *cap_t;
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/libcap.h"
struct _cap_struct {
   struct __user_cap_header_struct head ;
   struct __user_cap_data_struct set ;
};
#line 82 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/libcap.h"
struct __anonstruct___cap_s_26 {
   unsigned int _blk[(sizeof(struct __user_cap_data_struct ) / 3UL) / sizeof(unsigned int )] ;
};
#line 82 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/libcap.h"
typedef struct __anonstruct___cap_s_26 __cap_s;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 33 "/usr/include/linux/capability.h"
typedef struct __user_cap_header_struct *cap_user_header_t;
#line 38 "/usr/include/linux/capability.h"
typedef struct __user_cap_data_struct *cap_user_data_t;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
typedef int cap_value_t;
#line 48
enum __anonenum_cap_flag_t_24 {
    CAP_EFFECTIVE = 0,
    CAP_PERMITTED = 1,
    CAP_INHERITABLE = 2
} ;
#line 48 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
typedef enum __anonenum_cap_flag_t_24 cap_flag_t;
#line 57
enum __anonenum_cap_flag_value_t_25 {
    CAP_CLEAR = 0,
    CAP_SET = 1
} ;
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
typedef enum __anonenum_cap_flag_value_t_25 cap_flag_value_t;
#line 22 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_extint.c"
struct cap_ext_struct {
   unsigned char magic[4] ;
   unsigned char length_of_capset ;
   unsigned char bytes[sizeof(struct __user_cap_data_struct ) / 3UL][3] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 88 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 88
struct sockaddr_in6;
#line 93 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 137 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 138 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 194 "/usr/include/netinet/in.h"
union __anonunion_in6_u_61 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 194 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_61 in6_u ;
};
#line 217 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 231 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 374 "../include/conf.h"
union __anonunion_na_addr_66 {
   struct sockaddr_in v4 ;
   struct sockaddr_in6 v6 ;
};
#line 374 "../include/conf.h"
struct __anonstruct_pr_netaddr_t_65 {
   int na_family ;
   char na_dnsstr[256] ;
   int na_have_dnsstr ;
   char na_ipstr[46] ;
   int na_have_ipstr ;
   union __anonunion_na_addr_66 na_addr ;
};
#line 374 "../include/conf.h"
typedef struct __anonstruct_pr_netaddr_t_65 pr_netaddr_t;
#line 36 "../include/pool.h"
struct pool;
#line 36 "../include/pool.h"
typedef struct pool pool;
#line 52 "../include/table.h"
struct table_rec;
#line 52 "../include/table.h"
typedef struct table_rec pr_table_t;
#line 63 "../include/proftpd.h"
struct conn_struc;
#line 64
struct cmd_struc;
#line 65
struct config_struc;
#line 35 "../include/sets.h"
struct XAsetmember;
#line 35 "../include/sets.h"
typedef struct XAsetmember xasetmember_t;
#line 36
struct XAset;
#line 36 "../include/sets.h"
typedef struct XAset xaset_t;
#line 40 "../include/sets.h"
struct XAsetmember {
   xasetmember_t *next ;
   xasetmember_t *prev ;
};
#line 44 "../include/sets.h"
struct XAset {
   xasetmember_t *xas_list ;
   pool *pool ;
   int (*xas_compare)(xasetmember_t *v1 , xasetmember_t *v2 ) ;
};
#line 40 "../include/dirtree.h"
typedef struct config_struc config_rec;
#line 44 "../include/dirtree.h"
struct server_struc {
   struct server_struc *next ;
   struct server_struc *prev ;
   pool *pool ;
   xaset_t *set ;
   char const   *ServerName ;
   char const   *ServerAddress ;
   char const   *ServerFQDN ;
   unsigned int ServerPort ;
   int tcp_mss_len ;
   int tcp_rcvbuf_len ;
   unsigned char tcp_rcvbuf_override ;
   int tcp_sndbuf_len ;
   unsigned char tcp_sndbuf_override ;
   char *ServerAdmin ;
   pr_netaddr_t *addr ;
   struct conn_struc *listen ;
   xaset_t *conf ;
   int config_type ;
   unsigned int sid ;
};
#line 44 "../include/dirtree.h"
typedef struct server_struc server_rec;
#line 96 "../include/dirtree.h"
struct cmd_struc {
   pool *pool ;
   server_rec *server ;
   config_rec *config ;
   pool *tmp_pool ;
   int argc ;
   char *arg ;
   char **argv ;
   char *group ;
   int class ;
   int stash_index ;
   pr_table_t *notes ;
};
#line 96 "../include/dirtree.h"
typedef struct cmd_struc cmd_rec;
#line 114 "../include/dirtree.h"
struct config_struc {
   struct config_struc *next ;
   struct config_struc *prev ;
   int config_type ;
   unsigned int config_id ;
   pool *pool ;
   xaset_t *set ;
   char *name ;
   int argc ;
   void **argv ;
   long flags ;
   server_rec *server ;
   config_rec *parent ;
   xaset_t *subset ;
};
#line 73 "../include/netio.h"
struct __anonstruct_pr_buffer_t_73 {
   char *buf ;
   unsigned long buflen ;
   char *current ;
   int remaining ;
};
#line 73 "../include/netio.h"
typedef struct __anonstruct_pr_buffer_t_73 pr_buffer_t;
#line 89 "../include/netio.h"
struct __anonstruct_pr_netio_stream_t_74 {
   pool *strm_pool ;
   int strm_type ;
   int strm_fd ;
   int strm_mode ;
   unsigned int strm_interval ;
   unsigned long volatile   strm_flags ;
   pr_buffer_t *strm_buf ;
   void *strm_data ;
   int strm_errno ;
};
#line 89 "../include/netio.h"
typedef struct __anonstruct_pr_netio_stream_t_74 pr_netio_stream_t;
#line 35 "../include/modules.h"
struct module_struc;
#line 35 "../include/modules.h"
typedef struct module_struc module;
#line 36
struct modret_struc;
#line 36 "../include/modules.h"
typedef struct modret_struc modret_t;
#line 38 "../include/modules.h"
struct modret_struc {
   module *mr_handler_module ;
   int mr_error ;
   char *mr_numeric ;
   char *mr_message ;
   void *data ;
};
#line 70 "../include/modules.h"
struct __anonstruct_conftable_76 {
   char *directive ;
   modret_t *(*handler)(cmd_rec * ) ;
   module *m ;
};
#line 70 "../include/modules.h"
typedef struct __anonstruct_conftable_76 conftable;
#line 103 "../include/modules.h"
struct __anonstruct_cmdtable_77 {
   unsigned char cmd_type ;
   char *command ;
   char *group ;
   modret_t *(*handler)(cmd_rec * ) ;
   unsigned char requires_auth ;
   unsigned char interrupt_xfer ;
   int class ;
   module *m ;
};
#line 103 "../include/modules.h"
typedef struct __anonstruct_cmdtable_77 cmdtable;
#line 123 "../include/modules.h"
struct __anonstruct_authtable_78 {
   int auth_flags ;
   char *name ;
   modret_t *(*handler)(cmd_rec * ) ;
   module *m ;
};
#line 123 "../include/modules.h"
typedef struct __anonstruct_authtable_78 authtable;
#line 133 "../include/modules.h"
struct module_struc {
   module *next ;
   module *prev ;
   int api_version ;
   char *name ;
   conftable *conftable ;
   cmdtable *cmdtable ;
   authtable *authtable ;
   int (*init)(void) ;
   int (*sess_init)(void) ;
   char *module_version ;
   void *handle ;
   int priority ;
};
#line 102 "../include/inet.h"
struct conn_struc {
   struct conn_struc *next ;
   pool *pool ;
   int mode ;
   int listen_fd ;
   int rcvbuf ;
   int sndbuf ;
   int xerrno ;
   int rfd ;
   int wfd ;
   pr_netio_stream_t *instrm ;
   pr_netio_stream_t *outstrm ;
   pr_netaddr_t *remote_addr ;
   int remote_port ;
   char const   *remote_name ;
   pr_netaddr_t *local_addr ;
   int local_port ;
};
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 61 "../include/pool.h"
struct __anonstruct_array_header_65 {
   pool *pool ;
   int elt_size ;
   int nelts ;
   int nalloc ;
   void *elts ;
};
#line 61 "../include/pool.h"
typedef struct __anonstruct_array_header_65 array_header;
#line 34 "../include/class.h"
struct pr_class_t {
   pool *cls_pool ;
   char *cls_name ;
   unsigned int cls_satisfy ;
   array_header *cls_acls ;
   struct pr_class_t *cls_next ;
};
#line 34 "../include/class.h"
typedef struct pr_class_t pr_class_t;
#line 67 "../include/proftpd.h"
struct __anonstruct_xfer_70 {
   struct pool *p ;
   int xfer_type ;
   int direction ;
   char *filename ;
   char *path ;
   char *path_hidden ;
   unsigned int bufsize ;
   unsigned int buflen ;
   struct timeval start_time ;
   off_t file_size ;
   off_t total_bytes ;
   char *bufstart ;
   char *buf ;
};
#line 67 "../include/proftpd.h"
struct __anonstruct_session_t_69 {
   pool *pool ;
   int volatile   sf_flags ;
   int volatile   sp_flags ;
   pr_netaddr_t data_addr ;
   unsigned short data_port ;
   char const   *auth_mech ;
   char const   *rfc2228_mech ;
   char cwd[4096] ;
   char vwd[4096] ;
   struct config_struc *dir_config ;
   pid_t pid ;
   int disable_id_switching ;
   uid_t uid ;
   uid_t ouid ;
   gid_t gid ;
   array_header *gids ;
   array_header *groups ;
   uid_t fsuid ;
   gid_t fsgid ;
   char *user ;
   char *group ;
   uid_t login_uid ;
   gid_t login_gid ;
   pr_table_t *notes ;
   pr_class_t *class ;
   char *proc_prefix ;
   int wtmp_log ;
   struct conn_struc *c ;
   struct conn_struc *d ;
   int hide_password ;
   char *chroot_path ;
   struct config_struc *anon_config ;
   char *anon_user ;
   char *curr_cmd ;
   int curr_phase ;
   off_t restart_pos ;
   struct __anonstruct_xfer_70 xfer ;
   off_t total_bytes_in ;
   off_t total_bytes_out ;
   off_t total_bytes ;
   unsigned int total_files_in ;
   unsigned int total_files_out ;
   unsigned int total_files_xfer ;
};
#line 67 "../include/proftpd.h"
typedef struct __anonstruct_session_t_69 session_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t___0;
#line 67 "../include/proftpd.h"
struct __anonstruct_xfer_72 {
   struct pool *p ;
   int xfer_type ;
   int direction ;
   char *filename ;
   char *path ;
   char *path_hidden ;
   unsigned int bufsize ;
   unsigned int buflen ;
   struct timeval start_time ;
   off_t___0 file_size ;
   off_t___0 total_bytes ;
   char *bufstart ;
   char *buf ;
};
#line 67 "../include/proftpd.h"
struct __anonstruct_session_t_71 {
   pool *pool ;
   int volatile   sf_flags ;
   int volatile   sp_flags ;
   pr_netaddr_t data_addr ;
   unsigned short data_port ;
   char const   *auth_mech ;
   char const   *rfc2228_mech ;
   char cwd[4096] ;
   char vwd[4096] ;
   struct config_struc *dir_config ;
   pid_t pid ;
   int disable_id_switching ;
   uid_t uid ;
   uid_t ouid ;
   gid_t gid ;
   array_header *gids ;
   array_header *groups ;
   uid_t fsuid ;
   gid_t fsgid ;
   char *user ;
   char *group ;
   uid_t login_uid ;
   gid_t login_gid ;
   pr_table_t *notes ;
   pr_class_t *class ;
   char *proc_prefix ;
   int wtmp_log ;
   struct conn_struc *c ;
   struct conn_struc *d ;
   int hide_password ;
   char *chroot_path ;
   struct config_struc *anon_config ;
   char *anon_user ;
   char *curr_cmd ;
   int curr_phase ;
   off_t___0 restart_pos ;
   struct __anonstruct_xfer_72 xfer ;
   off_t___0 total_bytes_in ;
   off_t___0 total_bytes_out ;
   off_t___0 total_bytes ;
   unsigned int total_files_in ;
   unsigned int total_files_out ;
   unsigned int total_files_xfer ;
};
#line 67 "../include/proftpd.h"
typedef struct __anonstruct_session_t_71 session_t___0;
#line 102 "../include/inet.h"
typedef struct conn_struc conn_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 170 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 343 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 407 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 410 "/usr/include/regex.h"
typedef int regoff_t;
#line 434 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_69 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 434 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_69 regmatch_t;
#line 48 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
struct mlinfo {
   pool *pool ;
   struct stat st ;
   struct tm *tm ;
   char const   *type ;
   char const   *perm ;
   char const   *path ;
};
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_8 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_9 {
   __fd_mask fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_9 fd_set;
#line 158 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 32 "../include/display.h"
struct fh_rec;
#line 90 "../include/fsio.h"
struct fs_rec;
#line 90 "../include/fsio.h"
typedef struct fs_rec pr_fs_t;
#line 91 "../include/fsio.h"
typedef struct fh_rec pr_fh_t;
#line 93 "../include/fsio.h"
struct fs_rec {
   pr_fs_t *fs_next ;
   pr_fs_t *fs_prev ;
   char *fs_name ;
   char *fs_path ;
   void *fs_data ;
   pool *fs_pool ;
   int (*stat)(pr_fs_t * , char const   * , struct stat * ) ;
   int (*fstat)(pr_fh_t * , int  , struct stat * ) ;
   int (*lstat)(pr_fs_t * , char const   * , struct stat * ) ;
   int (*rename)(pr_fs_t * , char const   * , char const   * ) ;
   int (*unlink)(pr_fs_t * , char const   * ) ;
   int (*open)(pr_fh_t * , char const   * , int  ) ;
   int (*creat)(pr_fh_t * , char const   * , mode_t  ) ;
   int (*close)(pr_fh_t * , int  ) ;
   int (*read)(pr_fh_t * , int  , char * , size_t  ) ;
   int (*write)(pr_fh_t * , int  , char const   * , size_t  ) ;
   off_t___0 (*lseek)(pr_fh_t * , int  , off_t___0  , int  ) ;
   int (*link)(pr_fs_t * , char const   * , char const   * ) ;
   int (*readlink)(pr_fs_t * , char const   * , char * , size_t  ) ;
   int (*symlink)(pr_fs_t * , char const   * , char const   * ) ;
   int (*ftruncate)(pr_fh_t * , int  , off_t___0  ) ;
   int (*truncate)(pr_fs_t * , char const   * , off_t___0  ) ;
   int (*chmod)(pr_fs_t * , char const   * , mode_t  ) ;
   int (*fchmod)(pr_fh_t * , int  , mode_t  ) ;
   int (*chown)(pr_fs_t * , char const   * , uid_t  , gid_t  ) ;
   int (*fchown)(pr_fh_t * , int  , uid_t  , gid_t  ) ;
   int (*access)(pr_fs_t * , char const   * , int  , uid_t  , gid_t  , array_header * ) ;
   int (*faccess)(pr_fh_t * , int  , uid_t  , gid_t  , array_header * ) ;
   int (*utimes)(pr_fs_t * , char const   * , struct timeval * ) ;
   int (*futimes)(pr_fh_t * , int  , struct timeval * ) ;
   int (*chdir)(pr_fs_t * , char const   * ) ;
   int (*chroot)(pr_fs_t * , char const   * ) ;
   void *(*opendir)(pr_fs_t * , char const   * ) ;
   int (*closedir)(pr_fs_t * , void * ) ;
   struct dirent *(*readdir)(pr_fs_t * , void * ) ;
   int (*mkdir)(pr_fs_t * , char const   * , mode_t  ) ;
   int (*rmdir)(pr_fs_t * , char const   * ) ;
   int allow_xdev_link ;
   int allow_xdev_rename ;
};
#line 174 "../include/fsio.h"
struct fh_rec {
   pool *fh_pool ;
   int fh_fd ;
   char *fh_path ;
   void *fh_data ;
   pr_fs_t *fh_fs ;
   pr_buffer_t *fh_buf ;
};
#line 78 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
struct delay_rec {
   unsigned int d_sid ;
   char d_addr[80] ;
   unsigned int d_port ;
   unsigned int d_nvals ;
   long d_vals[256] ;
};
#line 86 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
struct __anonstruct_delay_tab_84 {
   char const   *dt_path ;
   int dt_fd ;
   off_t___0 dt_size ;
   void *dt_data ;
};
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
struct __anonstruct__help_84 {
   char *cmd ;
   char *syntax ;
   int implemented ;
};
#line 34 "../include/response.h"
struct resp_struc {
   struct resp_struc *next ;
   char *num ;
   char *msg ;
};
#line 34 "../include/response.h"
typedef struct resp_struc pr_response_t;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
struct logformat_struc;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
typedef struct logformat_struc logformat_t;
#line 42
struct logfile_struc;
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
typedef struct logfile_struc logfile_t;
#line 44 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
struct logformat_struc {
   logformat_t *next ;
   logformat_t *prev ;
   char *lf_nickname ;
   unsigned char *lf_format ;
};
#line 51 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
struct logfile_struc {
   logfile_t *next ;
   logfile_t *prev ;
   char *lf_filename ;
   int lf_fd ;
   int lf_syslog_level ;
   logformat_t *lf_format ;
   int lf_classes ;
   config_rec *lf_conf ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 100 "../include/glibc-glob.h"
struct __anonstruct_glob_t_82 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , struct stat * ) ;
   int (*gl_stat)(char const   * , struct stat * ) ;
};
#line 100 "../include/glibc-glob.h"
typedef struct __anonstruct_glob_t_82 glob_t;
#line 70 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
struct list_limit_rec {
   unsigned int curr ;
   unsigned int max ;
   unsigned char logged ;
};
#line 565 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
struct filename {
   struct filename *down ;
   struct filename *right ;
   char *line ;
   int top ;
};
#line 572 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
struct sort_filename {
   time_t mtime ;
   off_t___0 size ;
   char *name ;
   char *suffix ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 60 "../include/scoreboard.h"
struct __anonstruct_pr_scoreboard_entry_t_81 {
   pid_t sce_pid ;
   uid_t sce_uid ;
   gid_t sce_gid ;
   char sce_user[32] ;
   int sce_server_port ;
   char sce_server_addr[80] ;
   char sce_server_label[32] ;
   char sce_client_addr[46] ;
   char sce_client_name[80] ;
   char sce_class[32] ;
   char sce_cwd[80] ;
   char sce_cmd[5] ;
   char sce_cmd_arg[80] ;
   time_t sce_begin_idle ;
   time_t sce_begin_session ;
   off_t___0 sce_xfer_size ;
   off_t___0 sce_xfer_done ;
   off_t___0 sce_xfer_len ;
   unsigned long sce_xfer_elapsed ;
};
#line 60 "../include/scoreboard.h"
typedef struct __anonstruct_pr_scoreboard_entry_t_81 pr_scoreboard_entry_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
union __anonunion_authfile_id_t_84 {
   uid_t uid ;
   gid_t gid ;
};
#line 49 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
typedef union __anonunion_authfile_id_t_84 authfile_id_t;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
struct file_rec {
   char *af_path ;
   FILE *af_file ;
   unsigned char af_restricted_ids ;
   authfile_id_t af_min_id ;
   authfile_id_t af_max_id ;
   unsigned char af_restricted_names ;
   char *af_name_filter ;
   regex_t *af_name_regex ;
   unsigned char af_name_regex_inverted ;
   unsigned char af_restricted_homes ;
   char *af_home_filter ;
   regex_t *af_home_regex ;
   unsigned char af_home_regex_inverted ;
};
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
typedef struct file_rec authfile_file_t;
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 148 "/usr/include/bits/types.h"
typedef unsigned int __id_t;
#line 105 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 217 "/usr/include/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 41 "/usr/include/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 55 "../include/data.h"
typedef ssize_t pr_sendfile_t;
#line 147 "/usr/include/bits/types.h"
typedef __u_quad_t __rlim64_t;
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 129 "/usr/include/bits/resource.h"
typedef __rlim64_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 32 "../include/netacl.h"
struct pr_netacl_t;
#line 32 "../include/netacl.h"
typedef struct pr_netacl_t pr_netacl_t;
#line 173 "../include/modules.h"
enum __anonenum_pr_stash_type_t_79 {
    PR_SYM_CONF = 1,
    PR_SYM_CMD = 2,
    PR_SYM_AUTH = 3,
    PR_SYM_HOOK = 4
} ;
#line 173 "../include/modules.h"
typedef enum __anonenum_pr_stash_type_t_79 pr_stash_type_t;
#line 1571 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
struct __anonstruct_factable_84 {
   char *name ;
   int facility ;
};
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
struct var {
   int v_type ;
   char const   *v_desc ;
   void *v_val ;
   void *v_data ;
   size_t v_datasz ;
};
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
struct event_handler {
   struct event_handler *next ;
   struct event_handler *prev ;
   module *module ;
   void (*cb)(void const   * , void * ) ;
   void *user_data ;
};
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
struct event_list {
   struct event_list *next ;
   pool *pool ;
   char const   *event ;
   struct event_handler *handlers ;
};
#line 174 "/usr/include/bits/types.h"
typedef __u_quad_t __fsblkcnt64_t;
#line 178 "/usr/include/bits/types.h"
typedef __u_quad_t __fsfilcnt64_t;
#line 52 "/usr/include/sys/types.h"
typedef __ino64_t ino_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 29 "/usr/include/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   int __f_unused ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
struct fsopendir;
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
typedef struct fsopendir fsopendir_t;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
struct fsopendir {
   fsopendir_t *next ;
   fsopendir_t *prev ;
   pool *pool ;
   pr_fs_t *fsdir ;
   DIR *dir ;
};
#line 321 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
struct __anonstruct_fs_statcache_t_85 {
   char sc_path[4097] ;
   struct stat sc_stat ;
   int sc_errno ;
   int sc_retval ;
};
#line 321 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
typedef struct __anonstruct_fs_statcache_t_85 fs_statcache_t;
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct auth_module_elt {
   struct auth_module_elt *prev ;
   struct auth_module_elt *next ;
   char const   *name ;
};
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
union __anonunion_ptr_84 {
   conftable *sym_conf ;
   cmdtable *sym_cmd ;
   authtable *sym_auth ;
   cmdtable *sym_hook ;
   void *sym_generic ;
};
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
struct stash {
   struct stash *next ;
   struct stash *prev ;
   pool *sym_pool ;
   char const   *sym_name ;
   pr_stash_type_t sym_type ;
   module *sym_module ;
   union __anonunion_ptr_84 ptr ;
};
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_33 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_36 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_37 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_31 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_32 _kill ;
   struct __anonstruct__timer_33 _timer ;
   struct __anonstruct__rt_34 _rt ;
   struct __anonstruct__sigchld_35 _sigchld ;
   struct __anonstruct__sigfault_36 _sigfault ;
   struct __anonstruct__sigpoll_37 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_31 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 125 "../include/netio.h"
struct __anonstruct_pr_netio_t_75 {
   pool *pool ;
   void (*abort)(pr_netio_stream_t * ) ;
   int (*close)(pr_netio_stream_t * ) ;
   pr_netio_stream_t *(*open)(pr_netio_stream_t * , int  , int  ) ;
   int (*poll)(pr_netio_stream_t * ) ;
   int (*postopen)(pr_netio_stream_t * ) ;
   int (*read)(pr_netio_stream_t * , char * , size_t  ) ;
   pr_netio_stream_t *(*reopen)(pr_netio_stream_t * , int  , int  ) ;
   int (*shutdown)(pr_netio_stream_t * , int  ) ;
   int (*write)(pr_netio_stream_t * , char * , size_t  ) ;
};
#line 125 "../include/netio.h"
typedef struct __anonstruct_pr_netio_t_75 pr_netio_t;
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/help.c"
struct help_rec {
   char const   *cmd ;
   char const   *syntax ;
   int impl ;
};
#line 41 "../include/scoreboard.h"
struct __anonstruct_pr_scoreboard_header_t_80 {
   unsigned long sch_magic ;
   unsigned long sch_version ;
   pid_t sch_pid ;
   time_t sch_uptime ;
};
#line 41 "../include/scoreboard.h"
typedef struct __anonstruct_pr_scoreboard_header_t_80 pr_scoreboard_header_t;
#line 34 "../include/netacl.h"
enum __anonenum_pr_netacl_type_t_70 {
    PR_NETACL_TYPE_ALL = 0,
    PR_NETACL_TYPE_NONE = 1,
    PR_NETACL_TYPE_IPMASK = 2,
    PR_NETACL_TYPE_IPMATCH = 3,
    PR_NETACL_TYPE_DNSMATCH = 4,
    PR_NETACL_TYPE_IPGLOB = 5,
    PR_NETACL_TYPE_DNSGLOB = 6
} ;
#line 34 "../include/netacl.h"
typedef enum __anonenum_pr_netacl_type_t_70 pr_netacl_type_t;
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
struct pr_netacl_t {
   pr_netacl_type_t type ;
   char const   *aclstr ;
   char *pattern ;
   int negated ;
   pr_netaddr_t *addr ;
   unsigned int masklen ;
};
#line 39 "../include/bindings.h"
struct ipbind_rec {
   struct ipbind_rec *ib_next ;
   pr_netaddr_t *ib_addr ;
   unsigned int ib_port ;
   server_rec *ib_server ;
   conn_t *ib_listener ;
   array_header *ib_namebinds ;
   unsigned char ib_isdefault ;
   unsigned char ib_islocalhost ;
   unsigned char ib_isactive ;
};
#line 39 "../include/bindings.h"
typedef struct ipbind_rec pr_ipbind_t;
#line 75 "../include/bindings.h"
struct namebind_rec {
   server_rec *nb_server ;
   conn_t *nb_listener ;
   char const   *nb_name ;
   unsigned char nb_isactive ;
};
#line 75 "../include/bindings.h"
typedef struct namebind_rec pr_namebind_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
struct config_src {
   struct config_src *cs_next ;
   pool *cs_pool ;
   pr_fh_t *cs_fh ;
   unsigned int cs_lineno ;
};
#line 32 "../include/child.h"
struct child {
   struct child *next ;
   struct child *prev ;
   pool *ch_pool ;
   pid_t ch_pid ;
   time_t ch_when ;
   int ch_pipefd ;
   unsigned char ch_dead ;
};
#line 32 "../include/child.h"
typedef struct child pr_child_t;
#line 251 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 126 "/usr/include/stdint.h"
typedef int intptr_t;
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
struct sched_obj {
   struct sched_obj *next ;
   struct sched_obj *prev ;
   pool *pool ;
   void (*f)(void * , void * , void * , void * ) ;
   int loops ;
   void *a1 ;
   void *a2 ;
   void *a3 ;
   void *a4 ;
};
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
typedef struct sched_obj sched_t;
#line 34 "../include/table.h"
struct tab_key {
   struct tab_key *next ;
   void *key_data ;
   size_t key_datasz ;
   unsigned int hash ;
   unsigned int nents ;
};
#line 34 "../include/table.h"
typedef struct tab_key pr_table_key_t;
#line 43 "../include/table.h"
struct tab_entry {
   struct tab_entry *next ;
   struct tab_entry *prev ;
   unsigned int idx ;
   pr_table_key_t *key ;
   void *value_data ;
   size_t value_datasz ;
};
#line 43 "../include/table.h"
typedef struct tab_entry pr_table_entry_t;
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
struct table_rec {
   pool *pool ;
   unsigned long flags ;
   pr_table_entry_t **chains ;
   unsigned int nchains ;
   unsigned int nents ;
   pr_table_entry_t *free_ents ;
   pr_table_key_t *free_keys ;
   pr_table_entry_t *tab_iter_ent ;
   pr_table_entry_t *val_iter_ent ;
   pr_table_entry_t *cache_ent ;
   int (*keycmp)(void const   * , size_t  , void const   * , size_t  ) ;
   unsigned int (*keyhash)(void const   * , size_t  ) ;
   void (*entinsert)(pr_table_entry_t ** , pr_table_entry_t * ) ;
   void (*entremove)(pr_table_entry_t ** , pr_table_entry_t * ) ;
};
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
union align {
   char *cp ;
   void (*f)(void) ;
   long l ;
   FILE *fp ;
   double d ;
};
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
struct __anonstruct_h_84 {
   char *endp ;
   union block_hdr *next ;
   char *first_avail ;
};
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
union block_hdr {
   union align a ;
   struct __anonstruct_h_84 h ;
};
#line 190
struct cleanup;
#line 196 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
struct pool {
   union block_hdr *first ;
   union block_hdr *last ;
   struct cleanup *cleanups ;
   struct pool *sub_pools ;
   struct pool *sub_next ;
   struct pool *sub_prev ;
   struct pool *parent ;
   char *free_first_avail ;
   char const   *tag ;
};
#line 693 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
struct cleanup {
   void *data ;
   void (*plain_cleanup_cb)(void * ) ;
   void (*child_cleanup_cb)(void * ) ;
   struct cleanup *next ;
};
#line 693 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
typedef struct cleanup cleanup_t;
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
struct timer {
   struct timer *next ;
   struct timer *prev ;
   long count ;
   long interval ;
   int timerno ;
   module *mod ;
   int (*callback)(unsigned long p1 , unsigned long p2 , unsigned long p3 , void *data ) ;
   char remove ;
   char const   *desc ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 2649 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
struct option_help {
   char const   *long_opt ;
   char const   *short_opt ;
   char const   *desc ;
};
#line 85 "../include/libsupp.h"
void pr_os_already_has_snprintf_and_vsnprintf(void) ;
#line 456 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/vsnprintf.c"
void pr_os_already_has_snprintf_and_vsnprintf(void) 
{ 


  {
#line 459
  return;
}
}
#line 91 "../include/libsupp.h"
void pr_os_already_has_strsep(void) ;
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/strsep.c"
void pr_os_already_has_strsep(void) 
{ 


  {
#line 63
  return;
}
}
#line 50 "../include/libsupp.h"
char *sstrncpy(char *dest , char const   *src , size_t n ) ;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/sstrncpy.c"
char *sstrncpy(char *dest , char const   *src , size_t n ) 
{ 
  register char *d ;
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 42
  d = dest;
#line 44
  if (! dest) {
#line 45
    return ((char *)((void *)0));
  }
#line 47
  if (n == 0U) {
#line 48
    return ((char *)((void *)0));
  }
#line 50
  if (src) {
#line 50
    if (*src) {
      {
#line 51
      while (1) {
        while_continue: /* CIL Label */ ;
#line 51
        if (*src) {
#line 51
          if (! (n > 1U)) {
#line 51
            goto while_break;
          }
        } else {
#line 51
          goto while_break;
        }
#line 52
        tmp = d;
#line 52
        d ++;
#line 52
        tmp___0 = src;
#line 52
        src ++;
#line 52
        *tmp = (char )*tmp___0;
#line 51
        n --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 55
  *d = (char )'\000';
#line 57
  return (dest);
}
}
#line 545 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 99 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 167
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 116
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 49 "../include/libsupp.h"
int pr_fnmatch(char const   *pattern , char const   *string , int flags ) ;
#line 186 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr_fnmatch.c"
static char *__strchrnul(char const   *s , int c ) ;
#line 188 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr_fnmatch.c"
static char *__strchrnul(char const   *s , int c ) 
{ 
  char *result ;
  char *tmp ;

  {
  {
#line 193
  tmp = strchr(s, c);
#line 193
  result = tmp;
  }
#line 194
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 195
    result = strchr(s, '\000');
    }
  }
#line 196
  return (result);
}
}
#line 30 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr_fnmatch_loop.c"
static int internal_fnmatch(char const   *pattern , char const   *string , int no_leading_period ,
                            int flags ) ;
#line 189 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr_fnmatch_loop.c"
static int posixly_correct  ;
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr_fnmatch_loop.c"
static int internal_fnmatch(char const   *pattern , char const   *string , int no_leading_period ,
                            int flags ) 
{ 
  register char const   *p ;
  register char const   *n ;
  register unsigned char c ;
  int is_range ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int result ;
  int tmp___12 ;
  char const   *slashp ;
  char *tmp___13 ;
  char *tmp___14 ;
  char const   *endp ;
  int tmp___15 ;
  char *tmp___16 ;
  int flags2 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int flags2___0 ;
  int tmp___21 ;
  int tmp___23 ;
  unsigned short const   **tmp___24 ;
  int tmp___26 ;
  int tmp___27 ;
  unsigned short const   **tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  register int not ;
  char cold ;
  char *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  unsigned char fn ;
  int tmp___36 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  int tmp___40 ;
  unsigned short const   **tmp___41 ;
  char str[7] ;
  size_t c1 ;
  char const   *startp ;
  size_t tmp___42 ;
  int tmp___43 ;
  unsigned short const   **tmp___44 ;
  int tmp___45 ;
  unsigned short const   **tmp___46 ;
  int tmp___47 ;
  unsigned short const   **tmp___48 ;
  int tmp___49 ;
  unsigned short const   **tmp___50 ;
  int tmp___51 ;
  unsigned short const   **tmp___52 ;
  int tmp___53 ;
  unsigned short const   **tmp___54 ;
  int tmp___55 ;
  unsigned short const   **tmp___56 ;
  int tmp___57 ;
  unsigned short const   **tmp___58 ;
  int tmp___59 ;
  unsigned short const   **tmp___60 ;
  int tmp___61 ;
  unsigned short const   **tmp___62 ;
  int tmp___63 ;
  unsigned short const   **tmp___64 ;
  int tmp___65 ;
  unsigned short const   **tmp___66 ;
  char const   *tmp___67 ;
  int tmp___69 ;
  unsigned short const   **tmp___70 ;
  int tmp___71 ;
  char const   *tmp___72 ;
  unsigned char cend ;
  char const   *tmp___73 ;
  char const   *tmp___74 ;
  char const   *tmp___75 ;
  char const   *tmp___76 ;
  int c1___0 ;
  char const   *startp___0 ;
  char const   *tmp___77 ;
  char const   *tmp___78 ;
  char const   *tmp___79 ;
  int tmp___81 ;
  int tmp___82 ;
  unsigned short const   **tmp___83 ;
  char const   *tmp___84 ;
  void *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;

  {
#line 41
  p = pattern;
#line 41
  n = string;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    tmp___84 = p;
#line 55
    p ++;
#line 55
    c = (unsigned char )*tmp___84;
#line 55
    if (! ((int )c != 0)) {
#line 55
      goto while_break;
    }
#line 57
    if (flags & (1 << 4)) {
      {
#line 57
      tmp___1 = __ctype_b_loc();
      }
#line 57
      if ((int const   )*(*tmp___1 + (int )c) & 256) {
        {
#line 57
        tmp___0 = tolower((int )c);
#line 57
        c = (unsigned char )tmp___0;
        }
      } else {
#line 57
        c = c;
      }
    } else {
#line 57
      c = c;
    }
    {
#line 61
    if ((int )c == 63) {
#line 61
      goto case_63;
    }
#line 72
    if ((int )c == 92) {
#line 72
      goto case_92;
    }
#line 85
    if ((int )c == 42) {
#line 85
      goto case_42;
    }
#line 187
    if ((int )c == 91) {
#line 187
      goto case_91;
    }
#line 958
    goto switch_default;
    case_63: /* CIL Label */ 
#line 62
    if ((int const   )*n == 0) {
#line 63
      return (1);
    } else
#line 64
    if ((int const   )*n == 47) {
#line 64
      if (flags & 1) {
#line 65
        return (1);
      } else {
#line 64
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 66
    if ((int const   )*n == 46) {
#line 66
      if (no_leading_period) {
#line 66
        if ((unsigned long )n == (unsigned long )string) {
#line 69
          return (1);
        } else
#line 66
        if ((int const   )*(n + -1) == 47) {
#line 66
          if (flags & 1) {
#line 69
            return (1);
          }
        }
      }
    }
#line 70
    goto switch_break;
    case_92: /* CIL Label */ 
#line 73
    if (! (flags & (1 << 1))) {
#line 75
      tmp___2 = p;
#line 75
      p ++;
#line 75
      c = (unsigned char )*tmp___2;
#line 76
      if ((int )c == 0) {
#line 78
        return (1);
      }
#line 79
      if (flags & (1 << 4)) {
        {
#line 79
        tmp___5 = __ctype_b_loc();
        }
#line 79
        if ((int const   )*(*tmp___5 + (int )c) & 256) {
          {
#line 79
          tmp___4 = tolower((int )c);
#line 79
          c = (unsigned char )tmp___4;
          }
        } else {
#line 79
          c = c;
        }
      } else {
#line 79
        c = c;
      }
    }
#line 81
    if (flags & (1 << 4)) {
      {
#line 81
      tmp___9 = __ctype_b_loc();
      }
#line 81
      if ((int const   )*(*tmp___9 + (int )((unsigned char )*n)) & 256) {
        {
#line 81
        tmp___7 = tolower((int )((unsigned char )*n));
#line 81
        tmp___8 = tmp___7;
        }
      } else {
#line 81
        tmp___8 = (int )((unsigned char )*n);
      }
    } else {
#line 81
      tmp___8 = (int )((unsigned char )*n);
    }
#line 81
    if (tmp___8 != (int )c) {
#line 82
      return (1);
    }
#line 83
    goto switch_break;
    case_42: /* CIL Label */ 
#line 86
    if ((int const   )*n == 46) {
#line 86
      if (no_leading_period) {
#line 86
        if ((unsigned long )n == (unsigned long )string) {
#line 89
          return (1);
        } else
#line 86
        if ((int const   )*(n + -1) == 47) {
#line 86
          if (flags & 1) {
#line 89
            return (1);
          }
        }
      }
    }
#line 91
    tmp___10 = p;
#line 91
    p ++;
#line 91
    c = (unsigned char )*tmp___10;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (! ((int )c == 63)) {
#line 91
        if (! ((int )c == 42)) {
#line 91
          goto while_break___0;
        }
      }
#line 93
      if ((int const   )*n == 47) {
#line 93
        if (flags & 1) {
#line 95
          return (1);
        } else {
#line 93
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 96
      if ((int )c == 63) {
#line 99
        if ((int const   )*n == 0) {
#line 101
          return (1);
        } else {
#line 106
          n ++;
        }
      }
#line 91
      tmp___11 = p;
#line 91
      p ++;
#line 91
      c = (unsigned char )*tmp___11;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    if ((int )c == 0) {
#line 117
      if ((flags & 1) == 0) {
#line 117
        tmp___12 = 0;
      } else {
#line 117
        tmp___12 = 1;
      }
#line 117
      result = tmp___12;
#line 119
      if (flags & 1) {
        {
#line 121
        tmp___13 = strchr(n, '/');
#line 121
        slashp = (char const   *)tmp___13;
        }
#line 123
        if (flags & (1 << 3)) {
#line 125
          if ((unsigned long )slashp != (unsigned long )((void *)0)) {
            {
#line 125
            tmp___14 = strchr(slashp + 1, '/');
            }
#line 125
            if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 127
              result = 0;
            }
          }
        } else
#line 131
        if ((unsigned long )slashp == (unsigned long )((void *)0)) {
#line 132
          result = 0;
        }
      }
#line 136
      return (result);
    } else {
#line 142
      if (flags & 1) {
#line 142
        tmp___15 = '/';
      } else {
#line 142
        tmp___15 = '\000';
      }
      {
#line 142
      tmp___16 = __strchrnul(n, tmp___15);
#line 142
      endp = (char const   *)tmp___16;
      }
#line 144
      if ((int )c == 91) {
#line 146
        if (flags & 1) {
#line 146
          tmp___17 = flags;
        } else {
#line 146
          tmp___17 = flags & ~ (1 << 2);
        }
#line 146
        flags2 = tmp___17;
#line 149
        p --;
        {
#line 149
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 149
          if (! ((unsigned long )n < (unsigned long )endp)) {
#line 149
            goto while_break___1;
          }
#line 150
          if (no_leading_period) {
#line 150
            if ((unsigned long )n == (unsigned long )string) {
#line 150
              tmp___18 = 1;
            } else
#line 150
            if ((int const   )*(n + -1) == 47) {
#line 150
              if (flags & 1) {
#line 150
                tmp___18 = 1;
              } else {
#line 150
                tmp___18 = 0;
              }
            } else {
#line 150
              tmp___18 = 0;
            }
          } else {
#line 150
            tmp___18 = 0;
          }
          {
#line 150
          tmp___19 = internal_fnmatch(p, n, tmp___18, flags2);
          }
#line 150
          if (tmp___19 == 0) {
#line 155
            return (0);
          }
#line 149
          n ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 157
      if ((int )c == 47) {
#line 157
        if (flags & 1) {
          {
#line 159
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 159
            if ((int const   )*n != 0) {
#line 159
              if (! ((int const   )*n != 47)) {
#line 159
                goto while_break___2;
              }
            } else {
#line 159
              goto while_break___2;
            }
#line 160
            n ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 161
          if ((int const   )*n == 47) {
            {
#line 161
            tmp___20 = internal_fnmatch(p, n + 1, flags & (1 << 2), flags);
            }
#line 161
            if (tmp___20 == 0) {
#line 163
              return (0);
            }
          }
        } else {
#line 157
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 167
        if (flags & 1) {
#line 167
          tmp___21 = flags;
        } else {
#line 167
          tmp___21 = flags & ~ (1 << 2);
        }
#line 167
        flags2___0 = tmp___21;
#line 170
        if ((int )c == 92) {
#line 170
          if (! (flags & (1 << 1))) {
#line 171
            c = (unsigned char )*p;
          }
        }
#line 172
        if (flags & (1 << 4)) {
          {
#line 172
          tmp___24 = __ctype_b_loc();
          }
#line 172
          if ((int const   )*(*tmp___24 + (int )c) & 256) {
            {
#line 172
            tmp___23 = tolower((int )c);
#line 172
            c = (unsigned char )tmp___23;
            }
          } else {
#line 172
            c = c;
          }
        } else {
#line 172
          c = c;
        }
#line 173
        p --;
        {
#line 173
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 173
          if (! ((unsigned long )n < (unsigned long )endp)) {
#line 173
            goto while_break___3;
          }
#line 174
          if (flags & (1 << 4)) {
            {
#line 174
            tmp___28 = __ctype_b_loc();
            }
#line 174
            if ((int const   )*(*tmp___28 + (int )((unsigned char )*n)) & 256) {
              {
#line 174
              tmp___26 = tolower((int )((unsigned char )*n));
#line 174
              tmp___27 = tmp___26;
              }
            } else {
#line 174
              tmp___27 = (int )((unsigned char )*n);
            }
          } else {
#line 174
            tmp___27 = (int )((unsigned char )*n);
          }
#line 174
          if (tmp___27 == (int )c) {
#line 174
            if (no_leading_period) {
#line 174
              if ((unsigned long )n == (unsigned long )string) {
#line 174
                tmp___29 = 1;
              } else
#line 174
              if ((int const   )*(n + -1) == 47) {
#line 174
                if (flags & 1) {
#line 174
                  tmp___29 = 1;
                } else {
#line 174
                  tmp___29 = 0;
                }
              } else {
#line 174
                tmp___29 = 0;
              }
            } else {
#line 174
              tmp___29 = 0;
            }
            {
#line 174
            tmp___30 = internal_fnmatch(p, n, tmp___29, flags2___0);
            }
#line 174
            if (tmp___30 == 0) {
#line 180
              return (0);
            }
          }
#line 173
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 185
    return (1);
    case_91: /* CIL Label */ 
#line 194
    if (posixly_correct == 0) {
      {
#line 195
      tmp___32 = getenv("POSIXLY_CORRECT");
      }
#line 195
      if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
#line 195
        posixly_correct = 1;
      } else {
#line 195
        posixly_correct = -1;
      }
    }
#line 197
    if ((int const   )*n == 0) {
#line 198
      return (1);
    }
#line 200
    if ((int const   )*n == 46) {
#line 200
      if (no_leading_period) {
#line 200
        if ((unsigned long )n == (unsigned long )string) {
#line 203
          return (1);
        } else
#line 200
        if ((int const   )*(n + -1) == 47) {
#line 200
          if (flags & 1) {
#line 203
            return (1);
          }
        }
      }
    }
#line 205
    if ((int const   )*n == 47) {
#line 205
      if (flags & 1) {
#line 207
        return (1);
      }
    }
#line 209
    if ((int const   )*p == 33) {
#line 209
      tmp___33 = 1;
    } else
#line 209
    if (posixly_correct < 0) {
#line 209
      if ((int const   )*p == 94) {
#line 209
        tmp___33 = 1;
      } else {
#line 209
        tmp___33 = 0;
      }
    } else {
#line 209
      tmp___33 = 0;
    }
#line 209
    not = tmp___33;
#line 210
    if (not) {
#line 211
      p ++;
    }
#line 213
    tmp___34 = p;
#line 213
    p ++;
#line 213
    c = (unsigned char )*tmp___34;
    {
#line 214
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 216
      if (flags & (1 << 4)) {
        {
#line 216
        tmp___38 = __ctype_b_loc();
        }
#line 216
        if ((int const   )*(*tmp___38 + (int )((unsigned char )*n)) & 256) {
          {
#line 216
          tmp___36 = tolower((int )((unsigned char )*n));
#line 216
          tmp___37 = tmp___36;
          }
        } else {
#line 216
          tmp___37 = (int )((unsigned char )*n);
        }
      } else {
#line 216
        tmp___37 = (int )((unsigned char )*n);
      }
#line 216
      fn = (unsigned char )tmp___37;
#line 218
      if (! (flags & (1 << 1))) {
#line 218
        if ((int )c == 92) {
#line 220
          if ((int const   )*p == 0) {
#line 221
            return (1);
          }
#line 222
          if (flags & (1 << 4)) {
            {
#line 222
            tmp___41 = __ctype_b_loc();
            }
#line 222
            if ((int const   )*(*tmp___41 + (int )((unsigned char )*p)) & 256) {
              {
#line 222
              tmp___40 = tolower((int )((unsigned char )*p));
#line 222
              c = (unsigned char )tmp___40;
              }
            } else {
#line 222
              c = (unsigned char )*p;
            }
          } else {
#line 222
            c = (unsigned char )*p;
          }
#line 223
          p ++;
#line 225
          if ((int )c == (int )fn) {
#line 226
            goto matched;
          }
        } else {
#line 218
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 228
      if ((int )c == 91) {
#line 228
        if ((int const   )*p == 58) {
#line 232
          c1 = (size_t )0;
#line 236
          startp = p;
          {
#line 238
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 240
            if (c1 == 6U) {
#line 243
              return (1);
            }
#line 245
            p ++;
#line 245
            c = (unsigned char )*p;
#line 246
            if ((int )c == 58) {
#line 246
              if ((int const   )*(p + 1) == 93) {
#line 248
                p += 2;
#line 249
                goto while_break___5;
              }
            }
#line 251
            if ((int )c < 97) {
#line 255
              p = startp;
#line 256
              c = (unsigned char )'[';
#line 257
              goto normal_bracket;
            } else
#line 251
            if ((int )c >= 122) {
#line 255
              p = startp;
#line 256
              c = (unsigned char )'[';
#line 257
              goto normal_bracket;
            }
#line 259
            tmp___42 = c1;
#line 259
            c1 ++;
#line 259
            str[tmp___42] = (char )c;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 261
          str[c1] = (char )'\000';
#line 299
          tmp___43 = strcmp((char const   *)(str), "alnum");
          }
#line 299
          if (tmp___43 == 0) {
            {
#line 299
            tmp___44 = __ctype_b_loc();
            }
#line 299
            if ((int const   )*(*tmp___44 + (int )((unsigned char )*n)) & 8) {
#line 311
              goto matched;
            } else {
#line 299
              goto _L___12;
            }
          } else {
            _L___12: /* CIL Label */ 
            {
#line 299
            tmp___45 = strcmp((char const   *)(str), "alpha");
            }
#line 299
            if (tmp___45 == 0) {
              {
#line 299
              tmp___46 = __ctype_b_loc();
              }
#line 299
              if ((int const   )*(*tmp___46 + (int )((unsigned char )*n)) & 1024) {
#line 311
                goto matched;
              } else {
#line 299
                goto _L___11;
              }
            } else {
              _L___11: /* CIL Label */ 
              {
#line 299
              tmp___47 = strcmp((char const   *)(str), "blank");
              }
#line 299
              if (tmp___47 == 0) {
                {
#line 299
                tmp___48 = __ctype_b_loc();
                }
#line 299
                if ((int const   )*(*tmp___48 + (int )((unsigned char )*n)) & 1) {
#line 311
                  goto matched;
                } else {
#line 299
                  goto _L___10;
                }
              } else {
                _L___10: /* CIL Label */ 
                {
#line 299
                tmp___49 = strcmp((char const   *)(str), "cntrl");
                }
#line 299
                if (tmp___49 == 0) {
                  {
#line 299
                  tmp___50 = __ctype_b_loc();
                  }
#line 299
                  if ((int const   )*(*tmp___50 + (int )((unsigned char )*n)) & 2) {
#line 311
                    goto matched;
                  } else {
#line 299
                    goto _L___9;
                  }
                } else {
                  _L___9: /* CIL Label */ 
                  {
#line 299
                  tmp___51 = strcmp((char const   *)(str), "digit");
                  }
#line 299
                  if (tmp___51 == 0) {
                    {
#line 299
                    tmp___52 = __ctype_b_loc();
                    }
#line 299
                    if ((int const   )*(*tmp___52 + (int )((unsigned char )*n)) & 2048) {
#line 311
                      goto matched;
                    } else {
#line 299
                      goto _L___8;
                    }
                  } else {
                    _L___8: /* CIL Label */ 
                    {
#line 299
                    tmp___53 = strcmp((char const   *)(str), "graph");
                    }
#line 299
                    if (tmp___53 == 0) {
                      {
#line 299
                      tmp___54 = __ctype_b_loc();
                      }
#line 299
                      if ((int const   )*(*tmp___54 + (int )((unsigned char )*n)) & 32768) {
#line 311
                        goto matched;
                      } else {
#line 299
                        goto _L___7;
                      }
                    } else {
                      _L___7: /* CIL Label */ 
                      {
#line 299
                      tmp___55 = strcmp((char const   *)(str), "lower");
                      }
#line 299
                      if (tmp___55 == 0) {
                        {
#line 299
                        tmp___56 = __ctype_b_loc();
                        }
#line 299
                        if ((int const   )*(*tmp___56 + (int )((unsigned char )*n)) & 512) {
#line 311
                          goto matched;
                        } else {
#line 299
                          goto _L___6;
                        }
                      } else {
                        _L___6: /* CIL Label */ 
                        {
#line 299
                        tmp___57 = strcmp((char const   *)(str), "print");
                        }
#line 299
                        if (tmp___57 == 0) {
                          {
#line 299
                          tmp___58 = __ctype_b_loc();
                          }
#line 299
                          if ((int const   )*(*tmp___58 + (int )((unsigned char )*n)) & 16384) {
#line 311
                            goto matched;
                          } else {
#line 299
                            goto _L___5;
                          }
                        } else {
                          _L___5: /* CIL Label */ 
                          {
#line 299
                          tmp___59 = strcmp((char const   *)(str), "punct");
                          }
#line 299
                          if (tmp___59 == 0) {
                            {
#line 299
                            tmp___60 = __ctype_b_loc();
                            }
#line 299
                            if ((int const   )*(*tmp___60 + (int )((unsigned char )*n)) & 4) {
#line 311
                              goto matched;
                            } else {
#line 299
                              goto _L___4;
                            }
                          } else {
                            _L___4: /* CIL Label */ 
                            {
#line 299
                            tmp___61 = strcmp((char const   *)(str), "space");
                            }
#line 299
                            if (tmp___61 == 0) {
                              {
#line 299
                              tmp___62 = __ctype_b_loc();
                              }
#line 299
                              if ((int const   )*(*tmp___62 + (int )((unsigned char )*n)) & 8192) {
#line 311
                                goto matched;
                              } else {
#line 299
                                goto _L___3;
                              }
                            } else {
                              _L___3: /* CIL Label */ 
                              {
#line 299
                              tmp___63 = strcmp((char const   *)(str), "upper");
                              }
#line 299
                              if (tmp___63 == 0) {
                                {
#line 299
                                tmp___64 = __ctype_b_loc();
                                }
#line 299
                                if ((int const   )*(*tmp___64 + (int )((unsigned char )*n)) & 256) {
#line 311
                                  goto matched;
                                } else {
#line 299
                                  goto _L___2;
                                }
                              } else {
                                _L___2: /* CIL Label */ 
                                {
#line 299
                                tmp___65 = strcmp((char const   *)(str), "xdigit");
                                }
#line 299
                                if (tmp___65 == 0) {
                                  {
#line 299
                                  tmp___66 = __ctype_b_loc();
                                  }
#line 299
                                  if ((int const   )*(*tmp___66 + (int )((unsigned char )*n)) & 4096) {
#line 311
                                    goto matched;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#line 313
          tmp___67 = p;
#line 313
          p ++;
#line 313
          c = (unsigned char )*tmp___67;
        } else {
#line 228
          goto _L___13;
        }
      } else
      _L___13: /* CIL Label */ 
#line 423
      if ((int )c == 0) {
#line 425
        return (1);
      } else {
#line 432
        is_range = 0;
#line 600
        if (flags & (1 << 4)) {
          {
#line 600
          tmp___70 = __ctype_b_loc();
          }
#line 600
          if ((int const   )*(*tmp___70 + (int )c) & 256) {
            {
#line 600
            tmp___69 = tolower((int )c);
#line 600
            c = (unsigned char )tmp___69;
            }
          } else {
#line 600
            c = c;
          }
        } else {
#line 600
          c = c;
        }
        normal_bracket: 
#line 606
        if ((int const   )*p == 45) {
#line 606
          if ((int const   )*(p + 1) != 0) {
#line 606
            tmp___71 = 1;
          } else {
#line 606
            tmp___71 = 0;
          }
        } else {
#line 606
          tmp___71 = 0;
        }
#line 606
        is_range = tmp___71;
#line 608
        if (! is_range) {
#line 608
          if ((int )c == (int )fn) {
#line 609
            goto matched;
          }
        }
#line 611
        cold = (char )c;
#line 612
        tmp___72 = p;
#line 612
        p ++;
#line 612
        c = (unsigned char )*tmp___72;
#line 615
        if ((int )c == 45) {
#line 615
          if ((int const   )*p != 93) {
#line 860
            tmp___73 = p;
#line 860
            p ++;
#line 860
            cend = (unsigned char )*tmp___73;
#line 862
            if (! (flags & (1 << 1))) {
#line 862
              if ((int )cend == 92) {
#line 863
                tmp___74 = p;
#line 863
                p ++;
#line 863
                cend = (unsigned char )*tmp___74;
              }
            }
#line 864
            if ((int )cend == 0) {
#line 865
              return (1);
            }
#line 868
            if ((int )cold <= (int )fn) {
#line 868
              if ((int )fn <= (int )c) {
#line 869
                goto matched;
              }
            }
#line 872
            tmp___75 = p;
#line 872
            p ++;
#line 872
            c = (unsigned char )*tmp___75;
          }
        }
      }
#line 876
      if ((int )c == 93) {
#line 877
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 880
    if (! not) {
#line 881
      return (1);
    }
#line 882
    goto switch_break;
    matched: 
    {
#line 886
    while (1) {
      while_continue___6: /* CIL Label */ ;
      ignore_next: 
#line 889
      tmp___76 = p;
#line 889
      p ++;
#line 889
      c = (unsigned char )*tmp___76;
#line 891
      if ((int )c == 0) {
#line 893
        return (1);
      }
#line 895
      if (! (flags & (1 << 1))) {
#line 895
        if ((int )c == 92) {
#line 897
          if ((int const   )*p == 0) {
#line 898
            return (1);
          }
#line 900
          p ++;
        } else {
#line 895
          goto _L___17;
        }
      } else
      _L___17: /* CIL Label */ 
#line 902
      if ((int )c == 91) {
#line 902
        if ((int const   )*p == 58) {
#line 904
          c1___0 = 0;
#line 905
          startp___0 = p;
          {
#line 907
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 909
            p ++;
#line 909
            c = (unsigned char )*p;
#line 910
            c1___0 ++;
#line 910
            if (c1___0 == 6) {
#line 911
              return (1);
            }
#line 913
            if ((int const   )*p == 58) {
#line 913
              if ((int const   )*(p + 1) == 93) {
#line 914
                goto while_break___7;
              }
            }
#line 916
            if ((int )c < 97) {
#line 918
              p = startp___0;
#line 919
              goto ignore_next;
            } else
#line 916
            if ((int )c >= 122) {
#line 918
              p = startp___0;
#line 919
              goto ignore_next;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 922
          p += 2;
#line 923
          tmp___77 = p;
#line 923
          p ++;
#line 923
          c = (unsigned char )*tmp___77;
        } else {
#line 902
          goto _L___16;
        }
      } else
      _L___16: /* CIL Label */ 
#line 925
      if ((int )c == 91) {
#line 925
        if ((int const   )*p == 61) {
#line 927
          p ++;
#line 927
          c = (unsigned char )*p;
#line 928
          if ((int )c == 0) {
#line 929
            return (1);
          }
#line 930
          p ++;
#line 930
          c = (unsigned char )*p;
#line 931
          if ((int )c != 61) {
#line 932
            return (1);
          } else
#line 931
          if ((int const   )*(p + 1) != 93) {
#line 932
            return (1);
          }
#line 933
          p += 2;
#line 934
          tmp___78 = p;
#line 934
          p ++;
#line 934
          c = (unsigned char )*tmp___78;
        } else {
#line 925
          goto _L___15;
        }
      } else
      _L___15: /* CIL Label */ 
#line 936
      if ((int )c == 91) {
#line 936
        if ((int const   )*p == 46) {
#line 938
          p ++;
          {
#line 939
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 941
            p ++;
#line 941
            c = (unsigned char )*p;
#line 942
            if ((int )c == 0) {
#line 943
              return (1);
            }
#line 945
            if ((int const   )*p == 46) {
#line 945
              if ((int const   )*(p + 1) == 93) {
#line 946
                goto while_break___8;
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
#line 948
          p += 2;
#line 949
          tmp___79 = p;
#line 949
          p ++;
#line 949
          c = (unsigned char )*tmp___79;
        }
      }
#line 886
      if (! ((int )c != 93)) {
#line 886
        goto while_break___6;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 953
    if (not) {
#line 954
      return (1);
    }
#line 956
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 959
    if (flags & (1 << 4)) {
      {
#line 959
      tmp___83 = __ctype_b_loc();
      }
#line 959
      if ((int const   )*(*tmp___83 + (int )((unsigned char )*n)) & 256) {
        {
#line 959
        tmp___81 = tolower((int )((unsigned char )*n));
#line 959
        tmp___82 = tmp___81;
        }
      } else {
#line 959
        tmp___82 = (int )((unsigned char )*n);
      }
    } else {
#line 959
      tmp___82 = (int )((unsigned char )*n);
    }
#line 959
    if ((int )c != tmp___82) {
#line 960
      return (1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 963
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 966
  if ((int const   )*n == 0) {
#line 967
    return (0);
  }
#line 969
  if (flags & (1 << 3)) {
#line 969
    if ((int const   )*n == 47) {
#line 971
      return (0);
    }
  }
#line 973
  return (1);
}
}
#line 330 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr_fnmatch.c"
int pr_fnmatch(char const   *pattern , char const   *string , int flags ) 
{ 
  int tmp ;

  {
  {
#line 371
  tmp = internal_fnmatch(pattern, string, flags & (1 << 2), flags);
  }
#line 371
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 365
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 59
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 87
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 242
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 101 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 125
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 137
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 282
extern char *tzname[2] ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 76 "../include/pr-syslog.h"
void pr_closelog(int sockfd ) ;
#line 81
int pr_openlog(char const   *ident , int opts___0 , int facility___0 ) ;
#line 84
int pr_setlogmask(int new_mask ) ;
#line 87
int pr_setlogfacility(int new_facility ) ;
#line 91
void pr_syslog(int sockfd , int pri , char const   *fmt  , ...) ;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static int sock_type  =    2;
#line 44 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static int log_opts  =    0;
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static char const   *log_ident  =    (char const   *)((void *)0);
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static int log_facility  =    1 << 3;
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static int log_mask  =    255;
#line 50
extern char *__progname ;
#line 56
static void pr_vsyslog(int sockfd , int pri , char const   *fmt , va_list ap ) ;
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static char logbuf[1024]  = {      (char )'\000'};
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static void pr_vsyslog(int sockfd , int pri , char const   *fmt , va_list ap ) 
{ 
  time_t now ;
  size_t buflen ;
  int saved_errno ;
  int *tmp ;
  char *timestr ;
  char *saved_tzname[2] ;
  size_t tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 57
  buflen = (size_t )0;
#line 58
  tmp = __errno_location();
#line 58
  saved_errno = *tmp;
#line 64
  timestr = (char *)((void *)0);
#line 72
  memset((void *)(logbuf), '\000', (size_t )sizeof(logbuf));
  }
#line 75
  if (pri & -1024) {
#line 76
    pri &= 1023;
  }
#line 79
  if (((1 << (pri & 7)) & log_mask) == 0) {
#line 80
    return;
  }
#line 83
  if ((pri & 1016) == 0) {
#line 84
    pri |= log_facility;
  }
  {
#line 87
  snprintf((char */* __restrict  */)(logbuf), (size_t )sizeof(logbuf), (char const   */* __restrict  */)"<%d>",
           pri);
#line 88
  logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 89
  buflen = strlen((char const   *)(logbuf));
#line 93
  memcpy((void */* __restrict  */)(saved_tzname), (void const   */* __restrict  */)(tzname),
         (size_t )sizeof(saved_tzname));
#line 96
  time(& now);
#line 97
  timestr = ctime((time_t const   *)(& now));
#line 104
  memcpy((void */* __restrict  */)(tzname), (void const   */* __restrict  */)(saved_tzname),
         (size_t )sizeof(saved_tzname));
#line 108
  tmp___0 = strlen((char const   *)timestr);
#line 108
  *(timestr + (tmp___0 - 1U)) = (char )'\000';
#line 111
  timestr += 4;
#line 113
  snprintf((char */* __restrict  */)(& logbuf[buflen]), (size_t )(sizeof(logbuf) - (unsigned long )buflen),
           (char const   */* __restrict  */)"%.15s ", timestr);
#line 114
  logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 115
  buflen = strlen((char const   *)(logbuf));
#line 118
  time(& now);
  }
#line 120
  if ((unsigned long )log_ident == (unsigned long )((void *)0)) {
#line 122
    log_ident = (char const   *)__progname;
  }
#line 127
  if ((unsigned long )buflen < sizeof(logbuf)) {
#line 127
    if ((unsigned long )log_ident != (unsigned long )((void *)0)) {
      {
#line 128
      snprintf((char */* __restrict  */)(& logbuf[buflen]), (size_t )(sizeof(logbuf) - (unsigned long )buflen),
               (char const   */* __restrict  */)"%s", log_ident);
#line 129
      logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 130
      buflen = strlen((char const   *)(logbuf));
      }
    }
  }
#line 133
  if ((unsigned long )buflen < sizeof(logbuf) - 1UL) {
#line 133
    if (log_opts & 1) {
      {
#line 134
      tmp___1 = getpid();
#line 134
      snprintf((char */* __restrict  */)(& logbuf[buflen]), (size_t )(sizeof(logbuf) - (unsigned long )buflen),
               (char const   */* __restrict  */)"[%d]", tmp___1);
#line 136
      logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 137
      buflen = strlen((char const   *)(logbuf));
      }
    }
  }
#line 140
  if ((unsigned long )buflen < sizeof(logbuf) - 1UL) {
#line 140
    if ((unsigned long )log_ident != (unsigned long )((void *)0)) {
      {
#line 141
      snprintf((char */* __restrict  */)(& logbuf[buflen]), (size_t )(sizeof(logbuf) - (unsigned long )buflen),
               (char const   */* __restrict  */)": ");
#line 142
      logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 143
      buflen = strlen((char const   *)(logbuf));
      }
    }
  }
  {
#line 147
  tmp___2 = __errno_location();
#line 147
  *tmp___2 = saved_errno;
  }
#line 150
  if ((unsigned long )buflen < sizeof(logbuf)) {
    {
#line 151
    vsnprintf((char */* __restrict  */)(& logbuf[buflen]), (size_t )(sizeof(logbuf) - (unsigned long )buflen),
              (char const   */* __restrict  */)fmt, ap);
#line 152
    logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 153
    buflen = strlen((char const   *)(logbuf));
    }
  }
#line 158
  logbuf[sizeof(logbuf) - 1UL] = (char )'\000';
#line 163
  if (sock_type == 1) {
#line 164
    buflen ++;
  }
  {
#line 167
  send(sockfd, (void const   *)(logbuf), buflen, 0);
  }
#line 185
  return;
}
}
#line 187 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
void pr_syslog(int sockfd , int pri , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 189
  __builtin_va_start(ap, fmt);
#line 190
  pr_vsyslog(sockfd, pri, fmt, ap);
#line 191
  __builtin_va_end(ap);
  }
#line 192
  return;
}
}
#line 196 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
static struct sockaddr syslog_addr  ;
#line 199 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
int pr_openlog(char const   *ident , int opts___0 , int facility___0 ) 
{ 
  int sockfd ;
  socklen_t addrlen ;
  int old_errno ;
  int *tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;

  {
#line 200
  sockfd = -1;
#line 202
  if ((unsigned long )ident != (unsigned long )((void *)0)) {
#line 203
    log_ident = ident;
  }
#line 205
  log_opts = opts___0;
#line 207
  if (facility___0 != 0) {
#line 207
    if ((facility___0 & -1017) == 0) {
#line 208
      log_facility = facility___0;
    }
  }
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    addrlen = (socklen_t )0;
#line 214
    if (sockfd == -1) {
      {
#line 215
      syslog_addr.sa_family = (sa_family_t )1;
#line 237
      strncpy((char */* __restrict  */)(syslog_addr.sa_data), (char const   */* __restrict  */)"/dev/log",
              (size_t )sizeof(syslog_addr.sa_data));
#line 238
      syslog_addr.sa_data[sizeof(syslog_addr.sa_data) - 1UL] = (char )'\000';
#line 239
      addrlen = (socklen_t )sizeof(syslog_addr);
      }
#line 242
      if (log_opts & 8) {
        {
#line 243
        sockfd = socket(1, sock_type, 0);
        }
#line 244
        if (sockfd < 0) {
#line 245
          return (-1);
        }
        {
#line 248
        fcntl(sockfd, 2, 1);
        }
      }
    }
#line 252
    if (sockfd != -1) {
      {
#line 253
      tmp = __errno_location();
#line 253
      old_errno = *tmp;
#line 255
      tmp___2 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)(& syslog_addr),
                        addrlen);
      }
#line 255
      if (tmp___2 == -1) {
        {
#line 256
        tmp___0 = __errno_location();
#line 256
        saved_errno = *tmp___0;
#line 257
        close(sockfd);
#line 258
        sockfd = -1;
        }
#line 260
        if (sock_type == 2) {
#line 260
          if (saved_errno == 91) {
            {
#line 262
            sock_type = 1;
#line 263
            tmp___1 = __errno_location();
#line 263
            *tmp___1 = old_errno;
            }
#line 264
            goto while_continue;
          }
        }
      }
    }
#line 268
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (sockfd);
}
}
#line 293 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
void pr_closelog(int sockfd ) 
{ 


  {
  {
#line 294
  close(sockfd);
#line 295
  sockfd = -1;
#line 298
  log_ident = (char const   *)((void *)0);
#line 301
  sock_type = 2;
  }
#line 302
  return;
}
}
#line 305 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
int pr_setlogmask(int new_mask ) 
{ 
  int old_mask ;

  {
#line 308
  old_mask = log_mask;
#line 309
  if (new_mask != 0) {
#line 310
    log_mask = new_mask;
  }
#line 312
  return (old_mask);
}
}
#line 315 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/pr-syslog.c"
int pr_setlogfacility(int new_facility ) 
{ 
  int old_facility ;

  {
#line 318
  old_facility = log_facility;
#line 319
  if (new_facility > 0) {
#line 320
    log_facility = new_facility;
  }
#line 322
  return (old_facility);
}
}
#line 75 "../include/libsupp.h"
void pr_os_already_has_mkstemp(void) ;
#line 102 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/glibc-mkstemp.c"
void pr_os_already_has_mkstemp(void) 
{ 


  {
#line 105
  return;
}
}
#line 69 "../include/libsupp.h"
void pr_os_already_has_hstrerror(void) ;
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/glibc-hstrerror.c"
void pr_os_already_has_hstrerror(void) 
{ 


  {
#line 80
  return;
}
}
#line 339 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 68 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
int cap_free(void *data_p ) ;
#line 69
cap_t cap_init(void) ;
#line 92
cap_t cap_from_text(char const   *str ) ;
#line 93
char *cap_to_text(cap_t caps , ssize_t *length_p ) ;
#line 9 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_names.h"
char const   *_cap_names[32]  = 
#line 9 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_names.h"
  {      "cap_chown",      "cap_dac_override",      "cap_dac_read_search",      "cap_fowner", 
        "cap_fsetid",      "cap_kill",      "cap_setgid",      "cap_setuid", 
        "cap_setpcap",      "cap_linux_immutable",      "cap_net_bind_service",      "cap_net_broadcast", 
        "cap_net_admin",      "cap_net_raw",      "cap_ipc_lock",      "cap_ipc_owner", 
        "cap_sys_module",      "cap_sys_rawio",      "cap_sys_chroot",      "cap_sys_ptrace", 
        "cap_sys_pacct",      "cap_sys_admin",      "cap_sys_boot",      "cap_sys_nice", 
        "cap_sys_resource",      "cap_sys_time",      "cap_sys_tty_config",      "cap_mknod", 
        "cap_lease",      "cap_audit_write",      "cap_audit_control",      "cap_setfcap"};
#line 119 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/libcap.h"
char *_libcap_strdup(char const   *old ) ;
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
static void _setbits(__cap_s *a , __cap_s *b ) 
{ 
  int n ;
  int tmp ;

  {
#line 35
  n = (int )((sizeof(struct __user_cap_data_struct ) / 3UL) / sizeof(unsigned int ));
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    tmp = n;
#line 35
    n --;
#line 35
    if (! tmp) {
#line 35
      goto while_break;
    }
#line 36
    a->_blk[n] |= b->_blk[n];
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
static void _clrbits(__cap_s *a , __cap_s *b ) 
{ 
  int n ;
  int tmp ;

  {
#line 43
  n = (int )((sizeof(struct __user_cap_data_struct ) / 3UL) / sizeof(unsigned int ));
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    tmp = n;
#line 43
    n --;
#line 43
    if (! tmp) {
#line 43
      goto while_break;
    }
#line 44
    a->_blk[n] &= ~ b->_blk[n];
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return;
}
}
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
static char const   *namcmp(char const   *str , char const   *nam ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (*nam) {
      {
#line 49
      tmp = tolower((int )((unsigned char )*str));
      }
#line 49
      if (! (tmp == (int )*nam)) {
#line 49
        goto while_break;
      }
    } else {
#line 49
      goto while_break;
    }
#line 50
    str ++;
#line 51
    nam ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  if (*nam) {
#line 54
    return ((char const   *)((void *)0));
  } else {
    {
#line 53
    tmp___0 = __ctype_b_loc();
    }
#line 53
    if ((int const   )*(*tmp___0 + (int )((unsigned char )*str)) & 8) {
#line 54
      return ((char const   *)((void *)0));
    } else
#line 53
    if ((int const   )*str == 95) {
#line 54
      return ((char const   *)((void *)0));
    }
  }
#line 55
  return (str);
}
}
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
static int lookupname(char const   **strp ) 
{ 
  char const   *str ;
  unsigned long n ;
  unsigned long tmp ;
  char const   *s ;
  int n___0 ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 60
  str = *strp;
#line 61
  tmp___1 = __ctype_b_loc();
  }
#line 61
  if ((int const   )*(*tmp___1 + (int )*str) & 2048) {
    {
#line 62
    tmp = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)((char **)(& str)),
                  0);
#line 62
    n = tmp;
    }
#line 63
    if (n >= 32UL) {
#line 64
      return (-1);
    }
#line 65
    *strp = str;
#line 66
    return ((int )n);
  } else {
#line 70
    n___0 = 32;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      tmp___0 = n___0;
#line 70
      n___0 --;
#line 70
      if (! tmp___0) {
#line 70
        goto while_break;
      }
#line 71
      if (_cap_names[n___0]) {
        {
#line 71
        s = namcmp(str, _cap_names[n___0]);
        }
#line 71
        if (s) {
#line 72
          *strp = s;
#line 73
          return (n___0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 75
    return (-1);
  }
}
}
#line 79 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
cap_t cap_from_text(char const   *str ) 
{ 
  cap_t res ;
  __cap_s allones ;
  int n ;
  int *tmp ;
  int tmp___0 ;
  char op ;
  int flags ;
  int listed ;
  __cap_s list ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  unsigned short const   **tmp___9 ;
  char const   *tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  int *tmp___13 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 85
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 87
    tmp = __errno_location();
#line 87
    *tmp = 22;
    }
#line 88
    return ((cap_t )((void *)0));
  }
  {
#line 91
  res = cap_init();
  }
#line 91
  if (! res) {
#line 92
    return ((cap_t )((void *)0));
  }
#line 93
  n = (int )((sizeof(struct __user_cap_data_struct ) / 3UL) / sizeof(unsigned int ));
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    tmp___0 = n;
#line 93
    n --;
#line 93
    if (! tmp___0) {
#line 93
      goto while_break;
    }
#line 94
    allones._blk[n] = 4294967295U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    flags = 0;
#line 99
    listed = 0;
#line 100
    list._blk[0] = 0U;
    {
#line 103
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 103
      tmp___1 = __ctype_b_loc();
      }
#line 103
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*str)) & 8192)) {
#line 103
        goto while_break___1;
      }
#line 104
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 105
    if (! *str) {
#line 109
      return (res);
    }
    {
#line 113
    tmp___4 = __ctype_b_loc();
    }
#line 113
    if ((int const   )*(*tmp___4 + (int )((unsigned char )*str)) & 8) {
#line 113
      goto _L;
    } else
#line 113
    if ((int const   )*str == 95) {
      _L: /* CIL Label */ 
      {
#line 114
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 115
        tmp___2 = namcmp(str, "all");
        }
#line 115
        if (tmp___2) {
#line 116
          str += 3;
#line 117
          list = allones;
        } else {
          {
#line 119
          n = lookupname(& str);
          }
#line 120
          if (n == -1) {
#line 121
            goto bad;
          }
#line 122
          list._blk[n >> 5] |= (unsigned int )(1 << (n & 31));
        }
#line 124
        if ((int const   )*str != 44) {
#line 125
          goto while_break___2;
        }
        {
#line 126
        tmp___3 = __ctype_b_loc();
#line 126
        str ++;
        }
#line 126
        if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*str)) & 8)) {
#line 126
          if ((int const   )*str != 95) {
#line 127
            goto bad;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 129
      listed = 1;
    } else
#line 130
    if ((int const   )*str == 43) {
#line 131
      goto bad;
    } else
#line 130
    if ((int const   )*str == 45) {
#line 131
      goto bad;
    } else {
#line 133
      list = allones;
    }
#line 136
    tmp___5 = str;
#line 136
    str ++;
#line 136
    op = (char )*tmp___5;
#line 137
    if ((int )op == 61) {
#line 137
      if ((int const   )*str == 43) {
#line 137
        goto _L___1;
      } else
#line 137
      if ((int const   )*str == 45) {
        _L___1: /* CIL Label */ 
#line 138
        if (! listed) {
#line 139
          goto bad;
        }
#line 140
        tmp___7 = str;
#line 140
        str ++;
#line 140
        if ((int const   )*tmp___7 == 43) {
#line 140
          op = (char )'P';
        } else {
#line 140
          op = (char )'M';
        }
      } else {
#line 137
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 141
    if ((int )op != 43) {
#line 141
      if ((int )op != 45) {
#line 141
        if ((int )op != 61) {
#line 142
          goto bad;
        }
      }
    }
    {
#line 145
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 147
      if (*str) {
        {
#line 147
        tmp___9 = __ctype_b_loc();
        }
#line 147
        if ((int const   )*(*tmp___9 + (int )*str) & 8192) {
#line 147
          goto _L___2;
        } else {
#line 148
          tmp___8 = str;
#line 148
          str ++;
          {
#line 149
          if ((int const   )*tmp___8 == 101) {
#line 149
            goto case_101;
          }
#line 152
          if ((int const   )*tmp___8 == 105) {
#line 152
            goto case_105;
          }
#line 155
          if ((int const   )*tmp___8 == 112) {
#line 155
            goto case_112;
          }
#line 158
          goto switch_default;
          case_101: /* CIL Label */ 
#line 150
          flags |= 1;
#line 151
          goto switch_break;
          case_105: /* CIL Label */ 
#line 153
          flags |= 2;
#line 154
          goto switch_break;
          case_112: /* CIL Label */ 
#line 156
          flags |= 4;
#line 157
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 159
          goto bad;
          switch_break: /* CIL Label */ ;
          }
        }
      } else
      _L___2: /* CIL Label */ 
#line 161
      if ((int )op != 61) {
#line 163
        goto bad;
      }
      {
#line 170
      if ((int )op == 77) {
#line 170
        goto case_77;
      }
#line 170
      if ((int )op == 80) {
#line 170
        goto case_77;
      }
#line 170
      if ((int )op == 61) {
#line 170
        goto case_77;
      }
#line 177
      if ((int )op == 43) {
#line 177
        goto case_43;
      }
#line 185
      if ((int )op == 45) {
#line 185
        goto minus;
      }
#line 167
      goto switch_break___0;
      case_77: /* CIL Label */ 
      case_80: /* CIL Label */ 
      case_61: /* CIL Label */ 
      {
#line 171
      _clrbits((__cap_s *)(& res->set.effective), & list);
#line 172
      _clrbits((__cap_s *)(& res->set.inheritable), & list);
#line 173
      _clrbits((__cap_s *)(& res->set.permitted), & list);
      }
#line 175
      if ((int )op == 77) {
#line 176
        goto minus;
      }
      case_43: /* CIL Label */ 
#line 178
      if (flags & 1) {
        {
#line 179
        _setbits((__cap_s *)(& res->set.effective), & list);
        }
      }
#line 180
      if (flags & 2) {
        {
#line 181
        _setbits((__cap_s *)(& res->set.inheritable), & list);
        }
      }
#line 182
      if (flags & 4) {
        {
#line 183
        _setbits((__cap_s *)(& res->set.permitted), & list);
        }
      }
#line 184
      goto switch_break___0;
      minus: 
      case_45: /* CIL Label */ 
#line 187
      if (flags & 1) {
        {
#line 188
        _clrbits((__cap_s *)(& res->set.effective), & list);
        }
      }
#line 189
      if (flags & 2) {
        {
#line 190
        _clrbits((__cap_s *)(& res->set.inheritable), & list);
        }
      }
#line 191
      if (flags & 4) {
        {
#line 192
        _clrbits((__cap_s *)(& res->set.permitted), & list);
        }
      }
#line 193
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 197
      if ((int const   )*str == 43) {
#line 197
        goto _L___3;
      } else
#line 197
      if ((int const   )*str == 45) {
        _L___3: /* CIL Label */ 
#line 198
        if (! listed) {
#line 200
          goto bad;
        }
        {
#line 202
        flags = 0;
#line 203
        tmp___10 = str;
#line 203
        str ++;
#line 203
        op = (char )*tmp___10;
#line 204
        tmp___11 = __ctype_b_loc();
        }
#line 204
        if (! ((int const   )*(*tmp___11 + (int )*str) & 1024)) {
#line 205
          goto bad;
        }
      }
#line 145
      if (*str) {
        {
#line 145
        tmp___12 = __ctype_b_loc();
        }
#line 145
        if ((int const   )*(*tmp___12 + (int )*str) & 8192) {
#line 145
          goto while_break___3;
        }
      } else {
#line 145
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  bad: 
  {
#line 212
  cap_free((void *)(& res));
#line 213
  tmp___13 = __errno_location();
#line 213
  *tmp___13 = 22;
  }
#line 214
  return ((cap_t )((void *)0));
}
}
#line 223 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
static int getstateflags(cap_t caps , int capno ) 
{ 
  int f ;

  {
#line 225
  f = 0;
#line 227
  if (((__cap_s *)(& caps->set.effective))->_blk[capno >> 5] & (unsigned int )(1 << (capno & 31))) {
#line 228
    f |= 1;
  }
#line 229
  if (((__cap_s *)(& caps->set.inheritable))->_blk[capno >> 5] & (unsigned int )(1 << (capno & 31))) {
#line 230
    f |= 2;
  }
#line 231
  if (((__cap_s *)(& caps->set.permitted))->_blk[capno >> 5] & (unsigned int )(1 << (capno & 31))) {
#line 232
    f |= 4;
  }
#line 234
  return (f);
}
}
#line 241 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
static char buf[612]  ;
#line 239 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_text.c"
char *cap_to_text(cap_t caps , ssize_t *length_p ) 
{ 
  char *p ;
  int histo[8] ;
  unsigned int tmp ;
  int m ;
  int n ;
  int t ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 243
  histo[0] = 0;
#line 243
  tmp = 1U;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (tmp >= 8U) {
#line 243
      goto while_break;
    }
#line 243
    histo[tmp] = 0;
#line 243
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  if (caps) {
#line 247
    if (! (*((unsigned int *)caps + -1) == 13275344U)) {
      {
#line 248
      tmp___0 = __errno_location();
#line 248
      *tmp___0 = 22;
      }
#line 249
      return ((char *)((void *)0));
    }
  } else {
    {
#line 248
    tmp___0 = __errno_location();
#line 248
    *tmp___0 = 22;
    }
#line 249
    return ((char *)((void *)0));
  }
#line 256
  n = 32;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 256
    tmp___2 = n;
#line 256
    n --;
#line 256
    if (! tmp___2) {
#line 256
      goto while_break___0;
    }
    {
#line 257
    tmp___1 = getstateflags(caps, n);
#line 257
    (histo[tmp___1]) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  t = 7;
#line 259
  m = t;
  {
#line 259
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 259
    tmp___3 = t;
#line 259
    t --;
#line 259
    if (! tmp___3) {
#line 259
      goto while_break___1;
    }
#line 260
    if (histo[t] > histo[m]) {
#line 261
      m = t;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 264
  if (m & 4) {
#line 264
    tmp___4 = "p";
  } else {
#line 264
    tmp___4 = "";
  }
#line 264
  if (m & 2) {
#line 264
    tmp___5 = "i";
  } else {
#line 264
    tmp___5 = "";
  }
#line 264
  if (m & 1) {
#line 264
    tmp___6 = "e";
  } else {
#line 264
    tmp___6 = "";
  }
  {
#line 264
  tmp___7 = sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"=%s%s%s",
                    tmp___6, tmp___5, tmp___4);
#line 264
  p = buf + tmp___7;
#line 269
  t = 8;
  }
  {
#line 269
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 269
    tmp___22 = t;
#line 269
    t --;
#line 269
    if (! tmp___22) {
#line 269
      goto while_break___2;
    }
#line 270
    if (t != m) {
#line 270
      if (histo[t]) {
#line 271
        tmp___8 = p;
#line 271
        p ++;
#line 271
        *tmp___8 = (char )' ';
#line 272
        n = 0;
        {
#line 272
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 272
          if (! (n != 32)) {
#line 272
            goto while_break___3;
          }
          {
#line 273
          tmp___12 = getstateflags(caps, n);
          }
#line 273
          if (tmp___12 == t) {
#line 274
            if (_cap_names[n]) {
              {
#line 275
              tmp___9 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s,",
                                _cap_names[n]);
#line 275
              p += tmp___9;
              }
            } else {
              {
#line 277
              tmp___10 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d,",
                                 n);
#line 277
              p += tmp___10;
              }
            }
#line 278
            if (p - buf > 512L) {
              {
#line 279
              tmp___11 = __errno_location();
#line 279
              *tmp___11 = 34;
              }
#line 280
              return ((char *)((void *)0));
            }
          }
#line 272
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 283
        p --;
#line 284
        n = t & ~ m;
#line 285
        if (n) {
#line 286
          if (n & 4) {
#line 286
            tmp___13 = "p";
          } else {
#line 286
            tmp___13 = "";
          }
#line 286
          if (n & 2) {
#line 286
            tmp___14 = "i";
          } else {
#line 286
            tmp___14 = "";
          }
#line 286
          if (n & 1) {
#line 286
            tmp___15 = "e";
          } else {
#line 286
            tmp___15 = "";
          }
          {
#line 286
          tmp___16 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"+%s%s%s",
                             tmp___15, tmp___14, tmp___13);
#line 286
          p += tmp___16;
          }
        }
#line 290
        n = ~ t & m;
#line 291
        if (n) {
#line 292
          if (n & 4) {
#line 292
            tmp___17 = "p";
          } else {
#line 292
            tmp___17 = "";
          }
#line 292
          if (n & 2) {
#line 292
            tmp___18 = "i";
          } else {
#line 292
            tmp___18 = "";
          }
#line 292
          if (n & 1) {
#line 292
            tmp___19 = "e";
          } else {
#line 292
            tmp___19 = "";
          }
          {
#line 292
          tmp___20 = sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"-%s%s%s",
                             tmp___19, tmp___18, tmp___17);
#line 292
          p += tmp___20;
          }
        }
#line 296
        if (p - buf > 512L) {
          {
#line 297
          tmp___21 = __errno_location();
#line 297
          *tmp___21 = 34;
          }
#line 298
          return ((char *)((void *)0));
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 303
  if (length_p) {
#line 304
    *length_p = (ssize_t )(p - buf);
  }
  {
#line 307
  tmp___23 = _libcap_strdup((char const   *)(buf));
  }
#line 307
  return (tmp___23);
}
}
#line 83 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
cap_t cap_get_proc(void) ;
#line 84
int cap_set_proc(cap_t cap_d ) ;
#line 127 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/libcap.h"
extern int capset(cap_user_header_t header , cap_user_data_t data ) ;
#line 128
extern int capget(cap_user_header_t header , cap_user_data_t const   data ) ;
#line 129
int capgetp(pid_t pid , cap_t cap_d ) ;
#line 130
int capsetp(pid_t pid , cap_t cap_d ) ;
#line 13 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_proc.c"
cap_t cap_get_proc(void) 
{ 
  cap_t result ;
  int tmp ;

  {
  {
#line 18
  result = cap_init();
  }
#line 19
  if (result) {
    {
#line 23
    tmp = capget(& result->head, (cap_user_data_t const   )(& result->set));
    }
#line 23
    if (tmp) {
      {
#line 24
      cap_free((void *)(& result));
      }
    }
  }
#line 28
  return (result);
}
}
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_proc.c"
int cap_set_proc(cap_t cap_d ) 
{ 
  int retval ;
  int *tmp ;

  {
#line 35
  if (cap_d) {
#line 35
    if (! (*((unsigned int *)cap_d + -1) == 13275344U)) {
      {
#line 36
      tmp = __errno_location();
#line 36
      *tmp = 22;
      }
#line 37
      return (-1);
    }
  } else {
    {
#line 36
    tmp = __errno_location();
#line 36
    *tmp = 22;
    }
#line 37
    return (-1);
  }
  {
#line 41
  retval = capset(& cap_d->head, & cap_d->set);
#line 43
  cap_d->head.version = (__u32 )429392688;
  }
#line 44
  return (retval);
}
}
#line 51 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_proc.c"
int capgetp(pid_t pid , cap_t cap_d ) 
{ 
  int error ;
  int *tmp ;

  {
#line 55
  if (cap_d) {
#line 55
    if (! (*((unsigned int *)cap_d + -1) == 13275344U)) {
      {
#line 56
      tmp = __errno_location();
#line 56
      *tmp = 22;
      }
#line 57
      return (-1);
    }
  } else {
    {
#line 56
    tmp = __errno_location();
#line 56
    *tmp = 22;
    }
#line 57
    return (-1);
  }
  {
#line 62
  cap_d->head.pid = pid;
#line 63
  error = capget(& cap_d->head, (cap_user_data_t const   )(& cap_d->set));
#line 64
  cap_d->head.version = (__u32 )429392688;
#line 65
  cap_d->head.pid = 0;
  }
#line 67
  return (error);
}
}
#line 72 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_proc.c"
int capsetp(pid_t pid , cap_t cap_d ) 
{ 
  int error ;
  int *tmp ;

  {
#line 76
  if (cap_d) {
#line 76
    if (! (*((unsigned int *)cap_d + -1) == 13275344U)) {
      {
#line 77
      tmp = __errno_location();
#line 77
      *tmp = 22;
      }
#line 78
      return (-1);
    }
  } else {
    {
#line 77
    tmp = __errno_location();
#line 77
    *tmp = 22;
    }
#line 78
    return (-1);
  }
  {
#line 82
  cap_d->head.pid = pid;
#line 83
  error = capset(& cap_d->head, & cap_d->set);
#line 84
  cap_d->head.version = (__u32 )429392688;
#line 85
  cap_d->head.pid = 0;
  }
#line 87
  return (error);
}
}
#line 72 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
int cap_get_flag(cap_t cap_d , cap_value_t value , cap_flag_t set , cap_flag_value_t *raised ) ;
#line 73
int cap_set_flag(cap_t cap_d , cap_flag_t set , int no_values , cap_value_t *array_values ,
                 cap_flag_value_t raise ) ;
#line 74
int cap_clear(cap_t cap_d ) ;
#line 20 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_flag.c"
int cap_get_flag(cap_t cap_d , cap_value_t value , cap_flag_t set , cap_flag_value_t *raised ) 
{ 
  __cap_s *cap_p ;
  int *tmp ;

  {
#line 28
  if (raised) {
#line 28
    if (cap_d) {
#line 28
      if (*((unsigned int *)cap_d + -1) == 13275344U) {
#line 28
        if (value >= 0) {
#line 28
          if (value < 32) {
#line 28
            if ((unsigned int )set >= 0U) {
#line 28
              if ((unsigned int )set < 3U) {
#line 30
                cap_p = (__cap_s *)((unsigned char *)(& cap_d->set) + (unsigned long )set * (sizeof(struct __user_cap_data_struct ) / 3UL));
#line 33
                if (cap_p->_blk[value >> 5] & (unsigned int )(1 << (value & 31))) {
#line 33
                  *raised = (cap_flag_value_t )1;
                } else {
#line 33
                  *raised = (cap_flag_value_t )0;
                }
#line 34
                return (0);
              } else {
                {
#line 39
                tmp = __errno_location();
#line 39
                *tmp = 22;
                }
#line 40
                return (-1);
              }
            } else {
              {
#line 39
              tmp = __errno_location();
#line 39
              *tmp = 22;
              }
#line 40
              return (-1);
            }
          } else {
            {
#line 39
            tmp = __errno_location();
#line 39
            *tmp = 22;
            }
#line 40
            return (-1);
          }
        } else {
          {
#line 39
          tmp = __errno_location();
#line 39
          *tmp = 22;
          }
#line 40
          return (-1);
        }
      } else {
        {
#line 39
        tmp = __errno_location();
#line 39
        *tmp = 22;
        }
#line 40
        return (-1);
      }
    } else {
      {
#line 39
      tmp = __errno_location();
#line 39
      *tmp = 22;
      }
#line 40
      return (-1);
    }
  } else {
    {
#line 39
    tmp = __errno_location();
#line 39
    *tmp = 22;
    }
#line 40
    return (-1);
  }
}
}
#line 49 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_flag.c"
int cap_set_flag(cap_t cap_d , cap_flag_t set , int no_values , cap_value_t *array_values ,
                 cap_flag_value_t raise ) 
{ 
  int i___0 ;
  int value ;
  __cap_s *cap_p ;
  int *tmp ;

  {
#line 58
  if (cap_d) {
#line 58
    if (*((unsigned int *)cap_d + -1) == 13275344U) {
#line 58
      if (no_values > 0) {
#line 58
        if (no_values <= 32) {
#line 58
          if ((unsigned int )set >= 0U) {
#line 58
            if ((unsigned int )set < 3U) {
#line 58
              if ((unsigned int )raise == 1U) {
#line 58
                goto _L;
              } else
#line 58
              if ((unsigned int )raise == 0U) {
                _L: /* CIL Label */ 
#line 62
                i___0 = 0;
                {
#line 62
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 62
                  if (! (i___0 < no_values)) {
#line 62
                    goto while_break;
                  }
#line 63
                  if (! (*(array_values + i___0) < 0)) {
#line 63
                    if (! (*(array_values + i___0) >= 32)) {
#line 66
                      value = *(array_values + i___0);
#line 67
                      cap_p = (__cap_s *)((unsigned char *)(& cap_d->set) + (unsigned long )set * (sizeof(struct __user_cap_data_struct ) / 3UL));
#line 70
                      if ((unsigned int )raise == 1U) {
#line 71
                        cap_p->_blk[value >> 5] |= (unsigned int )(1 << (value & 31));
                      } else {
#line 73
                        cap_p->_blk[value >> 5] &= (unsigned int )(~ (1 << (value & 31)));
                      }
                    }
                  }
#line 62
                  i___0 ++;
                }
                while_break: /* CIL Label */ ;
                }
#line 77
                return (0);
              } else {
                {
#line 82
                tmp = __errno_location();
#line 82
                *tmp = 22;
                }
#line 83
                return (-1);
              }
            } else {
              {
#line 82
              tmp = __errno_location();
#line 82
              *tmp = 22;
              }
#line 83
              return (-1);
            }
          } else {
            {
#line 82
            tmp = __errno_location();
#line 82
            *tmp = 22;
            }
#line 83
            return (-1);
          }
        } else {
          {
#line 82
          tmp = __errno_location();
#line 82
          *tmp = 22;
          }
#line 83
          return (-1);
        }
      } else {
        {
#line 82
        tmp = __errno_location();
#line 82
        *tmp = 22;
        }
#line 83
        return (-1);
      }
    } else {
      {
#line 82
      tmp = __errno_location();
#line 82
      *tmp = 22;
      }
#line 83
      return (-1);
    }
  } else {
    {
#line 82
    tmp = __errno_location();
#line 82
    *tmp = 22;
    }
#line 83
    return (-1);
  }
}
}
#line 92 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_flag.c"
int cap_clear(cap_t cap_d ) 
{ 
  int *tmp ;

  {
#line 94
  if (cap_d) {
#line 94
    if (*((unsigned int *)cap_d + -1) == 13275344U) {
      {
#line 96
      memset((void *)(& cap_d->set), 0, (size_t )sizeof(cap_d->set));
      }
#line 97
      return (0);
    } else {
      {
#line 102
      tmp = __errno_location();
#line 102
      *tmp = 22;
      }
#line 103
      return (-1);
    }
  } else {
    {
#line 102
    tmp = __errno_location();
#line 102
    *tmp = 22;
    }
#line 103
    return (-1);
  }
}
}
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 87 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
ssize_t cap_size(cap_t caps ) ;
#line 88
ssize_t cap_copy_ext(void *cap_ext , cap_t cap_d , ssize_t length ) ;
#line 89
cap_t cap_copy_int(void const   *cap_ext ) ;
#line 20 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_extint.c"
static unsigned char const   external_magic[5]  = {      (unsigned char const   )'\220',      (unsigned char const   )'\302',      (unsigned char const   )'\001',      (unsigned char const   )'Q', 
        (unsigned char const   )'\000'};
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_extint.c"
ssize_t cap_size(cap_t caps ) 
{ 


  {
#line 36
  return ((ssize_t )sizeof(struct cap_ext_struct ));
}
}
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_extint.c"
ssize_t cap_copy_ext(void *cap_ext , cap_t cap_d , ssize_t length ) 
{ 
  struct cap_ext_struct *result ;
  unsigned int *from ;
  int i___0 ;
  int *tmp ;
  int j ;
  unsigned int val ;
  unsigned int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 47
  result = (struct cap_ext_struct *)cap_ext;
#line 48
  from = (unsigned int *)(& cap_d->set);
#line 52
  if (cap_d) {
#line 52
    if (*((unsigned int *)cap_d + -1) == 13275344U) {
#line 52
      if ((unsigned long )length < sizeof(struct cap_ext_struct )) {
        {
#line 54
        tmp = __errno_location();
#line 54
        *tmp = 22;
        }
#line 55
        return (-1);
      } else
#line 52
      if ((unsigned long )cap_ext == (unsigned long )((void *)0)) {
        {
#line 54
        tmp = __errno_location();
#line 54
        *tmp = 22;
        }
#line 55
        return (-1);
      }
    } else {
      {
#line 54
      tmp = __errno_location();
#line 54
      *tmp = 22;
      }
#line 55
      return (-1);
    }
  } else {
    {
#line 54
    tmp = __errno_location();
#line 54
    *tmp = 22;
    }
#line 55
    return (-1);
  }
  {
#line 59
  memcpy((void */* __restrict  */)(& result->magic), (void const   */* __restrict  */)(external_magic),
         (size_t )4);
#line 60
  result->length_of_capset = (unsigned char )(sizeof(struct __user_cap_data_struct ) / 3UL);
#line 62
  i___0 = 0;
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (i___0 < 3)) {
#line 62
      goto while_break;
    }
#line 64
    j = 0;
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! ((unsigned long )j < sizeof(struct __user_cap_data_struct ) / 3UL)) {
#line 64
        goto while_break___0;
      }
#line 65
      tmp___0 = from;
#line 65
      from ++;
#line 65
      val = *tmp___0;
#line 67
      tmp___1 = j;
#line 67
      j ++;
#line 67
      result->bytes[tmp___1][i___0] = (unsigned char )(val & 255U);
#line 68
      tmp___2 = j;
#line 68
      j ++;
#line 68
      val >>= 8;
#line 68
      result->bytes[tmp___2][i___0] = (unsigned char )(val & 255U);
#line 69
      tmp___3 = j;
#line 69
      j ++;
#line 69
      val >>= 8;
#line 69
      result->bytes[tmp___3][i___0] = (unsigned char )(val & 255U);
#line 70
      tmp___4 = j;
#line 70
      j ++;
#line 70
      result->bytes[tmp___4][i___0] = (unsigned char )((val >> 8) & 255U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 62
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return ((ssize_t )sizeof(struct cap_ext_struct ));
}
}
#line 88 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_extint.c"
cap_t cap_copy_int(void const   *cap_ext ) 
{ 
  struct cap_ext_struct  const  *export ;
  cap_t cap_d ;
  int set ;
  int blen ;
  unsigned int *to ;
  int *tmp ;
  int tmp___0 ;
  int blk ;
  int bno ;
  unsigned int val ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int *tmp___5 ;

  {
#line 90
  export = (struct cap_ext_struct  const  *)cap_ext;
#line 92
  cap_d = (cap_t )((void *)0);
#line 94
  to = (unsigned int *)(& cap_d->set);
#line 97
  if ((unsigned long )export == (unsigned long )((void *)0)) {
    {
#line 99
    tmp = __errno_location();
#line 99
    *tmp = 22;
    }
#line 100
    return ((cap_t )((void *)0));
  } else {
    {
#line 97
    tmp___0 = memcmp((void const   *)(export->magic), (void const   *)(external_magic),
                     (size_t )4);
    }
#line 97
    if (! tmp___0) {
      {
#line 99
      tmp = __errno_location();
#line 99
      *tmp = 22;
      }
#line 100
      return ((cap_t )((void *)0));
    }
  }
  {
#line 104
  cap_d = cap_init();
  }
#line 104
  if (! cap_d) {
#line 105
    return ((cap_t )((void *)0));
  }
#line 107
  blen = (int )export->length_of_capset;
#line 108
  set = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (set <= 3)) {
#line 108
      goto while_break;
    }
#line 110
    bno = 0;
#line 111
    blk = 0;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! ((unsigned long )blk < (sizeof(struct __user_cap_data_struct ) / 3UL) / 4UL)) {
#line 111
        goto while_break___0;
      }
#line 112
      val = 0U;
#line 114
      if (bno != blen) {
#line 115
        tmp___1 = bno;
#line 115
        bno ++;
#line 115
        val = (unsigned int )export->bytes[tmp___1][set];
      }
#line 116
      if (bno != blen) {
#line 117
        tmp___2 = bno;
#line 117
        bno ++;
#line 117
        val |= (unsigned int )((int )export->bytes[tmp___2][set] << 8);
      }
#line 118
      if (bno != blen) {
#line 119
        tmp___3 = bno;
#line 119
        bno ++;
#line 119
        val |= (unsigned int )((int )export->bytes[tmp___3][set] << 16);
      }
#line 120
      if (bno != blen) {
#line 121
        tmp___4 = bno;
#line 121
        bno ++;
#line 121
        val |= (unsigned int )((int )export->bytes[tmp___4][set] << 24);
      }
#line 123
      tmp___5 = to;
#line 123
      to ++;
#line 123
      *tmp___5 = val;
#line 111
      blk ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    set ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (cap_d);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/include/sys/capability.h"
cap_t cap_dup(cap_t cap_d ) ;
#line 19 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_alloc.c"
cap_t cap_init(void) 
{ 
  unsigned int *raw_data ;
  cap_t result ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 24
  tmp = malloc((size_t )(sizeof(unsigned int ) + sizeof(*result)));
#line 24
  raw_data = (unsigned int *)tmp;
  }
#line 26
  if ((unsigned long )raw_data == (unsigned long )((void *)0)) {
    {
#line 28
    tmp___0 = __errno_location();
#line 28
    *tmp___0 = 12;
    }
#line 29
    return ((cap_t )((void *)0));
  }
  {
#line 32
  *raw_data = 13275344U;
#line 33
  result = (cap_t )(raw_data + 1);
#line 34
  memset((void *)result, 0, (size_t )sizeof(*result));
#line 36
  result->head.version = (__u32 )429392688;
  }
#line 38
  return (result);
}
}
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_alloc.c"
char *_libcap_strdup(char const   *old ) 
{ 
  unsigned int *raw_data ;
  int *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  unsigned int *tmp___3 ;

  {
#line 50
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    {
#line 51
    tmp = __errno_location();
#line 51
    *tmp = 22;
    }
#line 52
    return ((char *)((void *)0));
  }
  {
#line 55
  tmp___0 = strlen(old);
#line 55
  tmp___1 = malloc((size_t )((sizeof(unsigned int ) + (unsigned long )tmp___0) + 1UL));
#line 55
  raw_data = (unsigned int *)tmp___1;
  }
#line 56
  if ((unsigned long )raw_data == (unsigned long )((void *)0)) {
    {
#line 57
    tmp___2 = __errno_location();
#line 57
    *tmp___2 = 12;
    }
#line 58
    return ((char *)((void *)0));
  }
  {
#line 61
  tmp___3 = raw_data;
#line 61
  raw_data ++;
#line 61
  *tmp___3 = 13276624U;
#line 62
  strcpy((char */* __restrict  */)((char *)raw_data), (char const   */* __restrict  */)old);
  }
#line 64
  return ((char *)raw_data);
}
}
#line 73 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_alloc.c"
cap_t cap_dup(cap_t cap_d ) 
{ 
  cap_t result ;
  int *tmp ;

  {
#line 77
  if (cap_d) {
#line 77
    if (! (*((unsigned int *)cap_d + -1) == 13275344U)) {
      {
#line 79
      tmp = __errno_location();
#line 79
      *tmp = 22;
      }
#line 80
      return ((cap_t )((void *)0));
    }
  } else {
    {
#line 79
    tmp = __errno_location();
#line 79
    *tmp = 22;
    }
#line 80
    return ((cap_t )((void *)0));
  }
  {
#line 83
  result = cap_init();
  }
#line 84
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 86
    return ((cap_t )((void *)0));
  }
  {
#line 89
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)cap_d,
         (size_t )sizeof(*cap_d));
  }
#line 91
  return (result);
}
}
#line 99 "/home/pronto/abs/test-suite/proftpd-1.3.2/lib/libcap/cap_alloc.c"
int cap_free(void *data_p ) 
{ 
  int length ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 102
  if (data_p) {
#line 102
    if (*((unsigned int *)data_p + -1) == 13275344U) {
      {
#line 103
      data_p = (void *)((unsigned int *)data_p + -1);
#line 104
      memset(data_p, 0, (size_t )(sizeof(unsigned int ) + sizeof(struct _cap_struct )));
#line 105
      free(data_p);
#line 106
      data_p = (void *)0;
      }
#line 107
      return (0);
    }
  }
#line 110
  if (data_p) {
#line 110
    if (*((unsigned int *)data_p + -1) == 13276624U) {
      {
#line 111
      tmp = strlen((char const   *)data_p);
#line 111
      length = (int )((unsigned long )tmp + sizeof(unsigned int ));
#line 112
      data_p = (void *)((unsigned int *)data_p + -1);
#line 113
      memset(data_p, 0, (size_t )length);
#line 114
      free(data_p);
#line 115
      data_p = (void *)0;
      }
#line 116
      return (0);
    }
  }
  {
#line 120
  tmp___0 = __errno_location();
#line 120
  *tmp___0 = 22;
  }
#line 121
  return (-1);
}
}
#line 7 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/module_glue.c"
module core_module ;
#line 8
module xfer_module ;
#line 9
module auth_unix_module ;
#line 10
module auth_file_module ;
#line 11
module auth_module ;
#line 12
module ls_module ;
#line 13
module log_module ;
#line 14
module site_module ;
#line 15
module delay_module ;
#line 16
module facts_module ;
#line 17
module ident_module ;
#line 18
module cap_module ;
#line 20 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/module_glue.c"
module *static_modules[13]  = 
#line 20
  {      & core_module,      & xfer_module,      & auth_unix_module,      & auth_file_module, 
        & auth_module,      & ls_module,      & log_module,      & site_module, 
        & delay_module,      & facts_module,      & ident_module,      & cap_module, 
        (module *)((void *)0)};
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/module_glue.c"
module *loaded_modules  =    (module *)((void *)0);
#line 672 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 256 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 331
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 51 "../include/pool.h"
void *pcalloc(struct pool *p , int sz ) ;
#line 36 "../include/str.h"
char *pstrcat(pool *p  , ...) ;
#line 192 "../include/proftpd.h"
extern session_t session ;
#line 249
void end_login(int exitcode ) ;
#line 63 "../include/support.h"
void pr_signals_block(void) ;
#line 64
void pr_signals_unblock(void) ;
#line 170 "../include/dirtree.h"
server_rec *main_server ;
#line 224
config_rec *add_config_param(char const   *name , int num  , ...) ;
#line 231
config_rec *find_config(xaset_t *set , int type , char const   *name , int recurse ) ;
#line 256
void *get_param_ptr(xaset_t *set , char const   *name , int recurse ) ;
#line 274
unsigned char check_context(cmd_rec *cmd , int allowed ) ;
#line 275
char *get_context_name(cmd_rec *cmd ) ;
#line 276
int get_boolean(cmd_rec *cmd , int av ) ;
#line 192 "../include/modules.h"
modret_t *mod_create_ret(cmd_rec *cmd , unsigned char err , char *n , char *m ) ;
#line 128 "../include/log.h"
void ( /* format attribute */  pr_log_pri)(int priority , char const   *fmt  , ...) ;
#line 142
void ( /* format attribute */  pr_log_debug)(int level , char const   *fmt  , ...) ;
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static cap_t capabilities  =    (cap_t )0;
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static unsigned char have_capabilities  =    (unsigned char)0;
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static unsigned char use_capabilities  =    (unsigned char)1;
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static unsigned int cap_flags  =    0U;
#line 70 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static void lp_debug(void) 
{ 
  char *res ;
  ssize_t len ;
  cap_t caps ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 75
  caps = cap_get_proc();
  }
#line 75
  if (! caps) {
    {
#line 76
    tmp = __errno_location();
#line 76
    tmp___0 = strerror(*tmp);
#line 76
    pr_log_pri(3, "mod_cap/1.0: cap_get_proc failed: %s", tmp___0);
    }
#line 78
    return;
  }
  {
#line 81
  res = cap_to_text(caps, & len);
  }
#line 81
  if (! res) {
    {
#line 82
    tmp___1 = __errno_location();
#line 82
    tmp___2 = strerror(*tmp___1);
#line 82
    pr_log_pri(3, "mod_cap/1.0: cap_to_text failed: %s", tmp___2);
#line 84
    tmp___5 = cap_free((void *)caps);
    }
#line 84
    if (tmp___5 < 0) {
      {
#line 85
      tmp___3 = __errno_location();
#line 85
      tmp___4 = strerror(*tmp___3);
#line 85
      pr_log_pri(5, "mod_cap/1.0: error freeing cap at line %d: %s", 84, tmp___4);
      }
    }
#line 87
    return;
  }
  {
#line 90
  pr_log_debug(1, "mod_cap/1.0: capabilities \'%s\'", res);
#line 91
  cap_free((void *)res);
#line 93
  tmp___8 = cap_free((void *)caps);
  }
#line 93
  if (tmp___8 < 0) {
    {
#line 94
    tmp___6 = __errno_location();
#line 94
    tmp___7 = strerror(*tmp___6);
#line 94
    pr_log_pri(5, "mod_cap/1.0: error freeing cap at line %d: %s", 93, tmp___7);
    }
  }
#line 96
  return;
}
}
#line 99 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static int lp_init_cap(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;

  {
  {
#line 101
  capabilities = cap_init();
  }
#line 101
  if (! capabilities) {
    {
#line 102
    tmp = __errno_location();
#line 102
    tmp___0 = strerror(*tmp);
#line 102
    pr_log_pri(3, "mod_cap/1.0: initializing cap failed: %s", tmp___0);
    }
#line 104
    return (-1);
  }
#line 107
  have_capabilities = (unsigned char)1;
#line 108
  return (0);
}
}
#line 112 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static void lp_free_cap(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;

  {
#line 113
  if (have_capabilities) {
    {
#line 114
    tmp___1 = cap_free((void *)capabilities);
    }
#line 114
    if (tmp___1 < 0) {
      {
#line 115
      tmp = __errno_location();
#line 115
      tmp___0 = strerror(*tmp);
#line 115
      pr_log_pri(5, "mod_cap/1.0: error freeing cap at line %d: %s", 114, tmp___0);
      }
    }
  }
#line 118
  return;
}
}
#line 121 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static int lp_add_cap(cap_value_t cap , cap_flag_t set ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 122
  tmp___1 = cap_set_flag(capabilities, set, 1, & cap, (cap_flag_value_t )1);
  }
#line 122
  if (tmp___1 == -1) {
    {
#line 123
    tmp = __errno_location();
#line 123
    tmp___0 = strerror(*tmp);
#line 123
    pr_log_pri(3, "mod_cap/1.0: cap_set_flag failed: %s", tmp___0);
    }
#line 125
    return (-1);
  }
#line 128
  return (0);
}
}
#line 132 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static int lp_set_cap(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
#line 133
  tmp___1 = cap_set_proc(capabilities);
  }
#line 133
  if (tmp___1 == -1) {
    {
#line 134
    tmp = __errno_location();
#line 134
    tmp___0 = strerror(*tmp);
#line 134
    pr_log_pri(3, "mod_cap/1.0: cap_set_proc failed: %s", tmp___0);
    }
#line 136
    return (-1);
  }
#line 139
  return (0);
}
}
#line 145 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static modret_t *set_caps(cmd_rec *cmd ) 
{ 
  unsigned int flags ;
  config_rec *c ;
  register unsigned int i___0 ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *cp ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  modret_t *tmp___15 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 146
  flags = 0U;
#line 147
  c = (config_rec *)((void *)0);
#line 148
  i___0 = 0U;
#line 150
  if (cmd->argc - 1 < 1) {
    {
#line 151
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "need at least one parameter",
                  (void *)0);
#line 151
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 151
    return (tmp___0);
  }
  {
#line 153
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 153
  if (! tmp___5) {
    {
#line 153
    tmp___1 = get_context_name(cmd);
#line 153
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 153
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 153
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 153
    return (tmp___4);
  }
#line 156
  flags |= 1U;
#line 158
  i___0 = 1U;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 158
      goto while_break;
    }
#line 159
    cp = *(cmd->argv + i___0);
#line 160
    cp ++;
#line 162
    if ((int )*(*(cmd->argv + i___0)) != 43) {
#line 162
      if ((int )*(*(cmd->argv + i___0)) != 45) {
        {
#line 163
        tmp___6 = pstrcat(cmd->tmp_pool, ": bad option: \'", *(cmd->argv + i___0),
                          "\'", (void *)0);
#line 163
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 163
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 163
        return (tmp___8);
      }
    }
    {
#line 166
    tmp___14 = strcasecmp((char const   *)cp, "CAP_CHOWN");
    }
#line 166
    if (tmp___14 == 0) {
#line 167
      if ((int )*(*(cmd->argv + i___0)) == 45) {
#line 168
        flags &= 4294967294U;
      }
    } else {
      {
#line 170
      tmp___13 = strcasecmp((char const   *)cp, "CAP_DAC_OVERRIDE");
      }
#line 170
      if (tmp___13 == 0) {
#line 171
        if ((int )*(*(cmd->argv + i___0)) == 43) {
#line 172
          flags |= 2U;
        }
      } else {
        {
#line 174
        tmp___12 = strcasecmp((char const   *)cp, "CAP_DAC_READ_SEARCH");
        }
#line 174
        if (tmp___12 == 0) {
#line 175
          if ((int )*(*(cmd->argv + i___0)) == 43) {
#line 176
            flags |= 4U;
          }
        } else {
          {
#line 179
          tmp___9 = pstrcat(cmd->tmp_pool, "unknown capability: \'", cp, "\'", (void *)0);
#line 179
          tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___9, (void *)0);
#line 179
          tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
          }
#line 179
          return (tmp___11);
        }
      }
    }
#line 158
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 184
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 185
  *((unsigned int *)*(c->argv + 0)) = flags;
#line 187
  tmp___15 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 187
  return (tmp___15);
}
}
#line 190 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static modret_t *set_capengine(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 191
  bool = -1;
#line 192
  c = (config_rec *)((void *)0);
#line 194
  if (cmd->argc - 1 < 1) {
    {
#line 194
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 194
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 194
    return (tmp___0);
  }
  {
#line 195
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 195
  if (! tmp___5) {
    {
#line 195
    tmp___1 = get_context_name(cmd);
#line 195
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 195
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 195
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 195
    return (tmp___4);
  }
  {
#line 197
  bool = get_boolean(cmd, 1);
  }
#line 198
  if (bool == -1) {
    {
#line 199
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expecting Boolean parameter",
                      (void *)0);
#line 199
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 199
    return (tmp___7);
  }
  {
#line 201
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 202
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 203
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 205
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 205
  return (tmp___8);
}
}
#line 215 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static modret_t *cap_post_pass(cmd_rec *cmd ) 
{ 
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 218
  if (! use_capabilities) {
#line 219
    return ((modret_t *)((void *)0));
  }
  {
#line 221
  pr_signals_block();
#line 228
  tmp___1 = setreuid(session.uid, (__uid_t )0);
  }
#line 228
  if (tmp___1 == -1) {
    {
#line 229
    tmp = __errno_location();
#line 229
    tmp___0 = strerror(*tmp);
#line 229
    pr_log_pri(3, "mod_cap/1.0: setreuid: %s", tmp___0);
#line 230
    pr_signals_unblock();
    }
#line 231
    return ((modret_t *)((void *)0));
  }
  {
#line 241
  res = lp_init_cap();
  }
#line 242
  if (res != -1) {
    {
#line 243
    res = lp_add_cap(10, (cap_flag_t )1);
    }
  }
#line 246
  if (res != -1) {
#line 246
    if (cap_flags & 1U) {
      {
#line 247
      res = lp_add_cap(0, (cap_flag_t )1);
      }
    }
  }
#line 249
  if (res != -1) {
#line 249
    if (cap_flags & 2U) {
      {
#line 250
      res = lp_add_cap(1, (cap_flag_t )1);
      }
    }
  }
#line 252
  if (res != -1) {
#line 252
    if (cap_flags & 4U) {
      {
#line 253
      res = lp_add_cap(2, (cap_flag_t )1);
      }
    }
  }
#line 255
  if (res != -1) {
    {
#line 256
    res = lp_set_cap();
    }
  }
  {
#line 258
  tmp___4 = setreuid((__uid_t )0, session.uid);
  }
#line 258
  if (tmp___4 == -1) {
    {
#line 259
    tmp___2 = __errno_location();
#line 259
    tmp___3 = strerror(*tmp___2);
#line 259
    pr_log_pri(3, "mod_cap/1.0: setreuid: %s", tmp___3);
#line 260
    lp_free_cap();
#line 261
    pr_signals_unblock();
#line 262
    end_login(1);
    }
  }
  {
#line 264
  pr_signals_unblock();
  }
#line 271
  if (res != -1) {
    {
#line 272
    res = lp_add_cap(10, (cap_flag_t )0);
    }
  }
#line 275
  if (res != -1) {
#line 275
    if (cap_flags & 1U) {
      {
#line 276
      res = lp_add_cap(0, (cap_flag_t )0);
      }
    }
  }
#line 278
  if (res != -1) {
#line 278
    if (cap_flags & 2U) {
      {
#line 279
      res = lp_add_cap(1, (cap_flag_t )0);
      }
    }
  }
#line 281
  if (res != -1) {
#line 281
    if (cap_flags & 4U) {
      {
#line 282
      res = lp_add_cap(2, (cap_flag_t )0);
      }
    }
  }
#line 284
  if (res != -1) {
    {
#line 285
    res = lp_set_cap();
    }
  }
  {
#line 287
  lp_free_cap();
  }
#line 289
  if (res != -1) {
    {
#line 291
    session.disable_id_switching = 1;
#line 292
    lp_debug();
    }
  } else {
    {
#line 295
    pr_log_pri(5, "mod_cap/1.0: attempt to configure capabilities failed, reverting to normal operation");
    }
  }
#line 298
  return ((modret_t *)((void *)0));
}
}
#line 304 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static int cap_sess_init(void) 
{ 
  unsigned char *cap_engine ;
  void *tmp ;
  config_rec *c ;
  config_rec *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 308
  if (use_capabilities) {
    {
#line 309
    tmp = get_param_ptr(main_server->conf, "CapabilitiesEngine", 0);
#line 309
    cap_engine = (unsigned char *)tmp;
    }
#line 312
    if (cap_engine) {
#line 312
      if ((int )*cap_engine == 0) {
        {
#line 313
        pr_log_debug(3, "mod_cap/1.0: lowering of capabilities disabled");
#line 315
        use_capabilities = (unsigned char)0;
        }
      }
    }
  }
#line 320
  if (use_capabilities) {
    {
#line 321
    tmp___0 = find_config(main_server->conf, 1 << 15, "CapabilitiesSet", 0);
#line 321
    c = tmp___0;
    }
#line 324
    if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 325
      cap_flags = *((unsigned int *)*(c->argv + 0));
#line 327
      if (! (cap_flags & 1U)) {
        {
#line 328
        pr_log_debug(3, "mod_cap/1.0: removing CAP_CHOWN capability");
        }
      }
#line 331
      if (cap_flags & 2U) {
        {
#line 332
        pr_log_debug(3, "mod_cap/1.0: adding CAP_DAC_OVERRIDE capability");
        }
      }
#line 335
      if (cap_flags & 4U) {
        {
#line 336
        pr_log_debug(3, "mod_cap/1.0: adding CAP_DAC_READ_SEARCH capability");
        }
      }
    }
  }
#line 341
  return (0);
}
}
#line 344 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static int cap_module_init(void) 
{ 
  cap_t res ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 351
  res = cap_get_proc();
  }
#line 352
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 352
    tmp = __errno_location();
    }
#line 352
    if (*tmp == 38) {
      {
#line 353
      pr_log_debug(2, "mod_cap/1.0: kernel does not support capabilities, disabling module");
#line 355
      use_capabilities = (unsigned char)0;
      }
    }
  }
#line 358
  if (res) {
    {
#line 358
    tmp___2 = cap_free((void *)res);
    }
#line 358
    if (tmp___2 < 0) {
      {
#line 359
      tmp___0 = __errno_location();
#line 359
      tmp___1 = strerror(*tmp___0);
#line 359
      pr_log_pri(5, "mod_cap/1.0: error freeing cap at line %d: %s", 358, tmp___1);
      }
    }
  }
#line 362
  return (0);
}
}
#line 369 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static conftable cap_conftab[3]  = {      {(char *)"CapabilitiesEngine", & set_capengine, (module *)((void *)0)}, 
        {(char *)"CapabilitiesSet", & set_caps, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)((void *)0)}};
#line 375 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
static cmdtable cap_cmdtab[2]  = {      {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & cap_post_pass, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 380 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_cap.c"
module cap_module  = 
#line 380
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"cap", cap_conftab,
    cap_cmdtab, (authtable *)((void *)0), & cap_module_init, & cap_sess_init, (char *)"mod_cap/1.0",
    (void *)0, 0};
#line 42 "../include/pool.h"
struct pool *make_sub_pool(struct pool *p ) ;
#line 46
void destroy_pool(struct pool *p ) ;
#line 37 "../include/str.h"
char *pstrdup(pool *p , char const   *str ) ;
#line 41
char *pr_str_strip_end(char *s , char *ch ) ;
#line 47
char *pr_str_get_token(char **s , char *sep ) ;
#line 66 "../include/table.h"
int pr_table_add_dup(pr_table_t *tab , char const   *key_data , void *value_data ,
                     size_t value_datasz ) ;
#line 250 "../include/proftpd.h"
void pr_signals_handle(void) ;
#line 145 "../include/netio.h"
void pr_netio_abort(pr_netio_stream_t *nstrm___0 ) ;
#line 148
int pr_netio_close(pr_netio_stream_t *nstrm___0 ) ;
#line 152
char *pr_netio_gets(char *buf___2 , size_t buflen , pr_netio_stream_t *nstrm___0 ) ;
#line 154
pr_netio_stream_t *pr_netio_open(pool *parent_pool , int strm_type , int fd___0 ,
                                 int mode ) ;
#line 158
int pr_netio_printf(pr_netio_stream_t *nstrm___0 , char const   *fmt  , ...) ;
#line 178
int pr_netio_poll(pr_netio_stream_t *nstrm___0 ) ;
#line 208
void pr_netio_set_poll_interval(pr_netio_stream_t *nstrm___0 , unsigned int secs ) ;
#line 43 "../include/timers.h"
int pr_timer_add(int seconds , int timerno , module *mod , int (*cb)(unsigned long p1 ,
                                                                     unsigned long p2 ,
                                                                     unsigned long p3 ,
                                                                     void *data ) ,
                 char const   *desc ) ;
#line 52
int pr_timer_remove(int timerno , module *mod ) ;
#line 137 "../include/inet.h"
int pr_inet_getservport(pool *p , char const   *serv , char const   *proto ) ;
#line 141
conn_t *pr_inet_create_connection(pool *p , xaset_t *servers , int fd___0 , pr_netaddr_t *bind_addr ,
                                  int port , int retry_bind ) ;
#line 145
void pr_inet_close(pool *p , conn_t *c ) ;
#line 151
int pr_inet_set_nonblock(pool *p , conn_t *c ) ;
#line 158
int pr_inet_connect_nowait(pool *p , conn_t *c , pr_netaddr_t *addr , int port ) ;
#line 159
int pr_inet_get_conn_info(conn_t *c , int fd___0 ) ;
#line 161
conn_t *pr_inet_openrw(pool *p , conn_t *c , pr_netaddr_t *addr , int strm_type ,
                       int fd___0 , int rfd , int wfd , int resolve ) ;
#line 335 "../include/netaddr.h"
char const   *pr_netaddr_get_ipstr(pr_netaddr_t *na ) ;
#line 36 "../include/trace.h"
int ( /* format attribute */  pr_trace_msg)(char const   *channel , int level , char const   *fmt 
                                            , ...) ;
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static int ident_engine  =    1;
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static pr_netio_stream_t *ident_nstrm  =    (pr_netio_stream_t *)((void *)0);
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static int ident_timeout_triggered  =    0;
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static char const   *trace_channel  =    "ident";
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static int ident_timeout_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                            void *data ) 
{ 


  {
#line 48
  ident_timeout_triggered = 1;
#line 50
  if (ident_nstrm) {
    {
#line 55
    pr_netio_abort(ident_nstrm);
    }
  }
#line 58
  return (0);
}
}
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static char *ident_lookup(pool *p , conn_t *conn ) 
{ 
  conn_t *ident_conn ;
  conn_t *ident_io ;
  char buf___2[256] ;
  char *ident ;
  int timerno ;
  int res ;
  int ident_port ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int xerrno ;
  int *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int xerrno___0 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int xerrno___1 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int xerrno___2 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char const   *tmp___21 ;
  char *tok ;
  char *tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  int tmp___25 ;
  unsigned short const   **tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
  {
#line 62
  ident_conn = (conn_t *)((void *)0);
#line 62
  ident_io = (conn_t *)((void *)0);
#line 63
  ident = (char *)((void *)0);
#line 64
  res = 0;
#line 65
  tmp = pr_inet_getservport(p, "ident", "tcp");
#line 65
  ident_port = tmp;
#line 67
  ident_nstrm = (pr_netio_stream_t *)((void *)0);
#line 68
  ident_timeout_triggered = 0;
  }
#line 70
  if (ident_port == -1) {
#line 71
    return ((char *)((void *)0));
  }
  {
#line 74
  timerno = pr_timer_add(10, -1, & ident_module, & ident_timeout_cb, "ident (RFC1413) lookup");
  }
#line 76
  if (timerno <= 0) {
    {
#line 77
    tmp___0 = __errno_location();
#line 77
    tmp___1 = strerror(*tmp___0);
#line 77
    pr_trace_msg(trace_channel, 8, "error adding timer: %s", tmp___1);
    }
#line 78
    return ((char *)((void *)0));
  }
  {
#line 81
  ident_conn = pr_inet_create_connection(p, (xaset_t *)((void *)0), -1, conn->local_addr,
                                         0, 0);
  }
#line 83
  if ((unsigned long )ident_conn == (unsigned long )((void *)0)) {
    {
#line 84
    tmp___2 = __errno_location();
#line 84
    tmp___3 = strerror(*tmp___2);
#line 84
    pr_trace_msg(trace_channel, 3, "error creating connection: %s", tmp___3);
    }
#line 86
    return ((char *)((void *)0));
  }
  {
#line 89
  pr_inet_set_nonblock(p, ident_conn);
#line 91
  res = pr_inet_connect_nowait(p, ident_conn, conn->remote_addr, ident_port);
  }
#line 93
  if (res < 0) {
    {
#line 94
    tmp___4 = __errno_location();
#line 94
    xerrno = *tmp___4;
#line 96
    pr_timer_remove(timerno, & ident_module);
#line 97
    pr_inet_close(p, ident_conn);
#line 99
    tmp___5 = strerror(xerrno);
#line 99
    tmp___6 = pr_netaddr_get_ipstr(conn->remote_addr);
#line 99
    pr_trace_msg(trace_channel, 5, "connection to %s, port %d failed: %s", tmp___6,
                 ident_port, tmp___5);
#line 102
    tmp___7 = __errno_location();
#line 102
    *tmp___7 = xerrno;
    }
#line 103
    return ((char *)((void *)0));
  }
#line 106
  if (res == 0) {
    {
#line 108
    ident_nstrm = pr_netio_open(p, 64, ident_conn->listen_fd, 1);
    }
#line 110
    if ((unsigned long )ident_nstrm == (unsigned long )((void *)0)) {
      {
#line 111
      tmp___8 = __errno_location();
#line 111
      tmp___9 = strerror(*tmp___8);
#line 111
      pr_trace_msg(trace_channel, 5, "error opening NetIO stream: %s", tmp___9);
      }
#line 113
      return ((char *)((void *)0));
    }
    {
#line 116
    pr_netio_set_poll_interval(ident_nstrm, 1U);
#line 118
    tmp___10 = pr_netio_poll(ident_nstrm);
    }
    {
#line 119
    if (tmp___10 == 1) {
#line 119
      goto case_1;
    }
#line 136
    if (tmp___10 == -1) {
#line 136
      goto case_neg_1;
    }
#line 153
    goto switch_default;
    case_1: /* CIL Label */ 
#line 121
    if (ident_timeout_triggered) {
      {
#line 122
      pr_netio_close(ident_nstrm);
#line 123
      ident_nstrm = (pr_netio_stream_t *)((void *)0);
#line 125
      pr_inet_close(p, ident_conn);
#line 126
      pr_timer_remove(timerno, & ident_module);
#line 128
      pr_trace_msg(trace_channel, 5, "ident lookup timed out after %u secs", 10);
      }
#line 130
      return ((char *)((void *)0));
    }
#line 133
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 138
    tmp___11 = __errno_location();
#line 138
    xerrno___0 = *tmp___11;
#line 140
    pr_netio_close(ident_nstrm);
#line 141
    ident_nstrm = (pr_netio_stream_t *)((void *)0);
#line 143
    pr_inet_close(p, ident_conn);
#line 144
    pr_timer_remove(timerno, & ident_module);
#line 146
    tmp___12 = strerror(xerrno___0);
#line 146
    pr_trace_msg(trace_channel, 6, "ident lookup failed: %s", tmp___12);
#line 149
    tmp___13 = __errno_location();
#line 149
    *tmp___13 = xerrno___0;
    }
#line 150
    return ((char *)((void *)0));
    switch_default: /* CIL Label */ 
    {
#line 155
    ident_conn->mode = 2;
#line 157
    tmp___17 = pr_inet_get_conn_info(ident_conn, ident_conn->listen_fd);
    }
#line 157
    if (tmp___17 < 0) {
      {
#line 158
      tmp___14 = __errno_location();
#line 158
      xerrno___1 = *tmp___14;
#line 160
      pr_netio_close(ident_nstrm);
#line 161
      ident_nstrm = (pr_netio_stream_t *)((void *)0);
#line 163
      pr_inet_close(p, ident_conn);
#line 164
      pr_timer_remove(timerno, & ident_module);
#line 166
      tmp___15 = strerror(xerrno___1);
#line 166
      pr_trace_msg(trace_channel, 3, "error retrieving ident peer details: %s", tmp___15);
#line 169
      tmp___16 = __errno_location();
#line 169
      *tmp___16 = xerrno___1;
      }
#line 170
      return ((char *)((void *)0));
    }
#line 173
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 178
  ident_io = pr_inet_openrw(p, ident_conn, (pr_netaddr_t *)((void *)0), 64, -1, -1,
                            -1, 0);
  }
#line 180
  if ((unsigned long )ident_io == (unsigned long )((void *)0)) {
    {
#line 181
    tmp___18 = __errno_location();
#line 181
    xerrno___2 = *tmp___18;
#line 183
    pr_netio_close(ident_nstrm);
#line 184
    ident_nstrm = (pr_netio_stream_t *)((void *)0);
#line 186
    pr_inet_close(p, ident_conn);
#line 187
    pr_timer_remove(timerno, & ident_module);
#line 189
    tmp___19 = strerror(xerrno___2);
#line 189
    pr_trace_msg(trace_channel, 3, "failed opening read/write connection: %s", tmp___19);
#line 192
    tmp___20 = __errno_location();
#line 192
    *tmp___20 = xerrno___2;
    }
#line 193
    return ((char *)((void *)0));
  }
  {
#line 196
  ident_nstrm = ident_io->instrm;
#line 198
  pr_inet_set_nonblock(p, ident_io);
#line 199
  pr_netio_set_poll_interval(ident_io->instrm, 1U);
#line 200
  pr_netio_set_poll_interval(ident_io->outstrm, 1U);
#line 202
  pr_netio_printf(ident_io->outstrm, "%d, %d\r\n", conn->remote_port, conn->local_port);
#line 205
  tmp___21 = pr_netaddr_get_ipstr(conn->remote_addr);
#line 205
  pr_trace_msg(trace_channel, 4, "reading response from ident server at %s", tmp___21);
#line 215
  tmp___29 = pr_netio_gets(buf___2, (size_t )sizeof(buf___2), ident_io->instrm);
  }
#line 215
  if (tmp___29) {
    {
#line 216
    tok = (char *)((void *)0);
#line 216
    tmp___22 = (char *)((void *)0);
#line 218
    pr_str_strip_end(buf___2, (char *)"\r\n");
#line 220
    pr_trace_msg(trace_channel, 6, "received \'%s\' from ident server", buf___2);
#line 222
    tmp___22 = buf___2;
#line 223
    tok = pr_str_get_token(& tmp___22, (char *)":");
    }
#line 224
    if (tok) {
      {
#line 224
      tok = pr_str_get_token(& tmp___22, (char *)":");
      }
#line 224
      if (tok) {
        {
#line 226
        while (1) {
          while_continue: /* CIL Label */ ;
#line 226
          if (*tok) {
            {
#line 226
            tmp___23 = __ctype_b_loc();
            }
#line 226
            if (! ((int const   )*(*tmp___23 + (int )*tok) & 8192)) {
#line 226
              goto while_break;
            }
          } else {
#line 226
            goto while_break;
          }
          {
#line 227
          pr_signals_handle();
#line 228
          tok ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 231
        pr_str_strip_end(tok, (char *)" \t");
#line 233
        tmp___28 = strcasecmp((char const   *)tok, "ERROR");
        }
#line 233
        if (tmp___28 == 0) {
#line 234
          if (tmp___22) {
            {
#line 235
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 235
              if (*tmp___22) {
                {
#line 235
                tmp___24 = __ctype_b_loc();
                }
#line 235
                if (! ((int const   )*(*tmp___24 + (int )*tmp___22) & 8192)) {
#line 235
                  goto while_break___0;
                }
              } else {
#line 235
                goto while_break___0;
              }
              {
#line 236
              pr_signals_handle();
#line 237
              tmp___22 ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 240
            pr_str_strip_end(tmp___22, (char *)" \t");
#line 242
            tmp___25 = strcasecmp((char const   *)tmp___22, "HIDDEN-USER");
            }
#line 242
            if (tmp___25 == 0) {
#line 243
              ident = (char *)"HIDDEN-USER";
            }
          }
        } else {
          {
#line 246
          tmp___27 = strcasecmp((char const   *)tok, "USERID");
          }
#line 246
          if (tmp___27 == 0) {
#line 247
            if (tmp___22) {
              {
#line 247
              tok = pr_str_get_token(& tmp___22, (char *)":");
              }
#line 247
              if (tok) {
#line 249
                if (tmp___22) {
                  {
#line 250
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 250
                    if (*tmp___22) {
                      {
#line 250
                      tmp___26 = __ctype_b_loc();
                      }
#line 250
                      if (! ((int const   )*(*tmp___26 + (int )*tmp___22) & 8192)) {
#line 250
                        goto while_break___1;
                      }
                    } else {
#line 250
                      goto while_break___1;
                    }
                    {
#line 251
                    pr_signals_handle();
#line 252
                    tmp___22 ++;
                    }
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                  {
#line 255
                  pr_str_strip_end(tmp___22, (char *)" \t");
#line 256
                  ident = tmp___22;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 263
  pr_inet_close(p, ident_io);
#line 264
  pr_inet_close(p, ident_conn);
#line 265
  pr_timer_remove(timerno, & ident_module);
#line 267
  tmp___30 = pstrdup(p, (char const   *)ident);
  }
#line 267
  return (tmp___30);
}
}
#line 274 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static modret_t *set_identlookups(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 275
  bool = -1;
#line 276
  c = (config_rec *)((void *)0);
#line 278
  if (cmd->argc - 1 < 1) {
    {
#line 278
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 278
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 278
    return (tmp___0);
  }
  {
#line 279
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 279
  if (! tmp___5) {
    {
#line 279
    tmp___1 = get_context_name(cmd);
#line 279
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 279
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 279
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 279
    return (tmp___4);
  }
  {
#line 281
  bool = get_boolean(cmd, 1);
  }
#line 282
  if (bool == -1) {
    {
#line 283
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 283
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 283
    return (tmp___7);
  }
  {
#line 285
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 286
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 287
  *((int *)*(c->argv + 0)) = bool;
#line 289
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 289
  return (tmp___8);
}
}
#line 295 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static int ident_sess_init(void) 
{ 
  pool *tmp_pool ;
  config_rec *c ;
  char *ident ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 296
  tmp_pool = (pool *)((void *)0);
#line 298
  ident = (char *)((void *)0);
#line 300
  c = find_config(main_server->conf, 1 << 15, "IdentLookups", 0);
  }
#line 301
  if (c) {
#line 302
    ident_engine = *((int *)*(c->argv + 0));
  }
#line 304
  if (! ident_engine) {
    {
#line 305
    pr_log_debug(6, "mod_ident/1.0: ident lookup disabled");
    }
#line 306
    return (0);
  }
  {
#line 309
  tmp_pool = make_sub_pool(session.pool);
#line 312
  pr_log_debug(6, "mod_ident/1.0: performing ident lookup");
#line 314
  ident = ident_lookup(tmp_pool, session.c);
  }
#line 315
  if (ident) {
    {
#line 316
    pr_log_debug(6, "mod_ident/1.0: ident lookup returned \'%s\'", ident);
    }
  } else {
    {
#line 320
    ident = (char *)"UNKNOWN";
#line 321
    pr_log_debug(6, "mod_ident/1.0: ident lookup failed, using \'%s\'", ident);
    }
  }
  {
#line 328
  tmp___1 = pr_table_add_dup(session.notes, "mod_ident.rfc1413-ident", (void *)ident,
                             (size_t )0);
  }
#line 328
  if (tmp___1 < 0) {
    {
#line 330
    tmp = __errno_location();
#line 330
    tmp___0 = strerror(*tmp);
#line 330
    pr_log_debug(3, "mod_ident/1.0: error stashing \'mod_ident.rfc1413-ident\' value \'%s\': %s",
                 ident, tmp___0);
    }
  }
  {
#line 335
  destroy_pool(tmp_pool);
  }
#line 336
  return (0);
}
}
#line 342 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
static conftable ident_conftab[2]  = {      {(char *)"IdentLookups", & set_identlookups, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))0, (module *)0}};
#line 347 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ident.c"
module ident_module  = 
#line 347
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"ident", ident_conftab,
    (cmdtable *)((void *)0), (authtable *)((void *)0), (int (*)(void))((void *)0),
    & ident_sess_init, (char *)"mod_ident/1.0", (void *)0, 0};
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 191
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 335
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 194 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 32 "../include/str.h"
char *sstrcat(char *dst , char const   *src , size_t n ) ;
#line 35
char *pdircat(pool *p  , ...) ;
#line 541 "/usr/include/regex.h"
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 92 "../include/support.h"
struct tm *pr_gmtime(pool *p , time_t const   *t ) ;
#line 265 "../include/dirtree.h"
int dir_check(pool *pp , char *cmd , char *group , char *path , int *hidden ) ;
#line 77 "../include/auth.h"
gid_t pr_auth_name2gid(pool *p , char const   *name ) ;
#line 44 "../include/response.h"
void ( /* format attribute */  pr_response_add)(char const   *numeric , char const   *fmt 
                                                , ...) ;
#line 51
void ( /* format attribute */  pr_response_add_err)(char const   *numeric , char const   *fmt 
                                                    , ...) ;
#line 97
void ( /* format attribute */  pr_response_send_raw)(char const   *fmt  , ...) ;
#line 32 "../include/help.h"
void pr_help_add(char const   *cmd , char const   *syntax , int impl ) ;
#line 32 "../include/feat.h"
int pr_feat_add(char const   *feat ) ;
#line 33
char const   *pr_feat_get(void) ;
#line 34
char const   *pr_feat_get_next(void) ;
#line 35
int pr_feat_remove(char const   *feat ) ;
#line 36 "../include/data.h"
int pr_data_open(char *filename , char *reason , int direction , off_t___0 size ) ;
#line 37
void pr_data_close(int quiet___0 ) ;
#line 38
void pr_data_abort(int err , int quiet___0 ) ;
#line 39
int pr_data_xfer(char *cl_buf , int cl_size ) ;
#line 233 "../include/fsio.h"
int pr_fsio_stat(char const   *path , struct stat *sbuf___0 ) ;
#line 242
void *pr_fsio_opendir(char const   *path ) ;
#line 243
int pr_fsio_closedir(void *dir ) ;
#line 244
struct dirent *pr_fsio_readdir(void *dir ) ;
#line 265
int pr_fsio_chmod(char const   *name , mode_t mode ) ;
#line 268
int pr_fsio_chown(char const   *name , uid_t uid , gid_t gid ) ;
#line 272
int pr_fsio_access(char const   *path , int mode , uid_t uid , gid_t gid , array_header *suppl_gids ) ;
#line 274
int pr_fsio_utimes(char const   *path , struct timeval *tvs ) ;
#line 304
void pr_fs_clear_cache(void) ;
#line 307
char const   *pr_fs_getcwd(void) ;
#line 313
char *pr_fs_decode_path(pool *p , char const   *path ) ;
#line 314
char *pr_fs_encode_path(pool *p , char const   *path ) ;
#line 35 "../include/env.h"
char *pr_env_get(pool *p , char const   *key ) ;
#line 45
int pr_env_set(pool *p , char const   *key , char const   *value ) ;
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static unsigned long facts_opts  =    0UL;
#line 58
static void facts_mlinfobuf_flush(void) ;
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_filters_allow_path(cmd_rec *cmd , char const   *path ) 
{ 
  regex_t *preg ;
  xaset_t *tmp ;
  xaset_t *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  xaset_t *tmp___3 ;
  xaset_t *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 65
  if (session.dir_config) {
#line 65
    tmp___0 = (session.dir_config)->subset;
  } else {
#line 65
    if (session.anon_config) {
#line 65
      tmp = (session.anon_config)->subset;
    } else {
#line 65
      tmp = main_server->conf;
    }
#line 65
    tmp___0 = tmp;
  }
  {
#line 65
  tmp___1 = get_param_ptr(tmp___0, "PathAllowFilter", 0);
#line 65
  preg = (regex_t *)tmp___1;
  }
#line 67
  if (preg) {
    {
#line 67
    tmp___2 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 67
    if (tmp___2 != 0) {
      {
#line 69
      pr_log_debug(2, "mod_facts/0.1: %s denied by PathAllowFilter on \'%s\'", *(cmd->argv + 0),
                   cmd->arg);
      }
#line 71
      return (-1);
    }
  }
#line 74
  if (session.dir_config) {
#line 74
    tmp___4 = (session.dir_config)->subset;
  } else {
#line 74
    if (session.anon_config) {
#line 74
      tmp___3 = (session.anon_config)->subset;
    } else {
#line 74
      tmp___3 = main_server->conf;
    }
#line 74
    tmp___4 = tmp___3;
  }
  {
#line 74
  tmp___5 = get_param_ptr(tmp___4, "PathDenyFilter", 0);
#line 74
  preg = (regex_t *)tmp___5;
  }
#line 76
  if (preg) {
    {
#line 76
    tmp___6 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 76
    if (tmp___6 == 0) {
      {
#line 78
      pr_log_debug(2, "mod_facts/0.1: %s denied by PathDenyFilter on \'%s\'", *(cmd->argv + 0),
                   cmd->arg);
      }
#line 80
      return (-1);
    }
  }
#line 84
  return (0);
}
}
#line 87 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static time_t facts_mktime(unsigned int year , unsigned int month , unsigned int mday ,
                           unsigned int hour , unsigned int min , unsigned int sec ) 
{ 
  struct tm tm ;
  time_t res ;
  char *env ;
  char *tzname_dup[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 116
  memcpy((void */* __restrict  */)(& tzname_dup), (void const   */* __restrict  */)(tzname),
         (size_t )sizeof(tzname_dup));
#line 119
  env = pr_env_get(session.pool, "TZ");
#line 124
  tmp___1 = pr_env_set(session.pool, "TZ", "GMT");
  }
#line 124
  if (tmp___1 < 0) {
    {
#line 125
    tmp = __errno_location();
#line 125
    tmp___0 = strerror(*tmp);
#line 125
    pr_log_debug(8, "mod_facts/0.1: error setting TZ environment variable to \'GMT\': %s",
                 tmp___0);
    }
  }
  {
#line 129
  tm.tm_sec = (int )sec;
#line 130
  tm.tm_min = (int )min;
#line 131
  tm.tm_hour = (int )hour;
#line 132
  tm.tm_mday = (int )mday;
#line 133
  tm.tm_mon = (int )(month - 1U);
#line 134
  tm.tm_year = (int )(year - 1900U);
#line 135
  tm.tm_wday = 0;
#line 136
  tm.tm_yday = 0;
#line 137
  tm.tm_isdst = -1;
#line 139
  res = mktime(& tm);
  }
#line 142
  if (env) {
    {
#line 143
    tmp___4 = pr_env_set(session.pool, "TZ", (char const   *)env);
    }
#line 143
    if (tmp___4 < 0) {
      {
#line 144
      tmp___2 = __errno_location();
#line 144
      tmp___3 = strerror(*tmp___2);
#line 144
      pr_log_debug(8, "mod_facts/0.1: error setting TZ environment variable to \'%s\': %s",
                   env, tmp___3);
      }
    }
  }
  {
#line 152
  memcpy((void */* __restrict  */)(tzname), (void const   */* __restrict  */)(tzname_dup),
         (size_t )sizeof(tzname_dup));
  }
#line 155
  return (res);
}
}
#line 158 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static size_t facts_mlinfo_fmt(struct mlinfo *info , char *buf___2 , size_t bufsz ) 
{ 
  char *ptr ;
  size_t buflen ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 160
  buflen = (size_t )0;
#line 162
  memset((void *)buf___2, '\000', bufsz);
#line 167
  tmp = strcmp((char const   *)session.curr_cmd, "MLST");
  }
#line 167
  if (tmp == 0) {
#line 168
    *(buf___2 + 0) = (char )' ';
#line 169
    buflen = (size_t )1;
  }
#line 172
  ptr = buf___2 + buflen;
#line 174
  if (facts_opts & 1UL) {
    {
#line 175
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"modify=%04d%02d%02d%02d%02d%02d;",
             (info->tm)->tm_year + 1900, (info->tm)->tm_mon + 1, (info->tm)->tm_mday,
             (info->tm)->tm_hour, (info->tm)->tm_min, (info->tm)->tm_sec);
#line 178
    buflen = strlen((char const   *)buf___2);
#line 179
    ptr = buf___2 + buflen;
    }
  }
#line 182
  if (facts_opts & 2UL) {
    {
#line 183
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"perm=%s;",
             info->perm);
#line 184
    buflen = strlen((char const   *)buf___2);
#line 185
    ptr = buf___2 + buflen;
    }
  }
#line 188
  if (! ((info->st.st_mode & 61440U) == 16384U)) {
#line 188
    if (facts_opts & 4UL) {
      {
#line 190
      snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"size=%llu;",
               (unsigned long long )info->st.st_size);
#line 192
      buflen = strlen((char const   *)buf___2);
#line 193
      ptr = buf___2 + buflen;
      }
    }
  }
#line 196
  if (facts_opts & 8UL) {
    {
#line 197
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"type=%s;",
             info->type);
#line 198
    buflen = strlen((char const   *)buf___2);
#line 199
    ptr = buf___2 + buflen;
    }
  }
#line 202
  if (facts_opts & 16UL) {
    {
#line 203
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"unique=%lXU%lX;",
             (unsigned long )info->st.st_dev, (unsigned long )info->st.st_ino);
#line 205
    buflen = strlen((char const   *)buf___2);
#line 206
    ptr = buf___2 + buflen;
    }
  }
#line 209
  if (facts_opts & 32UL) {
    {
#line 210
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"UNIX.group=%lu;",
             (unsigned long )info->st.st_gid);
#line 212
    buflen = strlen((char const   *)buf___2);
#line 213
    ptr = buf___2 + buflen;
    }
  }
#line 216
  if (facts_opts & 64UL) {
    {
#line 217
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"UNIX.mode=0%o;",
             info->st.st_mode & 4095U);
#line 219
    buflen = strlen((char const   *)buf___2);
#line 220
    ptr = buf___2 + buflen;
    }
  }
#line 223
  if (facts_opts & 128UL) {
    {
#line 224
    snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)"UNIX.owner=%lu;",
             (unsigned long )info->st.st_uid);
#line 226
    buflen = strlen((char const   *)buf___2);
#line 227
    ptr = buf___2 + buflen;
    }
  }
  {
#line 230
  snprintf((char */* __restrict  */)ptr, bufsz - buflen, (char const   */* __restrict  */)" %s\n",
           info->path);
#line 232
  *(buf___2 + (bufsz - 1U)) = (char )'\000';
#line 233
  buflen = strlen((char const   *)buf___2);
  }
#line 235
  return (buflen);
}
}
#line 247 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static char mlinfo_buf[1024]  ;
#line 248 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static size_t mlinfo_buflen  =    (size_t )0;
#line 250 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static void facts_mlinfobuf_init(void) 
{ 


  {
  {
#line 251
  memset((void *)(mlinfo_buf), '\000', (size_t )sizeof(mlinfo_buf));
#line 252
  mlinfo_buflen = (size_t )0;
  }
#line 253
  return;
}
}
#line 255 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static void facts_mlinfobuf_add(struct mlinfo *info ) 
{ 
  char buf___2[1024] ;
  size_t buflen ;
  void *__cil_tmp4 ;

  {
  {
#line 259
  buflen = facts_mlinfo_fmt(info, buf___2, (size_t )sizeof(buf___2));
  }
#line 264
  if ((unsigned long )buflen >= sizeof(mlinfo_buf) - (unsigned long )mlinfo_buflen) {
    {
#line 265
    facts_mlinfobuf_flush();
    }
  }
  {
#line 268
  sstrcat(mlinfo_buf, (char const   *)(buf___2), (size_t )sizeof(mlinfo_buf));
#line 269
  mlinfo_buflen += buflen;
  }
#line 270
  return;
}
}
#line 272 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static void facts_mlinfobuf_flush(void) 
{ 
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp6 ;

  {
#line 273
  if (mlinfo_buflen > 0U) {
    {
#line 276
    res = pr_data_xfer(mlinfo_buf, (int )mlinfo_buflen);
    }
#line 277
    if (res < 0) {
      {
#line 277
      tmp___2 = __errno_location();
      }
#line 277
      if (*tmp___2 != 0) {
        {
#line 279
        tmp = __errno_location();
#line 279
        tmp___0 = strerror(*tmp);
#line 279
        tmp___1 = __errno_location();
#line 279
        pr_log_debug(3, "mod_facts/0.1: error transferring data: [%d] %s", *tmp___1,
                     tmp___0);
        }
      }
    }
  }
  {
#line 284
  facts_mlinfobuf_init();
  }
#line 285
  return;
}
}
#line 287 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_mlinfo_get(struct mlinfo *info , char const   *path ) 
{ 
  char *perm ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 288
  perm = (char *)"";
#line 290
  tmp___1 = pr_fsio_stat(path, & info->st);
  }
#line 290
  if (tmp___1 < 0) {
    {
#line 291
    tmp = __errno_location();
#line 291
    tmp___0 = strerror(*tmp);
#line 291
    pr_log_debug(4, "mod_facts/0.1: error stat\'ing \'%s\': %s", path, tmp___0);
    }
#line 293
    return (-1);
  }
  {
#line 296
  info->tm = pr_gmtime(info->pool, (time_t const   *)(& info->st.st_mtim.tv_sec));
  }
#line 298
  if (! ((info->st.st_mode & 61440U) == 16384U)) {
    {
#line 299
    info->type = "file";
#line 301
    tmp___2 = pr_fsio_access(path, 4, session.uid, session.gid, session.gids);
    }
#line 301
    if (tmp___2 == 0) {
      {
#line 310
      perm = pstrcat(info->pool, perm, "adfr", (void *)0);
      }
    }
    {
#line 313
    tmp___3 = pr_fsio_access(path, 2, session.uid, session.gid, session.gids);
    }
#line 313
    if (tmp___3 == 0) {
      {
#line 315
      perm = pstrcat(info->pool, perm, "w", (void *)0);
      }
    }
  } else {
#line 319
    info->type = "dir";
#line 321
    if ((int const   )*(path + 0) != 46) {
      {
#line 322
      tmp___4 = pr_fs_getcwd();
#line 322
      tmp___5 = strcmp(path, tmp___4);
      }
#line 322
      if (tmp___5 == 0) {
#line 323
        info->type = "cdir";
      }
    } else {
#line 327
      if ((int const   )*(path + 1) == 0) {
#line 328
        info->type = "cdir";
      }
#line 331
      if ((int const   )*(path + 1) == 46) {
#line 331
        if ((int const   )*(path + 2) == 0) {
#line 333
          info->type = "pdir";
        }
      }
    }
    {
#line 337
    tmp___6 = pr_fsio_access(path, 4, session.uid, session.gid, session.gids);
    }
#line 337
    if (tmp___6 == 0) {
      {
#line 339
      perm = pstrcat(info->pool, perm, "fl", (void *)0);
      }
    }
    {
#line 342
    tmp___7 = pr_fsio_access(path, 2, session.uid, session.gid, session.gids);
    }
#line 342
    if (tmp___7 == 0) {
      {
#line 344
      perm = pstrcat(info->pool, perm, "cdmp", (void *)0);
      }
    }
    {
#line 347
    tmp___8 = pr_fsio_access(path, 1, session.uid, session.gid, session.gids);
    }
#line 347
    if (tmp___8 == 0) {
      {
#line 349
      perm = pstrcat(info->pool, perm, "e", (void *)0);
      }
    }
  }
#line 353
  info->perm = (char const   *)perm;
#line 354
  return (0);
}
}
#line 357 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static void facts_mlinfo_send(struct mlinfo *info ) 
{ 
  char buf___2[1024] ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 360
  facts_mlinfo_fmt(info, buf___2, (size_t )sizeof(buf___2));
#line 361
  pr_response_send_raw("%s", buf___2);
  }
#line 362
  return;
}
}
#line 364 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static void facts_mlst_feat_add(pool *p ) 
{ 
  char *feat_str ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 365
  feat_str = (char *)"";
#line 367
  feat_str = pstrcat(p, feat_str, "modify", (void *)0);
  }
#line 368
  if (facts_opts & 1UL) {
    {
#line 369
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 372
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 375
  feat_str = pstrcat(p, feat_str, "perm", (void *)0);
  }
#line 376
  if (facts_opts & 2UL) {
    {
#line 377
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 380
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 383
  feat_str = pstrcat(p, feat_str, "size", (void *)0);
  }
#line 384
  if (facts_opts & 4UL) {
    {
#line 385
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 388
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 391
  feat_str = pstrcat(p, feat_str, "type", (void *)0);
  }
#line 392
  if (facts_opts & 8UL) {
    {
#line 393
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 396
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 399
  feat_str = pstrcat(p, feat_str, "unique", (void *)0);
  }
#line 400
  if (facts_opts & 16UL) {
    {
#line 401
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 404
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 407
  feat_str = pstrcat(p, feat_str, "UNIX.group", (void *)0);
  }
#line 408
  if (facts_opts & 32UL) {
    {
#line 409
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 412
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 415
  feat_str = pstrcat(p, feat_str, "UNIX.mode", (void *)0);
  }
#line 416
  if (facts_opts & 64UL) {
    {
#line 417
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 420
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 423
  feat_str = pstrcat(p, feat_str, "UNIX.owner", (void *)0);
  }
#line 424
  if (facts_opts & 128UL) {
    {
#line 425
    feat_str = pstrcat(p, feat_str, "*;", (void *)0);
    }
  } else {
    {
#line 428
    feat_str = pstrcat(p, feat_str, ";", (void *)0);
    }
  }
  {
#line 431
  feat_str = pstrcat(p, "MLST ", feat_str, (void *)0);
#line 432
  pr_feat_add((char const   *)feat_str);
  }
#line 433
  return;
}
}
#line 435 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static void facts_mlst_feat_remove(void) 
{ 
  char const   *feat ;
  char const   *mlst_feat ;
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 436
  mlst_feat = (char const   *)((void *)0);
#line 438
  feat = pr_feat_get();
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! feat) {
#line 439
      goto while_break;
    }
    {
#line 440
    pr_signals_handle();
#line 442
    tmp = strncmp(feat, "MLST", (size_t )4);
    }
#line 442
    if (tmp == 0) {
#line 443
      mlst_feat = feat;
#line 444
      goto while_break;
    }
    {
#line 447
    feat = pr_feat_get_next();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  if (mlst_feat) {
    {
#line 451
    pr_feat_remove(mlst_feat);
    }
  }
#line 452
  return;
}
}
#line 454 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_modify_mtime(pool *p , char const   *path , char *timestamp ) 
{ 
  char c ;
  char *ptr ;
  unsigned int year ;
  unsigned int month ;
  unsigned int day ;
  unsigned int hour ;
  unsigned int min ;
  unsigned int sec ;
  struct timeval tvs[2] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 461
  ptr = timestamp;
#line 462
  c = *(timestamp + 4);
#line 463
  *(timestamp + 4) = (char )'\000';
#line 464
  tmp = atoi((char const   *)ptr);
#line 464
  year = (unsigned int )tmp;
#line 465
  *(timestamp + 4) = c;
#line 467
  ptr = timestamp + 4;
#line 468
  c = *(timestamp + 6);
#line 469
  *(timestamp + 6) = (char )'\000';
#line 470
  tmp___0 = atoi((char const   *)ptr);
#line 470
  month = (unsigned int )tmp___0;
#line 471
  *(timestamp + 6) = c;
  }
#line 473
  if (month < 1U) {
    {
#line 475
    pr_log_debug(8, "mod_facts/0.1: bad number of months (%d) in timestamp \'%s\'",
                 month, timestamp);
#line 477
    tmp___1 = __errno_location();
#line 477
    *tmp___1 = 22;
    }
#line 478
    return (-1);
  } else
#line 473
  if (month > 12U) {
    {
#line 475
    pr_log_debug(8, "mod_facts/0.1: bad number of months (%d) in timestamp \'%s\'",
                 month, timestamp);
#line 477
    tmp___1 = __errno_location();
#line 477
    *tmp___1 = 22;
    }
#line 478
    return (-1);
  }
  {
#line 481
  ptr = timestamp + 6;
#line 482
  c = *(timestamp + 8);
#line 483
  *(timestamp + 8) = (char )'\000';
#line 484
  tmp___2 = atoi((char const   *)ptr);
#line 484
  day = (unsigned int )tmp___2;
#line 485
  *(timestamp + 8) = c;
  }
#line 487
  if (day < 1U) {
    {
#line 489
    pr_log_debug(8, "mod_facts/0.1: bad number of days (%d) in timestamp \'%s\'",
                 day, timestamp);
#line 491
    tmp___3 = __errno_location();
#line 491
    *tmp___3 = 22;
    }
#line 492
    return (-1);
  } else
#line 487
  if (day > 31U) {
    {
#line 489
    pr_log_debug(8, "mod_facts/0.1: bad number of days (%d) in timestamp \'%s\'",
                 day, timestamp);
#line 491
    tmp___3 = __errno_location();
#line 491
    *tmp___3 = 22;
    }
#line 492
    return (-1);
  }
  {
#line 495
  ptr = timestamp + 8;
#line 496
  c = *(timestamp + 10);
#line 497
  *(timestamp + 10) = (char )'\000';
#line 498
  tmp___4 = atoi((char const   *)ptr);
#line 498
  hour = (unsigned int )tmp___4;
#line 499
  *(timestamp + 10) = c;
  }
#line 501
  if (hour < 0U) {
    {
#line 503
    pr_log_debug(8, "mod_facts/0.1: bad number of hours (%d) in timestamp \'%s\'",
                 hour, timestamp);
#line 505
    tmp___5 = __errno_location();
#line 505
    *tmp___5 = 22;
    }
#line 506
    return (-1);
  } else
#line 501
  if (hour > 24U) {
    {
#line 503
    pr_log_debug(8, "mod_facts/0.1: bad number of hours (%d) in timestamp \'%s\'",
                 hour, timestamp);
#line 505
    tmp___5 = __errno_location();
#line 505
    *tmp___5 = 22;
    }
#line 506
    return (-1);
  }
  {
#line 509
  ptr = timestamp + 10;
#line 510
  c = *(timestamp + 12);
#line 511
  *(timestamp + 12) = (char )'\000';
#line 512
  tmp___6 = atoi((char const   *)ptr);
#line 512
  min = (unsigned int )tmp___6;
#line 513
  *(timestamp + 12) = c;
  }
#line 515
  if (min < 0U) {
    {
#line 517
    pr_log_debug(8, "mod_facts/0.1: bad number of minutes (%d) in timestamp \'%s\'",
                 min, timestamp);
#line 519
    tmp___7 = __errno_location();
#line 519
    *tmp___7 = 22;
    }
#line 520
    return (-1);
  } else
#line 515
  if (min > 60U) {
    {
#line 517
    pr_log_debug(8, "mod_facts/0.1: bad number of minutes (%d) in timestamp \'%s\'",
                 min, timestamp);
#line 519
    tmp___7 = __errno_location();
#line 519
    *tmp___7 = 22;
    }
#line 520
    return (-1);
  }
  {
#line 523
  ptr = timestamp + 12;
#line 524
  tmp___8 = atoi((char const   *)ptr);
#line 524
  sec = (unsigned int )tmp___8;
  }
#line 526
  if (sec < 0U) {
    {
#line 528
    pr_log_debug(8, "mod_facts/0.1: bad number of seconds (%d) in timestamp \'%s\'",
                 sec, timestamp);
#line 530
    tmp___9 = __errno_location();
#line 530
    *tmp___9 = 22;
    }
#line 531
    return (-1);
  } else
#line 526
  if (sec > 61U) {
    {
#line 528
    pr_log_debug(8, "mod_facts/0.1: bad number of seconds (%d) in timestamp \'%s\'",
                 sec, timestamp);
#line 530
    tmp___9 = __errno_location();
#line 530
    *tmp___9 = 22;
    }
#line 531
    return (-1);
  }
  {
#line 534
  tvs[1].tv_usec = (__suseconds_t )0;
#line 534
  tvs[0].tv_usec = tvs[1].tv_usec;
#line 535
  tvs[1].tv_sec = facts_mktime(year, month, day, hour, min, sec);
#line 535
  tvs[0].tv_sec = tvs[1].tv_sec;
#line 538
  tmp___12 = pr_fsio_utimes(path, tvs);
  }
#line 538
  if (tmp___12 < 0) {
    {
#line 539
    tmp___10 = __errno_location();
#line 539
    tmp___11 = strerror(*tmp___10);
#line 539
    pr_log_debug(2, "mod_facts/0.1: error modifying modify fact for \'%s\': %s", path,
                 tmp___11);
    }
#line 541
    return (-1);
  }
#line 544
  return (0);
}
}
#line 547 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_modify_unix_group(pool *p , char const   *path , char const   *group ) 
{ 
  gid_t gid ;
  char *tmp ;
  unsigned long tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 550
  tmp = (char *)((void *)0);
#line 552
  tmp___0 = strtoul((char const   */* __restrict  */)group, (char **/* __restrict  */)(& tmp),
                    10);
#line 552
  gid = (gid_t )tmp___0;
  }
#line 553
  if (tmp) {
#line 553
    if (*tmp) {
      {
#line 556
      gid = pr_auth_name2gid(p, group);
      }
#line 557
      if (gid == 4294967295U) {
        {
#line 558
        pr_log_debug(7, "mod_facts/0.1: no such group \'%s\'", group);
#line 559
        tmp___1 = __errno_location();
#line 559
        *tmp___1 = 22;
        }
#line 560
        return (-1);
      }
    }
  }
  {
#line 564
  tmp___4 = pr_fsio_chown(path, (uid_t )-1, gid);
  }
#line 564
  if (tmp___4 < 0) {
    {
#line 565
    tmp___2 = __errno_location();
#line 565
    tmp___3 = strerror(*tmp___2);
#line 565
    pr_log_debug(5, "mod_facts/0.1: error modifying UNIX.group fact for \'%s\': %s",
                 path, tmp___3);
    }
#line 567
    return (-1);
  }
#line 570
  return (0);
}
}
#line 573 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_modify_unix_mode(pool *p , char const   *path , char *mode_str ) 
{ 
  mode_t mode ;
  char *tmp ;
  unsigned long tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 575
  tmp = (char *)((void *)0);
#line 577
  tmp___0 = strtoul((char const   */* __restrict  */)mode_str, (char **/* __restrict  */)(& tmp),
                    8);
#line 577
  mode = (mode_t )tmp___0;
  }
#line 578
  if (tmp) {
#line 578
    if (*tmp) {
      {
#line 580
      pr_log_debug(3, "mod_facts/0.1: UNIX.mode fact \'%s\' is not an octal number",
                   mode_str);
      }
#line 582
      return (-1);
    }
  }
  {
#line 585
  tmp___3 = pr_fsio_chmod(path, mode);
  }
#line 585
  if (tmp___3 < 0) {
    {
#line 586
    tmp___1 = __errno_location();
#line 586
    tmp___2 = strerror(*tmp___1);
#line 586
    pr_log_debug(5, "mod_facts/0.1: error modifying UNIX.mode fact for \'%s\': %s",
                 path, tmp___2);
    }
#line 588
    return (-1);
  }
#line 591
  return (0);
}
}
#line 597 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static modret_t *facts_mff(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  char const   *path ;
  char const   *decoded_path ;
  char *facts ;
  char *ptr ;
  modret_t *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *timestamp ;
  char *ptr2 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  size_t tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___18 ;
  int *tmp___19 ;
  modret_t *tmp___20 ;
  int tmp___21 ;
  char *group ;
  char *ptr2___0 ;
  char *tmp___22 ;
  modret_t *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  char const   *tmp___27 ;
  int *tmp___28 ;
  modret_t *tmp___29 ;
  int tmp___30 ;
  char *mode_str ;
  char *ptr2___1 ;
  char *tmp___31 ;
  modret_t *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  char const   *tmp___36 ;
  int *tmp___37 ;
  modret_t *tmp___38 ;
  int tmp___39 ;
  modret_t *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  modret_t *tmp___44 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;

  {
#line 602
  if (cmd->argc < 3) {
    {
#line 603
    pr_response_add_err("501", "Invalid number of arguments");
#line 604
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 604
    return (tmp);
  }
  {
#line 607
  facts = *(cmd->argv + 1);
#line 612
  tmp___0 = pstrdup(cmd->tmp_pool, (char const   *)*(cmd->argv + 2));
#line 612
  path = (char const   *)tmp___0;
#line 613
  i___0 = 3U;
  }
  {
#line 613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 613
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 613
      goto while_break;
    }
    {
#line 614
    tmp___1 = pstrcat(cmd->tmp_pool, path, " ", *(cmd->argv + i___0), (void *)0);
#line 614
    path = (char const   *)tmp___1;
#line 613
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 617
  tmp___2 = pr_fs_decode_path(cmd->tmp_pool, path);
#line 617
  decoded_path = (char const   *)tmp___2;
#line 619
  tmp___4 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, (char *)decoded_path,
                      (int *)((void *)0));
  }
#line 619
  if (! tmp___4) {
    {
#line 621
    pr_log_debug(4, "mod_facts/0.1: %s command denied by <Limit>", *(cmd->argv + 0));
#line 623
    pr_response_add_err("550", "Unable to handle command");
#line 624
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 624
    return (tmp___3);
  }
  {
#line 627
  tmp___7 = facts_filters_allow_path(cmd, decoded_path);
  }
#line 627
  if (tmp___7 < 0) {
    {
#line 628
    tmp___5 = strerror(13);
#line 628
    pr_response_add_err("550", "%s: %s", path, tmp___5);
#line 629
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 629
    return (tmp___6);
  }
  {
#line 632
  ptr = strchr((char const   *)facts, ';');
  }
#line 633
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 634
    tmp___8 = strerror(22);
#line 634
    pr_response_add_err("550", "%s: %s", facts, tmp___8);
#line 635
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 635
    return (tmp___9);
  }
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 638
    if (! ptr) {
#line 638
      goto while_break___0;
    }
    {
#line 639
    pr_signals_handle();
#line 641
    *ptr = (char )'\000';
#line 643
    tmp___43 = strncasecmp((char const   *)facts, "modify", (size_t )6);
    }
#line 643
    if (tmp___43 == 0) {
      {
#line 648
      ptr2 = strchr((char const   *)facts, '=');
      }
#line 649
      if (! ptr2) {
        {
#line 650
        tmp___10 = strerror(22);
#line 650
        pr_response_add_err("501", "%s: %s", *(cmd->argv + 1), tmp___10);
#line 651
        tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 651
        return (tmp___11);
      }
      {
#line 654
      timestamp = ptr2 + 1;
#line 656
      tmp___14 = strlen((char const   *)timestamp);
      }
#line 656
      if (tmp___14 < 14U) {
        {
#line 657
        tmp___12 = strerror(22);
#line 657
        pr_response_add_err("501", "%s: %s", timestamp, tmp___12);
#line 658
        tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 658
        return (tmp___13);
      }
      {
#line 661
      ptr2 = strchr((char const   *)timestamp, '.');
      }
#line 662
      if (ptr2) {
        {
#line 663
        pr_log_debug(7, "mod_facts/0.1: %s: ignoring unsupported timestamp precision in \'%s\'",
                     *(cmd->argv + 0), timestamp);
#line 666
        *ptr2 = (char )'\000';
        }
      }
      {
#line 669
      tmp___21 = facts_modify_mtime(cmd->tmp_pool, decoded_path, timestamp);
      }
#line 669
      if (tmp___21 < 0) {
        {
#line 670
        tmp___15 = __errno_location();
#line 670
        tmp___16 = strerror(*tmp___15);
#line 670
        tmp___19 = __errno_location();
        }
#line 670
        if (*tmp___19 == 2) {
#line 670
          tmp___18 = "550";
        } else {
#line 670
          tmp___18 = "501";
        }
        {
#line 670
        pr_response_add_err(tmp___18, "%s: %s", path, tmp___16);
#line 672
        tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 672
        return (tmp___20);
      }
    } else {
      {
#line 675
      tmp___42 = strncasecmp((char const   *)facts, "UNIX.group", (size_t )10);
      }
#line 675
      if (tmp___42 == 0) {
        {
#line 680
        ptr2___0 = strchr((char const   *)facts, '=');
        }
#line 681
        if (! ptr2___0) {
          {
#line 682
          *ptr = (char )';';
#line 683
          tmp___22 = strerror(22);
#line 683
          pr_response_add_err("501", "%s: %s", *(cmd->argv + 1), tmp___22);
#line 684
          tmp___23 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 684
          return (tmp___23);
        }
        {
#line 687
        group = ptr2___0 + 1;
#line 689
        tmp___30 = facts_modify_unix_group(cmd->tmp_pool, decoded_path, (char const   *)group);
        }
#line 689
        if (tmp___30 < 0) {
          {
#line 690
          tmp___24 = __errno_location();
#line 690
          tmp___25 = strerror(*tmp___24);
#line 690
          tmp___28 = __errno_location();
          }
#line 690
          if (*tmp___28 == 2) {
#line 690
            tmp___27 = "550";
          } else {
#line 690
            tmp___27 = "501";
          }
          {
#line 690
          pr_response_add_err(tmp___27, "%s: %s", path, tmp___25);
#line 692
          tmp___29 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 692
          return (tmp___29);
        }
      } else {
        {
#line 695
        tmp___41 = strncasecmp((char const   *)facts, "UNIX.mode", (size_t )9);
        }
#line 695
        if (tmp___41 == 0) {
          {
#line 700
          ptr2___1 = strchr((char const   *)facts, '=');
          }
#line 701
          if (! ptr2___1) {
            {
#line 702
            *ptr = (char )';';
#line 703
            tmp___31 = strerror(22);
#line 703
            pr_response_add_err("501", "%s: %s", *(cmd->argv + 1), tmp___31);
#line 704
            tmp___32 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      (char *)((void *)0));
            }
#line 704
            return (tmp___32);
          }
          {
#line 707
          mode_str = ptr2___1 + 1;
#line 709
          tmp___39 = facts_modify_unix_mode(cmd->tmp_pool, decoded_path, mode_str);
          }
#line 709
          if (tmp___39 < 0) {
            {
#line 710
            tmp___33 = __errno_location();
#line 710
            tmp___34 = strerror(*tmp___33);
#line 710
            tmp___37 = __errno_location();
            }
#line 710
            if (*tmp___37 == 2) {
#line 710
              tmp___36 = "550";
            } else {
#line 710
              tmp___36 = "501";
            }
            {
#line 710
            pr_response_add_err(tmp___36, "%s: %s", path, tmp___34);
#line 712
            tmp___38 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      (char *)((void *)0));
            }
#line 712
            return (tmp___38);
          }
        } else {
          {
#line 719
          pr_log_debug(5, "mod_facts/0.1: %s: fact \'%s\' unsupported for modification, denying request",
                       *(cmd->argv + 0), facts);
#line 722
          pr_response_add_err("504", "Cannot modify fact \'%s\'", facts);
#line 724
          *ptr = (char )';';
#line 725
          tmp___40 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 725
          return (tmp___40);
        }
      }
    }
    {
#line 728
    *ptr = (char )';';
#line 729
    facts = ptr + 1;
#line 730
    ptr = strchr((char const   *)facts, ';');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 737
  pr_response_add("213", "%s %s", *(cmd->argv + 1), path);
#line 738
  tmp___44 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 738
  return (tmp___44);
}
}
#line 741 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static modret_t *facts_mfmt(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  char const   *path ;
  char const   *decoded_path ;
  char *timestamp ;
  char *ptr ;
  int res ;
  modret_t *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___14 ;
  int *tmp___15 ;
  modret_t *tmp___16 ;
  modret_t *tmp___17 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 747
  if (cmd->argc < 3) {
    {
#line 748
    pr_response_add_err("501", "Invalid number of arguments");
#line 749
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 749
    return (tmp);
  }
  {
#line 752
  timestamp = *(cmd->argv + 1);
#line 757
  tmp___0 = pstrdup(cmd->tmp_pool, (char const   *)*(cmd->argv + 2));
#line 757
  path = (char const   *)tmp___0;
#line 758
  i___0 = 3U;
  }
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 758
      goto while_break;
    }
    {
#line 759
    tmp___1 = pstrcat(cmd->tmp_pool, path, " ", *(cmd->argv + i___0), (void *)0);
#line 759
    path = (char const   *)tmp___1;
#line 758
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 762
  tmp___2 = pr_fs_decode_path(cmd->tmp_pool, path);
#line 762
  decoded_path = (char const   *)tmp___2;
#line 764
  tmp___4 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, (char *)decoded_path,
                      (int *)((void *)0));
  }
#line 764
  if (! tmp___4) {
    {
#line 766
    pr_log_debug(4, "mod_facts/0.1: %s command denied by <Limit>", *(cmd->argv + 0));
#line 768
    pr_response_add_err("550", "Unable to handle command");
#line 769
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 769
    return (tmp___3);
  }
  {
#line 772
  tmp___7 = facts_filters_allow_path(cmd, decoded_path);
  }
#line 772
  if (tmp___7 < 0) {
    {
#line 773
    tmp___5 = strerror(13);
#line 773
    pr_response_add_err("550", "%s: %s", path, tmp___5);
#line 774
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 774
    return (tmp___6);
  }
  {
#line 777
  tmp___10 = strlen((char const   *)timestamp);
  }
#line 777
  if (tmp___10 < 14U) {
    {
#line 778
    tmp___8 = strerror(22);
#line 778
    pr_response_add_err("501", "%s: %s", timestamp, tmp___8);
#line 779
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 779
    return (tmp___9);
  }
  {
#line 782
  ptr = strchr((char const   *)timestamp, '.');
  }
#line 783
  if (ptr) {
    {
#line 784
    pr_log_debug(7, "mod_facts/0.1: %s: ignoring unsupported timestamp precision in \'%s\'",
                 *(cmd->argv + 0), timestamp);
#line 787
    *ptr = (char )'\000';
    }
  }
  {
#line 790
  res = facts_modify_mtime(cmd->tmp_pool, decoded_path, timestamp);
  }
#line 791
  if (res < 0) {
#line 792
    if (ptr) {
#line 793
      *ptr = (char )'.';
    }
    {
#line 796
    tmp___11 = __errno_location();
#line 796
    tmp___12 = strerror(*tmp___11);
#line 796
    tmp___15 = __errno_location();
    }
#line 796
    if (*tmp___15 == 2) {
#line 796
      tmp___14 = "550";
    } else {
#line 796
      tmp___14 = "501";
    }
    {
#line 796
    pr_response_add_err(tmp___14, "%s: %s", path, tmp___12);
#line 798
    tmp___16 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 798
    return (tmp___16);
  }
  {
#line 808
  pr_response_add("213", "Modify=%s; %s", timestamp, path);
  }
#line 810
  if (ptr) {
#line 811
    *ptr = (char )'.';
  }
  {
#line 814
  tmp___17 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 814
  return (tmp___17);
}
}
#line 817 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static modret_t *facts_mlsd(cmd_rec *cmd ) 
{ 
  char const   *path ;
  char const   *decoded_path ;
  struct mlinfo info ;
  DIR *dirh ;
  struct dirent *dent ;
  modret_t *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  modret_t *tmp___3 ;
  char *tmp___4 ;
  int xerrno ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  void *tmp___11 ;
  int xerrno___0 ;
  int *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  modret_t *tmp___15 ;
  int tmp___16 ;
  char const   *p ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  modret_t *tmp___22 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 823
  if (cmd->argc > 2) {
    {
#line 824
    pr_response_add_err("501", "Invalid number of arguments");
#line 825
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 825
    return (tmp);
  }
#line 828
  if (cmd->argc != 1) {
    {
#line 829
    path = (char const   *)*(cmd->argv + 1);
#line 830
    tmp___0 = pr_fs_decode_path(cmd->tmp_pool, path);
#line 830
    decoded_path = (char const   *)tmp___0;
    }
  } else {
    {
#line 833
    path = pr_fs_getcwd();
#line 833
    decoded_path = path;
    }
  }
  {
#line 836
  tmp___2 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, (char *)decoded_path,
                      (int *)((void *)0));
  }
#line 836
  if (! tmp___2) {
    {
#line 838
    pr_log_debug(4, "mod_facts/0.1: %s command denied by <Limit>", *(cmd->argv + 0));
#line 840
    pr_response_add_err("550", "Unable to handle command");
#line 841
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 841
    return (tmp___1);
  }
  {
#line 845
  tmp___4 = strpbrk(decoded_path, "{[*?");
  }
#line 845
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 846
    pr_log_debug(2, "mod_facts/0.1: unable to handle MLSD command: target \'%s\' contains glob characters",
                 decoded_path);
#line 848
    pr_response_add_err("550", "Unable to handle command");
#line 849
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 849
    return (tmp___3);
  }
  {
#line 853
  tmp___9 = pr_fsio_stat(decoded_path, & info.st);
  }
#line 853
  if (tmp___9 < 0) {
    {
#line 854
    tmp___5 = __errno_location();
#line 854
    xerrno = *tmp___5;
#line 856
    tmp___6 = strerror(xerrno);
#line 856
    pr_log_debug(4, "mod_facts/0.1: unable to stat \'%s\' (%s), denying %s", decoded_path,
                 tmp___6, *(cmd->argv + 0));
#line 859
    tmp___7 = strerror(xerrno);
#line 859
    pr_response_add_err("550", "%s: %s", path, tmp___7);
#line 860
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 860
    return (tmp___8);
  }
#line 863
  if (! ((info.st.st_mode & 61440U) == 16384U)) {
    {
#line 864
    pr_response_add_err("550", "\'%s\' is not a directory", path);
#line 865
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 865
    return (tmp___10);
  }
  {
#line 868
  tmp___11 = pr_fsio_opendir(decoded_path);
#line 868
  dirh = (DIR *)tmp___11;
  }
#line 869
  if ((unsigned long )dirh == (unsigned long )((void *)0)) {
    {
#line 870
    tmp___12 = __errno_location();
#line 870
    xerrno___0 = *tmp___12;
#line 872
    tmp___13 = strerror(xerrno___0);
#line 872
    pr_trace_msg("fileperms", 1, "MLSD, user \'%s\' (UID %lu, GID %lu): error reading directory \'%s\': %s",
                 session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                 decoded_path, tmp___13);
#line 877
    pr_response_add_err("550", "\'%s\' cannot be listed", path);
#line 878
    tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 878
    return (tmp___14);
  }
  {
#line 882
  session.sf_flags |= (int volatile   )32;
#line 883
  tmp___16 = pr_data_open((char *)((void *)0), (char *)"MLSD", 2, (off_t___0 )0);
  }
#line 883
  if (tmp___16 < 0) {
    {
#line 884
    pr_fsio_closedir((void *)dirh);
#line 885
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 885
    return (tmp___15);
  }
  {
#line 888
  pr_fs_clear_cache();
#line 889
  facts_mlinfobuf_init();
  }
  {
#line 891
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 891
    dent = pr_fsio_readdir((void *)dirh);
    }
#line 891
    if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 891
      goto while_break;
    }
    {
#line 894
    pr_signals_handle();
#line 896
    tmp___17 = pdircat(cmd->tmp_pool, decoded_path, dent->d_name, (void *)0);
#line 896
    p = (char const   *)tmp___17;
#line 897
    memset((void *)(& info), 0, (size_t )sizeof(struct mlinfo ));
#line 899
    info.pool = cmd->tmp_pool;
#line 900
    tmp___20 = facts_mlinfo_get(& info, p);
    }
#line 900
    if (tmp___20 < 0) {
      {
#line 901
      tmp___18 = __errno_location();
#line 901
      tmp___19 = strerror(*tmp___18);
#line 901
      pr_log_debug(3, "mod_facts/0.1: MLSD: unable to get info for \'%s\': %s", p,
                   tmp___19);
      }
#line 903
      goto while_continue;
    }
    {
#line 909
    tmp___21 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)(dent->d_name));
#line 909
    info.path = (char const   *)tmp___21;
#line 911
    facts_mlinfobuf_add(& info);
    }
#line 913
    if (session.sf_flags & (int volatile   )2) {
      {
#line 914
      pr_data_abort(0, 0);
      }
#line 915
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 919
  pr_fsio_closedir((void *)dirh);
  }
#line 921
  if (session.sf_flags & (int volatile   )2) {
    {
#line 922
    pr_data_close(1);
    }
  } else {
    {
#line 925
    facts_mlinfobuf_flush();
#line 926
    pr_data_close(0);
    }
  }
  {
#line 929
  tmp___22 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 929
  return (tmp___22);
}
}
#line 932 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static modret_t *facts_mlst(cmd_rec *cmd ) 
{ 
  char const   *path ;
  char const   *decoded_path ;
  struct mlinfo info ;
  modret_t *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  modret_t *tmp___5 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 936
  if (cmd->argc > 2) {
    {
#line 937
    pr_response_add_err("501", "Invalid number of arguments");
#line 938
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 938
    return (tmp);
  }
#line 941
  if (cmd->argc != 1) {
    {
#line 942
    path = (char const   *)*(cmd->argv + 1);
#line 943
    tmp___0 = pr_fs_decode_path(cmd->tmp_pool, path);
#line 943
    decoded_path = (char const   *)tmp___0;
    }
  } else {
    {
#line 946
    path = pr_fs_getcwd();
#line 946
    decoded_path = path;
    }
  }
  {
#line 949
  tmp___2 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, (char *)decoded_path,
                      (int *)((void *)0));
  }
#line 949
  if (! tmp___2) {
    {
#line 951
    pr_log_debug(4, "mod_facts/0.1: %s command denied by <Limit>", *(cmd->argv + 0));
#line 953
    pr_response_add_err("550", "Unable to handle command");
#line 954
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 954
    return (tmp___1);
  }
  {
#line 957
  info.pool = cmd->tmp_pool;
#line 959
  pr_fs_clear_cache();
#line 960
  tmp___4 = facts_mlinfo_get(& info, decoded_path);
  }
#line 960
  if (tmp___4 < 0) {
    {
#line 961
    pr_response_add_err("550", "\'%s\' cannot be listed", path);
#line 962
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 962
    return (tmp___3);
  }
  {
#line 968
  info.path = path;
#line 970
  pr_response_send_raw("%s- Start of list for %s", "250", path);
#line 971
  facts_mlinfo_send(& info);
#line 972
  pr_response_send_raw("%s End of list", "250");
#line 974
  tmp___5 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 974
  return (tmp___5);
}
}
#line 977 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static modret_t *facts_opts_mlst(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  char *method ;
  char *facts ;
  char *ptr ;
  char *resp_str ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 979
  resp_str = (char *)"";
#line 981
  method = pstrdup(cmd->tmp_pool, (char const   *)*(cmd->argv + 0));
#line 984
  i___0 = 0U;
  }
  {
#line 984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 984
    if (! *(method + i___0)) {
#line 984
      goto while_break;
    }
#line 985
    if ((int )*(method + i___0) == 95) {
#line 986
      *(method + i___0) = (char )' ';
    }
#line 984
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 989
  if (cmd->argc > 2) {
    {
#line 990
    pr_response_add_err("501", "\'%s\' not understood", method);
#line 991
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 991
    return (tmp);
  }
#line 994
  if (cmd->argc == 1) {
    {
#line 995
    facts_opts = 0UL;
#line 998
    facts_mlst_feat_remove();
#line 999
    facts_mlst_feat_add(cmd->tmp_pool);
#line 1004
    pr_response_add("200", "%s", method);
#line 1005
    tmp___0 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 1005
    return (tmp___0);
  }
  {
#line 1012
  facts_opts = 0UL;
#line 1013
  facts_mlst_feat_remove();
#line 1015
  facts = *(cmd->argv + 1);
#line 1016
  ptr = strchr((char const   *)facts, ';');
  }
  {
#line 1018
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1018
    if (! ptr) {
#line 1018
      goto while_break___0;
    }
    {
#line 1019
    pr_signals_handle();
#line 1021
    *ptr = (char )'\000';
#line 1023
    tmp___8 = strcasecmp((char const   *)facts, "modify");
    }
#line 1023
    if (tmp___8 == 0) {
      {
#line 1024
      facts_opts |= 1UL;
#line 1025
      resp_str = pstrcat(cmd->tmp_pool, resp_str, "modify;", (void *)0);
      }
    } else {
      {
#line 1027
      tmp___7 = strcasecmp((char const   *)facts, "perm");
      }
#line 1027
      if (tmp___7 == 0) {
        {
#line 1028
        facts_opts |= 2UL;
#line 1029
        resp_str = pstrcat(cmd->tmp_pool, resp_str, "perm;", (void *)0);
        }
      } else {
        {
#line 1031
        tmp___6 = strcasecmp((char const   *)facts, "size");
        }
#line 1031
        if (tmp___6 == 0) {
          {
#line 1032
          facts_opts |= 4UL;
#line 1033
          resp_str = pstrcat(cmd->tmp_pool, resp_str, "size;", (void *)0);
          }
        } else {
          {
#line 1035
          tmp___5 = strcasecmp((char const   *)facts, "type");
          }
#line 1035
          if (tmp___5 == 0) {
            {
#line 1036
            facts_opts |= 8UL;
#line 1037
            resp_str = pstrcat(cmd->tmp_pool, resp_str, "type;", (void *)0);
            }
          } else {
            {
#line 1039
            tmp___4 = strcasecmp((char const   *)facts, "unique");
            }
#line 1039
            if (tmp___4 == 0) {
              {
#line 1040
              facts_opts |= 16UL;
#line 1041
              resp_str = pstrcat(cmd->tmp_pool, resp_str, "unique;", (void *)0);
              }
            } else {
              {
#line 1043
              tmp___3 = strcasecmp((char const   *)facts, "UNIX.group");
              }
#line 1043
              if (tmp___3 == 0) {
                {
#line 1044
                facts_opts |= 32UL;
#line 1045
                resp_str = pstrcat(cmd->tmp_pool, resp_str, "UNIX.group;", (void *)0);
                }
              } else {
                {
#line 1047
                tmp___2 = strcasecmp((char const   *)facts, "UNIX.mode");
                }
#line 1047
                if (tmp___2 == 0) {
                  {
#line 1048
                  facts_opts |= 64UL;
#line 1049
                  resp_str = pstrcat(cmd->tmp_pool, resp_str, "UNIX.mode;", (void *)0);
                  }
                } else {
                  {
#line 1051
                  tmp___1 = strcasecmp((char const   *)facts, "UNIX.owner");
                  }
#line 1051
                  if (tmp___1 == 0) {
                    {
#line 1052
                    facts_opts |= 128UL;
#line 1053
                    resp_str = pstrcat(cmd->tmp_pool, resp_str, "UNIX.owner;", (void *)0);
                    }
                  } else {
                    {
#line 1056
                    pr_log_debug(3, "mod_facts/0.1: %s: client requested unsupported fact \'%s\'",
                                 method, facts);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 1060
    *ptr = (char )';';
#line 1061
    facts = ptr + 1;
#line 1062
    ptr = strchr((char const   *)facts, ';');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1065
  facts_mlst_feat_add(cmd->tmp_pool);
#line 1068
  pr_response_add("200", "%s %s", method, resp_str);
#line 1069
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1069
  return (tmp___9);
}
}
#line 1076 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static modret_t *set_factsadvertise(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1077
  bool = -1;
#line 1078
  c = (config_rec *)((void *)0);
#line 1080
  if (cmd->argc - 1 < 1) {
    {
#line 1080
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1080
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1080
    return (tmp___0);
  }
  {
#line 1081
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 1081
  if (! tmp___5) {
    {
#line 1081
    tmp___1 = get_context_name(cmd);
#line 1081
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1081
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1081
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1081
    return (tmp___4);
  }
  {
#line 1083
  bool = get_boolean(cmd, 1);
  }
#line 1084
  if (bool == -1) {
    {
#line 1085
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 1085
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 1085
    return (tmp___7);
  }
  {
#line 1087
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1088
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 1089
  *((int *)*(c->argv + 0)) = bool;
#line 1091
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1091
  return (tmp___8);
}
}
#line 1097 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1098
  pr_help_add("MLSD", "[<sp> pathname]", 1);
#line 1099
  pr_help_add("MLST", "[<sp> pathname]", 1);
  }
#line 1101
  return (0);
}
}
#line 1104 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static int facts_sess_init(void) 
{ 
  config_rec *c ;
  int advertise ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1106
  advertise = 1;
#line 1108
  c = find_config(main_server->conf, 1 << 15, "FactsAdvertise", 0);
  }
#line 1109
  if (c) {
#line 1110
    advertise = *((int *)*(c->argv + 0));
  }
#line 1113
  if (advertise == 0) {
#line 1114
    return (0);
  }
  {
#line 1116
  facts_opts = 255UL;
#line 1124
  pr_feat_add("MFF modify;UNIX.group;UNIX.mode;");
#line 1125
  pr_feat_add("MFMT");
#line 1127
  facts_mlst_feat_add(session.pool);
  }
#line 1129
  return (0);
}
}
#line 1135 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static conftable facts_conftab[2]  = {      {(char *)"FactsAdvertise", & set_factsadvertise, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))0, (module *)0}};
#line 1140 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
static cmdtable facts_cmdtab[6]  = {      {(unsigned char)2, (char *)"MFF", (char *)"WRITE", & facts_mff, (unsigned char)1,
      (unsigned char)0, 1 << 4, (module *)0}, 
        {(unsigned char)2, (char *)"MFMT", (char *)"WRITE", & facts_mfmt, (unsigned char)1,
      (unsigned char)0, 1 << 4, (module *)0}, 
        {(unsigned char)2, (char *)"MLSD", (char *)"DIRS", & facts_mlsd, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"MLST", (char *)"DIRS", & facts_mlst, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"OPTS_MLST", (char *)((void *)0), & facts_opts_mlst,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 1149 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_facts.c"
module facts_module  = 
#line 1149
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"facts", facts_conftab,
    facts_cmdtab, (authtable *)((void *)0), & facts_init, & facts_sess_init, (char *)"mod_facts/0.1",
    (void *)0, 0};
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 380 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 38 "../include/pool.h"
pool *permanent_pool ;
#line 49
void *palloc(struct pool *p , int sz ) ;
#line 53
void pr_pool_tag(struct pool *p , char const   *tag ) ;
#line 69
array_header *make_array(pool *p , unsigned int nelts , size_t elt_size ) ;
#line 71
void *push_array(array_header *arr ) ;
#line 225 "../include/dirtree.h"
config_rec *add_config_param_str(char const   *name , int num  , ...) ;
#line 235 "../include/fsio.h"
int pr_fsio_fstat(pr_fh_t *fh , struct stat *sbuf___0 ) ;
#line 251
pr_fh_t *pr_fsio_open(char const   *name , int flags ) ;
#line 255
int pr_fsio_close(pr_fh_t *fh ) ;
#line 257
int pr_fsio_write(pr_fh_t *fh , char const   *buf___2 , size_t size ) ;
#line 262
int pr_fsio_ftruncate(pr_fh_t *fh , off_t___0 len ) ;
#line 316
int pr_fs_valid_path(char const   *path ) ;
#line 45 "../include/event.h"
int pr_event_register(module *m , char const   *event , void (*cb)(void const   * ,
                                                                   void * ) , void *user_data ) ;
#line 71
int pr_event_unregister(module *m , char const   *event , void (*cb)(void const   * ,
                                                                     void * ) ) ;
#line 78
void pr_event_generate(char const   *event , void const   *event_data ) ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 74 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
xaset_t *server_list ;
#line 86 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
struct __anonstruct_delay_tab_84 delay_tab  ;
#line 94 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static unsigned int delay_engine  =    1U;
#line 95 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static unsigned int delay_nuser  =    0U;
#line 96 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static unsigned int delay_npass  =    0U;
#line 97 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static pool *delay_pool  =    (pool *)((void *)0);
#line 98 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static struct timeval delay_tv  ;
#line 100
static void delay_table_reset(void) ;
#line 107 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static long delay_select_k(unsigned long k , array_header *values ) 
{ 
  unsigned long l ;
  unsigned long ir ;
  unsigned long tmp ;
  long *elts ;
  int nelts ;
  unsigned long i___0 ;
  unsigned long j ;
  long p ;
  unsigned long mid ;

  {
#line 108
  tmp = 0UL;
#line 109
  elts = (long *)values->elts;
#line 110
  nelts = values->nelts;
#line 118
  l = 1UL;
#line 119
  ir = (unsigned long )(values->nelts - 1);
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (ir <= l + 1UL) {
#line 123
      if (ir == l + 1UL) {
#line 123
        if (*(elts + ir) < *(elts + l)) {
#line 125
          tmp = (unsigned long )*(elts + l);
        }
      }
#line 125
      *(elts + l) = *(elts + ir);
#line 125
      *(elts + ir) = (long )tmp;
#line 127
      return (*(elts + k));
    } else {
#line 132
      mid = (l + ir) >> 1;
#line 134
      tmp = (unsigned long )*(elts + mid);
#line 134
      *(elts + mid) = *(elts + (l + 1UL));
#line 134
      *(elts + (l + 1UL)) = (long )tmp;
#line 135
      if (*(elts + l) > *(elts + ir)) {
#line 136
        tmp = (unsigned long )*(elts + l);
      }
#line 136
      *(elts + l) = *(elts + ir);
#line 136
      *(elts + ir) = (long )tmp;
#line 138
      if (*(elts + (l + 1UL)) > *(elts + ir)) {
#line 139
        tmp = (unsigned long )*(elts + (l + 1UL));
      }
#line 139
      *(elts + (l + 1UL)) = *(elts + ir);
#line 139
      *(elts + ir) = (long )tmp;
#line 141
      if (*(elts + l) > *(elts + (l + 1UL))) {
#line 142
        tmp = (unsigned long )*(elts + l);
      }
#line 142
      *(elts + l) = *(elts + (l + 1UL));
#line 142
      *(elts + (l + 1UL)) = (long )tmp;
#line 144
      i___0 = l + 1UL;
#line 145
      j = ir;
#line 146
      p = *(elts + (l + 1UL));
      {
#line 148
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 149
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 149
          i___0 ++;
#line 149
          if (i___0 < (unsigned long )nelts) {
#line 149
            if (! (*(elts + i___0) < p)) {
#line 149
              goto while_break___1;
            }
          } else {
#line 149
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 152
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 152
          j --;
#line 152
          if (j >= 0UL) {
#line 152
            if (! (*(elts + j) > p)) {
#line 152
              goto while_break___2;
            }
          } else {
#line 152
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 155
        if (j < i___0) {
#line 156
          goto while_break___0;
        }
#line 158
        tmp = (unsigned long )*(elts + i___0);
#line 158
        *(elts + i___0) = *(elts + j);
#line 158
        *(elts + j) = (long )tmp;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 161
      *(elts + (l + 1UL)) = *(elts + j);
#line 162
      *(elts + j) = p;
#line 164
      if ((unsigned long )p >= k) {
#line 165
        ir = j - 1UL;
      }
#line 167
      if ((unsigned long )p <= k) {
#line 168
        l = i___0;
      }
#line 170
      if (l >= (unsigned long )(nelts - 1)) {
#line 172
        goto while_break;
      } else
#line 170
      if (ir >= (unsigned long )nelts) {
#line 172
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (-1L);
}
}
#line 179 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static long delay_get_median(pool *p , unsigned int rownum , long interval ) 
{ 
  register unsigned int i___0 ;
  struct delay_rec *row ;
  long *tab_vals ;
  array_header *list ;
  array_header *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 183
  tmp = make_array(p, 1U, (size_t )sizeof(long ));
#line 183
  list = tmp;
#line 197
  row = (struct delay_rec *)delay_tab.dt_data + rownum;
#line 198
  tab_vals = row->d_vals;
#line 203
  i___0 = 1U;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i___0 < row->d_nvals)) {
#line 203
      goto while_break;
    }
    {
#line 204
    tmp___0 = push_array(list);
#line 204
    *((long *)tmp___0) = *(tab_vals + (256U - i___0));
#line 203
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  tmp___1 = push_array(list);
#line 205
  *((long *)tmp___1) = interval;
  }
#line 207
  if (list->nelts != 1) {
#line 207
    tmp___2 = "values";
  } else {
#line 207
    tmp___2 = "value";
  }
  {
#line 207
  pr_trace_msg("delay", 6, "selecting median interval from %d %s", list->nelts, tmp___2);
#line 209
  tmp___3 = delay_select_k((unsigned long )((list->nelts + 1) / 2), list);
  }
#line 209
  return (tmp___3);
}
}
#line 213 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static sigset_t mask_sigset  ;
#line 212 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_mask_signals(unsigned char block ) 
{ 


  {
#line 215
  if (block) {
    {
#line 216
    sigemptyset(& mask_sigset);
#line 218
    sigaddset(& mask_sigset, 17);
#line 219
    sigaddset(& mask_sigset, 10);
#line 220
    sigaddset(& mask_sigset, 2);
#line 221
    sigaddset(& mask_sigset, 3);
#line 222
    sigaddset(& mask_sigset, 14);
#line 224
    sigaddset(& mask_sigset, 29);
#line 227
    sigaddset(& mask_sigset, 7);
#line 229
    sigaddset(& mask_sigset, 1);
#line 231
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& mask_sigset), (sigset_t */* __restrict  */)((void *)0));
    }
  } else {
    {
#line 234
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& mask_sigset), (sigset_t */* __restrict  */)((void *)0));
    }
  }
#line 235
  return;
}
}
#line 237 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_signals_block(void) 
{ 


  {
  {
#line 238
  delay_mask_signals((unsigned char)1);
  }
#line 239
  return;
}
}
#line 241 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_signals_unblock(void) 
{ 


  {
  {
#line 242
  delay_mask_signals((unsigned char)0);
  }
#line 243
  return;
}
}
#line 245 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_delay(long interval ) 
{ 
  struct timeval tv ;
  long rand_usec ;
  int tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 252
  tmp = rand();
#line 252
  rand_usec = (long )((((double )interval / 2.0) * (double )tmp) / (double )2147483647);
#line 253
  interval += rand_usec;
#line 254
  pr_trace_msg("delay", 8, "additional random delay of %ld usecs added", rand_usec);
#line 257
  tv.tv_sec = interval / 1000000L;
#line 258
  tv.tv_usec = interval % 1000000L;
#line 260
  pr_trace_msg("delay", 8, "delaying for %ld usecs", tv.tv_sec * 1000000L + tv.tv_usec);
#line 263
  delay_signals_block();
#line 264
  select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 265
  delay_signals_unblock();
  }
#line 266
  return;
}
}
#line 268 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_table_add_interval(unsigned int rownum , long interval ) 
{ 
  struct delay_rec *row ;

  {
  {
#line 271
  row = (struct delay_rec *)delay_tab.dt_data + rownum;
#line 274
  memmove((void *)(& row->d_vals[0]), (void const   *)(& row->d_vals[1]), (size_t )(sizeof(long ) * 255UL));
#line 278
  row->d_vals[255] = interval;
  }
#line 279
  if (row->d_nvals < 256U) {
#line 280
    (row->d_nvals) ++;
  }
#line 281
  return;
}
}
#line 283 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_table_init(void) 
{ 
  pr_fh_t *fh ;
  struct stat st ;
  server_rec *s ;
  unsigned int nservers ;
  off_t___0 tab_size ;
  int flags ;
  int reset_table ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  struct flock lock ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  int xerrno ;
  int *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int *tmp___33 ;
  ssize_t tmp___34 ;
  int xerrno___0 ;
  int *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  int *tmp___38 ;
  struct delay_rec *row ;
  unsigned int i___0 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  int tmp___42 ;
  struct flock lock___0 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int *tmp___47 ;
  int tmp___48 ;
  int xerrno___1 ;
  int *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  int *tmp___52 ;
  ssize_t tmp___53 ;
  int xerrno___2 ;
  int *tmp___54 ;
  int *tmp___55 ;
  int *tmp___56 ;
  char *tmp___57 ;
  int *tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  int *tmp___61 ;
  char *tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;

  {
#line 287
  nservers = 0U;
#line 289
  flags = 66;
#line 290
  reset_table = 0;
#line 303
  s = (server_rec *)server_list->xas_list;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! s) {
#line 303
      goto while_break;
    }
#line 304
    nservers ++;
#line 303
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  tab_size = (off_t___0 )((unsigned long )(nservers * 2U) * sizeof(struct delay_rec ));
#line 307
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c",
               307);
#line 307
  pr_signals_block();
  }
#line 307
  if (! session.disable_id_switching) {
    {
#line 307
    tmp___1 = seteuid((__uid_t )0);
    }
#line 307
    if (tmp___1) {
      {
#line 307
      tmp = __errno_location();
#line 307
      tmp___0 = strerror(*tmp);
#line 307
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 307
    tmp___4 = setegid((__gid_t )0);
    }
#line 307
    if (tmp___4) {
      {
#line 307
      tmp___2 = __errno_location();
#line 307
      tmp___3 = strerror(*tmp___2);
#line 307
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 307
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 307
  pr_signals_unblock();
#line 308
  fh = pr_fsio_open(delay_tab.dt_path, flags);
#line 309
  pr_signals_block();
  }
#line 309
  if (! session.disable_id_switching) {
    {
#line 309
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c",
                 309);
#line 309
    tmp___8 = geteuid();
    }
#line 309
    if (tmp___8 != 0U) {
      {
#line 309
      tmp___7 = seteuid((__uid_t )0);
      }
#line 309
      if (tmp___7) {
        {
#line 309
        tmp___5 = __errno_location();
#line 309
        tmp___6 = strerror(*tmp___5);
#line 309
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
        }
      }
    }
    {
#line 309
    tmp___11 = setegid(session.gid);
    }
#line 309
    if (tmp___11) {
      {
#line 309
      tmp___9 = __errno_location();
#line 309
      tmp___10 = strerror(*tmp___9);
#line 309
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
      }
    }
    {
#line 309
    tmp___14 = seteuid(session.uid);
    }
#line 309
    if (tmp___14) {
      {
#line 309
      tmp___12 = __errno_location();
#line 309
      tmp___13 = strerror(*tmp___12);
#line 309
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
      }
    }
  } else {
    {
#line 309
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 309
  pr_signals_unblock();
  }
#line 311
  if (! fh) {
    {
#line 312
    tmp___15 = __errno_location();
#line 312
    tmp___16 = strerror(*tmp___15);
#line 312
    pr_log_debug(0, "mod_delay/0.6: error opening DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___16);
#line 315
    tmp___17 = __errno_location();
#line 315
    tmp___18 = strerror(*tmp___17);
#line 315
    pr_trace_msg("delay", 1, "error opening DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___18);
    }
#line 317
    return (-1);
  }
  {
#line 320
  tmp___21 = pr_fsio_fstat(fh, & st);
  }
#line 320
  if (tmp___21 < 0) {
    {
#line 321
    tmp___19 = __errno_location();
#line 321
    tmp___20 = strerror(*tmp___19);
#line 321
    pr_trace_msg("delay", 1, "error stat\'ing DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___20);
    }
#line 323
    return (-1);
  }
#line 326
  if (st.st_size != tab_size) {
    {
#line 332
    pr_trace_msg("delay", 3, "expected table size %llu, found %llu, resetting table",
                 (unsigned long long )tab_size, (unsigned long long )st.st_size);
#line 335
    reset_table = 1;
    }
  }
#line 338
  if (reset_table) {
    {
#line 341
    lock.l_type = (short)1;
#line 342
    lock.l_whence = (short)0;
#line 343
    lock.l_start = (__off64_t )0;
#line 344
    lock.l_len = (__off64_t )0;
#line 346
    pr_trace_msg("delay", 8, "write-locking DelayTable \'%s\'", fh->fh_path);
    }
    {
#line 347
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 347
      tmp___27 = fcntl(fh->fh_fd, 14, & lock);
      }
#line 347
      if (! (tmp___27 < 0)) {
#line 347
        goto while_break___0;
      }
      {
#line 348
      tmp___26 = __errno_location();
      }
#line 348
      if (*tmp___26 == 4) {
        {
#line 349
        pr_signals_handle();
        }
#line 350
        goto while_continue___0;
      } else {
        {
#line 353
        tmp___22 = __errno_location();
#line 353
        tmp___23 = strerror(*tmp___22);
#line 353
        pr_log_pri(4, "mod_delay/0.6: unable to obtain write lock on DelayTable \'%s\': %s",
                   fh->fh_path, tmp___23);
#line 356
        tmp___24 = __errno_location();
#line 356
        tmp___25 = strerror(*tmp___24);
#line 356
        pr_trace_msg("delay", 1, "unable to obtain write lock on DelayTable \'%s\': %s",
                     fh->fh_path, tmp___25);
#line 359
        pr_fsio_close(fh);
        }
#line 360
        return (-1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 369
    lseek(fh->fh_fd, tab_size - 1LL, 0);
#line 370
    tmp___34 = write(fh->fh_fd, (void const   *)"", (size_t )1);
    }
#line 370
    if (tmp___34 != 1) {
      {
#line 371
      tmp___28 = __errno_location();
#line 371
      xerrno = *tmp___28;
#line 373
      tmp___29 = __errno_location();
#line 373
      tmp___30 = strerror(*tmp___29);
#line 373
      pr_log_pri(4, "mod_delay/0.6: error writing single byte to DelayTable \'%s\': %s",
                 fh->fh_path, tmp___30);
#line 376
      tmp___31 = __errno_location();
#line 376
      tmp___32 = strerror(*tmp___31);
#line 376
      pr_trace_msg("delay", 1, "error writing single byte to DelayTable \'%s\': %s",
                   fh->fh_path, tmp___32);
#line 380
      pr_fsio_close(fh);
#line 382
      tmp___33 = __errno_location();
#line 382
      *tmp___33 = xerrno;
      }
#line 383
      return (-1);
    }
    {
#line 387
    pr_fsio_ftruncate(fh, tab_size);
#line 389
    lock.l_type = (short)2;
#line 391
    pr_trace_msg("delay", 8, "unlocking DelayTable \'%s\'", fh->fh_path);
#line 392
    fcntl(fh->fh_fd, 13, & lock);
    }
  }
  {
#line 395
  delay_tab.dt_fd = fh->fh_fd;
#line 396
  delay_tab.dt_size = tab_size;
#line 398
  pr_trace_msg("delay", 8, "mapping DelayTable \'%s\' (%llu bytes, fd %d) into memory",
               fh->fh_path, (unsigned long long )delay_tab.dt_size, delay_tab.dt_fd);
#line 401
  delay_tab.dt_data = mmap((void *)0, (size_t )delay_tab.dt_size, 3, 1, delay_tab.dt_fd,
                           (__off64_t )0);
  }
#line 404
  if ((unsigned long )delay_tab.dt_data == (unsigned long )((void *)-1)) {
    {
#line 405
    tmp___35 = __errno_location();
#line 405
    xerrno___0 = *tmp___35;
#line 407
    delay_tab.dt_data = (void *)0;
#line 409
    tmp___36 = strerror(xerrno___0);
#line 409
    pr_log_pri(3, "mod_delay/0.6: error mapping DelayTable \'%s\' into memory: %s",
               delay_tab.dt_path, tmp___36);
#line 412
    tmp___37 = strerror(xerrno___0);
#line 412
    pr_trace_msg("delay", 1, "error mapping DelayTable \'%s\' into memory: %s", delay_tab.dt_path,
                 tmp___37);
#line 415
    pr_fsio_close(fh);
#line 416
    delay_tab.dt_fd = -1;
#line 418
    tmp___38 = __errno_location();
#line 418
    *tmp___38 = xerrno___0;
    }
#line 419
    return (-1);
  }
#line 422
  if (! reset_table) {
#line 425
    s = (server_rec *)server_list->xas_list;
    {
#line 425
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 425
      if (! s) {
#line 425
        goto while_break___1;
      }
      {
#line 426
      i___0 = s->sid - 1U;
#line 429
      row = (struct delay_rec *)delay_tab.dt_data + i___0;
#line 430
      tmp___39 = pr_netaddr_get_ipstr(s->addr);
#line 430
      tmp___40 = strcmp(tmp___39, (char const   *)(row->d_addr));
      }
#line 430
      if (tmp___40 != 0) {
#line 431
        reset_table = 1;
#line 432
        goto while_break___1;
      }
#line 435
      if (s->ServerPort != row->d_port) {
#line 436
        reset_table = 1;
#line 437
        goto while_break___1;
      }
      {
#line 441
      row = (struct delay_rec *)delay_tab.dt_data + (i___0 + 1U);
#line 442
      tmp___41 = pr_netaddr_get_ipstr(s->addr);
#line 442
      tmp___42 = strcmp(tmp___41, (char const   *)(row->d_addr));
      }
#line 442
      if (tmp___42 != 0) {
#line 443
        reset_table = 1;
#line 444
        goto while_break___1;
      }
#line 447
      if (s->ServerPort != row->d_port) {
#line 448
        reset_table = 1;
#line 449
        goto while_break___1;
      }
#line 425
      s = s->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 454
  if (reset_table) {
    {
#line 457
    lock___0.l_type = (short)1;
#line 458
    lock___0.l_whence = (short)0;
#line 459
    lock___0.l_start = (__off64_t )0;
#line 460
    lock___0.l_len = (__off64_t )0;
#line 462
    pr_trace_msg("delay", 8, "write-locking DelayTable \'%s\'", fh->fh_path);
    }
    {
#line 463
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 463
      tmp___48 = fcntl(fh->fh_fd, 14, & lock___0);
      }
#line 463
      if (! (tmp___48 < 0)) {
#line 463
        goto while_break___2;
      }
      {
#line 464
      tmp___47 = __errno_location();
      }
#line 464
      if (*tmp___47 == 4) {
        {
#line 465
        pr_signals_handle();
        }
#line 466
        goto while_continue___2;
      } else {
        {
#line 469
        tmp___43 = __errno_location();
#line 469
        tmp___44 = strerror(*tmp___43);
#line 469
        pr_log_pri(4, "mod_delay/0.6: unable to obtain write lock on DelayTable \'%s\': %s",
                   fh->fh_path, tmp___44);
#line 472
        tmp___45 = __errno_location();
#line 472
        tmp___46 = strerror(*tmp___45);
#line 472
        pr_trace_msg("delay", 1, "unable to obtain write lock on DelayTable \'%s\': %s",
                     fh->fh_path, tmp___46);
#line 475
        pr_fsio_close(fh);
        }
#line 476
        return (-1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 485
    lseek(fh->fh_fd, tab_size - 1LL, 0);
#line 486
    tmp___53 = write(fh->fh_fd, (void const   *)"", (size_t )1);
    }
#line 486
    if (tmp___53 != 1) {
      {
#line 487
      tmp___49 = __errno_location();
#line 487
      xerrno___1 = *tmp___49;
#line 489
      tmp___50 = strerror(xerrno___1);
#line 489
      pr_log_pri(4, "mod_delay/0.6: error writing single byte to DelayTable \'%s\': %s",
                 fh->fh_path, tmp___50);
#line 492
      tmp___51 = strerror(xerrno___1);
#line 492
      pr_trace_msg("delay", 1, "error writing single byte to DelayTable \'%s\': %s",
                   fh->fh_path, tmp___51);
#line 496
      pr_fsio_close(fh);
#line 498
      tmp___52 = __errno_location();
#line 498
      *tmp___52 = xerrno___1;
      }
#line 499
      return (-1);
    }
    {
#line 503
    pr_fsio_ftruncate(fh, tab_size);
#line 505
    pr_trace_msg("delay", 6, "resetting DelayTable \'%s\'", delay_tab.dt_path);
#line 506
    delay_table_reset();
#line 508
    lock___0.l_type = (short)2;
#line 510
    pr_trace_msg("delay", 8, "unlocking DelayTable \'%s\'", fh->fh_path);
#line 511
    fcntl(fh->fh_fd, 13, & lock___0);
    }
  }
  {
#line 515
  pr_trace_msg("delay", 8, "unmapping DelayTable \'%s\' from memory", delay_tab.dt_path);
#line 517
  tmp___60 = munmap(delay_tab.dt_data, (size_t )delay_tab.dt_size);
  }
#line 517
  if (tmp___60 < 0) {
    {
#line 518
    tmp___54 = __errno_location();
#line 518
    xerrno___2 = *tmp___54;
#line 519
    pr_fsio_close(fh);
#line 521
    tmp___55 = __errno_location();
#line 521
    *tmp___55 = xerrno___2;
#line 522
    tmp___56 = __errno_location();
#line 522
    tmp___57 = strerror(*tmp___56);
#line 522
    pr_log_pri(4, "mod_delay/0.6: error unmapping DelayTable \'%s\': %s", delay_tab.dt_path,
               tmp___57);
#line 525
    tmp___58 = __errno_location();
#line 525
    tmp___59 = strerror(*tmp___58);
#line 525
    pr_trace_msg("delay", 1, "error unmapping DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___59);
    }
#line 527
    return (-1);
  }
  {
#line 530
  delay_tab.dt_data = (void *)0;
#line 531
  delay_tab.dt_fd = -1;
#line 533
  tmp___65 = pr_fsio_close(fh);
  }
#line 533
  if (tmp___65 < 0) {
    {
#line 534
    tmp___61 = __errno_location();
#line 534
    tmp___62 = strerror(*tmp___61);
#line 534
    pr_log_pri(4, "mod_delay/0.6: error closing DelayTable \'%s\': %s", delay_tab.dt_path,
               tmp___62);
#line 537
    tmp___63 = __errno_location();
#line 537
    tmp___64 = strerror(*tmp___63);
#line 537
    pr_trace_msg("delay", 1, "error closing DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___64);
    }
#line 539
    return (-1);
  }
#line 542
  return (0);
}
}
#line 545 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_table_load(int lock_table ) 
{ 
  struct flock lock ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 547
  if (lock_table) {
    {
#line 549
    lock.l_type = (short)1;
#line 550
    lock.l_whence = (short)0;
#line 551
    lock.l_start = (__off64_t )0;
#line 552
    lock.l_len = (__off64_t )0;
#line 554
    pr_trace_msg("delay", 8, "write-locking DelayTable \'%s\'", delay_tab.dt_path);
    }
    {
#line 556
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 556
      tmp___0 = fcntl(delay_tab.dt_fd, 14, & lock);
      }
#line 556
      if (! (tmp___0 < 0)) {
#line 556
        goto while_break;
      }
      {
#line 557
      tmp = __errno_location();
      }
#line 557
      if (*tmp == 4) {
        {
#line 558
        pr_signals_handle();
        }
#line 559
        goto while_continue;
      } else {
#line 562
        return (-1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 566
  if ((unsigned long )delay_tab.dt_data == (unsigned long )((void *)0)) {
    {
#line 567
    pr_trace_msg("delay", 8, "mapping DelayTable \'%s\' (%llu bytes, fd %d) into memory",
                 delay_tab.dt_path, (unsigned long long )delay_tab.dt_size, delay_tab.dt_fd);
#line 570
    delay_tab.dt_data = mmap((void *)0, (size_t )delay_tab.dt_size, 3, 1, delay_tab.dt_fd,
                             (__off64_t )0);
    }
#line 573
    if ((unsigned long )delay_tab.dt_data == (unsigned long )((void *)-1)) {
#line 574
      delay_tab.dt_data = (void *)0;
#line 575
      return (-1);
    }
  }
#line 579
  return (0);
}
}
#line 582 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_table_reset(void) 
{ 
  server_rec *s ;
  unsigned int i___0 ;
  struct delay_rec *row ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 585
  s = (server_rec *)server_list->xas_list;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! s) {
#line 585
      goto while_break;
    }
    {
#line 586
    i___0 = s->sid - 1U;
#line 589
    row = (struct delay_rec *)delay_tab.dt_data + i___0;
#line 590
    row->d_sid = s->sid;
#line 591
    tmp = pr_netaddr_get_ipstr(s->addr);
#line 591
    sstrncpy(row->d_addr, tmp, (size_t )sizeof(row->d_addr));
#line 592
    row->d_port = s->ServerPort;
#line 593
    row->d_nvals = 0U;
#line 594
    memset((void *)(row->d_vals), 0, (size_t )sizeof(row->d_vals));
#line 597
    row = (struct delay_rec *)delay_tab.dt_data + (i___0 + 1U);
#line 598
    row->d_sid = s->sid;
#line 599
    tmp___0 = pr_netaddr_get_ipstr(s->addr);
#line 599
    sstrncpy(row->d_addr, tmp___0, (size_t )sizeof(row->d_addr));
#line 600
    row->d_port = s->ServerPort;
#line 601
    row->d_nvals = 0U;
#line 602
    memset((void *)(row->d_vals), 0, (size_t )sizeof(row->d_vals));
#line 585
    s = s->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  return;
}
}
#line 608 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_table_wlock(unsigned int rownum ) 
{ 
  struct flock lock ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 611
  lock.l_type = (short)1;
#line 612
  lock.l_whence = (short)0;
#line 613
  lock.l_start = (__off64_t )(sizeof(struct delay_rec ) * (unsigned long )rownum);
#line 614
  lock.l_len = (__off64_t )sizeof(struct delay_rec );
#line 616
  pr_trace_msg("delay", 8, "write-locking DelayTable \'%s\', row %u", delay_tab.dt_path,
               rownum + 1U);
  }
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 618
    tmp___2 = fcntl(delay_tab.dt_fd, 14, & lock);
    }
#line 618
    if (! (tmp___2 < 0)) {
#line 618
      goto while_break;
    }
    {
#line 619
    tmp = __errno_location();
    }
#line 619
    if (*tmp == 4) {
      {
#line 620
      pr_signals_handle();
      }
#line 621
      goto while_continue;
    }
    {
#line 624
    tmp___0 = __errno_location();
#line 624
    tmp___1 = strerror(*tmp___0);
#line 624
    pr_trace_msg("delay", 1, "error locking row: %s", tmp___1);
    }
#line 625
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return (0);
}
}
#line 631 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_table_unload(int unlock_table ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct flock lock ;
  int *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 633
  if (delay_tab.dt_data) {
    {
#line 634
    pr_trace_msg("delay", 8, "unmapping DelayTable \'%s\' from memory", delay_tab.dt_path);
#line 636
    tmp___3 = munmap(delay_tab.dt_data, (size_t )delay_tab.dt_size);
    }
#line 636
    if (tmp___3 < 0) {
      {
#line 637
      tmp = __errno_location();
#line 637
      tmp___0 = strerror(*tmp);
#line 637
      pr_log_pri(4, "mod_delay/0.6: error unmapping DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___0);
#line 640
      tmp___1 = __errno_location();
#line 640
      tmp___2 = strerror(*tmp___1);
#line 640
      pr_trace_msg("delay", 1, "error unmapping DelayTable \'%s\': %s", delay_tab.dt_path,
                   tmp___2);
      }
#line 642
      return (-1);
    }
#line 645
    delay_tab.dt_data = (void *)0;
  }
#line 648
  if (unlock_table) {
    {
#line 650
    lock.l_type = (short)2;
#line 651
    lock.l_whence = (short)0;
#line 652
    lock.l_start = (__off64_t )0;
#line 653
    lock.l_len = (__off64_t )0;
#line 655
    pr_trace_msg("delay", 8, "unlocking DelayTable \'%s\'", delay_tab.dt_path);
    }
    {
#line 656
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 656
      tmp___5 = fcntl(delay_tab.dt_fd, 13, & lock);
      }
#line 656
      if (! (tmp___5 < 0)) {
#line 656
        goto while_break;
      }
      {
#line 657
      tmp___4 = __errno_location();
      }
#line 657
      if (*tmp___4 == 4) {
        {
#line 658
        pr_signals_handle();
        }
#line 659
        goto while_continue;
      } else {
#line 662
        return (-1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 666
  return (0);
}
}
#line 669 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_table_unlock(unsigned int rownum ) 
{ 
  struct flock lock ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 672
  lock.l_type = (short)2;
#line 673
  lock.l_whence = (short)0;
#line 674
  lock.l_start = (__off64_t )(sizeof(struct delay_rec ) * (unsigned long )rownum);
#line 675
  lock.l_len = (__off64_t )sizeof(struct delay_rec );
#line 677
  pr_trace_msg("delay", 8, "unlocking DelayTable \'%s\', row %u", delay_tab.dt_path,
               rownum + 1U);
  }
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 679
    tmp___2 = fcntl(delay_tab.dt_fd, 14, & lock);
    }
#line 679
    if (! (tmp___2 < 0)) {
#line 679
      goto while_break;
    }
    {
#line 680
    tmp = __errno_location();
    }
#line 680
    if (*tmp == 4) {
      {
#line 681
      pr_signals_handle();
      }
#line 682
      goto while_continue;
    }
    {
#line 685
    tmp___0 = __errno_location();
#line 685
    tmp___1 = strerror(*tmp___0);
#line 685
    pr_trace_msg("delay", 1, "error unlocking row: %s", tmp___1);
    }
#line 686
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  return (0);
}
}
#line 908 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *set_delayctrlsacls(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 935
  tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "requires Controls support (--enable-ctrls)",
                (void *)0);
#line 935
  tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
  }
#line 935
  return (tmp___0);
}
}
#line 940 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *set_delayengine(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 944
  if (cmd->argc - 1 < 1) {
    {
#line 944
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 944
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 944
    return (tmp___0);
  }
  {
#line 945
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 945
  if (! tmp___5) {
    {
#line 945
    tmp___1 = get_context_name(cmd);
#line 945
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 945
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 945
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 945
    return (tmp___4);
  }
  {
#line 947
  bool = get_boolean(cmd, 1);
  }
#line 948
  if (bool == -1) {
    {
#line 949
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 949
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 949
    return (tmp___7);
  }
  {
#line 951
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 952
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 953
  *((unsigned int *)*(c->argv + 0)) = (unsigned int )bool;
#line 955
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 955
  return (tmp___8);
}
}
#line 959 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *set_delaytable(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 960
  if (cmd->argc - 1 < 1) {
    {
#line 960
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 960
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 960
    return (tmp___0);
  }
  {
#line 961
  tmp___5 = check_context(cmd, 1);
  }
#line 961
  if (! tmp___5) {
    {
#line 961
    tmp___1 = get_context_name(cmd);
#line 961
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 961
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 961
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 961
    return (tmp___4);
  }
  {
#line 963
  tmp___8 = pr_fs_valid_path((char const   *)*(cmd->argv + 1));
  }
#line 963
  if (tmp___8 < 0) {
    {
#line 964
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "must be an absolute path",
                      (void *)0);
#line 964
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 964
    return (tmp___7);
  }
  {
#line 966
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 967
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 967
  return (tmp___9);
}
}
#line 973 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *delay_post_pass(cmd_rec *cmd ) 
{ 
  struct timeval tv ;
  unsigned int rownum ;
  long interval ;
  long median ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 978
  if (! delay_engine) {
#line 979
    return ((modret_t *)((void *)0));
  }
  {
#line 986
  rownum = main_server->sid;
#line 989
  tmp___3 = delay_table_load(0);
  }
#line 989
  if (tmp___3 < 0) {
    {
#line 990
    tmp = __errno_location();
#line 990
    xerrno = *tmp;
#line 992
    tmp___0 = strerror(xerrno);
#line 992
    pr_log_pri(4, "mod_delay/0.6: unable to load DelayTable \'%s\' into memory: %s",
               delay_tab.dt_path, tmp___0);
#line 995
    tmp___1 = strerror(xerrno);
#line 995
    pr_trace_msg("delay", 1, "unable to load DelayTable \'%s\' into memory: %s", delay_tab.dt_path,
                 tmp___1);
#line 998
    tmp___2 = __errno_location();
#line 998
    *tmp___2 = xerrno;
    }
#line 999
    return ((modret_t *)((void *)0));
  }
  {
#line 1002
  delay_table_wlock(rownum);
#line 1004
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1006
  interval = (tv.tv_sec - delay_tv.tv_sec) * 1000000L + (tv.tv_usec - delay_tv.tv_usec);
#line 1010
  median = delay_get_median(cmd->tmp_pool, rownum, interval);
  }
#line 1016
  if (delay_npass < 16U) {
    {
#line 1017
    pr_trace_msg("delay", 8, "adding %ld usecs to PASS row", interval);
#line 1018
    delay_table_add_interval(rownum, interval);
#line 1019
    delay_npass ++;
    }
  } else {
    {
#line 1025
    pr_event_generate("mod_delay.max-pass", (void const   *)session.c);
    }
  }
  {
#line 1029
  delay_table_unlock(rownum);
#line 1030
  tmp___6 = delay_table_unload(0);
  }
#line 1030
  if (tmp___6 < 0) {
    {
#line 1031
    tmp___4 = __errno_location();
#line 1031
    tmp___5 = strerror(*tmp___4);
#line 1031
    pr_log_pri(4, "mod_delay/0.6: unable to unload DelayTable \'%s\' from memory: %s",
               delay_tab.dt_path, tmp___5);
    }
  }
#line 1039
  if (interval < median) {
    {
#line 1040
    delay_delay(median - interval);
    }
  }
#line 1042
  return ((modret_t *)((void *)0));
}
}
#line 1045 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *delay_pre_pass(cmd_rec *cmd ) 
{ 


  {
#line 1046
  if (! delay_engine) {
#line 1047
    return ((modret_t *)((void *)0));
  }
  {
#line 1049
  gettimeofday((struct timeval */* __restrict  */)(& delay_tv), (__timezone_ptr_t )((void *)0));
  }
#line 1050
  return ((modret_t *)((void *)0));
}
}
#line 1053 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *delay_post_user(cmd_rec *cmd ) 
{ 
  struct timeval tv ;
  unsigned int rownum ;
  long interval ;
  long median ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1058
  if (! delay_engine) {
#line 1059
    return ((modret_t *)((void *)0));
  }
  {
#line 1064
  rownum = main_server->sid - 1U;
#line 1067
  tmp___3 = delay_table_load(0);
  }
#line 1067
  if (tmp___3 < 0) {
    {
#line 1068
    tmp = __errno_location();
#line 1068
    xerrno = *tmp;
#line 1070
    tmp___0 = strerror(xerrno);
#line 1070
    pr_log_pri(4, "mod_delay/0.6: unable to load DelayTable \'%s\' into memory: %s",
               delay_tab.dt_path, tmp___0);
#line 1073
    tmp___1 = strerror(xerrno);
#line 1073
    pr_trace_msg("delay", 1, "unable to load DelayTable \'%s\' into memory: %s", delay_tab.dt_path,
                 tmp___1);
#line 1076
    tmp___2 = __errno_location();
#line 1076
    *tmp___2 = xerrno;
    }
#line 1077
    return ((modret_t *)((void *)0));
  }
  {
#line 1080
  delay_table_wlock(rownum);
#line 1082
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 1084
  interval = (tv.tv_sec - delay_tv.tv_sec) * 1000000L + (tv.tv_usec - delay_tv.tv_usec);
#line 1088
  median = delay_get_median(cmd->tmp_pool, rownum, interval);
  }
#line 1094
  if (delay_nuser < 16U) {
    {
#line 1095
    pr_trace_msg("delay", 8, "adding %ld usecs to USER row", interval);
#line 1096
    delay_table_add_interval(rownum, interval);
#line 1097
    delay_nuser ++;
    }
  } else {
    {
#line 1103
    pr_event_generate("mod_delay.max-user", (void const   *)session.c);
    }
  }
  {
#line 1106
  delay_table_unlock(rownum);
#line 1107
  tmp___6 = delay_table_unload(0);
  }
#line 1107
  if (tmp___6 < 0) {
    {
#line 1108
    tmp___4 = __errno_location();
#line 1108
    tmp___5 = strerror(*tmp___4);
#line 1108
    pr_log_pri(4, "mod_delay/0.6: unable to unload DelayTable \'%s\' from memory: %s",
               delay_tab.dt_path, tmp___5);
    }
  }
#line 1116
  if (interval < median) {
    {
#line 1117
    delay_delay(median - interval);
    }
  }
#line 1119
  return ((modret_t *)((void *)0));
}
}
#line 1122 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static modret_t *delay_pre_user(cmd_rec *cmd ) 
{ 


  {
#line 1123
  if (! delay_engine) {
#line 1124
    return ((modret_t *)((void *)0));
  }
  {
#line 1126
  gettimeofday((struct timeval */* __restrict  */)(& delay_tv), (__timezone_ptr_t )((void *)0));
  }
#line 1127
  return ((modret_t *)((void *)0));
}
}
#line 1133 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_exit_ev(void const   *event_data , void *user_data ) 
{ 
  pr_fh_t *fh ;
  char *data ;
  size_t datalen ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int xerrno ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 1138
  if (! delay_engine) {
#line 1139
    return;
  }
  {
#line 1145
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c",
               1145);
#line 1145
  pr_signals_block();
  }
#line 1145
  if (! session.disable_id_switching) {
    {
#line 1145
    tmp___1 = seteuid((__uid_t )0);
    }
#line 1145
    if (tmp___1) {
      {
#line 1145
      tmp = __errno_location();
#line 1145
      tmp___0 = strerror(*tmp);
#line 1145
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 1145
    tmp___4 = setegid((__gid_t )0);
    }
#line 1145
    if (tmp___4) {
      {
#line 1145
      tmp___2 = __errno_location();
#line 1145
      tmp___3 = strerror(*tmp___2);
#line 1145
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 1145
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 1145
  pr_signals_unblock();
#line 1146
  fh = pr_fsio_open(delay_tab.dt_path, 2);
#line 1147
  pr_signals_block();
  }
#line 1147
  if (! session.disable_id_switching) {
    {
#line 1147
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c",
                 1147);
#line 1147
    tmp___8 = geteuid();
    }
#line 1147
    if (tmp___8 != 0U) {
      {
#line 1147
      tmp___7 = seteuid((__uid_t )0);
      }
#line 1147
      if (tmp___7) {
        {
#line 1147
        tmp___5 = __errno_location();
#line 1147
        tmp___6 = strerror(*tmp___5);
#line 1147
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
        }
      }
    }
    {
#line 1147
    tmp___11 = setegid(session.gid);
    }
#line 1147
    if (tmp___11) {
      {
#line 1147
      tmp___9 = __errno_location();
#line 1147
      tmp___10 = strerror(*tmp___9);
#line 1147
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
      }
    }
    {
#line 1147
    tmp___14 = seteuid(session.uid);
    }
#line 1147
    if (tmp___14) {
      {
#line 1147
      tmp___12 = __errno_location();
#line 1147
      tmp___13 = strerror(*tmp___12);
#line 1147
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
      }
    }
  } else {
    {
#line 1147
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 1147
  pr_signals_unblock();
  }
#line 1149
  if (! fh) {
    {
#line 1150
    tmp___15 = __errno_location();
#line 1150
    tmp___16 = strerror(*tmp___15);
#line 1150
    pr_log_pri(4, "mod_delay/0.6: unable to open DelayTable \'%s\': %s", delay_tab.dt_path,
               tmp___16);
    }
#line 1153
    return;
  }
  {
#line 1156
  delay_tab.dt_fd = fh->fh_fd;
#line 1157
  delay_tab.dt_data = (void *)0;
#line 1159
  tmp___23 = delay_table_load(1);
  }
#line 1159
  if (tmp___23 < 0) {
    {
#line 1160
    tmp___17 = __errno_location();
#line 1160
    xerrno = *tmp___17;
#line 1161
    pr_fsio_close(fh);
#line 1163
    tmp___18 = __errno_location();
#line 1163
    *tmp___18 = xerrno;
#line 1164
    tmp___19 = __errno_location();
#line 1164
    tmp___20 = strerror(*tmp___19);
#line 1164
    pr_log_pri(4, "mod_delay/0.6: unable to load DelayTable \'%s\' into memory: %s",
               delay_tab.dt_path, tmp___20);
#line 1167
    tmp___21 = __errno_location();
#line 1167
    tmp___22 = strerror(*tmp___21);
#line 1167
    pr_trace_msg("delay", 1, "unable to load DelayTable \'%s\' into memory: %s", delay_tab.dt_path,
                 tmp___22);
    }
#line 1169
    return;
  }
  {
#line 1172
  datalen = (size_t )delay_tab.dt_size;
#line 1173
  tmp___24 = palloc(delay_pool, (int )datalen);
#line 1173
  data = (char *)tmp___24;
#line 1174
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)delay_tab.dt_data,
         datalen);
#line 1176
  tmp___27 = delay_table_unload(1);
  }
#line 1176
  if (tmp___27 < 0) {
    {
#line 1177
    tmp___25 = __errno_location();
#line 1177
    tmp___26 = strerror(*tmp___25);
#line 1177
    pr_log_pri(4, "mod_delay/0.6: error unloading DelayTable \'%s\' from memory: %s",
               delay_tab.dt_path, tmp___26);
    }
  }
  {
#line 1182
  tmp___30 = pr_fsio_write(fh, (char const   *)data, datalen);
  }
#line 1182
  if (tmp___30 < 0) {
    {
#line 1183
    tmp___28 = __errno_location();
#line 1183
    tmp___29 = strerror(*tmp___28);
#line 1183
    pr_log_pri(4, "mod_delay/0.6: error updating DelayTable \'%s\': %s", delay_tab.dt_path,
               tmp___29);
    }
  }
  {
#line 1188
  delay_tab.dt_fd = -1;
#line 1189
  tmp___33 = pr_fsio_close(fh);
  }
#line 1189
  if (tmp___33 < 0) {
    {
#line 1190
    tmp___31 = __errno_location();
#line 1190
    tmp___32 = strerror(*tmp___31);
#line 1190
    pr_log_pri(4, "mod_delay/0.6: error writing DelayTable \'%s\': %s", delay_tab.dt_path,
               tmp___32);
    }
  }
#line 1195
  return;
}
}
#line 1198 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_postparse_ev(void const   *event_data , void *user_data ) 
{ 
  config_rec *c ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1201
  c = find_config(main_server->conf, 1 << 15, "DelayEngine", 0);
  }
#line 1202
  if (c) {
#line 1202
    if (*((unsigned int *)*(c->argv + 0)) == 0U) {
#line 1203
      delay_engine = 0U;
    }
  }
#line 1205
  if (! delay_engine) {
#line 1206
    return;
  }
  {
#line 1208
  c = find_config(main_server->conf, 1 << 15, "DelayTable", 0);
  }
#line 1209
  if (c) {
#line 1210
    delay_tab.dt_path = (char const   *)*(c->argv + 0);
  }
  {
#line 1212
  delay_table_init();
  }
#line 1213
  return;
}
}
#line 1216 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static void delay_restart_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;

  {
#line 1217
  if (delay_pool) {
    {
#line 1218
    destroy_pool(delay_pool);
    }
  }
  {
#line 1220
  delay_pool = make_sub_pool(permanent_pool);
#line 1221
  pr_pool_tag(delay_pool, "mod_delay/0.6");
  }
#line 1223
  return;
}
}
#line 1229 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1230
  delay_tab.dt_path = "/usr/local/var/proftpd/proftpd.delay";
#line 1231
  delay_tab.dt_data = (void *)0;
#line 1233
  pr_event_register(& delay_module, "core.exit", & delay_exit_ev, (void *)0);
#line 1234
  pr_event_register(& delay_module, "core.postparse", & delay_postparse_ev, (void *)0);
#line 1235
  pr_event_register(& delay_module, "core.restart", & delay_restart_ev, (void *)0);
#line 1237
  delay_pool = make_sub_pool(permanent_pool);
#line 1238
  pr_pool_tag(delay_pool, "mod_delay/0.6");
  }
#line 1256
  return (0);
}
}
#line 1259 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static int delay_sess_init(void) 
{ 
  pr_fh_t *fh ;
  config_rec *c ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 1263
  pr_event_unregister(& delay_module, "core.exit", & delay_exit_ev);
  }
#line 1265
  if (! delay_engine) {
#line 1266
    return (0);
  }
  {
#line 1271
  c = find_config(main_server->conf, 1 << 15, "DelayEngine", 0);
  }
#line 1272
  if (c) {
#line 1272
    if (*((unsigned int *)*(c->argv + 0)) == 0U) {
#line 1273
      delay_engine = 0U;
    }
  }
#line 1275
  if (! delay_engine) {
#line 1276
    return (0);
  }
  {
#line 1278
  delay_nuser = 0U;
#line 1279
  delay_npass = 0U;
#line 1281
  pr_trace_msg("delay", 6, "opening DelayTable \'%s\'", delay_tab.dt_path);
#line 1283
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c",
               1283);
#line 1283
  pr_signals_block();
  }
#line 1283
  if (! session.disable_id_switching) {
    {
#line 1283
    tmp___1 = seteuid((__uid_t )0);
    }
#line 1283
    if (tmp___1) {
      {
#line 1283
      tmp = __errno_location();
#line 1283
      tmp___0 = strerror(*tmp);
#line 1283
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 1283
    tmp___4 = setegid((__gid_t )0);
    }
#line 1283
    if (tmp___4) {
      {
#line 1283
      tmp___2 = __errno_location();
#line 1283
      tmp___3 = strerror(*tmp___2);
#line 1283
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 1283
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 1283
  pr_signals_unblock();
#line 1284
  fh = pr_fsio_open(delay_tab.dt_path, 2);
#line 1285
  pr_signals_block();
  }
#line 1285
  if (! session.disable_id_switching) {
    {
#line 1285
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c",
                 1285);
#line 1285
    tmp___8 = geteuid();
    }
#line 1285
    if (tmp___8 != 0U) {
      {
#line 1285
      tmp___7 = seteuid((__uid_t )0);
      }
#line 1285
      if (tmp___7) {
        {
#line 1285
        tmp___5 = __errno_location();
#line 1285
        tmp___6 = strerror(*tmp___5);
#line 1285
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
        }
      }
    }
    {
#line 1285
    tmp___11 = setegid(session.gid);
    }
#line 1285
    if (tmp___11) {
      {
#line 1285
      tmp___9 = __errno_location();
#line 1285
      tmp___10 = strerror(*tmp___9);
#line 1285
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
      }
    }
    {
#line 1285
    tmp___14 = seteuid(session.uid);
    }
#line 1285
    if (tmp___14) {
      {
#line 1285
      tmp___12 = __errno_location();
#line 1285
      tmp___13 = strerror(*tmp___12);
#line 1285
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
      }
    }
  } else {
    {
#line 1285
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 1285
  pr_signals_unblock();
  }
#line 1287
  if (! fh) {
    {
#line 1288
    tmp___15 = __errno_location();
#line 1288
    tmp___16 = strerror(*tmp___15);
#line 1288
    pr_log_pri(4, "mod_delay/0.6: unable to open DelayTable \'%s\': %s", delay_tab.dt_path,
               tmp___16);
#line 1291
    tmp___17 = __errno_location();
#line 1291
    tmp___18 = strerror(*tmp___17);
#line 1291
    pr_trace_msg("delay", 1, "unable to open DelayTable \'%s\': %s", delay_tab.dt_path,
                 tmp___18);
#line 1293
    delay_engine = 0U;
    }
#line 1294
    return (0);
  }
#line 1297
  delay_tab.dt_fd = fh->fh_fd;
#line 1298
  delay_tab.dt_data = (void *)0;
#line 1300
  return (0);
}
}
#line 1314 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static conftable delay_conftab[4]  = {      {(char *)"DelayControlsACLs", & set_delayctrlsacls, (module *)((void *)0)}, 
        {(char *)"DelayEngine", & set_delayengine, (module *)((void *)0)}, 
        {(char *)"DelayTable", & set_delaytable, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))0, (module *)0}};
#line 1321 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
static cmdtable delay_cmdtab[7]  = {      {(unsigned char)1, (char *)"PASS", (char *)((void *)0), & delay_pre_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & delay_post_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)4, (char *)"PASS", (char *)((void *)0), & delay_post_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)1, (char *)"USER", (char *)((void *)0), & delay_pre_user, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)3, (char *)"USER", (char *)((void *)0), & delay_post_user, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)4, (char *)"USER", (char *)((void *)0), & delay_post_user, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 1331 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_delay.c"
module delay_module  = 
#line 1331
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"delay", delay_conftab,
    delay_cmdtab, (authtable *)((void *)0), & delay_init, & delay_sess_init, (char *)"mod_delay/0.6",
    (void *)0, 0};
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 309 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 68 "../include/support.h"
char *dir_realpath(pool *p , char const   *path ) ;
#line 189 "../include/modules.h"
int (*cmd_auth_chk)(cmd_rec * ) ;
#line 202
int core_chgrp(cmd_rec *cmd , char *dir , uid_t uid , gid_t gid ) ;
#line 203
int core_chmod(cmd_rec *cmd , char *dir , mode_t mode ) ;
#line 62 "../include/response.h"
void ( /* format attribute */  pr_response_send)(char const   *resp_numeric , char const   *fmt 
                                                 , ...) ;
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
modret_t *site_dispatch(cmd_rec *cmd ) ;
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static struct __anonstruct__help_84 _help[4]  = {      {(char *)"HELP", (char *)"[<sp> site-command]", 1}, 
        {(char *)"CHGRP", (char *)"<sp> group <sp> pathname", 1}, 
        {(char *)"CHMOD", (char *)"<sp> mode <sp> pathname", 1}, 
        {(char *)((void *)0), (char *)((void *)0), 0}};
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static char *_get_full_cmd(cmd_rec *cmd ) 
{ 
  char *res ;
  size_t reslen ;
  int i___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 54
  res = (char *)"";
#line 55
  reslen = (size_t )0;
#line 58
  i___0 = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i___0 < cmd->argc)) {
#line 58
      goto while_break;
    }
    {
#line 59
    res = pstrcat(cmd->tmp_pool, res, *(cmd->argv + i___0), " ", (void *)0);
#line 58
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  reslen = strlen((char const   *)res);
  }
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (reslen >= 1U) {
#line 62
      if (! ((int )*(res + (reslen - 1U)) == 32)) {
#line 62
        goto while_break___0;
      }
    } else {
#line 62
      goto while_break___0;
    }
    {
#line 64
    *(res + (reslen - 1U)) = (char )'\000';
#line 65
    reslen = strlen((char const   *)res);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 68
  return (res);
}
}
#line 71 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static modret_t *site_chgrp(cmd_rec *cmd ) 
{ 
  gid_t gid ;
  char *path ;
  char *tmp ;
  char *arg ;
  register unsigned int i___0 ;
  regex_t *preg ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  xaset_t *tmp___3 ;
  xaset_t *tmp___4 ;
  void *tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  xaset_t *tmp___8 ;
  xaset_t *tmp___9 ;
  void *tmp___10 ;
  modret_t *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  int tmp___22 ;
  modret_t *tmp___23 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
#line 73
  path = (char *)((void *)0);
#line 73
  tmp = (char *)((void *)0);
#line 73
  arg = (char *)"";
#line 74
  i___0 = 0U;
#line 79
  if (cmd->argc < 3) {
    {
#line 80
    tmp___0 = _get_full_cmd(cmd);
#line 80
    pr_response_add_err("500", "\'SITE %s\' not understood", tmp___0);
    }
#line 82
    return ((modret_t *)((void *)0));
  }
#line 88
  i___0 = 2U;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i___0 <= (unsigned int )(cmd->argc - 1))) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___1 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)*(cmd->argv + i___0));
    }
#line 89
    if (*arg) {
#line 89
      tmp___2 = " ";
    } else {
#line 89
      tmp___2 = "";
    }
    {
#line 89
    arg = pstrcat(cmd->tmp_pool, arg, tmp___2, tmp___1, (void *)0);
#line 88
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (session.dir_config) {
#line 93
    tmp___4 = (session.dir_config)->subset;
  } else {
#line 93
    if (session.anon_config) {
#line 93
      tmp___3 = (session.anon_config)->subset;
    } else {
#line 93
      tmp___3 = main_server->conf;
    }
#line 93
    tmp___4 = tmp___3;
  }
  {
#line 93
  tmp___5 = get_param_ptr(tmp___4, "PathAllowFilter", 0);
#line 93
  preg = (regex_t *)tmp___5;
  }
#line 95
  if (preg) {
    {
#line 95
    tmp___7 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)arg,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 95
    if (tmp___7 != 0) {
      {
#line 97
      pr_log_debug(2, "\'%s %s\' denied by PathAllowFilter", *(cmd->argv + 0), arg);
#line 99
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 100
      tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 100
      return (tmp___6);
    }
  }
#line 103
  if (session.dir_config) {
#line 103
    tmp___9 = (session.dir_config)->subset;
  } else {
#line 103
    if (session.anon_config) {
#line 103
      tmp___8 = (session.anon_config)->subset;
    } else {
#line 103
      tmp___8 = main_server->conf;
    }
#line 103
    tmp___9 = tmp___8;
  }
  {
#line 103
  tmp___10 = get_param_ptr(tmp___9, "PathDenyFilter", 0);
#line 103
  preg = (regex_t *)tmp___10;
  }
#line 105
  if (preg) {
    {
#line 105
    tmp___12 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)arg,
                       (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 105
    if (tmp___12 == 0) {
      {
#line 107
      pr_log_debug(2, "\'%s %s\' denied by PathDenyFilter", *(cmd->argv + 0), arg);
#line 109
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 110
      tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 110
      return (tmp___11);
    }
  }
  {
#line 114
  path = dir_realpath(cmd->tmp_pool, (char const   *)arg);
  }
#line 116
  if (! path) {
    {
#line 117
    tmp___13 = __errno_location();
#line 117
    tmp___14 = strerror(*tmp___13);
#line 117
    pr_response_add_err("550", "%s: %s", arg, tmp___14);
#line 118
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 118
    return (tmp___15);
  }
  {
#line 124
  tmp___16 = strtoul((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& tmp),
                     10);
#line 124
  gid = (gid_t )tmp___16;
  }
#line 126
  if (tmp) {
#line 126
    if (*tmp) {
      {
#line 129
      gid = pr_auth_name2gid(cmd->tmp_pool, (char const   *)*(cmd->argv + 1));
      }
#line 130
      if (gid == 4294967295U) {
        {
#line 131
        tmp___17 = strerror(22);
#line 131
        pr_response_add_err("550", "%s: %s", arg, tmp___17);
#line 132
        tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 132
        return (tmp___18);
      }
    }
  }
  {
#line 136
  tmp___22 = core_chgrp(cmd, path, (uid_t )-1, gid);
  }
#line 136
  if (tmp___22 == -1) {
    {
#line 137
    tmp___19 = __errno_location();
#line 137
    tmp___20 = strerror(*tmp___19);
#line 137
    pr_response_add_err("550", "%s: %s", arg, tmp___20);
#line 138
    tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 138
    return (tmp___21);
  } else {
    {
#line 141
    pr_response_add("200", "SITE %s command successful", *(cmd->argv + 0));
    }
  }
  {
#line 143
  tmp___23 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 143
  return (tmp___23);
}
}
#line 146 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static modret_t *site_chmod(cmd_rec *cmd ) 
{ 
  mode_t mode ;
  char *dir ;
  char *endp ;
  char *tmp ;
  char *arg ;
  register unsigned int i___0 ;
  regex_t *preg ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  xaset_t *tmp___3 ;
  xaset_t *tmp___4 ;
  void *tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  xaset_t *tmp___8 ;
  xaset_t *tmp___9 ;
  void *tmp___10 ;
  modret_t *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  long tmp___16 ;
  char *cp ;
  int mask ;
  int mode_op ;
  int curmode ;
  int curumask ;
  __mode_t tmp___17 ;
  int invalid ;
  char *who ;
  char *how ;
  char *what ;
  struct stat st ;
  int tmp___18 ;
  modret_t *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  modret_t *tmp___22 ;
  int tmp___23 ;
  modret_t *tmp___24 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
#line 147
  mode = (mode_t )0;
#line 148
  arg = (char *)"";
#line 149
  i___0 = 0U;
#line 154
  if (cmd->argc < 3) {
    {
#line 155
    tmp___0 = _get_full_cmd(cmd);
#line 155
    pr_response_add_err("500", "\'SITE %s\' not understood", tmp___0);
    }
#line 157
    return ((modret_t *)((void *)0));
  }
#line 163
  i___0 = 2U;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i___0 <= (unsigned int )(cmd->argc - 1))) {
#line 163
      goto while_break;
    }
    {
#line 164
    tmp___1 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)*(cmd->argv + i___0));
    }
#line 164
    if (*arg) {
#line 164
      tmp___2 = " ";
    } else {
#line 164
      tmp___2 = "";
    }
    {
#line 164
    arg = pstrcat(cmd->tmp_pool, arg, tmp___2, tmp___1, (void *)0);
#line 163
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (session.dir_config) {
#line 168
    tmp___4 = (session.dir_config)->subset;
  } else {
#line 168
    if (session.anon_config) {
#line 168
      tmp___3 = (session.anon_config)->subset;
    } else {
#line 168
      tmp___3 = main_server->conf;
    }
#line 168
    tmp___4 = tmp___3;
  }
  {
#line 168
  tmp___5 = get_param_ptr(tmp___4, "PathAllowFilter", 0);
#line 168
  preg = (regex_t *)tmp___5;
  }
#line 170
  if (preg) {
    {
#line 170
    tmp___7 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)arg,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 170
    if (tmp___7 != 0) {
      {
#line 172
      pr_log_debug(2, "\'%s %s %s\' denied by PathAllowFilter", *(cmd->argv + 0),
                   *(cmd->argv + 1), arg);
#line 174
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 175
      tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 175
      return (tmp___6);
    }
  }
#line 178
  if (session.dir_config) {
#line 178
    tmp___9 = (session.dir_config)->subset;
  } else {
#line 178
    if (session.anon_config) {
#line 178
      tmp___8 = (session.anon_config)->subset;
    } else {
#line 178
      tmp___8 = main_server->conf;
    }
#line 178
    tmp___9 = tmp___8;
  }
  {
#line 178
  tmp___10 = get_param_ptr(tmp___9, "PathDenyFilter", 0);
#line 178
  preg = (regex_t *)tmp___10;
  }
#line 180
  if (preg) {
    {
#line 180
    tmp___12 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)arg,
                       (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 180
    if (tmp___12 == 0) {
      {
#line 182
      pr_log_debug(2, "\'%s %s %s\' denied by PathDenyFilter", *(cmd->argv + 0), *(cmd->argv + 1),
                   arg);
#line 184
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 185
      tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 185
      return (tmp___11);
    }
  }
  {
#line 189
  dir = dir_realpath(cmd->tmp_pool, (char const   *)arg);
  }
#line 191
  if (! dir) {
    {
#line 192
    tmp___13 = __errno_location();
#line 192
    tmp___14 = strerror(*tmp___13);
#line 192
    pr_response_add_err("550", "%s: %s", arg, tmp___14);
#line 193
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 193
    return (tmp___15);
  }
#line 201
  if ((int )*(*(cmd->argv + 1) + 0) != 48) {
    {
#line 202
    tmp = pstrcat(cmd->tmp_pool, "0", *(cmd->argv + 1), (void *)0);
    }
  } else {
#line 204
    tmp = *(cmd->argv + 1);
  }
  {
#line 206
  tmp___16 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)(& endp),
                    0);
#line 206
  mode = (mode_t )tmp___16;
  }
#line 207
  if (endp) {
#line 207
    if (*endp) {
      {
#line 209
      cp = *(cmd->argv + 1);
#line 210
      mask = 0;
#line 210
      mode_op = 0;
#line 210
      curmode = 0;
#line 210
      tmp___17 = umask((__mode_t )0);
#line 210
      curumask = (int )tmp___17;
#line 211
      invalid = 0;
#line 215
      umask((__mode_t )curumask);
#line 216
      mode = (mode_t )0;
#line 218
      tmp___18 = pr_fsio_stat((char const   *)dir, & st);
      }
#line 218
      if (tmp___18 != -1) {
#line 219
        curmode = (int )st.st_mode;
      }
      {
#line 221
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 222
        who = pstrdup(cmd->tmp_pool, (char const   *)cp);
#line 224
        tmp = strpbrk((char const   *)who, "+-=");
        }
#line 225
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
#line 226
          how = pstrdup(cmd->tmp_pool, (char const   *)tmp);
          }
#line 227
          if ((int )*how != 61) {
#line 228
            mode = (mode_t )curmode;
          }
#line 230
          *tmp = (char )'\000';
        } else {
#line 233
          invalid ++;
#line 234
          goto while_break___0;
        }
        {
#line 237
        tmp = strpbrk((char const   *)how, "rwxXstugo");
        }
#line 238
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
#line 239
          what = pstrdup(cmd->tmp_pool, (char const   *)tmp);
#line 240
          *tmp = (char )'\000';
          }
        } else {
#line 243
          invalid ++;
#line 244
          goto while_break___0;
        }
#line 247
        cp = what;
        {
#line 248
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 248
          if (! cp) {
#line 248
            goto while_break___1;
          }
          {
#line 250
          if ((int )*who == 117) {
#line 250
            goto case_117;
          }
#line 254
          if ((int )*who == 103) {
#line 254
            goto case_103;
          }
#line 258
          if ((int )*who == 111) {
#line 258
            goto case_111;
          }
#line 262
          if ((int )*who == 97) {
#line 262
            goto case_97;
          }
#line 266
          if ((int )*who == 0) {
#line 266
            goto case_0;
          }
#line 270
          goto switch_default;
          case_117: /* CIL Label */ 
#line 251
          mask = 63;
#line 252
          goto switch_break;
          case_103: /* CIL Label */ 
#line 255
          mask = 455;
#line 256
          goto switch_break;
          case_111: /* CIL Label */ 
#line 259
          mask = 504;
#line 260
          goto switch_break;
          case_97: /* CIL Label */ 
#line 263
          mask = 0;
#line 264
          goto switch_break;
          case_0: /* CIL Label */ 
#line 267
          mask = curumask;
#line 268
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 271
          invalid ++;
#line 272
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 275
          if (invalid) {
#line 276
            goto while_break___1;
          }
          {
#line 281
          if ((int )*how == 61) {
#line 281
            goto case_61;
          }
#line 281
          if ((int )*how == 45) {
#line 281
            goto case_61;
          }
#line 281
          if ((int )*how == 43) {
#line 281
            goto case_61;
          }
#line 284
          goto switch_default___0;
          case_61: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_43: /* CIL Label */ 
#line 282
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
#line 285
          invalid ++;
          switch_break___0: /* CIL Label */ ;
          }
#line 288
          if (invalid) {
#line 289
            goto while_break___1;
          }
          {
#line 292
          if ((int )*cp == 114) {
#line 292
            goto case_114;
          }
#line 296
          if ((int )*cp == 119) {
#line 296
            goto case_119;
          }
#line 299
          if ((int )*cp == 120) {
#line 299
            goto case_120;
          }
#line 304
          if ((int )*cp == 115) {
#line 304
            goto case_115;
          }
#line 309
          if ((int )*cp == 116) {
#line 309
            goto case_116;
          }
#line 314
          if ((int )*cp == 111) {
#line 314
            goto case_111___0;
          }
#line 320
          if ((int )*cp == 103) {
#line 320
            goto case_103___0;
          }
#line 326
          if ((int )*cp == 117) {
#line 326
            goto case_117___0;
          }
#line 332
          if ((int )*cp == 0) {
#line 332
            goto case_0___0;
          }
#line 356
          goto switch_default___1;
          case_114: /* CIL Label */ 
#line 293
          mode_op |= (256 | (256 >> 3)) | ((256 >> 3) >> 3);
#line 294
          goto switch_break___1;
          case_119: /* CIL Label */ 
#line 297
          mode_op |= (128 | (128 >> 3)) | ((128 >> 3) >> 3);
#line 298
          goto switch_break___1;
          case_120: /* CIL Label */ 
#line 300
          mode_op |= (64 | (64 >> 3)) | ((64 >> 3) >> 3);
#line 301
          goto switch_break___1;
          case_115: /* CIL Label */ 
#line 306
          mode_op |= 2048;
#line 307
          goto switch_break___1;
          case_116: /* CIL Label */ 
#line 311
          mode_op |= 512;
#line 312
          goto switch_break___1;
          case_111___0: /* CIL Label */ 
#line 315
          mode_op |= curmode & ((448 >> 3) >> 3);
#line 316
          mode_op |= (curmode & ((448 >> 3) >> 3)) << 3;
#line 317
          mode_op |= (curmode & ((448 >> 3) >> 3)) << 6;
#line 318
          goto switch_break___1;
          case_103___0: /* CIL Label */ 
#line 321
          mode_op |= (curmode & (448 >> 3)) >> 3;
#line 322
          mode_op |= curmode & (448 >> 3);
#line 323
          mode_op |= (curmode & (448 >> 3)) << 3;
#line 324
          goto switch_break___1;
          case_117___0: /* CIL Label */ 
#line 327
          mode_op |= (curmode & ((448 >> 3) >> 3)) >> 6;
#line 328
          mode_op |= (curmode & ((448 >> 3) >> 3)) >> 3;
#line 329
          mode_op |= curmode & 448;
#line 330
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
          {
#line 336
          if ((int )*how == 61) {
#line 336
            goto case_61___0;
          }
#line 336
          if ((int )*how == 43) {
#line 336
            goto case_61___0;
          }
#line 340
          if ((int )*how == 45) {
#line 340
            goto case_45___0;
          }
#line 334
          goto switch_break___2;
          case_61___0: /* CIL Label */ 
          case_43___0: /* CIL Label */ 
#line 337
          mode |= (unsigned int )(mode_op & ~ mask);
#line 338
          goto switch_break___2;
          case_45___0: /* CIL Label */ 
#line 341
          mode &= (unsigned int )(~ (mode_op & ~ mask));
#line 342
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
#line 345
          mode_op = 0;
#line 346
          if (*who) {
#line 346
            if (*(who + 1)) {
#line 347
              who ++;
#line 348
              cp = what;
#line 349
              goto while_continue___1;
            } else {
#line 352
              cp = (char *)((void *)0);
            }
          } else {
#line 352
            cp = (char *)((void *)0);
          }
#line 354
          goto switch_break___1;
          switch_default___1: /* CIL Label */ 
#line 357
          invalid ++;
          switch_break___1: /* CIL Label */ ;
          }
#line 360
          if (invalid) {
#line 361
            goto while_break___1;
          }
#line 363
          if (cp) {
#line 364
            cp ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 366
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 369
      if (invalid) {
        {
#line 370
        pr_response_add_err("550", "\'%s\': invalid mode", *(cmd->argv + 1));
#line 371
        tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 371
        return (tmp___19);
      }
    }
  }
  {
#line 375
  tmp___23 = core_chmod(cmd, dir, mode);
  }
#line 375
  if (tmp___23 == -1) {
    {
#line 376
    tmp___20 = __errno_location();
#line 376
    tmp___21 = strerror(*tmp___20);
#line 376
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___21);
#line 377
    tmp___22 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 377
    return (tmp___22);
  } else {
    {
#line 380
    pr_response_add("200", "SITE %s command successful", *(cmd->argv + 0));
    }
  }
  {
#line 382
  tmp___24 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 382
  return (tmp___24);
}
}
#line 385 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static modret_t *site_help(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *cp ;
  int tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  modret_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 386
  i___0 = 0U;
#line 393
  if (cmd->argc == 1) {
#line 393
    goto _L___1;
  } else
#line 393
  if (cmd->argc == 2) {
    {
#line 393
    tmp___6 = strcasecmp((char const   *)*(cmd->argv + 0), "SITE");
    }
#line 393
    if (tmp___6 == 0) {
      {
#line 393
      tmp___7 = strcasecmp((char const   *)*(cmd->argv + 1), "HELP");
      }
#line 393
      if (tmp___7 == 0) {
#line 393
        goto _L___1;
      } else {
#line 393
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 393
      tmp___8 = strcasecmp((char const   *)*(cmd->argv + 0), "HELP");
      }
#line 393
      if (tmp___8 == 0) {
        {
#line 393
        tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "SITE");
        }
#line 393
        if (tmp___9 == 0) {
          _L___1: /* CIL Label */ 
#line 399
          i___0 = 0U;
          {
#line 399
          while (1) {
            while_continue: /* CIL Label */ ;
#line 399
            if (! _help[i___0].cmd) {
#line 399
              goto while_break;
            }
#line 400
            if (_help[i___0].implemented) {
#line 401
              if (i___0 != 0U) {
#line 401
                tmp = (char const   *)((void *)0);
              } else {
#line 401
                tmp = "214";
              }
              {
#line 401
              pr_response_add(tmp, "%s", _help[i___0].cmd);
              }
            } else {
              {
#line 403
              tmp___0 = pstrcat(cmd->pool, _help[i___0].cmd, "*", (void *)0);
              }
#line 403
              if (i___0 != 0U) {
#line 403
                tmp___1 = (char const   *)((void *)0);
              } else {
#line 403
                tmp___1 = "214";
              }
              {
#line 403
              pr_response_add(tmp___1, "%s", tmp___0);
              }
            }
#line 399
            i___0 ++;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 393
          goto _L___0;
        }
      } else {
#line 393
        goto _L___0;
      }
    }
  } else {
    _L___0: /* CIL Label */ 
#line 408
    cp = (char *)((void *)0);
#line 410
    cp = *(cmd->argv + 1);
    {
#line 410
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 410
      if (! *cp) {
#line 410
        goto while_break___0;
      }
      {
#line 411
      tmp___2 = toupper((int )*cp);
#line 411
      *cp = (char )tmp___2;
#line 410
      cp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 413
    i___0 = 0U;
    {
#line 413
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 413
      if (! _help[i___0].cmd) {
#line 413
        goto while_break___1;
      }
      {
#line 414
      tmp___4 = strcasecmp((char const   *)*(cmd->argv + 1), (char const   *)_help[i___0].cmd);
      }
#line 414
      if (tmp___4 == 0) {
        {
#line 415
        pr_response_add("214", "Syntax: SITE %s %s", *(cmd->argv + 1), _help[i___0].syntax);
#line 417
        tmp___3 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
        }
#line 417
        return (tmp___3);
      }
#line 413
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 420
    pr_response_add_err("502", "Unknown command \'SITE %s\'", cmd->arg);
#line 421
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 421
    return (tmp___5);
  }
  {
#line 424
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 424
  return (tmp___10);
}
}
#line 431 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static cmdtable site_commands[4]  = {      {(unsigned char)2, (char *)"HELP", (char *)((void *)0), & site_help, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"CHGRP", (char *)((void *)0), & site_chgrp, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"CHMOD", (char *)((void *)0), & site_chmod, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 438 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
modret_t *site_dispatch(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  modret_t *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 439
  i___0 = 0U;
#line 441
  if (! cmd->argc) {
    {
#line 442
    pr_response_add_err("500", "\'SITE\' requires parameters");
#line 443
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 443
    return (tmp);
  }
#line 446
  i___0 = 0U;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! site_commands[i___0].command) {
#line 446
      goto while_break;
    }
    {
#line 447
    tmp___3 = strcmp((char const   *)*(cmd->argv + 0), (char const   *)site_commands[i___0].command);
    }
#line 447
    if (tmp___3 == 0) {
#line 448
      if (site_commands[i___0].requires_auth) {
#line 448
        if (cmd_auth_chk) {
          {
#line 448
          tmp___2 = (*cmd_auth_chk)(cmd);
          }
#line 448
          if (tmp___2) {
            {
#line 454
            tmp___1 = (*(site_commands[i___0].handler))(cmd);
            }
#line 454
            return (tmp___1);
          } else {
            {
#line 450
            pr_response_send("530", "Please login with USER and PASS");
#line 451
            tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
            }
#line 451
            return (tmp___0);
          }
        } else {
          {
#line 454
          tmp___1 = (*(site_commands[i___0].handler))(cmd);
          }
#line 454
          return (tmp___1);
        }
      } else {
        {
#line 454
        tmp___1 = (*(site_commands[i___0].handler))(cmd);
        }
#line 454
        return (tmp___1);
      }
    }
#line 446
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 457
  pr_response_add_err("500", "\'SITE %s\' not understood", *(cmd->argv + 0));
#line 458
  tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 458
  return (tmp___4);
}
}
#line 464 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static modret_t *site_pre_cmd(cmd_rec *cmd ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 465
  if (cmd->argc > 1) {
    {
#line 465
    tmp = strcasecmp((char const   *)*(cmd->argv + 1), "help");
    }
#line 465
    if (! tmp) {
      {
#line 466
      pr_response_add("214", "The following SITE commands are recognized (* =>\'s unimplemented)");
      }
    }
  }
#line 468
  return ((modret_t *)((void *)0));
}
}
#line 471 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static modret_t *site_cmd(cmd_rec *cmd ) 
{ 
  char *cp ;
  cmd_rec *tmpcmd ;
  void *tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 472
  cp = (char *)((void *)0);
#line 473
  tmpcmd = (cmd_rec *)((void *)0);
#line 476
  tmp = pcalloc(cmd->pool, (int )sizeof(cmd_rec ));
#line 476
  tmpcmd = (cmd_rec *)tmp;
#line 477
  memcpy((void */* __restrict  */)tmpcmd, (void const   */* __restrict  */)cmd, (size_t )sizeof(cmd_rec ));
#line 479
  (tmpcmd->argc) --;
#line 480
  (tmpcmd->argv) ++;
  }
#line 482
  if (tmpcmd->argc) {
#line 483
    cp = *(tmpcmd->argv + 0);
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
#line 483
      if (! *cp) {
#line 483
        goto while_break;
      }
      {
#line 484
      tmp___0 = toupper((int )*cp);
#line 484
      *cp = (char )tmp___0;
#line 483
      cp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 488
  tmpcmd->notes = cmd->notes;
#line 490
  tmp___1 = site_dispatch(tmpcmd);
  }
#line 490
  return (tmp___1);
}
}
#line 493 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static modret_t *site_post_cmd(cmd_rec *cmd ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 494
  if (cmd->argc > 1) {
    {
#line 494
    tmp___0 = strcasecmp((char const   *)*(cmd->argv + 1), "help");
    }
#line 494
    if (tmp___0 == 0) {
#line 496
      if ((cmd->server)->ServerAdmin) {
#line 496
        tmp = (char const   *)(cmd->server)->ServerAdmin;
      } else {
#line 496
        tmp = "ftp-admin";
      }
      {
#line 496
      pr_response_add("214", "Direct comments to %s", tmp);
      }
    }
  }
#line 499
  return ((modret_t *)((void *)0));
}
}
#line 505 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static int site_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 508
  pr_help_add("SITE", "<sp> string", 1);
  }
#line 510
  return (0);
}
}
#line 516 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
static cmdtable site_cmdtab[4]  = {      {(unsigned char)1, (char *)"SITE", (char *)((void *)0), & site_pre_cmd, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"SITE", (char *)((void *)0), & site_cmd, (unsigned char)0,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)3, (char *)"SITE", (char *)((void *)0), & site_post_cmd, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 523 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_site.c"
module site_module  = 
#line 523
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"site", (conftable *)((void *)0),
    site_cmdtab, (authtable *)((void *)0), & site_init, (int (*)(void))((void *)0),
    (char *)0, (void *)0, 0};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 170 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 200 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 232
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 117 "../include/table.h"
void *pr_table_get(pr_table_t *tab , char const   *key_data , size_t *value_datasz ) ;
#line 67 "../include/support.h"
char *dir_abs_path(pool *p , char const   *path , int interpolate ) ;
#line 69
char *dir_canonical_path(pool *p , char const   *path ) ;
#line 71
char *dir_best_path(pool *p , char const   *path ) ;
#line 93
struct tm *pr_localtime(pool *p , time_t const   *t ) ;
#line 52 "../include/sets.h"
xaset_t *xaset_create(pool *p , int (*cmpfunc)(xasetmember_t *v1 , xasetmember_t *v2 ) ) ;
#line 54
int xaset_insert(xaset_t *set , xasetmember_t *member ) ;
#line 55
int xaset_insert_end(xaset_t *set , xasetmember_t *member ) ;
#line 229 "../include/dirtree.h"
config_rec *find_config_next(config_rec *prev , config_rec *c , int type , char const   *name ,
                             int recurse ) ;
#line 277
char *get_full_cmd(cmd_rec *cmd ) ;
#line 369 "../include/netaddr.h"
pr_netaddr_t *pr_netaddr_get_sess_remote_addr(void) ;
#line 370
char const   *pr_netaddr_get_sess_remote_name(void) ;
#line 112 "../include/log.h"
int pr_log_openfile(char const   *log_file , int *log_fd , mode_t log_mode ) ;
#line 124
void log_closesyslog(void) ;
#line 125
int log_opensyslog(char const   *fn ) ;
#line 152
void log_discard(void) ;
#line 155
int pr_log_str2sysloglevel(char const   *name ) ;
#line 308 "../include/fsio.h"
char const   *pr_fs_getvwd(void) ;
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
pr_response_t *resp_list ;
#line 34
pr_response_t *resp_err_list ;
#line 102 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static off_t___0 log_dele_filesz  =    (off_t___0 )0;
#line 104 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static pool *log_pool  ;
#line 105 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static logformat_t *formats  =    (logformat_t *)((void *)0);
#line 106 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static xaset_t *format_set  =    (xaset_t *)((void *)0);
#line 107 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static logfile_t *logs  =    (logfile_t *)((void *)0);
#line 108 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static xaset_t *log_set  =    (xaset_t *)((void *)0);
#line 140 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static void add_meta(unsigned char **s , unsigned char meta , int args  , ...) 
{ 
  int arglen ;
  char *arg ;
  va_list ap ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 144
  *(*s) = (unsigned char)255;
#line 145
  (*s) ++;
#line 146
  *(*s) = meta;
#line 147
  (*s) ++;
#line 149
  if (args) {
    {
#line 151
    __builtin_va_start(ap, args);
    }
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      tmp___1 = args;
#line 153
      args --;
#line 153
      if (! tmp___1) {
#line 153
        goto while_break;
      }
      {
#line 154
      tmp = __builtin_va_arg(ap, int );
#line 154
      arglen = tmp;
#line 155
      tmp___0 = __builtin_va_arg(ap, char *);
#line 155
      arg = tmp___0;
#line 157
      memcpy((void */* __restrict  */)*s, (void const   */* __restrict  */)arg, (size_t )arglen);
#line 158
      *s += arglen;
#line 159
      *(*s) = (unsigned char)254;
#line 160
      (*s) ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 163
    __builtin_va_end(ap);
    }
  }
#line 165
  return;
}
}
#line 167 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static char *preparse_arg(char **s ) 
{ 
  char *ret ;

  {
#line 168
  ret = *s + 1;
#line 170
  (*s) ++;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (*(*s)) {
#line 171
      if (! ((int )*(*s) != 125)) {
#line 171
        goto while_break;
      }
    } else {
#line 171
      goto while_break;
    }
#line 172
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  *(*s) = (char )'\000';
#line 175
  (*s) ++;
#line 176
  return (ret);
}
}
#line 179 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static void logformat(char *nickname , char *fmts ) 
{ 
  char *tmp ;
  char *arg ;
  unsigned char format[4096] ;
  unsigned int tmp___0 ;
  unsigned char *outs ;
  logformat_t *lf ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  char *tmp___7 ;
  unsigned char *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 181
  format[0] = (unsigned char )'\000';
#line 181
  tmp___0 = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp___0 >= 4096U) {
#line 181
      goto while_break;
    }
#line 181
    format[tmp___0] = (unsigned char)0;
#line 181
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  outs = format;
#line 190
  tmp = fmts;
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 190
    if (! *tmp) {
#line 190
      goto while_break___0;
    }
#line 191
    if ((int )*tmp == 37) {
#line 192
      arg = (char *)((void *)0);
#line 193
      tmp ++;
      {
#line 194
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 196
        tmp___2 = strncmp((char const   *)tmp, "{version}", (size_t )9);
        }
#line 196
        if (tmp___2 == 0) {
          {
#line 197
          add_meta(& outs, (unsigned char)27, 0);
#line 198
          tmp += 9;
#line 199
          tmp___1 = outs;
#line 199
          outs ++;
#line 199
          *tmp___1 = (unsigned char )*tmp;
          }
#line 200
          goto __Cont;
        }
        {
#line 204
        if ((int )*tmp == 123) {
#line 204
          goto case_123;
        }
#line 208
        if ((int )*tmp == 97) {
#line 208
          goto case_97;
        }
#line 212
        if ((int )*tmp == 65) {
#line 212
          goto case_65;
        }
#line 216
        if ((int )*tmp == 98) {
#line 216
          goto case_98;
        }
#line 220
        if ((int )*tmp == 99) {
#line 220
          goto case_99;
        }
#line 224
        if ((int )*tmp == 68) {
#line 224
          goto case_68;
        }
#line 228
        if ((int )*tmp == 100) {
#line 228
          goto case_100;
        }
#line 232
        if ((int )*tmp == 101) {
#line 232
          goto case_101;
        }
#line 239
        if ((int )*tmp == 102) {
#line 239
          goto case_102;
        }
#line 243
        if ((int )*tmp == 70) {
#line 243
          goto case_70;
        }
#line 247
        if ((int )*tmp == 104) {
#line 247
          goto case_104;
        }
#line 251
        if ((int )*tmp == 74) {
#line 251
          goto case_74;
        }
#line 255
        if ((int )*tmp == 108) {
#line 255
          goto case_108;
        }
#line 259
        if ((int )*tmp == 76) {
#line 259
          goto case_76;
        }
#line 263
        if ((int )*tmp == 109) {
#line 263
          goto case_109;
        }
#line 267
        if ((int )*tmp == 112) {
#line 267
          goto case_112;
        }
#line 271
        if ((int )*tmp == 80) {
#line 271
          goto case_80;
        }
#line 275
        if ((int )*tmp == 114) {
#line 275
          goto case_114;
        }
#line 279
        if ((int )*tmp == 115) {
#line 279
          goto case_115;
        }
#line 283
        if ((int )*tmp == 83) {
#line 283
          goto case_83;
        }
#line 287
        if ((int )*tmp == 116) {
#line 287
          goto case_116;
        }
#line 293
        if ((int )*tmp == 84) {
#line 293
          goto case_84;
        }
#line 297
        if ((int )*tmp == 117) {
#line 297
          goto case_117;
        }
#line 301
        if ((int )*tmp == 85) {
#line 301
          goto case_85;
        }
#line 305
        if ((int )*tmp == 118) {
#line 305
          goto case_118;
        }
#line 309
        if ((int )*tmp == 86) {
#line 309
          goto case_86;
        }
#line 313
        if ((int )*tmp == 37) {
#line 313
          goto case_37;
        }
#line 203
        goto switch_break;
        case_123: /* CIL Label */ 
        {
#line 205
        arg = preparse_arg(& tmp);
        }
#line 206
        goto __Cont;
        case_97: /* CIL Label */ 
        {
#line 209
        add_meta(& outs, (unsigned char)6, 0);
        }
#line 210
        goto switch_break;
        case_65: /* CIL Label */ 
        {
#line 213
        add_meta(& outs, (unsigned char)20, 0);
        }
#line 214
        goto switch_break;
        case_98: /* CIL Label */ 
        {
#line 217
        add_meta(& outs, (unsigned char)2, 0);
        }
#line 218
        goto switch_break;
        case_99: /* CIL Label */ 
        {
#line 221
        add_meta(& outs, (unsigned char)19, 0);
        }
#line 222
        goto switch_break;
        case_68: /* CIL Label */ 
        {
#line 225
        add_meta(& outs, (unsigned char)24, 0);
        }
#line 226
        goto switch_break;
        case_100: /* CIL Label */ 
        {
#line 229
        add_meta(& outs, (unsigned char)23, 0);
        }
#line 230
        goto switch_break;
        case_101: /* CIL Label */ 
#line 233
        if (arg) {
          {
#line 234
          add_meta(& outs, (unsigned char)4, 0);
#line 235
          tmp___3 = strlen((char const   *)arg);
#line 235
          add_meta(& outs, (unsigned char)1, 1, (int )tmp___3, arg);
          }
        }
#line 237
        goto switch_break;
        case_102: /* CIL Label */ 
        {
#line 240
        add_meta(& outs, (unsigned char)3, 0);
        }
#line 241
        goto switch_break;
        case_70: /* CIL Label */ 
        {
#line 244
        add_meta(& outs, (unsigned char)22, 0);
        }
#line 245
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 248
        add_meta(& outs, (unsigned char)5, 0);
        }
#line 249
        goto switch_break;
        case_74: /* CIL Label */ 
        {
#line 252
        add_meta(& outs, (unsigned char)25, 0);
        }
#line 253
        goto switch_break;
        case_108: /* CIL Label */ 
        {
#line 256
        add_meta(& outs, (unsigned char)7, 0);
        }
#line 257
        goto switch_break;
        case_76: /* CIL Label */ 
        {
#line 260
        add_meta(& outs, (unsigned char)14, 0);
        }
#line 261
        goto switch_break;
        case_109: /* CIL Label */ 
        {
#line 264
        add_meta(& outs, (unsigned char)21, 0);
        }
#line 265
        goto switch_break;
        case_112: /* CIL Label */ 
        {
#line 268
        add_meta(& outs, (unsigned char)13, 0);
        }
#line 269
        goto switch_break;
        case_80: /* CIL Label */ 
        {
#line 272
        add_meta(& outs, (unsigned char)8, 0);
        }
#line 273
        goto switch_break;
        case_114: /* CIL Label */ 
        {
#line 276
        add_meta(& outs, (unsigned char)11, 0);
        }
#line 277
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 280
        add_meta(& outs, (unsigned char)18, 0);
        }
#line 281
        goto switch_break;
        case_83: /* CIL Label */ 
        {
#line 284
        add_meta(& outs, (unsigned char)26, 0);
        }
#line 285
        goto switch_break;
        case_116: /* CIL Label */ 
        {
#line 288
        add_meta(& outs, (unsigned char)9, 0);
        }
#line 289
        if (arg) {
          {
#line 290
          tmp___4 = strlen((char const   *)arg);
#line 290
          add_meta(& outs, (unsigned char)1, 1, (int )tmp___4, arg);
          }
        }
#line 291
        goto switch_break;
        case_84: /* CIL Label */ 
        {
#line 294
        add_meta(& outs, (unsigned char)10, 0);
        }
#line 295
        goto switch_break;
        case_117: /* CIL Label */ 
        {
#line 298
        add_meta(& outs, (unsigned char)16, 0);
        }
#line 299
        goto switch_break;
        case_85: /* CIL Label */ 
        {
#line 302
        add_meta(& outs, (unsigned char)17, 0);
        }
#line 303
        goto switch_break;
        case_118: /* CIL Label */ 
        {
#line 306
        add_meta(& outs, (unsigned char)12, 0);
        }
#line 307
        goto switch_break;
        case_86: /* CIL Label */ 
        {
#line 310
        add_meta(& outs, (unsigned char)15, 0);
        }
#line 311
        goto switch_break;
        case_37: /* CIL Label */ 
#line 314
        tmp___5 = outs;
#line 314
        outs ++;
#line 314
        *tmp___5 = (unsigned char )'%';
#line 315
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 318
        tmp ++;
#line 319
        goto while_break___1;
        __Cont: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 323
      tmp___6 = outs;
#line 323
      outs ++;
#line 323
      tmp___7 = tmp;
#line 323
      tmp ++;
#line 323
      *tmp___6 = (unsigned char )*tmp___7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 327
  tmp___8 = outs;
#line 327
  outs ++;
#line 327
  *tmp___8 = (unsigned char )'\000';
#line 329
  tmp___9 = pcalloc(log_pool, (int )sizeof(logformat_t ));
#line 329
  lf = (logformat_t *)tmp___9;
#line 330
  lf->lf_nickname = pstrdup(log_pool, (char const   *)nickname);
#line 331
  tmp___10 = palloc(log_pool, (int )(outs - format));
#line 331
  lf->lf_format = (unsigned char *)tmp___10;
#line 332
  memcpy((void */* __restrict  */)lf->lf_format, (void const   */* __restrict  */)(format),
         (size_t )(outs - format));
  }
#line 334
  if (! format_set) {
    {
#line 335
    format_set = xaset_create(log_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
  {
#line 337
  xaset_insert_end(format_set, (xasetmember_t *)lf);
#line 338
  formats = (logformat_t *)format_set->xas_list;
  }
#line 339
  return;
}
}
#line 342 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *set_logformat(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 343
  if (cmd->argc - 1 < 2) {
    {
#line 343
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 343
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 343
    return (tmp___0);
  }
  {
#line 344
  tmp___5 = check_context(cmd, 1);
  }
#line 344
  if (! tmp___5) {
    {
#line 344
    tmp___1 = get_context_name(cmd);
#line 344
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 344
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 344
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 344
    return (tmp___4);
  }
  {
#line 346
  logformat(*(cmd->argv + 1), *(cmd->argv + 2));
#line 347
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 347
  return (tmp___6);
}
}
#line 350 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static int _parse_classes(char *s ) 
{ 
  int classes ;
  char *nextp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 351
  classes = 0;
#line 352
  nextp = (char *)((void *)0);
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    nextp = strchr((char const   *)s, ',');
    }
#line 356
    if (nextp) {
#line 357
      tmp = nextp;
#line 357
      nextp ++;
#line 357
      *tmp = (char )'\000';
    }
#line 359
    if (! nextp) {
      {
#line 360
      nextp = strchr((char const   *)s, '|');
      }
#line 360
      if (nextp) {
#line 361
        tmp___0 = nextp;
#line 361
        nextp ++;
#line 361
        *tmp___0 = (char )'\000';
      }
    }
    {
#line 364
    tmp___1 = strcasecmp((char const   *)s, "NONE");
    }
#line 364
    if (tmp___1 == 0) {
#line 365
      classes = 0;
#line 366
      goto while_break;
    }
    {
#line 369
    tmp___10 = strcasecmp((char const   *)s, "ALL");
    }
#line 369
    if (tmp___10 == 0) {
#line 370
      classes = (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6);
#line 371
      goto while_break;
    } else {
      {
#line 373
      tmp___9 = strcasecmp((char const   *)s, "AUTH");
      }
#line 373
      if (tmp___9 == 0) {
#line 374
        classes |= 1;
      } else {
        {
#line 376
        tmp___8 = strcasecmp((char const   *)s, "INFO");
        }
#line 376
        if (tmp___8 == 0) {
#line 377
          classes |= 1 << 1;
        } else {
          {
#line 379
          tmp___7 = strcasecmp((char const   *)s, "DIRS");
          }
#line 379
          if (tmp___7 == 0) {
#line 380
            classes |= 1 << 2;
          } else {
            {
#line 382
            tmp___6 = strcasecmp((char const   *)s, "READ");
            }
#line 382
            if (tmp___6 == 0) {
#line 383
              classes |= 1 << 3;
            } else {
              {
#line 385
              tmp___5 = strcasecmp((char const   *)s, "WRITE");
              }
#line 385
              if (tmp___5 == 0) {
#line 386
                classes |= 1 << 4;
              } else {
                {
#line 388
                tmp___4 = strcasecmp((char const   *)s, "MISC");
                }
#line 388
                if (tmp___4 == 0) {
#line 389
                  classes |= 1 << 5;
                } else {
                  {
#line 391
                  tmp___2 = strcasecmp((char const   *)s, "SEC");
                  }
#line 391
                  if (tmp___2 == 0) {
#line 393
                    classes |= 1 << 6;
                  } else {
                    {
#line 391
                    tmp___3 = strcasecmp((char const   *)s, "SECURE");
                    }
#line 391
                    if (tmp___3 == 0) {
#line 393
                      classes |= 1 << 6;
                    } else {
                      {
#line 396
                      pr_log_pri(5, "ExtendedLog class \'%s\' is not defined.", s);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 354
    s = nextp;
#line 354
    if (! s) {
#line 354
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (classes);
}
}
#line 404 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *set_extendedlog(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int argc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 405
  c = (config_rec *)((void *)0);
#line 408
  tmp___3 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 408
  if (! tmp___3) {
    {
#line 408
    tmp = get_context_name(cmd);
#line 408
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 408
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 408
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 408
    return (tmp___2);
  }
#line 410
  argc = cmd->argc;
#line 412
  if (argc < 2) {
    {
#line 413
    tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "Syntax: ExtendedLog file [<cmd-classes> [<nickname>]]",
                      (void *)0);
#line 413
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
    }
#line 413
    return (tmp___5);
  }
  {
#line 415
  c = add_config_param((char const   *)*(cmd->argv + 0), 3, (void *)0, (void *)0,
                       (void *)0);
#line 417
  tmp___17 = strncasecmp((char const   *)*(cmd->argv + 1), "syslog:", (size_t )7);
  }
#line 417
  if (tmp___17 == 0) {
    {
#line 418
    tmp___7 = strchr((char const   *)*(cmd->argv + 1), ':');
#line 418
    tmp___6 = tmp___7;
#line 420
    tmp___6 ++;
#line 420
    tmp___12 = pr_log_str2sysloglevel((char const   *)tmp___6);
    }
#line 420
    if (tmp___12 < 0) {
      {
#line 421
      tmp___8 = pstrcat(cmd->tmp_pool, "unknown syslog level: \'", tmp___6, "\'",
                        (void *)0);
#line 421
      tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___8, (void *)0);
#line 421
      tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
      }
#line 421
      return (tmp___10);
    } else {
      {
#line 425
      tmp___11 = pstrdup(log_pool, (char const   *)*(cmd->argv + 1));
#line 425
      *(c->argv + 0) = (void *)tmp___11;
      }
    }
  } else
#line 427
  if ((int )*(*(cmd->argv + 1) + 0) != 47) {
    {
#line 428
    tmp___13 = pstrcat(cmd->tmp_pool, "relative paths not allowed: \'", *(cmd->argv + 1),
                       "\'", (void *)0);
#line 428
    tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___13, (void *)0);
#line 428
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___14);
    }
#line 428
    return (tmp___15);
  } else {
    {
#line 432
    tmp___16 = pstrdup(log_pool, (char const   *)*(cmd->argv + 1));
#line 432
    *(c->argv + 0) = (void *)tmp___16;
    }
  }
#line 434
  if (argc > 2) {
    {
#line 435
    tmp___18 = pstrdup(log_pool, (char const   *)*(cmd->argv + 2));
#line 435
    *(c->argv + 1) = (void *)tmp___18;
    }
  }
#line 437
  if (argc > 3) {
    {
#line 438
    tmp___19 = pstrdup(log_pool, (char const   *)*(cmd->argv + 3));
#line 438
    *(c->argv + 2) = (void *)tmp___19;
    }
  }
  {
#line 440
  c->argc = argc - 1;
#line 441
  tmp___20 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 441
  return (tmp___20);
}
}
#line 445 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *set_allowlogsymlinks(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 446
  bool = -1;
#line 447
  c = (config_rec *)((void *)0);
#line 449
  if (cmd->argc - 1 < 1) {
    {
#line 449
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 449
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 449
    return (tmp___0);
  }
  {
#line 450
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 450
  if (! tmp___5) {
    {
#line 450
    tmp___1 = get_context_name(cmd);
#line 450
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 450
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 450
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 450
    return (tmp___4);
  }
  {
#line 452
  bool = get_boolean(cmd, 1);
  }
#line 453
  if (bool == -1) {
    {
#line 454
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 454
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 454
    return (tmp___7);
  }
  {
#line 456
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 457
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 458
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 460
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 460
  return (tmp___8);
}
}
#line 464 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *set_serverlog(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 465
  if (cmd->argc - 1 < 1) {
    {
#line 465
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 465
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 465
    return (tmp___0);
  }
  {
#line 466
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 466
  if (! tmp___5) {
    {
#line 466
    tmp___1 = get_context_name(cmd);
#line 466
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 466
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 466
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 466
    return (tmp___4);
  }
  {
#line 468
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 470
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 470
  return (tmp___6);
}
}
#line 474 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *set_systemlog(cmd_rec *cmd ) 
{ 
  char *syslogfn ;
  int res ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  int xerrno ;
  int *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  char *tmp___11 ;
  modret_t *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  modret_t *tmp___16 ;
  modret_t *tmp___17 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 475
  syslogfn = (char *)((void *)0);
#line 478
  if (cmd->argc - 1 < 1) {
    {
#line 478
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 478
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 478
    return (tmp___0);
  }
  {
#line 479
  tmp___5 = check_context(cmd, 1);
  }
#line 479
  if (! tmp___5) {
    {
#line 479
    tmp___1 = get_context_name(cmd);
#line 479
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 479
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 479
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 479
    return (tmp___4);
  }
  {
#line 481
  log_closesyslog();
#line 483
  syslogfn = *(cmd->argv + 1);
#line 485
  tmp___7 = strcasecmp((char const   *)syslogfn, "NONE");
  }
#line 485
  if (tmp___7 == 0) {
    {
#line 486
    log_discard();
#line 487
    tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 487
    return (tmp___6);
  }
#line 490
  if ((int )*syslogfn != 47) {
    {
#line 491
    syslogfn = dir_canonical_path(cmd->tmp_pool, (char const   *)syslogfn);
    }
  }
  {
#line 493
  pr_signals_block();
#line 495
  res = log_opensyslog((char const   *)syslogfn);
  }
#line 496
  if (res < 0) {
    {
#line 497
    tmp___8 = __errno_location();
#line 497
    xerrno = *tmp___8;
#line 499
    pr_signals_unblock();
    }
#line 501
    if (res == -2) {
      {
#line 502
      tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "you are attempting to log to a world writable directory",
                        (void *)0);
#line 502
      tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
      }
#line 502
      return (tmp___10);
    } else
#line 505
    if (res == -3) {
      {
#line 506
      tmp___11 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "you are attempting to log to a symbolic link",
                         (void *)0);
#line 506
      tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___11);
      }
#line 506
      return (tmp___12);
    } else {
      {
#line 509
      tmp___13 = strerror(xerrno);
#line 509
      tmp___14 = pstrcat(cmd->tmp_pool, "unable to redirect logging to \'", syslogfn,
                         "\': ", tmp___13, (void *)0);
#line 509
      tmp___15 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___14, (void *)0);
#line 509
      tmp___16 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___15);
      }
#line 509
      return (tmp___16);
    }
  }
  {
#line 515
  pr_signals_unblock();
#line 516
  tmp___17 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 516
  return (tmp___17);
}
}
#line 519 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static struct tm *_get_gmtoff(int *tz ) 
{ 
  time_t tt ;
  time_t tmp ;
  struct tm gmt ;
  struct tm *t ;
  int days___0 ;
  int hours ;
  int minutes ;
  struct tm *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;

  {
  {
#line 520
  tmp = time((time_t *)((void *)0));
#line 520
  tt = tmp;
#line 525
  tmp___0 = gmtime((time_t const   *)(& tt));
#line 525
  gmt = *tmp___0;
#line 526
  t = pr_localtime((pool *)((void *)0), (time_t const   *)(& tt));
#line 528
  days___0 = t->tm_yday - gmt.tm_yday;
  }
#line 529
  if (days___0 < -1) {
#line 529
    tmp___2 = 24;
  } else {
#line 529
    if (1 < days___0) {
#line 529
      tmp___1 = -24;
    } else {
#line 529
      tmp___1 = days___0 * 24;
    }
#line 529
    tmp___2 = tmp___1;
  }
#line 529
  hours = (tmp___2 + t->tm_hour) - gmt.tm_hour;
#line 531
  minutes = (hours * 60 + t->tm_min) - gmt.tm_min;
#line 532
  *tz = minutes;
#line 533
  return (t);
}
}
#line 536 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static char *get_next_meta(pool *p , cmd_rec *cmd , unsigned char **f ) 
{ 
  unsigned char *m ;
  char arg[512] ;
  unsigned int tmp ;
  char *argp ;
  char *pass ;
  char *tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *path ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  register unsigned int i___0 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *path___0 ;
  char *tmp___51 ;
  char *path___1 ;
  char *tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  char *key ;
  char *tmp___55 ;
  char *env ;
  char *tmp___56 ;
  char const   *tmp___57 ;
  pr_netaddr_t *tmp___58 ;
  char const   *tmp___59 ;
  char *rfc1413_ident ;
  void *tmp___60 ;
  char *ptr ;
  int tmp___61 ;
  int tmp___62 ;
  char const   *tmp___63 ;
  __pid_t tmp___64 ;
  char *time_fmt ;
  struct tm t ;
  int internal_fmt ;
  int timz ;
  char sign ;
  struct tm *tmp___65 ;
  size_t tmp___66 ;
  size_t tmp___67 ;
  size_t tmp___68 ;
  struct timeval end_time ;
  char *tmp___69 ;
  int tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  char *u ;
  void *tmp___73 ;
  char *login_user ;
  void *tmp___74 ;
  pr_response_t *r ;
  int tmp___75 ;
  pr_response_t *r___0 ;
  char *tmp___76 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  void *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;

  {
#line 538
  arg[0] = (char )'\000';
#line 538
  tmp = 1U;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (tmp >= 512U) {
#line 538
      goto while_break;
    }
#line 538
    arg[tmp] = (char)0;
#line 538
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  argp = (char *)((void *)0);
#line 545
  m = *f + 1;
  {
#line 547
  if ((int )*m == 1) {
#line 547
    goto case_1;
  }
#line 558
  if ((int )*m == 20) {
#line 558
    goto case_20;
  }
#line 570
  if ((int )*m == 2) {
#line 570
    goto case_2;
  }
#line 585
  if ((int )*m == 19) {
#line 585
    goto case_19;
  }
#line 592
  if ((int )*m == 23) {
#line 592
    goto case_23;
  }
#line 617
  if ((int )*m == 24) {
#line 617
    goto case_24;
  }
#line 657
  if ((int )*m == 3) {
#line 657
    goto case_3;
  }
#line 702
  if ((int )*m == 22) {
#line 702
    goto case_22;
  }
#line 735
  if ((int )*m == 4) {
#line 735
    goto case_4;
  }
#line 752
  if ((int )*m == 5) {
#line 752
    goto case_5;
  }
#line 758
  if ((int )*m == 6) {
#line 758
    goto case_6;
  }
#line 765
  if ((int )*m == 7) {
#line 765
    goto case_7;
  }
#line 779
  if ((int )*m == 21) {
#line 779
    goto case_21;
  }
#line 802
  if ((int )*m == 13) {
#line 802
    goto case_13;
  }
#line 808
  if ((int )*m == 14) {
#line 808
    goto case_14;
  }
#line 814
  if ((int )*m == 15) {
#line 814
    goto case_15;
  }
#line 820
  if ((int )*m == 8) {
#line 820
    goto case_8;
  }
#line 826
  if ((int )*m == 9) {
#line 826
    goto case_9;
  }
#line 864
  if ((int )*m == 10) {
#line 864
    goto case_10;
  }
#line 898
  if ((int )*m == 11) {
#line 898
    goto case_11;
  }
#line 912
  if ((int )*m == 25) {
#line 912
    goto case_25;
  }
#line 925
  if ((int )*m == 12) {
#line 925
    goto case_12;
  }
#line 931
  if ((int )*m == 16) {
#line 931
    goto case_16;
  }
#line 948
  if ((int )*m == 17) {
#line 948
    goto case_17;
  }
#line 961
  if ((int )*m == 18) {
#line 961
    goto case_18;
  }
#line 984
  if ((int )*m == 26) {
#line 984
    goto case_26;
  }
#line 1003
  if ((int )*m == 27) {
#line 1003
    goto case_27;
  }
#line 546
  goto switch_break;
  case_1: /* CIL Label */ 
#line 548
  m ++;
#line 549
  argp = arg;
  {
#line 550
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 550
    if (! ((int )*m != 254)) {
#line 550
      goto while_break___0;
    }
#line 551
    tmp___0 = argp;
#line 551
    argp ++;
#line 551
    tmp___1 = m;
#line 551
    m ++;
#line 551
    *tmp___0 = (char )*tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 553
  *argp = (char)0;
#line 554
  argp = arg;
#line 555
  m ++;
#line 556
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 559
  argp = arg;
#line 561
  tmp___2 = get_param_ptr((cmd->server)->conf, "PASS", 0);
#line 561
  pass = (char *)tmp___2;
  }
#line 562
  if (! pass) {
#line 563
    pass = (char *)"UNKNOWN";
  }
  {
#line 565
  sstrncpy(argp, (char const   *)pass, (size_t )sizeof(arg));
#line 567
  m ++;
  }
#line 568
  goto switch_break;
  case_2: /* CIL Label */ 
#line 571
  argp = arg;
#line 572
  if (session.xfer.p) {
    {
#line 573
    snprintf((char */* __restrict  */)argp, (size_t )sizeof(arg), (char const   */* __restrict  */)"%llu",
             (unsigned long long )session.xfer.total_bytes);
    }
  } else {
    {
#line 576
    tmp___3 = strcmp((char const   *)*(cmd->argv + 0), "DELE");
    }
#line 576
    if (tmp___3 == 0) {
      {
#line 577
      snprintf((char */* __restrict  */)argp, (size_t )sizeof(arg), (char const   */* __restrict  */)"%llu",
               (unsigned long long )log_dele_filesz);
      }
    } else {
      {
#line 580
      sstrncpy(argp, "-", (size_t )sizeof(arg));
      }
    }
  }
#line 582
  m ++;
#line 583
  goto switch_break;
  case_19: /* CIL Label */ 
#line 586
  argp = arg;
#line 587
  if (session.class) {
#line 587
    tmp___4 = (char const   *)(session.class)->cls_name;
  } else {
#line 587
    tmp___4 = "-";
  }
  {
#line 587
  sstrncpy(argp, tmp___4, (size_t )sizeof(arg));
#line 589
  m ++;
  }
#line 590
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 593
  argp = arg;
#line 595
  tmp___7 = strcmp((char const   *)*(cmd->argv + 0), "CDUP");
  }
#line 595
  if (tmp___7 == 0) {
#line 595
    goto _L;
  } else {
    {
#line 595
    tmp___8 = strcmp((char const   *)*(cmd->argv + 0), "CWD");
    }
#line 595
    if (tmp___8 == 0) {
#line 595
      goto _L;
    } else {
      {
#line 595
      tmp___9 = strcmp((char const   *)*(cmd->argv + 0), "MKD");
      }
#line 595
      if (tmp___9 == 0) {
#line 595
        goto _L;
      } else {
        {
#line 595
        tmp___10 = strcmp((char const   *)*(cmd->argv + 0), "RMD");
        }
#line 595
        if (tmp___10 == 0) {
#line 595
          goto _L;
        } else {
          {
#line 595
          tmp___11 = strcmp((char const   *)*(cmd->argv + 0), "XCWD");
          }
#line 595
          if (tmp___11 == 0) {
#line 595
            goto _L;
          } else {
            {
#line 595
            tmp___12 = strcmp((char const   *)*(cmd->argv + 0), "XCUP");
            }
#line 595
            if (tmp___12 == 0) {
#line 595
              goto _L;
            } else {
              {
#line 595
              tmp___13 = strcmp((char const   *)*(cmd->argv + 0), "XMKD");
              }
#line 595
              if (tmp___13 == 0) {
#line 595
                goto _L;
              } else {
                {
#line 595
                tmp___14 = strcmp((char const   *)*(cmd->argv + 0), "XRMD");
                }
#line 595
                if (tmp___14 == 0) {
                  _L: /* CIL Label */ 
                  {
#line 605
                  path = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 606
                  tmp___5 = strrchr((char const   *)path, '/');
                  }
#line 608
                  if (tmp___5) {
#line 608
                    tmp___6 = tmp___5;
                  } else {
#line 608
                    tmp___6 = path;
                  }
                  {
#line 608
                  sstrncpy(argp, (char const   *)tmp___6, (size_t )sizeof(arg));
                  }
                } else {
                  {
#line 611
                  sstrncpy(argp, "", (size_t )sizeof(arg));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 614
  m ++;
#line 615
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 618
  argp = arg;
#line 620
  tmp___27 = strcmp((char const   *)*(cmd->argv + 0), "CDUP");
  }
#line 620
  if (tmp___27 == 0) {
    {
#line 626
    tmp___15 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 626
    tmp___16 = dir_abs_path(p, (char const   *)tmp___15, 1);
#line 626
    sstrncpy(argp, (char const   *)tmp___16, (size_t )sizeof(arg));
    }
  } else {
    {
#line 620
    tmp___28 = strcmp((char const   *)*(cmd->argv + 0), "MKD");
    }
#line 620
    if (tmp___28 == 0) {
      {
#line 626
      tmp___15 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 626
      tmp___16 = dir_abs_path(p, (char const   *)tmp___15, 1);
#line 626
      sstrncpy(argp, (char const   *)tmp___16, (size_t )sizeof(arg));
      }
    } else {
      {
#line 620
      tmp___29 = strcmp((char const   *)*(cmd->argv + 0), "RMD");
      }
#line 620
      if (tmp___29 == 0) {
        {
#line 626
        tmp___15 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 626
        tmp___16 = dir_abs_path(p, (char const   *)tmp___15, 1);
#line 626
        sstrncpy(argp, (char const   *)tmp___16, (size_t )sizeof(arg));
        }
      } else {
        {
#line 620
        tmp___30 = strcmp((char const   *)*(cmd->argv + 0), "XCUP");
        }
#line 620
        if (tmp___30 == 0) {
          {
#line 626
          tmp___15 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 626
          tmp___16 = dir_abs_path(p, (char const   *)tmp___15, 1);
#line 626
          sstrncpy(argp, (char const   *)tmp___16, (size_t )sizeof(arg));
          }
        } else {
          {
#line 620
          tmp___31 = strcmp((char const   *)*(cmd->argv + 0), "XMKD");
          }
#line 620
          if (tmp___31 == 0) {
            {
#line 626
            tmp___15 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 626
            tmp___16 = dir_abs_path(p, (char const   *)tmp___15, 1);
#line 626
            sstrncpy(argp, (char const   *)tmp___16, (size_t )sizeof(arg));
            }
          } else {
            {
#line 620
            tmp___32 = strcmp((char const   *)*(cmd->argv + 0), "XRMD");
            }
#line 620
            if (tmp___32 == 0) {
              {
#line 626
              tmp___15 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 626
              tmp___16 = dir_abs_path(p, (char const   *)tmp___15, 1);
#line 626
              sstrncpy(argp, (char const   *)tmp___16, (size_t )sizeof(arg));
              }
            } else {
              {
#line 629
              tmp___25 = strcmp((char const   *)*(cmd->argv + 0), "CWD");
              }
#line 629
              if (tmp___25 == 0) {
#line 629
                goto _L___0;
              } else {
                {
#line 629
                tmp___26 = strcmp((char const   *)*(cmd->argv + 0), "XCWD");
                }
#line 629
                if (tmp___26 == 0) {
                  _L___0: /* CIL Label */ 
#line 640
                  if (session.chroot_path) {
                    {
#line 642
                    tmp___22 = pr_fs_getvwd();
#line 642
                    tmp___23 = strcmp(tmp___22, "/");
                    }
#line 642
                    if (tmp___23) {
                      {
#line 642
                      tmp___19 = pr_fs_getvwd();
#line 642
                      tmp___20 = pdircat(p, session.chroot_path, tmp___19, (void *)0);
#line 642
                      tmp___21 = tmp___20;
                      }
                    } else {
#line 642
                      tmp___21 = session.chroot_path;
                    }
                    {
#line 642
                    sstrncpy(arg, (char const   *)tmp___21, (size_t )sizeof(arg));
                    }
                  } else {
                    {
#line 649
                    tmp___24 = pr_fs_getcwd();
#line 649
                    sstrncpy(arg, tmp___24, (size_t )sizeof(arg));
                    }
                  }
                } else {
                  {
#line 652
                  sstrncpy(argp, "", (size_t )sizeof(arg));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 654
  m ++;
#line 655
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 658
  argp = arg;
#line 660
  tmp___50 = strcmp((char const   *)*(cmd->argv + 0), "RNTO");
  }
#line 660
  if (tmp___50 == 0) {
    {
#line 661
    tmp___33 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 661
    tmp___34 = dir_abs_path(p, (char const   *)tmp___33, 1);
#line 661
    sstrncpy(argp, (char const   *)tmp___34, (size_t )sizeof(arg));
    }
  } else
#line 664
  if (session.xfer.p) {
#line 664
    if (session.xfer.path) {
      {
#line 666
      tmp___35 = dir_abs_path(p, (char const   *)session.xfer.path, 1);
#line 666
      sstrncpy(argp, (char const   *)tmp___35, (size_t )sizeof(arg));
      }
    } else {
#line 664
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 668
    tmp___47 = strcmp((char const   *)*(cmd->argv + 0), "SITE");
    }
#line 668
    if (tmp___47 == 0) {
      {
#line 668
      tmp___48 = strcasecmp((char const   *)*(cmd->argv + 1), "CHGRP");
      }
#line 668
      if (tmp___48 == 0) {
#line 668
        goto _L___2;
      } else {
        {
#line 668
        tmp___49 = strcasecmp((char const   *)*(cmd->argv + 1), "CHMOD");
        }
#line 668
        if (tmp___49 == 0) {
          _L___2: /* CIL Label */ 
#line 672
          tmp___36 = (char *)"";
#line 674
          i___0 = 3U;
          {
#line 674
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 674
            if (! (i___0 <= (unsigned int )(cmd->argc - 1))) {
#line 674
              goto while_break___1;
            }
            {
#line 675
            tmp___37 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)*(cmd->argv + i___0));
            }
#line 675
            if (*tmp___36) {
#line 675
              tmp___38 = " ";
            } else {
#line 675
              tmp___38 = "";
            }
            {
#line 675
            tmp___36 = pstrcat(cmd->tmp_pool, tmp___36, tmp___38, tmp___37, (void *)0);
#line 674
            i___0 ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 679
          tmp___39 = dir_abs_path(p, (char const   *)tmp___36, 1);
#line 679
          sstrncpy(argp, (char const   *)tmp___39, (size_t )sizeof(arg));
          }
        } else {
#line 668
          goto _L___1;
        }
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 686
      tmp___42 = strcmp((char const   *)*(cmd->argv + 0), "DELE");
      }
#line 686
      if (tmp___42 == 0) {
        {
#line 691
        tmp___40 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 691
        tmp___41 = dir_abs_path(p, (char const   *)tmp___40, 1);
#line 691
        sstrncpy(arg, (char const   *)tmp___41, (size_t )sizeof(arg));
        }
      } else {
        {
#line 686
        tmp___43 = strcmp((char const   *)*(cmd->argv + 0), "MKD");
        }
#line 686
        if (tmp___43 == 0) {
          {
#line 691
          tmp___40 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 691
          tmp___41 = dir_abs_path(p, (char const   *)tmp___40, 1);
#line 691
          sstrncpy(arg, (char const   *)tmp___41, (size_t )sizeof(arg));
          }
        } else {
          {
#line 686
          tmp___44 = strcmp((char const   *)*(cmd->argv + 0), "RMD");
          }
#line 686
          if (tmp___44 == 0) {
            {
#line 691
            tmp___40 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 691
            tmp___41 = dir_abs_path(p, (char const   *)tmp___40, 1);
#line 691
            sstrncpy(arg, (char const   *)tmp___41, (size_t )sizeof(arg));
            }
          } else {
            {
#line 686
            tmp___45 = strcmp((char const   *)*(cmd->argv + 0), "XMKD");
            }
#line 686
            if (tmp___45 == 0) {
              {
#line 691
              tmp___40 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 691
              tmp___41 = dir_abs_path(p, (char const   *)tmp___40, 1);
#line 691
              sstrncpy(arg, (char const   *)tmp___41, (size_t )sizeof(arg));
              }
            } else {
              {
#line 686
              tmp___46 = strcmp((char const   *)*(cmd->argv + 0), "XRMD");
              }
#line 686
              if (tmp___46 == 0) {
                {
#line 691
                tmp___40 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 691
                tmp___41 = dir_abs_path(p, (char const   *)tmp___40, 1);
#line 691
                sstrncpy(arg, (char const   *)tmp___41, (size_t )sizeof(arg));
                }
              } else {
                {
#line 696
                sstrncpy(argp, "-", (size_t )sizeof(arg));
                }
              }
            }
          }
        }
      }
    }
  }
#line 699
  m ++;
#line 700
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 703
  argp = arg;
#line 705
  tmp___54 = strcmp((char const   *)*(cmd->argv + 0), "RNTO");
  }
#line 705
  if (tmp___54 == 0) {
    {
#line 708
    tmp___51 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 708
    path___0 = dir_best_path(cmd->tmp_pool, (char const   *)tmp___51);
#line 710
    sstrncpy(arg, (char const   *)path___0, (size_t )sizeof(arg));
    }
  } else
#line 712
  if (session.xfer.p) {
#line 712
    if (session.xfer.path) {
      {
#line 714
      sstrncpy(argp, (char const   *)session.xfer.path, (size_t )sizeof(arg));
      }
    } else {
#line 712
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 721
    tmp___53 = strcmp((char const   *)*(cmd->argv + 0), "DELE");
    }
#line 721
    if (tmp___53 == 0) {
      {
#line 724
      tmp___52 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 724
      path___1 = dir_best_path(cmd->tmp_pool, (char const   *)tmp___52);
#line 726
      sstrncpy(arg, (char const   *)path___1, (size_t )sizeof(arg));
      }
    } else {
      {
#line 729
      sstrncpy(argp, "-", (size_t )sizeof(arg));
      }
    }
  }
#line 732
  m ++;
#line 733
  goto switch_break;
  case_4: /* CIL Label */ 
#line 736
  argp = arg;
#line 737
  m ++;
#line 739
  if ((int )*m == 255) {
#line 739
    if ((int )*(m + 1) == 1) {
      {
#line 741
      tmp___55 = get_next_meta(p, cmd, & m);
#line 741
      key = tmp___55;
      }
#line 742
      if (key) {
        {
#line 743
        tmp___56 = pr_env_get(cmd->tmp_pool, (char const   *)key);
#line 743
        env = tmp___56;
        }
#line 744
        if (env) {
          {
#line 745
          sstrncpy(argp, (char const   *)env, (size_t )sizeof(arg));
          }
        }
      }
    }
  }
#line 750
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 753
  argp = arg;
#line 754
  tmp___57 = pr_netaddr_get_sess_remote_name();
#line 754
  sstrncpy(argp, tmp___57, (size_t )sizeof(arg));
#line 755
  m ++;
  }
#line 756
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 759
  argp = arg;
#line 760
  tmp___58 = pr_netaddr_get_sess_remote_addr();
#line 760
  tmp___59 = pr_netaddr_get_ipstr(tmp___58);
#line 760
  sstrncpy(argp, tmp___59, (size_t )sizeof(arg));
#line 762
  m ++;
  }
#line 763
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 768
  argp = arg;
#line 769
  tmp___60 = pr_table_get(session.notes, "mod_ident.rfc1413-ident", (size_t *)((void *)0));
#line 769
  rfc1413_ident = (char *)tmp___60;
  }
#line 771
  if ((unsigned long )rfc1413_ident == (unsigned long )((void *)0)) {
#line 772
    rfc1413_ident = (char *)"UNKNOWN";
  }
  {
#line 774
  sstrncpy(argp, (char const   *)rfc1413_ident, (size_t )sizeof(arg));
#line 775
  m ++;
  }
#line 776
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 780
  argp = arg;
#line 782
  tmp___62 = strcmp((char const   *)*(cmd->argv + 0), "SITE");
  }
#line 782
  if (tmp___62 != 0) {
    {
#line 783
    sstrncpy(argp, (char const   *)*(cmd->argv + 0), (size_t )sizeof(arg));
    }
  } else {
#line 792
    ptr = *(cmd->argv + 1);
    {
#line 792
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 792
      if (! *ptr) {
#line 792
        goto while_break___2;
      }
      {
#line 793
      tmp___61 = toupper((int )*ptr);
#line 793
      *ptr = (char )tmp___61;
#line 792
      ptr ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 796
    snprintf((char */* __restrict  */)argp, (size_t )sizeof(arg), (char const   */* __restrict  */)"%s %s",
             *(cmd->argv + 0), *(cmd->argv + 1));
    }
  }
#line 799
  m ++;
#line 800
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 803
  argp = arg;
#line 804
  snprintf((char */* __restrict  */)argp, (size_t )sizeof(arg), (char const   */* __restrict  */)"%d",
           (cmd->server)->ServerPort);
#line 805
  m ++;
  }
#line 806
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 809
  argp = arg;
#line 810
  tmp___63 = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 810
  sstrncpy(argp, tmp___63, (size_t )sizeof(arg));
#line 811
  m ++;
  }
#line 812
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 815
  argp = arg;
#line 816
  sstrncpy(argp, (cmd->server)->ServerFQDN, (size_t )sizeof(arg));
#line 817
  m ++;
  }
#line 818
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 821
  argp = arg;
#line 822
  tmp___64 = getpid();
#line 822
  snprintf((char */* __restrict  */)argp, (size_t )sizeof(arg), (char const   */* __restrict  */)"%u",
           (unsigned int )tmp___64);
#line 823
  m ++;
  }
#line 824
  goto switch_break;
  case_9: /* CIL Label */ 
#line 828
  time_fmt = (char *)"[%d/%b/%Y:%H:%M:%S ";
#line 830
  internal_fmt = 1;
#line 834
  argp = arg;
#line 835
  m ++;
#line 837
  if ((int )*m == 255) {
#line 837
    if ((int )*(m + 1) == 1) {
      {
#line 839
      time_fmt = get_next_meta(p, cmd, & m);
#line 840
      internal_fmt = 0;
      }
    }
  }
  {
#line 843
  tmp___65 = _get_gmtoff(& timz);
#line 843
  t = *tmp___65;
  }
#line 844
  if (timz < 0) {
#line 844
    sign = (char )'-';
  } else {
#line 844
    sign = (char )'+';
  }
#line 845
  if (timz < 0) {
#line 846
    timz = - timz;
  }
#line 848
  if (time_fmt) {
    {
#line 849
    strftime((char */* __restrict  */)argp, (size_t )80, (char const   */* __restrict  */)time_fmt,
             (struct tm  const  */* __restrict  */)(& t));
    }
#line 850
    if (internal_fmt) {
      {
#line 851
      tmp___68 = strlen((char const   *)argp);
      }
#line 851
      if ((unsigned long )tmp___68 < sizeof(arg)) {
        {
#line 852
        tmp___66 = strlen((char const   *)argp);
#line 852
        tmp___67 = strlen((char const   *)argp);
#line 852
        snprintf((char */* __restrict  */)(argp + tmp___67), (size_t )(sizeof(arg) - (unsigned long )tmp___66),
                 (char const   */* __restrict  */)"%c%.2d%.2d]", (int )sign, timz / 60,
                 timz % 60);
        }
      } else {
        {
#line 856
        pr_log_pri(5, "notice: %%t expansion yields excessive string, ignoring");
        }
      }
    }
  }
#line 862
  goto switch_break;
  case_10: /* CIL Label */ 
#line 865
  argp = arg;
#line 866
  if (session.xfer.p) {
#line 870
    if (session.xfer.start_time.tv_sec != 0L) {
#line 870
      goto _L___5;
    } else
#line 870
    if (session.xfer.start_time.tv_usec != 0L) {
      _L___5: /* CIL Label */ 
      {
#line 874
      gettimeofday((struct timeval */* __restrict  */)(& end_time), (__timezone_ptr_t )((void *)0));
#line 875
      end_time.tv_sec -= session.xfer.start_time.tv_sec;
      }
#line 877
      if (end_time.tv_usec >= session.xfer.start_time.tv_usec) {
#line 878
        end_time.tv_usec -= session.xfer.start_time.tv_usec;
      } else {
#line 881
        end_time.tv_usec = 1000000L - (session.xfer.start_time.tv_usec - end_time.tv_usec);
#line 883
        (end_time.tv_sec) --;
      }
      {
#line 886
      snprintf((char */* __restrict  */)argp, (size_t )sizeof(arg), (char const   */* __restrict  */)"%ld.%03ld",
               end_time.tv_sec, end_time.tv_usec / 1000L);
      }
    } else {
      {
#line 890
      sstrncpy(argp, "-", (size_t )sizeof(arg));
      }
    }
  } else {
    {
#line 893
    sstrncpy(argp, "-", (size_t )sizeof(arg));
    }
  }
#line 895
  m ++;
#line 896
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 899
  argp = arg;
#line 901
  tmp___70 = strcasecmp((char const   *)*(cmd->argv + 0), "PASS");
  }
#line 901
  if (tmp___70 == 0) {
#line 901
    if (session.hide_password) {
      {
#line 903
      sstrncpy(argp, "PASS (hidden)", (size_t )sizeof(arg));
      }
    } else {
      {
#line 906
      tmp___69 = get_full_cmd(cmd);
#line 906
      sstrncpy(argp, (char const   *)tmp___69, (size_t )sizeof(arg));
      }
    }
  } else {
    {
#line 906
    tmp___69 = get_full_cmd(cmd);
#line 906
    sstrncpy(argp, (char const   *)tmp___69, (size_t )sizeof(arg));
    }
  }
#line 909
  m ++;
#line 910
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 913
  argp = arg;
#line 914
  tmp___72 = strcasecmp((char const   *)*(cmd->argv + 0), "PASS");
  }
#line 914
  if (tmp___72 == 0) {
#line 914
    if (session.hide_password) {
      {
#line 916
      sstrncpy(argp, "(hidden)", (size_t )sizeof(arg));
      }
    } else {
      {
#line 919
      tmp___71 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 919
      sstrncpy(argp, (char const   *)tmp___71, (size_t )sizeof(arg));
      }
    }
  } else {
    {
#line 919
    tmp___71 = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 919
    sstrncpy(argp, (char const   *)tmp___71, (size_t )sizeof(arg));
    }
  }
#line 922
  m ++;
#line 923
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 926
  argp = arg;
#line 927
  sstrncpy(argp, (cmd->server)->ServerName, (size_t )sizeof(arg));
#line 928
  m ++;
  }
#line 929
  goto switch_break;
  case_16: /* CIL Label */ 
#line 932
  argp = arg;
#line 934
  if (! session.user) {
    {
#line 935
    tmp___73 = get_param_ptr((cmd->server)->conf, "UserName", 0);
#line 935
    u = (char *)tmp___73;
    }
#line 936
    if (! u) {
#line 937
      u = (char *)"root";
    }
    {
#line 939
    sstrncpy(argp, (char const   *)u, (size_t )sizeof(arg));
    }
  } else {
    {
#line 942
    sstrncpy(argp, (char const   *)session.user, (size_t )sizeof(arg));
    }
  }
#line 945
  m ++;
#line 946
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 949
  tmp___74 = get_param_ptr(main_server->conf, "USER", 0);
#line 949
  login_user = (char *)tmp___74;
#line 950
  argp = arg;
  }
#line 952
  if (login_user) {
    {
#line 953
    sstrncpy(argp, (char const   *)login_user, (size_t )sizeof(arg));
    }
  } else {
    {
#line 955
    sstrncpy(argp, "(none)", (size_t )sizeof(arg));
    }
  }
#line 957
  m ++;
#line 958
  goto switch_break;
  case_18: /* CIL Label */ 
#line 964
  argp = arg;
#line 965
  if (resp_list) {
#line 965
    r = resp_list;
  } else {
#line 965
    r = resp_err_list;
  }
  {
#line 967
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 967
    if (r) {
#line 967
      if (! (! r->num)) {
#line 967
        goto while_break___3;
      }
    } else {
#line 967
      goto while_break___3;
    }
#line 967
    r = r->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 968
  if (r) {
#line 968
    if (r->num) {
      {
#line 970
      sstrncpy(argp, (char const   *)r->num, (size_t )sizeof(arg));
      }
    } else {
#line 968
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    {
#line 973
    tmp___75 = strcasecmp((char const   *)*(cmd->argv + 0), "QUIT");
    }
#line 973
    if (tmp___75 == 0) {
      {
#line 974
      sstrncpy(argp, "221", (size_t )sizeof(arg));
      }
    } else {
      {
#line 977
      sstrncpy(argp, "-", (size_t )sizeof(arg));
      }
    }
  }
#line 980
  m ++;
#line 981
  goto switch_break;
  case_26: /* CIL Label */ 
#line 987
  argp = arg;
#line 988
  if (resp_list) {
#line 988
    r___0 = resp_list;
  } else {
#line 988
    r___0 = resp_err_list;
  }
  {
#line 990
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 990
    if (r___0) {
#line 990
      if (! (! r___0->msg)) {
#line 990
        goto while_break___4;
      }
    } else {
#line 990
      goto while_break___4;
    }
#line 990
    r___0 = r___0->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 991
  if (r___0) {
#line 991
    if (r___0->msg) {
      {
#line 993
      sstrncpy(argp, (char const   *)r___0->msg, (size_t )sizeof(arg));
      }
    } else {
      {
#line 996
      sstrncpy(argp, "-", (size_t )sizeof(arg));
      }
    }
  } else {
    {
#line 996
    sstrncpy(argp, "-", (size_t )sizeof(arg));
    }
  }
#line 999
  m ++;
#line 1000
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 1004
  argp = arg;
#line 1005
  sstrncpy(argp, "1.3.2", (size_t )sizeof(arg));
#line 1006
  m ++;
  }
#line 1007
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1011
  *f = m;
#line 1012
  if (argp) {
    {
#line 1013
    tmp___76 = pstrdup(p, (char const   *)argp);
    }
#line 1013
    return (tmp___76);
  }
#line 1016
  return ((char *)((void *)0));
}
}
#line 1020
int syslog_sockfd ;
#line 1022 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static void do_log(cmd_rec *cmd , logfile_t *lf ) 
{ 
  unsigned char *f ;
  size_t size ;
  char logbuf___0[1025] ;
  unsigned int tmp ;
  logformat_t *fmt ;
  char *s ;
  char *bp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1023
  f = (unsigned char *)((void *)0);
#line 1024
  size = (size_t )1023;
#line 1025
  logbuf___0[0] = (char )'\000';
#line 1025
  tmp = 1U;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (tmp >= 1025U) {
#line 1025
      goto while_break;
    }
#line 1025
    logbuf___0[tmp] = (char)0;
#line 1025
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1026
  fmt = (logformat_t *)((void *)0);
#line 1029
  fmt = lf->lf_format;
#line 1030
  f = fmt->lf_format;
#line 1031
  bp = logbuf___0;
  {
#line 1033
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1033
    if (*f) {
#line 1033
      if (! size) {
#line 1033
        goto while_break___0;
      }
    } else {
#line 1033
      goto while_break___0;
    }
#line 1034
    if ((int )*f == 255) {
      {
#line 1035
      s = get_next_meta(cmd->tmp_pool, cmd, & f);
      }
#line 1037
      if (s) {
        {
#line 1040
        tmp___0 = strlen((char const   *)s);
        }
#line 1041
        if (tmp___0 > size) {
#line 1042
          tmp___0 = size;
        }
        {
#line 1044
        memcpy((void */* __restrict  */)bp, (void const   */* __restrict  */)s, tmp___0);
#line 1045
        size -= tmp___0;
#line 1046
        bp += tmp___0;
        }
      }
    } else {
#line 1050
      tmp___1 = bp;
#line 1050
      bp ++;
#line 1050
      tmp___2 = f;
#line 1050
      f ++;
#line 1050
      *tmp___1 = (char )*tmp___2;
#line 1051
      size --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1055
  tmp___3 = bp;
#line 1055
  bp ++;
#line 1055
  *tmp___3 = (char )'\n';
#line 1056
  *bp = (char )'\000';
#line 1058
  if (lf->lf_fd != -4) {
    {
#line 1059
    tmp___6 = strlen((char const   *)(logbuf___0));
#line 1059
    tmp___7 = write(lf->lf_fd, (void const   *)(logbuf___0), tmp___6);
    }
#line 1059
    if (tmp___7 < 0) {
      {
#line 1060
      tmp___4 = __errno_location();
#line 1060
      tmp___5 = strerror(*tmp___4);
#line 1060
      pr_log_pri(3, "error: cannot write ExtendedLog to fd %d: %s", lf->lf_fd, tmp___5);
      }
    }
  } else {
    {
#line 1065
    pr_syslog(syslog_sockfd, lf->lf_syslog_level, "%s", logbuf___0);
    }
  }
#line 1066
  return;
}
}
#line 1068 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *log_any(cmd_rec *cmd ) 
{ 
  logfile_t *lf ;

  {
#line 1069
  lf = (logfile_t *)((void *)0);
#line 1072
  lf = logs;
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! lf) {
#line 1072
      goto while_break;
    }
#line 1073
    if (lf->lf_fd != -1) {
#line 1073
      if (cmd->class & lf->lf_classes) {
#line 1076
        if (! session.anon_config) {
#line 1076
          if (lf->lf_conf) {
#line 1076
            if ((lf->lf_conf)->config_type == 1 << 2) {
#line 1079
              goto __Cont;
            }
          }
        }
        {
#line 1081
        do_log(cmd, lf);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1072
    lf = lf->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1085
  return ((modret_t *)((void *)0));
}
}
#line 1088 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static void log_restart_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1089
  destroy_pool(log_pool);
#line 1091
  formats = (logformat_t *)((void *)0);
#line 1092
  format_set = (xaset_t *)((void *)0);
#line 1093
  logs = (logfile_t *)((void *)0);
#line 1094
  log_set = (xaset_t *)((void *)0);
#line 1096
  log_pool = make_sub_pool(permanent_pool);
#line 1097
  pr_pool_tag(log_pool, "mod_log pool");
#line 1099
  logformat((char *)"", (char *)"%h %l %u %t \"%r\" %s %b");
  }
#line 1101
  return;
}
}
#line 1104 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static int log_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1105
  log_pool = make_sub_pool(permanent_pool);
#line 1106
  pr_pool_tag(log_pool, "mod_log pool");
#line 1109
  logformat((char *)"", (char *)"%h %l %u %t \"%r\" %s %b");
#line 1111
  pr_event_register(& log_module, "core.restart", & log_restart_ev, (void *)0);
  }
#line 1112
  return (0);
}
}
#line 1115 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static void find_extendedlogs(void) 
{ 
  config_rec *c ;
  char *logfname ;
  int logclasses ;
  logformat_t *logfmt ;
  char *logfmt_s ;
  logfile_t *extlog ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1118
  logclasses = (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6);
#line 1120
  logfmt_s = (char *)((void *)0);
#line 1121
  extlog = (logfile_t *)((void *)0);
#line 1131
  c = find_config(main_server->conf, 1 << 15, "ExtendedLog", 1);
  }
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! c) {
#line 1133
      goto while_break;
    }
#line 1134
    logfname = (char *)*(c->argv + 0);
#line 1136
    if (c->argc > 1) {
      {
#line 1137
      logclasses = _parse_classes((char *)*(c->argv + 1));
      }
#line 1138
      if (c->argc > 2) {
#line 1139
        logfmt_s = (char *)*(c->argv + 2);
      }
    }
#line 1144
    if (logclasses == 0) {
#line 1145
      goto loop_extendedlogs;
    }
#line 1147
    if (logfmt_s) {
#line 1149
      logfmt = formats;
      {
#line 1149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1149
        if (! logfmt) {
#line 1149
          goto while_break___0;
        }
        {
#line 1150
        tmp = strcmp((char const   *)logfmt->lf_nickname, (char const   *)logfmt_s);
        }
#line 1150
        if (tmp == 0) {
#line 1151
          goto while_break___0;
        }
#line 1149
        logfmt = logfmt->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1153
      if (! logfmt) {
        {
#line 1154
        pr_log_pri(5, "ExtendedLog \'%s\' uses unknown format nickname \'%s\'", logfname,
                   logfmt_s);
        }
#line 1157
        goto loop_extendedlogs;
      }
    } else {
#line 1161
      logfmt = formats;
    }
    {
#line 1164
    tmp___0 = pcalloc(session.pool, (int )sizeof(logfile_t ));
#line 1164
    extlog = (logfile_t *)tmp___0;
#line 1166
    extlog->lf_filename = pstrdup(session.pool, (char const   *)logfname);
#line 1167
    extlog->lf_fd = -1;
#line 1168
    extlog->lf_syslog_level = -1;
#line 1169
    extlog->lf_classes = logclasses;
#line 1170
    extlog->lf_format = logfmt;
#line 1171
    extlog->lf_conf = c->parent;
    }
#line 1172
    if (! log_set) {
      {
#line 1173
      log_set = xaset_create(session.pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
      }
    }
    {
#line 1175
    xaset_insert(log_set, (xasetmember_t *)extlog);
#line 1176
    logs = (logfile_t *)log_set->xas_list;
    }
    loop_extendedlogs: 
    {
#line 1179
    c = find_config_next(c, c->next, 1 << 15, "ExtendedLog", 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1181
  return;
}
}
#line 1183 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *log_pre_dele(cmd_rec *cmd ) 
{ 
  char *path ;
  char *tmp ;
  struct stat st ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 1186
  log_dele_filesz = (off_t___0 )0;
#line 1188
  tmp = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 1188
  path = dir_canonical_path(cmd->tmp_pool, (char const   *)tmp);
  }
#line 1190
  if (path) {
    {
#line 1196
    pr_fs_clear_cache();
#line 1197
    tmp___0 = pr_fsio_stat((char const   *)path, & st);
    }
#line 1197
    if (tmp___0 == 0) {
#line 1198
      log_dele_filesz = st.st_size;
    }
  }
#line 1201
  return ((modret_t *)((void *)0));
}
}
#line 1204 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static modret_t *log_post_pass(cmd_rec *cmd ) 
{ 
  logfile_t *lf ;
  logfile_t *lfi ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1210
  if (! session.anon_config) {
#line 1211
    lf = logs;
    {
#line 1211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1211
      if (! lf) {
#line 1211
        goto while_break;
      }
#line 1212
      if (lf->lf_fd != -1) {
#line 1212
        if (lf->lf_fd != -4) {
#line 1212
          if (lf->lf_conf) {
#line 1212
            if ((lf->lf_conf)->config_type == 1 << 2) {
              {
#line 1214
              pr_log_debug(7, "mod_log: closing ExtendedLog \'%s\'", lf->lf_filename);
#line 1216
              close(lf->lf_fd);
#line 1217
              lf->lf_fd = -1;
              }
            }
          }
        }
      }
#line 1211
      lf = lf->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1225
    lf = logs;
    {
#line 1225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1225
      if (! lf) {
#line 1225
        goto while_break___0;
      }
#line 1226
      if (lf->lf_fd != -1) {
#line 1226
        if (lf->lf_fd != -4) {
#line 1226
          if (lf->lf_conf) {
#line 1226
            if ((unsigned long )lf->lf_conf != (unsigned long )session.anon_config) {
              {
#line 1228
              pr_log_debug(7, "mod_log: closing ExtendedLog \'%s\'", lf->lf_filename);
#line 1230
              close(lf->lf_fd);
#line 1231
              lf->lf_fd = -1;
              }
            }
          }
        }
      }
#line 1225
      lf = lf->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1238
    lf = logs;
    {
#line 1238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1238
      if (! lf) {
#line 1238
        goto while_break___1;
      }
#line 1239
      if (lf->lf_conf) {
#line 1239
        if ((unsigned long )lf->lf_conf == (unsigned long )session.anon_config) {
#line 1243
          lfi = (logfile_t *)((void *)0);
#line 1245
          lfi = logs;
          {
#line 1245
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1245
            if (! lfi) {
#line 1245
              goto while_break___2;
            }
#line 1246
            if (lfi->lf_fd != -1) {
#line 1246
              if (lfi->lf_fd != -4) {
#line 1246
                if (! lfi->lf_conf) {
                  {
#line 1246
                  tmp = strcmp((char const   *)lfi->lf_filename, (char const   *)lf->lf_filename);
                  }
#line 1246
                  if (tmp == 0) {
                    {
#line 1250
                    pr_log_debug(7, "mod_log: closing ExtendedLog \'%s\'", lf->lf_filename);
#line 1252
                    close(lfi->lf_fd);
#line 1253
                    lfi->lf_fd = -1;
                    }
                  }
                }
              }
            }
#line 1245
            lfi = lfi->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1258
          if (lf->lf_fd != -1) {
#line 1258
            if (lf->lf_fd != -4) {
#line 1258
              if (lf->lf_classes == 0) {
                {
#line 1261
                pr_log_debug(7, "mod_log: closing ExtendedLog \'%s\'", lf->lf_filename);
#line 1263
                close(lf->lf_fd);
#line 1264
                lf->lf_fd = -1;
                }
              }
            }
          }
        }
      }
#line 1238
      lf = lf->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1270
  return ((modret_t *)((void *)0));
}
}
#line 1274 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static int log_sess_init(void) 
{ 
  char *serverlog_name ;
  logfile_t *lf ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  int res ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  __uid_t tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
  {
#line 1275
  serverlog_name = (char *)((void *)0);
#line 1276
  lf = (logfile_t *)((void *)0);
#line 1279
  tmp___15 = get_param_ptr(main_server->conf, "ServerLog", 0);
#line 1279
  serverlog_name = (char *)tmp___15;
  }
#line 1279
  if ((unsigned long )serverlog_name != (unsigned long )((void *)0)) {
    {
#line 1281
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c",
                 1281);
#line 1281
    pr_signals_block();
    }
#line 1281
    if (! session.disable_id_switching) {
      {
#line 1281
      tmp___1 = seteuid((__uid_t )0);
      }
#line 1281
      if (tmp___1) {
        {
#line 1281
        tmp = __errno_location();
#line 1281
        tmp___0 = strerror(*tmp);
#line 1281
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
        }
      }
      {
#line 1281
      tmp___4 = setegid((__gid_t )0);
      }
#line 1281
      if (tmp___4) {
        {
#line 1281
        tmp___2 = __errno_location();
#line 1281
        tmp___3 = strerror(*tmp___2);
#line 1281
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
        }
      }
    } else {
      {
#line 1281
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 1281
    pr_signals_unblock();
#line 1282
    log_closesyslog();
#line 1283
    log_opensyslog((char const   *)serverlog_name);
#line 1284
    pr_signals_block();
    }
#line 1284
    if (! session.disable_id_switching) {
      {
#line 1284
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c",
                   1284);
#line 1284
      tmp___8 = geteuid();
      }
#line 1284
      if (tmp___8 != 0U) {
        {
#line 1284
        tmp___7 = seteuid((__uid_t )0);
        }
#line 1284
        if (tmp___7) {
          {
#line 1284
          tmp___5 = __errno_location();
#line 1284
          tmp___6 = strerror(*tmp___5);
#line 1284
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
          }
        }
      }
      {
#line 1284
      tmp___11 = setegid(session.gid);
      }
#line 1284
      if (tmp___11) {
        {
#line 1284
        tmp___9 = __errno_location();
#line 1284
        tmp___10 = strerror(*tmp___9);
#line 1284
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
        }
      }
      {
#line 1284
      tmp___14 = seteuid(session.uid);
      }
#line 1284
      if (tmp___14) {
        {
#line 1284
        tmp___12 = __errno_location();
#line 1284
        tmp___13 = strerror(*tmp___12);
#line 1284
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
        }
      }
    } else {
      {
#line 1284
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 1284
    pr_signals_unblock();
    }
  }
  {
#line 1288
  find_extendedlogs();
#line 1290
  lf = logs;
  }
  {
#line 1290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1290
    if (! lf) {
#line 1290
      goto while_break;
    }
#line 1292
    if (lf->lf_fd == -1) {
      {
#line 1295
      tmp___36 = strncasecmp((char const   *)lf->lf_filename, "syslog:", (size_t )7);
      }
#line 1295
      if (tmp___36 != 0) {
        {
#line 1296
        res = 0;
#line 1298
        pr_log_debug(7, "mod_log: opening ExtendedLog \'%s\'", lf->lf_filename);
#line 1301
        pr_signals_block();
#line 1302
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c",
                     1302);
#line 1302
        pr_signals_block();
        }
#line 1302
        if (! session.disable_id_switching) {
          {
#line 1302
          tmp___18 = seteuid((__uid_t )0);
          }
#line 1302
          if (tmp___18) {
            {
#line 1302
            tmp___16 = __errno_location();
#line 1302
            tmp___17 = strerror(*tmp___16);
#line 1302
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___17);
            }
          }
          {
#line 1302
          tmp___21 = setegid((__gid_t )0);
          }
#line 1302
          if (tmp___21) {
            {
#line 1302
            tmp___19 = __errno_location();
#line 1302
            tmp___20 = strerror(*tmp___19);
#line 1302
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___20);
            }
          }
        } else {
          {
#line 1302
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 1302
        pr_signals_unblock();
#line 1303
        res = pr_log_openfile((char const   *)lf->lf_filename, & lf->lf_fd, (mode_t )420);
#line 1304
        pr_signals_block();
        }
#line 1304
        if (! session.disable_id_switching) {
          {
#line 1304
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c",
                       1304);
#line 1304
          tmp___25 = geteuid();
          }
#line 1304
          if (tmp___25 != 0U) {
            {
#line 1304
            tmp___24 = seteuid((__uid_t )0);
            }
#line 1304
            if (tmp___24) {
              {
#line 1304
              tmp___22 = __errno_location();
#line 1304
              tmp___23 = strerror(*tmp___22);
#line 1304
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___23);
              }
            }
          }
          {
#line 1304
          tmp___28 = setegid(session.gid);
          }
#line 1304
          if (tmp___28) {
            {
#line 1304
            tmp___26 = __errno_location();
#line 1304
            tmp___27 = strerror(*tmp___26);
#line 1304
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___27);
            }
          }
          {
#line 1304
          tmp___31 = seteuid(session.uid);
          }
#line 1304
          if (tmp___31) {
            {
#line 1304
            tmp___29 = __errno_location();
#line 1304
            tmp___30 = strerror(*tmp___29);
#line 1304
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___30);
            }
          }
        } else {
          {
#line 1304
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 1304
        pr_signals_unblock();
#line 1305
        pr_signals_unblock();
        }
#line 1307
        if (res == -1) {
          {
#line 1308
          tmp___32 = __errno_location();
#line 1308
          tmp___33 = strerror(*tmp___32);
#line 1308
          pr_log_pri(5, "unable to open ExtendedLog \'%s\': %s", lf->lf_filename,
                     tmp___33);
          }
#line 1310
          goto __Cont;
        } else
#line 1312
        if (res == -2) {
          {
#line 1313
          pr_log_pri(5, "unable to open ExtendedLog \'%s\': containing directory is world writable",
                     lf->lf_filename);
          }
#line 1315
          goto __Cont;
        } else
#line 1317
        if (res == -3) {
          {
#line 1318
          pr_log_pri(5, "unable to open ExtendedLog \'%s\': %s is a symbolic link",
                     lf->lf_filename, lf->lf_filename);
#line 1320
          close(lf->lf_fd);
#line 1321
          lf->lf_fd = -1;
          }
#line 1322
          goto __Cont;
        }
      } else {
        {
#line 1326
        tmp___35 = strchr((char const   *)lf->lf_filename, ':');
#line 1326
        tmp___34 = tmp___35;
#line 1328
        tmp___34 ++;
#line 1328
        lf->lf_syslog_level = pr_log_str2sysloglevel((char const   *)tmp___34);
#line 1329
        lf->lf_fd = -4;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1290
    lf = lf->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1334
  return (0);
}
}
#line 1340 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static conftable log_conftab[6]  = {      {(char *)"AllowLogSymlinks", & set_allowlogsymlinks, (module *)((void *)0)}, 
        {(char *)"ExtendedLog", & set_extendedlog, (module *)((void *)0)}, 
        {(char *)"LogFormat", & set_logformat, (module *)((void *)0)}, 
        {(char *)"ServerLog", & set_serverlog, (module *)((void *)0)}, 
        {(char *)"SystemLog", & set_systemlog, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)((void *)0)}};
#line 1349 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
static cmdtable log_cmdtab[5]  = {      {(unsigned char)1, (char *)"DELE", (char *)((void *)0), & log_pre_dele, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)5, (char *)"*", (char *)((void *)0), & log_any, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"*", (char *)((void *)0), & log_any, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & log_post_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 1357 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_log.c"
module log_module  = 
#line 1357
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"log", log_conftab,
    log_cmdtab, (authtable *)((void *)0), & log_init, & log_sess_init, (char *)0,
    (void *)0, 0};
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 531
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 686
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 224 "/usr/include/dirent.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dirfd)(DIR *__dirp ) ;
#line 79 "../include/support.h"
int get_name_max(char *dirname , int dir_fd ) ;
#line 81
mode_t file_mode(char *path ) ;
#line 262 "../include/dirtree.h"
unsigned char dir_hide_file(char const   *path ) ;
#line 266
int dir_check_canon(pool *pp , char *cmd , char *group , char *path , int *hidden ) ;
#line 267
int is_dotdir(char const   *dir ) ;
#line 68 "../include/auth.h"
struct passwd *pr_auth_getpwnam(pool *p , char const   *name ) ;
#line 74
char const   *pr_auth_uid2name(pool *p , uid_t uid ) ;
#line 75
char const   *pr_auth_gid2name(pool *p , gid_t gid ) ;
#line 35 "../include/data.h"
void pr_data_cleanup(void) ;
#line 236 "../include/fsio.h"
int pr_fsio_lstat(char const   *path , struct stat *sbuf___0 ) ;
#line 238
int pr_fsio_readlink(char const   *path , char *buf___2 , size_t buflen ) ;
#line 240
int pr_fsio_chdir(char const   *path , int hidesymlink ) ;
#line 241
int pr_fsio_chdir_canon(char const   *path , int hidesymlink ) ;
#line 318
void pr_fs_clean_path(char const   *path , char *buf___2 , size_t buflen ) ;
#line 319
int pr_fs_glob(char const   *pattern , int flags , int (*errfunc)(char const   * ,
                                                                  int  ) , glob_t *pglob ) ;
#line 320
void pr_fs_globfree(glob_t *pglob ) ;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void addfile(cmd_rec *cmd , char const   *name , char const   *suffix , time_t mtime ,
                    off_t___0 size ) ;
#line 44
static int outputfiles(cmd_rec *cmd ) ;
#line 46
static int listfile(cmd_rec *cmd , pool *p , char const   *name ) ;
#line 47
static int listdir(cmd_rec *cmd , pool *workp , char const   *name ) ;
#line 49
static int ( /* format attribute */  sendline)(int flags , char *fmt  , ...) ;
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static unsigned char list_strict_opts  =    (unsigned char)0;
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char *list_options  =    (char *)((void *)0);
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static unsigned char list_show_symlinks  =    (unsigned char)1;
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static unsigned char list_times_gmt  =    (unsigned char)1;
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static unsigned char show_symlinks_hold  ;
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char *fakeuser  =    (char *)((void *)0);
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char *fakegroup  =    (char *)((void *)0);
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static mode_t fakemode  ;
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static unsigned char have_fake_mode  =    (unsigned char)0;
#line 64 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int ls_errno  =    0;
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static time_t ls_curtime  =    (time_t )0;
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static unsigned char use_globbing  =    (unsigned char)1;
#line 75 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static struct list_limit_rec list_ndepth  ;
#line 76 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static struct list_limit_rec list_ndirs  ;
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static struct list_limit_rec list_nfiles  ;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_a  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_A  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_C  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_d  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_F  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_h  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_l  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_L  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_n  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_R  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_r  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_S  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_t  =    0;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int opt_STAT  =    0;
#line 96 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char cwd[4097]  = {      (char )'\000'};
#line 103 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static config_rec *_find_ls_limit(char *ftp_cmd ) 
{ 
  config_rec *c ;
  config_rec *limit_c ;
  register unsigned int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 104
  c = (config_rec *)((void *)0);
#line 104
  limit_c = (config_rec *)((void *)0);
#line 106
  if (! ftp_cmd) {
#line 107
    return ((config_rec *)((void *)0));
  }
#line 109
  if (! session.dir_config) {
#line 110
    return ((config_rec *)((void *)0));
  }
#line 113
  c = session.dir_config;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! c) {
#line 113
      goto while_break;
    }
#line 115
    if (c->subset) {
#line 117
      limit_c = (config_rec *)(c->subset)->xas_list;
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 117
        if (! limit_c) {
#line 117
          goto while_break___0;
        }
#line 120
        if (limit_c->config_type == 1 << 3) {
#line 121
          i___0 = 0U;
#line 123
          i___0 = 0U;
          {
#line 123
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 123
            if (! (i___0 < (unsigned int )limit_c->argc)) {
#line 123
              goto while_break___1;
            }
            {
#line 127
            tmp = strcasecmp((char const   *)ftp_cmd, (char const   *)((char *)*(limit_c->argv + i___0)));
            }
#line 127
            if (tmp) {
              {
#line 127
              tmp___0 = strcasecmp("DIRS", (char const   *)((char *)*(limit_c->argv + i___0)));
              }
#line 127
              if (tmp___0) {
                {
#line 127
                tmp___1 = strcasecmp("ALL", (char const   *)((char *)*(limit_c->argv + i___0)));
                }
#line 127
                if (! tmp___1) {
#line 130
                  goto while_break___1;
                }
              } else {
#line 130
                goto while_break___1;
              }
            } else {
#line 130
              goto while_break___1;
            }
#line 123
            i___0 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 133
          if (i___0 == (unsigned int )limit_c->argc) {
#line 134
            goto __Cont;
          }
#line 138
          return (limit_c);
        }
        __Cont: /* CIL Label */ 
#line 117
        limit_c = limit_c->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 113
    c = c->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return ((config_rec *)((void *)0));
}
}
#line 147 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void push_cwd(char *_cwd , unsigned char *symhold ) 
{ 
  char const   *tmp ;

  {
#line 148
  if (! _cwd) {
#line 149
    _cwd = cwd;
  }
#line 151
  if (! symhold) {
#line 152
    *symhold = show_symlinks_hold;
  }
  {
#line 154
  tmp = pr_fs_getcwd();
#line 154
  sstrncpy(_cwd, tmp, (size_t )4097);
#line 155
  *symhold = list_show_symlinks;
  }
#line 156
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void pop_cwd(char *_cwd , unsigned char *symhold ) 
{ 


  {
#line 159
  if (! _cwd) {
#line 160
    _cwd = cwd;
  }
#line 162
  if (! symhold) {
#line 163
    *symhold = show_symlinks_hold;
  }
  {
#line 165
  pr_fsio_chdir((char const   *)_cwd, (int )*symhold);
#line 166
  list_show_symlinks = *symhold;
  }
#line 167
  return;
}
}
#line 169 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int ls_perms_full(pool *p , cmd_rec *cmd , char const   *path , int *hidden ) 
{ 
  int res ;
  int canon ;
  char *fullpath ;
  mode_t *fake_mode ;
  unsigned char *tmp ;
  void *tmp___0 ;
  xaset_t *tmp___1 ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 170
  canon = 0;
#line 172
  fake_mode = (mode_t *)((void *)0);
#line 174
  fullpath = dir_realpath(p, path);
  }
#line 176
  if (! fullpath) {
    {
#line 177
    fullpath = dir_canonical_path(p, path);
#line 178
    canon = 1;
    }
  }
#line 181
  if (! fullpath) {
    {
#line 182
    fullpath = pstrdup(p, path);
    }
  }
#line 184
  if (canon) {
    {
#line 185
    res = dir_check_canon(p, *(cmd->argv + 0), cmd->group, fullpath, hidden);
    }
  } else {
    {
#line 187
    res = dir_check(p, *(cmd->argv + 0), cmd->group, fullpath, hidden);
    }
  }
#line 189
  if (session.dir_config) {
    {
#line 190
    tmp___0 = get_param_ptr((session.dir_config)->subset, "ShowSymlinks", 0);
#line 190
    tmp = (unsigned char *)tmp___0;
    }
#line 193
    if (tmp) {
#line 194
      list_show_symlinks = *tmp;
    }
  }
#line 197
  if (session.dir_config) {
#line 197
    tmp___2 = (session.dir_config)->subset;
  } else {
#line 197
    if (session.anon_config) {
#line 197
      tmp___1 = (session.anon_config)->subset;
    } else {
#line 197
      tmp___1 = main_server->conf;
    }
#line 197
    tmp___2 = tmp___1;
  }
  {
#line 197
  tmp___3 = get_param_ptr(tmp___2, "DirFakeMode", 0);
#line 197
  fake_mode = (mode_t *)tmp___3;
  }
#line 198
  if (fake_mode) {
#line 199
    fakemode = *fake_mode;
#line 200
    have_fake_mode = (unsigned char)1;
  } else {
#line 203
    have_fake_mode = (unsigned char)0;
  }
#line 205
  return (res);
}
}
#line 208 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int ls_perms(pool *p , cmd_rec *cmd , char const   *path , int *hidden ) 
{ 
  int res ;
  char fullpath[4097] ;
  unsigned int tmp ;
  mode_t *fake_mode ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  unsigned char *tmp___4 ;
  void *tmp___5 ;
  xaset_t *tmp___6 ;
  xaset_t *tmp___7 ;
  void *tmp___8 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 209
  res = 0;
#line 210
  fullpath[0] = (char )'\000';
#line 210
  tmp = 1U;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (tmp >= 4097U) {
#line 210
      goto while_break;
    }
#line 210
    fullpath[tmp] = (char)0;
#line 210
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  fake_mode = (mode_t *)((void *)0);
#line 214
  tmp___0 = is_dotdir(path);
  }
#line 214
  if (tmp___0) {
#line 215
    return (1);
  }
#line 217
  if ((int const   )*path == 126) {
    {
#line 218
    tmp___1 = ls_perms_full(p, cmd, path, hidden);
    }
#line 218
    return (tmp___1);
  }
#line 220
  if ((int const   )*path != 47) {
    {
#line 221
    tmp___2 = pr_fs_getcwd();
#line 221
    tmp___3 = pdircat(p, tmp___2, path, (void *)0);
#line 221
    pr_fs_clean_path((char const   *)tmp___3, fullpath, (size_t )4096);
    }
  } else {
    {
#line 224
    pr_fs_clean_path(path, fullpath, (size_t )4096);
    }
  }
  {
#line 226
  res = dir_check(p, *(cmd->argv + 0), cmd->group, fullpath, hidden);
  }
#line 228
  if (session.dir_config) {
    {
#line 229
    tmp___5 = get_param_ptr((session.dir_config)->subset, "ShowSymlinks", 0);
#line 229
    tmp___4 = (unsigned char *)tmp___5;
    }
#line 232
    if (tmp___4) {
#line 233
      list_show_symlinks = *tmp___4;
    }
  }
#line 236
  if (session.dir_config) {
#line 236
    tmp___7 = (session.dir_config)->subset;
  } else {
#line 236
    if (session.anon_config) {
#line 236
      tmp___6 = (session.anon_config)->subset;
    } else {
#line 236
      tmp___6 = main_server->conf;
    }
#line 236
    tmp___7 = tmp___6;
  }
  {
#line 236
  tmp___8 = get_param_ptr(tmp___7, "DirFakeMode", 0);
#line 236
  fake_mode = (mode_t *)tmp___8;
  }
#line 237
  if (fake_mode) {
#line 238
    fakemode = *fake_mode;
#line 239
    have_fake_mode = (unsigned char)1;
  } else {
#line 242
    have_fake_mode = (unsigned char)0;
  }
#line 244
  return (res);
}
}
#line 249 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char listbuf[1024]  = {      (char )'\000'};
#line 248 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int ( /* format attribute */  sendline)(int flags , char *fmt  , ...) 
{ 
  va_list msg ;
  char buf___2[1025] ;
  unsigned int tmp ;
  int res ;
  size_t listbuflen ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 251
  buf___2[0] = (char )'\000';
#line 251
  tmp = 1U;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (tmp >= 1025U) {
#line 251
      goto while_break;
    }
#line 251
    buf___2[tmp] = (char)0;
#line 251
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  res = 0;
#line 254
  if (flags & 1) {
    {
#line 255
    tmp___0 = strlen((char const   *)(listbuf));
#line 255
    listbuflen = tmp___0;
    }
#line 257
    if (listbuflen > 0U) {
      {
#line 258
      res = pr_data_xfer(listbuf, (int )listbuflen);
      }
#line 259
      if (res < 0) {
        {
#line 259
        tmp___2 = __errno_location();
        }
#line 259
        if (*tmp___2 != 0) {
          {
#line 261
          tmp___1 = strerror(((session.d)->outstrm)->strm_errno);
#line 261
          pr_log_debug(3, "pr_data_xfer returned %d, error = %s.", res, tmp___1);
          }
        }
      }
      {
#line 265
      memset((void *)(listbuf), '\000', (size_t )sizeof(listbuf));
      }
    }
#line 268
    return (res);
  }
  {
#line 271
  __builtin_va_start(msg, fmt);
#line 272
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 273
  __builtin_va_end(msg);
#line 275
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 278
  tmp___6 = strlen((char const   *)(buf___2));
#line 278
  tmp___7 = strlen((char const   *)(listbuf));
  }
#line 278
  if ((unsigned long )tmp___6 >= sizeof(listbuf) - (unsigned long )tmp___7) {
    {
#line 279
    tmp___3 = strlen((char const   *)(listbuf));
#line 279
    res = pr_data_xfer(listbuf, (int )tmp___3);
    }
#line 280
    if (res < 0) {
      {
#line 280
      tmp___5 = __errno_location();
      }
#line 280
      if (*tmp___5 != 0) {
        {
#line 282
        tmp___4 = strerror(((session.d)->outstrm)->strm_errno);
#line 282
        pr_log_debug(3, "pr_data_xfer returned %d, error = %s.", res, tmp___4);
        }
      }
    }
    {
#line 286
    memset((void *)(listbuf), '\000', (size_t )sizeof(listbuf));
    }
  }
  {
#line 289
  sstrcat(listbuf, (char const   *)(buf___2), (size_t )sizeof(listbuf));
  }
#line 290
  return (res);
}
}
#line 293 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void ls_done(cmd_rec *cmd ) 
{ 
  int quiet___0 ;

  {
#line 294
  quiet___0 = 0;
#line 296
  if (session.sf_flags & (int volatile   )2) {
#line 297
    quiet___0 = 1;
  }
  {
#line 299
  pr_data_close(quiet___0);
  }
#line 300
  return;
}
}
#line 302 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char units[6][2]  = { {        (char )'\000'}, 
   {        (char )'k',        (char )'\000'}, 
   {        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'\000'}};
#line 305 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void ls_fmt_filesize(char *buf___2 , size_t buflen , off_t___0 sz ) 
{ 
  register unsigned int i___0 ;
  float size ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 306
  if (! opt_h) {
    {
#line 307
    snprintf((char */* __restrict  */)buf___2, buflen, (char const   */* __restrict  */)"%8llu",
             (unsigned long long )sz);
    }
  } else
#line 306
  if (sz < 1000LL) {
    {
#line 307
    snprintf((char */* __restrict  */)buf___2, buflen, (char const   */* __restrict  */)"%8llu",
             (unsigned long long )sz);
    }
  } else {
#line 310
    i___0 = 0U;
#line 311
    size = (float )sz;
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      if (! ((double )size >= 1024.0)) {
#line 314
        goto while_break;
      }
#line 315
      size = (float )((double )size / 1024.0);
#line 316
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 319
    snprintf((char */* __restrict  */)buf___2, buflen, (char const   */* __restrict  */)"%7.1f%s",
             (double )size, units[i___0]);
    }
  }
#line 321
  return;
}
}
#line 323 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char months[12][4]  = 
#line 323
  { {        (char )'J',        (char )'a',        (char )'n',        (char )'\000'}, 
   {        (char )'F',        (char )'e',        (char )'b',        (char )'\000'}, 
   {        (char )'M',        (char )'a',        (char )'r',        (char )'\000'}, 
   {        (char )'A',        (char )'p',        (char )'r',        (char )'\000'}, 
   {        (char )'M',        (char )'a',        (char )'y',        (char )'\000'}, 
   {        (char )'J',        (char )'u',        (char )'n',        (char )'\000'}, 
   {        (char )'J',        (char )'u',        (char )'l',        (char )'\000'}, 
   {        (char )'A',        (char )'u',        (char )'g',        (char )'\000'}, 
   {        (char )'S',        (char )'e',        (char )'p',        (char )'\000'}, 
   {        (char )'O',        (char )'c',        (char )'t',        (char )'\000'}, 
   {        (char )'N',        (char )'o',        (char )'v',        (char )'\000'}, 
   {        (char )'D',        (char )'e',        (char )'c',        (char )'\000'}};
#line 327 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int listfile(cmd_rec *cmd , pool *p , char const   *name ) 
{ 
  int rval ;
  int len ;
  time_t mtime ;
  char m[1024] ;
  unsigned int tmp ;
  char l[1024] ;
  unsigned int tmp___0 ;
  char s[16] ;
  unsigned int tmp___1 ;
  struct stat st ;
  struct tm *t ;
  char suffix[2] ;
  int hidden ;
  struct stat l_st ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char nameline[8320] ;
  unsigned int tmp___7 ;
  char timeline[6] ;
  unsigned int tmp___8 ;
  mode_t mode ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *buf___2 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
#line 328
  rval = 0;
#line 330
  m[0] = (char )'\000';
#line 330
  tmp = 1U;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (tmp >= 1024U) {
#line 330
      goto while_break;
    }
#line 330
    m[tmp] = (char)0;
#line 330
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  l[0] = (char )'\000';
#line 330
  tmp___0 = 1U;
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 330
    if (tmp___0 >= 1024U) {
#line 330
      goto while_break___0;
    }
#line 330
    l[tmp___0] = (char)0;
#line 330
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  s[0] = (char )'\000';
#line 330
  tmp___1 = 1U;
  {
#line 330
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 330
    if (tmp___1 >= 16U) {
#line 330
      goto while_break___1;
    }
#line 330
    s[tmp___1] = (char)0;
#line 330
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 332
  t = (struct tm *)((void *)0);
#line 334
  hidden = 0;
#line 336
  if (list_nfiles.curr) {
#line 336
    if (list_nfiles.max) {
#line 336
      if (list_nfiles.curr >= list_nfiles.max) {
#line 339
        if (! list_nfiles.logged) {
          {
#line 340
          pr_log_debug(8, "ListOptions maxfiles (%u) reached", list_nfiles.max);
#line 342
          list_nfiles.logged = (unsigned char)1;
          }
        }
#line 345
        return (2);
      }
    }
  }
#line 347
  (list_nfiles.curr) ++;
#line 349
  if (! p) {
#line 350
    p = cmd->tmp_pool;
  }
  {
#line 352
  tmp___26 = pr_fsio_lstat(name, & st);
  }
#line 352
  if (tmp___26 == 0) {
#line 353
    suffix[1] = (char )'\000';
#line 353
    suffix[0] = suffix[1];
#line 355
    if ((st.st_mode & 61440U) == 40960U) {
#line 355
      if (opt_L) {
#line 355
        goto _L___0;
      } else
#line 355
      if (! list_show_symlinks) {
        _L___0: /* CIL Label */ 
        {
#line 359
        pr_fs_clear_cache();
#line 360
        tmp___3 = pr_fsio_stat(name, & l_st);
        }
#line 360
        if (tmp___3 != -1) {
          {
#line 361
          memcpy((void */* __restrict  */)(& st), (void const   */* __restrict  */)(& l_st),
                 (size_t )sizeof(struct stat ));
#line 363
          len = pr_fsio_readlink(name, m, (size_t )(sizeof(m) - 1UL));
          }
#line 364
          if (len < 0) {
#line 365
            return (0);
          }
#line 367
          if ((unsigned long )len >= sizeof(m)) {
#line 368
            return (0);
          }
          {
#line 370
          m[len] = (char )'\000';
#line 372
          tmp___2 = ls_perms_full(p, cmd, (char const   *)(m), (int *)((void *)0));
          }
#line 372
          if (! tmp___2) {
#line 373
            return (0);
          }
        } else {
#line 376
          return (0);
        }
      } else {
#line 355
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 378
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 379
      len = pr_fsio_readlink(name, l, (size_t )(sizeof(l) - 1UL));
      }
#line 380
      if (len < 0) {
#line 381
        return (0);
      }
#line 383
      if ((unsigned long )len >= sizeof(l)) {
#line 384
        return (0);
      }
      {
#line 386
      l[len] = (char )'\000';
#line 388
      tmp___4 = ls_perms_full(p, cmd, (char const   *)(l), & hidden);
      }
#line 388
      if (! tmp___4) {
#line 389
        return (0);
      }
    } else {
      {
#line 391
      tmp___5 = ls_perms(p, cmd, name, & hidden);
      }
#line 391
      if (! tmp___5) {
#line 392
        return (0);
      }
    }
#line 395
    if ((int const   )*name == 46) {
#line 395
      if (! opt_a) {
#line 395
        if (! opt_A) {
#line 397
          return (0);
        } else {
          {
#line 395
          tmp___6 = is_dotdir(name);
          }
#line 395
          if (tmp___6) {
#line 397
            return (0);
          }
        }
      }
    }
#line 399
    if (hidden) {
#line 400
      return (0);
    }
#line 402
    mtime = st.st_mtim.tv_sec;
#line 404
    if (list_times_gmt) {
      {
#line 405
      t = pr_gmtime(p, (time_t const   *)(& mtime));
      }
    } else {
      {
#line 407
      t = pr_localtime(p, (time_t const   *)(& mtime));
      }
    }
#line 409
    if (opt_F) {
#line 410
      if ((st.st_mode & 61440U) == 40960U) {
#line 411
        suffix[0] = (char )'@';
      } else
#line 413
      if ((st.st_mode & 61440U) == 16384U) {
#line 414
        suffix[0] = (char )'/';
#line 415
        rval = 1;
      } else
#line 417
      if (st.st_mode & 73U) {
#line 418
        suffix[0] = (char )'*';
      }
    }
#line 421
    if (opt_l) {
      {
#line 422
      sstrncpy(m, " ---------", (size_t )sizeof(m));
      }
      {
#line 424
      if ((st.st_mode & 61440U) == 32768U) {
#line 424
        goto case_32768;
      }
#line 428
      if ((st.st_mode & 61440U) == 40960U) {
#line 428
        goto case_40960;
      }
#line 433
      if ((st.st_mode & 61440U) == 49152U) {
#line 433
        goto case_49152;
      }
#line 438
      if ((st.st_mode & 61440U) == 24576U) {
#line 438
        goto case_24576;
      }
#line 442
      if ((st.st_mode & 61440U) == 8192U) {
#line 442
        goto case_8192;
      }
#line 446
      if ((st.st_mode & 61440U) == 4096U) {
#line 446
        goto case_4096;
      }
#line 450
      if ((st.st_mode & 61440U) == 16384U) {
#line 450
        goto case_16384;
      }
#line 423
      goto switch_break;
      case_32768: /* CIL Label */ 
#line 425
      m[0] = (char )'-';
#line 426
      goto switch_break;
      case_40960: /* CIL Label */ 
#line 429
      m[0] = (char )'l';
#line 430
      goto switch_break;
      case_49152: /* CIL Label */ 
#line 434
      m[0] = (char )'s';
#line 435
      goto switch_break;
      case_24576: /* CIL Label */ 
#line 439
      m[0] = (char )'b';
#line 440
      goto switch_break;
      case_8192: /* CIL Label */ 
#line 443
      m[0] = (char )'c';
#line 444
      goto switch_break;
      case_4096: /* CIL Label */ 
#line 447
      m[0] = (char )'p';
#line 448
      goto switch_break;
      case_16384: /* CIL Label */ 
#line 451
      m[0] = (char )'d';
#line 452
      rval = 1;
#line 453
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 456
      if ((int )m[0] != 32) {
#line 457
        nameline[0] = (char )'\000';
#line 457
        tmp___7 = 1U;
        {
#line 457
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 457
          if (tmp___7 >= 8320U) {
#line 457
            goto while_break___2;
          }
#line 457
          nameline[tmp___7] = (char)0;
#line 457
          tmp___7 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 458
        timeline[0] = (char )'\000';
#line 458
        tmp___8 = 1U;
        {
#line 458
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 458
          if (tmp___8 >= 6U) {
#line 458
            goto while_break___3;
          }
#line 458
          timeline[tmp___8] = (char)0;
#line 458
          tmp___8 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 459
        mode = st.st_mode;
#line 461
        if (have_fake_mode) {
#line 462
          mode = fakemode;
#line 464
          if ((st.st_mode & 61440U) == 16384U) {
#line 465
            if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 465
              mode |= (unsigned int )((64 >> 3) >> 3);
            }
#line 466
            if (mode & (unsigned int )(256 >> 3)) {
#line 466
              mode |= (unsigned int )(64 >> 3);
            }
#line 467
            if (mode & 256U) {
#line 467
              mode |= 64U;
            }
          }
        }
#line 471
        if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 471
          if (mode & 512U) {
#line 471
            tmp___9 = 't';
          } else {
#line 471
            tmp___9 = 'x';
          }
#line 471
          m[9] = (char )tmp___9;
        } else {
#line 471
          if (mode & 512U) {
#line 471
            tmp___10 = 'T';
          } else {
#line 471
            tmp___10 = '-';
          }
#line 471
          m[9] = (char )tmp___10;
        }
#line 474
        if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 474
          m[8] = (char )'w';
        } else {
#line 474
          m[8] = (char )'-';
        }
#line 475
        if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 475
          m[7] = (char )'r';
        } else {
#line 475
          m[7] = (char )'-';
        }
#line 476
        if (mode & (unsigned int )(64 >> 3)) {
#line 476
          if (mode & 1024U) {
#line 476
            tmp___11 = 's';
          } else {
#line 476
            tmp___11 = 'x';
          }
#line 476
          m[6] = (char )tmp___11;
        } else {
#line 476
          if (mode & 1024U) {
#line 476
            tmp___12 = 'S';
          } else {
#line 476
            tmp___12 = '-';
          }
#line 476
          m[6] = (char )tmp___12;
        }
#line 479
        if (mode & (unsigned int )(128 >> 3)) {
#line 479
          m[5] = (char )'w';
        } else {
#line 479
          m[5] = (char )'-';
        }
#line 480
        if (mode & (unsigned int )(256 >> 3)) {
#line 480
          m[4] = (char )'r';
        } else {
#line 480
          m[4] = (char )'-';
        }
#line 481
        if (mode & 64U) {
#line 481
          if (mode & 2048U) {
#line 481
            tmp___13 = 's';
          } else {
#line 481
            tmp___13 = 'x';
          }
#line 481
          m[3] = (char )tmp___13;
        } else {
#line 481
          if (mode & 2048U) {
#line 481
            tmp___14 = 'S';
          } else {
#line 481
            tmp___14 = '-';
          }
#line 481
          m[3] = (char )tmp___14;
        }
#line 484
        if (mode & 128U) {
#line 484
          m[2] = (char )'w';
        } else {
#line 484
          m[2] = (char )'-';
        }
#line 485
        if (mode & 256U) {
#line 485
          m[1] = (char )'r';
        } else {
#line 485
          m[1] = (char )'-';
        }
#line 487
        if (ls_curtime - mtime > 15552000L) {
          {
#line 488
          snprintf((char */* __restrict  */)(timeline), (size_t )sizeof(timeline),
                   (char const   */* __restrict  */)"%5d", t->tm_year + 1900);
          }
        } else {
          {
#line 491
          snprintf((char */* __restrict  */)(timeline), (size_t )sizeof(timeline),
                   (char const   */* __restrict  */)"%02d:%02d", t->tm_hour, t->tm_min);
          }
        }
        {
#line 494
        ls_fmt_filesize(s, (size_t )sizeof(s), st.st_size);
        }
#line 496
        if (! opt_n) {
          {
#line 499
          tmp___15 = pr_fs_encode_path(cmd->tmp_pool, name);
          }
#line 499
          if (fakegroup) {
#line 499
            tmp___17 = (char const   *)fakegroup;
          } else {
            {
#line 499
            tmp___16 = pr_auth_gid2name(cmd->tmp_pool, st.st_gid);
#line 499
            tmp___17 = tmp___16;
            }
          }
#line 499
          if (fakeuser) {
#line 499
            tmp___19 = (char const   *)fakeuser;
          } else {
            {
#line 499
            tmp___18 = pr_auth_uid2name(cmd->tmp_pool, st.st_uid);
#line 499
            tmp___19 = tmp___18;
            }
          }
          {
#line 499
          snprintf((char */* __restrict  */)(nameline), (size_t )(sizeof(nameline) - 1UL),
                   (char const   */* __restrict  */)"%s %3d %-8s %-8s %s %s %2d %s %s",
                   m, (int )st.st_nlink, tmp___19, tmp___17, s, months[t->tm_mon],
                   t->tm_mday, timeline, tmp___15);
          }
        } else {
          {
#line 508
          tmp___20 = pr_fs_encode_path(cmd->tmp_pool, name);
#line 508
          snprintf((char */* __restrict  */)(nameline), (size_t )(sizeof(nameline) - 1UL),
                   (char const   */* __restrict  */)"%s %3d %-8u %-8u %s %s %2d %s %s",
                   m, (int )st.st_nlink, st.st_uid, st.st_gid, s, months[t->tm_mon],
                   t->tm_mday, timeline, tmp___20);
          }
        }
#line 515
        nameline[sizeof(nameline) - 1UL] = (char )'\000';
#line 517
        if ((st.st_mode & 61440U) == 40960U) {
          {
#line 518
          tmp___21 = strlen((char const   *)(nameline));
#line 518
          buf___2 = nameline + tmp___21;
#line 520
          suffix[0] = (char )'\000';
          }
#line 521
          if (opt_F) {
            {
#line 521
            tmp___22 = pr_fsio_stat(name, & st);
            }
#line 521
            if (tmp___22 == 0) {
#line 522
              if ((st.st_mode & 61440U) == 40960U) {
#line 523
                suffix[0] = (char )'@';
              } else
#line 525
              if ((st.st_mode & 61440U) == 16384U) {
#line 526
                suffix[0] = (char )'/';
              } else
#line 528
              if (st.st_mode & 73U) {
#line 529
                suffix[0] = (char )'*';
              }
            }
          }
#line 532
          if (! opt_L) {
#line 532
            if (list_show_symlinks) {
              {
#line 533
              tmp___24 = strlen((char const   *)(nameline));
              }
#line 533
              if (sizeof(nameline) - (unsigned long )tmp___24 > 4UL) {
                {
#line 534
                tmp___23 = strlen((char const   *)(nameline));
#line 534
                snprintf((char */* __restrict  */)buf___2, (size_t )((sizeof(nameline) - (unsigned long )tmp___23) - 4UL),
                         (char const   */* __restrict  */)" -> %s", l);
                }
              } else {
                {
#line 537
                pr_log_pri(5, "notice: symlink \'%s\' yields an excessive string, ignoring",
                           name);
                }
              }
            }
          }
#line 541
          nameline[sizeof(nameline) - 1UL] = (char )'\000';
        }
#line 544
        if (opt_STAT) {
          {
#line 545
          pr_response_add("211", "%s%s", nameline, suffix);
          }
        } else {
          {
#line 547
          addfile(cmd, (char const   *)(nameline), (char const   *)(suffix), mtime,
                  st.st_size);
          }
        }
      }
    } else
#line 551
    if ((st.st_mode & 61440U) == 32768U) {
      {
#line 554
      tmp___25 = pr_fs_encode_path(cmd->tmp_pool, name);
#line 554
      addfile(cmd, (char const   *)tmp___25, (char const   *)(suffix), mtime, st.st_size);
      }
    } else
#line 551
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 554
      tmp___25 = pr_fs_encode_path(cmd->tmp_pool, name);
#line 554
      addfile(cmd, (char const   *)tmp___25, (char const   *)(suffix), mtime, st.st_size);
      }
    } else
#line 551
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 554
      tmp___25 = pr_fs_encode_path(cmd->tmp_pool, name);
#line 554
      addfile(cmd, (char const   *)tmp___25, (char const   *)(suffix), mtime, st.st_size);
      }
    }
  }
#line 559
  return (rval);
}
}
#line 562 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int colwidth  =    0;
#line 563 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int filenames  =    0;
#line 579 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static struct filename *head  =    (struct filename *)((void *)0);
#line 580 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static struct filename *tail  =    (struct filename *)((void *)0);
#line 581 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static array_header *sort_arr  =    (array_header *)((void *)0);
#line 582 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static pool *fpool  =    (pool *)((void *)0);
#line 584 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void addfile(cmd_rec *cmd , char const   *name , char const   *suffix , time_t mtime ,
                    off_t___0 size ) 
{ 
  struct filename *p ;
  size_t l ;
  struct sort_filename *s ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 589
  if (! name) {
#line 590
    return;
  } else
#line 589
  if (! suffix) {
#line 590
    return;
  }
#line 592
  if (! fpool) {
    {
#line 593
    fpool = make_sub_pool(cmd->tmp_pool);
#line 594
    pr_pool_tag(fpool, "mod_ls: addfile() fpool");
    }
  }
#line 597
  if (opt_S) {
#line 597
    goto _L;
  } else
#line 597
  if (opt_t) {
    _L: /* CIL Label */ 
#line 600
    if (! sort_arr) {
      {
#line 601
      sort_arr = make_array(fpool, 50U, (size_t )sizeof(struct sort_filename ));
      }
    }
    {
#line 603
    tmp = push_array(sort_arr);
#line 603
    s = (struct sort_filename *)tmp;
#line 604
    s->mtime = mtime;
#line 605
    s->size = size;
#line 606
    s->name = pstrdup(fpool, name);
#line 607
    s->suffix = pstrdup(fpool, suffix);
    }
#line 609
    return;
  }
  {
#line 612
  tmp___0 = strlen(name);
#line 612
  tmp___1 = strlen(suffix);
#line 612
  l = tmp___0 + tmp___1;
  }
#line 613
  if (l > (size_t )colwidth) {
#line 614
    colwidth = (int )l;
  }
  {
#line 616
  tmp___2 = pcalloc(fpool, (int )sizeof(struct filename ));
#line 616
  p = (struct filename *)tmp___2;
#line 617
  tmp___3 = pcalloc(fpool, (int )(l + 2U));
#line 617
  p->line = (char *)tmp___3;
#line 618
  snprintf((char */* __restrict  */)p->line, l + 1U, (char const   */* __restrict  */)"%s%s",
           name, suffix);
  }
#line 620
  if (tail) {
#line 621
    tail->down = p;
  } else {
#line 624
    head = p;
  }
#line 626
  tail = p;
#line 627
  filenames ++;
#line 628
  return;
}
}
#line 630 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int file_mtime_cmp(struct sort_filename  const  *f1 , struct sort_filename  const  *f2 ) 
{ 


  {
#line 633
  if (f1->mtime > f2->mtime) {
#line 634
    return (-1);
  } else
#line 636
  if (f1->mtime < f2->mtime) {
#line 637
    return (1);
  }
#line 639
  return (0);
}
}
#line 642 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int file_mtime_reverse_cmp(struct sort_filename  const  *f1 , struct sort_filename  const  *f2 ) 
{ 
  int tmp ;

  {
  {
#line 644
  tmp = file_mtime_cmp(f1, f2);
  }
#line 644
  return (- tmp);
}
}
#line 647 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int file_size_cmp(struct sort_filename  const  *f1 , struct sort_filename  const  *f2 ) 
{ 


  {
#line 650
  if (f1->size > f2->size) {
#line 651
    return (-1);
  } else
#line 653
  if (f1->size < f2->size) {
#line 654
    return (1);
  }
#line 656
  return (0);
}
}
#line 659 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int file_size_reverse_cmp(struct sort_filename  const  *f1 , struct sort_filename  const  *f2 ) 
{ 
  int tmp ;

  {
  {
#line 661
  tmp = file_size_cmp(f1, f2);
  }
#line 661
  return (- tmp);
}
}
#line 664 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void sortfiles(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  int setting ;
  struct sort_filename *elts ;
  int (*tmp)(struct sort_filename  const  *f1 , struct sort_filename  const  *f2 ) ;
  register unsigned int i___1 ;
  int setting___0 ;
  struct sort_filename *elts___0 ;
  int (*tmp___0)(struct sort_filename  const  *f1 , struct sort_filename  const  *f2 ) ;

  {
#line 666
  if (sort_arr) {
#line 669
    if (opt_t) {
#line 670
      i___0 = 0U;
#line 671
      setting = opt_S;
#line 672
      elts = (struct sort_filename *)sort_arr->elts;
#line 674
      if (opt_r) {
#line 674
        tmp = & file_mtime_reverse_cmp;
      } else {
#line 674
        tmp = & file_mtime_cmp;
      }
      {
#line 674
      qsort(sort_arr->elts, (size_t )sort_arr->nelts, (size_t )sizeof(struct sort_filename ),
            (int (*)(void const   * , void const   * ))tmp);
#line 678
      opt_t = 0;
#line 678
      opt_S = opt_t;
#line 680
      i___0 = 0U;
      }
      {
#line 680
      while (1) {
        while_continue: /* CIL Label */ ;
#line 680
        if (! (i___0 < (unsigned int )sort_arr->nelts)) {
#line 680
          goto while_break;
        }
        {
#line 681
        addfile(cmd, (char const   *)(elts + i___0)->name, (char const   *)(elts + i___0)->suffix,
                (elts + i___0)->mtime, (elts + i___0)->size);
#line 680
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 683
      opt_S = setting;
#line 684
      opt_t = 1;
    } else
#line 687
    if (opt_S) {
#line 688
      i___1 = 0U;
#line 689
      setting___0 = opt_t;
#line 690
      elts___0 = (struct sort_filename *)sort_arr->elts;
#line 692
      if (opt_r) {
#line 692
        tmp___0 = & file_size_reverse_cmp;
      } else {
#line 692
        tmp___0 = & file_size_cmp;
      }
      {
#line 692
      qsort(sort_arr->elts, (size_t )sort_arr->nelts, (size_t )sizeof(struct sort_filename ),
            (int (*)(void const   * , void const   * ))tmp___0);
#line 696
      opt_t = 0;
#line 696
      opt_S = opt_t;
#line 698
      i___1 = 0U;
      }
      {
#line 698
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 698
        if (! (i___1 < (unsigned int )sort_arr->nelts)) {
#line 698
          goto while_break___0;
        }
        {
#line 699
        addfile(cmd, (char const   *)(elts___0 + i___1)->name, (char const   *)(elts___0 + i___1)->suffix,
                (elts___0 + i___1)->mtime, (elts___0 + i___1)->size);
#line 698
        i___1 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 701
      opt_S = 1;
#line 702
      opt_t = setting___0;
    }
  }
#line 706
  sort_arr = (array_header *)((void *)0);
#line 707
  return;
}
}
#line 709 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int outputfiles(cmd_rec *cmd ) 
{ 
  int n ;
  struct filename *p ;
  struct filename *q ;
  char pad[6] ;
  unsigned int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 711
  p = (struct filename *)((void *)0);
#line 711
  q = (struct filename *)((void *)0);
#line 713
  if (opt_S) {
    {
#line 714
    sortfiles(cmd);
    }
  } else
#line 713
  if (opt_t) {
    {
#line 714
    sortfiles(cmd);
    }
  }
#line 716
  if (! head) {
#line 717
    return (0);
  }
#line 719
  tail->down = (struct filename *)((void *)0);
#line 720
  tail = (struct filename *)((void *)0);
#line 721
  colwidth = (colwidth | 7) + 1;
#line 722
  if (opt_l) {
#line 723
    colwidth = 75;
  } else
#line 722
  if (! opt_C) {
#line 723
    colwidth = 75;
  }
#line 726
  if (colwidth > 75) {
#line 727
    colwidth = 75;
  }
#line 729
  p = head;
#line 730
  p->top = 1;
#line 731
  n = ((filenames + 75 / colwidth) - 1) / (75 / colwidth);
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (n) {
#line 732
      if (! p) {
#line 732
        goto while_break;
      }
    } else {
#line 732
      goto while_break;
    }
#line 733
    p = p->down;
#line 734
    if (p) {
#line 735
      p->top = 0;
    }
#line 736
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  q = head;
  {
#line 740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 740
    if (! p) {
#line 740
      goto while_break___0;
    }
#line 741
    p->top = q->top;
#line 742
    q->right = p;
#line 743
    q = q->down;
#line 744
    p = p->down;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 747
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 747
    if (! q) {
#line 747
      goto while_break___1;
    }
#line 748
    q->right = (struct filename *)((void *)0);
#line 749
    q = q->down;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 752
  p = head;
  {
#line 753
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 753
    if (p) {
#line 753
      if (p->down) {
#line 753
        if (! (! (p->down)->top)) {
#line 753
          goto while_break___2;
        }
      } else {
#line 753
        goto while_break___2;
      }
    } else {
#line 753
      goto while_break___2;
    }
#line 754
    p = p->down;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 755
  if (p) {
#line 755
    if (p->down) {
#line 756
      p->down = (struct filename *)((void *)0);
    }
  }
#line 758
  p = head;
  {
#line 759
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 759
    if (! p) {
#line 759
      goto while_break___3;
    }
#line 760
    q = p;
#line 761
    p = p->down;
    {
#line 762
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 762
      if (! q) {
#line 762
        goto while_break___4;
      }
#line 763
      pad[0] = (char )'\000';
#line 763
      tmp = 1U;
      {
#line 763
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 763
        if (tmp >= 6U) {
#line 763
          goto while_break___5;
        }
#line 763
        pad[tmp] = (char)0;
#line 763
        tmp ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 765
      if (q->right) {
        {
#line 766
        sstrncpy(pad, "\t\t\t\t\t", (size_t )sizeof(pad));
#line 767
        tmp___0 = strlen((char const   *)q->line);
#line 767
        pad[((size_t )(colwidth + 7) - tmp___0) / 8U] = (char )'\000';
        }
      } else {
        {
#line 770
        sstrncpy(pad, "\n", (size_t )sizeof(pad));
        }
      }
      {
#line 773
      tmp___1 = sendline(0, (char *)"%s%s", q->line, pad);
      }
#line 773
      if (tmp___1 < 0) {
#line 774
        return (-1);
      }
#line 776
      q = q->right;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 780
  destroy_pool(fpool);
#line 781
  fpool = (pool *)((void *)0);
#line 782
  sort_arr = (array_header *)((void *)0);
#line 783
  tail = (struct filename *)((void *)0);
#line 783
  head = tail;
#line 784
  colwidth = 0;
#line 785
  filenames = 0;
#line 787
  tmp___2 = sendline(1, (char *)" ");
  }
#line 787
  if (tmp___2 < 0) {
#line 788
    return (-1);
  }
#line 790
  return (0);
}
}
#line 793 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void discard_output(void) 
{ 


  {
#line 794
  if (fpool) {
    {
#line 795
    destroy_pool(fpool);
    }
  }
#line 796
  fpool = (pool *)((void *)0);
#line 798
  tail = (struct filename *)((void *)0);
#line 798
  head = tail;
#line 799
  colwidth = 0;
#line 800
  filenames = 0;
#line 801
  return;
}
}
#line 803 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int dircmp(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 807
  tmp = strcmp(*((char const   **)a), *((char const   **)b));
  }
#line 807
  return (tmp);
}
}
#line 811 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static char **sreaddir(char const   *dirname , int const   sort ) 
{ 
  DIR *d ;
  struct dirent *de ;
  struct stat st ;
  int i___0 ;
  char **p ;
  int dsize ;
  int ssize ;
  int dir_fd ;
  int tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char **newp ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 820
  tmp = pr_fsio_stat(dirname, & st);
  }
#line 820
  if (tmp < 0) {
#line 821
    return ((char **)((void *)0));
  }
#line 823
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 824
    tmp___0 = __errno_location();
#line 824
    *tmp___0 = 20;
    }
#line 825
    return ((char **)((void *)0));
  }
  {
#line 828
  tmp___1 = pr_fsio_opendir(dirname);
#line 828
  d = (DIR *)tmp___1;
  }
#line 829
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 830
    return ((char **)((void *)0));
  }
  {
#line 839
  dsize = (int )(st.st_size / 4LL + 10LL);
#line 846
  dir_fd = dirfd(d);
#line 857
  ssize = get_name_max((char *)dirname, dir_fd);
  }
#line 858
  if (ssize < 1) {
    {
#line 859
    pr_log_debug(1, "get_name_max(%s, %d) = %d, using %d", dirname, dir_fd, ssize,
                 255);
#line 861
    ssize = 255;
    }
  }
  {
#line 864
  ssize *= dsize / 4 + 1;
#line 872
  tmp___2 = malloc((size_t )((unsigned long )dsize * sizeof(char *)));
#line 872
  p = (char **)tmp___2;
  }
#line 872
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 873
    pr_log_pri(3, "fatal: memory exhausted");
#line 874
    exit(1);
    }
  }
#line 877
  i___0 = 0;
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 879
    de = pr_fsio_readdir((void *)d);
    }
#line 879
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 879
      goto while_break;
    }
    {
#line 880
    pr_signals_handle();
    }
#line 882
    if (i___0 >= dsize - 1) {
      {
#line 889
      pr_log_debug(0, "Reallocating sreaddir buffer from %d entries to %d entries",
                   dsize, dsize * 2);
#line 893
      tmp___3 = realloc((void *)p, (size_t )((unsigned long )(2 * dsize) * sizeof(char *)));
#line 893
      newp = (char **)tmp___3;
      }
#line 893
      if ((unsigned long )newp == (unsigned long )((void *)0)) {
        {
#line 894
        pr_log_pri(3, "fatal: memory exhausted");
#line 895
        exit(1);
        }
      }
#line 897
      p = newp;
#line 898
      dsize *= 2;
    }
    {
#line 902
    tmp___5 = strlen((char const   *)(de->d_name));
#line 902
    tmp___6 = calloc(tmp___5 + 1U, (size_t )sizeof(char ));
#line 902
    tmp___4 = (char *)tmp___6;
#line 902
    *(p + i___0) = tmp___4;
    }
#line 902
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
      {
#line 904
      pr_log_pri(3, "fatal: memory exhausted");
#line 905
      exit(1);
      }
    }
    {
#line 907
    tmp___7 = strlen((char const   *)(de->d_name));
#line 907
    tmp___8 = i___0;
#line 907
    i___0 ++;
#line 907
    sstrncpy(*(p + tmp___8), (char const   *)(de->d_name), tmp___7 + 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 910
  pr_fsio_closedir((void *)d);
#line 914
  *(p + i___0) = (char *)((void *)0);
  }
#line 916
  if (sort) {
    {
#line 917
    qsort((void *)p, (size_t )i___0, (size_t )sizeof(char *), & dircmp);
    }
  }
#line 919
  return (p);
}
}
#line 923 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int listdir(cmd_rec *cmd , pool *workp , char const   *name ) 
{ 
  char **dir ;
  int dest_workp ;
  config_rec *c ;
  unsigned char ignore_hidden ;
  register unsigned int i___0 ;
  unsigned char *ignore ;
  void *tmp ;
  char **s ;
  char **r ;
  int d ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  char cwd_buf[4097] ;
  unsigned int tmp___3 ;
  unsigned char symhold ;
  int tmp___4 ;
  int tmp___5 ;
  char *subdir ;
  int res ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
#line 925
  dest_workp = 0;
#line 926
  c = (config_rec *)((void *)0);
#line 927
  ignore_hidden = (unsigned char)0;
#line 928
  i___0 = 0U;
#line 930
  if (list_ndepth.curr) {
#line 930
    if (list_ndepth.max) {
#line 930
      if (list_ndepth.curr >= list_ndepth.max) {
#line 933
        if (! list_ndepth.logged) {
          {
#line 935
          pr_log_debug(8, "ListOptions maxdepth (%u) reached", list_ndepth.max - 1U);
#line 937
          list_ndepth.logged = (unsigned char)1;
          }
        }
#line 940
        return (1);
      }
    }
  }
#line 943
  if (list_ndirs.curr) {
#line 943
    if (list_ndirs.max) {
#line 943
      if (list_ndirs.curr >= list_ndirs.max) {
#line 946
        if (! list_ndirs.logged) {
          {
#line 947
          pr_log_debug(8, "ListOptions maxdirs (%u) reached", list_ndirs.max);
#line 948
          list_ndirs.logged = (unsigned char)1;
          }
        }
#line 951
        return (1);
      }
    }
  }
#line 953
  (list_ndirs.curr) ++;
#line 955
  if (session.sf_flags & (int volatile   )2) {
#line 956
    return (-1);
  }
#line 958
  if (! workp) {
    {
#line 959
    workp = make_sub_pool(cmd->tmp_pool);
#line 960
    pr_pool_tag(workp, "mod_ls: listdir(): workp (from cmd->tmp_pool)");
#line 961
    dest_workp ++;
    }
  } else {
    {
#line 964
    workp = make_sub_pool(workp);
#line 965
    pr_pool_tag(workp, "mod_ls: listdir(): workp (from workp)");
#line 966
    dest_workp ++;
    }
  }
  {
#line 969
  dir = sreaddir(".", (int const   )1);
#line 974
  c = _find_ls_limit(*(cmd->argv + 0));
  }
#line 975
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 976
    tmp = get_param_ptr(c->subset, "IgnoreHidden", 0);
#line 976
    ignore = (unsigned char *)tmp;
    }
#line 978
    if (ignore) {
#line 978
      if ((int )*ignore == 1) {
#line 979
        ignore_hidden = (unsigned char)1;
      }
    }
  }
#line 982
  if (dir) {
#line 986
    d = 0;
#line 988
    s = dir;
    {
#line 989
    while (1) {
      while_continue: /* CIL Label */ ;
#line 989
      if (! *s) {
#line 989
        goto while_break;
      }
#line 990
      if ((int )*(*s) == 46) {
#line 991
        if (! opt_a) {
#line 991
          if (! opt_A) {
#line 992
            d = 0;
          } else {
            {
#line 991
            tmp___0 = is_dotdir((char const   *)*s);
            }
#line 991
            if (tmp___0) {
#line 992
              d = 0;
            } else {
              {
#line 999
              d = listfile(cmd, workp, (char const   *)*s);
              }
            }
          }
        } else {
          {
#line 999
          d = listfile(cmd, workp, (char const   *)*s);
          }
        }
      } else {
        {
#line 1003
        d = listfile(cmd, workp, (char const   *)*s);
        }
      }
#line 1006
      if (opt_R) {
#line 1006
        if (d == 0) {
#line 1013
          *(*s) = (char )'.';
#line 1014
          *(*s + 1) = (char )'\000';
        } else {
#line 1006
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1016
      if (d == 2) {
#line 1017
        goto while_break;
      }
#line 1019
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1022
    tmp___2 = outputfiles(cmd);
    }
#line 1022
    if (tmp___2 < 0) {
#line 1023
      if (dest_workp) {
        {
#line 1024
        destroy_pool(workp);
        }
      }
#line 1029
      i___0 = 0U;
      {
#line 1030
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1030
        if (! ((unsigned long )*(dir + i___0) != (unsigned long )((void *)0))) {
#line 1030
          goto while_break___0;
        }
        {
#line 1031
        tmp___1 = i___0;
#line 1031
        i___0 ++;
#line 1031
        free((void *)*(dir + tmp___1));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1032
      free((void *)dir);
      }
#line 1034
      return (-1);
    }
#line 1037
    r = dir;
    {
#line 1038
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1038
      if (opt_R) {
#line 1038
        if (! ((unsigned long )r != (unsigned long )s)) {
#line 1038
          goto while_break___1;
        }
      } else {
#line 1038
        goto while_break___1;
      }
#line 1039
      cwd_buf[0] = (char )'\000';
#line 1039
      tmp___3 = 1U;
      {
#line 1039
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1039
        if (tmp___3 >= 4097U) {
#line 1039
          goto while_break___2;
        }
#line 1039
        cwd_buf[tmp___3] = (char)0;
#line 1039
        tmp___3 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1042
      if (*r) {
        {
#line 1042
        tmp___4 = strcmp((char const   *)*r, ".");
        }
#line 1042
        if (tmp___4 == 0) {
#line 1043
          r ++;
#line 1044
          goto while_continue___1;
        } else {
          {
#line 1042
          tmp___5 = strcmp((char const   *)*r, "..");
          }
#line 1042
          if (tmp___5 == 0) {
#line 1043
            r ++;
#line 1044
            goto while_continue___1;
          }
        }
      }
      {
#line 1050
      pr_signals_handle();
      }
#line 1052
      if (list_ndirs.curr) {
#line 1052
        if (list_ndirs.max) {
#line 1052
          if (list_ndirs.curr >= list_ndirs.max) {
#line 1055
            if (! list_ndirs.logged) {
              {
#line 1056
              pr_log_debug(8, "ListOptions maxdirs (%u) reached", list_ndirs.max);
#line 1058
              list_ndirs.logged = (unsigned char)1;
              }
            }
#line 1061
            goto while_break___1;
          }
        }
      }
#line 1064
      if (list_nfiles.curr) {
#line 1064
        if (list_nfiles.max) {
#line 1064
          if (list_nfiles.curr >= list_nfiles.max) {
#line 1067
            if (! list_nfiles.logged) {
              {
#line 1068
              pr_log_debug(8, "ListOptions maxfiles (%u) reached", list_nfiles.max);
#line 1070
              list_nfiles.logged = (unsigned char)1;
              }
            }
#line 1073
            goto while_break___1;
          }
        }
      }
      {
#line 1076
      push_cwd(cwd_buf, & symhold);
      }
#line 1078
      if (*r) {
        {
#line 1078
        tmp___12 = ls_perms_full(workp, cmd, (char const   *)*r, (int *)((void *)0));
        }
#line 1078
        if (tmp___12) {
#line 1078
          if (! opt_L) {
#line 1078
            if (list_show_symlinks) {
#line 1078
              tmp___13 = 1;
            } else {
#line 1078
              tmp___13 = 0;
            }
          } else {
#line 1078
            tmp___13 = 0;
          }
          {
#line 1078
          tmp___14 = pr_fsio_chdir_canon((char const   *)*r, tmp___13);
          }
#line 1078
          if (! tmp___14) {
            {
#line 1081
            res = 0;
#line 1083
            tmp___6 = strcmp(name, ".");
            }
#line 1083
            if (tmp___6 == 0) {
#line 1084
              subdir = *r;
            } else {
              {
#line 1086
              subdir = pdircat(workp, name, *r, (void *)0);
              }
            }
#line 1088
            if (opt_STAT) {
              {
#line 1089
              pr_response_add("211", "%s", "");
#line 1090
              tmp___7 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)subdir);
#line 1090
              pr_response_add("211", "%s:", tmp___7);
              }
            } else {
              {
#line 1093
              tmp___8 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)subdir);
#line 1093
              tmp___9 = sendline(0, (char *)"\n%s:\n", tmp___8);
              }
#line 1093
              if (tmp___9 < 0) {
#line 1093
                goto _L___0;
              } else {
                {
#line 1093
                tmp___10 = sendline(1, (char *)" ");
                }
#line 1093
                if (tmp___10 < 0) {
                  _L___0: /* CIL Label */ 
                  {
#line 1096
                  pop_cwd(cwd_buf, & symhold);
                  }
#line 1098
                  if (dest_workp) {
                    {
#line 1099
                    destroy_pool(workp);
                    }
                  }
#line 1101
                  return (-1);
                }
              }
            }
            {
#line 1104
            (list_ndepth.curr) ++;
#line 1105
            res = listdir(cmd, workp, (char const   *)subdir);
#line 1106
            (list_ndepth.curr) --;
#line 1107
            pop_cwd(cwd_buf, & symhold);
            }
#line 1109
            if (res > 0) {
#line 1110
              goto while_break___1;
            } else
#line 1112
            if (res < 0) {
#line 1113
              if (dest_workp) {
                {
#line 1114
                destroy_pool(workp);
                }
              }
#line 1119
              i___0 = 0U;
              {
#line 1120
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1120
                if (! ((unsigned long )*(dir + i___0) != (unsigned long )((void *)0))) {
#line 1120
                  goto while_break___3;
                }
                {
#line 1121
                tmp___11 = i___0;
#line 1121
                i___0 ++;
#line 1121
                free((void *)*(dir + tmp___11));
                }
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 1122
              free((void *)dir);
              }
#line 1124
              return (-1);
            }
          }
        }
      }
#line 1127
      r ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1131
  if (dest_workp) {
    {
#line 1132
    destroy_pool(workp);
    }
  }
#line 1137
  if (dir) {
#line 1138
    i___0 = 0U;
    {
#line 1139
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1139
      if (! ((unsigned long )*(dir + i___0) != (unsigned long )((void *)0))) {
#line 1139
        goto while_break___4;
      }
      {
#line 1140
      tmp___15 = i___0;
#line 1140
      i___0 ++;
#line 1140
      free((void *)*(dir + tmp___15));
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1141
    free((void *)dir);
    }
  }
#line 1144
  return (0);
}
}
#line 1147 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void ls_terminate(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1148
  if (! opt_STAT) {
    {
#line 1149
    discard_output();
    }
#line 1151
    if (! (session.sf_flags & (int volatile   )2)) {
#line 1153
      if (ls_errno) {
        {
#line 1154
        pr_data_abort(ls_errno, 0);
        }
      } else {
#line 1156
        if (session.d) {
#line 1156
          if ((session.d)->outstrm) {
#line 1156
            tmp___0 = ((session.d)->outstrm)->strm_errno;
          } else {
            {
#line 1156
            tmp = __errno_location();
#line 1156
            tmp___0 = *tmp;
            }
          }
        } else {
          {
#line 1156
          tmp = __errno_location();
#line 1156
          tmp___0 = *tmp;
          }
        }
        {
#line 1156
        pr_data_abort(tmp___0, 0);
        }
      }
    }
#line 1159
    ls_errno = 0;
  } else
#line 1161
  if (ls_errno) {
    {
#line 1162
    tmp___1 = strerror(ls_errno);
#line 1162
    pr_response_add("211", "ERROR: %s", tmp___1);
#line 1163
    ls_errno = 0;
    }
  }
#line 1165
  return;
}
}
#line 1167 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static void parse_list_opts(char **opt , int *glob_flags , int handle_plus_opts ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1168
    tmp = __ctype_b_loc();
    }
#line 1168
    if (! ((int const   )*(*tmp + (int )*(*opt)) & 8192)) {
#line 1168
      goto while_break;
    }
    {
#line 1169
    pr_signals_handle();
#line 1170
    (*opt) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1174
    if (*opt) {
#line 1174
      if (! ((int )*(*opt) == 45)) {
#line 1174
        goto while_break___0;
      }
    } else {
#line 1174
      goto while_break___0;
    }
    {
#line 1175
    pr_signals_handle();
    }
    {
#line 1177
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1177
      tmp___5 = *opt;
#line 1177
      (*opt) ++;
#line 1177
      if (tmp___5) {
        {
#line 1177
        tmp___6 = __ctype_b_loc();
        }
#line 1177
        if (! ((int const   )*(*tmp___6 + (int )*(*opt)) & 8)) {
#line 1177
          goto while_break___1;
        }
      } else {
#line 1177
        goto while_break___1;
      }
      {
#line 1179
      if ((int )*(*opt) == 49) {
#line 1179
        goto case_49;
      }
#line 1183
      if ((int )*(*opt) == 65) {
#line 1183
        goto case_65;
      }
#line 1187
      if ((int )*(*opt) == 97) {
#line 1187
        goto case_97;
      }
#line 1191
      if ((int )*(*opt) == 67) {
#line 1191
        goto case_67;
      }
#line 1198
      if ((int )*(*opt) == 100) {
#line 1198
        goto case_100;
      }
#line 1202
      if ((int )*(*opt) == 70) {
#line 1202
        goto case_70;
      }
#line 1208
      if ((int )*(*opt) == 104) {
#line 1208
        goto case_104;
      }
#line 1214
      if ((int )*(*opt) == 76) {
#line 1214
        goto case_76;
      }
#line 1218
      if ((int )*(*opt) == 108) {
#line 1218
        goto case_108;
      }
#line 1225
      if ((int )*(*opt) == 110) {
#line 1225
        goto case_110;
      }
#line 1231
      if ((int )*(*opt) == 82) {
#line 1231
        goto case_82;
      }
#line 1235
      if ((int )*(*opt) == 114) {
#line 1235
        goto case_114;
      }
#line 1239
      if ((int )*(*opt) == 83) {
#line 1239
        goto case_83;
      }
#line 1243
      if ((int )*(*opt) == 116) {
#line 1243
        goto case_116;
      }
#line 1178
      goto switch_break;
      case_49: /* CIL Label */ 
#line 1180
      opt_C = 0;
#line 1180
      opt_l = opt_C;
#line 1181
      goto switch_break;
      case_65: /* CIL Label */ 
#line 1184
      opt_A = 1;
#line 1185
      goto switch_break;
      case_97: /* CIL Label */ 
#line 1188
      opt_a = 1;
#line 1189
      goto switch_break;
      case_67: /* CIL Label */ 
      {
#line 1192
      tmp___0 = strcmp((char const   *)session.curr_cmd, "NLST");
      }
#line 1192
      if (tmp___0 != 0) {
#line 1193
        opt_l = 0;
#line 1194
        opt_C = 1;
      }
#line 1196
      goto switch_break;
      case_100: /* CIL Label */ 
#line 1199
      opt_d = 1;
#line 1200
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 1203
      tmp___1 = strcmp((char const   *)session.curr_cmd, "NLST");
      }
#line 1203
      if (tmp___1 != 0) {
#line 1204
        opt_F = 1;
      }
#line 1206
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 1209
      tmp___2 = strcmp((char const   *)session.curr_cmd, "NLST");
      }
#line 1209
      if (tmp___2 != 0) {
#line 1210
        opt_h = 1;
      }
#line 1212
      goto switch_break;
      case_76: /* CIL Label */ 
#line 1215
      opt_L = 1;
#line 1216
      goto switch_break;
      case_108: /* CIL Label */ 
      {
#line 1219
      tmp___3 = strcmp((char const   *)session.curr_cmd, "NLST");
      }
#line 1219
      if (tmp___3 != 0) {
#line 1220
        opt_l = 1;
#line 1221
        opt_C = 0;
      }
#line 1223
      goto switch_break;
      case_110: /* CIL Label */ 
      {
#line 1226
      tmp___4 = strcmp((char const   *)session.curr_cmd, "NLST");
      }
#line 1226
      if (tmp___4 != 0) {
#line 1227
        opt_n = 1;
      }
#line 1229
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1232
      opt_R = 1;
#line 1233
      goto switch_break;
      case_114: /* CIL Label */ 
#line 1236
      opt_r = 1;
#line 1237
      goto switch_break;
      case_83: /* CIL Label */ 
#line 1240
      opt_S = 1;
#line 1241
      goto switch_break;
      case_116: /* CIL Label */ 
#line 1244
      opt_t = 1;
#line 1245
      if (glob_flags) {
#line 1246
        *glob_flags |= 1 << 2;
      }
#line 1247
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1251
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1251
      tmp___7 = __ctype_b_loc();
      }
#line 1251
      if (! ((int const   )*(*tmp___7 + (int )*(*opt)) & 8192)) {
#line 1251
        goto while_break___2;
      }
      {
#line 1252
      pr_signals_handle();
#line 1253
      (*opt) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1257
  if (! handle_plus_opts) {
#line 1258
    return;
  }
  {
#line 1261
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1261
    if (*opt) {
#line 1261
      if (! ((int )*(*opt) == 43)) {
#line 1261
        goto while_break___3;
      }
    } else {
#line 1261
      goto while_break___3;
    }
    {
#line 1262
    pr_signals_handle();
    }
    {
#line 1264
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1264
      tmp___8 = *opt;
#line 1264
      (*opt) ++;
#line 1264
      if (tmp___8) {
        {
#line 1264
        tmp___9 = __ctype_b_loc();
        }
#line 1264
        if (! ((int const   )*(*tmp___9 + (int )*(*opt)) & 8)) {
#line 1264
          goto while_break___4;
        }
      } else {
#line 1264
        goto while_break___4;
      }
      {
#line 1266
      if ((int )*(*opt) == 49) {
#line 1266
        goto case_49___0;
      }
#line 1270
      if ((int )*(*opt) == 65) {
#line 1270
        goto case_65___0;
      }
#line 1274
      if ((int )*(*opt) == 97) {
#line 1274
        goto case_97___0;
      }
#line 1278
      if ((int )*(*opt) == 67) {
#line 1278
        goto case_67___0;
      }
#line 1282
      if ((int )*(*opt) == 100) {
#line 1282
        goto case_100___0;
      }
#line 1286
      if ((int )*(*opt) == 70) {
#line 1286
        goto case_70___0;
      }
#line 1290
      if ((int )*(*opt) == 104) {
#line 1290
        goto case_104___0;
      }
#line 1294
      if ((int )*(*opt) == 76) {
#line 1294
        goto case_76___0;
      }
#line 1298
      if ((int )*(*opt) == 108) {
#line 1298
        goto case_108___0;
      }
#line 1302
      if ((int )*(*opt) == 110) {
#line 1302
        goto case_110___0;
      }
#line 1306
      if ((int )*(*opt) == 82) {
#line 1306
        goto case_82___0;
      }
#line 1310
      if ((int )*(*opt) == 114) {
#line 1310
        goto case_114___0;
      }
#line 1314
      if ((int )*(*opt) == 83) {
#line 1314
        goto case_83___0;
      }
#line 1318
      if ((int )*(*opt) == 116) {
#line 1318
        goto case_116___0;
      }
#line 1265
      goto switch_break___0;
      case_49___0: /* CIL Label */ 
#line 1267
      opt_C = 0;
#line 1267
      opt_l = opt_C;
#line 1268
      goto switch_break___0;
      case_65___0: /* CIL Label */ 
#line 1271
      opt_A = 0;
#line 1272
      goto switch_break___0;
      case_97___0: /* CIL Label */ 
#line 1275
      opt_a = 0;
#line 1276
      goto switch_break___0;
      case_67___0: /* CIL Label */ 
#line 1279
      opt_C = 0;
#line 1279
      opt_l = opt_C;
#line 1280
      goto switch_break___0;
      case_100___0: /* CIL Label */ 
#line 1283
      opt_d = 0;
#line 1284
      goto switch_break___0;
      case_70___0: /* CIL Label */ 
#line 1287
      opt_F = 0;
#line 1288
      goto switch_break___0;
      case_104___0: /* CIL Label */ 
#line 1291
      opt_h = 0;
#line 1292
      goto switch_break___0;
      case_76___0: /* CIL Label */ 
#line 1295
      opt_L = 0;
#line 1296
      goto switch_break___0;
      case_108___0: /* CIL Label */ 
#line 1299
      opt_C = 0;
#line 1299
      opt_l = opt_C;
#line 1300
      goto switch_break___0;
      case_110___0: /* CIL Label */ 
#line 1303
      opt_n = 0;
#line 1304
      goto switch_break___0;
      case_82___0: /* CIL Label */ 
#line 1307
      opt_R = 0;
#line 1308
      goto switch_break___0;
      case_114___0: /* CIL Label */ 
#line 1311
      opt_r = 0;
#line 1312
      goto switch_break___0;
      case_83___0: /* CIL Label */ 
#line 1315
      opt_S = 0;
#line 1316
      goto switch_break___0;
      case_116___0: /* CIL Label */ 
#line 1319
      opt_t = 0;
#line 1320
      if (glob_flags) {
#line 1321
        *glob_flags &= 1 << 2;
      }
#line 1322
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1326
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1326
      tmp___10 = __ctype_b_loc();
      }
#line 1326
      if (! ((int const   )*(*tmp___10 + (int )*(*opt)) & 8192)) {
#line 1326
        goto while_break___5;
      }
      {
#line 1327
      pr_signals_handle();
#line 1328
      (*opt) ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1331
  return;
}
}
#line 1336 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int dolist(cmd_rec *cmd , char const   *opt , int clearflags ) 
{ 
  int skiparg ;
  int glob_flags ;
  char *arg ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int justone ;
  glob_t g ;
  int globbed ;
  int a ;
  char pbuffer[4097] ;
  unsigned int tmp___3 ;
  char *target ;
  struct passwd *pw ;
  int i___0 ;
  char const   *p ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  struct stat st ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int list_dir_as_file ;
  char **path ;
  char *tmp___17 ;
  struct stat st___0 ;
  mode_t target_mode ;
  mode_t lmode ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char cwd_buf[4097] ;
  unsigned int tmp___21 ;
  unsigned char symhold ;
  char *tmp___22 ;
  char *tmp___23 ;
  int res ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
  {
#line 1337
  skiparg = 0;
#line 1338
  glob_flags = 1 << 7;
#line 1339
  arg = (char *)opt;
#line 1341
  ls_curtime = time((time_t *)((void *)0));
  }
#line 1343
  if (clearflags) {
#line 1344
    opt_L = 0;
#line 1344
    opt_STAT = opt_L;
#line 1344
    opt_t = opt_STAT;
#line 1344
    opt_S = opt_t;
#line 1344
    opt_R = opt_S;
#line 1344
    opt_r = opt_R;
#line 1344
    opt_n = opt_r;
#line 1344
    opt_h = opt_n;
#line 1344
    opt_F = opt_h;
#line 1344
    opt_d = opt_F;
#line 1344
    opt_C = opt_d;
#line 1344
    opt_a = opt_C;
#line 1344
    opt_A = opt_a;
  }
#line 1347
  if (! list_strict_opts) {
    {
#line 1348
    parse_list_opts(& arg, & glob_flags, 0);
    }
  } else {
    {
#line 1355
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1355
      if (*arg) {
        {
#line 1355
        tmp = __ctype_b_loc();
        }
#line 1355
        if (! ((int const   )*(*tmp + (int )*arg) & 8192)) {
#line 1355
          goto while_break;
        }
      } else {
#line 1355
        goto while_break;
      }
      {
#line 1356
      pr_signals_handle();
#line 1357
      arg ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1360
      if (arg) {
#line 1360
        if (! ((int )*arg == 45)) {
#line 1360
          goto while_break___0;
        }
      } else {
#line 1360
        goto while_break___0;
      }
      {
#line 1363
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1363
        if ((int )*arg != 0) {
          {
#line 1363
          tmp___0 = __ctype_b_loc();
          }
#line 1363
          if ((int const   )*(*tmp___0 + (int )*arg) & 8192) {
#line 1363
            goto while_break___1;
          }
        } else {
#line 1363
          goto while_break___1;
        }
#line 1364
        arg ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1366
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1366
        tmp___1 = __ctype_b_loc();
        }
#line 1366
        if (! ((int const   )*(*tmp___1 + (int )*arg) & 8192)) {
#line 1366
          goto while_break___2;
        }
#line 1367
        arg ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1370
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1370
      tmp___2 = __ctype_b_loc();
      }
#line 1370
      if (! ((int const   )*(*tmp___2 + (int )*arg) & 8192)) {
#line 1370
        goto while_break___3;
      }
#line 1371
      arg ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1374
  if (list_options) {
    {
#line 1375
    parse_list_opts(& list_options, & glob_flags, 1);
    }
  }
#line 1377
  if (arg) {
#line 1377
    if (*arg) {
#line 1378
      justone = 1;
#line 1380
      globbed = 0;
#line 1382
      pbuffer[0] = (char )'\000';
#line 1382
      tmp___3 = 1U;
      {
#line 1382
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1382
        if (tmp___3 >= 4097U) {
#line 1382
          goto while_break___4;
        }
#line 1382
        pbuffer[tmp___3] = (char)0;
#line 1382
        tmp___3 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1386
      memset((void *)(& g), '\000', (size_t )sizeof(g));
      }
#line 1388
      if ((int )*arg == 126) {
#line 1393
        i___0 = 0;
#line 1393
        p = (char const   *)(arg + 1);
        {
#line 1393
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1393
          if ((unsigned long )i___0 < sizeof(pbuffer) - 1UL) {
#line 1393
            if (p) {
#line 1393
              if (*p) {
#line 1393
                if (! ((int const   )*p != 47)) {
#line 1393
                  goto while_break___5;
                }
              } else {
#line 1393
                goto while_break___5;
              }
            } else {
#line 1393
              goto while_break___5;
            }
          } else {
#line 1393
            goto while_break___5;
          }
#line 1393
          tmp___4 = i___0;
#line 1393
          i___0 ++;
#line 1393
          tmp___5 = p;
#line 1393
          p ++;
#line 1393
          pbuffer[tmp___4] = (char )*tmp___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1397
        pbuffer[i___0] = (char )'\000';
#line 1399
        if (i___0) {
#line 1399
          tmp___6 = pbuffer;
        } else {
#line 1399
          tmp___6 = session.user;
        }
        {
#line 1399
        pw = pr_auth_getpwnam(cmd->tmp_pool, (char const   *)tmp___6);
        }
#line 1400
        if (pw) {
          {
#line 1401
          snprintf((char */* __restrict  */)(pbuffer), (size_t )sizeof(pbuffer), (char const   */* __restrict  */)"%s%s",
                   pw->pw_dir, p);
          }
        } else {
#line 1404
          pbuffer[0] = (char )'\000';
        }
      }
#line 1407
      if (pbuffer[0]) {
#line 1407
        target = pbuffer;
      } else {
#line 1407
        target = arg;
      }
#line 1410
      if (! opt_STAT) {
        {
#line 1411
        session.sf_flags |= (int volatile   )32;
#line 1412
        tmp___7 = pr_data_open((char *)((void *)0), (char *)"file list", 2, (off_t___0 )0);
        }
#line 1412
        if (tmp___7 < 0) {
#line 1413
          return (-1);
        }
      }
      {
#line 1419
      tmp___12 = strpbrk((char const   *)target, "{[*?");
      }
#line 1419
      if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
        {
#line 1422
        pr_fs_clear_cache();
#line 1423
        tmp___11 = pr_fsio_stat((char const   *)target, & st);
        }
#line 1423
        if (tmp___11 < 0) {
          {
#line 1424
          tmp___8 = __errno_location();
#line 1424
          tmp___9 = strerror(*tmp___8);
#line 1424
          tmp___10 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)target);
#line 1424
          pr_response_add_err("450", "%s: %s", tmp___10, tmp___9);
          }
#line 1426
          return (-1);
        }
      }
      {
#line 1431
      tmp___16 = ls_perms_full(cmd->tmp_pool, cmd, (char const   *)target, (int *)((void *)0));
      }
#line 1431
      if (tmp___16) {
#line 1437
        skiparg = 0;
#line 1439
        if (use_globbing) {
          {
#line 1439
          tmp___15 = strpbrk((char const   *)target, "{[*?");
          }
#line 1439
          if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
            {
#line 1441
            a = pr_fs_glob((char const   *)target, glob_flags, (int (*)(char const   * ,
                                                                        int  ))((void *)0),
                           & g);
#line 1442
            globbed = 1;
            }
          } else {
#line 1439
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1447
          a = 0;
#line 1448
          tmp___13 = pcalloc(cmd->tmp_pool, (int )(2UL * sizeof(char *)));
#line 1448
          g.gl_pathv = (char **)tmp___13;
#line 1449
          tmp___14 = pstrdup(cmd->tmp_pool, (char const   *)target);
#line 1449
          *(g.gl_pathv + 0) = tmp___14;
#line 1450
          *(g.gl_pathv + 1) = (char *)((void *)0);
          }
        }
      } else {
#line 1432
        a = -1;
#line 1433
        skiparg = 1;
      }
#line 1454
      if (! a) {
#line 1455
        list_dir_as_file = 0;
#line 1462
        if (use_globbing) {
          {
#line 1462
          tmp___17 = strpbrk((char const   *)target, "{[*?");
          }
#line 1462
          if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 1462
            if (! opt_R) {
#line 1465
              list_dir_as_file = 1;
            }
          }
        }
#line 1467
        path = g.gl_pathv;
#line 1469
        if (path) {
#line 1469
          if (*(path + 0)) {
#line 1469
            if (*(path + 1)) {
#line 1470
              justone = 0;
            }
          }
        }
        {
#line 1472
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1472
          if (path) {
#line 1472
            if (! *path) {
#line 1472
              goto while_break___6;
            }
          } else {
#line 1472
            goto while_break___6;
          }
          {
#line 1475
          tmp___19 = pr_fsio_lstat((char const   *)*path, & st___0);
          }
#line 1475
          if (tmp___19 == 0) {
#line 1477
            target_mode = st___0.st_mode;
#line 1479
            if ((st___0.st_mode & 61440U) == 40960U) {
              {
#line 1479
              lmode = file_mode(*path);
              }
#line 1479
              if (lmode != 0U) {
#line 1480
                if (opt_L) {
#line 1481
                  st___0.st_mode = lmode;
                } else
#line 1480
                if (! list_show_symlinks) {
#line 1481
                  st___0.st_mode = lmode;
                }
#line 1482
                target_mode = lmode;
              }
            }
#line 1485
            if (opt_d) {
#line 1485
              goto _L___0;
            } else
#line 1485
            if (! ((target_mode & 61440U) == 16384U)) {
#line 1485
              goto _L___0;
            } else
#line 1485
            if ((target_mode & 61440U) == 16384U) {
#line 1485
              if (list_dir_as_file) {
                _L___0: /* CIL Label */ 
                {
#line 1488
                tmp___18 = listfile(cmd, (pool *)((void *)0), (char const   *)*path);
                }
#line 1488
                if (tmp___18 < 0) {
                  {
#line 1489
                  ls_terminate();
                  }
#line 1490
                  if (use_globbing) {
#line 1490
                    if (globbed) {
                      {
#line 1491
                      pr_fs_globfree(& g);
                      }
                    }
                  }
#line 1492
                  return (-1);
                }
#line 1495
                *(*path) = (char )'\000';
              }
            }
          } else {
#line 1499
            *(*path) = (char )'\000';
          }
#line 1501
          path ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1504
        tmp___20 = outputfiles(cmd);
        }
#line 1504
        if (tmp___20 < 0) {
          {
#line 1505
          ls_terminate();
          }
#line 1506
          if (use_globbing) {
#line 1506
            if (globbed) {
              {
#line 1507
              pr_fs_globfree(& g);
              }
            }
          }
#line 1509
          return (-1);
        }
#line 1512
        path = g.gl_pathv;
        {
#line 1513
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1513
          if (path) {
#line 1513
            if (! *path) {
#line 1513
              goto while_break___7;
            }
          } else {
#line 1513
            goto while_break___7;
          }
#line 1514
          if (*(*path)) {
            {
#line 1514
            tmp___26 = ls_perms_full(cmd->tmp_pool, cmd, (char const   *)*path, (int *)((void *)0));
            }
#line 1514
            if (tmp___26) {
#line 1515
              cwd_buf[0] = (char )'\000';
#line 1515
              tmp___21 = 1U;
              {
#line 1515
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1515
                if (tmp___21 >= 4097U) {
#line 1515
                  goto while_break___8;
                }
#line 1515
                cwd_buf[tmp___21] = (char)0;
#line 1515
                tmp___21 ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1518
              if (! justone) {
#line 1519
                if (opt_STAT) {
                  {
#line 1520
                  pr_response_add("211", "%s", "");
#line 1521
                  tmp___22 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)*path);
#line 1521
                  pr_response_add("211", "%s:", tmp___22);
                  }
                } else {
                  {
#line 1525
                  tmp___23 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)*path);
#line 1525
                  sendline(0, (char *)"\n%s:\n", tmp___23);
#line 1527
                  sendline(1, (char *)" ");
                  }
                }
              }
              {
#line 1531
              push_cwd(cwd_buf, & symhold);
              }
#line 1533
              if (! opt_L) {
#line 1533
                if (list_show_symlinks) {
#line 1533
                  tmp___24 = 1;
                } else {
#line 1533
                  tmp___24 = 0;
                }
              } else {
#line 1533
                tmp___24 = 0;
              }
              {
#line 1533
              tmp___25 = pr_fsio_chdir_canon((char const   *)*path, tmp___24);
              }
#line 1533
              if (! tmp___25) {
                {
#line 1534
                res = 0;
#line 1536
                (list_ndepth.curr) ++;
#line 1537
                res = listdir(cmd, (pool *)((void *)0), (char const   *)*path);
#line 1538
                (list_ndepth.curr) --;
#line 1540
                pop_cwd(cwd_buf, & symhold);
                }
#line 1542
                if (res > 0) {
#line 1543
                  goto while_break___7;
                } else
#line 1545
                if (res < 0) {
                  {
#line 1546
                  ls_terminate();
                  }
#line 1547
                  if (use_globbing) {
#line 1547
                    if (globbed) {
                      {
#line 1548
                      pr_fs_globfree(& g);
                      }
                    }
                  }
#line 1549
                  return (-1);
                }
              }
            }
          }
#line 1554
          if (session.sf_flags & (int volatile   )2) {
            {
#line 1555
            discard_output();
            }
#line 1556
            if (use_globbing) {
#line 1556
              if (globbed) {
                {
#line 1557
                pr_fs_globfree(& g);
                }
              }
            }
#line 1558
            return (-1);
          }
#line 1561
          path ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else
#line 1564
      if (! skiparg) {
#line 1565
        if (a == 1) {
          {
#line 1566
          tmp___27 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)arg);
#line 1566
          pr_response_add("226", "Out of memory during globbing of %s", tmp___27);
          }
        } else
#line 1569
        if (a == 2) {
          {
#line 1570
          tmp___28 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)arg);
#line 1570
          pr_response_add("226", "Read error during globbing of %s", tmp___28);
          }
        } else
#line 1573
        if (a != 3) {
          {
#line 1574
          tmp___29 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)arg);
#line 1574
          pr_response_add("226", "Unknown error during globbing of %s", tmp___29);
          }
        }
      }
#line 1578
      if (! skiparg) {
#line 1578
        if (use_globbing) {
#line 1578
          if (globbed) {
            {
#line 1579
            pr_fs_globfree(& g);
            }
          }
        }
      }
#line 1581
      if (session.sf_flags & (int volatile   )2) {
        {
#line 1582
        discard_output();
        }
#line 1583
        return (-1);
      }
    } else {
#line 1377
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1589
    if (! opt_STAT) {
      {
#line 1590
      session.sf_flags |= (int volatile   )32;
#line 1591
      tmp___30 = pr_data_open((char *)((void *)0), (char *)"file list", 2, (off_t___0 )0);
      }
#line 1591
      if (tmp___30 < 0) {
#line 1592
        return (-1);
      }
    }
    {
#line 1595
    tmp___33 = ls_perms_full(cmd->tmp_pool, cmd, ".", (int *)((void *)0));
    }
#line 1595
    if (tmp___33) {
#line 1597
      if (opt_d) {
        {
#line 1598
        tmp___31 = listfile(cmd, (pool *)((void *)0), ".");
        }
#line 1598
        if (tmp___31 < 0) {
          {
#line 1599
          ls_terminate();
          }
#line 1600
          return (-1);
        }
      } else {
        {
#line 1604
        (list_ndepth.curr) ++;
#line 1605
        tmp___32 = listdir(cmd, (pool *)((void *)0), ".");
        }
#line 1605
        if (tmp___32 < 0) {
          {
#line 1606
          ls_terminate();
          }
#line 1607
          return (-1);
        }
#line 1610
        (list_ndepth.curr) --;
      }
    }
    {
#line 1614
    tmp___34 = outputfiles(cmd);
    }
#line 1614
    if (tmp___34 < 0) {
      {
#line 1615
      ls_terminate();
      }
#line 1616
      return (-1);
    }
  }
#line 1620
  return (0);
}
}
#line 1627 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int nlstfile(cmd_rec *cmd , char const   *file ) 
{ 
  int res ;
  int *tmp ;
  unsigned char tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1628
  res = 0;
#line 1631
  if ((session.sf_flags & (int volatile   )4) == (int volatile   )0) {
    {
#line 1632
    tmp = __errno_location();
#line 1632
    *tmp = 1;
    }
#line 1633
    return (-1);
  }
  {
#line 1636
  tmp___0 = dir_hide_file(file);
  }
#line 1636
  if (tmp___0) {
#line 1637
    return (1);
  }
  {
#line 1640
  tmp___1 = pr_fs_encode_path(cmd->tmp_pool, file);
#line 1640
  res = sendline(0, (char *)"%s\n", tmp___1);
  }
#line 1641
  if (res < 0) {
#line 1642
    return (res);
  }
  {
#line 1644
  res = sendline(1, (char *)" ");
  }
#line 1645
  if (res < 0) {
#line 1646
    return (res);
  }
#line 1648
  return (1);
}
}
#line 1655 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int nlstdir(cmd_rec *cmd , char const   *dir ) 
{ 
  char **list ;
  char *p ;
  char *f ;
  char file[4097] ;
  unsigned int tmp ;
  char cwd_buf[4097] ;
  unsigned int tmp___0 ;
  pool *workp ;
  unsigned char symhold ;
  int curdir ;
  int i___0 ;
  int j ;
  int count ;
  int hidden ;
  mode_t mode ;
  config_rec *c ;
  unsigned char ignore_hidden ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned char *ignore ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *str ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 1656
  file[0] = (char )'\000';
#line 1656
  tmp = 1U;
  {
#line 1656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1656
    if (tmp >= 4097U) {
#line 1656
      goto while_break;
    }
#line 1656
    file[tmp] = (char)0;
#line 1656
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1658
  cwd_buf[0] = (char )'\000';
#line 1658
  tmp___0 = 1U;
  {
#line 1658
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1658
    if (tmp___0 >= 4097U) {
#line 1658
      goto while_break___0;
    }
#line 1658
    cwd_buf[tmp___0] = (char)0;
#line 1658
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1661
  curdir = 0;
#line 1661
  count = 0;
#line 1661
  hidden = 0;
#line 1663
  c = (config_rec *)((void *)0);
#line 1664
  ignore_hidden = (unsigned char)0;
#line 1666
  if (list_ndepth.curr) {
#line 1666
    if (list_ndepth.max) {
#line 1666
      if (list_ndepth.curr >= list_ndepth.max) {
#line 1669
        if (! list_ndepth.logged) {
          {
#line 1671
          pr_log_debug(8, "ListOptions maxdepth (%u) reached", list_ndepth.max - 1U);
#line 1673
          list_ndepth.logged = (unsigned char)1;
          }
        }
#line 1676
        return (0);
      }
    }
  }
#line 1679
  if (list_ndirs.curr) {
#line 1679
    if (list_ndirs.max) {
#line 1679
      if (list_ndirs.curr >= list_ndirs.max) {
#line 1682
        if (! list_ndirs.logged) {
          {
#line 1683
          pr_log_debug(8, "ListOptions maxdirs (%u) reached", list_ndirs.max);
#line 1684
          list_ndirs.logged = (unsigned char)1;
          }
        }
#line 1687
        return (0);
      }
    }
  }
  {
#line 1689
  (list_ndirs.curr) ++;
#line 1691
  workp = make_sub_pool(cmd->tmp_pool);
#line 1692
  pr_pool_tag(workp, "mod_ls: nlstdir(): workp (from cmd->tmp_pool)");
  }
#line 1694
  if (! *dir) {
#line 1695
    curdir = 1;
#line 1696
    dir = "";
  } else
#line 1694
  if ((int const   )*dir == 46) {
#line 1694
    if (! *(dir + 1)) {
#line 1695
      curdir = 1;
#line 1696
      dir = "";
    } else {
#line 1694
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1694
    tmp___1 = strcmp(dir, "./");
    }
#line 1694
    if (tmp___1 == 0) {
#line 1695
      curdir = 1;
#line 1696
      dir = "";
    } else {
      {
#line 1699
      push_cwd(cwd_buf, & symhold);
      }
    }
  }
#line 1701
  if (! opt_L) {
#line 1701
    if (list_show_symlinks) {
#line 1701
      tmp___2 = 1;
    } else {
#line 1701
      tmp___2 = 0;
    }
  } else {
#line 1701
    tmp___2 = 0;
  }
  {
#line 1701
  tmp___3 = pr_fsio_chdir_canon(dir, tmp___2);
  }
#line 1701
  if (tmp___3) {
    {
#line 1702
    destroy_pool(workp);
    }
#line 1703
    return (0);
  }
  {
#line 1706
  list = sreaddir(".", (int const   )0);
  }
#line 1706
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 1707
    if (! curdir) {
      {
#line 1708
      pop_cwd(cwd_buf, & symhold);
      }
    }
    {
#line 1709
    destroy_pool(workp);
    }
#line 1710
    return (0);
  }
  {
#line 1716
  c = _find_ls_limit(*(cmd->argv + 0));
  }
#line 1717
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 1718
    tmp___4 = get_param_ptr(c->subset, "IgnoreHidden", 0);
#line 1718
    ignore = (unsigned char *)tmp___4;
    }
#line 1720
    if (ignore) {
#line 1720
      if ((int )*ignore == 1) {
#line 1721
        ignore_hidden = (unsigned char)1;
      }
    }
  }
#line 1724
  j = 0;
  {
#line 1725
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1725
    if (*(list + j)) {
#line 1725
      if (! (count >= 0)) {
#line 1725
        goto while_break___1;
      }
    } else {
#line 1725
      goto while_break___1;
    }
#line 1726
    tmp___5 = j;
#line 1726
    j ++;
#line 1726
    p = *(list + tmp___5);
#line 1728
    if ((int )*p == 46) {
#line 1729
      if (! opt_a) {
#line 1729
        if (! opt_A) {
#line 1730
          goto while_continue___1;
        } else {
          {
#line 1729
          tmp___6 = is_dotdir((char const   *)p);
          }
#line 1729
          if (tmp___6) {
#line 1730
            goto while_continue___1;
          } else {
#line 1729
            goto _L___0;
          }
        }
      } else
      _L___0: /* CIL Label */ 
#line 1733
      if (ignore_hidden) {
#line 1734
        goto while_continue___1;
      }
    }
    {
#line 1737
    i___0 = pr_fsio_readlink((char const   *)p, file, (size_t )(sizeof(file) - 1UL));
    }
#line 1738
    if (i___0 > 0) {
#line 1739
      if ((unsigned long )i___0 >= sizeof(file)) {
#line 1740
        goto while_continue___1;
      }
#line 1742
      file[i___0] = (char )'\000';
#line 1743
      f = file;
    } else {
#line 1746
      f = p;
    }
    {
#line 1749
    tmp___14 = dir_best_path(cmd->tmp_pool, (char const   *)f);
#line 1749
    tmp___15 = ls_perms(workp, cmd, (char const   *)tmp___14, & hidden);
    }
#line 1749
    if (tmp___15) {
#line 1750
      if (hidden) {
#line 1751
        goto while_continue___1;
      }
      {
#line 1753
      mode = file_mode(f);
      }
#line 1754
      if (mode == 0U) {
#line 1755
        goto while_continue___1;
      }
#line 1757
      if (! curdir) {
        {
#line 1758
        tmp___7 = pdircat(cmd->tmp_pool, dir, p, (void *)0);
#line 1758
        tmp___8 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)tmp___7);
#line 1758
        str = tmp___8;
#line 1761
        tmp___9 = sendline(0, (char *)"%s\n", str);
        }
#line 1761
        if (tmp___9 < 0) {
#line 1763
          count = -1;
        } else {
          {
#line 1761
          tmp___10 = sendline(1, (char *)" ");
          }
#line 1761
          if (tmp___10 < 0) {
#line 1763
            count = -1;
          } else {
#line 1766
            count ++;
#line 1768
            if (list_nfiles.curr) {
#line 1768
              if (list_nfiles.max) {
#line 1768
                if (list_nfiles.curr >= list_nfiles.max) {
#line 1771
                  if (! list_nfiles.logged) {
                    {
#line 1772
                    pr_log_debug(8, "ListOptions maxfiles (%u) reached", list_nfiles.max);
#line 1774
                    list_nfiles.logged = (unsigned char)1;
                    }
                  }
#line 1777
                  goto while_break___1;
                }
              }
            }
#line 1779
            (list_nfiles.curr) ++;
          }
        }
      } else {
        {
#line 1783
        tmp___11 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)p);
#line 1783
        tmp___12 = sendline(0, (char *)"%s\n", tmp___11);
        }
#line 1783
        if (tmp___12 < 0) {
#line 1785
          count = -1;
        } else {
          {
#line 1783
          tmp___13 = sendline(1, (char *)" ");
          }
#line 1783
          if (tmp___13 < 0) {
#line 1785
            count = -1;
          } else {
#line 1788
            count ++;
#line 1790
            if (list_nfiles.curr) {
#line 1790
              if (list_nfiles.max) {
#line 1790
                if (list_nfiles.curr >= list_nfiles.max) {
#line 1793
                  if (! list_nfiles.logged) {
                    {
#line 1794
                    pr_log_debug(8, "ListOptions maxfiles (%u) reached", list_nfiles.max);
#line 1796
                    list_nfiles.logged = (unsigned char)1;
                    }
                  }
#line 1799
                  goto while_break___1;
                }
              }
            }
#line 1801
            (list_nfiles.curr) ++;
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1807
  if (! curdir) {
    {
#line 1808
    pop_cwd(cwd_buf, & symhold);
    }
  }
  {
#line 1810
  destroy_pool(workp);
#line 1815
  i___0 = 0;
  }
  {
#line 1816
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1816
    if (! ((unsigned long )*(list + i___0) != (unsigned long )((void *)0))) {
#line 1816
      goto while_break___2;
    }
    {
#line 1817
    tmp___16 = i___0;
#line 1817
    i___0 ++;
#line 1817
    free((void *)*(list + tmp___16));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1818
  free((void *)list);
  }
#line 1820
  return (count);
}
}
#line 1824 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *genericlist(cmd_rec *cmd ) 
{ 
  int res ;
  unsigned char *tmp ;
  mode_t *fake_mode ;
  config_rec *c ;
  xaset_t *tmp___0 ;
  void *tmp___1 ;
  xaset_t *tmp___2 ;
  xaset_t *tmp___3 ;
  xaset_t *tmp___4 ;
  xaset_t *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  xaset_t *tmp___8 ;
  xaset_t *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  xaset_t *tmp___12 ;
  xaset_t *tmp___13 ;
  void *tmp___14 ;
  xaset_t *tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  modret_t *tmp___19 ;
  modret_t *tmp___20 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1825
  res = 0;
#line 1826
  tmp = (unsigned char *)((void *)0);
#line 1827
  fake_mode = (mode_t *)((void *)0);
#line 1828
  c = (config_rec *)((void *)0);
#line 1830
  if (session.anon_config) {
#line 1830
    tmp___0 = (session.anon_config)->subset;
  } else {
#line 1830
    tmp___0 = main_server->conf;
  }
  {
#line 1830
  tmp___1 = get_param_ptr(tmp___0, "ShowSymlinks", 0);
#line 1830
  tmp = (unsigned char *)tmp___1;
  }
#line 1831
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1832
    list_show_symlinks = *tmp;
  }
#line 1834
  list_strict_opts = (unsigned char)0;
#line 1836
  list_ndepth.max = 0U;
#line 1836
  list_ndirs.max = list_ndepth.max;
#line 1836
  list_nfiles.max = list_ndirs.max;
#line 1838
  if (session.dir_config) {
#line 1838
    tmp___3 = (session.dir_config)->subset;
  } else {
#line 1838
    if (session.anon_config) {
#line 1838
      tmp___2 = (session.anon_config)->subset;
    } else {
#line 1838
      tmp___2 = main_server->conf;
    }
#line 1838
    tmp___3 = tmp___2;
  }
  {
#line 1838
  c = find_config(tmp___3, 1 << 15, "ListOptions", 0);
  }
#line 1839
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1840
    list_options = (char *)*(c->argv + 0);
#line 1841
    list_strict_opts = *((unsigned char *)*(c->argv + 1));
#line 1843
    list_ndepth.max = *((unsigned int *)*(c->argv + 2));
#line 1851
    if (list_ndepth.max) {
#line 1852
      (list_ndepth.max) ++;
    }
#line 1854
    list_nfiles.max = *((unsigned int *)*(c->argv + 3));
#line 1855
    list_ndirs.max = *((unsigned int *)*(c->argv + 4));
  }
#line 1858
  if (session.dir_config) {
#line 1858
    tmp___5 = (session.dir_config)->subset;
  } else {
#line 1858
    if (session.anon_config) {
#line 1858
      tmp___4 = (session.anon_config)->subset;
    } else {
#line 1858
      tmp___4 = main_server->conf;
    }
#line 1858
    tmp___5 = tmp___4;
  }
  {
#line 1858
  tmp___6 = get_param_ptr(tmp___5, "DirFakeUser", 0);
#line 1858
  fakeuser = (char *)tmp___6;
  }
#line 1861
  if (fakeuser) {
    {
#line 1861
    tmp___7 = strcmp((char const   *)fakeuser, "~");
    }
#line 1861
    if (tmp___7 == 0) {
#line 1862
      fakeuser = session.user;
    }
  }
#line 1864
  if (session.dir_config) {
#line 1864
    tmp___9 = (session.dir_config)->subset;
  } else {
#line 1864
    if (session.anon_config) {
#line 1864
      tmp___8 = (session.anon_config)->subset;
    } else {
#line 1864
      tmp___8 = main_server->conf;
    }
#line 1864
    tmp___9 = tmp___8;
  }
  {
#line 1864
  tmp___10 = get_param_ptr(tmp___9, "DirFakeGroup", 0);
#line 1864
  fakegroup = (char *)tmp___10;
  }
#line 1867
  if (fakegroup) {
    {
#line 1867
    tmp___11 = strcmp((char const   *)fakegroup, "~");
    }
#line 1867
    if (tmp___11 == 0) {
#line 1868
      fakegroup = session.group;
    }
  }
#line 1870
  if (session.dir_config) {
#line 1870
    tmp___13 = (session.dir_config)->subset;
  } else {
#line 1870
    if (session.anon_config) {
#line 1870
      tmp___12 = (session.anon_config)->subset;
    } else {
#line 1870
      tmp___12 = main_server->conf;
    }
#line 1870
    tmp___13 = tmp___12;
  }
  {
#line 1870
  tmp___14 = get_param_ptr(tmp___13, "DirFakeMode", 0);
#line 1870
  fake_mode = (mode_t *)tmp___14;
  }
#line 1871
  if (fake_mode) {
#line 1872
    fakemode = *fake_mode;
#line 1873
    have_fake_mode = (unsigned char)1;
  } else {
#line 1876
    have_fake_mode = (unsigned char)0;
  }
#line 1878
  if (session.anon_config) {
#line 1878
    tmp___15 = (session.anon_config)->subset;
  } else {
#line 1878
    tmp___15 = main_server->conf;
  }
  {
#line 1878
  tmp___16 = get_param_ptr(tmp___15, "TimesGMT", 0);
#line 1878
  tmp = (unsigned char *)tmp___16;
  }
#line 1879
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1880
    list_times_gmt = *tmp;
  }
  {
#line 1882
  tmp___17 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 1882
  res = dolist(cmd, (char const   *)tmp___17, 1);
  }
#line 1884
  if (session.sf_flags & (int volatile   )2) {
    {
#line 1885
    pr_data_abort(0, 0);
#line 1886
    res = -1;
    }
  } else
#line 1888
  if (session.sf_flags & (int volatile   )4) {
    {
#line 1889
    ls_done(cmd);
    }
  }
#line 1891
  opt_l = 0;
#line 1893
  if (res == -1) {
    {
#line 1893
    tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
#line 1893
    tmp___20 = tmp___18;
    }
  } else {
    {
#line 1893
    tmp___19 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
#line 1893
    tmp___20 = tmp___19;
    }
  }
#line 1893
  return (tmp___20);
}
}
#line 1896 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *ls_log_nlst(cmd_rec *cmd ) 
{ 


  {
  {
#line 1897
  pr_data_cleanup();
  }
#line 1898
  return ((modret_t *)((void *)0));
}
}
#line 1901 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *ls_err_nlst(cmd_rec *cmd ) 
{ 


  {
  {
#line 1902
  pr_data_cleanup();
  }
#line 1903
  return ((modret_t *)((void *)0));
}
}
#line 1906 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *ls_stat(cmd_rec *cmd ) 
{ 
  int res ;
  char *arg ;
  unsigned char *tmp ;
  mode_t *fake_mode ;
  config_rec *c ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  modret_t *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  xaset_t *tmp___12 ;
  void *tmp___13 ;
  xaset_t *tmp___14 ;
  xaset_t *tmp___15 ;
  xaset_t *tmp___16 ;
  xaset_t *tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  xaset_t *tmp___20 ;
  xaset_t *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  xaset_t *tmp___24 ;
  xaset_t *tmp___25 ;
  void *tmp___26 ;
  xaset_t *tmp___27 ;
  void *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  modret_t *tmp___33 ;
  modret_t *tmp___34 ;
  modret_t *tmp___35 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;

  {
#line 1908
  arg = cmd->arg;
#line 1909
  tmp = (unsigned char *)((void *)0);
#line 1910
  fake_mode = (mode_t *)((void *)0);
#line 1911
  c = (config_rec *)((void *)0);
#line 1913
  if (cmd->argc == 1) {
    {
#line 1919
    tmp___2 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, session.cwd,
                        (int *)((void *)0));
    }
#line 1919
    if (! tmp___2) {
      {
#line 1921
      tmp___0 = strerror(1);
#line 1921
      pr_response_add_err("500", "%s: %s", *(cmd->argv + 0), tmp___0);
#line 1922
      tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1922
      return (tmp___1);
    }
    {
#line 1925
    pr_response_add("211", "Status of \'%s\'", main_server->ServerName);
#line 1926
    tmp___3 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1926
    pr_response_add((char const   *)((void *)0), "Connected from %s (%s)", (session.c)->remote_name,
                    tmp___3);
#line 1928
    pr_response_add((char const   *)((void *)0), "Logged in as %s", session.user);
    }
#line 1929
    if (session.sf_flags & (int volatile   )16) {
#line 1929
      tmp___4 = "ASCII";
    } else {
#line 1929
      tmp___4 = "BINARY";
    }
    {
#line 1929
    pr_response_add((char const   *)((void *)0), "TYPE: %s, STRUcture: File, Mode: Stream",
                    tmp___4);
    }
#line 1932
    if (session.total_bytes) {
      {
#line 1933
      pr_response_add((char const   *)((void *)0), "Total bytes transferred for session: %llu",
                      (unsigned long long )session.total_bytes);
      }
    }
#line 1936
    if (session.sf_flags & (int volatile   )4) {
      {
#line 1940
      tmp___5 = pr_netaddr_get_ipstr((session.d)->remote_addr);
      }
#line 1940
      if (session.sf_flags & (int volatile   )1) {
#line 1940
        tmp___6 = "Passive data transfer from";
      } else {
#line 1940
        tmp___6 = "Active data transfer to";
      }
      {
#line 1940
      pr_response_add((char const   *)((void *)0), "%s from %s port %u", tmp___6,
                      tmp___5, (session.d)->remote_port);
      }
#line 1945
      if (session.xfer.file_size) {
#line 1946
        if (session.xfer.direction == 1) {
#line 1946
          tmp___7 = "STOR";
        } else {
#line 1946
          tmp___7 = "RETR";
        }
        {
#line 1946
        pr_response_add((char const   *)((void *)0), "%s %s (%llu/%llu)", tmp___7,
                        session.xfer.path, (unsigned long long )session.xfer.file_size,
                        (unsigned long long )session.xfer.total_bytes);
        }
      } else {
#line 1952
        if (session.xfer.direction == 1) {
#line 1952
          tmp___8 = "STOR";
        } else {
#line 1952
          tmp___8 = "RETR";
        }
        {
#line 1952
        pr_response_add((char const   *)((void *)0), "%s %s (%llu)", tmp___8, session.xfer.path,
                        (unsigned long long )session.xfer.total_bytes);
        }
      }
    } else {
      {
#line 1957
      pr_response_add((char const   *)((void *)0), "No data connection");
      }
    }
    {
#line 1959
    pr_response_add((char const   *)((void *)0), "End of status");
#line 1961
    tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 1961
    return (tmp___9);
  }
  {
#line 1964
  list_ndepth.curr = 0U;
#line 1964
  list_ndirs.curr = list_ndepth.curr;
#line 1964
  list_nfiles.curr = list_ndirs.curr;
#line 1965
  list_ndepth.logged = (unsigned char)0;
#line 1965
  list_ndirs.logged = list_ndepth.logged;
#line 1965
  list_nfiles.logged = list_ndirs.logged;
#line 1967
  arg = pr_fs_decode_path(cmd->tmp_pool, (char const   *)arg);
  }
#line 1970
  if ((int )*arg == 45) {
    {
#line 1971
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1971
      if (arg) {
#line 1971
        if (*arg) {
          {
#line 1971
          tmp___10 = __ctype_b_loc();
          }
#line 1971
          if ((int const   )*(*tmp___10 + (int )*arg) & 8192) {
#line 1971
            goto while_break;
          }
        } else {
#line 1971
          goto while_break;
        }
      } else {
#line 1971
        goto while_break;
      }
#line 1972
      arg ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1974
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1974
    if (arg) {
#line 1974
      if (*arg) {
        {
#line 1974
        tmp___11 = __ctype_b_loc();
        }
#line 1974
        if (! ((int const   )*(*tmp___11 + (int )*arg) & 8192)) {
#line 1974
          goto while_break___0;
        }
      } else {
#line 1974
        goto while_break___0;
      }
    } else {
#line 1974
      goto while_break___0;
    }
#line 1975
    arg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1977
  if (session.anon_config) {
#line 1977
    tmp___12 = (session.anon_config)->subset;
  } else {
#line 1977
    tmp___12 = main_server->conf;
  }
  {
#line 1977
  tmp___13 = get_param_ptr(tmp___12, "ShowSymlinks", 0);
#line 1977
  tmp = (unsigned char *)tmp___13;
  }
#line 1978
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1979
    list_show_symlinks = *tmp;
  }
#line 1981
  list_strict_opts = (unsigned char)0;
#line 1982
  list_ndirs.max = 0U;
#line 1982
  list_nfiles.max = list_ndirs.max;
#line 1982
  list_ndepth.max = list_nfiles.max;
#line 1984
  if (session.dir_config) {
#line 1984
    tmp___15 = (session.dir_config)->subset;
  } else {
#line 1984
    if (session.anon_config) {
#line 1984
      tmp___14 = (session.anon_config)->subset;
    } else {
#line 1984
      tmp___14 = main_server->conf;
    }
#line 1984
    tmp___15 = tmp___14;
  }
  {
#line 1984
  c = find_config(tmp___15, 1 << 15, "ListOptions", 0);
  }
#line 1985
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1986
    list_options = (char *)*(c->argv + 0);
#line 1987
    list_strict_opts = *((unsigned char *)*(c->argv + 1));
#line 1989
    list_ndepth.max = *((unsigned int *)*(c->argv + 2));
#line 1997
    if (list_ndepth.max) {
#line 1998
      (list_ndepth.max) ++;
    }
#line 2000
    list_nfiles.max = *((unsigned int *)*(c->argv + 3));
#line 2001
    list_ndirs.max = *((unsigned int *)*(c->argv + 4));
  }
#line 2004
  if (session.dir_config) {
#line 2004
    tmp___17 = (session.dir_config)->subset;
  } else {
#line 2004
    if (session.anon_config) {
#line 2004
      tmp___16 = (session.anon_config)->subset;
    } else {
#line 2004
      tmp___16 = main_server->conf;
    }
#line 2004
    tmp___17 = tmp___16;
  }
  {
#line 2004
  tmp___18 = get_param_ptr(tmp___17, "DirFakeUser", 0);
#line 2004
  fakeuser = (char *)tmp___18;
  }
#line 2007
  if (fakeuser) {
    {
#line 2007
    tmp___19 = strcmp((char const   *)fakeuser, "~");
    }
#line 2007
    if (tmp___19 == 0) {
#line 2008
      fakeuser = session.user;
    }
  }
#line 2010
  if (session.dir_config) {
#line 2010
    tmp___21 = (session.dir_config)->subset;
  } else {
#line 2010
    if (session.anon_config) {
#line 2010
      tmp___20 = (session.anon_config)->subset;
    } else {
#line 2010
      tmp___20 = main_server->conf;
    }
#line 2010
    tmp___21 = tmp___20;
  }
  {
#line 2010
  tmp___22 = get_param_ptr(tmp___21, "DirFakeGroup", 0);
#line 2010
  fakegroup = (char *)tmp___22;
  }
#line 2013
  if (fakegroup) {
    {
#line 2013
    tmp___23 = strcmp((char const   *)fakegroup, "~");
    }
#line 2013
    if (tmp___23 == 0) {
#line 2014
      fakegroup = session.group;
    }
  }
#line 2016
  if (session.dir_config) {
#line 2016
    tmp___25 = (session.dir_config)->subset;
  } else {
#line 2016
    if (session.anon_config) {
#line 2016
      tmp___24 = (session.anon_config)->subset;
    } else {
#line 2016
      tmp___24 = main_server->conf;
    }
#line 2016
    tmp___25 = tmp___24;
  }
  {
#line 2016
  tmp___26 = get_param_ptr(tmp___25, "DirFakeMode", 0);
#line 2016
  fake_mode = (mode_t *)tmp___26;
  }
#line 2017
  if (fake_mode) {
#line 2018
    fakemode = *fake_mode;
#line 2019
    have_fake_mode = (unsigned char)1;
  } else {
#line 2022
    have_fake_mode = (unsigned char)0;
  }
#line 2024
  if (session.anon_config) {
#line 2024
    tmp___27 = (session.anon_config)->subset;
  } else {
#line 2024
    tmp___27 = main_server->conf;
  }
  {
#line 2024
  tmp___28 = get_param_ptr(tmp___27, "TimesGMT", 0);
#line 2024
  tmp = (unsigned char *)tmp___28;
  }
#line 2025
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2026
    list_times_gmt = *tmp;
  }
#line 2028
  opt_R = 0;
#line 2028
  opt_F = opt_R;
#line 2028
  opt_d = opt_F;
#line 2028
  opt_C = opt_d;
#line 2029
  opt_STAT = 1;
#line 2029
  opt_l = opt_STAT;
#line 2029
  opt_a = opt_l;
#line 2031
  if (arg) {
#line 2031
    if (*arg) {
      {
#line 2031
      tmp___29 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)arg);
#line 2031
      tmp___31 = tmp___29;
      }
    } else {
      {
#line 2031
      tmp___30 = pr_fs_encode_path(cmd->tmp_pool, ".");
#line 2031
      tmp___31 = tmp___30;
      }
    }
  } else {
    {
#line 2031
    tmp___30 = pr_fs_encode_path(cmd->tmp_pool, ".");
#line 2031
    tmp___31 = tmp___30;
    }
  }
  {
#line 2031
  pr_response_add("211", "Status of %s:", tmp___31);
  }
#line 2034
  if (arg) {
#line 2034
    if (*arg) {
#line 2034
      tmp___32 = (char const   *)arg;
    } else {
#line 2034
      tmp___32 = ".";
    }
  } else {
#line 2034
    tmp___32 = ".";
  }
  {
#line 2034
  res = dolist(cmd, tmp___32, 0);
#line 2035
  pr_response_add("211", "End of status");
  }
#line 2036
  if (res == -1) {
    {
#line 2036
    tmp___33 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
#line 2036
    tmp___35 = tmp___33;
    }
  } else {
    {
#line 2036
    tmp___34 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
#line 2036
    tmp___35 = tmp___34;
    }
  }
#line 2036
  return (tmp___35);
}
}
#line 2039 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *ls_list(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;

  {
  {
#line 2040
  list_ndepth.curr = 0U;
#line 2040
  list_ndirs.curr = list_ndepth.curr;
#line 2040
  list_nfiles.curr = list_ndirs.curr;
#line 2041
  list_ndepth.logged = (unsigned char)0;
#line 2041
  list_ndirs.logged = list_ndepth.logged;
#line 2041
  list_nfiles.logged = list_ndirs.logged;
#line 2043
  opt_l = 1;
#line 2044
  tmp = genericlist(cmd);
  }
#line 2044
  return (tmp);
}
}
#line 2052 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *ls_nlst(cmd_rec *cmd ) 
{ 
  char *target ;
  char buf___2[4097] ;
  unsigned int tmp ;
  size_t targetlen ;
  config_rec *c ;
  int count ;
  int res ;
  int hidden ;
  int glob_flags ;
  unsigned char *tmp___0 ;
  xaset_t *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  xaset_t *tmp___4 ;
  xaset_t *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char pb[4097] ;
  unsigned int tmp___10 ;
  struct passwd *pw ;
  int i___0 ;
  char const   *p ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  size_t cwdlen ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  glob_t g ;
  char **path ;
  char *p___0 ;
  modret_t *tmp___19 ;
  int tmp___20 ;
  modret_t *tmp___21 ;
  int tmp___22 ;
  struct stat st ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  struct stat st___0 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  modret_t *tmp___30 ;
  int tmp___31 ;
  unsigned char *ignore_hidden ;
  void *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  modret_t *tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  modret_t *tmp___40 ;
  int tmp___41 ;
  modret_t *tmp___42 ;
  int tmp___43 ;
  modret_t *tmp___44 ;
  int tmp___45 ;
  modret_t *tmp___46 ;
  char *tmp___47 ;
  modret_t *tmp___48 ;
  modret_t *tmp___49 ;
  modret_t *tmp___50 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;

  {
#line 2053
  buf___2[0] = (char )'\000';
#line 2053
  tmp = 1U;
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    if (tmp >= 4097U) {
#line 2053
      goto while_break;
    }
#line 2053
    buf___2[tmp] = (char)0;
#line 2053
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2054
  targetlen = (size_t )0;
#line 2055
  c = (config_rec *)((void *)0);
#line 2056
  count = 0;
#line 2056
  res = 0;
#line 2056
  hidden = 0;
#line 2057
  glob_flags = 1 << 7;
#line 2058
  tmp___0 = (unsigned char *)((void *)0);
#line 2060
  list_ndepth.curr = 0U;
#line 2060
  list_ndirs.curr = list_ndepth.curr;
#line 2060
  list_nfiles.curr = list_ndirs.curr;
#line 2061
  list_ndepth.logged = (unsigned char)0;
#line 2061
  list_ndirs.logged = list_ndepth.logged;
#line 2061
  list_nfiles.logged = list_ndirs.logged;
#line 2063
  if (session.anon_config) {
#line 2063
    tmp___1 = (session.anon_config)->subset;
  } else {
#line 2063
    tmp___1 = main_server->conf;
  }
  {
#line 2063
  tmp___2 = get_param_ptr(tmp___1, "ShowSymlinks", 0);
#line 2063
  tmp___0 = (unsigned char *)tmp___2;
  }
#line 2064
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 2065
    list_show_symlinks = *tmp___0;
  }
#line 2067
  if (cmd->argc == 1) {
#line 2067
    target = (char *)".";
  } else {
    {
#line 2067
    tmp___3 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 2067
    target = tmp___3;
    }
  }
#line 2070
  if (session.dir_config) {
#line 2070
    tmp___5 = (session.dir_config)->subset;
  } else {
#line 2070
    if (session.anon_config) {
#line 2070
      tmp___4 = (session.anon_config)->subset;
    } else {
#line 2070
      tmp___4 = main_server->conf;
    }
#line 2070
    tmp___5 = tmp___4;
  }
  {
#line 2070
  c = find_config(tmp___5, 1 << 15, "ListOptions", 0);
  }
#line 2071
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 2072
    list_options = (char *)*(c->argv + 0);
#line 2073
    list_strict_opts = *((unsigned char *)*(c->argv + 1));
#line 2075
    list_ndepth.max = *((unsigned int *)*(c->argv + 2));
#line 2083
    if (list_ndepth.max) {
#line 2084
      (list_ndepth.max) ++;
    }
#line 2086
    list_nfiles.max = *((unsigned int *)*(c->argv + 3));
#line 2087
    list_ndirs.max = *((unsigned int *)*(c->argv + 4));
  }
#line 2091
  opt_L = 0;
#line 2091
  opt_STAT = opt_L;
#line 2091
  opt_t = opt_STAT;
#line 2091
  opt_S = opt_t;
#line 2091
  opt_R = opt_S;
#line 2091
  opt_r = opt_R;
#line 2091
  opt_n = opt_r;
#line 2091
  opt_F = opt_n;
#line 2091
  opt_d = opt_F;
#line 2091
  opt_C = opt_d;
#line 2091
  opt_a = opt_C;
#line 2091
  opt_A = opt_a;
#line 2094
  if (! list_strict_opts) {
    {
#line 2095
    parse_list_opts(& target, & glob_flags, 0);
    }
  } else {
    {
#line 2102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2102
      if (*target) {
        {
#line 2102
        tmp___6 = __ctype_b_loc();
        }
#line 2102
        if (! ((int const   )*(*tmp___6 + (int )*target) & 8192)) {
#line 2102
          goto while_break___0;
        }
      } else {
#line 2102
        goto while_break___0;
      }
#line 2103
      target ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2105
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2105
      if (target) {
#line 2105
        if (! ((int )*target == 45)) {
#line 2105
          goto while_break___1;
        }
      } else {
#line 2105
        goto while_break___1;
      }
      {
#line 2108
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2108
        if ((int )*target != 0) {
          {
#line 2108
          tmp___7 = __ctype_b_loc();
          }
#line 2108
          if ((int const   )*(*tmp___7 + (int )*target) & 8192) {
#line 2108
            goto while_break___2;
          }
        } else {
#line 2108
          goto while_break___2;
        }
#line 2109
        target ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2111
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2111
        if (*target) {
          {
#line 2111
          tmp___8 = __ctype_b_loc();
          }
#line 2111
          if (! ((int const   )*(*tmp___8 + (int )*target) & 8192)) {
#line 2111
            goto while_break___3;
          }
        } else {
#line 2111
          goto while_break___3;
        }
#line 2112
        target ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2115
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2115
      if (*target) {
        {
#line 2115
        tmp___9 = __ctype_b_loc();
        }
#line 2115
        if (! ((int const   )*(*tmp___9 + (int )*target) & 8192)) {
#line 2115
          goto while_break___4;
        }
      } else {
#line 2115
        goto while_break___4;
      }
#line 2116
      target ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 2119
  if (list_options) {
    {
#line 2120
    parse_list_opts(& list_options, & glob_flags, 1);
    }
  }
#line 2123
  if ((int )*target == 126) {
#line 2124
    pb[0] = (char )'\000';
#line 2124
    tmp___10 = 1U;
    {
#line 2124
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2124
      if (tmp___10 >= 4097U) {
#line 2124
        goto while_break___5;
      }
#line 2124
      pb[tmp___10] = (char)0;
#line 2124
      tmp___10 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2125
    pw = (struct passwd *)((void *)0);
#line 2126
    i___0 = 0;
#line 2127
    p = (char const   *)target;
#line 2129
    p ++;
    {
#line 2131
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2131
      if (*p) {
#line 2131
        if ((int const   )*p != 47) {
#line 2131
          if (! (i___0 < 4096)) {
#line 2131
            goto while_break___6;
          }
        } else {
#line 2131
          goto while_break___6;
        }
      } else {
#line 2131
        goto while_break___6;
      }
#line 2132
      tmp___11 = i___0;
#line 2132
      i___0 ++;
#line 2132
      tmp___12 = p;
#line 2132
      p ++;
#line 2132
      pb[tmp___11] = (char )*tmp___12;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2133
    pb[i___0] = (char )'\000';
#line 2135
    if (i___0) {
#line 2135
      tmp___13 = pb;
    } else {
#line 2135
      tmp___13 = session.user;
    }
    {
#line 2135
    pw = pr_auth_getpwnam(cmd->tmp_pool, (char const   *)tmp___13);
    }
#line 2136
    if (pw) {
      {
#line 2137
      snprintf((char */* __restrict  */)(pb), (size_t )sizeof(pb), (char const   */* __restrict  */)"%s%s",
               pw->pw_dir, p);
#line 2138
      sstrncpy(buf___2, (char const   *)(pb), (size_t )sizeof(buf___2));
#line 2139
      target = buf___2;
      }
    }
  }
#line 2144
  if ((int )*target != 47) {
    {
#line 2145
    tmp___14 = pr_fs_getcwd();
#line 2145
    tmp___15 = strlen(tmp___14);
#line 2145
    cwdlen = tmp___15;
#line 2147
    tmp___16 = pr_fs_getcwd();
#line 2147
    tmp___17 = pdircat(cmd->tmp_pool, tmp___16, target, (void *)0);
#line 2147
    pr_fs_clean_path((char const   *)tmp___17, buf___2, (size_t )sizeof(buf___2));
#line 2150
    target = buf___2;
#line 2155
    target += cwdlen;
    }
#line 2162
    if (cwdlen > 1U) {
#line 2163
      target ++;
    }
  } else {
    {
#line 2166
    pr_fs_clean_path((char const   *)target, buf___2, (size_t )sizeof(buf___2));
#line 2167
    target = buf___2;
    }
  }
  {
#line 2171
  targetlen = strlen((char const   *)target);
  }
  {
#line 2172
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2172
    if (targetlen >= 1U) {
#line 2172
      if (! ((int )*(target + (targetlen - 1U)) == 47)) {
#line 2172
        goto while_break___7;
      }
    } else {
#line 2172
      goto while_break___7;
    }
    {
#line 2175
    tmp___18 = strcmp((char const   *)target, "/");
    }
#line 2175
    if (tmp___18 == 0) {
#line 2176
      goto while_break___7;
    }
    {
#line 2179
    *(target + (targetlen - 1U)) = (char )'\000';
#line 2180
    targetlen = strlen((char const   *)target);
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2184
  if (use_globbing) {
    {
#line 2184
    tmp___47 = strpbrk((char const   *)target, "{[*?");
    }
#line 2184
    if ((unsigned long )tmp___47 != (unsigned long )((void *)0)) {
      {
#line 2190
      memset((void *)(& g), '\000', (size_t )sizeof(glob_t ));
#line 2192
      tmp___20 = pr_fs_glob((char const   *)target, 1 << 7, (int (*)(char const   * ,
                                                                     int  ))((void *)0),
                            & g);
      }
#line 2192
      if (tmp___20 != 0) {
        {
#line 2193
        pr_response_add_err("450", "No files found");
#line 2194
        tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2194
        return (tmp___19);
      }
      {
#line 2197
      tmp___22 = pr_data_open((char *)((void *)0), (char *)"file list", 2, (off_t___0 )0);
      }
#line 2197
      if (tmp___22 < 0) {
        {
#line 2198
        tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2198
        return (tmp___21);
      }
#line 2199
      session.sf_flags |= (int volatile   )32;
#line 2202
      path = g.gl_pathv;
      {
#line 2203
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2203
        if (path) {
#line 2203
          if (*path) {
#line 2203
            if (! (res >= 0)) {
#line 2203
              goto while_break___8;
            }
          } else {
#line 2203
            goto while_break___8;
          }
        } else {
#line 2203
          goto while_break___8;
        }
#line 2206
        p___0 = *path;
#line 2207
        path ++;
#line 2209
        if ((int )*p___0 == 46) {
#line 2209
          if (! opt_A) {
#line 2210
            goto while_continue___8;
          } else {
            {
#line 2209
            tmp___23 = is_dotdir((char const   *)p___0);
            }
#line 2209
            if (tmp___23) {
#line 2210
              goto while_continue___8;
            }
          }
        }
        {
#line 2212
        tmp___25 = pr_fsio_stat((char const   *)p___0, & st);
        }
#line 2212
        if (tmp___25 == 0) {
#line 2214
          if ((st.st_mode & 61440U) == 16384U) {
            {
#line 2215
            res = nlstdir(cmd, (char const   *)p___0);
            }
          } else
#line 2217
          if ((st.st_mode & 61440U) == 32768U) {
            {
#line 2217
            tmp___24 = ls_perms(cmd->tmp_pool, cmd, (char const   *)p___0, & hidden);
            }
#line 2217
            if (tmp___24) {
#line 2220
              if (hidden) {
#line 2221
                goto while_continue___8;
              }
              {
#line 2223
              res = nlstfile(cmd, (char const   *)p___0);
              }
            }
          }
#line 2226
          if (res > 0) {
#line 2227
            count += res;
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 2231
      pr_fs_globfree(& g);
      }
    } else {
#line 2184
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2240
    tmp___31 = ls_perms_full(cmd->tmp_pool, cmd, (char const   *)target, & hidden);
    }
#line 2240
    if (! tmp___31) {
      {
#line 2241
      tmp___26 = __errno_location();
#line 2241
      tmp___27 = strerror(*tmp___26);
      }
#line 2241
      if (*(cmd->arg)) {
#line 2241
        tmp___29 = cmd->arg;
      } else {
        {
#line 2241
        tmp___28 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)(session.vwd));
#line 2241
        tmp___29 = tmp___28;
        }
      }
      {
#line 2241
      pr_response_add_err("450", "%s: %s", tmp___29, tmp___27);
#line 2243
      tmp___30 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 2243
      return (tmp___30);
    }
#line 2247
    if (hidden) {
      {
#line 2248
      c = _find_ls_limit(target);
      }
#line 2250
      if (c) {
        {
#line 2251
        tmp___32 = get_param_ptr(c->subset, "IgnoreHidden", 0);
#line 2251
        ignore_hidden = (unsigned char *)tmp___32;
        }
#line 2254
        if (ignore_hidden) {
#line 2254
          if ((int )*ignore_hidden == 1) {
            {
#line 2255
            tmp___33 = strerror(2);
#line 2255
            tmp___34 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)target);
#line 2255
            pr_response_add_err("450", "%s: %s", tmp___34, tmp___33);
            }
          } else {
            {
#line 2259
            tmp___35 = strerror(13);
#line 2259
            tmp___36 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)target);
#line 2259
            pr_response_add_err("450", "%s: %s", tmp___36, tmp___35);
            }
          }
        } else {
          {
#line 2259
          tmp___35 = strerror(13);
#line 2259
          tmp___36 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)target);
#line 2259
          pr_response_add_err("450", "%s: %s", tmp___36, tmp___35);
          }
        }
        {
#line 2263
        tmp___37 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2263
        return (tmp___37);
      }
    }
    {
#line 2270
    pr_fs_clear_cache();
#line 2271
    tmp___41 = pr_fsio_stat((char const   *)target, & st___0);
    }
#line 2271
    if (tmp___41 < 0) {
      {
#line 2272
      tmp___38 = __errno_location();
#line 2272
      tmp___39 = strerror(*tmp___38);
#line 2272
      pr_response_add_err("450", "%s: %s", cmd->arg, tmp___39);
#line 2273
      tmp___40 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 2273
      return (tmp___40);
    }
#line 2276
    if ((st___0.st_mode & 61440U) == 32768U) {
      {
#line 2277
      tmp___43 = pr_data_open((char *)((void *)0), (char *)"file list", 2, (off_t___0 )0);
      }
#line 2277
      if (tmp___43 < 0) {
        {
#line 2278
        tmp___42 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2278
        return (tmp___42);
      }
      {
#line 2279
      session.sf_flags |= (int volatile   )32;
#line 2281
      res = nlstfile(cmd, (char const   *)target);
      }
    } else
#line 2283
    if ((st___0.st_mode & 61440U) == 16384U) {
      {
#line 2284
      tmp___45 = pr_data_open((char *)((void *)0), (char *)"file list", 2, (off_t___0 )0);
      }
#line 2284
      if (tmp___45 < 0) {
        {
#line 2285
        tmp___44 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2285
        return (tmp___44);
      }
      {
#line 2286
      session.sf_flags |= (int volatile   )32;
#line 2288
      res = nlstdir(cmd, (char const   *)target);
      }
    } else {
      {
#line 2291
      pr_response_add_err("450", "%s: Not a regular file", cmd->arg);
#line 2292
      tmp___46 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 2292
      return (tmp___46);
    }
#line 2295
    if (res > 0) {
#line 2296
      count += res;
    }
  }
#line 2299
  if (session.sf_flags & (int volatile   )2) {
    {
#line 2300
    pr_data_abort(0, 0);
#line 2301
    res = -1;
    }
  } else {
    {
#line 2307
    ls_done(cmd);
    }
  }
#line 2310
  if (res < 0) {
    {
#line 2310
    tmp___48 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
#line 2310
    tmp___50 = tmp___48;
    }
  } else {
    {
#line 2310
    tmp___49 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
#line 2310
    tmp___50 = tmp___49;
    }
  }
#line 2310
  return (tmp___50);
}
}
#line 2316 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *ls_post_pass(cmd_rec *cmd ) 
{ 
  unsigned char *globbing ;
  xaset_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2317
  globbing = (unsigned char *)((void *)0);
#line 2319
  if (session.anon_config) {
#line 2319
    tmp = (session.anon_config)->subset;
  } else {
#line 2319
    tmp = main_server->conf;
  }
  {
#line 2319
  tmp___0 = get_param_ptr(tmp, "UseGlobbing", 0);
#line 2319
  globbing = (unsigned char *)tmp___0;
  }
#line 2320
  if ((unsigned long )globbing != (unsigned long )((void *)0)) {
#line 2320
    if ((int )*globbing == 0) {
      {
#line 2322
      pr_log_debug(3, "UseGlobbing: disabling globbing functionality");
#line 2323
      use_globbing = (unsigned char)0;
      }
    }
  }
#line 2326
  return ((modret_t *)((void *)0));
}
}
#line 2332 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *set_dirfakeusergroup(cmd_rec *cmd ) 
{ 
  int bool ;
  char *as ;
  config_rec *c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 2333
  bool = -1;
#line 2334
  as = (char *)"ftp";
#line 2335
  c = (config_rec *)((void *)0);
#line 2337
  tmp___3 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 2)) | (1 << 6)) | (1 << 1)) | (1 << 5));
  }
#line 2337
  if (! tmp___3) {
    {
#line 2337
    tmp = get_context_name(cmd);
#line 2337
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2337
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2337
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2337
    return (tmp___2);
  }
#line 2340
  if (cmd->argc < 2) {
    {
#line 2341
    tmp___4 = pstrcat(cmd->tmp_pool, "syntax: ", *(cmd->argv + 0), " on|off [<id to display>]",
                      (void *)0);
#line 2341
    tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___4, (void *)0);
#line 2341
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
    }
#line 2341
    return (tmp___6);
  } else
#line 2340
  if (cmd->argc > 3) {
    {
#line 2341
    tmp___4 = pstrcat(cmd->tmp_pool, "syntax: ", *(cmd->argv + 0), " on|off [<id to display>]",
                      (void *)0);
#line 2341
    tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___4, (void *)0);
#line 2341
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
    }
#line 2341
    return (tmp___6);
  }
  {
#line 2344
  bool = get_boolean(cmd, 1);
  }
#line 2344
  if (bool == -1) {
    {
#line 2345
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected boolean argument",
                      (void *)0);
#line 2345
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2345
    return (tmp___8);
  }
#line 2347
  if (bool == 1) {
#line 2349
    if (cmd->argc > 2) {
#line 2350
      as = *(cmd->argv + 2);
    }
    {
#line 2352
    c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, as);
    }
  } else {
    {
#line 2356
    c = add_config_param_str((char const   *)*(cmd->argv + 0), 0);
    }
  }
  {
#line 2359
  c->flags |= 1L;
#line 2361
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2361
  return (tmp___9);
}
}
#line 2364 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *set_dirfakemode(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *endp ;
  mode_t fake_mode ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2365
  c = (config_rec *)((void *)0);
#line 2366
  endp = (char *)((void *)0);
#line 2369
  if (cmd->argc - 1 < 1) {
    {
#line 2369
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2369
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2369
    return (tmp___0);
  }
  {
#line 2370
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2370
  if (! tmp___5) {
    {
#line 2370
    tmp___1 = get_context_name(cmd);
#line 2370
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2370
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2370
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2370
    return (tmp___4);
  }
  {
#line 2373
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   8);
#line 2373
  fake_mode = (mode_t )tmp___6;
  }
#line 2375
  if (endp) {
#line 2375
    if (*endp) {
      {
#line 2376
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be an octal number",
                        (void *)0);
#line 2376
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2376
      return (tmp___8);
    }
  }
  {
#line 2378
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2379
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(mode_t ));
#line 2380
  *((mode_t *)*(c->argv + 0)) = fake_mode;
#line 2381
  c->flags |= 1L;
#line 2383
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2383
  return (tmp___9);
}
}
#line 2386 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *set_listoptions(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  register unsigned int i___0 ;
  int maxdepth ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  int maxfiles ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int maxdirs ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  modret_t *tmp___26 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 2387
  c = (config_rec *)((void *)0);
#line 2389
  if (cmd->argc - 1 < 1) {
    {
#line 2390
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2390
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2390
    return (tmp___0);
  }
  {
#line 2392
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2392
  if (! tmp___5) {
    {
#line 2392
    tmp___1 = get_context_name(cmd);
#line 2392
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2392
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2392
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2392
    return (tmp___4);
  }
  {
#line 2395
  c = add_config_param((char const   *)*(cmd->argv + 0), 5, (void *)0, (void *)0,
                       (void *)0, (void *)0, (void *)0);
#line 2396
  c->flags |= 1L;
#line 2398
  tmp___6 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 2398
  *(c->argv + 0) = (void *)tmp___6;
#line 2401
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2402
  *((unsigned char *)*(c->argv + 1)) = (unsigned char)0;
#line 2405
  *(c->argv + 2) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2406
  *((unsigned int *)*(c->argv + 2)) = 0U;
#line 2409
  *(c->argv + 3) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2410
  *((unsigned int *)*(c->argv + 3)) = 0U;
#line 2413
  *(c->argv + 4) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2414
  *((unsigned int *)*(c->argv + 4)) = 0U;
  }
#line 2417
  if (cmd->argc - 1 >= 2) {
#line 2418
    i___0 = 0U;
#line 2420
    i___0 = 2U;
    {
#line 2420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2420
      if (! (i___0 < (unsigned int )cmd->argc)) {
#line 2420
        goto while_break;
      }
      {
#line 2422
      tmp___25 = strcasecmp((char const   *)*(cmd->argv + i___0), "strict");
      }
#line 2422
      if (tmp___25 == 0) {
#line 2423
        *((unsigned int *)*(c->argv + 1)) = 1U;
      } else {
        {
#line 2425
        tmp___24 = strcasecmp((char const   *)*(cmd->argv + i___0), "maxdepth");
        }
#line 2425
        if (tmp___24 == 0) {
          {
#line 2426
          i___0 ++;
#line 2426
          tmp___7 = atoi((char const   *)*(cmd->argv + i___0));
#line 2426
          maxdepth = tmp___7;
          }
#line 2428
          if (maxdepth < 1) {
            {
#line 2429
            tmp___8 = pstrcat(cmd->tmp_pool, ": maxdepth must be greater than 0: \'",
                              *(cmd->argv + i___0), "\'", (void *)0);
#line 2429
            tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___8, (void *)0);
#line 2429
            tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___9);
            }
#line 2429
            return (tmp___10);
          }
#line 2433
          *((unsigned int *)*(c->argv + 2)) = (unsigned int )maxdepth;
        } else {
          {
#line 2435
          tmp___23 = strcasecmp((char const   *)*(cmd->argv + i___0), "maxfiles");
          }
#line 2435
          if (tmp___23 == 0) {
            {
#line 2436
            i___0 ++;
#line 2436
            tmp___11 = atoi((char const   *)*(cmd->argv + i___0));
#line 2436
            maxfiles = tmp___11;
            }
#line 2438
            if (maxfiles < 1) {
              {
#line 2439
              tmp___12 = pstrcat(cmd->tmp_pool, ": maxfiles must be greater than 0: \'",
                                 *(cmd->argv + i___0), "\'", (void *)0);
#line 2439
              tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___12,
                                 (void *)0);
#line 2439
              tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___13);
              }
#line 2439
              return (tmp___14);
            }
#line 2443
            *((unsigned int *)*(c->argv + 3)) = (unsigned int )maxfiles;
          } else {
            {
#line 2445
            tmp___22 = strcasecmp((char const   *)*(cmd->argv + i___0), "maxdirs");
            }
#line 2445
            if (tmp___22 == 0) {
              {
#line 2446
              i___0 ++;
#line 2446
              tmp___15 = atoi((char const   *)*(cmd->argv + i___0));
#line 2446
              maxdirs = tmp___15;
              }
#line 2448
              if (maxdirs < 1) {
                {
#line 2449
                tmp___16 = pstrcat(cmd->tmp_pool, ": maxdirs must be greater than 0: \'",
                                   *(cmd->argv + i___0), "\'", (void *)0);
#line 2449
                tmp___17 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___16,
                                   (void *)0);
#line 2449
                tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                          tmp___17);
                }
#line 2449
                return (tmp___18);
              }
#line 2453
              *((unsigned int *)*(c->argv + 4)) = (unsigned int )maxdirs;
            } else {
              {
#line 2456
              tmp___19 = pstrcat(cmd->tmp_pool, ": unknown keyword: \'", *(cmd->argv + i___0),
                                 "\'", (void *)0);
#line 2456
              tmp___20 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___19,
                                 (void *)0);
#line 2456
              tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___20);
              }
#line 2456
              return (tmp___21);
            }
          }
        }
      }
#line 2420
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2462
  tmp___26 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2462
  return (tmp___26);
}
}
#line 2465 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *set_showsymlinks(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2466
  bool = -1;
#line 2467
  c = (config_rec *)((void *)0);
#line 2469
  if (cmd->argc - 1 < 1) {
    {
#line 2469
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2469
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2469
    return (tmp___0);
  }
  {
#line 2470
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2470
  if (! tmp___5) {
    {
#line 2470
    tmp___1 = get_context_name(cmd);
#line 2470
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2470
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2470
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2470
    return (tmp___4);
  }
  {
#line 2472
  bool = get_boolean(cmd, 1);
  }
#line 2472
  if (bool == -1) {
    {
#line 2473
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2473
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2473
    return (tmp___7);
  }
  {
#line 2475
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2476
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2477
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2478
  c->flags |= 1L;
#line 2480
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2480
  return (tmp___8);
}
}
#line 2483 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static modret_t *set_useglobbing(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2484
  bool = -1;
#line 2485
  c = (config_rec *)((void *)0);
#line 2487
  if (cmd->argc - 1 < 1) {
    {
#line 2487
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2487
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2487
    return (tmp___0);
  }
  {
#line 2488
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2488
  if (! tmp___5) {
    {
#line 2488
    tmp___1 = get_context_name(cmd);
#line 2488
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2488
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2488
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2488
    return (tmp___4);
  }
  {
#line 2490
  bool = get_boolean(cmd, 1);
  }
#line 2490
  if (bool == -1) {
    {
#line 2491
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2491
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2491
    return (tmp___7);
  }
  {
#line 2493
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2494
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2495
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2496
  c->flags |= 1L;
#line 2498
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2498
  return (tmp___8);
}
}
#line 2504 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static int ls_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 2507
  pr_help_add("LIST", "[<sp> pathname]", 1);
#line 2508
  pr_help_add("NLST", "[<sp> (pathname)]", 1);
#line 2509
  pr_help_add("STAT", "[<sp> pathname]", 1);
  }
#line 2511
  return (0);
}
}
#line 2517 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static conftable ls_conftab[7]  = {      {(char *)"DirFakeUser", & set_dirfakeusergroup, (module *)((void *)0)}, 
        {(char *)"DirFakeGroup", & set_dirfakeusergroup, (module *)((void *)0)}, 
        {(char *)"DirFakeMode", & set_dirfakemode, (module *)((void *)0)}, 
        {(char *)"ListOptions", & set_listoptions, (module *)((void *)0)}, 
        {(char *)"ShowSymlinks", & set_showsymlinks, (module *)((void *)0)}, 
        {(char *)"UseGlobbing", & set_useglobbing, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)((void *)0)}};
#line 2527 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
static cmdtable ls_cmdtab[9]  = 
#line 2527
  {      {(unsigned char)2, (char *)"NLST", (char *)"DIRS", & ls_nlst, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"LIST", (char *)"DIRS", & ls_list, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"STAT", (char *)"DIRS", & ls_stat, (unsigned char)1,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & ls_post_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)5, (char *)"LIST", (char *)((void *)0), & ls_log_nlst, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)5, (char *)"NLST", (char *)((void *)0), & ls_log_nlst, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"LIST", (char *)((void *)0), & ls_err_nlst, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"NLST", (char *)((void *)0), & ls_err_nlst, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 2539 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_ls.c"
module ls_module  = 
#line 2539
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"ls", ls_conftab, ls_cmdtab,
    (authtable *)((void *)0), & ls_init, (int (*)(void))((void *)0), (char *)0, (void *)0,
    0};
#line 642 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 648
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 74 "../include/pool.h"
array_header *copy_array(pool *p , array_header const   *arr ) ;
#line 75
array_header *copy_array_str(pool *p , array_header const   *arr ) ;
#line 33 "../include/str.h"
char *sreplace(pool *p , char *s  , ...) ;
#line 537 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 546
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 36 "../include/regexp.h"
regex_t *pr_regexp_alloc(void) ;
#line 37
void pr_regexp_free(regex_t *regex ) ;
#line 182 "../include/proftpd.h"
uid_t daemon_uid ;
#line 183
gid_t daemon_gid ;
#line 184
array_header *daemon_gids ;
#line 251
void session_exit(int pri , void *lv , int exitval , void *dummy ) ;
#line 252
void session_set_idle(void) ;
#line 90 "../include/support.h"
void pr_memscrub(void *ptr , size_t ptrlen ) ;
#line 226 "../include/dirtree.h"
config_rec *add_config_param_set(xaset_t **set , char const   *name , int num  , ...) ;
#line 233
int remove_config(xaset_t *set , char const   *name , int recurse ) ;
#line 254
cmd_rec *pr_cmd_alloc(pool *p , int argc  , ...) ;
#line 261
void build_dyn_config(pool *p , char *_path , struct stat *stp , unsigned char recurse ) ;
#line 263
int dir_check_full(pool *pp , char *cmd , char *group , char *path , int *hidden ) ;
#line 269
int login_check_limits(xaset_t *set , int recurse , int and , int *found ) ;
#line 270
char *path_subst_uservar(pool *path_pool , char **path ) ;
#line 271
void resolve_anonymous_dirs(xaset_t *clist ) ;
#line 272
void resolve_deferred_dirs(server_rec *s ) ;
#line 273
void fixup_dirs(server_rec *s , int flags ) ;
#line 50 "../include/expr.h"
array_header *pr_expr_create(pool *p , int *argc , char **argv ) ;
#line 54
int pr_expr_eval_group_and(char **expr ) ;
#line 57
int pr_expr_eval_user_or(char **expr ) ;
#line 186 "../include/modules.h"
void set_auth_check(int (*chk)(cmd_rec * ) ) ;
#line 198
int pr_cmd_dispatch(cmd_rec *cmd ) ;
#line 62 "../include/auth.h"
void pr_auth_setpwent(pool *p ) ;
#line 63
void pr_auth_endpwent(pool *p ) ;
#line 64
void pr_auth_setgrent(pool *p ) ;
#line 65
void pr_auth_endgrent(pool *p ) ;
#line 66
struct passwd *pr_auth_getpwent(pool *p ) ;
#line 67
struct group *pr_auth_getgrent(pool *p ) ;
#line 70
struct group *pr_auth_getgrnam(pool *p , char const   *name ) ;
#line 72
int pr_auth_authenticate(pool *p , char const   *name , char const   *pw ) ;
#line 73
int pr_auth_check(pool *p , char const   *cpw , char const   *name , char const   *pw ) ;
#line 78
int pr_auth_getgroups(pool *p , char const   *name , array_header **group_ids , array_header **group_names ) ;
#line 79
int pr_auth_requires_pass(pool *p , char const   *name ) ;
#line 86
config_rec *pr_auth_get_anon_config(pool *p , char **login_name , char **user_name ,
                                    char **anon_name ) ;
#line 91
int pr_auth_chroot(char const   *path ) ;
#line 97
int pr_auth_banned_by_ftpusers(xaset_t *ctx , char const   *user ) ;
#line 103
int pr_auth_is_valid_shell(xaset_t *ctx , char const   *shell ) ;
#line 116
int set_groups(pool *p , gid_t primary_gid , array_header *suppl_gids ) ;
#line 69 "../include/response.h"
void ( /* format attribute */  pr_response_send_async)(char const   *resp_numeric ,
                                                       char const   *fmt  , ...) ;
#line 109 "../include/log.h"
int log_wtmp(char *line , char const   *name , char const   *host , pr_netaddr_t *ip ) ;
#line 135
void ( /* format attribute */  pr_log_auth)(int priority , char const   *fmt  , ...) ;
#line 33 "../include/xferlog.h"
int xferlog_open(char const   *path ) ;
#line 120 "../include/scoreboard.h"
int pr_open_scoreboard(int flags ) ;
#line 121
int pr_restore_scoreboard(void) ;
#line 122
int pr_rewind_scoreboard(void) ;
#line 128
int pr_scoreboard_entry_add(void) ;
#line 130
pr_scoreboard_entry_t *pr_scoreboard_entry_read(void) ;
#line 132
int pr_scoreboard_entry_update(pid_t pid  , ...) ;
#line 39 "../include/display.h"
int pr_display_fh(struct fh_rec *fh , char const   *fs , char const   *code ) ;
#line 46
int pr_display_file(char const   *path , char const   *fs , char const   *code ) ;
#line 310 "../include/fsio.h"
int pr_fs_interpolate(char const   *path , char *buf___2 , size_t buflen ) ;
#line 321
void pr_resolve_fs_map(void) ;
#line 32 "../include/mkhome.h"
int create_home(pool *p , char const   *home , char const   *user , uid_t uid , gid_t gid ) ;
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static unsigned char mkhome  =    (unsigned char)0;
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static unsigned char authenticated_without_pass  =    (unsigned char)0;
#line 48 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int TimeoutLogin  =    300;
#line 49 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int logged_in  =    0;
#line 50 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int auth_tries  =    0;
#line 51 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static char *auth_pass_resp_code  =    (char *)"230";
#line 52 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static pr_fh_t *displaylogin_fh  =    (pr_fh_t *)((void *)0);
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static unsigned int TimeoutSession  =    0U;
#line 55
static void auth_scan_scoreboard(void) ;
#line 56
static void auth_count_scoreboard(cmd_rec *cmd , char *user ) ;
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int auth_cmd_chk_cb(cmd_rec *cmd ) 
{ 
  unsigned char *authenticated ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 62
  tmp = get_param_ptr((cmd->server)->conf, "authenticated", 0);
#line 62
  authenticated = (unsigned char *)tmp;
  }
#line 65
  if (! authenticated) {
    {
#line 66
    pr_response_send("530", "Please login with USER and PASS");
    }
#line 67
    return (0);
  } else
#line 65
  if ((int )*authenticated == 0) {
    {
#line 66
    pr_response_send("530", "Please login with USER and PASS");
    }
#line 67
    return (0);
  }
#line 70
  return (1);
}
}
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int auth_login_timeout_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                                 void *data ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 78
  pr_event_generate("core.timeout-login", (void const   *)((void *)0));
#line 79
  pr_response_send_async("421", "Login Timeout (%d seconds): closing control connection",
                         TimeoutLogin);
#line 82
  session_exit(5, (void *)"Session timed out, disconnected", 0, (void *)0);
  }
#line 85
  return (0);
}
}
#line 88 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int auth_session_timeout_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                                   void *data ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 89
  pr_event_generate("core.timeout-session", (void const   *)((void *)0));
#line 90
  pr_response_send_async("421", "Session Timeout (%u seconds): closing control connection",
                         TimeoutSession);
#line 94
  session_exit(5, (void *)"FTP session timed out, disconnected", 0, (void *)0);
  }
#line 97
  return (0);
}
}
#line 100 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int auth_sess_init(void) 
{ 
  config_rec *c ;
  unsigned char *tmp ;
  int res ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  time_t tmp___21 ;
  char const   *tmp___22 ;
  void *tmp___23 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 101
  c = (config_rec *)((void *)0);
#line 102
  tmp = (unsigned char *)((void *)0);
#line 103
  res = 0;
#line 106
  c = find_config(main_server->conf, 1 << 15, "TimeoutLogin", 0);
  }
#line 106
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 108
    TimeoutLogin = *((int *)*(c->argv + 0));
  }
#line 111
  if (TimeoutLogin) {
    {
#line 112
    pr_timer_remove(1, & auth_module);
#line 113
    pr_timer_add(TimeoutLogin, 1, & auth_module, & auth_login_timeout_cb, "TimeoutLogin");
    }
  }
  {
#line 117
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
               117);
#line 117
  pr_signals_block();
  }
#line 117
  if (! session.disable_id_switching) {
    {
#line 117
    tmp___2 = seteuid((__uid_t )0);
    }
#line 117
    if (tmp___2) {
      {
#line 117
      tmp___0 = __errno_location();
#line 117
      tmp___1 = strerror(*tmp___0);
#line 117
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___1);
      }
    }
    {
#line 117
    tmp___5 = setegid((__gid_t )0);
    }
#line 117
    if (tmp___5) {
      {
#line 117
      tmp___3 = __errno_location();
#line 117
      tmp___4 = strerror(*tmp___3);
#line 117
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___4);
      }
    }
  } else {
    {
#line 117
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 117
  pr_signals_unblock();
#line 118
  res = pr_open_scoreboard(2);
#line 119
  pr_signals_block();
  }
#line 119
  if (! session.disable_id_switching) {
    {
#line 119
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 119);
#line 119
    tmp___9 = geteuid();
    }
#line 119
    if (tmp___9 != 0U) {
      {
#line 119
      tmp___8 = seteuid((__uid_t )0);
      }
#line 119
      if (tmp___8) {
        {
#line 119
        tmp___6 = __errno_location();
#line 119
        tmp___7 = strerror(*tmp___6);
#line 119
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___7);
        }
      }
    }
    {
#line 119
    tmp___12 = setegid(session.gid);
    }
#line 119
    if (tmp___12) {
      {
#line 119
      tmp___10 = __errno_location();
#line 119
      tmp___11 = strerror(*tmp___10);
#line 119
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___11);
      }
    }
    {
#line 119
    tmp___15 = seteuid(session.uid);
    }
#line 119
    if (tmp___15) {
      {
#line 119
      tmp___13 = __errno_location();
#line 119
      tmp___14 = strerror(*tmp___13);
#line 119
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___14);
      }
    }
  } else {
    {
#line 119
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 119
  pr_signals_unblock();
  }
#line 121
  if (res < 0) {
    {
#line 123
    if (res == -2) {
#line 123
      goto case_neg_2;
    }
#line 127
    if (res == -3) {
#line 127
      goto case_neg_3;
    }
#line 131
    if (res == -4) {
#line 131
      goto case_neg_4;
    }
#line 135
    goto switch_default;
    case_neg_2: /* CIL Label */ 
    {
#line 124
    pr_log_debug(0, "error opening scoreboard: bad/corrupted file");
    }
#line 125
    goto switch_break;
    case_neg_3: /* CIL Label */ 
    {
#line 128
    pr_log_debug(0, "error opening scoreboard: bad version (too old)");
    }
#line 129
    goto switch_break;
    case_neg_4: /* CIL Label */ 
    {
#line 132
    pr_log_debug(0, "error opening scoreboard: bad version (too new)");
    }
#line 133
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 136
    tmp___16 = __errno_location();
#line 136
    tmp___17 = strerror(*tmp___16);
#line 136
    pr_log_debug(0, "error opening scoreboard: %s", tmp___17);
    }
#line 137
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 142
  tmp___20 = pr_scoreboard_entry_add();
  }
#line 142
  if (tmp___20 < 0) {
    {
#line 143
    tmp___18 = __errno_location();
#line 143
    tmp___19 = strerror(*tmp___18);
#line 143
    pr_log_pri(5, "notice: unable to add scoreboard entry: %s", tmp___19);
    }
  }
  {
#line 146
  tmp___21 = time((time_t *)((void *)0));
  }
#line 146
  if (session.class) {
#line 146
    tmp___22 = (char const   *)(session.class)->cls_name;
  } else {
#line 146
    tmp___22 = "";
  }
  {
#line 146
  pr_scoreboard_entry_update(session.pid, 1, "(none)", 8, main_server->ServerPort,
                             9, main_server->addr, main_server->ServerPort, 10, main_server->ServerName,
                             2, (session.c)->remote_addr, 3, (session.c)->remote_name,
                             4, tmp___22, 14, tmp___21, (void *)0);
#line 158
  tmp___23 = get_param_ptr(main_server->conf, "CreateHome", 0);
#line 158
  tmp = (unsigned char *)tmp___23;
  }
#line 159
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 159
    if ((int )*tmp == 1) {
#line 160
      mkhome = (unsigned char)1;
    } else {
#line 162
      mkhome = (unsigned char)0;
    }
  } else {
#line 162
    mkhome = (unsigned char)0;
  }
  {
#line 178
  auth_scan_scoreboard();
  }
#line 180
  return (0);
}
}
#line 183 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int auth_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 186
  pr_help_add("USER", "<sp> username", 1);
#line 187
  pr_help_add("PASS", "<sp> password", 1);
#line 188
  pr_help_add("ACCT", "is not implemented", 0);
#line 189
  pr_help_add("REIN", "is not implemented", 0);
#line 192
  set_auth_check(& auth_cmd_chk_cb);
  }
#line 194
  return (0);
}
}
#line 197 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int _do_auth(pool *p , xaset_t *conf , char *u , char *pw ) 
{ 
  char *cpw ;
  config_rec *c ;
  int tmp ;
  int *tmp___0 ;
  struct passwd *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 198
  cpw = (char *)((void *)0);
#line 201
  if (conf) {
    {
#line 202
    c = find_config(conf, 1 << 15, "UserPassword", 0);
    }
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 204
      if (! c) {
#line 204
        goto while_break;
      }
      {
#line 205
      tmp = strcmp((char const   *)*(c->argv + 0), (char const   *)u);
      }
#line 205
      if (tmp == 0) {
#line 206
        cpw = (char *)*(c->argv + 1);
#line 207
        goto while_break;
      }
      {
#line 210
      c = find_config_next(c, c->next, 1 << 15, "UserPassword", 0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 214
  if (cpw) {
    {
#line 215
    tmp___1 = pr_auth_getpwnam(p, (char const   *)u);
    }
#line 215
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 216
      tmp___0 = __errno_location();
      }
#line 216
      if (*tmp___0 == 2) {
        {
#line 217
        pr_log_pri(5, "no such user \'%s\'", u);
        }
      }
#line 219
      return (-2);
    }
    {
#line 222
    tmp___2 = pr_auth_check(p, (char const   *)cpw, (char const   *)u, (char const   *)pw);
    }
#line 222
    return (tmp___2);
  }
  {
#line 225
  tmp___3 = pr_auth_authenticate(p, (char const   *)u, (char const   *)pw);
  }
#line 225
  return (tmp___3);
}
}
#line 228 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_err_pass(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 237
  remove_config((cmd->server)->conf, "USER", 0);
#line 239
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 239
  return (tmp);
}
}
#line 242 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_log_pass(cmd_rec *cmd ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 248
  if ((unsigned long )session.anon_config != (unsigned long )((void *)0)) {
#line 248
    tmp = "ANON";
  } else {
#line 248
    tmp = "USER";
  }
  {
#line 248
  pr_log_auth(5, "%s %s: Login successful.", tmp, session.user);
  }
#line 251
  return ((modret_t *)((void *)0));
}
}
#line 254 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_post_pass(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *grantmsg ;
  char *user ;
  unsigned int ctxt_precedence ;
  unsigned char have_user_timeout ;
  unsigned char have_group_timeout ;
  unsigned char have_class_timeout ;
  unsigned char have_all_timeout ;
  unsigned char *privsdrop ;
  void *tmp ;
  xaset_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *displaylogin ;
  xaset_t *tmp___13 ;
  void *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *displaylogin___0 ;
  xaset_t *tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  xaset_t *tmp___23 ;
  void *tmp___24 ;
  xaset_t *tmp___25 ;
  void *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;

  {
  {
#line 255
  c = (config_rec *)((void *)0);
#line 256
  grantmsg = (char *)((void *)0);
#line 257
  ctxt_precedence = 0U;
#line 258
  privsdrop = (unsigned char *)((void *)0);
#line 261
  tmp = get_param_ptr((cmd->server)->conf, "USER", 0);
#line 261
  user = (char *)tmp;
#line 267
  auth_count_scoreboard(cmd, session.user);
#line 269
  have_all_timeout = (unsigned char)0;
#line 269
  have_class_timeout = have_all_timeout;
#line 269
  have_group_timeout = have_class_timeout;
#line 269
  have_user_timeout = have_group_timeout;
  }
#line 272
  if (session.anon_config) {
#line 272
    tmp___0 = (session.anon_config)->subset;
  } else {
#line 272
    tmp___0 = main_server->conf;
  }
  {
#line 272
  c = find_config(tmp___0, 1 << 15, "TimeoutSession", 0);
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 273
      goto while_break;
    }
    {
#line 274
    pr_signals_handle();
    }
#line 276
    if (c->argc == 3) {
      {
#line 277
      tmp___6 = strcmp((char const   *)*(c->argv + 1), "user");
      }
#line 277
      if (tmp___6 == 0) {
        {
#line 278
        tmp___1 = pr_expr_eval_user_or((char **)(c->argv + 2));
        }
#line 278
        if (tmp___1 == 1) {
#line 280
          if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 283
            ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 285
            TimeoutSession = *((unsigned int *)*(c->argv + 0));
#line 287
            have_all_timeout = (unsigned char)0;
#line 287
            have_class_timeout = have_all_timeout;
#line 287
            have_group_timeout = have_class_timeout;
#line 288
            have_user_timeout = (unsigned char)1;
          }
        }
      } else {
        {
#line 292
        tmp___5 = strcmp((char const   *)*(c->argv + 1), "group");
        }
#line 292
        if (tmp___5 == 0) {
          {
#line 293
          tmp___2 = pr_expr_eval_group_and((char **)(c->argv + 2));
          }
#line 293
          if (tmp___2 == 1) {
#line 295
            if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 298
              ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 300
              TimeoutSession = *((unsigned int *)*(c->argv + 0));
#line 302
              have_all_timeout = (unsigned char)0;
#line 302
              have_class_timeout = have_all_timeout;
#line 302
              have_user_timeout = have_class_timeout;
#line 303
              have_group_timeout = (unsigned char)1;
            }
          }
        } else {
          {
#line 307
          tmp___4 = strcmp((char const   *)*(c->argv + 1), "class");
          }
#line 307
          if (tmp___4 == 0) {
#line 308
            if (session.class) {
              {
#line 308
              tmp___3 = strcmp((char const   *)(session.class)->cls_name, (char const   *)*(c->argv + 2));
              }
#line 308
              if (tmp___3 == 0) {
#line 311
                if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 314
                  ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 316
                  TimeoutSession = *((unsigned int *)*(c->argv + 0));
#line 318
                  have_all_timeout = (unsigned char)0;
#line 318
                  have_group_timeout = have_all_timeout;
#line 318
                  have_user_timeout = have_group_timeout;
#line 319
                  have_class_timeout = (unsigned char)1;
                }
              }
            }
          }
        }
      }
    } else
#line 326
    if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 329
      ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 331
      TimeoutSession = *((unsigned int *)*(c->argv + 0));
#line 333
      have_class_timeout = (unsigned char)0;
#line 333
      have_group_timeout = have_class_timeout;
#line 333
      have_user_timeout = have_group_timeout;
#line 334
      have_all_timeout = (unsigned char)1;
    }
    {
#line 338
    c = find_config_next(c, c->next, 1 << 15, "TimeoutSession", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if (have_user_timeout) {
#line 347
    goto _L;
  } else
#line 347
  if (have_group_timeout) {
#line 347
    goto _L;
  } else
#line 347
  if (have_class_timeout) {
#line 347
    goto _L;
  } else
#line 347
  if (have_all_timeout) {
    _L: /* CIL Label */ 
#line 349
    if (have_user_timeout) {
#line 349
      tmp___9 = "user";
    } else {
#line 349
      if (have_group_timeout) {
#line 349
        tmp___8 = "group";
      } else {
#line 349
        if (have_class_timeout) {
#line 349
          tmp___7 = "class";
        } else {
#line 349
          tmp___7 = "all";
        }
#line 349
        tmp___8 = tmp___7;
      }
#line 349
      tmp___9 = tmp___8;
    }
    {
#line 349
    pr_log_debug(4, "setting TimeoutSession of %u seconds for current %s", TimeoutSession,
                 tmp___9);
#line 353
    pr_timer_add((int )TimeoutSession, 5, & auth_module, & auth_session_timeout_cb,
                 "TimeoutSession");
    }
  }
#line 358
  if (displaylogin_fh) {
#line 359
    if (! (session.sf_flags & (int volatile   )64)) {
      {
#line 360
      tmp___12 = pr_display_fh(displaylogin_fh, (char const   *)((void *)0), (char const   *)auth_pass_resp_code);
      }
#line 360
      if (tmp___12 < 0) {
        {
#line 361
        tmp___10 = __errno_location();
#line 361
        tmp___11 = strerror(*tmp___10);
#line 361
        pr_log_debug(6, "unable to display DisplayLogin file \'%s\': %s", displaylogin_fh->fh_path,
                     tmp___11);
        }
      }
      {
#line 363
      pr_fsio_close(displaylogin_fh);
#line 364
      displaylogin_fh = (pr_fh_t *)((void *)0);
      }
    } else {
      {
#line 373
      pr_fsio_close(displaylogin_fh);
#line 374
      displaylogin_fh = (pr_fh_t *)((void *)0);
      }
#line 376
      if (session.anon_config) {
#line 376
        tmp___13 = (session.anon_config)->subset;
      } else {
#line 376
        tmp___13 = main_server->conf;
      }
      {
#line 376
      tmp___14 = get_param_ptr(tmp___13, "DisplayLogin", 0);
#line 376
      displaylogin = (char *)tmp___14;
      }
#line 377
      if (displaylogin) {
        {
#line 378
        tmp___17 = pr_display_file((char const   *)displaylogin, (char const   *)((void *)0),
                                   (char const   *)auth_pass_resp_code);
        }
#line 378
        if (tmp___17 < 0) {
          {
#line 379
          tmp___15 = __errno_location();
#line 379
          tmp___16 = strerror(*tmp___15);
#line 379
          pr_log_debug(6, "unable to display DisplayLogin file \'%s\': %s", displaylogin,
                       tmp___16);
          }
        }
      }
    }
  } else {
#line 385
    if (session.anon_config) {
#line 385
      tmp___18 = (session.anon_config)->subset;
    } else {
#line 385
      tmp___18 = main_server->conf;
    }
    {
#line 385
    tmp___19 = get_param_ptr(tmp___18, "DisplayLogin", 0);
#line 385
    displaylogin___0 = (char *)tmp___19;
    }
#line 386
    if (displaylogin___0) {
      {
#line 387
      tmp___22 = pr_display_file((char const   *)displaylogin___0, (char const   *)((void *)0),
                                 (char const   *)auth_pass_resp_code);
      }
#line 387
      if (tmp___22 < 0) {
        {
#line 388
        tmp___20 = __errno_location();
#line 388
        tmp___21 = strerror(*tmp___20);
#line 388
        pr_log_debug(6, "unable to display DisplayLogin file \'%s\': %s", displaylogin___0,
                     tmp___21);
        }
      }
    }
  }
#line 393
  if (session.anon_config) {
#line 393
    tmp___23 = (session.anon_config)->subset;
  } else {
#line 393
    tmp___23 = main_server->conf;
  }
  {
#line 393
  tmp___24 = get_param_ptr(tmp___23, "AccessGrantMsg", 0);
#line 393
  grantmsg = (char *)tmp___24;
  }
#line 394
  if (! grantmsg) {
#line 396
    if (session.sf_flags & (int volatile   )64) {
      {
#line 397
      pr_response_add((char const   *)auth_pass_resp_code, "Anonymous access granted, restrictions apply");
      }
    } else {
      {
#line 400
      pr_response_add((char const   *)auth_pass_resp_code, "User %s logged in", user);
      }
    }
  } else {
    {
#line 404
    grantmsg = sreplace(cmd->tmp_pool, grantmsg, "%u", user, (void *)0);
#line 405
    pr_response_add((char const   *)auth_pass_resp_code, "%s", grantmsg);
    }
  }
#line 408
  if (session.anon_config) {
#line 408
    tmp___25 = (session.anon_config)->subset;
  } else {
#line 408
    tmp___25 = main_server->conf;
  }
  {
#line 408
  tmp___26 = get_param_ptr(tmp___25, "RootRevoke", 0);
#line 408
  privsdrop = (unsigned char *)tmp___26;
  }
#line 409
  if ((unsigned long )privsdrop != (unsigned long )((void *)0)) {
#line 409
    if ((int )*privsdrop == 1) {
      {
#line 411
      pr_signals_block();
#line 412
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                   412);
#line 412
      pr_signals_block();
      }
#line 412
      if (! session.disable_id_switching) {
        {
#line 412
        tmp___29 = seteuid((__uid_t )0);
        }
#line 412
        if (tmp___29) {
          {
#line 412
          tmp___27 = __errno_location();
#line 412
          tmp___28 = strerror(*tmp___27);
#line 412
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___28);
          }
        }
        {
#line 412
        tmp___32 = setegid((__gid_t )0);
        }
#line 412
        if (tmp___32) {
          {
#line 412
          tmp___30 = __errno_location();
#line 412
          tmp___31 = strerror(*tmp___30);
#line 412
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___31);
          }
        }
      } else {
        {
#line 412
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 412
      pr_signals_unblock();
#line 413
      pr_log_debug(9, "REVOKE PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                   413);
#line 413
      pr_signals_block();
#line 413
      tmp___35 = seteuid((__uid_t )0);
      }
#line 413
      if (tmp___35) {
        {
#line 413
        tmp___33 = __errno_location();
#line 413
        tmp___34 = strerror(*tmp___33);
#line 413
        pr_log_pri(3, "PRIVS_REVOKE: unable to seteuid(): %s", tmp___34);
        }
      }
      {
#line 413
      tmp___38 = setgid(session.gid);
      }
#line 413
      if (tmp___38) {
        {
#line 413
        tmp___36 = __errno_location();
#line 413
        tmp___37 = strerror(*tmp___36);
#line 413
        pr_log_pri(3, "PRIVS_REVOKE: unable to setgid(): %s", tmp___37);
        }
      }
      {
#line 413
      tmp___41 = setuid(session.uid);
      }
#line 413
      if (tmp___41) {
        {
#line 413
        tmp___39 = __errno_location();
#line 413
        tmp___40 = strerror(*tmp___39);
#line 413
        pr_log_pri(3, "PRIVS_REVOKE: unable to setuid(): %s", tmp___40);
        }
      }
      {
#line 413
      pr_signals_unblock();
#line 414
      pr_signals_unblock();
#line 417
      session.disable_id_switching = 1;
      }
#line 424
      if ((session.c)->local_port < 1025) {
        {
#line 425
        pr_log_debug(0, "RootRevoke in effect, disabling active transfers");
        }
      }
      {
#line 427
      pr_log_debug(0, "RootRevoke in effect, dropped root privs");
      }
    }
  }
#line 430
  return ((modret_t *)((void *)0));
}
}
#line 437 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static config_rec *_auth_group(pool *p , char *user , char **group , char **ournamep ,
                               char **anonnamep , char *pass ) 
{ 
  config_rec *c ;
  char *ourname ;
  char *anonname ;
  char **grmem ;
  struct group *grp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 441
  ourname = (char *)((void *)0);
#line 441
  anonname = (char *)((void *)0);
#line 445
  tmp = get_param_ptr(main_server->conf, "UserName", 0);
#line 445
  ourname = (char *)tmp;
  }
#line 446
  if (ournamep) {
#line 446
    if (ourname) {
#line 447
      *ournamep = ourname;
    }
  }
  {
#line 449
  c = find_config(main_server->conf, 1 << 15, "GroupPassword", 1);
  }
#line 451
  if (c) {
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 452
      grp = pr_auth_getgrnam(p, (char const   *)*(c->argv + 0));
      }
#line 454
      if (! grp) {
#line 455
        goto __Cont;
      }
#line 457
      grmem = grp->gr_mem;
      {
#line 457
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 457
        if (! *grmem) {
#line 457
          goto while_break___0;
        }
        {
#line 458
        tmp___1 = strcmp((char const   *)*grmem, (char const   *)user);
        }
#line 458
        if (tmp___1 == 0) {
          {
#line 459
          tmp___0 = pr_auth_check(p, (char const   *)*(c->argv + 1), (char const   *)user,
                                  (char const   *)pass);
          }
#line 459
          if (tmp___0 == 0) {
#line 460
            goto while_break___0;
          }
        }
#line 457
        grmem ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 463
      if (*grmem) {
#line 464
        if (group) {
#line 465
          *group = (char *)*(c->argv + 0);
        }
#line 467
        if (c->parent) {
#line 468
          c = c->parent;
        }
#line 470
        if (c->config_type == 1 << 2) {
          {
#line 471
          tmp___2 = get_param_ptr(c->subset, "UserName", 0);
#line 471
          anonname = (char *)tmp___2;
          }
        }
#line 472
        if (anonnamep) {
#line 473
          *anonnamep = anonname;
        }
#line 474
        if (anonnamep) {
#line 474
          if (! anonname) {
#line 474
            if (ourname) {
#line 475
              *anonnamep = ourname;
            }
          }
        }
#line 477
        goto while_break;
      }
      __Cont: /* CIL Label */ 
      {
#line 451
      c = find_config_next(c, c->next, 1 << 15, "GroupPassword", 1);
      }
#line 451
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 451
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 481
  return (c);
}
}
#line 487 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static char *get_default_chdir(pool *p , xaset_t *conf ) 
{ 
  config_rec *c ;
  char *dir ;
  int ret ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 489
  dir = (char *)((void *)0);
#line 492
  c = find_config(conf, 1 << 15, "DefaultChdir", 0);
  }
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! c) {
#line 494
      goto while_break;
    }
#line 496
    if (c->argc < 2) {
#line 497
      dir = (char *)*(c->argv + 0);
#line 498
      goto while_break;
    }
    {
#line 501
    ret = pr_expr_eval_group_and((char **)c->argv + 1);
    }
#line 503
    if (ret) {
#line 504
      dir = (char *)*(c->argv + 0);
#line 505
      goto while_break;
    }
    {
#line 508
    c = find_config_next(c, c->next, 1 << 15, "DefaultChdir", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  if (dir) {
#line 512
    if ((int )*dir != 47) {
#line 512
      if ((int )*dir != 126) {
        {
#line 513
        dir = pdircat(p, session.cwd, dir, (void *)0);
        }
      }
    }
  }
#line 516
  if (dir) {
    {
#line 517
    dir = path_subst_uservar(p, & dir);
    }
  }
#line 519
  return (dir);
}
}
#line 525 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static char *get_default_root(pool *p ) 
{ 
  config_rec *c ;
  char *dir ;
  int ret ;
  char *realdir ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char interp_dir[4097] ;
  char *tmp___19 ;
  int tmp___20 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 526
  c = (config_rec *)((void *)0);
#line 527
  dir = (char *)((void *)0);
#line 530
  c = find_config(main_server->conf, 1 << 15, "DefaultRoot", 0);
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! c) {
#line 532
      goto while_break;
    }
#line 534
    if (c->argc < 2) {
#line 535
      dir = (char *)*(c->argv + 0);
#line 536
      goto while_break;
    }
    {
#line 539
    ret = pr_expr_eval_group_and((char **)c->argv + 1);
    }
#line 541
    if (ret) {
#line 542
      dir = (char *)*(c->argv + 0);
#line 543
      goto while_break;
    }
    {
#line 546
    c = find_config_next(c, c->next, 1 << 15, "DefaultRoot", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  if (dir) {
    {
#line 552
    dir = path_subst_uservar(p, & dir);
#line 554
    tmp___20 = strcmp((char const   *)dir, "/");
    }
#line 554
    if (tmp___20 == 0) {
#line 555
      dir = (char *)((void *)0);
    } else {
      {
#line 559
      xerrno = 0;
#line 567
      pr_log_debug(9, "USER PRIVS %d at %s:%d", (int )session.login_uid, "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                   567);
#line 567
      pr_signals_block();
      }
#line 567
      if (! session.disable_id_switching) {
        {
#line 567
        tmp___1 = seteuid((__uid_t )0);
        }
#line 567
        if (tmp___1) {
          {
#line 567
          tmp = __errno_location();
#line 567
          tmp___0 = strerror(*tmp);
#line 567
          pr_log_pri(3, "PRIVS_USER: unable to seteuid(PR_ROOT_UID): %s", tmp___0);
          }
        }
        {
#line 567
        tmp___4 = setegid(session.login_gid);
        }
#line 567
        if (tmp___4) {
          {
#line 567
          tmp___2 = __errno_location();
#line 567
          tmp___3 = strerror(*tmp___2);
#line 567
          pr_log_pri(3, "PRIVS_USER: unable to setegid(session.login_gid): %s", tmp___3);
          }
        }
        {
#line 567
        tmp___7 = seteuid(session.login_uid);
        }
#line 567
        if (tmp___7) {
          {
#line 567
          tmp___5 = __errno_location();
#line 567
          tmp___6 = strerror(*tmp___5);
#line 567
          pr_log_pri(3, "PRIVS_USER: unable to seteuid(session.login_uid): %s", tmp___6);
          }
        }
      } else {
        {
#line 567
        pr_log_debug(9, "PRIVS_USER: ID switching disabled");
        }
      }
      {
#line 567
      pr_signals_unblock();
#line 568
      realdir = dir_realpath(p, (char const   *)dir);
      }
#line 569
      if (! realdir) {
        {
#line 570
        tmp___8 = __errno_location();
#line 570
        xerrno = *tmp___8;
        }
      }
      {
#line 571
      pr_signals_block();
      }
#line 571
      if (! session.disable_id_switching) {
        {
#line 571
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                     571);
#line 571
        tmp___12 = geteuid();
        }
#line 571
        if (tmp___12 != 0U) {
          {
#line 571
          tmp___11 = seteuid((__uid_t )0);
          }
#line 571
          if (tmp___11) {
            {
#line 571
            tmp___9 = __errno_location();
#line 571
            tmp___10 = strerror(*tmp___9);
#line 571
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___10);
            }
          }
        }
        {
#line 571
        tmp___15 = setegid(session.gid);
        }
#line 571
        if (tmp___15) {
          {
#line 571
          tmp___13 = __errno_location();
#line 571
          tmp___14 = strerror(*tmp___13);
#line 571
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___14);
          }
        }
        {
#line 571
        tmp___18 = seteuid(session.uid);
        }
#line 571
        if (tmp___18) {
          {
#line 571
          tmp___16 = __errno_location();
#line 571
          tmp___17 = strerror(*tmp___16);
#line 571
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___17);
          }
        }
      } else {
        {
#line 571
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 571
      pr_signals_unblock();
      }
#line 573
      if (realdir) {
#line 574
        dir = realdir;
      } else {
        {
#line 580
        memset((void *)(interp_dir), '\000', (size_t )sizeof(interp_dir));
#line 581
        ret = pr_fs_interpolate((char const   *)dir, interp_dir, (size_t )(sizeof(interp_dir) - 1UL));
#line 583
        tmp___19 = strerror(xerrno);
#line 583
        pr_log_pri(5, "notice: unable to use \'%s\' [resolved to \'%s\']: %s", dir,
                   interp_dir, tmp___19);
        }
      }
    }
  }
#line 590
  return (dir);
}
}
#line 593 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static struct passwd *passwd_dup(pool *p , struct passwd *pw ) 
{ 
  struct passwd *npw ;
  void *tmp ;

  {
  {
#line 596
  tmp = pcalloc(p, (int )sizeof(struct passwd ));
#line 596
  npw = (struct passwd *)tmp;
#line 598
  npw->pw_name = pstrdup(p, (char const   *)pw->pw_name);
#line 599
  npw->pw_passwd = pstrdup(p, (char const   *)pw->pw_passwd);
#line 600
  npw->pw_uid = pw->pw_uid;
#line 601
  npw->pw_gid = pw->pw_gid;
#line 602
  npw->pw_gecos = pstrdup(p, (char const   *)pw->pw_gecos);
#line 603
  npw->pw_dir = pstrdup(p, (char const   *)pw->pw_dir);
#line 604
  npw->pw_shell = pstrdup(p, (char const   *)pw->pw_shell);
  }
#line 606
  return (npw);
}
}
#line 609 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static void ensure_open_passwd(pool *p ) 
{ 


  {
  {
#line 612
  pr_auth_setpwent(p);
#line 613
  pr_auth_setgrent(p);
#line 618
  pr_auth_getpwent(p);
#line 619
  pr_auth_getgrent(p);
  }
#line 620
  return;
}
}
#line 625 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static int setup_env(pool *p , char *user , char *pass ) 
{ 
  struct passwd *pw ;
  struct stat sbuf___0 ;
  config_rec *c ;
  config_rec *tmpc ;
  char *origuser ;
  char *ourname ;
  char *anonname ;
  char *anongroup ;
  char *ugroup ;
  char sess_ttyname[20] ;
  unsigned int tmp ;
  char *defaulttransfermode ;
  char *defroot ;
  char *defchdir ;
  char *xferlog ;
  int aclp ;
  int i___0 ;
  int force_anon ;
  int res ;
  int showsymlinks ;
  unsigned char *wtmp_log ;
  unsigned char *anon_require_passwd ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *root_allow ;
  size_t tmp___4 ;
  xaset_t *tmp___5 ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int re_res ;
  regex_t *pw_regex ;
  char errstr[200] ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int auth_code ;
  char *user_name ;
  unsigned char *auth_using_alias ;
  void *tmp___15 ;
  int tmp___16 ;
  xaset_t *tmp___17 ;
  size_t tmp___18 ;
  xaset_t *tmp___19 ;
  xaset_t *tmp___20 ;
  struct group *grp ;
  unsigned char *add_userdir ;
  char *u ;
  void *tmp___21 ;
  void *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  int *tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  __uid_t tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int *tmp___61 ;
  char *tmp___62 ;
  int tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;
  int tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  int *tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  int *tmp___73 ;
  char *tmp___74 ;
  int tmp___75 ;
  int *tmp___76 ;
  char *tmp___77 ;
  int tmp___78 ;
  __uid_t tmp___79 ;
  void *tmp___80 ;
  struct group *grp___0 ;
  char *homedir ;
  int *tmp___81 ;
  char *tmp___82 ;
  int tmp___83 ;
  int *tmp___84 ;
  char *tmp___85 ;
  int tmp___86 ;
  int *tmp___87 ;
  char *tmp___88 ;
  int tmp___89 ;
  int *tmp___90 ;
  char *tmp___91 ;
  int tmp___92 ;
  __uid_t tmp___93 ;
  int *tmp___94 ;
  char *tmp___95 ;
  int tmp___96 ;
  int *tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  xaset_t *tmp___101 ;
  char const   *tmp___102 ;
  xaset_t *tmp___103 ;
  int tmp___104 ;
  __pid_t tmp___105 ;
  void *tmp___106 ;
  void *tmp___107 ;
  int *tmp___108 ;
  char *tmp___109 ;
  int tmp___110 ;
  int *tmp___111 ;
  char *tmp___112 ;
  int tmp___113 ;
  void *tmp___114 ;
  void *tmp___115 ;
  int tmp___116 ;
  int *tmp___117 ;
  char *tmp___118 ;
  int *tmp___119 ;
  char *tmp___120 ;
  int tmp___121 ;
  __uid_t tmp___122 ;
  int *tmp___123 ;
  char *tmp___124 ;
  int tmp___125 ;
  int *tmp___126 ;
  char *tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  char *newcwd ;
  size_t tmp___130 ;
  size_t tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int *tmp___134 ;
  char *tmp___135 ;
  int tmp___136 ;
  int *tmp___137 ;
  char *tmp___138 ;
  int tmp___139 ;
  int *tmp___140 ;
  char *tmp___141 ;
  int tmp___142 ;
  int *tmp___143 ;
  char *tmp___144 ;
  int tmp___145 ;
  int *tmp___146 ;
  char *tmp___147 ;
  int tmp___148 ;
  int *tmp___149 ;
  char *tmp___150 ;
  int tmp___151 ;
  int *tmp___152 ;
  char *tmp___153 ;
  int tmp___154 ;
  int *tmp___155 ;
  char *tmp___156 ;
  int tmp___157 ;
  __uid_t tmp___158 ;
  int tmp___159 ;
  unsigned char *show_symlinks ;
  xaset_t *tmp___160 ;
  void *tmp___161 ;
  char *tmp___162 ;
  int *tmp___163 ;
  char *tmp___164 ;
  int *tmp___165 ;
  char *tmp___166 ;
  int tmp___167 ;
  int *tmp___168 ;
  char *tmp___169 ;
  int *tmp___170 ;
  char *tmp___171 ;
  int tmp___172 ;
  int *tmp___173 ;
  char *tmp___174 ;
  int tmp___175 ;
  char const   *tmp___176 ;
  char const   *tmp___177 ;
  int tmp___178 ;
  void *tmp___179 ;
  int tmp___180 ;
  size_t tmp___181 ;
  void *__cil_tmp222 ;
  void *__cil_tmp223 ;
  void *__cil_tmp224 ;
  void *__cil_tmp225 ;
  void *__cil_tmp226 ;
  void *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;

  {
#line 629
  anonname = (char *)((void *)0);
#line 629
  anongroup = (char *)((void *)0);
#line 629
  ugroup = (char *)((void *)0);
#line 630
  sess_ttyname[0] = (char )'\000';
#line 630
  tmp = 1U;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (tmp >= 20U) {
#line 630
      goto while_break;
    }
#line 630
    sess_ttyname[tmp] = (char)0;
#line 630
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 631
  defroot = (char *)((void *)0);
#line 631
  defchdir = (char *)((void *)0);
#line 631
  xferlog = (char *)((void *)0);
#line 632
  force_anon = 0;
#line 632
  res = 0;
#line 633
  wtmp_log = (unsigned char *)((void *)0);
#line 633
  anon_require_passwd = (unsigned char *)((void *)0);
#line 637
  session.hide_password = 1;
#line 639
  origuser = user;
#line 640
  c = pr_auth_get_anon_config(p, & user, & ourname, & anonname);
  }
#line 642
  if (c) {
#line 643
    session.anon_config = c;
  }
#line 645
  if (! user) {
    {
#line 646
    tmp___0 = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 646
    tmp___1 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 646
    pr_log_auth(5, "USER %s: user is not a UserAlias from %s [%s] to %s:%i", origuser,
                (session.c)->remote_name, tmp___1, tmp___0, (session.c)->local_port);
    }
#line 650
    goto auth_failure;
  }
  {
#line 653
  pw = pr_auth_getpwnam(p, (char const   *)user);
  }
#line 654
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 655
    tmp___2 = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 655
    tmp___3 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 655
    pr_log_auth(5, "USER %s: no such user found from %s [%s] to %s:%i", user, (session.c)->remote_name,
                tmp___3, tmp___2, (session.c)->local_port);
    }
#line 660
    goto auth_failure;
  }
  {
#line 666
  pw = passwd_dup(p, pw);
  }
#line 668
  if (pw->pw_uid == 0U) {
    {
#line 669
    root_allow = (unsigned char *)((void *)0);
#line 671
    pr_event_generate("mod_auth.root-login", (void const   *)((void *)0));
    }
#line 676
    if (c) {
#line 676
      tmp___5 = c->subset;
    } else {
#line 676
      tmp___5 = main_server->conf;
    }
    {
#line 676
    tmp___6 = get_param_ptr(tmp___5, "RootLogin", 0);
#line 676
    root_allow = (unsigned char *)tmp___6;
    }
#line 676
    if ((unsigned long )root_allow == (unsigned long )((void *)0)) {
#line 676
      goto _L;
    } else
#line 676
    if ((int )*root_allow != 1) {
      _L: /* CIL Label */ 
#line 678
      if (pass) {
        {
#line 679
        tmp___4 = strlen((char const   *)pass);
#line 679
        pr_memscrub((void *)pass, tmp___4);
        }
      }
      {
#line 680
      pr_log_auth(2, "SECURITY VIOLATION: root login attempted.");
      }
#line 681
      return (0);
    }
  }
  {
#line 685
  session.user = pstrdup(p, (char const   *)pw->pw_name);
#line 686
  tmp___7 = pr_auth_gid2name(p, pw->pw_gid);
#line 686
  session.group = pstrdup(p, tmp___7);
#line 689
  session.login_uid = pw->pw_uid;
#line 690
  session.login_gid = pw->pw_gid;
#line 693
  pw->pw_dir = path_subst_uservar(p, & pw->pw_dir);
#line 703
  tmp___8 = strcmp((char const   *)pw->pw_name, (char const   *)user);
  }
#line 703
  if (tmp___8 != 0) {
    {
#line 704
    pr_log_debug(10, "local user name \'%s\' differs from client-sent user name \'%s\', clearing cached group data",
                 pw->pw_name, user);
#line 706
    session.gids = (array_header *)((void *)0);
#line 707
    session.groups = (array_header *)((void *)0);
    }
  }
#line 710
  if (! session.gids) {
#line 710
    if (! session.groups) {
      {
#line 719
      res = pr_auth_getgroups(p, (char const   *)pw->pw_name, & session.gids, & session.groups);
      }
#line 720
      if (res < 1) {
        {
#line 721
        pr_log_debug(2, "no supplemental groups found for user \'%s\'", pw->pw_name);
        }
      }
    }
  }
  {
#line 727
  aclp = login_check_limits(main_server->conf, 0, 1, & i___0);
  }
#line 732
  if (c) {
#line 732
    if (c->config_type != 1 << 2) {
      {
#line 733
      force_anon = 1;
#line 735
      defroot = get_default_root(session.pool);
      }
#line 736
      if (! defroot) {
        {
#line 737
        defroot = pstrdup(session.pool, (char const   *)pw->pw_dir);
        }
      }
      {
#line 739
      tmp___9 = pcalloc(session.pool, (int )sizeof(config_rec ));
#line 739
      c = (config_rec *)tmp___9;
#line 740
      c->config_type = 1 << 2;
#line 741
      c->name = defroot;
#line 743
      anonname = pw->pw_name;
#line 748
      c->subset = main_server->conf;
      }
    }
  }
#line 751
  if (c) {
#line 752
    if (! force_anon) {
      {
#line 753
      tmp___10 = get_param_ptr(c->subset, "GroupName", 0);
#line 753
      anongroup = (char *)tmp___10;
      }
#line 754
      if (! anongroup) {
        {
#line 755
        tmp___11 = get_param_ptr(main_server->conf, "GroupName", 0);
#line 755
        anongroup = (char *)tmp___11;
        }
      }
    }
    {
#line 762
    tmpc = find_config(c->subset, 1 << 15, "AnonRejectPasswords", 0);
    }
#line 762
    if ((unsigned long )tmpc != (unsigned long )((void *)0)) {
#line 765
      pw_regex = (regex_t *)*(tmpc->argv + 0);
#line 767
      if (pw_regex) {
#line 767
        if (pass) {
          {
#line 767
          re_res = regexec((regex_t const   */* __restrict  */)pw_regex, (char const   */* __restrict  */)pass,
                           (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                           0);
          }
#line 767
          if (re_res == 0) {
#line 769
            errstr[0] = (char )'\000';
#line 769
            tmp___12 = 1U;
            {
#line 769
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 769
              if (tmp___12 >= 200U) {
#line 769
                goto while_break___0;
              }
#line 769
              errstr[tmp___12] = (char)0;
#line 769
              tmp___12 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 771
            regerror(re_res, (regex_t const   */* __restrict  */)pw_regex, (char */* __restrict  */)(errstr),
                     (size_t )sizeof(errstr));
#line 772
            pr_log_auth(5, "ANON %s: AnonRejectPasswords denies login", origuser);
#line 775
            pr_event_generate("mod_auth.anon-reject-passwords", (void const   *)session.c);
            }
#line 776
            goto auth_failure;
          }
        }
      }
    }
    {
#line 781
    tmp___13 = login_check_limits(c->subset, 0, 1, & i___0);
    }
#line 781
    if (tmp___13) {
#line 781
      if (! aclp) {
#line 781
        if (! i___0) {
          {
#line 782
          pr_log_auth(5, "ANON %s (Login failed): Limit access denies login.", origuser);
          }
#line 784
          goto auth_failure;
        }
      }
    } else {
      {
#line 782
      pr_log_auth(5, "ANON %s (Login failed): Limit access denies login.", origuser);
      }
#line 784
      goto auth_failure;
    }
  }
#line 788
  if (! c) {
#line 788
    if (! aclp) {
      {
#line 789
      pr_log_auth(5, "USER %s (Login failed): Limit access denies login", origuser);
      }
#line 791
      goto auth_failure;
    }
  }
#line 794
  if (c) {
    {
#line 795
    tmp___14 = get_param_ptr(c->subset, "AnonRequirePassword", 0);
#line 795
    anon_require_passwd = (unsigned char *)tmp___14;
    }
  }
#line 799
  if (! c) {
#line 799
    goto _L___0;
  } else
#line 799
  if (anon_require_passwd) {
#line 799
    if ((int )*anon_require_passwd == 1) {
      _L___0: /* CIL Label */ 
#line 802
      user_name = user;
#line 804
      if (c) {
#line 804
        if (origuser) {
          {
#line 804
          tmp___16 = strcasecmp((char const   *)user, (char const   *)origuser);
          }
#line 804
          if (tmp___16 != 0) {
            {
#line 807
            tmp___15 = get_param_ptr(c->subset, "AuthUsingAlias", 0);
#line 807
            auth_using_alias = (unsigned char *)tmp___15;
            }
#line 813
            if (auth_using_alias) {
#line 813
              if ((int )*auth_using_alias == 1) {
                {
#line 815
                user_name = origuser;
#line 816
                pr_log_auth(5, "ANON AUTH: User %s, authenticating using alias %s",
                            user, user_name);
                }
              }
            }
          }
        }
      }
#line 826
      if (! authenticated_without_pass) {
#line 827
        if (c) {
#line 827
          tmp___17 = c->subset;
        } else {
#line 827
          tmp___17 = main_server->conf;
        }
        {
#line 827
        auth_code = _do_auth(p, tmp___17, user_name, pass);
        }
      } else {
#line 831
        auth_code = 3;
      }
      {
#line 834
      pr_event_generate("mod_auth.authentication-code", (void const   *)(& auth_code));
      }
#line 836
      if (auth_code < 0) {
        {
#line 841
        c = _auth_group(p, user, & anongroup, & ourname, & anonname, pass);
        }
#line 842
        if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 843
          if (c->config_type != 1 << 2) {
#line 844
            c = (config_rec *)((void *)0);
#line 845
            ugroup = anongroup;
#line 846
            anongroup = (char *)((void *)0);
          }
#line 849
          auth_code = 0;
        }
      }
#line 853
      if (pass) {
        {
#line 854
        tmp___18 = strlen((char const   *)pass);
#line 854
        pr_memscrub((void *)pass, tmp___18);
        }
      }
#line 856
      if (session.auth_mech) {
        {
#line 857
        pr_log_debug(2, "user \'%s\' authenticated by %s", user, session.auth_mech);
        }
      }
      {
#line 861
      if (auth_code == 3) {
#line 861
        goto case_3;
      }
#line 865
      if (auth_code == 0) {
#line 865
        goto case_0;
      }
#line 869
      if (auth_code == -2) {
#line 869
        goto case_neg_2;
      }
#line 874
      if (auth_code == -3) {
#line 874
        goto case_neg_3;
      }
#line 879
      if (auth_code == -4) {
#line 879
        goto case_neg_4;
      }
#line 884
      if (auth_code == -5) {
#line 884
        goto case_neg_5;
      }
#line 889
      goto switch_default;
      case_3: /* CIL Label */ 
#line 862
      auth_pass_resp_code = (char *)"232";
#line 863
      goto switch_break;
      case_0: /* CIL Label */ 
#line 866
      auth_pass_resp_code = (char *)"230";
#line 867
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 870
      pr_log_auth(5, "USER %s (Login failed): No such user found.", user);
      }
#line 872
      goto auth_failure;
      case_neg_3: /* CIL Label */ 
      {
#line 875
      pr_log_auth(5, "USER %s (Login failed): Incorrect password.", origuser);
      }
#line 877
      goto auth_failure;
      case_neg_4: /* CIL Label */ 
      {
#line 880
      pr_log_auth(5, "USER %s (Login failed): Password expired.", user);
      }
#line 882
      goto auth_failure;
      case_neg_5: /* CIL Label */ 
      {
#line 885
      pr_log_auth(5, "USER %s (Login failed): Account disabled.", user);
      }
#line 887
      goto auth_failure;
      switch_default: /* CIL Label */ 
#line 890
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 894
      if (auth_code < 0) {
#line 895
        goto auth_failure;
      }
#line 897
      if (pw->pw_uid == 0U) {
        {
#line 898
        pr_log_auth(4, "ROOT FTP login successful.");
        }
      }
    } else {
#line 799
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 900
  if (c) {
#line 900
    if (! anon_require_passwd) {
#line 901
      session.hide_password = 0;
    } else
#line 900
    if ((int )*anon_require_passwd == 0) {
#line 901
      session.hide_password = 0;
    }
  }
  {
#line 904
  pr_auth_setgrent(p);
  }
#line 906
  if (c) {
#line 906
    tmp___19 = c->subset;
  } else {
#line 906
    tmp___19 = main_server->conf;
  }
  {
#line 906
  res = pr_auth_is_valid_shell(tmp___19, (char const   *)pw->pw_shell);
  }
#line 908
  if (res == 0) {
    {
#line 909
    pr_log_auth(5, "USER %s (Login failed): Invalid shell: \'%s\'", user, pw->pw_shell);
    }
#line 911
    goto auth_failure;
  }
#line 914
  if (c) {
#line 914
    tmp___20 = c->subset;
  } else {
#line 914
    tmp___20 = main_server->conf;
  }
  {
#line 914
  res = pr_auth_banned_by_ftpusers(tmp___20, (char const   *)pw->pw_name);
  }
#line 916
  if (res == 1) {
    {
#line 917
    pr_log_auth(5, "USER %s (Login failed): User in /etc/ftpusers", user);
    }
#line 919
    goto auth_failure;
  }
#line 922
  if (c) {
    {
#line 923
    grp = (struct group *)((void *)0);
#line 924
    add_userdir = (unsigned char *)((void *)0);
#line 925
    tmp___21 = get_param_ptr(main_server->conf, "USER", 0);
#line 925
    u = (char *)tmp___21;
#line 927
    tmp___22 = get_param_ptr(c->subset, "UserDirRoot", 0);
#line 927
    add_userdir = (unsigned char *)tmp___22;
#line 935
    pr_signals_block();
#line 937
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 937);
#line 937
    pr_signals_block();
    }
#line 937
    if (! session.disable_id_switching) {
      {
#line 937
      tmp___25 = seteuid((__uid_t )0);
      }
#line 937
      if (tmp___25) {
        {
#line 937
        tmp___23 = __errno_location();
#line 937
        tmp___24 = strerror(*tmp___23);
#line 937
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___24);
        }
      }
      {
#line 937
      tmp___28 = setegid((__gid_t )0);
      }
#line 937
      if (tmp___28) {
        {
#line 937
        tmp___26 = __errno_location();
#line 937
        tmp___27 = strerror(*tmp___26);
#line 937
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___27);
        }
      }
    } else {
      {
#line 937
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 937
    pr_signals_unblock();
#line 938
    res = set_groups(p, pw->pw_gid, session.gids);
    }
#line 939
    if (res < 0) {
      {
#line 940
      tmp___29 = __errno_location();
#line 940
      tmp___30 = strerror(*tmp___29);
#line 940
      pr_log_pri(3, "error: unable to set groups: %s", tmp___30);
      }
    }
    {
#line 949
    setuid((__uid_t )0);
#line 950
    setgid((__gid_t )0);
#line 954
    pr_log_debug(9, "SETUP PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 954);
#line 954
    pr_signals_block();
#line 954
    tmp___49 = getuid();
    }
#line 954
    if (tmp___49 != 0U) {
      {
#line 954
      session.uid = getuid();
#line 954
      session.ouid = session.uid;
#line 954
      session.gid = getgid();
#line 954
      tmp___33 = setgid(session.gid);
      }
#line 954
      if (tmp___33) {
        {
#line 954
        tmp___31 = __errno_location();
#line 954
        tmp___32 = strerror(*tmp___31);
#line 954
        pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___32);
        }
      }
      {
#line 954
      tmp___36 = setuid(session.uid);
      }
#line 954
      if (tmp___36) {
        {
#line 954
        tmp___34 = __errno_location();
#line 954
        tmp___35 = strerror(*tmp___34);
#line 954
        pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___35);
        }
      }
      {
#line 954
      tmp___39 = seteuid(session.uid);
      }
#line 954
      if (tmp___39) {
        {
#line 954
        tmp___37 = __errno_location();
#line 954
        tmp___38 = strerror(*tmp___37);
#line 954
        pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___38);
        }
      }
    } else {
      {
#line 954
      session.ouid = getuid();
#line 954
      session.uid = pw->pw_uid;
#line 954
      session.gid = pw->pw_gid;
#line 954
      tmp___42 = setuid((__uid_t )0);
      }
#line 954
      if (tmp___42) {
        {
#line 954
        tmp___40 = __errno_location();
#line 954
        tmp___41 = strerror(*tmp___40);
#line 954
        pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___41);
        }
      }
      {
#line 954
      tmp___45 = setgid(pw->pw_gid);
      }
#line 954
      if (tmp___45) {
        {
#line 954
        tmp___43 = __errno_location();
#line 954
        tmp___44 = strerror(*tmp___43);
#line 954
        pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___44);
        }
      }
      {
#line 954
      tmp___48 = seteuid(pw->pw_uid);
      }
#line 954
      if (tmp___48) {
        {
#line 954
        tmp___46 = __errno_location();
#line 954
        tmp___47 = strerror(*tmp___46);
#line 954
        pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___47);
        }
      }
    }
    {
#line 954
    pr_signals_unblock();
    }
#line 956
    if (add_userdir) {
#line 956
      if ((int )*add_userdir == 1) {
        {
#line 956
        tmp___51 = strcmp((char const   *)u, (char const   *)user);
        }
#line 956
        if (tmp___51 != 0) {
          {
#line 958
          tmp___50 = pdircat(p, c->name, u, (void *)0);
#line 958
          session.chroot_path = dir_realpath(p, (char const   *)tmp___50);
          }
        } else {
          {
#line 961
          session.chroot_path = dir_realpath(p, (char const   *)c->name);
          }
        }
      } else {
        {
#line 961
        session.chroot_path = dir_realpath(p, (char const   *)c->name);
        }
      }
    } else {
      {
#line 961
      session.chroot_path = dir_realpath(p, (char const   *)c->name);
      }
    }
#line 964
    if (session.chroot_path) {
      {
#line 964
      tmp___52 = pr_fsio_access((char const   *)session.chroot_path, 1, session.uid,
                                session.gid, session.gids);
      }
#line 964
      if (tmp___52 != 0) {
#line 967
        session.chroot_path = (char *)((void *)0);
      } else {
        {
#line 970
        session.chroot_path = pstrdup(session.pool, (char const   *)session.chroot_path);
        }
      }
    } else {
      {
#line 970
      session.chroot_path = pstrdup(session.pool, (char const   *)session.chroot_path);
      }
    }
    {
#line 974
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 974);
#line 974
    pr_signals_block();
    }
#line 974
    if (! session.disable_id_switching) {
      {
#line 974
      tmp___55 = seteuid((__uid_t )0);
      }
#line 974
      if (tmp___55) {
        {
#line 974
        tmp___53 = __errno_location();
#line 974
        tmp___54 = strerror(*tmp___53);
#line 974
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___54);
        }
      }
      {
#line 974
      tmp___58 = setegid((__gid_t )0);
      }
#line 974
      if (tmp___58) {
        {
#line 974
        tmp___56 = __errno_location();
#line 974
        tmp___57 = strerror(*tmp___56);
#line 974
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___57);
        }
      }
    } else {
      {
#line 974
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 974
    pr_signals_unblock();
#line 975
    res = set_groups(p, daemon_gid, daemon_gids);
    }
#line 976
    if (res < 0) {
      {
#line 977
      tmp___59 = __errno_location();
#line 977
      tmp___60 = strerror(*tmp___59);
#line 977
      pr_log_pri(3, "error: unable to set groups: %s", tmp___60);
      }
    }
    {
#line 986
    setuid((__uid_t )0);
#line 987
    setgid((__gid_t )0);
#line 991
    pr_log_debug(9, "SETUP PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 991);
#line 991
    pr_signals_block();
#line 991
    tmp___79 = getuid();
    }
#line 991
    if (tmp___79 != 0U) {
      {
#line 991
      session.uid = getuid();
#line 991
      session.ouid = session.uid;
#line 991
      session.gid = getgid();
#line 991
      tmp___63 = setgid(session.gid);
      }
#line 991
      if (tmp___63) {
        {
#line 991
        tmp___61 = __errno_location();
#line 991
        tmp___62 = strerror(*tmp___61);
#line 991
        pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___62);
        }
      }
      {
#line 991
      tmp___66 = setuid(session.uid);
      }
#line 991
      if (tmp___66) {
        {
#line 991
        tmp___64 = __errno_location();
#line 991
        tmp___65 = strerror(*tmp___64);
#line 991
        pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___65);
        }
      }
      {
#line 991
      tmp___69 = seteuid(session.uid);
      }
#line 991
      if (tmp___69) {
        {
#line 991
        tmp___67 = __errno_location();
#line 991
        tmp___68 = strerror(*tmp___67);
#line 991
        pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___68);
        }
      }
    } else {
      {
#line 991
      session.ouid = getuid();
#line 991
      session.uid = daemon_uid;
#line 991
      session.gid = daemon_gid;
#line 991
      tmp___72 = setuid((__uid_t )0);
      }
#line 991
      if (tmp___72) {
        {
#line 991
        tmp___70 = __errno_location();
#line 991
        tmp___71 = strerror(*tmp___70);
#line 991
        pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___71);
        }
      }
      {
#line 991
      tmp___75 = setgid(daemon_gid);
      }
#line 991
      if (tmp___75) {
        {
#line 991
        tmp___73 = __errno_location();
#line 991
        tmp___74 = strerror(*tmp___73);
#line 991
        pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___74);
        }
      }
      {
#line 991
      tmp___78 = seteuid(daemon_uid);
      }
#line 991
      if (tmp___78) {
        {
#line 991
        tmp___76 = __errno_location();
#line 991
        tmp___77 = strerror(*tmp___76);
#line 991
        pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___77);
        }
      }
    }
    {
#line 991
    pr_signals_unblock();
#line 993
    pr_signals_unblock();
    }
#line 1009
    if (anon_require_passwd) {
#line 1009
      if ((int )*anon_require_passwd == 1) {
        {
#line 1011
        session.anon_user = pstrdup(session.pool, (char const   *)origuser);
        }
      } else {
        {
#line 1014
        session.anon_user = pstrdup(session.pool, (char const   *)pass);
        }
      }
    } else {
      {
#line 1014
      session.anon_user = pstrdup(session.pool, (char const   *)pass);
      }
    }
#line 1017
    if (! session.chroot_path) {
      {
#line 1018
      pr_log_pri(3, "%s: Directory %s is not accessible.", session.user, c->name);
#line 1020
      pr_response_add_err("530", "Unable to set anonymous privileges.");
      }
#line 1021
      goto auth_failure;
    }
    {
#line 1024
    sstrncpy(session.cwd, "/", (size_t )sizeof(session.cwd));
#line 1025
    tmp___80 = get_param_ptr(c->subset, "TransferLog", 0);
#line 1025
    xferlog = (char *)tmp___80;
    }
#line 1027
    if (anongroup) {
      {
#line 1028
      grp = pr_auth_getgrnam(p, (char const   *)anongroup);
      }
#line 1029
      if (grp) {
        {
#line 1030
        pw->pw_gid = grp->gr_gid;
#line 1031
        session.group = pstrdup(p, (char const   *)grp->gr_name);
        }
      }
    }
  } else {
#line 1039
    if (ugroup) {
      {
#line 1040
      grp___0 = pr_auth_getgrnam(p, (char const   *)ugroup);
      }
#line 1041
      if (grp___0) {
        {
#line 1042
        pw->pw_gid = grp___0->gr_gid;
#line 1043
        session.group = pstrdup(p, (char const   *)grp___0->gr_name);
        }
      }
    }
    {
#line 1048
    pr_log_debug(9, "USER PRIVS %d at %s:%d", (int )session.login_uid, "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 1048);
#line 1048
    pr_signals_block();
    }
#line 1048
    if (! session.disable_id_switching) {
      {
#line 1048
      tmp___83 = seteuid((__uid_t )0);
      }
#line 1048
      if (tmp___83) {
        {
#line 1048
        tmp___81 = __errno_location();
#line 1048
        tmp___82 = strerror(*tmp___81);
#line 1048
        pr_log_pri(3, "PRIVS_USER: unable to seteuid(PR_ROOT_UID): %s", tmp___82);
        }
      }
      {
#line 1048
      tmp___86 = setegid(session.login_gid);
      }
#line 1048
      if (tmp___86) {
        {
#line 1048
        tmp___84 = __errno_location();
#line 1048
        tmp___85 = strerror(*tmp___84);
#line 1048
        pr_log_pri(3, "PRIVS_USER: unable to setegid(session.login_gid): %s", tmp___85);
        }
      }
      {
#line 1048
      tmp___89 = seteuid(session.login_uid);
      }
#line 1048
      if (tmp___89) {
        {
#line 1048
        tmp___87 = __errno_location();
#line 1048
        tmp___88 = strerror(*tmp___87);
#line 1048
        pr_log_pri(3, "PRIVS_USER: unable to seteuid(session.login_uid): %s", tmp___88);
        }
      }
    } else {
      {
#line 1048
      pr_log_debug(9, "PRIVS_USER: ID switching disabled");
      }
    }
    {
#line 1048
    pr_signals_unblock();
#line 1049
    homedir = dir_realpath(p, (char const   *)pw->pw_dir);
#line 1050
    pr_signals_block();
    }
#line 1050
    if (! session.disable_id_switching) {
      {
#line 1050
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                   1050);
#line 1050
      tmp___93 = geteuid();
      }
#line 1050
      if (tmp___93 != 0U) {
        {
#line 1050
        tmp___92 = seteuid((__uid_t )0);
        }
#line 1050
        if (tmp___92) {
          {
#line 1050
          tmp___90 = __errno_location();
#line 1050
          tmp___91 = strerror(*tmp___90);
#line 1050
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___91);
          }
        }
      }
      {
#line 1050
      tmp___96 = setegid(session.gid);
      }
#line 1050
      if (tmp___96) {
        {
#line 1050
        tmp___94 = __errno_location();
#line 1050
        tmp___95 = strerror(*tmp___94);
#line 1050
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___95);
        }
      }
      {
#line 1050
      tmp___99 = seteuid(session.uid);
      }
#line 1050
      if (tmp___99) {
        {
#line 1050
        tmp___97 = __errno_location();
#line 1050
        tmp___98 = strerror(*tmp___97);
#line 1050
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___98);
        }
      }
    } else {
      {
#line 1050
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 1050
    pr_signals_unblock();
    }
#line 1052
    if (homedir) {
      {
#line 1053
      sstrncpy(session.cwd, (char const   *)homedir, (size_t )sizeof(session.cwd));
      }
    } else {
      {
#line 1055
      sstrncpy(session.cwd, (char const   *)pw->pw_dir, (size_t )sizeof(session.cwd));
      }
    }
  }
#line 1060
  if (! c) {
#line 1060
    if (mkhome) {
      {
#line 1061
      tmp___100 = create_home(p, (char const   *)(session.cwd), (char const   *)origuser,
                              pw->pw_uid, pw->pw_gid);
      }
#line 1061
      if (tmp___100 < 0) {
#line 1064
        goto auth_failure;
      }
    }
  }
#line 1069
  if (c) {
#line 1069
    tmp___101 = c->subset;
  } else {
#line 1069
    tmp___101 = main_server->conf;
  }
  {
#line 1069
  defchdir = get_default_chdir(p, tmp___101);
  }
#line 1071
  if (defchdir) {
    {
#line 1072
    sstrncpy(session.cwd, (char const   *)defchdir, (size_t )sizeof(session.cwd));
    }
  }
#line 1078
  if (c) {
#line 1078
    tmp___103 = c->subset;
  } else {
#line 1078
    tmp___103 = main_server->conf;
  }
  {
#line 1078
  tmp___104 = login_check_limits(tmp___103, 0, 1, & i___0);
  }
#line 1078
  if (! tmp___104) {
#line 1080
    if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1080
      tmp___102 = "ANON";
    } else {
#line 1080
      tmp___102 = "USER";
    }
    {
#line 1080
    pr_log_auth(5, "%s %s: Limit access denies login.", tmp___102, origuser);
    }
#line 1082
    goto auth_failure;
  }
  {
#line 1086
  resolve_deferred_dirs(main_server);
#line 1087
  fixup_dirs(main_server, 1 << 3);
  }
#line 1092
  if (c) {
#line 1092
    if (c->subset) {
      {
#line 1093
      resolve_anonymous_dirs(c->subset);
      }
    }
  }
  {
#line 1104
  tmp___105 = getpid();
#line 1104
  snprintf((char */* __restrict  */)(sess_ttyname), (size_t )sizeof(sess_ttyname),
           (char const   */* __restrict  */)"ftpd%d", tmp___105);
  }
#line 1110
  if (c) {
    {
#line 1111
    tmp___106 = get_param_ptr(c->subset, "WtmpLog", 0);
#line 1111
    wtmp_log = (unsigned char *)tmp___106;
    }
  }
#line 1113
  if ((unsigned long )wtmp_log == (unsigned long )((void *)0)) {
    {
#line 1114
    tmp___107 = get_param_ptr(main_server->conf, "WtmpLog", 0);
#line 1114
    wtmp_log = (unsigned char *)tmp___107;
    }
  }
  {
#line 1116
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
               1116);
#line 1116
  pr_signals_block();
  }
#line 1116
  if (! session.disable_id_switching) {
    {
#line 1116
    tmp___110 = seteuid((__uid_t )0);
    }
#line 1116
    if (tmp___110) {
      {
#line 1116
      tmp___108 = __errno_location();
#line 1116
      tmp___109 = strerror(*tmp___108);
#line 1116
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___109);
      }
    }
    {
#line 1116
    tmp___113 = setegid((__gid_t )0);
    }
#line 1116
    if (tmp___113) {
      {
#line 1116
      tmp___111 = __errno_location();
#line 1116
      tmp___112 = strerror(*tmp___111);
#line 1116
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___112);
      }
    }
  } else {
    {
#line 1116
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 1116
  pr_signals_unblock();
  }
#line 1118
  if (! wtmp_log) {
    {
#line 1119
    log_wtmp(sess_ttyname, (char const   *)session.user, (session.c)->remote_name,
             (session.c)->remote_addr);
#line 1121
    session.wtmp_log = 1;
    }
  } else
#line 1118
  if ((int )*wtmp_log == 1) {
    {
#line 1119
    log_wtmp(sess_ttyname, (char const   *)session.user, (session.c)->remote_name,
             (session.c)->remote_addr);
#line 1121
    session.wtmp_log = 1;
    }
  }
#line 1131
  if (! xferlog) {
#line 1132
    if (c) {
      {
#line 1133
      tmp___114 = get_param_ptr(c->subset, "TransferLog", 0);
#line 1133
      xferlog = (char *)tmp___114;
      }
    }
#line 1135
    if (! xferlog) {
      {
#line 1136
      tmp___115 = get_param_ptr(main_server->conf, "TransferLog", 0);
#line 1136
      xferlog = (char *)tmp___115;
      }
    }
#line 1138
    if (! xferlog) {
#line 1139
      xferlog = (char *)"/var/log/xferlog";
    }
  }
  {
#line 1142
  tmp___116 = strcasecmp((char const   *)xferlog, "NONE");
  }
#line 1142
  if (tmp___116 == 0) {
    {
#line 1143
    xferlog_open((char const   *)((void *)0));
    }
  } else {
    {
#line 1145
    xferlog_open((char const   *)xferlog);
    }
  }
  {
#line 1147
  res = set_groups(p, pw->pw_gid, session.gids);
  }
#line 1148
  if (res < 0) {
    {
#line 1149
    tmp___117 = __errno_location();
#line 1149
    tmp___118 = strerror(*tmp___117);
#line 1149
    pr_log_pri(3, "error: unable to set groups: %s", tmp___118);
    }
  }
  {
#line 1153
  pr_signals_block();
  }
#line 1153
  if (! session.disable_id_switching) {
    {
#line 1153
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                 1153);
#line 1153
    tmp___122 = geteuid();
    }
#line 1153
    if (tmp___122 != 0U) {
      {
#line 1153
      tmp___121 = seteuid((__uid_t )0);
      }
#line 1153
      if (tmp___121) {
        {
#line 1153
        tmp___119 = __errno_location();
#line 1153
        tmp___120 = strerror(*tmp___119);
#line 1153
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___120);
        }
      }
    }
    {
#line 1153
    tmp___125 = setegid(session.gid);
    }
#line 1153
    if (tmp___125) {
      {
#line 1153
      tmp___123 = __errno_location();
#line 1153
      tmp___124 = strerror(*tmp___123);
#line 1153
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___124);
      }
    }
    {
#line 1153
    tmp___128 = seteuid(session.uid);
    }
#line 1153
    if (tmp___128) {
      {
#line 1153
      tmp___126 = __errno_location();
#line 1153
      tmp___127 = strerror(*tmp___126);
#line 1153
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___127);
      }
    }
  } else {
    {
#line 1153
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 1153
  pr_signals_unblock();
  }
#line 1156
  if (! c) {
    {
#line 1156
    defroot = get_default_root(session.pool);
    }
#line 1156
    if (defroot) {
      {
#line 1158
      ensure_open_passwd(p);
#line 1160
      tmp___129 = pr_auth_chroot((char const   *)defroot);
      }
#line 1160
      if (tmp___129 == -1) {
        {
#line 1161
        pr_log_pri(3, "error: unable to set default root directory");
#line 1162
        pr_response_send("530", "Login incorrect.");
#line 1163
        end_login(1);
        }
      }
      {
#line 1170
      tmp___131 = strlen((char const   *)defroot);
#line 1170
      tmp___132 = strncmp((char const   *)(session.cwd), (char const   *)defroot,
                          tmp___131);
      }
#line 1170
      if (tmp___132 == 0) {
        {
#line 1171
        tmp___130 = strlen((char const   *)defroot);
#line 1171
        newcwd = & session.cwd[tmp___130];
        }
#line 1173
        if ((int )*newcwd == 47) {
#line 1174
          newcwd ++;
        }
        {
#line 1175
        session.cwd[0] = (char )'/';
#line 1176
        sstrncpy(& session.cwd[1], (char const   *)newcwd, (size_t )sizeof(session.cwd));
        }
      }
    }
  }
#line 1180
  if (c) {
    {
#line 1181
    ensure_open_passwd(p);
    }
  }
#line 1183
  if (c) {
    {
#line 1183
    tmp___133 = pr_auth_chroot((char const   *)session.chroot_path);
    }
#line 1183
    if (tmp___133 == -1) {
      {
#line 1185
      pr_log_pri(3, "error: unable to set anonymous privileges");
#line 1186
      pr_response_send("530", "Login incorrect.");
#line 1187
      end_login(1);
      }
    }
  }
  {
#line 1195
  pr_signals_block();
#line 1197
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
               1197);
#line 1197
  pr_signals_block();
  }
#line 1197
  if (! session.disable_id_switching) {
    {
#line 1197
    tmp___136 = seteuid((__uid_t )0);
    }
#line 1197
    if (tmp___136) {
      {
#line 1197
      tmp___134 = __errno_location();
#line 1197
      tmp___135 = strerror(*tmp___134);
#line 1197
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___135);
      }
    }
    {
#line 1197
    tmp___139 = setegid((__gid_t )0);
    }
#line 1197
    if (tmp___139) {
      {
#line 1197
      tmp___137 = __errno_location();
#line 1197
      tmp___138 = strerror(*tmp___137);
#line 1197
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___138);
      }
    }
  } else {
    {
#line 1197
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 1197
  pr_signals_unblock();
#line 1200
  setuid((__uid_t )0);
#line 1201
  setgid((__gid_t )0);
#line 1204
  pr_log_debug(9, "SETUP PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
               1204);
#line 1204
  pr_signals_block();
#line 1204
  tmp___158 = getuid();
  }
#line 1204
  if (tmp___158 != 0U) {
    {
#line 1204
    session.uid = getuid();
#line 1204
    session.ouid = session.uid;
#line 1204
    session.gid = getgid();
#line 1204
    tmp___142 = setgid(session.gid);
    }
#line 1204
    if (tmp___142) {
      {
#line 1204
      tmp___140 = __errno_location();
#line 1204
      tmp___141 = strerror(*tmp___140);
#line 1204
      pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___141);
      }
    }
    {
#line 1204
    tmp___145 = setuid(session.uid);
    }
#line 1204
    if (tmp___145) {
      {
#line 1204
      tmp___143 = __errno_location();
#line 1204
      tmp___144 = strerror(*tmp___143);
#line 1204
      pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___144);
      }
    }
    {
#line 1204
    tmp___148 = seteuid(session.uid);
    }
#line 1204
    if (tmp___148) {
      {
#line 1204
      tmp___146 = __errno_location();
#line 1204
      tmp___147 = strerror(*tmp___146);
#line 1204
      pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___147);
      }
    }
  } else {
    {
#line 1204
    session.ouid = getuid();
#line 1204
    session.uid = pw->pw_uid;
#line 1204
    session.gid = pw->pw_gid;
#line 1204
    tmp___151 = setuid((__uid_t )0);
    }
#line 1204
    if (tmp___151) {
      {
#line 1204
      tmp___149 = __errno_location();
#line 1204
      tmp___150 = strerror(*tmp___149);
#line 1204
      pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___150);
      }
    }
    {
#line 1204
    tmp___154 = setgid(pw->pw_gid);
    }
#line 1204
    if (tmp___154) {
      {
#line 1204
      tmp___152 = __errno_location();
#line 1204
      tmp___153 = strerror(*tmp___152);
#line 1204
      pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___153);
      }
    }
    {
#line 1204
    tmp___157 = seteuid(pw->pw_uid);
    }
#line 1204
    if (tmp___157) {
      {
#line 1204
      tmp___155 = __errno_location();
#line 1204
      tmp___156 = strerror(*tmp___155);
#line 1204
      pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___156);
      }
    }
  }
  {
#line 1204
  pr_signals_unblock();
#line 1206
  pr_signals_unblock();
  }
#line 1227
  if ((unsigned long )pw->pw_dir == (unsigned long )((void *)0)) {
    {
#line 1229
    pr_log_pri(3, "error: user %s home directory is NULL or \"\"", session.user);
#line 1231
    pr_response_send("530", "Login incorrect.");
#line 1232
    end_login(1);
    }
  } else {
    {
#line 1227
    tmp___159 = strcmp((char const   *)pw->pw_dir, "");
    }
#line 1227
    if (tmp___159 == 0) {
      {
#line 1229
      pr_log_pri(3, "error: user %s home directory is NULL or \"\"", session.user);
#line 1231
      pr_response_send("530", "Login incorrect.");
#line 1232
      end_login(1);
      }
    }
  }
#line 1236
  if (c) {
#line 1236
    tmp___160 = c->subset;
  } else {
#line 1236
    tmp___160 = main_server->conf;
  }
  {
#line 1236
  tmp___161 = get_param_ptr(tmp___160, "ShowSymlinks", 0);
#line 1236
  show_symlinks = (unsigned char *)tmp___161;
  }
#line 1239
  if (! show_symlinks) {
#line 1240
    showsymlinks = 1;
  } else
#line 1239
  if ((int )*show_symlinks == 1) {
#line 1240
    showsymlinks = 1;
  } else {
#line 1242
    showsymlinks = 0;
  }
  {
#line 1252
  tmp___175 = pr_fsio_chdir_canon((char const   *)(session.cwd), ! showsymlinks);
  }
#line 1252
  if (tmp___175 == -1) {
#line 1258
    if ((unsigned long )session.chroot_path != (unsigned long )((void *)0)) {
#line 1258
      goto _L___2;
    } else
#line 1258
    if (defroot) {
      _L___2: /* CIL Label */ 
#line 1260
      if (session.chroot_path) {
#line 1260
        tmp___162 = session.chroot_path;
      } else {
#line 1260
        tmp___162 = defroot;
      }
      {
#line 1260
      tmp___163 = __errno_location();
#line 1260
      tmp___164 = strerror(*tmp___163);
#line 1260
      pr_log_debug(2, "unable to chdir to %s (%s), defaulting to chroot directory %s",
                   session.cwd, tmp___164, tmp___162);
#line 1264
      tmp___167 = pr_fsio_chdir_canon("/", ! showsymlinks);
      }
#line 1264
      if (tmp___167 == -1) {
        {
#line 1265
        tmp___165 = __errno_location();
#line 1265
        tmp___166 = strerror(*tmp___165);
#line 1265
        pr_log_pri(3, "%s chdir(\"/\"): %s", session.user, tmp___166);
#line 1267
        pr_response_send("530", "Login incorrect.");
#line 1268
        end_login(1);
        }
      }
    } else
#line 1271
    if (defchdir) {
      {
#line 1276
      tmp___168 = __errno_location();
#line 1276
      tmp___169 = strerror(*tmp___168);
#line 1276
      pr_log_debug(2, "unable to chdir to %s (%s), defaulting to home directory %s",
                   session.cwd, tmp___169, pw->pw_dir);
#line 1279
      tmp___172 = pr_fsio_chdir_canon((char const   *)pw->pw_dir, ! showsymlinks);
      }
#line 1279
      if (tmp___172 == -1) {
        {
#line 1280
        tmp___170 = __errno_location();
#line 1280
        tmp___171 = strerror(*tmp___170);
#line 1280
        pr_log_pri(3, "%s chdir(\"%s\"): %s", session.user, session.cwd, tmp___171);
#line 1282
        pr_response_send("530", "Login incorrect.");
#line 1283
        end_login(1);
        }
      }
    } else {
      {
#line 1291
      tmp___173 = __errno_location();
#line 1291
      tmp___174 = strerror(*tmp___173);
#line 1291
      pr_log_pri(3, "%s chdir(\"%s\"): %s", session.user, session.cwd, tmp___174);
#line 1293
      pr_response_send("530", "Login incorrect.");
#line 1294
      end_login(1);
      }
    }
  }
  {
#line 1298
  tmp___176 = pr_fs_getcwd();
#line 1298
  sstrncpy(session.cwd, tmp___176, (size_t )sizeof(session.cwd));
#line 1299
  tmp___177 = pr_fs_getvwd();
#line 1299
  sstrncpy(session.vwd, tmp___177, (size_t )sizeof(session.vwd));
#line 1302
  dir_check_full(p, (char *)"PASS", (char *)((void *)0), session.cwd, (int *)((void *)0));
  }
#line 1304
  if (c) {
#line 1305
    if (! session.hide_password) {
      {
#line 1306
      session.proc_prefix = pstrcat(session.pool, (session.c)->remote_name, ": anonymous/",
                                    pass, (void *)0);
      }
    } else {
      {
#line 1310
      session.proc_prefix = pstrcat(session.pool, (session.c)->remote_name, ": anonymous",
                                    (void *)0);
      }
    }
#line 1313
    session.sf_flags = (int volatile   )64;
  } else {
    {
#line 1316
    session.proc_prefix = pstrdup(session.pool, (session.c)->remote_name);
#line 1317
    session.sf_flags = (int volatile   )0;
    }
  }
  {
#line 1324
  tmp___178 = pr_fsio_stat((char const   *)(session.cwd), & sbuf___0);
  }
#line 1324
  if (tmp___178 != -1) {
    {
#line 1325
    build_dyn_config(p, session.cwd, & sbuf___0, (unsigned char)1);
    }
  }
  {
#line 1335
  tmp___179 = get_param_ptr(main_server->conf, "DefaultTransferMode", 0);
#line 1335
  defaulttransfermode = (char *)tmp___179;
  }
#line 1338
  if (defaulttransfermode) {
    {
#line 1338
    tmp___180 = strcasecmp((char const   *)defaulttransfermode, "binary");
    }
#line 1338
    if (tmp___180 == 0) {
#line 1340
      session.sf_flags &= (int volatile   )1895;
    } else {
#line 1343
      session.sf_flags |= (int volatile   )16;
    }
  } else {
#line 1343
    session.sf_flags |= (int volatile   )16;
  }
  {
#line 1351
  pr_scoreboard_entry_update(session.pid, 1, session.user, 5, session.cwd, (void *)0);
#line 1356
  session_set_idle();
#line 1358
  pr_timer_remove(1, & auth_module);
#line 1364
  session.user = pstrdup(session.pool, (char const   *)session.user);
  }
#line 1366
  if (session.group) {
    {
#line 1367
    session.group = pstrdup(session.pool, (char const   *)session.group);
    }
  }
#line 1369
  if (session.gids) {
    {
#line 1370
    session.gids = copy_array(session.pool, (array_header const   *)session.gids);
    }
  }
  {
#line 1375
  session.groups = copy_array_str(session.pool, (array_header const   *)session.groups);
#line 1378
  pr_resolve_fs_map();
  }
#line 1380
  return (1);
  auth_failure: 
#line 1383
  if (pass) {
    {
#line 1384
    tmp___181 = strlen((char const   *)pass);
#line 1384
    pr_memscrub((void *)pass, tmp___181);
    }
  }
#line 1385
  session.group = (char *)((void *)0);
#line 1385
  session.user = session.group;
#line 1386
  session.groups = (array_header *)((void *)0);
#line 1386
  session.gids = session.groups;
#line 1387
  session.wtmp_log = 0;
#line 1388
  return (0);
}
}
#line 1397 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static void auth_scan_scoreboard(void) 
{ 
  config_rec *c ;
  pr_scoreboard_entry_t *score ;
  unsigned int cur ;
  unsigned int ccur ;
  unsigned int hcur ;
  char config_class_users[128] ;
  unsigned int tmp ;
  char curr_server_addr[80] ;
  unsigned int tmp___0 ;
  xaset_t *conf ;
  char const   *client_addr ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  xaset_t *tmp___10 ;
  xaset_t *tmp___11 ;
  xaset_t *tmp___12 ;
  xaset_t *tmp___13 ;
  xaset_t *tmp___14 ;
  unsigned int *max ;
  char maxstr[20] ;
  char *msg ;
  char *tmp___15 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 1398
  c = (config_rec *)((void *)0);
#line 1399
  score = (pr_scoreboard_entry_t *)((void *)0);
#line 1400
  cur = 0U;
#line 1400
  ccur = 0U;
#line 1400
  hcur = 0U;
#line 1401
  config_class_users[0] = (char )'\000';
#line 1401
  tmp = 1U;
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if (tmp >= 128U) {
#line 1401
      goto while_break;
    }
#line 1401
    config_class_users[tmp] = (char)0;
#line 1401
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1402
  curr_server_addr[0] = (char )'\000';
#line 1402
  tmp___0 = 1U;
  {
#line 1402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1402
    if (tmp___0 >= 80U) {
#line 1402
      goto while_break___0;
    }
#line 1402
    curr_server_addr[tmp___0] = (char)0;
#line 1402
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1403
  conf = (xaset_t *)((void *)0);
#line 1404
  tmp___1 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1404
  client_addr = tmp___1;
#line 1406
  tmp___2 = pr_netaddr_get_ipstr(main_server->addr);
#line 1406
  snprintf((char */* __restrict  */)(curr_server_addr), (size_t )sizeof(curr_server_addr),
           (char const   */* __restrict  */)"%s:%d", tmp___2, main_server->ServerPort);
#line 1408
  curr_server_addr[sizeof(curr_server_addr) - 1UL] = (char )'\000';
#line 1411
  tmp___5 = pr_rewind_scoreboard();
  }
#line 1411
  if (tmp___5 < 0) {
    {
#line 1412
    tmp___3 = __errno_location();
#line 1412
    tmp___4 = strerror(*tmp___3);
#line 1412
    pr_log_pri(5, "error rewinding scoreboard: %s", tmp___4);
    }
  }
  {
#line 1415
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1415
    score = pr_scoreboard_entry_read();
    }
#line 1415
    if (! ((unsigned long )score != (unsigned long )((void *)0))) {
#line 1415
      goto while_break___1;
    }
    {
#line 1418
    tmp___9 = strcmp((char const   *)(score->sce_server_addr), (char const   *)(curr_server_addr));
    }
#line 1418
    if (tmp___9 == 0) {
      {
#line 1419
      cur ++;
#line 1421
      tmp___6 = strcmp((char const   *)(score->sce_client_addr), client_addr);
      }
#line 1421
      if (tmp___6 == 0) {
#line 1422
        hcur ++;
      }
      {
#line 1425
      tmp___7 = strcmp((char const   *)(score->sce_user), "(none)");
      }
#line 1425
      if (tmp___7 == 0) {
#line 1426
        goto while_continue___1;
      }
#line 1431
      if (session.class) {
        {
#line 1431
        tmp___8 = strcasecmp((char const   *)(score->sce_class), (char const   *)(session.class)->cls_name);
        }
#line 1431
        if (tmp___8 == 0) {
#line 1433
          ccur ++;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1436
  pr_restore_scoreboard();
  }
#line 1440
  if (session.dir_config) {
#line 1440
    conf = (session.dir_config)->subset;
  } else {
#line 1440
    if (session.anon_config) {
#line 1440
      tmp___10 = (session.anon_config)->subset;
    } else {
#line 1440
      tmp___10 = main_server->conf;
    }
#line 1440
    conf = tmp___10;
  }
#line 1442
  if (session.dir_config) {
#line 1442
    tmp___12 = (session.dir_config)->subset;
  } else {
#line 1442
    if (session.anon_config) {
#line 1442
      tmp___11 = (session.anon_config)->subset;
    } else {
#line 1442
      tmp___11 = main_server->conf;
    }
#line 1442
    tmp___12 = tmp___11;
  }
  {
#line 1442
  remove_config(tmp___12, "CURRENT-CLIENTS", 0);
#line 1443
  c = add_config_param_set(& conf, "CURRENT-CLIENTS", 1, (void *)0);
#line 1444
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 1445
  *((unsigned int *)*(c->argv + 0)) = cur;
  }
#line 1447
  if (session.class) {
    {
#line 1448
    snprintf((char */* __restrict  */)(config_class_users), (size_t )sizeof(config_class_users),
             (char const   */* __restrict  */)"CURRENT-CLIENTS-CLASS-%s", (session.class)->cls_name);
    }
#line 1450
    if (session.dir_config) {
#line 1450
      tmp___14 = (session.dir_config)->subset;
    } else {
#line 1450
      if (session.anon_config) {
#line 1450
        tmp___13 = (session.anon_config)->subset;
      } else {
#line 1450
        tmp___13 = main_server->conf;
      }
#line 1450
      tmp___14 = tmp___13;
    }
    {
#line 1450
    remove_config(tmp___14, (char const   *)(config_class_users), 0);
#line 1451
    c = add_config_param_set(& conf, (char const   *)(config_class_users), 1, (void *)0);
#line 1452
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 1453
    *((unsigned int *)*(c->argv + 0)) = ccur;
    }
  }
  {
#line 1457
  c = find_config(main_server->conf, 1 << 15, "MaxConnectionsPerHost", 0);
  }
#line 1460
  if (c) {
#line 1461
    max = (unsigned int *)*(c->argv + 0);
#line 1463
    if (*max) {
#line 1463
      if (hcur > *max) {
        {
#line 1467
        msg = (char *)"Sorry, the maximum number of connections (%m) for your host are already connected.";
#line 1470
        pr_event_generate("mod_auth.max-connections-per-host", (void const   *)session.c);
        }
#line 1472
        if (c->argc == 2) {
#line 1473
          msg = (char *)*(c->argv + 1);
        }
        {
#line 1475
        memset((void *)(maxstr), '\000', (size_t )sizeof(maxstr));
#line 1476
        snprintf((char */* __restrict  */)(maxstr), (size_t )sizeof(maxstr), (char const   */* __restrict  */)"%u",
                 *max);
#line 1477
        maxstr[sizeof(maxstr) - 1UL] = (char )'\000';
#line 1479
        tmp___15 = sreplace(session.pool, msg, "%m", maxstr, (void *)0);
#line 1479
        pr_response_send("530", "%s", tmp___15);
#line 1482
        pr_log_auth(5, "Connection refused (MaxConnectionsPerHost %u)", *max);
#line 1484
        end_login(1);
        }
      }
    }
  }
#line 1487
  return;
}
}
#line 1489 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static void auth_count_scoreboard(cmd_rec *cmd , char *user ) 
{ 
  pr_scoreboard_entry_t *score ;
  long cur ;
  long hcur ;
  long ccur ;
  long hostsperuser ;
  long usersessions ;
  config_rec *c ;
  config_rec *anon_config ;
  config_rec *maxc ;
  char *origuser ;
  char config_class_users[128] ;
  unsigned int tmp ;
  char curr_server_addr[80] ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned char same_host ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  __uid_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *maxstr ;
  unsigned int *max ;
  int tmp___22 ;
  char maxn[20] ;
  unsigned int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  xaset_t *tmp___26 ;
  char *maxstr___0 ;
  unsigned int *max___0 ;
  char maxn___0[20] ;
  unsigned int tmp___27 ;
  char *tmp___28 ;
  xaset_t *tmp___29 ;
  char *maxstr___1 ;
  unsigned int *max___1 ;
  char maxn___1[20] ;
  unsigned int tmp___30 ;
  char *tmp___31 ;
  xaset_t *tmp___32 ;
  char *maxstr___2 ;
  unsigned int *max___2 ;
  char maxn___2[20] ;
  unsigned int tmp___33 ;
  char *tmp___34 ;
  xaset_t *tmp___35 ;
  char *maxstr___3 ;
  unsigned int *max___3 ;
  char maxn___3[20] ;
  unsigned int tmp___36 ;
  char *tmp___37 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;

  {
#line 1490
  score = (pr_scoreboard_entry_t *)((void *)0);
#line 1491
  cur = 0L;
#line 1491
  hcur = 0L;
#line 1491
  ccur = 0L;
#line 1491
  hostsperuser = 1L;
#line 1491
  usersessions = 0L;
#line 1492
  c = (config_rec *)((void *)0);
#line 1492
  anon_config = (config_rec *)((void *)0);
#line 1492
  maxc = (config_rec *)((void *)0);
#line 1493
  config_class_users[0] = (char )'\000';
#line 1493
  tmp = 1U;
  {
#line 1493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1493
    if (tmp >= 128U) {
#line 1493
      goto while_break;
    }
#line 1493
    config_class_users[tmp] = (char)0;
#line 1493
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1496
  origuser = user;
#line 1497
  anon_config = pr_auth_get_anon_config(cmd->tmp_pool, & user, (char **)((void *)0),
                                        (char **)((void *)0));
  }
#line 1500
  if (user) {
#line 1501
    curr_server_addr[0] = (char )'\000';
#line 1501
    tmp___0 = 1U;
    {
#line 1501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1501
      if (tmp___0 >= 80U) {
#line 1501
        goto while_break___0;
      }
#line 1501
      curr_server_addr[tmp___0] = (char)0;
#line 1501
      tmp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1503
    tmp___1 = pr_netaddr_get_ipstr(main_server->addr);
#line 1503
    snprintf((char */* __restrict  */)(curr_server_addr), (size_t )sizeof(curr_server_addr),
             (char const   */* __restrict  */)"%s:%d", tmp___1, main_server->ServerPort);
#line 1505
    curr_server_addr[sizeof(curr_server_addr) - 1UL] = (char )'\000';
#line 1507
    tmp___4 = pr_rewind_scoreboard();
    }
#line 1507
    if (tmp___4 < 0) {
      {
#line 1508
      tmp___2 = __errno_location();
#line 1508
      tmp___3 = strerror(*tmp___2);
#line 1508
      pr_log_pri(5, "error rewinding scoreboard: %s", tmp___3);
      }
    }
    {
#line 1511
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1511
      score = pr_scoreboard_entry_read();
      }
#line 1511
      if (! ((unsigned long )score != (unsigned long )((void *)0))) {
#line 1511
        goto while_break___1;
      }
      {
#line 1512
      same_host = (unsigned char)0;
#line 1515
      tmp___11 = strcmp((char const   *)(score->sce_server_addr), (char const   *)(curr_server_addr));
      }
#line 1515
      if (tmp___11 == 0) {
#line 1517
        if (c) {
#line 1517
          if (c->config_type == 1 << 2) {
            {
#line 1517
            tmp___9 = strcmp((char const   *)(score->sce_user), (char const   *)user);
            }
#line 1517
            if (tmp___9) {
#line 1517
              goto _L___1;
            } else {
#line 1517
              goto _L;
            }
          } else {
#line 1517
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1517
        if (! c) {
          _L: /* CIL Label */ 
#line 1524
          if (c) {
#line 1524
            if (c->config_type == 1 << 2) {
#line 1524
              if (cur == 0L) {
#line 1525
                cur = 1L;
              }
            }
          }
          {
#line 1528
          tmp___5 = strcmp((char const   *)(score->sce_user), "(none)");
          }
#line 1528
          if (tmp___5 == 0) {
#line 1529
            goto while_continue___1;
          }
          {
#line 1531
          cur ++;
#line 1535
          tmp___6 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1535
          tmp___7 = strcmp((char const   *)(score->sce_client_addr), tmp___6);
          }
#line 1535
          if (! tmp___7) {
#line 1537
            same_host = (unsigned char)1;
#line 1543
            if (c) {
#line 1543
              if (c->config_type == 1 << 2) {
#line 1543
                if (hcur == 0L) {
#line 1544
                  hcur = 1L;
                }
              }
            }
#line 1546
            hcur ++;
          }
          {
#line 1550
          tmp___8 = strcmp((char const   *)(score->sce_user), (char const   *)user);
          }
#line 1550
          if (! tmp___8) {
#line 1551
            usersessions ++;
#line 1554
            if (! same_host) {
#line 1555
              hostsperuser ++;
            }
          }
        }
#line 1559
        if (session.class) {
          {
#line 1559
          tmp___10 = strcasecmp((char const   *)(score->sce_class), (char const   *)(session.class)->cls_name);
          }
#line 1559
          if (tmp___10 == 0) {
#line 1561
            ccur ++;
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1564
    pr_restore_scoreboard();
#line 1565
    pr_signals_block();
    }
#line 1565
    if (! session.disable_id_switching) {
      {
#line 1565
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c",
                   1565);
#line 1565
      tmp___15 = geteuid();
      }
#line 1565
      if (tmp___15 != 0U) {
        {
#line 1565
        tmp___14 = seteuid((__uid_t )0);
        }
#line 1565
        if (tmp___14) {
          {
#line 1565
          tmp___12 = __errno_location();
#line 1565
          tmp___13 = strerror(*tmp___12);
#line 1565
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___13);
          }
        }
      }
      {
#line 1565
      tmp___18 = setegid(session.gid);
      }
#line 1565
      if (tmp___18) {
        {
#line 1565
        tmp___16 = __errno_location();
#line 1565
        tmp___17 = strerror(*tmp___16);
#line 1565
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___17);
        }
      }
      {
#line 1565
      tmp___21 = seteuid(session.uid);
      }
#line 1565
      if (tmp___21) {
        {
#line 1565
        tmp___19 = __errno_location();
#line 1565
        tmp___20 = strerror(*tmp___19);
#line 1565
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___20);
        }
      }
    } else {
      {
#line 1565
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 1565
    pr_signals_unblock();
    }
  }
  {
#line 1568
  remove_config((cmd->server)->conf, "CURRENT-CLIENTS", 0);
#line 1569
  c = add_config_param_set(& (cmd->server)->conf, "CURRENT-CLIENTS", 1, (void *)0);
#line 1570
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 1571
  *((int *)*(c->argv + 0)) = (int )cur;
  }
#line 1573
  if (session.class) {
    {
#line 1574
    snprintf((char */* __restrict  */)(config_class_users), (size_t )sizeof(config_class_users),
             (char const   */* __restrict  */)"%s-%s", "CURRENT-CLIENTS-CLASS", (session.class)->cls_name);
#line 1576
    remove_config((cmd->server)->conf, (char const   *)(config_class_users), 0);
#line 1577
    c = add_config_param_set(& (cmd->server)->conf, (char const   *)(config_class_users),
                             1, (void *)0);
#line 1578
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 1579
    *((int *)*(c->argv + 0)) = (int )ccur;
    }
  }
  {
#line 1587
  maxc = find_config((cmd->server)->conf, 1 << 15, "MaxClientsPerClass", 0);
  }
  {
#line 1589
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1589
    if (session.class) {
#line 1589
      if (! maxc) {
#line 1589
        goto while_break___2;
      }
    } else {
#line 1589
      goto while_break___2;
    }
    {
#line 1590
    maxstr = (char *)"Sorry, the maximum number of clients (%m) from your class are already connected.";
#line 1592
    max = (unsigned int *)*(maxc->argv + 1);
#line 1594
    tmp___22 = strcmp((char const   *)*(maxc->argv + 0), (char const   *)(session.class)->cls_name);
    }
#line 1594
    if (tmp___22 != 0) {
      {
#line 1595
      maxc = find_config_next(maxc, maxc->next, 1 << 15, "MaxClientsPerClass", 0);
      }
#line 1597
      goto while_continue___2;
    }
#line 1600
    if (maxc->argc > 2) {
#line 1601
      maxstr = (char *)*(maxc->argv + 2);
    }
#line 1603
    if (*max) {
#line 1603
      if (ccur > (long )*max) {
#line 1605
        maxn[0] = (char )'\000';
#line 1605
        tmp___23 = 1U;
        {
#line 1605
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1605
          if (tmp___23 >= 20U) {
#line 1605
            goto while_break___3;
          }
#line 1605
          maxn[tmp___23] = (char)0;
#line 1605
          tmp___23 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1607
        if (session.class) {
#line 1607
          tmp___24 = (session.class)->cls_name;
        } else {
#line 1607
          tmp___24 = (char *)((void *)0);
        }
        {
#line 1607
        pr_event_generate("mod_auth.max-clients-per-class", (void const   *)tmp___24);
#line 1610
        snprintf((char */* __restrict  */)(maxn), (size_t )sizeof(maxn), (char const   */* __restrict  */)"%u",
                 *max);
#line 1611
        tmp___25 = sreplace(cmd->tmp_pool, maxstr, "%m", maxn, (void *)0);
#line 1611
        pr_response_send("530", "%s", tmp___25);
#line 1613
        pr_log_auth(5, "Connection refused (max clients %u per class %s).", *max,
                    (session.class)->cls_name);
#line 1616
        end_login(0);
        }
      }
    }
#line 1619
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1622
  if (session.anon_config) {
#line 1622
    tmp___26 = (session.anon_config)->subset;
  } else {
#line 1622
    tmp___26 = main_server->conf;
  }
  {
#line 1622
  maxc = find_config(tmp___26, 1 << 15, "MaxClientsPerHost", 0);
  }
#line 1623
  if (maxc) {
#line 1624
    maxstr___0 = (char *)"Sorry, the maximum number of clients (%m) from your host are already connected.";
#line 1626
    max___0 = (unsigned int *)*(maxc->argv + 0);
#line 1628
    if (maxc->argc > 1) {
#line 1629
      maxstr___0 = (char *)*(maxc->argv + 1);
    }
#line 1631
    if (*max___0) {
#line 1631
      if (hcur > (long )*max___0) {
#line 1632
        maxn___0[0] = (char )'\000';
#line 1632
        tmp___27 = 1U;
        {
#line 1632
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1632
          if (tmp___27 >= 20U) {
#line 1632
            goto while_break___4;
          }
#line 1632
          maxn___0[tmp___27] = (char)0;
#line 1632
          tmp___27 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 1634
        pr_event_generate("mod_auth.max-clients-per-host", (void const   *)session.c);
#line 1636
        snprintf((char */* __restrict  */)(maxn___0), (size_t )sizeof(maxn___0), (char const   */* __restrict  */)"%u",
                 *max___0);
#line 1637
        tmp___28 = sreplace(cmd->tmp_pool, maxstr___0, "%m", maxn___0, (void *)0);
#line 1637
        pr_response_send("530", "%s", tmp___28);
#line 1639
        pr_log_auth(5, "Connection refused (max clients per host %u).", *max___0);
#line 1641
        end_login(0);
        }
      }
    }
  }
#line 1646
  if (session.anon_config) {
#line 1646
    tmp___29 = (session.anon_config)->subset;
  } else {
#line 1646
    tmp___29 = main_server->conf;
  }
  {
#line 1646
  maxc = find_config(tmp___29, 1 << 15, "MaxClientsPerUser", 0);
  }
#line 1647
  if (maxc) {
#line 1648
    maxstr___1 = (char *)"Sorry, the maximum number of clients (%m) for this user are already connected.";
#line 1650
    max___1 = (unsigned int *)*(maxc->argv + 0);
#line 1652
    if (maxc->argc > 1) {
#line 1653
      maxstr___1 = (char *)*(maxc->argv + 1);
    }
#line 1655
    if (*max___1) {
#line 1655
      if (usersessions > (long )*max___1) {
#line 1656
        maxn___1[0] = (char )'\000';
#line 1656
        tmp___30 = 1U;
        {
#line 1656
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1656
          if (tmp___30 >= 20U) {
#line 1656
            goto while_break___5;
          }
#line 1656
          maxn___1[tmp___30] = (char)0;
#line 1656
          tmp___30 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1658
        pr_event_generate("mod_auth.max-clients-per-user", (void const   *)user);
#line 1660
        snprintf((char */* __restrict  */)(maxn___1), (size_t )sizeof(maxn___1), (char const   */* __restrict  */)"%u",
                 *max___1);
#line 1661
        tmp___31 = sreplace(cmd->tmp_pool, maxstr___1, "%m", maxn___1, (void *)0);
#line 1661
        pr_response_send("530", "%s", tmp___31);
#line 1663
        pr_log_auth(5, "Connection refused (max clients per user %u).", *max___1);
#line 1665
        end_login(0);
        }
      }
    }
  }
#line 1669
  if (session.anon_config) {
#line 1669
    tmp___32 = (session.anon_config)->subset;
  } else {
#line 1669
    tmp___32 = main_server->conf;
  }
  {
#line 1669
  maxc = find_config(tmp___32, 1 << 15, "MaxClients", 0);
  }
#line 1670
  if (maxc) {
#line 1671
    maxstr___2 = (char *)"Sorry, the maximum number of allowed clients (%m) are already connected.";
#line 1673
    max___2 = (unsigned int *)*(maxc->argv + 0);
#line 1675
    if (maxc->argc > 1) {
#line 1676
      maxstr___2 = (char *)*(maxc->argv + 1);
    }
#line 1678
    if (*max___2) {
#line 1678
      if (cur > (long )*max___2) {
#line 1679
        maxn___2[0] = (char )'\000';
#line 1679
        tmp___33 = 1U;
        {
#line 1679
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1679
          if (tmp___33 >= 20U) {
#line 1679
            goto while_break___6;
          }
#line 1679
          maxn___2[tmp___33] = (char)0;
#line 1679
          tmp___33 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1681
        pr_event_generate("mod_auth.max-clients", (void const   *)((void *)0));
#line 1683
        snprintf((char */* __restrict  */)(maxn___2), (size_t )sizeof(maxn___2), (char const   */* __restrict  */)"%u",
                 *max___2);
#line 1684
        tmp___34 = sreplace(cmd->tmp_pool, maxstr___2, "%m", maxn___2, (void *)0);
#line 1684
        pr_response_send("530", "%s", tmp___34);
#line 1686
        pr_log_auth(5, "Connection refused (max clients %u).", *max___2);
#line 1687
        end_login(0);
        }
      }
    }
  }
#line 1691
  if (session.anon_config) {
#line 1691
    tmp___35 = (session.anon_config)->subset;
  } else {
#line 1691
    tmp___35 = main_server->conf;
  }
  {
#line 1691
  maxc = find_config(tmp___35, 1 << 15, "MaxHostsPerUser", 0);
  }
#line 1692
  if (maxc) {
#line 1693
    maxstr___3 = (char *)"Sorry, the maximum number of hosts (%m) for this user are already connected.";
#line 1695
    max___3 = (unsigned int *)*(maxc->argv + 0);
#line 1697
    if (maxc->argc > 1) {
#line 1698
      maxstr___3 = (char *)*(maxc->argv + 1);
    }
#line 1700
    if (*max___3) {
#line 1700
      if (hostsperuser > (long )*max___3) {
#line 1701
        maxn___3[0] = (char )'\000';
#line 1701
        tmp___36 = 1U;
        {
#line 1701
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1701
          if (tmp___36 >= 20U) {
#line 1701
            goto while_break___7;
          }
#line 1701
          maxn___3[tmp___36] = (char)0;
#line 1701
          tmp___36 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1703
        pr_event_generate("mod_auth.max-hosts-per-user", (void const   *)user);
#line 1705
        snprintf((char */* __restrict  */)(maxn___3), (size_t )sizeof(maxn___3), (char const   */* __restrict  */)"%u",
                 *max___3);
#line 1706
        tmp___37 = sreplace(cmd->tmp_pool, maxstr___3, "%m", maxn___3, (void *)0);
#line 1706
        pr_response_send("530", "%s", tmp___37);
#line 1708
        pr_log_auth(5, "Connection refused (max hosts per host %u).", *max___3);
#line 1710
        end_login(0);
        }
      }
    }
  }
#line 1713
  return;
}
}
#line 1715 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_pre_user(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1717
  if (logged_in) {
#line 1718
    return ((modret_t *)((void *)0));
  }
  {
#line 1723
  pr_auth_endpwent(cmd->tmp_pool);
#line 1724
  pr_auth_endgrent(cmd->tmp_pool);
#line 1727
  tmp___0 = strlen((char const   *)cmd->arg);
  }
#line 1727
  if (tmp___0 > 256U) {
    {
#line 1728
    pr_log_pri(5, "USER %s (Login failed): maximum login length exceeded", cmd->arg);
#line 1730
    pr_response_add_err("501", "Login incorrect.");
#line 1731
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1731
    return (tmp);
  }
#line 1734
  return ((modret_t *)((void *)0));
}
}
#line 1737 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_user(cmd_rec *cmd ) 
{ 
  int nopass ;
  config_rec *c ;
  char *user ;
  char *origuser ;
  int failnopwprompt ;
  int aclp ;
  int i___0 ;
  unsigned char *anon_require_passwd ;
  unsigned char *login_passwd_prompt ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  cmd_rec *fakecmd ;
  cmd_rec *tmp___7 ;
  int tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 1738
  nopass = 0;
#line 1741
  failnopwprompt = 0;
#line 1742
  anon_require_passwd = (unsigned char *)((void *)0);
#line 1742
  login_passwd_prompt = (unsigned char *)((void *)0);
#line 1744
  if (logged_in) {
    {
#line 1745
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)"503", (char *)"You are already logged in");
    }
#line 1745
    return (tmp);
  }
#line 1747
  if (cmd->argc < 2) {
    {
#line 1748
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)"500", (char *)"USER: command requires a parameter");
    }
#line 1748
    return (tmp___0);
  }
  {
#line 1750
  user = cmd->arg;
#line 1752
  remove_config((cmd->server)->conf, "USER", 0);
#line 1753
  remove_config((cmd->server)->conf, "PASS", 0);
#line 1755
  c = add_config_param_set(& (cmd->server)->conf, "USER", 1, (void *)0);
#line 1756
  tmp___1 = pstrdup(c->pool, (char const   *)user);
#line 1756
  *(c->argv + 0) = (void *)tmp___1;
#line 1758
  origuser = user;
#line 1759
  c = pr_auth_get_anon_config(cmd->tmp_pool, & user, (char **)((void *)0), (char **)((void *)0));
  }
#line 1761
  if (c) {
#line 1761
    if (c->config_type == 1 << 2) {
#line 1761
      tmp___2 = c->subset;
    } else {
#line 1761
      tmp___2 = main_server->conf;
    }
  } else {
#line 1761
    tmp___2 = main_server->conf;
  }
  {
#line 1761
  tmp___3 = get_param_ptr(tmp___2, "LoginPasswordPrompt", 0);
#line 1761
  login_passwd_prompt = (unsigned char *)tmp___3;
  }
#line 1765
  if (login_passwd_prompt) {
#line 1765
    if ((int )*login_passwd_prompt == 0) {
#line 1766
      failnopwprompt = 1;
    } else {
#line 1768
      failnopwprompt = 0;
    }
  } else {
#line 1768
    failnopwprompt = 0;
  }
#line 1770
  if (failnopwprompt) {
#line 1771
    if (! user) {
      {
#line 1772
      remove_config((cmd->server)->conf, "USER", 0);
#line 1773
      remove_config((cmd->server)->conf, "PASS", 0);
#line 1775
      pr_log_pri(5, "USER %s (Login failed): Not a UserAlias.", origuser);
#line 1777
      pr_response_send("530", "Login incorrect.");
#line 1779
      end_login(0);
      }
    }
    {
#line 1782
    aclp = login_check_limits(main_server->conf, 0, 1, & i___0);
    }
#line 1784
    if (c) {
#line 1784
      if (c->config_type != 1 << 2) {
        {
#line 1785
        tmp___4 = pcalloc(session.pool, (int )sizeof(config_rec ));
#line 1785
        c = (config_rec *)tmp___4;
#line 1786
        c->config_type = 1 << 2;
#line 1787
        c->name = (char *)"";
#line 1788
        c->subset = main_server->conf;
        }
      }
    }
#line 1791
    if (c) {
      {
#line 1792
      tmp___5 = login_check_limits(c->subset, 0, 1, & i___0);
      }
#line 1792
      if (tmp___5) {
#line 1792
        if (! aclp) {
#line 1792
          if (! i___0) {
            {
#line 1794
            remove_config((cmd->server)->conf, "USER", 0);
#line 1795
            remove_config((cmd->server)->conf, "PASS", 0);
#line 1797
            pr_log_auth(5, "ANON %s: Limit access denies login.", origuser);
#line 1799
            pr_response_send("530", "Login incorrect.");
#line 1801
            end_login(0);
            }
          }
        }
      } else {
        {
#line 1794
        remove_config((cmd->server)->conf, "USER", 0);
#line 1795
        remove_config((cmd->server)->conf, "PASS", 0);
#line 1797
        pr_log_auth(5, "ANON %s: Limit access denies login.", origuser);
#line 1799
        pr_response_send("530", "Login incorrect.");
#line 1801
        end_login(0);
        }
      }
    }
#line 1805
    if (! c) {
#line 1805
      if (! aclp) {
        {
#line 1806
        remove_config((cmd->server)->conf, "USER", 0);
#line 1807
        remove_config((cmd->server)->conf, "PASS", 0);
#line 1809
        pr_log_auth(5, "USER %s: Limit access denies login.", origuser);
#line 1811
        pr_response_send("530", "Login incorrect.");
#line 1813
        end_login(0);
        }
      }
    }
  }
#line 1817
  if (c) {
    {
#line 1818
    tmp___6 = get_param_ptr(c->subset, "AnonRequirePassword", 0);
#line 1818
    anon_require_passwd = (unsigned char *)tmp___6;
    }
  }
#line 1821
  if (c) {
#line 1821
    if (user) {
#line 1821
      if (! anon_require_passwd) {
#line 1822
        nopass = 1;
      } else
#line 1821
      if ((int )*anon_require_passwd == 0) {
#line 1822
        nopass = 1;
      }
    }
  }
#line 1824
  session.gids = (array_header *)((void *)0);
#line 1825
  session.groups = (array_header *)((void *)0);
#line 1826
  session.user = (char *)((void *)0);
#line 1827
  session.group = (char *)((void *)0);
#line 1829
  if (nopass) {
    {
#line 1830
    pr_response_add("331", "Anonymous login ok, send your complete email address as your password");
    }
  } else {
    {
#line 1836
    tmp___8 = pr_auth_requires_pass(cmd->tmp_pool, (char const   *)user);
    }
#line 1836
    if (tmp___8 == 0) {
      {
#line 1839
      tmp___7 = pr_cmd_alloc(cmd->pool, 2, (void *)0);
#line 1839
      fakecmd = tmp___7;
#line 1845
      *(fakecmd->argv + 0) = pstrdup(fakecmd->pool, "PASS");
#line 1846
      *(fakecmd->argv + 1) = (char *)((void *)0);
#line 1847
      fakecmd->arg = (char *)((void *)0);
#line 1849
      c = add_config_param_set(& (cmd->server)->conf, "authenticated", 1, (void *)0);
#line 1850
      *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 1851
      *((unsigned char *)*(c->argv + 0)) = (unsigned char)1;
#line 1853
      authenticated_without_pass = (unsigned char)1;
#line 1854
      pr_log_auth(5, "USER %s: Authenticated without password", user);
#line 1856
      pr_cmd_dispatch(fakecmd);
      }
    } else {
      {
#line 1859
      pr_response_add("331", "Password required for %s", *(cmd->argv + 1));
      }
    }
  }
  {
#line 1861
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1861
  return (tmp___9);
}
}
#line 1865 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_pre_pass(cmd_rec *cmd ) 
{ 
  char *displaylogin ;
  xaset_t *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1868
  pr_auth_endpwent(cmd->tmp_pool);
#line 1869
  pr_auth_endgrent(cmd->tmp_pool);
  }
#line 1877
  if (session.anon_config) {
#line 1877
    tmp = (session.anon_config)->subset;
  } else {
#line 1877
    tmp = main_server->conf;
  }
  {
#line 1877
  tmp___0 = get_param_ptr(tmp, "DisplayLogin", 0);
#line 1877
  displaylogin = (char *)tmp___0;
  }
#line 1878
  if (displaylogin) {
#line 1878
    if ((int )*displaylogin == 47) {
      {
#line 1881
      displaylogin_fh = pr_fsio_open((char const   *)displaylogin, 0);
      }
#line 1882
      if ((unsigned long )displaylogin_fh == (unsigned long )((void *)0)) {
        {
#line 1883
        tmp___1 = __errno_location();
#line 1883
        tmp___2 = strerror(*tmp___1);
#line 1883
        pr_log_debug(6, "unable to open DisplayLogin file \'%s\': %s", displaylogin,
                     tmp___2);
        }
      }
    }
  }
#line 1887
  return ((modret_t *)((void *)0));
}
}
#line 1890 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_pass(cmd_rec *cmd ) 
{ 
  char *user ;
  int res ;
  modret_t *tmp ;
  void *tmp___0 ;
  modret_t *tmp___1 ;
  config_rec *c ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned int max_logins ;
  unsigned int *max ;
  char *denymsg ;
  xaset_t *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  modret_t *tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 1891
  user = (char *)((void *)0);
#line 1892
  res = 0;
#line 1894
  if (logged_in) {
    {
#line 1895
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)"503", (char *)"You are already logged in");
    }
#line 1895
    return (tmp);
  }
  {
#line 1897
  tmp___0 = get_param_ptr((cmd->server)->conf, "USER", 0);
#line 1897
  user = (char *)tmp___0;
  }
#line 1899
  if (! user) {
    {
#line 1900
    remove_config((cmd->server)->conf, "USER", 0);
#line 1901
    remove_config((cmd->server)->conf, "PASS", 0);
#line 1903
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)"503", (char *)"Login with USER first");
    }
#line 1903
    return (tmp___1);
  }
  {
#line 1907
  session.anon_config = (struct config_struc *)((void *)0);
#line 1908
  session.dir_config = (struct config_struc *)((void *)0);
#line 1910
  res = setup_env(cmd->tmp_pool, user, cmd->arg);
  }
#line 1911
  if (res == 1) {
    {
#line 1912
    c = (config_rec *)((void *)0);
#line 1914
    c = add_config_param_set(& (cmd->server)->conf, "authenticated", 1, (void *)0);
#line 1915
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 1916
    *((unsigned char *)*(c->argv + 0)) = (unsigned char)1;
#line 1918
    set_auth_check((int (*)(cmd_rec * ))((void *)0));
#line 1920
    remove_config((cmd->server)->conf, "PASS", 0);
    }
#line 1922
    if (session.sf_flags & (int volatile   )64) {
      {
#line 1923
      tmp___2 = pr_fs_decode_path((cmd->server)->pool, (char const   *)cmd->arg);
#line 1923
      tmp___3 = pstrdup((cmd->server)->pool, (char const   *)tmp___2);
#line 1923
      add_config_param_set(& (cmd->server)->conf, "PASS", 1, tmp___3);
      }
    }
    {
#line 1927
    logged_in = 1;
#line 1928
    tmp___4 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 1928
    return (tmp___4);
  }
  {
#line 1931
  remove_config((cmd->server)->conf, "PASS", 0);
  }
#line 1933
  if (res == 0) {
#line 1934
    max = (unsigned int *)((void *)0);
#line 1935
    denymsg = (char *)((void *)0);
#line 1938
    if (session.anon_config) {
#line 1938
      tmp___5 = (session.anon_config)->subset;
    } else {
#line 1938
      tmp___5 = (cmd->server)->conf;
    }
    {
#line 1938
    tmp___6 = get_param_ptr(tmp___5, "AccessDenyMsg", 0);
#line 1938
    denymsg = (char *)tmp___6;
    }
#line 1938
    if ((unsigned long )denymsg != (unsigned long )((void *)0)) {
      {
#line 1941
      denymsg = sreplace(cmd->tmp_pool, denymsg, "%u", user, (void *)0);
      }
    }
    {
#line 1944
    tmp___7 = get_param_ptr(main_server->conf, "MaxLoginAttempts", 0);
#line 1944
    max = (unsigned int *)tmp___7;
    }
#line 1944
    if ((unsigned long )max == (unsigned long )((void *)0)) {
#line 1946
      max_logins = 3U;
    } else {
#line 1948
      max_logins = *max;
    }
#line 1950
    auth_tries ++;
#line 1950
    if ((unsigned int )auth_tries >= max_logins) {
#line 1951
      if (denymsg) {
        {
#line 1952
        pr_response_send("530", "%s", denymsg);
        }
      } else {
        {
#line 1954
        pr_response_send("530", "Login incorrect.");
        }
      }
      {
#line 1956
      pr_log_auth(5, "Maximum login attempts (%u) exceeded, connection refused", max_logins);
#line 1960
      pr_event_generate("mod_auth.max-login-attempts", (void const   *)session.c);
#line 1962
      end_login(0);
      }
    }
#line 1965
    if (denymsg) {
#line 1965
      tmp___8 = (char const   *)denymsg;
    } else {
#line 1965
      tmp___8 = "Login incorrect.";
    }
    {
#line 1965
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)"530", (char *)tmp___8);
    }
#line 1965
    return (tmp___9);
  }
  {
#line 1968
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1968
  return (tmp___10);
}
}
#line 1971 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_acct(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1972
  pr_response_add("502", "ACCT command not implemented");
#line 1973
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1973
  return (tmp);
}
}
#line 1976 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *auth_rein(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1977
  pr_response_add("502", "REIN command not implemented");
#line 1978
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1978
  return (tmp);
}
}
#line 1984 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_accessdenymsg(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1985
  c = (config_rec *)((void *)0);
#line 1987
  if (cmd->argc - 1 < 1) {
    {
#line 1987
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1987
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1987
    return (tmp___0);
  }
  {
#line 1988
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 1988
  if (! tmp___5) {
    {
#line 1988
    tmp___1 = get_context_name(cmd);
#line 1988
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1988
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1988
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1988
    return (tmp___4);
  }
  {
#line 1990
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 1991
  c->flags |= 1L;
#line 1993
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1993
  return (tmp___6);
}
}
#line 1996 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_accessgrantmsg(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1997
  c = (config_rec *)((void *)0);
#line 1999
  if (cmd->argc - 1 < 1) {
    {
#line 1999
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1999
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1999
    return (tmp___0);
  }
  {
#line 2000
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2000
  if (! tmp___5) {
    {
#line 2000
    tmp___1 = get_context_name(cmd);
#line 2000
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2000
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2000
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2000
    return (tmp___4);
  }
  {
#line 2002
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2003
  c->flags |= 1L;
#line 2005
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2005
  return (tmp___6);
}
}
#line 2008 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_anonrequirepassword(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2009
  bool = -1;
#line 2010
  c = (config_rec *)((void *)0);
#line 2012
  if (cmd->argc - 1 < 1) {
    {
#line 2012
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2012
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2012
    return (tmp___0);
  }
  {
#line 2013
  tmp___5 = check_context(cmd, 1 << 2);
  }
#line 2013
  if (! tmp___5) {
    {
#line 2013
    tmp___1 = get_context_name(cmd);
#line 2013
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2013
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2013
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2013
    return (tmp___4);
  }
  {
#line 2015
  bool = get_boolean(cmd, 1);
  }
#line 2016
  if (bool == -1) {
    {
#line 2017
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2017
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2017
    return (tmp___7);
  }
  {
#line 2019
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2020
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2021
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2023
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2023
  return (tmp___8);
}
}
#line 2026 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_anonrejectpasswords(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  regex_t *preg ;
  int res ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char errstr[200] ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  modret_t *tmp___10 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 2028
  c = (config_rec *)((void *)0);
#line 2029
  preg = (regex_t *)((void *)0);
#line 2032
  if (cmd->argc - 1 < 1) {
    {
#line 2032
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2032
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2032
    return (tmp___0);
  }
  {
#line 2033
  tmp___5 = check_context(cmd, 1 << 2);
  }
#line 2033
  if (! tmp___5) {
    {
#line 2033
    tmp___1 = get_context_name(cmd);
#line 2033
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2033
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2033
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2033
    return (tmp___4);
  }
  {
#line 2035
  preg = pr_regexp_alloc();
#line 2037
  res = regcomp((regex_t */* __restrict  */)preg, (char const   */* __restrict  */)*(cmd->argv + 1),
                1 | (((1 << 1) << 1) << 1));
  }
#line 2038
  if (res != 0) {
#line 2039
    errstr[0] = (char )'\000';
#line 2039
    tmp___6 = 1U;
    {
#line 2039
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2039
      if (tmp___6 >= 200U) {
#line 2039
        goto while_break;
      }
#line 2039
      errstr[tmp___6] = (char)0;
#line 2039
      tmp___6 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2041
    regerror(res, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errstr),
             (size_t )200);
#line 2042
    pr_regexp_free(preg);
#line 2044
    tmp___7 = pstrcat(cmd->tmp_pool, "Unable to compile regex \'", *(cmd->argv + 1),
                      "\': ", errstr, (void *)0);
#line 2044
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 2044
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 2044
    return (tmp___9);
  }
  {
#line 2048
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)preg);
#line 2049
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2049
  return (tmp___10);
}
}
#line 2058 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *add_anonymousgroup(cmd_rec *cmd ) 
{ 
  int argc ;
  config_rec *c ;
  char **argv ;
  array_header *acl ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  void *tmp___6 ;
  char **tmp___7 ;
  int tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2060
  c = (config_rec *)((void *)0);
#line 2061
  argv = (char **)((void *)0);
#line 2062
  acl = (array_header *)((void *)0);
#line 2064
  if (cmd->argc < 2) {
    {
#line 2065
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2065
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2065
    return (tmp___0);
  }
  {
#line 2067
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2067
  if (! tmp___5) {
    {
#line 2067
    tmp___1 = get_context_name(cmd);
#line 2067
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2067
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2067
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2067
    return (tmp___4);
  }
  {
#line 2069
  argv = cmd->argv;
#line 2070
  argc = cmd->argc - 1;
#line 2072
  acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2074
  c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2075
  c->argc = argc;
#line 2076
  tmp___6 = pcalloc(c->pool, (int )((unsigned long )(argc + 1) * sizeof(char *)));
#line 2076
  c->argv = (void **)tmp___6;
#line 2077
  argv = (char **)c->argv;
  }
#line 2079
  if (argc) {
#line 2079
    if (acl) {
      {
#line 2080
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2080
        tmp___8 = argc;
#line 2080
        argc --;
#line 2080
        if (! tmp___8) {
#line 2080
          goto while_break;
        }
        {
#line 2081
        tmp___7 = argv;
#line 2081
        argv ++;
#line 2081
        *tmp___7 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2082
        acl->elts = (void *)((char **)acl->elts + 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 2085
  *argv = (char *)((void *)0);
#line 2087
  pr_log_pri(7, "The \'%s\' directive has been deprecated, and will be removed in future releases",
             *(cmd->argv + 0));
#line 2090
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2090
  return (tmp___9);
}
}
#line 2093 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_authaliasonly(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2094
  bool = -1;
#line 2095
  c = (config_rec *)((void *)0);
#line 2097
  if (cmd->argc - 1 < 1) {
    {
#line 2097
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2097
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2097
    return (tmp___0);
  }
  {
#line 2098
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2098
  if (! tmp___5) {
    {
#line 2098
    tmp___1 = get_context_name(cmd);
#line 2098
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2098
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2098
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2098
    return (tmp___4);
  }
  {
#line 2100
  bool = get_boolean(cmd, 1);
  }
#line 2101
  if (bool == -1) {
    {
#line 2102
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2102
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2102
    return (tmp___7);
  }
  {
#line 2104
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2105
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2106
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2108
  c->flags |= 1L;
#line 2109
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2109
  return (tmp___8);
}
}
#line 2112 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_authusingalias(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2113
  bool = -1;
#line 2114
  c = (config_rec *)((void *)0);
#line 2116
  if (cmd->argc - 1 < 1) {
    {
#line 2116
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2116
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2116
    return (tmp___0);
  }
  {
#line 2117
  tmp___5 = check_context(cmd, 1 << 2);
  }
#line 2117
  if (! tmp___5) {
    {
#line 2117
    tmp___1 = get_context_name(cmd);
#line 2117
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2117
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2117
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2117
    return (tmp___4);
  }
  {
#line 2119
  bool = get_boolean(cmd, 1);
  }
#line 2120
  if (bool == -1) {
    {
#line 2121
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2121
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2121
    return (tmp___7);
  }
  {
#line 2123
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2124
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2125
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2127
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2127
  return (tmp___8);
}
}
#line 2130 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_createhome(cmd_rec *cmd ) 
{ 
  int bool ;
  int start ;
  mode_t mode ;
  mode_t dirmode ;
  char *skel_path ;
  config_rec *c ;
  uid_t cuid ;
  gid_t cgid ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  register unsigned int i___0 ;
  struct stat st ;
  char *tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  modret_t *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  modret_t *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  modret_t *tmp___30 ;
  char *tmp___31 ;
  long tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  modret_t *tmp___35 ;
  char *tmp___36 ;
  uid_t uid ;
  long tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  modret_t *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  gid_t gid ;
  long tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  modret_t *tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  modret_t *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  modret_t *tmp___56 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;

  {
#line 2131
  bool = -1;
#line 2131
  start = 2;
#line 2132
  mode = (mode_t )448;
#line 2132
  dirmode = (mode_t )457;
#line 2133
  skel_path = (char *)((void *)0);
#line 2134
  c = (config_rec *)((void *)0);
#line 2135
  cuid = (uid_t )0;
#line 2136
  cgid = (gid_t )0;
#line 2138
  if (cmd->argc - 1 < 1) {
    {
#line 2139
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2139
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2139
    return (tmp___0);
  }
  {
#line 2141
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2141
  if (! tmp___5) {
    {
#line 2141
    tmp___1 = get_context_name(cmd);
#line 2141
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2141
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2141
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2141
    return (tmp___4);
  }
  {
#line 2143
  bool = get_boolean(cmd, 1);
  }
#line 2144
  if (bool == -1) {
    {
#line 2145
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2145
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2145
    return (tmp___7);
  }
#line 2148
  if (bool == 0) {
    {
#line 2149
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2150
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2151
    *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2153
    tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 2153
    return (tmp___8);
  }
#line 2157
  if (cmd->argc - 1 >= 2) {
    {
#line 2157
    tmp___14 = strcasecmp((char const   *)*(cmd->argv + 2), "dirmode");
    }
#line 2157
    if (tmp___14 != 0) {
      {
#line 2157
      tmp___15 = strcasecmp((char const   *)*(cmd->argv + 2), "skel");
      }
#line 2157
      if (tmp___15 != 0) {
        {
#line 2160
        tmp___9 = (char *)((void *)0);
#line 2162
        tmp___10 = strtol((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& tmp___9),
                          8);
#line 2162
        mode = (mode_t )tmp___10;
        }
#line 2164
        if (tmp___9) {
#line 2164
          if (*tmp___9) {
            {
#line 2165
            tmp___11 = pstrcat(cmd->tmp_pool, ": bad mode parameter: \'", *(cmd->argv + 2),
                               "\'", (void *)0);
#line 2165
            tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___11, (void *)0);
#line 2165
            tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___12);
            }
#line 2165
            return (tmp___13);
          }
        }
#line 2168
        start = 3;
      }
    }
  }
#line 2171
  if (cmd->argc - 1 > 2) {
#line 2175
    i___0 = (unsigned int )start;
    {
#line 2175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2175
      if (! (i___0 < (unsigned int )cmd->argc)) {
#line 2175
        goto while_break;
      }
      {
#line 2176
      tmp___54 = strcasecmp((char const   *)*(cmd->argv + i___0), "skel");
      }
#line 2176
      if (tmp___54 == 0) {
#line 2183
        i___0 ++;
#line 2183
        skel_path = *(cmd->argv + i___0);
#line 2185
        if ((int )*skel_path != 47) {
          {
#line 2186
          tmp___16 = pstrcat(cmd->tmp_pool, "skel path \'", skel_path, "\' is not a full path",
                             (void *)0);
#line 2186
          tmp___17 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___16, (void *)0);
#line 2186
          tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___17);
          }
#line 2186
          return (tmp___18);
        }
        {
#line 2189
        tmp___24 = pr_fsio_stat((char const   *)skel_path, & st);
        }
#line 2189
        if (tmp___24 < 0) {
          {
#line 2190
          tmp___19 = __errno_location();
#line 2190
          tmp___20 = strerror(*tmp___19);
#line 2190
          tmp___21 = pstrcat(cmd->tmp_pool, "unable to stat \'", skel_path, "\': ",
                             tmp___20, (void *)0);
#line 2190
          tmp___22 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___21, (void *)0);
#line 2190
          tmp___23 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___22);
          }
#line 2190
          return (tmp___23);
        }
#line 2193
        if (! ((st.st_mode & 61440U) == 16384U)) {
          {
#line 2194
          tmp___25 = pstrcat(cmd->tmp_pool, "\'", skel_path, "\' is not a directory",
                             (void *)0);
#line 2194
          tmp___26 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___25, (void *)0);
#line 2194
          tmp___27 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___26);
          }
#line 2194
          return (tmp___27);
        }
#line 2198
        if (st.st_mode & (unsigned int )((128 >> 3) >> 3)) {
          {
#line 2199
          tmp___28 = pstrcat(cmd->tmp_pool, "\'", skel_path, "\' is world-writable",
                             (void *)0);
#line 2199
          tmp___29 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___28, (void *)0);
#line 2199
          tmp___30 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___29);
          }
#line 2199
          return (tmp___30);
        }
#line 2203
        i___0 ++;
      } else {
        {
#line 2205
        tmp___53 = strcasecmp((char const   *)*(cmd->argv + i___0), "dirmode");
        }
#line 2205
        if (tmp___53 == 0) {
          {
#line 2206
          tmp___31 = (char *)((void *)0);
#line 2208
          i___0 ++;
#line 2208
          tmp___32 = strtol((char const   */* __restrict  */)*(cmd->argv + i___0),
                            (char **/* __restrict  */)(& tmp___31), 8);
#line 2208
          dirmode = (mode_t )tmp___32;
          }
#line 2210
          if (tmp___31) {
#line 2210
            if (*tmp___31) {
              {
#line 2211
              tmp___33 = pstrcat(cmd->tmp_pool, "bad mode parameter: \'", *(cmd->argv + i___0),
                                 "\'", (void *)0);
#line 2211
              tmp___34 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___33,
                                 (void *)0);
#line 2211
              tmp___35 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___34);
              }
#line 2211
              return (tmp___35);
            }
          }
#line 2215
          i___0 ++;
        } else {
          {
#line 2217
          tmp___52 = strcasecmp((char const   *)*(cmd->argv + i___0), "uid");
          }
#line 2217
          if (tmp___52 == 0) {
            {
#line 2220
            tmp___41 = strcmp((char const   *)*(cmd->argv + (i___0 + 1U)), "~");
            }
#line 2220
            if (tmp___41 != 0) {
              {
#line 2221
              tmp___36 = (char *)((void *)0);
#line 2224
              i___0 ++;
#line 2224
              tmp___37 = strtol((char const   */* __restrict  */)*(cmd->argv + i___0),
                                (char **/* __restrict  */)(& tmp___36), 10);
#line 2224
              uid = (uid_t )tmp___37;
              }
#line 2226
              if (tmp___36) {
#line 2226
                if (*tmp___36) {
                  {
#line 2227
                  tmp___38 = pstrcat(cmd->tmp_pool, "bad UID parameter: \'", *(cmd->argv + i___0),
                                     "\'", (void *)0);
#line 2227
                  tmp___39 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___38,
                                     (void *)0);
#line 2227
                  tmp___40 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                            tmp___39);
                  }
#line 2227
                  return (tmp___40);
                }
              }
#line 2231
              cuid = uid;
            } else {
#line 2234
              cuid = (uid_t )-1;
#line 2235
              i___0 ++;
            }
#line 2239
            i___0 ++;
          } else {
            {
#line 2241
            tmp___51 = strcasecmp((char const   *)*(cmd->argv + i___0), "gid");
            }
#line 2241
            if (tmp___51 == 0) {
              {
#line 2244
              tmp___47 = strcmp((char const   *)*(cmd->argv + (i___0 + 1U)), "~");
              }
#line 2244
              if (tmp___47 != 0) {
                {
#line 2245
                tmp___42 = (char *)((void *)0);
#line 2248
                i___0 ++;
#line 2248
                tmp___43 = strtol((char const   */* __restrict  */)*(cmd->argv + i___0),
                                  (char **/* __restrict  */)(& tmp___42), 10);
#line 2248
                gid = (gid_t )tmp___43;
                }
#line 2250
                if (tmp___42) {
#line 2250
                  if (*tmp___42) {
                    {
#line 2251
                    tmp___44 = pstrcat(cmd->tmp_pool, "bad GID parameter: \'", *(cmd->argv + i___0),
                                       "\'", (void *)0);
#line 2251
                    tmp___45 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___44,
                                       (void *)0);
#line 2251
                    tmp___46 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                              tmp___45);
                    }
#line 2251
                    return (tmp___46);
                  }
                }
#line 2255
                cgid = gid;
              } else {
#line 2258
                cgid = (gid_t )-1;
#line 2259
                i___0 ++;
              }
#line 2263
              i___0 ++;
            } else {
              {
#line 2266
              tmp___48 = pstrcat(cmd->tmp_pool, "unknown parameter: \'", *(cmd->argv + i___0),
                                 "\'", (void *)0);
#line 2266
              tmp___49 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___48,
                                 (void *)0);
#line 2266
              tmp___50 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___49);
              }
#line 2266
              return (tmp___50);
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2272
  c = add_config_param((char const   *)*(cmd->argv + 0), 6, (void *)0, (void *)0,
                       (void *)0, (void *)0, (void *)0, (void *)0);
#line 2275
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2276
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2277
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(mode_t ));
#line 2278
  *((mode_t *)*(c->argv + 1)) = mode;
#line 2279
  *(c->argv + 2) = pcalloc(c->pool, (int )sizeof(mode_t ));
#line 2280
  *((mode_t *)*(c->argv + 2)) = dirmode;
  }
#line 2282
  if (skel_path) {
    {
#line 2283
    tmp___55 = pstrdup(c->pool, (char const   *)skel_path);
#line 2283
    *(c->argv + 3) = (void *)tmp___55;
    }
  }
  {
#line 2285
  *(c->argv + 4) = pcalloc(c->pool, (int )sizeof(uid_t ));
#line 2286
  *((uid_t *)*(c->argv + 4)) = cuid;
#line 2287
  *(c->argv + 5) = pcalloc(c->pool, (int )sizeof(gid_t ));
#line 2288
  *((gid_t *)*(c->argv + 5)) = cgid;
#line 2290
  tmp___56 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2290
  return (tmp___56);
}
}
#line 2293 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *add_defaultroot(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *dir ;
  char **argv ;
  int argc ;
  array_header *acl ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  char **tmp___15 ;
  char **tmp___16 ;
  int tmp___17 ;
  modret_t *tmp___18 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 2297
  acl = (array_header *)((void *)0);
#line 2299
  tmp___3 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2299
  if (! tmp___3) {
    {
#line 2299
    tmp = get_context_name(cmd);
#line 2299
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2299
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2299
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2299
    return (tmp___2);
  }
#line 2301
  if (cmd->argc < 2) {
    {
#line 2302
    tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "syntax: DefaultRoot <directory> [<group-expression>]",
                      (void *)0);
#line 2302
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
    }
#line 2302
    return (tmp___5);
  }
#line 2304
  argv = cmd->argv;
#line 2305
  argc = cmd->argc - 2;
#line 2307
  argv ++;
#line 2307
  dir = *argv;
#line 2310
  if ((int )*dir != 47) {
#line 2310
    if ((int )*dir != 126) {
      {
#line 2312
      tmp___6 = pstrcat(cmd->tmp_pool, "(", dir, ") absolute pathname required", (void *)0);
#line 2312
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2312
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2312
      return (tmp___8);
    }
  }
  {
#line 2315
  tmp___12 = strchr((char const   *)dir, '*');
  }
#line 2315
  if (tmp___12) {
    {
#line 2316
    tmp___9 = pstrcat(cmd->tmp_pool, "(", dir, ") wildcards not allowed in pathname",
                      (void *)0);
#line 2316
    tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___9, (void *)0);
#line 2316
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
    }
#line 2316
    return (tmp___11);
  }
  {
#line 2319
  tmp___13 = strlen((char const   *)dir);
  }
#line 2319
  if ((int )*((dir + tmp___13) - 1) != 47) {
    {
#line 2320
    dir = pstrcat(cmd->tmp_pool, dir, "/", (void *)0);
    }
  }
  {
#line 2322
  acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2324
  c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2326
  c->argc = argc + 1;
#line 2327
  tmp___14 = pcalloc(c->pool, (int )((unsigned long )(argc + 2) * sizeof(char *)));
#line 2327
  c->argv = (void **)tmp___14;
#line 2328
  argv = (char **)c->argv;
#line 2329
  tmp___15 = argv;
#line 2329
  argv ++;
#line 2329
  *tmp___15 = pstrdup(c->pool, (char const   *)dir);
  }
#line 2331
  if (argc) {
#line 2331
    if (acl) {
      {
#line 2332
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2332
        tmp___17 = argc;
#line 2332
        argc --;
#line 2332
        if (! tmp___17) {
#line 2332
          goto while_break;
        }
        {
#line 2333
        tmp___16 = argv;
#line 2333
        argv ++;
#line 2333
        *tmp___16 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2334
        acl->elts = (void *)((char **)acl->elts + 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 2337
  *argv = (char *)((void *)0);
#line 2338
  tmp___18 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2338
  return (tmp___18);
}
}
#line 2341 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *add_defaultchdir(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *dir ;
  char **argv ;
  int argc ;
  array_header *acl ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char **tmp___12 ;
  char **tmp___13 ;
  int tmp___14 ;
  modret_t *tmp___15 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 2345
  acl = (array_header *)((void *)0);
#line 2347
  tmp___3 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2347
  if (! tmp___3) {
    {
#line 2347
    tmp = get_context_name(cmd);
#line 2347
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2347
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2347
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2347
    return (tmp___2);
  }
#line 2349
  if (cmd->argc < 2) {
    {
#line 2350
    tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "syntax: DefaultChdir <directory> [<group-expression>]",
                      (void *)0);
#line 2350
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
    }
#line 2350
    return (tmp___5);
  }
  {
#line 2352
  argv = cmd->argv;
#line 2353
  argc = cmd->argc - 2;
#line 2355
  argv ++;
#line 2355
  dir = *argv;
#line 2357
  tmp___9 = strchr((char const   *)dir, '*');
  }
#line 2357
  if (tmp___9) {
    {
#line 2358
    tmp___6 = pstrcat(cmd->tmp_pool, "(", dir, ") wildcards not allowed in pathname",
                      (void *)0);
#line 2358
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2358
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2358
    return (tmp___8);
  }
  {
#line 2361
  tmp___10 = strlen((char const   *)dir);
  }
#line 2361
  if ((int )*((dir + tmp___10) - 1) != 47) {
    {
#line 2362
    dir = pstrcat(cmd->tmp_pool, dir, "/", (void *)0);
    }
  }
  {
#line 2364
  acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2366
  c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2368
  c->argc = argc + 1;
#line 2369
  tmp___11 = pcalloc(c->pool, (int )((unsigned long )(argc + 2) * sizeof(char *)));
#line 2369
  c->argv = (void **)tmp___11;
#line 2370
  argv = (char **)c->argv;
#line 2371
  tmp___12 = argv;
#line 2371
  argv ++;
#line 2371
  *tmp___12 = pstrdup(c->pool, (char const   *)dir);
  }
#line 2373
  if (argc) {
#line 2373
    if (acl) {
      {
#line 2374
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2374
        tmp___14 = argc;
#line 2374
        argc --;
#line 2374
        if (! tmp___14) {
#line 2374
          goto while_break;
        }
        {
#line 2375
        tmp___13 = argv;
#line 2375
        argv ++;
#line 2375
        *tmp___13 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2376
        acl->elts = (void *)((char **)acl->elts + 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 2379
  *argv = (char *)((void *)0);
#line 2381
  c->flags |= 1L;
#line 2382
  tmp___15 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2382
  return (tmp___15);
}
}
#line 2385 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_displaylogin(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2386
  c = (config_rec *)((void *)0);
#line 2388
  if (cmd->argc - 1 < 1) {
    {
#line 2388
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2388
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2388
    return (tmp___0);
  }
  {
#line 2389
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2389
  if (! tmp___5) {
    {
#line 2389
    tmp___1 = get_context_name(cmd);
#line 2389
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2389
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2389
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2389
    return (tmp___4);
  }
  {
#line 2391
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2392
  c->flags |= 1L;
#line 2394
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2394
  return (tmp___6);
}
}
#line 2397 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_grouppassword(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2398
  c = (config_rec *)((void *)0);
#line 2400
  if (cmd->argc - 1 < 2) {
    {
#line 2400
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2400
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2400
    return (tmp___0);
  }
  {
#line 2401
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2401
  if (! tmp___5) {
    {
#line 2401
    tmp___1 = get_context_name(cmd);
#line 2401
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2401
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2401
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2401
    return (tmp___4);
  }
  {
#line 2403
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 2, *(cmd->argv + 1),
                           *(cmd->argv + 2));
#line 2404
  c->flags |= 1L;
#line 2406
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2406
  return (tmp___6);
}
}
#line 2409 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_loginpasswordprompt(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2410
  bool = -1;
#line 2411
  c = (config_rec *)((void *)0);
#line 2413
  if (cmd->argc - 1 < 1) {
    {
#line 2413
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2413
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2413
    return (tmp___0);
  }
  {
#line 2414
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2414
  if (! tmp___5) {
    {
#line 2414
    tmp___1 = get_context_name(cmd);
#line 2414
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2414
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2414
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2414
    return (tmp___4);
  }
  {
#line 2416
  bool = get_boolean(cmd, 1);
  }
#line 2417
  if (bool == -1) {
    {
#line 2418
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2418
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2418
    return (tmp___7);
  }
  {
#line 2420
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2421
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2422
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2423
  c->flags |= 1L;
#line 2425
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2425
  return (tmp___8);
}
}
#line 2429 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxclientsclass(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *endp ;
  long tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 2433
  tmp___3 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2433
  if (! tmp___3) {
    {
#line 2433
    tmp = get_context_name(cmd);
#line 2433
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2433
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2433
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2433
    return (tmp___2);
  }
  {
#line 2435
  tmp___7 = strcasecmp((char const   *)*(cmd->argv + 2), "none");
  }
#line 2435
  if (tmp___7 == 0) {
#line 2436
    max = 0;
  } else {
    {
#line 2439
    endp = (char *)((void *)0);
#line 2441
    tmp___4 = strtol((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& endp),
                     10);
#line 2441
    max = (int )tmp___4;
    }
#line 2443
    if (endp) {
#line 2443
      if (*endp) {
        {
#line 2444
        tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "max must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2444
        tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
        }
#line 2444
        return (tmp___6);
      } else {
#line 2443
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2443
    if (max < 1) {
      {
#line 2444
      tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "max must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2444
      tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
      }
#line 2444
      return (tmp___6);
    }
  }
#line 2447
  if (cmd->argc == 4) {
    {
#line 2448
    c = add_config_param((char const   *)*(cmd->argv + 0), 3, (void *)0, (void *)0,
                         (void *)0);
#line 2449
    tmp___8 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 2449
    *(c->argv + 0) = (void *)tmp___8;
#line 2450
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2451
    *((unsigned int *)*(c->argv + 1)) = (unsigned int )max;
#line 2452
    tmp___9 = pstrdup(c->pool, (char const   *)*(cmd->argv + 3));
#line 2452
    *(c->argv + 2) = (void *)tmp___9;
    }
  } else {
    {
#line 2455
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2456
    tmp___10 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 2456
    *(c->argv + 0) = (void *)tmp___10;
#line 2457
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2458
    *((unsigned int *)*(c->argv + 1)) = (unsigned int )max;
    }
  }
  {
#line 2461
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2461
  return (tmp___11);
}
}
#line 2465 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxclients(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *endp ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2467
  c = (config_rec *)((void *)0);
#line 2469
  if (cmd->argc < 2) {
    {
#line 2470
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2470
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2470
    return (tmp___0);
  } else
#line 2469
  if (cmd->argc > 3) {
    {
#line 2470
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2470
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2470
    return (tmp___0);
  }
  {
#line 2472
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2472
  if (! tmp___5) {
    {
#line 2472
    tmp___1 = get_context_name(cmd);
#line 2472
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2472
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2472
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2472
    return (tmp___4);
  }
  {
#line 2474
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 2474
  if (tmp___9) {
    {
#line 2478
    endp = (char *)((void *)0);
#line 2480
    tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 2480
    max = (int )tmp___6;
    }
#line 2482
    if (endp) {
#line 2482
      if (*endp) {
        {
#line 2483
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2483
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 2483
        return (tmp___8);
      } else {
#line 2482
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2482
    if (max < 1) {
      {
#line 2483
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2483
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2483
      return (tmp___8);
    }
  } else {
#line 2475
    max = 0;
  }
#line 2486
  if (cmd->argc == 3) {
    {
#line 2487
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2488
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2489
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
#line 2490
    tmp___10 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
#line 2490
    *(c->argv + 1) = (void *)tmp___10;
    }
  } else {
    {
#line 2493
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2494
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2495
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
    }
  }
  {
#line 2498
  c->flags |= 1L;
#line 2500
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2500
  return (tmp___11);
}
}
#line 2504 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxhostclients(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *endp ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2506
  c = (config_rec *)((void *)0);
#line 2508
  if (cmd->argc < 2) {
    {
#line 2509
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2509
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2509
    return (tmp___0);
  } else
#line 2508
  if (cmd->argc > 3) {
    {
#line 2509
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2509
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2509
    return (tmp___0);
  }
  {
#line 2511
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2511
  if (! tmp___5) {
    {
#line 2511
    tmp___1 = get_context_name(cmd);
#line 2511
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2511
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2511
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2511
    return (tmp___4);
  }
  {
#line 2513
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 2513
  if (tmp___9) {
    {
#line 2517
    endp = (char *)((void *)0);
#line 2519
    tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 2519
    max = (int )tmp___6;
    }
#line 2521
    if (endp) {
#line 2521
      if (*endp) {
        {
#line 2522
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2522
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 2522
        return (tmp___8);
      } else {
#line 2521
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2521
    if (max < 1) {
      {
#line 2522
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2522
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2522
      return (tmp___8);
    }
  } else {
#line 2514
    max = 0;
  }
#line 2525
  if (cmd->argc == 3) {
    {
#line 2526
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2527
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2528
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
#line 2529
    tmp___10 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
#line 2529
    *(c->argv + 1) = (void *)tmp___10;
    }
  } else {
    {
#line 2532
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2533
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2534
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
    }
  }
  {
#line 2537
  c->flags |= 1L;
#line 2539
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2539
  return (tmp___11);
}
}
#line 2544 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxuserclients(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *endp ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2546
  c = (config_rec *)((void *)0);
#line 2548
  if (cmd->argc < 2) {
    {
#line 2549
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2549
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2549
    return (tmp___0);
  } else
#line 2548
  if (cmd->argc > 3) {
    {
#line 2549
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2549
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2549
    return (tmp___0);
  }
  {
#line 2551
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2551
  if (! tmp___5) {
    {
#line 2551
    tmp___1 = get_context_name(cmd);
#line 2551
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2551
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2551
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2551
    return (tmp___4);
  }
  {
#line 2553
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 2553
  if (tmp___9) {
    {
#line 2557
    endp = (char *)((void *)0);
#line 2559
    tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 2559
    max = (int )tmp___6;
    }
#line 2561
    if (endp) {
#line 2561
      if (*endp) {
        {
#line 2562
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2562
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 2562
        return (tmp___8);
      } else {
#line 2561
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2561
    if (max < 1) {
      {
#line 2562
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2562
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2562
      return (tmp___8);
    }
  } else {
#line 2554
    max = 0;
  }
#line 2565
  if (cmd->argc == 3) {
    {
#line 2566
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2567
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2568
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
#line 2569
    tmp___10 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
#line 2569
    *(c->argv + 1) = (void *)tmp___10;
    }
  } else {
    {
#line 2572
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2573
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2574
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
    }
  }
  {
#line 2577
  c->flags |= 1L;
#line 2579
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2579
  return (tmp___11);
}
}
#line 2583 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxconnectsperhost(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  modret_t *tmp___12 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2587
  if (cmd->argc < 2) {
    {
#line 2588
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2588
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2588
    return (tmp___0);
  } else
#line 2587
  if (cmd->argc > 3) {
    {
#line 2588
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2588
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2588
    return (tmp___0);
  }
  {
#line 2590
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2590
  if (! tmp___5) {
    {
#line 2590
    tmp___1 = get_context_name(cmd);
#line 2590
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2590
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2590
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2590
    return (tmp___4);
  }
  {
#line 2592
  tmp___10 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 2592
  if (tmp___10 == 0) {
#line 2593
    max = 0;
  } else {
    {
#line 2596
    tmp___6 = (char *)((void *)0);
#line 2598
    tmp___7 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& tmp___6),
                     10);
#line 2598
    max = (int )tmp___7;
    }
#line 2600
    if (tmp___6) {
#line 2600
      if (*tmp___6) {
        {
#line 2601
        tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2601
        tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
        }
#line 2601
        return (tmp___9);
      } else {
#line 2600
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2600
    if (max < 1) {
      {
#line 2601
      tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2601
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
      }
#line 2601
      return (tmp___9);
    }
  }
#line 2604
  if (cmd->argc == 3) {
    {
#line 2605
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2606
    tmp___11 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
#line 2606
    *(c->argv + 1) = (void *)tmp___11;
    }
  } else {
    {
#line 2609
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
    }
  }
  {
#line 2611
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2612
  *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
#line 2614
  tmp___12 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2614
  return (tmp___12);
}
}
#line 2618 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxhostsperuser(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  char *endp ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 2620
  c = (config_rec *)((void *)0);
#line 2622
  tmp___3 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2622
  if (! tmp___3) {
    {
#line 2622
    tmp = get_context_name(cmd);
#line 2622
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2622
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2622
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2622
    return (tmp___2);
  }
#line 2624
  if (cmd->argc < 2) {
    {
#line 2625
    tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                      (void *)0);
#line 2625
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
    }
#line 2625
    return (tmp___5);
  } else
#line 2624
  if (cmd->argc > 3) {
    {
#line 2625
    tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                      (void *)0);
#line 2625
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
    }
#line 2625
    return (tmp___5);
  }
  {
#line 2627
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 2627
  if (tmp___9) {
    {
#line 2631
    endp = (char *)((void *)0);
#line 2633
    tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 2633
    max = (int )tmp___6;
    }
#line 2635
    if (endp) {
#line 2635
      if (*endp) {
        {
#line 2636
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2636
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 2636
        return (tmp___8);
      } else {
#line 2635
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2635
    if (max < 1) {
      {
#line 2636
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2636
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2636
      return (tmp___8);
    }
  } else {
#line 2628
    max = 0;
  }
#line 2639
  if (cmd->argc == 3) {
    {
#line 2640
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2641
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2642
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
#line 2643
    tmp___10 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
#line 2643
    *(c->argv + 1) = (void *)tmp___10;
    }
  } else {
    {
#line 2646
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2647
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2648
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
    }
  }
  {
#line 2651
  c->flags |= 1L;
#line 2653
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2653
  return (tmp___11);
}
}
#line 2656 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_maxloginattempts(cmd_rec *cmd ) 
{ 
  int max ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *endp ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 2658
  c = (config_rec *)((void *)0);
#line 2660
  if (cmd->argc - 1 < 1) {
    {
#line 2660
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2660
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2660
    return (tmp___0);
  }
  {
#line 2661
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2661
  if (! tmp___5) {
    {
#line 2661
    tmp___1 = get_context_name(cmd);
#line 2661
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2661
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2661
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2661
    return (tmp___4);
  }
  {
#line 2663
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 2663
  if (tmp___9) {
    {
#line 2667
    endp = (char *)((void *)0);
#line 2668
    tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 2668
    max = (int )tmp___6;
    }
#line 2670
    if (endp) {
#line 2670
      if (*endp) {
        {
#line 2671
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                          (void *)0);
#line 2671
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 2671
        return (tmp___8);
      } else {
#line 2670
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2670
    if (max < 1) {
      {
#line 2671
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'none\' or a number greater than 0",
                        (void *)0);
#line 2671
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2671
      return (tmp___8);
    }
  } else {
#line 2664
    max = 0;
  }
  {
#line 2674
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2675
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2676
  *((unsigned int *)*(c->argv + 0)) = (unsigned int )max;
#line 2678
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2678
  return (tmp___10);
}
}
#line 2681 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_requirevalidshell(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2682
  bool = -1;
#line 2683
  c = (config_rec *)((void *)0);
#line 2685
  if (cmd->argc - 1 < 1) {
    {
#line 2685
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2685
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2685
    return (tmp___0);
  }
  {
#line 2686
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2686
  if (! tmp___5) {
    {
#line 2686
    tmp___1 = get_context_name(cmd);
#line 2686
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2686
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2686
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2686
    return (tmp___4);
  }
  {
#line 2688
  bool = get_boolean(cmd, 1);
  }
#line 2689
  if (bool == -1) {
    {
#line 2690
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2690
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2690
    return (tmp___7);
  }
  {
#line 2692
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2693
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2694
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2695
  c->flags |= 1L;
#line 2697
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2697
  return (tmp___8);
}
}
#line 2700 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_rootlogin(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2701
  bool = -1;
#line 2702
  c = (config_rec *)((void *)0);
#line 2704
  if (cmd->argc - 1 < 1) {
    {
#line 2704
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2704
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2704
    return (tmp___0);
  }
  {
#line 2705
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2705
  if (! tmp___5) {
    {
#line 2705
    tmp___1 = get_context_name(cmd);
#line 2705
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2705
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2705
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2705
    return (tmp___4);
  }
  {
#line 2707
  bool = get_boolean(cmd, 1);
  }
#line 2708
  if (bool == -1) {
    {
#line 2709
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2709
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2709
    return (tmp___7);
  }
  {
#line 2711
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2712
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2713
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2714
  c->flags |= 1L;
#line 2716
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2716
  return (tmp___8);
}
}
#line 2719 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_rootrevoke(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2720
  bool = -1;
#line 2721
  c = (config_rec *)((void *)0);
#line 2723
  if (cmd->argc - 1 < 1) {
    {
#line 2723
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2723
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2723
    return (tmp___0);
  }
  {
#line 2724
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2724
  if (! tmp___5) {
    {
#line 2724
    tmp___1 = get_context_name(cmd);
#line 2724
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2724
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2724
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2724
    return (tmp___4);
  }
  {
#line 2726
  bool = get_boolean(cmd, 1);
  }
#line 2727
  if (bool == -1) {
    {
#line 2728
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2728
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2728
    return (tmp___7);
  }
  {
#line 2730
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2731
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2732
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2734
  c->flags |= 1L;
#line 2735
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2735
  return (tmp___8);
}
}
#line 2738 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_timeoutlogin(cmd_rec *cmd ) 
{ 
  int timeout ;
  char *endp ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 2739
  timeout = -1;
#line 2740
  endp = (char *)((void *)0);
#line 2741
  c = (config_rec *)((void *)0);
#line 2743
  if (cmd->argc - 1 < 1) {
    {
#line 2743
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2743
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2743
    return (tmp___0);
  }
  {
#line 2744
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2744
  if (! tmp___5) {
    {
#line 2744
    tmp___1 = get_context_name(cmd);
#line 2744
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2744
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2744
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2744
    return (tmp___4);
  }
  {
#line 2746
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   10);
#line 2746
  timeout = (int )tmp___6;
  }
#line 2748
  if (endp) {
#line 2748
    if (*endp) {
      {
#line 2749
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                        (void *)0);
#line 2749
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2749
      return (tmp___8);
    } else {
#line 2748
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2748
  if (timeout < 0) {
    {
#line 2749
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 2749
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2749
    return (tmp___8);
  } else
#line 2748
  if (timeout > 65535) {
    {
#line 2749
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 2749
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2749
    return (tmp___8);
  }
  {
#line 2751
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2752
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 2753
  *((int *)*(c->argv + 0)) = timeout;
#line 2755
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2755
  return (tmp___9);
}
}
#line 2758 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_timeoutsession(cmd_rec *cmd ) 
{ 
  int seconds ;
  int precedence ;
  config_rec *c ;
  int ctxt ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  unsigned char tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  array_header *acl ;
  int argc ;
  char **argv ;
  void *tmp___18 ;
  void *tmp___19 ;
  char **tmp___20 ;
  void *tmp___21 ;
  char **tmp___22 ;
  char **tmp___23 ;
  char **tmp___24 ;
  int tmp___25 ;
  modret_t *tmp___26 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 2759
  seconds = 0;
#line 2759
  precedence = 0;
#line 2760
  c = (config_rec *)((void *)0);
#line 2762
  if (cmd->config) {
#line 2762
    if ((cmd->config)->config_type != 1 << 15) {
#line 2762
      tmp___0 = (cmd->config)->config_type;
    } else {
#line 2762
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2762
    if ((cmd->server)->config_type) {
#line 2762
      tmp = (cmd->server)->config_type;
    } else {
#line 2762
      tmp = 1;
    }
#line 2762
    tmp___0 = tmp;
  }
#line 2762
  ctxt = tmp___0;
#line 2767
  if (cmd->argc - 1 != 1) {
#line 2767
    if (cmd->argc - 1 != 3) {
      {
#line 2768
      tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments",
                        (void *)0);
#line 2768
      tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
      }
#line 2768
      return (tmp___2);
    }
  }
  {
#line 2770
  tmp___7 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2770
  if (! tmp___7) {
    {
#line 2770
    tmp___3 = get_context_name(cmd);
#line 2770
    tmp___4 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___3, " context",
                      (void *)0);
#line 2770
    tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___4, (void *)0);
#line 2770
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
    }
#line 2770
    return (tmp___6);
  }
#line 2775
  if (ctxt & (1 << 6)) {
#line 2776
    precedence = 1;
  } else
#line 2779
  if (ctxt & 1) {
#line 2780
    precedence = 2;
  } else
#line 2779
  if (ctxt & (1 << 4)) {
#line 2780
    precedence = 2;
  } else
#line 2782
  if (ctxt & (1 << 2)) {
#line 2783
    precedence = 3;
  }
  {
#line 2785
  seconds = atoi((char const   *)*(cmd->argv + 1));
  }
#line 2785
  if (seconds < 0) {
    {
#line 2786
    tmp___8 = pstrcat(cmd->tmp_pool, "seconds must be greater than or equal to 0",
                      (void *)0);
#line 2786
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___8, (void *)0);
#line 2786
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 2786
    return (tmp___10);
  } else
#line 2789
  if (seconds == 0) {
    {
#line 2792
    tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 2792
    return (tmp___11);
  }
#line 2795
  if (cmd->argc - 1 == 3) {
    {
#line 2796
    tmp___15 = strcmp((char const   *)*(cmd->argv + 2), "user");
    }
#line 2796
    if (tmp___15) {
      {
#line 2796
      tmp___16 = strcmp((char const   *)*(cmd->argv + 2), "group");
      }
#line 2796
      if (tmp___16) {
        {
#line 2796
        tmp___17 = strcmp((char const   *)*(cmd->argv + 2), "class");
        }
#line 2796
        if (tmp___17) {
          {
#line 2803
          tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": unknown classifier used: \'",
                             *(cmd->argv + 2), "\'", (void *)0);
#line 2803
          tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___12, (void *)0);
#line 2803
          tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___13);
          }
#line 2803
          return (tmp___14);
        }
      }
    }
  }
#line 2807
  if (cmd->argc - 1 == 1) {
    {
#line 2808
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0);
#line 2809
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2810
    *((unsigned int *)*(c->argv + 0)) = (unsigned int )seconds;
#line 2811
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2812
    *((unsigned int *)*(c->argv + 1)) = (unsigned int )precedence;
    }
  } else
#line 2814
  if (cmd->argc - 1 == 3) {
    {
#line 2815
    acl = (array_header *)((void *)0);
#line 2816
    argc = cmd->argc - 3;
#line 2817
    argv = cmd->argv + 2;
#line 2819
    acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2821
    c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2822
    c->argc = argc + 2;
#line 2828
    tmp___18 = pcalloc(c->pool, (int )((unsigned long )(argc + 4) * sizeof(char *)));
#line 2828
    c->argv = (void **)tmp___18;
#line 2833
    argv = (char **)c->argv;
#line 2836
    tmp___19 = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2836
    *argv = (char *)tmp___19;
#line 2837
    tmp___20 = argv;
#line 2837
    argv ++;
#line 2837
    *((unsigned int *)*tmp___20) = (unsigned int )seconds;
#line 2840
    tmp___21 = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2840
    *argv = (char *)tmp___21;
#line 2841
    tmp___22 = argv;
#line 2841
    argv ++;
#line 2841
    *((unsigned int *)*tmp___22) = (unsigned int )precedence;
#line 2844
    tmp___23 = argv;
#line 2844
    argv ++;
#line 2844
    *tmp___23 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
    }
#line 2847
    if (argc) {
#line 2847
      if (acl) {
        {
#line 2848
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2848
          tmp___25 = argc;
#line 2848
          argc --;
#line 2848
          if (! tmp___25) {
#line 2848
            goto while_break;
          }
          {
#line 2849
          tmp___24 = argv;
#line 2849
          argv ++;
#line 2849
          *tmp___24 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2850
          acl->elts = (void *)((char **)acl->elts + 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 2855
    *argv = (char *)((void *)0);
  }
  {
#line 2858
  c->flags |= (long )(1 << 1);
#line 2859
  tmp___26 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2859
  return (tmp___26);
}
}
#line 2862 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_useftpusers(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2863
  bool = -1;
#line 2864
  c = (config_rec *)((void *)0);
#line 2866
  if (cmd->argc - 1 < 1) {
    {
#line 2866
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2866
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2866
    return (tmp___0);
  }
  {
#line 2867
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2867
  if (! tmp___5) {
    {
#line 2867
    tmp___1 = get_context_name(cmd);
#line 2867
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2867
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2867
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2867
    return (tmp___4);
  }
  {
#line 2869
  bool = get_boolean(cmd, 1);
  }
#line 2870
  if (bool == -1) {
    {
#line 2871
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2871
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2871
    return (tmp___7);
  }
  {
#line 2873
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2874
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2875
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2876
  c->flags |= 1L;
#line 2878
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2878
  return (tmp___8);
}
}
#line 2882 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_uselastlog(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2900
  tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "requires lastlog support (--with-lastlog)",
                (void *)0);
#line 2900
  tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
  }
#line 2900
  return (tmp___0);
}
}
#line 2905 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_useralias(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  unsigned char tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2906
  c = (config_rec *)((void *)0);
#line 2908
  if (cmd->argc - 1 < 2) {
    {
#line 2908
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2908
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2908
    return (tmp___0);
  }
  {
#line 2909
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2909
  if (! tmp___5) {
    {
#line 2909
    tmp___1 = get_context_name(cmd);
#line 2909
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2909
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2909
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2909
    return (tmp___4);
  }
  {
#line 2912
  tmp___8 = strcmp((char const   *)*(cmd->argv + 1), (char const   *)*(cmd->argv + 2));
  }
#line 2912
  if (tmp___8 == 0) {
    {
#line 2913
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "alias and real user names must differ",
                      (void *)0);
#line 2913
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2913
    return (tmp___7);
  }
  {
#line 2915
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 2, *(cmd->argv + 1),
                           *(cmd->argv + 2));
#line 2920
  tmp___9 = check_context(cmd, 1 << 2);
  }
#line 2920
  if (! tmp___9) {
#line 2921
    c->flags |= 1L;
  }
  {
#line 2923
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2923
  return (tmp___10);
}
}
#line 2926 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_userdirroot(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2927
  bool = -1;
#line 2928
  c = (config_rec *)((void *)0);
#line 2930
  if (cmd->argc - 1 < 1) {
    {
#line 2930
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2930
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2930
    return (tmp___0);
  }
  {
#line 2931
  tmp___5 = check_context(cmd, 1 << 2);
  }
#line 2931
  if (! tmp___5) {
    {
#line 2931
    tmp___1 = get_context_name(cmd);
#line 2931
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2931
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2931
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2931
    return (tmp___4);
  }
  {
#line 2933
  bool = get_boolean(cmd, 1);
  }
#line 2934
  if (bool == -1) {
    {
#line 2935
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2935
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2935
    return (tmp___7);
  }
  {
#line 2937
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2938
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2939
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2941
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2941
  return (tmp___8);
}
}
#line 2944 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static modret_t *set_userpassword(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2945
  c = (config_rec *)((void *)0);
#line 2947
  if (cmd->argc - 1 < 2) {
    {
#line 2947
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2947
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2947
    return (tmp___0);
  }
  {
#line 2948
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2948
  if (! tmp___5) {
    {
#line 2948
    tmp___1 = get_context_name(cmd);
#line 2948
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2948
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2948
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2948
    return (tmp___4);
  }
  {
#line 2950
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 2, *(cmd->argv + 1),
                           *(cmd->argv + 2));
#line 2951
  c->flags |= 1L;
#line 2953
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2953
  return (tmp___6);
}
}
#line 2959 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static conftable auth_conftab[31]  = 
#line 2959
  {      {(char *)"AccessDenyMsg", & set_accessdenymsg, (module *)((void *)0)}, 
        {(char *)"AccessGrantMsg", & set_accessgrantmsg, (module *)((void *)0)}, 
        {(char *)"AnonRequirePassword", & set_anonrequirepassword, (module *)((void *)0)}, 
        {(char *)"AnonRejectPasswords",
      & set_anonrejectpasswords, (module *)((void *)0)}, 
        {(char *)"AnonymousGroup", & add_anonymousgroup, (module *)((void *)0)}, 
        {(char *)"AuthAliasOnly", & set_authaliasonly, (module *)((void *)0)}, 
        {(char *)"AuthUsingAlias", & set_authusingalias, (module *)((void *)0)}, 
        {(char *)"CreateHome", & set_createhome, (module *)((void *)0)}, 
        {(char *)"DefaultChdir", & add_defaultchdir, (module *)((void *)0)}, 
        {(char *)"DefaultRoot", & add_defaultroot, (module *)((void *)0)}, 
        {(char *)"DisplayLogin", & set_displaylogin, (module *)((void *)0)}, 
        {(char *)"GroupPassword", & set_grouppassword, (module *)((void *)0)}, 
        {(char *)"LoginPasswordPrompt", & set_loginpasswordprompt, (module *)((void *)0)}, 
        {(char *)"MaxClients",
      & set_maxclients, (module *)((void *)0)}, 
        {(char *)"MaxClientsPerClass", & set_maxclientsclass, (module *)((void *)0)}, 
        {(char *)"MaxClientsPerHost",
      & set_maxhostclients, (module *)((void *)0)}, 
        {(char *)"MaxClientsPerUser", & set_maxuserclients, (module *)((void *)0)}, 
        {(char *)"MaxConnectionsPerHost", & set_maxconnectsperhost, (module *)((void *)0)}, 
        {(char *)"MaxHostsPerUser",
      & set_maxhostsperuser, (module *)((void *)0)}, 
        {(char *)"MaxLoginAttempts", & set_maxloginattempts, (module *)((void *)0)}, 
        {(char *)"RequireValidShell", & set_requirevalidshell, (module *)((void *)0)}, 
        {(char *)"RootLogin",
      & set_rootlogin, (module *)((void *)0)}, 
        {(char *)"RootRevoke", & set_rootrevoke, (module *)((void *)0)}, 
        {(char *)"TimeoutLogin", & set_timeoutlogin, (module *)((void *)0)}, 
        {(char *)"TimeoutSession", & set_timeoutsession, (module *)((void *)0)}, 
        {(char *)"UseFtpUsers", & set_useftpusers, (module *)((void *)0)}, 
        {(char *)"UseLastlog", & set_uselastlog, (module *)((void *)0)}, 
        {(char *)"UserAlias", & set_useralias, (module *)((void *)0)}, 
        {(char *)"UserDirRoot", & set_userdirroot, (module *)((void *)0)}, 
        {(char *)"UserPassword", & set_userpassword, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)((void *)0)}};
#line 2993 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
static cmdtable auth_cmdtab[10]  = 
#line 2993
  {      {(unsigned char)1, (char *)"USER", (char *)((void *)0), & auth_pre_user, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)2, (char *)"USER", (char *)((void *)0), & auth_user, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)1, (char *)"PASS", (char *)((void *)0), & auth_pre_pass, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)2, (char *)"PASS", (char *)((void *)0), & auth_pass, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & auth_post_pass, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)5, (char *)"PASS", (char *)((void *)0), & auth_log_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"PASS", (char *)((void *)0), & auth_err_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"ACCT", (char *)((void *)0), & auth_acct, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)2, (char *)"REIN", (char *)((void *)0), & auth_rein, (unsigned char)0,
      (unsigned char)0, 1, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 3008 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth.c"
module auth_module  = 
#line 3008
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"auth", auth_conftab,
    auth_cmdtab, (authtable *)((void *)0), & auth_init, & auth_sess_init, (char *)0,
    (void *)0, 0};
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 728
extern void rewind(FILE *__stream ) ;
#line 95 "/usr/include/pwd.h"
extern struct passwd *fgetpwent(FILE *__stream ) ;
#line 85 "/usr/include/grp.h"
extern struct group *fgetgrent(FILE *__stream ) ;
#line 1073 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) crypt)(char const   *__key ,
                                                                                      char const   *__salt ) ;
#line 193 "../include/modules.h"
modret_t *mod_create_error(cmd_rec *cmd , int mr_errno ) ;
#line 194
modret_t *mod_create_data(cmd_rec *cmd , void *d ) ;
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static authfile_file_t *af_user_file  =    (authfile_file_t *)((void *)0);
#line 81 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static authfile_file_t *af_group_file  =    (authfile_file_t *)((void *)0);
#line 85
static int af_setpwent(void) ;
#line 86
static int af_setgrent(void) ;
#line 260 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static int af_allow_grent(struct group *grp ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int res ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 261
  if (! af_group_file) {
    {
#line 262
    tmp = __errno_location();
#line 262
    *tmp = 1;
    }
#line 263
    return (-1);
  }
#line 267
  if (af_group_file->af_restricted_ids) {
#line 269
    if (grp->gr_gid < af_group_file->af_min_id.gid) {
      {
#line 270
      pr_log_debug(3, "mod_auth_file/0.8.3: skipping group \'%s\': GID (%u) below the minimum allowed (%u)",
                   grp->gr_name, grp->gr_gid, af_group_file->af_min_id.gid);
#line 274
      tmp___0 = __errno_location();
#line 274
      *tmp___0 = 22;
      }
#line 275
      return (-1);
    }
#line 278
    if (grp->gr_gid > af_group_file->af_max_id.gid) {
      {
#line 279
      pr_log_debug(3, "mod_auth_file/0.8.3: skipping group \'%s\': GID (%u) above the maximum allowed (%u)",
                   grp->gr_name, grp->gr_gid, af_group_file->af_max_id.gid);
#line 283
      tmp___1 = __errno_location();
#line 283
      *tmp___1 = 22;
      }
#line 284
      return (-1);
    }
  }
#line 290
  if (af_group_file->af_restricted_names) {
    {
#line 291
    tmp___2 = regexec((regex_t const   */* __restrict  */)af_group_file->af_name_regex,
                      (char const   */* __restrict  */)grp->gr_name, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
#line 291
    res = tmp___2;
    }
#line 293
    if (res != 0) {
#line 293
      if (! af_group_file->af_name_regex_inverted) {
        {
#line 295
        pr_log_debug(3, "mod_auth_file/0.8.3: skipping group \'%s\': name \'%s\' does not meet allowed filter \'%s\'",
                     grp->gr_name, grp->gr_name, af_group_file->af_name_filter);
#line 298
        tmp___3 = __errno_location();
#line 298
        *tmp___3 = 22;
        }
#line 299
        return (-1);
      } else {
#line 293
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 293
    if (res == 0) {
#line 293
      if (af_group_file->af_name_regex_inverted) {
        {
#line 295
        pr_log_debug(3, "mod_auth_file/0.8.3: skipping group \'%s\': name \'%s\' does not meet allowed filter \'%s\'",
                     grp->gr_name, grp->gr_name, af_group_file->af_name_filter);
#line 298
        tmp___3 = __errno_location();
#line 298
        *tmp___3 = 22;
        }
#line 299
        return (-1);
      }
    }
  }
#line 304
  return (0);
}
}
#line 307 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static void af_endgrent(void) 
{ 


  {
#line 308
  if (af_group_file) {
#line 308
    if (af_group_file->af_file) {
      {
#line 310
      fclose(af_group_file->af_file);
#line 311
      af_group_file->af_file = (FILE *)((void *)0);
      }
    }
  }
#line 314
  return;
}
}
#line 317 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static struct group *af_getgrent(void) 
{ 
  struct group *grp ;
  int *tmp ;
  int tmp___0 ;

  {
#line 318
  grp = (struct group *)((void *)0);
#line 320
  if (! af_group_file) {
    {
#line 322
    tmp = __errno_location();
#line 322
    *tmp = 22;
    }
#line 323
    return ((struct group *)((void *)0));
  } else
#line 320
  if (! af_group_file->af_file) {
    {
#line 322
    tmp = __errno_location();
#line 322
    *tmp = 22;
    }
#line 323
    return ((struct group *)((void *)0));
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    pr_signals_handle();
#line 329
    grp = fgetgrent(af_group_file->af_file);
    }
#line 358
    if (! grp) {
#line 359
      goto while_break;
    }
    {
#line 361
    tmp___0 = af_allow_grent(grp);
    }
#line 361
    if (tmp___0 < 0) {
#line 362
      goto while_continue;
    }
#line 364
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return (grp);
}
}
#line 370 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static struct group *af_getgrnam(char const   *name ) 
{ 
  struct group *grp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 371
  grp = (struct group *)((void *)0);
#line 373
  tmp = af_setgrent();
  }
#line 373
  if (tmp < 0) {
#line 374
    return ((struct group *)((void *)0));
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    grp = af_getgrent();
    }
#line 376
    if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 376
      goto while_break;
    }
    {
#line 377
    tmp___0 = strcmp(name, (char const   *)grp->gr_name);
    }
#line 377
    if (tmp___0 == 0) {
#line 380
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (grp);
}
}
#line 387 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static struct group *af_getgrgid(gid_t gid ) 
{ 
  struct group *grp ;
  int tmp ;

  {
  {
#line 388
  grp = (struct group *)((void *)0);
#line 390
  tmp = af_setgrent();
  }
#line 390
  if (tmp < 0) {
#line 391
    return ((struct group *)((void *)0));
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 393
    grp = af_getgrent();
    }
#line 393
    if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 393
      goto while_break;
    }
#line 394
    if (grp->gr_gid == gid) {
#line 397
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (grp);
}
}
#line 404 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static int af_setgrent(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 406
  if (af_group_file) {
#line 407
    if (af_group_file->af_file) {
      {
#line 409
      rewind(af_group_file->af_file);
      }
#line 410
      return (0);
    } else {
      {
#line 413
      af_group_file->af_file = fopen((char const   */* __restrict  */)af_group_file->af_path,
                                     (char const   */* __restrict  */)"r");
      }
#line 414
      if ((unsigned long )af_group_file->af_file == (unsigned long )((void *)0)) {
        {
#line 415
        tmp = __errno_location();
#line 415
        tmp___0 = strerror(*tmp);
#line 415
        pr_log_pri(3, "error: unable to open group file \'%s\': %s", af_group_file->af_path,
                   tmp___0);
        }
#line 417
        return (-1);
      }
      {
#line 420
      pr_log_debug(7, "mod_auth_file/0.8.3: using group file \'%s\'", af_group_file->af_path);
      }
#line 422
      return (0);
    }
  }
  {
#line 426
  tmp___1 = __errno_location();
#line 426
  *tmp___1 = 1;
  }
#line 427
  return (-1);
}
}
#line 430 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static int af_allow_pwent(struct passwd *pwd ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int res ;
  int tmp___2 ;
  int *tmp___3 ;
  int res___0 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 431
  if (! af_user_file) {
    {
#line 432
    tmp = __errno_location();
#line 432
    *tmp = 1;
    }
#line 433
    return (-1);
  }
#line 437
  if (af_user_file->af_restricted_ids) {
#line 439
    if (pwd->pw_uid < af_user_file->af_min_id.uid) {
      {
#line 440
      pr_log_debug(3, "mod_auth_file/0.8.3: skipping user \'%s\': UID (%u) below the minimum allowed (%u)",
                   pwd->pw_name, pwd->pw_uid, af_user_file->af_min_id.uid);
#line 443
      tmp___0 = __errno_location();
#line 443
      *tmp___0 = 22;
      }
#line 444
      return (-1);
    }
#line 447
    if (pwd->pw_uid > af_user_file->af_max_id.gid) {
      {
#line 448
      pr_log_debug(3, "mod_auth_file/0.8.3: skipping user \'%s\': UID (%u) above the maximum allowed (%u)",
                   pwd->pw_name, pwd->pw_uid, af_user_file->af_max_id.uid);
#line 451
      tmp___1 = __errno_location();
#line 451
      *tmp___1 = 22;
      }
#line 452
      return (-1);
    }
  }
#line 458
  if (af_user_file->af_restricted_names) {
    {
#line 459
    tmp___2 = regexec((regex_t const   */* __restrict  */)af_user_file->af_name_regex,
                      (char const   */* __restrict  */)pwd->pw_name, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
#line 459
    res = tmp___2;
    }
#line 461
    if (res != 0) {
#line 461
      if (! af_user_file->af_name_regex_inverted) {
        {
#line 463
        pr_log_debug(3, "mod_auth_file/0.8.3: skipping user \'%s\': name \'%s\' does not meet allowed filter \'%s\'",
                     pwd->pw_name, pwd->pw_name, af_user_file->af_name_filter);
#line 466
        tmp___3 = __errno_location();
#line 466
        *tmp___3 = 22;
        }
#line 467
        return (-1);
      } else {
#line 461
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 461
    if (res == 0) {
#line 461
      if (af_user_file->af_name_regex_inverted) {
        {
#line 463
        pr_log_debug(3, "mod_auth_file/0.8.3: skipping user \'%s\': name \'%s\' does not meet allowed filter \'%s\'",
                     pwd->pw_name, pwd->pw_name, af_user_file->af_name_filter);
#line 466
        tmp___3 = __errno_location();
#line 466
        *tmp___3 = 22;
        }
#line 467
        return (-1);
      }
    }
  }
#line 472
  if (af_user_file->af_restricted_homes) {
    {
#line 474
    tmp___4 = regexec((regex_t const   */* __restrict  */)af_user_file->af_home_regex,
                      (char const   */* __restrict  */)pwd->pw_dir, (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                      0);
#line 474
    res___0 = tmp___4;
    }
#line 476
    if (res___0 != 0) {
#line 476
      if (! af_user_file->af_home_regex_inverted) {
        {
#line 478
        pr_log_debug(3, "mod_auth_file/0.8.3: skipping user \'%s\': home \'%s\' does not meet allowed filter \'%s\'",
                     pwd->pw_name, pwd->pw_dir, af_user_file->af_home_filter);
#line 481
        tmp___5 = __errno_location();
#line 481
        *tmp___5 = 22;
        }
#line 482
        return (-1);
      } else {
#line 476
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 476
    if (res___0 == 0) {
#line 476
      if (af_user_file->af_home_regex_inverted) {
        {
#line 478
        pr_log_debug(3, "mod_auth_file/0.8.3: skipping user \'%s\': home \'%s\' does not meet allowed filter \'%s\'",
                     pwd->pw_name, pwd->pw_dir, af_user_file->af_home_filter);
#line 481
        tmp___5 = __errno_location();
#line 481
        *tmp___5 = 22;
        }
#line 482
        return (-1);
      }
    }
  }
#line 487
  return (0);
}
}
#line 490 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static void af_endpwent(void) 
{ 


  {
#line 491
  if (af_user_file) {
#line 491
    if (af_user_file->af_file) {
      {
#line 493
      fclose(af_user_file->af_file);
#line 494
      af_user_file->af_file = (FILE *)((void *)0);
      }
    }
  }
#line 497
  return;
}
}
#line 500 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static struct passwd *af_getpwent(void) 
{ 
  struct passwd *pwd ;
  int *tmp ;
  int tmp___0 ;

  {
#line 501
  pwd = (struct passwd *)((void *)0);
#line 503
  if (! af_user_file) {
    {
#line 505
    tmp = __errno_location();
#line 505
    *tmp = 22;
    }
#line 506
    return ((struct passwd *)((void *)0));
  } else
#line 503
  if (! af_user_file->af_file) {
    {
#line 505
    tmp = __errno_location();
#line 505
    *tmp = 22;
    }
#line 506
    return ((struct passwd *)((void *)0));
  }
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 511
    pr_signals_handle();
#line 512
    pwd = fgetpwent(af_user_file->af_file);
    }
#line 531
    if (! pwd) {
#line 532
      goto while_break;
    }
    {
#line 534
    tmp___0 = af_allow_pwent(pwd);
    }
#line 534
    if (tmp___0 < 0) {
#line 535
      goto while_continue;
    }
#line 537
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  return (pwd);
}
}
#line 543 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static struct passwd *af_getpwnam(char const   *name ) 
{ 
  struct passwd *pwd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 544
  pwd = (struct passwd *)((void *)0);
#line 546
  tmp = af_setpwent();
  }
#line 546
  if (tmp < 0) {
#line 547
    return ((struct passwd *)((void *)0));
  }
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 549
    pwd = af_getpwent();
    }
#line 549
    if (! ((unsigned long )pwd != (unsigned long )((void *)0))) {
#line 549
      goto while_break;
    }
    {
#line 550
    tmp___0 = strcmp(name, (char const   *)pwd->pw_name);
    }
#line 550
    if (tmp___0 == 0) {
#line 553
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (pwd);
}
}
#line 560 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static char *af_getpwpass(char const   *name ) 
{ 
  struct passwd *pwd ;
  struct passwd *tmp ;
  char *tmp___0 ;

  {
  {
#line 561
  tmp = af_getpwnam(name);
#line 561
  pwd = tmp;
  }
#line 562
  if (pwd) {
#line 562
    tmp___0 = pwd->pw_passwd;
  } else {
#line 562
    tmp___0 = (char *)((void *)0);
  }
#line 562
  return (tmp___0);
}
}
#line 565 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static struct passwd *af_getpwuid(uid_t uid ) 
{ 
  struct passwd *pwd ;
  int tmp ;

  {
  {
#line 566
  pwd = (struct passwd *)((void *)0);
#line 568
  tmp = af_setpwent();
  }
#line 568
  if (tmp < 0) {
#line 569
    return ((struct passwd *)((void *)0));
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 571
    pwd = af_getpwent();
    }
#line 571
    if (! ((unsigned long )pwd != (unsigned long )((void *)0))) {
#line 571
      goto while_break;
    }
#line 572
    if (pwd->pw_uid == uid) {
#line 575
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  return (pwd);
}
}
#line 582 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static int af_setpwent(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 584
  if (af_user_file) {
#line 585
    if (af_user_file->af_file) {
      {
#line 587
      rewind(af_user_file->af_file);
      }
#line 588
      return (0);
    } else {
      {
#line 591
      af_user_file->af_file = fopen((char const   */* __restrict  */)af_user_file->af_path,
                                    (char const   */* __restrict  */)"r");
      }
#line 592
      if ((unsigned long )af_user_file->af_file == (unsigned long )((void *)0)) {
        {
#line 593
        tmp = __errno_location();
#line 593
        tmp___0 = strerror(*tmp);
#line 593
        pr_log_pri(3, "error: unable to open passwd file \'%s\': %s", af_user_file->af_path,
                   tmp___0);
        }
#line 595
        return (-1);
      }
      {
#line 598
      pr_log_debug(7, "mod_auth_file/0.8.3: using passwd file \'%s\'", af_user_file->af_path);
      }
#line 600
      return (0);
    }
  }
  {
#line 604
  tmp___1 = __errno_location();
#line 604
  *tmp___1 = 1;
  }
#line 605
  return (-1);
}
}
#line 611 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_endpwent(cmd_rec *cmd ) 
{ 


  {
  {
#line 612
  af_endpwent();
  }
#line 613
  return ((modret_t *)((void *)0));
}
}
#line 616 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getpwent(cmd_rec *cmd ) 
{ 
  struct passwd *pwd ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
  {
#line 617
  pwd = (struct passwd *)((void *)0);
#line 619
  pwd = af_getpwent();
  }
#line 621
  if (pwd) {
    {
#line 621
    tmp = mod_create_data(cmd, (void *)pwd);
#line 621
    tmp___0 = tmp;
    }
  } else {
#line 621
    tmp___0 = (modret_t *)((void *)0);
  }
#line 621
  return (tmp___0);
}
}
#line 624 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getpwnam(cmd_rec *cmd ) 
{ 
  struct passwd *pwd ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  modret_t *tmp___2 ;

  {
  {
#line 625
  pwd = (struct passwd *)((void *)0);
#line 626
  name = (char const   *)*(cmd->argv + 0);
#line 628
  tmp = af_setpwent();
  }
#line 628
  if (tmp < 0) {
#line 629
    return ((modret_t *)((void *)0));
  }
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 632
    pwd = af_getpwent();
    }
#line 632
    if (! ((unsigned long )pwd != (unsigned long )((void *)0))) {
#line 632
      goto while_break;
    }
    {
#line 633
    tmp___0 = strcmp(name, (char const   *)pwd->pw_name);
    }
#line 633
    if (tmp___0 == 0) {
#line 636
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if (pwd) {
    {
#line 640
    tmp___1 = mod_create_data(cmd, (void *)pwd);
#line 640
    tmp___2 = tmp___1;
    }
  } else {
#line 640
    tmp___2 = (modret_t *)((void *)0);
  }
#line 640
  return (tmp___2);
}
}
#line 643 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getpwuid(cmd_rec *cmd ) 
{ 
  struct passwd *pwd ;
  uid_t uid ;
  int tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 644
  pwd = (struct passwd *)((void *)0);
#line 645
  uid = *((uid_t *)*(cmd->argv + 0));
#line 647
  tmp = af_setpwent();
  }
#line 647
  if (tmp < 0) {
#line 648
    return ((modret_t *)((void *)0));
  }
  {
#line 650
  pwd = af_getpwuid(uid);
  }
#line 652
  if (pwd) {
    {
#line 652
    tmp___0 = mod_create_data(cmd, (void *)pwd);
#line 652
    tmp___1 = tmp___0;
    }
  } else {
#line 652
    tmp___1 = (modret_t *)((void *)0);
  }
#line 652
  return (tmp___1);
}
}
#line 655 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_name2uid(cmd_rec *cmd ) 
{ 
  struct passwd *pwd ;
  int tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 656
  pwd = (struct passwd *)((void *)0);
#line 658
  tmp = af_setpwent();
  }
#line 658
  if (tmp < 0) {
#line 659
    return ((modret_t *)((void *)0));
  }
  {
#line 661
  pwd = af_getpwnam((char const   *)*(cmd->argv + 0));
  }
#line 663
  if (pwd) {
    {
#line 663
    tmp___0 = mod_create_data(cmd, (void *)(& pwd->pw_uid));
#line 663
    tmp___1 = tmp___0;
    }
  } else {
#line 663
    tmp___1 = (modret_t *)((void *)0);
  }
#line 663
  return (tmp___1);
}
}
#line 666 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_setpwent(cmd_rec *cmd ) 
{ 
  int tmp ;

  {
  {
#line 667
  tmp = af_setpwent();
  }
#line 667
  if (tmp == 0) {
#line 668
    return ((modret_t *)((void *)0));
  }
#line 670
  return ((modret_t *)((void *)0));
}
}
#line 673 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_uid2name(cmd_rec *cmd ) 
{ 
  struct passwd *pwd ;
  int tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 674
  pwd = (struct passwd *)((void *)0);
#line 676
  tmp = af_setpwent();
  }
#line 676
  if (tmp < 0) {
#line 677
    return ((modret_t *)((void *)0));
  }
  {
#line 679
  pwd = af_getpwuid(*((uid_t *)*(cmd->argv + 0)));
  }
#line 681
  if (pwd) {
    {
#line 681
    tmp___0 = mod_create_data(cmd, (void *)pwd->pw_name);
#line 681
    tmp___1 = tmp___0;
    }
  } else {
#line 681
    tmp___1 = (modret_t *)((void *)0);
  }
#line 681
  return (tmp___1);
}
}
#line 684 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_endgrent(cmd_rec *cmd ) 
{ 


  {
  {
#line 685
  af_endgrent();
  }
#line 686
  return ((modret_t *)((void *)0));
}
}
#line 689 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getgrent(cmd_rec *cmd ) 
{ 
  struct group *grp ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
  {
#line 690
  grp = (struct group *)((void *)0);
#line 692
  grp = af_getgrent();
  }
#line 694
  if (grp) {
    {
#line 694
    tmp = mod_create_data(cmd, (void *)grp);
#line 694
    tmp___0 = tmp;
    }
  } else {
#line 694
    tmp___0 = (modret_t *)((void *)0);
  }
#line 694
  return (tmp___0);
}
}
#line 697 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getgrgid(cmd_rec *cmd ) 
{ 
  struct group *grp ;
  gid_t gid ;
  int tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 698
  grp = (struct group *)((void *)0);
#line 699
  gid = *((gid_t *)*(cmd->argv + 0));
#line 701
  tmp = af_setgrent();
  }
#line 701
  if (tmp < 0) {
#line 702
    return ((modret_t *)((void *)0));
  }
  {
#line 704
  grp = af_getgrgid(gid);
  }
#line 706
  if (grp) {
    {
#line 706
    tmp___0 = mod_create_data(cmd, (void *)grp);
#line 706
    tmp___1 = tmp___0;
    }
  } else {
#line 706
    tmp___1 = (modret_t *)((void *)0);
  }
#line 706
  return (tmp___1);
}
}
#line 709 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getgrnam(cmd_rec *cmd ) 
{ 
  struct group *grp ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  modret_t *tmp___2 ;

  {
  {
#line 710
  grp = (struct group *)((void *)0);
#line 711
  name = (char const   *)*(cmd->argv + 0);
#line 713
  tmp = af_setgrent();
  }
#line 713
  if (tmp < 0) {
#line 714
    return ((modret_t *)((void *)0));
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 716
    grp = af_getgrent();
    }
#line 716
    if (! ((unsigned long )grp != (unsigned long )((void *)0))) {
#line 716
      goto while_break;
    }
    {
#line 717
    tmp___0 = strcmp(name, (char const   *)grp->gr_name);
    }
#line 717
    if (tmp___0 == 0) {
#line 720
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  if (grp) {
    {
#line 724
    tmp___1 = mod_create_data(cmd, (void *)grp);
#line 724
    tmp___2 = tmp___1;
    }
  } else {
#line 724
    tmp___2 = (modret_t *)((void *)0);
  }
#line 724
  return (tmp___2);
}
}
#line 727 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_getgroups(cmd_rec *cmd ) 
{ 
  struct passwd *pwd ;
  struct group *grp ;
  array_header *gids ;
  array_header *groups ;
  char *name ;
  int tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char **gr_mems ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;

  {
  {
#line 728
  pwd = (struct passwd *)((void *)0);
#line 729
  grp = (struct group *)((void *)0);
#line 730
  gids = (array_header *)((void *)0);
#line 730
  groups = (array_header *)((void *)0);
#line 731
  name = *(cmd->argv + 0);
#line 733
  tmp = af_setpwent();
  }
#line 733
  if (tmp < 0) {
#line 734
    return ((modret_t *)((void *)0));
  }
  {
#line 736
  tmp___0 = af_setgrent();
  }
#line 736
  if (tmp___0 < 0) {
#line 737
    return ((modret_t *)((void *)0));
  }
#line 740
  if (*(cmd->argv + 1)) {
#line 741
    gids = (array_header *)*(cmd->argv + 1);
  }
#line 743
  if (*(cmd->argv + 2)) {
#line 744
    groups = (array_header *)*(cmd->argv + 2);
  }
#line 747
  if (! name) {
    {
#line 748
    tmp___1 = mod_create_error(cmd, -1);
    }
#line 748
    return (tmp___1);
  } else {
    {
#line 747
    pwd = af_getpwnam((char const   *)name);
    }
#line 747
    if (! pwd) {
      {
#line 748
      tmp___1 = mod_create_error(cmd, -1);
      }
#line 748
      return (tmp___1);
    }
  }
#line 751
  if (gids) {
    {
#line 752
    tmp___2 = push_array(gids);
#line 752
    *((gid_t *)tmp___2) = pwd->pw_gid;
    }
  }
#line 754
  if (groups) {
    {
#line 754
    grp = af_getgrgid(pwd->pw_gid);
    }
#line 754
    if ((unsigned long )grp != (unsigned long )((void *)0)) {
      {
#line 756
      tmp___3 = push_array(groups);
#line 756
      *((char **)tmp___3) = pstrdup(session.pool, (char const   *)grp->gr_name);
      }
    }
  }
  {
#line 758
  af_setgrent();
  }
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 763
    grp = af_getgrent();
    }
#line 763
    if ((unsigned long )grp != (unsigned long )((void *)0)) {
#line 763
      if (! grp->gr_mem) {
#line 763
        goto while_break;
      }
    } else {
#line 763
      goto while_break;
    }
#line 765
    gr_mems = (char **)((void *)0);
#line 768
    gr_mems = grp->gr_mem;
    {
#line 768
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 768
      if (! *gr_mems) {
#line 768
        goto while_break___0;
      }
      {
#line 771
      tmp___6 = strcmp((char const   *)*gr_mems, (char const   *)pwd->pw_name);
      }
#line 771
      if (tmp___6 == 0) {
#line 774
        if (gids) {
          {
#line 775
          tmp___4 = push_array(gids);
#line 775
          *((gid_t *)tmp___4) = grp->gr_gid;
          }
        }
#line 777
        if (groups) {
          {
#line 778
          tmp___5 = push_array(groups);
#line 778
          *((char **)tmp___5) = pstrdup(session.pool, (char const   *)grp->gr_name);
          }
        }
      }
#line 768
      gr_mems ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  if (gids) {
#line 783
    if (gids->nelts > 0) {
      {
#line 784
      tmp___7 = mod_create_data(cmd, (void *)(& gids->nelts));
      }
#line 784
      return (tmp___7);
    } else {
#line 783
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 786
  if (groups) {
#line 786
    if (groups->nelts > 0) {
      {
#line 787
      tmp___8 = mod_create_data(cmd, (void *)(& groups->nelts));
      }
#line 787
      return (tmp___8);
    }
  }
#line 789
  return ((modret_t *)((void *)0));
}
}
#line 792 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_gid2name(cmd_rec *cmd ) 
{ 
  struct group *grp ;
  int tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 793
  grp = (struct group *)((void *)0);
#line 795
  tmp = af_setgrent();
  }
#line 795
  if (tmp < 0) {
#line 796
    return ((modret_t *)((void *)0));
  }
  {
#line 798
  grp = af_getgrgid(*((gid_t *)*(cmd->argv + 0)));
  }
#line 800
  if (grp) {
    {
#line 800
    tmp___0 = mod_create_data(cmd, (void *)grp->gr_name);
#line 800
    tmp___1 = tmp___0;
    }
  } else {
#line 800
    tmp___1 = (modret_t *)((void *)0);
  }
#line 800
  return (tmp___1);
}
}
#line 803 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_name2gid(cmd_rec *cmd ) 
{ 
  struct group *grp ;
  int tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;

  {
  {
#line 804
  grp = (struct group *)((void *)0);
#line 806
  tmp = af_setgrent();
  }
#line 806
  if (tmp < 0) {
#line 807
    return ((modret_t *)((void *)0));
  }
  {
#line 809
  grp = af_getgrnam((char const   *)*(cmd->argv + 0));
  }
#line 811
  if (grp) {
    {
#line 811
    tmp___0 = mod_create_data(cmd, (void *)(& grp->gr_gid));
#line 811
    tmp___1 = tmp___0;
    }
  } else {
#line 811
    tmp___1 = (modret_t *)((void *)0);
  }
#line 811
  return (tmp___1);
}
}
#line 814 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_setgrent(cmd_rec *cmd ) 
{ 
  int tmp ;

  {
  {
#line 815
  tmp = af_setgrent();
  }
#line 815
  if (tmp == 0) {
#line 816
    return ((modret_t *)((void *)0));
  }
#line 818
  return ((modret_t *)((void *)0));
}
}
#line 821 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_auth(cmd_rec *cmd ) 
{ 
  char *tmp ;
  char *cleartxt_pass ;
  char const   *name ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  modret_t *tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 822
  tmp = (char *)((void *)0);
#line 822
  cleartxt_pass = (char *)((void *)0);
#line 823
  name = (char const   *)*(cmd->argv + 0);
#line 825
  tmp___0 = af_setpwent();
  }
#line 825
  if (tmp___0 < 0) {
#line 826
    return ((modret_t *)((void *)0));
  }
  {
#line 829
  tmp = af_getpwpass(name);
  }
#line 830
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 837
    return ((modret_t *)((void *)0));
  }
  {
#line 847
  cleartxt_pass = pstrdup(cmd->tmp_pool, (char const   *)tmp);
#line 849
  tmp___2 = pr_auth_check(cmd->tmp_pool, (char const   *)cleartxt_pass, name, (char const   *)*(cmd->argv + 1));
  }
#line 849
  if (tmp___2) {
    {
#line 850
    tmp___1 = mod_create_error(cmd, -3);
    }
#line 850
    return (tmp___1);
  }
  {
#line 852
  session.auth_mech = "mod_auth_file.c";
#line 853
  tmp___3 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 853
  return (tmp___3);
}
}
#line 856 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *authfile_chkpass(cmd_rec *cmd ) 
{ 
  char const   *ciphertxt_pass ;
  char const   *cleartxt_pass ;
  char *crypted_pass ;
  int *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 857
  ciphertxt_pass = (char const   *)*(cmd->argv + 0);
#line 858
  cleartxt_pass = (char const   *)*(cmd->argv + 2);
#line 859
  crypted_pass = (char *)((void *)0);
#line 861
  if (! ciphertxt_pass) {
    {
#line 862
    pr_log_debug(2, "mod_auth_file/0.8.3: missing ciphertext password for comparison");
    }
#line 864
    return ((modret_t *)((void *)0));
  }
#line 867
  if (! cleartxt_pass) {
    {
#line 868
    pr_log_debug(2, "mod_auth_file/0.8.3: missing client-provided password for comparison");
    }
#line 870
    return ((modret_t *)((void *)0));
  }
#line 878
  if (! af_user_file) {
#line 879
    return ((modret_t *)((void *)0));
  }
  {
#line 881
  crypted_pass = crypt(cleartxt_pass, ciphertxt_pass);
  }
#line 882
  if (! crypted_pass) {
    {
#line 883
    tmp = __errno_location();
#line 883
    tmp___0 = strerror(*tmp);
#line 883
    pr_log_debug(0, "mod_auth_file/0.8.3: error using crypt(3): %s", tmp___0);
    }
#line 885
    return ((modret_t *)((void *)0));
  }
  {
#line 888
  tmp___2 = strcmp((char const   *)crypted_pass, ciphertxt_pass);
  }
#line 888
  if (tmp___2 == 0) {
    {
#line 889
    session.auth_mech = "mod_auth_file.c";
#line 890
    tmp___1 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 890
    return (tmp___1);
  }
#line 893
  return ((modret_t *)((void *)0));
}
}
#line 900 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *set_authgroupfile(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  authfile_file_t *file ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  void *tmp___9 ;
  register unsigned int i___0 ;
  gid_t min ;
  gid_t max ;
  char *sep ;
  char *tmp___10 ;
  char *tmp___11 ;
  modret_t *tmp___12 ;
  long tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  long tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  char *filter ;
  regex_t *preg ;
  int res ;
  char errstr[200] ;
  unsigned int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  modret_t *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  modret_t *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  modret_t *tmp___30 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
#line 901
  c = (config_rec *)((void *)0);
#line 902
  file = (authfile_file_t *)((void *)0);
#line 905
  if (cmd->argc - 1 < 1) {
    {
#line 909
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 909
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 909
    return (tmp___0);
  } else
#line 905
  if (cmd->argc - 1 > 5) {
    {
#line 909
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 909
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 909
    return (tmp___0);
  }
  {
#line 911
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 911
  if (! tmp___5) {
    {
#line 911
    tmp___1 = get_context_name(cmd);
#line 911
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 911
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 911
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 911
    return (tmp___4);
  }
#line 913
  if ((int )*(*(cmd->argv + 1)) != 47) {
    {
#line 914
    tmp___6 = pstrcat(cmd->tmp_pool, "unable to use relative path for ", *(cmd->argv + 0),
                      " \'", *(cmd->argv + 1), "\'.", (void *)0);
#line 914
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 914
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 914
    return (tmp___8);
  }
  {
#line 918
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 920
  tmp___9 = pcalloc(c->pool, (int )sizeof(authfile_file_t ));
#line 920
  file = (authfile_file_t *)tmp___9;
#line 921
  file->af_path = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 922
  *(c->argv + 0) = (void *)file;
  }
#line 925
  if (cmd->argc - 1 != 1) {
#line 926
    i___0 = 0U;
#line 928
    i___0 = 2U;
    {
#line 928
    while (1) {
      while_continue: /* CIL Label */ ;
#line 928
      if (! (i___0 < (unsigned int )cmd->argc)) {
#line 928
        goto while_break;
      }
      {
#line 929
      tmp___29 = strcmp((char const   *)*(cmd->argv + i___0), "id");
      }
#line 929
      if (tmp___29 == 0) {
        {
#line 931
        sep = (char *)((void *)0);
#line 931
        tmp___10 = (char *)((void *)0);
#line 937
        i___0 ++;
#line 937
        sep = strchr((char const   *)*(cmd->argv + i___0), '-');
        }
#line 938
        if ((unsigned long )sep == (unsigned long )((void *)0)) {
          {
#line 939
          tmp___11 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted ID restriction parameter",
                             (void *)0);
#line 939
          tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___11);
          }
#line 939
          return (tmp___12);
        }
        {
#line 941
        *sep = (char )'\000';
#line 943
        tmp___13 = strtol((char const   */* __restrict  */)*(cmd->argv + i___0), (char **/* __restrict  */)(& tmp___10),
                          10);
#line 943
        min = (gid_t )tmp___13;
        }
#line 945
        if (tmp___10) {
#line 945
          if (*tmp___10) {
            {
#line 946
            tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted minimum ID",
                               (void *)0);
#line 946
            tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___14);
            }
#line 946
            return (tmp___15);
          }
        }
        {
#line 948
        tmp___10 = (char *)((void *)0);
#line 950
        tmp___16 = strtol((char const   */* __restrict  */)(sep + 1), (char **/* __restrict  */)(& tmp___10),
                          10);
#line 950
        max = (gid_t )tmp___16;
        }
#line 952
        if (tmp___10) {
#line 952
          if (*tmp___10) {
            {
#line 953
            tmp___17 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted maximum ID",
                               (void *)0);
#line 953
            tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___17);
            }
#line 953
            return (tmp___18);
          }
        }
#line 955
        if (min > max) {
          {
#line 956
          tmp___19 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "minimum cannot be larger than maximum",
                             (void *)0);
#line 956
          tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___19);
          }
#line 956
          return (tmp___20);
        }
#line 958
        file->af_min_id.gid = min;
#line 959
        file->af_max_id.gid = max;
#line 960
        file->af_restricted_ids = (unsigned char)1;
      } else {
        {
#line 963
        tmp___28 = strcmp((char const   *)*(cmd->argv + i___0), "name");
        }
#line 963
        if (tmp___28 == 0) {
          {
#line 964
          i___0 ++;
#line 964
          filter = *(cmd->argv + i___0);
#line 965
          preg = (regex_t *)((void *)0);
#line 966
          res = 0;
#line 968
          preg = pr_regexp_alloc();
          }
#line 971
          if ((int )*filter == 33) {
#line 972
            filter ++;
#line 973
            file->af_name_regex_inverted = (unsigned char)1;
          }
          {
#line 976
          res = regcomp((regex_t */* __restrict  */)preg, (char const   */* __restrict  */)filter,
                        1 | (((1 << 1) << 1) << 1));
          }
#line 977
          if (res != 0) {
#line 978
            errstr[0] = (char )'\000';
#line 978
            tmp___21 = 1U;
            {
#line 978
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 978
              if (tmp___21 >= 200U) {
#line 978
                goto while_break___0;
              }
#line 978
              errstr[tmp___21] = (char)0;
#line 978
              tmp___21 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 980
            regerror(res, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errstr),
                     (size_t )sizeof(errstr));
#line 981
            pr_regexp_free(preg);
#line 983
            tmp___22 = pstrcat(cmd->tmp_pool, "\'", filter, "\' failed regex compilation: ",
                               errstr, (void *)0);
#line 983
            tmp___23 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___22, (void *)0);
#line 983
            tmp___24 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___23);
            }
#line 983
            return (tmp___24);
          }
          {
#line 987
          file->af_name_filter = pstrdup(c->pool, (char const   *)*(cmd->argv + i___0));
#line 988
          file->af_name_regex = preg;
#line 989
          file->af_restricted_names = (unsigned char)1;
          }
        } else {
          {
#line 994
          tmp___25 = pstrcat(cmd->tmp_pool, ": unknown restriction \'", *(cmd->argv + i___0),
                             "\'", (void *)0);
#line 994
          tmp___26 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___25, (void *)0);
#line 994
          tmp___27 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___26);
          }
#line 994
          return (tmp___27);
        }
      }
#line 928
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 999
  tmp___30 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 999
  return (tmp___30);
}
}
#line 1003 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static modret_t *set_authuserfile(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  authfile_file_t *file ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  void *tmp___9 ;
  register unsigned int i___0 ;
  uid_t min ;
  uid_t max ;
  char *sep ;
  char *tmp___10 ;
  char *tmp___11 ;
  modret_t *tmp___12 ;
  long tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  long tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  char *filter ;
  regex_t *preg ;
  int res ;
  char errstr[200] ;
  unsigned int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  modret_t *tmp___24 ;
  char *filter___0 ;
  regex_t *preg___0 ;
  int res___0 ;
  char errstr___0[200] ;
  unsigned int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  modret_t *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  modret_t *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  modret_t *tmp___35 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
#line 1004
  c = (config_rec *)((void *)0);
#line 1005
  file = (authfile_file_t *)((void *)0);
#line 1008
  if (cmd->argc - 1 < 1) {
    {
#line 1012
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1012
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1012
    return (tmp___0);
  } else
#line 1008
  if (cmd->argc - 1 > 7) {
    {
#line 1012
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1012
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1012
    return (tmp___0);
  }
  {
#line 1014
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 1014
  if (! tmp___5) {
    {
#line 1014
    tmp___1 = get_context_name(cmd);
#line 1014
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1014
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1014
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1014
    return (tmp___4);
  }
#line 1016
  if ((int )*(*(cmd->argv + 1)) != 47) {
    {
#line 1017
    tmp___6 = pstrcat(cmd->tmp_pool, "unable to use relative path for ", *(cmd->argv + 0),
                      " \'", *(cmd->argv + 1), "\'.", (void *)0);
#line 1017
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 1017
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 1017
    return (tmp___8);
  }
  {
#line 1021
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1023
  tmp___9 = pcalloc(c->pool, (int )sizeof(authfile_file_t ));
#line 1023
  file = (authfile_file_t *)tmp___9;
#line 1024
  file->af_path = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 1025
  *(c->argv + 0) = (void *)file;
  }
#line 1028
  if (cmd->argc - 1 != 1) {
#line 1029
    i___0 = 0U;
#line 1031
    i___0 = 2U;
    {
#line 1031
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1031
      if (! (i___0 < (unsigned int )cmd->argc)) {
#line 1031
        goto while_break;
      }
      {
#line 1032
      tmp___34 = strcmp((char const   *)*(cmd->argv + i___0), "id");
      }
#line 1032
      if (tmp___34 == 0) {
        {
#line 1034
        sep = (char *)((void *)0);
#line 1034
        tmp___10 = (char *)((void *)0);
#line 1040
        i___0 ++;
#line 1040
        sep = strchr((char const   *)*(cmd->argv + i___0), '-');
        }
#line 1041
        if ((unsigned long )sep == (unsigned long )((void *)0)) {
          {
#line 1042
          tmp___11 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted ID restriction parameter",
                             (void *)0);
#line 1042
          tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___11);
          }
#line 1042
          return (tmp___12);
        }
        {
#line 1044
        *sep = (char )'\000';
#line 1046
        tmp___13 = strtol((char const   */* __restrict  */)*(cmd->argv + i___0), (char **/* __restrict  */)(& tmp___10),
                          10);
#line 1046
        min = (uid_t )tmp___13;
        }
#line 1048
        if (tmp___10) {
#line 1048
          if (*tmp___10) {
            {
#line 1049
            tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted minimum ID",
                               (void *)0);
#line 1049
            tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___14);
            }
#line 1049
            return (tmp___15);
          }
        }
        {
#line 1051
        tmp___10 = (char *)((void *)0);
#line 1053
        tmp___16 = strtol((char const   */* __restrict  */)(sep + 1), (char **/* __restrict  */)(& tmp___10),
                          10);
#line 1053
        max = (uid_t )tmp___16;
        }
#line 1055
        if (tmp___10) {
#line 1055
          if (*tmp___10) {
            {
#line 1056
            tmp___17 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted maximum ID",
                               (void *)0);
#line 1056
            tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___17);
            }
#line 1056
            return (tmp___18);
          }
        }
#line 1058
        if (min > max) {
          {
#line 1059
          tmp___19 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "minimum cannot be larger than maximum",
                             (void *)0);
#line 1059
          tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___19);
          }
#line 1059
          return (tmp___20);
        }
#line 1061
        file->af_min_id.uid = min;
#line 1062
        file->af_max_id.uid = max;
#line 1063
        file->af_restricted_ids = (unsigned char)1;
      } else {
        {
#line 1066
        tmp___33 = strcmp((char const   *)*(cmd->argv + i___0), "home");
        }
#line 1066
        if (tmp___33 == 0) {
          {
#line 1067
          i___0 ++;
#line 1067
          filter = *(cmd->argv + i___0);
#line 1068
          preg = (regex_t *)((void *)0);
#line 1069
          res = 0;
#line 1071
          preg = pr_regexp_alloc();
          }
#line 1074
          if ((int )*filter == 33) {
#line 1075
            filter ++;
#line 1076
            file->af_home_regex_inverted = (unsigned char)1;
          }
          {
#line 1079
          res = regcomp((regex_t */* __restrict  */)preg, (char const   */* __restrict  */)filter,
                        1 | (((1 << 1) << 1) << 1));
          }
#line 1080
          if (res != 0) {
#line 1081
            errstr[0] = (char )'\000';
#line 1081
            tmp___21 = 1U;
            {
#line 1081
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1081
              if (tmp___21 >= 200U) {
#line 1081
                goto while_break___0;
              }
#line 1081
              errstr[tmp___21] = (char)0;
#line 1081
              tmp___21 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 1083
            regerror(res, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errstr),
                     (size_t )sizeof(errstr));
#line 1084
            pr_regexp_free(preg);
#line 1086
            tmp___22 = pstrcat(cmd->tmp_pool, "\'", filter, "\' failed regex compilation: ",
                               errstr, (void *)0);
#line 1086
            tmp___23 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___22, (void *)0);
#line 1086
            tmp___24 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___23);
            }
#line 1086
            return (tmp___24);
          }
          {
#line 1090
          file->af_home_filter = pstrdup(c->pool, (char const   *)*(cmd->argv + i___0));
#line 1091
          file->af_home_regex = preg;
#line 1092
          file->af_restricted_homes = (unsigned char)1;
          }
        } else {
          {
#line 1094
          tmp___32 = strcmp((char const   *)*(cmd->argv + i___0), "name");
          }
#line 1094
          if (tmp___32 == 0) {
            {
#line 1095
            i___0 ++;
#line 1095
            filter___0 = *(cmd->argv + i___0);
#line 1096
            preg___0 = (regex_t *)((void *)0);
#line 1097
            res___0 = 0;
#line 1099
            preg___0 = pr_regexp_alloc();
            }
#line 1102
            if ((int )*filter___0 == 33) {
#line 1103
              filter___0 ++;
#line 1104
              file->af_name_regex_inverted = (unsigned char)1;
            }
            {
#line 1107
            res___0 = regcomp((regex_t */* __restrict  */)preg___0, (char const   */* __restrict  */)filter___0,
                              1 | (((1 << 1) << 1) << 1));
            }
#line 1108
            if (res___0 != 0) {
#line 1109
              errstr___0[0] = (char )'\000';
#line 1109
              tmp___25 = 1U;
              {
#line 1109
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1109
                if (tmp___25 >= 200U) {
#line 1109
                  goto while_break___1;
                }
#line 1109
                errstr___0[tmp___25] = (char)0;
#line 1109
                tmp___25 ++;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 1111
              regerror(res___0, (regex_t const   */* __restrict  */)preg___0, (char */* __restrict  */)(errstr___0),
                       (size_t )sizeof(errstr___0));
#line 1112
              pr_regexp_free(preg___0);
#line 1114
              tmp___26 = pstrcat(cmd->tmp_pool, "\'", filter___0, "\' failed regex compilation: ",
                                 errstr___0, (void *)0);
#line 1114
              tmp___27 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___26,
                                 (void *)0);
#line 1114
              tmp___28 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___27);
              }
#line 1114
              return (tmp___28);
            }
            {
#line 1118
            file->af_name_filter = pstrdup(c->pool, (char const   *)*(cmd->argv + i___0));
#line 1119
            file->af_name_regex = preg___0;
#line 1120
            file->af_restricted_names = (unsigned char)1;
            }
          } else {
            {
#line 1125
            tmp___29 = pstrcat(cmd->tmp_pool, ": unknown restriction \'", *(cmd->argv + i___0),
                               "\'", (void *)0);
#line 1125
            tmp___30 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___29, (void *)0);
#line 1125
            tmp___31 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___30);
            }
#line 1125
            return (tmp___31);
          }
        }
      }
#line 1031
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1130
  tmp___35 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1130
  return (tmp___35);
}
}
#line 1136 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static int authfile_sess_init(void) 
{ 
  config_rec *c ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1137
  c = (config_rec *)((void *)0);
#line 1139
  c = find_config(main_server->conf, 1 << 15, "AuthUserFile", 0);
  }
#line 1140
  if (c) {
#line 1141
    af_user_file = (authfile_file_t *)*(c->argv + 0);
  }
  {
#line 1144
  c = find_config(main_server->conf, 1 << 15, "AuthGroupFile", 0);
  }
#line 1145
  if (c) {
#line 1146
    af_group_file = (authfile_file_t *)*(c->argv + 0);
  }
#line 1149
  return (0);
}
}
#line 1155 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static conftable authfile_conftab[3]  = {      {(char *)"AuthGroupFile", & set_authgroupfile, (module *)((void *)0)}, 
        {(char *)"AuthUserFile", & set_authuserfile, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))0, (module *)0}};
#line 1161 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
static authtable authfile_authtab[18]  = 
#line 1161
  {      {0, (char *)"endpwent", & authfile_endpwent, (module *)0}, 
        {0, (char *)"getpwent", & authfile_getpwent, (module *)0}, 
        {0, (char *)"getpwnam", & authfile_getpwnam, (module *)0}, 
        {0, (char *)"getpwuid", & authfile_getpwuid, (module *)0}, 
        {0, (char *)"name2uid", & authfile_name2uid, (module *)0}, 
        {0, (char *)"setpwent", & authfile_setpwent, (module *)0}, 
        {0, (char *)"uid2name", & authfile_uid2name, (module *)0}, 
        {0, (char *)"endgrent", & authfile_endgrent, (module *)0}, 
        {0, (char *)"getgrent", & authfile_getgrent, (module *)0}, 
        {0, (char *)"getgrgid", & authfile_getgrgid, (module *)0}, 
        {0, (char *)"getgrnam", & authfile_getgrnam, (module *)0}, 
        {0, (char *)"getgroups", & authfile_getgroups, (module *)0}, 
        {0, (char *)"gid2name", & authfile_gid2name, (module *)0}, 
        {0, (char *)"name2gid", & authfile_name2gid, (module *)0}, 
        {0, (char *)"setgrent", & authfile_setgrent, (module *)0}, 
        {0, (char *)"auth", & authfile_auth, (module *)0}, 
        {0, (char *)"check", & authfile_chkpass, (module *)0}, 
        {0, (char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)0}};
#line 1189 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_file.c"
module auth_file_module  = 
#line 1189
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"auth_file", authfile_conftab,
    (cmdtable *)((void *)0), authfile_authtab, (int (*)(void))((void *)0), & authfile_sess_init,
    (char *)"mod_auth_file/0.8.3", (void *)0, 0};
#line 73 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 79
extern void endpwent(void) ;
#line 85
extern struct passwd *getpwent(void) ;
#line 111
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 63 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 69
extern void endgrent(void) ;
#line 75
extern struct group *getgrent(void) ;
#line 103
extern struct group *getgrgid(__gid_t __gid ) ;
#line 109
extern struct group *getgrnam(char const   *__name ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 63 "/usr/include/shadow.h"
extern void setspent(void) ;
#line 71
extern void endspent(void) ;
#line 87
extern struct spwd *getspnam(char const   *__name ) ;
#line 98 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static char const   *pwdfname  =    "/etc/passwd";
#line 99 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static char const   *grpfname  =    "/etc/group";
#line 107 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static FILE *pwdf  =    (FILE *)((void *)0);
#line 108 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static FILE *grpf  =    (FILE *)((void *)0);
#line 110
unsigned char persistent_passwd ;
#line 126 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static void p_setpwent(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 127
  if (pwdf) {
    {
#line 128
    rewind(pwdf);
    }
  } else {
    {
#line 131
    pwdf = fopen((char const   */* __restrict  */)pwdfname, (char const   */* __restrict  */)"r");
    }
#line 132
    if ((unsigned long )pwdf == (unsigned long )((void *)0)) {
      {
#line 133
      tmp = __errno_location();
#line 133
      tmp___0 = strerror(*tmp);
#line 133
      pr_log_pri(3, "Unable to open password file %s for reading: %s", pwdfname, tmp___0);
      }
    }
  }
#line 137
  return;
}
}
#line 139 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static void p_endpwent(void) 
{ 


  {
#line 140
  if (pwdf) {
    {
#line 141
    fclose(pwdf);
#line 142
    pwdf = (FILE *)((void *)0);
    }
  }
#line 144
  return;
}
}
#line 146 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static void p_setgrent(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 147
  if (grpf) {
    {
#line 148
    rewind(grpf);
    }
  } else {
    {
#line 151
    grpf = fopen((char const   */* __restrict  */)grpfname, (char const   */* __restrict  */)"r");
    }
#line 152
    if ((unsigned long )grpf == (unsigned long )((void *)0)) {
      {
#line 153
      tmp = __errno_location();
#line 153
      tmp___0 = strerror(*tmp);
#line 153
      pr_log_pri(3, "Unable to open group file %s for reading: %s", grpfname, tmp___0);
      }
    }
  }
#line 161
  return;
}
}
#line 163 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static void p_endgrent(void) 
{ 


  {
#line 164
  if (grpf) {
    {
#line 165
    fclose(grpf);
#line 166
    grpf = (FILE *)((void *)0);
    }
  }
#line 168
  return;
}
}
#line 170 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static struct passwd *p_getpwent(void) 
{ 
  struct passwd *tmp ;

  {
#line 171
  if (! pwdf) {
    {
#line 172
    p_setpwent();
    }
  }
#line 174
  if (! pwdf) {
#line 175
    return ((struct passwd *)((void *)0));
  }
  {
#line 177
  tmp = fgetpwent(pwdf);
  }
#line 177
  return (tmp);
}
}
#line 180 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static struct group *p_getgrent(void) 
{ 
  struct group *gr ;

  {
#line 181
  gr = (struct group *)((void *)0);
#line 183
  if (! grpf) {
    {
#line 184
    p_setgrent();
    }
  }
#line 186
  if (! grpf) {
#line 187
    return ((struct group *)((void *)0));
  }
  {
#line 189
  gr = fgetgrent(grpf);
  }
#line 191
  return (gr);
}
}
#line 194 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static struct passwd *p_getpwnam(char const   *name ) 
{ 
  struct passwd *pw ;
  int tmp ;

  {
  {
#line 195
  pw = (struct passwd *)((void *)0);
#line 197
  p_setpwent();
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 198
    pw = p_getpwent();
    }
#line 198
    if (! ((unsigned long )pw != (unsigned long )((void *)0))) {
#line 198
      goto while_break;
    }
    {
#line 199
    pr_signals_handle();
#line 201
    tmp = strcmp(name, (char const   *)pw->pw_name);
    }
#line 201
    if (tmp == 0) {
#line 202
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (pw);
}
}
#line 208 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static struct passwd *p_getpwuid(uid_t uid ) 
{ 
  struct passwd *pw ;

  {
  {
#line 209
  pw = (struct passwd *)((void *)0);
#line 211
  p_setpwent();
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    pw = p_getpwent();
    }
#line 212
    if (! ((unsigned long )pw != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
    {
#line 213
    pr_signals_handle();
    }
#line 215
    if (pw->pw_uid == uid) {
#line 216
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (pw);
}
}
#line 222 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static struct group *p_getgrnam(char const   *name ) 
{ 
  struct group *gr ;
  int tmp ;

  {
  {
#line 223
  gr = (struct group *)((void *)0);
#line 225
  p_setgrent();
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    gr = p_getgrent();
    }
#line 226
    if (! ((unsigned long )gr != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
    {
#line 227
    pr_signals_handle();
#line 229
    tmp = strcmp(name, (char const   *)gr->gr_name);
    }
#line 229
    if (tmp == 0) {
#line 230
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (gr);
}
}
#line 236 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static struct group *p_getgrgid(gid_t gid ) 
{ 
  struct group *gr ;

  {
  {
#line 237
  gr = (struct group *)((void *)0);
#line 239
  p_setgrent();
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 240
    gr = p_getgrent();
    }
#line 240
    if (! ((unsigned long )gr != (unsigned long )((void *)0))) {
#line 240
      goto while_break;
    }
    {
#line 241
    pr_signals_handle();
    }
#line 243
    if (gr->gr_gid == gid) {
#line 244
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return (gr);
}
}
#line 250 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_setpwent(cmd_rec *cmd ) 
{ 


  {
#line 251
  if (persistent_passwd) {
    {
#line 252
    p_setpwent();
    }
  } else {
    {
#line 255
    setpwent();
    }
  }
#line 257
  return ((modret_t *)((void *)0));
}
}
#line 260 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_endpwent(cmd_rec *cmd ) 
{ 


  {
#line 261
  if (persistent_passwd) {
    {
#line 262
    p_endpwent();
    }
  } else {
    {
#line 265
    endpwent();
    }
  }
#line 267
  return ((modret_t *)((void *)0));
}
}
#line 270 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_setgrent(cmd_rec *cmd ) 
{ 


  {
#line 271
  if (persistent_passwd) {
    {
#line 272
    p_setgrent();
    }
  } else {
    {
#line 275
    setgrent();
    }
  }
#line 277
  return ((modret_t *)((void *)0));
}
}
#line 280 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_endgrent(cmd_rec *cmd ) 
{ 


  {
#line 281
  if (persistent_passwd) {
    {
#line 282
    p_endgrent();
    }
  } else {
    {
#line 285
    endgrent();
    }
  }
#line 287
  return ((modret_t *)((void *)0));
}
}
#line 290 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getgrent(cmd_rec *cmd ) 
{ 
  struct group *gr ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 293
  if (persistent_passwd) {
    {
#line 294
    gr = p_getgrent();
    }
  } else {
    {
#line 297
    gr = getgrent();
    }
  }
#line 299
  if (gr) {
    {
#line 299
    tmp = mod_create_data(cmd, (void *)gr);
#line 299
    tmp___0 = tmp;
    }
  } else {
#line 299
    tmp___0 = (modret_t *)((void *)0);
  }
#line 299
  return (tmp___0);
}
}
#line 302 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getpwent(cmd_rec *cmd ) 
{ 
  struct passwd *pw ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 305
  if (persistent_passwd) {
    {
#line 306
    pw = p_getpwent();
    }
  } else {
    {
#line 309
    pw = getpwent();
    }
  }
#line 311
  if (pw) {
    {
#line 311
    tmp = mod_create_data(cmd, (void *)pw);
#line 311
    tmp___0 = tmp;
    }
  } else {
#line 311
    tmp___0 = (modret_t *)((void *)0);
  }
#line 311
  return (tmp___0);
}
}
#line 314 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getpwuid(cmd_rec *cmd ) 
{ 
  struct passwd *pw ;
  uid_t uid ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 318
  uid = *((uid_t *)*(cmd->argv + 0));
#line 319
  if (persistent_passwd) {
    {
#line 320
    pw = p_getpwuid(uid);
    }
  } else {
    {
#line 323
    pw = getpwuid(uid);
    }
  }
#line 325
  if (pw) {
    {
#line 325
    tmp = mod_create_data(cmd, (void *)pw);
#line 325
    tmp___0 = tmp;
    }
  } else {
#line 325
    tmp___0 = (modret_t *)((void *)0);
  }
#line 325
  return (tmp___0);
}
}
#line 328 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getpwnam(cmd_rec *cmd ) 
{ 
  struct passwd *pw ;
  char const   *name ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 332
  name = (char const   *)*(cmd->argv + 0);
#line 333
  if (persistent_passwd) {
    {
#line 334
    pw = p_getpwnam(name);
    }
  } else {
    {
#line 337
    pw = getpwnam(name);
    }
  }
#line 339
  if (pw) {
    {
#line 339
    tmp = mod_create_data(cmd, (void *)pw);
#line 339
    tmp___0 = tmp;
    }
  } else {
#line 339
    tmp___0 = (modret_t *)((void *)0);
  }
#line 339
  return (tmp___0);
}
}
#line 342 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getgrnam(cmd_rec *cmd ) 
{ 
  struct group *gr ;
  char const   *name ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 346
  name = (char const   *)*(cmd->argv + 0);
#line 347
  if (persistent_passwd) {
    {
#line 348
    gr = p_getgrnam(name);
    }
  } else {
    {
#line 351
    gr = getgrnam(name);
    }
  }
#line 353
  if (gr) {
    {
#line 353
    tmp = mod_create_data(cmd, (void *)gr);
#line 353
    tmp___0 = tmp;
    }
  } else {
#line 353
    tmp___0 = (modret_t *)((void *)0);
  }
#line 353
  return (tmp___0);
}
}
#line 356 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getgrgid(cmd_rec *cmd ) 
{ 
  struct group *gr ;
  gid_t gid ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 360
  gid = *((gid_t *)*(cmd->argv + 0));
#line 361
  if (persistent_passwd) {
    {
#line 362
    gr = p_getgrgid(gid);
    }
  } else {
    {
#line 365
    gr = getgrgid(gid);
    }
  }
#line 367
  if (gr) {
    {
#line 367
    tmp = mod_create_data(cmd, (void *)gr);
#line 367
    tmp___0 = tmp;
    }
  } else {
#line 367
    tmp___0 = (modret_t *)((void *)0);
  }
#line 367
  return (tmp___0);
}
}
#line 371 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static char *_get_pw_info(pool *p , char const   *u , time_t *lstchg , time_t *min ,
                          time_t *max , time_t *warn , time_t *inact , time_t *expire ) 
{ 
  struct spwd *sp ;
  char *cpw ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 374
  cpw = (char *)((void *)0);
#line 376
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c",
               376);
#line 376
  pr_signals_block();
  }
#line 376
  if (! session.disable_id_switching) {
    {
#line 376
    tmp___1 = seteuid((__uid_t )0);
    }
#line 376
    if (tmp___1) {
      {
#line 376
      tmp = __errno_location();
#line 376
      tmp___0 = strerror(*tmp);
#line 376
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 376
    tmp___4 = setegid((__gid_t )0);
    }
#line 376
    if (tmp___4) {
      {
#line 376
      tmp___2 = __errno_location();
#line 376
      tmp___3 = strerror(*tmp___2);
#line 376
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 376
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 376
  pr_signals_unblock();
#line 378
  setspent();
#line 381
  sp = getspnam(u);
  }
#line 383
  if (sp) {
    {
#line 384
    cpw = pstrdup(p, (char const   *)sp->sp_pwdp);
    }
#line 386
    if (lstchg) {
#line 387
      if (sp->sp_lstchg == -1L) {
#line 387
        *lstchg = sp->sp_lstchg;
      } else {
#line 387
        *lstchg = sp->sp_lstchg * 86400L;
      }
    }
#line 389
    if (min) {
#line 390
      if (sp->sp_min == -1L) {
#line 390
        *min = sp->sp_min;
      } else {
#line 390
        *min = sp->sp_min * 86400L;
      }
    }
#line 392
    if (max) {
#line 393
      if (sp->sp_max == -1L) {
#line 393
        *max = sp->sp_max;
      } else {
#line 393
        *max = sp->sp_max * 86400L;
      }
    }
#line 396
    if (warn) {
#line 397
      if (sp->sp_warn == -1L) {
#line 397
        *warn = sp->sp_warn;
      } else {
#line 397
        *warn = sp->sp_warn * 86400L;
      }
    }
#line 401
    if (inact) {
#line 402
      if (sp->sp_inact == -1L) {
#line 402
        *inact = sp->sp_inact;
      } else {
#line 402
        *inact = sp->sp_inact * 86400L;
      }
    }
#line 406
    if (expire) {
#line 407
      if (sp->sp_expire == -1L) {
#line 407
        *expire = sp->sp_expire;
      } else {
#line 407
        *expire = sp->sp_expire * 86400L;
      }
    }
  }
  {
#line 441
  endspent();
#line 442
  pr_signals_block();
  }
#line 442
  if (! session.disable_id_switching) {
    {
#line 442
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c",
                 442);
#line 442
    tmp___8 = geteuid();
    }
#line 442
    if (tmp___8 != 0U) {
      {
#line 442
      tmp___7 = seteuid((__uid_t )0);
      }
#line 442
      if (tmp___7) {
        {
#line 442
        tmp___5 = __errno_location();
#line 442
        tmp___6 = strerror(*tmp___5);
#line 442
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
        }
      }
    }
    {
#line 442
    tmp___11 = setegid(session.gid);
    }
#line 442
    if (tmp___11) {
      {
#line 442
      tmp___9 = __errno_location();
#line 442
      tmp___10 = strerror(*tmp___9);
#line 442
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
      }
    }
    {
#line 442
    tmp___14 = seteuid(session.uid);
    }
#line 442
    if (tmp___14) {
      {
#line 442
      tmp___12 = __errno_location();
#line 442
      tmp___13 = strerror(*tmp___12);
#line 442
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
      }
    }
  } else {
    {
#line 442
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 442
  pr_signals_unblock();
  }
#line 444
  return (cpw);
}
}
#line 560 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_auth(cmd_rec *cmd ) 
{ 
  time_t now ;
  char *cpw ;
  time_t lstchg ;
  time_t max ;
  time_t inact ;
  time_t disable ;
  char const   *name ;
  modret_t *tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  modret_t *tmp___2 ;
  modret_t *tmp___3 ;
  char *__cil_tmp14 ;

  {
  {
#line 563
  lstchg = (time_t )-1;
#line 563
  max = (time_t )-1;
#line 563
  inact = (time_t )-1;
#line 563
  disable = (time_t )-1;
#line 566
  name = (char const   *)*(cmd->argv + 0);
#line 567
  time(& now);
#line 569
  cpw = _get_pw_info(cmd->tmp_pool, name, & lstchg, (time_t *)((void *)0), & max,
                     (time_t *)((void *)0), & inact, & disable);
  }
#line 572
  if (! cpw) {
#line 573
    return ((modret_t *)((void *)0));
  }
  {
#line 575
  tmp___0 = pr_auth_check(cmd->tmp_pool, (char const   *)cpw, (char const   *)*(cmd->argv + 0),
                          (char const   *)*(cmd->argv + 1));
  }
#line 575
  if (tmp___0) {
    {
#line 576
    tmp = mod_create_error(cmd, -3);
    }
#line 576
    return (tmp);
  }
#line 578
  if (lstchg > 0L) {
#line 578
    if (max > 0L) {
#line 578
      if (inact > 0L) {
#line 581
        if (now > (lstchg + max) + inact) {
          {
#line 582
          tmp___1 = mod_create_error(cmd, -4);
          }
#line 582
          return (tmp___1);
        }
      }
    }
  }
#line 584
  if (disable > 0L) {
#line 584
    if (now > disable) {
      {
#line 586
      tmp___2 = mod_create_error(cmd, -5);
      }
#line 586
      return (tmp___2);
    }
  }
  {
#line 588
  session.auth_mech = "mod_auth_unix.c";
#line 589
  tmp___3 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 589
  return (tmp___3);
}
}
#line 597 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_check(cmd_rec *cmd ) 
{ 
  char const   *cpw ;
  char const   *pw ;
  char *tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 598
  cpw = (char const   *)*(cmd->argv + 0);
#line 599
  pw = (char const   *)*(cmd->argv + 2);
#line 769
  tmp = crypt(pw, cpw);
#line 769
  tmp___0 = strcmp((char const   *)tmp, cpw);
  }
#line 769
  if (tmp___0 != 0) {
#line 770
    return ((modret_t *)((void *)0));
  }
  {
#line 778
  session.auth_mech = "mod_auth_unix.c";
#line 779
  tmp___1 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 779
  return (tmp___1);
}
}
#line 782 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_uid2name(cmd_rec *cmd ) 
{ 
  uid_t uid ;
  struct passwd *pw ;
  modret_t *tmp ;

  {
#line 786
  uid = *((uid_t *)*(cmd->argv + 0));
#line 788
  if (persistent_passwd) {
    {
#line 789
    pw = p_getpwuid(uid);
    }
  } else {
    {
#line 792
    pw = getpwuid(uid);
    }
  }
#line 794
  if (pw) {
    {
#line 795
    tmp = mod_create_data(cmd, (void *)pw->pw_name);
    }
#line 795
    return (tmp);
  }
#line 797
  return ((modret_t *)((void *)0));
}
}
#line 800 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_gid2name(cmd_rec *cmd ) 
{ 
  gid_t gid ;
  struct group *gr ;
  modret_t *tmp ;

  {
#line 804
  gid = *((gid_t *)*(cmd->argv + 0));
#line 806
  if (persistent_passwd) {
    {
#line 807
    gr = p_getgrgid(gid);
    }
  } else {
    {
#line 810
    gr = getgrgid(gid);
    }
  }
#line 812
  if (gr) {
    {
#line 813
    tmp = mod_create_data(cmd, (void *)gr->gr_name);
    }
#line 813
    return (tmp);
  }
#line 815
  return ((modret_t *)((void *)0));
}
}
#line 818 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_name2uid(cmd_rec *cmd ) 
{ 
  struct passwd *pw ;
  char const   *name ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 822
  name = (char const   *)*(cmd->argv + 0);
#line 824
  if (persistent_passwd) {
    {
#line 825
    pw = p_getpwnam(name);
    }
  } else {
    {
#line 828
    pw = getpwnam(name);
    }
  }
#line 830
  if (pw) {
    {
#line 830
    tmp = mod_create_data(cmd, (void *)(& pw->pw_uid));
#line 830
    tmp___0 = tmp;
    }
  } else {
#line 830
    tmp___0 = (modret_t *)((void *)0);
  }
#line 830
  return (tmp___0);
}
}
#line 833 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_name2gid(cmd_rec *cmd ) 
{ 
  struct group *gr ;
  char const   *name ;
  modret_t *tmp ;
  modret_t *tmp___0 ;

  {
#line 837
  name = (char const   *)*(cmd->argv + 0);
#line 839
  if (persistent_passwd) {
    {
#line 840
    gr = p_getgrnam(name);
    }
  } else {
    {
#line 843
    gr = getgrnam(name);
    }
  }
#line 845
  if (gr) {
    {
#line 845
    tmp = mod_create_data(cmd, (void *)(& gr->gr_gid));
#line 845
    tmp___0 = tmp;
    }
  } else {
#line 845
    tmp___0 = (modret_t *)((void *)0);
  }
#line 845
  return (tmp___0);
}
}
#line 853 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *pw_getgroups(cmd_rec *cmd ) 
{ 
  struct passwd *pw ;
  struct group *gr ;
  array_header *gids ;
  array_header *groups ;
  char *name ;
  int use_getgrouplist ;
  struct passwd *(*my_getpwnam)(char const   * ) ;
  struct group *(*my_getgrgid)(gid_t  ) ;
  struct group *(*my_getgrent)(void) ;
  void (*my_setgrent)(void) ;
  void *tmp ;
  void *tmp___0 ;
  gid_t group_ids[65536] ;
  int ngroups ;
  register unsigned int i___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char **gr_member ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  modret_t *tmp___9 ;
  modret_t *tmp___10 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 854
  pw = (struct passwd *)((void *)0);
#line 855
  gr = (struct group *)((void *)0);
#line 856
  gids = (array_header *)((void *)0);
#line 856
  groups = (array_header *)((void *)0);
#line 857
  name = (char *)((void *)0);
#line 858
  use_getgrouplist = 0;
#line 861
  my_getpwnam = (struct passwd *(*)(char const   * ))((void *)0);
#line 862
  my_getgrgid = (struct group *(*)(gid_t  ))((void *)0);
#line 863
  my_getgrent = (struct group *(*)(void))((void *)0);
#line 864
  my_setgrent = (void (*)(void))((void *)0);
#line 867
  if (persistent_passwd) {
#line 868
    my_getpwnam = & p_getpwnam;
#line 869
    my_getgrgid = & p_getgrgid;
#line 870
    my_getgrent = & p_getgrent;
#line 871
    my_setgrent = & p_setgrent;
  } else {
#line 874
    my_getpwnam = & getpwnam;
#line 875
    my_getgrgid = & getgrgid;
#line 876
    my_getgrent = & getgrent;
#line 877
    my_setgrent = & setgrent;
  }
#line 886
  use_getgrouplist = 1;
#line 896
  name = *(cmd->argv + 0);
#line 899
  if (*(cmd->argv + 1)) {
#line 900
    gids = (array_header *)*(cmd->argv + 1);
  }
#line 902
  if (*(cmd->argv + 2)) {
#line 903
    groups = (array_header *)*(cmd->argv + 2);
  }
#line 906
  if (! name) {
#line 907
    return ((modret_t *)((void *)0));
  } else {
    {
#line 906
    pw = (*my_getpwnam)((char const   *)name);
    }
#line 906
    if (! pw) {
#line 907
      return ((modret_t *)((void *)0));
    }
  }
#line 910
  if (gids) {
    {
#line 911
    tmp = push_array(gids);
#line 911
    *((gid_t *)tmp) = pw->pw_gid;
    }
  }
#line 913
  if (groups) {
    {
#line 913
    gr = (*my_getgrgid)(pw->pw_gid);
    }
#line 913
    if ((unsigned long )gr != (unsigned long )((void *)0)) {
      {
#line 914
      tmp___0 = push_array(groups);
#line 914
      *((char **)tmp___0) = pstrdup(session.pool, (char const   *)gr->gr_name);
      }
    }
  }
  {
#line 916
  (*my_setgrent)();
  }
#line 918
  if (use_getgrouplist) {
    {
#line 923
    ngroups = 65536;
#line 926
    pr_trace_msg("auth", 4, "using getgrouplist(3) to look up group membership");
#line 929
    memset((void *)(group_ids), 0, (size_t )sizeof(group_ids));
#line 930
    tmp___3 = getgrouplist((char const   *)pw->pw_name, pw->pw_gid, group_ids, & ngroups);
    }
#line 930
    if (tmp___3 < 0) {
      {
#line 931
      tmp___1 = __errno_location();
#line 931
      tmp___2 = strerror(*tmp___1);
#line 931
      pr_log_pri(3, "getgrouplist error: %s", tmp___2);
      }
#line 932
      return ((modret_t *)((void *)0));
    }
#line 935
    i___0 = 0U;
    {
#line 935
    while (1) {
      while_continue: /* CIL Label */ ;
#line 935
      if (! (i___0 < (unsigned int )ngroups)) {
#line 935
        goto while_break;
      }
      {
#line 936
      gr = (*my_getgrgid)(group_ids[i___0]);
      }
#line 937
      if (gr) {
#line 938
        if (gids) {
#line 938
          if (pw->pw_gid != gr->gr_gid) {
            {
#line 939
            tmp___4 = push_array(gids);
#line 939
            *((gid_t *)tmp___4) = gr->gr_gid;
            }
          }
        }
#line 941
        if (groups) {
#line 941
          if (pw->pw_gid != gr->gr_gid) {
            {
#line 942
            tmp___5 = push_array(groups);
#line 942
            *((char **)tmp___5) = pstrdup(session.pool, (char const   *)gr->gr_name);
            }
          }
        }
      }
#line 935
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 949
    gr_member = (char **)((void *)0);
    {
#line 954
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 954
      gr = (*my_getgrent)();
      }
#line 954
      if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 954
        if (! gr->gr_mem) {
#line 954
          goto while_break___0;
        }
      } else {
#line 954
        goto while_break___0;
      }
      {
#line 955
      pr_signals_handle();
#line 958
      gr_member = gr->gr_mem;
      }
      {
#line 958
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 958
        if (! *gr_member) {
#line 958
          goto while_break___1;
        }
        {
#line 961
        tmp___8 = strcmp((char const   *)*gr_member, (char const   *)pw->pw_name);
        }
#line 961
        if (tmp___8 == 0) {
#line 964
          if (gids) {
            {
#line 965
            tmp___6 = push_array(gids);
#line 965
            *((gid_t *)tmp___6) = gr->gr_gid;
            }
          }
#line 967
          if (groups) {
#line 967
            if (pw->pw_gid != gr->gr_gid) {
              {
#line 968
              tmp___7 = push_array(groups);
#line 968
              *((char **)tmp___7) = pstrdup(session.pool, (char const   *)gr->gr_name);
              }
            }
          }
        }
#line 958
        gr_member ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 975
  if (gids) {
#line 975
    if (gids->nelts > 0) {
      {
#line 976
      tmp___9 = mod_create_data(cmd, (void *)(& gids->nelts));
      }
#line 976
      return (tmp___9);
    } else {
#line 975
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 978
  if (groups) {
#line 978
    if (groups->nelts > 0) {
      {
#line 979
      tmp___10 = mod_create_data(cmd, (void *)(& groups->nelts));
      }
#line 979
      return (tmp___10);
    }
  }
#line 981
  return ((modret_t *)((void *)0));
}
}
#line 984 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static modret_t *set_persistentpasswd(cmd_rec *cmd ) 
{ 
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 985
  bool = -1;
#line 987
  if (cmd->argc - 1 < 1) {
    {
#line 987
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 987
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 987
    return (tmp___0);
  }
  {
#line 988
  tmp___5 = check_context(cmd, 1);
  }
#line 988
  if (! tmp___5) {
    {
#line 988
    tmp___1 = get_context_name(cmd);
#line 988
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 988
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 988
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 988
    return (tmp___4);
  }
  {
#line 990
  bool = get_boolean(cmd, 1);
  }
#line 990
  if (bool == -1) {
    {
#line 991
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 991
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 991
    return (tmp___7);
  }
  {
#line 993
  persistent_passwd = (unsigned char )bool;
#line 995
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 995
  return (tmp___8);
}
}
#line 1001 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static void auth_unix_exit_ev(void const   *event_data , void *user_data ) 
{ 


  {
  {
#line 1002
  pr_auth_endpwent(session.pool);
#line 1003
  pr_auth_endgrent(session.pool);
  }
#line 1005
  return;
}
}
#line 1011 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static int auth_unix_init(void) 
{ 


  {
#line 1017
  return (0);
}
}
#line 1020 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static int auth_unix_sess_init(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1021
  pr_event_register(& auth_unix_module, "core.exit", & auth_unix_exit_ev, (void *)0);
  }
#line 1022
  return (0);
}
}
#line 1028 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static conftable auth_unix_conftab[2]  = {      {(char *)"PersistentPasswd", & set_persistentpasswd, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)((void *)0)}};
#line 1033 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
static authtable auth_unix_authtab[18]  = 
#line 1033
  {      {0, (char *)"setpwent", & pw_setpwent, (module *)0}, 
        {0, (char *)"endpwent", & pw_endpwent, (module *)0}, 
        {0, (char *)"setgrent", & pw_setgrent, (module *)0}, 
        {0, (char *)"endgrent", & pw_endgrent, (module *)0}, 
        {0, (char *)"getpwent", & pw_getpwent, (module *)0}, 
        {0, (char *)"getgrent", & pw_getgrent, (module *)0}, 
        {0, (char *)"getpwnam", & pw_getpwnam, (module *)0}, 
        {0, (char *)"getpwuid", & pw_getpwuid, (module *)0}, 
        {0, (char *)"getgrnam", & pw_getgrnam, (module *)0}, 
        {0, (char *)"getgrgid", & pw_getgrgid, (module *)0}, 
        {0, (char *)"auth", & pw_auth, (module *)0}, 
        {0, (char *)"check", & pw_check, (module *)0}, 
        {0, (char *)"uid2name", & pw_uid2name, (module *)0}, 
        {0, (char *)"gid2name", & pw_gid2name, (module *)0}, 
        {0, (char *)"name2uid", & pw_name2uid, (module *)0}, 
        {0, (char *)"name2gid", & pw_name2gid, (module *)0}, 
        {0, (char *)"getgroups", & pw_getgroups, (module *)0}, 
        {0, (char *)((void *)0), (modret_t *(*)(cmd_rec * ))0, (module *)0}};
#line 1054 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_auth_unix.c"
module auth_unix_module  = 
#line 1054
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"auth_unix", auth_unix_conftab,
    (cmdtable *)((void *)0), auth_unix_authtab, & auth_unix_init, & auth_unix_sess_init,
    (char *)0, (void *)0, 0};
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 215
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1))) strtoull)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 597
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template )  __asm__("mkstemp64")  ;
#line 94 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 98
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 193 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 38 "../include/str.h"
char *pstrndup(pool *p , char const   *str , size_t n ) ;
#line 59 "../include/table.h"
int pr_table_add(pr_table_t *tab , char const   *key_data , void *value_data , size_t value_datasz ) ;
#line 142
int pr_table_set(pr_table_t *tab , char const   *key_data , void *value_data , size_t value_datasz ) ;
#line 242 "../include/dirtree.h"
int pr_config_get_xfer_bufsz(void) ;
#line 53 "../include/expr.h"
int pr_expr_eval_class_or(char **expr ) ;
#line 55
int pr_expr_eval_group_or(char **expr ) ;
#line 35 "../include/xferlog.h"
int xferlog_write(long xfertime , char const   *remhost , off_t___0 fsize , char *fname ,
                  char xfertype , char direction , char access_mode , char *user ,
                  char abort_flag ) ;
#line 34 "../include/data.h"
void pr_data_init(char *filename , int direction ) ;
#line 40
void pr_data_reset(void) ;
#line 46
void pr_data_clear_xfer_pool(void) ;
#line 48
int pr_data_get_timeout(int id ) ;
#line 49
void pr_data_set_timeout(int id , int timeout ) ;
#line 68
pr_sendfile_t pr_data_sendfile(int retr_fd , off_t___0 *offset , off_t___0 count ) ;
#line 247 "../include/fsio.h"
int pr_fsio_rename(char const   *rnfm , char const   *rnto ) ;
#line 249
int pr_fsio_unlink(char const   *name ) ;
#line 256
int pr_fsio_read(pr_fh_t *fh , char *buf___2 , size_t size ) ;
#line 276
off_t___0 pr_fsio_lseek(pr_fh_t *fh , off_t___0 offset , int whence ) ;
#line 306
void pr_fs_setcwd(char const   *dir ) ;
#line 32 "../include/throttle.h"
int pr_throttle_have_rate(void) ;
#line 33
void pr_throttle_init(cmd_rec *cmd ) ;
#line 34
void pr_throttle_pause(off_t___0 xferlen , int xfer_ending ) ;
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static pr_fh_t *retr_fh  =    (pr_fh_t *)((void *)0);
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static pr_fh_t *stor_fh  =    (pr_fh_t *)((void *)0);
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static pr_fh_t *displayfilexfer_fh  =    (pr_fh_t *)((void *)0);
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static unsigned char have_prot  =    (unsigned char)0;
#line 64 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static unsigned char have_zmode  =    (unsigned char)0;
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static unsigned char use_sendfile  =    (unsigned char)1;
#line 67
static int xfer_check_limit(cmd_rec *cmd ) ;
#line 70 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_prio_config  =    0;
#line 71 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_prio_curr  =    0;
#line 72 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static unsigned long xfer_prio_flags  =    0UL;
#line 78
static int xfer_prio_adjust(void) ;
#line 79
static int xfer_prio_restore(void) ;
#line 82
static int xfer_parse_cmdlist(char const   *name , config_rec *c , char *cmdlist ) ;
#line 86 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_errno  ;
#line 87 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_logged_sendfile_decline_msg  =    0;
#line 89 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static char const   *trace_channel___0  =    "xfer";
#line 91 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static unsigned long find_max_nbytes(char *directive ) 
{ 
  config_rec *c ;
  unsigned int ctxt_precedence ;
  unsigned char have_user_limit ;
  unsigned char have_group_limit ;
  unsigned char have_class_limit ;
  unsigned char have_all_limit ;
  unsigned long max_nbytes ;
  xaset_t *tmp ;
  xaset_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 92
  c = (config_rec *)((void *)0);
#line 93
  ctxt_precedence = 0U;
#line 96
  max_nbytes = 0UL;
#line 98
  have_all_limit = (unsigned char)0;
#line 98
  have_class_limit = have_all_limit;
#line 98
  have_group_limit = have_class_limit;
#line 98
  have_user_limit = have_group_limit;
#line 101
  if (session.dir_config) {
#line 101
    tmp___0 = (session.dir_config)->subset;
  } else {
#line 101
    if (session.anon_config) {
#line 101
      tmp = (session.anon_config)->subset;
    } else {
#line 101
      tmp = main_server->conf;
    }
#line 101
    tmp___0 = tmp;
  }
  {
#line 101
  c = find_config(tmp___0, 1 << 15, (char const   *)directive, 0);
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! c) {
#line 103
      goto while_break;
    }
#line 111
    if (c->argc > 3) {
      {
#line 112
      tmp___6 = strcmp((char const   *)*(c->argv + 2), "user");
      }
#line 112
      if (tmp___6 == 0) {
        {
#line 114
        tmp___1 = pr_expr_eval_user_or((char **)(c->argv + 3));
        }
#line 114
        if (tmp___1 == 1) {
#line 115
          if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 118
            ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 120
            max_nbytes = *((unsigned long *)*(c->argv + 0));
#line 122
            have_all_limit = (unsigned char)0;
#line 122
            have_class_limit = have_all_limit;
#line 122
            have_group_limit = have_class_limit;
#line 123
            have_user_limit = (unsigned char)1;
          }
        }
      } else {
        {
#line 127
        tmp___5 = strcmp((char const   *)*(c->argv + 2), "group");
        }
#line 127
        if (tmp___5 == 0) {
          {
#line 129
          tmp___2 = pr_expr_eval_group_or((char **)(c->argv + 3));
          }
#line 129
          if (tmp___2 == 1) {
#line 130
            if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 133
              ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 135
              max_nbytes = *((unsigned long *)*(c->argv + 0));
#line 137
              have_all_limit = (unsigned char)0;
#line 137
              have_class_limit = have_all_limit;
#line 137
              have_user_limit = have_class_limit;
#line 138
              have_group_limit = (unsigned char)1;
            }
          }
        } else {
          {
#line 142
          tmp___4 = strcmp((char const   *)*(c->argv + 2), "class");
          }
#line 142
          if (tmp___4 == 0) {
            {
#line 144
            tmp___3 = pr_expr_eval_class_or((char **)(c->argv + 3));
            }
#line 144
            if (tmp___3 == 1) {
#line 145
              if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 148
                ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 150
                max_nbytes = *((unsigned long *)*(c->argv + 0));
#line 152
                have_all_limit = (unsigned char)0;
#line 152
                have_group_limit = have_all_limit;
#line 152
                have_user_limit = have_group_limit;
#line 153
                have_class_limit = (unsigned char)1;
              }
            }
          }
        }
      }
    } else
#line 160
    if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 163
      ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 165
      max_nbytes = *((unsigned long *)*(c->argv + 0));
#line 167
      have_class_limit = (unsigned char)0;
#line 167
      have_group_limit = have_class_limit;
#line 167
      have_user_limit = have_group_limit;
#line 168
      have_all_limit = (unsigned char)1;
    }
    {
#line 172
    c = find_config_next(c, c->next, 1 << 15, (char const   *)directive, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  if (max_nbytes > 0UL) {
#line 176
    if (have_user_limit) {
#line 176
      goto _L;
    } else
#line 176
    if (have_group_limit) {
#line 176
      goto _L;
    } else
#line 176
    if (have_class_limit) {
#line 176
      goto _L;
    } else
#line 176
    if (have_all_limit) {
      _L: /* CIL Label */ 
#line 179
      if (have_user_limit) {
#line 179
        tmp___9 = "user ";
      } else {
#line 179
        if (have_group_limit) {
#line 179
          tmp___8 = "group ";
        } else {
#line 179
          if (have_class_limit) {
#line 179
            tmp___7 = "class ";
          } else {
#line 179
            tmp___7 = "all";
          }
#line 179
          tmp___8 = tmp___7;
        }
#line 179
        tmp___9 = tmp___8;
      }
      {
#line 179
      pr_log_debug(5, "%s (%lu bytes) in effect for %s", directive, max_nbytes, tmp___9);
      }
    }
  }
#line 185
  return (max_nbytes);
}
}
#line 188 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static unsigned long parse_max_nbytes(char *nbytes_str , char *units_str ) 
{ 
  long res ;
  unsigned long nbytes ;
  char *endp ;
  float units_factor ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 191
  endp = (char *)((void *)0);
#line 192
  units_factor = (float )0.0;
#line 195
  xfer_errno = 0;
#line 199
  tmp___2 = strcasecmp("Gb", (char const   *)units_str);
  }
#line 199
  if (tmp___2) {
    {
#line 202
    tmp___1 = strcasecmp("Mb", (char const   *)units_str);
    }
#line 202
    if (tmp___1) {
      {
#line 205
      tmp___0 = strcasecmp("Kb", (char const   *)units_str);
      }
#line 205
      if (tmp___0) {
        {
#line 208
        tmp = strcasecmp("b", (char const   *)units_str);
        }
#line 208
        if (tmp) {
#line 212
          xfer_errno = 22;
#line 213
          return (0UL);
        } else {
#line 209
          units_factor = (float )1.0;
        }
      } else {
#line 206
        units_factor = (float )1024.0;
      }
    } else {
#line 203
      units_factor = (float )(1024.0 * 1024.0);
    }
  } else {
#line 200
    units_factor = (float )((1024.0 * 1024.0) * 1024.0);
  }
  {
#line 217
  tmp___3 = __ctype_b_loc();
  }
#line 217
  if (! ((int const   )*(*tmp___3 + (int )*nbytes_str) & 2048)) {
#line 218
    xfer_errno = 22;
#line 219
    return (0UL);
  }
  {
#line 225
  res = strtol((char const   */* __restrict  */)nbytes_str, (char **/* __restrict  */)(& endp),
               10);
#line 227
  tmp___4 = __errno_location();
  }
#line 227
  if (*tmp___4 == 34) {
#line 228
    xfer_errno = 34;
#line 229
    return (0UL);
  }
#line 232
  if (endp) {
#line 232
    if (*endp) {
#line 233
      xfer_errno = 22;
#line 234
      return (0UL);
    }
  }
#line 240
  if ((float )res > (float )4294967295UL / units_factor) {
#line 241
    xfer_errno = 34;
#line 242
    return (0UL);
  }
#line 245
  nbytes = (unsigned long )((float )((unsigned long )res) * units_factor);
#line 246
  return (nbytes);
}
}
#line 249 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void _log_transfer(char direction , char abort_flag ) 
{ 
  struct timeval end_time ;
  char *fullpath ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 251
  fullpath = (char *)((void *)0);
#line 253
  memset((void *)(& end_time), '\000', (size_t )sizeof(end_time));
  }
#line 255
  if (session.xfer.start_time.tv_sec != 0L) {
    {
#line 256
    gettimeofday((struct timeval */* __restrict  */)(& end_time), (__timezone_ptr_t )((void *)0));
#line 257
    end_time.tv_sec -= session.xfer.start_time.tv_sec;
    }
#line 259
    if (end_time.tv_usec >= session.xfer.start_time.tv_usec) {
#line 260
      end_time.tv_usec -= session.xfer.start_time.tv_usec;
    } else {
#line 263
      end_time.tv_usec = 1000000L - (session.xfer.start_time.tv_usec - end_time.tv_usec);
#line 265
      (end_time.tv_sec) --;
    }
  }
  {
#line 269
  fullpath = dir_abs_path(session.xfer.p, (char const   *)session.xfer.path, 1);
  }
#line 271
  if ((session.sf_flags & (int volatile   )64) != (int volatile   )0) {
#line 272
    if (session.sf_flags & (int volatile   )16) {
#line 272
      tmp = 'a';
    } else {
#line 272
      tmp = 'b';
    }
    {
#line 272
    tmp___0 = pr_netaddr_get_sess_remote_name();
#line 272
    xferlog_write(end_time.tv_sec, tmp___0, session.xfer.total_bytes, fullpath, (char )tmp,
                  direction, (char )'a', session.anon_user, abort_flag);
    }
  } else {
#line 278
    if (session.sf_flags & (int volatile   )16) {
#line 278
      tmp___1 = 'a';
    } else {
#line 278
      tmp___1 = 'b';
    }
    {
#line 278
    tmp___2 = pr_netaddr_get_sess_remote_name();
#line 278
    xferlog_write(end_time.tv_sec, tmp___2, session.xfer.total_bytes, fullpath, (char )tmp___1,
                  direction, (char )'r', session.user, abort_flag);
    }
  }
#line 284
  if ((int )abort_flag == 99) {
#line 284
    tmp___3 = "completed:";
  } else {
#line 284
    tmp___3 = "aborted after";
  }
  {
#line 284
  pr_log_debug(1, "Transfer %s %llu bytes in %ld.%02lu seconds", tmp___3, (unsigned long long )session.xfer.total_bytes,
               end_time.tv_sec, (unsigned long )(end_time.tv_usec / 10000L));
  }
#line 288
  return;
}
}
#line 293 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static char *get_cmd_from_list(char **list ) 
{ 
  char *res ;
  char *dst ;
  unsigned char quote_mode ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 294
  res = (char *)((void *)0);
#line 294
  dst = (char *)((void *)0);
#line 295
  quote_mode = (unsigned char)0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (*(*list)) {
      {
#line 297
      tmp = __ctype_b_loc();
      }
#line 297
      if (! ((int const   )*(*tmp + (int )*(*list)) & 8192)) {
#line 297
        goto while_break;
      }
    } else {
#line 297
      goto while_break;
    }
#line 298
    (*list) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  if (! *(*list)) {
#line 301
    return ((char *)((void *)0));
  }
#line 303
  dst = *list;
#line 303
  res = dst;
#line 305
  if ((int )*(*list) == 34) {
#line 306
    quote_mode = (unsigned char)1;
#line 307
    (*list) ++;
  }
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 310
    if (*(*list)) {
#line 310
      if ((int )*(*list) != 44) {
#line 310
        if (quote_mode) {
#line 310
          tmp___3 = (int )*(*list) != 34;
        } else {
          {
#line 310
          tmp___1 = __ctype_b_loc();
          }
#line 310
          if ((int const   )*(*tmp___1 + (int )*(*list)) & 8192) {
#line 310
            tmp___2 = 0;
          } else {
#line 310
            tmp___2 = 1;
          }
#line 310
          tmp___3 = tmp___2;
        }
#line 310
        if (! tmp___3) {
#line 310
          goto while_break___0;
        }
      } else {
#line 310
        goto while_break___0;
      }
    } else {
#line 310
      goto while_break___0;
    }
#line 313
    if ((int )*(*list) == 92) {
#line 313
      if (quote_mode) {
#line 316
        if (*(*list + 1)) {
#line 317
          (*list) ++;
#line 317
          *dst = *(*list);
        }
      }
    }
#line 320
    tmp___0 = dst;
#line 320
    dst ++;
#line 320
    *tmp___0 = *(*list);
#line 321
    (*list) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 324
  if (*(*list)) {
#line 325
    (*list) ++;
  }
#line 327
  *dst = (char )'\000';
#line 329
  return (res);
}
}
#line 332 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_check_limit(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char const   *client_addr ;
  char const   *tmp ;
  char server_addr[128] ;
  char const   *tmp___0 ;
  xaset_t *tmp___1 ;
  xaset_t *tmp___2 ;
  char *xfer_cmd ;
  char **cmdlist ;
  unsigned char matched_cmd ;
  unsigned int curr ;
  unsigned int max ;
  pr_scoreboard_entry_t *score ;
  char **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char maxn[20] ;
  char *maxstr ;
  char *tmp___8 ;
  xaset_t *tmp___9 ;
  xaset_t *tmp___10 ;
  char *xfer_cmd___0 ;
  char **cmdlist___0 ;
  unsigned char matched_cmd___0 ;
  unsigned int curr___0 ;
  unsigned int max___0 ;
  pr_scoreboard_entry_t *score___0 ;
  char **tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char maxn___0[20] ;
  char *maxstr___0 ;
  char *tmp___16 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 333
  c = (config_rec *)((void *)0);
#line 334
  tmp = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 334
  client_addr = tmp;
#line 337
  memset((void *)(server_addr), '\000', (size_t )sizeof(server_addr));
#line 338
  tmp___0 = pr_netaddr_get_ipstr(main_server->addr);
#line 338
  snprintf((char */* __restrict  */)(server_addr), (size_t )(sizeof(server_addr) - 1UL),
           (char const   */* __restrict  */)"%s:%d", tmp___0, main_server->ServerPort);
#line 340
  server_addr[sizeof(server_addr) - 1UL] = (char )'\000';
  }
#line 342
  if (session.dir_config) {
#line 342
    tmp___2 = (session.dir_config)->subset;
  } else {
#line 342
    if (session.anon_config) {
#line 342
      tmp___1 = (session.anon_config)->subset;
    } else {
#line 342
      tmp___1 = main_server->conf;
    }
#line 342
    tmp___2 = tmp___1;
  }
  {
#line 342
  c = find_config(tmp___2, 1 << 15, "MaxTransfersPerHost", 0);
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! c) {
#line 343
      goto while_break;
    }
    {
#line 344
    xfer_cmd = (char *)((void *)0);
#line 344
    cmdlist = (char **)*(c->argv + 0);
#line 345
    matched_cmd = (unsigned char)0;
#line 346
    curr = 0U;
#line 346
    max = 0U;
#line 347
    score = (pr_scoreboard_entry_t *)((void *)0);
#line 349
    pr_signals_handle();
#line 355
    xfer_cmd = *cmdlist;
    }
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! xfer_cmd) {
#line 355
        goto while_break___0;
      }
      {
#line 356
      tmp___4 = strcasecmp((char const   *)xfer_cmd, (char const   *)*(cmd->argv + 0));
      }
#line 356
      if (tmp___4 == 0) {
#line 357
        matched_cmd = (unsigned char)1;
#line 358
        goto while_break___0;
      }
#line 355
      tmp___3 = cmdlist;
#line 355
      cmdlist ++;
#line 355
      xfer_cmd = *tmp___3;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    if (! matched_cmd) {
      {
#line 363
      c = find_config_next(c, c->next, 1 << 15, "MaxTransfersPerHost", 0);
      }
#line 365
      goto while_continue;
    }
    {
#line 368
    max = *((unsigned int *)*(c->argv + 1));
#line 374
    pr_rewind_scoreboard();
    }
    {
#line 375
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 375
      score = pr_scoreboard_entry_read();
      }
#line 375
      if (! ((unsigned long )score != (unsigned long )((void *)0))) {
#line 375
        goto while_break___1;
      }
      {
#line 376
      pr_signals_handle();
#line 381
      tmp___5 = strcmp((char const   *)(score->sce_server_addr), (char const   *)(server_addr));
      }
#line 381
      if (tmp___5 != 0) {
#line 382
        goto while_continue___1;
      }
      {
#line 384
      tmp___6 = strcmp((char const   *)(score->sce_client_addr), client_addr);
      }
#line 384
      if (tmp___6 != 0) {
#line 385
        goto while_continue___1;
      }
      {
#line 387
      tmp___7 = strcmp((char const   *)(score->sce_cmd), (char const   *)xfer_cmd);
      }
#line 387
      if (tmp___7 == 0) {
#line 388
        curr ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 391
    pr_restore_scoreboard();
    }
#line 393
    if (curr >= max) {
#line 396
      maxstr = (char *)"Sorry, the maximum number of data transfers (%m) from your host are currently being used.";
#line 399
      if ((unsigned long )*(c->argv + 2) != (unsigned long )((void *)0)) {
#line 400
        maxstr = (char *)*(c->argv + 2);
      }
      {
#line 402
      pr_event_generate("mod_xfer.max-transfers-per-host", (void const   *)session.c);
#line 404
      memset((void *)(maxn), '\000', (size_t )sizeof(maxn));
#line 405
      snprintf((char */* __restrict  */)(maxn), (size_t )(sizeof(maxn) - 1UL), (char const   */* __restrict  */)"%u",
               max);
#line 406
      tmp___8 = sreplace(cmd->tmp_pool, maxstr, "%m", maxn, (void *)0);
#line 406
      pr_response_send("451", "%s", tmp___8);
#line 408
      pr_log_debug(4, "MaxTransfersPerHost %u exceeded for %s for client \'%s\'",
                   max, xfer_cmd, client_addr);
      }
#line 411
      return (-1);
    }
    {
#line 414
    c = find_config_next(c, c->next, 1 << 15, "MaxTransferPerHost", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  if (session.dir_config) {
#line 417
    tmp___10 = (session.dir_config)->subset;
  } else {
#line 417
    if (session.anon_config) {
#line 417
      tmp___9 = (session.anon_config)->subset;
    } else {
#line 417
      tmp___9 = main_server->conf;
    }
#line 417
    tmp___10 = tmp___9;
  }
  {
#line 417
  c = find_config(tmp___10, 1 << 15, "MaxTransfersPerUser", 0);
  }
  {
#line 418
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 418
    if (! c) {
#line 418
      goto while_break___2;
    }
    {
#line 419
    xfer_cmd___0 = (char *)((void *)0);
#line 419
    cmdlist___0 = (char **)*(c->argv + 0);
#line 420
    matched_cmd___0 = (unsigned char)0;
#line 421
    curr___0 = 0U;
#line 421
    max___0 = 0U;
#line 422
    score___0 = (pr_scoreboard_entry_t *)((void *)0);
#line 424
    pr_signals_handle();
#line 430
    xfer_cmd___0 = *cmdlist___0;
    }
    {
#line 430
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 430
      if (! xfer_cmd___0) {
#line 430
        goto while_break___3;
      }
      {
#line 431
      tmp___12 = strcasecmp((char const   *)xfer_cmd___0, (char const   *)*(cmd->argv + 0));
      }
#line 431
      if (tmp___12 == 0) {
#line 432
        matched_cmd___0 = (unsigned char)1;
#line 433
        goto while_break___3;
      }
#line 430
      tmp___11 = cmdlist___0;
#line 430
      cmdlist___0 ++;
#line 430
      xfer_cmd___0 = *tmp___11;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 437
    if (! matched_cmd___0) {
      {
#line 438
      c = find_config_next(c, c->next, 1 << 15, "MaxTransfersPerUser", 0);
      }
#line 440
      goto while_continue___2;
    }
    {
#line 443
    max___0 = *((unsigned int *)*(c->argv + 1));
#line 449
    pr_rewind_scoreboard();
    }
    {
#line 450
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 450
      score___0 = pr_scoreboard_entry_read();
      }
#line 450
      if (! ((unsigned long )score___0 != (unsigned long )((void *)0))) {
#line 450
        goto while_break___4;
      }
      {
#line 451
      pr_signals_handle();
#line 453
      tmp___13 = strcmp((char const   *)(score___0->sce_server_addr), (char const   *)(server_addr));
      }
#line 453
      if (tmp___13 != 0) {
#line 454
        goto while_continue___4;
      }
      {
#line 456
      tmp___14 = strcmp((char const   *)(score___0->sce_user), (char const   *)session.user);
      }
#line 456
      if (tmp___14 != 0) {
#line 457
        goto while_continue___4;
      }
      {
#line 459
      tmp___15 = strcmp((char const   *)(score___0->sce_cmd), (char const   *)xfer_cmd___0);
      }
#line 459
      if (tmp___15 == 0) {
#line 460
        curr___0 ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 463
    pr_restore_scoreboard();
    }
#line 465
    if (curr___0 >= max___0) {
#line 468
      maxstr___0 = (char *)"Sorry, the maximum number of data transfers (%m) from this user are currently being used.";
#line 471
      if ((unsigned long )*(c->argv + 2) != (unsigned long )((void *)0)) {
#line 472
        maxstr___0 = (char *)*(c->argv + 2);
      }
      {
#line 474
      pr_event_generate("mod_xfer.max-transfers-per-user", (void const   *)session.user);
#line 476
      memset((void *)(maxn___0), '\000', (size_t )sizeof(maxn___0));
#line 477
      snprintf((char */* __restrict  */)(maxn___0), (size_t )(sizeof(maxn___0) - 1UL),
               (char const   */* __restrict  */)"%u", max___0);
#line 478
      tmp___16 = sreplace(cmd->tmp_pool, maxstr___0, "%m", maxn___0, (void *)0);
#line 478
      pr_response_send("451", "%s", tmp___16);
#line 480
      pr_log_debug(4, "MaxTransfersPerUser %u exceeded for %s for user \'%s\'", max___0,
                   xfer_cmd___0, session.user);
      }
#line 483
      return (-1);
    }
    {
#line 486
    c = find_config_next(c, c->next, 1 << 15, "MaxTransferPerHost", 0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 489
  return (0);
}
}
#line 492 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_prio_adjust(void) 
{ 
  int res ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 495
  if (xfer_prio_config == 0) {
#line 496
    return (0);
  }
  {
#line 499
  tmp = __errno_location();
#line 499
  *tmp = 0;
#line 500
  res = getpriority((__priority_which_t )0, (id_t )0);
  }
#line 501
  if (res < 0) {
    {
#line 501
    tmp___2 = __errno_location();
    }
#line 501
    if (*tmp___2 != 0) {
      {
#line 503
      tmp___0 = __errno_location();
#line 503
      tmp___1 = strerror(*tmp___0);
#line 503
      pr_trace_msg(trace_channel___0, 7, "unable to get current process priority: %s",
                   tmp___1);
      }
#line 505
      return (-1);
    }
  }
#line 511
  if (res == xfer_prio_config) {
    {
#line 512
    pr_trace_msg(trace_channel___0, 10, "current process priority matches configured priority");
    }
#line 514
    return (0);
  }
  {
#line 517
  xfer_prio_curr = res;
#line 519
  pr_trace_msg(trace_channel___0, 10, "adjusting process priority to be %d", xfer_prio_config);
  }
#line 521
  if (xfer_prio_config > 0) {
    {
#line 522
    res = setpriority((__priority_which_t )0, (id_t )0, xfer_prio_config);
    }
  } else {
    {
#line 526
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                 526);
#line 526
    pr_signals_block();
    }
#line 526
    if (! session.disable_id_switching) {
      {
#line 526
      tmp___5 = seteuid((__uid_t )0);
      }
#line 526
      if (tmp___5) {
        {
#line 526
        tmp___3 = __errno_location();
#line 526
        tmp___4 = strerror(*tmp___3);
#line 526
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___4);
        }
      }
      {
#line 526
      tmp___8 = setegid((__gid_t )0);
      }
#line 526
      if (tmp___8) {
        {
#line 526
        tmp___6 = __errno_location();
#line 526
        tmp___7 = strerror(*tmp___6);
#line 526
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___7);
        }
      }
    } else {
      {
#line 526
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 526
    pr_signals_unblock();
#line 527
    res = setpriority((__priority_which_t )0, (id_t )0, xfer_prio_config);
#line 528
    pr_signals_block();
    }
#line 528
    if (! session.disable_id_switching) {
      {
#line 528
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                   528);
#line 528
      tmp___12 = geteuid();
      }
#line 528
      if (tmp___12 != 0U) {
        {
#line 528
        tmp___11 = seteuid((__uid_t )0);
        }
#line 528
        if (tmp___11) {
          {
#line 528
          tmp___9 = __errno_location();
#line 528
          tmp___10 = strerror(*tmp___9);
#line 528
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___10);
          }
        }
      }
      {
#line 528
      tmp___15 = setegid(session.gid);
      }
#line 528
      if (tmp___15) {
        {
#line 528
        tmp___13 = __errno_location();
#line 528
        tmp___14 = strerror(*tmp___13);
#line 528
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___14);
        }
      }
      {
#line 528
      tmp___18 = seteuid(session.uid);
      }
#line 528
      if (tmp___18) {
        {
#line 528
        tmp___16 = __errno_location();
#line 528
        tmp___17 = strerror(*tmp___16);
#line 528
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___17);
        }
      }
    } else {
      {
#line 528
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 528
    pr_signals_unblock();
    }
  }
#line 531
  if (res < 0) {
    {
#line 532
    tmp___19 = __errno_location();
#line 532
    tmp___20 = strerror(*tmp___19);
#line 532
    pr_trace_msg(trace_channel___0, 0, "error adjusting process priority: %s", tmp___20);
    }
#line 534
    return (-1);
  }
#line 537
  return (0);
}
}
#line 540 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_prio_restore(void) 
{ 
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 543
  if (xfer_prio_config == 0) {
#line 545
    return (0);
  } else
#line 543
  if (xfer_prio_curr == 0) {
#line 545
    return (0);
  }
  {
#line 548
  pr_trace_msg(trace_channel___0, 10, "restoring process priority to %d", xfer_prio_curr);
#line 551
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
               551);
#line 551
  pr_signals_block();
  }
#line 551
  if (! session.disable_id_switching) {
    {
#line 551
    tmp___1 = seteuid((__uid_t )0);
    }
#line 551
    if (tmp___1) {
      {
#line 551
      tmp = __errno_location();
#line 551
      tmp___0 = strerror(*tmp);
#line 551
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 551
    tmp___4 = setegid((__gid_t )0);
    }
#line 551
    if (tmp___4) {
      {
#line 551
      tmp___2 = __errno_location();
#line 551
      tmp___3 = strerror(*tmp___2);
#line 551
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 551
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 551
  pr_signals_unblock();
#line 552
  res = setpriority((__priority_which_t )0, (id_t )0, xfer_prio_curr);
#line 553
  pr_signals_block();
  }
#line 553
  if (! session.disable_id_switching) {
    {
#line 553
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                 553);
#line 553
    tmp___8 = geteuid();
    }
#line 553
    if (tmp___8 != 0U) {
      {
#line 553
      tmp___7 = seteuid((__uid_t )0);
      }
#line 553
      if (tmp___7) {
        {
#line 553
        tmp___5 = __errno_location();
#line 553
        tmp___6 = strerror(*tmp___5);
#line 553
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
        }
      }
    }
    {
#line 553
    tmp___11 = setegid(session.gid);
    }
#line 553
    if (tmp___11) {
      {
#line 553
      tmp___9 = __errno_location();
#line 553
      tmp___10 = strerror(*tmp___9);
#line 553
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
      }
    }
    {
#line 553
    tmp___14 = seteuid(session.uid);
    }
#line 553
    if (tmp___14) {
      {
#line 553
      tmp___12 = __errno_location();
#line 553
      tmp___13 = strerror(*tmp___12);
#line 553
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
      }
    }
  } else {
    {
#line 553
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 553
  pr_signals_unblock();
  }
#line 555
  if (res < 0) {
    {
#line 556
    tmp___15 = __errno_location();
#line 556
    tmp___16 = strerror(*tmp___15);
#line 556
    pr_trace_msg(trace_channel___0, 0, "error restoring process priority: %s", tmp___16);
    }
  }
#line 560
  xfer_prio_curr = 0;
#line 561
  return (0);
}
}
#line 564 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_parse_cmdlist(char const   *name , config_rec *c , char *cmdlist ) 
{ 
  char *cmd ;
  array_header *cmds ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 566
  cmd = (char *)((void *)0);
#line 567
  cmds = (array_header *)((void *)0);
#line 570
  cmds = make_array(c->pool, 0U, (size_t )sizeof(char *));
  }
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 575
    cmd = get_cmd_from_list(& cmdlist);
    }
#line 575
    if (! ((unsigned long )cmd != (unsigned long )((void *)0))) {
#line 575
      goto while_break;
    }
    {
#line 578
    tmp___0 = strcasecmp((char const   *)cmd, "APPE");
    }
#line 578
    if (tmp___0 != 0) {
      {
#line 578
      tmp___1 = strcasecmp((char const   *)cmd, "RETR");
      }
#line 578
      if (tmp___1 != 0) {
        {
#line 578
        tmp___2 = strcasecmp((char const   *)cmd, "STOR");
        }
#line 578
        if (tmp___2 != 0) {
          {
#line 578
          tmp___3 = strcasecmp((char const   *)cmd, "STOU");
          }
#line 578
          if (tmp___3 != 0) {
            {
#line 582
            pr_log_debug(0, "invalid %s command: %s", name, cmd);
#line 583
            tmp = __errno_location();
#line 583
            *tmp = 22;
            }
#line 584
            return (-1);
          }
        }
      }
    }
    {
#line 587
    tmp___4 = push_array(cmds);
#line 587
    *((char **)tmp___4) = pstrdup(c->pool, (char const   *)cmd);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 591
  tmp___5 = push_array(cmds);
#line 591
  *((char **)tmp___5) = (char *)((void *)0);
#line 594
  *(c->argv + 0) = cmds->elts;
  }
#line 596
  return (0);
}
}
#line 599 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int transmit_normal(char *buf___2 , long bufsz ) 
{ 
  long sz ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 600
  tmp = pr_fsio_read(retr_fh, buf___2, (size_t )bufsz);
#line 600
  sz = (long )tmp;
  }
#line 602
  if (sz < 0L) {
    {
#line 603
    tmp___0 = __errno_location();
#line 603
    tmp___1 = strerror(*tmp___0);
#line 603
    pr_trace_msg("fileperms", 1, "RETR, user \'%s\' (UID %lu, GID %lu): error reading from \'%s\': %s",
                 session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                 retr_fh->fh_path, tmp___1);
    }
#line 607
    return (0);
  }
#line 610
  if (sz == 0L) {
#line 611
    return (0);
  }
  {
#line 614
  tmp___2 = pr_data_xfer(buf___2, (int )sz);
  }
#line 614
  return (tmp___2);
}
}
#line 618 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int transmit_sendfile(off_t___0 count , off_t___0 *offset , pr_sendfile_t *sentlen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 629
  tmp___0 = pr_throttle_have_rate();
  }
#line 629
  if (tmp___0) {
#line 629
    goto _L;
  } else
#line 629
  if (! (session.xfer.file_size - count)) {
#line 629
    goto _L;
  } else
#line 629
  if (session.sf_flags & (int volatile   )48) {
#line 629
    goto _L;
  } else
#line 629
  if (have_prot) {
#line 629
    goto _L;
  } else
#line 629
  if (have_zmode) {
#line 629
    goto _L;
  } else
#line 629
  if (! use_sendfile) {
    _L: /* CIL Label */ 
#line 635
    if (! xfer_logged_sendfile_decline_msg) {
      {
#line 636
      tmp = pr_throttle_have_rate();
      }
#line 636
      if (tmp) {
        {
#line 637
        pr_log_debug(10, "declining use of sendfile due to TransferRate restrictions");
        }
      } else
#line 640
      if (session.sf_flags & (int volatile   )48) {
        {
#line 641
        pr_log_debug(10, "declining use of sendfile for ASCII data");
        }
      } else
#line 643
      if (have_prot) {
        {
#line 644
        pr_log_debug(10, "declining use of sendfile due to RFC2228 data channel protections");
        }
      } else
#line 647
      if (have_zmode) {
        {
#line 648
        pr_log_debug(10, "declining use of sendfile due to MODE Z restrictions");
        }
      } else
#line 651
      if (! use_sendfile) {
        {
#line 652
        pr_log_debug(10, "declining use of sendfile due to UseSendfile configuration setting");
        }
      } else {
        {
#line 656
        pr_log_debug(10, "declining use of sendfile due to lack of data to transmit");
        }
      }
#line 660
      xfer_logged_sendfile_decline_msg = 1;
    }
#line 663
    return (0);
  }
  {
#line 666
  pr_log_debug(0, "using sendfile capability for transmitting data");
  }
  retry: 
  {
#line 669
  *sentlen = pr_data_sendfile(retr_fh->fh_fd, offset, session.xfer.file_size - count);
  }
#line 672
  if (*sentlen == -1) {
    {
#line 673
    tmp___1 = __errno_location();
    }
    {
#line 675
    if (*tmp___1 == 4) {
#line 675
      goto case_4;
    }
#line 675
    if (*tmp___1 == 11) {
#line 675
      goto case_4;
    }
#line 688
    if (*tmp___1 == 113) {
#line 688
      goto case_113;
    }
#line 688
    if (*tmp___1 == 110) {
#line 688
      goto case_113;
    }
#line 688
    if (*tmp___1 == 104) {
#line 688
      goto case_113;
    }
#line 688
    if (*tmp___1 == 32) {
#line 688
      goto case_113;
    }
#line 696
    if (*tmp___1 == 22) {
#line 696
      goto case_22;
    }
#line 696
    if (*tmp___1 == 38) {
#line 696
      goto case_22;
    }
#line 701
    goto switch_default;
    case_4: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 676
    if (session.sf_flags & (int volatile   )2) {
      {
#line 677
      pr_log_pri(5, "sendfile transmission aborted");
      }
#line 678
      return (-1);
    }
    {
#line 682
    pr_signals_handle();
    }
#line 683
    goto retry;
    case_113: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 690
    goto switch_break;
    case_22: /* CIL Label */ 
    case_38: /* CIL Label */ 
#line 698
    return (0);
#line 699
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 702
    tmp___2 = __errno_location();
#line 702
    tmp___3 = strerror(*tmp___2);
#line 702
    tmp___4 = __errno_location();
#line 702
    pr_log_pri(3, "error using sendfile(): [%d] %s", *tmp___4, tmp___3);
    }
#line 704
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 708
  return (1);
}
}
#line 716 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static long transmit_data(off_t___0 count , off_t___0 *offset , char *buf___2 , long bufsz ) 
{ 
  long res ;
  int on ;
  socklen_t len ;
  int tcp_level ;
  pr_sendfile_t sentlen ;
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 720
  on = 1;
#line 721
  len = (socklen_t )sizeof(int );
#line 724
  tcp_level = 6;
#line 739
  tmp___1 = setsockopt(((session.d)->outstrm)->strm_fd, tcp_level, 3, (void const   *)(& on),
                       len);
  }
#line 739
  if (tmp___1 < 0) {
    {
#line 741
    tmp = __errno_location();
#line 741
    tmp___0 = strerror(*tmp);
#line 741
    pr_log_pri(5, "error setting TCP_CORK: %s", tmp___0);
    }
  }
  {
#line 745
  ret = transmit_sendfile(count, offset, & sentlen);
  }
#line 746
  if (ret > 0) {
#line 748
    res = (long )sentlen;
  } else
#line 750
  if (ret == 0) {
    {
#line 754
    tmp___2 = transmit_normal(buf___2, bufsz);
#line 754
    res = (long )tmp___2;
    }
  } else {
    {
#line 762
    tmp___3 = __errno_location();
#line 762
    tmp___4 = __errno_location();
#line 762
    tmp___5 = strerror(*tmp___4);
#line 762
    pr_log_debug(10, "use of sendfile(2) failed due to %s (%d), falling back to normal data transmission",
                 tmp___5, *tmp___3);
#line 765
    tmp___6 = transmit_normal(buf___2, bufsz);
#line 765
    res = (long )tmp___6;
    }
  }
#line 776
  if (session.d) {
    {
#line 780
    on = 0;
#line 781
    tmp___9 = setsockopt(((session.d)->outstrm)->strm_fd, tcp_level, 3, (void const   *)(& on),
                         len);
    }
#line 781
    if (tmp___9 < 0) {
      {
#line 783
      tmp___7 = __errno_location();
#line 783
      tmp___8 = strerror(*tmp___7);
#line 783
      pr_log_pri(5, "error setting TCP_CORK: %s", tmp___8);
      }
    }
  }
#line 788
  return (res);
}
}
#line 791 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void stor_chown(void) 
{ 
  struct stat st ;
  char *xfer_path ;
  int err ;
  int iserr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  __uid_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  __uid_t tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  register unsigned int i___0 ;
  int res ;
  int use_root_privs ;
  gid_t *group_ids ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int *tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  __uid_t tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  int *tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  char const   *tmp___55 ;
  char const   *tmp___56 ;
  int *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  __uid_t tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  int *tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  int *tmp___73 ;
  char *tmp___74 ;
  char const   *tmp___75 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;

  {
#line 793
  xfer_path = (char *)((void *)0);
#line 795
  if (session.xfer.xfer_type == 2) {
#line 796
    xfer_path = session.xfer.path_hidden;
  } else {
#line 798
    xfer_path = session.xfer.path;
  }
#line 803
  if (session.fsuid != 4294967295U) {
#line 803
    if (xfer_path) {
      {
#line 804
      err = 0;
#line 804
      iserr = 0;
#line 806
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                   806);
#line 806
      pr_signals_block();
      }
#line 806
      if (! session.disable_id_switching) {
        {
#line 806
        tmp___1 = seteuid((__uid_t )0);
        }
#line 806
        if (tmp___1) {
          {
#line 806
          tmp = __errno_location();
#line 806
          tmp___0 = strerror(*tmp);
#line 806
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
          }
        }
        {
#line 806
        tmp___4 = setegid((__gid_t )0);
        }
#line 806
        if (tmp___4) {
          {
#line 806
          tmp___2 = __errno_location();
#line 806
          tmp___3 = strerror(*tmp___2);
#line 806
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
          }
        }
      } else {
        {
#line 806
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 806
      pr_signals_unblock();
#line 807
      tmp___6 = pr_fsio_chown((char const   *)xfer_path, session.fsuid, session.fsgid);
      }
#line 807
      if (tmp___6 == -1) {
        {
#line 808
        iserr ++;
#line 809
        tmp___5 = __errno_location();
#line 809
        err = *tmp___5;
        }
      }
      {
#line 811
      pr_signals_block();
      }
#line 811
      if (! session.disable_id_switching) {
        {
#line 811
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                     811);
#line 811
        tmp___10 = geteuid();
        }
#line 811
        if (tmp___10 != 0U) {
          {
#line 811
          tmp___9 = seteuid((__uid_t )0);
          }
#line 811
          if (tmp___9) {
            {
#line 811
            tmp___7 = __errno_location();
#line 811
            tmp___8 = strerror(*tmp___7);
#line 811
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___8);
            }
          }
        }
        {
#line 811
        tmp___13 = setegid(session.gid);
        }
#line 811
        if (tmp___13) {
          {
#line 811
          tmp___11 = __errno_location();
#line 811
          tmp___12 = strerror(*tmp___11);
#line 811
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___12);
          }
        }
        {
#line 811
        tmp___16 = seteuid(session.uid);
        }
#line 811
        if (tmp___16) {
          {
#line 811
          tmp___14 = __errno_location();
#line 811
          tmp___15 = strerror(*tmp___14);
#line 811
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___15);
          }
        }
      } else {
        {
#line 811
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 811
      pr_signals_unblock();
      }
#line 813
      if (iserr) {
        {
#line 814
        tmp___17 = strerror(err);
#line 814
        pr_log_pri(4, "chown(%s) as root failed: %s", xfer_path, tmp___17);
        }
      } else {
#line 819
        if (session.fsgid != 4294967295U) {
          {
#line 820
          pr_log_debug(2, "root chown(%s) to uid %lu, gid %lu successful", xfer_path,
                       (unsigned long )session.fsuid, (unsigned long )session.fsgid);
          }
        } else {
          {
#line 825
          pr_log_debug(2, "root chown(%s) to uid %lu successful", xfer_path, (unsigned long )session.fsuid);
          }
        }
        {
#line 828
        pr_fs_clear_cache();
#line 829
        pr_fsio_stat((char const   *)xfer_path, & st);
#line 840
        iserr = 0;
#line 841
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                     841);
#line 841
        pr_signals_block();
        }
#line 841
        if (! session.disable_id_switching) {
          {
#line 841
          tmp___20 = seteuid((__uid_t )0);
          }
#line 841
          if (tmp___20) {
            {
#line 841
            tmp___18 = __errno_location();
#line 841
            tmp___19 = strerror(*tmp___18);
#line 841
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___19);
            }
          }
          {
#line 841
          tmp___23 = setegid((__gid_t )0);
          }
#line 841
          if (tmp___23) {
            {
#line 841
            tmp___21 = __errno_location();
#line 841
            tmp___22 = strerror(*tmp___21);
#line 841
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___22);
            }
          }
        } else {
          {
#line 841
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 841
        pr_signals_unblock();
#line 842
        tmp___24 = pr_fsio_chmod((char const   *)xfer_path, st.st_mode);
        }
#line 842
        if (tmp___24 < 0) {
#line 843
          iserr ++;
        }
        {
#line 844
        pr_signals_block();
        }
#line 844
        if (! session.disable_id_switching) {
          {
#line 844
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                       844);
#line 844
          tmp___28 = geteuid();
          }
#line 844
          if (tmp___28 != 0U) {
            {
#line 844
            tmp___27 = seteuid((__uid_t )0);
            }
#line 844
            if (tmp___27) {
              {
#line 844
              tmp___25 = __errno_location();
#line 844
              tmp___26 = strerror(*tmp___25);
#line 844
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___26);
              }
            }
          }
          {
#line 844
          tmp___31 = setegid(session.gid);
          }
#line 844
          if (tmp___31) {
            {
#line 844
            tmp___29 = __errno_location();
#line 844
            tmp___30 = strerror(*tmp___29);
#line 844
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___30);
            }
          }
          {
#line 844
          tmp___34 = seteuid(session.uid);
          }
#line 844
          if (tmp___34) {
            {
#line 844
            tmp___32 = __errno_location();
#line 844
            tmp___33 = strerror(*tmp___32);
#line 844
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___33);
            }
          }
        } else {
          {
#line 844
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 844
        pr_signals_unblock();
        }
#line 846
        if (iserr) {
          {
#line 847
          tmp___35 = __errno_location();
#line 847
          tmp___36 = strerror(*tmp___35);
#line 847
          pr_log_debug(0, "root chmod(%s) to %04o failed: %s", xfer_path, st.st_mode,
                       tmp___36);
          }
        } else {
          {
#line 850
          pr_log_debug(2, "root chmod(%s) to %04o successful", xfer_path, st.st_mode);
          }
        }
      }
    } else {
#line 803
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 854
  if (session.fsgid != 4294967295U) {
#line 854
    if (xfer_path) {
#line 856
      use_root_privs = 1;
#line 859
      i___0 = 0U;
      {
#line 859
      while (1) {
        while_continue: /* CIL Label */ ;
#line 859
        if (! (i___0 < (unsigned int )(session.gids)->nelts)) {
#line 859
          goto while_break;
        }
#line 860
        group_ids = (gid_t *)(session.gids)->elts;
#line 862
        if (*(group_ids + i___0) == session.fsgid) {
#line 863
          use_root_privs = 0;
#line 864
          goto while_break;
        }
#line 859
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 868
      if (use_root_privs) {
        {
#line 869
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                     869);
#line 869
        pr_signals_block();
        }
#line 869
        if (! session.disable_id_switching) {
          {
#line 869
          tmp___39 = seteuid((__uid_t )0);
          }
#line 869
          if (tmp___39) {
            {
#line 869
            tmp___37 = __errno_location();
#line 869
            tmp___38 = strerror(*tmp___37);
#line 869
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___38);
            }
          }
          {
#line 869
          tmp___42 = setegid((__gid_t )0);
          }
#line 869
          if (tmp___42) {
            {
#line 869
            tmp___40 = __errno_location();
#line 869
            tmp___41 = strerror(*tmp___40);
#line 869
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___41);
            }
          }
        } else {
          {
#line 869
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 869
        pr_signals_unblock();
        }
      }
      {
#line 872
      res = pr_fsio_chown((char const   *)xfer_path, (uid_t )-1, session.fsgid);
      }
#line 874
      if (use_root_privs) {
        {
#line 875
        pr_signals_block();
        }
#line 875
        if (! session.disable_id_switching) {
          {
#line 875
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                       875);
#line 875
          tmp___46 = geteuid();
          }
#line 875
          if (tmp___46 != 0U) {
            {
#line 875
            tmp___45 = seteuid((__uid_t )0);
            }
#line 875
            if (tmp___45) {
              {
#line 875
              tmp___43 = __errno_location();
#line 875
              tmp___44 = strerror(*tmp___43);
#line 875
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___44);
              }
            }
          }
          {
#line 875
          tmp___49 = setegid(session.gid);
          }
#line 875
          if (tmp___49) {
            {
#line 875
            tmp___47 = __errno_location();
#line 875
            tmp___48 = strerror(*tmp___47);
#line 875
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___48);
            }
          }
          {
#line 875
          tmp___52 = seteuid(session.uid);
          }
#line 875
          if (tmp___52) {
            {
#line 875
            tmp___50 = __errno_location();
#line 875
            tmp___51 = strerror(*tmp___50);
#line 875
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___51);
            }
          }
        } else {
          {
#line 875
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 875
        pr_signals_unblock();
        }
      }
#line 878
      if (res == -1) {
        {
#line 879
        tmp___53 = __errno_location();
#line 879
        tmp___54 = strerror(*tmp___53);
        }
#line 879
        if (use_root_privs) {
#line 879
          tmp___55 = "root ";
        } else {
#line 879
          tmp___55 = "";
        }
        {
#line 879
        pr_log_pri(4, "%schown(%s) failed: %s", tmp___55, xfer_path, tmp___54);
        }
      } else {
#line 883
        if (use_root_privs) {
#line 883
          tmp___56 = "root ";
        } else {
#line 883
          tmp___56 = "";
        }
        {
#line 883
        pr_log_debug(2, "%schown(%s) to gid %lu successful", tmp___56, xfer_path,
                     (unsigned long )session.fsgid);
#line 887
        pr_fs_clear_cache();
#line 888
        pr_fsio_stat((char const   *)xfer_path, & st);
        }
#line 890
        if (use_root_privs) {
          {
#line 891
          pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                       891);
#line 891
          pr_signals_block();
          }
#line 891
          if (! session.disable_id_switching) {
            {
#line 891
            tmp___59 = seteuid((__uid_t )0);
            }
#line 891
            if (tmp___59) {
              {
#line 891
              tmp___57 = __errno_location();
#line 891
              tmp___58 = strerror(*tmp___57);
#line 891
              pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___58);
              }
            }
            {
#line 891
            tmp___62 = setegid((__gid_t )0);
            }
#line 891
            if (tmp___62) {
              {
#line 891
              tmp___60 = __errno_location();
#line 891
              tmp___61 = strerror(*tmp___60);
#line 891
              pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___61);
              }
            }
          } else {
            {
#line 891
            pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
            }
          }
          {
#line 891
          pr_signals_unblock();
          }
        }
        {
#line 894
        res = pr_fsio_chmod((char const   *)xfer_path, st.st_mode);
        }
#line 896
        if (use_root_privs) {
          {
#line 897
          pr_signals_block();
          }
#line 897
          if (! session.disable_id_switching) {
            {
#line 897
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c",
                         897);
#line 897
            tmp___66 = geteuid();
            }
#line 897
            if (tmp___66 != 0U) {
              {
#line 897
              tmp___65 = seteuid((__uid_t )0);
              }
#line 897
              if (tmp___65) {
                {
#line 897
                tmp___63 = __errno_location();
#line 897
                tmp___64 = strerror(*tmp___63);
#line 897
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___64);
                }
              }
            }
            {
#line 897
            tmp___69 = setegid(session.gid);
            }
#line 897
            if (tmp___69) {
              {
#line 897
              tmp___67 = __errno_location();
#line 897
              tmp___68 = strerror(*tmp___67);
#line 897
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___68);
              }
            }
            {
#line 897
            tmp___72 = seteuid(session.uid);
            }
#line 897
            if (tmp___72) {
              {
#line 897
              tmp___70 = __errno_location();
#line 897
              tmp___71 = strerror(*tmp___70);
#line 897
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___71);
              }
            }
          } else {
            {
#line 897
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 897
          pr_signals_unblock();
          }
        }
#line 900
        if (res < 0) {
          {
#line 901
          tmp___73 = __errno_location();
#line 901
          tmp___74 = strerror(*tmp___73);
          }
#line 901
          if (use_root_privs) {
#line 901
            tmp___75 = "root ";
          } else {
#line 901
            tmp___75 = "";
          }
          {
#line 901
          pr_log_debug(0, "%schmod(%s) to %04o failed: %s", tmp___75, xfer_path, st.st_mode,
                       tmp___74);
          }
        }
      }
    }
  }
#line 906
  return;
}
}
#line 908 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void retr_abort(void) 
{ 


  {
#line 911
  if (retr_fh) {
    {
#line 912
    pr_fsio_close(retr_fh);
#line 913
    retr_fh = (pr_fh_t *)((void *)0);
    }
  }
  {
#line 916
  _log_transfer((char )'o', (char )'i');
  }
#line 917
  return;
}
}
#line 919 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void retr_complete(void) 
{ 


  {
  {
#line 920
  pr_fsio_close(retr_fh);
#line 921
  retr_fh = (pr_fh_t *)((void *)0);
  }
#line 922
  return;
}
}
#line 924 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void stor_abort(void) 
{ 
  unsigned char *delete_stores ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  xaset_t *tmp___3 ;
  xaset_t *tmp___4 ;
  void *tmp___5 ;
  xaset_t *tmp___6 ;
  xaset_t *tmp___7 ;
  void *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 925
  delete_stores = (unsigned char *)((void *)0);
#line 927
  if (stor_fh) {
    {
#line 928
    tmp___2 = pr_fsio_close(stor_fh);
    }
#line 928
    if (tmp___2 < 0) {
      {
#line 929
      tmp = __errno_location();
#line 929
      xerrno = *tmp;
#line 931
      tmp___0 = strerror(xerrno);
#line 931
      pr_log_pri(5, "notice: error closing \'%s\': %s", stor_fh->fh_path, tmp___0);
#line 934
      tmp___1 = __errno_location();
#line 934
      *tmp___1 = xerrno;
      }
    }
#line 937
    stor_fh = (pr_fh_t *)((void *)0);
  }
#line 940
  if (session.xfer.xfer_type == 2) {
#line 941
    if (session.dir_config) {
#line 941
      tmp___4 = (session.dir_config)->subset;
    } else {
#line 941
      if (session.anon_config) {
#line 941
        tmp___3 = (session.anon_config)->subset;
      } else {
#line 941
        tmp___3 = main_server->conf;
      }
#line 941
      tmp___4 = tmp___3;
    }
    {
#line 941
    tmp___5 = get_param_ptr(tmp___4, "DeleteAbortedStores", 0);
#line 941
    delete_stores = (unsigned char *)tmp___5;
    }
#line 942
    if ((unsigned long )delete_stores != (unsigned long )((void *)0)) {
#line 942
      if ((int )*delete_stores == 1) {
#line 947
        if (session.xfer.path_hidden) {
          {
#line 948
          pr_log_debug(5, "removing aborted HiddenStores file \'%s\'", session.xfer.path_hidden);
#line 950
          pr_fsio_unlink((char const   *)session.xfer.path_hidden);
          }
        }
      }
    }
  } else
#line 954
  if (session.xfer.path) {
#line 955
    if (session.dir_config) {
#line 955
      tmp___7 = (session.dir_config)->subset;
    } else {
#line 955
      if (session.anon_config) {
#line 955
        tmp___6 = (session.anon_config)->subset;
      } else {
#line 955
        tmp___6 = main_server->conf;
      }
#line 955
      tmp___7 = tmp___6;
    }
    {
#line 955
    tmp___8 = get_param_ptr(tmp___7, "DeleteAbortedStores", 0);
#line 955
    delete_stores = (unsigned char *)tmp___8;
    }
#line 956
    if ((unsigned long )delete_stores != (unsigned long )((void *)0)) {
#line 956
      if ((int )*delete_stores == 1) {
        {
#line 958
        pr_log_debug(5, "removing aborted file \'%s\'", session.xfer.path);
#line 959
        pr_fsio_unlink((char const   *)session.xfer.path);
        }
      }
    }
  }
  {
#line 963
  _log_transfer((char )'i', (char )'i');
  }
#line 964
  return;
}
}
#line 966 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int stor_complete(void) 
{ 
  int res ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 967
  res = 0;
#line 969
  tmp___2 = pr_fsio_close(stor_fh);
  }
#line 969
  if (tmp___2 < 0) {
    {
#line 970
    tmp = __errno_location();
#line 970
    xerrno = *tmp;
#line 972
    tmp___0 = strerror(xerrno);
#line 972
    pr_log_pri(5, "notice: error closing \'%s\': %s", stor_fh->fh_path, tmp___0);
    }
#line 978
    if (session.xfer.xfer_type == 2) {
#line 979
      if (session.xfer.path_hidden) {
        {
#line 980
        pr_log_debug(5, "failed to close HiddenStores file \'%s\', removing", session.xfer.path_hidden);
#line 982
        pr_fsio_unlink((char const   *)session.xfer.path_hidden);
        }
      }
    }
    {
#line 986
    tmp___1 = __errno_location();
#line 986
    *tmp___1 = xerrno;
#line 987
    res = -1;
    }
  }
#line 990
  stor_fh = (pr_fh_t *)((void *)0);
#line 991
  return (res);
}
}
#line 994 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int get_hidden_store_path(cmd_rec *cmd , char *path ) 
{ 
  char *c ;
  char *hidden_path ;
  int dotcount ;
  int foundslash ;
  int basenamestart ;
  int maxlen ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 995
  c = (char *)((void *)0);
#line 996
  dotcount = 0;
#line 996
  foundslash = 0;
#line 996
  basenamestart = 0;
#line 1003
  c = path;
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if (! *c) {
#line 1003
      goto while_break;
    }
#line 1005
    if ((int )*c == 47) {
#line 1006
      foundslash = 1;
#line 1007
      dotcount = 0;
#line 1007
      basenamestart = dotcount;
    } else
#line 1009
    if ((int )*c == 46) {
#line 1010
      dotcount ++;
#line 1016
      if (dotcount > 2) {
#line 1016
        if (! basenamestart) {
#line 1018
          basenamestart = (int )(((unsigned long )c - (unsigned long )path) - (unsigned long )dotcount);
        }
      }
    } else
#line 1026
    if (! basenamestart) {
#line 1027
      basenamestart = (int )(((unsigned long )c - (unsigned long )path) - (unsigned long )dotcount);
    }
#line 1003
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  if (! basenamestart) {
    {
#line 1032
    session.xfer.xfer_type = 0;
#line 1035
    pr_response_add_err("451", "%s: Bad file name", path);
    }
#line 1036
    return (-1);
  }
  {
#line 1042
  tmp = strlen((char const   *)path);
#line 1042
  maxlen = (int )(tmp + 6U);
  }
#line 1044
  if (maxlen > 4096) {
    {
#line 1045
    session.xfer.xfer_type = 0;
#line 1047
    pr_log_pri(5, "making path \'%s\' a hidden path exceeds max path length (%u)",
               path, 4096);
#line 1051
    pr_response_add_err("451", "%s: File name too long", path);
    }
#line 1052
    return (-1);
  }
  {
#line 1055
  tmp___2 = pr_table_add(cmd->notes, "mod_xfer.store-hidden-path", (void *)0, (size_t )0);
  }
#line 1055
  if (tmp___2 < 0) {
    {
#line 1056
    tmp___0 = __errno_location();
#line 1056
    tmp___1 = strerror(*tmp___0);
#line 1056
    pr_log_pri(5, "notice: error adding \'mod_xfer.store-hidden-path\': %s", tmp___1);
    }
  }
#line 1060
  if (! foundslash) {
    {
#line 1063
    hidden_path = pstrcat(cmd->tmp_pool, ".in.", path, ".", (void *)0);
#line 1065
    pr_log_pri(7, "HiddenStore: local path, will rename %s to %s", hidden_path, path);
    }
  } else {
    {
#line 1071
    hidden_path = pstrndup(cmd->pool, (char const   *)path, (size_t )maxlen);
#line 1072
    *(hidden_path + basenamestart) = (char )'\000';
#line 1074
    hidden_path = pstrcat(cmd->pool, hidden_path, ".in.", path + basenamestart, ".",
                          (void *)0);
#line 1077
    pr_log_pri(7, "HiddenStore: complex path, will rename %s to %s", hidden_path,
               path);
    }
  }
  {
#line 1081
  tmp___3 = file_mode(hidden_path);
  }
#line 1081
  if (tmp___3) {
    {
#line 1082
    session.xfer.xfer_type = 0;
#line 1084
    pr_log_debug(3, "HiddenStore path \'%s\' already exists", hidden_path);
#line 1087
    pr_response_add_err("550", "%s: Temporary hidden file %s already exists", cmd->arg,
                        hidden_path);
    }
#line 1090
    return (-1);
  }
  {
#line 1093
  tmp___6 = pr_table_set(cmd->notes, "mod_xfer.store-hidden-path", (void *)hidden_path,
                         (size_t )0);
  }
#line 1093
  if (tmp___6 < 0) {
    {
#line 1095
    tmp___4 = __errno_location();
#line 1095
    tmp___5 = strerror(*tmp___4);
#line 1095
    pr_log_pri(5, "notice: error setting \'mod_xfer.store-hidden-path\': %s", tmp___5);
    }
  }
#line 1099
  session.xfer.xfer_type = 2;
#line 1100
  return (0);
}
}
#line 1103 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_post_prot(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1104
  if (cmd->argc != 2) {
    {
#line 1104
    pr_response_add_err("501", "Invalid number of arguments");
#line 1104
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1104
    return (tmp);
  }
  {
#line 1106
  tmp___0 = strcmp((char const   *)*(cmd->argv + 1), "C");
  }
#line 1106
  if (tmp___0 != 0) {
#line 1107
    have_prot = (unsigned char)1;
  } else {
#line 1109
    have_prot = (unsigned char)0;
  }
#line 1111
  return ((modret_t *)((void *)0));
}
}
#line 1114 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_post_mode(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1115
  if (cmd->argc != 2) {
    {
#line 1115
    pr_response_add_err("501", "Invalid number of arguments");
#line 1115
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1115
    return (tmp);
  }
  {
#line 1117
  tmp___0 = strcmp((char const   *)*(cmd->argv + 1), "Z");
  }
#line 1117
  if (tmp___0 == 0) {
#line 1118
    have_zmode = (unsigned char)1;
  } else {
#line 1120
    have_zmode = (unsigned char)0;
  }
#line 1122
  return ((modret_t *)((void *)0));
}
}
#line 1130 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_pre_stor(cmd_rec *cmd ) 
{ 
  char *path ;
  mode_t fmode ;
  unsigned char *hidden_stores ;
  unsigned char *allow_overwrite ;
  unsigned char *allow_restart ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  int tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  xaset_t *tmp___8 ;
  xaset_t *tmp___9 ;
  void *tmp___10 ;
  modret_t *tmp___11 ;
  modret_t *tmp___12 ;
  int tmp___13 ;
  xaset_t *tmp___14 ;
  xaset_t *tmp___15 ;
  void *tmp___16 ;
  modret_t *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  xaset_t *tmp___22 ;
  xaset_t *tmp___23 ;
  void *tmp___24 ;
  modret_t *tmp___25 ;
  int tmp___26 ;
  modret_t *tmp___27 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 1133
  hidden_stores = (unsigned char *)((void *)0);
#line 1133
  allow_overwrite = (unsigned char *)((void *)0);
#line 1133
  allow_restart = (unsigned char *)((void *)0);
#line 1136
  if (cmd->argc < 2) {
    {
#line 1137
    tmp = get_full_cmd(cmd);
#line 1137
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 1138
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1138
    return (tmp___0);
  }
  {
#line 1141
  tmp___1 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 1141
  path = dir_best_path(cmd->tmp_pool, (char const   *)tmp___1);
  }
#line 1144
  if (! path) {
    {
#line 1146
    tmp___2 = __errno_location();
#line 1146
    tmp___3 = strerror(*tmp___2);
#line 1146
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 1147
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1147
    return (tmp___4);
  } else {
    {
#line 1144
    tmp___5 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, path, (int *)((void *)0));
    }
#line 1144
    if (! tmp___5) {
      {
#line 1146
      tmp___2 = __errno_location();
#line 1146
      tmp___3 = strerror(*tmp___2);
#line 1146
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 1147
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1147
      return (tmp___4);
    }
  }
  {
#line 1150
  tmp___7 = xfer_check_limit(cmd);
  }
#line 1150
  if (tmp___7 < 0) {
    {
#line 1151
    pr_response_add_err("451", "%s: Too many transfers", cmd->arg);
#line 1152
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1152
    return (tmp___6);
  }
  {
#line 1155
  fmode = file_mode(path);
  }
#line 1157
  if (session.dir_config) {
#line 1157
    tmp___9 = (session.dir_config)->subset;
  } else {
#line 1157
    if (session.anon_config) {
#line 1157
      tmp___8 = (session.anon_config)->subset;
    } else {
#line 1157
      tmp___8 = main_server->conf;
    }
#line 1157
    tmp___9 = tmp___8;
  }
  {
#line 1157
  tmp___10 = get_param_ptr(tmp___9, "AllowOverwrite", 0);
#line 1157
  allow_overwrite = (unsigned char *)tmp___10;
  }
#line 1159
  if (fmode) {
#line 1159
    if (session.xfer.xfer_type != 1) {
#line 1159
      if (! allow_overwrite) {
        {
#line 1161
        pr_log_debug(6, "AllowOverwrite denied permission for %s", cmd->arg);
#line 1162
        pr_response_add_err("550", "%s: Overwrite permission denied", cmd->arg);
#line 1163
        tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1163
        return (tmp___11);
      } else
#line 1159
      if ((int )*allow_overwrite == 0) {
        {
#line 1161
        pr_log_debug(6, "AllowOverwrite denied permission for %s", cmd->arg);
#line 1162
        pr_response_add_err("550", "%s: Overwrite permission denied", cmd->arg);
#line 1163
        tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1163
        return (tmp___11);
      }
    }
  }
#line 1166
  if (fmode) {
#line 1166
    if (! ((fmode & 61440U) == 32768U)) {
#line 1166
      if (! ((fmode & 61440U) == 4096U)) {
        {
#line 1174
        tmp___13 = strcasecmp((char const   *)path, "/dev/null");
        }
#line 1174
        if (tmp___13 != 0) {
          {
#line 1175
          pr_response_add_err("550", "%s: Not a regular file", cmd->arg);
#line 1176
          tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 1176
          return (tmp___12);
        }
      }
    }
  }
#line 1183
  if (session.dir_config) {
#line 1183
    tmp___15 = (session.dir_config)->subset;
  } else {
#line 1183
    if (session.anon_config) {
#line 1183
      tmp___14 = (session.anon_config)->subset;
    } else {
#line 1183
      tmp___14 = main_server->conf;
    }
#line 1183
    tmp___15 = tmp___14;
  }
  {
#line 1183
  tmp___16 = get_param_ptr(tmp___15, "AllowStoreRestart", 0);
#line 1183
  allow_restart = (unsigned char *)tmp___16;
  }
#line 1185
  if (fmode) {
#line 1185
    if (session.restart_pos) {
#line 1185
      goto _L;
    } else
#line 1185
    if (session.xfer.xfer_type == 1) {
      _L: /* CIL Label */ 
#line 1185
      if (! allow_restart) {
        {
#line 1189
        pr_response_add_err("451", "%s: Append/Restart not permitted, try again",
                            cmd->arg);
#line 1191
        session.restart_pos = (off_t___0 )0L;
#line 1192
        session.xfer.xfer_type = 0;
#line 1193
        tmp___17 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1193
        return (tmp___17);
      } else
#line 1185
      if ((int )*allow_restart == 0) {
        {
#line 1189
        pr_response_add_err("451", "%s: Append/Restart not permitted, try again",
                            cmd->arg);
#line 1191
        session.restart_pos = (off_t___0 )0L;
#line 1192
        session.xfer.xfer_type = 0;
#line 1193
        tmp___17 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1193
        return (tmp___17);
      }
    }
  }
  {
#line 1197
  tmp___20 = pstrdup(cmd->pool, (char const   *)path);
#line 1197
  tmp___21 = pr_table_add(cmd->notes, "mod_xfer.store-path", (void *)tmp___20, (size_t )0);
  }
#line 1197
  if (tmp___21 < 0) {
    {
#line 1199
    tmp___18 = __errno_location();
#line 1199
    tmp___19 = strerror(*tmp___18);
#line 1199
    pr_log_pri(5, "notice: error adding \'mod_xfer.store-path\': %s", tmp___19);
    }
  }
#line 1202
  if (session.dir_config) {
#line 1202
    tmp___23 = (session.dir_config)->subset;
  } else {
#line 1202
    if (session.anon_config) {
#line 1202
      tmp___22 = (session.anon_config)->subset;
    } else {
#line 1202
      tmp___22 = main_server->conf;
    }
#line 1202
    tmp___23 = tmp___22;
  }
  {
#line 1202
  tmp___24 = get_param_ptr(tmp___23, "HiddenStores", 0);
#line 1202
  hidden_stores = (unsigned char *)tmp___24;
  }
#line 1203
  if ((unsigned long )hidden_stores != (unsigned long )((void *)0)) {
#line 1203
    if ((int )*hidden_stores == 1) {
      {
#line 1206
      tmp___26 = get_hidden_store_path(cmd, path);
      }
#line 1206
      if (tmp___26 < 0) {
        {
#line 1207
        tmp___25 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1207
        return (tmp___25);
      }
    }
  }
  {
#line 1210
  xfer_prio_adjust();
#line 1211
  tmp___27 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1211
  return (tmp___27);
}
}
#line 1218 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_pre_stou(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *prefix ;
  char *filename ;
  int tmpfd ;
  mode_t mode ;
  unsigned char *allow_overwrite ;
  char *tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  modret_t *tmp___3 ;
  xaset_t *tmp___4 ;
  xaset_t *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int xerrno ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  modret_t *tmp___12 ;
  int tmp___13 ;
  xaset_t *tmp___14 ;
  xaset_t *tmp___15 ;
  void *tmp___16 ;
  modret_t *tmp___17 ;
  modret_t *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  modret_t *tmp___23 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 1219
  c = (config_rec *)((void *)0);
#line 1220
  prefix = (char *)"ftp";
#line 1220
  filename = (char *)((void *)0);
#line 1223
  allow_overwrite = (unsigned char *)((void *)0);
#line 1225
  session.xfer.xfer_type = 0;
#line 1232
  if (cmd->argc > 2) {
    {
#line 1233
    tmp = get_full_cmd(cmd);
#line 1233
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 1234
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1234
    return (tmp___0);
  }
  {
#line 1237
  tmp___2 = xfer_check_limit(cmd);
  }
#line 1237
  if (tmp___2 < 0) {
    {
#line 1238
    pr_response_add_err("451", "%s: Too many transfers", cmd->arg);
#line 1239
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1239
    return (tmp___1);
  }
#line 1246
  if (session.restart_pos) {
    {
#line 1247
    pr_response_add_err("550", "STOU incompatible with REST");
#line 1248
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1248
    return (tmp___3);
  }
#line 1254
  if (session.dir_config) {
#line 1254
    tmp___5 = (session.dir_config)->subset;
  } else {
#line 1254
    if (session.anon_config) {
#line 1254
      tmp___4 = (session.anon_config)->subset;
    } else {
#line 1254
      tmp___4 = main_server->conf;
    }
#line 1254
    tmp___5 = tmp___4;
  }
  {
#line 1254
  c = find_config(tmp___5, 1 << 15, "StoreUniquePrefix", 0);
  }
#line 1255
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1256
    prefix = (char *)*(c->argv + 0);
  }
  {
#line 1261
  filename = pstrcat(cmd->pool, prefix, "XXXXXX", (void *)0);
#line 1263
  tmpfd = mkstemp(filename);
  }
#line 1264
  if (tmpfd < 0) {
    {
#line 1265
    tmp___6 = __errno_location();
#line 1265
    tmp___7 = strerror(*tmp___6);
#line 1265
    pr_log_pri(3, "error: unable to use mkstemp(): %s", tmp___7);
#line 1269
    pr_response_add_err("450", "%s: unable to generate unique filename", *(cmd->argv + 0));
#line 1271
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1271
    return (tmp___8);
  } else {
    {
#line 1274
    cmd->arg = filename;
#line 1281
    close(tmpfd);
    }
  }
  {
#line 1285
  filename = dir_best_path(cmd->tmp_pool, (char const   *)cmd->arg);
  }
#line 1287
  if (! filename) {
#line 1287
    goto _L;
  } else {
    {
#line 1287
    tmp___13 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, filename, (int *)((void *)0));
    }
#line 1287
    if (! tmp___13) {
      _L: /* CIL Label */ 
      {
#line 1289
      tmp___9 = __errno_location();
#line 1289
      xerrno = *tmp___9;
#line 1294
      pr_fsio_unlink((char const   *)cmd->arg);
#line 1296
      tmp___10 = strerror(xerrno);
#line 1296
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___10);
#line 1297
      tmp___11 = __errno_location();
#line 1297
      *tmp___11 = xerrno;
#line 1298
      tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1298
      return (tmp___12);
    }
  }
  {
#line 1301
  mode = file_mode(filename);
  }
#line 1306
  if (session.dir_config) {
#line 1306
    tmp___15 = (session.dir_config)->subset;
  } else {
#line 1306
    if (session.anon_config) {
#line 1306
      tmp___14 = (session.anon_config)->subset;
    } else {
#line 1306
      tmp___14 = main_server->conf;
    }
#line 1306
    tmp___15 = tmp___14;
  }
  {
#line 1306
  tmp___16 = get_param_ptr(tmp___15, "AllowOverwrite", 0);
#line 1306
  allow_overwrite = (unsigned char *)tmp___16;
  }
#line 1308
  if (mode) {
#line 1308
    if (session.xfer.xfer_type != 1) {
#line 1308
      if (! allow_overwrite) {
        {
#line 1310
        pr_log_debug(6, "AllowOverwrite denied permission for %s", cmd->arg);
#line 1311
        pr_response_add_err("550", "%s: Overwrite permission denied", cmd->arg);
#line 1312
        tmp___17 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1312
        return (tmp___17);
      } else
#line 1308
      if ((int )*allow_overwrite == 0) {
        {
#line 1310
        pr_log_debug(6, "AllowOverwrite denied permission for %s", cmd->arg);
#line 1311
        pr_response_add_err("550", "%s: Overwrite permission denied", cmd->arg);
#line 1312
        tmp___17 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1312
        return (tmp___17);
      }
    }
  }
#line 1316
  if (mode) {
#line 1316
    if (! ((mode & 61440U) == 32768U)) {
      {
#line 1318
      pr_fsio_unlink((char const   *)cmd->arg);
#line 1319
      pr_response_add_err("550", "%s: Not a regular file", cmd->arg);
#line 1320
      tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1320
      return (tmp___18);
    }
  }
  {
#line 1324
  tmp___21 = pstrdup(cmd->pool, (char const   *)filename);
#line 1324
  tmp___22 = pr_table_add(cmd->notes, "mod_xfer.store-path", (void *)tmp___21, (size_t )0);
  }
#line 1324
  if (tmp___22 < 0) {
    {
#line 1326
    tmp___19 = __errno_location();
#line 1326
    tmp___20 = strerror(*tmp___19);
#line 1326
    pr_log_pri(5, "notice: error adding \'mod_xfer.store-path\': %s", tmp___20);
    }
  }
  {
#line 1329
  session.xfer.xfer_type = 3;
#line 1331
  xfer_prio_adjust();
#line 1332
  tmp___23 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1332
  return (tmp___23);
}
}
#line 1335 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_post_xfer(cmd_rec *cmd ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  off_t___0 tmp___4 ;
  char *displayfilexfer ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1337
  if (displayfilexfer_fh) {
    {
#line 1338
    tmp___1 = pr_display_fh(displayfilexfer_fh, (char const   *)(session.vwd), "226");
    }
#line 1338
    if (tmp___1 < 0) {
      {
#line 1339
      tmp = __errno_location();
#line 1339
      tmp___0 = strerror(*tmp);
#line 1339
      pr_log_debug(6, "unable to display DisplayFileTransfer file \'%s\': %s", displayfilexfer_fh->fh_path,
                   tmp___0);
      }
    }
    {
#line 1343
    tmp___4 = pr_fsio_lseek(displayfilexfer_fh, (off_t___0 )0, 0);
    }
#line 1343
    if (tmp___4 < 0LL) {
      {
#line 1344
      tmp___2 = __errno_location();
#line 1344
      tmp___3 = strerror(*tmp___2);
#line 1344
      pr_log_debug(6, "error rewinding DisplayFileTransfer file \'%s\': %s", displayfilexfer_fh->fh_path,
                   tmp___3);
      }
    }
  } else {
    {
#line 1348
    tmp___5 = get_param_ptr(main_server->conf, "DisplayFileTransfer", 0);
#line 1348
    displayfilexfer = (char *)tmp___5;
    }
#line 1350
    if (displayfilexfer) {
      {
#line 1351
      tmp___8 = pr_display_file((char const   *)displayfilexfer, (char const   *)(session.vwd),
                                "226");
      }
#line 1351
      if (tmp___8 < 0) {
        {
#line 1352
        tmp___6 = __errno_location();
#line 1352
        tmp___7 = strerror(*tmp___6);
#line 1352
        pr_log_debug(6, "unable to display DisplayFileTransfer file \'%s\': %s", displayfilexfer,
                     tmp___7);
        }
      }
    }
  }
#line 1357
  return ((modret_t *)((void *)0));
}
}
#line 1365 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_post_stou(cmd_rec *cmd ) 
{ 
  char *display ;
  mode_t mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1371
  mode = (mode_t )438;
#line 1373
  tmp___1 = pr_fsio_chmod((char const   *)cmd->arg, mode);
  }
#line 1373
  if (tmp___1 < 0) {
    {
#line 1376
    tmp = __errno_location();
#line 1376
    tmp___0 = strerror(*tmp);
#line 1376
    pr_log_pri(3, "error: unable to chmod \'%s\': %s", cmd->arg, tmp___0);
    }
  }
  {
#line 1380
  tmp___2 = get_param_ptr(main_server->conf, "DisplayFileTransfer", 0);
#line 1380
  display = (char *)tmp___2;
  }
#line 1381
  if (display) {
    {
#line 1382
    tmp___5 = pr_display_file((char const   *)display, (char const   *)(session.vwd),
                              "226");
    }
#line 1382
    if (tmp___5 < 0) {
      {
#line 1383
      tmp___3 = __errno_location();
#line 1383
      tmp___4 = strerror(*tmp___3);
#line 1383
      pr_log_debug(3, "error displaying \'%s\': %s", display, tmp___4);
      }
    }
  }
#line 1388
  return ((modret_t *)((void *)0));
}
}
#line 1394 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_pre_appe(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  int tmp___0 ;
  modret_t *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1395
  session.xfer.xfer_type = 0;
#line 1397
  tmp___0 = xfer_check_limit(cmd);
  }
#line 1397
  if (tmp___0 < 0) {
    {
#line 1398
    pr_response_add_err("451", "%s: Too many transfers", cmd->arg);
#line 1399
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1399
    return (tmp);
  }
  {
#line 1402
  session.xfer.xfer_type = 1;
#line 1403
  tmp___1 = xfer_pre_stor(cmd);
  }
#line 1403
  return (tmp___1);
}
}
#line 1406 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_stor(cmd_rec *cmd ) 
{ 
  char *path ;
  char *lbuf ;
  int bufsz ;
  int len ;
  int ferrno ;
  off_t___0 nbytes_stored ;
  off_t___0 nbytes_max_store ;
  unsigned char have_limit ;
  struct stat st ;
  off_t___0 curr_pos ;
  regex_t *preg ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  xaset_t *tmp___1 ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  modret_t *tmp___4 ;
  char errmsg[200] ;
  xaset_t *tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  modret_t *tmp___8 ;
  char errmsg___0[200] ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  off_t___0 tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int xerrno ;
  int *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int *tmp___29 ;
  int tmp___30 ;
  off_t___0 tmp___31 ;
  int *tmp___32 ;
  modret_t *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  modret_t *tmp___36 ;
  void *tmp___37 ;
  void *tmp___38 ;
  modret_t *tmp___39 ;
  int tmp___40 ;
  unsigned long tmp___41 ;
  char const   *tmp___42 ;
  modret_t *tmp___43 ;
  int tmp___44 ;
  void *tmp___45 ;
  int res ;
  modret_t *tmp___46 ;
  int xerrno___0 ;
  int *tmp___47 ;
  char *tmp___48 ;
  modret_t *tmp___49 ;
  modret_t *tmp___50 ;
  modret_t *tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  modret_t *tmp___54 ;
  int *tmp___55 ;
  int *tmp___56 ;
  char *tmp___57 ;
  modret_t *tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  int *tmp___62 ;
  char *tmp___63 ;
  modret_t *tmp___64 ;
  int tmp___65 ;
  modret_t *tmp___66 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  void *__cil_tmp90 ;
  void *__cil_tmp91 ;
  void *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;

  {
  {
#line 1409
  ferrno = 0;
#line 1410
  nbytes_max_store = (off_t___0 )0;
#line 1411
  have_limit = (unsigned char)0;
#line 1413
  curr_pos = (off_t___0 )0;
#line 1421
  pr_throttle_init(cmd);
#line 1423
  tmp = pr_table_get(cmd->notes, "mod_xfer.store-path", (size_t *)((void *)0));
#line 1423
  session.xfer.path = (char *)tmp;
#line 1424
  tmp___0 = pr_table_get(cmd->notes, "mod_xfer.store-hidden-path", (size_t *)((void *)0));
#line 1424
  session.xfer.path_hidden = (char *)tmp___0;
#line 1427
  path = session.xfer.path;
  }
#line 1430
  if (session.dir_config) {
#line 1430
    tmp___2 = (session.dir_config)->subset;
  } else {
#line 1430
    if (session.anon_config) {
#line 1430
      tmp___1 = (session.anon_config)->subset;
    } else {
#line 1430
      tmp___1 = main_server->conf;
    }
#line 1430
    tmp___2 = tmp___1;
  }
  {
#line 1430
  tmp___3 = get_param_ptr(tmp___2, "PathAllowFilter", 0);
#line 1430
  preg = (regex_t *)tmp___3;
  }
#line 1432
  if (preg) {
    {
#line 1433
    ret = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)cmd->arg,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 1434
    if (ret != 0) {
      {
#line 1435
      pr_log_debug(2, "\'%s\' denied by PathAllowFilter", cmd->arg);
#line 1436
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 1437
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1437
      return (tmp___4);
    } else {
      {
#line 1441
      regerror(ret, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errmsg),
               (size_t )sizeof(errmsg));
#line 1442
      pr_log_debug(8, "\'%s\' allowed by PathAllowFilter (%s)", cmd->arg, errmsg);
      }
    }
  }
#line 1447
  if (session.dir_config) {
#line 1447
    tmp___6 = (session.dir_config)->subset;
  } else {
#line 1447
    if (session.anon_config) {
#line 1447
      tmp___5 = (session.anon_config)->subset;
    } else {
#line 1447
      tmp___5 = main_server->conf;
    }
#line 1447
    tmp___6 = tmp___5;
  }
  {
#line 1447
  tmp___7 = get_param_ptr(tmp___6, "PathDenyFilter", 0);
#line 1447
  preg = (regex_t *)tmp___7;
  }
#line 1449
  if (preg) {
    {
#line 1450
    ret = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)cmd->arg,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 1451
    if (ret == 0) {
      {
#line 1452
      pr_log_debug(2, "\'%s\' denied by PathDenyFilter", cmd->arg);
#line 1453
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 1454
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1454
      return (tmp___8);
    } else {
      {
#line 1458
      regerror(ret, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errmsg___0),
               (size_t )sizeof(errmsg___0));
#line 1459
      pr_log_debug(8, "\'%s\' allowed by PathDenyFilter (%s)", cmd->arg, errmsg___0);
      }
    }
  }
  {
#line 1468
  tmp___9 = pr_fs_getcwd();
#line 1468
  pr_fs_setcwd(tmp___9);
  }
#line 1470
  if (session.xfer.xfer_type == 2) {
#line 1471
    if (session.restart_pos) {
#line 1471
      tmp___10 = 0;
    } else {
#line 1471
      tmp___10 = 192;
    }
    {
#line 1471
    stor_fh = pr_fsio_open((char const   *)session.xfer.path_hidden, 1 | tmp___10);
    }
#line 1473
    if ((unsigned long )stor_fh == (unsigned long )((void *)0)) {
      {
#line 1474
      tmp___11 = __errno_location();
#line 1474
      ferrno = *tmp___11;
#line 1476
      tmp___12 = __errno_location();
#line 1476
      tmp___13 = strerror(*tmp___12);
#line 1476
      pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error opening \'%s\': %s",
                   *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                   session.xfer.path_hidden, tmp___13);
      }
    }
  } else
#line 1482
  if (session.xfer.xfer_type == 1) {
    {
#line 1483
    stor_fh = pr_fsio_open((char const   *)session.xfer.path, 65);
    }
#line 1485
    if (stor_fh) {
      {
#line 1486
      tmp___16 = pr_fsio_lseek(stor_fh, (off_t___0 )0, 2);
      }
#line 1486
      if (tmp___16 == -1LL) {
        {
#line 1487
        tmp___14 = __errno_location();
#line 1487
        tmp___15 = strerror(*tmp___14);
#line 1487
        pr_log_debug(4, "unable to seek to end of \'%s\' for appending: %s", cmd->arg,
                     tmp___15);
#line 1489
        pr_fsio_close(stor_fh);
#line 1490
        stor_fh = (pr_fh_t *)((void *)0);
        }
      }
    } else {
      {
#line 1494
      tmp___17 = __errno_location();
#line 1494
      ferrno = *tmp___17;
#line 1496
      tmp___18 = __errno_location();
#line 1496
      tmp___19 = strerror(*tmp___18);
#line 1496
      pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error opening \'%s\': %s",
                   *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                   session.xfer.path, tmp___19);
      }
    }
  } else {
#line 1504
    if (session.restart_pos) {
#line 1504
      tmp___20 = 0;
    } else {
#line 1504
      tmp___20 = 576;
    }
    {
#line 1504
    stor_fh = pr_fsio_open((char const   *)path, 1 | tmp___20);
    }
#line 1506
    if ((unsigned long )stor_fh == (unsigned long )((void *)0)) {
      {
#line 1507
      tmp___21 = __errno_location();
#line 1507
      ferrno = *tmp___21;
#line 1509
      tmp___22 = __errno_location();
#line 1509
      tmp___23 = strerror(*tmp___22);
#line 1509
      pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error opening \'%s\': %s",
                   *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                   path, tmp___23);
      }
    }
  }
#line 1516
  if (stor_fh) {
#line 1516
    if (session.restart_pos) {
      {
#line 1518
      xerrno = 0;
#line 1520
      tmp___31 = pr_fsio_lseek(stor_fh, session.restart_pos, 0);
      }
#line 1520
      if (tmp___31 == -1LL) {
        {
#line 1521
        tmp___24 = __errno_location();
#line 1521
        tmp___25 = strerror(*tmp___24);
#line 1521
        pr_log_debug(4, "unable to seek to position %llu of \'%s\': %s", (unsigned long long )session.restart_pos,
                     cmd->arg, tmp___25);
#line 1523
        tmp___26 = __errno_location();
#line 1523
        xerrno = *tmp___26;
        }
      } else {
        {
#line 1525
        tmp___30 = pr_fsio_stat((char const   *)path, & st);
        }
#line 1525
        if (tmp___30 == -1) {
          {
#line 1526
          tmp___27 = __errno_location();
#line 1526
          tmp___28 = strerror(*tmp___27);
#line 1526
          pr_log_debug(4, "unable to stat \'%s\': %s", cmd->arg, tmp___28);
#line 1528
          tmp___29 = __errno_location();
#line 1528
          xerrno = *tmp___29;
          }
        }
      }
#line 1531
      if (xerrno) {
        {
#line 1532
        pr_fsio_close(stor_fh);
#line 1533
        tmp___32 = __errno_location();
#line 1533
        *tmp___32 = xerrno;
#line 1534
        stor_fh = (pr_fh_t *)((void *)0);
        }
      }
#line 1540
      if (stor_fh) {
#line 1540
        if (session.restart_pos > st.st_size) {
          {
#line 1542
          pr_response_add_err("554", "%s: invalid REST argument", cmd->arg);
#line 1543
          pr_fsio_close(stor_fh);
#line 1544
          stor_fh = (pr_fh_t *)((void *)0);
#line 1545
          tmp___33 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 1545
          return (tmp___33);
        }
      }
#line 1548
      curr_pos = session.restart_pos;
#line 1549
      session.restart_pos = (off_t___0 )0L;
    }
  }
#line 1552
  if (! stor_fh) {
    {
#line 1553
    tmp___34 = strerror(ferrno);
#line 1553
    pr_log_debug(4, "unable to open \'%s\' for writing: %s", cmd->arg, tmp___34);
#line 1555
    tmp___35 = strerror(ferrno);
#line 1555
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___35);
#line 1556
    tmp___36 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1556
    return (tmp___36);
  }
  {
#line 1560
  pr_data_init(cmd->arg, 1);
#line 1566
  tmp___37 = pr_table_get(cmd->notes, "mod_xfer.store-path", (size_t *)((void *)0));
#line 1566
  session.xfer.path = (char *)tmp___37;
#line 1567
  tmp___38 = pr_table_get(cmd->notes, "mod_xfer.store-hidden-path", (size_t *)((void *)0));
#line 1567
  session.xfer.path_hidden = (char *)tmp___38;
#line 1569
  session.xfer.file_size = curr_pos;
#line 1572
  stor_chown();
#line 1574
  tmp___40 = pr_data_open(cmd->arg, (char *)((void *)0), 1, (off_t___0 )0);
  }
#line 1574
  if (tmp___40 < 0) {
    {
#line 1575
    stor_abort();
#line 1576
    pr_data_abort(0, 1);
#line 1577
    tmp___39 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1577
    return (tmp___39);
  }
  {
#line 1581
  nbytes_stored = (off_t___0 )0;
#line 1587
  tmp___41 = find_max_nbytes((char *)"MaxStoreFileSize");
#line 1587
  nbytes_max_store = (off_t___0 )tmp___41;
  }
#line 1587
  if (nbytes_max_store == 0LL) {
#line 1588
    have_limit = (unsigned char)0;
  } else {
#line 1590
    have_limit = (unsigned char)1;
  }
#line 1593
  if (have_limit) {
#line 1593
    if (nbytes_max_store == 0LL) {
#line 1596
      if (nbytes_max_store != 1LL) {
#line 1596
        tmp___42 = "bytes";
      } else {
#line 1596
        tmp___42 = "byte";
      }
      {
#line 1596
      pr_log_pri(6, "MaxStoreFileSize (%llu %s) reached: aborting transfer of \'%s\'",
                 (unsigned long long )nbytes_max_store, tmp___42, path);
#line 1601
      stor_abort();
#line 1605
      pr_data_abort(122, 0);
#line 1611
      tmp___43 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1611
      return (tmp___43);
    }
  }
#line 1614
  if (main_server->tcp_rcvbuf_len > 0) {
#line 1614
    bufsz = main_server->tcp_rcvbuf_len;
  } else {
    {
#line 1614
    tmp___44 = pr_config_get_xfer_bufsz();
#line 1614
    bufsz = tmp___44;
    }
  }
  {
#line 1616
  tmp___45 = palloc(cmd->tmp_pool, bufsz);
#line 1616
  lbuf = (char *)tmp___45;
  }
  {
#line 1618
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1618
    len = pr_data_xfer(lbuf, bufsz);
    }
#line 1618
    if (! (len > 0)) {
#line 1618
      goto while_break;
    }
    {
#line 1621
    pr_signals_handle();
    }
#line 1623
    if (session.sf_flags & (int volatile   )2) {
#line 1624
      goto while_break;
    }
#line 1626
    nbytes_stored += (off_t___0 )len;
#line 1631
    if (have_limit) {
#line 1631
      if (nbytes_stored > nbytes_max_store) {
        {
#line 1634
        pr_log_pri(6, "MaxStoreFileSize (%llu bytes) reached: aborting transfer of \'%s\'",
                   (unsigned long long )nbytes_max_store, path);
#line 1638
        stor_abort();
#line 1642
        pr_data_abort(122, 0);
#line 1648
        tmp___46 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1648
        return (tmp___46);
      }
    }
    {
#line 1651
    res = pr_fsio_write(stor_fh, (char const   *)lbuf, (size_t )len);
    }
#line 1652
    if (res != len) {
#line 1653
      xerrno___0 = 5;
#line 1655
      if (res < 0) {
        {
#line 1656
        tmp___47 = __errno_location();
#line 1656
        xerrno___0 = *tmp___47;
        }
      }
      {
#line 1658
      tmp___48 = strerror(xerrno___0);
#line 1658
      pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error writing to \'%s\': %s",
                   *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                   stor_fh->fh_path, tmp___48);
#line 1663
      stor_abort();
#line 1664
      pr_data_abort(xerrno___0, 0);
#line 1665
      tmp___49 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1665
      return (tmp___49);
    }
    {
#line 1669
    pr_throttle_pause(nbytes_stored, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1672
  if (session.sf_flags & (int volatile   )2) {
    {
#line 1673
    stor_abort();
#line 1674
    pr_data_abort(0, 0);
#line 1675
    tmp___50 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1675
    return (tmp___50);
  } else
#line 1677
  if (len < 0) {
    {
#line 1678
    stor_abort();
#line 1679
    pr_data_abort(((session.d)->instrm)->strm_errno, 0);
#line 1680
    tmp___51 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1680
    return (tmp___51);
  } else {
    {
#line 1685
    pr_throttle_pause(nbytes_stored, 1);
#line 1687
    tmp___59 = stor_complete();
    }
#line 1687
    if (tmp___59 < 0) {
      {
#line 1694
      tmp___55 = __errno_location();
      }
#line 1694
      if (*tmp___55 == 122) {
        {
#line 1695
        tmp___52 = __errno_location();
#line 1695
        tmp___53 = strerror(*tmp___52);
#line 1695
        pr_response_add_err("552", "%s: %s", cmd->arg, tmp___53);
#line 1696
        tmp___54 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1696
        return (tmp___54);
      }
      {
#line 1705
      tmp___56 = __errno_location();
#line 1705
      tmp___57 = strerror(*tmp___56);
#line 1705
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___57);
#line 1706
      tmp___58 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1706
      return (tmp___58);
    }
#line 1709
    if (session.xfer.path) {
#line 1709
      if (session.xfer.path_hidden) {
        {
#line 1711
        tmp___65 = pr_fsio_rename((char const   *)session.xfer.path_hidden, (char const   *)session.xfer.path);
        }
#line 1711
        if (tmp___65 != 0) {
          {
#line 1718
          tmp___60 = __errno_location();
#line 1718
          tmp___61 = strerror(*tmp___60);
#line 1718
          pr_log_pri(4, "Rename of %s to %s failed: %s.", session.xfer.path_hidden,
                     session.xfer.path, tmp___61);
#line 1721
          tmp___62 = __errno_location();
#line 1721
          tmp___63 = strerror(*tmp___62);
#line 1721
          pr_response_add_err("550", "%s: Rename of hidden file %s failed: %s", session.xfer.path,
                              session.xfer.path_hidden, tmp___63);
#line 1724
          pr_fsio_unlink((char const   *)session.xfer.path_hidden);
#line 1725
          tmp___64 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 1725
          return (tmp___64);
        }
      }
    }
    {
#line 1729
    pr_data_close(0);
    }
  }
  {
#line 1732
  tmp___66 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1732
  return (tmp___66);
}
}
#line 1735 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_rest(cmd_rec *cmd ) 
{ 
  off_t___0 pos ;
  char *endp ;
  unsigned char *hidden_stores ;
  char *tmp ;
  modret_t *tmp___0 ;
  xaset_t *tmp___1 ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  modret_t *tmp___4 ;
  modret_t *tmp___5 ;
  unsigned long long tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1737
  endp = (char *)((void *)0);
#line 1738
  hidden_stores = (unsigned char *)((void *)0);
#line 1740
  if (cmd->argc != 2) {
    {
#line 1741
    tmp = get_full_cmd(cmd);
#line 1741
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 1742
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1742
    return (tmp___0);
  }
#line 1746
  if (session.dir_config) {
#line 1746
    tmp___2 = (session.dir_config)->subset;
  } else {
#line 1746
    if (session.anon_config) {
#line 1746
      tmp___1 = (session.anon_config)->subset;
    } else {
#line 1746
      tmp___1 = main_server->conf;
    }
#line 1746
    tmp___2 = tmp___1;
  }
  {
#line 1746
  tmp___3 = get_param_ptr(tmp___2, "HiddenStores", 0);
#line 1746
  hidden_stores = (unsigned char *)tmp___3;
  }
#line 1747
  if ((unsigned long )hidden_stores != (unsigned long )((void *)0)) {
#line 1747
    if ((int )*hidden_stores == 1) {
      {
#line 1749
      pr_response_add_err("501", "REST not compatible with server configuration");
#line 1751
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1751
      return (tmp___4);
    }
  }
#line 1757
  if ((int )*(*(cmd->argv + 1)) == 45) {
    {
#line 1758
    pr_response_add_err("501", "REST requires a value greater than or equal to 0");
#line 1760
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1760
    return (tmp___5);
  }
  {
#line 1764
  tmp___6 = strtoull((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 1764
  pos = (off_t___0 )tmp___6;
  }
#line 1769
  if (endp) {
#line 1769
    if (*endp) {
      {
#line 1771
      pr_response_add_err("501", "REST requires a value greater than or equal to 0");
#line 1773
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1773
      return (tmp___7);
    }
  }
#line 1785
  if (session.sf_flags & (int volatile   )16) {
#line 1785
    if (pos != 0LL) {
      {
#line 1787
      pr_log_debug(5, "%s not allowed in ASCII mode", *(cmd->argv + 0));
#line 1788
      pr_response_add_err("501", "%s: Resuming transfers not allowed in ASCII mode",
                          *(cmd->argv + 0));
#line 1790
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1790
      return (tmp___8);
    }
  }
  {
#line 1793
  session.restart_pos = pos;
#line 1795
  pr_response_add("350", "Restarting at %llu. Send STORE or RETRIEVE to initiate transfer",
                  (unsigned long long )pos);
#line 1797
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1797
  return (tmp___9);
}
}
#line 1804 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_pre_retr(cmd_rec *cmd ) 
{ 
  char *dir ;
  mode_t fmode ;
  unsigned char *allow_restart ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  int tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  xaset_t *tmp___11 ;
  xaset_t *tmp___12 ;
  void *tmp___13 ;
  modret_t *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  modret_t *tmp___19 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 1805
  dir = (char *)((void *)0);
#line 1807
  allow_restart = (unsigned char *)((void *)0);
#line 1809
  xfer_logged_sendfile_decline_msg = 0;
#line 1811
  if (cmd->argc < 2) {
    {
#line 1812
    tmp = get_full_cmd(cmd);
#line 1812
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 1813
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1813
    return (tmp___0);
  }
  {
#line 1816
  tmp___1 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 1816
  dir = dir_realpath(cmd->tmp_pool, (char const   *)tmp___1);
  }
#line 1819
  if (! dir) {
    {
#line 1821
    tmp___2 = __errno_location();
#line 1821
    tmp___3 = strerror(*tmp___2);
#line 1821
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 1822
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1822
    return (tmp___4);
  } else {
    {
#line 1819
    tmp___5 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, dir, (int *)((void *)0));
    }
#line 1819
    if (! tmp___5) {
      {
#line 1821
      tmp___2 = __errno_location();
#line 1821
      tmp___3 = strerror(*tmp___2);
#line 1821
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 1822
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1822
      return (tmp___4);
    }
  }
  {
#line 1825
  tmp___7 = xfer_check_limit(cmd);
  }
#line 1825
  if (tmp___7 < 0) {
    {
#line 1826
    pr_response_add_err("451", "%s: Too many transfers", cmd->arg);
#line 1827
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1827
    return (tmp___6);
  }
  {
#line 1830
  fmode = file_mode(dir);
  }
#line 1832
  if (! ((fmode & 61440U) == 32768U)) {
#line 1833
    if (! fmode) {
      {
#line 1834
      tmp___8 = __errno_location();
#line 1834
      tmp___9 = strerror(*tmp___8);
#line 1834
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___9);
      }
    } else {
      {
#line 1836
      pr_response_add_err("550", "%s: Not a regular file", cmd->arg);
      }
    }
    {
#line 1837
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1837
    return (tmp___10);
  }
#line 1843
  if (session.dir_config) {
#line 1843
    tmp___12 = (session.dir_config)->subset;
  } else {
#line 1843
    if (session.anon_config) {
#line 1843
      tmp___11 = (session.anon_config)->subset;
    } else {
#line 1843
      tmp___11 = main_server->conf;
    }
#line 1843
    tmp___12 = tmp___11;
  }
  {
#line 1843
  tmp___13 = get_param_ptr(tmp___12, "AllowRetrieveRestart", 0);
#line 1843
  allow_restart = (unsigned char *)tmp___13;
  }
#line 1845
  if (session.restart_pos) {
#line 1845
    if (allow_restart) {
#line 1845
      if ((int )*allow_restart == 0) {
        {
#line 1847
        pr_response_add_err("451", "%s: Restart not permitted, try again", cmd->arg);
#line 1849
        session.restart_pos = (off_t___0 )0L;
#line 1850
        tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 1850
        return (tmp___14);
      }
    }
  }
  {
#line 1854
  tmp___17 = pstrdup(cmd->pool, (char const   *)dir);
#line 1854
  tmp___18 = pr_table_add(cmd->notes, "mod_xfer.retr-path", (void *)tmp___17, (size_t )0);
  }
#line 1854
  if (tmp___18 < 0) {
    {
#line 1856
    tmp___15 = __errno_location();
#line 1856
    tmp___16 = strerror(*tmp___15);
#line 1856
    pr_log_pri(5, "notice: error adding \'mod_xfer.retr-path\': %s", tmp___16);
    }
  }
  {
#line 1859
  xfer_prio_adjust();
#line 1860
  tmp___19 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1860
  return (tmp___19);
}
}
#line 1863 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_retr(cmd_rec *cmd ) 
{ 
  char *dir ;
  char *lbuf ;
  struct stat st ;
  off_t___0 nbytes_max_retrieve ;
  unsigned char have_limit ;
  long bufsz ;
  long len ;
  off_t___0 curr_pos ;
  off_t___0 nbytes_sent ;
  off_t___0 cnt_steps ;
  off_t___0 cnt_next ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  int xerrno ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  int tmp___10 ;
  modret_t *tmp___11 ;
  int xerrno___0 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  off_t___0 tmp___19 ;
  modret_t *tmp___20 ;
  int tmp___21 ;
  unsigned long tmp___22 ;
  char const   *tmp___23 ;
  modret_t *tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  int xerrno___1 ;
  int *tmp___27 ;
  modret_t *tmp___28 ;
  modret_t *tmp___29 ;
  modret_t *tmp___30 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
  {
#line 1864
  dir = (char *)((void *)0);
#line 1866
  nbytes_max_retrieve = (off_t___0 )0;
#line 1867
  have_limit = (unsigned char)0;
#line 1868
  len = 0L;
#line 1869
  curr_pos = (off_t___0 )0;
#line 1869
  nbytes_sent = (off_t___0 )0;
#line 1869
  cnt_steps = (off_t___0 )0;
#line 1869
  cnt_next = (off_t___0 )0;
#line 1872
  pr_throttle_init(cmd);
#line 1874
  tmp = pr_table_get(cmd->notes, "mod_xfer.retr-path", (size_t *)((void *)0));
#line 1874
  dir = (char *)tmp;
#line 1876
  retr_fh = pr_fsio_open((char const   *)dir, 0);
  }
#line 1877
  if ((unsigned long )retr_fh == (unsigned long )((void *)0)) {
    {
#line 1878
    tmp___0 = __errno_location();
#line 1878
    tmp___1 = strerror(*tmp___0);
#line 1878
    pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error opening \'%s\': %s",
                 *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                 dir, tmp___1);
#line 1883
    tmp___2 = __errno_location();
#line 1883
    tmp___3 = strerror(*tmp___2);
#line 1883
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 1884
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1884
    return (tmp___4);
  }
  {
#line 1887
  tmp___10 = pr_fsio_stat((char const   *)dir, & st);
  }
#line 1887
  if (tmp___10 < 0) {
    {
#line 1889
    tmp___5 = __errno_location();
#line 1889
    xerrno = *tmp___5;
#line 1890
    pr_fsio_close(retr_fh);
#line 1891
    tmp___6 = __errno_location();
#line 1891
    *tmp___6 = xerrno;
#line 1893
    retr_fh = (pr_fh_t *)((void *)0);
#line 1894
    tmp___7 = __errno_location();
#line 1894
    tmp___8 = strerror(*tmp___7);
#line 1894
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___8);
#line 1895
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1895
    return (tmp___9);
  }
#line 1898
  if (session.restart_pos) {
#line 1903
    if (session.restart_pos > st.st_size) {
      {
#line 1904
      pr_response_add_err("554", "%s: invalid REST argument", cmd->arg);
#line 1905
      pr_fsio_close(retr_fh);
#line 1906
      retr_fh = (pr_fh_t *)((void *)0);
#line 1908
      tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1908
      return (tmp___11);
    }
    {
#line 1911
    tmp___19 = pr_fsio_lseek(retr_fh, session.restart_pos, 0);
    }
#line 1911
    if (tmp___19 == -1LL) {
      {
#line 1913
      tmp___12 = __errno_location();
#line 1913
      xerrno___0 = *tmp___12;
#line 1914
      pr_fsio_close(retr_fh);
#line 1915
      tmp___13 = __errno_location();
#line 1915
      *tmp___13 = xerrno___0;
#line 1916
      retr_fh = (pr_fh_t *)((void *)0);
#line 1918
      tmp___14 = __errno_location();
#line 1918
      tmp___15 = strerror(*tmp___14);
#line 1918
      pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error seeking to byte %llu of \'%s\': %s",
                   *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                   (unsigned long long )session.restart_pos, dir, tmp___15);
#line 1923
      tmp___16 = __errno_location();
#line 1923
      tmp___17 = strerror(*tmp___16);
#line 1923
      pr_log_debug(0, "error seeking to offset %llufor file %s: %s", (unsigned long long )session.restart_pos,
                   dir, tmp___17);
#line 1926
      pr_response_add_err("554", "%s: invalid REST argument", cmd->arg);
#line 1927
      tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1927
      return (tmp___18);
    }
#line 1930
    curr_pos = session.restart_pos;
#line 1931
    session.restart_pos = (off_t___0 )0L;
  }
  {
#line 1935
  pr_data_init(cmd->arg, 2);
#line 1937
  session.xfer.path = dir;
#line 1938
  session.xfer.file_size = st.st_size;
#line 1940
  cnt_steps = session.xfer.file_size / 100LL;
  }
#line 1941
  if (cnt_steps == 0LL) {
#line 1942
    cnt_steps = (off_t___0 )1;
  }
  {
#line 1944
  tmp___21 = pr_data_open(cmd->arg, (char *)((void *)0), 2, st.st_size - curr_pos);
  }
#line 1944
  if (tmp___21 < 0) {
    {
#line 1945
    retr_abort();
#line 1946
    pr_data_abort(0, 1);
#line 1947
    tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 1947
    return (tmp___20);
  }
  {
#line 1951
  tmp___22 = find_max_nbytes((char *)"MaxRetrieveFileSize");
#line 1951
  nbytes_max_retrieve = (off_t___0 )tmp___22;
  }
#line 1952
  if (nbytes_max_retrieve == 0LL) {
#line 1953
    have_limit = (unsigned char)0;
  } else {
#line 1955
    have_limit = (unsigned char)1;
  }
#line 1961
  if (have_limit) {
#line 1961
    if (nbytes_max_retrieve == 0LL) {
#line 1961
      goto _L;
    } else
#line 1961
    if (st.st_size > nbytes_max_retrieve) {
      _L: /* CIL Label */ 
#line 1964
      if (nbytes_max_retrieve != 1LL) {
#line 1964
        tmp___23 = "bytes";
      } else {
#line 1964
        tmp___23 = "byte";
      }
      {
#line 1964
      pr_log_pri(6, "MaxRetrieveFileSize (%llu %s) reached: aborting transfer of \'%s\'",
                 (unsigned long long )nbytes_max_retrieve, tmp___23, dir);
#line 1969
      retr_abort();
#line 1972
      pr_data_abort(1, 0);
#line 1973
      tmp___24 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 1973
      return (tmp___24);
    }
  }
#line 1976
  if (main_server->tcp_sndbuf_len > 0) {
#line 1976
    bufsz = (long )main_server->tcp_sndbuf_len;
  } else {
    {
#line 1976
    tmp___25 = pr_config_get_xfer_bufsz();
#line 1976
    bufsz = (long )tmp___25;
    }
  }
  {
#line 1978
  tmp___26 = palloc(cmd->tmp_pool, (int )bufsz);
#line 1978
  lbuf = (char *)tmp___26;
#line 1980
  nbytes_sent = curr_pos;
#line 1982
  pr_scoreboard_entry_update(session.pid, 12, session.xfer.file_size, 11, (off_t___0 )0,
                             (void *)0);
  }
  {
#line 1987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1987
    if (! (nbytes_sent != session.xfer.file_size)) {
#line 1987
      goto while_break;
    }
    {
#line 1988
    pr_signals_handle();
    }
#line 1990
    if (session.sf_flags & (int volatile   )2) {
#line 1991
      goto while_break;
    }
    {
#line 1993
    len = transmit_data(nbytes_sent, & curr_pos, lbuf, bufsz);
    }
#line 1994
    if (len == 0L) {
#line 1995
      goto while_break;
    }
#line 1997
    if (len < 0L) {
      {
#line 2001
      tmp___27 = __errno_location();
#line 2001
      xerrno___1 = *tmp___27;
#line 2003
      retr_abort();
#line 2005
      pr_data_abort(xerrno___1, 0);
#line 2006
      tmp___28 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 2006
      return (tmp___28);
    }
#line 2009
    nbytes_sent += (off_t___0 )len;
#line 2011
    if (nbytes_sent / cnt_steps != cnt_next) {
      {
#line 2012
      cnt_next = nbytes_sent / cnt_steps;
#line 2014
      pr_scoreboard_entry_update(session.pid, 11, nbytes_sent, (void *)0);
      }
    }
    {
#line 2025
    pr_throttle_pause(session.xfer.total_bytes, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2028
  if (session.sf_flags & (int volatile   )2) {
    {
#line 2029
    retr_abort();
#line 2030
    pr_data_abort(0, 0);
#line 2031
    tmp___29 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2031
    return (tmp___29);
  } else {
    {
#line 2040
    pr_throttle_pause(session.xfer.total_bytes, 1);
#line 2042
    retr_complete();
#line 2043
    pr_data_close(0);
    }
  }
  {
#line 2046
  tmp___30 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2046
  return (tmp___30);
}
}
#line 2049 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_abor(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2050
  if (cmd->argc != 1) {
    {
#line 2051
    tmp = get_full_cmd(cmd);
#line 2051
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 2052
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2052
    return (tmp___0);
  }
#line 2055
  if (session.xfer.direction == 1) {
    {
#line 2056
    stor_abort();
    }
  } else
#line 2058
  if (session.xfer.direction == 2) {
    {
#line 2059
    retr_abort();
    }
  }
  {
#line 2062
  pr_data_abort(0, 0);
#line 2063
  pr_data_reset();
#line 2064
  pr_data_cleanup();
#line 2066
  pr_response_add("226", "Abort successful");
#line 2067
  tmp___1 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2067
  return (tmp___1);
}
}
#line 2070 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_type(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 2071
  if (cmd->argc < 2) {
    {
#line 2072
    tmp = get_full_cmd(cmd);
#line 2072
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 2073
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2073
    return (tmp___0);
  } else
#line 2071
  if (cmd->argc > 3) {
    {
#line 2072
    tmp = get_full_cmd(cmd);
#line 2072
    pr_response_add_err("500", "\'%s\' not understood", tmp);
#line 2073
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2073
    return (tmp___0);
  }
  {
#line 2076
  tmp___1 = toupper((int )*(*(cmd->argv + 1) + 0));
#line 2076
  *(*(cmd->argv + 1) + 0) = (char )tmp___1;
#line 2078
  tmp___7 = strcmp((char const   *)*(cmd->argv + 1), "A");
  }
#line 2078
  if (tmp___7) {
#line 2078
    if (cmd->argc == 3) {
      {
#line 2078
      tmp___8 = strcmp((char const   *)*(cmd->argv + 1), "L");
      }
#line 2078
      if (tmp___8) {
#line 2078
        goto _L___0;
      } else {
        {
#line 2078
        tmp___9 = strcmp((char const   *)*(cmd->argv + 2), "7");
        }
#line 2078
        if (tmp___9) {
#line 2078
          goto _L___0;
        } else {
#line 2083
          session.sf_flags |= (int volatile   )16;
        }
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 2085
      tmp___4 = strcmp((char const   *)*(cmd->argv + 1), "I");
      }
#line 2085
      if (tmp___4) {
#line 2085
        if (cmd->argc == 3) {
          {
#line 2085
          tmp___5 = strcmp((char const   *)*(cmd->argv + 1), "L");
          }
#line 2085
          if (tmp___5) {
            {
#line 2093
            tmp___2 = get_full_cmd(cmd);
#line 2093
            pr_response_add_err("500", "\'%s\' not understood", tmp___2);
#line 2094
            tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
            }
#line 2094
            return (tmp___3);
          } else {
            {
#line 2085
            tmp___6 = strcmp((char const   *)*(cmd->argv + 2), "8");
            }
#line 2085
            if (tmp___6) {
              {
#line 2093
              tmp___2 = get_full_cmd(cmd);
#line 2093
              pr_response_add_err("500", "\'%s\' not understood", tmp___2);
#line 2094
              tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                       (char *)((void *)0));
              }
#line 2094
              return (tmp___3);
            } else {
#line 2090
              session.sf_flags &= (int volatile   )1863;
            }
          }
        } else {
          {
#line 2093
          tmp___2 = get_full_cmd(cmd);
#line 2093
          pr_response_add_err("500", "\'%s\' not understood", tmp___2);
#line 2094
          tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 2094
          return (tmp___3);
        }
      } else {
#line 2090
        session.sf_flags &= (int volatile   )1863;
      }
    }
  } else {
#line 2083
    session.sf_flags |= (int volatile   )16;
  }
  {
#line 2097
  pr_response_add("200", "Type set to %s", *(cmd->argv + 1));
#line 2098
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2098
  return (tmp___10);
}
}
#line 2101 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_stru(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  int tmp___1 ;
  modret_t *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2102
  if (cmd->argc != 2) {
    {
#line 2103
    tmp = get_full_cmd(cmd);
#line 2103
    pr_response_add_err("501", "\'%s\' not understood", tmp);
#line 2104
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2104
    return (tmp___0);
  }
  {
#line 2107
  tmp___1 = toupper((int )*(*(cmd->argv + 1) + 0));
#line 2107
  *(*(cmd->argv + 1) + 0) = (char )tmp___1;
  }
  {
#line 2110
  if ((int )*(*(cmd->argv + 1) + 0) == 70) {
#line 2110
    goto case_70;
  }
#line 2129
  if ((int )*(*(cmd->argv + 1) + 0) == 80) {
#line 2129
    goto case_80;
  }
#line 2129
  if ((int )*(*(cmd->argv + 1) + 0) == 82) {
#line 2129
    goto case_80;
  }
#line 2136
  goto switch_default;
  case_70: /* CIL Label */ 
  {
#line 2112
  pr_response_add("200", "Structure set to F");
#line 2113
  tmp___2 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2113
  return (tmp___2);
#line 2114
  goto switch_break;
  case_80: /* CIL Label */ 
  case_82: /* CIL Label */ 
  {
#line 2131
  tmp___3 = get_full_cmd(cmd);
#line 2131
  pr_response_add_err("504", "\'%s\' unsupported structure type", tmp___3);
#line 2133
  tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 2133
  return (tmp___4);
#line 2134
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2137
  tmp___5 = get_full_cmd(cmd);
#line 2137
  pr_response_add_err("501", "\'%s\' unrecognized structure type", tmp___5);
#line 2139
  tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 2139
  return (tmp___6);
#line 2140
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2142
  return ((modret_t *)0);
}
}
#line 2144 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_mode(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  int tmp___1 ;
  modret_t *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2145
  if (cmd->argc != 2) {
    {
#line 2146
    tmp = get_full_cmd(cmd);
#line 2146
    pr_response_add_err("501", "\'%s\' not understood", tmp);
#line 2147
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2147
    return (tmp___0);
  }
  {
#line 2150
  tmp___1 = toupper((int )*(*(cmd->argv + 1) + 0));
#line 2150
  *(*(cmd->argv + 1) + 0) = (char )tmp___1;
  }
  {
#line 2153
  if ((int )*(*(cmd->argv + 1) + 0) == 83) {
#line 2153
    goto case_83;
  }
#line 2162
  if ((int )*(*(cmd->argv + 1) + 0) == 67) {
#line 2162
    goto case_67;
  }
#line 2162
  if ((int )*(*(cmd->argv + 1) + 0) == 66) {
#line 2162
    goto case_67;
  }
#line 2168
  goto switch_default;
  case_83: /* CIL Label */ 
  {
#line 2155
  pr_response_add("200", "Mode set to S");
#line 2156
  tmp___2 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2156
  return (tmp___2);
#line 2157
  goto switch_break;
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  {
#line 2163
  tmp___3 = get_full_cmd(cmd);
#line 2163
  pr_response_add_err("504", "\'%s\' unsupported transfer mode", tmp___3);
#line 2165
  tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 2165
  return (tmp___4);
#line 2166
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2169
  tmp___5 = get_full_cmd(cmd);
#line 2169
  pr_response_add_err("501", "\'%s\' unrecognized transfer mode", tmp___5);
#line 2171
  tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 2171
  return (tmp___6);
#line 2172
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2174
  return ((modret_t *)0);
}
}
#line 2176 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_allo(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 2177
  pr_response_add("202", "No storage allocation necessary");
#line 2178
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2178
  return (tmp);
}
}
#line 2181 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_smnt(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 2182
  pr_response_add("502", "SMNT command not implemented");
#line 2183
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2183
  return (tmp);
}
}
#line 2186 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_err_cleanup(cmd_rec *cmd ) 
{ 


  {
  {
#line 2187
  pr_data_clear_xfer_pool();
#line 2189
  memset((void *)(& session.xfer), '\000', (size_t )sizeof(session.xfer));
#line 2192
  session.restart_pos = (off_t___0 )0;
#line 2194
  xfer_prio_restore();
  }
#line 2195
  return ((modret_t *)((void *)0));
}
}
#line 2198 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_log_stor(cmd_rec *cmd ) 
{ 


  {
  {
#line 2199
  _log_transfer((char )'i', (char )'c');
#line 2202
  session.total_bytes_in += session.xfer.total_bytes;
#line 2205
  (session.total_files_in) ++;
#line 2206
  (session.total_files_xfer) ++;
#line 2208
  pr_data_cleanup();
#line 2211
  session.restart_pos = (off_t___0 )0;
#line 2213
  xfer_prio_restore();
  }
#line 2214
  return ((modret_t *)((void *)0));
}
}
#line 2217 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_log_retr(cmd_rec *cmd ) 
{ 


  {
  {
#line 2219
  _log_transfer((char )'o', (char )'c');
#line 2222
  session.total_bytes_out += session.xfer.total_bytes;
#line 2225
  (session.total_files_out) ++;
#line 2226
  (session.total_files_xfer) ++;
#line 2228
  pr_data_cleanup();
#line 2231
  session.restart_pos = (off_t___0 )0;
#line 2233
  xfer_prio_restore();
  }
#line 2234
  return ((modret_t *)((void *)0));
}
}
#line 2237 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int noxfer_timeout_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                             void *data ) 
{ 
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 2238
  if (session.sf_flags & (int volatile   )4) {
#line 2240
    return (1);
  }
  {
#line 2242
  pr_event_generate("core.timeout-no-transfer", (void const   *)((void *)0));
#line 2243
  tmp = pr_data_get_timeout(2);
#line 2243
  pr_response_send_async("421", "No transfer timeout (%d seconds): closing control connection",
                         tmp);
#line 2247
  pr_timer_remove(2, (module *)4294967295U);
#line 2248
  pr_timer_remove(1, (module *)4294967295U);
  }
#line 2254
  if (session.sf_flags & (int volatile   )1) {
    {
#line 2255
    pr_log_pri(6, "Passive data transfer failed, possibly due to network issues");
#line 2257
    pr_log_pri(6, "Check your PassivePorts and MasqueradeAddress settings,");
#line 2259
    pr_log_pri(6, "and any router, NAT, and firewall rules in the network path.");
    }
  }
  {
#line 2263
  session_exit(5, (void *)"FTP no transfer timeout, disconnected", 0, (void *)0);
  }
#line 2264
  return (0);
}
}
#line 2267 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *xfer_post_pass(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  xaset_t *tmp ;
  int timeout ;
  xaset_t *tmp___0 ;
  int timeout___0 ;
  xaset_t *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2270
  if (session.anon_config) {
#line 2270
    tmp = (session.anon_config)->subset;
  } else {
#line 2270
    tmp = main_server->conf;
  }
  {
#line 2270
  c = find_config(tmp, 1 << 15, "TimeoutNoTransfer", 0);
  }
#line 2271
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 2272
    timeout = *((int *)*(c->argv + 0));
#line 2273
    pr_data_set_timeout(2, timeout);
    }
#line 2276
    if (timeout > 0) {
      {
#line 2277
      pr_timer_add(timeout, 3, & xfer_module, & noxfer_timeout_cb, "TimeoutNoTransfer");
      }
    }
  }
#line 2282
  if (session.anon_config) {
#line 2282
    tmp___0 = (session.anon_config)->subset;
  } else {
#line 2282
    tmp___0 = main_server->conf;
  }
  {
#line 2282
  c = find_config(tmp___0, 1 << 15, "TimeoutStalled", 0);
  }
#line 2283
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 2284
    timeout___0 = *((int *)*(c->argv + 0));
#line 2285
    pr_data_set_timeout(4, timeout___0);
    }
  }
#line 2293
  if (session.anon_config) {
#line 2293
    tmp___1 = (session.anon_config)->subset;
  } else {
#line 2293
    tmp___1 = main_server->conf;
  }
  {
#line 2293
  c = find_config(tmp___1, 1 << 15, "TransferPriority", 0);
  }
#line 2294
  if (c) {
#line 2295
    xfer_prio_flags = *((unsigned long *)*(c->argv + 0));
#line 2296
    xfer_prio_config = *((int *)*(c->argv + 1));
  }
#line 2299
  return ((modret_t *)((void *)0));
}
}
#line 2305 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_allowoverwrite(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2306
  bool = -1;
#line 2307
  c = (config_rec *)((void *)0);
#line 2309
  if (cmd->argc - 1 < 1) {
    {
#line 2309
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2309
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2309
    return (tmp___0);
  }
  {
#line 2310
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2310
  if (! tmp___5) {
    {
#line 2310
    tmp___1 = get_context_name(cmd);
#line 2310
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2310
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2310
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2310
    return (tmp___4);
  }
  {
#line 2313
  bool = get_boolean(cmd, 1);
  }
#line 2314
  if (bool == -1) {
    {
#line 2315
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected boolean parameter",
                      (void *)0);
#line 2315
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2315
    return (tmp___7);
  }
  {
#line 2317
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2318
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2319
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2320
  c->flags |= 1L;
#line 2322
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2322
  return (tmp___8);
}
}
#line 2325 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_allowrestart(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2326
  bool = -1;
#line 2327
  c = (config_rec *)((void *)0);
#line 2329
  if (cmd->argc - 1 < 1) {
    {
#line 2329
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2329
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2329
    return (tmp___0);
  }
  {
#line 2330
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2330
  if (! tmp___5) {
    {
#line 2330
    tmp___1 = get_context_name(cmd);
#line 2330
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2330
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2330
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2330
    return (tmp___4);
  }
  {
#line 2333
  bool = get_boolean(cmd, 1);
  }
#line 2334
  if (bool == -1) {
    {
#line 2335
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected boolean parameter",
                      (void *)0);
#line 2335
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2335
    return (tmp___7);
  }
  {
#line 2337
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2338
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2339
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2340
  c->flags |= 1L;
#line 2342
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2342
  return (tmp___8);
}
}
#line 2345 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_deleteabortedstores(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2346
  bool = -1;
#line 2347
  c = (config_rec *)((void *)0);
#line 2349
  if (cmd->argc - 1 < 1) {
    {
#line 2349
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2349
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2349
    return (tmp___0);
  }
  {
#line 2350
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2350
  if (! tmp___5) {
    {
#line 2350
    tmp___1 = get_context_name(cmd);
#line 2350
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2350
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2350
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2350
    return (tmp___4);
  }
  {
#line 2353
  bool = get_boolean(cmd, 1);
  }
#line 2354
  if (bool == -1) {
    {
#line 2355
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2355
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2355
    return (tmp___7);
  }
  {
#line 2357
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2358
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2359
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2360
  c->flags |= 1L;
#line 2362
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2362
  return (tmp___8);
}
}
#line 2366 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_displayfiletransfer(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 2367
  if (cmd->argc - 1 < 1) {
    {
#line 2367
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2367
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2367
    return (tmp___0);
  }
  {
#line 2368
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2368
  if (! tmp___5) {
    {
#line 2368
    tmp___1 = get_context_name(cmd);
#line 2368
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2368
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2368
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2368
    return (tmp___4);
  }
  {
#line 2370
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2371
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2371
  return (tmp___6);
}
}
#line 2374 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_hiddenstores(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2375
  bool = -1;
#line 2376
  c = (config_rec *)((void *)0);
#line 2378
  if (cmd->argc - 1 < 1) {
    {
#line 2378
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2378
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2378
    return (tmp___0);
  }
  {
#line 2379
  tmp___5 = check_context(cmd, (((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1));
  }
#line 2379
  if (! tmp___5) {
    {
#line 2379
    tmp___1 = get_context_name(cmd);
#line 2379
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2379
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2379
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2379
    return (tmp___4);
  }
  {
#line 2381
  bool = get_boolean(cmd, 1);
  }
#line 2382
  if (bool == -1) {
    {
#line 2383
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2383
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2383
    return (tmp___7);
  }
  {
#line 2385
  c = add_config_param("HiddenStores", 1, (void *)0);
#line 2386
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2387
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2388
  c->flags |= 1L;
#line 2390
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2390
  return (tmp___8);
}
}
#line 2393 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_maxfilesize(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  unsigned long nbytes ;
  unsigned int precedence ;
  int ctxt ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  unsigned char tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  char ulong_max[80] ;
  char *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  array_header *acl ;
  int argc ;
  char **argv ;
  void *tmp___22 ;
  void *tmp___23 ;
  char **tmp___24 ;
  void *tmp___25 ;
  char **tmp___26 ;
  char **tmp___27 ;
  char **tmp___28 ;
  int tmp___29 ;
  modret_t *tmp___30 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 2394
  c = (config_rec *)((void *)0);
#line 2396
  precedence = 0U;
#line 2398
  if (cmd->config) {
#line 2398
    if ((cmd->config)->config_type != 1 << 15) {
#line 2398
      tmp___0 = (cmd->config)->config_type;
    } else {
#line 2398
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2398
    if ((cmd->server)->config_type) {
#line 2398
      tmp = (cmd->server)->config_type;
    } else {
#line 2398
      tmp = 1;
    }
#line 2398
    tmp___0 = tmp;
  }
#line 2398
  ctxt = tmp___0;
#line 2402
  if (cmd->argc - 1 == 1) {
    {
#line 2403
    tmp___3 = strcmp((char const   *)*(cmd->argv + 1), "*");
    }
#line 2403
    if (tmp___3 != 0) {
      {
#line 2404
      tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "incorrect number of parameters",
                        (void *)0);
#line 2404
      tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
      }
#line 2404
      return (tmp___2);
    }
  } else
#line 2406
  if (cmd->argc - 1 != 2) {
#line 2406
    if (cmd->argc - 1 != 4) {
      {
#line 2407
      tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "incorrect number of parameters",
                        (void *)0);
#line 2407
      tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
      }
#line 2407
      return (tmp___5);
    }
  }
  {
#line 2409
  tmp___10 = check_context(cmd, ((((1 | (1 << 2)) | (1 << 4)) | (1 << 6)) | (1 << 1)) | (1 << 5));
  }
#line 2409
  if (! tmp___10) {
    {
#line 2409
    tmp___6 = get_context_name(cmd);
#line 2409
    tmp___7 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___6, " context",
                      (void *)0);
#line 2409
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 2409
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 2409
    return (tmp___9);
  }
#line 2415
  if (ctxt & (1 << 6)) {
#line 2416
    precedence = 1U;
  } else
#line 2419
  if (ctxt & 1) {
#line 2420
    precedence = 2U;
  } else
#line 2419
  if (ctxt & (1 << 4)) {
#line 2420
    precedence = 2U;
  } else
#line 2422
  if (ctxt & (1 << 2)) {
#line 2423
    precedence = 3U;
  } else
#line 2425
  if (ctxt & (1 << 1)) {
#line 2426
    precedence = 4U;
  } else
#line 2428
  if (ctxt & (1 << 5)) {
#line 2429
    precedence = 5U;
  }
#line 2435
  if (cmd->argc - 1 == 4) {
    {
#line 2436
    tmp___14 = strcmp((char const   *)*(cmd->argv + 3), "user");
    }
#line 2436
    if (tmp___14) {
      {
#line 2436
      tmp___15 = strcmp((char const   *)*(cmd->argv + 3), "group");
      }
#line 2436
      if (tmp___15) {
        {
#line 2436
        tmp___16 = strcmp((char const   *)*(cmd->argv + 3), "class");
        }
#line 2436
        if (tmp___16) {
          {
#line 2443
          tmp___11 = pstrcat(cmd->tmp_pool, "unknown classifier used: \'", *(cmd->argv + 3),
                             "\'", (void *)0);
#line 2443
          tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___11, (void *)0);
#line 2443
          tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
          }
#line 2443
          return (tmp___13);
        }
      }
    }
  }
#line 2447
  if (cmd->argc - 1 == 1) {
#line 2453
    nbytes = 0UL;
  } else {
    {
#line 2460
    nbytes = parse_max_nbytes(*(cmd->argv + 1), *(cmd->argv + 2));
    }
#line 2461
    if (nbytes == 0UL) {
#line 2462
      if (xfer_errno == 22) {
        {
#line 2463
        tmp___17 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "invalid parameters",
                           (void *)0);
#line 2463
        tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___17);
        }
#line 2463
        return (tmp___18);
      }
#line 2465
      if (xfer_errno == 34) {
        {
#line 2468
        memset((void *)(ulong_max), '\000', (size_t )sizeof(ulong_max));
#line 2469
        snprintf((char */* __restrict  */)(ulong_max), (size_t )(sizeof(ulong_max) - 1UL),
                 (char const   */* __restrict  */)"%lu", 4294967295UL);
#line 2472
        tmp___19 = pstrcat(cmd->tmp_pool, "number of bytes must be between 0 and ",
                           ulong_max, (void *)0);
#line 2472
        tmp___20 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___19, (void *)0);
#line 2472
        tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___20);
        }
#line 2472
        return (tmp___21);
      }
    }
  }
#line 2478
  if (cmd->argc - 1 == 1) {
    {
#line 2479
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2480
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned long ));
#line 2481
    *((unsigned long *)*(c->argv + 0)) = nbytes;
#line 2482
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2483
    *((unsigned int *)*(c->argv + 1)) = precedence;
    }
  } else
#line 2478
  if (cmd->argc - 1 == 2) {
    {
#line 2479
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2480
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned long ));
#line 2481
    *((unsigned long *)*(c->argv + 0)) = nbytes;
#line 2482
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2483
    *((unsigned int *)*(c->argv + 1)) = precedence;
    }
  } else {
    {
#line 2486
    acl = (array_header *)((void *)0);
#line 2487
    argc = cmd->argc - 4;
#line 2488
    argv = cmd->argv + 3;
#line 2490
    acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2492
    c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2493
    c->argc = argc + 3;
#line 2494
    tmp___22 = pcalloc(c->pool, (int )((unsigned long )(argc + 4) * sizeof(char *)));
#line 2494
    c->argv = (void **)tmp___22;
#line 2496
    argv = (char **)c->argv;
#line 2499
    tmp___23 = pcalloc(c->pool, (int )sizeof(unsigned long ));
#line 2499
    *argv = (char *)tmp___23;
#line 2500
    tmp___24 = argv;
#line 2500
    argv ++;
#line 2500
    *((unsigned long *)*tmp___24) = nbytes;
#line 2503
    tmp___25 = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2503
    *argv = (char *)tmp___25;
#line 2504
    tmp___26 = argv;
#line 2504
    argv ++;
#line 2504
    *((unsigned int *)*tmp___26) = precedence;
#line 2507
    tmp___27 = argv;
#line 2507
    argv ++;
#line 2507
    *tmp___27 = pstrdup(c->pool, (char const   *)*(cmd->argv + 3));
    }
#line 2509
    if (argc) {
#line 2509
      if (acl) {
        {
#line 2510
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2510
          tmp___29 = argc;
#line 2510
          argc --;
#line 2510
          if (! tmp___29) {
#line 2510
            goto while_break;
          }
          {
#line 2511
          tmp___28 = argv;
#line 2511
          argv ++;
#line 2511
          *tmp___28 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2512
          acl->elts = (void *)((char **)acl->elts + 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 2517
    *argv = (char *)((void *)0);
  }
  {
#line 2520
  c->flags |= (long )(1 << 1);
#line 2522
  tmp___30 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2522
  return (tmp___30);
}
}
#line 2526 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_maxtransfersperhost(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int count ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 2527
  c = (config_rec *)((void *)0);
#line 2528
  count = 0;
#line 2530
  if (cmd->argc - 1 < 2) {
    {
#line 2532
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "bad number of parameters",
                  (void *)0);
#line 2532
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2532
    return (tmp___0);
  } else
#line 2530
  if (cmd->argc - 1 > 3) {
    {
#line 2532
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "bad number of parameters",
                  (void *)0);
#line 2532
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2532
    return (tmp___0);
  }
  {
#line 2534
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2534
  if (! tmp___5) {
    {
#line 2534
    tmp___1 = get_context_name(cmd);
#line 2534
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2534
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2534
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2534
    return (tmp___4);
  }
  {
#line 2537
  count = atoi((char const   *)*(cmd->argv + 2));
  }
#line 2538
  if (count < 1) {
    {
#line 2539
    tmp___6 = pstrcat(cmd->tmp_pool, "count must be greater than zero: \'", *(cmd->argv + 2),
                      "\'", (void *)0);
#line 2539
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2539
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2539
    return (tmp___8);
  }
  {
#line 2542
  c = add_config_param((char const   *)*(cmd->argv + 0), 3, (void *)0, (void *)0,
                       (void *)0);
#line 2545
  tmp___11 = xfer_parse_cmdlist((char const   *)*(cmd->argv + 0), c, *(cmd->argv + 1));
  }
#line 2545
  if (tmp___11 < 0) {
    {
#line 2546
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "error with command list",
                      (void *)0);
#line 2546
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 2546
    return (tmp___10);
  }
  {
#line 2548
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2549
  *((unsigned int *)*(c->argv + 1)) = (unsigned int )count;
  }
#line 2551
  if (cmd->argc - 1 == 3) {
    {
#line 2552
    tmp___12 = pstrdup(c->pool, (char const   *)*(cmd->argv + 3));
#line 2552
    *(c->argv + 2) = (void *)tmp___12;
    }
  }
  {
#line 2554
  c->flags |= (long )(1 << 1);
#line 2556
  tmp___13 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2556
  return (tmp___13);
}
}
#line 2560 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_maxtransfersperuser(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int count ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 2561
  c = (config_rec *)((void *)0);
#line 2562
  count = 0;
#line 2564
  if (cmd->argc - 1 < 2) {
    {
#line 2566
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "bad number of parameters",
                  (void *)0);
#line 2566
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2566
    return (tmp___0);
  } else
#line 2564
  if (cmd->argc - 1 > 3) {
    {
#line 2566
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "bad number of parameters",
                  (void *)0);
#line 2566
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2566
    return (tmp___0);
  }
  {
#line 2568
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2568
  if (! tmp___5) {
    {
#line 2568
    tmp___1 = get_context_name(cmd);
#line 2568
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2568
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2568
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2568
    return (tmp___4);
  }
  {
#line 2571
  count = atoi((char const   *)*(cmd->argv + 2));
  }
#line 2572
  if (count < 1) {
    {
#line 2573
    tmp___6 = pstrcat(cmd->tmp_pool, "count must be greater than zero: \'", *(cmd->argv + 2),
                      "\'", (void *)0);
#line 2573
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2573
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2573
    return (tmp___8);
  }
  {
#line 2576
  c = add_config_param((char const   *)*(cmd->argv + 0), 3, (void *)0, (void *)0,
                       (void *)0);
#line 2579
  tmp___11 = xfer_parse_cmdlist((char const   *)*(cmd->argv + 0), c, *(cmd->argv + 1));
  }
#line 2579
  if (tmp___11 < 0) {
    {
#line 2580
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "error with command list",
                      (void *)0);
#line 2580
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 2580
    return (tmp___10);
  }
  {
#line 2582
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2583
  *((unsigned int *)*(c->argv + 1)) = (unsigned int )count;
  }
#line 2585
  if (cmd->argc - 1 == 3) {
    {
#line 2586
    tmp___12 = pstrdup(c->pool, (char const   *)*(cmd->argv + 3));
#line 2586
    *(c->argv + 2) = (void *)tmp___12;
    }
  }
  {
#line 2588
  c->flags |= (long )(1 << 1);
#line 2590
  tmp___13 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2590
  return (tmp___13);
}
}
#line 2593 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_storeuniqueprefix(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2594
  c = (config_rec *)((void *)0);
#line 2596
  if (cmd->argc - 1 < 1) {
    {
#line 2596
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2596
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2596
    return (tmp___0);
  }
  {
#line 2597
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2597
  if (! tmp___5) {
    {
#line 2597
    tmp___1 = get_context_name(cmd);
#line 2597
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2597
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2597
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2597
    return (tmp___4);
  }
  {
#line 2601
  tmp___9 = strchr((char const   *)*(cmd->argv + 1), '/');
  }
#line 2601
  if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
    {
#line 2602
    tmp___6 = pstrcat(cmd->tmp_pool, "no slashes allowed in prefix: \'", *(cmd->argv + 1),
                      "\'", (void *)0);
#line 2602
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2602
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2602
    return (tmp___8);
  }
  {
#line 2605
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, (void *)*(cmd->argv + 1));
#line 2606
  c->flags |= 1L;
#line 2608
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2608
  return (tmp___10);
}
}
#line 2611 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_timeoutnoxfer(cmd_rec *cmd ) 
{ 
  int timeout ;
  char *endp ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 2612
  timeout = -1;
#line 2613
  endp = (char *)((void *)0);
#line 2614
  c = (config_rec *)((void *)0);
#line 2616
  if (cmd->argc - 1 < 1) {
    {
#line 2616
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2616
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2616
    return (tmp___0);
  }
  {
#line 2617
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2617
  if (! tmp___5) {
    {
#line 2617
    tmp___1 = get_context_name(cmd);
#line 2617
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2617
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2617
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2617
    return (tmp___4);
  }
  {
#line 2619
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   10);
#line 2619
  timeout = (int )tmp___6;
  }
#line 2621
  if (endp) {
#line 2621
    if (*endp) {
      {
#line 2622
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                        (void *)0);
#line 2622
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2622
      return (tmp___8);
    } else {
#line 2621
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2621
  if (timeout < 0) {
    {
#line 2622
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 2622
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2622
    return (tmp___8);
  } else
#line 2621
  if (timeout > 65535) {
    {
#line 2622
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 2622
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2622
    return (tmp___8);
  }
  {
#line 2624
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2625
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 2626
  *((int *)*(c->argv + 0)) = timeout;
#line 2627
  c->flags |= 1L;
#line 2629
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2629
  return (tmp___9);
}
}
#line 2632 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_timeoutstalled(cmd_rec *cmd ) 
{ 
  int timeout ;
  char *endp ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 2633
  timeout = -1;
#line 2634
  endp = (char *)((void *)0);
#line 2635
  c = (config_rec *)((void *)0);
#line 2637
  if (cmd->argc - 1 < 1) {
    {
#line 2637
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2637
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2637
    return (tmp___0);
  }
  {
#line 2638
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2638
  if (! tmp___5) {
    {
#line 2638
    tmp___1 = get_context_name(cmd);
#line 2638
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2638
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2638
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2638
    return (tmp___4);
  }
  {
#line 2640
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   10);
#line 2640
  timeout = (int )tmp___6;
  }
#line 2642
  if (endp) {
#line 2642
    if (*endp) {
      {
#line 2643
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                        (void *)0);
#line 2643
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2643
      return (tmp___8);
    } else {
#line 2642
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2642
  if (timeout < 0) {
    {
#line 2643
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 2643
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2643
    return (tmp___8);
  } else
#line 2642
  if (timeout > 65535) {
    {
#line 2643
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 2643
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2643
    return (tmp___8);
  }
  {
#line 2645
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2646
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 2647
  *((int *)*(c->argv + 0)) = timeout;
#line 2648
  c->flags |= 1L;
#line 2650
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2650
  return (tmp___9);
}
}
#line 2655 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_transferpriority(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int prio ;
  char *str ;
  unsigned long flags ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int res ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  modret_t *tmp___20 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 2659
  flags = 0UL;
#line 2661
  if (cmd->argc - 1 < 2) {
    {
#line 2661
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2661
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2661
    return (tmp___0);
  }
  {
#line 2662
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2662
  if (! tmp___5) {
    {
#line 2662
    tmp___1 = get_context_name(cmd);
#line 2662
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2662
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2662
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2662
    return (tmp___4);
  }
  {
#line 2664
  tmp___12 = strcasecmp((char const   *)*(cmd->argv + 2), "low");
  }
#line 2664
  if (tmp___12 == 0) {
#line 2665
    prio = 15;
  } else {
    {
#line 2667
    tmp___11 = strcasecmp((char const   *)*(cmd->argv + 2), "medium");
    }
#line 2667
    if (tmp___11 == 0) {
#line 2668
      prio = 0;
    } else {
      {
#line 2670
      tmp___10 = strcasecmp((char const   *)*(cmd->argv + 2), "high");
      }
#line 2670
      if (tmp___10 == 0) {
#line 2671
        prio = -15;
      } else {
        {
#line 2674
        tmp___6 = atoi((char const   *)*(cmd->argv + 2));
#line 2674
        res = tmp___6;
        }
#line 2676
        if (res < -20) {
          {
#line 2678
          tmp___7 = pstrcat(cmd->tmp_pool, ": invalid priority \'", *(cmd->argv + 2),
                            "\'", (void *)0);
#line 2678
          tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 2678
          tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
          }
#line 2678
          return (tmp___9);
        } else
#line 2676
        if (res > 20) {
          {
#line 2678
          tmp___7 = pstrcat(cmd->tmp_pool, ": invalid priority \'", *(cmd->argv + 2),
                            "\'", (void *)0);
#line 2678
          tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 2678
          tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
          }
#line 2678
          return (tmp___9);
        }
#line 2682
        prio = res;
      }
    }
  }
  {
#line 2685
  c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
  }
  {
#line 2688
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2688
    str = get_cmd_from_list(cmd->argv + 1);
    }
#line 2688
    if (! ((unsigned long )str != (unsigned long )((void *)0))) {
#line 2688
      goto while_break;
    }
    {
#line 2690
    tmp___19 = strcmp((char const   *)str, "APPE");
    }
#line 2690
    if (tmp___19 == 0) {
#line 2691
      flags |= 1UL;
    } else {
      {
#line 2693
      tmp___18 = strcmp((char const   *)str, "RETR");
      }
#line 2693
      if (tmp___18 == 0) {
#line 2694
        flags |= 2UL;
      } else {
        {
#line 2696
        tmp___17 = strcmp((char const   *)str, "STOR");
        }
#line 2696
        if (tmp___17 == 0) {
#line 2697
          flags |= 4UL;
        } else {
          {
#line 2699
          tmp___16 = strcmp((char const   *)str, "STOU");
          }
#line 2699
          if (tmp___16 == 0) {
#line 2700
            flags |= 8UL;
          } else {
            {
#line 2703
            tmp___13 = pstrcat(cmd->tmp_pool, ": invalid FTP transfer command: \'",
                               str, "\'", (void *)0);
#line 2703
            tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___13, (void *)0);
#line 2703
            tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___14);
            }
#line 2703
            return (tmp___15);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2708
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned long ));
#line 2709
  *((unsigned long *)*(c->argv + 0)) = flags;
#line 2710
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(int ));
#line 2711
  *((int *)*(c->argv + 1)) = prio;
#line 2712
  c->flags |= 1L;
#line 2714
  tmp___20 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2714
  return (tmp___20);
}
}
#line 2720 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_transferrate(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  char *endp ;
  long double rate ;
  off_t___0 freebytes ;
  unsigned int precedence ;
  int ctxt ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  unsigned char tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  char *tmp___16 ;
  modret_t *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  modret_t *tmp___23 ;
  unsigned long tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  modret_t *tmp___27 ;
  char *tmp___28 ;
  modret_t *tmp___29 ;
  int tmp___30 ;
  array_header *acl ;
  int argc ;
  char **argv ;
  void *tmp___31 ;
  char *tmp___32 ;
  modret_t *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  char **tmp___36 ;
  void *tmp___37 ;
  char **tmp___38 ;
  void *tmp___39 ;
  char **tmp___40 ;
  char **tmp___41 ;
  char **tmp___42 ;
  int tmp___43 ;
  modret_t *tmp___44 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 2721
  c = (config_rec *)((void *)0);
#line 2722
  tmp = (char *)((void *)0);
#line 2722
  endp = (char *)((void *)0);
#line 2723
  rate = (long double )0.0;
#line 2724
  freebytes = (off_t___0 )0;
#line 2725
  precedence = 0U;
#line 2727
  if (cmd->config) {
#line 2727
    if ((cmd->config)->config_type != 1 << 15) {
#line 2727
      tmp___1 = (cmd->config)->config_type;
    } else {
#line 2727
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2727
    if ((cmd->server)->config_type) {
#line 2727
      tmp___0 = (cmd->server)->config_type;
    } else {
#line 2727
      tmp___0 = 1;
    }
#line 2727
    tmp___1 = tmp___0;
  }
#line 2727
  ctxt = tmp___1;
#line 2732
  if (cmd->argc - 1 != 2) {
#line 2732
    if (cmd->argc - 1 != 4) {
      {
#line 2733
      tmp___2 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                        (void *)0);
#line 2733
      tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___2);
      }
#line 2733
      return (tmp___3);
    }
  }
  {
#line 2735
  tmp___8 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2735
  if (! tmp___8) {
    {
#line 2735
    tmp___4 = get_context_name(cmd);
#line 2735
    tmp___5 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___4, " context",
                      (void *)0);
#line 2735
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___5, (void *)0);
#line 2735
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2735
    return (tmp___7);
  }
#line 2741
  if (ctxt & (1 << 6)) {
#line 2742
    precedence = 1U;
  } else
#line 2745
  if (ctxt & 1) {
#line 2746
    precedence = 2U;
  } else
#line 2745
  if (ctxt & (1 << 4)) {
#line 2746
    precedence = 2U;
  } else
#line 2748
  if (ctxt & (1 << 2)) {
#line 2749
    precedence = 3U;
  } else
#line 2751
  if (ctxt & (1 << 1)) {
#line 2752
    precedence = 4U;
  } else
#line 2758
  if (ctxt & (1 << 5)) {
#line 2759
    precedence = 5U;
  }
#line 2762
  if (cmd->argc - 1 > 2) {
    {
#line 2763
    tmp___12 = strcmp((char const   *)*(cmd->argv + 3), "user");
    }
#line 2763
    if (tmp___12) {
      {
#line 2763
      tmp___13 = strcmp((char const   *)*(cmd->argv + 3), "group");
      }
#line 2763
      if (tmp___13) {
        {
#line 2763
        tmp___14 = strcmp((char const   *)*(cmd->argv + 3), "class");
        }
#line 2763
        if (tmp___14) {
          {
#line 2769
          tmp___9 = pstrcat(cmd->tmp_pool, "unknown classifier requested: \'", *(cmd->argv + 3),
                            "\'", (void *)0);
#line 2769
          tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___9, (void *)0);
#line 2769
          tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
          }
#line 2769
          return (tmp___11);
        }
      }
    }
  }
  {
#line 2773
  tmp = strchr((char const   *)*(cmd->argv + 2), ':');
  }
#line 2773
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2774
    *tmp = (char )'\000';
  }
  {
#line 2779
  tmp___15 = strtod((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& endp));
#line 2779
  rate = (long double )tmp___15;
  }
#line 2781
  if (rate < (long double )0.0) {
    {
#line 2782
    tmp___16 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "rate must be greater than zero",
                       (void *)0);
#line 2782
    tmp___17 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___16);
    }
#line 2782
    return (tmp___17);
  }
#line 2784
  if (endp) {
#line 2784
    if (*endp) {
      {
#line 2785
      tmp___18 = pstrcat(cmd->tmp_pool, "invalid number: \'", *(cmd->argv + 2), "\'",
                         (void *)0);
#line 2785
      tmp___19 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___18, (void *)0);
#line 2785
      tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___19);
      }
#line 2785
      return (tmp___20);
    }
  }
#line 2789
  if (tmp) {
    {
#line 2790
    tmp ++;
#line 2790
    *(cmd->argv + 2) = tmp;
#line 2792
    tmp___24 = strtoul((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& endp),
                       10);
#line 2792
    freebytes = (off_t___0 )tmp___24;
    }
#line 2792
    if (freebytes < 0LL) {
      {
#line 2793
      tmp___21 = pstrcat(cmd->tmp_pool, "negative values not allowed: \'", *(cmd->argv + 2),
                         "\'", (void *)0);
#line 2793
      tmp___22 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___21, (void *)0);
#line 2793
      tmp___23 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___22);
      }
#line 2793
      return (tmp___23);
    }
#line 2796
    if (endp) {
#line 2796
      if (*endp) {
        {
#line 2797
        tmp___25 = pstrcat(cmd->tmp_pool, "invalid number: \'", *(cmd->argv + 2),
                           "\'", (void *)0);
#line 2797
        tmp___26 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___25, (void *)0);
#line 2797
        tmp___27 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___26);
        }
#line 2797
        return (tmp___27);
      }
    }
  }
#line 2802
  if (cmd->argc - 1 == 2) {
    {
#line 2803
    c = add_config_param((char const   *)*(cmd->argv + 0), 4, (void *)0, (void *)0,
                         (void *)0, (void *)0);
#line 2806
    tmp___30 = xfer_parse_cmdlist((char const   *)*(cmd->argv + 0), c, *(cmd->argv + 1));
    }
#line 2806
    if (tmp___30 < 0) {
      {
#line 2807
      tmp___28 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "error with command list",
                         (void *)0);
#line 2807
      tmp___29 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___28);
      }
#line 2807
      return (tmp___29);
    }
    {
#line 2809
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(long double ));
#line 2810
    *((long double *)*(c->argv + 1)) = rate;
#line 2811
    *(c->argv + 2) = pcalloc(c->pool, (int )sizeof(off_t___0 ));
#line 2812
    *((off_t___0 *)*(c->argv + 2)) = freebytes;
#line 2813
    *(c->argv + 3) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2814
    *((unsigned int *)*(c->argv + 3)) = precedence;
    }
  } else {
    {
#line 2817
    acl = (array_header *)((void *)0);
#line 2818
    argc = cmd->argc - 4;
#line 2819
    argv = cmd->argv + 3;
#line 2821
    acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2823
    c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2830
    c->argc = argc + 5;
#line 2832
    tmp___31 = pcalloc(c->pool, (int )((unsigned long )(c->argc + 1) * sizeof(char *)));
#line 2832
    c->argv = (void **)tmp___31;
#line 2833
    argv = (char **)c->argv;
#line 2835
    tmp___34 = xfer_parse_cmdlist((char const   *)*(cmd->argv + 0), c, *(cmd->argv + 1));
    }
#line 2835
    if (tmp___34 < 0) {
      {
#line 2836
      tmp___32 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "error with command list",
                         (void *)0);
#line 2836
      tmp___33 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___32);
      }
#line 2836
      return (tmp___33);
    }
    {
#line 2839
    argv ++;
#line 2841
    tmp___35 = pcalloc(c->pool, (int )sizeof(long double ));
#line 2841
    *argv = (char *)tmp___35;
#line 2842
    tmp___36 = argv;
#line 2842
    argv ++;
#line 2842
    *((long double *)*tmp___36) = rate;
#line 2843
    tmp___37 = pcalloc(c->pool, (int )sizeof(off_t___0 ));
#line 2843
    *argv = (char *)tmp___37;
#line 2844
    tmp___38 = argv;
#line 2844
    argv ++;
#line 2844
    *((unsigned long *)*tmp___38) = (unsigned long )freebytes;
#line 2845
    tmp___39 = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2845
    *argv = (char *)tmp___39;
#line 2846
    tmp___40 = argv;
#line 2846
    argv ++;
#line 2846
    *((unsigned int *)*tmp___40) = precedence;
#line 2848
    tmp___41 = argv;
#line 2848
    argv ++;
#line 2848
    *tmp___41 = pstrdup(c->pool, (char const   *)*(cmd->argv + 3));
    }
#line 2850
    if (argc) {
#line 2850
      if (acl) {
        {
#line 2851
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2851
          tmp___43 = argc;
#line 2851
          argc --;
#line 2851
          if (! tmp___43) {
#line 2851
            goto while_break;
          }
          {
#line 2852
          tmp___42 = argv;
#line 2852
          argv ++;
#line 2852
          *tmp___42 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2853
          acl->elts = (void *)((char **)acl->elts + 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 2858
    *argv = (char *)((void *)0);
  }
  {
#line 2861
  c->flags |= (long )(1 << 1);
#line 2862
  tmp___44 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2862
  return (tmp___44);
}
}
#line 2866 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static modret_t *set_usesendfile(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2867
  bool = -1;
#line 2870
  if (cmd->argc - 1 < 1) {
    {
#line 2870
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2870
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2870
    return (tmp___0);
  }
  {
#line 2871
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2871
  if (! tmp___5) {
    {
#line 2871
    tmp___1 = get_context_name(cmd);
#line 2871
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2871
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2871
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2871
    return (tmp___4);
  }
  {
#line 2873
  bool = get_boolean(cmd, 1);
  }
#line 2874
  if (bool == -1) {
    {
#line 2875
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2875
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2875
    return (tmp___7);
  }
  {
#line 2877
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2878
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2879
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2881
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2881
  return (tmp___8);
}
}
#line 2887 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void xfer_sigusr2_ev(void const   *event_data , void *user_data ) 
{ 
  pool *p ;
  pool *tmp ;
  cmd_rec *cmd ;
  cmd_rec *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 2892
  tmp___1 = strcmp((char const   *)session.curr_cmd, "APPE");
  }
#line 2892
  if (tmp___1 == 0) {
#line 2892
    goto _L;
  } else {
    {
#line 2892
    tmp___2 = strcmp((char const   *)session.curr_cmd, "RETR");
    }
#line 2892
    if (tmp___2 == 0) {
#line 2892
      goto _L;
    } else {
      {
#line 2892
      tmp___3 = strcmp((char const   *)session.curr_cmd, "STOR");
      }
#line 2892
      if (tmp___3 == 0) {
#line 2892
        goto _L;
      } else {
        {
#line 2892
        tmp___4 = strcmp((char const   *)session.curr_cmd, "STOU");
        }
#line 2892
        if (tmp___4 == 0) {
          _L: /* CIL Label */ 
          {
#line 2896
          tmp = make_sub_pool(session.pool);
#line 2896
          p = tmp;
#line 2897
          tmp___0 = pr_cmd_alloc(p, 1, session.curr_cmd);
#line 2897
          cmd = tmp___0;
#line 2902
          pr_log_debug(2, "rechecking TransferRates");
#line 2903
          pr_throttle_init(cmd);
#line 2905
          destroy_pool(p);
          }
        }
      }
    }
  }
#line 2908
  return;
}
}
#line 2914 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void xfer_exit_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2916
  if (session.sf_flags & (int volatile   )4) {
#line 2917
    if (session.xfer.direction == 1) {
      {
#line 2919
      pr_trace_msg(trace_channel___0, 6, "session exiting, aborting upload");
#line 2920
      stor_abort();
      }
    } else {
      {
#line 2924
      pr_trace_msg(trace_channel___0, 6, "session exiting, aborting download");
#line 2925
      retr_abort();
      }
    }
  }
#line 2929
  return;
}
}
#line 2932 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static void xfer_xfer_stalled_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2933
  if (! (session.sf_flags & (int volatile   )4)) {
#line 2934
    if (session.xfer.direction == 1) {
      {
#line 2935
      pr_trace_msg(trace_channel___0, 6, "transfer stalled, aborting upload");
#line 2936
      stor_abort();
      }
    } else {
      {
#line 2939
      pr_trace_msg(trace_channel___0, 6, "transfer stalled, aborting download");
#line 2940
      retr_abort();
      }
    }
  }
#line 2951
  return;
}
}
#line 2957 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 2960
  pr_help_add("TYPE", "<sp> type-code (A, I, L 7, L 8)", 1);
#line 2961
  pr_help_add("STRU", "is not implemented (always F)", 1);
#line 2962
  pr_help_add("MODE", "is not implemented (always S)", 1);
#line 2963
  pr_help_add("RETR", "<sp> pathname", 1);
#line 2964
  pr_help_add("STOR", "<sp> pathname", 1);
#line 2965
  pr_help_add("STOU", "(store unique filename)", 1);
#line 2966
  pr_help_add("APPE", "<sp> pathname", 1);
#line 2967
  pr_help_add("REST", "<sp> byte-count", 1);
#line 2968
  pr_help_add("ABOR", "(abort current operation)", 1);
  }
#line 2970
  return (0);
}
}
#line 2973 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static int xfer_sess_init(void) 
{ 
  char *displayfilexfer ;
  config_rec *c ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 2974
  displayfilexfer = (char *)((void *)0);
#line 2975
  c = (config_rec *)((void *)0);
#line 2978
  c = find_config(main_server->conf, 1 << 15, "UseSendfile", 0);
  }
#line 2979
  if (c) {
#line 2980
    use_sendfile = *((unsigned char *)*(c->argv + 0));
  }
  {
#line 2984
  pr_event_register(& xfer_module, "core.exit", & xfer_exit_ev, (void *)0);
#line 2985
  pr_event_register(& xfer_module, "core.timeout-stalled", & xfer_xfer_stalled_ev,
                    (void *)0);
#line 2988
  pr_event_register(& xfer_module, "core.signal.USR2", & xfer_sigusr2_ev, (void *)0);
#line 2997
  tmp = get_param_ptr(main_server->conf, "DisplayFileTransfer", 0);
#line 2997
  displayfilexfer = (char *)tmp;
  }
#line 2999
  if (displayfilexfer) {
#line 2999
    if ((int )*displayfilexfer == 47) {
      {
#line 3002
      displayfilexfer_fh = pr_fsio_open((char const   *)displayfilexfer, 0);
      }
#line 3003
      if ((unsigned long )displayfilexfer_fh == (unsigned long )((void *)0)) {
        {
#line 3004
        tmp___0 = __errno_location();
#line 3004
        tmp___1 = strerror(*tmp___0);
#line 3004
        pr_log_debug(6, "unable to open DisplayFileTransfer file \'%s\': %s", displayfilexfer,
                     tmp___1);
        }
      }
    }
  }
#line 3008
  return (0);
}
}
#line 3014 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static conftable xfer_conftab[17]  = 
#line 3014
  {      {(char *)"AllowOverwrite", & set_allowoverwrite, (module *)((void *)0)}, 
        {(char *)"AllowRetrieveRestart", & set_allowrestart, (module *)((void *)0)}, 
        {(char *)"AllowStoreRestart", & set_allowrestart, (module *)((void *)0)}, 
        {(char *)"DeleteAbortedStores", & set_deleteabortedstores, (module *)((void *)0)}, 
        {(char *)"DisplayFileTransfer",
      & set_displayfiletransfer, (module *)((void *)0)}, 
        {(char *)"HiddenStores", & set_hiddenstores, (module *)((void *)0)}, 
        {(char *)"MaxRetrieveFileSize", & set_maxfilesize, (module *)((void *)0)}, 
        {(char *)"MaxStoreFileSize", & set_maxfilesize, (module *)((void *)0)}, 
        {(char *)"MaxTransfersPerHost", & set_maxtransfersperhost, (module *)((void *)0)}, 
        {(char *)"MaxTransfersPerUser",
      & set_maxtransfersperuser, (module *)((void *)0)}, 
        {(char *)"StoreUniquePrefix", & set_storeuniqueprefix, (module *)((void *)0)}, 
        {(char *)"TimeoutNoTransfer",
      & set_timeoutnoxfer, (module *)((void *)0)}, 
        {(char *)"TimeoutStalled", & set_timeoutstalled, (module *)((void *)0)}, 
        {(char *)"TransferPriority", & set_transferpriority, (module *)((void *)0)}, 
        {(char *)"TransferRate", & set_transferrate, (module *)((void *)0)}, 
        {(char *)"UseSendfile", & set_usesendfile, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))0, (module *)0}};
#line 3035 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
static cmdtable xfer_cmdtab[30]  = 
#line 3035
  {      {(unsigned char)2, (char *)"TYPE", (char *)((void *)0), & xfer_type, (unsigned char)0,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"STRU", (char *)((void *)0), & xfer_stru, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"MODE", (char *)((void *)0), & xfer_mode, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)3, (char *)"MODE", (char *)((void *)0), & xfer_post_mode, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"ALLO", (char *)((void *)0), & xfer_allo, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"SMNT", (char *)((void *)0), & xfer_smnt, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)1, (char *)"RETR", (char *)"READ", & xfer_pre_retr, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"RETR", (char *)"READ", & xfer_retr, (unsigned char)1,
      (unsigned char)0, 1 << 3, (module *)0}, 
        {(unsigned char)5, (char *)"RETR", (char *)((void *)0), & xfer_log_retr, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"RETR", (char *)((void *)0), & xfer_err_cleanup, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)1, (char *)"STOR", (char *)"WRITE", & xfer_pre_stor, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"STOR", (char *)"WRITE", & xfer_stor, (unsigned char)1,
      (unsigned char)0, 1 << 4, (module *)0}, 
        {(unsigned char)5, (char *)"STOR", (char *)((void *)0), & xfer_log_stor, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"STOR", (char *)((void *)0), & xfer_err_cleanup, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)1, (char *)"STOU", (char *)"WRITE", & xfer_pre_stou, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"STOU", (char *)"WRITE", & xfer_stor, (unsigned char)1,
      (unsigned char)0, 1 << 4, (module *)0}, 
        {(unsigned char)3, (char *)"STOU", (char *)"WRITE", & xfer_post_stou, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)5, (char *)"STOU", (char *)((void *)0), & xfer_log_stor, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"STOU", (char *)((void *)0), & xfer_err_cleanup, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)1, (char *)"APPE", (char *)"WRITE", & xfer_pre_appe, (unsigned char)1,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"APPE", (char *)"WRITE", & xfer_stor, (unsigned char)1,
      (unsigned char)0, 1 << 4, (module *)0}, 
        {(unsigned char)5, (char *)"APPE", (char *)((void *)0), & xfer_log_stor, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"APPE", (char *)((void *)0), & xfer_err_cleanup, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"ABOR", (char *)((void *)0), & xfer_abor, (unsigned char)1,
      (unsigned char)1, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"REST", (char *)((void *)0), & xfer_rest, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)3, (char *)"PROT", (char *)((void *)0), & xfer_post_prot, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)3, (char *)"RETR", (char *)((void *)0), & xfer_post_xfer, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)3, (char *)"STOR", (char *)((void *)0), & xfer_post_xfer, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & xfer_post_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 3068 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_xfer.c"
module xfer_module  = 
#line 3068
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"xfer", xfer_conftab,
    xfer_cmdtab, (authtable *)((void *)0), & xfer_init, & xfer_sess_init, (char *)0,
    (void *)0, 0};
#line 411 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 564 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 55 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits )  __asm__("getrlimit64")  ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 357 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 59 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
#line 49 "../include/netacl.h"
pr_netacl_t *pr_netacl_create(pool *p , char *aclstr ) ;
#line 66 "../include/class.h"
int pr_class_open(pool *p , char const   *name ) ;
#line 73
int pr_class_close(void) ;
#line 77
int pr_class_add_acl(pr_netacl_t *acl ) ;
#line 81
int pr_class_set_satisfy(int satisfy ) ;
#line 193 "../include/proftpd.h"
char AddressCollisionCheck ;
#line 194
char ServerType ;
#line 195
char MultilineRFC2228 ;
#line 70 "../include/support.h"
char *dir_canonical_vpath(pool *p , char const   *path ) ;
#line 84
int exists(char *path ) ;
#line 57 "../include/sets.h"
int xaset_remove(xaset_t *set , xasetmember_t *member ) ;
#line 171 "../include/dirtree.h"
int tcpBackLog ;
#line 172
int SocketBindTight ;
#line 174
int ServerMaxInstances ;
#line 175
int ServerUseReverseDNS ;
#line 216
int pr_define_add(char const   *definition ) ;
#line 217
unsigned char pr_define_exists(char const   *definition ) ;
#line 221
int parse_config_path(pool *p , char const   *path ) ;
#line 222
config_rec *add_config_set(xaset_t **set , char const   *name ) ;
#line 165 "../include/modules.h"
unsigned char pr_module_exists(char const   *name ) ;
#line 166
module *pr_module_get(char const   *name ) ;
#line 170
modret_t *pr_module_call(module *m , modret_t *(*func)(cmd_rec * ) , cmd_rec *cmd ) ;
#line 181
int pr_stash_add_symbol(pr_stash_type_t sym_type , void *data ) ;
#line 183
int pr_stash_remove_symbol(pr_stash_type_t sym_type , char const   *sym_name , module *sym_module ) ;
#line 115 "../include/auth.h"
int init_auth(void) ;
#line 132 "../include/inet.h"
void pr_cmd_set_handler(void (*handler)(server_rec * , conn_t * ) ) ;
#line 143
conn_t *pr_inet_create_connection_portrange(pool *p , xaset_t *servers , pr_netaddr_t *bind_addr ,
                                            int low_port , int high_port ) ;
#line 150
int pr_inet_set_block(pool *p , conn_t *c ) ;
#line 154
int pr_inet_listen(pool *p , conn_t *c , int backlog ) ;
#line 221 "../include/netaddr.h"
void pr_netaddr_clear(pr_netaddr_t *na ) ;
#line 233
pr_netaddr_t *pr_netaddr_get_addr(pool *p , char const   *name , array_header **addrs ) ;
#line 241
int pr_netaddr_cmp(pr_netaddr_t const   *na1 , pr_netaddr_t const   *na2 ) ;
#line 283
int pr_netaddr_get_family(pr_netaddr_t const   *na ) ;
#line 288
int pr_netaddr_set_family(pr_netaddr_t *na , int family ) ;
#line 294
void *pr_netaddr_get_inaddr(pr_netaddr_t const   *na ) ;
#line 300
struct sockaddr *pr_netaddr_get_sockaddr(pr_netaddr_t const   *na ) ;
#line 306
int pr_netaddr_set_sockaddr(pr_netaddr_t *na , struct sockaddr *addr ) ;
#line 314
unsigned int pr_netaddr_get_port(pr_netaddr_t const   *na ) ;
#line 319
int pr_netaddr_set_port(pr_netaddr_t *na , unsigned int port ) ;
#line 340
char const   *pr_netaddr_get_localaddr_str(pool *p ) ;
#line 353
int pr_netaddr_is_v4mappedv6(pr_netaddr_t const   *na ) ;
#line 356
unsigned char pr_netaddr_use_ipv6(void) ;
#line 359
void pr_netaddr_disable_ipv6(void) ;
#line 362
void pr_netaddr_enable_ipv6(void) ;
#line 33 "../include/help.h"
int pr_help_add_response(cmd_rec *cmd , char const   *target ) ;
#line 126 "../include/log.h"
void log_setfacility(int f ) ;
#line 149
int pr_log_setdebuglevel(int level ) ;
#line 50 "../include/parser.h"
config_rec *pr_parser_config_ctxt_close(int *empty ) ;
#line 61
config_rec *pr_parser_config_ctxt_open(char const   *name ) ;
#line 65
unsigned int pr_parser_get_lineno(void) ;
#line 105
char *pr_parser_read_line(char *buf___2 , size_t bufsz ) ;
#line 112
server_rec *pr_parser_server_ctxt_close(void) ;
#line 124
server_rec *pr_parser_server_ctxt_open(char const   *addrstr ) ;
#line 116 "../include/scoreboard.h"
int pr_set_scoreboard(char const   *path ) ;
#line 126
int pr_scoreboard_scrub(void) ;
#line 41 "../include/data.h"
void pr_data_set_linger(long linger ) ;
#line 245 "../include/fsio.h"
int pr_fsio_mkdir(char const   *path , mode_t mode ) ;
#line 246
int pr_fsio_rmdir(char const   *path ) ;
#line 305
int pr_fs_copy_file(char const   *src , char const   *dst ) ;
#line 98 "../include/var.h"
int pr_var_set(pool *p , char const   *name , char const   *desc , int type , void *val ,
               void *data , size_t datasz ) ;
#line 34 "../include/trace.h"
int pr_trace_set_file(char const   *path ) ;
#line 35
int pr_trace_set_level(char const   *channel , int level ) ;
#line 50 "../include/env.h"
int pr_env_unset(pool *p , char const   *key ) ;
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
unsigned long max_connects ;
#line 46
unsigned int max_connect_interval ;
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
char AddressCollisionCheck  =    (char)1;
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static int core_scrub_timer_id  ;
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static pr_fh_t *displayquit_fh  =    (pr_fh_t *)((void *)0);
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static char const   *trace_log  =    (char const   *)((void *)0);
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static ssize_t get_num_bytes(char *nbytes_str ) 
{ 
  ssize_t nbytes ;
  unsigned long inb ;
  char units___0 ;
  char junk ;
  int result ;
  char *__cil_tmp7 ;

  {
  {
#line 66
  nbytes = 0;
#line 78
  result = sscanf((char const   */* __restrict  */)nbytes_str, (char const   */* __restrict  */)"%lu%c%c",
                  & inb, & units___0, & junk);
  }
#line 78
  if (result == 2) {
#line 80
    if ((int )units___0 != 71) {
#line 80
      if ((int )units___0 != 103) {
#line 80
        if ((int )units___0 != 77) {
#line 80
          if ((int )units___0 != 109) {
#line 80
            if ((int )units___0 != 75) {
#line 80
              if ((int )units___0 != 107) {
#line 80
                if ((int )units___0 != 66) {
#line 80
                  if ((int )units___0 != 98) {
#line 84
                    return (-1);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 86
    nbytes = (ssize_t )inb;
#line 91
    if ((int )units___0 == 71) {
#line 92
      nbytes *= 1073741824;
    } else
#line 91
    if ((int )units___0 == 103) {
#line 92
      nbytes *= 1073741824;
    }
#line 94
    if ((int )units___0 == 77) {
#line 95
      nbytes *= 1048576;
    } else
#line 94
    if ((int )units___0 == 109) {
#line 95
      nbytes *= 1048576;
    }
#line 97
    if ((int )units___0 == 75) {
#line 98
      nbytes *= 1024;
    } else
#line 97
    if ((int )units___0 == 107) {
#line 98
      nbytes *= 1024;
    }
#line 108
    return (nbytes);
  } else
#line 110
  if (result == 1) {
#line 113
    return ((ssize_t )inb);
  }
#line 118
  return (-2);
}
}
#line 121 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static int core_idle_timeout_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                                void *data ) 
{ 
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 123
  if (session.sf_flags & (int volatile   )4) {
#line 126
    return (1);
  }
  {
#line 129
  pr_event_generate("core.timeout-idle", (void const   *)((void *)0));
#line 131
  tmp = pr_data_get_timeout(1);
#line 131
  pr_response_send_async("421", "Idle timeout (%d seconds): closing control connection",
                         tmp);
#line 134
  session_exit(6, (void *)"Client session idle timeout, disconnected", 0, (void *)0);
#line 137
  pr_timer_remove(1, (module *)4294967295U);
#line 138
  pr_timer_remove(3, (module *)4294967295U);
  }
#line 139
  return (0);
}
}
#line 142 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static int core_scrub_scoreboard_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                                    void *data ) 
{ 


  {
  {
#line 147
  pr_scoreboard_scrub();
  }
#line 149
  return (1);
}
}
#line 152 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *start_ifdefine(cmd_rec *cmd ) 
{ 
  unsigned int ifdefine_ctx_count ;
  unsigned char not_define ;
  unsigned char defined ;
  char buf___2[1024] ;
  unsigned int tmp ;
  char *config_line ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  unsigned int tmp___2 ;
  char const   *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  modret_t *tmp___11 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 153
  ifdefine_ctx_count = 1U;
#line 154
  not_define = (unsigned char)0;
#line 154
  defined = (unsigned char)0;
#line 155
  buf___2[0] = (char )'\000';
#line 155
  tmp = 1U;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (tmp >= 1024U) {
#line 155
      goto while_break;
    }
#line 155
    buf___2[tmp] = (char)0;
#line 155
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  config_line = (char *)((void *)0);
#line 157
  if (cmd->argc - 1 < 1) {
    {
#line 157
    tmp___0 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments",
                      (void *)0);
#line 157
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___0);
    }
#line 157
    return (tmp___1);
  }
#line 159
  if ((int )*(*(cmd->argv + 1)) == 33) {
#line 160
    not_define = (unsigned char)1;
#line 161
    (*(cmd->argv + 1)) ++;
  }
  {
#line 164
  defined = pr_define_exists((char const   *)*(cmd->argv + 1));
  }
#line 169
  if (! not_define) {
#line 169
    if (defined) {
#line 169
      goto _L;
    } else {
#line 169
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 169
  if (not_define) {
#line 169
    if (! defined) {
      _L: /* CIL Label */ 
      {
#line 170
      tmp___2 = pr_parser_get_lineno();
      }
#line 170
      if (not_define) {
#line 170
        tmp___3 = "!";
      } else {
#line 170
        tmp___3 = "";
      }
      {
#line 170
      pr_log_debug(3, "%s: using \'%s%s\' section at line %u", *(cmd->argv + 0), tmp___3,
                   *(cmd->argv + 1), tmp___2);
#line 172
      tmp___4 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
      }
#line 172
      return (tmp___4);
    } else {
#line 169
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 175
    tmp___5 = pr_parser_get_lineno();
    }
#line 175
    if (not_define) {
#line 175
      tmp___6 = "!";
    } else {
#line 175
      tmp___6 = "";
    }
    {
#line 175
    pr_log_debug(3, "%s: skipping \'%s%s\' section at line %u", *(cmd->argv + 0),
                 tmp___6, *(cmd->argv + 1), tmp___5);
    }
  }
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 184
    if (ifdefine_ctx_count) {
      {
#line 184
      config_line = pr_parser_read_line(buf___2, (size_t )sizeof(buf___2));
      }
#line 184
      if (! ((unsigned long )config_line != (unsigned long )((void *)0))) {
#line 184
        goto while_break___0;
      }
    } else {
#line 184
      goto while_break___0;
    }
    {
#line 187
    tmp___7 = strncasecmp((char const   *)config_line, "<IfDefine", (size_t )9);
    }
#line 187
    if (tmp___7 == 0) {
#line 188
      ifdefine_ctx_count ++;
    }
    {
#line 190
    tmp___8 = strcasecmp((char const   *)config_line, "</IfDefine>");
    }
#line 190
    if (tmp___8 == 0) {
#line 191
      ifdefine_ctx_count --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 196
  if (ifdefine_ctx_count) {
    {
#line 197
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unclosed <IfDefine> context",
                      (void *)0);
#line 197
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 197
    return (tmp___10);
  }
  {
#line 199
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 199
  return (tmp___11);
}
}
#line 206 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_ifdefine(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;

  {
  {
#line 207
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *start_ifmodule(cmd_rec *cmd ) 
{ 
  unsigned int ifmodule_ctx_count ;
  unsigned char not_module ;
  unsigned char found_module ;
  char buf___2[1024] ;
  unsigned int tmp ;
  char *config_line ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  unsigned int tmp___2 ;
  char const   *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  char *bufp ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  modret_t *tmp___12 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 211
  ifmodule_ctx_count = 1U;
#line 212
  not_module = (unsigned char)0;
#line 212
  found_module = (unsigned char)0;
#line 213
  buf___2[0] = (char )'\000';
#line 213
  tmp = 1U;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (tmp >= 1024U) {
#line 213
      goto while_break;
    }
#line 213
    buf___2[tmp] = (char)0;
#line 213
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  config_line = (char *)((void *)0);
#line 215
  if (cmd->argc - 1 < 1) {
    {
#line 215
    tmp___0 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments",
                      (void *)0);
#line 215
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___0);
    }
#line 215
    return (tmp___1);
  }
#line 217
  if ((int )*(*(cmd->argv + 1)) == 33) {
#line 218
    not_module = (unsigned char)1;
#line 219
    (*(cmd->argv + 1)) ++;
  }
  {
#line 222
  found_module = pr_module_exists((char const   *)*(cmd->argv + 1));
  }
#line 227
  if (! not_module) {
#line 227
    if (found_module) {
#line 227
      goto _L;
    } else {
#line 227
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 227
  if (not_module) {
#line 227
    if (! found_module) {
      _L: /* CIL Label */ 
      {
#line 228
      tmp___2 = pr_parser_get_lineno();
      }
#line 228
      if (not_module) {
#line 228
        tmp___3 = "!";
      } else {
#line 228
        tmp___3 = "";
      }
      {
#line 228
      pr_log_debug(3, "%s: using \'%s%s\' section at line %u", *(cmd->argv + 0), tmp___3,
                   *(cmd->argv + 1), tmp___2);
#line 230
      tmp___4 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
      }
#line 230
      return (tmp___4);
    } else {
#line 227
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 233
    tmp___5 = pr_parser_get_lineno();
    }
#line 233
    if (not_module) {
#line 233
      tmp___6 = "!";
    } else {
#line 233
      tmp___6 = "";
    }
    {
#line 233
    pr_log_debug(3, "%s: skipping \'%s%s\' section at line %u", *(cmd->argv + 0),
                 tmp___6, *(cmd->argv + 1), tmp___5);
    }
  }
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (ifmodule_ctx_count) {
      {
#line 242
      config_line = pr_parser_read_line(buf___2, (size_t )sizeof(buf___2));
      }
#line 242
      if (! ((unsigned long )config_line != (unsigned long )((void *)0))) {
#line 242
        goto while_break___0;
      }
    } else {
#line 242
      goto while_break___0;
    }
#line 247
    bufp = config_line;
    {
#line 247
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 247
      if (*bufp) {
        {
#line 247
        tmp___7 = __ctype_b_loc();
        }
#line 247
        if (! ((int const   )*(*tmp___7 + (int )*bufp) & 8192)) {
#line 247
          goto while_break___1;
        }
      } else {
#line 247
        goto while_break___1;
      }
#line 247
      bufp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 249
    tmp___8 = strncasecmp((char const   *)bufp, "<IfModule", (size_t )9);
    }
#line 249
    if (tmp___8 == 0) {
#line 250
      ifmodule_ctx_count ++;
    }
    {
#line 252
    tmp___9 = strcasecmp((char const   *)bufp, "</IfModule>");
    }
#line 252
    if (tmp___9 == 0) {
#line 253
      ifmodule_ctx_count --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 258
  if (ifmodule_ctx_count) {
    {
#line 259
    tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unclosed <IfModule> context",
                       (void *)0);
#line 259
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
    }
#line 259
    return (tmp___11);
  }
  {
#line 261
  tmp___12 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 261
  return (tmp___12);
}
}
#line 268 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_ifmodule(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;

  {
  {
#line 269
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 269
  return (tmp);
}
}
#line 281 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_define(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 284
  if (cmd->argc - 1 < 1) {
    {
#line 284
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 284
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 284
    return (tmp___0);
  }
  {
#line 290
  pr_define_add((char const   *)*(cmd->argv + 1));
#line 291
  tmp___1 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 291
  return (tmp___1);
}
}
#line 294 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_include(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  modret_t *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  modret_t *tmp___19 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 295
  if (cmd->argc - 1 < 1) {
    {
#line 295
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 295
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 295
    return (tmp___0);
  }
  {
#line 296
  tmp___5 = check_context(cmd, (((1 | (1 << 4)) | (1 << 2)) | (1 << 6)) | (1 << 1));
  }
#line 296
  if (! tmp___5) {
    {
#line 296
    tmp___1 = get_context_name(cmd);
#line 296
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 296
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 296
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 296
    return (tmp___4);
  }
  {
#line 299
  tmp___9 = pr_fs_valid_path((char const   *)*(cmd->argv + 1));
  }
#line 299
  if (tmp___9 < 0) {
    {
#line 300
    tmp___6 = pstrcat(cmd->tmp_pool, "unable to use path for configuration file \'",
                      *(cmd->argv + 1), "\'", (void *)0);
#line 300
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 300
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 300
    return (tmp___8);
  }
  {
#line 304
  tmp___18 = parse_config_path(cmd->tmp_pool, (char const   *)*(cmd->argv + 1));
  }
#line 304
  if (tmp___18 == -1) {
    {
#line 305
    tmp___17 = __errno_location();
    }
#line 305
    if (*tmp___17 != 22) {
      {
#line 306
      tmp___10 = __errno_location();
#line 306
      tmp___11 = strerror(*tmp___10);
#line 306
      pr_log_pri(4, "warning: unable to include \'%s\': %s", *(cmd->argv + 1), tmp___11);
      }
    } else {
      {
#line 310
      tmp___12 = __errno_location();
#line 310
      tmp___13 = strerror(*tmp___12);
#line 310
      tmp___14 = pstrcat(cmd->tmp_pool, "error including \'", *(cmd->argv + 1), "\': ",
                         tmp___13, (void *)0);
#line 310
      tmp___15 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___14, (void *)0);
#line 310
      tmp___16 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___15);
      }
#line 310
      return (tmp___16);
    }
  }
  {
#line 315
  tmp___19 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 315
  return (tmp___19);
}
}
#line 318 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_debuglevel(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int debuglevel ;
  char *endp ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  modret_t *tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 319
  c = (config_rec *)((void *)0);
#line 320
  debuglevel = -1;
#line 321
  endp = (char *)((void *)0);
#line 323
  if (cmd->argc - 1 < 1) {
    {
#line 323
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 323
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 323
    return (tmp___0);
  }
  {
#line 324
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 324
  if (! tmp___5) {
    {
#line 324
    tmp___1 = get_context_name(cmd);
#line 324
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 324
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 324
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 324
    return (tmp___4);
  }
  {
#line 327
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   10);
#line 327
  debuglevel = (int )tmp___6;
  }
#line 329
  if (endp) {
#line 329
    if (*endp) {
      {
#line 330
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "not a valid number",
                        (void *)0);
#line 330
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 330
      return (tmp___8);
    }
  }
#line 333
  if (debuglevel < 0) {
    {
#line 334
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "invalid debug level configured",
                      (void *)0);
#line 334
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 334
    return (tmp___10);
  } else
#line 333
  if (debuglevel > 10) {
    {
#line 334
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "invalid debug level configured",
                      (void *)0);
#line 334
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 334
    return (tmp___10);
  }
  {
#line 336
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 337
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 338
  *((unsigned int *)*(c->argv + 0)) = (unsigned int )debuglevel;
#line 340
  tmp___11 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 340
  return (tmp___11);
}
}
#line 343 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_defaultaddress(cmd_rec *cmd ) 
{ 
  pr_netaddr_t *main_addr ;
  array_header *addrs ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  register unsigned int i___0 ;
  pr_netaddr_t **elts ;
  char const   *ipstr ;
  char const   *tmp___8 ;
  char *ipbuf ;
  void *tmp___9 ;
  int tmp___10 ;
  unsigned char tmp___11 ;
  register unsigned int i___1 ;
  char *addrs_str ;
  char const   *tmp___12 ;
  pr_netaddr_t *addr ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  modret_t *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  register unsigned int j ;
  pr_netaddr_t **elts___0 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  modret_t *tmp___22 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 344
  main_addr = (pr_netaddr_t *)((void *)0);
#line 345
  addrs = (array_header *)((void *)0);
#line 347
  if (cmd->argc - 1 < 1) {
    {
#line 348
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 348
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 348
    return (tmp___0);
  }
  {
#line 349
  tmp___5 = check_context(cmd, 1);
  }
#line 349
  if (! tmp___5) {
    {
#line 349
    tmp___1 = get_context_name(cmd);
#line 349
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 349
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 349
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 349
    return (tmp___4);
  }
  {
#line 351
  main_addr = pr_netaddr_get_addr(main_server->pool, (char const   *)*(cmd->argv + 1),
                                  & addrs);
  }
#line 352
  if ((unsigned long )main_addr == (unsigned long )((void *)0)) {
    {
#line 353
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": unable to resolve \"", *(cmd->argv + 1),
                      "\"", (void *)0);
#line 353
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 353
    return (tmp___7);
  }
  {
#line 357
  main_server->ServerAddress = pr_netaddr_get_ipstr(main_addr);
#line 358
  main_server->addr = main_addr;
  }
#line 360
  if (addrs) {
#line 362
    elts = (pr_netaddr_t **)addrs->elts;
#line 365
    i___0 = 0U;
    {
#line 365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 365
      if (! (i___0 < (unsigned int )addrs->nelts)) {
#line 365
        goto while_break;
      }
      {
#line 366
      tmp___8 = pr_netaddr_get_ipstr(*(elts + i___0));
#line 366
      ipstr = tmp___8;
#line 369
      tmp___11 = pr_netaddr_use_ipv6();
      }
#line 369
      if (tmp___11) {
        {
#line 370
        tmp___9 = pcalloc(cmd->tmp_pool, 46);
#line 370
        ipbuf = (char *)tmp___9;
#line 371
        tmp___10 = pr_netaddr_get_family((pr_netaddr_t const   *)*(elts + i___0));
        }
#line 371
        if (tmp___10 == 2) {
          {
#line 376
          snprintf((char */* __restrict  */)ipbuf, (size_t )sizeof(ipbuf), (char const   */* __restrict  */)"::ffff:%s",
                   ipstr);
#line 377
          ipstr = (char const   *)ipbuf;
          }
        }
      }
      {
#line 382
      add_config_param_str("_bind", 1, ipstr);
#line 365
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 390
  if (cmd->argc - 1 > 1) {
    {
#line 392
    tmp___12 = pr_netaddr_get_ipstr(main_addr);
#line 392
    addrs_str = (char *)tmp___12;
#line 394
    i___1 = 2U;
    }
    {
#line 394
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 394
      if (! (i___1 < (unsigned int )cmd->argc)) {
#line 394
        goto while_break___0;
      }
      {
#line 396
      addrs = (array_header *)((void *)0);
#line 398
      addr = pr_netaddr_get_addr(cmd->tmp_pool, (char const   *)*(cmd->argv + i___1),
                                 & addrs);
      }
#line 400
      if ((unsigned long )addr == (unsigned long )((void *)0)) {
        {
#line 401
        tmp___13 = __errno_location();
#line 401
        tmp___14 = strerror(*tmp___13);
#line 401
        tmp___15 = pstrcat(cmd->tmp_pool, "error resolving \'", *(cmd->argv + i___1),
                           "\': ", tmp___14, (void *)0);
#line 401
        tmp___16 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___15, (void *)0);
#line 401
        tmp___17 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___16);
        }
#line 401
        return (tmp___17);
      }
      {
#line 404
      tmp___18 = pr_netaddr_get_ipstr(addr);
#line 404
      add_config_param_str("_bind", 1, tmp___18);
#line 406
      tmp___19 = pr_netaddr_get_ipstr(addr);
#line 406
      addrs_str = pstrcat(cmd->tmp_pool, addrs_str, ", ", tmp___19, (void *)0);
      }
#line 409
      if (addrs) {
#line 411
        elts___0 = (pr_netaddr_t **)addrs->elts;
#line 414
        j = 0U;
        {
#line 414
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 414
          if (! (j < (unsigned int )addrs->nelts)) {
#line 414
            goto while_break___1;
          }
          {
#line 415
          tmp___20 = pr_netaddr_get_ipstr(*(elts___0 + j));
#line 415
          add_config_param_str("_bind", 1, tmp___20);
#line 414
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 394
      i___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 419
    pr_log_pri(6, "setting default addresses to %s", addrs_str);
    }
  } else {
    {
#line 422
    tmp___21 = pr_netaddr_get_ipstr(main_addr);
#line 422
    pr_log_pri(6, "setting default address to %s", tmp___21);
    }
  }
  {
#line 426
  tmp___22 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 426
  return (tmp___22);
}
}
#line 429 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_servername(cmd_rec *cmd ) 
{ 
  server_rec *s ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 430
  s = cmd->server;
#line 432
  if (cmd->argc - 1 < 1) {
    {
#line 432
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 432
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 432
    return (tmp___0);
  }
  {
#line 433
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 433
  if (! tmp___5) {
    {
#line 433
    tmp___1 = get_context_name(cmd);
#line 433
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 433
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 433
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 433
    return (tmp___4);
  }
  {
#line 435
  tmp___6 = pstrdup(s->pool, (char const   *)*(cmd->argv + 1));
#line 435
  s->ServerName = (char const   *)tmp___6;
#line 436
  tmp___7 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 436
  return (tmp___7);
}
}
#line 439 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_servertype(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 440
  if (cmd->argc - 1 < 1) {
    {
#line 440
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 440
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 440
    return (tmp___0);
  }
  {
#line 441
  tmp___5 = check_context(cmd, 1);
  }
#line 441
  if (! tmp___5) {
    {
#line 441
    tmp___1 = get_context_name(cmd);
#line 441
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 441
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 441
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 441
    return (tmp___4);
  }
  {
#line 443
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "inetd");
  }
#line 443
  if (tmp___9 == 0) {
#line 444
    ServerType = (char)0;
  } else {
    {
#line 446
    tmp___8 = strcasecmp((char const   *)*(cmd->argv + 1), "standalone");
    }
#line 446
    if (tmp___8 == 0) {
#line 447
      ServerType = (char)1;
    } else {
      {
#line 450
      tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "type must be either \'inetd\' or \'standalone\'",
                        (void *)0);
#line 450
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
      }
#line 450
      return (tmp___7);
    }
  }
  {
#line 452
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 452
  return (tmp___10);
}
}
#line 455 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_setenv(cmd_rec *cmd ) 
{ 
  int ctxt_type ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 458
  if (cmd->argc - 1 < 2) {
    {
#line 458
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 458
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 458
    return (tmp___0);
  }
  {
#line 459
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 459
  if (! tmp___5) {
    {
#line 459
    tmp___1 = get_context_name(cmd);
#line 459
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 459
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 459
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 459
    return (tmp___4);
  }
  {
#line 461
  add_config_param_str((char const   *)*(cmd->argv + 0), 2, *(cmd->argv + 1), *(cmd->argv + 2));
  }
#line 468
  if (cmd->config) {
#line 468
    if ((cmd->config)->config_type != 1 << 15) {
#line 468
      ctxt_type = (cmd->config)->config_type;
    } else {
#line 468
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 468
    if ((cmd->server)->config_type) {
#line 468
      tmp___6 = (cmd->server)->config_type;
    } else {
#line 468
      tmp___6 = 1;
    }
#line 468
    ctxt_type = tmp___6;
  }
#line 472
  if (ctxt_type == 1) {
    {
#line 473
    tmp___9 = pr_env_set((cmd->server)->pool, (char const   *)*(cmd->argv + 1), (char const   *)*(cmd->argv + 2));
    }
#line 473
    if (tmp___9 < 0) {
      {
#line 474
      tmp___7 = __errno_location();
#line 474
      tmp___8 = strerror(*tmp___7);
#line 474
      pr_log_debug(1, "%s: unable to set environ variable \'%s\': %s", *(cmd->argv + 0),
                   *(cmd->argv + 1), tmp___8);
      }
    }
  }
  {
#line 479
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 479
  return (tmp___10);
}
}
#line 482 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_transferlog(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 483
  c = (config_rec *)((void *)0);
#line 485
  if (cmd->argc - 1 < 1) {
    {
#line 485
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 485
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 485
    return (tmp___0);
  }
  {
#line 486
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 486
  if (! tmp___5) {
    {
#line 486
    tmp___1 = get_context_name(cmd);
#line 486
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 486
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 486
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 486
    return (tmp___4);
  }
  {
#line 488
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 489
  c->flags |= 1L;
#line 491
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 491
  return (tmp___6);
}
}
#line 494 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_wtmplog(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 495
  bool = -1;
#line 496
  c = (config_rec *)((void *)0);
#line 498
  if (cmd->argc - 1 < 1) {
    {
#line 498
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 498
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 498
    return (tmp___0);
  }
  {
#line 499
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 499
  if (! tmp___5) {
    {
#line 499
    tmp___1 = get_context_name(cmd);
#line 499
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 499
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 499
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 499
    return (tmp___4);
  }
  {
#line 501
  tmp___6 = strcasecmp((char const   *)*(cmd->argv + 1), "NONE");
  }
#line 501
  if (tmp___6 == 0) {
#line 502
    bool = 0;
  } else {
    {
#line 504
    bool = get_boolean(cmd, 1);
    }
  }
#line 506
  if (bool != -1) {
    {
#line 507
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 508
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 509
    *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 510
    c->flags |= 1L;
    }
  } else {
    {
#line 513
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected boolean argument, or \"NONE\"",
                      (void *)0);
#line 513
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 513
    return (tmp___8);
  }
  {
#line 515
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 515
  return (tmp___9);
}
}
#line 518 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_serveradmin(cmd_rec *cmd ) 
{ 
  server_rec *s ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 519
  s = cmd->server;
#line 521
  if (cmd->argc - 1 < 1) {
    {
#line 521
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 521
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 521
    return (tmp___0);
  }
  {
#line 522
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 522
  if (! tmp___5) {
    {
#line 522
    tmp___1 = get_context_name(cmd);
#line 522
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 522
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 522
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 522
    return (tmp___4);
  }
  {
#line 524
  s->ServerAdmin = pstrdup(s->pool, (char const   *)*(cmd->argv + 1));
#line 525
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 525
  return (tmp___6);
}
}
#line 529 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_useipv6(cmd_rec *cmd ) 
{ 
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 531
  bool = -1;
#line 533
  if (cmd->argc - 1 < 1) {
    {
#line 533
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 533
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 533
    return (tmp___0);
  }
  {
#line 534
  tmp___5 = check_context(cmd, 1);
  }
#line 534
  if (! tmp___5) {
    {
#line 534
    tmp___1 = get_context_name(cmd);
#line 534
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 534
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 534
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 534
    return (tmp___4);
  }
  {
#line 536
  bool = get_boolean(cmd, 1);
  }
#line 537
  if (bool == -1) {
    {
#line 538
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 538
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 538
    return (tmp___7);
  }
#line 540
  if (bool == 0) {
    {
#line 541
    pr_log_debug(2, "disabling runtime support for IPv6 connections");
#line 542
    pr_netaddr_disable_ipv6();
    }
  } else {
    {
#line 545
    pr_netaddr_enable_ipv6();
    }
  }
  {
#line 548
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 548
  return (tmp___8);
}
}
#line 555 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_usereversedns(cmd_rec *cmd ) 
{ 
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 556
  bool = -1;
#line 558
  if (cmd->argc - 1 < 1) {
    {
#line 558
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 558
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 558
    return (tmp___0);
  }
  {
#line 559
  tmp___5 = check_context(cmd, 1);
  }
#line 559
  if (! tmp___5) {
    {
#line 559
    tmp___1 = get_context_name(cmd);
#line 559
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 559
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 559
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 559
    return (tmp___4);
  }
  {
#line 561
  bool = get_boolean(cmd, 1);
  }
#line 562
  if (bool == -1) {
    {
#line 563
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 563
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 563
    return (tmp___7);
  }
  {
#line 565
  ServerUseReverseDNS = bool;
#line 567
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 567
  return (tmp___8);
}
}
#line 570 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_satisfy(cmd_rec *cmd ) 
{ 
  int satisfy ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  int tmp___16 ;
  modret_t *tmp___17 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 571
  satisfy = -1;
#line 573
  if (cmd->argc - 1 < 1) {
    {
#line 573
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 573
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 573
    return (tmp___0);
  }
  {
#line 574
  tmp___5 = check_context(cmd, 1 << 7);
  }
#line 574
  if (! tmp___5) {
    {
#line 574
    tmp___1 = get_context_name(cmd);
#line 574
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 574
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 574
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 574
    return (tmp___4);
  }
  {
#line 576
  tmp___10 = strcasecmp((char const   *)*(cmd->argv + 1), "any");
  }
#line 576
  if (tmp___10 == 0) {
#line 577
    satisfy = 0;
  } else {
    {
#line 579
    tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "all");
    }
#line 579
    if (tmp___9 == 0) {
#line 580
      satisfy = 1;
    } else {
      {
#line 583
      tmp___6 = pstrcat(cmd->tmp_pool, "invalid parameter: \'", *(cmd->argv + 1),
                        "\'", (void *)0);
#line 583
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 583
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 583
      return (tmp___8);
    }
  }
  {
#line 586
  tmp___16 = pr_class_set_satisfy(satisfy);
  }
#line 586
  if (tmp___16 < 0) {
    {
#line 587
    tmp___11 = __errno_location();
#line 587
    tmp___12 = strerror(*tmp___11);
#line 587
    tmp___13 = pstrcat(cmd->tmp_pool, "error setting Satisfy: ", tmp___12, (void *)0);
#line 587
    tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___13, (void *)0);
#line 587
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___14);
    }
#line 587
    return (tmp___15);
  }
  {
#line 590
  tmp___17 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 590
  return (tmp___17);
}
}
#line 593 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_scoreboardfile(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  int tmp___11 ;
  modret_t *tmp___12 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 594
  if (cmd->argc - 1 < 1) {
    {
#line 594
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 594
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 594
    return (tmp___0);
  }
  {
#line 595
  tmp___5 = check_context(cmd, 1);
  }
#line 595
  if (! tmp___5) {
    {
#line 595
    tmp___1 = get_context_name(cmd);
#line 595
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 595
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 595
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 595
    return (tmp___4);
  }
  {
#line 597
  tmp___11 = pr_set_scoreboard((char const   *)*(cmd->argv + 1));
  }
#line 597
  if (tmp___11 < 0) {
    {
#line 598
    tmp___6 = __errno_location();
#line 598
    tmp___7 = strerror(*tmp___6);
#line 598
    tmp___8 = pstrcat(cmd->tmp_pool, ": unable to use \'", *(cmd->argv + 1), "\': ",
                      tmp___7, (void *)0);
#line 598
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___8, (void *)0);
#line 598
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 598
    return (tmp___10);
  }
  {
#line 601
  tmp___12 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 601
  return (tmp___12);
}
}
#line 604 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_serverport(cmd_rec *cmd ) 
{ 
  server_rec *s ;
  int port ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 605
  s = cmd->server;
#line 608
  if (cmd->argc - 1 < 1) {
    {
#line 608
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 608
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 608
    return (tmp___0);
  }
  {
#line 609
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 609
  if (! tmp___5) {
    {
#line 609
    tmp___1 = get_context_name(cmd);
#line 609
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 609
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 609
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 609
    return (tmp___4);
  }
  {
#line 611
  port = atoi((char const   *)*(cmd->argv + 1));
  }
#line 612
  if (port < 0) {
    {
#line 613
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "value must be between 0 and 65535",
                      (void *)0);
#line 613
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 613
    return (tmp___7);
  } else
#line 612
  if (port > 65535) {
    {
#line 613
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "value must be between 0 and 65535",
                      (void *)0);
#line 613
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 613
    return (tmp___7);
  }
  {
#line 615
  s->ServerPort = (unsigned int )port;
#line 616
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 616
  return (tmp___8);
}
}
#line 619 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_pidfile(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 620
  if (cmd->argc - 1 < 1) {
    {
#line 620
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 620
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 620
    return (tmp___0);
  }
  {
#line 621
  tmp___5 = check_context(cmd, 1);
  }
#line 621
  if (! tmp___5) {
    {
#line 621
    tmp___1 = get_context_name(cmd);
#line 621
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 621
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 621
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 621
    return (tmp___4);
  }
  {
#line 623
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 624
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 624
  return (tmp___6);
}
}
#line 627 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_sysloglevel(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int level ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 628
  c = (config_rec *)((void *)0);
#line 629
  level = 0;
#line 631
  if (cmd->argc - 1 < 1) {
    {
#line 631
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 631
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 631
    return (tmp___0);
  }
  {
#line 632
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 632
  if (! tmp___5) {
    {
#line 632
    tmp___1 = get_context_name(cmd);
#line 632
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 632
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 632
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 632
    return (tmp___4);
  }
  {
#line 634
  level = pr_log_str2sysloglevel((char const   *)*(cmd->argv + 1));
  }
#line 635
  if (level < 0) {
    {
#line 636
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "SyslogLevel requires level keyword: one of emerg/alert/crit/error/warn/notice/info/debug",
                      (void *)0);
#line 636
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 636
    return (tmp___7);
  }
  {
#line 639
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 640
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 641
  *((unsigned int *)*(c->argv + 0)) = (unsigned int )level;
#line 643
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 643
  return (tmp___8);
}
}
#line 646 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_serverident(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 647
  bool = -1;
#line 648
  c = (config_rec *)((void *)0);
#line 650
  if (cmd->argc < 2) {
    {
#line 651
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 651
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 651
    return (tmp___0);
  } else
#line 650
  if (cmd->argc > 3) {
    {
#line 651
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 651
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 651
    return (tmp___0);
  }
  {
#line 653
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 653
  if (! tmp___5) {
    {
#line 653
    tmp___1 = get_context_name(cmd);
#line 653
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 653
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 653
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 653
    return (tmp___4);
  }
  {
#line 655
  bool = get_boolean(cmd, 1);
  }
#line 656
  if (bool == -1) {
    {
#line 657
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 657
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 657
    return (tmp___7);
  }
#line 659
  if (bool) {
#line 659
    if (cmd->argc == 3) {
      {
#line 660
      c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 661
      *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 662
      *((unsigned char *)*(c->argv + 0)) = (unsigned char )(! bool);
#line 663
      tmp___8 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
#line 663
      *(c->argv + 1) = (void *)tmp___8;
      }
    } else {
      {
#line 667
      c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 668
      *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 669
      *((unsigned char *)*(c->argv + 0)) = (unsigned char )(! bool);
      }
    }
  } else {
    {
#line 667
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 668
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 669
    *((unsigned char *)*(c->argv + 0)) = (unsigned char )(! bool);
    }
  }
  {
#line 672
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 672
  return (tmp___9);
}
}
#line 675 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_defaultserver(cmd_rec *cmd ) 
{ 
  int bool ;
  server_rec *s ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  config_rec *tmp___11 ;
  modret_t *tmp___12 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 676
  bool = -1;
#line 677
  s = (server_rec *)((void *)0);
#line 678
  c = (config_rec *)((void *)0);
#line 680
  if (cmd->argc - 1 < 1) {
    {
#line 680
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 680
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 680
    return (tmp___0);
  }
  {
#line 681
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 681
  if (! tmp___5) {
    {
#line 681
    tmp___1 = get_context_name(cmd);
#line 681
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 681
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 681
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 681
    return (tmp___4);
  }
  {
#line 683
  bool = get_boolean(cmd, 1);
  }
#line 684
  if (bool == -1) {
    {
#line 685
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 685
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 685
    return (tmp___7);
  }
#line 687
  if (! bool) {
    {
#line 688
    tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 688
    return (tmp___8);
  }
#line 691
  s = (server_rec *)server_list->xas_list;
  {
#line 691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 691
    if (! s) {
#line 691
      goto while_break;
    }
    {
#line 692
    tmp___11 = find_config(s->conf, 1 << 15, (char const   *)*(cmd->argv + 0), 0);
    }
#line 692
    if (tmp___11) {
      {
#line 693
      tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "DefaultServer has already been set",
                        (void *)0);
#line 693
      tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
      }
#line 693
      return (tmp___10);
    }
#line 691
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 695
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 696
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 697
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 699
  tmp___12 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 699
  return (tmp___12);
}
}
#line 702 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_masqueradeaddress(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  pr_netaddr_t *masq_addr ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 703
  c = (config_rec *)((void *)0);
#line 704
  masq_addr = (pr_netaddr_t *)((void *)0);
#line 706
  if (cmd->argc - 1 < 1) {
    {
#line 706
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 706
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 706
    return (tmp___0);
  }
  {
#line 707
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 707
  if (! tmp___5) {
    {
#line 707
    tmp___1 = get_context_name(cmd);
#line 707
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 707
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 707
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 707
    return (tmp___4);
  }
  {
#line 712
  masq_addr = pr_netaddr_get_addr((cmd->server)->pool, (char const   *)*(cmd->argv + 1),
                                  (array_header **)((void *)0));
  }
#line 713
  if ((unsigned long )masq_addr == (unsigned long )((void *)0)) {
    {
#line 714
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": unable to resolve \"", *(cmd->argv + 1),
                      "\"", (void *)0);
#line 714
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 714
    return (tmp___7);
  }
  {
#line 717
  c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)masq_addr, (void *)0);
#line 718
  tmp___8 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 718
  *(c->argv + 1) = (void *)tmp___8;
#line 720
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 720
  return (tmp___9);
}
}
#line 723 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_maxinstances(cmd_rec *cmd ) 
{ 
  int max ;
  char *endp ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 727
  if (cmd->argc - 1 < 1) {
    {
#line 727
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 727
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 727
    return (tmp___0);
  }
  {
#line 728
  tmp___5 = check_context(cmd, 1);
  }
#line 728
  if (! tmp___5) {
    {
#line 728
    tmp___1 = get_context_name(cmd);
#line 728
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 728
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 728
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 728
    return (tmp___4);
  }
  {
#line 730
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 730
  if (tmp___9 == 0) {
#line 731
    max = 0;
  } else {
    {
#line 734
    tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                     10);
#line 734
    max = (int )tmp___6;
    }
#line 736
    if (endp) {
#line 736
      if (*endp) {
        {
#line 737
        tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "argument must be \'none\' or a number greater than 0",
                          (void *)0);
#line 737
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
        }
#line 737
        return (tmp___8);
      } else {
#line 736
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 736
    if (max < 1) {
      {
#line 737
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "argument must be \'none\' or a number greater than 0",
                        (void *)0);
#line 737
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 737
      return (tmp___8);
    }
  }
  {
#line 740
  ServerMaxInstances = max;
#line 741
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 741
  return (tmp___10);
}
}
#line 745 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_maxconnrate(cmd_rec *cmd ) 
{ 
  long conn_max ;
  char *endp ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  modret_t *tmp___14 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 746
  conn_max = 0L;
#line 747
  endp = (char *)((void *)0);
#line 749
  if (cmd->argc - 1 < 1) {
    {
#line 750
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 750
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 750
    return (tmp___0);
  } else
#line 749
  if (cmd->argc - 1 > 2) {
    {
#line 750
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 750
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 750
    return (tmp___0);
  }
  {
#line 751
  tmp___5 = check_context(cmd, 1);
  }
#line 751
  if (! tmp___5) {
    {
#line 751
    tmp___1 = get_context_name(cmd);
#line 751
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 751
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 751
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 751
    return (tmp___4);
  }
  {
#line 753
  conn_max = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                    10);
  }
#line 755
  if (endp) {
#line 755
    if (*endp) {
      {
#line 756
      tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "invalid connection rate",
                        (void *)0);
#line 756
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
      }
#line 756
      return (tmp___7);
    }
  }
#line 758
  if (conn_max < 0L) {
    {
#line 759
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "connection rate must be positive",
                      (void *)0);
#line 759
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 759
    return (tmp___9);
  }
#line 761
  max_connects = (unsigned long )conn_max;
#line 764
  if (cmd->argc - 1 == 2) {
    {
#line 765
    tmp___10 = atoi((char const   *)*(cmd->argv + 2));
#line 765
    max_connect_interval = (unsigned int )tmp___10;
    }
#line 767
    if (max_connect_interval < 1U) {
      {
#line 768
      tmp___11 = pstrcat(cmd->tmp_pool, ": interval must be greater than zero", (void *)0);
#line 768
      tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___11, (void *)0);
#line 768
      tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
      }
#line 768
      return (tmp___13);
    }
  }
  {
#line 772
  tmp___14 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 772
  return (tmp___14);
}
}
#line 775 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_timeoutidle(cmd_rec *cmd ) 
{ 
  int timeout ;
  char *endp ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 776
  timeout = -1;
#line 777
  endp = (char *)((void *)0);
#line 778
  c = (config_rec *)((void *)0);
#line 780
  if (cmd->argc - 1 < 1) {
    {
#line 780
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 780
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 780
    return (tmp___0);
  }
  {
#line 781
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 781
  if (! tmp___5) {
    {
#line 781
    tmp___1 = get_context_name(cmd);
#line 781
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 781
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 781
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 781
    return (tmp___4);
  }
  {
#line 783
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   10);
#line 783
  timeout = (int )tmp___6;
  }
#line 785
  if (endp) {
#line 785
    if (*endp) {
      {
#line 786
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                        (void *)0);
#line 786
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 786
      return (tmp___8);
    } else {
#line 785
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 785
  if (timeout < 0) {
    {
#line 786
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 786
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 786
    return (tmp___8);
  } else
#line 785
  if (timeout > 65535) {
    {
#line 786
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 786
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 786
    return (tmp___8);
  }
  {
#line 788
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 789
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 790
  *((int *)*(c->argv + 0)) = timeout;
#line 791
  c->flags |= 1L;
#line 793
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 793
  return (tmp___9);
}
}
#line 796 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_timeoutlinger(cmd_rec *cmd ) 
{ 
  long timeout ;
  char *endp ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 797
  timeout = -1L;
#line 798
  endp = (char *)((void *)0);
#line 799
  c = (config_rec *)((void *)0);
#line 801
  if (cmd->argc - 1 < 1) {
    {
#line 801
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 801
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 801
    return (tmp___0);
  }
  {
#line 802
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 802
  if (! tmp___5) {
    {
#line 802
    tmp___1 = get_context_name(cmd);
#line 802
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 802
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 802
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 802
    return (tmp___4);
  }
  {
#line 804
  timeout = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   10);
  }
#line 806
  if (endp) {
#line 806
    if (*endp) {
      {
#line 807
      tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                        (void *)0);
#line 807
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
      }
#line 807
      return (tmp___7);
    } else {
#line 806
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 806
  if (timeout < 0L) {
    {
#line 807
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 807
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 807
    return (tmp___7);
  } else
#line 806
  if (timeout > 65535L) {
    {
#line 807
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "timeout values must be between 0 and 65535",
                      (void *)0);
#line 807
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 807
    return (tmp___7);
  }
  {
#line 809
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 810
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(long ));
#line 811
  *((long *)*(c->argv + 0)) = timeout;
#line 813
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 813
  return (tmp___8);
}
}
#line 816 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_socketbindtight(cmd_rec *cmd ) 
{ 
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 817
  bool = -1;
#line 818
  if (cmd->argc - 1 < 1) {
    {
#line 818
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 818
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 818
    return (tmp___0);
  }
  {
#line 819
  tmp___5 = check_context(cmd, 1);
  }
#line 819
  if (! tmp___5) {
    {
#line 819
    tmp___1 = get_context_name(cmd);
#line 819
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 819
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 819
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 819
    return (tmp___4);
  }
  {
#line 821
  bool = get_boolean(cmd, 1);
  }
#line 822
  if (bool == -1) {
    {
#line 823
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 823
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 823
    return (tmp___7);
  }
  {
#line 825
  SocketBindTight = bool;
#line 826
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 826
  return (tmp___8);
}
}
#line 832 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_socketoptions(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int value ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  modret_t *tmp___18 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 833
  i___0 = 0U;
#line 836
  if ((cmd->argc - 1) % 2 != 0) {
    {
#line 837
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "bad number of parameters",
                  (void *)0);
#line 837
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 837
    return (tmp___0);
  }
  {
#line 839
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 839
  if (! tmp___5) {
    {
#line 839
    tmp___1 = get_context_name(cmd);
#line 839
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 839
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 839
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 839
    return (tmp___4);
  }
#line 841
  i___0 = 1U;
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 841
      goto while_break;
    }
    {
#line 842
    value = 0;
#line 844
    tmp___17 = strcasecmp((char const   *)*(cmd->argv + i___0), "maxseg");
    }
#line 844
    if (tmp___17 == 0) {
      {
#line 845
      i___0 ++;
#line 845
      value = atoi((char const   *)*(cmd->argv + i___0));
      }
#line 851
      if (value < 0) {
        {
#line 852
        tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "maxseg size must be greater than 0",
                          (void *)0);
#line 852
        tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
        }
#line 852
        return (tmp___7);
      }
#line 854
      (cmd->server)->tcp_mss_len = value;
    } else {
      {
#line 856
      tmp___16 = strcasecmp((char const   *)*(cmd->argv + i___0), "rcvbuf");
      }
#line 856
      if (tmp___16 == 0) {
        {
#line 857
        i___0 ++;
#line 857
        value = atoi((char const   *)*(cmd->argv + i___0));
        }
#line 859
        if (value < 1024) {
          {
#line 860
          tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "rcvbuf size must be greater than or equal to 1024",
                            (void *)0);
#line 860
          tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
          }
#line 860
          return (tmp___9);
        }
#line 862
        (cmd->server)->tcp_rcvbuf_len = value;
#line 863
        (cmd->server)->tcp_rcvbuf_override = (unsigned char)1;
      } else {
        {
#line 865
        tmp___15 = strcasecmp((char const   *)*(cmd->argv + i___0), "sndbuf");
        }
#line 865
        if (tmp___15 == 0) {
          {
#line 866
          i___0 ++;
#line 866
          value = atoi((char const   *)*(cmd->argv + i___0));
          }
#line 868
          if (value < 1024) {
            {
#line 869
            tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "sndbuf size must be greater than or equal to 1024",
                               (void *)0);
#line 869
            tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___10);
            }
#line 869
            return (tmp___11);
          }
#line 871
          (cmd->server)->tcp_sndbuf_len = value;
#line 872
          (cmd->server)->tcp_sndbuf_override = (unsigned char)1;
        } else {
          {
#line 875
          tmp___12 = pstrcat(cmd->tmp_pool, ": unknown socket option: \'", *(cmd->argv + i___0),
                             "\'", (void *)0);
#line 875
          tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___12, (void *)0);
#line 875
          tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___13);
          }
#line 875
          return (tmp___14);
        }
      }
    }
#line 841
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 880
  tmp___18 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 880
  return (tmp___18);
}
}
#line 883 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_multilinerfc2228(cmd_rec *cmd ) 
{ 
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 884
  bool = -1;
#line 885
  if (cmd->argc - 1 < 1) {
    {
#line 885
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 885
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 885
    return (tmp___0);
  }
  {
#line 886
  tmp___5 = check_context(cmd, 1);
  }
#line 886
  if (! tmp___5) {
    {
#line 886
    tmp___1 = get_context_name(cmd);
#line 886
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 886
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 886
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 886
    return (tmp___4);
  }
  {
#line 888
  bool = get_boolean(cmd, 1);
  }
#line 889
  if (bool == -1) {
    {
#line 890
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 890
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 890
    return (tmp___7);
  }
  {
#line 892
  MultilineRFC2228 = (char )bool;
#line 893
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 893
  return (tmp___8);
}
}
#line 896 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_identlookups___0(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 897
  bool = -1;
#line 898
  c = (config_rec *)((void *)0);
#line 900
  if (cmd->argc - 1 < 1) {
    {
#line 900
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 900
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 900
    return (tmp___0);
  }
  {
#line 901
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 901
  if (! tmp___5) {
    {
#line 901
    tmp___1 = get_context_name(cmd);
#line 901
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 901
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 901
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 901
    return (tmp___4);
  }
  {
#line 903
  bool = get_boolean(cmd, 1);
  }
#line 904
  if (bool == -1) {
    {
#line 905
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 905
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 905
    return (tmp___7);
  }
  {
#line 907
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 908
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 909
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 911
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 911
  return (tmp___8);
}
}
#line 914 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_tcpbacklog(cmd_rec *cmd ) 
{ 
  int backlog ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 917
  if (cmd->argc - 1 < 1) {
    {
#line 917
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 917
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 917
    return (tmp___0);
  }
  {
#line 918
  tmp___5 = check_context(cmd, 1);
  }
#line 918
  if (! tmp___5) {
    {
#line 918
    tmp___1 = get_context_name(cmd);
#line 918
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 918
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 918
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 918
    return (tmp___4);
  }
  {
#line 920
  backlog = atoi((char const   *)*(cmd->argv + 1));
  }
#line 922
  if (backlog < 1) {
    {
#line 923
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be a number between 1 and 255",
                      (void *)0);
#line 923
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 923
    return (tmp___7);
  } else
#line 922
  if (backlog > 255) {
    {
#line 923
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be a number between 1 and 255",
                      (void *)0);
#line 923
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 923
    return (tmp___7);
  }
  {
#line 925
  tcpBackLog = backlog;
#line 926
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 926
  return (tmp___8);
}
}
#line 929 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_tcpnodelay(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 930
  bool = -1;
#line 931
  c = (config_rec *)((void *)0);
#line 933
  if (cmd->argc - 1 < 1) {
    {
#line 933
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 933
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 933
    return (tmp___0);
  }
  {
#line 934
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 934
  if (! tmp___5) {
    {
#line 934
    tmp___1 = get_context_name(cmd);
#line 934
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 934
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 934
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 934
    return (tmp___4);
  }
  {
#line 936
  bool = get_boolean(cmd, 1);
  }
#line 937
  if (bool == -1) {
    {
#line 938
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 938
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 938
    return (tmp___7);
  }
  {
#line 940
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 941
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 942
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 944
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 944
  return (tmp___8);
}
}
#line 947 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_user(cmd_rec *cmd ) 
{ 
  struct passwd *pw ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  config_rec *c ;
  config_rec *tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 948
  pw = (struct passwd *)((void *)0);
#line 950
  if (cmd->argc - 1 < 1) {
    {
#line 950
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 950
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 950
    return (tmp___0);
  }
  {
#line 951
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 951
  if (! tmp___5) {
    {
#line 951
    tmp___1 = get_context_name(cmd);
#line 951
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 951
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 951
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 951
    return (tmp___4);
  }
#line 957
  if (! cmd->config) {
#line 957
    goto _L;
  } else
#line 957
  if ((cmd->config)->config_type != 1 << 2) {
    _L: /* CIL Label */ 
    {
#line 958
    pw = pr_auth_getpwnam(cmd->tmp_pool, (char const   *)*(cmd->argv + 1));
    }
#line 959
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 960
      tmp___6 = pstrcat(cmd->tmp_pool, "Unknown user \'", *(cmd->argv + 1), "\'",
                        (void *)0);
#line 960
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 960
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 960
      return (tmp___8);
    }
  }
#line 965
  if (pw) {
    {
#line 966
    tmp___9 = add_config_param("UserID", 1, (void *)0);
#line 966
    c = tmp___9;
#line 967
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(uid_t ));
#line 968
    *((uid_t *)*(c->argv + 0)) = pw->pw_uid;
    }
  }
  {
#line 971
  add_config_param_str("UserName", 1, *(cmd->argv + 1));
#line 972
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 972
  return (tmp___10);
}
}
#line 975 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_from(cmd_rec *cmd ) 
{ 
  int cargc ;
  char **cargv ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  pr_netacl_t *acl ;
  pr_netacl_t *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *ent ;
  char *str ;
  char *tmp___18 ;
  pr_netacl_t *acl___0 ;
  int tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  modret_t *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  modret_t *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  modret_t *tmp___33 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 979
  tmp___3 = check_context(cmd, 1 << 7);
  }
#line 979
  if (! tmp___3) {
    {
#line 979
    tmp = get_context_name(cmd);
#line 979
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 979
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 979
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 979
    return (tmp___2);
  }
#line 981
  cargc = cmd->argc - 1;
#line 982
  cargv = cmd->argv;
  {
#line 984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 984
    if (cargc) {
#line 984
      if (! *(cargv + 1)) {
#line 984
        goto while_break;
      }
    } else {
#line 984
      goto while_break;
    }
    {
#line 985
    tmp___16 = strcasecmp("all", (char const   *)*(cargv + 1));
    }
#line 985
    if (tmp___16 == 0) {
#line 985
      goto _L;
    } else {
      {
#line 985
      tmp___17 = strcasecmp("none", (char const   *)*(cargv + 1));
      }
#line 985
      if (tmp___17 == 0) {
        _L: /* CIL Label */ 
        {
#line 987
        tmp___4 = pr_netacl_create(cmd->tmp_pool, *(cargv + 1));
#line 987
        acl = tmp___4;
        }
#line 988
        if (! acl) {
          {
#line 989
          tmp___5 = __errno_location();
#line 989
          tmp___6 = strerror(*tmp___5);
#line 989
          tmp___7 = pstrcat(cmd->tmp_pool, "bad ACL definition \'", *(cargv + 1),
                            "\': ", tmp___6, (void *)0);
#line 989
          tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 989
          tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
          }
#line 989
          return (tmp___9);
        }
        {
#line 993
        tmp___15 = pr_class_add_acl(acl);
        }
#line 993
        if (tmp___15 < 0) {
          {
#line 994
          tmp___10 = __errno_location();
#line 994
          tmp___11 = strerror(*tmp___10);
#line 994
          tmp___12 = pstrcat(cmd->tmp_pool, "error adding rule \'", *(cargv + 1),
                             "\': ", tmp___11, (void *)0);
#line 994
          tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___12, (void *)0);
#line 994
          tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___13);
          }
#line 994
          return (tmp___14);
        }
#line 998
        cargc = 0;
      }
    }
#line 1001
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1005
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1005
    tmp___32 = cargc;
#line 1005
    cargc --;
#line 1005
    if (tmp___32) {
#line 1005
      cargv ++;
#line 1005
      if (! *cargv) {
#line 1005
        goto while_break___0;
      }
    } else {
#line 1005
      goto while_break___0;
    }
    {
#line 1006
    ent = (char *)((void *)0);
#line 1007
    tmp___18 = pstrdup(cmd->tmp_pool, (char const   *)*cargv);
#line 1007
    str = tmp___18;
    }
    {
#line 1009
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1009
      ent = pr_str_get_token(& str, (char *)",");
      }
#line 1009
      if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 1009
        goto while_break___1;
      }
#line 1010
      if (*ent) {
        {
#line 1013
        tmp___19 = strcasecmp((char const   *)ent, "all");
        }
#line 1013
        if (tmp___19 == 0) {
#line 1015
          cargc = 0;
#line 1016
          goto while_break___1;
        } else {
          {
#line 1013
          tmp___20 = strcasecmp((char const   *)ent, "none");
          }
#line 1013
          if (tmp___20 == 0) {
#line 1015
            cargc = 0;
#line 1016
            goto while_break___1;
          }
        }
        {
#line 1019
        acl___0 = pr_netacl_create(cmd->tmp_pool, ent);
        }
#line 1020
        if (! acl___0) {
          {
#line 1021
          tmp___21 = __errno_location();
#line 1021
          tmp___22 = strerror(*tmp___21);
#line 1021
          tmp___23 = pstrcat(cmd->tmp_pool, "bad ACL definition \'", *(cargv + 1),
                             "\': ", tmp___22, (void *)0);
#line 1021
          tmp___24 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___23, (void *)0);
#line 1021
          tmp___25 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___24);
          }
#line 1021
          return (tmp___25);
        }
        {
#line 1025
        tmp___31 = pr_class_add_acl(acl___0);
        }
#line 1025
        if (tmp___31 < 0) {
          {
#line 1026
          tmp___26 = __errno_location();
#line 1026
          tmp___27 = strerror(*tmp___26);
#line 1026
          tmp___28 = pstrcat(cmd->tmp_pool, "error adding rule \'", ent, "\': ", tmp___27,
                             (void *)0);
#line 1026
          tmp___29 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___28, (void *)0);
#line 1026
          tmp___30 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___29);
          }
#line 1026
          return (tmp___30);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1033
  tmp___33 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1033
  return (tmp___33);
}
}
#line 1036 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_group(cmd_rec *cmd ) 
{ 
  struct group *grp ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  config_rec *c ;
  config_rec *tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1037
  grp = (struct group *)((void *)0);
#line 1039
  if (cmd->argc - 1 < 1) {
    {
#line 1039
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1039
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1039
    return (tmp___0);
  }
  {
#line 1040
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 1040
  if (! tmp___5) {
    {
#line 1040
    tmp___1 = get_context_name(cmd);
#line 1040
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1040
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1040
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1040
    return (tmp___4);
  }
#line 1042
  if (! cmd->config) {
#line 1042
    goto _L;
  } else
#line 1042
  if ((cmd->config)->config_type != 1 << 2) {
    _L: /* CIL Label */ 
    {
#line 1043
    grp = pr_auth_getgrnam(cmd->tmp_pool, (char const   *)*(cmd->argv + 1));
    }
#line 1044
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
      {
#line 1045
      tmp___6 = pstrcat(cmd->tmp_pool, "Unknown group \'", *(cmd->argv + 1), "\'",
                        (void *)0);
#line 1045
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 1045
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 1045
      return (tmp___8);
    }
  }
#line 1050
  if (grp) {
    {
#line 1051
    tmp___9 = add_config_param("GroupID", 1, (void *)0);
#line 1051
    c = tmp___9;
#line 1052
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(gid_t ));
#line 1053
    *((gid_t *)*(c->argv + 0)) = grp->gr_gid;
    }
  }
  {
#line 1056
  add_config_param_str("GroupName", 1, *(cmd->argv + 1));
#line 1057
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1057
  return (tmp___10);
}
}
#line 1061 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_trace(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *channel ;
  char *tmp___6 ;
  int level ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  modret_t *tmp___16 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1065
  if (cmd->argc - 1 < 1) {
    {
#line 1066
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1066
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1066
    return (tmp___0);
  }
  {
#line 1067
  tmp___5 = check_context(cmd, 1);
  }
#line 1067
  if (! tmp___5) {
    {
#line 1067
    tmp___1 = get_context_name(cmd);
#line 1067
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1067
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1067
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1067
    return (tmp___4);
  }
#line 1069
  i___0 = 1U;
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 1069
      goto while_break;
    }
    {
#line 1073
    tmp___6 = strchr((char const   *)*(cmd->argv + i___0), ':');
    }
#line 1074
    if (! tmp___6) {
      {
#line 1075
      tmp___7 = pstrcat(cmd->tmp_pool, "badly formatted parameter: \'", *(cmd->argv + i___0),
                        "\'", (void *)0);
#line 1075
      tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 1075
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
      }
#line 1075
      return (tmp___9);
    }
    {
#line 1078
    channel = *(cmd->argv + i___0);
#line 1079
    *tmp___6 = (char )'\000';
#line 1080
    tmp___6 ++;
#line 1080
    level = atoi((char const   *)tmp___6);
#line 1082
    tmp___15 = pr_trace_set_level((char const   *)channel, level);
    }
#line 1082
    if (tmp___15 < 0) {
      {
#line 1083
      tmp___10 = __errno_location();
#line 1083
      tmp___11 = strerror(*tmp___10);
#line 1083
      tmp___12 = pstrcat(cmd->tmp_pool, "error setting level ", tmp___6, " for channel \'",
                         channel, "\': ", tmp___11, (void *)0);
#line 1083
      tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___12, (void *)0);
#line 1083
      tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___13);
      }
#line 1083
      return (tmp___14);
    }
#line 1069
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1087
  tmp___16 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1087
  return (tmp___16);
}
}
#line 1095 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_tracelog(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  modret_t *tmp___16 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1097
  if (cmd->argc - 1 != 1) {
    {
#line 1098
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1098
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1098
    return (tmp___0);
  }
  {
#line 1099
  tmp___5 = check_context(cmd, 1);
  }
#line 1099
  if (! tmp___5) {
    {
#line 1099
    tmp___1 = get_context_name(cmd);
#line 1099
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1099
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1099
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1099
    return (tmp___4);
  }
  {
#line 1101
  tmp___8 = pr_fs_valid_path((char const   *)*(cmd->argv + 1));
  }
#line 1101
  if (tmp___8 < 0) {
    {
#line 1102
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "must be an absolute path",
                      (void *)0);
#line 1102
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 1102
    return (tmp___7);
  }
  {
#line 1104
  tmp___9 = pstrdup((cmd->server)->pool, (char const   *)*(cmd->argv + 1));
#line 1104
  trace_log = (char const   *)tmp___9;
#line 1105
  tmp___15 = pr_trace_set_file(trace_log);
  }
#line 1105
  if (tmp___15 < 0) {
    {
#line 1106
    tmp___10 = __errno_location();
#line 1106
    tmp___11 = strerror(*tmp___10);
#line 1106
    tmp___12 = pstrcat(cmd->tmp_pool, "error using TraceLog \'", trace_log, "\': ",
                       tmp___11, (void *)0);
#line 1106
    tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___12, (void *)0);
#line 1106
    tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___13);
    }
#line 1106
    return (tmp___14);
  }
  {
#line 1110
  tmp___16 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1110
  return (tmp___16);
}
}
#line 1117 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_umask(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *endp ;
  mode_t tmp_umask ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  long tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  modret_t *tmp___14 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1122
  if (cmd->argc - 1 < 1) {
    {
#line 1122
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1122
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1122
    return (tmp___0);
  } else
#line 1122
  if (cmd->argc - 1 > 2) {
    {
#line 1122
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1122
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1122
    return (tmp___0);
  }
  {
#line 1123
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 1123
  if (! tmp___5) {
    {
#line 1123
    tmp___1 = get_context_name(cmd);
#line 1123
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1123
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1123
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1123
    return (tmp___4);
  }
  {
#line 1126
  tmp___6 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& endp),
                   8);
#line 1126
  tmp_umask = (mode_t )tmp___6;
  }
#line 1128
  if (endp) {
#line 1128
    if (*endp) {
      {
#line 1129
      tmp___7 = pstrcat(cmd->tmp_pool, "\'", *(cmd->argv + 1), "\' is not a valid umask",
                        (void *)0);
#line 1129
      tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 1129
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
      }
#line 1129
      return (tmp___9);
    }
  }
  {
#line 1132
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1133
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(mode_t ));
#line 1134
  *((mode_t *)*(c->argv + 0)) = tmp_umask;
#line 1135
  c->flags |= 1L;
  }
#line 1139
  if (cmd->argc - 1 == 2) {
    {
#line 1144
    tmp___10 = strtol((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& endp),
                      8);
#line 1144
    tmp_umask = (mode_t )tmp___10;
    }
#line 1146
    if (endp) {
#line 1146
      if (*endp) {
        {
#line 1147
        tmp___11 = pstrcat(cmd->tmp_pool, "\'", *(cmd->argv + 2), "\' is not a valid umask",
                           (void *)0);
#line 1147
        tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___11, (void *)0);
#line 1147
        tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
        }
#line 1147
        return (tmp___13);
      }
    }
    {
#line 1150
    c = add_config_param("DirUmask", 1, (void *)0);
#line 1151
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(mode_t ));
#line 1152
    *((mode_t *)*(c->argv + 0)) = tmp_umask;
#line 1153
    c->flags |= 1L;
    }
  }
  {
#line 1156
  tmp___14 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1156
  return (tmp___14);
}
}
#line 1159 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_unsetenv(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1160
  if (cmd->argc - 1 < 1) {
    {
#line 1160
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1160
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1160
    return (tmp___0);
  }
  {
#line 1161
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 1161
  if (! tmp___5) {
    {
#line 1161
    tmp___1 = get_context_name(cmd);
#line 1161
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1161
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1161
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1161
    return (tmp___4);
  }
  {
#line 1163
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 1164
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1164
  return (tmp___6);
}
}
#line 1167 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_rlimitcpu(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  config_rec *c ;
  struct rlimit *rlim ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  unsigned long num ;
  unsigned long tmp___17 ;
  char *tmp___18 ;
  modret_t *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  unsigned long num___0 ;
  unsigned long tmp___22 ;
  char *tmp___23 ;
  modret_t *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  struct rlimit *rlim___0 ;
  void *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  long num___1 ;
  long tmp___32 ;
  char *tmp___33 ;
  modret_t *tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  long num___2 ;
  long tmp___37 ;
  char *tmp___38 ;
  modret_t *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  modret_t *tmp___43 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
#line 1170
  if (cmd->argc - 1 < 1) {
    {
#line 1171
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1171
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1171
    return (tmp___0);
  } else
#line 1170
  if (cmd->argc - 1 > 3) {
    {
#line 1171
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1171
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1171
    return (tmp___0);
  }
  {
#line 1180
  tmp___11 = strcmp((char const   *)*(cmd->argv + 1), "daemon");
  }
#line 1180
  if (tmp___11 == 0) {
    {
#line 1181
    tmp___5 = check_context(cmd, 1);
    }
#line 1181
    if (! tmp___5) {
      {
#line 1181
      tmp___1 = get_context_name(cmd);
#line 1181
      tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                        (void *)0);
#line 1181
      tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1181
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
      }
#line 1181
      return (tmp___4);
    }
  } else {
    {
#line 1184
    tmp___10 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
    }
#line 1184
    if (! tmp___10) {
      {
#line 1184
      tmp___6 = get_context_name(cmd);
#line 1184
      tmp___7 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___6, " context",
                        (void *)0);
#line 1184
      tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 1184
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
      }
#line 1184
      return (tmp___9);
    }
  }
  {
#line 1190
  tmp___41 = strcmp((char const   *)*(cmd->argv + 1), "daemon");
  }
#line 1190
  if (tmp___41 == 0) {
#line 1190
    goto _L;
  } else {
    {
#line 1190
    tmp___42 = strcmp((char const   *)*(cmd->argv + 1), "session");
    }
#line 1190
    if (tmp___42 == 0) {
      _L: /* CIL Label */ 
      {
#line 1192
      c = (config_rec *)((void *)0);
#line 1193
      tmp___12 = pcalloc((cmd->server)->pool, (int )sizeof(struct rlimit ));
#line 1193
      rlim = (struct rlimit *)tmp___12;
#line 1196
      tmp___15 = getrlimit((__rlimit_resource_t )0, rlim);
      }
#line 1196
      if (tmp___15 < 0) {
        {
#line 1197
        tmp___13 = __errno_location();
#line 1197
        tmp___14 = strerror(*tmp___13);
#line 1197
        pr_log_pri(3, "error: getrlimit(RLIMIT_CPU): %s", tmp___14);
        }
      }
      {
#line 1200
      tmp___20 = strcasecmp("max", (char const   *)*(cmd->argv + 2));
      }
#line 1200
      if (tmp___20 == 0) {
#line 1201
        rlim->rlim_cur = 0xffffffffffffffffULL;
      } else {
        {
#line 1207
        tmp___16 = (char *)((void *)0);
#line 1208
        tmp___17 = strtoul((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& tmp___16),
                           10);
#line 1208
        num = tmp___17;
        }
#line 1210
        if (tmp___16) {
#line 1210
          if (*tmp___16) {
            {
#line 1211
            tmp___18 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                               (void *)0);
#line 1211
            tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___18);
            }
#line 1211
            return (tmp___19);
          }
        }
#line 1213
        rlim->rlim_cur = (rlim_t )num;
      }
#line 1217
      if (cmd->argc - 1 == 3) {
        {
#line 1218
        tmp___25 = strcasecmp("max", (char const   *)*(cmd->argv + 3));
        }
#line 1218
        if (tmp___25 == 0) {
#line 1219
          rlim->rlim_max = 0xffffffffffffffffULL;
        } else {
          {
#line 1225
          tmp___21 = (char *)((void *)0);
#line 1226
          tmp___22 = strtoul((char const   */* __restrict  */)*(cmd->argv + 3), (char **/* __restrict  */)(& tmp___21),
                             10);
#line 1226
          num___0 = tmp___22;
          }
#line 1228
          if (tmp___21) {
#line 1228
            if (*tmp___21) {
              {
#line 1229
              tmp___23 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                                 (void *)0);
#line 1229
              tmp___24 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___23);
              }
#line 1229
              return (tmp___24);
            }
          }
#line 1231
          rlim->rlim_max = (rlim_t )num___0;
        }
      }
      {
#line 1235
      c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)rlim, (void *)0);
#line 1236
      tmp___26 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 1236
      *(c->argv + 1) = (void *)tmp___26;
      }
    } else {
      {
#line 1242
      tmp___27 = pcalloc((cmd->server)->pool, (int )sizeof(struct rlimit ));
#line 1242
      rlim___0 = (struct rlimit *)tmp___27;
#line 1245
      tmp___30 = getrlimit((__rlimit_resource_t )0, rlim___0);
      }
#line 1245
      if (tmp___30 < 0) {
        {
#line 1246
        tmp___28 = __errno_location();
#line 1246
        tmp___29 = strerror(*tmp___28);
#line 1246
        pr_log_pri(3, "error: getrlimit(RLIMIT_CPU): %s", tmp___29);
        }
      }
      {
#line 1249
      tmp___35 = strcasecmp("max", (char const   *)*(cmd->argv + 1));
      }
#line 1249
      if (tmp___35 == 0) {
#line 1250
        rlim___0->rlim_cur = 0xffffffffffffffffULL;
      } else {
        {
#line 1256
        tmp___31 = (char *)((void *)0);
#line 1257
        tmp___32 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& tmp___31),
                          10);
#line 1257
        num___1 = tmp___32;
        }
#line 1259
        if (tmp___31) {
#line 1259
          if (*tmp___31) {
            {
#line 1260
            tmp___33 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                               (void *)0);
#line 1260
            tmp___34 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___33);
            }
#line 1260
            return (tmp___34);
          }
        }
#line 1262
        rlim___0->rlim_cur = (rlim_t )num___1;
      }
#line 1266
      if (cmd->argc - 1 == 2) {
        {
#line 1267
        tmp___40 = strcasecmp("max", (char const   *)*(cmd->argv + 2));
        }
#line 1267
        if (tmp___40 == 0) {
#line 1268
          rlim___0->rlim_max = 0xffffffffffffffffULL;
        } else {
          {
#line 1274
          tmp___36 = (char *)((void *)0);
#line 1275
          tmp___37 = strtol((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& tmp___36),
                            10);
#line 1275
          num___2 = tmp___37;
          }
#line 1277
          if (tmp___36) {
#line 1277
            if (*tmp___36) {
              {
#line 1278
              tmp___38 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                                 (void *)0);
#line 1278
              tmp___39 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___38);
              }
#line 1278
              return (tmp___39);
            }
          }
#line 1280
          rlim___0->rlim_max = (rlim_t )num___2;
        }
      }
      {
#line 1284
      add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)rlim___0, (void *)0);
      }
    }
  }
  {
#line 1287
  tmp___43 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1287
  return (tmp___43);
}
}
#line 1293 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_rlimitmemory(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  config_rec *c ;
  struct rlimit *rlim ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  modret_t *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  ssize_t tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  modret_t *tmp___25 ;
  char *tmp___26 ;
  modret_t *tmp___27 ;
  char *tmp___28 ;
  struct rlimit *rlim___0 ;
  void *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  ssize_t tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  modret_t *tmp___36 ;
  char *tmp___37 ;
  modret_t *tmp___38 ;
  ssize_t tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  modret_t *tmp___42 ;
  char *tmp___43 ;
  modret_t *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  modret_t *tmp___47 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
#line 1296
  if (cmd->argc - 1 < 1) {
    {
#line 1297
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1297
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1297
    return (tmp___0);
  } else
#line 1296
  if (cmd->argc - 1 > 3) {
    {
#line 1297
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1297
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1297
    return (tmp___0);
  }
  {
#line 1306
  tmp___11 = strcmp((char const   *)*(cmd->argv + 1), "daemon");
  }
#line 1306
  if (tmp___11 == 0) {
    {
#line 1307
    tmp___5 = check_context(cmd, 1);
    }
#line 1307
    if (! tmp___5) {
      {
#line 1307
      tmp___1 = get_context_name(cmd);
#line 1307
      tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                        (void *)0);
#line 1307
      tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1307
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
      }
#line 1307
      return (tmp___4);
    }
  } else {
    {
#line 1310
    tmp___10 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
    }
#line 1310
    if (! tmp___10) {
      {
#line 1310
      tmp___6 = get_context_name(cmd);
#line 1310
      tmp___7 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___6, " context",
                        (void *)0);
#line 1310
      tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 1310
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
      }
#line 1310
      return (tmp___9);
    }
  }
  {
#line 1316
  tmp___45 = strcmp((char const   *)*(cmd->argv + 1), "daemon");
  }
#line 1316
  if (tmp___45 == 0) {
#line 1316
    goto _L;
  } else {
    {
#line 1316
    tmp___46 = strcmp((char const   *)*(cmd->argv + 1), "session");
    }
#line 1316
    if (tmp___46 == 0) {
      _L: /* CIL Label */ 
      {
#line 1318
      c = (config_rec *)((void *)0);
#line 1319
      tmp___12 = pcalloc((cmd->server)->pool, (int )sizeof(struct rlimit ));
#line 1319
      rlim = (struct rlimit *)tmp___12;
#line 1323
      tmp___15 = getrlimit((__rlimit_resource_t )2, rlim);
      }
#line 1323
      if (tmp___15 == -1) {
        {
#line 1324
        tmp___13 = __errno_location();
#line 1324
        tmp___14 = strerror(*tmp___13);
#line 1324
        pr_log_pri(3, "error: getrlimit(RLIMIT_DATA): %s", tmp___14);
        }
      }
      {
#line 1336
      tmp___17 = strcasecmp("max", (char const   *)*(cmd->argv + 2));
      }
#line 1336
      if (tmp___17 == 0) {
#line 1337
        rlim->rlim_cur = 0xffffffffffffffffULL;
      } else {
        {
#line 1340
        tmp___16 = get_num_bytes(*(cmd->argv + 2));
#line 1340
        rlim->rlim_cur = (rlim_t )tmp___16;
        }
      }
#line 1344
      if (rlim->rlim_cur == 0xffffffffffffffffULL) {
        {
#line 1345
        tmp___18 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unknown units used",
                           (void *)0);
#line 1345
        tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___18);
        }
#line 1345
        return (tmp___19);
      }
#line 1347
      if (rlim->rlim_cur == 0xfffffffffffffffeULL) {
        {
#line 1348
        tmp___20 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted parameter",
                           (void *)0);
#line 1348
        tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___20);
        }
#line 1348
        return (tmp___21);
      }
#line 1351
      if (cmd->argc - 1 == 3) {
        {
#line 1352
        tmp___23 = strcasecmp("max", (char const   *)*(cmd->argv + 3));
        }
#line 1352
        if (tmp___23 == 0) {
#line 1353
          rlim->rlim_max = 0xffffffffffffffffULL;
        } else {
          {
#line 1356
          tmp___22 = get_num_bytes(*(cmd->argv + 3));
#line 1356
          rlim->rlim_max = (rlim_t )tmp___22;
          }
        }
#line 1360
        if (rlim->rlim_max == 0xffffffffffffffffULL) {
          {
#line 1361
          tmp___24 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unknown units used",
                             (void *)0);
#line 1361
          tmp___25 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___24);
          }
#line 1361
          return (tmp___25);
        }
#line 1363
        if (rlim->rlim_max == 0xfffffffffffffffeULL) {
          {
#line 1364
          tmp___26 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted parameter",
                             (void *)0);
#line 1364
          tmp___27 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___26);
          }
#line 1364
          return (tmp___27);
        }
      }
      {
#line 1367
      c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)rlim, (void *)0);
#line 1368
      tmp___28 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 1368
      *(c->argv + 1) = (void *)tmp___28;
      }
    } else {
      {
#line 1374
      tmp___29 = pcalloc((cmd->server)->pool, (int )sizeof(struct rlimit ));
#line 1374
      rlim___0 = (struct rlimit *)tmp___29;
#line 1378
      tmp___32 = getrlimit((__rlimit_resource_t )2, rlim___0);
      }
#line 1378
      if (tmp___32 < 0) {
        {
#line 1379
        tmp___30 = __errno_location();
#line 1379
        tmp___31 = strerror(*tmp___30);
#line 1379
        pr_log_pri(3, "error: getrlimit(RLIMIT_DATA): %s", tmp___31);
        }
      }
      {
#line 1391
      tmp___34 = strcasecmp("max", (char const   *)*(cmd->argv + 1));
      }
#line 1391
      if (tmp___34 == 0) {
#line 1392
        rlim___0->rlim_cur = 0xffffffffffffffffULL;
      } else {
        {
#line 1395
        tmp___33 = get_num_bytes(*(cmd->argv + 1));
#line 1395
        rlim___0->rlim_cur = (rlim_t )tmp___33;
        }
      }
#line 1399
      if (rlim___0->rlim_cur == 0xffffffffffffffffULL) {
        {
#line 1400
        tmp___35 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unknown units used",
                           (void *)0);
#line 1400
        tmp___36 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___35);
        }
#line 1400
        return (tmp___36);
      }
#line 1402
      if (rlim___0->rlim_cur == 0xfffffffffffffffeULL) {
        {
#line 1403
        tmp___37 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted parameter",
                           (void *)0);
#line 1403
        tmp___38 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___37);
        }
#line 1403
        return (tmp___38);
      }
#line 1406
      if (cmd->argc - 1 == 2) {
        {
#line 1407
        tmp___40 = strcasecmp("max", (char const   *)*(cmd->argv + 2));
        }
#line 1407
        if (tmp___40 == 0) {
#line 1408
          rlim___0->rlim_max = 0xffffffffffffffffULL;
        } else {
          {
#line 1411
          tmp___39 = get_num_bytes(*(cmd->argv + 2));
#line 1411
          rlim___0->rlim_max = (rlim_t )tmp___39;
          }
        }
#line 1415
        if (rlim___0->rlim_max == 0xffffffffffffffffULL) {
          {
#line 1416
          tmp___41 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unknown units used",
                             (void *)0);
#line 1416
          tmp___42 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___41);
          }
#line 1416
          return (tmp___42);
        }
#line 1418
        if (rlim___0->rlim_max == 0xfffffffffffffffeULL) {
          {
#line 1419
          tmp___43 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted parameter",
                             (void *)0);
#line 1419
          tmp___44 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___43);
          }
#line 1419
          return (tmp___44);
        }
      }
      {
#line 1422
      add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)rlim___0, (void *)0);
      }
    }
  }
  {
#line 1425
  tmp___47 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1425
  return (tmp___47);
}
}
#line 1431 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_rlimitopenfiles(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  config_rec *c ;
  struct rlimit *rlim ;
  void *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  char *tmp___17 ;
  long num ;
  long tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  char *tmp___23 ;
  long num___0 ;
  long tmp___24 ;
  char *tmp___25 ;
  modret_t *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  struct rlimit *rlim___0 ;
  void *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  long tmp___33 ;
  char *tmp___34 ;
  long num___1 ;
  long tmp___35 ;
  char *tmp___36 ;
  modret_t *tmp___37 ;
  int tmp___38 ;
  long tmp___39 ;
  char *tmp___40 ;
  long num___2 ;
  long tmp___41 ;
  char *tmp___42 ;
  modret_t *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  modret_t *tmp___47 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
#line 1434
  if (cmd->argc - 1 < 1) {
    {
#line 1435
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1435
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1435
    return (tmp___0);
  } else
#line 1434
  if (cmd->argc - 1 > 3) {
    {
#line 1435
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 1435
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1435
    return (tmp___0);
  }
  {
#line 1444
  tmp___11 = strcmp((char const   *)*(cmd->argv + 1), "daemon");
  }
#line 1444
  if (tmp___11 == 0) {
    {
#line 1445
    tmp___5 = check_context(cmd, 1);
    }
#line 1445
    if (! tmp___5) {
      {
#line 1445
      tmp___1 = get_context_name(cmd);
#line 1445
      tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                        (void *)0);
#line 1445
      tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1445
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
      }
#line 1445
      return (tmp___4);
    }
  } else {
    {
#line 1448
    tmp___10 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
    }
#line 1448
    if (! tmp___10) {
      {
#line 1448
      tmp___6 = get_context_name(cmd);
#line 1448
      tmp___7 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___6, " context",
                        (void *)0);
#line 1448
      tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 1448
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
      }
#line 1448
      return (tmp___9);
    }
  }
  {
#line 1454
  tmp___45 = strcmp((char const   *)*(cmd->argv + 1), "daemon");
  }
#line 1454
  if (tmp___45 == 0) {
#line 1454
    goto _L;
  } else {
    {
#line 1454
    tmp___46 = strcmp((char const   *)*(cmd->argv + 1), "session");
    }
#line 1454
    if (tmp___46 == 0) {
      _L: /* CIL Label */ 
      {
#line 1456
      c = (config_rec *)((void *)0);
#line 1457
      tmp___12 = pcalloc((cmd->server)->pool, (int )sizeof(struct rlimit ));
#line 1457
      rlim = (struct rlimit *)tmp___12;
#line 1461
      tmp___15 = getrlimit((__rlimit_resource_t )7, rlim);
      }
#line 1461
      if (tmp___15 < 0) {
        {
#line 1462
        tmp___13 = __errno_location();
#line 1462
        tmp___14 = strerror(*tmp___13);
#line 1462
        pr_log_pri(3, "error: getrlimit(RLIMIT_NOFILE): %s", tmp___14);
        }
      }
      {
#line 1470
      tmp___21 = strcasecmp("max", (char const   *)*(cmd->argv + 2));
      }
#line 1470
      if (tmp___21 == 0) {
        {
#line 1471
        tmp___16 = sysconf(4);
#line 1471
        rlim->rlim_cur = (rlim_t )tmp___16;
        }
      } else {
        {
#line 1477
        tmp___17 = (char *)((void *)0);
#line 1478
        tmp___18 = strtol((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& tmp___17),
                          10);
#line 1478
        num = tmp___18;
        }
#line 1480
        if (tmp___17) {
#line 1480
          if (*tmp___17) {
            {
#line 1481
            tmp___19 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                               (void *)0);
#line 1481
            tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___19);
            }
#line 1481
            return (tmp___20);
          }
        }
#line 1483
        rlim->rlim_cur = (rlim_t )num;
      }
#line 1487
      if (cmd->argc - 1 == 3) {
        {
#line 1488
        tmp___27 = strcasecmp("max", (char const   *)*(cmd->argv + 3));
        }
#line 1488
        if (tmp___27 == 0) {
          {
#line 1489
          tmp___22 = sysconf(4);
#line 1489
          rlim->rlim_max = (rlim_t )tmp___22;
          }
        } else {
          {
#line 1495
          tmp___23 = (char *)((void *)0);
#line 1496
          tmp___24 = strtol((char const   */* __restrict  */)*(cmd->argv + 3), (char **/* __restrict  */)(& tmp___23),
                            10);
#line 1496
          num___0 = tmp___24;
          }
#line 1498
          if (tmp___23) {
#line 1498
            if (*tmp___23) {
              {
#line 1499
              tmp___25 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                                 (void *)0);
#line 1499
              tmp___26 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___25);
              }
#line 1499
              return (tmp___26);
            }
          }
#line 1501
          rlim->rlim_max = (rlim_t )num___0;
        }
      }
      {
#line 1505
      c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)rlim, (void *)0);
#line 1506
      tmp___28 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 1506
      *(c->argv + 1) = (void *)tmp___28;
      }
    } else {
      {
#line 1512
      tmp___29 = pcalloc((cmd->server)->pool, (int )sizeof(struct rlimit ));
#line 1512
      rlim___0 = (struct rlimit *)tmp___29;
#line 1516
      tmp___32 = getrlimit((__rlimit_resource_t )7, rlim___0);
      }
#line 1516
      if (tmp___32 < 0) {
        {
#line 1517
        tmp___30 = __errno_location();
#line 1517
        tmp___31 = strerror(*tmp___30);
#line 1517
        pr_log_pri(3, "error: getrlimit(RLIMIT_NOFILE): %s", tmp___31);
        }
      }
      {
#line 1525
      tmp___38 = strcasecmp("max", (char const   *)*(cmd->argv + 1));
      }
#line 1525
      if (tmp___38 == 0) {
        {
#line 1526
        tmp___33 = sysconf(4);
#line 1526
        rlim___0->rlim_cur = (rlim_t )tmp___33;
        }
      } else {
        {
#line 1532
        tmp___34 = (char *)((void *)0);
#line 1533
        tmp___35 = strtol((char const   */* __restrict  */)*(cmd->argv + 1), (char **/* __restrict  */)(& tmp___34),
                          10);
#line 1533
        num___1 = tmp___35;
        }
#line 1535
        if (tmp___34) {
#line 1535
          if (*tmp___34) {
            {
#line 1536
            tmp___36 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                               (void *)0);
#line 1536
            tmp___37 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___36);
            }
#line 1536
            return (tmp___37);
          }
        }
#line 1538
        rlim___0->rlim_cur = (rlim_t )num___1;
      }
#line 1542
      if (cmd->argc - 1 == 2) {
        {
#line 1543
        tmp___44 = strcasecmp("max", (char const   *)*(cmd->argv + 2));
        }
#line 1543
        if (tmp___44 == 0) {
          {
#line 1544
          tmp___39 = sysconf(4);
#line 1544
          rlim___0->rlim_max = (rlim_t )tmp___39;
          }
        } else {
          {
#line 1550
          tmp___40 = (char *)((void *)0);
#line 1551
          tmp___41 = strtol((char const   */* __restrict  */)*(cmd->argv + 2), (char **/* __restrict  */)(& tmp___40),
                            10);
#line 1551
          num___2 = tmp___41;
          }
#line 1553
          if (tmp___40) {
#line 1553
            if (*tmp___40) {
              {
#line 1554
              tmp___42 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "badly formatted argument",
                                 (void *)0);
#line 1554
              tmp___43 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                        tmp___42);
              }
#line 1554
              return (tmp___43);
            }
          }
#line 1556
          rlim___0->rlim_max = (rlim_t )num___2;
        }
      }
      {
#line 1560
      add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)rlim___0, (void *)0);
      }
    }
  }
  {
#line 1563
  tmp___47 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1563
  return (tmp___47);
}
}
#line 1569 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_syslogfacility(cmd_rec *cmd ) 
{ 
  int i___0 ;
  struct __anonstruct_factable_84 factable[20] ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  modret_t *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  modret_t *tmp___19 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
#line 1571
  factable[0].name = (char *)"AUTH";
#line 1571
  factable[0].facility = 10 << 3;
#line 1571
  factable[1].name = (char *)"AUTHPRIV";
#line 1571
  factable[1].facility = 10 << 3;
#line 1571
  factable[2].name = (char *)"FTP";
#line 1571
  factable[2].facility = 11 << 3;
#line 1571
  factable[3].name = (char *)"CRON";
#line 1571
  factable[3].facility = 9 << 3;
#line 1571
  factable[4].name = (char *)"DAEMON";
#line 1571
  factable[4].facility = 3 << 3;
#line 1571
  factable[5].name = (char *)"KERN";
#line 1571
  factable[5].facility = 0;
#line 1571
  factable[6].name = (char *)"LOCAL0";
#line 1571
  factable[6].facility = 16 << 3;
#line 1571
  factable[7].name = (char *)"LOCAL1";
#line 1571
  factable[7].facility = 17 << 3;
#line 1571
  factable[8].name = (char *)"LOCAL2";
#line 1571
  factable[8].facility = 18 << 3;
#line 1571
  factable[9].name = (char *)"LOCAL3";
#line 1571
  factable[9].facility = 19 << 3;
#line 1571
  factable[10].name = (char *)"LOCAL4";
#line 1571
  factable[10].facility = 20 << 3;
#line 1571
  factable[11].name = (char *)"LOCAL5";
#line 1571
  factable[11].facility = 21 << 3;
#line 1571
  factable[12].name = (char *)"LOCAL6";
#line 1571
  factable[12].facility = 22 << 3;
#line 1571
  factable[13].name = (char *)"LOCAL7";
#line 1571
  factable[13].facility = 23 << 3;
#line 1571
  factable[14].name = (char *)"LPR";
#line 1571
  factable[14].facility = 6 << 3;
#line 1571
  factable[15].name = (char *)"MAIL";
#line 1571
  factable[15].facility = 2 << 3;
#line 1571
  factable[16].name = (char *)"NEWS";
#line 1571
  factable[16].facility = 7 << 3;
#line 1571
  factable[17].name = (char *)"USER";
#line 1571
  factable[17].facility = 1 << 3;
#line 1571
  factable[18].name = (char *)"UUCP";
#line 1571
  factable[18].facility = 8 << 3;
#line 1571
  factable[19].name = (char *)((void *)0);
#line 1571
  factable[19].facility = 0;
#line 1600
  if (cmd->argc - 1 < 1) {
    {
#line 1600
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1600
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1600
    return (tmp___0);
  }
  {
#line 1601
  tmp___5 = check_context(cmd, 1);
  }
#line 1601
  if (! tmp___5) {
    {
#line 1601
    tmp___1 = get_context_name(cmd);
#line 1601
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1601
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1601
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1601
    return (tmp___4);
  }
#line 1603
  i___0 = 0;
  {
#line 1603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1603
    if (! factable[i___0].name) {
#line 1603
      goto while_break;
    }
    {
#line 1604
    tmp___17 = strcasecmp((char const   *)*(cmd->argv + 1), (char const   *)factable[i___0].name);
    }
#line 1604
    if (tmp___17 == 0) {
      {
#line 1605
      log_closesyslog();
#line 1606
      log_setfacility(factable[i___0].facility);
#line 1608
      pr_signals_block();
#line 1609
      tmp___6 = log_opensyslog((char const   *)((void *)0));
      }
      {
#line 1610
      if (tmp___6 == -1) {
#line 1610
        goto case_neg_1;
      }
#line 1616
      if (tmp___6 == -2) {
#line 1616
        goto case_neg_2;
      }
#line 1622
      if (tmp___6 == -3) {
#line 1622
        goto case_neg_3;
      }
#line 1627
      goto switch_default;
      case_neg_1: /* CIL Label */ 
      {
#line 1611
      pr_signals_unblock();
#line 1612
      tmp___7 = __errno_location();
#line 1612
      tmp___8 = strerror(*tmp___7);
#line 1612
      tmp___9 = pstrcat(cmd->tmp_pool, "unable to open syslog: ", tmp___8, (void *)0);
#line 1612
      tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___9, (void *)0);
#line 1612
      tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
      }
#line 1612
      return (tmp___11);
#line 1614
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 1617
      pr_signals_unblock();
#line 1618
      tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "you are attempting to log to a world writeable directory",
                         (void *)0);
#line 1618
      tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
      }
#line 1618
      return (tmp___13);
#line 1620
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 1623
      pr_signals_unblock();
#line 1624
      tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "you are attempting to log to a symbolic link",
                         (void *)0);
#line 1624
      tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___14);
      }
#line 1624
      return (tmp___15);
#line 1625
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1628
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1630
      pr_signals_unblock();
#line 1632
      tmp___16 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
      }
#line 1632
      return (tmp___16);
    }
#line 1603
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1636
  tmp___18 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "argument must be a valid syslog facility",
                     (void *)0);
#line 1636
  tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___18);
  }
#line 1636
  return (tmp___19);
}
}
#line 1639 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_timesgmt(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1640
  bool = -1;
#line 1641
  c = (config_rec *)((void *)0);
#line 1643
  if (cmd->argc - 1 < 1) {
    {
#line 1643
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1643
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1643
    return (tmp___0);
  }
  {
#line 1644
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 1644
  if (! tmp___5) {
    {
#line 1644
    tmp___1 = get_context_name(cmd);
#line 1644
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1644
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1644
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1644
    return (tmp___4);
  }
  {
#line 1646
  bool = get_boolean(cmd, 1);
  }
#line 1647
  if (bool == -1) {
    {
#line 1648
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 1648
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 1648
    return (tmp___7);
  }
  {
#line 1650
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1651
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 1652
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 1654
  c->flags |= 1L;
#line 1656
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1656
  return (tmp___8);
}
}
#line 1659 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_regex(cmd_rec *cmd , char *param , char *type ) 
{ 
  regex_t *preg ;
  config_rec *c ;
  int res ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char errstr[200] ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  modret_t *tmp___10 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1661
  preg = (regex_t *)((void *)0);
#line 1662
  c = (config_rec *)((void *)0);
#line 1663
  res = 0;
#line 1665
  if (cmd->argc - 1 < 1) {
    {
#line 1665
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1665
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1665
    return (tmp___0);
  }
  {
#line 1666
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 1666
  if (! tmp___5) {
    {
#line 1666
    tmp___1 = get_context_name(cmd);
#line 1666
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1666
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1666
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1666
    return (tmp___4);
  }
  {
#line 1669
  pr_log_debug(4, "%s: compiling %s regex \'%s\'", *(cmd->argv + 0), type, *(cmd->argv + 1));
#line 1671
  preg = pr_regexp_alloc();
#line 1673
  res = regcomp((regex_t */* __restrict  */)preg, (char const   */* __restrict  */)*(cmd->argv + 1),
                1 | (((1 << 1) << 1) << 1));
  }
#line 1674
  if (res != 0) {
#line 1675
    errstr[0] = (char )'\000';
#line 1675
    tmp___6 = 1U;
    {
#line 1675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1675
      if (tmp___6 >= 200U) {
#line 1675
        goto while_break;
      }
#line 1675
      errstr[tmp___6] = (char)0;
#line 1675
      tmp___6 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1677
    regerror(res, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errstr),
             (size_t )sizeof(errstr));
#line 1678
    pr_regexp_free(preg);
#line 1680
    tmp___7 = pstrcat(cmd->tmp_pool, "\'", *(cmd->argv + 1), "\' failed regex compilation: ",
                      errstr, (void *)0);
#line 1680
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___7, (void *)0);
#line 1680
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 1680
    return (tmp___9);
  }
  {
#line 1684
  c = add_config_param((char const   *)param, 1, preg);
#line 1685
  c->flags |= 1L;
#line 1686
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1686
  return (tmp___10);
}
}
#line 1695 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_allowfilter(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 1696
  tmp = set_regex(cmd, *(cmd->argv + 0), (char *)"allow");
  }
#line 1696
  return (tmp);
}
}
#line 1699 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_denyfilter(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 1700
  tmp = set_regex(cmd, *(cmd->argv + 0), (char *)"deny");
  }
#line 1700
  return (tmp);
}
}
#line 1703 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_passiveports(cmd_rec *cmd ) 
{ 
  int pasv_min_port ;
  int pasv_max_port ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  modret_t *tmp___14 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 1705
  c = (config_rec *)((void *)0);
#line 1707
  if (cmd->argc - 1 < 2) {
    {
#line 1707
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1707
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1707
    return (tmp___0);
  }
  {
#line 1708
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 1708
  if (! tmp___5) {
    {
#line 1708
    tmp___1 = get_context_name(cmd);
#line 1708
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1708
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1708
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1708
    return (tmp___4);
  }
  {
#line 1710
  pasv_min_port = atoi((char const   *)*(cmd->argv + 1));
#line 1711
  pasv_max_port = atoi((char const   *)*(cmd->argv + 2));
  }
#line 1714
  if (pasv_min_port <= 0) {
    {
#line 1715
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "min port must be allowable port number",
                      (void *)0);
#line 1715
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 1715
    return (tmp___7);
  } else
#line 1714
  if (pasv_min_port > 65535) {
    {
#line 1715
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "min port must be allowable port number",
                      (void *)0);
#line 1715
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 1715
    return (tmp___7);
  }
#line 1717
  if (pasv_max_port <= 0) {
    {
#line 1718
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "max port must be allowable port number",
                      (void *)0);
#line 1718
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 1718
    return (tmp___9);
  } else
#line 1717
  if (pasv_max_port > 65535) {
    {
#line 1718
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "max port must be allowable port number",
                      (void *)0);
#line 1718
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 1718
    return (tmp___9);
  }
#line 1720
  if (pasv_min_port < 1024) {
    {
#line 1721
    tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "port numbers must be above 1023",
                       (void *)0);
#line 1721
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
    }
#line 1721
    return (tmp___11);
  } else
#line 1720
  if (pasv_max_port < 1024) {
    {
#line 1721
    tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "port numbers must be above 1023",
                       (void *)0);
#line 1721
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
    }
#line 1721
    return (tmp___11);
  }
#line 1723
  if (pasv_max_port <= pasv_min_port) {
    {
#line 1724
    tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "min port must be less than max port",
                       (void *)0);
#line 1724
    tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
    }
#line 1724
    return (tmp___13);
  }
  {
#line 1726
  c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 1727
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 1728
  *((int *)*(c->argv + 0)) = pasv_min_port;
#line 1729
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(int ));
#line 1730
  *((int *)*(c->argv + 1)) = pasv_max_port;
#line 1732
  tmp___14 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1732
  return (tmp___14);
}
}
#line 1735 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_pathallowfilter(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 1736
  tmp = set_regex(cmd, *(cmd->argv + 0), (char *)"allow");
  }
#line 1736
  return (tmp);
}
}
#line 1739 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_pathdenyfilter(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 1740
  tmp = set_regex(cmd, *(cmd->argv + 0), (char *)"deny");
  }
#line 1740
  return (tmp);
}
}
#line 1743 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_allowforeignaddress(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1744
  bool = -1;
#line 1745
  c = (config_rec *)((void *)0);
#line 1747
  if (cmd->argc - 1 < 1) {
    {
#line 1747
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1747
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1747
    return (tmp___0);
  }
  {
#line 1748
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 1748
  if (! tmp___5) {
    {
#line 1748
    tmp___1 = get_context_name(cmd);
#line 1748
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1748
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1748
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1748
    return (tmp___4);
  }
  {
#line 1750
  bool = get_boolean(cmd, 1);
  }
#line 1751
  if (bool == -1) {
    {
#line 1752
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 1752
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 1752
    return (tmp___7);
  }
  {
#line 1754
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1755
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 1756
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 1758
  c->flags |= 1L;
#line 1760
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1760
  return (tmp___8);
}
}
#line 1763 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_commandbuffersize(cmd_rec *cmd ) 
{ 
  int size ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1764
  size = 0;
#line 1765
  c = (config_rec *)((void *)0);
#line 1767
  if (cmd->argc - 1 < 1) {
    {
#line 1767
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1767
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1767
    return (tmp___0);
  }
  {
#line 1768
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 1768
  if (! tmp___5) {
    {
#line 1768
    tmp___1 = get_context_name(cmd);
#line 1768
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1768
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1768
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1768
    return (tmp___4);
  }
  {
#line 1771
  size = atoi((char const   *)*(cmd->argv + 1));
#line 1773
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1774
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 1775
  *((int *)*(c->argv + 0)) = size;
#line 1777
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1777
  return (tmp___6);
}
}
#line 1780 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_cdpath(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1781
  c = (config_rec *)((void *)0);
#line 1783
  if (cmd->argc - 1 < 1) {
    {
#line 1783
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1783
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1783
    return (tmp___0);
  }
  {
#line 1784
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 1784
  if (! tmp___5) {
    {
#line 1784
    tmp___1 = get_context_name(cmd);
#line 1784
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1784
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1784
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1784
    return (tmp___4);
  }
  {
#line 1786
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 1787
  c->flags |= 1L;
#line 1789
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1789
  return (tmp___6);
}
}
#line 1792 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_directory(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *dir ;
  char *rootdir ;
  int flags ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  unsigned char tmp___12 ;
  config_rec *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  modret_t *tmp___17 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 1794
  rootdir = (char *)((void *)0);
#line 1795
  flags = 0;
#line 1797
  if (cmd->argc - 1 < 1) {
    {
#line 1797
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 1797
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 1797
    return (tmp___0);
  }
  {
#line 1798
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 1798
  if (! tmp___5) {
    {
#line 1798
    tmp___1 = get_context_name(cmd);
#line 1798
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 1798
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 1798
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 1798
    return (tmp___4);
  }
#line 1800
  dir = *(cmd->argv + 1);
#line 1802
  if ((int )*dir != 47) {
#line 1802
    if ((int )*dir != 126) {
#line 1802
      if (! cmd->config) {
        {
#line 1806
        tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "relative path not allowed in non-<Anonymous> sections",
                          (void *)0);
#line 1806
        tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
        }
#line 1806
        return (tmp___7);
      } else
#line 1802
      if ((cmd->config)->config_type != 1 << 2) {
        {
#line 1806
        tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "relative path not allowed in non-<Anonymous> sections",
                          (void *)0);
#line 1806
        tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
        }
#line 1806
        return (tmp___7);
      }
    }
  }
#line 1814
  if (cmd->config) {
#line 1814
    if ((cmd->config)->config_type == 1 << 2) {
#line 1814
      if ((int )*dir != 47) {
#line 1814
        if ((int )*dir != 126) {
          {
#line 1818
          tmp___8 = strcmp((char const   *)dir, "*");
          }
#line 1818
          if (tmp___8 != 0) {
            {
#line 1819
            dir = pdircat(cmd->tmp_pool, "/", dir, (void *)0);
            }
          }
#line 1820
          rootdir = (cmd->config)->name;
        } else {
#line 1823
          flags |= 1 << 3;
        }
      } else {
#line 1823
        flags |= 1 << 3;
      }
    } else {
#line 1823
      flags |= 1 << 3;
    }
  } else {
#line 1823
    flags |= 1 << 3;
  }
  {
#line 1834
  tmp___12 = check_context(cmd, 1 << 2);
  }
#line 1834
  if (! tmp___12) {
    {
#line 1834
    tmp___13 = find_config((cmd->server)->conf, 1 << 1, (char const   *)dir, 0);
    }
#line 1834
    if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
      {
#line 1836
      tmp___9 = pstrcat(cmd->tmp_pool, "<Directory> section already configured for \'",
                        *(cmd->argv + 1), "\'", (void *)0);
#line 1836
      tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___9, (void *)0);
#line 1836
      tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
      }
#line 1836
      return (tmp___11);
    }
  }
  {
#line 1843
  tmp___14 = strstr((char const   *)dir, "%u");
  }
#line 1843
  if (tmp___14) {
#line 1844
    flags |= 1 << 3;
  }
  {
#line 1847
  c = pr_parser_config_ctxt_open((char const   *)dir);
#line 1848
  c->argc = 2;
#line 1849
  tmp___15 = pcalloc(c->pool, (int )(3UL * sizeof(void *)));
#line 1849
  c->argv = (void **)tmp___15;
  }
#line 1854
  if (rootdir) {
    {
#line 1855
    tmp___16 = pstrdup(c->pool, (char const   *)rootdir);
#line 1855
    *(c->argv + 1) = (void *)tmp___16;
    }
  }
#line 1858
  c->config_type = 1 << 1;
#line 1859
  c->flags |= (long )flags;
#line 1861
  if (! (c->flags & (long )(1 << 3))) {
    {
#line 1862
    pr_log_debug(2, "<Directory %s>: adding section for resolved path \'%s\'", *(cmd->argv + 1),
                 dir);
    }
  } else {
    {
#line 1866
    pr_log_debug(2, "<Directory %s>: deferring resolution of path", *(cmd->argv + 1));
    }
  }
  {
#line 1870
  tmp___17 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 1870
  return (tmp___17);
}
}
#line 1873 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_hidefiles(cmd_rec *cmd ) 
{ 
  regex_t *regexp ;
  config_rec *c ;
  int res ;
  unsigned int precedence ;
  unsigned char inverted ;
  int ctxt ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  unsigned char tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char errstr[200] ;
  unsigned int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  array_header *acl ;
  int argc ;
  char **argv ;
  void *tmp___19 ;
  void *tmp___20 ;
  char **tmp___21 ;
  void *tmp___22 ;
  char **tmp___23 ;
  void *tmp___24 ;
  char **tmp___25 ;
  char **tmp___26 ;
  char **tmp___27 ;
  int tmp___28 ;
  modret_t *tmp___29 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 1875
  regexp = (regex_t *)((void *)0);
#line 1876
  c = (config_rec *)((void *)0);
#line 1878
  precedence = 0U;
#line 1879
  inverted = (unsigned char)0;
#line 1881
  if (cmd->config) {
#line 1881
    if ((cmd->config)->config_type != 1 << 15) {
#line 1881
      tmp___0 = (cmd->config)->config_type;
    } else {
#line 1881
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1881
    if ((cmd->server)->config_type) {
#line 1881
      tmp = (cmd->server)->config_type;
    } else {
#line 1881
      tmp = 1;
    }
#line 1881
    tmp___0 = tmp;
  }
#line 1881
  ctxt = tmp___0;
#line 1886
  if (cmd->argc - 1 != 1) {
#line 1886
    if (cmd->argc - 1 != 3) {
      {
#line 1887
      tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                        (void *)0);
#line 1887
      tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
      }
#line 1887
      return (tmp___2);
    }
  }
  {
#line 1889
  tmp___7 = check_context(cmd, (1 << 1) | (1 << 5));
  }
#line 1889
  if (! tmp___7) {
    {
#line 1889
    tmp___3 = get_context_name(cmd);
#line 1889
    tmp___4 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___3, " context",
                      (void *)0);
#line 1889
    tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___4, (void *)0);
#line 1889
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
    }
#line 1889
    return (tmp___6);
  }
#line 1894
  if (ctxt & (1 << 1)) {
#line 1895
    precedence = 1U;
  } else {
#line 1898
    precedence = 2U;
  }
  {
#line 1903
  tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "none");
  }
#line 1903
  if (tmp___9 == 0) {
    {
#line 1904
    pr_log_debug(4, "setting %s to NULL", *(cmd->argv + 0));
#line 1905
    c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 1906
    c->flags |= (long )(1 << 1);
#line 1907
    tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
    }
#line 1907
    return (tmp___8);
  }
#line 1911
  if ((int )*(*(cmd->argv + 1)) == 33) {
#line 1912
    inverted = (unsigned char)1;
#line 1913
    (*(cmd->argv + 1)) ++;
  }
  {
#line 1916
  regexp = pr_regexp_alloc();
#line 1918
  res = regcomp((regex_t */* __restrict  */)regexp, (char const   */* __restrict  */)*(cmd->argv + 1),
                1 | (((1 << 1) << 1) << 1));
  }
#line 1919
  if (res != 0) {
#line 1920
    errstr[0] = (char )'\000';
#line 1920
    tmp___10 = 1U;
    {
#line 1920
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1920
      if (tmp___10 >= 200U) {
#line 1920
        goto while_break;
      }
#line 1920
      errstr[tmp___10] = (char)0;
#line 1920
      tmp___10 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1922
    regerror(res, (regex_t const   */* __restrict  */)regexp, (char */* __restrict  */)(errstr),
             (size_t )sizeof(errstr));
#line 1923
    pr_regexp_free(regexp);
#line 1925
    tmp___11 = pstrcat(cmd->tmp_pool, "\'", *(cmd->argv + 1), "\' failed regex compilation: ",
                       errstr, (void *)0);
#line 1925
    tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___11, (void *)0);
#line 1925
    tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
    }
#line 1925
    return (tmp___13);
  }
#line 1933
  if (cmd->argc - 1 == 3) {
    {
#line 1934
    tmp___16 = strcmp((char const   *)*(cmd->argv + 2), "user");
    }
#line 1934
    if (! (tmp___16 == 0)) {
      {
#line 1934
      tmp___17 = strcmp((char const   *)*(cmd->argv + 2), "group");
      }
#line 1934
      if (! (tmp___17 == 0)) {
        {
#line 1934
        tmp___18 = strcmp((char const   *)*(cmd->argv + 2), "class");
        }
#line 1934
        if (! (tmp___18 == 0)) {
          {
#line 1941
          tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": unknown classifier used: \'",
                             *(cmd->argv + 2), "\'", (void *)0);
#line 1941
          tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___14);
          }
#line 1941
          return (tmp___15);
        }
      }
    }
  }
#line 1945
  if (cmd->argc - 1 == 1) {
    {
#line 1946
    c = add_config_param((char const   *)*(cmd->argv + 0), 3, (void *)0, (void *)0,
                         (void *)0);
#line 1947
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(regex_t *));
#line 1948
    *((regex_t **)*(c->argv + 0)) = regexp;
#line 1949
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 1950
    *((unsigned char *)*(c->argv + 1)) = inverted;
#line 1951
    *(c->argv + 2) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 1952
    *((unsigned int *)*(c->argv + 2)) = precedence;
    }
  } else
#line 1954
  if (cmd->argc - 1 == 3) {
    {
#line 1955
    acl = (array_header *)((void *)0);
#line 1956
    argc = cmd->argc - 3;
#line 1957
    argv = cmd->argv + 2;
#line 1959
    acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 1961
    c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 1962
    c->argc = argc + 4;
#line 1968
    tmp___19 = pcalloc(c->pool, (int )((unsigned long )(argc + 5) * sizeof(char *)));
#line 1968
    c->argv = (void **)tmp___19;
#line 1973
    argv = (char **)c->argv;
#line 1976
    tmp___20 = pcalloc(c->pool, (int )sizeof(regex_t *));
#line 1976
    *argv = (char *)tmp___20;
#line 1977
    tmp___21 = argv;
#line 1977
    argv ++;
#line 1977
    *((regex_t **)*tmp___21) = regexp;
#line 1980
    tmp___22 = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 1980
    *argv = (char *)tmp___22;
#line 1981
    tmp___23 = argv;
#line 1981
    argv ++;
#line 1981
    *((unsigned char *)*tmp___23) = inverted;
#line 1984
    tmp___24 = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 1984
    *argv = (char *)tmp___24;
#line 1985
    tmp___25 = argv;
#line 1985
    argv ++;
#line 1985
    *((unsigned int *)*tmp___25) = precedence;
#line 1988
    tmp___26 = argv;
#line 1988
    argv ++;
#line 1988
    *tmp___26 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
    }
#line 1991
    if (argc) {
#line 1991
      if (acl) {
        {
#line 1992
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1992
          tmp___28 = argc;
#line 1992
          argc --;
#line 1992
          if (! tmp___28) {
#line 1992
            goto while_break___0;
          }
          {
#line 1993
          tmp___27 = argv;
#line 1993
          argv ++;
#line 1993
          *tmp___27 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 1994
          acl->elts = (void *)((char **)acl->elts + 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1999
    *argv = (char *)((void *)0);
  }
  {
#line 2002
  c->flags |= (long )(1 << 1);
#line 2003
  tmp___29 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2003
  return (tmp___29);
}
}
#line 2012 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_hidenoaccess(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2013
  bool = -1;
#line 2014
  c = (config_rec *)((void *)0);
#line 2016
  if (cmd->argc - 1 < 1) {
    {
#line 2016
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2016
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2016
    return (tmp___0);
  }
  {
#line 2017
  tmp___5 = check_context(cmd, (1 << 2) | (1 << 1));
  }
#line 2017
  if (! tmp___5) {
    {
#line 2017
    tmp___1 = get_context_name(cmd);
#line 2017
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2017
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2017
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2017
    return (tmp___4);
  }
  {
#line 2019
  bool = get_boolean(cmd, 1);
  }
#line 2020
  if (bool == -1) {
    {
#line 2021
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2021
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2021
    return (tmp___7);
  }
  {
#line 2023
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2024
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2025
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2026
  c->flags |= 1L;
#line 2028
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2028
  return (tmp___8);
}
}
#line 2031 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_hideuser(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *user ;
  struct passwd *pw ;
  unsigned char inverted ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 2032
  c = (config_rec *)((void *)0);
#line 2033
  user = (char *)((void *)0);
#line 2034
  pw = (struct passwd *)((void *)0);
#line 2035
  inverted = (unsigned char)0;
#line 2037
  if (cmd->argc - 1 < 1) {
    {
#line 2037
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2037
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2037
    return (tmp___0);
  }
  {
#line 2038
  tmp___5 = check_context(cmd, (1 << 2) | (1 << 1));
  }
#line 2038
  if (! tmp___5) {
    {
#line 2038
    tmp___1 = get_context_name(cmd);
#line 2038
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2038
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2038
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2038
    return (tmp___4);
  }
#line 2040
  user = *(cmd->argv + 1);
#line 2042
  if ((int )*user == 33) {
#line 2043
    inverted = (unsigned char)1;
#line 2044
    user ++;
  }
  {
#line 2047
  pw = pr_auth_getpwnam(cmd->tmp_pool, (char const   *)user);
  }
#line 2049
  if (! pw) {
    {
#line 2050
    tmp___6 = pstrcat(cmd->tmp_pool, "\'", user, "\' is not a valid user", (void *)0);
#line 2050
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2050
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2050
    return (tmp___8);
  }
  {
#line 2053
  c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2054
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(uid_t ));
#line 2055
  *((uid_t *)*(c->argv + 0)) = pw->pw_uid;
#line 2056
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2057
  *((unsigned char *)*(c->argv + 1)) = inverted;
#line 2059
  c->flags |= 1L;
#line 2060
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2060
  return (tmp___9);
}
}
#line 2063 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_hidegroup(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *group ;
  struct group *gr ;
  unsigned char inverted ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 2064
  c = (config_rec *)((void *)0);
#line 2065
  group = (char *)((void *)0);
#line 2066
  gr = (struct group *)((void *)0);
#line 2067
  inverted = (unsigned char)0;
#line 2069
  if (cmd->argc - 1 < 1) {
    {
#line 2069
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2069
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2069
    return (tmp___0);
  }
  {
#line 2070
  tmp___5 = check_context(cmd, (1 << 2) | (1 << 1));
  }
#line 2070
  if (! tmp___5) {
    {
#line 2070
    tmp___1 = get_context_name(cmd);
#line 2070
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2070
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2070
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2070
    return (tmp___4);
  }
#line 2072
  group = *(cmd->argv + 1);
#line 2074
  if ((int )*group == 33) {
#line 2075
    inverted = (unsigned char)1;
#line 2076
    group ++;
  }
  {
#line 2079
  gr = pr_auth_getgrnam(cmd->tmp_pool, (char const   *)group);
  }
#line 2081
  if (! gr) {
    {
#line 2082
    tmp___6 = pstrcat(cmd->tmp_pool, "\'", group, "\' is not a valid group", (void *)0);
#line 2082
    tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2082
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
    }
#line 2082
    return (tmp___8);
  }
  {
#line 2085
  c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2086
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(gid_t ));
#line 2087
  *((gid_t *)*(c->argv + 0)) = gr->gr_gid;
#line 2088
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2089
  *((unsigned char *)*(c->argv + 1)) = inverted;
#line 2091
  c->flags |= 1L;
#line 2092
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2092
  return (tmp___9);
}
}
#line 2095 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_groupowner(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2096
  c = (config_rec *)((void *)0);
#line 2098
  if (cmd->argc - 1 < 1) {
    {
#line 2098
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2098
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2098
    return (tmp___0);
  }
  {
#line 2099
  tmp___5 = check_context(cmd, ((1 << 2) | (1 << 1)) | (1 << 5));
  }
#line 2099
  if (! tmp___5) {
    {
#line 2099
    tmp___1 = get_context_name(cmd);
#line 2099
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2099
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2099
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2099
    return (tmp___4);
  }
  {
#line 2101
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2102
  c->flags |= 1L;
#line 2104
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2104
  return (tmp___6);
}
}
#line 2107 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_userowner(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2108
  c = (config_rec *)((void *)0);
#line 2110
  if (cmd->argc - 1 < 1) {
    {
#line 2110
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2110
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2110
    return (tmp___0);
  }
  {
#line 2111
  tmp___5 = check_context(cmd, (1 << 2) | (1 << 1));
  }
#line 2111
  if (! tmp___5) {
    {
#line 2111
    tmp___1 = get_context_name(cmd);
#line 2111
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2111
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2111
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2111
    return (tmp___4);
  }
  {
#line 2113
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2114
  c->flags |= 1L;
#line 2116
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2116
  return (tmp___6);
}
}
#line 2119 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_allowoverride(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  unsigned int precedence ;
  int ctxt ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  modret_t *tmp___6 ;
  unsigned char tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  array_header *acl ;
  int argc ;
  char **argv ;
  void *tmp___15 ;
  void *tmp___16 ;
  char **tmp___17 ;
  void *tmp___18 ;
  char **tmp___19 ;
  char **tmp___20 ;
  char **tmp___21 ;
  int tmp___22 ;
  modret_t *tmp___23 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 2120
  bool = -1;
#line 2121
  c = (config_rec *)((void *)0);
#line 2122
  precedence = 0U;
#line 2124
  if (cmd->config) {
#line 2124
    if ((cmd->config)->config_type != 1 << 15) {
#line 2124
      tmp___0 = (cmd->config)->config_type;
    } else {
#line 2124
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2124
    if ((cmd->server)->config_type) {
#line 2124
      tmp = (cmd->server)->config_type;
    } else {
#line 2124
      tmp = 1;
    }
#line 2124
    tmp___0 = tmp;
  }
#line 2124
  ctxt = tmp___0;
#line 2129
  if (cmd->argc - 1 != 1) {
#line 2129
    if (cmd->argc - 1 != 3) {
      {
#line 2130
      tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments",
                        (void *)0);
#line 2130
      tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
      }
#line 2130
      return (tmp___2);
    }
  }
  {
#line 2132
  tmp___7 = check_context(cmd, (((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1));
  }
#line 2132
  if (! tmp___7) {
    {
#line 2132
    tmp___3 = get_context_name(cmd);
#line 2132
    tmp___4 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___3, " context",
                      (void *)0);
#line 2132
    tmp___5 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___4, (void *)0);
#line 2132
    tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___5);
    }
#line 2132
    return (tmp___6);
  }
  {
#line 2134
  bool = get_boolean(cmd, 1);
  }
#line 2135
  if (bool == -1) {
    {
#line 2136
    tmp___8 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2136
    tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___8);
    }
#line 2136
    return (tmp___9);
  }
#line 2141
  if (ctxt & (1 << 6)) {
#line 2142
    precedence = 1U;
  } else
#line 2145
  if (ctxt & 1) {
#line 2146
    precedence = 2U;
  } else
#line 2145
  if (ctxt & (1 << 4)) {
#line 2146
    precedence = 2U;
  } else
#line 2148
  if (ctxt & (1 << 2)) {
#line 2149
    precedence = 3U;
  } else
#line 2151
  if (ctxt & (1 << 1)) {
#line 2152
    precedence = 4U;
  }
#line 2158
  if (cmd->argc - 1 == 3) {
    {
#line 2159
    tmp___12 = strcmp((char const   *)*(cmd->argv + 2), "user");
    }
#line 2159
    if (! (tmp___12 == 0)) {
      {
#line 2159
      tmp___13 = strcmp((char const   *)*(cmd->argv + 2), "group");
      }
#line 2159
      if (! (tmp___13 == 0)) {
        {
#line 2159
        tmp___14 = strcmp((char const   *)*(cmd->argv + 2), "class");
        }
#line 2159
        if (! (tmp___14 == 0)) {
          {
#line 2166
          tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": unknown classifier used: \'",
                             *(cmd->argv + 2), "\'", (void *)0);
#line 2166
          tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
          }
#line 2166
          return (tmp___11);
        }
      }
    }
  }
#line 2170
  if (cmd->argc - 1 == 1) {
    {
#line 2171
    c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2172
    *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 2173
    *((int *)*(c->argv + 0)) = bool;
#line 2174
    *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2175
    *((unsigned int *)*(c->argv + 1)) = precedence;
    }
  }
#line 2177
  if (cmd->argc - 1 == 3) {
    {
#line 2178
    acl = (array_header *)((void *)0);
#line 2179
    argc = cmd->argc - 3;
#line 2180
    argv = cmd->argv + 2;
#line 2182
    acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2184
    c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2185
    c->argc = argc + 3;
#line 2191
    tmp___15 = pcalloc(c->pool, (int )((unsigned long )(argc + 4) * sizeof(char *)));
#line 2191
    c->argv = (void **)tmp___15;
#line 2196
    argv = (char **)c->argv;
#line 2199
    tmp___16 = pcalloc(c->pool, (int )sizeof(int ));
#line 2199
    *argv = (char *)tmp___16;
#line 2200
    tmp___17 = argv;
#line 2200
    argv ++;
#line 2200
    *((int *)*tmp___17) = bool;
#line 2203
    tmp___18 = pcalloc(c->pool, (int )sizeof(unsigned int ));
#line 2203
    *argv = (char *)tmp___18;
#line 2204
    tmp___19 = argv;
#line 2204
    argv ++;
#line 2204
    *((unsigned int *)*tmp___19) = precedence;
#line 2207
    tmp___20 = argv;
#line 2207
    argv ++;
#line 2207
    *tmp___20 = pstrdup(c->pool, (char const   *)*(cmd->argv + 2));
    }
#line 2210
    if (argc) {
#line 2210
      if (acl) {
        {
#line 2211
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2211
          tmp___22 = argc;
#line 2211
          argc --;
#line 2211
          if (! tmp___22) {
#line 2211
            goto while_break;
          }
          {
#line 2212
          tmp___21 = argv;
#line 2212
          argv ++;
#line 2212
          *tmp___21 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2213
          acl->elts = (void *)((char **)acl->elts + 1);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 2218
    *argv = (char *)((void *)0);
  }
  {
#line 2221
  c->flags |= (long )(1 << 1);
#line 2223
  tmp___23 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2223
  return (tmp___23);
}
}
#line 2226 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_directory(cmd_rec *cmd ) 
{ 
  int empty_ctxt ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2227
  empty_ctxt = 0;
#line 2229
  if (cmd->argc - 1 < 0) {
    {
#line 2229
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2229
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2229
    return (tmp___0);
  }
  {
#line 2230
  tmp___5 = check_context(cmd, 1 << 1);
  }
#line 2230
  if (! tmp___5) {
    {
#line 2230
    tmp___1 = get_context_name(cmd);
#line 2230
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2230
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2230
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2230
    return (tmp___4);
  }
  {
#line 2232
  pr_parser_config_ctxt_close(& empty_ctxt);
  }
#line 2234
  if (empty_ctxt) {
    {
#line 2235
    pr_log_debug(3, "%s: ignoring empty section", *(cmd->argv + 0));
    }
  }
  {
#line 2237
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2237
  return (tmp___6);
}
}
#line 2240 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_anonymous(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *dir ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  modret_t *tmp___22 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 2241
  c = (config_rec *)((void *)0);
#line 2244
  if (cmd->argc - 1 < 1) {
    {
#line 2244
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2244
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2244
    return (tmp___0);
  }
  {
#line 2245
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2245
  if (! tmp___5) {
    {
#line 2245
    tmp___1 = get_context_name(cmd);
#line 2245
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2245
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2245
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2245
    return (tmp___4);
  }
#line 2247
  dir = *(cmd->argv + 1);
#line 2249
  if ((int )*dir != 47) {
#line 2249
    if ((int )*dir != 126) {
      {
#line 2250
      tmp___6 = pstrcat(cmd->tmp_pool, "(", dir, ") absolute pathname required", (void *)0);
#line 2250
      tmp___7 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___6, (void *)0);
#line 2250
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___7);
      }
#line 2250
      return (tmp___8);
    }
  }
  {
#line 2253
  tmp___12 = strchr((char const   *)dir, '*');
  }
#line 2253
  if (tmp___12) {
    {
#line 2254
    tmp___9 = pstrcat(cmd->tmp_pool, "(", dir, ") wildcards not allowed in pathname",
                      (void *)0);
#line 2254
    tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___9, (void *)0);
#line 2254
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___10);
    }
#line 2254
    return (tmp___11);
  }
  {
#line 2257
  tmp___15 = strcmp((char const   *)dir, "/");
  }
#line 2257
  if (tmp___15 == 0) {
    {
#line 2258
    tmp___13 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "\'/\' not permitted for anonymous root directory",
                       (void *)0);
#line 2258
    tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___13);
    }
#line 2258
    return (tmp___14);
  }
  {
#line 2260
  tmp___16 = strlen((char const   *)dir);
  }
#line 2260
  if ((int )*((dir + tmp___16) - 1) != 47) {
    {
#line 2261
    dir = pstrcat(cmd->tmp_pool, dir, "/", (void *)0);
    }
  }
#line 2263
  if (! dir) {
    {
#line 2264
    tmp___17 = __errno_location();
#line 2264
    tmp___18 = strerror(*tmp___17);
#line 2264
    tmp___19 = pstrcat(cmd->tmp_pool, *(cmd->argv + 1), ": ", tmp___18, (void *)0);
#line 2264
    tmp___20 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___19, (void *)0);
#line 2264
    tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___20);
    }
#line 2264
    return (tmp___21);
  }
  {
#line 2267
  c = pr_parser_config_ctxt_open((char const   *)dir);
#line 2269
  c->config_type = 1 << 2;
#line 2270
  tmp___22 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2270
  return (tmp___22);
}
}
#line 2273 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_anonymous(cmd_rec *cmd ) 
{ 
  int empty_ctxt ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2274
  empty_ctxt = 0;
#line 2276
  if (cmd->argc - 1 < 0) {
    {
#line 2276
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2276
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2276
    return (tmp___0);
  }
  {
#line 2277
  tmp___5 = check_context(cmd, 1 << 2);
  }
#line 2277
  if (! tmp___5) {
    {
#line 2277
    tmp___1 = get_context_name(cmd);
#line 2277
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2277
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2277
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2277
    return (tmp___4);
  }
  {
#line 2279
  pr_parser_config_ctxt_close(& empty_ctxt);
  }
#line 2281
  if (empty_ctxt) {
    {
#line 2282
    pr_log_debug(3, "%s: ignoring empty section", *(cmd->argv + 0));
    }
  }
  {
#line 2284
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2284
  return (tmp___6);
}
}
#line 2287 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_class(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  modret_t *tmp___10 ;
  int tmp___11 ;
  modret_t *tmp___12 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 2288
  if (cmd->argc - 1 < 1) {
    {
#line 2288
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2288
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2288
    return (tmp___0);
  }
  {
#line 2289
  tmp___5 = check_context(cmd, 1);
  }
#line 2289
  if (! tmp___5) {
    {
#line 2289
    tmp___1 = get_context_name(cmd);
#line 2289
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2289
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2289
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2289
    return (tmp___4);
  }
  {
#line 2291
  tmp___11 = pr_class_open(main_server->pool, (char const   *)*(cmd->argv + 1));
  }
#line 2291
  if (tmp___11 < 0) {
    {
#line 2292
    tmp___6 = __errno_location();
#line 2292
    tmp___7 = strerror(*tmp___6);
#line 2292
    tmp___8 = pstrcat(cmd->tmp_pool, "error creating <Class ", *(cmd->argv + 1), ">: ",
                      tmp___7, (void *)0);
#line 2292
    tmp___9 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___8, (void *)0);
#line 2292
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___9);
    }
#line 2292
    return (tmp___10);
  }
  {
#line 2295
  tmp___12 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2295
  return (tmp___12);
}
}
#line 2298 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_class(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  int tmp___6 ;
  modret_t *tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2299
  if (cmd->argc - 1 < 0) {
    {
#line 2299
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2299
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2299
    return (tmp___0);
  }
  {
#line 2300
  tmp___5 = check_context(cmd, 1 << 7);
  }
#line 2300
  if (! tmp___5) {
    {
#line 2300
    tmp___1 = get_context_name(cmd);
#line 2300
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2300
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2300
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2300
    return (tmp___4);
  }
  {
#line 2302
  tmp___6 = pr_class_close();
  }
#line 2302
  if (tmp___6 < 0) {
    {
#line 2303
    pr_log_pri(4, "warning: empty <Class> definition");
    }
  }
  {
#line 2305
  tmp___7 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2305
  return (tmp___7);
}
}
#line 2308 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_global(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2309
  c = (config_rec *)((void *)0);
#line 2311
  if (cmd->argc - 1 != 0) {
    {
#line 2312
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "Too many parameters", (void *)0);
#line 2312
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2312
    return (tmp___0);
  }
  {
#line 2313
  tmp___5 = check_context(cmd, 1 | (1 << 4));
  }
#line 2313
  if (! tmp___5) {
    {
#line 2313
    tmp___1 = get_context_name(cmd);
#line 2313
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2313
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2313
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2313
    return (tmp___4);
  }
  {
#line 2315
  c = pr_parser_config_ctxt_open((char const   *)*(cmd->argv + 0));
#line 2316
  c->config_type = 1 << 6;
#line 2318
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2318
  return (tmp___6);
}
}
#line 2321 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_global(cmd_rec *cmd ) 
{ 
  int empty_ctxt ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2322
  empty_ctxt = 0;
#line 2324
  if (cmd->argc - 1 < 0) {
    {
#line 2324
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2324
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2324
    return (tmp___0);
  }
  {
#line 2325
  tmp___5 = check_context(cmd, 1 << 6);
  }
#line 2325
  if (! tmp___5) {
    {
#line 2325
    tmp___1 = get_context_name(cmd);
#line 2325
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2325
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2325
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2325
    return (tmp___4);
  }
  {
#line 2327
  pr_parser_config_ctxt_close(& empty_ctxt);
  }
#line 2329
  if (empty_ctxt) {
    {
#line 2330
    pr_log_debug(3, "%s: ignoring empty section", *(cmd->argv + 0));
    }
  }
  {
#line 2332
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2332
  return (tmp___6);
}
}
#line 2335 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_limit(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int cargc ;
  char **cargv ;
  array_header *list ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *ent ;
  char *str ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 2336
  c = (config_rec *)((void *)0);
#line 2341
  if (cmd->argc < 2) {
    {
#line 2342
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "directive requires one or more commands",
                  (void *)0);
#line 2342
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2342
    return (tmp___0);
  }
  {
#line 2343
  tmp___5 = check_context(cmd, ((((1 | (1 << 4)) | (1 << 1)) | (1 << 2)) | (1 << 5)) | (1 << 6));
  }
#line 2343
  if (! tmp___5) {
    {
#line 2343
    tmp___1 = get_context_name(cmd);
#line 2343
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2343
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2343
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2343
    return (tmp___4);
  }
  {
#line 2345
  c = pr_parser_config_ctxt_open("Limit");
#line 2346
  c->config_type = 1 << 3;
#line 2347
  cargc = cmd->argc;
#line 2348
  cargv = cmd->argv;
#line 2350
  list = make_array(c->pool, (unsigned int )(c->argc + 1), (size_t )sizeof(void *));
  }
  {
#line 2352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2352
    tmp___8 = cargc;
#line 2352
    cargc --;
#line 2352
    if (tmp___8) {
#line 2352
      cargv ++;
#line 2352
      if (! *cargv) {
#line 2352
        goto while_break;
      }
    } else {
#line 2352
      goto while_break;
    }
    {
#line 2353
    ent = (char *)((void *)0);
#line 2354
    tmp___6 = pstrdup(cmd->tmp_pool, (char const   *)*cargv);
#line 2354
    str = tmp___6;
    }
    {
#line 2356
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2356
      ent = pr_str_get_token(& str, (char *)",");
      }
#line 2356
      if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 2356
        goto while_break___0;
      }
      {
#line 2357
      pr_signals_handle();
      }
#line 2359
      if (*ent) {
        {
#line 2360
        tmp___7 = push_array(list);
#line 2360
        *((char **)tmp___7) = pstrdup(c->pool, (char const   *)ent);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2365
  c->argc = list->nelts;
#line 2366
  c->argv = (void **)list->elts;
#line 2368
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2368
  return (tmp___9);
}
}
#line 2371 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_order(cmd_rec *cmd ) 
{ 
  int order ;
  int argc ;
  char *arg ;
  char **argv ;
  config_rec *c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 2372
  order = -1;
#line 2372
  argc = cmd->argc;
#line 2373
  arg = (char *)"";
#line 2373
  argv = cmd->argv + 1;
#line 2374
  c = (config_rec *)((void *)0);
#line 2376
  tmp___3 = check_context(cmd, 1 << 3);
  }
#line 2376
  if (! tmp___3) {
    {
#line 2376
    tmp = get_context_name(cmd);
#line 2376
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2376
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2376
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2376
    return (tmp___2);
  }
  {
#line 2378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2378
    argc --;
#line 2378
    if (argc) {
#line 2378
      if (! *argv) {
#line 2378
        goto while_break;
      }
    } else {
#line 2378
      goto while_break;
    }
    {
#line 2379
    tmp___4 = argv;
#line 2379
    argv ++;
#line 2379
    arg = pstrcat(cmd->tmp_pool, arg, *tmp___4, (void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2381
  tmp___9 = strcasecmp((char const   *)arg, "allow,deny");
  }
#line 2381
  if (tmp___9 == 0) {
#line 2382
    order = 0;
  } else {
    {
#line 2384
    tmp___8 = strcasecmp((char const   *)arg, "deny,allow");
    }
#line 2384
    if (tmp___8 == 0) {
#line 2385
      order = 1;
    } else {
      {
#line 2388
      tmp___5 = pstrcat(cmd->tmp_pool, "\'", arg, "\': invalid argument", (void *)0);
#line 2388
      tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___5, (void *)0);
#line 2388
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
      }
#line 2388
      return (tmp___7);
    }
  }
  {
#line 2391
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2392
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(int ));
#line 2393
  *((int *)*(c->argv + 0)) = order;
#line 2395
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2395
  return (tmp___10);
}
}
#line 2398 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_allowdenyusergroupclass(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char **argv ;
  int argc ;
  int eval_type ;
  array_header *acl ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  regex_t *preg ;
  int res ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char errstr[200] ;
  unsigned int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  modret_t *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  char **tmp___21 ;
  int tmp___22 ;
  modret_t *tmp___23 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 2404
  tmp___3 = check_context(cmd, 1 << 3);
  }
#line 2404
  if (! tmp___3) {
    {
#line 2404
    tmp = get_context_name(cmd);
#line 2404
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2404
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2404
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2404
    return (tmp___2);
  }
#line 2406
  if (cmd->argc < 2) {
    {
#line 2407
    tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                      (void *)0);
#line 2407
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
    }
#line 2407
    return (tmp___5);
  }
  {
#line 2412
  tmp___6 = strcmp((char const   *)*(cmd->argv + 0), "AllowClass");
  }
#line 2412
  if (tmp___6 == 0) {
#line 2416
    eval_type = 1;
  } else {
    {
#line 2412
    tmp___7 = strcmp((char const   *)*(cmd->argv + 0), "AllowUser");
    }
#line 2412
    if (tmp___7 == 0) {
#line 2416
      eval_type = 1;
    } else {
      {
#line 2412
      tmp___8 = strcmp((char const   *)*(cmd->argv + 0), "DenyClass");
      }
#line 2412
      if (tmp___8 == 0) {
#line 2416
        eval_type = 1;
      } else {
        {
#line 2412
        tmp___9 = strcmp((char const   *)*(cmd->argv + 0), "DenyUser");
        }
#line 2412
        if (tmp___9 == 0) {
#line 2416
          eval_type = 1;
        } else {
#line 2420
          eval_type = 0;
        }
      }
    }
  }
#line 2422
  if (cmd->argc > 2) {
    {
#line 2426
    tmp___19 = strcasecmp((char const   *)*(cmd->argv + 1), "AND");
    }
#line 2426
    if (tmp___19 == 0) {
#line 2427
      eval_type = 0;
#line 2428
      argc = cmd->argc - 2;
#line 2429
      argv = cmd->argv + 1;
    } else {
      {
#line 2431
      tmp___18 = strcasecmp((char const   *)*(cmd->argv + 1), "OR");
      }
#line 2431
      if (tmp___18 == 0) {
#line 2432
        eval_type = 1;
#line 2433
        argc = cmd->argc - 2;
#line 2434
        argv = cmd->argv + 1;
      } else {
        {
#line 2436
        tmp___17 = strcasecmp((char const   *)*(cmd->argv + 1), "regex");
        }
#line 2436
        if (tmp___17 == 0) {
#line 2441
          if (cmd->argc != 3) {
            {
#line 2442
            tmp___10 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                               (void *)0);
#line 2442
            tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___10);
            }
#line 2442
            return (tmp___11);
          }
          {
#line 2444
          preg = pr_regexp_alloc();
#line 2446
          res = regcomp((regex_t */* __restrict  */)preg, (char const   */* __restrict  */)*(cmd->argv + 2),
                        1 | (((1 << 1) << 1) << 1));
          }
#line 2447
          if (res != 0) {
#line 2448
            errstr[0] = (char )'\000';
#line 2448
            tmp___12 = 1U;
            {
#line 2448
            while (1) {
              while_continue: /* CIL Label */ ;
#line 2448
              if (tmp___12 >= 200U) {
#line 2448
                goto while_break;
              }
#line 2448
              errstr[tmp___12] = (char)0;
#line 2448
              tmp___12 ++;
            }
            while_break: /* CIL Label */ ;
            }
            {
#line 2450
            regerror(res, (regex_t const   */* __restrict  */)preg, (char */* __restrict  */)(errstr),
                     (size_t )sizeof(errstr));
#line 2451
            pr_regexp_free(preg);
#line 2453
            tmp___13 = pstrcat(cmd->tmp_pool, "\'", *(cmd->argv + 2), "\' failed regex compilation: ",
                               errstr, (void *)0);
#line 2453
            tmp___14 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___13, (void *)0);
#line 2453
            tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0),
                                      tmp___14);
            }
#line 2453
            return (tmp___15);
          }
          {
#line 2457
          c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2458
          *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2459
          *((unsigned char *)*(c->argv + 0)) = (unsigned char)2;
#line 2460
          *(c->argv + 1) = (void *)preg;
#line 2462
          tmp___16 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
          }
#line 2462
          return (tmp___16);
        } else {
#line 2470
          argc = cmd->argc - 1;
#line 2471
          argv = cmd->argv;
        }
      }
    }
  } else {
#line 2475
    argc = cmd->argc - 1;
#line 2476
    argv = cmd->argv;
  }
  {
#line 2479
  acl = pr_expr_create(cmd->tmp_pool, & argc, argv);
#line 2481
  c = add_config_param((char const   *)*(cmd->argv + 0), 0);
#line 2483
  c->argc = acl->nelts + 1;
#line 2484
  tmp___20 = pcalloc(c->pool, (int )((unsigned long )(c->argc + 1) * sizeof(char *)));
#line 2484
  c->argv = (void **)tmp___20;
#line 2486
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2487
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )eval_type;
#line 2489
  argv = (char **)c->argv + 1;
  }
#line 2491
  if (acl) {
    {
#line 2492
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2492
      tmp___22 = acl->nelts;
#line 2492
      (acl->nelts) --;
#line 2492
      if (! tmp___22) {
#line 2492
        goto while_break___0;
      }
      {
#line 2493
      tmp___21 = argv;
#line 2493
      argv ++;
#line 2493
      *tmp___21 = pstrdup(c->pool, (char const   *)*((char **)acl->elts));
#line 2494
      acl->elts = (void *)((char **)acl->elts + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2498
  *argv = (char *)((void *)0);
#line 2500
  tmp___23 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2500
  return (tmp___23);
}
}
#line 2503 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_allowdeny(cmd_rec *cmd ) 
{ 
  int argc ;
  char **argv ;
  pr_netacl_t **aclargv ;
  array_header *list ;
  config_rec *c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  modret_t *tmp___2 ;
  unsigned char tmp___3 ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *ent ;
  char *s ;
  char *tmp___12 ;
  pr_netacl_t *acl ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  modret_t *tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  modret_t *tmp___24 ;
  void *tmp___25 ;
  pr_netacl_t **tmp___26 ;
  int tmp___27 ;
  modret_t *tmp___28 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 2510
  tmp___3 = check_context(cmd, 1 << 3);
  }
#line 2510
  if (! tmp___3) {
    {
#line 2510
    tmp = get_context_name(cmd);
#line 2510
    tmp___0 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp, " context",
                      (void *)0);
#line 2510
    tmp___1 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___0, (void *)0);
#line 2510
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___1);
    }
#line 2510
    return (tmp___2);
  }
  {
#line 2513
  list = make_array(cmd->tmp_pool, (unsigned int )cmd->argc, (size_t )sizeof(pr_netacl_t *));
#line 2514
  argc = cmd->argc - 1;
#line 2515
  argv = cmd->argv;
#line 2517
  c = add_config_param((char const   *)*(cmd->argv + 0), 0);
  }
  {
#line 2523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2523
    if (argc) {
#line 2523
      if (! *(argv + 1)) {
#line 2523
        goto while_break;
      }
    } else {
#line 2523
      goto while_break;
    }
    {
#line 2524
    tmp___11 = strcasecmp("from", (char const   *)*(argv + 1));
    }
#line 2524
    if (tmp___11 == 0) {
#line 2525
      argv ++;
#line 2526
      argc --;
#line 2527
      goto while_continue;
    } else {
      {
#line 2529
      tmp___9 = strcasecmp("!all", (char const   *)*(argv + 1));
      }
#line 2529
      if (tmp___9 == 0) {
        {
#line 2531
        tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "the ! negation operator cannot be used with ALL/NONE",
                          (void *)0);
#line 2531
        tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
        }
#line 2531
        return (tmp___5);
      } else {
        {
#line 2529
        tmp___10 = strcasecmp("!none", (char const   *)*(argv + 1));
        }
#line 2529
        if (tmp___10 == 0) {
          {
#line 2531
          tmp___4 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "the ! negation operator cannot be used with ALL/NONE",
                            (void *)0);
#line 2531
          tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___4);
          }
#line 2531
          return (tmp___5);
        } else {
          {
#line 2533
          tmp___7 = strcasecmp("all", (char const   *)*(argv + 1));
          }
#line 2533
          if (tmp___7 == 0) {
            {
#line 2535
            tmp___6 = push_array(list);
#line 2535
            *((pr_netacl_t **)tmp___6) = pr_netacl_create(c->pool, *(argv + 1));
#line 2537
            argc = 0;
            }
          } else {
            {
#line 2533
            tmp___8 = strcasecmp("none", (char const   *)*(argv + 1));
            }
#line 2533
            if (tmp___8 == 0) {
              {
#line 2535
              tmp___6 = push_array(list);
#line 2535
              *((pr_netacl_t **)tmp___6) = pr_netacl_create(c->pool, *(argv + 1));
#line 2537
              argc = 0;
              }
            }
          }
        }
      }
    }
#line 2540
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2544
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2544
    tmp___21 = argc;
#line 2544
    argc --;
#line 2544
    if (tmp___21) {
#line 2544
      argv ++;
#line 2544
      if (! *argv) {
#line 2544
        goto while_break___0;
      }
    } else {
#line 2544
      goto while_break___0;
    }
    {
#line 2545
    ent = (char *)((void *)0);
#line 2546
    tmp___12 = pstrdup(cmd->tmp_pool, (char const   *)*argv);
#line 2546
    s = tmp___12;
    }
    {
#line 2549
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 2549
      ent = pr_str_get_token(& s, (char *)",");
      }
#line 2549
      if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 2549
        goto while_break___1;
      }
#line 2550
      if (*ent) {
        {
#line 2553
        tmp___13 = strcasecmp((char const   *)ent, "all");
        }
#line 2553
        if (tmp___13 == 0) {
#line 2555
          list->nelts = 0;
#line 2556
          argc = 0;
#line 2557
          goto while_break___1;
        } else {
          {
#line 2553
          tmp___14 = strcasecmp((char const   *)ent, "none");
          }
#line 2553
          if (tmp___14 == 0) {
#line 2555
            list->nelts = 0;
#line 2556
            argc = 0;
#line 2557
            goto while_break___1;
          }
        }
        {
#line 2560
        acl = pr_netacl_create(c->pool, ent);
        }
#line 2561
        if (! acl) {
          {
#line 2562
          tmp___15 = __errno_location();
#line 2562
          tmp___16 = strerror(*tmp___15);
#line 2562
          tmp___17 = pstrcat(cmd->tmp_pool, "bad ACL definition \'", ent, "\': ",
                             tmp___16, (void *)0);
#line 2562
          tmp___18 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___17, (void *)0);
#line 2562
          tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___18);
          }
#line 2562
          return (tmp___19);
        }
        {
#line 2566
        tmp___20 = push_array(list);
#line 2566
        *((pr_netacl_t **)tmp___20) = acl;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2571
  if (! list->nelts) {
    {
#line 2572
    tmp___22 = pstrcat(cmd->tmp_pool, "syntax: ", *(cmd->argv + 0), " [from] [all|none]|host|network[,...]",
                       (void *)0);
#line 2572
    tmp___23 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___22, (void *)0);
#line 2572
    tmp___24 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___23);
    }
#line 2572
    return (tmp___24);
  }
  {
#line 2575
  c->argc = list->nelts;
#line 2576
  tmp___25 = pcalloc(c->pool, (int )((unsigned long )(c->argc + 1) * sizeof(pr_netacl_t *)));
#line 2576
  c->argv = (void **)tmp___25;
#line 2577
  aclargv = (pr_netacl_t **)c->argv;
  }
  {
#line 2579
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2579
    tmp___27 = list->nelts;
#line 2579
    (list->nelts) --;
#line 2579
    if (! tmp___27) {
#line 2579
      goto while_break___2;
    }
#line 2580
    tmp___26 = aclargv;
#line 2580
    aclargv ++;
#line 2580
    *tmp___26 = *((pr_netacl_t **)list->elts);
#line 2581
    list->elts = (void *)((pr_netacl_t **)list->elts + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2583
  *aclargv = (pr_netacl_t *)((void *)0);
#line 2585
  tmp___28 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2585
  return (tmp___28);
}
}
#line 2588 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_denyall(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2589
  c = (config_rec *)((void *)0);
#line 2591
  if (cmd->argc - 1 < 0) {
    {
#line 2591
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2591
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2591
    return (tmp___0);
  }
  {
#line 2592
  tmp___5 = check_context(cmd, (((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2592
  if (! tmp___5) {
    {
#line 2592
    tmp___1 = get_context_name(cmd);
#line 2592
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2592
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2592
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2592
    return (tmp___4);
  }
  {
#line 2594
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2595
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2596
  *((unsigned char *)*(c->argv + 0)) = (unsigned char)1;
#line 2598
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2598
  return (tmp___6);
}
}
#line 2601 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_allowall(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2602
  c = (config_rec *)((void *)0);
#line 2604
  if (cmd->argc - 1 < 0) {
    {
#line 2604
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2604
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2604
    return (tmp___0);
  }
  {
#line 2605
  tmp___5 = check_context(cmd, (((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 5));
  }
#line 2605
  if (! tmp___5) {
    {
#line 2605
    tmp___1 = get_context_name(cmd);
#line 2605
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2605
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2605
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2605
    return (tmp___4);
  }
  {
#line 2607
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2608
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2609
  *((unsigned char *)*(c->argv + 0)) = (unsigned char)1;
#line 2611
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2611
  return (tmp___6);
}
}
#line 2614 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_authorder(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  config_rec *c ;
  array_header *module_list ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  config_rec *tmp___8 ;
  void *tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 2615
  i___0 = 0U;
#line 2616
  c = (config_rec *)((void *)0);
#line 2617
  module_list = (array_header *)((void *)0);
#line 2619
  if (cmd->argc - 1 < 1) {
    {
#line 2619
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2619
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2619
    return (tmp___0);
  }
  {
#line 2620
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2620
  if (! tmp___5) {
    {
#line 2620
    tmp___1 = get_context_name(cmd);
#line 2620
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2620
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2620
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2620
    return (tmp___4);
  }
  {
#line 2623
  tmp___8 = find_config((cmd->server)->conf, 1 << 15, (char const   *)*(cmd->argv + 0),
                        0);
  }
#line 2623
  if (tmp___8) {
    {
#line 2624
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "AuthOrder has already been configured",
                      (void *)0);
#line 2624
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2624
    return (tmp___7);
  }
  {
#line 2626
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2627
  module_list = make_array(c->pool, 0U, (size_t )sizeof(char *));
#line 2629
  i___0 = 1U;
  }
  {
#line 2629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2629
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 2629
      goto while_break;
    }
    {
#line 2630
    tmp___9 = push_array(module_list);
#line 2630
    *((char **)tmp___9) = pstrdup(c->pool, (char const   *)*(cmd->argv + i___0));
#line 2629
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2632
  *(c->argv + 0) = (void *)module_list;
#line 2634
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2634
  return (tmp___10);
}
}
#line 2637 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_limit(cmd_rec *cmd ) 
{ 
  int empty_ctxt ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 2638
  empty_ctxt = 0;
#line 2640
  if (cmd->argc - 1 < 0) {
    {
#line 2640
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2640
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2640
    return (tmp___0);
  }
  {
#line 2641
  tmp___5 = check_context(cmd, 1 << 3);
  }
#line 2641
  if (! tmp___5) {
    {
#line 2641
    tmp___1 = get_context_name(cmd);
#line 2641
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2641
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2641
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2641
    return (tmp___4);
  }
  {
#line 2643
  pr_parser_config_ctxt_close(& empty_ctxt);
  }
#line 2645
  if (empty_ctxt) {
    {
#line 2646
    pr_log_debug(3, "%s: ignoring empty section", *(cmd->argv + 0));
    }
  }
  {
#line 2648
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2648
  return (tmp___6);
}
}
#line 2651 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_ignorehidden(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2652
  bool = -1;
#line 2653
  c = (config_rec *)((void *)0);
#line 2655
  if (cmd->argc - 1 < 1) {
    {
#line 2655
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2655
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2655
    return (tmp___0);
  }
  {
#line 2656
  tmp___5 = check_context(cmd, 1 << 3);
  }
#line 2656
  if (! tmp___5) {
    {
#line 2656
    tmp___1 = get_context_name(cmd);
#line 2656
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2656
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2656
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2656
    return (tmp___4);
  }
  {
#line 2658
  bool = get_boolean(cmd, 1);
  }
#line 2659
  if (bool == -1) {
    {
#line 2660
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 2660
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2660
    return (tmp___7);
  }
  {
#line 2662
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 2663
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 2664
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 2666
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2666
  return (tmp___8);
}
}
#line 2670 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_displaychdir(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  int bool ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  char *tmp___8 ;
  modret_t *tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 2671
  c = (config_rec *)((void *)0);
#line 2672
  bool = 0;
#line 2674
  if (cmd->argc - 1 < 1) {
    {
#line 2676
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2676
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2676
    return (tmp___0);
  } else
#line 2674
  if (cmd->argc - 1 > 2) {
    {
#line 2676
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2676
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2676
    return (tmp___0);
  }
  {
#line 2678
  tmp___5 = check_context(cmd, (((1 | (1 << 4)) | (1 << 6)) | (1 << 2)) | (1 << 1));
  }
#line 2678
  if (! tmp___5) {
    {
#line 2678
    tmp___1 = get_context_name(cmd);
#line 2678
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2678
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2678
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2678
    return (tmp___4);
  }
#line 2680
  if (cmd->argc - 1 == 2) {
    {
#line 2681
    bool = get_boolean(cmd, 2);
    }
#line 2682
    if (bool < 0) {
      {
#line 2683
      tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                        (void *)0);
#line 2683
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
      }
#line 2683
      return (tmp___7);
    }
  }
  {
#line 2687
  c = add_config_param((char const   *)*(cmd->argv + 0), 2, (void *)0, (void *)0);
#line 2688
  tmp___8 = pstrdup(c->pool, (char const   *)*(cmd->argv + 1));
#line 2688
  *(c->argv + 0) = (void *)tmp___8;
#line 2689
  *(c->argv + 1) = pcalloc(c->pool, (int )sizeof(int ));
#line 2690
  *((int *)*(c->argv + 1)) = bool;
#line 2692
  c->flags |= 1L;
#line 2694
  tmp___9 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2694
  return (tmp___9);
}
}
#line 2697 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_displayconnect(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 2698
  if (cmd->argc - 1 < 1) {
    {
#line 2698
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2698
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2698
    return (tmp___0);
  }
  {
#line 2699
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 2699
  if (! tmp___5) {
    {
#line 2699
    tmp___1 = get_context_name(cmd);
#line 2699
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2699
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2699
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2699
    return (tmp___4);
  }
  {
#line 2701
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2703
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2703
  return (tmp___6);
}
}
#line 2706 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_displayquit(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2707
  c = (config_rec *)((void *)0);
#line 2709
  if (cmd->argc - 1 < 1) {
    {
#line 2709
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2709
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2709
    return (tmp___0);
  }
  {
#line 2710
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2710
  if (! tmp___5) {
    {
#line 2710
    tmp___1 = get_context_name(cmd);
#line 2710
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2710
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2710
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2710
    return (tmp___4);
  }
  {
#line 2712
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2713
  c->flags |= 1L;
#line 2715
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2715
  return (tmp___6);
}
}
#line 2718 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_displaygoaway(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2719
  c = (config_rec *)((void *)0);
#line 2721
  if (cmd->argc - 1 < 1) {
    {
#line 2721
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2721
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2721
    return (tmp___0);
  }
  {
#line 2722
  tmp___5 = check_context(cmd, ((1 | (1 << 4)) | (1 << 6)) | (1 << 2));
  }
#line 2722
  if (! tmp___5) {
    {
#line 2722
    tmp___1 = get_context_name(cmd);
#line 2722
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2722
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2722
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2722
    return (tmp___4);
  }
  {
#line 2724
  c = add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 2725
  c->flags |= 1L;
#line 2727
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2727
  return (tmp___6);
}
}
#line 2730 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *add_virtualhost(cmd_rec *cmd ) 
{ 
  server_rec *s ;
  pr_netaddr_t *addr ;
  array_header *addrs ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  register unsigned int i___0 ;
  pr_netaddr_t **elts ;
  char const   *tmp___8 ;
  register unsigned int i___1 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  char const   *tmp___14 ;
  register unsigned int j ;
  pr_netaddr_t **elts___0 ;
  char const   *tmp___15 ;
  modret_t *tmp___16 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 2731
  s = (server_rec *)((void *)0);
#line 2732
  addr = (pr_netaddr_t *)((void *)0);
#line 2733
  addrs = (array_header *)((void *)0);
#line 2735
  if (cmd->argc - 1 < 1) {
    {
#line 2736
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "wrong number of parameters",
                  (void *)0);
#line 2736
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2736
    return (tmp___0);
  }
  {
#line 2737
  tmp___5 = check_context(cmd, 1);
  }
#line 2737
  if (! tmp___5) {
    {
#line 2737
    tmp___1 = get_context_name(cmd);
#line 2737
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2737
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2737
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2737
    return (tmp___4);
  }
  {
#line 2739
  s = pr_parser_server_ctxt_open((char const   *)*(cmd->argv + 1));
  }
#line 2740
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 2741
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "unable to create virtual server configuration",
                      (void *)0);
#line 2741
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 2741
    return (tmp___7);
  }
  {
#line 2749
  addr = pr_netaddr_get_addr(cmd->tmp_pool, (char const   *)*(cmd->argv + 1), & addrs);
  }
#line 2750
  if (addrs) {
#line 2752
    elts = (pr_netaddr_t **)addrs->elts;
#line 2755
    i___0 = 0U;
    {
#line 2755
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2755
      if (! (i___0 < (unsigned int )addrs->nelts)) {
#line 2755
        goto while_break;
      }
      {
#line 2756
      tmp___8 = pr_netaddr_get_ipstr(*(elts + i___0));
#line 2756
      add_config_param_str("_bind", 1, tmp___8);
#line 2755
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2763
  if (cmd->argc - 1 > 1) {
#line 2766
    i___1 = 2U;
    {
#line 2766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2766
      if (! (i___1 < (unsigned int )cmd->argc)) {
#line 2766
        goto while_break___0;
      }
      {
#line 2767
      addrs = (array_header *)((void *)0);
#line 2769
      addr = pr_netaddr_get_addr(cmd->tmp_pool, (char const   *)*(cmd->argv + i___1),
                                 & addrs);
      }
#line 2771
      if ((unsigned long )addr == (unsigned long )((void *)0)) {
        {
#line 2772
        tmp___9 = __errno_location();
#line 2772
        tmp___10 = strerror(*tmp___9);
#line 2772
        tmp___11 = pstrcat(cmd->tmp_pool, "error resolving \'", *(cmd->argv + i___1),
                           "\': ", tmp___10, (void *)0);
#line 2772
        tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___11, (void *)0);
#line 2772
        tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
        }
#line 2772
        return (tmp___13);
      }
      {
#line 2775
      tmp___14 = pr_netaddr_get_ipstr(addr);
#line 2775
      add_config_param_str("_bind", 1, tmp___14);
      }
#line 2777
      if (addrs) {
#line 2779
        elts___0 = (pr_netaddr_t **)addrs->elts;
#line 2782
        j = 0U;
        {
#line 2782
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2782
          if (! (j < (unsigned int )addrs->nelts)) {
#line 2782
            goto while_break___1;
          }
          {
#line 2783
          tmp___15 = pr_netaddr_get_ipstr(*(elts___0 + j));
#line 2783
          add_config_param_str("_bind", 1, tmp___15);
#line 2782
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 2766
      i___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2788
  tmp___16 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2788
  return (tmp___16);
}
}
#line 2791 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *end_virtualhost(cmd_rec *cmd ) 
{ 
  server_rec *s ;
  server_rec *next_s ;
  pr_netaddr_t *addr ;
  char const   *address ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char const   *serv_addrstr ;
  pr_netaddr_t *serv_addr ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  server_rec *tmp___14 ;
  modret_t *tmp___15 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 2792
  s = (server_rec *)((void *)0);
#line 2792
  next_s = (server_rec *)((void *)0);
#line 2793
  addr = (pr_netaddr_t *)((void *)0);
#line 2794
  address = (char const   *)((void *)0);
#line 2796
  if (cmd->argc - 1 < 0) {
    {
#line 2796
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 2796
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 2796
    return (tmp___0);
  }
  {
#line 2797
  tmp___5 = check_context(cmd, 1 << 4);
  }
#line 2797
  if (! tmp___5) {
    {
#line 2797
    tmp___1 = get_context_name(cmd);
#line 2797
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 2797
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 2797
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 2797
    return (tmp___4);
  }
#line 2799
  if ((cmd->server)->ServerAddress) {
#line 2800
    address = (cmd->server)->ServerAddress;
  } else {
    {
#line 2802
    address = pr_netaddr_get_localaddr_str(cmd->tmp_pool);
    }
  }
  {
#line 2807
  addr = pr_netaddr_get_addr(cmd->tmp_pool, address, (array_header **)((void *)0));
  }
#line 2808
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 2812
    pr_log_pri(4, "warning: unable to determine IP address of \'%s\'", address);
    }
  }
#line 2815
  if (AddressCollisionCheck) {
#line 2817
    s = (server_rec *)server_list->xas_list;
    {
#line 2817
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2817
      if (addr) {
#line 2817
        if (! s) {
#line 2817
          goto while_break;
        }
      } else {
#line 2817
        goto while_break;
      }
#line 2818
      next_s = s->next;
#line 2823
      if ((unsigned long )s != (unsigned long )cmd->server) {
#line 2824
        serv_addrstr = (char const   *)((void *)0);
#line 2825
        serv_addr = (pr_netaddr_t *)((void *)0);
#line 2827
        if (s->addr) {
#line 2828
          serv_addr = s->addr;
        } else {
#line 2831
          if (s->ServerAddress) {
#line 2831
            serv_addrstr = s->ServerAddress;
          } else {
            {
#line 2831
            tmp___6 = pr_netaddr_get_localaddr_str(cmd->tmp_pool);
#line 2831
            serv_addrstr = tmp___6;
            }
          }
          {
#line 2834
          serv_addr = pr_netaddr_get_addr(cmd->tmp_pool, serv_addrstr, (array_header **)((void *)0));
          }
        }
#line 2837
        if (! serv_addr) {
          {
#line 2838
          pr_log_pri(4, "warning: unable to determine IP address of \'%s\'", serv_addrstr);
          }
        } else {
          {
#line 2841
          tmp___11 = pr_netaddr_cmp((pr_netaddr_t const   *)addr, (pr_netaddr_t const   *)serv_addr);
          }
#line 2841
          if (tmp___11 == 0) {
#line 2841
            if ((cmd->server)->ServerPort == s->ServerPort) {
#line 2843
              if (s->ServerName) {
#line 2843
                tmp___7 = s->ServerName;
              } else {
#line 2843
                tmp___7 = "ProFTPD";
              }
              {
#line 2843
              tmp___8 = pr_netaddr_get_ipstr(addr);
              }
#line 2843
              if ((cmd->server)->ServerName) {
#line 2843
                tmp___9 = (cmd->server)->ServerName;
              } else {
#line 2843
                tmp___9 = "ProFTPD";
              }
              {
#line 2843
              pr_log_pri(4, "warning: \"%s\" address/port (%s:%d) already in use by \"%s\"",
                         tmp___9, tmp___8, (cmd->server)->ServerPort, tmp___7);
#line 2849
              tmp___10 = xaset_remove(server_list, (xasetmember_t *)cmd->server);
              }
#line 2849
              if (tmp___10 == 1) {
                {
#line 2850
                destroy_pool((cmd->server)->pool);
                }
              }
#line 2852
              goto __Cont;
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 2817
      s = next_s;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2858
  tmp___14 = pr_parser_server_ctxt_close();
  }
#line 2858
  if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
    {
#line 2859
    tmp___12 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "must have matching <VirtualHost> directive",
                       (void *)0);
#line 2859
    tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___12);
    }
#line 2859
    return (tmp___13);
  }
  {
#line 2861
  tmp___15 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2861
  return (tmp___15);
}
}
#line 2865 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *regex_filters(cmd_rec *cmd ) 
{ 
  regex_t *allow_regex ;
  regex_t *deny_regex ;
  int tmp ;
  xaset_t *tmp___0 ;
  xaset_t *tmp___1 ;
  void *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  xaset_t *tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 2866
  allow_regex = (regex_t *)((void *)0);
#line 2866
  deny_regex = (regex_t *)((void *)0);
#line 2871
  tmp = strcasecmp((char const   *)*(cmd->argv + 0), "PASS");
  }
#line 2871
  if (tmp == 0) {
#line 2872
    return ((modret_t *)((void *)0));
  }
#line 2875
  if (session.dir_config) {
#line 2875
    tmp___1 = (session.dir_config)->subset;
  } else {
#line 2875
    if (session.anon_config) {
#line 2875
      tmp___0 = (session.anon_config)->subset;
    } else {
#line 2875
      tmp___0 = main_server->conf;
    }
#line 2875
    tmp___1 = tmp___0;
  }
  {
#line 2875
  tmp___2 = get_param_ptr(tmp___1, "AllowFilter", 0);
#line 2875
  allow_regex = (regex_t *)tmp___2;
  }
#line 2877
  if (allow_regex) {
#line 2877
    if (cmd->arg) {
      {
#line 2877
      tmp___4 = regexec((regex_t const   */* __restrict  */)allow_regex, (char const   */* __restrict  */)cmd->arg,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 2877
      if (tmp___4 != 0) {
        {
#line 2879
        pr_log_debug(2, "\'%s %s\' denied by AllowFilter", *(cmd->argv + 0), cmd->arg);
#line 2881
        pr_response_add_err("550", "%s: Forbidden command argument", cmd->arg);
#line 2882
        tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2882
        return (tmp___3);
      }
    }
  }
#line 2886
  if (session.dir_config) {
#line 2886
    tmp___6 = (session.dir_config)->subset;
  } else {
#line 2886
    if (session.anon_config) {
#line 2886
      tmp___5 = (session.anon_config)->subset;
    } else {
#line 2886
      tmp___5 = main_server->conf;
    }
#line 2886
    tmp___6 = tmp___5;
  }
  {
#line 2886
  tmp___7 = get_param_ptr(tmp___6, "DenyFilter", 0);
#line 2886
  deny_regex = (regex_t *)tmp___7;
  }
#line 2888
  if (deny_regex) {
#line 2888
    if (cmd->arg) {
      {
#line 2888
      tmp___9 = regexec((regex_t const   */* __restrict  */)deny_regex, (char const   */* __restrict  */)cmd->arg,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 2888
      if (tmp___9 == 0) {
        {
#line 2890
        pr_log_debug(2, "\'%s %s\' denied by DenyFilter", *(cmd->argv + 0), cmd->arg);
#line 2892
        pr_response_add_err("550", "%s: Forbidden command argument", cmd->arg);
#line 2893
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 2893
        return (tmp___8);
      }
    }
  }
#line 2896
  return ((modret_t *)((void *)0));
}
}
#line 2900 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_clear_fs(cmd_rec *cmd ) 
{ 


  {
  {
#line 2902
  pr_fs_clear_cache();
  }
#line 2904
  return ((modret_t *)((void *)0));
}
}
#line 2907 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_quit(cmd_rec *cmd ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *display ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  modret_t *tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 2908
  if (displayquit_fh) {
    {
#line 2909
    tmp___1 = pr_display_fh(displayquit_fh, (char const   *)((void *)0), "221");
    }
#line 2909
    if (tmp___1 < 0) {
      {
#line 2910
      tmp = __errno_location();
#line 2910
      tmp___0 = strerror(*tmp);
#line 2910
      pr_log_debug(6, "unable to display DisplayQuit file \'%s\': %s", displayquit_fh->fh_path,
                   tmp___0);
      }
    }
    {
#line 2912
    pr_fsio_close(displayquit_fh);
#line 2913
    displayquit_fh = (pr_fh_t *)((void *)0);
#line 2917
    pr_response_send("221", "%s", "");
    }
  } else {
#line 2920
    if (session.anon_config) {
#line 2920
      tmp___2 = (session.anon_config)->subset;
    } else {
#line 2920
      tmp___2 = main_server->conf;
    }
    {
#line 2920
    tmp___3 = get_param_ptr(tmp___2, "DisplayQuit", 0);
#line 2920
    display = (char *)tmp___3;
    }
#line 2921
    if (display) {
      {
#line 2922
      tmp___6 = pr_display_file((char const   *)display, (char const   *)((void *)0),
                                "221");
      }
#line 2922
      if (tmp___6 < 0) {
        {
#line 2923
        tmp___4 = __errno_location();
#line 2923
        tmp___5 = strerror(*tmp___4);
#line 2923
        pr_log_debug(6, "unable to display DisplayQuit file \'%s\': %s", display,
                     tmp___5);
        }
      }
      {
#line 2929
      pr_response_send("221", "%s", "");
      }
    } else {
      {
#line 2932
      pr_response_send("221", "Goodbye.");
      }
    }
  }
  {
#line 2940
  tmp___7 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2940
  return (tmp___7);
}
}
#line 2943 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_log_quit(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;

  {
  {
#line 2946
  end_login(0);
#line 2952
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2952
  return (tmp);
}
}
#line 2959 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static char const   *quote_dir(cmd_rec *cmd , char *dir ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2960
  tmp = sreplace(cmd->tmp_pool, dir, "\"", "\"\"", (void *)0);
  }
#line 2960
  return ((char const   *)tmp);
}
}
#line 2963 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_pwd(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  modret_t *tmp___6 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 2964
  if (cmd->argc != 1) {
    {
#line 2964
    pr_response_add_err("501", "Invalid number of arguments");
#line 2964
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2964
    return (tmp);
  }
  {
#line 2966
  tmp___2 = dir_check(cmd->tmp_pool, (char *)"PWD", cmd->group, session.vwd, (int *)((void *)0));
  }
#line 2966
  if (tmp___2) {
    {
#line 2966
    tmp___3 = dir_check(cmd->tmp_pool, (char *)"XPWD", cmd->group, session.vwd, (int *)((void *)0));
    }
#line 2966
    if (! tmp___3) {
      {
#line 2968
      tmp___0 = strerror(13);
#line 2968
      pr_response_add_err("550", "%s: %s", *(cmd->argv + 0), tmp___0);
#line 2969
      tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 2969
      return (tmp___1);
    }
  } else {
    {
#line 2968
    tmp___0 = strerror(13);
#line 2968
    pr_response_add_err("550", "%s: %s", *(cmd->argv + 0), tmp___0);
#line 2969
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2969
    return (tmp___1);
  }
  {
#line 2972
  tmp___4 = pr_fs_encode_path(cmd->tmp_pool, (char const   *)(session.vwd));
#line 2972
  tmp___5 = quote_dir(cmd, tmp___4);
#line 2972
  pr_response_add("257", "\"%s\" is the current directory", tmp___5);
#line 2975
  tmp___6 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2975
  return (tmp___6);
}
}
#line 2978 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_pasv(cmd_rec *cmd ) 
{ 
  unsigned int port ;
  char *addrstr ;
  char *tmp ;
  config_rec *c ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  int pasv_min_port ;
  int pasv_max_port ;
  modret_t *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 2979
  port = 0U;
#line 2980
  addrstr = (char *)((void *)0);
#line 2980
  tmp = (char *)((void *)0);
#line 2981
  c = (config_rec *)((void *)0);
#line 2983
  if (session.sf_flags & (int volatile   )1024) {
    {
#line 2984
    pr_response_add_err("500", "Illegal PASV command, EPSV ALL in effect");
#line 2985
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2985
    return (tmp___0);
  }
#line 2988
  if (cmd->argc != 1) {
    {
#line 2988
    pr_response_add_err("501", "Invalid number of arguments");
#line 2988
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2988
    return (tmp___1);
  }
  {
#line 2993
  tmp___4 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, session.cwd, (int *)((void *)0));
  }
#line 2993
  if (! tmp___4) {
    {
#line 2994
    pr_log_debug(8, "PASV denied by <Limit> configuration");
#line 2995
    tmp___2 = strerror(1);
#line 2995
    pr_response_add_err("501", "%s: %s", *(cmd->argv + 0), tmp___2);
#line 2996
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 2996
    return (tmp___3);
  }
#line 3000
  if (session.d) {
    {
#line 3001
    pr_inet_close((session.d)->pool, session.d);
#line 3002
    session.d = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 3005
  c = find_config(main_server->conf, 1 << 15, "PassivePorts", 0);
  }
#line 3005
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 3007
    pasv_min_port = *((int *)*(c->argv + 0));
#line 3008
    pasv_max_port = *((int *)*(c->argv + 1));
#line 3010
    session.d = pr_inet_create_connection_portrange(session.pool, (xaset_t *)((void *)0),
                                                    (session.c)->local_addr, pasv_min_port,
                                                    pasv_max_port);
    }
#line 3010
    if (! session.d) {
      {
#line 3017
      pr_log_pri(4, "unable to find open port in PassivePorts range %d-%d: defaulting to INPORT_ANY",
                 pasv_min_port, pasv_max_port);
      }
    }
  }
#line 3024
  if (! session.d) {
    {
#line 3025
    session.d = pr_inet_create_connection(session.pool, (xaset_t *)((void *)0), -1,
                                          (session.c)->local_addr, 0, 0);
    }
  }
#line 3028
  if (! session.d) {
    {
#line 3029
    pr_response_add_err("425", "Unable to build data connection: Internal error");
#line 3031
    tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3031
    return (tmp___5);
  }
  {
#line 3034
  pr_inet_set_block(session.pool, session.d);
#line 3035
  pr_inet_listen(session.pool, session.d, 1);
#line 3037
  (session.d)->instrm = pr_netio_open(session.pool, 32, (session.d)->listen_fd, 1);
#line 3041
  session.data_port = (unsigned short )(session.d)->local_port;
#line 3041
  port = (unsigned int )session.data_port;
#line 3042
  session.sf_flags |= (int volatile   )1;
#line 3044
  tmp___6 = pr_netaddr_get_ipstr((session.d)->local_addr);
#line 3044
  addrstr = (char *)tmp___6;
#line 3049
  c = find_config(main_server->conf, 1 << 15, "MasqueradeAddress", 0);
  }
#line 3049
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 3051
    tmp___7 = pr_netaddr_get_ipstr((pr_netaddr_t *)*(c->argv + 0));
#line 3051
    addrstr = (char *)tmp___7;
    }
  }
  {
#line 3054
  tmp = strrchr((char const   *)addrstr, ':');
  }
#line 3055
  if (tmp) {
#line 3056
    addrstr = tmp + 1;
  }
#line 3058
  tmp = addrstr;
  {
#line 3058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3058
    if (! *tmp) {
#line 3058
      goto while_break;
    }
#line 3059
    if ((int )*tmp == 46) {
#line 3060
      *tmp = (char )',';
    }
#line 3058
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3062
  pr_log_debug(1, "Entering Passive Mode (%s,%u,%u).", addrstr, (port >> 8) & 255U,
               port & 255U);
#line 3068
  pr_response_add("227", "Entering Passive Mode (%s,%u,%u).", addrstr, (port >> 8) & 255U,
                  port & 255U);
#line 3071
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3071
  return (tmp___8);
}
}
#line 3074 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_port(cmd_rec *cmd ) 
{ 
  pr_netaddr_t *port_addr ;
  char buf___2[46] ;
  unsigned int tmp ;
  unsigned int h1 ;
  unsigned int h2 ;
  unsigned int h3 ;
  unsigned int h4 ;
  unsigned int p1 ;
  unsigned int p2 ;
  unsigned short port ;
  unsigned char *allow_foreign_addr ;
  unsigned char *privsdrop ;
  modret_t *tmp___0 ;
  modret_t *tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  xaset_t *tmp___5 ;
  void *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  int tmp___11 ;
  unsigned char tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  int tmp___16 ;
  uint16_t tmp___17 ;
  xaset_t *tmp___18 ;
  void *tmp___19 ;
  pr_netaddr_t *remote_addr ;
  modret_t *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned char tmp___23 ;
  modret_t *tmp___24 ;
  int tmp___25 ;
  modret_t *tmp___26 ;
  modret_t *tmp___27 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;

  {
#line 3075
  port_addr = (pr_netaddr_t *)((void *)0);
#line 3077
  buf___2[0] = (char )'\000';
#line 3077
  tmp = 1U;
  {
#line 3077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3077
    if (tmp >= 46U) {
#line 3077
      goto while_break;
    }
#line 3077
    buf___2[tmp] = (char)0;
#line 3077
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3083
  allow_foreign_addr = (unsigned char *)((void *)0);
#line 3083
  privsdrop = (unsigned char *)((void *)0);
#line 3085
  if (session.sf_flags & (int volatile   )1024) {
    {
#line 3086
    pr_response_add_err("500", "Illegal PORT command, EPSV ALL in effect");
#line 3087
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3087
    return (tmp___0);
  }
#line 3090
  if (cmd->argc != 2) {
    {
#line 3090
    pr_response_add_err("501", "Invalid number of arguments");
#line 3090
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3090
    return (tmp___1);
  }
  {
#line 3095
  tmp___4 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, session.cwd, (int *)((void *)0));
  }
#line 3095
  if (! tmp___4) {
    {
#line 3096
    pr_log_debug(8, "PORT denied by <Limit> configuration");
#line 3097
    tmp___2 = strerror(1);
#line 3097
    pr_response_add_err("501", "%s: %s", *(cmd->argv + 0), tmp___2);
#line 3098
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3098
    return (tmp___3);
  }
#line 3105
  if (session.anon_config) {
#line 3105
    tmp___5 = (session.anon_config)->subset;
  } else {
#line 3105
    tmp___5 = main_server->conf;
  }
  {
#line 3105
  tmp___6 = get_param_ptr(tmp___5, "RootRevoke", 0);
#line 3105
  privsdrop = (unsigned char *)tmp___6;
  }
#line 3106
  if ((unsigned long )privsdrop != (unsigned long )((void *)0)) {
#line 3106
    if ((int )*privsdrop == 1) {
#line 3106
      if ((session.c)->local_port < 1025) {
        {
#line 3109
        pr_log_debug(0, "RootRevoke in effect, unable to bind to local port %d for active transfer",
                     (session.c)->local_port);
#line 3111
        pr_response_add_err("500", "Unable to service PORT commands");
#line 3112
        tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 3112
        return (tmp___7);
      }
    }
  }
  {
#line 3116
  tmp___9 = sscanf((char const   */* __restrict  */)*(cmd->argv + 1), (char const   */* __restrict  */)"%u,%u,%u,%u,%u,%u",
                   & h1, & h2, & h3, & h4, & p1, & p2);
  }
#line 3116
  if (tmp___9 != 6) {
    {
#line 3118
    pr_log_debug(2, "PORT \'%s\' is not syntactically valid", *(cmd->argv + 1));
#line 3119
    pr_response_add_err("501", "Illegal PORT command");
#line 3120
    tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3120
    return (tmp___8);
  }
#line 3123
  if (h1 > 255U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if (h2 > 255U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if (h3 > 255U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if (h4 > 255U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if (p1 > 255U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if (p2 > 255U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if ((((h1 | h2) | h3) | h4) == 0U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  } else
#line 3123
  if ((p1 | p2) == 0U) {
    {
#line 3125
    pr_log_debug(2, "PORT \'%s\' has invalid value(s)", cmd->arg);
#line 3126
    pr_response_add_err("501", "Illegal PORT command");
#line 3127
    tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3127
    return (tmp___10);
  }
  {
#line 3129
  port = (unsigned short )((p1 << 8) | p2);
#line 3132
  tmp___12 = pr_netaddr_use_ipv6();
  }
#line 3132
  if (tmp___12) {
    {
#line 3133
    tmp___11 = pr_netaddr_get_family((pr_netaddr_t const   *)(session.c)->remote_addr);
    }
#line 3133
    if (tmp___11 == 10) {
      {
#line 3134
      snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"::ffff:%u.%u.%u.%u",
               h1, h2, h3, h4);
      }
    } else {
      {
#line 3137
      snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%u.%u.%u.%u",
               h1, h2, h3, h4);
      }
    }
  } else {
    {
#line 3142
    snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%u.%u.%u.%u",
             h1, h2, h3, h4);
    }
  }
  {
#line 3143
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 3145
  port_addr = pr_netaddr_get_addr(cmd->tmp_pool, (char const   *)(buf___2), (array_header **)((void *)0));
  }
#line 3146
  if ((unsigned long )port_addr == (unsigned long )((void *)0)) {
    {
#line 3147
    tmp___13 = __errno_location();
#line 3147
    tmp___14 = strerror(*tmp___13);
#line 3147
    pr_log_debug(1, "error getting sockaddr for \'%s\': %s", buf___2, tmp___14);
#line 3149
    pr_response_add_err("501", "Illegal PORT command");
#line 3150
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3150
    return (tmp___15);
  }
  {
#line 3153
  tmp___16 = pr_netaddr_get_family((pr_netaddr_t const   *)port_addr);
#line 3153
  pr_netaddr_set_family(& session.data_addr, tmp___16);
#line 3154
  tmp___17 = htons(port);
#line 3154
  pr_netaddr_set_port(& session.data_addr, (unsigned int )tmp___17);
  }
#line 3160
  if (session.anon_config) {
#line 3160
    tmp___18 = (session.anon_config)->subset;
  } else {
#line 3160
    tmp___18 = main_server->conf;
  }
  {
#line 3160
  tmp___19 = get_param_ptr(tmp___18, "AllowForeignAddress", 0);
#line 3160
  allow_foreign_addr = (unsigned char *)tmp___19;
  }
#line 3163
  if (! allow_foreign_addr) {
#line 3163
    goto _L;
  } else
#line 3163
  if ((int )*allow_foreign_addr == 0) {
    _L: /* CIL Label */ 
    {
#line 3164
    remote_addr = (session.c)->remote_addr;
#line 3167
    tmp___23 = pr_netaddr_use_ipv6();
    }
#line 3167
    if (tmp___23) {
      {
#line 3171
      tmp___21 = pr_netaddr_get_family((pr_netaddr_t const   *)remote_addr);
      }
#line 3171
      if (tmp___21 == 10) {
        {
#line 3171
        tmp___22 = pr_netaddr_is_v4mappedv6((pr_netaddr_t const   *)remote_addr);
        }
#line 3171
        if (tmp___22 != 1) {
          {
#line 3173
          pr_log_pri(4, "Refused PORT %s (IPv4/IPv6 address mismatch)", cmd->arg);
#line 3175
          pr_response_add_err("500", "Illegal PORT command");
#line 3176
          tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 3176
          return (tmp___20);
        }
      }
    }
    {
#line 3181
    tmp___25 = pr_netaddr_cmp((pr_netaddr_t const   *)port_addr, (pr_netaddr_t const   *)remote_addr);
    }
#line 3181
    if (tmp___25 != 0) {
      {
#line 3182
      pr_log_pri(4, "Refused PORT %s (address mismatch)", cmd->arg);
#line 3184
      pr_response_add_err("500", "Illegal PORT command");
#line 3185
      tmp___24 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3185
      return (tmp___24);
    }
  }
#line 3195
  if ((int )port < 1024) {
    {
#line 3196
    pr_log_pri(4, "Refused PORT %s (bounce attack)", cmd->arg);
#line 3197
    pr_response_add_err("500", "Illegal PORT command");
#line 3198
    tmp___26 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3198
    return (tmp___26);
  }
  {
#line 3201
  memcpy((void */* __restrict  */)(& session.data_addr), (void const   */* __restrict  */)port_addr,
         (size_t )sizeof(session.data_addr));
#line 3202
  session.data_port = port;
#line 3203
  session.sf_flags &= (int volatile   )1910;
  }
#line 3206
  if (session.d) {
    {
#line 3207
    pr_inet_close((session.d)->pool, session.d);
#line 3208
    session.d = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 3211
  session.sf_flags |= (int volatile   )512;
#line 3212
  pr_response_add("200", "PORT command successful");
#line 3214
  tmp___27 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3214
  return (tmp___27);
}
}
#line 3217 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_eprt(cmd_rec *cmd ) 
{ 
  pr_netaddr_t na ;
  int family ;
  unsigned short port ;
  unsigned char *allow_foreign_addr ;
  unsigned char *privsdrop ;
  char delim ;
  char *argstr ;
  char *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  modret_t *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  int tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  modret_t *tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  modret_t *tmp___12 ;
  unsigned short const   **tmp___13 ;
  modret_t *tmp___14 ;
  modret_t *tmp___15 ;
  struct sockaddr *sa ;
  int *tmp___16 ;
  char *tmp___17 ;
  modret_t *tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  struct sockaddr *sa___0 ;
  int *tmp___21 ;
  char *tmp___22 ;
  modret_t *tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned short const   **tmp___27 ;
  modret_t *tmp___28 ;
  xaset_t *tmp___29 ;
  void *tmp___30 ;
  modret_t *tmp___31 ;
  int tmp___32 ;
  modret_t *tmp___33 ;
  uint16_t tmp___34 ;
  struct sockaddr *tmp___35 ;
  unsigned int tmp___36 ;
  modret_t *tmp___37 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;

  {
  {
#line 3219
  family = 0;
#line 3220
  port = (unsigned short)0;
#line 3221
  allow_foreign_addr = (unsigned char *)((void *)0);
#line 3221
  privsdrop = (unsigned char *)((void *)0);
#line 3222
  delim = (char )'\000';
#line 3222
  tmp = pstrdup(cmd->tmp_pool, (char const   *)*(cmd->argv + 1));
#line 3222
  argstr = tmp;
#line 3223
  tmp___0 = (char *)((void *)0);
  }
#line 3225
  if (session.sf_flags & (int volatile   )1024) {
    {
#line 3226
    pr_response_add_err("500", "Illegal PORT command, EPSV ALL in effect");
#line 3227
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3227
    return (tmp___1);
  }
#line 3230
  if (cmd->argc != 2) {
    {
#line 3230
    pr_response_add_err("501", "Invalid number of arguments");
#line 3230
    tmp___2 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3230
    return (tmp___2);
  }
  {
#line 3235
  tmp___5 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, session.cwd, (int *)((void *)0));
  }
#line 3235
  if (! tmp___5) {
    {
#line 3236
    pr_log_debug(8, "EPRT denied by <Limit> configuration");
#line 3237
    tmp___3 = strerror(1);
#line 3237
    pr_response_add_err("501", "%s: %s", *(cmd->argv + 0), tmp___3);
#line 3238
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3238
    return (tmp___4);
  }
  {
#line 3242
  pr_netaddr_clear(& na);
  }
#line 3248
  if (session.anon_config) {
#line 3248
    tmp___6 = (session.anon_config)->subset;
  } else {
#line 3248
    tmp___6 = main_server->conf;
  }
  {
#line 3248
  tmp___7 = get_param_ptr(tmp___6, "RootRevoke", 0);
#line 3248
  privsdrop = (unsigned char *)tmp___7;
  }
#line 3249
  if ((unsigned long )privsdrop != (unsigned long )((void *)0)) {
#line 3249
    if ((int )*privsdrop == 1) {
#line 3249
      if ((session.c)->local_port < 1025) {
        {
#line 3252
        pr_log_debug(0, "RootRevoke in effect, unable to bind to local port %d for active transfer",
                     (session.c)->local_port);
#line 3254
        pr_response_add_err("500", "Unable to service EPRT commands");
#line 3255
        tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 3255
        return (tmp___8);
      }
    }
  }
  {
#line 3261
  tmp___9 = argstr;
#line 3261
  argstr ++;
#line 3261
  delim = *tmp___9;
#line 3266
  family = atoi((char const   *)argstr);
  }
  {
#line 3269
  if (family == 1) {
#line 3269
    goto case_1;
  }
#line 3273
  if (family == 2) {
#line 3273
    goto case_2;
  }
#line 3278
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3270
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3274
  tmp___10 = pr_netaddr_use_ipv6();
  }
#line 3274
  if (tmp___10) {
#line 3275
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 3280
  tmp___11 = pr_netaddr_use_ipv6();
  }
#line 3280
  if (tmp___11) {
    {
#line 3281
    pr_response_add_err("522", "Network protocol not supported, use (1,2)");
    }
  } else {
    {
#line 3283
    pr_response_add_err("522", "Network protocol not supported, use (1)");
    }
  }
  {
#line 3287
  tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 3287
  return (tmp___12);
  switch_break: /* CIL Label */ ;
  }
  {
#line 3291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3291
    tmp___13 = __ctype_b_loc();
    }
#line 3291
    if (! ((int const   )*(*tmp___13 + (int )((unsigned char )*argstr)) & 2048)) {
#line 3291
      goto while_break;
    }
#line 3292
    argstr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3297
  if ((int )*argstr == (int )delim) {
#line 3298
    argstr ++;
  } else {
    {
#line 3301
    pr_response_add_err("501", "Illegal EPRT command");
#line 3302
    tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3302
    return (tmp___14);
  }
  {
#line 3305
  tmp___0 = strchr((char const   *)argstr, (int )delim);
  }
#line 3305
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 3306
    pr_log_debug(3, "badly formatted EPRT argument: \'%s\'", *(cmd->argv + 1));
#line 3307
    pr_response_add_err("501", "Illegal EPRT command");
#line 3308
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3308
    return (tmp___15);
  }
  {
#line 3314
  *tmp___0 = (char )'\000';
#line 3316
  memset((void *)(& na), 0, (size_t )sizeof(na));
  }
  {
#line 3322
  if (family == 1) {
#line 3322
    goto case_1___0;
  }
#line 3338
  if (family == 2) {
#line 3338
    goto case_2___0;
  }
#line 3321
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 3323
  sa = (struct sockaddr *)((void *)0);
#line 3325
  pr_netaddr_set_family(& na, 2);
#line 3326
  sa = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
  }
#line 3327
  if (sa) {
#line 3328
    sa->sa_family = (sa_family_t )2;
  }
  {
#line 3329
  tmp___19 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)(& na));
#line 3329
  tmp___20 = inet_pton(2, (char const   */* __restrict  */)argstr, (void */* __restrict  */)tmp___19);
  }
#line 3329
  if (tmp___20 <= 0) {
    {
#line 3330
    tmp___16 = __errno_location();
#line 3330
    tmp___17 = strerror(*tmp___16);
#line 3330
    pr_log_debug(2, "error converting IPv4 address \'%s\': %s", argstr, tmp___17);
#line 3332
    pr_response_add_err("501", "Illegal EPRT command");
#line 3333
    tmp___18 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3333
    return (tmp___18);
  }
#line 3335
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 3339
  sa___0 = (struct sockaddr *)((void *)0);
#line 3341
  pr_netaddr_set_family(& na, 10);
#line 3342
  sa___0 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
  }
#line 3343
  if (sa___0) {
#line 3344
    sa___0->sa_family = (sa_family_t )10;
  }
  {
#line 3345
  tmp___24 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)(& na));
#line 3345
  tmp___25 = inet_pton(10, (char const   */* __restrict  */)argstr, (void */* __restrict  */)tmp___24);
  }
#line 3345
  if (tmp___25 <= 0) {
    {
#line 3346
    tmp___21 = __errno_location();
#line 3346
    tmp___22 = strerror(*tmp___21);
#line 3346
    pr_log_debug(2, "error converting IPv6 address \'%s\': %s", argstr, tmp___22);
#line 3348
    pr_response_add_err("501", "Illegal EPRT command");
#line 3349
    tmp___23 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3349
    return (tmp___23);
  }
#line 3351
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 3356
  tmp___0 ++;
#line 3356
  argstr = tmp___0;
#line 3358
  tmp___26 = atoi((char const   *)argstr);
#line 3358
  port = (unsigned short )tmp___26;
  }
  {
#line 3360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 3360
    tmp___27 = __ctype_b_loc();
    }
#line 3360
    if (! ((int const   )*(*tmp___27 + (int )((unsigned char )*argstr)) & 2048)) {
#line 3360
      goto while_break___0;
    }
#line 3361
    argstr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3366
  if ((int )*argstr != (int )delim) {
    {
#line 3367
    pr_log_debug(3, "badly formatted EPRT argument: \'%s\'", *(cmd->argv + 1));
#line 3368
    pr_response_add_err("501", "Illegal EPRT command");
#line 3369
    tmp___28 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3369
    return (tmp___28);
  }
#line 3376
  if (session.anon_config) {
#line 3376
    tmp___29 = (session.anon_config)->subset;
  } else {
#line 3376
    tmp___29 = main_server->conf;
  }
  {
#line 3376
  tmp___30 = get_param_ptr(tmp___29, "AllowForeignAddress", 0);
#line 3376
  allow_foreign_addr = (unsigned char *)tmp___30;
  }
#line 3379
  if (! allow_foreign_addr) {
#line 3379
    goto _L;
  } else
#line 3379
  if ((int )*allow_foreign_addr == 0) {
    _L: /* CIL Label */ 
    {
#line 3380
    tmp___32 = pr_netaddr_cmp((pr_netaddr_t const   *)(& na), (pr_netaddr_t const   *)(session.c)->remote_addr);
    }
#line 3380
    if (tmp___32 != 0) {
      {
#line 3381
      pr_log_pri(4, "Refused EPRT %s (address mismatch)", cmd->arg);
#line 3383
      pr_response_add_err("500", "Illegal EPRT command");
#line 3384
      tmp___31 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3384
      return (tmp___31);
    } else
#line 3380
    if (! port) {
      {
#line 3381
      pr_log_pri(4, "Refused EPRT %s (address mismatch)", cmd->arg);
#line 3383
      pr_response_add_err("500", "Illegal EPRT command");
#line 3384
      tmp___31 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3384
      return (tmp___31);
    }
  }
#line 3394
  if ((int )port < 1024) {
    {
#line 3395
    pr_log_pri(4, "Refused EPRT %s (bounce attack)", cmd->arg);
#line 3396
    pr_response_add_err("500", "Illegal EPRT command");
#line 3397
    tmp___33 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3397
    return (tmp___33);
  }
  {
#line 3401
  tmp___34 = htons(port);
#line 3401
  pr_netaddr_set_port(& na, (unsigned int )tmp___34);
  }
  {
#line 3404
  if (family == 1) {
#line 3404
    goto case_1___1;
  }
#line 3408
  if (family == 2) {
#line 3408
    goto case_2___1;
  }
#line 3403
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 3405
  pr_netaddr_set_family(& session.data_addr, 2);
  }
#line 3406
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 3409
  pr_netaddr_set_family(& session.data_addr, 10);
  }
#line 3410
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 3413
  tmp___35 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 3413
  pr_netaddr_set_sockaddr(& session.data_addr, tmp___35);
#line 3414
  tmp___36 = pr_netaddr_get_port((pr_netaddr_t const   *)(& na));
#line 3414
  pr_netaddr_set_port(& session.data_addr, tmp___36);
#line 3415
  session.data_port = port;
#line 3416
  session.sf_flags &= (int volatile   )1910;
  }
#line 3419
  if (session.d) {
    {
#line 3420
    pr_inet_close((session.d)->pool, session.d);
#line 3421
    session.d = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 3424
  session.sf_flags |= (int volatile   )512;
#line 3425
  pr_response_add("200", "EPRT command successful");
#line 3427
  tmp___37 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3427
  return (tmp___37);
}
}
#line 3430 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_epsv(cmd_rec *cmd ) 
{ 
  char *addrstr ;
  char *endp ;
  char *arg ;
  int family ;
  int epsv_min_port ;
  int epsv_max_port ;
  config_rec *c ;
  modret_t *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  modret_t *tmp___6 ;
  int tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  modret_t *tmp___11 ;
  modret_t *tmp___12 ;
  modret_t *tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 3431
  addrstr = (char *)"";
#line 3432
  endp = (char *)((void *)0);
#line 3432
  arg = (char *)((void *)0);
#line 3433
  family = 0;
#line 3434
  epsv_min_port = 1024;
#line 3434
  epsv_max_port = 65535;
#line 3435
  c = (config_rec *)((void *)0);
#line 3437
  if (cmd->argc < 1) {
    {
#line 3437
    pr_response_add_err("501", "Invalid number of arguments");
#line 3437
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3437
    return (tmp);
  }
  {
#line 3442
  tmp___2 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, session.cwd, (int *)((void *)0));
  }
#line 3442
  if (! tmp___2) {
    {
#line 3443
    pr_log_debug(8, "EPSV denied by <Limit> configuration");
#line 3444
    tmp___0 = strerror(1);
#line 3444
    pr_response_add_err("501", "%s: %s", *(cmd->argv + 0), tmp___0);
#line 3445
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3445
    return (tmp___1);
  }
#line 3448
  if (cmd->argc - 1 == 1) {
    {
#line 3449
    arg = pstrdup(cmd->tmp_pool, (char const   *)*(cmd->argv + 1));
    }
  }
#line 3451
  if (arg) {
    {
#line 3451
    tmp___4 = strcasecmp((char const   *)arg, "all");
    }
#line 3451
    if (tmp___4 == 0) {
      {
#line 3452
      session.sf_flags |= (int volatile   )1024;
#line 3453
      pr_response_add("200", "EPSV ALL command successful");
#line 3454
      tmp___3 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
      }
#line 3454
      return (tmp___3);
    }
  }
#line 3461
  if (arg) {
    {
#line 3462
    tmp___5 = strtol((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& endp),
                     10);
#line 3462
    family = (int )tmp___5;
    }
#line 3464
    if (endp) {
#line 3464
      if (*endp) {
        {
#line 3465
        pr_response_add_err("501", "%s: unknown network protocol", *(cmd->argv + 0));
#line 3467
        tmp___6 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 3467
        return (tmp___6);
      }
    }
  } else {
    {
#line 3472
    tmp___7 = pr_netaddr_get_family((pr_netaddr_t const   *)(session.c)->local_addr);
    }
    {
#line 3473
    if (tmp___7 == 2) {
#line 3473
      goto case_2;
    }
#line 3478
    if (tmp___7 == 10) {
#line 3478
      goto case_10;
    }
#line 3485
    goto switch_default;
    case_2: /* CIL Label */ 
#line 3474
    family = 1;
#line 3475
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 3479
    tmp___8 = pr_netaddr_use_ipv6();
    }
#line 3479
    if (tmp___8) {
#line 3480
      family = 2;
#line 3481
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3486
    family = 0;
#line 3487
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 3492
  if (family == 1) {
#line 3492
    goto case_1;
  }
#line 3496
  if (family == 2) {
#line 3496
    goto case_2___0;
  }
#line 3501
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 3493
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 3497
  tmp___9 = pr_netaddr_use_ipv6();
  }
#line 3497
  if (tmp___9) {
#line 3498
    goto switch_break___0;
  }
  switch_default___0: /* CIL Label */ 
  {
#line 3503
  tmp___10 = pr_netaddr_use_ipv6();
  }
#line 3503
  if (tmp___10) {
    {
#line 3504
    pr_response_add_err("522", "Network protocol not supported, use (1,2)");
    }
  } else {
    {
#line 3506
    pr_response_add_err("522", "Network protocol not supported, use (1)");
    }
  }
  {
#line 3510
  tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
  }
#line 3510
  return (tmp___11);
  switch_break___0: /* CIL Label */ ;
  }
#line 3514
  if (session.d) {
    {
#line 3515
    pr_inet_close((session.d)->pool, session.d);
#line 3516
    session.d = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 3519
  c = find_config(main_server->conf, 1 << 15, "PassivePorts", 0);
  }
#line 3520
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 3521
    epsv_min_port = *((int *)*(c->argv + 0));
#line 3522
    epsv_max_port = *((int *)*(c->argv + 1));
  }
  {
#line 3535
  session.d = pr_inet_create_connection_portrange(session.pool, (xaset_t *)((void *)0),
                                                  (session.c)->local_addr, epsv_min_port,
                                                  epsv_max_port);
  }
#line 3538
  if ((unsigned long )session.d == (unsigned long )((void *)0)) {
    {
#line 3543
    pr_log_pri(4, "unable to find open port in PassivePorts range %d-%d: defaulting to INPORT_ANY",
               epsv_min_port, epsv_max_port);
#line 3546
    session.d = pr_inet_create_connection(session.pool, (xaset_t *)((void *)0), -1,
                                          (session.c)->local_addr, 0, 0);
    }
  }
#line 3550
  if ((unsigned long )session.d == (unsigned long )((void *)0)) {
    {
#line 3551
    pr_response_add_err("425", "Unable to build data connection: Internal error");
#line 3553
    tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3553
    return (tmp___12);
  }
  {
#line 3556
  pr_inet_set_block(session.pool, session.d);
#line 3557
  pr_inet_listen(session.pool, session.d, 1);
#line 3559
  (session.d)->instrm = pr_netio_open(session.pool, 32, (session.d)->listen_fd, 1);
#line 3563
  session.data_port = (unsigned short )(session.d)->local_port;
#line 3564
  session.sf_flags |= (int volatile   )1;
#line 3583
  pr_log_debug(1, "Entering Extended Passive Mode (||%s|%u|)", addrstr, (unsigned int )session.data_port);
#line 3585
  pr_response_add("229", "Entering Extended Passive Mode (||%s|%u|)", addrstr, (unsigned int )session.data_port);
#line 3588
  tmp___13 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3588
  return (tmp___13);
}
}
#line 3591 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_help(cmd_rec *cmd ) 
{ 
  char *cp ;
  int tmp ;
  modret_t *tmp___0 ;
  int tmp___1 ;
  modret_t *tmp___2 ;
  int tmp___3 ;
  modret_t *tmp___4 ;
  modret_t *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 3593
  if (cmd->argc == 1) {
    {
#line 3594
    pr_help_add_response(cmd, (char const   *)((void *)0));
    }
  } else {
#line 3599
    cp = *(cmd->argv + 1);
    {
#line 3599
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3599
      if (! *cp) {
#line 3599
        goto while_break;
      }
      {
#line 3600
      tmp = toupper((int )*cp);
#line 3600
      *cp = (char )tmp;
#line 3599
      cp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3602
    tmp___1 = strcasecmp((char const   *)*(cmd->argv + 1), "SITE");
    }
#line 3602
    if (tmp___1 == 0) {
      {
#line 3603
      tmp___0 = pr_module_call(& site_module, & site_dispatch, cmd);
      }
#line 3603
      return (tmp___0);
    }
    {
#line 3605
    tmp___3 = pr_help_add_response(cmd, (char const   *)*(cmd->argv + 1));
    }
#line 3605
    if (tmp___3 == 0) {
      {
#line 3606
      tmp___2 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
      }
#line 3606
      return (tmp___2);
    }
    {
#line 3608
    pr_response_add_err("502", "Unknown command \'%s\'", *(cmd->argv + 1));
#line 3609
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3609
    return (tmp___4);
  }
  {
#line 3612
  tmp___5 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3612
  return (tmp___5);
}
}
#line 3615 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_syst(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 3616
  pr_response_add("215", "UNIX Type: L8");
#line 3617
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3617
  return (tmp);
}
}
#line 3620 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
int core_chgrp(cmd_rec *cmd , char *dir , uid_t uid , gid_t gid ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 3621
  tmp = dir_check(cmd->tmp_pool, (char *)"SITE_CHGRP", (char *)"WRITE", dir, (int *)((void *)0));
  }
#line 3621
  if (! tmp) {
#line 3622
    return (-1);
  }
  {
#line 3624
  tmp___0 = pr_fsio_chown((char const   *)dir, uid, gid);
  }
#line 3624
  return (tmp___0);
}
}
#line 3627 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
int core_chmod(cmd_rec *cmd , char *dir , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 3628
  tmp = dir_check(cmd->tmp_pool, (char *)"SITE_CHMOD", (char *)"WRITE", dir, (int *)((void *)0));
  }
#line 3628
  if (! tmp) {
#line 3629
    return (-1);
  }
  {
#line 3631
  tmp___0 = pr_fsio_chmod((char const   *)dir, mode);
  }
#line 3631
  return (tmp___0);
}
}
#line 3634 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *_chdir(cmd_rec *cmd , char *ndir ) 
{ 
  char *dir ;
  char *odir ;
  char *cdir ;
  config_rec *c ;
  config_rec *cdpath ;
  unsigned char show_symlinks ;
  unsigned char *tmp ;
  xaset_t *tmp___0 ;
  void *tmp___1 ;
  int use_cdpath ;
  int allowed_access ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  int use_cdpath___0 ;
  int allowed_access___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  void *tmp___31 ;
  char const   *tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  modret_t *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  struct stat st ;
  time_t prev ;
  char *display ;
  int bool ;
  void *tmp___44 ;
  time_t tmp___45 ;
  int *tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  modret_t *tmp___51 ;
  void *__cil_tmp70 ;
  void *__cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;

  {
  {
#line 3636
  c = (config_rec *)((void *)0);
#line 3637
  show_symlinks = (unsigned char)1;
#line 3637
  tmp = (unsigned char *)((void *)0);
#line 3639
  odir = ndir;
#line 3640
  pr_fs_clear_cache();
  }
#line 3642
  if (session.anon_config) {
#line 3642
    tmp___0 = (session.anon_config)->subset;
  } else {
#line 3642
    tmp___0 = main_server->conf;
  }
  {
#line 3642
  tmp___1 = get_param_ptr(tmp___0, "ShowSymlinks", 0);
#line 3642
  tmp = (unsigned char *)tmp___1;
  }
#line 3643
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 3644
    show_symlinks = *tmp;
  }
#line 3646
  if (show_symlinks) {
    {
#line 3647
    use_cdpath = 0;
#line 3649
    dir = dir_realpath(cmd->tmp_pool, (char const   *)ndir);
    }
#line 3651
    if (! dir) {
#line 3652
      use_cdpath = 1;
    }
#line 3655
    if (! use_cdpath) {
      {
#line 3656
      allowed_access = 1;
#line 3658
      allowed_access = dir_check_full(cmd->tmp_pool, *(cmd->argv + 0), cmd->group,
                                      dir, (int *)((void *)0));
      }
#line 3661
      if (allowed_access) {
        {
#line 3661
        tmp___4 = strcmp((char const   *)*(cmd->argv + 0), "XCWD");
        }
#line 3661
        if (tmp___4 == 0) {
#line 3663
          if (allowed_access) {
            {
#line 3663
            tmp___2 = dir_check_full(cmd->tmp_pool, (char *)"CWD", cmd->group, dir,
                                     (int *)((void *)0));
            }
#line 3663
            if (tmp___2) {
#line 3663
              tmp___3 = 1;
            } else {
#line 3663
              tmp___3 = 0;
            }
          } else {
#line 3663
            tmp___3 = 0;
          }
#line 3663
          allowed_access = tmp___3;
        }
      }
#line 3667
      if (allowed_access) {
        {
#line 3667
        tmp___7 = strcmp((char const   *)*(cmd->argv + 0), "XCUP");
        }
#line 3667
        if (tmp___7 == 0) {
#line 3669
          if (allowed_access) {
            {
#line 3669
            tmp___5 = dir_check_full(cmd->tmp_pool, (char *)"CDUP", cmd->group, dir,
                                     (int *)((void *)0));
            }
#line 3669
            if (tmp___5) {
#line 3669
              tmp___6 = 1;
            } else {
#line 3669
              tmp___6 = 0;
            }
          } else {
#line 3669
            tmp___6 = 0;
          }
#line 3669
          allowed_access = tmp___6;
        }
      }
#line 3673
      if (! allowed_access) {
#line 3674
        use_cdpath = 1;
      }
    }
#line 3677
    if (! use_cdpath) {
      {
#line 3677
      tmp___8 = pr_fsio_chdir((char const   *)dir, 0);
      }
#line 3677
      if (tmp___8 < 0) {
#line 3679
        use_cdpath = 1;
      }
    }
#line 3682
    if (use_cdpath) {
      {
#line 3683
      cdpath = find_config(main_server->conf, 1 << 15, "CDPath", 1);
      }
      {
#line 3683
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3683
        if (! ((unsigned long )cdpath != (unsigned long )((void *)0))) {
#line 3683
          goto while_break;
        }
        {
#line 3686
        tmp___9 = strlen((char const   *)*(cdpath->argv + 0));
#line 3686
        tmp___10 = strlen((char const   *)ndir);
#line 3686
        tmp___11 = malloc((tmp___9 + tmp___10) + 2U);
#line 3686
        cdir = (char *)tmp___11;
#line 3687
        tmp___14 = strlen((char const   *)*(cdpath->argv + 0));
        }
#line 3687
        if ((int )*((char *)*(cdpath->argv + 0) + (tmp___14 - 1U)) == 47) {
#line 3687
          tmp___13 = "";
        } else {
#line 3687
          tmp___13 = "/";
        }
        {
#line 3687
        tmp___15 = strlen((char const   *)*(cdpath->argv + 0));
#line 3687
        tmp___16 = strlen((char const   *)ndir);
#line 3687
        snprintf((char */* __restrict  */)cdir, (tmp___15 + tmp___16) + 2U, (char const   */* __restrict  */)"%s%s%s",
                 (char *)*(cdpath->argv + 0), tmp___13, ndir);
#line 3691
        dir = dir_realpath(cmd->tmp_pool, (char const   *)cdir);
#line 3692
        free((void *)cdir);
        }
#line 3694
        if (dir) {
          {
#line 3694
          tmp___17 = dir_check_full(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, dir,
                                    (int *)((void *)0));
          }
#line 3694
          if (tmp___17) {
            {
#line 3694
            tmp___18 = pr_fsio_chdir((char const   *)dir, 0);
            }
#line 3694
            if (tmp___18 == 0) {
#line 3697
              goto while_break;
            }
          }
        }
        {
#line 3683
        cdpath = find_config_next(cdpath, cdpath->next, 1 << 15, "CDPath", 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3701
      if (! cdpath) {
        {
#line 3702
        tmp___19 = __errno_location();
#line 3702
        tmp___20 = strerror(*tmp___19);
#line 3702
        pr_response_add_err("550", "%s: %s", odir, tmp___20);
#line 3703
        tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 3703
        return (tmp___21);
      }
    }
  } else {
    {
#line 3708
    use_cdpath___0 = 0;
#line 3711
    ndir = dir_canonical_vpath(cmd->tmp_pool, (char const   *)ndir);
#line 3712
    dir = dir_realpath(cmd->tmp_pool, (char const   *)ndir);
    }
#line 3714
    if (! dir) {
#line 3715
      use_cdpath___0 = 1;
    }
#line 3718
    if (! use_cdpath___0) {
      {
#line 3719
      allowed_access___0 = 1;
#line 3721
      allowed_access___0 = dir_check_full(cmd->tmp_pool, *(cmd->argv + 0), cmd->group,
                                          dir, (int *)((void *)0));
      }
#line 3724
      if (allowed_access___0) {
        {
#line 3724
        tmp___24 = strcmp((char const   *)*(cmd->argv + 0), "XCWD");
        }
#line 3724
        if (tmp___24 == 0) {
#line 3726
          if (allowed_access___0) {
            {
#line 3726
            tmp___22 = dir_check_full(cmd->tmp_pool, (char *)"CWD", cmd->group, dir,
                                      (int *)((void *)0));
            }
#line 3726
            if (tmp___22) {
#line 3726
              tmp___23 = 1;
            } else {
#line 3726
              tmp___23 = 0;
            }
          } else {
#line 3726
            tmp___23 = 0;
          }
#line 3726
          allowed_access___0 = tmp___23;
        }
      }
#line 3730
      if (allowed_access___0) {
        {
#line 3730
        tmp___27 = strcmp((char const   *)*(cmd->argv + 0), "XCUP");
        }
#line 3730
        if (tmp___27 == 0) {
#line 3732
          if (allowed_access___0) {
            {
#line 3732
            tmp___25 = dir_check_full(cmd->tmp_pool, (char *)"CDUP", cmd->group, dir,
                                      (int *)((void *)0));
            }
#line 3732
            if (tmp___25) {
#line 3732
              tmp___26 = 1;
            } else {
#line 3732
              tmp___26 = 0;
            }
          } else {
#line 3732
            tmp___26 = 0;
          }
#line 3732
          allowed_access___0 = tmp___26;
        }
      }
#line 3736
      if (! allowed_access___0) {
#line 3737
        use_cdpath___0 = 1;
      }
    }
#line 3740
    if (! use_cdpath___0) {
      {
#line 3740
      tmp___28 = pr_fsio_chdir_canon((char const   *)ndir, 1);
      }
#line 3740
      if (tmp___28 < 0) {
#line 3742
        use_cdpath___0 = 1;
      }
    }
#line 3745
    if (use_cdpath___0) {
      {
#line 3746
      cdpath = find_config(main_server->conf, 1 << 15, "CDPath", 1);
      }
      {
#line 3746
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3746
        if (! ((unsigned long )cdpath != (unsigned long )((void *)0))) {
#line 3746
          goto while_break___0;
        }
        {
#line 3749
        tmp___29 = strlen((char const   *)*(cdpath->argv + 0));
#line 3749
        tmp___30 = strlen((char const   *)ndir);
#line 3749
        tmp___31 = malloc((tmp___29 + tmp___30) + 2U);
#line 3749
        cdir = (char *)tmp___31;
#line 3750
        tmp___34 = strlen((char const   *)*(cdpath->argv + 0));
        }
#line 3750
        if ((int )*((char *)*(cdpath->argv + 0) + (tmp___34 - 1U)) == 47) {
#line 3750
          tmp___33 = "";
        } else {
#line 3750
          tmp___33 = "/";
        }
        {
#line 3750
        tmp___35 = strlen((char const   *)*(cdpath->argv + 0));
#line 3750
        tmp___36 = strlen((char const   *)ndir);
#line 3750
        snprintf((char */* __restrict  */)cdir, (tmp___35 + tmp___36) + 2U, (char const   */* __restrict  */)"%s%s%s",
                 (char *)*(cdpath->argv + 0), tmp___33, ndir);
#line 3754
        ndir = dir_canonical_vpath(cmd->tmp_pool, (char const   *)cdir);
#line 3755
        dir = dir_realpath(cmd->tmp_pool, (char const   *)ndir);
#line 3756
        free((void *)cdir);
        }
#line 3758
        if (dir) {
          {
#line 3758
          tmp___37 = dir_check_full(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, dir,
                                    (int *)((void *)0));
          }
#line 3758
          if (tmp___37) {
            {
#line 3758
            tmp___38 = pr_fsio_chdir_canon((char const   *)ndir, 1);
            }
#line 3758
            if (tmp___38 != -1) {
#line 3761
              goto while_break___0;
            }
          }
        }
        {
#line 3746
        cdpath = find_config_next(cdpath, cdpath->next, 1 << 15, "CDPath", 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3765
      if (! cdpath) {
        {
#line 3766
        tmp___39 = __errno_location();
#line 3766
        tmp___40 = strerror(*tmp___39);
#line 3766
        pr_response_add_err("550", "%s: %s", odir, tmp___40);
#line 3767
        tmp___41 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 3767
        return (tmp___41);
      }
    }
  }
  {
#line 3772
  tmp___42 = pr_fs_getcwd();
#line 3772
  sstrncpy(session.cwd, tmp___42, (size_t )sizeof(session.cwd));
#line 3773
  tmp___43 = pr_fs_getvwd();
#line 3773
  sstrncpy(session.vwd, tmp___43, (size_t )sizeof(session.vwd));
#line 3775
  pr_scoreboard_entry_update(session.pid, 5, session.cwd, (void *)0);
  }
#line 3779
  if (session.dir_config) {
    {
#line 3780
    c = find_config((session.dir_config)->subset, 1 << 15, "DisplayChdir", 0);
    }
  }
#line 3784
  if (! c) {
#line 3784
    if (session.anon_config) {
      {
#line 3786
      c = find_config((session.anon_config)->subset, 1 << 15, "DisplayChdir", 0);
      }
    }
  }
#line 3790
  if (! c) {
    {
#line 3791
    c = find_config((cmd->server)->conf, 1 << 15, "DisplayChdir", 0);
    }
  }
#line 3794
  if (c) {
#line 3798
    display = (char *)*(c->argv + 0);
#line 3799
    bool = *((int *)*(c->argv + 1));
#line 3801
    if (bool) {
      {
#line 3806
      c = find_config((cmd->server)->conf, 1 << 14, (char const   *)(session.cwd),
                      0);
      }
#line 3808
      if (! c) {
        {
#line 3809
        time(& prev);
#line 3810
        c = add_config_set(& (cmd->server)->conf, (char const   *)(session.cwd));
#line 3811
        c->config_type = 1 << 14;
#line 3812
        c->argc = 1;
#line 3813
        tmp___44 = pcalloc(c->pool, (int )(sizeof(void **) * 2UL));
#line 3813
        c->argv = (void **)tmp___44;
#line 3814
        *(c->argv + 0) = (void *)prev;
#line 3815
        prev = 0L;
        }
      } else {
        {
#line 3818
        prev = (time_t )*(c->argv + 0);
#line 3819
        tmp___45 = time((time_t *)((void *)0));
#line 3819
        *(c->argv + 0) = (void *)tmp___45;
        }
      }
    }
    {
#line 3823
    tmp___49 = pr_fsio_stat((char const   *)display, & st);
    }
#line 3823
    if (tmp___49 != -1) {
#line 3823
      if (! ((st.st_mode & 61440U) == 16384U)) {
#line 3823
        if (bool) {
#line 3823
          tmp___50 = st.st_mtim.tv_sec > prev;
        } else {
#line 3823
          tmp___50 = 1;
        }
#line 3823
        if (tmp___50) {
          {
#line 3827
          tmp___48 = pr_display_file((char const   *)display, (char const   *)(session.cwd),
                                     "250");
          }
#line 3827
          if (tmp___48 < 0) {
            {
#line 3828
            tmp___46 = __errno_location();
#line 3828
            tmp___47 = strerror(*tmp___46);
#line 3828
            pr_log_debug(3, "error displaying \'%s\': %s", display, tmp___47);
            }
          }
        }
      }
    }
  }
  {
#line 3834
  pr_response_add("250", "%s command successful", *(cmd->argv + 0));
#line 3835
  tmp___51 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3835
  return (tmp___51);
}
}
#line 3838 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_rmd(cmd_rec *cmd ) 
{ 
  char *dir ;
  regex_t *preg ;
  modret_t *tmp ;
  xaset_t *tmp___0 ;
  xaset_t *tmp___1 ;
  void *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  xaset_t *tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  int tmp___21 ;
  modret_t *tmp___22 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 3844
  if (cmd->argc < 2) {
    {
#line 3844
    pr_response_add_err("501", "Invalid number of arguments");
#line 3844
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3844
    return (tmp);
  }
  {
#line 3846
  dir = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
  }
#line 3849
  if (session.dir_config) {
#line 3849
    tmp___1 = (session.dir_config)->subset;
  } else {
#line 3849
    if (session.anon_config) {
#line 3849
      tmp___0 = (session.anon_config)->subset;
    } else {
#line 3849
      tmp___0 = main_server->conf;
    }
#line 3849
    tmp___1 = tmp___0;
  }
  {
#line 3849
  tmp___2 = get_param_ptr(tmp___1, "PathAllowFilter", 0);
#line 3849
  preg = (regex_t *)tmp___2;
  }
#line 3851
  if (preg) {
    {
#line 3851
    tmp___4 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)dir,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 3851
    if (tmp___4 != 0) {
      {
#line 3853
      pr_log_debug(2, "\'%s %s\' denied by PathAllowFilter", *(cmd->argv + 0), dir);
#line 3855
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 3856
      tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3856
      return (tmp___3);
    }
  }
#line 3859
  if (session.dir_config) {
#line 3859
    tmp___6 = (session.dir_config)->subset;
  } else {
#line 3859
    if (session.anon_config) {
#line 3859
      tmp___5 = (session.anon_config)->subset;
    } else {
#line 3859
      tmp___5 = main_server->conf;
    }
#line 3859
    tmp___6 = tmp___5;
  }
  {
#line 3859
  tmp___7 = get_param_ptr(tmp___6, "PathDenyFilter", 0);
#line 3859
  preg = (regex_t *)tmp___7;
  }
#line 3861
  if (preg) {
    {
#line 3861
    tmp___9 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)dir,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 3861
    if (tmp___9 == 0) {
      {
#line 3863
      pr_log_debug(2, "\'%s %s\' denied by PathDenyFilter", *(cmd->argv + 0), dir);
#line 3865
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 3866
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3866
      return (tmp___8);
    }
  }
  {
#line 3873
  dir = dir_canonical_path(cmd->tmp_pool, (char const   *)dir);
  }
#line 3875
  if (! dir) {
    {
#line 3876
    tmp___10 = strerror(22);
#line 3876
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___10);
#line 3877
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3877
    return (tmp___11);
  }
  {
#line 3880
  tmp___14 = dir_check_canon(cmd->tmp_pool, (char *)"RMD", cmd->group, dir, (int *)((void *)0));
  }
#line 3880
  if (tmp___14) {
    {
#line 3880
    tmp___15 = dir_check_canon(cmd->tmp_pool, (char *)"XRMD", cmd->group, dir, (int *)((void *)0));
    }
#line 3880
    if (! tmp___15) {
      {
#line 3882
      tmp___12 = strerror(13);
#line 3882
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___12);
#line 3883
      tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3883
      return (tmp___13);
    }
  } else {
    {
#line 3882
    tmp___12 = strerror(13);
#line 3882
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___12);
#line 3883
    tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3883
    return (tmp___13);
  }
  {
#line 3886
  tmp___21 = pr_fsio_rmdir((char const   *)dir);
  }
#line 3886
  if (tmp___21 < 0) {
    {
#line 3887
    tmp___16 = __errno_location();
#line 3887
    tmp___17 = strerror(*tmp___16);
#line 3887
    pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error removing directory \'%s\': %s",
                 *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                 dir, tmp___17);
#line 3892
    tmp___18 = __errno_location();
#line 3892
    tmp___19 = strerror(*tmp___18);
#line 3892
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___19);
#line 3893
    tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3893
    return (tmp___20);
  }
  {
#line 3896
  pr_response_add("250", "%s command successful", *(cmd->argv + 0));
#line 3897
  tmp___22 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 3897
  return (tmp___22);
}
}
#line 3900 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_mkd(cmd_rec *cmd ) 
{ 
  char *dir ;
  struct stat sbuf___0 ;
  regex_t *preg ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  xaset_t *tmp___2 ;
  xaset_t *tmp___3 ;
  void *tmp___4 ;
  modret_t *tmp___5 ;
  int tmp___6 ;
  xaset_t *tmp___7 ;
  xaset_t *tmp___8 ;
  void *tmp___9 ;
  modret_t *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  modret_t *tmp___13 ;
  char *tmp___14 ;
  modret_t *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int xerrno ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  modret_t *tmp___21 ;
  int tmp___22 ;
  int err ;
  int iserr ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  __uid_t tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  register unsigned int i___0 ;
  int res ;
  int use_root_privs ;
  gid_t *group_ids ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  __uid_t tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  int *tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;
  int *tmp___58 ;
  char *tmp___59 ;
  char const   *tmp___60 ;
  char const   *tmp___61 ;
  char const   *tmp___62 ;
  modret_t *tmp___63 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;

  {
#line 3907
  if (cmd->argc < 2) {
    {
#line 3907
    pr_response_add_err("501", "Invalid number of arguments");
#line 3907
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3907
    return (tmp);
  }
  {
#line 3909
  tmp___1 = strchr((char const   *)cmd->arg, '*');
  }
#line 3909
  if (tmp___1) {
    {
#line 3910
    pr_response_add_err("550", "%s: Invalid directory name", *(cmd->argv + 1));
#line 3911
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3911
    return (tmp___0);
  }
  {
#line 3914
  dir = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
  }
#line 3917
  if (session.dir_config) {
#line 3917
    tmp___3 = (session.dir_config)->subset;
  } else {
#line 3917
    if (session.anon_config) {
#line 3917
      tmp___2 = (session.anon_config)->subset;
    } else {
#line 3917
      tmp___2 = main_server->conf;
    }
#line 3917
    tmp___3 = tmp___2;
  }
  {
#line 3917
  tmp___4 = get_param_ptr(tmp___3, "PathAllowFilter", 0);
#line 3917
  preg = (regex_t *)tmp___4;
  }
#line 3919
  if (preg) {
    {
#line 3919
    tmp___6 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)dir,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 3919
    if (tmp___6 != 0) {
      {
#line 3921
      pr_log_debug(2, "\'%s %s\' denied by PathAllowFilter", *(cmd->argv + 0), dir);
#line 3923
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 3924
      tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3924
      return (tmp___5);
    }
  }
#line 3927
  if (session.dir_config) {
#line 3927
    tmp___8 = (session.dir_config)->subset;
  } else {
#line 3927
    if (session.anon_config) {
#line 3927
      tmp___7 = (session.anon_config)->subset;
    } else {
#line 3927
      tmp___7 = main_server->conf;
    }
#line 3927
    tmp___8 = tmp___7;
  }
  {
#line 3927
  tmp___9 = get_param_ptr(tmp___8, "PathDenyFilter", 0);
#line 3927
  preg = (regex_t *)tmp___9;
  }
#line 3929
  if (preg) {
    {
#line 3929
    tmp___11 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)dir,
                       (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 3929
    if (tmp___11 == 0) {
      {
#line 3931
      pr_log_debug(2, "\'%s %s\' denied by PathDenyFilter", *(cmd->argv + 0), dir);
#line 3933
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 3934
      tmp___10 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3934
      return (tmp___10);
    }
  }
  {
#line 3938
  dir = dir_canonical_path(cmd->tmp_pool, (char const   *)dir);
  }
#line 3940
  if (! dir) {
    {
#line 3941
    tmp___12 = strerror(22);
#line 3941
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___12);
#line 3942
    tmp___13 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3942
    return (tmp___13);
  }
  {
#line 3945
  tmp___16 = dir_check_canon(cmd->tmp_pool, (char *)"MKD", cmd->group, dir, (int *)((void *)0));
  }
#line 3945
  if (tmp___16) {
    {
#line 3945
    tmp___17 = dir_check_canon(cmd->tmp_pool, (char *)"XMKD", cmd->group, dir, (int *)((void *)0));
    }
#line 3945
    if (! tmp___17) {
      {
#line 3947
      pr_log_debug(8, "%s command denied by <Limit> config", *(cmd->argv + 0));
#line 3948
      tmp___14 = strerror(13);
#line 3948
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___14);
#line 3949
      tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 3949
      return (tmp___15);
    }
  } else {
    {
#line 3947
    pr_log_debug(8, "%s command denied by <Limit> config", *(cmd->argv + 0));
#line 3948
    tmp___14 = strerror(13);
#line 3948
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___14);
#line 3949
    tmp___15 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3949
    return (tmp___15);
  }
  {
#line 3952
  tmp___22 = pr_fsio_mkdir((char const   *)dir, (mode_t )511);
  }
#line 3952
  if (tmp___22 < 0) {
    {
#line 3953
    tmp___18 = __errno_location();
#line 3953
    xerrno = *tmp___18;
#line 3955
    tmp___19 = strerror(xerrno);
#line 3955
    pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error making directory \'%s\': %s",
                 *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                 dir, tmp___19);
#line 3960
    tmp___20 = strerror(xerrno);
#line 3960
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___20);
#line 3961
    tmp___21 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 3961
    return (tmp___21);
  }
#line 3967
  if (session.fsuid != 4294967295U) {
    {
#line 3968
    err = 0;
#line 3968
    iserr = 0;
#line 3970
    pr_fsio_stat((char const   *)dir, & sbuf___0);
#line 3972
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c",
                 3972);
#line 3972
    pr_signals_block();
    }
#line 3972
    if (! session.disable_id_switching) {
      {
#line 3972
      tmp___25 = seteuid((__uid_t )0);
      }
#line 3972
      if (tmp___25) {
        {
#line 3972
        tmp___23 = __errno_location();
#line 3972
        tmp___24 = strerror(*tmp___23);
#line 3972
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___24);
        }
      }
      {
#line 3972
      tmp___28 = setegid((__gid_t )0);
      }
#line 3972
      if (tmp___28) {
        {
#line 3972
        tmp___26 = __errno_location();
#line 3972
        tmp___27 = strerror(*tmp___26);
#line 3972
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___27);
        }
      }
    } else {
      {
#line 3972
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 3972
    pr_signals_unblock();
#line 3973
    tmp___30 = pr_fsio_chown((char const   *)dir, session.fsuid, session.fsgid);
    }
#line 3973
    if (tmp___30 == -1) {
      {
#line 3974
      iserr ++;
#line 3975
      tmp___29 = __errno_location();
#line 3975
      err = *tmp___29;
      }
    }
    {
#line 3977
    pr_signals_block();
    }
#line 3977
    if (! session.disable_id_switching) {
      {
#line 3977
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c",
                   3977);
#line 3977
      tmp___34 = geteuid();
      }
#line 3977
      if (tmp___34 != 0U) {
        {
#line 3977
        tmp___33 = seteuid((__uid_t )0);
        }
#line 3977
        if (tmp___33) {
          {
#line 3977
          tmp___31 = __errno_location();
#line 3977
          tmp___32 = strerror(*tmp___31);
#line 3977
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___32);
          }
        }
      }
      {
#line 3977
      tmp___37 = setegid(session.gid);
      }
#line 3977
      if (tmp___37) {
        {
#line 3977
        tmp___35 = __errno_location();
#line 3977
        tmp___36 = strerror(*tmp___35);
#line 3977
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___36);
        }
      }
      {
#line 3977
      tmp___40 = seteuid(session.uid);
      }
#line 3977
      if (tmp___40) {
        {
#line 3977
        tmp___38 = __errno_location();
#line 3977
        tmp___39 = strerror(*tmp___38);
#line 3977
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___39);
        }
      }
    } else {
      {
#line 3977
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 3977
    pr_signals_unblock();
    }
#line 3979
    if (iserr) {
      {
#line 3980
      tmp___41 = strerror(err);
#line 3980
      pr_log_pri(4, "chown() as root failed: %s", tmp___41);
      }
    } else
#line 3983
    if (session.fsgid != 4294967295U) {
      {
#line 3984
      pr_log_debug(2, "root chown(%s) to uid %lu, gid %lu successful", dir, (unsigned long )session.fsuid,
                   (unsigned long )session.fsgid);
      }
    } else {
      {
#line 3988
      pr_log_debug(2, "root chown(%s) to uid %lu successful", dir, (unsigned long )session.fsuid);
      }
    }
  } else
#line 3993
  if (session.fsgid != 4294967295U) {
    {
#line 3995
    use_root_privs = 1;
#line 3997
    pr_fsio_stat((char const   *)dir, & sbuf___0);
#line 4000
    i___0 = 0U;
    }
    {
#line 4000
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4000
      if (! (i___0 < (unsigned int )(session.gids)->nelts)) {
#line 4000
        goto while_break;
      }
#line 4001
      group_ids = (gid_t *)(session.gids)->elts;
#line 4003
      if (*(group_ids + i___0) == session.fsgid) {
#line 4004
        use_root_privs = 0;
#line 4005
        goto while_break;
      }
#line 4000
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4009
    if (use_root_privs) {
      {
#line 4010
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c",
                   4010);
#line 4010
      pr_signals_block();
      }
#line 4010
      if (! session.disable_id_switching) {
        {
#line 4010
        tmp___44 = seteuid((__uid_t )0);
        }
#line 4010
        if (tmp___44) {
          {
#line 4010
          tmp___42 = __errno_location();
#line 4010
          tmp___43 = strerror(*tmp___42);
#line 4010
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___43);
          }
        }
        {
#line 4010
        tmp___47 = setegid((__gid_t )0);
        }
#line 4010
        if (tmp___47) {
          {
#line 4010
          tmp___45 = __errno_location();
#line 4010
          tmp___46 = strerror(*tmp___45);
#line 4010
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___46);
          }
        }
      } else {
        {
#line 4010
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 4010
      pr_signals_unblock();
      }
    }
    {
#line 4013
    res = pr_fsio_chown((char const   *)dir, (uid_t )-1, session.fsgid);
    }
#line 4015
    if (use_root_privs) {
      {
#line 4016
      pr_signals_block();
      }
#line 4016
      if (! session.disable_id_switching) {
        {
#line 4016
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c",
                     4016);
#line 4016
        tmp___51 = geteuid();
        }
#line 4016
        if (tmp___51 != 0U) {
          {
#line 4016
          tmp___50 = seteuid((__uid_t )0);
          }
#line 4016
          if (tmp___50) {
            {
#line 4016
            tmp___48 = __errno_location();
#line 4016
            tmp___49 = strerror(*tmp___48);
#line 4016
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___49);
            }
          }
        }
        {
#line 4016
        tmp___54 = setegid(session.gid);
        }
#line 4016
        if (tmp___54) {
          {
#line 4016
          tmp___52 = __errno_location();
#line 4016
          tmp___53 = strerror(*tmp___52);
#line 4016
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___53);
          }
        }
        {
#line 4016
        tmp___57 = seteuid(session.uid);
        }
#line 4016
        if (tmp___57) {
          {
#line 4016
          tmp___55 = __errno_location();
#line 4016
          tmp___56 = strerror(*tmp___55);
#line 4016
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___56);
          }
        }
      } else {
        {
#line 4016
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 4016
      pr_signals_unblock();
      }
    }
#line 4019
    if (res == -1) {
      {
#line 4020
      tmp___58 = __errno_location();
#line 4020
      tmp___59 = strerror(*tmp___58);
      }
#line 4020
      if (use_root_privs) {
#line 4020
        tmp___60 = "root ";
      } else {
#line 4020
        tmp___60 = "";
      }
      {
#line 4020
      pr_log_pri(4, "%schown() failed: %s", tmp___60, tmp___59);
      }
    } else {
#line 4024
      if (use_root_privs) {
#line 4024
        tmp___61 = "root ";
      } else {
#line 4024
        tmp___61 = "";
      }
      {
#line 4024
      pr_log_debug(2, "%schown(%s) to gid %lu successful", tmp___61, dir, (unsigned long )session.fsgid);
      }
    }
  }
  {
#line 4029
  tmp___62 = quote_dir(cmd, dir);
#line 4029
  pr_response_add("257", "\"%s\" - Directory successfully created", tmp___62);
#line 4032
  tmp___63 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4032
  return (tmp___63);
}
}
#line 4035 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_cwd(cmd_rec *cmd ) 
{ 
  char *dir ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 4037
  if (cmd->argc < 2) {
    {
#line 4037
    pr_response_add_err("501", "Invalid number of arguments");
#line 4037
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4037
    return (tmp);
  }
  {
#line 4039
  dir = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 4040
  tmp___0 = _chdir(cmd, dir);
  }
#line 4040
  return (tmp___0);
}
}
#line 4043 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_cdup(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  modret_t *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 4044
  if (cmd->argc != 1) {
    {
#line 4044
    pr_response_add_err("501", "Invalid number of arguments");
#line 4044
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4044
    return (tmp);
  }
  {
#line 4045
  tmp___0 = _chdir(cmd, (char *)"..");
  }
#line 4045
  return (tmp___0);
}
}
#line 4050 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_mdtm(cmd_rec *cmd ) 
{ 
  char *path ;
  struct stat st ;
  modret_t *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  modret_t *tmp___3 ;
  modret_t *tmp___4 ;
  char buf___2[16] ;
  struct tm *tm ;
  int tmp___5 ;
  int tmp___6 ;
  modret_t *tmp___7 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 4054
  if (cmd->argc < 2) {
    {
#line 4054
    pr_response_add_err("501", "Invalid number of arguments");
#line 4054
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4054
    return (tmp);
  }
  {
#line 4056
  tmp___0 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 4056
  path = dir_realpath(cmd->tmp_pool, (char const   *)tmp___0);
  }
#line 4059
  if (! path) {
    {
#line 4062
    tmp___1 = __errno_location();
#line 4062
    tmp___2 = strerror(*tmp___1);
#line 4062
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___2);
#line 4063
    tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4063
    return (tmp___3);
  } else {
    {
#line 4059
    tmp___5 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, path, (int *)((void *)0));
    }
#line 4059
    if (tmp___5) {
      {
#line 4059
      tmp___6 = pr_fsio_stat((char const   *)path, & st);
      }
#line 4059
      if (tmp___6 == -1) {
        {
#line 4062
        tmp___1 = __errno_location();
#line 4062
        tmp___2 = strerror(*tmp___1);
#line 4062
        pr_response_add_err("550", "%s: %s", cmd->arg, tmp___2);
#line 4063
        tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 4063
        return (tmp___3);
      } else
#line 4067
      if (! ((st.st_mode & 61440U) == 32768U)) {
        {
#line 4068
        pr_response_add_err("550", "%s: not a plain file", cmd->arg);
#line 4069
        tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 4069
        return (tmp___4);
      } else {
        {
#line 4075
        memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 4077
        tm = pr_gmtime(cmd->tmp_pool, (time_t const   *)(& st.st_mtim.tv_sec));
        }
#line 4078
        if (tm) {
          {
#line 4079
          snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%04d%02d%02d%02d%02d%02d",
                   tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min,
                   tm->tm_sec);
          }
        } else {
          {
#line 4084
          snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"00000000000000");
          }
        }
        {
#line 4087
        pr_response_add("213", "%s", buf___2);
        }
      }
    } else {
      {
#line 4062
      tmp___1 = __errno_location();
#line 4062
      tmp___2 = strerror(*tmp___1);
#line 4062
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___2);
#line 4063
      tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4063
      return (tmp___3);
    }
  }
  {
#line 4091
  tmp___7 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4091
  return (tmp___7);
}
}
#line 4094 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_size(cmd_rec *cmd ) 
{ 
  char *path ;
  struct stat st ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  modret_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  modret_t *tmp___8 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 4098
  if (cmd->argc < 2) {
    {
#line 4098
    pr_response_add_err("501", "Invalid number of arguments");
#line 4098
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4098
    return (tmp);
  }
#line 4101
  if (session.sf_flags & (int volatile   )16) {
    {
#line 4102
    pr_log_debug(5, "%s not allowed in ASCII mode", *(cmd->argv + 0));
#line 4103
    pr_response_add_err("550", "%s not allowed in ASCII mode", *(cmd->argv + 0));
#line 4104
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4104
    return (tmp___0);
  }
  {
#line 4107
  tmp___1 = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
#line 4107
  path = dir_realpath(cmd->tmp_pool, (char const   *)tmp___1);
  }
#line 4110
  if (! path) {
    {
#line 4113
    tmp___2 = __errno_location();
#line 4113
    tmp___3 = strerror(*tmp___2);
#line 4113
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 4114
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4114
    return (tmp___4);
  } else {
    {
#line 4110
    tmp___6 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, path, (int *)((void *)0));
    }
#line 4110
    if (tmp___6) {
      {
#line 4110
      tmp___7 = pr_fsio_stat((char const   *)path, & st);
      }
#line 4110
      if (tmp___7 == -1) {
        {
#line 4113
        tmp___2 = __errno_location();
#line 4113
        tmp___3 = strerror(*tmp___2);
#line 4113
        pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 4114
        tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 4114
        return (tmp___4);
      } else
#line 4117
      if (! ((st.st_mode & 61440U) == 32768U)) {
        {
#line 4118
        pr_response_add_err("550", "%s: not a regular file", cmd->arg);
#line 4119
        tmp___5 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 4119
        return (tmp___5);
      } else {
        {
#line 4122
        pr_response_add("213", "%llu", (unsigned long long )st.st_size);
        }
      }
    } else {
      {
#line 4113
      tmp___2 = __errno_location();
#line 4113
      tmp___3 = strerror(*tmp___2);
#line 4113
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___3);
#line 4114
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4114
      return (tmp___4);
    }
  }
  {
#line 4125
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4125
  return (tmp___8);
}
}
#line 4128 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_dele(cmd_rec *cmd ) 
{ 
  char *path ;
  char *fullpath ;
  struct stat st ;
  regex_t *preg ;
  modret_t *tmp ;
  xaset_t *tmp___0 ;
  xaset_t *tmp___1 ;
  void *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  xaset_t *tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  modret_t *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  modret_t *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  modret_t *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  modret_t *tmp___32 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 4136
  if (cmd->argc < 2) {
    {
#line 4136
    pr_response_add_err("501", "Invalid number of arguments");
#line 4136
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4136
    return (tmp);
  }
  {
#line 4138
  path = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
  }
#line 4141
  if (session.dir_config) {
#line 4141
    tmp___1 = (session.dir_config)->subset;
  } else {
#line 4141
    if (session.anon_config) {
#line 4141
      tmp___0 = (session.anon_config)->subset;
    } else {
#line 4141
      tmp___0 = main_server->conf;
    }
#line 4141
    tmp___1 = tmp___0;
  }
  {
#line 4141
  tmp___2 = get_param_ptr(tmp___1, "PathAllowFilter", 0);
#line 4141
  preg = (regex_t *)tmp___2;
  }
#line 4143
  if (preg) {
    {
#line 4143
    tmp___4 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 4143
    if (tmp___4 != 0) {
      {
#line 4145
      pr_log_debug(2, "\'%s %s\' denied by PathAllowFilter", *(cmd->argv + 0), path);
#line 4147
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 4148
      tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4148
      return (tmp___3);
    }
  }
#line 4151
  if (session.dir_config) {
#line 4151
    tmp___6 = (session.dir_config)->subset;
  } else {
#line 4151
    if (session.anon_config) {
#line 4151
      tmp___5 = (session.anon_config)->subset;
    } else {
#line 4151
      tmp___5 = main_server->conf;
    }
#line 4151
    tmp___6 = tmp___5;
  }
  {
#line 4151
  tmp___7 = get_param_ptr(tmp___6, "PathDenyFilter", 0);
#line 4151
  preg = (regex_t *)tmp___7;
  }
#line 4153
  if (preg) {
    {
#line 4153
    tmp___9 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 4153
    if (tmp___9 == 0) {
      {
#line 4155
      pr_log_debug(2, "\'%s %s\' denied by PathDenyFilter", *(cmd->argv + 0), path);
#line 4157
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 4158
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4158
      return (tmp___8);
    }
  }
  {
#line 4163
  path = dir_canonical_path(cmd->tmp_pool, (char const   *)path);
  }
#line 4164
  if (! path) {
    {
#line 4165
    tmp___10 = strerror(2);
#line 4165
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___10);
#line 4166
    tmp___11 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4166
    return (tmp___11);
  }
  {
#line 4169
  tmp___15 = dir_check_canon(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, path, (int *)((void *)0));
  }
#line 4169
  if (! tmp___15) {
    {
#line 4170
    tmp___12 = __errno_location();
#line 4170
    tmp___13 = strerror(*tmp___12);
#line 4170
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___13);
#line 4171
    tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4171
    return (tmp___14);
  }
  {
#line 4177
  memset((void *)(& st), 0, (size_t )sizeof(st));
#line 4178
  pr_fs_clear_cache();
#line 4179
  tmp___21 = pr_fsio_stat((char const   *)path, & st);
  }
#line 4179
  if (tmp___21 < 0) {
    {
#line 4180
    tmp___16 = __errno_location();
#line 4180
    tmp___17 = strerror(*tmp___16);
#line 4180
    pr_log_debug(3, "unable to stat \'%s\': %s", path, tmp___17);
#line 4181
    tmp___18 = __errno_location();
#line 4181
    tmp___19 = strerror(*tmp___18);
#line 4181
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___19);
#line 4182
    tmp___20 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4182
    return (tmp___20);
  }
  {
#line 4185
  tmp___29 = pr_fsio_unlink((char const   *)path);
  }
#line 4185
  if (tmp___29 < 0) {
    {
#line 4186
    tmp___22 = __errno_location();
#line 4186
    tmp___23 = strerror(*tmp___22);
#line 4186
    pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error deleting \'%s\': %s",
                 *(cmd->argv + 0), session.user, (unsigned long )session.uid, (unsigned long )session.gid,
                 path, tmp___23);
#line 4191
    tmp___24 = __errno_location();
#line 4191
    tmp___25 = strerror(*tmp___24);
#line 4191
    pr_log_debug(3, "error deleting \'%s\': %s", path, tmp___25);
#line 4192
    tmp___26 = __errno_location();
#line 4192
    tmp___27 = strerror(*tmp___26);
#line 4192
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___27);
#line 4193
    tmp___28 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4193
    return (tmp___28);
  }
  {
#line 4196
  fullpath = dir_abs_path(cmd->tmp_pool, (char const   *)path, 1);
  }
#line 4198
  if (session.sf_flags & (int volatile   )64) {
#line 4199
    if (session.sf_flags & (int volatile   )16) {
#line 4199
      tmp___30 = 'a';
    } else {
#line 4199
      tmp___30 = 'b';
    }
    {
#line 4199
    xferlog_write(0L, (session.c)->remote_name, st.st_size, fullpath, (char )tmp___30,
                  (char )'d', (char )'a', session.anon_user, (char )'c');
    }
  } else {
#line 4204
    if (session.sf_flags & (int volatile   )16) {
#line 4204
      tmp___31 = 'a';
    } else {
#line 4204
      tmp___31 = 'b';
    }
    {
#line 4204
    xferlog_write(0L, (session.c)->remote_name, st.st_size, fullpath, (char )tmp___31,
                  (char )'d', (char )'r', session.user, (char )'c');
    }
  }
  {
#line 4208
  pr_response_add("250", "%s command successful", *(cmd->argv + 0));
#line 4209
  tmp___32 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4209
  return (tmp___32);
}
}
#line 4212 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_rnto(cmd_rec *cmd ) 
{ 
  char *path ;
  unsigned char *allow_overwrite ;
  struct stat st ;
  regex_t *preg ;
  modret_t *tmp ;
  modret_t *tmp___0 ;
  xaset_t *tmp___1 ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  modret_t *tmp___4 ;
  int tmp___5 ;
  xaset_t *tmp___6 ;
  xaset_t *tmp___7 ;
  void *tmp___8 ;
  modret_t *tmp___9 ;
  int tmp___10 ;
  xaset_t *tmp___11 ;
  xaset_t *tmp___12 ;
  void *tmp___13 ;
  modret_t *tmp___14 ;
  int tmp___15 ;
  int xerrno ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  modret_t *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  modret_t *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  modret_t *tmp___30 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
#line 4214
  allow_overwrite = (unsigned char *)((void *)0);
#line 4221
  if (cmd->argc < 2) {
    {
#line 4221
    pr_response_add_err("501", "Invalid number of arguments");
#line 4221
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4221
    return (tmp);
  }
#line 4223
  if (! session.xfer.path) {
#line 4224
    if (session.xfer.p) {
      {
#line 4225
      destroy_pool(session.xfer.p);
#line 4226
      memset((void *)(& session.xfer), '\000', (size_t )sizeof(session.xfer));
      }
    }
    {
#line 4229
    pr_response_add_err("503", "Bad sequence of commands");
#line 4230
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4230
    return (tmp___0);
  }
  {
#line 4233
  path = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
  }
#line 4236
  if (session.dir_config) {
#line 4236
    tmp___2 = (session.dir_config)->subset;
  } else {
#line 4236
    if (session.anon_config) {
#line 4236
      tmp___1 = (session.anon_config)->subset;
    } else {
#line 4236
      tmp___1 = main_server->conf;
    }
#line 4236
    tmp___2 = tmp___1;
  }
  {
#line 4236
  tmp___3 = get_param_ptr(tmp___2, "PathAllowFilter", 0);
#line 4236
  preg = (regex_t *)tmp___3;
  }
#line 4238
  if (preg) {
    {
#line 4238
    tmp___5 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 4238
    if (tmp___5 != 0) {
      {
#line 4240
      pr_log_debug(2, "\'%s %s\' denied by PathAllowFilter", *(cmd->argv + 0), path);
#line 4242
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 4243
      tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4243
      return (tmp___4);
    }
  }
#line 4246
  if (session.dir_config) {
#line 4246
    tmp___7 = (session.dir_config)->subset;
  } else {
#line 4246
    if (session.anon_config) {
#line 4246
      tmp___6 = (session.anon_config)->subset;
    } else {
#line 4246
      tmp___6 = main_server->conf;
    }
#line 4246
    tmp___7 = tmp___6;
  }
  {
#line 4246
  tmp___8 = get_param_ptr(tmp___7, "PathDenyFilter", 0);
#line 4246
  preg = (regex_t *)tmp___8;
  }
#line 4248
  if (preg) {
    {
#line 4248
    tmp___10 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                       (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 4248
    if (tmp___10 == 0) {
      {
#line 4250
      pr_log_debug(2, "\'%s %s\' denied by PathDenyFilter", *(cmd->argv + 0), path);
#line 4252
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 4253
      tmp___9 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4253
      return (tmp___9);
    }
  }
  {
#line 4257
  path = dir_canonical_path(cmd->tmp_pool, (char const   *)path);
  }
#line 4259
  if (session.dir_config) {
#line 4259
    tmp___12 = (session.dir_config)->subset;
  } else {
#line 4259
    if (session.anon_config) {
#line 4259
      tmp___11 = (session.anon_config)->subset;
    } else {
#line 4259
      tmp___11 = main_server->conf;
    }
#line 4259
    tmp___12 = tmp___11;
  }
  {
#line 4259
  tmp___13 = get_param_ptr(tmp___12, "AllowOverwrite", 0);
#line 4259
  allow_overwrite = (unsigned char *)tmp___13;
#line 4264
  pr_fs_clear_cache();
  }
#line 4265
  if (! allow_overwrite) {
#line 4265
    goto _L;
  } else
#line 4265
  if ((int )*allow_overwrite == 0) {
    _L: /* CIL Label */ 
    {
#line 4265
    tmp___15 = pr_fsio_stat((char const   *)path, & st);
    }
#line 4265
    if (tmp___15 == 0) {
      {
#line 4267
      pr_log_debug(6, "AllowOverwrite denied permission for %s", path);
#line 4268
      pr_response_add_err("550", "%s: Rename permission denied", cmd->arg);
#line 4269
      tmp___14 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4269
      return (tmp___14);
    }
  }
#line 4272
  if (! path) {
#line 4272
    goto _L___0;
  } else {
    {
#line 4272
    tmp___28 = dir_check_canon(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, path,
                               (int *)((void *)0));
    }
#line 4272
    if (tmp___28) {
      {
#line 4272
      tmp___29 = pr_fsio_rename((char const   *)session.xfer.path, (char const   *)path);
      }
#line 4272
      if (tmp___29 == -1) {
        _L___0: /* CIL Label */ 
        {
#line 4275
        tmp___16 = __errno_location();
#line 4275
        xerrno = *tmp___16;
        }
#line 4277
        if (xerrno != 18) {
          {
#line 4278
          tmp___17 = strerror(xerrno);
#line 4278
          pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error renaming \'%s\' to \'%s\': %s",
                       *(cmd->argv + 0), session.user, (unsigned long )session.uid,
                       (unsigned long )session.gid, session.xfer.path, path, tmp___17);
#line 4283
          tmp___18 = strerror(xerrno);
#line 4283
          pr_response_add_err("550", "Rename %s: %s", cmd->arg, tmp___18);
#line 4284
          tmp___19 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 4284
          return (tmp___19);
        }
        {
#line 4290
        tmp___24 = pr_fs_copy_file((char const   *)session.xfer.path, (char const   *)path);
        }
#line 4290
        if (tmp___24 < 0) {
          {
#line 4291
          tmp___20 = __errno_location();
#line 4291
          xerrno = *tmp___20;
#line 4293
          tmp___21 = strerror(xerrno);
#line 4293
          pr_trace_msg("fileperms", 1, "%s, user \'%s\' (UID %lu, GID %lu): error copying \'%s\' to \'%s\': %s",
                       *(cmd->argv + 0), session.user, (unsigned long )session.uid,
                       (unsigned long )session.gid, session.xfer.path, path, tmp___21);
#line 4298
          tmp___22 = strerror(xerrno);
#line 4298
          pr_response_add_err("550", "Rename %s: %s", cmd->arg, tmp___22);
#line 4299
          tmp___23 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
          }
#line 4299
          return (tmp___23);
        }
        {
#line 4303
        tmp___27 = pr_fsio_unlink((char const   *)session.xfer.path);
        }
#line 4303
        if (tmp___27 < 0) {
          {
#line 4304
          tmp___25 = __errno_location();
#line 4304
          tmp___26 = strerror(*tmp___25);
#line 4304
          pr_log_debug(0, "error unlinking \'%s\': %s", session.xfer.path, tmp___26);
          }
        }
      }
    } else {
#line 4272
      goto _L___0;
    }
  }
  {
#line 4309
  session.xfer.path = pstrdup(session.xfer.p, (char const   *)path);
#line 4311
  pr_response_add("250", "Rename successful");
#line 4312
  tmp___30 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4312
  return (tmp___30);
}
}
#line 4315 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_rnto_cleanup(cmd_rec *cmd ) 
{ 


  {
#line 4316
  if (session.xfer.p) {
    {
#line 4317
    destroy_pool(session.xfer.p);
    }
  }
  {
#line 4319
  memset((void *)(& session.xfer), '\000', (size_t )sizeof(session.xfer));
  }
#line 4320
  return ((modret_t *)((void *)0));
}
}
#line 4323 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_rnfr(cmd_rec *cmd ) 
{ 
  char *path ;
  regex_t *preg ;
  modret_t *tmp ;
  xaset_t *tmp___0 ;
  xaset_t *tmp___1 ;
  void *tmp___2 ;
  modret_t *tmp___3 ;
  int tmp___4 ;
  xaset_t *tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  modret_t *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  modret_t *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  modret_t *tmp___15 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 4329
  if (cmd->argc < 2) {
    {
#line 4329
    pr_response_add_err("501", "Invalid number of arguments");
#line 4329
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4329
    return (tmp);
  }
  {
#line 4331
  path = pr_fs_decode_path(cmd->tmp_pool, (char const   *)cmd->arg);
  }
#line 4334
  if (session.dir_config) {
#line 4334
    tmp___1 = (session.dir_config)->subset;
  } else {
#line 4334
    if (session.anon_config) {
#line 4334
      tmp___0 = (session.anon_config)->subset;
    } else {
#line 4334
      tmp___0 = main_server->conf;
    }
#line 4334
    tmp___1 = tmp___0;
  }
  {
#line 4334
  tmp___2 = get_param_ptr(tmp___1, "PathAllowFilter", 0);
#line 4334
  preg = (regex_t *)tmp___2;
  }
#line 4336
  if (preg) {
    {
#line 4336
    tmp___4 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 4336
    if (tmp___4 != 0) {
      {
#line 4338
      pr_log_debug(2, "\'%s %s\' denied by PathAllowFilter", *(cmd->argv + 0), path);
#line 4340
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 4341
      tmp___3 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4341
      return (tmp___3);
    }
  }
#line 4344
  if (session.dir_config) {
#line 4344
    tmp___6 = (session.dir_config)->subset;
  } else {
#line 4344
    if (session.anon_config) {
#line 4344
      tmp___5 = (session.anon_config)->subset;
    } else {
#line 4344
      tmp___5 = main_server->conf;
    }
#line 4344
    tmp___6 = tmp___5;
  }
  {
#line 4344
  tmp___7 = get_param_ptr(tmp___6, "PathDenyFilter", 0);
#line 4344
  preg = (regex_t *)tmp___7;
  }
#line 4346
  if (preg) {
    {
#line 4346
    tmp___9 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)path,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 4346
    if (tmp___9 == 0) {
      {
#line 4348
      pr_log_debug(2, "\'%s %s\' denied by PathDenyFilter", *(cmd->argv + 0), path);
#line 4350
      pr_response_add_err("550", "%s: Forbidden filename", cmd->arg);
#line 4351
      tmp___8 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4351
      return (tmp___8);
    }
  }
  {
#line 4356
  path = dir_canonical_path(cmd->tmp_pool, (char const   *)path);
  }
#line 4358
  if (! path) {
    {
#line 4361
    tmp___10 = __errno_location();
#line 4361
    tmp___11 = strerror(*tmp___10);
#line 4361
    pr_response_add_err("550", "%s: %s", cmd->arg, tmp___11);
#line 4362
    tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4362
    return (tmp___12);
  } else {
    {
#line 4358
    tmp___13 = dir_check_canon(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, path,
                               (int *)((void *)0));
    }
#line 4358
    if (tmp___13) {
      {
#line 4358
      tmp___14 = exists(path);
      }
#line 4358
      if (! tmp___14) {
        {
#line 4361
        tmp___10 = __errno_location();
#line 4361
        tmp___11 = strerror(*tmp___10);
#line 4361
        pr_response_add_err("550", "%s: %s", cmd->arg, tmp___11);
#line 4362
        tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
        }
#line 4362
        return (tmp___12);
      }
    } else {
      {
#line 4361
      tmp___10 = __errno_location();
#line 4361
      tmp___11 = strerror(*tmp___10);
#line 4361
      pr_response_add_err("550", "%s: %s", cmd->arg, tmp___11);
#line 4362
      tmp___12 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
      }
#line 4362
      return (tmp___12);
    }
  }
#line 4366
  if (session.xfer.p) {
    {
#line 4367
    destroy_pool(session.xfer.p);
#line 4368
    memset((void *)(& session.xfer), '\000', (size_t )sizeof(session.xfer));
    }
  }
  {
#line 4371
  session.xfer.p = make_sub_pool(session.pool);
#line 4372
  pr_pool_tag(session.xfer.p, "session xfer pool");
#line 4374
  session.xfer.path = pstrdup(session.xfer.p, (char const   *)path);
#line 4375
  pr_response_add("350", "File or directory exists, ready for destination name");
#line 4378
  tmp___15 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4378
  return (tmp___15);
}
}
#line 4381 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_noop(cmd_rec *cmd ) 
{ 
  modret_t *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 4382
  pr_response_add("200", "NOOP command successful");
#line 4383
  tmp = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4383
  return (tmp);
}
}
#line 4386 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_feat(cmd_rec *cmd ) 
{ 
  char const   *feat ;
  modret_t *tmp ;
  char *tmp___0 ;
  modret_t *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *next ;
  char *tmp___4 ;
  modret_t *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4387
  feat = (char const   *)((void *)0);
#line 4388
  if (cmd->argc != 1) {
    {
#line 4388
    pr_response_add_err("501", "Invalid number of arguments");
#line 4388
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4388
    return (tmp);
  }
  {
#line 4390
  tmp___2 = dir_check(cmd->tmp_pool, *(cmd->argv + 0), cmd->group, session.vwd, (int *)((void *)0));
  }
#line 4390
  if (! tmp___2) {
    {
#line 4391
    pr_log_debug(3, "%s command denied by <Limit> configuration", *(cmd->argv + 0));
#line 4393
    tmp___0 = strerror(1);
#line 4393
    pr_response_add_err("550", "%s: %s", *(cmd->argv + 0), tmp___0);
#line 4394
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4394
    return (tmp___1);
  }
  {
#line 4397
  feat = pr_feat_get();
  }
#line 4398
  if (feat) {
    {
#line 4399
    tmp___3 = pstrcat(cmd->tmp_pool, "Features:\n ", feat, (void *)0);
#line 4399
    feat = (char const   *)tmp___3;
    }
    {
#line 4400
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 4403
      pr_signals_handle();
#line 4405
      next = pr_feat_get_next();
      }
#line 4406
      if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 4407
        goto while_break;
      }
      {
#line 4410
      tmp___4 = pstrcat(cmd->tmp_pool, feat, "\n ", next, (void *)0);
#line 4410
      feat = (char const   *)tmp___4;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4413
    pr_response_add("211", "%s", feat);
#line 4414
    pr_response_add((char const   *)((void *)0), "End");
    }
  } else {
    {
#line 4417
    pr_response_add("211", "No features supported");
    }
  }
  {
#line 4420
  tmp___5 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4420
  return (tmp___5);
}
}
#line 4423 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_opts(cmd_rec *cmd ) 
{ 
  register unsigned int i___0 ;
  int res ;
  char *arg ;
  cmd_rec *subcmd ;
  modret_t *tmp ;
  char const   *tmp___0 ;
  modret_t *tmp___1 ;
  modret_t *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 4426
  arg = (char *)"";
#line 4429
  if (cmd->argc < 2) {
    {
#line 4429
    pr_response_add_err("501", "Invalid number of arguments");
#line 4429
    tmp = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4429
    return (tmp);
  }
  {
#line 4431
  subcmd = pr_cmd_alloc(cmd->tmp_pool, cmd->argc - 1, (void *)0);
#line 4432
  *(subcmd->argv + 0) = pstrcat(cmd->tmp_pool, "OPTS_", *(cmd->argv + 1), (void *)0);
#line 4434
  i___0 = 2U;
  }
  {
#line 4434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4434
    if (! (i___0 < (unsigned int )cmd->argc)) {
#line 4434
      goto while_break;
    }
#line 4435
    *(subcmd->argv + (i___0 - 1U)) = *(cmd->argv + i___0);
#line 4437
    if (*arg) {
#line 4437
      tmp___0 = " ";
    } else {
#line 4437
      tmp___0 = "";
    }
    {
#line 4437
    arg = pstrcat(cmd->tmp_pool, arg, tmp___0, *(cmd->argv + i___0), (void *)0);
#line 4434
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4440
  subcmd->arg = arg;
#line 4442
  res = pr_cmd_dispatch(subcmd);
  }
#line 4443
  if (res < 0) {
    {
#line 4444
    tmp___1 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), (char *)((void *)0));
    }
#line 4444
    return (tmp___1);
  }
  {
#line 4446
  tmp___2 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4446
  return (tmp___2);
}
}
#line 4449 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *core_post_pass(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  xaset_t *tmp ;
  int prev_timeout ;
  int timeout ;
  modret_t *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 4452
  if (session.anon_config) {
#line 4452
    tmp = (session.anon_config)->subset;
  } else {
#line 4452
    tmp = main_server->conf;
  }
  {
#line 4452
  c = find_config(tmp, 1 << 15, "TimeoutIdle", 0);
  }
#line 4453
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 4456
    prev_timeout = pr_data_get_timeout(1);
#line 4457
    timeout = *((int *)*(c->argv + 0));
    }
#line 4459
    if (timeout != prev_timeout) {
      {
#line 4460
      pr_data_set_timeout(1, timeout);
#line 4465
      pr_timer_remove(2, & core_module);
      }
#line 4467
      if (timeout > 0) {
        {
#line 4468
        pr_timer_add(timeout, 2, (module *)((void *)0), & core_idle_timeout_cb, "TimeoutIdle");
        }
      }
    }
  }
  {
#line 4480
  tmp___0 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4480
  return (tmp___0);
}
}
#line 4483 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_defaulttransfermode(cmd_rec *cmd ) 
{ 
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  modret_t *tmp___10 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4484
  if (cmd->argc - 1 < 1) {
    {
#line 4484
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 4484
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 4484
    return (tmp___0);
  }
  {
#line 4485
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 4485
  if (! tmp___5) {
    {
#line 4485
    tmp___1 = get_context_name(cmd);
#line 4485
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 4485
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 4485
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 4485
    return (tmp___4);
  }
  {
#line 4487
  tmp___8 = strcasecmp((char const   *)*(cmd->argv + 1), "ascii");
  }
#line 4487
  if (tmp___8 != 0) {
    {
#line 4487
    tmp___9 = strcasecmp((char const   *)*(cmd->argv + 1), "binary");
    }
#line 4487
    if (tmp___9 != 0) {
      {
#line 4489
      tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "parameter must be \'ascii\' or \'binary\'",
                        (void *)0);
#line 4489
      tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
      }
#line 4489
      return (tmp___7);
    }
  }
  {
#line 4491
  add_config_param_str((char const   *)*(cmd->argv + 0), 1, *(cmd->argv + 1));
#line 4493
  tmp___10 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4493
  return (tmp___10);
}
}
#line 4496 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static modret_t *set_deferwelcome(cmd_rec *cmd ) 
{ 
  int bool ;
  config_rec *c ;
  char *tmp ;
  modret_t *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  modret_t *tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  modret_t *tmp___7 ;
  modret_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 4497
  bool = -1;
#line 4498
  c = (config_rec *)((void *)0);
#line 4500
  if (cmd->argc - 1 < 1) {
    {
#line 4500
    tmp = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "missing arguments", (void *)0);
#line 4500
    tmp___0 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp);
    }
#line 4500
    return (tmp___0);
  }
  {
#line 4501
  tmp___5 = check_context(cmd, (1 | (1 << 4)) | (1 << 6));
  }
#line 4501
  if (! tmp___5) {
    {
#line 4501
    tmp___1 = get_context_name(cmd);
#line 4501
    tmp___2 = pstrcat(cmd->tmp_pool, "directive not allowed in ", tmp___1, " context",
                      (void *)0);
#line 4501
    tmp___3 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", tmp___2, (void *)0);
#line 4501
    tmp___4 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___3);
    }
#line 4501
    return (tmp___4);
  }
  {
#line 4503
  bool = get_boolean(cmd, 1);
  }
#line 4504
  if (bool == -1) {
    {
#line 4505
    tmp___6 = pstrcat(cmd->tmp_pool, *(cmd->argv + 0), ": ", "expected Boolean parameter",
                      (void *)0);
#line 4505
    tmp___7 = mod_create_ret(cmd, (unsigned char)1, (char *)((void *)0), tmp___6);
    }
#line 4505
    return (tmp___7);
  }
  {
#line 4507
  c = add_config_param((char const   *)*(cmd->argv + 0), 1, (void *)0);
#line 4508
  *(c->argv + 0) = pcalloc(c->pool, (int )sizeof(unsigned char ));
#line 4509
  *((unsigned char *)*(c->argv + 0)) = (unsigned char )bool;
#line 4511
  tmp___8 = mod_create_ret(cmd, (unsigned char)0, (char *)((void *)0), (char *)((void *)0));
  }
#line 4511
  return (tmp___8);
}
}
#line 4517 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static char const   *core_get_sess_bytes_str(void *data , size_t datasz ) 
{ 
  char buf___2[1024] ;
  off_t___0 bytes ;
  char *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 4519
  bytes = *((off_t___0 *)data);
#line 4521
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 4522
  snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%llu",
           (unsigned long long )bytes);
#line 4524
  tmp = pstrdup(session.pool, (char const   *)(buf___2));
  }
#line 4524
  return ((char const   *)tmp);
}
}
#line 4527 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static char const   *core_get_sess_files_str(void *data , size_t datasz ) 
{ 
  char buf___2[1024] ;
  unsigned int files ;
  char *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 4529
  files = *((unsigned int *)data);
#line 4531
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 4532
  snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%u",
           files);
#line 4534
  tmp = pstrdup(session.pool, (char const   *)(buf___2));
  }
#line 4534
  return ((char const   *)tmp);
}
}
#line 4540 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static void core_restart_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 4541
  pr_scoreboard_scrub();
  }
#line 4544
  if (trace_log) {
    {
#line 4545
    pr_trace_set_level("ALL", -1);
#line 4546
    pr_trace_set_file((char const   *)((void *)0));
#line 4547
    trace_log = (char const   *)((void *)0);
    }
  }
#line 4550
  return;
}
}
#line 4552 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static void core_startup_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 4555
  core_scrub_timer_id = pr_timer_add(30, -1, & core_module, & core_scrub_scoreboard_cb,
                                     "scoreboard scrubbing");
#line 4559
  pr_event_register(& core_module, "core.restart", & core_restart_ev, (void *)0);
  }
#line 4560
  return;
}
}
#line 4565 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static int core_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
  {
#line 4567
  pr_cmd_set_handler((void (*)(server_rec * , conn_t * ))((void *)0));
#line 4570
  pr_help_add("CWD", "<sp> pathname", 1);
#line 4571
  pr_help_add("XCWD", "<sp> pathname", 1);
#line 4572
  pr_help_add("CDUP", "(up one directory)", 1);
#line 4573
  pr_help_add("XCUP", "(up one directory)", 1);
#line 4574
  pr_help_add("SMNT", "is not implemented", 0);
#line 4575
  pr_help_add("QUIT", "(close control connection)", 1);
#line 4576
  pr_help_add("PORT", "<sp> h1,h2,h3,h4,p1,p2", 1);
#line 4577
  pr_help_add("PASV", "(returns address/port)", 1);
#line 4578
  pr_help_add("EPRT", "<sp> |proto|addr|port|", 1);
#line 4579
  pr_help_add("EPSV", "(returns port |||port|)", 1);
#line 4580
  pr_help_add("ALLO", "is not implemented (ignored)", 0);
#line 4581
  pr_help_add("RNFR", "<sp> pathname", 1);
#line 4582
  pr_help_add("RNTO", "<sp> pathname", 1);
#line 4583
  pr_help_add("DELE", "<sp> pathname", 1);
#line 4584
  pr_help_add("MDTM", "<sp> pathname", 1);
#line 4585
  pr_help_add("RMD", "<sp> pathname", 1);
#line 4586
  pr_help_add("XRMD", "<sp> pathname", 1);
#line 4587
  pr_help_add("MKD", "<sp> pathname", 1);
#line 4588
  pr_help_add("XMKD", "<sp> pathname", 1);
#line 4589
  pr_help_add("PWD", "(returns current working directory)", 1);
#line 4590
  pr_help_add("XPWD", "(returns current working directory)", 1);
#line 4591
  pr_help_add("SIZE", "<sp> pathname", 1);
#line 4592
  pr_help_add("SYST", "(returns system type)", 1);
#line 4593
  pr_help_add("HELP", "[<sp> command]", 1);
#line 4594
  pr_help_add("NOOP", "(no operation)", 1);
#line 4595
  pr_help_add("FEAT", "(returns feature list)", 1);
#line 4596
  pr_help_add("OPTS", "<sp> command [<sp> options]", 1);
#line 4597
  pr_help_add("AUTH", "<sp> base64-data", 0);
#line 4598
  pr_help_add("CCC", "(clears protection level)", 0);
#line 4599
  pr_help_add("CONF", "<sp> base64-data", 0);
#line 4600
  pr_help_add("ENC", "<sp> base64-data", 0);
#line 4601
  pr_help_add("MIC", "<sp> base64-data", 0);
#line 4602
  pr_help_add("PBSZ", "<sp> protection buffer size", 0);
#line 4603
  pr_help_add("PROT", "<sp> protection code", 0);
#line 4609
  pr_feat_add("MDTM");
#line 4610
  pr_feat_add("REST STREAM");
#line 4611
  pr_feat_add("SIZE");
#line 4613
  pr_event_register(& core_module, "core.startup", & core_startup_ev, (void *)0);
  }
#line 4615
  return (0);
}
}
#line 4618 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static int core_sess_init(void) 
{ 
  int timeout_idle___0 ;
  char *displayquit ;
  config_rec *c ;
  unsigned int *debug_level___0 ;
  int timeout ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  array_header *module_list ;
  int modulec ;
  char **modulev ;
  register unsigned int i___0 ;
  char const   *auth_syms[18] ;
  module *m ;
  int required ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  authtable *authtab ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  xaset_t *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;

  {
  {
#line 4620
  displayquit = (char *)((void *)0);
#line 4621
  c = (config_rec *)((void *)0);
#line 4622
  debug_level___0 = (unsigned int *)((void *)0);
#line 4624
  init_auth();
#line 4628
  c = find_config(main_server->conf, 1 << 15, "TimeoutIdle", 0);
  }
#line 4629
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 4630
    timeout = *((int *)*(c->argv + 0));
#line 4631
    pr_data_set_timeout(1, timeout);
    }
  }
  {
#line 4634
  timeout_idle___0 = pr_data_get_timeout(1);
  }
#line 4635
  if (timeout_idle___0) {
    {
#line 4636
    pr_timer_add(timeout_idle___0, 2, (module *)((void *)0), & core_idle_timeout_cb,
                 "TimeoutIdle");
    }
  }
  {
#line 4641
  c = find_config(main_server->conf, 1 << 15, "TimeoutLinger", 0);
  }
#line 4642
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 4643
    pr_data_set_linger(*((long *)*(c->argv + 0)));
    }
  }
  {
#line 4646
  tmp = get_param_ptr(main_server->conf, "DebugLevel", 0);
#line 4646
  debug_level___0 = (unsigned int *)tmp;
  }
#line 4647
  if ((unsigned long )debug_level___0 != (unsigned long )((void *)0)) {
    {
#line 4648
    pr_log_setdebuglevel((int )*debug_level___0);
    }
  }
  {
#line 4651
  c = find_config(main_server->conf, 1 << 15, "SetEnv", 0);
  }
  {
#line 4653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4653
    if (! c) {
#line 4653
      goto while_break;
    }
    {
#line 4654
    tmp___2 = pr_env_set(session.pool, (char const   *)*(c->argv + 0), (char const   *)*(c->argv + 1));
    }
#line 4654
    if (tmp___2 < 0) {
      {
#line 4655
      tmp___0 = __errno_location();
#line 4655
      tmp___1 = strerror(*tmp___0);
#line 4655
      pr_log_debug(1, "unable to set environ variable \'%s\': %s", (char *)*(c->argv + 0),
                   tmp___1);
      }
    }
    {
#line 4659
    c = find_config_next(c, c->next, 1 << 15, "SetEnv", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4663
  c = find_config(main_server->conf, 1 << 15, "UnsetEnv", 0);
  }
  {
#line 4665
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4665
    if (! c) {
#line 4665
      goto while_break___0;
    }
    {
#line 4666
    tmp___5 = pr_env_unset(session.pool, (char const   *)*(c->argv + 0));
    }
#line 4666
    if (tmp___5 < 0) {
      {
#line 4667
      tmp___3 = __errno_location();
#line 4667
      tmp___4 = strerror(*tmp___3);
#line 4667
      pr_log_debug(1, "unable to unset environ variable \'%s\': %s", (char *)*(c->argv + 0),
                   tmp___4);
      }
    }
    {
#line 4671
    c = find_config_next(c, c->next, 1 << 15, "UnsetEnv", 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4675
  c = find_config(main_server->conf, 1 << 15, "AuthOrder", 0);
  }
#line 4676
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 4677
    module_list = (array_header *)*(c->argv + 0);
#line 4678
    modulec = 0;
#line 4679
    modulev = (char **)((void *)0);
#line 4680
    i___0 = 0U;
#line 4681
    auth_syms[0] = "setpwent";
#line 4681
    auth_syms[1] = "endpwent";
#line 4681
    auth_syms[2] = "setgrent";
#line 4681
    auth_syms[3] = "endgrent";
#line 4681
    auth_syms[4] = "getpwent";
#line 4681
    auth_syms[5] = "getgrent";
#line 4681
    auth_syms[6] = "getpwnam";
#line 4681
    auth_syms[7] = "getgrnam";
#line 4681
    auth_syms[8] = "getpwuid";
#line 4681
    auth_syms[9] = "getgrgid";
#line 4681
    auth_syms[10] = "auth";
#line 4681
    auth_syms[11] = "check";
#line 4681
    auth_syms[12] = "uid2name";
#line 4681
    auth_syms[13] = "gid2name";
#line 4681
    auth_syms[14] = "name2uid";
#line 4681
    auth_syms[15] = "name2gid";
#line 4681
    auth_syms[16] = "getgroups";
#line 4681
    auth_syms[17] = (char const   *)((void *)0);
#line 4687
    pr_log_debug(3, "AuthOrder in effect, resetting auth module order");
#line 4689
    modulec = module_list->nelts;
#line 4690
    modulev = (char **)module_list->elts;
#line 4693
    i___0 = 0U;
    }
    {
#line 4693
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4693
      if (! ((unsigned long )auth_syms[i___0] != (unsigned long )((void *)0))) {
#line 4693
        goto while_break___1;
      }
      {
#line 4694
      pr_stash_remove_symbol((pr_stash_type_t )3, auth_syms[i___0], (module *)((void *)0));
#line 4693
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4700
    i___0 = 0U;
    {
#line 4700
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4700
      if (! (i___0 < (unsigned int )modulec)) {
#line 4700
        goto while_break___2;
      }
      {
#line 4702
      required = 0;
#line 4705
      tmp___7 = strlen((char const   *)*(modulev + i___0));
      }
#line 4705
      if ((int )*(*(modulev + i___0) + (tmp___7 - 1U)) == 42) {
        {
#line 4706
        required = 1;
#line 4707
        tmp___6 = strlen((char const   *)*(modulev + i___0));
#line 4707
        *(*(modulev + i___0) + (tmp___6 - 1U)) = (char )'\000';
        }
      }
      {
#line 4710
      m = pr_module_get((char const   *)*(modulev + i___0));
      }
#line 4712
      if (m) {
#line 4714
        if (m->authtable) {
#line 4722
          m->priority = (int )((unsigned int )modulec - i___0);
#line 4724
          authtab = m->authtable;
          {
#line 4724
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 4724
            if (! authtab->name) {
#line 4724
              goto while_break___3;
            }
#line 4725
            authtab->m = m;
#line 4727
            if (required) {
#line 4728
              authtab->auth_flags |= 1;
            }
            {
#line 4730
            pr_stash_add_symbol((pr_stash_type_t )3, (void *)authtab);
#line 4724
            authtab ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
          {
#line 4734
          pr_log_debug(0, "AuthOrder: warning: module \'%s\' is not a valid auth module (no auth handlers), authentication may fail",
                       *(modulev + i___0));
          }
        }
      } else {
        {
#line 4739
        pr_log_debug(0, "AuthOrder: warning: module \'%s\' not loaded", *(modulev + i___0));
        }
      }
#line 4700
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 4749
  pr_timer_remove(core_scrub_timer_id, & core_module);
  }
#line 4755
  if ((int )ServerType == 0) {
    {
#line 4756
    pr_scoreboard_scrub();
    }
  }
  {
#line 4759
  tmp___10 = pr_var_set(session.pool, "%{total_bytes_in}", "Number of bytes uploaded during a session",
                        2, (void *)(& core_get_sess_bytes_str), (void *)(& session.total_bytes_in),
                        (size_t )sizeof(off_t___0 *));
  }
#line 4759
  if (tmp___10 < 0) {
    {
#line 4763
    tmp___8 = __errno_location();
#line 4763
    tmp___9 = strerror(*tmp___8);
#line 4763
    pr_log_debug(6, "error setting %%{total_bytes_in} variable: %s", tmp___9);
    }
  }
  {
#line 4766
  tmp___13 = pr_var_set(session.pool, "%{total_bytes_out}", "Number of bytes downloaded during a session",
                        2, (void *)(& core_get_sess_bytes_str), (void *)(& session.total_bytes_out),
                        (size_t )sizeof(off_t___0 *));
  }
#line 4766
  if (tmp___13 < 0) {
    {
#line 4770
    tmp___11 = __errno_location();
#line 4770
    tmp___12 = strerror(*tmp___11);
#line 4770
    pr_log_debug(6, "error setting %%{total_bytes_out} variable: %s", tmp___12);
    }
  }
  {
#line 4773
  tmp___16 = pr_var_set(session.pool, "%{total_bytes_xfer}", "Number of bytes transfered during a session",
                        2, (void *)(& core_get_sess_bytes_str), (void *)(& session.total_bytes),
                        (size_t )sizeof(off_t___0 *));
  }
#line 4773
  if (tmp___16 < 0) {
    {
#line 4777
    tmp___14 = __errno_location();
#line 4777
    tmp___15 = strerror(*tmp___14);
#line 4777
    pr_log_debug(6, "error setting %%{total_bytes_fer} variable: %s", tmp___15);
    }
  }
  {
#line 4780
  tmp___19 = pr_var_set(session.pool, "%{total_files_in}", "Number of files uploaded during a session",
                        2, (void *)(& core_get_sess_files_str), (void *)(& session.total_files_in),
                        (size_t )sizeof(unsigned int *));
  }
#line 4780
  if (tmp___19 < 0) {
    {
#line 4784
    tmp___17 = __errno_location();
#line 4784
    tmp___18 = strerror(*tmp___17);
#line 4784
    pr_log_debug(6, "error setting %%{total_files_in} variable: %s", tmp___18);
    }
  }
  {
#line 4787
  tmp___22 = pr_var_set(session.pool, "%{total_files_out}", "Number of files downloaded during a session",
                        2, (void *)(& core_get_sess_files_str), (void *)(& session.total_files_out),
                        (size_t )sizeof(unsigned int *));
  }
#line 4787
  if (tmp___22 < 0) {
    {
#line 4791
    tmp___20 = __errno_location();
#line 4791
    tmp___21 = strerror(*tmp___20);
#line 4791
    pr_log_debug(6, "error setting %%{total_files_out} variable: %s", tmp___21);
    }
  }
  {
#line 4794
  tmp___25 = pr_var_set(session.pool, "%{total_files_xfer}", "Number of files transfered during a session",
                        2, (void *)(& core_get_sess_files_str), (void *)(& session.total_files_xfer),
                        (size_t )sizeof(unsigned int *));
  }
#line 4794
  if (tmp___25 < 0) {
    {
#line 4798
    tmp___23 = __errno_location();
#line 4798
    tmp___24 = strerror(*tmp___23);
#line 4798
    pr_log_debug(6, "error setting %%{total_files_xfer} variable: %s", tmp___24);
    }
  }
#line 4807
  if (session.anon_config) {
#line 4807
    tmp___26 = (session.anon_config)->subset;
  } else {
#line 4807
    tmp___26 = main_server->conf;
  }
  {
#line 4807
  tmp___27 = get_param_ptr(tmp___26, "DisplayQuit", 0);
#line 4807
  displayquit = (char *)tmp___27;
  }
#line 4808
  if (displayquit) {
#line 4808
    if ((int )*displayquit == 47) {
      {
#line 4811
      displayquit_fh = pr_fsio_open((char const   *)displayquit, 0);
      }
#line 4812
      if ((unsigned long )displayquit_fh == (unsigned long )((void *)0)) {
        {
#line 4813
        tmp___28 = __errno_location();
#line 4813
        tmp___29 = strerror(*tmp___28);
#line 4813
        pr_log_debug(6, "unable to open DisplayQuit file \'%s\': %s", displayquit,
                     tmp___29);
        }
      }
    }
  }
#line 4817
  return (0);
}
}
#line 4823 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static conftable core_conftab[93]  = 
#line 4823
  {      {(char *)"<Anonymous>", & add_anonymous, (module *)((void *)0)}, 
        {(char *)"</Anonymous>", & end_anonymous, (module *)((void *)0)}, 
        {(char *)"<Class>", & add_class, (module *)((void *)0)}, 
        {(char *)"</Class>", & end_class, (module *)((void *)0)}, 
        {(char *)"<Directory>", & add_directory, (module *)((void *)0)}, 
        {(char *)"</Directory>", & end_directory, (module *)((void *)0)}, 
        {(char *)"<Global>", & add_global, (module *)((void *)0)}, 
        {(char *)"</Global>", & end_global, (module *)((void *)0)}, 
        {(char *)"<IfDefine>", & start_ifdefine, (module *)((void *)0)}, 
        {(char *)"</IfDefine>", & end_ifdefine, (module *)((void *)0)}, 
        {(char *)"<IfModule>", & start_ifmodule, (module *)((void *)0)}, 
        {(char *)"</IfModule>", & end_ifmodule, (module *)((void *)0)}, 
        {(char *)"<Limit>", & add_limit, (module *)((void *)0)}, 
        {(char *)"</Limit>", & end_limit, (module *)((void *)0)}, 
        {(char *)"<VirtualHost>", & add_virtualhost, (module *)((void *)0)}, 
        {(char *)"</VirtualHost>", & end_virtualhost, (module *)((void *)0)}, 
        {(char *)"Allow", & set_allowdeny, (module *)((void *)0)}, 
        {(char *)"AllowAll", & set_allowall, (module *)((void *)0)}, 
        {(char *)"AllowClass", & set_allowdenyusergroupclass, (module *)((void *)0)}, 
        {(char *)"AllowFilter",
      & set_allowfilter, (module *)((void *)0)}, 
        {(char *)"AllowForeignAddress", & set_allowforeignaddress, (module *)((void *)0)}, 
        {(char *)"AllowGroup",
      & set_allowdenyusergroupclass, (module *)((void *)0)}, 
        {(char *)"AllowOverride", & set_allowoverride, (module *)((void *)0)}, 
        {(char *)"AllowUser", & set_allowdenyusergroupclass, (module *)((void *)0)}, 
        {(char *)"AuthOrder", & set_authorder, (module *)((void *)0)}, 
        {(char *)"CDPath", & set_cdpath, (module *)((void *)0)}, 
        {(char *)"CommandBufferSize", & set_commandbuffersize, (module *)((void *)0)}, 
        {(char *)"DebugLevel",
      & set_debuglevel, (module *)((void *)0)}, 
        {(char *)"DefaultAddress", & set_defaultaddress, (module *)((void *)0)}, 
        {(char *)"DefaultServer", & set_defaultserver, (module *)((void *)0)}, 
        {(char *)"DefaultTransferMode", & set_defaulttransfermode, (module *)((void *)0)}, 
        {(char *)"DeferWelcome",
      & set_deferwelcome, (module *)((void *)0)}, 
        {(char *)"Define", & set_define, (module *)((void *)0)}, 
        {(char *)"Deny", & set_allowdeny, (module *)((void *)0)}, 
        {(char *)"DenyAll", & set_denyall, (module *)((void *)0)}, 
        {(char *)"DenyClass", & set_allowdenyusergroupclass, (module *)((void *)0)}, 
        {(char *)"DenyFilter", & set_denyfilter, (module *)((void *)0)}, 
        {(char *)"DenyGroup", & set_allowdenyusergroupclass, (module *)((void *)0)}, 
        {(char *)"DenyUser", & set_allowdenyusergroupclass, (module *)((void *)0)}, 
        {(char *)"DisplayChdir", & set_displaychdir, (module *)((void *)0)}, 
        {(char *)"DisplayConnect", & set_displayconnect, (module *)((void *)0)}, 
        {(char *)"DisplayGoAway", & set_displaygoaway, (module *)((void *)0)}, 
        {(char *)"DisplayQuit", & set_displayquit, (module *)((void *)0)}, 
        {(char *)"From", & add_from, (module *)((void *)0)}, 
        {(char *)"Group", & set_group, (module *)((void *)0)}, 
        {(char *)"GroupOwner", & add_groupowner, (module *)((void *)0)}, 
        {(char *)"HideFiles", & set_hidefiles, (module *)((void *)0)}, 
        {(char *)"HideGroup", & set_hidegroup, (module *)((void *)0)}, 
        {(char *)"HideNoAccess", & set_hidenoaccess, (module *)((void *)0)}, 
        {(char *)"HideUser", & set_hideuser, (module *)((void *)0)}, 
        {(char *)"IdentLookups", & set_identlookups___0, (module *)((void *)0)}, 
        {(char *)"IgnoreHidden", & set_ignorehidden, (module *)((void *)0)}, 
        {(char *)"Include", & add_include, (module *)((void *)0)}, 
        {(char *)"MasqueradeAddress", & set_masqueradeaddress, (module *)((void *)0)}, 
        {(char *)"MaxConnectionRate",
      & set_maxconnrate, (module *)((void *)0)}, 
        {(char *)"MaxInstances", & set_maxinstances, (module *)((void *)0)}, 
        {(char *)"MultilineRFC2228", & set_multilinerfc2228, (module *)((void *)0)}, 
        {(char *)"Order", & set_order, (module *)((void *)0)}, 
        {(char *)"PassivePorts", & set_passiveports, (module *)((void *)0)}, 
        {(char *)"PathAllowFilter", & set_pathallowfilter, (module *)((void *)0)}, 
        {(char *)"PathDenyFilter", & set_pathdenyfilter, (module *)((void *)0)}, 
        {(char *)"PidFile", & set_pidfile, (module *)((void *)0)}, 
        {(char *)"Port", & set_serverport, (module *)((void *)0)}, 
        {(char *)"RLimitCPU", & set_rlimitcpu, (module *)((void *)0)}, 
        {(char *)"RLimitMemory", & set_rlimitmemory, (module *)((void *)0)}, 
        {(char *)"RLimitOpenFiles", & set_rlimitopenfiles, (module *)((void *)0)}, 
        {(char *)"Satisfy", & set_satisfy, (module *)((void *)0)}, 
        {(char *)"ScoreboardFile", & set_scoreboardfile, (module *)((void *)0)}, 
        {(char *)"ServerAdmin", & set_serveradmin, (module *)((void *)0)}, 
        {(char *)"ServerIdent", & set_serverident, (module *)((void *)0)}, 
        {(char *)"ServerName", & set_servername, (module *)((void *)0)}, 
        {(char *)"ServerType", & set_servertype, (module *)((void *)0)}, 
        {(char *)"SetEnv", & set_setenv, (module *)((void *)0)}, 
        {(char *)"SocketBindTight", & set_socketbindtight, (module *)((void *)0)}, 
        {(char *)"SocketOptions", & set_socketoptions, (module *)((void *)0)}, 
        {(char *)"SyslogFacility", & set_syslogfacility, (module *)((void *)0)}, 
        {(char *)"SyslogLevel", & set_sysloglevel, (module *)((void *)0)}, 
        {(char *)"TimeoutIdle", & set_timeoutidle, (module *)((void *)0)}, 
        {(char *)"TimeoutLinger", & set_timeoutlinger, (module *)((void *)0)}, 
        {(char *)"TimesGMT", & set_timesgmt, (module *)((void *)0)}, 
        {(char *)"Trace", & set_trace, (module *)((void *)0)}, 
        {(char *)"TraceLog", & set_tracelog, (module *)((void *)0)}, 
        {(char *)"TransferLog", & add_transferlog, (module *)((void *)0)}, 
        {(char *)"Umask", & set_umask, (module *)((void *)0)}, 
        {(char *)"UnsetEnv", & set_unsetenv, (module *)((void *)0)}, 
        {(char *)"UseIPv6", & set_useipv6, (module *)((void *)0)}, 
        {(char *)"UseReverseDNS", & set_usereversedns, (module *)((void *)0)}, 
        {(char *)"User", & set_user, (module *)((void *)0)}, 
        {(char *)"UserOwner", & add_userowner, (module *)((void *)0)}, 
        {(char *)"WtmpLog", & set_wtmplog, (module *)((void *)0)}, 
        {(char *)"tcpBackLog", & set_tcpbacklog, (module *)((void *)0)}, 
        {(char *)"tcpNoDelay", & set_tcpnodelay, (module *)((void *)0)}, 
        {(char *)((void *)0), (modret_t *(*)(cmd_rec * ))((void *)0), (module *)((void *)0)}};
#line 4920 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
static cmdtable core_cmdtab[33]  = 
#line 4920
  {      {(unsigned char)1, (char *)"*", (char *)((void *)0), & regex_filters, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)1, (char *)"*", (char *)((void *)0), & core_clear_fs, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"HELP", (char *)((void *)0), & core_help, (unsigned char)0,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)2, (char *)"PORT", (char *)((void *)0), & core_port, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"PASV", (char *)((void *)0), & core_pasv, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"EPRT", (char *)((void *)0), & core_eprt, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"EPSV", (char *)((void *)0), & core_epsv, (unsigned char)1,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"SYST", (char *)((void *)0), & core_syst, (unsigned char)0,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)2, (char *)"PWD", (char *)"DIRS", & core_pwd, (unsigned char)1,
      (unsigned char)0, (1 << 1) | (1 << 2), (module *)0}, 
        {(unsigned char)2, (char *)"XPWD", (char *)"DIRS", & core_pwd, (unsigned char)1,
      (unsigned char)0, (1 << 1) | (1 << 2), (module *)0}, 
        {(unsigned char)2, (char *)"CWD", (char *)"DIRS", & core_cwd, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"XCWD", (char *)"DIRS", & core_cwd, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"MKD", (char *)"WRITE", & core_mkd, (unsigned char)1,
      (unsigned char)0, (1 << 2) | (1 << 4), (module *)0}, 
        {(unsigned char)2, (char *)"XMKD", (char *)"WRITE", & core_mkd, (unsigned char)1,
      (unsigned char)0, (1 << 2) | (1 << 4), (module *)0}, 
        {(unsigned char)2, (char *)"RMD", (char *)"WRITE", & core_rmd, (unsigned char)1,
      (unsigned char)0, (1 << 2) | (1 << 4), (module *)0}, 
        {(unsigned char)2, (char *)"XRMD", (char *)"WRITE", & core_rmd, (unsigned char)1,
      (unsigned char)0, (1 << 2) | (1 << 4), (module *)0}, 
        {(unsigned char)2, (char *)"CDUP", (char *)"DIRS", & core_cdup, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"XCUP", (char *)"DIRS", & core_cdup, (unsigned char)1,
      (unsigned char)0, 1 << 2, (module *)0}, 
        {(unsigned char)2, (char *)"DELE", (char *)"WRITE", & core_dele, (unsigned char)1,
      (unsigned char)0, 1 << 4, (module *)0}, 
        {(unsigned char)2, (char *)"MDTM", (char *)"DIRS", & core_mdtm, (unsigned char)1,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)2, (char *)"RNFR", (char *)"DIRS", & core_rnfr, (unsigned char)1,
      (unsigned char)0, (1 << 5) | (1 << 4), (module *)0}, 
        {(unsigned char)2, (char *)"RNTO", (char *)"WRITE", & core_rnto, (unsigned char)1,
      (unsigned char)0, (1 << 5) | (1 << 4), (module *)0}, 
        {(unsigned char)5, (char *)"RNTO", (char *)((void *)0), & core_rnto_cleanup,
      (unsigned char)1, (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"RNTO", (char *)((void *)0), & core_rnto_cleanup,
      (unsigned char)1, (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"SIZE", (char *)"READ", & core_size, (unsigned char)1,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)2, (char *)"QUIT", (char *)((void *)0), & core_quit, (unsigned char)0,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)5, (char *)"QUIT", (char *)((void *)0), & core_log_quit, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)6, (char *)"QUIT", (char *)((void *)0), & core_log_quit, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)2, (char *)"NOOP", (char *)((void *)0), & core_noop, (unsigned char)0,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)2, (char *)"FEAT", (char *)((void *)0), & core_feat, (unsigned char)0,
      (unsigned char)0, 1 << 1, (module *)0}, 
        {(unsigned char)2, (char *)"OPTS", (char *)((void *)0), & core_opts, (unsigned char)0,
      (unsigned char)0, 1 << 5, (module *)0}, 
        {(unsigned char)3, (char *)"PASS", (char *)((void *)0), & core_post_pass, (unsigned char)0,
      (unsigned char)0, 0, (module *)0}, 
        {(unsigned char)0, (char *)((void *)0), (char *)0, (modret_t *(*)(cmd_rec * ))0,
      (unsigned char)0, (unsigned char)0, 0, (module *)0}};
#line 4958 "/home/pronto/abs/test-suite/proftpd-1.3.2/modules/mod_core.c"
module core_module  = 
#line 4958
     {(module *)((void *)0), (module *)((void *)0), 32, (char *)"core", core_conftab,
    core_cmdtab, (authtable *)((void *)0), & core_init, & core_sess_init, (char *)0,
    (void *)0, 0};
#line 10 "../include/version.h"
unsigned long pr_version_get_module_api_number(void) ;
#line 11
unsigned long pr_version_get_number(void) ;
#line 12
char const   *pr_version_get_str(void) ;
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/version.c"
unsigned long pr_version_get_module_api_number(void) 
{ 


  {
#line 33
  return (32UL);
}
}
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/version.c"
unsigned long pr_version_get_number(void) 
{ 


  {
#line 37
  return (16974341UL);
}
}
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/version.c"
char const   *pr_version_get_str(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 41
  return ("1.3.2");
}
}
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 567
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/env.c"
char *pr_env_get(pool *p , char const   *key ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 33
  if (! p) {
    {
#line 34
    tmp = __errno_location();
#line 34
    *tmp = 22;
    }
#line 35
    return ((char *)((void *)0));
  } else
#line 33
  if (! key) {
    {
#line 34
    tmp = __errno_location();
#line 34
    *tmp = 22;
    }
#line 35
    return ((char *)((void *)0));
  }
  {
#line 39
  tmp___0 = getenv(key);
  }
#line 39
  return (tmp___0);
}
}
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/env.c"
int pr_env_set(pool *p , char const   *key , char const   *value ) 
{ 
  char const   *k ;
  char const   *v ;
  int *tmp ;
  int tmp___0 ;

  {
#line 53
  if (! p) {
    {
#line 54
    tmp = __errno_location();
#line 54
    *tmp = 22;
    }
#line 55
    return (-1);
  } else
#line 53
  if (! key) {
    {
#line 54
    tmp = __errno_location();
#line 54
    *tmp = 22;
    }
#line 55
    return (-1);
  } else
#line 53
  if (! value) {
    {
#line 54
    tmp = __errno_location();
#line 54
    *tmp = 22;
    }
#line 55
    return (-1);
  }
  {
#line 78
  k = key;
#line 79
  v = value;
#line 81
  tmp___0 = setenv(k, v, 1);
  }
#line 81
  return (tmp___0);
}
}
#line 101 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/env.c"
int pr_env_unset(pool *p , char const   *key ) 
{ 
  char *res ;
  int *tmp ;

  {
#line 106
  if (! p) {
    {
#line 107
    tmp = __errno_location();
#line 107
    *tmp = 22;
    }
#line 108
    return (-1);
  } else
#line 106
  if (! key) {
    {
#line 107
    tmp = __errno_location();
#line 107
    *tmp = 22;
    }
#line 108
    return (-1);
  }
  {
#line 115
  res = pr_env_get(p, key);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! res) {
#line 116
      goto while_break;
    }
    {
#line 117
    pr_signals_handle();
#line 119
    unsetenv(key);
#line 120
    res = pr_env_get(p, key);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 331
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 792 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 33 "../include/pidfile.h"
int pr_pidfile_remove(void) ;
#line 34
void pr_pidfile_write(void) ;
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pidfile.c"
static char const   *pidfile_path  =    "/usr/local/var/proftpd.pid";
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pidfile.c"
void pr_pidfile_write(void) 
{ 
  FILE *fh ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  __pid_t tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 36
  fh = (FILE *)((void *)0);
#line 38
  tmp = get_param_ptr(main_server->conf, "PidFile", 0);
#line 38
  pidfile_path = (char const   *)tmp;
  }
#line 39
  if (! pidfile_path) {
#line 40
    pidfile_path = "/usr/local/var/proftpd.pid";
  } else
#line 39
  if (! *pidfile_path) {
#line 40
    pidfile_path = "/usr/local/var/proftpd.pid";
  }
  {
#line 42
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pidfile.c",
               42);
#line 42
  pr_signals_block();
  }
#line 42
  if (! session.disable_id_switching) {
    {
#line 42
    tmp___2 = seteuid((__uid_t )0);
    }
#line 42
    if (tmp___2) {
      {
#line 42
      tmp___0 = __errno_location();
#line 42
      tmp___1 = strerror(*tmp___0);
#line 42
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___1);
      }
    }
    {
#line 42
    tmp___5 = setegid((__gid_t )0);
    }
#line 42
    if (tmp___5) {
      {
#line 42
      tmp___3 = __errno_location();
#line 42
      tmp___4 = strerror(*tmp___3);
#line 42
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___4);
      }
    }
  } else {
    {
#line 42
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 42
  pr_signals_unblock();
#line 43
  fh = fopen((char const   */* __restrict  */)pidfile_path, (char const   */* __restrict  */)"w");
#line 44
  pr_signals_block();
  }
#line 44
  if (! session.disable_id_switching) {
    {
#line 44
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pidfile.c",
                 44);
#line 44
    tmp___9 = geteuid();
    }
#line 44
    if (tmp___9 != 0U) {
      {
#line 44
      tmp___8 = seteuid((__uid_t )0);
      }
#line 44
      if (tmp___8) {
        {
#line 44
        tmp___6 = __errno_location();
#line 44
        tmp___7 = strerror(*tmp___6);
#line 44
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___7);
        }
      }
    }
    {
#line 44
    tmp___12 = setegid(session.gid);
    }
#line 44
    if (tmp___12) {
      {
#line 44
      tmp___10 = __errno_location();
#line 44
      tmp___11 = strerror(*tmp___10);
#line 44
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___11);
      }
    }
    {
#line 44
    tmp___15 = seteuid(session.uid);
    }
#line 44
    if (tmp___15) {
      {
#line 44
      tmp___13 = __errno_location();
#line 44
      tmp___14 = strerror(*tmp___13);
#line 44
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___14);
      }
    }
  } else {
    {
#line 44
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 44
  pr_signals_unblock();
  }
#line 46
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
    {
#line 47
    tmp___16 = __errno_location();
#line 47
    tmp___17 = strerror(*tmp___16);
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening PidFile \'%s\': %s\n",
            pidfile_path, tmp___17);
#line 49
    exit(1);
    }
  }
  {
#line 52
  tmp___18 = getpid();
#line 52
  fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"%lu\n", (unsigned long )tmp___18);
#line 53
  tmp___21 = fclose(fh);
  }
#line 53
  if (tmp___21 < 0) {
    {
#line 54
    tmp___19 = __errno_location();
#line 54
    tmp___20 = strerror(*tmp___19);
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error writing PidFile \'%s\': %s\n",
            pidfile_path, tmp___20);
    }
  }
#line 57
  return;
}
}
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pidfile.c"
int pr_pidfile_remove(void) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = unlink(pidfile_path);
  }
#line 60
  return (tmp);
}
}
#line 498 "/usr/include/unistd.h"
extern char **environ ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 33 "../include/proctitle.h"
void pr_proctitle_free(void) ;
#line 34
void pr_proctitle_init(int argc , char **argv , char **envp ) ;
#line 36
int pr_proctitle_get(char *buf___2 , size_t bufsz ) ;
#line 38
void ( /* format attribute */  pr_proctitle_set)(char const   *fmt  , ...) ;
#line 45
void pr_proctitle_set_str(char const   *str ) ;
#line 52 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
extern char *__progname_full ;
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
static char **prog_argv  =    (char **)((void *)0);
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
static char *prog_last_argv  =    (char *)((void *)0);
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
static int prog_argc  =    -1;
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
static char proc_title_buf[8192]  ;
#line 64 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
void pr_proctitle_init(int argc , char **argv , char **envp ) 
{ 
  register int i___0 ;
  register size_t envpsize ;
  char **p ;
  size_t tmp ;
  size_t envp_len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp14 ;

  {
#line 71
  envpsize = (size_t )0;
#line 71
  i___0 = (int )envpsize;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )*(envp + i___0) != (unsigned long )((void *)0))) {
#line 71
      goto while_break;
    }
    {
#line 72
    tmp = strlen((char const   *)*(envp + i___0));
#line 72
    envpsize += tmp + 1U;
#line 71
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  tmp___2 = malloc((size_t )((unsigned long )(i___0 + 1) * sizeof(char *)));
#line 74
  p = (char **)tmp___2;
  }
#line 74
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 75
    environ = p;
#line 77
    i___0 = 0;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! ((unsigned long )*(envp + i___0) != (unsigned long )((void *)0))) {
#line 77
        goto while_break___0;
      }
      {
#line 78
      tmp___0 = strlen((char const   *)*(envp + i___0));
#line 78
      envp_len = tmp___0;
#line 80
      tmp___1 = malloc(envp_len + 1U);
#line 80
      *(environ + i___0) = (char *)tmp___1;
      }
#line 81
      if ((unsigned long )*(environ + i___0) != (unsigned long )((void *)0)) {
        {
#line 82
        sstrncpy(*(environ + i___0), (char const   *)*(envp + i___0), envp_len + 1U);
        }
      }
#line 77
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    *(environ + i___0) = (char *)((void *)0);
  }
#line 89
  prog_argv = argv;
#line 90
  prog_argc = argc;
#line 92
  i___0 = 0;
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (i___0 < prog_argc)) {
#line 92
      goto while_break___1;
    }
#line 93
    if (! i___0) {
      {
#line 94
      tmp___3 = strlen((char const   *)*(argv + i___0));
#line 94
      prog_last_argv = *(argv + i___0) + tmp___3;
      }
    } else
#line 93
    if ((unsigned long )(prog_last_argv + 1) == (unsigned long )*(argv + i___0)) {
      {
#line 94
      tmp___3 = strlen((char const   *)*(argv + i___0));
#line 94
      prog_last_argv = *(argv + i___0) + tmp___3;
      }
    }
#line 92
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 97
  i___0 = 0;
  {
#line 97
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )*(envp + i___0) != (unsigned long )((void *)0))) {
#line 97
      goto while_break___2;
    }
#line 98
    if ((unsigned long )(prog_last_argv + 1) == (unsigned long )*(envp + i___0)) {
      {
#line 99
      tmp___4 = strlen((char const   *)*(envp + i___0));
#line 99
      prog_last_argv = *(envp + i___0) + tmp___4;
      }
    }
#line 97
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 106
  __progname = strdup("proftpd");
#line 107
  __progname_full = strdup((char const   *)*(argv + 0));
#line 115
  memset((void *)(proc_title_buf), '\000', (size_t )sizeof(proc_title_buf));
  }
#line 116
  return;
}
}
#line 118 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
void pr_proctitle_free(void) 
{ 


  {
#line 138
  return;
}
}
#line 140 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
void pr_proctitle_set_str(char const   *str ) 
{ 
  char *p ;
  int i___0 ;
  int procbuflen ;
  int maxlen ;
  size_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 145
  maxlen = (int )((prog_last_argv - *(prog_argv + 0)) - 2L);
#line 151
  sstrncpy(proc_title_buf, str, (size_t )sizeof(proc_title_buf));
#line 152
  tmp = strlen((char const   *)(proc_title_buf));
#line 152
  procbuflen = (int )tmp;
#line 164
  snprintf((char */* __restrict  */)*(prog_argv + 0), (size_t )maxlen, (char const   */* __restrict  */)"%s",
           proc_title_buf);
#line 165
  p = *(prog_argv + 0) + procbuflen;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! ((unsigned long )p < (unsigned long )prog_last_argv)) {
#line 167
      goto while_break;
    }
#line 168
    tmp___0 = p;
#line 168
    p ++;
#line 168
    *tmp___0 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  i___0 = 1;
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! (i___0 < prog_argc)) {
#line 170
      goto while_break___0;
    }
#line 171
    *(prog_argv + i___0) = (char *)"";
#line 170
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 187 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
void ( /* format attribute */  pr_proctitle_set)(char const   *fmt  , ...) 
{ 
  va_list msg ;
  char *p ;
  int i___0 ;
  int procbuflen ;
  int maxlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 196
  maxlen = (int )((prog_last_argv - *(prog_argv + 0)) - 2L);
#line 199
  if (! fmt) {
#line 200
    return;
  }
  {
#line 202
  __builtin_va_start(msg, fmt);
#line 204
  memset((void *)(proc_title_buf), 0, (size_t )sizeof(proc_title_buf));
#line 222
  snprintf((char */* __restrict  */)(proc_title_buf), (size_t )sizeof(proc_title_buf),
           (char const   */* __restrict  */)"%s", "proftpd: ");
#line 223
  tmp = strlen((char const   *)(proc_title_buf));
#line 223
  tmp___0 = strlen((char const   *)(proc_title_buf));
#line 223
  vsnprintf((char */* __restrict  */)(proc_title_buf + tmp___0), (size_t )(sizeof(proc_title_buf) - (unsigned long )tmp),
            (char const   */* __restrict  */)fmt, msg);
#line 228
  __builtin_va_end(msg);
#line 233
  tmp___1 = strlen((char const   *)(proc_title_buf));
#line 233
  procbuflen = (int )tmp___1;
#line 245
  snprintf((char */* __restrict  */)*(prog_argv + 0), (size_t )maxlen, (char const   */* __restrict  */)"%s",
           proc_title_buf);
#line 246
  p = *(prog_argv + 0) + procbuflen;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! ((unsigned long )p < (unsigned long )prog_last_argv)) {
#line 248
      goto while_break;
    }
#line 249
    tmp___2 = p;
#line 249
    p ++;
#line 249
    *tmp___2 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  i___0 = 1;
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! (i___0 < prog_argc)) {
#line 251
      goto while_break___0;
    }
#line 252
    *(prog_argv + i___0) = (char *)"";
#line 251
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 272 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/proctitle.c"
int pr_proctitle_get(char *buf___2 , size_t bufsz ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 273
  if ((unsigned long )buf___2 == (unsigned long )((void *)0)) {
    {
#line 280
    tmp = strlen((char const   *)(proc_title_buf));
    }
#line 280
    return ((int )tmp);
  } else
#line 273
  if (bufsz == 0U) {
    {
#line 280
    tmp = strlen((char const   *)(proc_title_buf));
    }
#line 280
    return ((int )tmp);
  }
  {
#line 283
  sstrncpy(buf___2, (char const   *)(proc_title_buf), bufsz);
#line 284
  tmp___0 = strlen((char const   *)buf___2);
  }
#line 284
  return ((int )tmp___0);
}
}
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 73 "../include/table.h"
pr_table_t *pr_table_alloc(pool *p , int flags ) ;
#line 106
int pr_table_exists(pr_table_t *tab , char const   *key_data ) ;
#line 129
void *pr_table_remove(pr_table_t *tab , char const   *key_data , size_t *value_datasz ) ;
#line 32 "../include/trace.h"
pr_table_t *pr_trace_get_table(void) ;
#line 33
int pr_trace_get_level(char const   *channel ) ;
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static int trace_logfd  =    -1;
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static pool *trace_pool  =    (pool *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static pr_table_t *trace_tab  =    (pr_table_t *)((void *)0);
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static char const   *trace_channels[28]  = 
#line 39
  {      "auth",      "binding",      "command",      "config", 
        "ctrls",      "data",      "delay",      "dns", 
        "dso",      "encode",      "event",      "facl", 
        "fsio",      "ident",      "inet",      "lock", 
        "netacl",      "netio",      "pam",      "pool", 
        "regexp",      "response",      "signal",      "site", 
        "timer",      "var",      "xfer",      (char const   *)((void *)0)};
#line 74 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static int const   trace_log_fallback_fd  =    (int const   )255;
#line 76 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static void trace_restart_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 77
  close(trace_logfd);
#line 78
  trace_logfd = -1;
  }
#line 80
  if (trace_pool) {
    {
#line 81
    destroy_pool(trace_pool);
#line 82
    trace_pool = (pool *)((void *)0);
#line 83
    trace_tab = (pr_table_t *)((void *)0);
#line 85
    pr_event_unregister((module *)((void *)0), "core.restart", & trace_restart_ev);
    }
  }
#line 88
  return;
}
}
#line 91 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
static int trace_write(char const   *channel , int level , char const   *msg ) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  time_t now ;
  struct tm *t ;
  __pid_t tmp___0 ;
  pid_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 92
  buf___2[0] = (char )'\000';
#line 92
  tmp = 1U;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (tmp >= 1024U) {
#line 92
      goto while_break;
    }
#line 92
    buf___2[tmp] = (char)0;
#line 92
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if (trace_logfd < 0) {
#line 97
    return (0);
  }
  {
#line 99
  now = time((time_t *)((void *)0));
#line 100
  t = pr_localtime((pool *)((void *)0), (time_t const   *)(& now));
#line 101
  strftime((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%b %d %H:%M:%S",
           (struct tm  const  */* __restrict  */)t);
#line 102
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
  }
#line 104
  if (session.pid) {
#line 104
    tmp___1 = session.pid;
  } else {
    {
#line 104
    tmp___0 = getpid();
#line 104
    tmp___1 = tmp___0;
    }
  }
  {
#line 104
  tmp___2 = strlen((char const   *)(buf___2));
#line 104
  tmp___3 = strlen((char const   *)(buf___2));
#line 104
  snprintf((char */* __restrict  */)(buf___2 + tmp___3), (size_t )(sizeof(buf___2) - (unsigned long )tmp___2),
           (char const   */* __restrict  */)" [%u] <%s:%d>: %s\n", (unsigned int )tmp___1,
           channel, level, msg);
#line 108
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 109
  tmp___4 = strlen((char const   *)(buf___2));
#line 109
  tmp___5 = write(trace_logfd, (void const   *)(buf___2), tmp___4);
  }
#line 109
  return (tmp___5);
}
}
#line 112 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
pr_table_t *pr_trace_get_table(void) 
{ 
  int *tmp ;

  {
#line 113
  if (! trace_tab) {
    {
#line 114
    tmp = __errno_location();
#line 114
    *tmp = 1;
    }
#line 115
    return ((pr_table_t *)((void *)0));
  }
#line 118
  return (trace_tab);
}
}
#line 121 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
int pr_trace_get_level(char const   *channel ) 
{ 
  int level ;
  void *value ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 125
  if (! channel) {
    {
#line 126
    tmp = __errno_location();
#line 126
    *tmp = 22;
    }
#line 127
    return (-1);
  }
#line 130
  if (! trace_tab) {
    {
#line 132
    tmp___0 = __errno_location();
#line 132
    *tmp___0 = 1;
    }
#line 133
    return (-1);
  } else
#line 130
  if (trace_logfd < 0) {
    {
#line 132
    tmp___0 = __errno_location();
#line 132
    *tmp___0 = 1;
    }
#line 133
    return (-1);
  }
  {
#line 136
  value = pr_table_get(trace_tab, channel, (size_t *)((void *)0));
  }
#line 137
  if (! value) {
    {
#line 138
    tmp___1 = __errno_location();
#line 138
    *tmp___1 = 2;
    }
#line 139
    return (-1);
  }
  {
#line 142
  memcpy((void */* __restrict  */)(& level), (void const   */* __restrict  */)value,
         (size_t )sizeof(int ));
  }
#line 143
  return (level);
}
}
#line 146 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
int pr_trace_set_file(char const   *path ) 
{ 
  int res ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 149
  if (! path) {
#line 150
    if (trace_logfd < 0) {
      {
#line 151
      tmp = __errno_location();
#line 151
      *tmp = 22;
      }
#line 152
      return (-1);
    }
    {
#line 155
    close(trace_logfd);
#line 156
    trace_logfd = -1;
    }
#line 157
    return (0);
  }
  {
#line 160
  pr_signals_block();
#line 161
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c",
               161);
#line 161
  pr_signals_block();
  }
#line 161
  if (! session.disable_id_switching) {
    {
#line 161
    tmp___2 = seteuid((__uid_t )0);
    }
#line 161
    if (tmp___2) {
      {
#line 161
      tmp___0 = __errno_location();
#line 161
      tmp___1 = strerror(*tmp___0);
#line 161
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___1);
      }
    }
    {
#line 161
    tmp___5 = setegid((__gid_t )0);
    }
#line 161
    if (tmp___5) {
      {
#line 161
      tmp___3 = __errno_location();
#line 161
      tmp___4 = strerror(*tmp___3);
#line 161
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___4);
      }
    }
  } else {
    {
#line 161
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 161
  pr_signals_unblock();
#line 162
  res = pr_log_openfile(path, & trace_logfd, (mode_t )432);
#line 163
  pr_signals_block();
  }
#line 163
  if (! session.disable_id_switching) {
    {
#line 163
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c",
                 163);
#line 163
    tmp___9 = geteuid();
    }
#line 163
    if (tmp___9 != 0U) {
      {
#line 163
      tmp___8 = seteuid((__uid_t )0);
      }
#line 163
      if (tmp___8) {
        {
#line 163
        tmp___6 = __errno_location();
#line 163
        tmp___7 = strerror(*tmp___6);
#line 163
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___7);
        }
      }
    }
    {
#line 163
    tmp___12 = setegid(session.gid);
    }
#line 163
    if (tmp___12) {
      {
#line 163
      tmp___10 = __errno_location();
#line 163
      tmp___11 = strerror(*tmp___10);
#line 163
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___11);
      }
    }
    {
#line 163
    tmp___15 = seteuid(session.uid);
    }
#line 163
    if (tmp___15) {
      {
#line 163
      tmp___13 = __errno_location();
#line 163
      tmp___14 = strerror(*tmp___13);
#line 163
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___14);
      }
    }
  } else {
    {
#line 163
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 163
  pr_signals_unblock();
#line 164
  pr_signals_unblock();
  }
#line 166
  if (res < 0) {
#line 167
    if (res == -1) {
      {
#line 168
      tmp___16 = __errno_location();
#line 168
      tmp___17 = strerror(*tmp___16);
#line 168
      pr_log_debug(1, "unable to open TraceLog \'%s\': %s", path, tmp___17);
      }
    } else
#line 171
    if (res == -2) {
      {
#line 172
      pr_log_debug(1, "unable to open TraceLog \'%s\': parent directory is world-writable",
                   path);
      }
    } else
#line 176
    if (res == -3) {
      {
#line 177
      pr_log_debug(1, "unable to open TraceLog \'%s\': cannot log to a symbolic link",
                   path);
      }
    }
#line 181
    return (res);
  }
#line 187
  if (trace_logfd < 3) {
    {
#line 188
    tmp___21 = dup2(trace_logfd, (int )trace_log_fallback_fd);
    }
#line 188
    if (tmp___21 < 0) {
      {
#line 189
      tmp___18 = __errno_location();
#line 189
      tmp___19 = strerror(*tmp___18);
#line 189
      pr_log_pri(5, "error duplicating trace log fd: %s", tmp___19);
#line 191
      close(trace_logfd);
#line 192
      trace_logfd = -1;
#line 194
      tmp___20 = __errno_location();
#line 194
      *tmp___20 = 13;
      }
#line 195
      return (-1);
    } else {
      {
#line 198
      close(trace_logfd);
#line 199
      trace_logfd = (int )trace_log_fallback_fd;
      }
    }
  }
#line 203
  return (0);
}
}
#line 206 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
int pr_trace_set_level(char const   *channel , int level ) 
{ 
  int *tmp ;
  void *value ;
  void *tmp___0 ;
  int count ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  register unsigned int i___0 ;
  int tmp___6 ;
  register unsigned int i___1 ;
  int tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 208
  if (! channel) {
    {
#line 209
    tmp = __errno_location();
#line 209
    *tmp = 22;
    }
#line 210
    return (-1);
  }
#line 213
  if (! trace_tab) {
#line 213
    if (level < 0) {
#line 215
      return (0);
    }
  }
#line 217
  if (! trace_pool) {
    {
#line 218
    trace_pool = make_sub_pool(permanent_pool);
#line 219
    pr_pool_tag(trace_pool, "Trace API");
#line 221
    trace_tab = pr_table_alloc(trace_pool, 0);
#line 224
    pr_event_register((module *)((void *)0), "core.restart", & trace_restart_ev, (void *)0);
    }
  }
#line 227
  if (level >= 0) {
    {
#line 228
    tmp___0 = palloc(trace_pool, (int )sizeof(int ));
#line 228
    value = tmp___0;
#line 229
    memcpy((void */* __restrict  */)value, (void const   */* __restrict  */)(& level),
           (size_t )sizeof(int ));
#line 231
    tmp___6 = strcmp(channel, "DEFAULT");
    }
#line 231
    if (tmp___6 != 0) {
      {
#line 232
      tmp___1 = pr_table_exists(trace_tab, channel);
#line 232
      count = tmp___1;
      }
#line 234
      if (count <= 0) {
        {
#line 235
        tmp___2 = pstrdup(trace_pool, channel);
#line 235
        tmp___3 = pr_table_add(trace_tab, (char const   *)tmp___2, value, (size_t )sizeof(int ));
        }
#line 235
        if (tmp___3 < 0) {
#line 237
          return (-1);
        }
      } else {
        {
#line 241
        tmp___4 = pstrdup(trace_pool, channel);
#line 241
        tmp___5 = pr_table_set(trace_tab, (char const   *)tmp___4, value, (size_t )sizeof(int ));
        }
#line 241
        if (tmp___5 < 0) {
#line 243
          return (-1);
        }
      }
    } else {
#line 249
      i___0 = 0U;
      {
#line 249
      while (1) {
        while_continue: /* CIL Label */ ;
#line 249
        if (! trace_channels[i___0]) {
#line 249
          goto while_break;
        }
        {
#line 250
        pr_trace_set_level(trace_channels[i___0], level);
#line 249
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 255
    tmp___7 = strcmp(channel, "DEFAULT");
    }
#line 255
    if (tmp___7 != 0) {
      {
#line 256
      pr_table_remove(trace_tab, channel, (size_t *)((void *)0));
      }
    } else {
#line 261
      i___1 = 0U;
      {
#line 261
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 261
        if (! trace_channels[i___1]) {
#line 261
          goto while_break___0;
        }
        {
#line 262
        pr_table_remove(trace_tab, trace_channels[i___1], (size_t *)((void *)0));
#line 261
        i___1 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 267
  return (0);
}
}
#line 270 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/trace.c"
int ( /* format attribute */  pr_trace_msg)(char const   *channel , int level , char const   *fmt 
                                            , ...) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  size_t buflen ;
  va_list msg ;
  int res ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;

  {
#line 271
  buf___2[0] = (char )'\000';
#line 271
  tmp = 1U;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (tmp >= 1024U) {
#line 271
      goto while_break;
    }
#line 271
    buf___2[tmp] = (char)0;
#line 271
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (! channel) {
    {
#line 279
    tmp___0 = __errno_location();
#line 279
    *tmp___0 = 22;
    }
#line 280
    return (-1);
  } else
#line 276
  if (! fmt) {
    {
#line 279
    tmp___0 = __errno_location();
#line 279
    *tmp___0 = 22;
    }
#line 280
    return (-1);
  } else
#line 276
  if (level < 0) {
    {
#line 279
    tmp___0 = __errno_location();
#line 279
    *tmp___0 = 22;
    }
#line 280
    return (-1);
  }
#line 283
  if (! trace_tab) {
    {
#line 284
    tmp___1 = __errno_location();
#line 284
    *tmp___1 = 1;
    }
#line 285
    return (-1);
  }
  {
#line 288
  res = pr_trace_get_level(channel);
  }
#line 289
  if (res < 0) {
#line 290
    return (-1);
  }
#line 292
  if (res < level) {
#line 293
    return (0);
  }
  {
#line 295
  __builtin_va_start(msg, fmt);
#line 296
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 297
  __builtin_va_end(msg);
#line 300
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 303
  buflen = strlen((char const   *)(buf___2));
  }
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 304
    if (buflen >= 1U) {
#line 304
      if (! ((int )buf___2[buflen - 1U] == 10)) {
#line 304
        goto while_break___0;
      }
    } else {
#line 304
      goto while_break___0;
    }
    {
#line 306
    pr_signals_handle();
#line 307
    buf___2[buflen - 1U] = (char )'\000';
#line 308
    buflen = strlen((char const   *)(buf___2));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 311
  tmp___2 = trace_write(channel, level, (char const   *)(buf___2));
  }
#line 311
  return (tmp___2);
}
}
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static long double xfer_rate_kbps  =    (long double )0.0;
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static long double xfer_rate_bps  =    (long double )0.0;
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static off_t___0 xfer_rate_freebytes  =    (off_t___0 )0.0;
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static int have_xfer_rate  =    0;
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static unsigned int xfer_rate_scoreboard_updates  =    0U;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static sigset_t sig_set  ;
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static void xfer_rate_sigmask(int block ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 45
  if (block) {
    {
#line 46
    sigemptyset(& sig_set);
#line 48
    sigaddset(& sig_set, 17);
#line 49
    sigaddset(& sig_set, 10);
#line 50
    sigaddset(& sig_set, 2);
#line 51
    sigaddset(& sig_set, 3);
#line 53
    sigaddset(& sig_set, 29);
#line 56
    sigaddset(& sig_set, 7);
#line 58
    sigaddset(& sig_set, 1);
    }
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 60
      tmp___0 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& sig_set), (sigset_t */* __restrict  */)((void *)0));
      }
#line 60
      if (! (tmp___0 < 0)) {
#line 60
        goto while_break;
      }
      {
#line 61
      tmp = __errno_location();
      }
#line 61
      if (*tmp == 4) {
        {
#line 62
        pr_signals_handle();
        }
#line 63
        goto while_continue;
      }
#line 66
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 70
      tmp___2 = sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set), (sigset_t */* __restrict  */)((void *)0));
      }
#line 70
      if (! (tmp___2 < 0)) {
#line 70
        goto while_break___0;
      }
      {
#line 71
      tmp___1 = __errno_location();
      }
#line 71
      if (*tmp___1 == 4) {
        {
#line 72
        pr_signals_handle();
        }
#line 73
        goto while_continue___0;
      }
#line 76
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 79
  return;
}
}
#line 84 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
static long xfer_rate_since(struct timeval *then ) 
{ 
  struct timeval now ;
  void *__cil_tmp3 ;

  {
  {
#line 86
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 88
  return ((now.tv_sec - then->tv_sec) * 1000L + (now.tv_usec - then->tv_usec) / 1000L);
}
}
#line 92 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
int pr_throttle_have_rate(void) 
{ 


  {
#line 93
  return (have_xfer_rate);
}
}
#line 96 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
void pr_throttle_init(cmd_rec *cmd ) 
{ 
  config_rec *c ;
  char *xfer_cmd ;
  unsigned char have_user_rate ;
  unsigned char have_group_rate ;
  unsigned char have_class_rate ;
  unsigned char have_all_rate ;
  unsigned int precedence ;
  xaset_t *tmp ;
  xaset_t *tmp___0 ;
  char **cmdlist ;
  int matched_cmd ;
  char **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 97
  c = (config_rec *)((void *)0);
#line 98
  xfer_cmd = (char *)((void *)0);
#line 99
  have_user_rate = (unsigned char)0;
#line 99
  have_group_rate = (unsigned char)0;
#line 99
  have_class_rate = (unsigned char)0;
#line 99
  have_all_rate = (unsigned char)0;
#line 101
  precedence = 0U;
#line 104
  xfer_rate_bps = (long double )0.0;
#line 104
  xfer_rate_kbps = xfer_rate_bps;
#line 105
  xfer_rate_freebytes = (off_t___0 )0;
#line 106
  xfer_rate_scoreboard_updates = 0U;
#line 107
  have_xfer_rate = 0;
#line 109
  if (session.dir_config) {
#line 109
    tmp___0 = (session.dir_config)->subset;
  } else {
#line 109
    if (session.anon_config) {
#line 109
      tmp = (session.anon_config)->subset;
    } else {
#line 109
      tmp = main_server->conf;
    }
#line 109
    tmp___0 = tmp;
  }
  {
#line 109
  c = find_config(tmp___0, 1 << 15, "TransferRate", 0);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! c) {
#line 116
      goto while_break;
    }
#line 117
    cmdlist = (char **)*(c->argv + 0);
#line 118
    matched_cmd = 0;
#line 124
    xfer_cmd = *cmdlist;
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! xfer_cmd) {
#line 124
        goto while_break___0;
      }
      {
#line 125
      tmp___2 = strcasecmp((char const   *)xfer_cmd, (char const   *)*(cmd->argv + 0));
      }
#line 125
      if (tmp___2 == 0) {
#line 126
        matched_cmd = 1;
#line 127
        goto while_break___0;
      }
#line 124
      tmp___1 = cmdlist;
#line 124
      cmdlist ++;
#line 124
      xfer_cmd = *tmp___1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    if (! matched_cmd) {
      {
#line 133
      c = find_config_next(c, c->next, 1 << 15, "TransferRate", 0);
      }
#line 134
      goto while_continue;
    }
#line 137
    if (c->argc > 4) {
      {
#line 138
      tmp___8 = strcmp((char const   *)*(c->argv + 4), "user");
      }
#line 138
      if (tmp___8 == 0) {
        {
#line 140
        tmp___3 = pr_expr_eval_user_or((char **)(c->argv + 5));
        }
#line 140
        if (tmp___3 == 1) {
#line 140
          if (*((unsigned int *)*(c->argv + 3)) > precedence) {
#line 144
            precedence = *((unsigned int *)*(c->argv + 3));
#line 146
            xfer_rate_kbps = *((long double *)*(c->argv + 1));
#line 147
            xfer_rate_freebytes = *((off_t___0 *)*(c->argv + 2));
#line 148
            have_xfer_rate = 1;
#line 149
            have_user_rate = (unsigned char)1;
#line 150
            have_all_rate = (unsigned char)0;
#line 150
            have_class_rate = have_all_rate;
#line 150
            have_group_rate = have_class_rate;
          }
        }
      } else {
        {
#line 153
        tmp___7 = strcmp((char const   *)*(c->argv + 4), "group");
        }
#line 153
        if (tmp___7 == 0) {
          {
#line 155
          tmp___4 = pr_expr_eval_group_and((char **)(c->argv + 5));
          }
#line 155
          if (tmp___4 == 1) {
#line 155
            if (*((unsigned int *)*(c->argv + 3)) > precedence) {
#line 159
              precedence = *((unsigned int *)*(c->argv + 3));
#line 161
              xfer_rate_kbps = *((long double *)*(c->argv + 1));
#line 162
              xfer_rate_freebytes = *((off_t___0 *)*(c->argv + 2));
#line 163
              have_xfer_rate = 1;
#line 164
              have_group_rate = (unsigned char)1;
#line 165
              have_all_rate = (unsigned char)0;
#line 165
              have_class_rate = have_all_rate;
#line 165
              have_user_rate = have_class_rate;
            }
          }
        } else {
          {
#line 168
          tmp___6 = strcmp((char const   *)*(c->argv + 4), "class");
          }
#line 168
          if (tmp___6 == 0) {
            {
#line 170
            tmp___5 = pr_expr_eval_class_or((char **)(c->argv + 5));
            }
#line 170
            if (tmp___5 == 1) {
#line 170
              if (*((unsigned int *)*(c->argv + 3)) > precedence) {
#line 174
                precedence = *((unsigned int *)*(c->argv + 3));
#line 176
                xfer_rate_kbps = *((long double *)*(c->argv + 1));
#line 177
                xfer_rate_freebytes = *((off_t___0 *)*(c->argv + 2));
#line 178
                have_xfer_rate = 1;
#line 179
                have_class_rate = (unsigned char)1;
#line 180
                have_all_rate = (unsigned char)0;
#line 180
                have_group_rate = have_all_rate;
#line 180
                have_user_rate = have_group_rate;
              }
            }
          }
        }
      }
    } else
#line 186
    if (*((unsigned int *)*(c->argv + 3)) > precedence) {
#line 189
      precedence = *((unsigned int *)*(c->argv + 3));
#line 191
      xfer_rate_kbps = *((long double *)*(c->argv + 1));
#line 192
      xfer_rate_freebytes = *((off_t___0 *)*(c->argv + 2));
#line 193
      have_xfer_rate = 1;
#line 194
      have_all_rate = (unsigned char)1;
#line 195
      have_class_rate = (unsigned char)0;
#line 195
      have_group_rate = have_class_rate;
#line 195
      have_user_rate = have_group_rate;
    }
    {
#line 199
    c = find_config_next(c, c->next, 1 << 15, "TransferRate", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  if (have_xfer_rate) {
#line 204
    if (have_user_rate) {
#line 204
      tmp___11 = " for current user";
    } else {
#line 204
      if (have_group_rate) {
#line 204
        tmp___10 = " for current group";
      } else {
#line 204
        if (have_class_rate) {
#line 204
          tmp___9 = " for current class";
        } else {
#line 204
          tmp___9 = "";
        }
#line 204
        tmp___10 = tmp___9;
      }
#line 204
      tmp___11 = tmp___10;
    }
    {
#line 204
    pr_log_debug(3, "TransferRate (%.3Lf KB/s, %llu bytes free) in effect%s", xfer_rate_kbps,
                 (unsigned long long )xfer_rate_freebytes, tmp___11);
#line 215
    xfer_rate_bps = xfer_rate_kbps * (long double )1024.0;
    }
  }
#line 217
  return;
}
}
#line 219 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/throttle.c"
void pr_throttle_pause(off_t___0 xferlen , int xfer_ending ) 
{ 
  long ideal ;
  long elapsed ;
  off_t___0 orig_xferlen ;
  struct timeval tv ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 220
  ideal = 0L;
#line 220
  elapsed = 0L;
#line 221
  orig_xferlen = xferlen;
#line 223
  if (session.sf_flags & (int volatile   )2) {
#line 224
    return;
  }
  {
#line 227
  elapsed = xfer_rate_since(& session.xfer.start_time);
  }
#line 230
  if (! have_xfer_rate) {
#line 231
    xfer_rate_scoreboard_updates ++;
#line 233
    if (xfer_ending) {
      {
#line 236
      pr_scoreboard_entry_update(session.pid, 15, orig_xferlen, 16, (unsigned long )elapsed,
                                 (void *)0);
#line 241
      xfer_rate_scoreboard_updates = 0U;
      }
    } else
#line 233
    if (xfer_rate_scoreboard_updates % 10U == 0U) {
      {
#line 236
      pr_scoreboard_entry_update(session.pid, 15, orig_xferlen, 16, (unsigned long )elapsed,
                                 (void *)0);
#line 241
      xfer_rate_scoreboard_updates = 0U;
      }
    }
#line 244
    return;
  }
#line 248
  if (xferlen) {
#line 248
    if (xfer_rate_freebytes) {
#line 250
      if (xferlen > xfer_rate_freebytes) {
#line 255
        xferlen -= xfer_rate_freebytes;
      } else {
#line 258
        xfer_rate_scoreboard_updates ++;
#line 264
        if (xfer_ending) {
          {
#line 266
          pr_scoreboard_entry_update(session.pid, 15, orig_xferlen, 16, (unsigned long )elapsed,
                                     (void *)0);
#line 271
          xfer_rate_scoreboard_updates = 0U;
          }
        } else
#line 264
        if (xfer_rate_scoreboard_updates % 10U == 0U) {
          {
#line 266
          pr_scoreboard_entry_update(session.pid, 15, orig_xferlen, 16, (unsigned long )elapsed,
                                     (void *)0);
#line 271
          xfer_rate_scoreboard_updates = 0U;
          }
        }
#line 274
        return;
      }
    }
  }
#line 278
  ideal = (long )((long double )(xferlen * 1000LL) / xfer_rate_bps);
#line 280
  if (ideal > elapsed) {
#line 289
    tv.tv_usec = (ideal - elapsed) * 1000L;
#line 290
    tv.tv_sec = tv.tv_usec / 1000000L;
#line 291
    tv.tv_usec %= 1000000L;
#line 293
    if (tv.tv_sec == 1L) {
#line 293
      tmp = "";
    } else {
#line 293
      tmp = "s";
    }
    {
#line 293
    pr_log_debug(7, "transferring too fast, delaying %ld sec%s, %ld usecs", tv.tv_sec,
                 tmp, tv.tv_usec);
#line 297
    xfer_rate_sigmask(1);
#line 299
    tmp___2 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 299
    if (tmp___2 < 0) {
#line 300
      if (session.sf_flags & (int volatile   )2) {
        {
#line 301
        pr_log_pri(5, "throttling interrupted, transfer aborted");
        }
#line 302
        return;
      }
      {
#line 305
      tmp___0 = __errno_location();
#line 305
      tmp___1 = strerror(*tmp___0);
#line 305
      pr_log_pri(4, "warning: unable to throttle bandwidth: %s", tmp___1);
      }
    }
    {
#line 309
    xfer_rate_sigmask(0);
#line 310
    pr_signals_handle();
#line 313
    pr_scoreboard_entry_update(session.pid, 15, orig_xferlen, 16, (unsigned long )ideal,
                               (void *)0);
    }
  } else {
    {
#line 321
    pr_scoreboard_entry_update(session.pid, 15, orig_xferlen, 16, (unsigned long )elapsed,
                               (void *)0);
    }
  }
#line 327
  return;
}
}
#line 100 "../include/table.h"
int pr_table_empty(pr_table_t *tab ) ;
#line 111
int pr_table_free(pr_table_t *tab ) ;
#line 123
void *pr_table_next(pr_table_t *tab ) ;
#line 134
int pr_table_rewind(pr_table_t *tab ) ;
#line 35 "../include/var.h"
int pr_var_delete(char const   *name ) ;
#line 41
int pr_var_exists(char const   *name ) ;
#line 47
char const   *pr_var_get(char const   *name ) ;
#line 55
char const   *pr_var_next(char const   **desc ) ;
#line 59
void pr_var_rewind(void) ;
#line 103
int var_init(void) ;
#line 104
int var_free(void) ;
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
static pool *var_pool  =    (pool *)((void *)0);
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
static pr_table_t *var_tab  =    (pr_table_t *)((void *)0);
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
int pr_var_delete(char const   *name ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 48
  if (! var_tab) {
    {
#line 49
    tmp = __errno_location();
#line 49
    *tmp = 1;
    }
#line 50
    return (-1);
  }
#line 53
  if (! name) {
    {
#line 54
    tmp___0 = __errno_location();
#line 54
    *tmp___0 = 22;
    }
#line 55
    return (-1);
  }
  {
#line 58
  tmp___3 = pr_table_remove(var_tab, name, (size_t *)((void *)0));
  }
#line 58
  if (tmp___3) {
#line 58
    tmp___2 = 0;
  } else {
#line 58
    tmp___2 = -1;
  }
#line 58
  return (tmp___2);
}
}
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
int pr_var_exists(char const   *name ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 62
  if (! var_tab) {
    {
#line 63
    tmp = __errno_location();
#line 63
    *tmp = 1;
    }
#line 64
    return (-1);
  }
#line 67
  if (! name) {
    {
#line 68
    tmp___0 = __errno_location();
#line 68
    *tmp___0 = 22;
    }
#line 69
    return (-1);
  }
  {
#line 72
  tmp___3 = pr_table_exists(var_tab, name);
  }
#line 72
  if (tmp___3 > 0) {
#line 72
    tmp___2 = 1;
  } else {
#line 72
    tmp___2 = 0;
  }
#line 72
  return (tmp___2);
}
}
#line 75 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
char const   *pr_var_get(char const   *name ) 
{ 
  struct var *v ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;

  {
#line 78
  if (! var_tab) {
    {
#line 79
    tmp = __errno_location();
#line 79
    *tmp = 1;
    }
#line 80
    return ((char const   *)((void *)0));
  }
#line 83
  if (! name) {
    {
#line 84
    tmp___0 = __errno_location();
#line 84
    *tmp___0 = 22;
    }
#line 85
    return ((char const   *)((void *)0));
  }
  {
#line 88
  tmp___1 = pr_table_get(var_tab, name, (size_t *)((void *)0));
#line 88
  v = (struct var *)tmp___1;
  }
#line 89
  if (! v) {
#line 90
    return ((char const   *)((void *)0));
  }
  {
#line 93
  if (v->v_type == 1) {
#line 93
    goto case_1;
  }
#line 97
  if (v->v_type == 2) {
#line 97
    goto case_2;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
#line 94
  return ((char const   *)v->v_val);
#line 95
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 98
  tmp___2 = (*((char const   *(*)(void * , size_t  ))v->v_val))(v->v_data, v->v_datasz);
  }
#line 98
  return (tmp___2);
#line 99
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 106
  tmp___3 = __errno_location();
#line 106
  *tmp___3 = 22;
  }
#line 107
  return ((char const   *)((void *)0));
}
}
#line 110 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
char const   *pr_var_next(char const   **desc ) 
{ 
  char const   *name ;
  struct var *v ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 114
  if (! var_tab) {
    {
#line 115
    tmp = __errno_location();
#line 115
    *tmp = 1;
    }
#line 116
    return ((char const   *)((void *)0));
  }
  {
#line 119
  tmp___0 = pr_table_next(var_tab);
#line 119
  name = (char const   *)tmp___0;
  }
#line 120
  if (! name) {
#line 121
    return ((char const   *)((void *)0));
  }
  {
#line 123
  tmp___1 = pr_table_get(var_tab, name, (size_t *)((void *)0));
#line 123
  v = (struct var *)tmp___1;
  }
#line 124
  if (v) {
#line 124
    if (desc) {
#line 125
      *desc = v->v_desc;
    }
  }
#line 127
  return (name);
}
}
#line 130 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
void pr_var_rewind(void) 
{ 


  {
#line 131
  if (var_tab) {
    {
#line 132
    pr_table_rewind(var_tab);
    }
  }
#line 133
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
int pr_var_set(pool *p , char const   *name , char const   *desc , int type , void *val ,
               void *data , size_t datasz ) 
{ 
  struct var *v ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp25 ;

  {
#line 139
  if ((unsigned long )var_tab == (unsigned long )((void *)0)) {
    {
#line 140
    tmp = __errno_location();
#line 140
    *tmp = 1;
    }
#line 141
    return (-1);
  }
#line 144
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
    }
#line 148
    return (-1);
  } else
#line 144
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
    }
#line 148
    return (-1);
  } else
#line 144
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
    }
#line 148
    return (-1);
  }
  {
#line 152
  tmp___2 = strlen(name);
  }
#line 152
  if (tmp___2 < 4U) {
    {
#line 153
    tmp___1 = __errno_location();
#line 153
    *tmp___1 = 22;
    }
#line 154
    return (-1);
  }
#line 158
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 158
    if (datasz == 0U) {
      {
#line 160
      tmp___3 = __errno_location();
#line 160
      *tmp___3 = 22;
      }
#line 161
      return (-1);
    }
  }
#line 167
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 167
    if (datasz > 0U) {
      {
#line 169
      tmp___4 = __errno_location();
#line 169
      *tmp___4 = 22;
      }
#line 170
      return (-1);
    }
  }
  {
#line 174
  tmp___6 = strncmp(name, "%{", (size_t )2);
  }
#line 174
  if (tmp___6 != 0) {
    {
#line 176
    tmp___5 = __errno_location();
#line 176
    *tmp___5 = 22;
    }
#line 177
    return (-1);
  } else {
    {
#line 174
    tmp___7 = strlen(name);
    }
#line 174
    if ((int const   )*(name + (tmp___7 - 1U)) != 125) {
      {
#line 176
      tmp___5 = __errno_location();
#line 176
      *tmp___5 = 22;
      }
#line 177
      return (-1);
    }
  }
  {
#line 186
  pr_var_delete(name);
  }
  {
#line 197
  if (type == 1) {
#line 197
    goto case_1;
  }
#line 207
  if (type == 2) {
#line 207
    goto case_2;
  }
#line 222
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 198
  tmp___8 = pcalloc(p, (int )sizeof(struct var ));
#line 198
  v = (struct var *)tmp___8;
  }
#line 200
  if (desc) {
    {
#line 201
    tmp___9 = pstrdup(p, desc);
#line 201
    v->v_desc = (char const   *)tmp___9;
    }
  }
  {
#line 202
  v->v_type = 1;
#line 203
  tmp___10 = pstrdup(p, (char const   *)((char *)val));
#line 203
  v->v_val = (void *)tmp___10;
#line 204
  v->v_datasz = strlen((char const   *)((char *)val));
  }
#line 205
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 208
  tmp___11 = pcalloc(p, (int )sizeof(struct var ));
#line 208
  v = (struct var *)tmp___11;
  }
#line 210
  if (desc) {
    {
#line 211
    tmp___12 = pstrdup(p, desc);
#line 211
    v->v_desc = (char const   *)tmp___12;
    }
  }
#line 212
  v->v_type = 2;
#line 213
  v->v_val = (void *)((char const   *(*)(void * , size_t  ))val);
#line 215
  if (data) {
#line 216
    v->v_data = data;
#line 217
    v->v_datasz = datasz;
  }
#line 220
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 223
  tmp___13 = __errno_location();
#line 223
  *tmp___13 = 22;
  }
#line 224
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 227
  tmp___14 = pr_table_add(var_tab, name, (void *)v, (size_t )sizeof(struct var ));
  }
#line 227
  return (tmp___14);
}
}
#line 230 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
int var_init(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 232
  if (! var_pool) {
    {
#line 233
    var_pool = make_sub_pool(permanent_pool);
#line 234
    pr_pool_tag(var_pool, "Variables Pool");
    }
  }
#line 237
  if (! var_tab) {
    {
#line 238
    var_tab = pr_table_alloc(var_pool, 0);
    }
  }
#line 240
  return (0);
}
}
#line 243 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/var.c"
int var_free(void) 
{ 


  {
#line 244
  if (var_pool) {
#line 245
    if (var_tab) {
      {
#line 246
      pr_table_empty(var_tab);
#line 247
      pr_table_free(var_tab);
      }
    }
    {
#line 250
    destroy_pool(var_pool);
#line 251
    var_pool = (pool *)((void *)0);
#line 252
    var_tab = (pr_table_t *)((void *)0);
    }
  }
#line 255
  return (0);
}
}
#line 43 "../include/pool.h"
struct pool *pr_pool_create_sz(struct pool *p , int sz ) ;
#line 81 "../include/event.h"
void pr_event_dump(void (*dumpf)(char const   *  , ...) ) ;
#line 50 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
static pool *event_pool  =    (pool *)((void *)0);
#line 51 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
static struct event_list *events  =    (struct event_list *)((void *)0);
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
static char const   *curr_event  =    (char const   *)((void *)0);
#line 54 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
static struct event_list *curr_evl  =    (struct event_list *)((void *)0);
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
static char const   *trace_channel___1  =    "event";
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
int pr_event_register(module *m , char const   *event , void (*cb)(void const   * ,
                                                                   void * ) , void *user_data ) 
{ 
  struct event_handler *evh ;
  struct event_list *evl ;
  pool *evl_pool ;
  int *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  struct event_handler *evhi ;
  int *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 66
  if (! event) {
    {
#line 67
    tmp = __errno_location();
#line 67
    *tmp = 22;
    }
#line 68
    return (-1);
  } else
#line 66
  if (! cb) {
    {
#line 67
    tmp = __errno_location();
#line 67
    *tmp = 22;
    }
#line 68
    return (-1);
  }
#line 71
  if (! event_pool) {
    {
#line 72
    event_pool = make_sub_pool(permanent_pool);
#line 73
    pr_pool_tag(event_pool, "Event Pool");
    }
  }
#line 76
  if (m) {
#line 76
    tmp___0 = (char const   *)m->name;
  } else {
#line 76
    tmp___0 = "(none)";
  }
  {
#line 76
  pr_trace_msg(trace_channel___1, 3, "module \'%s\' registering handler for event \'%s\' (at %p)",
               tmp___0, event, cb);
#line 80
  tmp___1 = pcalloc(event_pool, (int )sizeof(struct event_handler ));
#line 80
  evh = (struct event_handler *)tmp___1;
#line 82
  evh->module = m;
#line 83
  evh->cb = cb;
#line 84
  evh->user_data = user_data;
#line 90
  evl = events;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! evl) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp___3 = strcmp(evl->event, event);
    }
#line 91
    if (tmp___3 == 0) {
#line 92
      evhi = evl->handlers;
#line 94
      if (evhi) {
        {
#line 98
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 98
          if (! evhi) {
#line 98
            goto while_break___0;
          }
#line 99
          if ((unsigned long )evhi->cb == (unsigned long )evh->cb) {
            {
#line 101
            tmp___2 = __errno_location();
#line 101
            *tmp___2 = 17;
            }
#line 102
            return (-1);
          }
#line 105
          if ((unsigned long )evhi->next == (unsigned long )((void *)0)) {
#line 106
            goto while_break___0;
          }
#line 108
          evhi = evhi->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 111
        evh->prev = evhi;
#line 112
        evhi->next = evh;
      } else {
#line 115
        evl->handlers = evh;
      }
#line 118
      return (0);
    }
#line 90
    evl = evl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  evl_pool = pr_pool_create_sz(event_pool, 256);
#line 123
  pr_pool_tag(evl_pool, "Event listener list pool");
#line 125
  tmp___4 = pcalloc(evl_pool, (int )sizeof(struct event_list ));
#line 125
  evl = (struct event_list *)tmp___4;
#line 126
  evl->pool = evl_pool;
#line 127
  tmp___5 = pstrdup(evl->pool, event);
#line 127
  evl->event = (char const   *)tmp___5;
#line 128
  evl->handlers = evh;
#line 129
  evl->next = events;
#line 131
  events = evl;
#line 134
  curr_event = (char const   *)((void *)0);
#line 135
  curr_evl = (struct event_list *)((void *)0);
  }
#line 137
  return (0);
}
}
#line 140 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
int pr_event_unregister(module *m , char const   *event , void (*cb)(void const   * ,
                                                                     void * ) ) 
{ 
  struct event_list *evl ;
  int unregistered ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct event_handler *evh ;
  struct event_handler *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 143
  unregistered = 0;
#line 145
  if (! events) {
#line 146
    return (0);
  }
#line 148
  if (event) {
#line 148
    tmp = event;
  } else {
#line 148
    tmp = "(all)";
  }
#line 148
  if (m) {
#line 148
    tmp___0 = (char const   *)m->name;
  } else {
#line 148
    tmp___0 = "(none)";
  }
  {
#line 148
  pr_trace_msg(trace_channel___1, 3, "module \'%s\' unregistering handler for event \'%s\'",
               tmp___0, tmp);
#line 158
  evl = events;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! evl) {
#line 158
      goto while_break;
    }
#line 159
    if (! event) {
#line 159
      goto _L___1;
    } else {
      {
#line 159
      tmp___2 = strcmp(evl->event, event);
      }
#line 159
      if (tmp___2 == 0) {
        _L___1: /* CIL Label */ 
#line 165
        if (! evl->handlers) {
#line 166
          goto __Cont;
        }
#line 168
        evh = evl->handlers;
        {
#line 168
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 168
          if (! evh) {
#line 168
            goto while_break___0;
          }
#line 170
          if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 170
            goto _L___0;
          } else
#line 170
          if ((unsigned long )evh->module == (unsigned long )m) {
            _L___0: /* CIL Label */ 
#line 170
            if ((unsigned long )cb == (unsigned long )((void *)0)) {
#line 170
              goto _L;
            } else
#line 170
            if ((unsigned long )evh->cb == (unsigned long )cb) {
              _L: /* CIL Label */ 
#line 172
              tmp___1 = evh->next;
#line 174
              if (evh->prev) {
#line 175
                (evh->prev)->next = evh->next;
              } else {
#line 179
                evl->handlers = evh->next;
              }
#line 181
              if (evh->next) {
#line 182
                (evh->next)->prev = evh->prev;
              }
#line 184
              evh = tmp___1;
#line 185
              unregistered = 1;
            } else {
#line 188
              evh = evh->next;
            }
          } else {
#line 188
            evh = evh->next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 158
    evl = evl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  curr_event = (char const   *)((void *)0);
#line 195
  curr_evl = (struct event_list *)((void *)0);
#line 197
  if (! unregistered) {
    {
#line 198
    tmp___3 = __errno_location();
#line 198
    *tmp___3 = 2;
    }
#line 199
    return (-1);
  }
#line 202
  return (0);
}
}
#line 205 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
void pr_event_generate(char const   *event , void const   *event_data ) 
{ 
  int use_cache ;
  struct event_list *evl ;
  int tmp ;
  struct event_handler *evh ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 206
  use_cache = 0;
#line 209
  if (! event) {
#line 210
    return;
  }
#line 213
  if (! events) {
#line 214
    return;
  }
#line 217
  if (curr_event) {
    {
#line 217
    tmp = strcmp(curr_event, event);
    }
#line 217
    if (tmp == 0) {
#line 219
      use_cache = 1;
    }
  }
#line 222
  if (use_cache) {
#line 222
    evl = curr_evl;
  } else {
#line 222
    evl = events;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! evl) {
#line 222
      goto while_break;
    }
    {
#line 224
    tmp___0 = strcmp(evl->event, event);
    }
#line 224
    if (tmp___0 == 0) {
#line 228
      if (! evl->handlers) {
        {
#line 229
        pr_trace_msg(trace_channel___1, 8, "no event handlers registered for \'%s\'",
                     event);
        }
#line 231
        return;
      }
#line 234
      curr_event = event;
#line 235
      curr_evl = evl;
#line 237
      evh = evl->handlers;
      {
#line 237
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 237
        if (! evh) {
#line 237
          goto while_break___0;
        }
#line 238
        if (evh->module) {
          {
#line 239
          pr_trace_msg(trace_channel___1, 8, "dispatching event \'%s\' to mod_%s",
                       event, (evh->module)->name);
          }
        } else {
          {
#line 243
          pr_trace_msg(trace_channel___1, 8, "dispatching event \'%s\' to core", event);
          }
        }
        {
#line 246
        (*(evh->cb))(event_data, evh->user_data);
#line 237
        evh = evh->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 249
      goto while_break;
    }
#line 222
    evl = evl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return;
}
}
#line 256 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/event.c"
void pr_event_dump(void (*dumpf)(char const   *  , ...) ) 
{ 
  struct event_list *evl ;
  struct event_handler *evh ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 259
  if (! dumpf) {
#line 260
    return;
  }
#line 263
  if (! events) {
    {
#line 264
    (*dumpf)("%s", "No events registered");
    }
#line 265
    return;
  }
#line 268
  evl = events;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! evl) {
#line 268
      goto while_break;
    }
#line 270
    if (! evl->handlers) {
      {
#line 271
      (*dumpf)("No handlers registered for \'%s\'", evl->event);
      }
    } else {
      {
#line 276
      (*dumpf)("Registered for \'%s\':", evl->event);
#line 277
      evh = evl->handlers;
      }
      {
#line 277
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 277
        if (! evh) {
#line 277
          goto while_break___0;
        }
#line 278
        if (evh->module) {
          {
#line 279
          (*dumpf)("  mod_%s.c", (evh->module)->name);
          }
        } else {
          {
#line 282
          (*dumpf)("  (core)");
          }
        }
#line 277
        evh = evh->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 268
    evl = evl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 354 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 166
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 260 "../include/fsio.h"
int pr_fsio_symlink(char const   *lfrom , char const   *lto ) ;
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c"
static int create_dir(char const   *dir , uid_t uid , gid_t gid , mode_t mode ) 
{ 
  mode_t prev_mask ;
  struct stat st ;
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 36
  res = -1;
#line 38
  pr_fs_clear_cache();
#line 39
  res = pr_fsio_stat(dir, & st);
  }
#line 41
  if (res == -1) {
    {
#line 41
    tmp___1 = __errno_location();
    }
#line 41
    if (*tmp___1 != 2) {
      {
#line 42
      tmp = __errno_location();
#line 42
      tmp___0 = strerror(*tmp);
#line 42
      pr_log_pri(4, "error checking \'%s\': %s", dir, tmp___0);
      }
#line 44
      return (-1);
    }
  }
#line 48
  if (res == 0) {
    {
#line 49
    pr_log_debug(3, "CreateHome: \'%s\' already exists", dir);
    }
#line 50
    return (0);
  }
  {
#line 54
  prev_mask = umask((__mode_t )0);
#line 56
  tmp___4 = pr_fsio_mkdir(dir, mode);
  }
#line 56
  if (tmp___4 < 0) {
    {
#line 57
    umask(prev_mask);
#line 58
    tmp___2 = __errno_location();
#line 58
    tmp___3 = strerror(*tmp___2);
#line 58
    pr_log_pri(4, "error creating \'%s\': %s", dir, tmp___3);
    }
#line 60
    return (-1);
  }
  {
#line 63
  umask(prev_mask);
#line 65
  tmp___7 = pr_fsio_chown(dir, uid, gid);
  }
#line 65
  if (tmp___7 < 0) {
    {
#line 66
    tmp___5 = __errno_location();
#line 66
    tmp___6 = strerror(*tmp___5);
#line 66
    pr_log_pri(4, "error setting ownership of \'%s\': %s", dir, tmp___6);
    }
#line 68
    return (-1);
  }
  {
#line 71
  pr_log_debug(6, "CreateHome: directory \'%s\' created", dir);
  }
#line 72
  return (0);
}
}
#line 78 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c"
static int create_path(pool *p , char const   *path , char const   *user , uid_t dir_uid ,
                       gid_t dir_gid , mode_t dir_mode , uid_t dst_uid , gid_t dst_gid ,
                       mode_t dst_mode ) 
{ 
  char *currpath ;
  char *tmppath ;
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  char *currdir ;
  char *tmp___1 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 81
  currpath = (char *)((void *)0);
#line 81
  tmppath = (char *)((void *)0);
#line 84
  pr_fs_clear_cache();
#line 85
  tmp___0 = pr_fsio_stat(path, & st);
  }
#line 85
  if (tmp___0 == 0) {
    {
#line 87
    tmp = __errno_location();
#line 87
    *tmp = 17;
    }
#line 88
    return (-1);
  }
  {
#line 91
  pr_event_generate("core.create-home", (void const   *)user);
  }
#line 97
  if (dir_uid == 4294967295U) {
#line 98
    dir_uid = dst_uid;
  }
#line 101
  if (dir_gid == 4294967295U) {
#line 102
    dir_gid = dst_gid;
  }
  {
#line 105
  pr_log_debug(3, "creating home directory \'%s\' for user \'%s\'", path, user);
#line 107
  tmppath = pstrdup(p, path);
#line 109
  currpath = (char *)"/";
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (tmppath) {
#line 110
      if (! *tmppath) {
#line 110
        goto while_break;
      }
    } else {
#line 110
      goto while_break;
    }
    {
#line 111
    tmp___1 = strsep((char **/* __restrict  */)(& tmppath), (char const   */* __restrict  */)"/");
#line 111
    currdir = tmp___1;
#line 112
    currpath = pdircat(p, currpath, currdir, (void *)0);
    }
#line 117
    if ((unsigned long )tmppath == (unsigned long )((void *)0)) {
      {
#line 118
      create_dir((char const   *)currpath, dst_uid, dst_gid, dst_mode);
      }
    } else
#line 117
    if ((int )*tmppath == 0) {
      {
#line 118
      create_dir((char const   *)currpath, dst_uid, dst_gid, dst_mode);
      }
    } else {
      {
#line 120
      create_dir((char const   *)currpath, dir_uid, dir_gid, dir_mode);
      }
    }
    {
#line 122
    pr_signals_handle();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  pr_log_debug(3, "home directory \'%s\' created", path);
  }
#line 126
  return (0);
}
}
#line 129 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c"
static int copy_symlink(pool *p , char const   *src_dir , char const   *src_path ,
                        char const   *dst_dir , char const   *dst_path , uid_t uid ,
                        gid_t gid ) 
{ 
  char *link_path ;
  void *tmp ;
  int len ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 131
  tmp = pcalloc(p, 1024);
#line 131
  link_path = (char *)tmp;
#line 134
  len = pr_fsio_readlink(src_path, link_path, (size_t )1023);
  }
#line 135
  if (len < 0) {
    {
#line 136
    tmp___0 = __errno_location();
#line 136
    tmp___1 = strerror(*tmp___0);
#line 136
    pr_log_pri(4, "CreateHome: error reading link \'%s\': %s", src_path, tmp___1);
    }
#line 138
    return (-1);
  }
  {
#line 140
  *(link_path + len) = (char )'\000';
#line 145
  tmp___3 = strlen(src_dir);
#line 145
  tmp___4 = strncmp((char const   *)link_path, src_dir, tmp___3);
  }
#line 145
  if (tmp___4 == 0) {
    {
#line 146
    tmp___2 = strlen(src_dir);
#line 146
    link_path = pdircat(p, dst_dir, link_path + tmp___2, (void *)0);
    }
  }
  {
#line 148
  tmp___7 = pr_fsio_symlink((char const   *)link_path, dst_path);
  }
#line 148
  if (tmp___7 < 0) {
    {
#line 149
    tmp___5 = __errno_location();
#line 149
    tmp___6 = strerror(*tmp___5);
#line 149
    pr_log_pri(4, "CreateHome: error symlinking \'%s\' to \'%s\': %s", link_path,
               dst_path, tmp___6);
    }
#line 151
    return (-1);
  }
  {
#line 155
  tmp___10 = pr_fsio_chown(dst_path, uid, gid);
  }
#line 155
  if (tmp___10 < 0) {
    {
#line 156
    tmp___8 = __errno_location();
#line 156
    tmp___9 = strerror(*tmp___8);
#line 156
    pr_log_pri(4, "CreateHome: error chown\'ing \'%s\' to %u/%u: %s", dst_path, uid,
               gid, tmp___9);
    }
  }
#line 160
  return (0);
}
}
#line 167 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c"
static int copy_dir(pool *p , char const   *src_dir , char const   *dst_dir , uid_t uid ,
                    gid_t gid ) 
{ 
  DIR *dh ;
  struct dirent *dent ;
  int *tmp ;
  char *tmp___0 ;
  struct stat st ;
  char *src_path ;
  char *dst_path ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  mode_t dst_mode ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 169
  dh = (DIR *)((void *)0);
#line 170
  dent = (struct dirent *)((void *)0);
#line 172
  dh = opendir(src_dir);
  }
#line 173
  if ((unsigned long )dh == (unsigned long )((void *)0)) {
    {
#line 174
    tmp = __errno_location();
#line 174
    tmp___0 = strerror(*tmp);
#line 174
    pr_log_pri(4, "CreateHome: error copying \'%s\' skel files: %s", src_dir, tmp___0);
    }
#line 176
    return (-1);
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    dent = readdir(dh);
    }
#line 179
    if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 179
      goto while_break;
    }
    {
#line 183
    pr_signals_handle();
#line 186
    tmp___1 = strcmp((char const   *)(dent->d_name), ".");
    }
#line 186
    if (tmp___1 == 0) {
#line 188
      goto while_continue;
    } else {
      {
#line 186
      tmp___2 = strcmp((char const   *)(dent->d_name), "..");
      }
#line 186
      if (tmp___2 == 0) {
#line 188
        goto while_continue;
      }
    }
    {
#line 190
    src_path = pdircat(p, src_dir, dent->d_name, (void *)0);
#line 191
    dst_path = pdircat(p, dst_dir, dent->d_name, (void *)0);
#line 193
    tmp___5 = pr_fsio_lstat((char const   *)src_path, & st);
    }
#line 193
    if (tmp___5 < 0) {
      {
#line 194
      tmp___3 = __errno_location();
#line 194
      tmp___4 = strerror(*tmp___3);
#line 194
      pr_log_debug(3, "CreateHome: unable to stat \'%s\' (%s), skipping", src_path,
                   tmp___4);
      }
#line 196
      goto while_continue;
    }
#line 200
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 202
      create_dir((char const   *)dst_path, uid, gid, st.st_mode);
#line 203
      copy_dir(p, (char const   *)src_path, (char const   *)dst_path, uid, gid);
      }
#line 204
      goto while_continue;
    } else
#line 208
    if ((st.st_mode & 61440U) == 32768U) {
#line 209
      dst_mode = st.st_mode;
#line 213
      if (dst_mode & 2048U) {
#line 214
        dst_mode &= 4294965247U;
      }
#line 216
      if (dst_mode & 1024U) {
#line 217
        dst_mode &= 4294966271U;
      }
      {
#line 219
      pr_fs_copy_file((char const   *)src_path, (char const   *)dst_path);
#line 222
      tmp___8 = pr_fsio_chown((char const   *)dst_path, uid, gid);
      }
#line 222
      if (tmp___8 < 0) {
        {
#line 223
        tmp___6 = __errno_location();
#line 223
        tmp___7 = strerror(*tmp___6);
#line 223
        pr_log_pri(4, "CreateHome: error chown\'ing \'%s\' to %u/%u: %s", dst_path,
                   uid, gid, tmp___7);
        }
      }
      {
#line 227
      tmp___11 = pr_fsio_chmod((char const   *)dst_path, dst_mode);
      }
#line 227
      if (tmp___11 < 0) {
        {
#line 228
        tmp___9 = __errno_location();
#line 228
        tmp___10 = strerror(*tmp___9);
#line 228
        pr_log_pri(4, "CreateHome: error chmod\'ing \'%s\' to %04o: %s", dst_path,
                   dst_mode, tmp___10);
        }
      }
#line 231
      goto while_continue;
    } else
#line 234
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 236
      copy_symlink(p, src_dir, (char const   *)src_path, dst_dir, (char const   *)dst_path,
                   uid, gid);
      }
#line 237
      goto while_continue;
    } else {
      {
#line 241
      pr_log_debug(3, "CreateHome: skipping skel file \'%s\'", src_path);
      }
#line 242
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  closedir(dh);
  }
#line 247
  return (0);
}
}
#line 253 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c"
int create_home(pool *p , char const   *home , char const   *user , uid_t uid , gid_t gid ) 
{ 
  int res ;
  config_rec *c ;
  config_rec *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *skel_dir ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  __uid_t tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
  {
#line 256
  tmp = find_config(main_server->conf, 1 << 15, "CreateHome", 0);
#line 256
  c = tmp;
  }
#line 259
  if (! c) {
#line 261
    return (0);
  } else
#line 259
  if (c) {
#line 259
    if ((int )*((unsigned char *)*(c->argv + 0)) == 0) {
#line 261
      return (0);
    }
  }
  {
#line 263
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c",
               263);
#line 263
  pr_signals_block();
  }
#line 263
  if (! session.disable_id_switching) {
    {
#line 263
    tmp___2 = seteuid((__uid_t )0);
    }
#line 263
    if (tmp___2) {
      {
#line 263
      tmp___0 = __errno_location();
#line 263
      tmp___1 = strerror(*tmp___0);
#line 263
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___1);
      }
    }
    {
#line 263
    tmp___5 = setegid((__gid_t )0);
    }
#line 263
    if (tmp___5) {
      {
#line 263
      tmp___3 = __errno_location();
#line 263
      tmp___4 = strerror(*tmp___3);
#line 263
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___4);
      }
    }
  } else {
    {
#line 263
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 263
  pr_signals_unblock();
#line 266
  res = create_path(p, home, user, *((uid_t *)*(c->argv + 4)), *((gid_t *)*(c->argv + 5)),
                    *((mode_t *)*(c->argv + 2)), uid, gid, *((mode_t *)*(c->argv + 1)));
  }
#line 270
  if (res < 0) {
    {
#line 270
    tmp___16 = __errno_location();
    }
#line 270
    if (*tmp___16 != 17) {
      {
#line 272
      pr_signals_block();
      }
#line 272
      if (! session.disable_id_switching) {
        {
#line 272
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c",
                     272);
#line 272
        tmp___9 = geteuid();
        }
#line 272
        if (tmp___9 != 0U) {
          {
#line 272
          tmp___8 = seteuid((__uid_t )0);
          }
#line 272
          if (tmp___8) {
            {
#line 272
            tmp___6 = __errno_location();
#line 272
            tmp___7 = strerror(*tmp___6);
#line 272
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___7);
            }
          }
        }
        {
#line 272
        tmp___12 = setegid(session.gid);
        }
#line 272
        if (tmp___12) {
          {
#line 272
          tmp___10 = __errno_location();
#line 272
          tmp___11 = strerror(*tmp___10);
#line 272
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___11);
          }
        }
        {
#line 272
        tmp___15 = seteuid(session.uid);
        }
#line 272
        if (tmp___15) {
          {
#line 272
          tmp___13 = __errno_location();
#line 272
          tmp___14 = strerror(*tmp___13);
#line 272
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___14);
          }
        }
      } else {
        {
#line 272
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 272
      pr_signals_unblock();
      }
#line 273
      return (-1);
    }
  }
#line 276
  if (res == 0) {
#line 276
    if (*(c->argv + 3)) {
      {
#line 278
      skel_dir = (char *)*(c->argv + 3);
#line 284
      pr_log_debug(4, "CreateHome: copying skel files from \'%s\' into \'%s\'", skel_dir,
                   home);
#line 286
      tmp___17 = copy_dir(p, (char const   *)skel_dir, home, uid, gid);
      }
#line 286
      if (tmp___17 < 0) {
        {
#line 287
        pr_log_debug(4, "CreateHome: error copying skel files");
        }
      }
    }
  }
  {
#line 290
  pr_signals_block();
  }
#line 290
  if (! session.disable_id_switching) {
    {
#line 290
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/mkhome.c",
                 290);
#line 290
    tmp___21 = geteuid();
    }
#line 290
    if (tmp___21 != 0U) {
      {
#line 290
      tmp___20 = seteuid((__uid_t )0);
      }
#line 290
      if (tmp___20) {
        {
#line 290
        tmp___18 = __errno_location();
#line 290
        tmp___19 = strerror(*tmp___18);
#line 290
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___19);
        }
      }
    }
    {
#line 290
    tmp___24 = setegid(session.gid);
    }
#line 290
    if (tmp___24) {
      {
#line 290
      tmp___22 = __errno_location();
#line 290
      tmp___23 = strerror(*tmp___22);
#line 290
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___23);
      }
    }
    {
#line 290
    tmp___27 = seteuid(session.uid);
    }
#line 290
    if (tmp___27) {
      {
#line 290
      tmp___25 = __errno_location();
#line 290
      tmp___26 = strerror(*tmp___25);
#line 290
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___26);
      }
    }
  } else {
    {
#line 290
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 290
  pr_signals_unblock();
  }
#line 291
  return (0);
}
}
#line 157 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 327 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 438
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 457
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 471
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 756
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 769
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) symlink)(char const   *__from ,
                                                                                      char const   *__to ) ;
#line 775
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2))) readlink)(char const   * __restrict  __path ,
                                                                                           char * __restrict  __buf ,
                                                                                           size_t __len ) ;
#line 801
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 910
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chroot)(char const   *__path ) ;
#line 952
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) truncate)(char const   *__file ,
                                                                                     __off64_t __length )  __asm__("truncate64")  ;
#line 973
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 217 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf )  __asm__("fstat64")  ;
#line 265
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 282
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 295
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 318
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 88 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 133
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , __mode_t __mode )  __asm__("creat64")  ;
#line 140 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
#line 149
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval  const  *__tvp ) ;
#line 181 "../include/glibc-glob.h"
extern int glob(char const   *__pattern , int __flags , int (*__errfunc)(char const   * ,
                                                                         int  ) ,
                glob_t *__pglob ) ;
#line 185
extern void globfree(glob_t *__pglob ) ;
#line 234 "../include/fsio.h"
int pr_fsio_stat_canon(char const   *path , struct stat *sbuf___0 ) ;
#line 237
int pr_fsio_lstat_canon(char const   *path , struct stat *sbuf___0 ) ;
#line 239
int pr_fsio_readlink_canon(char const   *path , char *buf___2 , size_t buflen ) ;
#line 248
int pr_fsio_rename_canon(char const   *rfrom , char const   *rto ) ;
#line 250
int pr_fsio_unlink_canon(char const   *name ) ;
#line 252
pr_fh_t *pr_fsio_open_canon(char const   *name , int flags ) ;
#line 253
pr_fh_t *pr_fsio_creat(char const   *name , mode_t mode ) ;
#line 254
pr_fh_t *pr_fsio_creat_canon(char const   *name , mode_t mode ) ;
#line 258
int pr_fsio_link(char const   *lfrom , char const   *lto ) ;
#line 259
int pr_fsio_link_canon(char const   *lfrom , char const   *lto ) ;
#line 261
int pr_fsio_symlink_canon(char const   *lfrom , char const   *lto ) ;
#line 263
int pr_fsio_truncate(char const   *path , off_t___0 len ) ;
#line 264
int pr_fsio_truncate_canon(char const   *path , off_t___0 len ) ;
#line 266
int pr_fsio_fchmod(pr_fh_t *fh , mode_t mode ) ;
#line 267
int pr_fsio_chmod_canon(char const   *name , mode_t mode ) ;
#line 269
int pr_fsio_fchown(pr_fh_t *fh , uid_t uid , gid_t gid ) ;
#line 270
int pr_fsio_chown_canon(char const   *name , uid_t uid , gid_t gid ) ;
#line 271
int pr_fsio_chroot(char const   *path ) ;
#line 273
int pr_fsio_faccess(pr_fh_t *fh , int mode , uid_t uid , gid_t gid , array_header *suppl_gids ) ;
#line 275
int pr_fsio_futimes(pr_fh_t *fh , struct timeval *tvs ) ;
#line 280
char *pr_fsio_getline(char *buf___2 , int buflen , pr_fh_t *fh , unsigned int *lineno ) ;
#line 281
char *pr_fsio_gets(char *buf___2 , size_t size , pr_fh_t *fh ) ;
#line 282
int pr_fsio_puts(char const   *buf___2 , pr_fh_t *fh ) ;
#line 284
pr_fs_t *pr_register_fs(pool *p , char const   *name , char const   *path ) ;
#line 285
pr_fs_t *pr_create_fs(pool *p , char const   *name ) ;
#line 286
pr_fs_t *pr_get_fs(char const   *path , int *exact ) ;
#line 287
int pr_insert_fs(pr_fs_t *fs , char const   *path ) ;
#line 288
pr_fs_t *pr_remove_fs(char const   *path ) ;
#line 289
pr_fs_t *pr_unmount_fs(char const   *path , char const   *name ) ;
#line 290
int pr_unregister_fs(char const   *path ) ;
#line 309
int pr_fs_dircat(char *buf___2 , int buflen , char const   *dir1 , char const   *dir2 ) ;
#line 311
int pr_fs_resolve_partial(char const   *path , char *buf___2 , size_t buflen , int op ) ;
#line 312
int pr_fs_resolve_path(char const   *path , char *buf___2 , size_t buflen , int op ) ;
#line 315
int pr_fs_use_encoding(int bool ) ;
#line 317
void pr_fs_virtual_path(char const   *path , char *buf___2 , size_t buflen ) ;
#line 325
off_t___0 pr_fs_getsize(char *path ) ;
#line 329
int init_fs(void) ;
#line 57 "/usr/include/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) statvfs)(char const   * __restrict  __file ,
                                                                                      struct statvfs * __restrict  __buf )  __asm__("statvfs64")  ;
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static char const   *trace_channel___2  =    "fsio";
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *root_fs  =    (pr_fs_t *)((void *)0);
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *fs_cwd  =    (pr_fs_t *)((void *)0);
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static array_header *fs_map  =    (array_header *)((void *)0);
#line 73 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static fsopendir_t *fsopendir_list  ;
#line 75 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static void *fs_cache_dir  =    (void *)0;
#line 76 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *fs_cache_fsdir  =    (pr_fs_t *)((void *)0);
#line 81 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static unsigned char chk_fs_map  =    (unsigned char)0;
#line 84 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static char vwd[4097]  = {      (char )'/',      (char )'\000'};
#line 85 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static char cwd___0[4097]  = {      (char )'/',      (char )'\000'};
#line 88 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int use_encoding  =    1;
#line 93 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_stat(pr_fs_t *fs , char const   *path , struct stat *sbuf___0 ) 
{ 
  int tmp ;

  {
  {
#line 94
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)sbuf___0);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_fstat(pr_fh_t *fh , int fd___0 , struct stat *sbuf___0 ) 
{ 
  int tmp ;

  {
  {
#line 98
  tmp = fstat(fd___0, sbuf___0);
  }
#line 98
  return (tmp);
}
}
#line 101 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_lstat(pr_fs_t *fs , char const   *path , struct stat *sbuf___0 ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)sbuf___0);
  }
#line 102
  return (tmp);
}
}
#line 105 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_rename(pr_fs_t *fs , char const   *rnfm , char const   *rnto ) 
{ 
  int tmp ;

  {
  {
#line 106
  tmp = rename(rnfm, rnto);
  }
#line 106
  return (tmp);
}
}
#line 109 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_unlink(pr_fs_t *fs , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 110
  tmp = unlink(path);
  }
#line 110
  return (tmp);
}
}
#line 113 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_open(pr_fh_t *fh , char const   *path , int flags ) 
{ 
  int tmp ;

  {
  {
#line 122
  tmp = open(path, flags, 438);
  }
#line 122
  return (tmp);
}
}
#line 125 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_creat(pr_fh_t *fh , char const   *path , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 126
  tmp = creat(path, mode);
  }
#line 126
  return (tmp);
}
}
#line 129 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_close(pr_fh_t *fh , int fd___0 ) 
{ 
  int tmp ;

  {
  {
#line 130
  tmp = close(fd___0);
  }
#line 130
  return (tmp);
}
}
#line 133 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_read(pr_fh_t *fh , int fd___0 , char *buf___2 , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 134
  tmp = read(fd___0, (void *)buf___2, size);
  }
#line 134
  return (tmp);
}
}
#line 137 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_write(pr_fh_t *fh , int fd___0 , char const   *buf___2 , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 138
  tmp = write(fd___0, (void const   *)buf___2, size);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static off_t___0 sys_lseek(pr_fh_t *fh , int fd___0 , off_t___0 offset , int whence ) 
{ 
  __off64_t tmp ;

  {
  {
#line 142
  tmp = lseek(fd___0, offset, whence);
  }
#line 142
  return (tmp);
}
}
#line 145 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_link(pr_fs_t *fs , char const   *path1 , char const   *path2 ) 
{ 
  int tmp ;

  {
  {
#line 146
  tmp = link(path1, path2);
  }
#line 146
  return (tmp);
}
}
#line 149 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_symlink(pr_fs_t *fs , char const   *path1 , char const   *path2 ) 
{ 
  int tmp ;

  {
  {
#line 150
  tmp = symlink(path1, path2);
  }
#line 150
  return (tmp);
}
}
#line 153 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_readlink(pr_fs_t *fs , char const   *path , char *buf___2 , size_t buflen ) 
{ 
  ssize_t tmp ;

  {
  {
#line 155
  tmp = readlink((char const   */* __restrict  */)path, (char */* __restrict  */)buf___2,
                 buflen);
  }
#line 155
  return (tmp);
}
}
#line 158 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_ftruncate(pr_fh_t *fh , int fd___0 , off_t___0 len ) 
{ 
  int tmp ;

  {
  {
#line 159
  tmp = ftruncate(fd___0, len);
  }
#line 159
  return (tmp);
}
}
#line 162 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_truncate(pr_fs_t *fs , char const   *path , off_t___0 len ) 
{ 
  int tmp ;

  {
  {
#line 163
  tmp = truncate(path, len);
  }
#line 163
  return (tmp);
}
}
#line 166 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_chmod(pr_fs_t *fs , char const   *path , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 167
  tmp = chmod(path, mode);
  }
#line 167
  return (tmp);
}
}
#line 170 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_fchmod(pr_fh_t *fh , int fd___0 , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 171
  tmp = fchmod(fd___0, mode);
  }
#line 171
  return (tmp);
}
}
#line 174 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_chown(pr_fs_t *fs , char const   *path , uid_t uid , gid_t gid ) 
{ 
  int tmp ;

  {
  {
#line 175
  tmp = chown(path, uid, gid);
  }
#line 175
  return (tmp);
}
}
#line 178 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_fchown(pr_fh_t *fh , int fd___0 , uid_t uid , gid_t gid ) 
{ 
  int tmp ;

  {
  {
#line 179
  tmp = fchown(fd___0, uid, gid);
  }
#line 179
  return (tmp);
}
}
#line 186 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_access(pr_fs_t *fs , char const   *path , int mode , uid_t uid , gid_t gid ,
                      array_header *suppl_gids ) 
{ 
  mode_t mask ;
  struct stat st ;
  int tmp ;
  register unsigned int i___0 ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 191
  pr_fs_clear_cache();
#line 192
  tmp = pr_fsio_stat(path, & st);
  }
#line 192
  if (tmp < 0) {
#line 193
    return (-1);
  }
#line 196
  if (uid == 0U) {
#line 197
    return (0);
  }
#line 205
  mask = (mode_t )((((256 >> 3) >> 3) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3));
#line 207
  if (st.st_uid == uid) {
#line 208
    mask |= 448U;
  }
#line 214
  if (st.st_gid == gid) {
#line 215
    mask |= (unsigned int )(((256 >> 3) | (128 >> 3)) | (64 >> 3));
  } else
#line 218
  if (suppl_gids) {
#line 219
    i___0 = 0U;
#line 221
    i___0 = 0U;
    {
#line 221
    while (1) {
      while_continue: /* CIL Label */ ;
#line 221
      if (! (i___0 < (unsigned int )suppl_gids->nelts)) {
#line 221
        goto while_break;
      }
#line 222
      if (st.st_gid == *((gid_t *)suppl_gids->elts + i___0)) {
#line 223
        mask |= (unsigned int )(((256 >> 3) | (128 >> 3)) | (64 >> 3));
#line 224
        goto while_break;
      }
#line 221
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 230
  mask &= st.st_mode;
#line 233
  if (mode & 4) {
#line 234
    if (! (mask & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) {
      {
#line 235
      tmp___0 = __errno_location();
#line 235
      *tmp___0 = 13;
      }
#line 236
      return (-1);
    }
  }
#line 240
  if (mode & 2) {
#line 241
    if (! (mask & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3)))) {
      {
#line 242
      tmp___1 = __errno_location();
#line 242
      *tmp___1 = 13;
      }
#line 243
      return (-1);
    }
  }
#line 247
  if (mode & 1) {
#line 248
    if (! (mask & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3)))) {
      {
#line 249
      tmp___2 = __errno_location();
#line 249
      *tmp___2 = 13;
      }
#line 250
      return (-1);
    }
  }
#line 255
  return (0);
}
}
#line 258 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_faccess(pr_fh_t *fh , int mode , uid_t uid , gid_t gid , array_header *suppl_gids ) 
{ 
  int tmp ;

  {
  {
#line 260
  tmp = sys_access(fh->fh_fs, (char const   *)fh->fh_path, mode, uid, gid, suppl_gids);
  }
#line 260
  return (tmp);
}
}
#line 263 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_utimes(pr_fs_t *fs , char const   *path , struct timeval *tvs ) 
{ 
  int tmp ;

  {
  {
#line 264
  tmp = utimes(path, (struct timeval  const  *)tvs);
  }
#line 264
  return (tmp);
}
}
#line 267 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_futimes(pr_fh_t *fh , int fd___0 , struct timeval *tvs ) 
{ 
  int tmp ;

  {
  {
#line 269
  tmp = futimes(fd___0, (struct timeval  const  *)tvs);
  }
#line 269
  return (tmp);
}
}
#line 275 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_chroot(pr_fs_t *fs , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 276
  tmp = chroot(path);
  }
#line 276
  if (tmp < 0) {
#line 277
    return (-1);
  }
#line 279
  session.chroot_path = (char *)path;
#line 280
  return (0);
}
}
#line 283 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_chdir(pr_fs_t *fs , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 284
  tmp = chdir(path);
  }
#line 284
  if (tmp < 0) {
#line 285
    return (-1);
  }
  {
#line 287
  pr_fs_setcwd(path);
  }
#line 288
  return (0);
}
}
#line 291 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static void *sys_opendir(pr_fs_t *fs , char const   *path ) 
{ 
  DIR *tmp ;

  {
  {
#line 292
  tmp = opendir(path);
  }
#line 292
  return ((void *)tmp);
}
}
#line 295 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_closedir(pr_fs_t *fs , void *dir ) 
{ 
  int tmp ;

  {
  {
#line 296
  tmp = closedir((DIR *)dir);
  }
#line 296
  return (tmp);
}
}
#line 299 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static struct dirent *sys_readdir(pr_fs_t *fs , void *dir ) 
{ 
  struct dirent *tmp ;

  {
  {
#line 300
  tmp = readdir((DIR *)dir);
  }
#line 300
  return (tmp);
}
}
#line 303 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_mkdir(pr_fs_t *fs , char const   *path , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 304
  tmp = mkdir(path, mode);
  }
#line 304
  return (tmp);
}
}
#line 307 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int sys_rmdir(pr_fs_t *fs , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 308
  tmp = rmdir(path);
  }
#line 308
  return (tmp);
}
}
#line 311 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int fs_cmp(void const   *a , void const   *b ) 
{ 
  pr_fs_t *fsa ;
  pr_fs_t *fsb ;
  int tmp ;

  {
  {
#line 314
  fsa = *((pr_fs_t **)a);
#line 315
  fsb = *((pr_fs_t **)b);
#line 317
  tmp = strcmp((char const   *)fsa->fs_path, (char const   *)fsb->fs_path);
  }
#line 317
  return (tmp);
}
}
#line 329 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static fs_statcache_t statcache  ;
#line 334 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static int cache_stat(pr_fs_t *fs , char const   *path , struct stat *sbuf___0 , unsigned int op ) 
{ 
  int res ;
  char pathbuf[4097] ;
  unsigned int tmp ;
  int (*mystat)(pr_fs_t * , char const   * , struct stat * ) ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 336
  res = -1;
#line 337
  pathbuf[0] = (char )'\000';
#line 337
  tmp = 1U;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (tmp >= 4097U) {
#line 337
      goto while_break;
    }
#line 337
    pathbuf[tmp] = (char)0;
#line 337
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  mystat = (int (*)(pr_fs_t * , char const   * , struct stat * ))((void *)0);
#line 341
  if (! fs) {
    {
#line 342
    tmp___0 = __errno_location();
#line 342
    *tmp___0 = 22;
    }
#line 343
    return (-1);
  }
#line 346
  if (! path) {
    {
#line 347
    tmp___1 = __errno_location();
#line 347
    *tmp___1 = 2;
    }
#line 348
    return (-1);
  }
#line 355
  if ((int const   )*path != 47) {
    {
#line 356
    sstrcat(pathbuf, (char const   *)(cwd___0), (size_t )(sizeof(pathbuf) - 1UL));
#line 362
    tmp___2 = strcmp((char const   *)(cwd___0), "/");
    }
#line 362
    if (tmp___2 != 0) {
      {
#line 363
      sstrcat(pathbuf, "/", (size_t )(sizeof(pathbuf) - 1UL));
      }
    }
    {
#line 365
    sstrcat(pathbuf, path, (size_t )(sizeof(pathbuf) - 1UL));
    }
  } else {
    {
#line 368
    sstrncpy(pathbuf, path, (size_t )(sizeof(pathbuf) - 1UL));
    }
  }
#line 371
  if (op == 1U) {
#line 372
    if (fs->stat) {
#line 372
      mystat = fs->stat;
    } else {
#line 372
      mystat = & sys_stat;
    }
  } else
#line 375
  if (fs->lstat) {
#line 375
    mystat = fs->lstat;
  } else {
#line 375
    mystat = & sys_lstat;
  }
  {
#line 379
  tmp___4 = strcmp((char const   *)(pathbuf), (char const   *)(statcache.sc_path));
  }
#line 379
  if (tmp___4 == 0) {
    {
#line 382
    memcpy((void */* __restrict  */)sbuf___0, (void const   */* __restrict  */)(& statcache.sc_stat),
           (size_t )sizeof(struct stat ));
#line 385
    tmp___3 = __errno_location();
#line 385
    *tmp___3 = statcache.sc_errno;
    }
#line 387
    return (statcache.sc_retval);
  }
  {
#line 390
  res = (*mystat)(fs, (char const   *)(pathbuf), sbuf___0);
#line 393
  memset((void *)(statcache.sc_path), '\000', (size_t )sizeof(statcache.sc_path));
#line 394
  sstrncpy(statcache.sc_path, (char const   *)(pathbuf), (size_t )sizeof(statcache.sc_path));
#line 395
  memcpy((void */* __restrict  */)(& statcache.sc_stat), (void const   */* __restrict  */)sbuf___0,
         (size_t )sizeof(struct stat ));
#line 396
  tmp___5 = __errno_location();
#line 396
  statcache.sc_errno = *tmp___5;
#line 397
  statcache.sc_retval = res;
  }
#line 399
  return (res);
}
}
#line 405
static pr_fs_t *lookup_file_canon_fs(char const   *path , char **deref , int op ) ;
#line 415 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *lookup_dir_fs(char const   *path , int op ) 
{ 
  char buf___2[4097] ;
  unsigned int tmp ;
  char tmp_path[4097] ;
  unsigned int tmp___0 ;
  pr_fs_t *fs ;
  int exact ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  pr_fs_t *tmp___4 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 416
  buf___2[0] = (char )'\000';
#line 416
  tmp = 1U;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (tmp >= 4097U) {
#line 416
      goto while_break;
    }
#line 416
    buf___2[tmp] = (char)0;
#line 416
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  tmp_path[0] = (char )'\000';
#line 417
  tmp___0 = 1U;
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 417
    if (tmp___0 >= 4097U) {
#line 417
      goto while_break___0;
    }
#line 417
    tmp_path[tmp___0] = (char)0;
#line 417
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 418
  fs = (pr_fs_t *)((void *)0);
#line 419
  exact = 0;
#line 425
  sstrncpy(buf___2, path, (size_t )sizeof(buf___2));
#line 431
  tmp___2 = pr_fs_valid_path(path);
  }
#line 431
  if (tmp___2 < 0) {
    {
#line 432
    tmp___1 = pr_fs_dircat(tmp_path, (int )sizeof(tmp_path), (char const   *)(cwd___0),
                           (char const   *)(buf___2));
    }
#line 432
    if (tmp___1 < 0) {
#line 433
      return ((pr_fs_t *)((void *)0));
    }
  } else {
    {
#line 436
    sstrncpy(tmp_path, (char const   *)(buf___2), (size_t )sizeof(tmp_path));
    }
  }
#line 442
  if ((((((((1 << 16) | (1 << 17)) | (1 << 18)) | (1 << 20)) | (1 << 19)) | (1 << 21)) | (1 << 22)) & op) {
    {
#line 442
    tmp___3 = strlen((char const   *)(tmp_path));
    }
#line 442
    if ((int )tmp_path[tmp___3 - 1U] != 47) {
      {
#line 443
      sstrcat(tmp_path, "/", (size_t )sizeof(tmp_path));
      }
    }
  }
  {
#line 445
  fs = pr_get_fs((char const   *)(tmp_path), & exact);
  }
#line 488
  if (fs) {
#line 488
    tmp___4 = fs;
  } else {
#line 488
    tmp___4 = root_fs;
  }
#line 488
  return (tmp___4);
}
}
#line 496 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *lookup_file_fs(char const   *path , char **deref , int op ) 
{ 
  pr_fs_t *fs ;
  struct stat sbuf___0 ;
  int (*mystat)(pr_fs_t * , char const   * , struct stat * ) ;
  int tmp ;
  char *tmp___2 ;
  pr_fs_t *tmp___3 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 498
  tmp___2 = strchr(path, '/');
  }
#line 498
  if (! tmp___2) {
#line 508
    fs = fs_cwd;
#line 510
    mystat = (int (*)(pr_fs_t * , char const   * , struct stat * ))((void *)0);
#line 513
    if (op == 1) {
      {
#line 514
      while (1) {
        while_continue: /* CIL Label */ ;
#line 514
        if (fs) {
#line 514
          if (fs->fs_next) {
#line 514
            if (! (! fs->stat)) {
#line 514
              goto while_break;
            }
          } else {
#line 514
            goto while_break;
          }
        } else {
#line 514
          goto while_break;
        }
#line 515
        fs = fs->fs_next;
      }
      while_break: /* CIL Label */ ;
      }
#line 517
      mystat = fs->stat;
    } else {
      {
#line 520
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 520
        if (fs) {
#line 520
          if (fs->fs_next) {
#line 520
            if (! (! fs->lstat)) {
#line 520
              goto while_break___0;
            }
          } else {
#line 520
            goto while_break___0;
          }
        } else {
#line 520
          goto while_break___0;
        }
#line 521
        fs = fs->fs_next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 523
      mystat = fs->lstat;
    }
    {
#line 526
    tmp = (*mystat)(fs, path, & sbuf___0);
    }
#line 526
    if (tmp == -1) {
#line 527
      return (fs);
    } else
#line 526
    if (! ((sbuf___0.st_mode & 61440U) == 40960U)) {
#line 527
      return (fs);
    }
  }
  {
#line 563
  tmp___3 = lookup_dir_fs(path, op);
  }
#line 563
  return (tmp___3);
}
}
#line 567 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static char workpath[4097]  ;
#line 566 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *lookup_file_canon_fs(char const   *path , char **deref , int op ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  pr_fs_t *tmp___2 ;

  {
  {
#line 569
  memset((void *)(workpath), '\000', (size_t )sizeof(workpath));
#line 571
  tmp___1 = pr_fs_resolve_partial(path, workpath, (size_t )(sizeof(workpath) - 1UL),
                                  1 << 4);
  }
#line 571
  if (tmp___1 == -1) {
#line 573
    if ((int const   )*path == 47) {
#line 573
      goto _L;
    } else
#line 573
    if ((int const   )*path == 126) {
      _L: /* CIL Label */ 
      {
#line 574
      tmp = pr_fs_interpolate(path, workpath, (size_t )(sizeof(workpath) - 1UL));
      }
#line 574
      if (tmp != -1) {
        {
#line 575
        sstrncpy(workpath, path, (size_t )sizeof(workpath));
        }
      }
    } else {
      {
#line 578
      tmp___0 = pr_fs_dircat(workpath, (int )sizeof(workpath), (char const   *)(cwd___0),
                             path);
      }
#line 578
      if (tmp___0 < 0) {
#line 579
        return ((pr_fs_t *)((void *)0));
      }
    }
  }
#line 583
  if (deref) {
#line 584
    *deref = workpath;
  }
  {
#line 586
  tmp___2 = lookup_file_fs((char const   *)(workpath), deref, op);
  }
#line 586
  return (tmp___2);
}
}
#line 591 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void pr_fs_clear_cache(void) 
{ 


  {
  {
#line 592
  memset((void *)(& statcache), '\000', (size_t )sizeof(statcache));
  }
#line 593
  return;
}
}
#line 595 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_copy_file(char const   *src , char const   *dst ) 
{ 
  pr_fh_t *src_fh ;
  pr_fh_t *dst_fh ;
  struct stat src_st ;
  struct stat dst_st ;
  char *buf___2 ;
  size_t bufsz ;
  int res ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int xerrno ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int xerrno___0 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 602
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    {
#line 604
    tmp = __errno_location();
#line 604
    *tmp = 22;
    }
#line 605
    return (-1);
  } else
#line 602
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
    {
#line 604
    tmp = __errno_location();
#line 604
    *tmp = 22;
    }
#line 605
    return (-1);
  }
  {
#line 608
  src_fh = pr_fsio_open(src, 0);
  }
#line 609
  if (! src_fh) {
    {
#line 610
    tmp___0 = __errno_location();
#line 610
    tmp___1 = strerror(*tmp___0);
#line 610
    pr_log_pri(4, "error opening source file \'%s\' for copying: %s", src, tmp___1);
    }
#line 612
    return (-1);
  }
  {
#line 621
  pr_fsio_fstat(src_fh, & src_st);
  }
#line 622
  if ((src_st.st_mode & 61440U) == 16384U) {
    {
#line 623
    pr_fsio_close(src_fh);
#line 625
    tmp___2 = __errno_location();
#line 625
    *tmp___2 = 21;
#line 626
    tmp___3 = __errno_location();
#line 626
    tmp___4 = strerror(*tmp___3);
#line 626
    pr_log_pri(4, "warning: cannot copy source \'%s\': %s", src, tmp___4);
    }
#line 628
    return (-1);
  }
  {
#line 631
  dst_fh = pr_fsio_open(dst, 65);
  }
#line 632
  if (! dst_fh) {
    {
#line 633
    tmp___5 = __errno_location();
#line 633
    xerrno = *tmp___5;
#line 635
    pr_fsio_close(src_fh);
#line 636
    tmp___6 = __errno_location();
#line 636
    *tmp___6 = xerrno;
#line 638
    tmp___7 = __errno_location();
#line 638
    tmp___8 = strerror(*tmp___7);
#line 638
    pr_log_pri(4, "error opening destination file \'%s\' for copying: %s", dst, tmp___8);
    }
#line 640
    return (-1);
  }
  {
#line 644
  tmp___13 = pr_fsio_fstat(src_fh, & src_st);
  }
#line 644
  if (tmp___13 < 0) {
    {
#line 645
    tmp___9 = __errno_location();
#line 645
    xerrno___0 = *tmp___9;
#line 646
    tmp___10 = __errno_location();
#line 646
    tmp___11 = strerror(*tmp___10);
#line 646
    pr_log_pri(4, "error checking source file \'%s\' for copying: %s", src, tmp___11);
#line 649
    pr_fsio_close(src_fh);
#line 650
    pr_fsio_close(dst_fh);
#line 651
    pr_fsio_unlink(dst);
#line 653
    tmp___12 = __errno_location();
#line 653
    *tmp___12 = xerrno___0;
    }
#line 654
    return (-1);
  }
  {
#line 657
  tmp___15 = pr_fsio_fstat(dst_fh, & dst_st);
  }
#line 657
  if (tmp___15 == 0) {
    {
#line 665
    tmp___14 = strcmp(src, dst);
    }
#line 665
    if (tmp___14 == 0) {
#line 665
      if (src_st.st_dev == dst_st.st_dev) {
#line 665
        if (src_st.st_ino == dst_st.st_ino) {
#line 665
          if (src_st.st_size == dst_st.st_size) {
#line 665
            if (src_st.st_mtim.tv_sec == dst_st.st_mtim.tv_sec) {
              {
#line 671
              pr_fsio_close(src_fh);
#line 672
              pr_fsio_close(dst_fh);
              }
#line 675
              return (0);
            }
          }
        }
      }
    }
  }
  {
#line 679
  bufsz = (size_t )src_st.st_blksize;
#line 680
  tmp___16 = malloc(bufsz);
#line 680
  buf___2 = (char *)tmp___16;
  }
#line 681
  if (! buf___2) {
    {
#line 682
    pr_log_pri(2, "Out of memory!");
#line 683
    exit(1);
    }
  }
  {
#line 687
  pr_fsio_truncate(dst, (off_t___0 )0);
  }
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 689
    res = pr_fsio_read(src_fh, buf___2, bufsz);
    }
#line 689
    if (! (res > 0)) {
#line 689
      goto while_break;
    }
    {
#line 690
    pr_signals_handle();
#line 692
    tmp___19 = pr_fsio_write(dst_fh, (char const   *)buf___2, (size_t )res);
    }
#line 692
    if (tmp___19 != res) {
      {
#line 693
      tmp___17 = __errno_location();
#line 693
      tmp___18 = strerror(*tmp___17);
#line 693
      pr_log_pri(4, "error copying to \'%s\': %s", dst, tmp___18);
      }
#line 695
      goto while_break;
    }
    {
#line 698
    pr_signals_handle();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 701
  free((void *)buf___2);
#line 789
  pr_fsio_close(src_fh);
#line 790
  tmp___22 = pr_fsio_close(dst_fh);
  }
#line 790
  if (tmp___22 < 0) {
    {
#line 791
    tmp___20 = __errno_location();
#line 791
    tmp___21 = strerror(*tmp___20);
#line 791
    pr_log_pri(4, "error closing \'%s\': %s", dst, tmp___21);
    }
  }
#line 794
  return (res);
}
}
#line 797 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fs_t *pr_register_fs(pool *p , char const   *name , char const   *path ) 
{ 
  pr_fs_t *fs ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 798
  fs = (pr_fs_t *)((void *)0);
#line 801
  if (! p) {
    {
#line 802
    tmp = __errno_location();
#line 802
    *tmp = 22;
    }
#line 803
    return ((pr_fs_t *)((void *)0));
  } else
#line 801
  if (! name) {
    {
#line 802
    tmp = __errno_location();
#line 802
    *tmp = 22;
    }
#line 803
    return ((pr_fs_t *)((void *)0));
  } else
#line 801
  if (! path) {
    {
#line 802
    tmp = __errno_location();
#line 802
    *tmp = 22;
    }
#line 803
    return ((pr_fs_t *)((void *)0));
  }
  {
#line 807
  fs = pr_create_fs(p, name);
  }
#line 808
  if ((unsigned long )fs != (unsigned long )((void *)0)) {
    {
#line 811
    tmp___0 = pr_insert_fs(fs, path);
    }
#line 811
    if (! tmp___0) {
      {
#line 812
      pr_trace_msg(trace_channel___2, 4, "error inserting FS \'%s\' at path \'%s\'",
                   name, path);
#line 815
      destroy_pool(fs->fs_pool);
      }
#line 816
      return ((pr_fs_t *)((void *)0));
    }
  } else {
    {
#line 820
    pr_trace_msg(trace_channel___2, 6, "error creating FS \'%s\'", name);
    }
  }
#line 822
  return (fs);
}
}
#line 825 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fs_t *pr_create_fs(pool *p , char const   *name ) 
{ 
  pr_fs_t *fs ;
  pool *fs_pool ;
  int *tmp ;
  void *tmp___0 ;
  pr_fs_t *tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 826
  fs = (pr_fs_t *)((void *)0);
#line 827
  fs_pool = (pool *)((void *)0);
#line 830
  if (! p) {
    {
#line 831
    tmp = __errno_location();
#line 831
    *tmp = 22;
    }
#line 832
    return ((pr_fs_t *)((void *)0));
  } else
#line 830
  if (! name) {
    {
#line 831
    tmp = __errno_location();
#line 831
    *tmp = 22;
    }
#line 832
    return ((pr_fs_t *)((void *)0));
  }
  {
#line 836
  fs_pool = make_sub_pool(p);
#line 837
  pr_pool_tag(fs_pool, "FS Pool");
#line 839
  tmp___0 = pcalloc(fs_pool, (int )sizeof(pr_fs_t ));
#line 839
  fs = (pr_fs_t *)tmp___0;
  }
#line 840
  if (! fs) {
#line 841
    return ((pr_fs_t *)((void *)0));
  }
  {
#line 843
  fs->fs_pool = fs_pool;
#line 844
  tmp___1 = (pr_fs_t *)((void *)0);
#line 844
  fs->fs_prev = tmp___1;
#line 844
  fs->fs_next = tmp___1;
#line 845
  fs->fs_name = pstrdup(fs->fs_pool, name);
#line 846
  fs->fs_next = root_fs;
#line 847
  fs->allow_xdev_link = 1;
#line 848
  fs->allow_xdev_rename = 1;
#line 851
  fs->fs_path = (char *)((void *)0);
  }
#line 853
  return (fs);
}
}
#line 856 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_insert_fs(pr_fs_t *fs , char const   *path ) 
{ 
  char cleaned_path[4096] ;
  unsigned int tmp ;
  pool *map_pool ;
  pool *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  pr_fs_t *fsi ;
  pr_fs_t **fs_objs ;
  register int i___0 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 857
  cleaned_path[0] = (char )'\000';
#line 857
  tmp = 1U;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (tmp >= 4096U) {
#line 857
      goto while_break;
    }
#line 857
    cleaned_path[tmp] = (char)0;
#line 857
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 859
  if (! fs_map) {
    {
#line 860
    tmp___0 = make_sub_pool(permanent_pool);
#line 860
    map_pool = tmp___0;
#line 861
    pr_pool_tag(map_pool, "FSIO Map Pool");
#line 863
    fs_map = make_array(map_pool, 0U, (size_t )sizeof(pr_fs_t *));
    }
  }
#line 869
  if ((int const   )*path == 47) {
    {
#line 870
    pr_fs_clean_path(path, cleaned_path, (size_t )sizeof(cleaned_path));
#line 877
    tmp___2 = strlen(path);
    }
#line 877
    if ((int const   )*(path + (tmp___2 - 1U)) == 47) {
      {
#line 878
      tmp___1 = strlen((char const   *)(cleaned_path));
#line 878
      len = tmp___1;
      }
#line 880
      if (len > 1U) {
#line 880
        if (len < 4093U) {
#line 880
          if ((int )cleaned_path[len - 1U] != 47) {
#line 883
            cleaned_path[len] = (char )'/';
#line 884
            cleaned_path[len + 1U] = (char )'\000';
          }
        }
      }
    }
  } else {
    {
#line 889
    sstrncpy(cleaned_path, path, (size_t )sizeof(cleaned_path));
    }
  }
#line 891
  if (! fs->fs_path) {
    {
#line 892
    fs->fs_path = pstrdup(fs->fs_pool, (char const   *)(cleaned_path));
    }
  }
#line 895
  if (fs_map->nelts > 0) {
#line 896
    fsi = (pr_fs_t *)((void *)0);
#line 896
    fs_objs = (pr_fs_t **)fs_map->elts;
#line 899
    i___0 = 0;
    {
#line 899
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 899
      if (! (i___0 < fs_map->nelts)) {
#line 899
        goto while_break___0;
      }
      {
#line 900
      fsi = *(fs_objs + i___0);
#line 902
      tmp___5 = strcmp((char const   *)fsi->fs_path, (char const   *)(cleaned_path));
      }
#line 902
      if (tmp___5 == 0) {
        {
#line 906
        tmp___4 = strcmp((char const   *)fsi->fs_name, (char const   *)fs->fs_name);
        }
#line 906
        if (tmp___4 == 0) {
          {
#line 907
          pr_log_pri(7, "error: duplicate fs paths not allowed: \'%s\'", cleaned_path);
#line 909
          tmp___3 = __errno_location();
#line 909
          *tmp___3 = 17;
          }
#line 910
          return (0);
        }
#line 914
        fs->fs_next = fsi;
#line 915
        fsi->fs_prev = fs;
#line 916
        *(fs_objs + i___0) = fs;
#line 918
        chk_fs_map = (unsigned char)1;
#line 919
        return (1);
      }
#line 899
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 925
  tmp___6 = push_array(fs_map);
#line 925
  *((pr_fs_t **)tmp___6) = fs;
  }
#line 930
  if (fs_map->nelts > 1) {
    {
#line 931
    qsort(fs_map->elts, (size_t )fs_map->nelts, (size_t )sizeof(pr_fs_t *), & fs_cmp);
    }
  }
#line 936
  chk_fs_map = (unsigned char)1;
#line 938
  return (1);
}
}
#line 941 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fs_t *pr_unmount_fs(char const   *path , char const   *name ) 
{ 
  pr_fs_t *fsi ;
  pr_fs_t **fs_objs ;
  register unsigned int i___0 ;
  int *tmp ;
  int *tmp___0 ;
  register unsigned int j ;
  pr_fs_t *tmp_fs ;
  pr_fs_t **old_objs ;
  pool *map_pool ;
  array_header *new_map ;
  void *tmp___1 ;
  int tmp___2 ;
  pr_fs_t *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;

  {
#line 942
  fsi = (pr_fs_t *)((void *)0);
#line 942
  fs_objs = (pr_fs_t **)((void *)0);
#line 943
  i___0 = 0U;
#line 946
  if (! path) {
    {
#line 947
    tmp = __errno_location();
#line 947
    *tmp = 22;
    }
#line 948
    return ((pr_fs_t *)((void *)0));
  }
#line 952
  if (! fs_map) {
    {
#line 953
    tmp___0 = __errno_location();
#line 953
    *tmp___0 = 13;
    }
#line 954
    return ((pr_fs_t *)((void *)0));
  }
#line 957
  fs_objs = (pr_fs_t **)fs_map->elts;
#line 959
  i___0 = 0U;
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! (i___0 < (unsigned int )fs_map->nelts)) {
#line 959
      goto while_break;
    }
    {
#line 960
    fsi = *(fs_objs + i___0);
#line 962
    tmp___4 = strcmp((char const   *)fsi->fs_path, path);
    }
#line 962
    if (tmp___4 == 0) {
#line 962
      if (name) {
        {
#line 962
        tmp___5 = strcmp((char const   *)fsi->fs_name, name);
#line 962
        tmp___6 = tmp___5 == 0;
        }
      } else {
#line 962
        tmp___6 = 1;
      }
#line 962
      if (tmp___6) {
#line 971
        if ((unsigned long )fsi->fs_next == (unsigned long )((void *)0)) {
#line 972
          j = 0U;
#line 973
          old_objs = (pr_fs_t **)((void *)0);
#line 980
          if (fs_map->nelts == 1) {
            {
#line 981
            destroy_pool(fs_map->pool);
#line 982
            fs_map = (array_header *)((void *)0);
#line 983
            fs_cwd = root_fs;
#line 985
            chk_fs_map = (unsigned char)1;
            }
#line 986
            return ((pr_fs_t *)((void *)0));
          }
          {
#line 989
          map_pool = make_sub_pool(permanent_pool);
#line 990
          new_map = make_array(map_pool, 0U, (size_t )sizeof(pr_fs_t *));
#line 992
          pr_pool_tag(map_pool, "FSIO Map Pool");
#line 993
          old_objs = (pr_fs_t **)fs_map->elts;
#line 995
          j = 0U;
          }
          {
#line 995
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 995
            if (! (j < (unsigned int )fs_map->nelts)) {
#line 995
              goto while_break___0;
            }
            {
#line 996
            tmp_fs = *(old_objs + j);
#line 998
            tmp___2 = strcmp((char const   *)tmp_fs->fs_path, path);
            }
#line 998
            if (tmp___2 != 0) {
              {
#line 999
              tmp___1 = push_array(new_map);
#line 999
              *((pr_fs_t **)tmp___1) = *(old_objs + j);
              }
            }
#line 995
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1002
          destroy_pool(fs_map->pool);
#line 1003
          fs_map = new_map;
#line 1008
          chk_fs_map = (unsigned char)1;
          }
#line 1010
          return (fsi);
        }
#line 1014
        if (fsi->fs_next) {
#line 1015
          (fsi->fs_next)->fs_prev = (pr_fs_t *)((void *)0);
        }
#line 1016
        *(fs_objs + i___0) = fsi->fs_next;
#line 1017
        tmp___3 = (pr_fs_t *)((void *)0);
#line 1017
        fsi->fs_prev = tmp___3;
#line 1017
        fsi->fs_next = tmp___3;
#line 1019
        chk_fs_map = (unsigned char)1;
#line 1020
        return (fsi);
      }
    }
#line 959
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  return ((pr_fs_t *)((void *)0));
}
}
#line 1027 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fs_t *pr_remove_fs(char const   *path ) 
{ 
  pr_fs_t *tmp ;

  {
  {
#line 1028
  tmp = pr_unmount_fs(path, (char const   *)((void *)0));
  }
#line 1028
  return (tmp);
}
}
#line 1031 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_unregister_fs(char const   *path ) 
{ 
  pr_fs_t *fs ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 1032
  fs = (pr_fs_t *)((void *)0);
#line 1034
  if (! path) {
    {
#line 1035
    tmp = __errno_location();
#line 1035
    *tmp = 22;
    }
#line 1036
    return (-1);
  }
  {
#line 1042
  fs = pr_remove_fs(path);
  }
#line 1043
  if (fs) {
    {
#line 1044
    destroy_pool(fs->fs_pool);
    }
#line 1045
    return (0);
  }
  {
#line 1048
  tmp___0 = __errno_location();
#line 1048
  *tmp___0 = 2;
  }
#line 1049
  return (-1);
}
}
#line 1064 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fs_t *pr_get_fs(char const   *path , int *exact ) 
{ 
  pr_fs_t *fs ;
  pr_fs_t **fs_objs ;
  pr_fs_t *best_match_fs ;
  register unsigned int i___0 ;
  int *tmp ;
  int res ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 1065
  fs = (pr_fs_t *)((void *)0);
#line 1065
  fs_objs = (pr_fs_t **)((void *)0);
#line 1065
  best_match_fs = (pr_fs_t *)((void *)0);
#line 1066
  i___0 = 0U;
#line 1069
  if (! path) {
    {
#line 1070
    tmp = __errno_location();
#line 1070
    *tmp = 22;
    }
#line 1071
    return ((pr_fs_t *)((void *)0));
  }
#line 1077
  if (! fs_map) {
#line 1079
    return (root_fs);
  } else
#line 1077
  if (fs_map->nelts == 0) {
#line 1079
    return (root_fs);
  }
#line 1082
  fs_objs = (pr_fs_t **)fs_map->elts;
#line 1083
  best_match_fs = root_fs;
#line 1093
  i___0 = 0U;
  {
#line 1093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (! (i___0 < (unsigned int )fs_map->nelts)) {
#line 1093
      goto while_break;
    }
    {
#line 1094
    res = 0;
#line 1096
    fs = *(fs_objs + i___0);
#line 1102
    tmp___0 = strlen((char const   *)fs->fs_path);
    }
#line 1102
    if ((int )*(fs->fs_path + (tmp___0 - 1U)) == 47) {
      {
#line 1102
      tmp___1 = strlen((char const   *)fs->fs_path);
#line 1102
      tmp___2 = strncmp(path, (char const   *)fs->fs_path, tmp___1);
      }
#line 1102
      if (! tmp___2) {
#line 1104
        best_match_fs = fs;
      }
    }
    {
#line 1106
    res = strcmp((char const   *)fs->fs_path, path);
    }
#line 1108
    if (res == 0) {
#line 1111
      if (exact) {
#line 1112
        *exact = 1;
      }
#line 1114
      chk_fs_map = (unsigned char)0;
#line 1115
      return (fs);
    } else
#line 1117
    if (res > 0) {
#line 1119
      if (exact) {
#line 1120
        *exact = 0;
      }
#line 1122
      chk_fs_map = (unsigned char)0;
#line 1125
      return (best_match_fs);
    }
#line 1093
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1129
  chk_fs_map = (unsigned char)0;
#line 1132
  return (best_match_fs);
}
}
#line 1355 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void pr_fs_setcwd(char const   *dir ) 
{ 


  {
  {
#line 1356
  pr_fs_resolve_path(dir, cwd___0, (size_t )(sizeof(cwd___0) - 1UL), 1 << 17);
#line 1357
  sstrncpy(cwd___0, dir, (size_t )sizeof(cwd___0));
#line 1358
  fs_cwd = lookup_dir_fs((char const   *)(cwd___0), 1 << 17);
#line 1359
  cwd___0[sizeof(cwd___0) - 1UL] = (char )'\000';
  }
#line 1360
  return;
}
}
#line 1362 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
char const   *pr_fs_getcwd(void) 
{ 


  {
#line 1363
  return ((char const   *)(cwd___0));
}
}
#line 1366 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
char const   *pr_fs_getvwd(void) 
{ 


  {
#line 1367
  return ((char const   *)(vwd));
}
}
#line 1370 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_dircat(char *buf___2 , int buflen , char const   *dir1 , char const   *dir2 ) 
{ 
  char *_dir1 ;
  char *_dir2 ;
  size_t dir1len ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp14 ;

  {
#line 1372
  _dir1 = (char *)((void *)0);
#line 1372
  _dir2 = (char *)((void *)0);
#line 1373
  dir1len = (size_t )0;
#line 1375
  if (! dir1) {
    {
#line 1376
    tmp = __errno_location();
#line 1376
    *tmp = 22;
    }
#line 1377
    return (-1);
  } else
#line 1375
  if (! dir2) {
    {
#line 1376
    tmp = __errno_location();
#line 1376
    *tmp = 22;
    }
#line 1377
    return (-1);
  }
  {
#line 1382
  tmp___1 = strlen(dir1);
#line 1382
  tmp___2 = strlen(dir2);
  }
#line 1382
  if ((tmp___1 + tmp___2) + 1U >= 4096U) {
    {
#line 1383
    tmp___0 = __errno_location();
#line 1383
    *tmp___0 = 36;
#line 1384
    *(buf___2 + 0) = (char )'\000';
    }
#line 1385
    return (-1);
  }
  {
#line 1388
  _dir1 = strdup(dir1);
  }
#line 1389
  if (! _dir1) {
#line 1390
    return (-1);
  }
  {
#line 1392
  _dir2 = strdup(dir2);
  }
#line 1393
  if (! _dir2) {
    {
#line 1394
    free((void *)_dir1);
    }
#line 1395
    return (-1);
  }
  {
#line 1398
  tmp___3 = strlen((char const   *)_dir1);
#line 1398
  dir1len = tmp___3 - 1U;
  }
#line 1400
  if ((int )*_dir2 == 47) {
    {
#line 1401
    sstrncpy(buf___2, (char const   *)_dir2, (size_t )buflen);
#line 1402
    free((void *)_dir1);
#line 1403
    free((void *)_dir2);
    }
#line 1404
    return (0);
  }
  {
#line 1407
  sstrncpy(buf___2, (char const   *)_dir1, (size_t )buflen);
  }
#line 1409
  if (buflen) {
#line 1409
    if ((int )*(_dir1 + dir1len) != 47) {
      {
#line 1410
      sstrcat(buf___2, "/", (size_t )buflen);
      }
    }
  }
  {
#line 1412
  sstrcat(buf___2, (char const   *)_dir2, (size_t )buflen);
  }
#line 1414
  if (! *buf___2) {
#line 1415
    tmp___4 = buf___2;
#line 1415
    buf___2 ++;
#line 1415
    *tmp___4 = (char )'/';
#line 1416
    *buf___2 = (char )'\000';
  }
  {
#line 1419
  free((void *)_dir1);
#line 1420
  free((void *)_dir2);
  }
#line 1422
  return (0);
}
}
#line 1432 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_interpolate(char const   *path , char *buf___2 , size_t buflen ) 
{ 
  pool *p ;
  struct passwd *pw ;
  struct stat sbuf___0 ;
  char *fname ;
  char user[257] ;
  unsigned int tmp ;
  int len ;
  int *tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1433
  p = (pool *)((void *)0);
#line 1434
  pw = (struct passwd *)((void *)0);
#line 1436
  fname = (char *)((void *)0);
#line 1437
  user[0] = (char )'\000';
#line 1437
  tmp = 1U;
  {
#line 1437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1437
    if (tmp >= 257U) {
#line 1437
      goto while_break;
    }
#line 1437
    user[tmp] = (char)0;
#line 1437
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1440
  if (! path) {
    {
#line 1441
    tmp___0 = __errno_location();
#line 1441
    *tmp___0 = 22;
    }
#line 1442
    return (-1);
  }
#line 1445
  if ((int const   )*(path + 0) == 126) {
    {
#line 1446
    fname = strchr(path, '/');
    }
#line 1450
    if (fname) {
#line 1451
      len = (int )(fname - (char *)path);
#line 1452
      if ((unsigned long )len > sizeof(user)) {
#line 1452
        tmp___1 = sizeof(user);
      } else {
#line 1452
        tmp___1 = (unsigned long )len;
      }
      {
#line 1452
      sstrncpy(user, path + 1, (size_t )tmp___1);
#line 1455
      fname ++;
      }
    } else {
      {
#line 1457
      tmp___4 = pr_fsio_stat(path, & sbuf___0);
      }
#line 1457
      if (tmp___4 == -1) {
        {
#line 1464
        tmp___2 = strlen(path);
#line 1464
        len = (int )tmp___2;
        }
#line 1465
        if ((unsigned long )len > sizeof(user)) {
#line 1465
          tmp___3 = sizeof(user);
        } else {
#line 1465
          tmp___3 = (unsigned long )len;
        }
        {
#line 1465
        sstrncpy(user, path + 1, (size_t )tmp___3);
        }
      } else {
#line 1471
        fname = (char *)path;
#line 1472
        return (0);
      }
    }
#line 1478
    if (! user[0]) {
      {
#line 1479
      sstrncpy(user, (char const   *)session.user, (size_t )sizeof(user));
      }
    }
    {
#line 1486
    p = make_sub_pool(permanent_pool);
#line 1487
    pr_pool_tag(p, "pr_fs_interpolate() pool");
#line 1489
    pw = pr_auth_getpwnam(p, (char const   *)(user));
    }
#line 1491
    if (! pw) {
      {
#line 1492
      destroy_pool(p);
#line 1493
      tmp___5 = __errno_location();
#line 1493
      *tmp___5 = 2;
      }
#line 1494
      return (-1);
    }
    {
#line 1497
    sstrncpy(buf___2, (char const   *)pw->pw_dir, buflen);
#line 1500
    destroy_pool(p);
#line 1502
    tmp___6 = strlen((char const   *)buf___2);
#line 1502
    len = (int )tmp___6;
    }
#line 1504
    if (fname) {
#line 1504
      if ((size_t )len < buflen) {
#line 1504
        if ((int )*(buf___2 + (len - 1)) != 47) {
#line 1505
          tmp___7 = len;
#line 1505
          len ++;
#line 1505
          *(buf___2 + tmp___7) = (char )'/';
        }
      }
    }
#line 1507
    if (fname) {
      {
#line 1508
      sstrncpy(buf___2 + len, (char const   *)fname, buflen - (size_t )len);
      }
    }
  } else {
    {
#line 1511
    sstrncpy(buf___2, path, buflen);
    }
  }
#line 1513
  return (1);
}
}
#line 1516 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_resolve_partial(char const   *path , char *buf___2 , size_t buflen , int op ) 
{ 
  char curpath[4097] ;
  unsigned int tmp ;
  char workpath___0[4097] ;
  unsigned int tmp___0 ;
  char namebuf___1[4097] ;
  unsigned int tmp___1 ;
  char *where ;
  char *ptr ;
  char *last ;
  pr_fs_t *fs ;
  int len ;
  int fini ;
  int link_cnt ;
  ino_t last_inode ;
  dev_t last_device ;
  struct stat sbuf___0 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t wherelen ;
  size_t tmp___8 ;
  int tmp___9 ;
  char linkpath[4097] ;
  unsigned int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  char tmpbuf[4097] ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
#line 1517
  curpath[0] = (char )'\000';
#line 1517
  tmp = 1U;
  {
#line 1517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1517
    if (tmp >= 4097U) {
#line 1517
      goto while_break;
    }
#line 1517
    curpath[tmp] = (char)0;
#line 1517
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1517
  workpath___0[0] = (char )'\000';
#line 1517
  tmp___0 = 1U;
  {
#line 1517
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1517
    if (tmp___0 >= 4097U) {
#line 1517
      goto while_break___0;
    }
#line 1517
    workpath___0[tmp___0] = (char)0;
#line 1517
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1517
  namebuf___1[0] = (char )'\000';
#line 1517
  tmp___1 = 1U;
  {
#line 1517
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1517
    if (tmp___1 >= 4097U) {
#line 1517
      goto while_break___1;
    }
#line 1517
    namebuf___1[tmp___1] = (char)0;
#line 1517
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1517
  where = (char *)((void *)0);
#line 1517
  ptr = (char *)((void *)0);
#line 1517
  last = (char *)((void *)0);
#line 1522
  fs = (pr_fs_t *)((void *)0);
#line 1523
  len = 0;
#line 1523
  fini = 1;
#line 1523
  link_cnt = 0;
#line 1524
  last_inode = (ino_t )0;
#line 1525
  last_device = (dev_t )0;
#line 1528
  if (! path) {
    {
#line 1529
    tmp___2 = __errno_location();
#line 1529
    *tmp___2 = 22;
    }
#line 1530
    return (-1);
  }
#line 1533
  if ((int const   )*path != 47) {
#line 1534
    if ((int const   )*path == 126) {
      {
#line 1535
      tmp___3 = pr_fs_interpolate(path, curpath, (size_t )(sizeof(curpath) - 1UL));
      }
      {
#line 1536
      if (tmp___3 == -1) {
#line 1536
        goto case_neg_1;
      }
#line 1539
      if (tmp___3 == 0) {
#line 1539
        goto case_0;
      }
#line 1535
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 1537
      return (-1);
      case_0: /* CIL Label */ 
      {
#line 1540
      sstrncpy(curpath, path, (size_t )sizeof(curpath));
#line 1541
      sstrncpy(workpath___0, (char const   *)(cwd___0), (size_t )sizeof(workpath___0));
      }
#line 1542
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1546
      sstrncpy(curpath, path, (size_t )sizeof(curpath));
#line 1547
      sstrncpy(workpath___0, (char const   *)(cwd___0), (size_t )sizeof(workpath___0));
      }
    }
  } else {
    {
#line 1551
    sstrncpy(curpath, path, (size_t )sizeof(curpath));
    }
  }
  {
#line 1553
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1553
    tmp___17 = fini;
#line 1553
    fini --;
#line 1553
    if (! tmp___17) {
#line 1553
      goto while_break___2;
    }
#line 1554
    where = curpath;
    {
#line 1556
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1556
      if (! ((int )*where != 0)) {
#line 1556
        goto while_break___3;
      }
      {
#line 1557
      pr_signals_handle();
#line 1560
      tmp___4 = strcmp((char const   *)where, ".");
      }
#line 1560
      if (tmp___4 == 0) {
#line 1561
        where ++;
#line 1562
        goto while_continue___3;
      }
      {
#line 1566
      tmp___5 = strcmp((char const   *)where, "..");
      }
#line 1566
      if (tmp___5 == 0) {
#line 1567
        where += 2;
#line 1568
        last = workpath___0;
#line 1568
        ptr = last;
        {
#line 1570
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1570
          if (! *ptr) {
#line 1570
            goto while_break___4;
          }
#line 1571
          if ((int )*ptr == 47) {
#line 1572
            last = ptr;
          }
#line 1573
          ptr ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1576
        *last = (char )'\000';
#line 1577
        goto while_continue___3;
      }
      {
#line 1581
      tmp___6 = strncmp((char const   *)where, "./", (size_t )2);
      }
#line 1581
      if (! tmp___6) {
#line 1582
        where += 2;
#line 1583
        goto while_continue___3;
      }
      {
#line 1587
      tmp___7 = strncmp((char const   *)where, "../", (size_t )3);
      }
#line 1587
      if (! tmp___7) {
#line 1588
        where += 3;
#line 1589
        last = workpath___0;
#line 1589
        ptr = last;
        {
#line 1591
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1591
          if (! *ptr) {
#line 1591
            goto while_break___5;
          }
#line 1592
          if ((int )*ptr == 47) {
#line 1593
            last = ptr;
          }
#line 1594
          ptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1597
        *last = (char )'\000';
#line 1598
        goto while_continue___3;
      }
      {
#line 1601
      ptr = strchr((char const   *)where, '/');
      }
#line 1603
      if (! ptr) {
        {
#line 1604
        tmp___8 = strlen((char const   *)where);
#line 1604
        wherelen = tmp___8;
#line 1606
        ptr = where;
        }
#line 1607
        if (wherelen >= 1U) {
#line 1608
          ptr += wherelen - 1U;
        }
      } else {
#line 1611
        *ptr = (char )'\000';
      }
      {
#line 1613
      sstrncpy(namebuf___1, (char const   *)(workpath___0), (size_t )sizeof(namebuf___1));
      }
#line 1615
      if (namebuf___1[0]) {
#line 1616
        last = namebuf___1;
        {
#line 1616
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1616
          if (! *last) {
#line 1616
            goto while_break___6;
          }
#line 1616
          last ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1617
        last --;
#line 1617
        if ((int )*last != 47) {
          {
#line 1618
          sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
          }
        }
      } else {
        {
#line 1621
        sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
        }
      }
      {
#line 1623
      sstrcat(namebuf___1, (char const   *)where, (size_t )(sizeof(namebuf___1) - 1UL));
#line 1625
      ptr ++;
#line 1625
      where = ptr;
#line 1627
      fs = lookup_dir_fs((char const   *)(namebuf___1), op);
#line 1629
      tmp___9 = cache_stat(fs, (char const   *)(namebuf___1), & sbuf___0, (unsigned int )(1 << 1));
      }
#line 1629
      if (tmp___9 == -1) {
#line 1630
        return (-1);
      }
#line 1632
      if ((sbuf___0.st_mode & 61440U) == 40960U) {
#line 1633
        linkpath[0] = (char )'\000';
#line 1633
        tmp___10 = 1U;
        {
#line 1633
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1633
          if (tmp___10 >= 4097U) {
#line 1633
            goto while_break___7;
          }
#line 1633
          linkpath[tmp___10] = (char)0;
#line 1633
          tmp___10 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1636
        if (sbuf___0.st_ino) {
#line 1636
          if (sbuf___0.st_ino == last_inode) {
#line 1636
            if (sbuf___0.st_dev) {
#line 1636
              if (sbuf___0.st_dev == last_device) {
                {
#line 1638
                tmp___11 = __errno_location();
#line 1638
                *tmp___11 = 40;
                }
#line 1639
                return (-1);
              }
            }
          }
        }
#line 1642
        last_inode = sbuf___0.st_ino;
#line 1643
        last_device = sbuf___0.st_dev;
#line 1645
        link_cnt ++;
#line 1645
        if (link_cnt > 32) {
          {
#line 1646
          tmp___12 = __errno_location();
#line 1646
          *tmp___12 = 40;
          }
#line 1647
          return (-1);
        }
        {
#line 1650
        len = pr_fsio_readlink((char const   *)(namebuf___1), linkpath, (size_t )(sizeof(linkpath) - 1UL));
        }
#line 1651
        if (len <= 0) {
          {
#line 1652
          tmp___13 = __errno_location();
#line 1652
          *tmp___13 = 2;
          }
#line 1653
          return (-1);
        }
#line 1656
        *(linkpath + len) = (char )'\000';
#line 1657
        if ((int )linkpath[0] == 47) {
#line 1658
          workpath___0[0] = (char )'\000';
        }
#line 1660
        if ((int )linkpath[0] == 126) {
#line 1661
          tmpbuf[0] = (char )'\000';
#line 1661
          tmp___14 = 1U;
          {
#line 1661
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1661
            if (tmp___14 >= 4097U) {
#line 1661
              goto while_break___8;
            }
#line 1661
            tmpbuf[tmp___14] = (char)0;
#line 1661
            tmp___14 ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 1663
          workpath___0[0] = (char )'\000';
#line 1664
          sstrncpy(tmpbuf, (char const   *)(linkpath), (size_t )sizeof(tmpbuf));
#line 1666
          tmp___15 = pr_fs_interpolate((char const   *)(tmpbuf), linkpath, (size_t )(sizeof(linkpath) - 1UL));
          }
#line 1666
          if (tmp___15 == -1) {
#line 1667
            return (-1);
          }
        }
#line 1670
        if (*where) {
          {
#line 1671
          sstrcat(linkpath, "/", (size_t )(sizeof(linkpath) - 1UL));
#line 1672
          sstrcat(linkpath, (char const   *)where, (size_t )(sizeof(linkpath) - 1UL));
          }
        }
        {
#line 1675
        sstrncpy(curpath, (char const   *)(linkpath), (size_t )sizeof(curpath));
#line 1676
        fini ++;
        }
#line 1677
        goto while_break___3;
      }
#line 1680
      if ((sbuf___0.st_mode & 61440U) == 16384U) {
        {
#line 1681
        sstrncpy(workpath___0, (char const   *)(namebuf___1), (size_t )sizeof(workpath___0));
        }
#line 1682
        goto while_continue___3;
      }
#line 1685
      if (*where) {
        {
#line 1686
        tmp___16 = __errno_location();
#line 1686
        *tmp___16 = 2;
        }
#line 1687
        return (-1);
      } else {
        {
#line 1690
        sstrncpy(workpath___0, (char const   *)(namebuf___1), (size_t )sizeof(workpath___0));
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1695
  if (! workpath___0[0]) {
    {
#line 1696
    sstrncpy(workpath___0, "/", (size_t )sizeof(workpath___0));
    }
  }
  {
#line 1698
  sstrncpy(buf___2, (char const   *)(workpath___0), buflen);
  }
#line 1700
  return (0);
}
}
#line 1703 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_resolve_path(char const   *path , char *buf___2 , size_t buflen , int op ) 
{ 
  char curpath[4097] ;
  unsigned int tmp ;
  char workpath___0[4097] ;
  unsigned int tmp___0 ;
  char namebuf___1[4097] ;
  unsigned int tmp___1 ;
  char *where ;
  char *ptr ;
  char *last ;
  pr_fs_t *fs ;
  int len ;
  int fini ;
  int link_cnt ;
  ino_t last_inode ;
  dev_t last_device ;
  struct stat sbuf___0 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t wherelen ;
  size_t tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char linkpath[4097] ;
  unsigned int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  char tmpbuf[4097] ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
#line 1704
  curpath[0] = (char )'\000';
#line 1704
  tmp = 1U;
  {
#line 1704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1704
    if (tmp >= 4097U) {
#line 1704
      goto while_break;
    }
#line 1704
    curpath[tmp] = (char)0;
#line 1704
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1704
  workpath___0[0] = (char )'\000';
#line 1704
  tmp___0 = 1U;
  {
#line 1704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1704
    if (tmp___0 >= 4097U) {
#line 1704
      goto while_break___0;
    }
#line 1704
    workpath___0[tmp___0] = (char)0;
#line 1704
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1704
  namebuf___1[0] = (char )'\000';
#line 1704
  tmp___1 = 1U;
  {
#line 1704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1704
    if (tmp___1 >= 4097U) {
#line 1704
      goto while_break___1;
    }
#line 1704
    namebuf___1[tmp___1] = (char)0;
#line 1704
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1704
  where = (char *)((void *)0);
#line 1704
  ptr = (char *)((void *)0);
#line 1704
  last = (char *)((void *)0);
#line 1709
  fs = (pr_fs_t *)((void *)0);
#line 1711
  len = 0;
#line 1711
  fini = 1;
#line 1711
  link_cnt = 0;
#line 1712
  last_inode = (ino_t )0;
#line 1713
  last_device = (dev_t )0;
#line 1716
  if (! path) {
    {
#line 1717
    tmp___2 = __errno_location();
#line 1717
    *tmp___2 = 22;
    }
#line 1718
    return (-1);
  }
  {
#line 1721
  tmp___3 = pr_fs_interpolate(path, curpath, (size_t )(sizeof(curpath) - 1UL));
  }
#line 1721
  if (tmp___3 != -1) {
    {
#line 1722
    sstrncpy(curpath, path, (size_t )sizeof(curpath));
    }
  }
#line 1724
  if ((int )curpath[0] != 47) {
    {
#line 1725
    sstrncpy(workpath___0, (char const   *)(cwd___0), (size_t )sizeof(workpath___0));
    }
  } else {
#line 1727
    workpath___0[0] = (char )'\000';
  }
  {
#line 1729
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1729
    tmp___17 = fini;
#line 1729
    fini --;
#line 1729
    if (! tmp___17) {
#line 1729
      goto while_break___2;
    }
#line 1730
    where = curpath;
    {
#line 1732
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1732
      if (! ((int )*where != 0)) {
#line 1732
        goto while_break___3;
      }
      {
#line 1733
      pr_signals_handle();
#line 1735
      tmp___4 = strcmp((char const   *)where, ".");
      }
#line 1735
      if (tmp___4 == 0) {
#line 1736
        where ++;
#line 1737
        goto while_continue___3;
      }
      {
#line 1741
      tmp___5 = strncmp((char const   *)where, "./", (size_t )2);
      }
#line 1741
      if (! tmp___5) {
#line 1742
        where += 2;
#line 1743
        goto while_continue___3;
      }
      {
#line 1747
      tmp___6 = strncmp((char const   *)where, "../", (size_t )3);
      }
#line 1747
      if (! tmp___6) {
#line 1748
        where += 3;
#line 1749
        last = workpath___0;
#line 1749
        ptr = last;
        {
#line 1750
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1750
          if (! *ptr) {
#line 1750
            goto while_break___4;
          }
#line 1751
          if ((int )*ptr == 47) {
#line 1752
            last = ptr;
          }
#line 1753
          ptr ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1756
        *last = (char )'\000';
#line 1757
        goto while_continue___3;
      }
      {
#line 1760
      ptr = strchr((char const   *)where, '/');
      }
#line 1762
      if (! ptr) {
        {
#line 1763
        tmp___7 = strlen((char const   *)where);
#line 1763
        wherelen = tmp___7;
#line 1765
        ptr = where;
        }
#line 1766
        if (wherelen >= 1U) {
#line 1767
          ptr += wherelen - 1U;
        }
      } else {
#line 1770
        *ptr = (char )'\000';
      }
      {
#line 1772
      sstrncpy(namebuf___1, (char const   *)(workpath___0), (size_t )sizeof(namebuf___1));
      }
#line 1774
      if (namebuf___1[0]) {
#line 1775
        last = namebuf___1;
        {
#line 1775
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1775
          if (! *last) {
#line 1775
            goto while_break___5;
          }
#line 1775
          last ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1777
        last --;
#line 1777
        if ((int )*last != 47) {
          {
#line 1778
          sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
          }
        }
      } else {
        {
#line 1781
        sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
        }
      }
      {
#line 1783
      sstrcat(namebuf___1, (char const   *)where, (size_t )(sizeof(namebuf___1) - 1UL));
#line 1785
      ptr ++;
#line 1785
      where = ptr;
#line 1787
      fs = lookup_dir_fs((char const   *)(namebuf___1), op);
#line 1789
      tmp___9 = cache_stat(fs, (char const   *)(namebuf___1), & sbuf___0, (unsigned int )(1 << 1));
      }
#line 1789
      if (tmp___9 == -1) {
        {
#line 1790
        tmp___8 = __errno_location();
#line 1790
        *tmp___8 = 2;
        }
#line 1791
        return (-1);
      }
#line 1794
      if ((sbuf___0.st_mode & 61440U) == 40960U) {
#line 1795
        linkpath[0] = (char )'\000';
#line 1795
        tmp___10 = 1U;
        {
#line 1795
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1795
          if (tmp___10 >= 4097U) {
#line 1795
            goto while_break___6;
          }
#line 1795
          linkpath[tmp___10] = (char)0;
#line 1795
          tmp___10 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1798
        if (sbuf___0.st_ino) {
#line 1798
          if (sbuf___0.st_ino == last_inode) {
#line 1798
            if (sbuf___0.st_dev) {
#line 1798
              if (sbuf___0.st_dev == last_device) {
                {
#line 1800
                tmp___11 = __errno_location();
#line 1800
                *tmp___11 = 40;
                }
#line 1801
                return (-1);
              }
            }
          }
        }
#line 1804
        last_inode = sbuf___0.st_ino;
#line 1805
        last_device = sbuf___0.st_dev;
#line 1807
        link_cnt ++;
#line 1807
        if (link_cnt > 32) {
          {
#line 1808
          tmp___12 = __errno_location();
#line 1808
          *tmp___12 = 40;
          }
#line 1809
          return (-1);
        }
        {
#line 1812
        len = pr_fsio_readlink((char const   *)(namebuf___1), linkpath, (size_t )(sizeof(linkpath) - 1UL));
        }
#line 1813
        if (len <= 0) {
          {
#line 1814
          tmp___13 = __errno_location();
#line 1814
          *tmp___13 = 2;
          }
#line 1815
          return (-1);
        }
#line 1818
        *(linkpath + len) = (char )'\000';
#line 1820
        if ((int )linkpath[0] == 47) {
#line 1821
          workpath___0[0] = (char )'\000';
        }
#line 1823
        if ((int )linkpath[0] == 126) {
#line 1824
          tmpbuf[0] = (char )'\000';
#line 1824
          tmp___14 = 1U;
          {
#line 1824
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1824
            if (tmp___14 >= 4097U) {
#line 1824
              goto while_break___7;
            }
#line 1824
            tmpbuf[tmp___14] = (char)0;
#line 1824
            tmp___14 ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 1825
          workpath___0[0] = (char )'\000';
#line 1827
          sstrncpy(tmpbuf, (char const   *)(linkpath), (size_t )sizeof(tmpbuf));
#line 1829
          tmp___15 = pr_fs_interpolate((char const   *)(tmpbuf), linkpath, (size_t )(sizeof(linkpath) - 1UL));
          }
#line 1829
          if (tmp___15 == -1) {
#line 1830
            return (-1);
          }
        }
#line 1833
        if (*where) {
          {
#line 1834
          sstrcat(linkpath, "/", (size_t )(sizeof(linkpath) - 1UL));
#line 1835
          sstrcat(linkpath, (char const   *)where, (size_t )(sizeof(linkpath) - 1UL));
          }
        }
        {
#line 1838
        sstrncpy(curpath, (char const   *)(linkpath), (size_t )sizeof(curpath));
#line 1839
        fini ++;
        }
#line 1840
        goto while_break___3;
      }
#line 1843
      if ((sbuf___0.st_mode & 61440U) == 16384U) {
        {
#line 1844
        sstrncpy(workpath___0, (char const   *)(namebuf___1), (size_t )sizeof(workpath___0));
        }
#line 1845
        goto while_continue___3;
      }
#line 1848
      if (*where) {
        {
#line 1849
        tmp___16 = __errno_location();
#line 1849
        *tmp___16 = 2;
        }
#line 1850
        return (-1);
      } else {
        {
#line 1853
        sstrncpy(workpath___0, (char const   *)(namebuf___1), (size_t )sizeof(workpath___0));
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1857
  if (! workpath___0[0]) {
    {
#line 1858
    sstrncpy(workpath___0, "/", (size_t )sizeof(workpath___0));
    }
  }
  {
#line 1860
  sstrncpy(buf___2, (char const   *)(workpath___0), buflen);
  }
#line 1862
  return (0);
}
}
#line 1865 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void pr_fs_clean_path(char const   *path , char *buf___2 , size_t buflen ) 
{ 
  char workpath___0[4097] ;
  unsigned int tmp ;
  char curpath[4097] ;
  unsigned int tmp___0 ;
  char namebuf___1[4097] ;
  unsigned int tmp___1 ;
  char *where ;
  char *ptr ;
  char *last ;
  int fini ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t wherelen ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 1866
  workpath___0[0] = (char )'\000';
#line 1866
  tmp = 1U;
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if (tmp >= 4097U) {
#line 1866
      goto while_break;
    }
#line 1866
    workpath___0[tmp] = (char)0;
#line 1866
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1867
  curpath[0] = (char )'\000';
#line 1867
  tmp___0 = 1U;
  {
#line 1867
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1867
    if (tmp___0 >= 4097U) {
#line 1867
      goto while_break___0;
    }
#line 1867
    curpath[tmp___0] = (char)0;
#line 1867
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1868
  namebuf___1[0] = (char )'\000';
#line 1868
  tmp___1 = 1U;
  {
#line 1868
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1868
    if (tmp___1 >= 4097U) {
#line 1868
      goto while_break___1;
    }
#line 1868
    namebuf___1[tmp___1] = (char)0;
#line 1868
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1869
  where = (char *)((void *)0);
#line 1869
  ptr = (char *)((void *)0);
#line 1869
  last = (char *)((void *)0);
#line 1870
  fini = 1;
#line 1872
  if (! path) {
#line 1873
    return;
  }
  {
#line 1875
  sstrncpy(curpath, path, (size_t )sizeof(curpath));
  }
  {
#line 1878
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1878
    tmp___7 = fini;
#line 1878
    fini --;
#line 1878
    if (! tmp___7) {
#line 1878
      goto while_break___2;
    }
#line 1879
    where = curpath;
    {
#line 1881
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1881
      if (! ((int )*where != 0)) {
#line 1881
        goto while_break___3;
      }
      {
#line 1882
      pr_signals_handle();
#line 1884
      tmp___2 = strcmp((char const   *)where, ".");
      }
#line 1884
      if (tmp___2 == 0) {
#line 1885
        where ++;
#line 1886
        goto while_continue___3;
      }
      {
#line 1890
      tmp___3 = strncmp((char const   *)where, "./", (size_t )2);
      }
#line 1890
      if (! tmp___3) {
#line 1891
        where += 2;
#line 1892
        goto while_continue___3;
      }
      {
#line 1896
      tmp___4 = strcmp((char const   *)where, "..");
      }
#line 1896
      if (tmp___4 == 0) {
#line 1897
        where += 2;
#line 1898
        last = workpath___0;
#line 1898
        ptr = last;
        {
#line 1900
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1900
          if (! *ptr) {
#line 1900
            goto while_break___4;
          }
#line 1901
          if ((int )*ptr == 47) {
#line 1902
            last = ptr;
          }
#line 1903
          ptr ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1906
        *last = (char )'\000';
#line 1907
        goto while_continue___3;
      }
      {
#line 1911
      tmp___5 = strncmp((char const   *)where, "../", (size_t )3);
      }
#line 1911
      if (! tmp___5) {
#line 1912
        where += 3;
#line 1913
        last = workpath___0;
#line 1913
        ptr = last;
        {
#line 1915
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1915
          if (! *ptr) {
#line 1915
            goto while_break___5;
          }
#line 1916
          if ((int )*ptr == 47) {
#line 1917
            last = ptr;
          }
#line 1918
          ptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1920
        *last = (char )'\000';
#line 1921
        goto while_continue___3;
      }
      {
#line 1923
      ptr = strchr((char const   *)where, '/');
      }
#line 1925
      if (! ptr) {
        {
#line 1926
        tmp___6 = strlen((char const   *)where);
#line 1926
        wherelen = tmp___6;
#line 1928
        ptr = where;
        }
#line 1929
        if (wherelen >= 1U) {
#line 1930
          ptr += wherelen - 1U;
        }
      } else {
#line 1933
        *ptr = (char )'\000';
      }
      {
#line 1935
      sstrncpy(namebuf___1, (char const   *)(workpath___0), (size_t )sizeof(namebuf___1));
      }
#line 1937
      if (namebuf___1[0]) {
#line 1938
        last = namebuf___1;
        {
#line 1938
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1938
          if (! *last) {
#line 1938
            goto while_break___6;
          }
#line 1938
          last ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1939
        last --;
#line 1939
        if ((int )*last != 47) {
          {
#line 1940
          sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
          }
        }
      } else {
        {
#line 1943
        sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
        }
      }
      {
#line 1945
      sstrcat(namebuf___1, (char const   *)where, (size_t )(sizeof(namebuf___1) - 1UL));
#line 1946
      namebuf___1[sizeof(namebuf___1) - 1UL] = (char )'\000';
#line 1948
      ptr ++;
#line 1948
      where = ptr;
#line 1950
      sstrncpy(workpath___0, (char const   *)(namebuf___1), (size_t )sizeof(workpath___0));
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1954
  if (! workpath___0[0]) {
    {
#line 1955
    sstrncpy(workpath___0, "/", (size_t )sizeof(workpath___0));
    }
  }
  {
#line 1957
  sstrncpy(buf___2, (char const   *)(workpath___0), buflen);
  }
#line 1958
  return;
}
}
#line 1960 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_use_encoding(int bool ) 
{ 
  int curr_setting ;

  {
#line 1961
  curr_setting = use_encoding;
#line 1962
  use_encoding = bool;
#line 1964
  return (curr_setting);
}
}
#line 1967 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
char *pr_fs_decode_path(pool *p , char const   *path ) 
{ 


  {
#line 1986
  return ((char *)path);
}
}
#line 1990 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
char *pr_fs_encode_path(pool *p , char const   *path ) 
{ 


  {
#line 2009
  return ((char *)path);
}
}
#line 2017 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_valid_path(char const   *path ) 
{ 
  pr_fs_t *fsi ;
  pr_fs_t **fs_objs ;
  register int i___0 ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 2019
  if (fs_map) {
#line 2019
    if (fs_map->nelts > 0) {
#line 2020
      fsi = (pr_fs_t *)((void *)0);
#line 2020
      fs_objs = (pr_fs_t **)fs_map->elts;
#line 2023
      i___0 = 0;
      {
#line 2023
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2023
        if (! (i___0 < fs_map->nelts)) {
#line 2023
          goto while_break;
        }
        {
#line 2024
        fsi = *(fs_objs + i___0);
#line 2026
        tmp = strlen((char const   *)fsi->fs_path);
#line 2026
        tmp___0 = strncmp((char const   *)fsi->fs_path, path, tmp);
        }
#line 2026
        if (tmp___0 == 0) {
#line 2027
          return (0);
        }
#line 2023
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2032
  if ((int const   )*path == 47) {
#line 2033
    return (0);
  }
  {
#line 2035
  tmp___1 = __errno_location();
#line 2035
  *tmp___1 = 22;
  }
#line 2036
  return (-1);
}
}
#line 2039 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void pr_fs_virtual_path(char const   *path , char *buf___2 , size_t buflen ) 
{ 
  char curpath[4097] ;
  unsigned int tmp ;
  char workpath___0[4097] ;
  unsigned int tmp___0 ;
  char namebuf___1[4097] ;
  unsigned int tmp___1 ;
  char *where ;
  char *ptr ;
  char *last ;
  int fini ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t wherelen ;
  size_t tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 2040
  curpath[0] = (char )'\000';
#line 2040
  tmp = 1U;
  {
#line 2040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2040
    if (tmp >= 4097U) {
#line 2040
      goto while_break;
    }
#line 2040
    curpath[tmp] = (char)0;
#line 2040
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2040
  workpath___0[0] = (char )'\000';
#line 2040
  tmp___0 = 1U;
  {
#line 2040
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2040
    if (tmp___0 >= 4097U) {
#line 2040
      goto while_break___0;
    }
#line 2040
    workpath___0[tmp___0] = (char)0;
#line 2040
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2040
  namebuf___1[0] = (char )'\000';
#line 2040
  tmp___1 = 1U;
  {
#line 2040
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2040
    if (tmp___1 >= 4097U) {
#line 2040
      goto while_break___1;
    }
#line 2040
    namebuf___1[tmp___1] = (char)0;
#line 2040
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2040
  where = (char *)((void *)0);
#line 2040
  ptr = (char *)((void *)0);
#line 2040
  last = (char *)((void *)0);
#line 2045
  fini = 1;
#line 2047
  if (! path) {
#line 2048
    return;
  }
  {
#line 2050
  tmp___2 = pr_fs_interpolate(path, curpath, (size_t )(sizeof(curpath) - 1UL));
  }
#line 2050
  if (tmp___2 != -1) {
    {
#line 2051
    sstrncpy(curpath, path, (size_t )sizeof(curpath));
    }
  }
#line 2053
  if ((int )curpath[0] != 47) {
    {
#line 2054
    sstrncpy(workpath___0, (char const   *)(vwd), (size_t )sizeof(workpath___0));
    }
  } else {
#line 2056
    workpath___0[0] = (char )'\000';
  }
  {
#line 2063
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2063
    tmp___8 = fini;
#line 2063
    fini --;
#line 2063
    if (! tmp___8) {
#line 2063
      goto while_break___2;
    }
#line 2064
    where = curpath;
    {
#line 2065
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2065
      if (! ((int )*where != 0)) {
#line 2065
        goto while_break___3;
      }
      {
#line 2066
      tmp___3 = strcmp((char const   *)where, ".");
      }
#line 2066
      if (tmp___3 == 0) {
#line 2067
        where ++;
#line 2068
        goto while_continue___3;
      }
      {
#line 2072
      tmp___4 = strncmp((char const   *)where, "./", (size_t )2);
      }
#line 2072
      if (! tmp___4) {
#line 2073
        where += 2;
#line 2074
        goto while_continue___3;
      }
      {
#line 2078
      tmp___5 = strcmp((char const   *)where, "..");
      }
#line 2078
      if (tmp___5 == 0) {
#line 2079
        where += 2;
#line 2080
        last = workpath___0;
#line 2080
        ptr = last;
        {
#line 2081
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2081
          if (! *ptr) {
#line 2081
            goto while_break___4;
          }
#line 2082
          if ((int )*ptr == 47) {
#line 2083
            last = ptr;
          }
#line 2084
          ptr ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2087
        *last = (char )'\000';
#line 2088
        goto while_continue___3;
      }
      {
#line 2092
      tmp___6 = strncmp((char const   *)where, "../", (size_t )3);
      }
#line 2092
      if (! tmp___6) {
#line 2093
        where += 3;
#line 2094
        last = workpath___0;
#line 2094
        ptr = last;
        {
#line 2095
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2095
          if (! *ptr) {
#line 2095
            goto while_break___5;
          }
#line 2096
          if ((int )*ptr == 47) {
#line 2097
            last = ptr;
          }
#line 2098
          ptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2100
        *last = (char )'\000';
#line 2101
        goto while_continue___3;
      }
      {
#line 2103
      ptr = strchr((char const   *)where, '/');
      }
#line 2105
      if (! ptr) {
        {
#line 2106
        tmp___7 = strlen((char const   *)where);
#line 2106
        wherelen = tmp___7;
#line 2108
        ptr = where;
        }
#line 2109
        if (wherelen >= 1U) {
#line 2110
          ptr += wherelen - 1U;
        }
      } else {
#line 2113
        *ptr = (char )'\000';
      }
      {
#line 2115
      sstrncpy(namebuf___1, (char const   *)(workpath___0), (size_t )sizeof(namebuf___1));
      }
#line 2117
      if (namebuf___1[0]) {
#line 2118
        last = namebuf___1;
        {
#line 2118
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2118
          if (! *last) {
#line 2118
            goto while_break___6;
          }
#line 2118
          last ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2119
        last --;
#line 2119
        if ((int )*last != 47) {
          {
#line 2120
          sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
          }
        }
      } else {
        {
#line 2123
        sstrcat(namebuf___1, "/", (size_t )(sizeof(namebuf___1) - 1UL));
        }
      }
      {
#line 2125
      sstrcat(namebuf___1, (char const   *)where, (size_t )(sizeof(namebuf___1) - 1UL));
#line 2127
      ptr ++;
#line 2127
      where = ptr;
#line 2129
      sstrncpy(workpath___0, (char const   *)(namebuf___1), (size_t )sizeof(workpath___0));
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2133
  if (! workpath___0[0]) {
    {
#line 2134
    sstrncpy(workpath___0, "/", (size_t )sizeof(workpath___0));
    }
  }
  {
#line 2136
  sstrncpy(buf___2, (char const   *)(workpath___0), buflen);
  }
#line 2137
  return;
}
}
#line 2139 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chdir_canon(char const   *path , int hidesymlink ) 
{ 
  char resbuf[4097] ;
  unsigned int tmp ;
  pr_fs_t *fs ;
  int res ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2140
  resbuf[0] = (char )'\000';
#line 2140
  tmp = 1U;
  {
#line 2140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2140
    if (tmp >= 4097U) {
#line 2140
      goto while_break;
    }
#line 2140
    resbuf[tmp] = (char)0;
#line 2140
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2141
  fs = (pr_fs_t *)((void *)0);
#line 2142
  res = 0;
#line 2144
  tmp___0 = pr_fs_resolve_partial(path, resbuf, (size_t )(sizeof(resbuf) - 1UL), 1 << 17);
  }
#line 2144
  if (tmp___0 == -1) {
#line 2146
    return (-1);
  }
  {
#line 2148
  fs = lookup_dir_fs((char const   *)(resbuf), 1 << 17);
  }
  {
#line 2153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2153
    if (fs) {
#line 2153
      if (fs->fs_next) {
#line 2153
        if (! (! fs->chdir)) {
#line 2153
          goto while_break___0;
        }
      } else {
#line 2153
        goto while_break___0;
      }
    } else {
#line 2153
      goto while_break___0;
    }
#line 2154
    fs = fs->fs_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2156
  pr_trace_msg(trace_channel___2, 8, "using %s chdir() for path \'%s\'", fs->fs_name,
               path);
#line 2158
  res = (*(fs->chdir))(fs, (char const   *)(resbuf));
  }
#line 2160
  if (res != -1) {
#line 2162
    if (fs) {
#line 2162
      fs_cwd = fs;
    } else {
#line 2162
      fs_cwd = root_fs;
    }
#line 2164
    if (hidesymlink) {
      {
#line 2165
      pr_fs_virtual_path(path, vwd, (size_t )(sizeof(vwd) - 1UL));
      }
    } else {
      {
#line 2167
      sstrncpy(vwd, (char const   *)(resbuf), (size_t )sizeof(vwd));
      }
    }
  }
#line 2170
  return (res);
}
}
#line 2173 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chdir(char const   *path , int hidesymlink ) 
{ 
  char resbuf[4097] ;
  unsigned int tmp ;
  pr_fs_t *fs ;
  int res ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2174
  resbuf[0] = (char )'\000';
#line 2174
  tmp = 1U;
  {
#line 2174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2174
    if (tmp >= 4097U) {
#line 2174
      goto while_break;
    }
#line 2174
    resbuf[tmp] = (char)0;
#line 2174
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2175
  fs = (pr_fs_t *)((void *)0);
#line 2178
  pr_fs_clean_path(path, resbuf, (size_t )(sizeof(resbuf) - 1UL));
#line 2180
  fs = lookup_dir_fs(path, 1 << 17);
  }
  {
#line 2185
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2185
    if (fs) {
#line 2185
      if (fs->fs_next) {
#line 2185
        if (! (! fs->chdir)) {
#line 2185
          goto while_break___0;
        }
      } else {
#line 2185
        goto while_break___0;
      }
    } else {
#line 2185
      goto while_break___0;
    }
#line 2186
    fs = fs->fs_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2188
  pr_trace_msg(trace_channel___2, 8, "using %s chdir() for path \'%s\'", fs->fs_name,
               path);
#line 2190
  res = (*(fs->chdir))(fs, (char const   *)(resbuf));
  }
#line 2192
  if (res != -1) {
#line 2194
    fs_cwd = fs;
#line 2196
    if (hidesymlink) {
      {
#line 2197
      pr_fs_virtual_path(path, vwd, (size_t )(sizeof(vwd) - 1UL));
      }
    } else {
      {
#line 2199
      sstrncpy(vwd, (char const   *)(resbuf), (size_t )sizeof(vwd));
      }
    }
  }
#line 2202
  return (res);
}
}
#line 2209 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void *pr_fsio_opendir(char const   *path ) 
{ 
  pr_fs_t *fs ;
  fsopendir_t *fsod ;
  fsopendir_t *fsodi ;
  pool *fsod_pool ;
  DIR *res ;
  char buf___2[4097] ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 2210
  fs = (pr_fs_t *)((void *)0);
#line 2211
  fsod = (fsopendir_t *)((void *)0);
#line 2211
  fsodi = (fsopendir_t *)((void *)0);
#line 2212
  fsod_pool = (pool *)((void *)0);
#line 2213
  res = (DIR *)((void *)0);
#line 2215
  tmp___1 = strchr(path, '/');
  }
#line 2215
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 2216
    fs = fs_cwd;
  } else {
#line 2219
    buf___2[0] = (char )'\000';
#line 2219
    tmp = 1U;
    {
#line 2219
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2219
      if (tmp >= 4097U) {
#line 2219
        goto while_break;
      }
#line 2219
      buf___2[tmp] = (char)0;
#line 2219
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2221
    tmp___0 = pr_fs_resolve_partial(path, buf___2, (size_t )(sizeof(buf___2) - 1UL),
                                    1 << 18);
    }
#line 2221
    if (tmp___0 == -1) {
#line 2222
      return ((void *)0);
    }
    {
#line 2224
    fs = lookup_dir_fs((char const   *)(buf___2), 1 << 18);
    }
  }
  {
#line 2230
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2230
    if (fs) {
#line 2230
      if (fs->fs_next) {
#line 2230
        if (! (! fs->opendir)) {
#line 2230
          goto while_break___0;
        }
      } else {
#line 2230
        goto while_break___0;
      }
    } else {
#line 2230
      goto while_break___0;
    }
#line 2231
    fs = fs->fs_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2233
  pr_trace_msg(trace_channel___2, 8, "using %s opendir() for path \'%s\'", fs->fs_name,
               path);
#line 2235
  tmp___2 = (*(fs->opendir))(fs, path);
#line 2235
  res = (DIR *)tmp___2;
  }
#line 2237
  if (! res) {
#line 2238
    return ((void *)0);
  }
  {
#line 2241
  fs_cache_dir = (void *)res;
#line 2242
  fs_cache_fsdir = fs;
#line 2244
  fsod_pool = make_sub_pool(permanent_pool);
#line 2245
  pr_pool_tag(fsod_pool, "fsod subpool");
#line 2247
  tmp___3 = pcalloc(fsod_pool, (int )sizeof(fsopendir_t ));
#line 2247
  fsod = (fsopendir_t *)tmp___3;
  }
#line 2249
  if (! fsod) {
#line 2251
    if (fs->closedir) {
      {
#line 2252
      (*(fs->closedir))(fs, (void *)res);
#line 2253
      tmp___4 = __errno_location();
#line 2253
      *tmp___4 = 12;
      }
#line 2254
      return ((void *)0);
    } else {
      {
#line 2257
      sys_closedir(fs, (void *)res);
#line 2258
      tmp___5 = __errno_location();
#line 2258
      *tmp___5 = 12;
      }
#line 2259
      return ((void *)0);
    }
  }
#line 2263
  fsod->pool = fsod_pool;
#line 2264
  fsod->dir = res;
#line 2265
  fsod->fsdir = fs;
#line 2266
  fsod->next = (fsopendir_t *)((void *)0);
#line 2267
  fsod->prev = (fsopendir_t *)((void *)0);
#line 2269
  if (fsopendir_list) {
#line 2272
    fsodi = fsopendir_list;
    {
#line 2273
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2273
      if (! fsodi->next) {
#line 2273
        goto while_break___1;
      }
#line 2274
      fsodi = fsodi->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2276
    fsod->next = (fsopendir_t *)((void *)0);
#line 2277
    fsod->prev = fsodi;
#line 2278
    fsodi->next = fsod;
  } else {
#line 2283
    fsopendir_list = fsod;
  }
#line 2285
  return ((void *)res);
}
}
#line 2288 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static pr_fs_t *find_opendir(void *dir , int closing ) 
{ 
  pr_fs_t *fs ;
  fsopendir_t *fsod ;

  {
#line 2289
  fs = (pr_fs_t *)((void *)0);
#line 2291
  if (fsopendir_list) {
#line 2294
    fsod = fsopendir_list;
    {
#line 2294
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2294
      if (! fsod) {
#line 2294
        goto while_break;
      }
#line 2295
      if (fsod->dir) {
#line 2295
        if ((unsigned long )fsod->dir == (unsigned long )dir) {
#line 2296
          fs = fsod->fsdir;
#line 2297
          goto while_break;
        }
      }
#line 2294
      fsod = fsod->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2301
    if (closing) {
#line 2301
      if (fsod) {
#line 2302
        if (fsod->prev) {
#line 2303
          (fsod->prev)->next = fsod->next;
        }
#line 2305
        if (fsod->next) {
#line 2306
          (fsod->next)->prev = fsod->prev;
        }
#line 2308
        if ((unsigned long )fsod == (unsigned long )fsopendir_list) {
#line 2309
          fsopendir_list = fsod->next;
        }
        {
#line 2311
        destroy_pool(fsod->pool);
        }
      }
    }
  }
#line 2315
  if ((unsigned long )dir == (unsigned long )fs_cache_dir) {
#line 2316
    fs = fs_cache_fsdir;
#line 2318
    if (closing) {
#line 2319
      fs_cache_dir = (void *)0;
#line 2320
      fs_cache_fsdir = (pr_fs_t *)((void *)0);
    }
  }
#line 2324
  return (fs);
}
}
#line 2327 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_closedir(void *dir ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 2329
  tmp = find_opendir(dir, 1);
#line 2329
  fs = tmp;
  }
#line 2331
  if (! fs) {
#line 2332
    return (-1);
  }
  {
#line 2337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2337
    if (fs) {
#line 2337
      if (fs->fs_next) {
#line 2337
        if (! (! fs->closedir)) {
#line 2337
          goto while_break;
        }
      } else {
#line 2337
        goto while_break;
      }
    } else {
#line 2337
      goto while_break;
    }
#line 2338
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2340
  pr_trace_msg(trace_channel___2, 8, "using %s closedir()", fs->fs_name);
#line 2341
  res = (*(fs->closedir))(fs, dir);
  }
#line 2343
  return (res);
}
}
#line 2346 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
struct dirent *pr_fsio_readdir(void *dir ) 
{ 
  struct dirent *res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 2348
  tmp = find_opendir(dir, 0);
#line 2348
  fs = tmp;
  }
#line 2350
  if (! fs) {
#line 2351
    return ((struct dirent *)((void *)0));
  }
  {
#line 2356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2356
    if (fs) {
#line 2356
      if (fs->fs_next) {
#line 2356
        if (! (! fs->readdir)) {
#line 2356
          goto while_break;
        }
      } else {
#line 2356
        goto while_break;
      }
    } else {
#line 2356
      goto while_break;
    }
#line 2357
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2359
  pr_trace_msg(trace_channel___2, 8, "using %s readdir()", fs->fs_name);
#line 2360
  res = (*(fs->readdir))(fs, dir);
  }
#line 2362
  return (res);
}
}
#line 2365 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_mkdir(char const   *path , mode_t mode ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 2367
  tmp = lookup_dir_fs(path, 1 << 21);
#line 2367
  fs = tmp;
  }
  {
#line 2372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2372
    if (fs) {
#line 2372
      if (fs->fs_next) {
#line 2372
        if (! (! fs->mkdir)) {
#line 2372
          goto while_break;
        }
      } else {
#line 2372
        goto while_break;
      }
    } else {
#line 2372
      goto while_break;
    }
#line 2373
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2375
  pr_trace_msg(trace_channel___2, 8, "using %s mkdir() for path \'%s\'", fs->fs_name,
               path);
#line 2377
  res = (*(fs->mkdir))(fs, path, mode);
  }
#line 2379
  return (res);
}
}
#line 2382 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_rmdir(char const   *path ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 2384
  tmp = lookup_dir_fs(path, 1 << 22);
#line 2384
  fs = tmp;
  }
  {
#line 2389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2389
    if (fs) {
#line 2389
      if (fs->fs_next) {
#line 2389
        if (! (! fs->rmdir)) {
#line 2389
          goto while_break;
        }
      } else {
#line 2389
        goto while_break;
      }
    } else {
#line 2389
      goto while_break;
    }
#line 2390
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2392
  pr_trace_msg(trace_channel___2, 8, "using %s rmdir() for path \'%s\'", fs->fs_name,
               path);
#line 2394
  res = (*(fs->rmdir))(fs, path);
  }
#line 2396
  return (res);
}
}
#line 2399 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_stat_canon(char const   *path , struct stat *sbuf___0 ) 
{ 
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char const   *tmp___0 ;
  pr_fs_t *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2400
  tmp = lookup_file_canon_fs(path, (char **)((void *)0), 1);
#line 2400
  fs = tmp;
  }
  {
#line 2405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2405
    if (fs) {
#line 2405
      if (fs->fs_next) {
#line 2405
        if (! (! fs->stat)) {
#line 2405
          goto while_break;
        }
      } else {
#line 2405
        goto while_break;
      }
    } else {
#line 2405
      goto while_break;
    }
#line 2406
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2408
  if (fs) {
#line 2408
    tmp___0 = (char const   *)fs->fs_name;
  } else {
#line 2408
    tmp___0 = "system";
  }
  {
#line 2408
  pr_trace_msg(trace_channel___2, 8, "using %s stat() for path \'%s\'", tmp___0, path);
  }
#line 2410
  if (fs) {
#line 2410
    tmp___1 = fs;
  } else {
#line 2410
    tmp___1 = root_fs;
  }
  {
#line 2410
  tmp___2 = cache_stat(tmp___1, path, sbuf___0, 1U);
  }
#line 2410
  return (tmp___2);
}
}
#line 2413 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_stat(char const   *path , struct stat *sbuf___0 ) 
{ 
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  pr_fs_t *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 2414
  tmp = lookup_file_fs(path, (char **)((void *)0), 1);
#line 2414
  fs = tmp;
  }
  {
#line 2419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2419
    if (fs) {
#line 2419
      if (fs->fs_next) {
#line 2419
        if (! (! fs->stat)) {
#line 2419
          goto while_break;
        }
      } else {
#line 2419
        goto while_break;
      }
    } else {
#line 2419
      goto while_break;
    }
#line 2420
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2422
  pr_trace_msg(trace_channel___2, 8, "using %s stat() for path \'%s\'", fs->fs_name,
               path);
  }
#line 2424
  if (fs) {
#line 2424
    tmp___0 = fs;
  } else {
#line 2424
    tmp___0 = root_fs;
  }
  {
#line 2424
  tmp___1 = cache_stat(tmp___0, path, sbuf___0, 1U);
  }
#line 2424
  return (tmp___1);
}
}
#line 2427 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_fstat(pr_fh_t *fh , struct stat *sbuf___0 ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp6 ;

  {
#line 2431
  if (! fh) {
    {
#line 2432
    tmp = __errno_location();
#line 2432
    *tmp = 22;
    }
#line 2433
    return (-1);
  }
#line 2439
  fs = fh->fh_fs;
  {
#line 2440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2440
    if (fs) {
#line 2440
      if (fs->fs_next) {
#line 2440
        if (! (! fs->fstat)) {
#line 2440
          goto while_break;
        }
      } else {
#line 2440
        goto while_break;
      }
    } else {
#line 2440
      goto while_break;
    }
#line 2441
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2443
  pr_trace_msg(trace_channel___2, 8, "using %s fstat() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 2445
  res = (*(fs->fstat))(fh, fh->fh_fd, sbuf___0);
  }
#line 2447
  return (res);
}
}
#line 2450 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_lstat_canon(char const   *path , struct stat *sbuf___0 ) 
{ 
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char const   *tmp___0 ;
  pr_fs_t *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2451
  tmp = lookup_file_canon_fs(path, (char **)((void *)0), 1 << 1);
#line 2451
  fs = tmp;
  }
  {
#line 2456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2456
    if (fs) {
#line 2456
      if (fs->fs_next) {
#line 2456
        if (! (! fs->lstat)) {
#line 2456
          goto while_break;
        }
      } else {
#line 2456
        goto while_break;
      }
    } else {
#line 2456
      goto while_break;
    }
#line 2457
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2459
  if (fs) {
#line 2459
    tmp___0 = (char const   *)fs->fs_name;
  } else {
#line 2459
    tmp___0 = "system";
  }
  {
#line 2459
  pr_trace_msg(trace_channel___2, 8, "using %s lstat() for path \'%s\'", tmp___0,
               path);
  }
#line 2461
  if (fs) {
#line 2461
    tmp___1 = fs;
  } else {
#line 2461
    tmp___1 = root_fs;
  }
  {
#line 2461
  tmp___2 = cache_stat(tmp___1, path, sbuf___0, (unsigned int )(1 << 1));
  }
#line 2461
  return (tmp___2);
}
}
#line 2464 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_lstat(char const   *path , struct stat *sbuf___0 ) 
{ 
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  pr_fs_t *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 2465
  tmp = lookup_file_fs(path, (char **)((void *)0), 1 << 1);
#line 2465
  fs = tmp;
  }
  {
#line 2470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2470
    if (fs) {
#line 2470
      if (fs->fs_next) {
#line 2470
        if (! (! fs->lstat)) {
#line 2470
          goto while_break;
        }
      } else {
#line 2470
        goto while_break;
      }
    } else {
#line 2470
      goto while_break;
    }
#line 2471
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2473
  pr_trace_msg(trace_channel___2, 8, "using %s lstat() for path \'%s\'", fs->fs_name,
               path);
  }
#line 2475
  if (fs) {
#line 2475
    tmp___0 = fs;
  } else {
#line 2475
    tmp___0 = root_fs;
  }
  {
#line 2475
  tmp___1 = cache_stat(tmp___0, path, sbuf___0, (unsigned int )(1 << 1));
  }
#line 2475
  return (tmp___1);
}
}
#line 2478 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_readlink_canon(char const   *path , char *buf___2 , size_t buflen ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 2480
  tmp = lookup_file_canon_fs(path, (char **)((void *)0), 1 << 11);
#line 2480
  fs = tmp;
  }
  {
#line 2485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2485
    if (fs) {
#line 2485
      if (fs->fs_next) {
#line 2485
        if (! (! fs->readlink)) {
#line 2485
          goto while_break;
        }
      } else {
#line 2485
        goto while_break;
      }
    } else {
#line 2485
      goto while_break;
    }
#line 2486
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2488
  pr_trace_msg(trace_channel___2, 8, "using %s readlink() for path \'%s\'", fs->fs_name,
               path);
#line 2490
  res = (*(fs->readlink))(fs, path, buf___2, buflen);
  }
#line 2492
  return (res);
}
}
#line 2495 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_readlink(char const   *path , char *buf___2 , size_t buflen ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 2497
  tmp = lookup_file_fs(path, (char **)((void *)0), 1 << 11);
#line 2497
  fs = tmp;
  }
  {
#line 2502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2502
    if (fs) {
#line 2502
      if (fs->fs_next) {
#line 2502
        if (! (! fs->readlink)) {
#line 2502
          goto while_break;
        }
      } else {
#line 2502
        goto while_break;
      }
    } else {
#line 2502
      goto while_break;
    }
#line 2503
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2505
  pr_trace_msg(trace_channel___2, 8, "using %s readlink() for path \'%s\'", fs->fs_name,
               path);
#line 2507
  res = (*(fs->readlink))(fs, path, buf___2, buflen);
  }
#line 2509
  return (res);
}
}
#line 2515 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fs_glob(char const   *pattern , int flags , int (*errfunc)(char const   * ,
                                                                  int  ) , glob_t *pglob ) 
{ 
  int tmp ;

  {
#line 2518
  if (pglob) {
#line 2519
    flags |= 1 << 9;
#line 2521
    pglob->gl_closedir = (void (*)(void * ))(& pr_fsio_closedir);
#line 2522
    pglob->gl_readdir = & pr_fsio_readdir;
#line 2523
    pglob->gl_opendir = & pr_fsio_opendir;
#line 2524
    pglob->gl_lstat = & pr_fsio_lstat;
#line 2525
    pglob->gl_stat = & pr_fsio_stat;
  }
  {
#line 2528
  tmp = glob(pattern, flags, errfunc, pglob);
  }
#line 2528
  return (tmp);
}
}
#line 2531 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void pr_fs_globfree(glob_t *pglob ) 
{ 


  {
  {
#line 2532
  globfree(pglob);
  }
#line 2533
  return;
}
}
#line 2535 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_rename_canon(char const   *rfrom , char const   *rto ) 
{ 
  int res ;
  pr_fs_t *from_fs ;
  pr_fs_t *to_fs ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 2539
  from_fs = lookup_file_canon_fs(rfrom, (char **)((void *)0), 1 << 2);
#line 2540
  to_fs = lookup_file_canon_fs(rto, (char **)((void *)0), 1 << 2);
  }
#line 2542
  if (from_fs->allow_xdev_rename == 0) {
#line 2542
    goto _L;
  } else
#line 2542
  if (to_fs->allow_xdev_rename == 0) {
    _L: /* CIL Label */ 
#line 2544
    if ((unsigned long )from_fs != (unsigned long )to_fs) {
      {
#line 2545
      tmp = __errno_location();
#line 2545
      *tmp = 18;
      }
#line 2546
      return (-1);
    }
  }
#line 2550
  fs = to_fs;
  {
#line 2555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2555
    if (fs) {
#line 2555
      if (fs->fs_next) {
#line 2555
        if (! (! fs->rename)) {
#line 2555
          goto while_break;
        }
      } else {
#line 2555
        goto while_break;
      }
    } else {
#line 2555
      goto while_break;
    }
#line 2556
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2558
  pr_trace_msg(trace_channel___2, 8, "using %s rename() for paths \'%s\', \'%s\'",
               fs->fs_name, rfrom, rto);
#line 2560
  res = (*(fs->rename))(fs, rfrom, rto);
  }
#line 2562
  return (res);
}
}
#line 2565 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_rename(char const   *rnfm , char const   *rnto ) 
{ 
  int res ;
  pr_fs_t *from_fs ;
  pr_fs_t *to_fs ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 2569
  from_fs = lookup_file_fs(rnfm, (char **)((void *)0), 1 << 2);
#line 2570
  to_fs = lookup_file_fs(rnto, (char **)((void *)0), 1 << 2);
  }
#line 2572
  if (from_fs->allow_xdev_rename == 0) {
#line 2572
    goto _L;
  } else
#line 2572
  if (to_fs->allow_xdev_rename == 0) {
    _L: /* CIL Label */ 
#line 2574
    if ((unsigned long )from_fs != (unsigned long )to_fs) {
      {
#line 2575
      tmp = __errno_location();
#line 2575
      *tmp = 18;
      }
#line 2576
      return (-1);
    }
  }
#line 2580
  fs = to_fs;
  {
#line 2585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2585
    if (fs) {
#line 2585
      if (fs->fs_next) {
#line 2585
        if (! (! fs->rename)) {
#line 2585
          goto while_break;
        }
      } else {
#line 2585
        goto while_break;
      }
    } else {
#line 2585
      goto while_break;
    }
#line 2586
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2588
  pr_trace_msg(trace_channel___2, 8, "using %s rename() for paths \'%s\', \'%s\'",
               fs->fs_name, rnfm, rnto);
#line 2590
  res = (*(fs->rename))(fs, rnfm, rnto);
  }
#line 2592
  return (res);
}
}
#line 2595 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_unlink_canon(char const   *name ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 2597
  tmp = lookup_file_canon_fs(name, (char **)((void *)0), 1 << 3);
#line 2597
  fs = tmp;
  }
  {
#line 2602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2602
    if (fs) {
#line 2602
      if (fs->fs_next) {
#line 2602
        if (! (! fs->unlink)) {
#line 2602
          goto while_break;
        }
      } else {
#line 2602
        goto while_break;
      }
    } else {
#line 2602
      goto while_break;
    }
#line 2603
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2605
  pr_trace_msg(trace_channel___2, 8, "using %s unlink() for path \'%s\'", fs->fs_name,
               name);
#line 2607
  res = (*(fs->unlink))(fs, name);
  }
#line 2609
  return (res);
}
}
#line 2612 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_unlink(char const   *name ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 2614
  tmp = lookup_file_fs(name, (char **)((void *)0), 1 << 3);
#line 2614
  fs = tmp;
  }
  {
#line 2619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2619
    if (fs) {
#line 2619
      if (fs->fs_next) {
#line 2619
        if (! (! fs->unlink)) {
#line 2619
          goto while_break;
        }
      } else {
#line 2619
        goto while_break;
      }
    } else {
#line 2619
      goto while_break;
    }
#line 2620
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2622
  pr_trace_msg(trace_channel___2, 8, "using %s unlink() for path \'%s\'", fs->fs_name,
               name);
#line 2624
  res = (*(fs->unlink))(fs, name);
  }
#line 2626
  return (res);
}
}
#line 2629 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fh_t *pr_fsio_open_canon(char const   *name , int flags ) 
{ 
  char *deref ;
  pool *tmp_pool ;
  pr_fh_t *fh ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2630
  deref = (char *)((void *)0);
#line 2631
  tmp_pool = (pool *)((void *)0);
#line 2632
  fh = (pr_fh_t *)((void *)0);
#line 2634
  tmp = lookup_file_canon_fs(name, & deref, 1 << 4);
#line 2634
  fs = tmp;
#line 2637
  tmp_pool = make_sub_pool(fs->fs_pool);
#line 2638
  pr_pool_tag(tmp_pool, "pr_fsio_open_canon() subpool");
#line 2640
  tmp___0 = pcalloc(tmp_pool, (int )sizeof(pr_fh_t ));
#line 2640
  fh = (pr_fh_t *)tmp___0;
#line 2641
  fh->fh_pool = tmp_pool;
#line 2642
  fh->fh_path = pstrdup(fh->fh_pool, name);
#line 2643
  fh->fh_fd = -1;
#line 2644
  fh->fh_buf = (pr_buffer_t *)((void *)0);
#line 2645
  fh->fh_fs = fs;
  }
  {
#line 2650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2650
    if (fs) {
#line 2650
      if (fs->fs_next) {
#line 2650
        if (! (! fs->open)) {
#line 2650
          goto while_break;
        }
      } else {
#line 2650
        goto while_break;
      }
    } else {
#line 2650
      goto while_break;
    }
#line 2651
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2653
  pr_trace_msg(trace_channel___2, 8, "using %s open() for path \'%s\'", fs->fs_name,
               name);
#line 2655
  fh->fh_fd = (*(fs->open))(fh, (char const   *)deref, flags);
  }
#line 2657
  if (fh->fh_fd == -1) {
    {
#line 2658
    destroy_pool(fh->fh_pool);
    }
#line 2659
    return ((pr_fh_t *)((void *)0));
  }
#line 2662
  return (fh);
}
}
#line 2665 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fh_t *pr_fsio_open(char const   *name , int flags ) 
{ 
  pool *tmp_pool ;
  pr_fh_t *fh ;
  pr_fs_t *fs ;
  int *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2666
  tmp_pool = (pool *)((void *)0);
#line 2667
  fh = (pr_fh_t *)((void *)0);
#line 2668
  fs = (pr_fs_t *)((void *)0);
#line 2670
  if (! name) {
    {
#line 2671
    tmp = __errno_location();
#line 2671
    *tmp = 22;
    }
#line 2672
    return ((pr_fh_t *)((void *)0));
  }
  {
#line 2675
  fs = lookup_file_fs(name, (char **)((void *)0), 1 << 4);
#line 2678
  tmp_pool = make_sub_pool(fs->fs_pool);
#line 2679
  pr_pool_tag(tmp_pool, "pr_fsio_open() subpool");
#line 2681
  tmp___0 = pcalloc(tmp_pool, (int )sizeof(pr_fh_t ));
#line 2681
  fh = (pr_fh_t *)tmp___0;
#line 2682
  fh->fh_pool = tmp_pool;
#line 2683
  fh->fh_path = pstrdup(fh->fh_pool, name);
#line 2684
  fh->fh_fd = -1;
#line 2685
  fh->fh_buf = (pr_buffer_t *)((void *)0);
#line 2686
  fh->fh_fs = fs;
  }
  {
#line 2691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2691
    if (fs) {
#line 2691
      if (fs->fs_next) {
#line 2691
        if (! (! fs->open)) {
#line 2691
          goto while_break;
        }
      } else {
#line 2691
        goto while_break;
      }
    } else {
#line 2691
      goto while_break;
    }
#line 2692
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2694
  pr_trace_msg(trace_channel___2, 8, "using %s open() for path \'%s\'", fs->fs_name,
               name);
#line 2696
  fh->fh_fd = (*(fs->open))(fh, name, flags);
  }
#line 2698
  if (fh->fh_fd == -1) {
    {
#line 2699
    destroy_pool(fh->fh_pool);
    }
#line 2700
    return ((pr_fh_t *)((void *)0));
  }
#line 2703
  return (fh);
}
}
#line 2706 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fh_t *pr_fsio_creat_canon(char const   *name , mode_t mode ) 
{ 
  char *deref ;
  pool *tmp_pool ;
  pr_fh_t *fh ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2707
  deref = (char *)((void *)0);
#line 2708
  tmp_pool = (pool *)((void *)0);
#line 2709
  fh = (pr_fh_t *)((void *)0);
#line 2710
  tmp = lookup_file_canon_fs(name, & deref, 1 << 5);
#line 2710
  fs = tmp;
#line 2713
  tmp_pool = make_sub_pool(fs->fs_pool);
#line 2714
  pr_pool_tag(tmp_pool, "pr_fsio_creat_canon() subpool");
#line 2716
  tmp___0 = pcalloc(tmp_pool, (int )sizeof(pr_fh_t ));
#line 2716
  fh = (pr_fh_t *)tmp___0;
#line 2717
  fh->fh_pool = tmp_pool;
#line 2718
  fh->fh_path = pstrdup(fh->fh_pool, name);
#line 2719
  fh->fh_fd = -1;
#line 2720
  fh->fh_buf = (pr_buffer_t *)((void *)0);
#line 2721
  fh->fh_fs = fs;
  }
  {
#line 2726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2726
    if (fs) {
#line 2726
      if (fs->fs_next) {
#line 2726
        if (! (! fs->creat)) {
#line 2726
          goto while_break;
        }
      } else {
#line 2726
        goto while_break;
      }
    } else {
#line 2726
      goto while_break;
    }
#line 2727
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2729
  pr_trace_msg(trace_channel___2, 8, "using %s creat() for path \'%s\'", fs->fs_name,
               name);
#line 2731
  fh->fh_fd = (*(fs->creat))(fh, (char const   *)deref, mode);
  }
#line 2733
  if (fh->fh_fd == -1) {
    {
#line 2734
    destroy_pool(fh->fh_pool);
    }
#line 2735
    return ((pr_fh_t *)((void *)0));
  }
#line 2738
  return (fh);
}
}
#line 2741 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
pr_fh_t *pr_fsio_creat(char const   *name , mode_t mode ) 
{ 
  pool *tmp_pool ;
  pr_fh_t *fh ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2742
  tmp_pool = (pool *)((void *)0);
#line 2743
  fh = (pr_fh_t *)((void *)0);
#line 2744
  tmp = lookup_file_fs(name, (char **)((void *)0), 1 << 5);
#line 2744
  fs = tmp;
#line 2747
  tmp_pool = make_sub_pool(fs->fs_pool);
#line 2748
  pr_pool_tag(tmp_pool, "pr_fsio_creat() subpool");
#line 2750
  tmp___0 = pcalloc(tmp_pool, (int )sizeof(pr_fh_t ));
#line 2750
  fh = (pr_fh_t *)tmp___0;
#line 2751
  fh->fh_pool = tmp_pool;
#line 2752
  fh->fh_path = pstrdup(fh->fh_pool, name);
#line 2753
  fh->fh_fd = -1;
#line 2754
  fh->fh_buf = (pr_buffer_t *)((void *)0);
#line 2755
  fh->fh_fs = fs;
  }
  {
#line 2760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2760
    if (fs) {
#line 2760
      if (fs->fs_next) {
#line 2760
        if (! (! fs->creat)) {
#line 2760
          goto while_break;
        }
      } else {
#line 2760
        goto while_break;
      }
    } else {
#line 2760
      goto while_break;
    }
#line 2761
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2763
  pr_trace_msg(trace_channel___2, 8, "using %s creat() for path \'%s\'", fs->fs_name,
               name);
#line 2765
  fh->fh_fd = (*(fs->creat))(fh, name, mode);
  }
#line 2767
  if (fh->fh_fd == -1) {
    {
#line 2768
    destroy_pool(fh->fh_pool);
    }
#line 2769
    return ((pr_fh_t *)((void *)0));
  }
#line 2772
  return (fh);
}
}
#line 2775 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_close(pr_fh_t *fh ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp5 ;

  {
#line 2776
  res = 0;
#line 2779
  if (! fh) {
    {
#line 2780
    tmp = __errno_location();
#line 2780
    *tmp = 22;
    }
#line 2781
    return (-1);
  }
#line 2787
  fs = fh->fh_fs;
  {
#line 2788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2788
    if (fs) {
#line 2788
      if (fs->fs_next) {
#line 2788
        if (! (! fs->close)) {
#line 2788
          goto while_break;
        }
      } else {
#line 2788
        goto while_break;
      }
    } else {
#line 2788
      goto while_break;
    }
#line 2789
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2791
  pr_trace_msg(trace_channel___2, 8, "using %s close() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 2793
  res = (*(fs->close))(fh, fh->fh_fd);
#line 2795
  destroy_pool(fh->fh_pool);
  }
#line 2796
  return (res);
}
}
#line 2799 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_read(pr_fh_t *fh , char *buf___2 , size_t size ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
#line 2803
  if (! fh) {
    {
#line 2804
    tmp = __errno_location();
#line 2804
    *tmp = 22;
    }
#line 2805
    return (-1);
  }
#line 2811
  fs = fh->fh_fs;
  {
#line 2812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2812
    if (fs) {
#line 2812
      if (fs->fs_next) {
#line 2812
        if (! (! fs->read)) {
#line 2812
          goto while_break;
        }
      } else {
#line 2812
        goto while_break;
      }
    } else {
#line 2812
      goto while_break;
    }
#line 2813
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2815
  pr_trace_msg(trace_channel___2, 8, "using %s read() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 2817
  res = (*(fs->read))(fh, fh->fh_fd, buf___2, size);
  }
#line 2819
  return (res);
}
}
#line 2822 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_write(pr_fh_t *fh , char const   *buf___2 , size_t size ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
#line 2826
  if (! fh) {
    {
#line 2827
    tmp = __errno_location();
#line 2827
    *tmp = 22;
    }
#line 2828
    return (-1);
  }
#line 2834
  fs = fh->fh_fs;
  {
#line 2835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2835
    if (fs) {
#line 2835
      if (fs->fs_next) {
#line 2835
        if (! (! fs->write)) {
#line 2835
          goto while_break;
        }
      } else {
#line 2835
        goto while_break;
      }
    } else {
#line 2835
      goto while_break;
    }
#line 2836
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2838
  pr_trace_msg(trace_channel___2, 8, "using %s write() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 2840
  res = (*(fs->write))(fh, fh->fh_fd, buf___2, size);
  }
#line 2842
  return (res);
}
}
#line 2845 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
off_t___0 pr_fsio_lseek(pr_fh_t *fh , off_t___0 offset , int whence ) 
{ 
  off_t___0 res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
#line 2849
  if (! fh) {
    {
#line 2850
    tmp = __errno_location();
#line 2850
    *tmp = 22;
    }
#line 2851
    return ((off_t___0 )-1);
  }
#line 2857
  fs = fh->fh_fs;
  {
#line 2858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2858
    if (fs) {
#line 2858
      if (fs->fs_next) {
#line 2858
        if (! (! fs->lseek)) {
#line 2858
          goto while_break;
        }
      } else {
#line 2858
        goto while_break;
      }
    } else {
#line 2858
      goto while_break;
    }
#line 2859
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2861
  pr_trace_msg(trace_channel___2, 8, "using %s lseek() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 2863
  res = (*(fs->lseek))(fh, fh->fh_fd, offset, whence);
  }
#line 2865
  return (res);
}
}
#line 2868 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_link_canon(char const   *lfrom , char const   *lto ) 
{ 
  int res ;
  pr_fs_t *from_fs ;
  pr_fs_t *to_fs ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 2872
  from_fs = lookup_file_fs(lfrom, (char **)((void *)0), 1 << 9);
#line 2873
  to_fs = lookup_file_fs(lto, (char **)((void *)0), 1 << 9);
  }
#line 2875
  if (from_fs->allow_xdev_link == 0) {
#line 2875
    goto _L;
  } else
#line 2875
  if (to_fs->allow_xdev_link == 0) {
    _L: /* CIL Label */ 
#line 2877
    if ((unsigned long )from_fs != (unsigned long )to_fs) {
      {
#line 2878
      tmp = __errno_location();
#line 2878
      *tmp = 18;
      }
#line 2879
      return (-1);
    }
  }
#line 2883
  fs = to_fs;
  {
#line 2888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2888
    if (fs) {
#line 2888
      if (fs->fs_next) {
#line 2888
        if (! (! fs->link)) {
#line 2888
          goto while_break;
        }
      } else {
#line 2888
        goto while_break;
      }
    } else {
#line 2888
      goto while_break;
    }
#line 2889
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2891
  pr_trace_msg(trace_channel___2, 8, "using %s link() for paths \'%s\', \'%s\'", fs->fs_name,
               lfrom, lto);
#line 2893
  res = (*(fs->link))(fs, lfrom, lto);
  }
#line 2895
  return (res);
}
}
#line 2898 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_link(char const   *lfrom , char const   *lto ) 
{ 
  int res ;
  pr_fs_t *from_fs ;
  pr_fs_t *to_fs ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 2903
  from_fs = lookup_file_fs(lfrom, (char **)((void *)0), 1 << 9);
#line 2904
  to_fs = lookup_file_fs(lto, (char **)((void *)0), 1 << 9);
  }
#line 2906
  if (from_fs->allow_xdev_link == 0) {
#line 2906
    goto _L;
  } else
#line 2906
  if (to_fs->allow_xdev_link == 0) {
    _L: /* CIL Label */ 
#line 2908
    if ((unsigned long )from_fs != (unsigned long )to_fs) {
      {
#line 2909
      tmp = __errno_location();
#line 2909
      *tmp = 18;
      }
#line 2910
      return (-1);
    }
  }
#line 2914
  fs = to_fs;
  {
#line 2919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2919
    if (fs) {
#line 2919
      if (fs->fs_next) {
#line 2919
        if (! (! fs->link)) {
#line 2919
          goto while_break;
        }
      } else {
#line 2919
        goto while_break;
      }
    } else {
#line 2919
      goto while_break;
    }
#line 2920
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2922
  pr_trace_msg(trace_channel___2, 8, "using %s link() for paths \'%s\', \'%s\'", fs->fs_name,
               lfrom, lto);
#line 2924
  res = (*(fs->link))(fs, lfrom, lto);
  }
#line 2926
  return (res);
}
}
#line 2929 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_symlink_canon(char const   *lfrom , char const   *lto ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 2931
  tmp = lookup_file_canon_fs(lto, (char **)((void *)0), 1 << 10);
#line 2931
  fs = tmp;
  }
  {
#line 2936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2936
    if (fs) {
#line 2936
      if (fs->fs_next) {
#line 2936
        if (! (! fs->symlink)) {
#line 2936
          goto while_break;
        }
      } else {
#line 2936
        goto while_break;
      }
    } else {
#line 2936
      goto while_break;
    }
#line 2937
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2939
  pr_trace_msg(trace_channel___2, 8, "using %s symlink() for path \'%s\'", fs->fs_name,
               lto);
#line 2941
  res = (*(fs->symlink))(fs, lfrom, lto);
  }
#line 2943
  return (res);
}
}
#line 2946 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_symlink(char const   *lfrom , char const   *lto ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 2948
  tmp = lookup_file_fs(lto, (char **)((void *)0), 1 << 10);
#line 2948
  fs = tmp;
  }
  {
#line 2953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2953
    if (fs) {
#line 2953
      if (fs->fs_next) {
#line 2953
        if (! (! fs->symlink)) {
#line 2953
          goto while_break;
        }
      } else {
#line 2953
        goto while_break;
      }
    } else {
#line 2953
      goto while_break;
    }
#line 2954
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2956
  pr_trace_msg(trace_channel___2, 8, "using %s symlink() for path \'%s\'", fs->fs_name,
               lto);
#line 2958
  res = (*(fs->symlink))(fs, lfrom, lto);
  }
#line 2960
  return (res);
}
}
#line 2963 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_ftruncate(pr_fh_t *fh , off_t___0 len ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp6 ;

  {
#line 2967
  if (! fh) {
    {
#line 2968
    tmp = __errno_location();
#line 2968
    *tmp = 22;
    }
#line 2969
    return (-1);
  }
#line 2975
  fs = fh->fh_fs;
  {
#line 2976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2976
    if (fs) {
#line 2976
      if (fs->fs_next) {
#line 2976
        if (! (! fs->ftruncate)) {
#line 2976
          goto while_break;
        }
      } else {
#line 2976
        goto while_break;
      }
    } else {
#line 2976
      goto while_break;
    }
#line 2977
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2979
  pr_trace_msg(trace_channel___2, 8, "using %s ftruncate() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 2981
  res = (*(fs->ftruncate))(fh, fh->fh_fd, len);
  }
#line 2983
  return (res);
}
}
#line 2986 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_truncate_canon(char const   *path , off_t___0 len ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 2988
  tmp = lookup_file_canon_fs(path, (char **)((void *)0), 1 << 12);
#line 2988
  fs = tmp;
  }
  {
#line 2993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2993
    if (fs) {
#line 2993
      if (fs->fs_next) {
#line 2993
        if (! (! fs->truncate)) {
#line 2993
          goto while_break;
        }
      } else {
#line 2993
        goto while_break;
      }
    } else {
#line 2993
      goto while_break;
    }
#line 2994
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2996
  pr_trace_msg(trace_channel___2, 8, "using %s truncate() for path \'%s\'", fs->fs_name,
               path);
#line 2998
  res = (*(fs->truncate))(fs, path, len);
  }
#line 3000
  return (res);
}
}
#line 3003 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_truncate(char const   *path , off_t___0 len ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 3005
  tmp = lookup_file_fs(path, (char **)((void *)0), 1 << 12);
#line 3005
  fs = tmp;
  }
  {
#line 3010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3010
    if (fs) {
#line 3010
      if (fs->fs_next) {
#line 3010
        if (! (! fs->truncate)) {
#line 3010
          goto while_break;
        }
      } else {
#line 3010
        goto while_break;
      }
    } else {
#line 3010
      goto while_break;
    }
#line 3011
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3013
  pr_trace_msg(trace_channel___2, 8, "using %s truncate() for path \'%s\'", fs->fs_name,
               path);
#line 3015
  res = (*(fs->truncate))(fs, path, len);
  }
#line 3017
  return (res);
}
}
#line 3020 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chmod_canon(char const   *name , mode_t mode ) 
{ 
  int res ;
  char *deref ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 3022
  deref = (char *)((void *)0);
#line 3023
  tmp = lookup_file_canon_fs(name, & deref, 1 << 13);
#line 3023
  fs = tmp;
  }
  {
#line 3028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3028
    if (fs) {
#line 3028
      if (fs->fs_next) {
#line 3028
        if (! (! fs->chmod)) {
#line 3028
          goto while_break;
        }
      } else {
#line 3028
        goto while_break;
      }
    } else {
#line 3028
      goto while_break;
    }
#line 3029
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3031
  pr_trace_msg(trace_channel___2, 8, "using %s chmod() for path \'%s\'", fs->fs_name,
               name);
#line 3033
  res = (*(fs->chmod))(fs, (char const   *)deref, mode);
  }
#line 3035
  if (res == 0) {
    {
#line 3036
    pr_fs_clear_cache();
    }
  }
#line 3038
  return (res);
}
}
#line 3041 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chmod(char const   *name , mode_t mode ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 3043
  tmp = lookup_file_fs(name, (char **)((void *)0), 1 << 13);
#line 3043
  fs = tmp;
  }
  {
#line 3048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3048
    if (fs) {
#line 3048
      if (fs->fs_next) {
#line 3048
        if (! (! fs->chmod)) {
#line 3048
          goto while_break;
        }
      } else {
#line 3048
        goto while_break;
      }
    } else {
#line 3048
      goto while_break;
    }
#line 3049
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3051
  pr_trace_msg(trace_channel___2, 8, "using %s chmod() for path \'%s\'", fs->fs_name,
               name);
#line 3053
  res = (*(fs->chmod))(fs, name, mode);
  }
#line 3055
  if (res == 0) {
    {
#line 3056
    pr_fs_clear_cache();
    }
  }
#line 3058
  return (res);
}
}
#line 3061 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_fchmod(pr_fh_t *fh , mode_t mode ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp6 ;

  {
#line 3065
  if (! fh) {
    {
#line 3066
    tmp = __errno_location();
#line 3066
    *tmp = 22;
    }
#line 3067
    return (-1);
  }
#line 3073
  fs = fh->fh_fs;
  {
#line 3074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3074
    if (fs) {
#line 3074
      if (fs->fs_next) {
#line 3074
        if (! (! fs->fchmod)) {
#line 3074
          goto while_break;
        }
      } else {
#line 3074
        goto while_break;
      }
    } else {
#line 3074
      goto while_break;
    }
#line 3075
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3077
  pr_trace_msg(trace_channel___2, 8, "using %s fchmod() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 3079
  res = (*(fs->fchmod))(fh, fh->fh_fd, mode);
  }
#line 3081
  if (res == 0) {
    {
#line 3082
    pr_fs_clear_cache();
    }
  }
#line 3084
  return (res);
}
}
#line 3087 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chown_canon(char const   *name , uid_t uid , gid_t gid ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 3089
  tmp = lookup_file_canon_fs(name, (char **)((void *)0), 1 << 14);
#line 3089
  fs = tmp;
  }
  {
#line 3094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3094
    if (fs) {
#line 3094
      if (fs->fs_next) {
#line 3094
        if (! (! fs->chown)) {
#line 3094
          goto while_break;
        }
      } else {
#line 3094
        goto while_break;
      }
    } else {
#line 3094
      goto while_break;
    }
#line 3095
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3097
  pr_trace_msg(trace_channel___2, 8, "using %s chown() for path \'%s\'", fs->fs_name,
               name);
#line 3099
  res = (*(fs->chown))(fs, name, uid, gid);
  }
#line 3101
  if (res == 0) {
    {
#line 3102
    pr_fs_clear_cache();
    }
  }
#line 3104
  return (res);
}
}
#line 3107 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chown(char const   *name , uid_t uid , gid_t gid ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 3109
  tmp = lookup_file_fs(name, (char **)((void *)0), 1 << 14);
#line 3109
  fs = tmp;
  }
  {
#line 3114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3114
    if (fs) {
#line 3114
      if (fs->fs_next) {
#line 3114
        if (! (! fs->chown)) {
#line 3114
          goto while_break;
        }
      } else {
#line 3114
        goto while_break;
      }
    } else {
#line 3114
      goto while_break;
    }
#line 3115
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3117
  pr_trace_msg(trace_channel___2, 8, "using %s chown() for path \'%s\'", fs->fs_name,
               name);
#line 3119
  res = (*(fs->chown))(fs, name, uid, gid);
  }
#line 3121
  if (res == 0) {
    {
#line 3122
    pr_fs_clear_cache();
    }
  }
#line 3124
  return (res);
}
}
#line 3127 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_fchown(pr_fh_t *fh , uid_t uid , gid_t gid ) 
{ 
  int res ;
  pr_fs_t *fs ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
#line 3131
  if (! fh) {
    {
#line 3132
    tmp = __errno_location();
#line 3132
    *tmp = 22;
    }
#line 3133
    return (-1);
  }
#line 3139
  fs = fh->fh_fs;
  {
#line 3140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3140
    if (fs) {
#line 3140
      if (fs->fs_next) {
#line 3140
        if (! (! fs->fchown)) {
#line 3140
          goto while_break;
        }
      } else {
#line 3140
        goto while_break;
      }
    } else {
#line 3140
      goto while_break;
    }
#line 3141
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3143
  pr_trace_msg(trace_channel___2, 8, "using %s fchown() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 3145
  res = (*(fs->fchown))(fh, fh->fh_fd, uid, gid);
  }
#line 3147
  if (res == 0) {
    {
#line 3148
    pr_fs_clear_cache();
    }
  }
#line 3150
  return (res);
}
}
#line 3153 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_access(char const   *path , int mode , uid_t uid , gid_t gid , array_header *suppl_gids ) 
{ 
  pr_fs_t *fs ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 3157
  if (! path) {
    {
#line 3158
    tmp = __errno_location();
#line 3158
    *tmp = 22;
    }
#line 3159
    return (-1);
  }
  {
#line 3162
  fs = lookup_file_fs(path, (char **)((void *)0), 1 << 15);
  }
  {
#line 3167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3167
    if (fs) {
#line 3167
      if (fs->fs_next) {
#line 3167
        if (! (! fs->access)) {
#line 3167
          goto while_break;
        }
      } else {
#line 3167
        goto while_break;
      }
    } else {
#line 3167
      goto while_break;
    }
#line 3168
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3170
  pr_trace_msg(trace_channel___2, 8, "using %s access() for path \'%s\'", fs->fs_name,
               path);
#line 3172
  tmp___0 = (*(fs->access))(fs, path, mode, uid, gid, suppl_gids);
  }
#line 3172
  return (tmp___0);
}
}
#line 3175 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_faccess(pr_fh_t *fh , int mode , uid_t uid , gid_t gid , array_header *suppl_gids ) 
{ 
  pr_fs_t *fs ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 3179
  if (! fh) {
    {
#line 3180
    tmp = __errno_location();
#line 3180
    *tmp = 22;
    }
#line 3181
    return (-1);
  }
#line 3187
  fs = fh->fh_fs;
  {
#line 3188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3188
    if (fs) {
#line 3188
      if (fs->fs_next) {
#line 3188
        if (! (! fs->faccess)) {
#line 3188
          goto while_break;
        }
      } else {
#line 3188
        goto while_break;
      }
    } else {
#line 3188
      goto while_break;
    }
#line 3189
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3191
  pr_trace_msg(trace_channel___2, 8, "using %s faccess() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 3193
  tmp___0 = (*((fh->fh_fs)->faccess))(fh, mode, uid, gid, suppl_gids);
  }
#line 3193
  return (tmp___0);
}
}
#line 3196 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_utimes(char const   *path , struct timeval *tvs ) 
{ 
  pr_fs_t *fs ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 3199
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 3201
    tmp = __errno_location();
#line 3201
    *tmp = 22;
    }
#line 3202
    return (-1);
  } else
#line 3199
  if ((unsigned long )tvs == (unsigned long )((void *)0)) {
    {
#line 3201
    tmp = __errno_location();
#line 3201
    *tmp = 22;
    }
#line 3202
    return (-1);
  }
  {
#line 3205
  fs = lookup_file_fs(path, (char **)((void *)0), 1 << 23);
  }
  {
#line 3210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3210
    if (fs) {
#line 3210
      if (fs->fs_next) {
#line 3210
        if (! (! fs->utimes)) {
#line 3210
          goto while_break;
        }
      } else {
#line 3210
        goto while_break;
      }
    } else {
#line 3210
      goto while_break;
    }
#line 3211
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3213
  pr_trace_msg(trace_channel___2, 8, "using %s utimes() for path \'%s\'", fs->fs_name,
               path);
#line 3215
  tmp___0 = (*(fs->utimes))(fs, path, tvs);
  }
#line 3215
  return (tmp___0);
}
}
#line 3218 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_futimes(pr_fh_t *fh , struct timeval *tvs ) 
{ 
  pr_fs_t *fs ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 3221
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
    {
#line 3223
    tmp = __errno_location();
#line 3223
    *tmp = 22;
    }
#line 3224
    return (-1);
  } else
#line 3221
  if ((unsigned long )tvs == (unsigned long )((void *)0)) {
    {
#line 3223
    tmp = __errno_location();
#line 3223
    *tmp = 22;
    }
#line 3224
    return (-1);
  }
#line 3230
  fs = fh->fh_fs;
  {
#line 3231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3231
    if (fs) {
#line 3231
      if (fs->fs_next) {
#line 3231
        if (! (! fs->futimes)) {
#line 3231
          goto while_break;
        }
      } else {
#line 3231
        goto while_break;
      }
    } else {
#line 3231
      goto while_break;
    }
#line 3232
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3234
  pr_trace_msg(trace_channel___2, 8, "using %s futimes() for path \'%s\'", fs->fs_name,
               fh->fh_path);
#line 3236
  tmp___0 = (*((fh->fh_fs)->futimes))(fh, fh->fh_fd, tvs);
  }
#line 3236
  return (tmp___0);
}
}
#line 3243 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_chroot(char const   *path ) 
{ 
  int res ;
  pr_fs_t *fs ;
  pr_fs_t *tmp ;
  unsigned int iter_start ;
  register unsigned int i___0 ;
  pool *map_pool ;
  pool *tmp___0 ;
  array_header *new_map ;
  array_header *tmp___1 ;
  pr_fs_t **fs_objs ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  pr_fs_t *tmpfs ;
  pr_fs_t *next ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 3244
  res = 0;
#line 3245
  tmp = lookup_dir_fs(path, 1 << 16);
#line 3245
  fs = tmp;
  }
  {
#line 3250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3250
    if (fs) {
#line 3250
      if (fs->fs_next) {
#line 3250
        if (! (! fs->chroot)) {
#line 3250
          goto while_break;
        }
      } else {
#line 3250
        goto while_break;
      }
    } else {
#line 3250
      goto while_break;
    }
#line 3251
    fs = fs->fs_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3253
  pr_trace_msg(trace_channel___2, 8, "using %s chroot() for path \'%s\'", fs->fs_name,
               path);
#line 3255
  res = (*(fs->chroot))(fs, path);
  }
#line 3256
  if (res == 0) {
    {
#line 3257
    iter_start = 0U;
#line 3261
    i___0 = 0U;
#line 3262
    tmp___0 = make_sub_pool(permanent_pool);
#line 3262
    map_pool = tmp___0;
#line 3263
    tmp___1 = make_array(map_pool, 0U, (size_t )sizeof(pr_fs_t *));
#line 3263
    new_map = tmp___1;
#line 3264
    fs_objs = (pr_fs_t **)((void *)0);
#line 3266
    pr_pool_tag(map_pool, "FSIO Map Pool");
    }
#line 3268
    if (fs_map) {
#line 3269
      fs_objs = (pr_fs_t **)fs_map->elts;
    }
#line 3271
    if ((unsigned long )fs != (unsigned long )root_fs) {
      {
#line 3272
      tmp___5 = strlen(path);
#line 3272
      tmp___6 = strncmp((char const   *)fs->fs_path, path, tmp___5);
      }
#line 3272
      if (tmp___6 == 0) {
        {
#line 3273
        tmp___2 = strlen((char const   *)fs->fs_path);
#line 3273
        tmp___3 = strlen(path);
#line 3273
        tmp___4 = strlen(path);
#line 3273
        memmove((void *)fs->fs_path, (void const   *)(fs->fs_path + tmp___4), (tmp___2 - tmp___3) + 1U);
        }
      }
      {
#line 3277
      tmp___7 = push_array(new_map);
#line 3277
      *((pr_fs_t **)tmp___7) = fs;
#line 3278
      iter_start = 1U;
      }
    }
#line 3281
    i___0 = iter_start;
    {
#line 3281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3281
      if (fs_map) {
#line 3281
        tmp___17 = fs_map->nelts;
      } else {
#line 3281
        tmp___17 = 0;
      }
#line 3281
      if (! (i___0 < (unsigned int )tmp___17)) {
#line 3281
        goto while_break___0;
      }
      {
#line 3282
      tmpfs = *(fs_objs + i___0);
#line 3291
      tmp___14 = strlen(path);
#line 3291
      tmp___15 = strncmp((char const   *)tmpfs->fs_path, path, tmp___14);
      }
#line 3291
      if (tmp___15 == 0) {
        {
#line 3294
        tmp___8 = strlen((char const   *)tmpfs->fs_path);
#line 3294
        tmp___9 = strlen(path);
#line 3294
        tmp___10 = strlen(path);
#line 3294
        memmove((void *)tmpfs->fs_path, (void const   *)(tmpfs->fs_path + tmp___10),
                (tmp___8 - tmp___9) + 1U);
#line 3298
        next = tmpfs->fs_next;
        }
        {
#line 3299
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3299
          if (! next) {
#line 3299
            goto while_break___1;
          }
          {
#line 3300
          pr_signals_handle();
#line 3302
          tmp___11 = strlen((char const   *)next->fs_path);
#line 3302
          tmp___12 = strlen(path);
#line 3302
          tmp___13 = strlen(path);
#line 3302
          memmove((void *)next->fs_path, (void const   *)(next->fs_path + tmp___13),
                  (tmp___11 - tmp___12) + 1U);
#line 3305
          next = next->fs_next;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 3310
      tmp___16 = push_array(new_map);
#line 3310
      *((pr_fs_t **)tmp___16) = tmpfs;
#line 3281
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3314
    qsort(new_map->elts, (size_t )new_map->nelts, (size_t )sizeof(pr_fs_t *), & fs_cmp);
    }
#line 3317
    if (fs_map) {
      {
#line 3318
      destroy_pool(fs_map->pool);
      }
    }
#line 3320
    fs_map = new_map;
#line 3321
    chk_fs_map = (unsigned char)1;
  }
#line 3324
  return (res);
}
}
#line 3327 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
char *pr_fsio_gets(char *buf___2 , size_t size , pr_fh_t *fh ) 
{ 
  char *bp ;
  int toread ;
  pr_buffer_t *pbuf ;
  int *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 3328
  bp = (char *)((void *)0);
#line 3329
  toread = 0;
#line 3330
  pbuf = (pr_buffer_t *)((void *)0);
#line 3332
  if (! buf___2) {
    {
#line 3333
    tmp = __errno_location();
#line 3333
    *tmp = 22;
    }
#line 3334
    return ((char *)((void *)0));
  } else
#line 3332
  if (! fh) {
    {
#line 3333
    tmp = __errno_location();
#line 3333
    *tmp = 22;
    }
#line 3334
    return ((char *)((void *)0));
  } else
#line 3332
  if (size <= 0U) {
    {
#line 3333
    tmp = __errno_location();
#line 3333
    *tmp = 22;
    }
#line 3334
    return ((char *)((void *)0));
  }
#line 3337
  if (! fh->fh_buf) {
    {
#line 3338
    tmp___0 = pcalloc(fh->fh_pool, (int )sizeof(pr_buffer_t ));
#line 3338
    fh->fh_buf = (pr_buffer_t *)tmp___0;
#line 3339
    tmp___2 = pcalloc(fh->fh_pool, 1024);
#line 3339
    tmp___1 = (char *)tmp___2;
#line 3339
    (fh->fh_buf)->current = tmp___1;
#line 3339
    (fh->fh_buf)->buf = tmp___1;
#line 3341
    tmp___3 = 1024UL;
#line 3341
    (fh->fh_buf)->buflen = tmp___3;
#line 3341
    (fh->fh_buf)->remaining = (int )tmp___3;
    }
  }
#line 3344
  pbuf = fh->fh_buf;
#line 3345
  bp = buf___2;
  {
#line 3347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3347
    if (! size) {
#line 3347
      goto while_break;
    }
    {
#line 3348
    pr_signals_handle();
    }
#line 3350
    if (! pbuf->current) {
#line 3350
      goto _L;
    } else
#line 3350
    if ((unsigned long )pbuf->remaining == pbuf->buflen) {
      _L: /* CIL Label */ 
#line 3353
      if ((unsigned long )size < pbuf->buflen) {
#line 3353
        tmp___4 = (unsigned long )size;
      } else {
#line 3353
        tmp___4 = pbuf->buflen;
      }
      {
#line 3353
      toread = pr_fsio_read(fh, pbuf->buf, (size_t )tmp___4);
      }
#line 3356
      if (toread <= 0) {
#line 3357
        if ((unsigned long )bp != (unsigned long )buf___2) {
#line 3358
          *bp = (char )'\000';
#line 3359
          return (buf___2);
        } else {
#line 3362
          return ((char *)((void *)0));
        }
      }
#line 3365
      pbuf->remaining = (int )(pbuf->buflen - (unsigned long )toread);
#line 3366
      pbuf->current = pbuf->buf;
    } else {
#line 3369
      toread = (int )(pbuf->buflen - (unsigned long )pbuf->remaining);
    }
    {
#line 3371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3371
      if (size) {
#line 3371
        if (toread > 0) {
#line 3371
          if ((int )*(pbuf->current) != 10) {
#line 3371
            tmp___7 = toread;
#line 3371
            toread --;
#line 3371
            if (! tmp___7) {
#line 3371
              goto while_break___0;
            }
          } else {
#line 3371
            goto while_break___0;
          }
        } else {
#line 3371
          goto while_break___0;
        }
      } else {
#line 3371
        goto while_break___0;
      }
      {
#line 3375
      pr_signals_handle();
#line 3377
      tmp___5 = bp;
#line 3377
      bp ++;
#line 3377
      tmp___6 = pbuf->current;
#line 3377
      (pbuf->current) ++;
#line 3377
      *tmp___5 = *tmp___6;
#line 3378
      size --;
#line 3379
      (pbuf->remaining) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3382
    if (size) {
#line 3382
      if (toread) {
#line 3382
        if ((int )*(pbuf->current) == 10) {
#line 3385
          size --;
#line 3386
          toread --;
#line 3387
          tmp___8 = bp;
#line 3387
          bp ++;
#line 3387
          tmp___9 = pbuf->current;
#line 3387
          (pbuf->current) ++;
#line 3387
          *tmp___8 = *tmp___9;
#line 3388
          (pbuf->remaining) ++;
#line 3389
          goto while_break;
        }
      }
    }
#line 3392
    if (! toread) {
#line 3393
      pbuf->current = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3396
  *bp = (char )'\000';
#line 3397
  return (buf___2);
}
}
#line 3406 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
char *pr_fsio_getline(char *buf___2 , int buflen , pr_fh_t *fh , unsigned int *lineno ) 
{ 
  int inlen ;
  char *start ;
  size_t tmp ;
  char *bufp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 3409
  start = buf___2;
  {
#line 3411
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3411
    tmp___1 = pr_fsio_gets(buf___2, (size_t )buflen, fh);
    }
#line 3411
    if (! tmp___1) {
#line 3411
      goto while_break;
    }
    {
#line 3412
    pr_signals_handle();
#line 3414
    tmp = strlen((char const   *)buf___2);
#line 3414
    inlen = (int )tmp;
    }
#line 3416
    if (inlen >= 1) {
#line 3417
      if ((int )*(buf___2 + (inlen - 1)) == 10) {
#line 3418
        (*lineno) ++;
#line 3420
        if (inlen >= 2) {
#line 3420
          if ((int )*(buf___2 + (inlen - 2)) == 92) {
#line 3423
            inlen -= 2;
#line 3429
            bufp = buf___2;
            {
#line 3429
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 3429
              if (*bufp) {
                {
#line 3429
                tmp___0 = __ctype_b_loc();
                }
#line 3429
                if (! ((int const   )*(*tmp___0 + (int )*bufp) & 8192)) {
#line 3429
                  goto while_break___0;
                }
              } else {
#line 3429
                goto while_break___0;
              }
#line 3429
              bufp ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 3431
            if ((int )*bufp == 35) {
#line 3432
              goto while_continue;
            }
          } else {
#line 3435
            return (start);
          }
        } else {
#line 3435
          return (start);
        }
      }
    }
#line 3440
    if (buflen - inlen == 0) {
#line 3441
      return (buf___2);
    }
#line 3443
    buf___2 += inlen;
#line 3444
    buflen -= inlen;
#line 3445
    *(buf___2 + 0) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 3448
  if ((unsigned long )buf___2 > (unsigned long )start) {
#line 3448
    tmp___2 = start;
  } else {
#line 3448
    tmp___2 = (char *)0;
  }
#line 3448
  return (tmp___2);
}
}
#line 3456 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
static off_t___0 calc_fs_size(size_t blocks , size_t bsize ) 
{ 
  off_t___0 bl_lo ;
  off_t___0 bl_hi ;
  off_t___0 res_lo ;
  off_t___0 res_hi ;
  off_t___0 tmp ;

  {
#line 3460
  bl_lo = (off_t___0 )(blocks & 65535U);
#line 3461
  bl_hi = (off_t___0 )(blocks & 4294901760U);
#line 3463
  tmp = (bl_hi >> 16) * (off_t___0 )bsize;
#line 3464
  res_hi = tmp & 4294901760LL;
#line 3465
  res_lo = (tmp & 65535LL) << 16;
#line 3466
  res_lo += bl_lo * (off_t___0 )bsize;
#line 3468
  if (res_hi & 4227858432LL) {
#line 3470
    return ((off_t___0 )0);
  }
#line 3472
  return ((res_lo >> 10) | (res_hi << 6));
}
}
#line 3475 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
off_t___0 pr_fs_getsize(char *path ) 
{ 
  struct statvfs fs ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  off_t___0 tmp___2 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 3493
  tmp___1 = statvfs((char const   */* __restrict  */)path, (struct statvfs */* __restrict  */)(& fs));
  }
#line 3493
  if (tmp___1 != 0) {
    {
#line 3494
    tmp = __errno_location();
#line 3494
    tmp___0 = strerror(*tmp);
#line 3494
    pr_trace_msg(trace_channel___2, 3, "statvfs() error using \'%s\': %s", path, tmp___0);
    }
#line 3496
    return ((off_t___0 )0);
  }
  {
#line 3499
  tmp___2 = calc_fs_size((size_t )fs.f_bavail, (size_t )fs.f_frsize);
  }
#line 3499
  return (tmp___2);
}
}
#line 3525 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int pr_fsio_puts(char const   *buf___2 , pr_fh_t *fh ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 3526
  if (! fh) {
    {
#line 3527
    tmp = __errno_location();
#line 3527
    *tmp = 22;
    }
#line 3528
    return (-1);
  }
  {
#line 3531
  tmp___0 = strlen(buf___2);
#line 3531
  tmp___1 = pr_fsio_write(fh, buf___2, tmp___0);
  }
#line 3531
  return (tmp___1);
}
}
#line 3534 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
void pr_resolve_fs_map(void) 
{ 
  register unsigned int i___0 ;
  char *newpath ;
  unsigned char add_slash ;
  pr_fs_t *tmpfs ;
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 3535
  i___0 = 0U;
#line 3537
  if (! fs_map) {
#line 3538
    return;
  }
#line 3540
  i___0 = 0U;
  {
#line 3540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3540
    if (! (i___0 < (unsigned int )fs_map->nelts)) {
#line 3540
      goto while_break;
    }
#line 3541
    newpath = (char *)((void *)0);
#line 3542
    add_slash = (unsigned char)0;
#line 3543
    tmpfs = *((pr_fs_t **)fs_map->elts + i___0);
#line 3546
    if ((unsigned long )tmpfs == (unsigned long )root_fs) {
#line 3547
      goto __Cont;
    }
    {
#line 3556
    tmp = strcmp((char const   *)tmpfs->fs_path, "/");
    }
#line 3556
    if (tmp != 0) {
      {
#line 3556
      tmp___0 = strlen((char const   *)tmpfs->fs_path);
      }
#line 3556
      if ((int )*(tmpfs->fs_path + (tmp___0 - 1U)) == 47) {
#line 3558
        add_slash = (unsigned char)1;
      }
    }
    {
#line 3560
    newpath = dir_realpath(tmpfs->fs_pool, (char const   *)tmpfs->fs_path);
    }
#line 3562
    if (add_slash) {
      {
#line 3563
      newpath = pstrcat(tmpfs->fs_pool, newpath, "/", (void *)0);
      }
    }
#line 3571
    tmpfs->fs_path = newpath;
    __Cont: /* CIL Label */ 
#line 3540
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3575
  qsort(fs_map->elts, (size_t )fs_map->nelts, (size_t )sizeof(pr_fs_t *), & fs_cmp);
  }
#line 3577
  return;
}
}
#line 3580 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/fsio.c"
int init_fs(void) 
{ 
  char cwdbuf[4097] ;
  unsigned int tmp ;
  char *tmp___0 ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3581
  cwdbuf[0] = (char )'\000';
#line 3581
  tmp = 1U;
  {
#line 3581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3581
    if (tmp >= 4097U) {
#line 3581
      goto while_break;
    }
#line 3581
    cwdbuf[tmp] = (char)0;
#line 3581
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3584
  root_fs = pr_create_fs(permanent_pool, "system");
  }
#line 3585
  if ((unsigned long )root_fs == (unsigned long )((void *)0)) {
    {
#line 3590
    pr_log_pri(3, "error: unable to initialize default fs");
#line 3591
    exit(1);
    }
  }
  {
#line 3594
  root_fs->fs_path = pstrdup(root_fs->fs_pool, "/");
#line 3597
  root_fs->stat = & sys_stat;
#line 3598
  root_fs->fstat = & sys_fstat;
#line 3599
  root_fs->lstat = & sys_lstat;
#line 3600
  root_fs->rename = & sys_rename;
#line 3601
  root_fs->unlink = & sys_unlink;
#line 3602
  root_fs->open = & sys_open;
#line 3603
  root_fs->creat = & sys_creat;
#line 3604
  root_fs->close = & sys_close;
#line 3605
  root_fs->read = & sys_read;
#line 3606
  root_fs->write = & sys_write;
#line 3607
  root_fs->lseek = & sys_lseek;
#line 3608
  root_fs->link = & sys_link;
#line 3609
  root_fs->readlink = & sys_readlink;
#line 3610
  root_fs->symlink = & sys_symlink;
#line 3611
  root_fs->ftruncate = & sys_ftruncate;
#line 3612
  root_fs->truncate = & sys_truncate;
#line 3613
  root_fs->chmod = & sys_chmod;
#line 3614
  root_fs->fchmod = & sys_fchmod;
#line 3615
  root_fs->chown = & sys_chown;
#line 3616
  root_fs->fchown = & sys_fchown;
#line 3617
  root_fs->access = & sys_access;
#line 3618
  root_fs->faccess = & sys_faccess;
#line 3619
  root_fs->utimes = & sys_utimes;
#line 3620
  root_fs->futimes = & sys_futimes;
#line 3622
  root_fs->chdir = & sys_chdir;
#line 3623
  root_fs->chroot = & sys_chroot;
#line 3624
  root_fs->opendir = & sys_opendir;
#line 3625
  root_fs->closedir = & sys_closedir;
#line 3626
  root_fs->readdir = & sys_readdir;
#line 3627
  root_fs->mkdir = & sys_mkdir;
#line 3628
  root_fs->rmdir = & sys_rmdir;
#line 3630
  tmp___0 = getcwd(cwdbuf, (size_t )(sizeof(cwdbuf) - 1UL));
  }
#line 3630
  if (tmp___0) {
    {
#line 3631
    cwdbuf[sizeof(cwdbuf) - 1UL] = (char )'\000';
#line 3632
    pr_fs_setcwd((char const   *)(cwdbuf));
    }
  } else {
    {
#line 3635
    pr_fsio_chdir("/", 0);
#line 3636
    pr_fs_setcwd("/");
    }
  }
#line 3639
  return (0);
}
}
#line 600 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 215 "../include/table.h"
int pr_table_ctl(pr_table_t *tab , int cmd , void *arg ) ;
#line 234
int pr_table_kadd(pr_table_t *tab , void const   *key_data , size_t key_datasz , void *value_data ,
                  size_t value_datasz ) ;
#line 241
int pr_table_kexists(pr_table_t *tab , void const   *key_data , size_t key_datasz ) ;
#line 247
void *pr_table_kget(pr_table_t *tab , void const   *key_data , size_t key_datasz ,
                    size_t *value_datasz ) ;
#line 232 "../include/dirtree.h"
void find_config_set_top(config_rec *c ) ;
#line 182 "../include/modules.h"
void *pr_stash_get_symbol(pr_stash_type_t sym_type , char const   *name , void *prev ,
                          int *idx_cache ) ;
#line 69 "../include/auth.h"
struct passwd *pr_auth_getpwuid(pool *p , uid_t uid ) ;
#line 71
struct group *pr_auth_getgrgid(pool *p , gid_t gid ) ;
#line 76
uid_t pr_auth_name2uid(pool *p , char const   *name ) ;
#line 106
int pr_auth_add_auth_only_module(char const   *name ) ;
#line 109
int pr_auth_cache_set(int bool , unsigned int flags ) ;
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static pool *auth_pool  =    (pool *)((void *)0);
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static pr_table_t *auth_tab  =    (pr_table_t *)((void *)0);
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static pr_table_t *uid_tab  =    (pr_table_t *)((void *)0);
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static pr_table_t *gid_tab  =    (pr_table_t *)((void *)0);
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static xaset_t *auth_module_list  =    (xaset_t *)((void *)0);
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static char const   *trace_channel___3  =    "auth";
#line 48 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static unsigned int auth_caching  =    7U;
#line 51 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static int uid_keycmp_cb(void const   *key1 , size_t keysz1 , void const   *key2 ,
                         size_t keysz2 ) 
{ 
  int tmp ;

  {
#line 55
  if (*((uid_t *)key1) == *((uid_t *)key2)) {
#line 55
    tmp = 0;
  } else {
#line 55
    tmp = 1;
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static int gid_keycmp_cb(void const   *key1 , size_t keysz1 , void const   *key2 ,
                         size_t keysz2 ) 
{ 
  int tmp ;

  {
#line 62
  if (*((gid_t *)key1) == *((gid_t *)key2)) {
#line 62
    tmp = 0;
  } else {
#line 62
    tmp = 1;
  }
#line 62
  return (tmp);
}
}
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static unsigned int uid_hash_cb(void const   *key , size_t keysz ) 
{ 
  uid_t u ;
  unsigned int res ;

  {
  {
#line 70
  memcpy((void */* __restrict  */)(& u), (void const   */* __restrict  */)key, keysz);
#line 71
  res = u << 8;
  }
#line 73
  return (res);
}
}
#line 76 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static unsigned int gid_hash_cb(void const   *key , size_t keysz ) 
{ 
  gid_t g ;
  unsigned int res ;

  {
  {
#line 80
  memcpy((void */* __restrict  */)(& g), (void const   */* __restrict  */)key, keysz);
#line 81
  res = g << 8;
  }
#line 83
  return (res);
}
}
#line 86 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static void uidcache_create(void) 
{ 
  int ok ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 87
  if (auth_caching & 1U) {
#line 87
    if (! uid_tab) {
#line 87
      if (auth_pool) {
        {
#line 90
        ok = 1;
#line 92
        uid_tab = pr_table_alloc(auth_pool, 0);
#line 94
        tmp___1 = pr_table_ctl(uid_tab, 4, (void *)(& uid_keycmp_cb));
        }
#line 94
        if (tmp___1 < 0) {
          {
#line 95
          tmp = __errno_location();
#line 95
          tmp___0 = strerror(*tmp);
#line 95
          pr_trace_msg(trace_channel___3, 2, "error setting key comparison callback for uidcache: %s",
                       tmp___0);
#line 98
          ok = 0;
          }
        }
        {
#line 101
        tmp___4 = pr_table_ctl(uid_tab, 5, (void *)(& uid_hash_cb));
        }
#line 101
        if (tmp___4 < 0) {
          {
#line 102
          tmp___2 = __errno_location();
#line 102
          tmp___3 = strerror(*tmp___2);
#line 102
          pr_trace_msg(trace_channel___3, 2, "error setting key hash callback for uidcache: %s",
                       tmp___3);
#line 105
          ok = 0;
          }
        }
#line 108
        if (! ok) {
          {
#line 109
          pr_trace_msg(trace_channel___3, 2, "%s", "destroying unusable uidcache table");
#line 111
          pr_table_free(uid_tab);
#line 112
          uid_tab = (pr_table_t *)((void *)0);
          }
        }
      }
    }
  }
#line 115
  return;
}
}
#line 117 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static void uidcache_add(uid_t uid , char const   *name ) 
{ 
  int count ;
  uid_t *cache_uid ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 118
  uidcache_create();
  }
#line 120
  if (uid_tab) {
    {
#line 123
    pr_table_rewind(uid_tab);
#line 124
    count = pr_table_kexists(uid_tab, (void const   *)(& uid), (size_t )sizeof(uid_t ));
    }
#line 125
    if (count <= 0) {
      {
#line 131
      tmp = palloc(auth_pool, (int )sizeof(uid_t ));
#line 131
      cache_uid = (uid_t *)tmp;
#line 132
      *cache_uid = uid;
#line 134
      tmp___2 = strlen(name);
#line 134
      tmp___3 = pstrdup(auth_pool, name);
#line 134
      tmp___4 = pr_table_kadd(uid_tab, (void const   *)cache_uid, (size_t )sizeof(uid_t ),
                              (void *)tmp___3, tmp___2 + 1U);
      }
#line 134
      if (tmp___4 < 0) {
        {
#line 134
        tmp___5 = __errno_location();
        }
#line 134
        if (*tmp___5 != 17) {
          {
#line 137
          tmp___0 = __errno_location();
#line 137
          tmp___1 = strerror(*tmp___0);
#line 137
          pr_trace_msg(trace_channel___3, 3, "error adding name \'%s\' for UID %lu to the uidcache: %s",
                       name, (unsigned long )uid, tmp___1);
          }
        } else {
          {
#line 142
          pr_trace_msg(trace_channel___3, 5, "stashed name \'%s\' for UID %lu in the uidcache",
                       name, (unsigned long )uid);
          }
        }
      } else {
        {
#line 142
        pr_trace_msg(trace_channel___3, 5, "stashed name \'%s\' for UID %lu in the uidcache",
                     name, (unsigned long )uid);
        }
      }
    }
  }
#line 148
  return;
}
}
#line 150 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static void gidcache_create(void) 
{ 
  int ok ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 151
  if (auth_caching & 2U) {
#line 151
    if (! gid_tab) {
#line 151
      if (auth_pool) {
        {
#line 154
        ok = 1;
#line 156
        gid_tab = pr_table_alloc(auth_pool, 0);
#line 158
        tmp___1 = pr_table_ctl(gid_tab, 4, (void *)(& gid_keycmp_cb));
        }
#line 158
        if (tmp___1 < 0) {
          {
#line 159
          tmp = __errno_location();
#line 159
          tmp___0 = strerror(*tmp);
#line 159
          pr_trace_msg(trace_channel___3, 2, "error setting key comparison callback for gidcache: %s",
                       tmp___0);
#line 162
          ok = 0;
          }
        }
        {
#line 165
        tmp___4 = pr_table_ctl(gid_tab, 5, (void *)(& gid_hash_cb));
        }
#line 165
        if (tmp___4 < 0) {
          {
#line 166
          tmp___2 = __errno_location();
#line 166
          tmp___3 = strerror(*tmp___2);
#line 166
          pr_trace_msg(trace_channel___3, 2, "error setting key hash callback for gidcache: %s",
                       tmp___3);
#line 169
          ok = 0;
          }
        }
#line 172
        if (! ok) {
          {
#line 173
          pr_trace_msg(trace_channel___3, 2, "%s", "destroying unusable gidcache table");
#line 175
          pr_table_free(gid_tab);
#line 176
          gid_tab = (pr_table_t *)((void *)0);
          }
        }
      }
    }
  }
#line 179
  return;
}
}
#line 181 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static void gidcache_add(gid_t gid , char const   *name ) 
{ 
  int count ;
  gid_t *cache_gid ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 182
  gidcache_create();
  }
#line 184
  if (gid_tab) {
    {
#line 187
    pr_table_rewind(gid_tab);
#line 188
    count = pr_table_kexists(gid_tab, (void const   *)(& gid), (size_t )sizeof(gid_t ));
    }
#line 189
    if (count <= 0) {
      {
#line 195
      tmp = palloc(auth_pool, (int )sizeof(gid_t ));
#line 195
      cache_gid = (gid_t *)tmp;
#line 196
      *cache_gid = gid;
#line 198
      tmp___2 = strlen(name);
#line 198
      tmp___3 = pstrdup(auth_pool, name);
#line 198
      tmp___4 = pr_table_kadd(gid_tab, (void const   *)cache_gid, (size_t )sizeof(gid_t ),
                              (void *)tmp___3, tmp___2 + 1U);
      }
#line 198
      if (tmp___4 < 0) {
        {
#line 198
        tmp___5 = __errno_location();
        }
#line 198
        if (*tmp___5 != 17) {
          {
#line 201
          tmp___0 = __errno_location();
#line 201
          tmp___1 = strerror(*tmp___0);
#line 201
          pr_trace_msg(trace_channel___3, 3, "error adding name \'%s\' for GID %lu to the gidcache: %s",
                       name, (unsigned long )gid, tmp___1);
          }
        } else {
          {
#line 206
          pr_trace_msg(trace_channel___3, 5, "stashed name \'%s\' for GID %lu in the gidcache",
                       name, (unsigned long )gid);
          }
        }
      } else {
        {
#line 206
        pr_trace_msg(trace_channel___3, 5, "stashed name \'%s\' for GID %lu in the gidcache",
                     name, (unsigned long )gid);
        }
      }
    }
  }
#line 212
  return;
}
}
#line 221 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static cmd_rec *make_cmd(pool *cp , int argc  , ...) 
{ 
  va_list args ;
  cmd_rec *c ;
  int i___0 ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___2 ;

  {
  {
#line 226
  tmp = pcalloc(cp, (int )sizeof(cmd_rec ));
#line 226
  c = (cmd_rec *)tmp;
#line 228
  c->argc = argc;
#line 229
  c->stash_index = -1;
  }
#line 231
  if (argc) {
    {
#line 232
    tmp___0 = pcalloc(cp, (int )(sizeof(void *) * (unsigned long )(argc + 1)));
#line 232
    c->argv = (char **)tmp___0;
#line 234
    __builtin_va_start(args, argc);
#line 236
    i___0 = 0;
    }
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (i___0 < argc)) {
#line 236
        goto while_break;
      }
      {
#line 237
      tmp___2 = __builtin_va_arg(args, char *);
#line 237
      *(c->argv + i___0) = (char *)((void *)tmp___2);
#line 236
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 239
    __builtin_va_end(args);
#line 241
    *(c->argv + argc) = (char *)((void *)0);
    }
  }
#line 244
  return (c);
}
}
#line 247 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static modret_t *dispatch_auth(cmd_rec *cmd , char *match , module **m ) 
{ 
  authtable *start_tab ;
  authtable *iter_tab ;
  modret_t *mr ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;

  {
  {
#line 248
  start_tab = (authtable *)((void *)0);
#line 248
  iter_tab = (authtable *)((void *)0);
#line 249
  mr = (modret_t *)((void *)0);
#line 251
  tmp = pr_stash_get_symbol((pr_stash_type_t )3, (char const   *)match, (void *)0,
                            & cmd->stash_index);
#line 251
  start_tab = (authtable *)tmp;
#line 253
  iter_tab = start_tab;
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! iter_tab) {
#line 255
      goto while_break;
    }
    {
#line 256
    pr_signals_handle();
    }
#line 258
    if (m) {
#line 258
      if (*m) {
#line 258
        if ((unsigned long )*m != (unsigned long )iter_tab->m) {
#line 259
          goto next;
        }
      }
    }
    {
#line 262
    pr_trace_msg(trace_channel___3, 6, "dispatching auth request \"%s\" to module mod_%s",
                 match, (iter_tab->m)->name);
#line 266
    mr = pr_module_call(iter_tab->m, iter_tab->handler, cmd);
    }
#line 268
    if (iter_tab->auth_flags & 1) {
#line 269
      goto while_break;
    }
#line 271
    if (mr) {
#line 271
      if (! mr->mr_error) {
#line 271
        goto _L;
      } else {
#line 271
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 271
    if (mr) {
#line 271
      if (mr->mr_error) {
        _L: /* CIL Label */ 
#line 278
        if (m) {
#line 279
          *m = iter_tab->m;
        }
#line 281
        goto while_break;
      }
    }
    next: 
    {
#line 285
    tmp___0 = pr_stash_get_symbol((pr_stash_type_t )3, (char const   *)match, (void *)iter_tab,
                                  & cmd->stash_index);
#line 285
    iter_tab = (authtable *)tmp___0;
    }
#line 288
    if ((unsigned long )iter_tab == (unsigned long )start_tab) {
#line 292
      mr = (modret_t *)((void *)0);
#line 293
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (mr);
}
}
#line 300 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
void pr_auth_setpwent(pool *p ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  char *__cil_tmp4 ;

  {
  {
#line 301
  cmd = (cmd_rec *)((void *)0);
#line 302
  mr = (modret_t *)((void *)0);
#line 304
  cmd = make_cmd(p, 0);
#line 305
  mr = dispatch_auth(cmd, (char *)"setpwent", (module **)((void *)0));
  }
#line 307
  if (cmd->tmp_pool) {
    {
#line 308
    destroy_pool(cmd->tmp_pool);
#line 309
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 312
  return;
}
}
#line 315 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
void pr_auth_endpwent(pool *p ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 316
  cmd = (cmd_rec *)((void *)0);
#line 317
  mr = (modret_t *)((void *)0);
#line 319
  cmd = make_cmd(p, 0);
#line 320
  mr = dispatch_auth(cmd, (char *)"endpwent", (module **)((void *)0));
  }
#line 322
  if (cmd->tmp_pool) {
    {
#line 323
    destroy_pool(cmd->tmp_pool);
#line 324
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 327
  if (auth_tab) {
    {
#line 328
    pr_trace_msg(trace_channel___3, 5, "emptying authcache");
#line 329
    pr_table_empty(auth_tab);
#line 330
    pr_table_free(auth_tab);
#line 331
    auth_tab = (pr_table_t *)((void *)0);
    }
  }
#line 334
  return;
}
}
#line 337 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
void pr_auth_setgrent(pool *p ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  char *__cil_tmp4 ;

  {
  {
#line 338
  cmd = (cmd_rec *)((void *)0);
#line 339
  mr = (modret_t *)((void *)0);
#line 341
  cmd = make_cmd(p, 0);
#line 342
  mr = dispatch_auth(cmd, (char *)"setgrent", (module **)((void *)0));
  }
#line 344
  if (cmd->tmp_pool) {
    {
#line 345
    destroy_pool(cmd->tmp_pool);
#line 346
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 349
  return;
}
}
#line 352 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
void pr_auth_endgrent(pool *p ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  char *__cil_tmp4 ;

  {
  {
#line 353
  cmd = (cmd_rec *)((void *)0);
#line 354
  mr = (modret_t *)((void *)0);
#line 356
  cmd = make_cmd(p, 0);
#line 357
  mr = dispatch_auth(cmd, (char *)"endgrent", (module **)((void *)0));
  }
#line 359
  if (cmd->tmp_pool) {
    {
#line 360
    destroy_pool(cmd->tmp_pool);
#line 361
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 364
  return;
}
}
#line 367 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct passwd *pr_auth_getpwent(pool *p ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  struct passwd *res ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 368
  cmd = (cmd_rec *)((void *)0);
#line 369
  mr = (modret_t *)((void *)0);
#line 370
  res = (struct passwd *)((void *)0);
#line 372
  cmd = make_cmd(p, 0);
#line 373
  mr = dispatch_auth(cmd, (char *)"getpwent", (module **)((void *)0));
  }
#line 375
  if (mr) {
#line 375
    if (! mr->mr_error) {
#line 375
      if (mr) {
#line 375
        if (mr->data) {
#line 375
          tmp = 1;
        } else {
#line 375
          tmp = 0;
        }
#line 375
        tmp___0 = tmp;
      } else {
#line 375
        tmp___0 = 0;
      }
#line 375
      if (tmp___0) {
#line 376
        res = (struct passwd *)mr->data;
      }
    }
  }
#line 378
  if (cmd->tmp_pool) {
    {
#line 379
    destroy_pool(cmd->tmp_pool);
#line 380
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 384
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 385
    return ((struct passwd *)((void *)0));
  }
#line 388
  if (res->pw_uid == 4294967295U) {
    {
#line 389
    pr_log_pri(3, "error: UID of -1 not allowed");
    }
#line 390
    return ((struct passwd *)((void *)0));
  }
#line 393
  if (res->pw_gid == 4294967295U) {
    {
#line 394
    pr_log_pri(3, "error: GID of -1 not allowed");
    }
#line 395
    return ((struct passwd *)((void *)0));
  }
#line 398
  return (res);
}
}
#line 401 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct group *pr_auth_getgrent(pool *p ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  struct group *res ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 402
  cmd = (cmd_rec *)((void *)0);
#line 403
  mr = (modret_t *)((void *)0);
#line 404
  res = (struct group *)((void *)0);
#line 406
  cmd = make_cmd(p, 0);
#line 407
  mr = dispatch_auth(cmd, (char *)"getgrent", (module **)((void *)0));
  }
#line 409
  if (mr) {
#line 409
    if (! mr->mr_error) {
#line 409
      if (mr) {
#line 409
        if (mr->data) {
#line 409
          tmp = 1;
        } else {
#line 409
          tmp = 0;
        }
#line 409
        tmp___0 = tmp;
      } else {
#line 409
        tmp___0 = 0;
      }
#line 409
      if (tmp___0) {
#line 410
        res = (struct group *)mr->data;
      }
    }
  }
#line 412
  if (cmd->tmp_pool) {
    {
#line 413
    destroy_pool(cmd->tmp_pool);
#line 414
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 418
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 419
    return ((struct group *)((void *)0));
  }
#line 422
  if (res->gr_gid == 4294967295U) {
    {
#line 423
    pr_log_pri(3, "error: GID of -1 not allowed");
    }
#line 424
    return ((struct group *)((void *)0));
  }
#line 427
  return (res);
}
}
#line 430 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct passwd *pr_auth_getpwnam(pool *p , char const   *name ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  struct passwd *res ;
  module *m ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int count ;
  void *value ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 431
  cmd = (cmd_rec *)((void *)0);
#line 432
  mr = (modret_t *)((void *)0);
#line 433
  res = (struct passwd *)((void *)0);
#line 434
  m = (module *)((void *)0);
#line 436
  cmd = make_cmd(p, 1, name);
#line 437
  mr = dispatch_auth(cmd, (char *)"getpwnam", & m);
  }
#line 439
  if (mr) {
#line 439
    if (! mr->mr_error) {
#line 439
      if (mr) {
#line 439
        if (mr->data) {
#line 439
          tmp = 1;
        } else {
#line 439
          tmp = 0;
        }
#line 439
        tmp___0 = tmp;
      } else {
#line 439
        tmp___0 = 0;
      }
#line 439
      if (tmp___0) {
#line 441
        res = (struct passwd *)mr->data;
      }
    }
  }
#line 443
  if (cmd->tmp_pool) {
    {
#line 444
    destroy_pool(cmd->tmp_pool);
#line 445
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 449
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 450
    tmp___1 = __errno_location();
#line 450
    *tmp___1 = 2;
    }
#line 451
    return ((struct passwd *)((void *)0));
  }
#line 455
  if (res->pw_uid == 4294967295U) {
    {
#line 456
    pr_log_pri(3, "error: UID of -1 not allowed");
    }
#line 457
    return ((struct passwd *)((void *)0));
  }
#line 460
  if (res->pw_gid == 4294967295U) {
    {
#line 461
    pr_log_pri(3, "error: GID of -1 not allowed");
    }
#line 462
    return ((struct passwd *)((void *)0));
  }
#line 465
  if (auth_caching & 4U) {
#line 465
    if (! auth_tab) {
#line 465
      if (auth_pool) {
        {
#line 468
        auth_tab = pr_table_alloc(auth_pool, 0);
        }
      }
    }
  }
#line 471
  if (m) {
#line 471
    if (auth_tab) {
      {
#line 473
      count = 0;
#line 474
      value = (void *)0;
#line 476
      value = palloc(auth_pool, (int )sizeof(module *));
#line 477
      *((module **)value) = m;
#line 479
      count = pr_table_exists(auth_tab, name);
      }
#line 480
      if (count <= 0) {
        {
#line 481
        tmp___4 = pstrdup(auth_pool, name);
#line 481
        tmp___5 = pr_table_add(auth_tab, (char const   *)tmp___4, value, (size_t )sizeof(module *));
        }
#line 481
        if (tmp___5 < 0) {
          {
#line 483
          tmp___2 = __errno_location();
#line 483
          tmp___3 = strerror(*tmp___2);
#line 483
          pr_trace_msg(trace_channel___3, 3, "error adding module \'mod_%s.c\' for user \'%s\' to the authcache: %s",
                       m->name, name, tmp___3);
          }
        } else {
          {
#line 488
          pr_trace_msg(trace_channel___3, 5, "stashed module \'mod_%s.c\' for user \'%s\' in the authcache",
                       m->name, name);
          }
        }
      } else {
        {
#line 494
        tmp___8 = pstrdup(auth_pool, name);
#line 494
        tmp___9 = pr_table_set(auth_tab, (char const   *)tmp___8, value, (size_t )sizeof(module *));
        }
#line 494
        if (tmp___9 < 0) {
          {
#line 496
          tmp___6 = __errno_location();
#line 496
          tmp___7 = strerror(*tmp___6);
#line 496
          pr_trace_msg(trace_channel___3, 3, "error setting module \'mod_%s.c\' for user \'%s\' in the authcache: %s",
                       m->name, name, tmp___7);
          }
        } else {
          {
#line 501
          pr_trace_msg(trace_channel___3, 5, "stashed module \'mod_%s.c\' for user \'%s\' in the authcache",
                       m->name, name);
          }
        }
      }
    }
  }
  {
#line 508
  uidcache_add(res->pw_uid, name);
#line 510
  pr_log_debug(10, "retrieved UID %lu for user \'%s\'", (unsigned long )res->pw_uid,
               name);
  }
#line 512
  return (res);
}
}
#line 515 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct passwd *pr_auth_getpwuid(pool *p , uid_t uid ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  struct passwd *res ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 516
  cmd = (cmd_rec *)((void *)0);
#line 517
  mr = (modret_t *)((void *)0);
#line 518
  res = (struct passwd *)((void *)0);
#line 520
  cmd = make_cmd(p, 1, (void *)(& uid));
#line 521
  mr = dispatch_auth(cmd, (char *)"getpwuid", (module **)((void *)0));
  }
#line 523
  if (mr) {
#line 523
    if (! mr->mr_error) {
#line 523
      if (mr) {
#line 523
        if (mr->data) {
#line 523
          tmp = 1;
        } else {
#line 523
          tmp = 0;
        }
#line 523
        tmp___0 = tmp;
      } else {
#line 523
        tmp___0 = 0;
      }
#line 523
      if (tmp___0) {
#line 524
        res = (struct passwd *)mr->data;
      }
    }
  }
#line 526
  if (cmd->tmp_pool) {
    {
#line 527
    destroy_pool(cmd->tmp_pool);
#line 528
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 532
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 533
    tmp___1 = __errno_location();
#line 533
    *tmp___1 = 2;
    }
#line 534
    return ((struct passwd *)((void *)0));
  }
#line 538
  if (res->pw_uid == 4294967295U) {
    {
#line 539
    pr_log_pri(3, "error: UID of -1 not allowed");
    }
#line 540
    return ((struct passwd *)((void *)0));
  }
#line 543
  if (res->pw_gid == 4294967295U) {
    {
#line 544
    pr_log_pri(3, "error: GID of -1 not allowed");
    }
#line 545
    return ((struct passwd *)((void *)0));
  }
  {
#line 548
  pr_log_debug(10, "retrieved user \'%s\' for UID %lu", res->pw_name, (unsigned long )uid);
  }
#line 550
  return (res);
}
}
#line 553 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct group *pr_auth_getgrnam(pool *p , char const   *name ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  struct group *res ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 554
  cmd = (cmd_rec *)((void *)0);
#line 555
  mr = (modret_t *)((void *)0);
#line 556
  res = (struct group *)((void *)0);
#line 558
  cmd = make_cmd(p, 1, name);
#line 559
  mr = dispatch_auth(cmd, (char *)"getgrnam", (module **)((void *)0));
  }
#line 561
  if (mr) {
#line 561
    if (! mr->mr_error) {
#line 561
      if (mr) {
#line 561
        if (mr->data) {
#line 561
          tmp = 1;
        } else {
#line 561
          tmp = 0;
        }
#line 561
        tmp___0 = tmp;
      } else {
#line 561
        tmp___0 = 0;
      }
#line 561
      if (tmp___0) {
#line 562
        res = (struct group *)mr->data;
      }
    }
  }
#line 564
  if (cmd->tmp_pool) {
    {
#line 565
    destroy_pool(cmd->tmp_pool);
#line 566
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 570
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 571
    tmp___1 = __errno_location();
#line 571
    *tmp___1 = 2;
    }
#line 572
    return ((struct group *)((void *)0));
  }
#line 576
  if (res->gr_gid == 4294967295U) {
    {
#line 577
    pr_log_pri(3, "error: GID of -1 not allowed");
    }
#line 578
    return ((struct group *)((void *)0));
  }
  {
#line 581
  gidcache_add(res->gr_gid, name);
#line 583
  pr_log_debug(10, "retrieved GID %lu for group \'%s\'", (unsigned long )res->gr_gid,
               name);
  }
#line 585
  return (res);
}
}
#line 588 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
struct group *pr_auth_getgrgid(pool *p , gid_t gid ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  struct group *res ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 589
  cmd = (cmd_rec *)((void *)0);
#line 590
  mr = (modret_t *)((void *)0);
#line 591
  res = (struct group *)((void *)0);
#line 593
  cmd = make_cmd(p, 1, (void *)(& gid));
#line 594
  mr = dispatch_auth(cmd, (char *)"getgrgid", (module **)((void *)0));
  }
#line 596
  if (mr) {
#line 596
    if (! mr->mr_error) {
#line 596
      if (mr) {
#line 596
        if (mr->data) {
#line 596
          tmp = 1;
        } else {
#line 596
          tmp = 0;
        }
#line 596
        tmp___0 = tmp;
      } else {
#line 596
        tmp___0 = 0;
      }
#line 596
      if (tmp___0) {
#line 597
        res = (struct group *)mr->data;
      }
    }
  }
#line 599
  if (cmd->tmp_pool) {
    {
#line 600
    destroy_pool(cmd->tmp_pool);
#line 601
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 605
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 606
    tmp___1 = __errno_location();
#line 606
    *tmp___1 = 2;
    }
#line 607
    return ((struct group *)((void *)0));
  }
#line 611
  if (res->gr_gid == 4294967295U) {
    {
#line 612
    pr_log_pri(3, "error: GID of -1 not allowed");
    }
#line 613
    return ((struct group *)((void *)0));
  }
  {
#line 616
  pr_log_debug(10, "retrieved group \'%s\' for GID %lu", res->gr_name, (unsigned long )gid);
  }
#line 618
  return (res);
}
}
#line 621 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_authenticate(pool *p , char const   *name , char const   *pw ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  module *m ;
  int res ;
  struct auth_module_elt *elt ;
  int tmp___1 ;
  int tmp___2 ;
  void *v ;
  void *tmp___3 ;
  module **tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 622
  cmd = (cmd_rec *)((void *)0);
#line 623
  mr = (modret_t *)((void *)0);
#line 624
  m = (module *)((void *)0);
#line 625
  res = -2;
#line 627
  cmd = make_cmd(p, 2, name, pw);
  }
#line 633
  if (auth_module_list) {
#line 636
    elt = (struct auth_module_elt *)auth_module_list->xas_list;
    {
#line 636
    while (1) {
      while_continue: /* CIL Label */ ;
#line 636
      if (! elt) {
#line 636
        goto while_break;
      }
      {
#line 639
      pr_trace_msg(trace_channel___3, 7, "checking with auth-only module \'%s\'",
                   elt->name);
#line 642
      m = pr_module_get(elt->name);
      }
#line 643
      if (m) {
        {
#line 644
        mr = dispatch_auth(cmd, (char *)"auth", & m);
        }
#line 646
        if (mr) {
#line 646
          if (! mr->mr_error) {
            {
#line 647
            pr_trace_msg(trace_channel___3, 4, "module \'%s\' used for authenticating user \'%s\'",
                         elt->name, name);
            }
#line 650
            if (mr) {
#line 650
              if (mr->data) {
#line 650
                tmp___1 = 1;
              } else {
#line 650
                tmp___1 = 0;
              }
#line 650
              tmp___2 = tmp___1;
            } else {
#line 650
              tmp___2 = 0;
            }
#line 650
            if (tmp___2) {
#line 650
              res = 2;
            } else {
#line 650
              res = 0;
            }
#line 652
            if (cmd->tmp_pool) {
              {
#line 653
              destroy_pool(cmd->tmp_pool);
#line 654
              cmd->tmp_pool = (pool *)((void *)0);
              }
            }
#line 657
            return (res);
          }
        }
#line 660
        if (mr) {
#line 660
          if (mr->mr_error) {
#line 661
            if (mr) {
#line 661
              res = mr->mr_error;
            } else {
#line 661
              res = 0;
            }
#line 663
            if (cmd->tmp_pool) {
              {
#line 664
              destroy_pool(cmd->tmp_pool);
#line 665
              cmd->tmp_pool = (pool *)((void *)0);
              }
            }
#line 668
            return (res);
          }
        }
#line 671
        m = (module *)((void *)0);
      }
#line 636
      elt = elt->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 676
  if (auth_tab) {
    {
#line 679
    tmp___3 = pr_table_get(auth_tab, name, (size_t *)((void *)0));
#line 679
    v = tmp___3;
    }
#line 680
    if (v) {
      {
#line 681
      m = *((module **)v);
#line 683
      pr_trace_msg(trace_channel___3, 4, "using module \'mod_%s.c\' from authcache to authenticate user \'%s\'",
                   m->name, name);
      }
    }
  }
#line 689
  if (m) {
#line 689
    tmp___4 = & m;
  } else {
#line 689
    tmp___4 = (module **)((void *)0);
  }
  {
#line 689
  mr = dispatch_auth(cmd, (char *)"auth", tmp___4);
  }
#line 691
  if (mr) {
#line 691
    if (! mr->mr_error) {
#line 692
      if (mr) {
#line 692
        if (mr->data) {
#line 692
          tmp___7 = 1;
        } else {
#line 692
          tmp___7 = 0;
        }
#line 692
        tmp___8 = tmp___7;
      } else {
#line 692
        tmp___8 = 0;
      }
#line 692
      if (tmp___8) {
#line 692
        res = 2;
      } else {
#line 692
        res = 0;
      }
    } else {
#line 691
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 694
  if (mr) {
#line 694
    if (mr->mr_error) {
#line 695
      if (mr) {
#line 695
        res = mr->mr_error;
      } else {
#line 695
        res = 0;
      }
    }
  }
#line 697
  if (cmd->tmp_pool) {
    {
#line 698
    destroy_pool(cmd->tmp_pool);
#line 699
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 702
  return (res);
}
}
#line 705 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_check(pool *p , char const   *cpw , char const   *name , char const   *pw ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  module *m ;
  int res ;
  struct auth_module_elt *elt ;
  int tmp___1 ;
  int tmp___2 ;
  void *v ;
  void *tmp___3 ;
  module **tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 706
  cmd = (cmd_rec *)((void *)0);
#line 707
  mr = (modret_t *)((void *)0);
#line 708
  m = (module *)((void *)0);
#line 709
  res = -3;
#line 711
  cmd = make_cmd(p, 3, cpw, name, pw);
  }
#line 717
  if (auth_module_list) {
#line 720
    elt = (struct auth_module_elt *)auth_module_list->xas_list;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (! elt) {
#line 720
        goto while_break;
      }
      {
#line 723
      m = pr_module_get(elt->name);
      }
#line 724
      if (m) {
        {
#line 725
        mr = dispatch_auth(cmd, (char *)"check", & m);
        }
#line 727
        if (mr) {
#line 727
          if (! mr->mr_error) {
            {
#line 728
            pr_trace_msg(trace_channel___3, 4, "module \'%s\' used for authenticating user \'%s\'",
                         elt->name, name);
            }
#line 731
            if (mr) {
#line 731
              if (mr->data) {
#line 731
                tmp___1 = 1;
              } else {
#line 731
                tmp___1 = 0;
              }
#line 731
              tmp___2 = tmp___1;
            } else {
#line 731
              tmp___2 = 0;
            }
#line 731
            if (tmp___2) {
#line 731
              res = 2;
            } else {
#line 731
              res = 0;
            }
#line 733
            if (cmd->tmp_pool) {
              {
#line 734
              destroy_pool(cmd->tmp_pool);
#line 735
              cmd->tmp_pool = (pool *)((void *)0);
              }
            }
#line 738
            return (res);
          }
        }
#line 741
        if (mr) {
#line 741
          if (mr->mr_error) {
#line 742
            if (mr) {
#line 742
              res = mr->mr_error;
            } else {
#line 742
              res = 0;
            }
#line 744
            if (cmd->tmp_pool) {
              {
#line 745
              destroy_pool(cmd->tmp_pool);
#line 746
              cmd->tmp_pool = (pool *)((void *)0);
              }
            }
#line 749
            return (res);
          }
        }
#line 752
        m = (module *)((void *)0);
      }
#line 720
      elt = elt->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 757
  if (auth_tab) {
    {
#line 760
    tmp___3 = pr_table_get(auth_tab, name, (size_t *)((void *)0));
#line 760
    v = tmp___3;
    }
#line 761
    if (v) {
      {
#line 762
      m = *((module **)v);
#line 764
      pr_trace_msg(trace_channel___3, 4, "using module \'mod_%s.c\' from authcache to authenticate user \'%s\'",
                   m->name, name);
      }
    }
  }
#line 770
  if (m) {
#line 770
    tmp___4 = & m;
  } else {
#line 770
    tmp___4 = (module **)((void *)0);
  }
  {
#line 770
  mr = dispatch_auth(cmd, (char *)"check", tmp___4);
  }
#line 772
  if (mr) {
#line 772
    if (! mr->mr_error) {
#line 773
      if (mr) {
#line 773
        if (mr->data) {
#line 773
          tmp___7 = 1;
        } else {
#line 773
          tmp___7 = 0;
        }
#line 773
        tmp___8 = tmp___7;
      } else {
#line 773
        tmp___8 = 0;
      }
#line 773
      if (tmp___8) {
#line 773
        res = 2;
      } else {
#line 773
        res = 0;
      }
    }
  }
#line 775
  if (cmd->tmp_pool) {
    {
#line 776
    destroy_pool(cmd->tmp_pool);
#line 777
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 780
  return (res);
}
}
#line 783 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_requires_pass(pool *p , char const   *name ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  int res ;
  char *__cil_tmp6 ;

  {
  {
#line 786
  res = 1;
#line 788
  cmd = make_cmd(p, 1, name);
#line 789
  mr = dispatch_auth(cmd, (char *)"requires_pass", (module **)((void *)0));
  }
#line 791
  if (mr) {
#line 791
    if (! mr->mr_error) {
#line 792
      res = 0;
    } else {
#line 791
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 794
  if (mr) {
#line 794
    if (mr->mr_error) {
#line 795
      if (mr) {
#line 795
        res = mr->mr_error;
      } else {
#line 795
        res = 0;
      }
    }
  }
#line 797
  if (cmd->tmp_pool) {
    {
#line 798
    destroy_pool(cmd->tmp_pool);
#line 799
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 802
  return (res);
}
}
#line 806 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static char namebuf[64]  ;
#line 805 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
char const   *pr_auth_uid2name(pool *p , uid_t uid ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  char *res ;
  void *v ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 807
  cmd = (cmd_rec *)((void *)0);
#line 808
  mr = (modret_t *)((void *)0);
#line 809
  res = (char *)((void *)0);
#line 811
  memset((void *)(namebuf), '\000', (size_t )sizeof(namebuf));
#line 813
  uidcache_create();
  }
#line 815
  if (uid_tab) {
    {
#line 816
    v = (void *)0;
#line 818
    v = pr_table_kget(uid_tab, (void const   *)(& uid), (size_t )sizeof(uid_t ), (size_t *)((void *)0));
    }
#line 819
    if (v) {
      {
#line 820
      sstrncpy(namebuf, (char const   *)v, (size_t )sizeof(namebuf));
#line 822
      pr_trace_msg(trace_channel___3, 8, "using name \'%s\' from uidcache for UID %lu",
                   namebuf, (unsigned long )uid);
#line 826
      res = namebuf;
      }
#line 827
      return ((char const   *)res);
    } else {
      {
#line 830
      tmp = __errno_location();
#line 830
      tmp___0 = strerror(*tmp);
#line 830
      pr_trace_msg(trace_channel___3, 9, "no value found in uidcache for UID %lu: %s",
                   (unsigned long )uid, tmp___0);
      }
    }
  }
  {
#line 836
  cmd = make_cmd(p, 1, (void *)(& uid));
#line 837
  mr = dispatch_auth(cmd, (char *)"uid2name", (module **)((void *)0));
  }
#line 839
  if (mr) {
#line 839
    if (! mr->mr_error) {
#line 839
      if (mr) {
#line 839
        if (mr->data) {
#line 839
          tmp___1 = 1;
        } else {
#line 839
          tmp___1 = 0;
        }
#line 839
        tmp___2 = tmp___1;
      } else {
#line 839
        tmp___2 = 0;
      }
#line 839
      if (tmp___2) {
        {
#line 841
        res = (char *)mr->data;
#line 842
        sstrncpy(namebuf, (char const   *)res, (size_t )sizeof(namebuf));
#line 843
        res = namebuf;
#line 845
        uidcache_add(uid, (char const   *)res);
        }
      }
    }
  }
#line 848
  if (cmd->tmp_pool) {
    {
#line 849
    destroy_pool(cmd->tmp_pool);
#line 850
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
  {
#line 853
  memset((void *)(namebuf), '\000', (size_t )sizeof(namebuf));
#line 854
  snprintf((char */* __restrict  */)(namebuf), (size_t )(sizeof(namebuf) - 1UL), (char const   */* __restrict  */)"%lu",
           (unsigned long )uid);
#line 855
  res = namebuf;
  }
#line 857
  return ((char const   *)res);
}
}
#line 863 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static char namebuf___0[64]  ;
#line 860 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
char const   *pr_auth_gid2name(pool *p , gid_t gid ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  char *res ;
  void *v ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 861
  cmd = (cmd_rec *)((void *)0);
#line 862
  mr = (modret_t *)((void *)0);
#line 864
  res = (char *)((void *)0);
#line 866
  memset((void *)(namebuf___0), '\000', (size_t )sizeof(namebuf___0));
#line 868
  gidcache_create();
  }
#line 870
  if (gid_tab) {
    {
#line 871
    v = (void *)0;
#line 873
    v = pr_table_kget(gid_tab, (void const   *)(& gid), (size_t )sizeof(gid_t ), (size_t *)((void *)0));
    }
#line 874
    if (v) {
      {
#line 875
      sstrncpy(namebuf___0, (char const   *)v, (size_t )sizeof(namebuf___0));
#line 877
      pr_trace_msg(trace_channel___3, 8, "using name \'%s\' from gidcache for GID %lu",
                   namebuf___0, (unsigned long )gid);
#line 881
      res = namebuf___0;
      }
#line 882
      return ((char const   *)res);
    } else {
      {
#line 885
      tmp = __errno_location();
#line 885
      tmp___0 = strerror(*tmp);
#line 885
      pr_trace_msg(trace_channel___3, 9, "no value found in gidcache for GID %lu: %s",
                   (unsigned long )gid, tmp___0);
      }
    }
  }
  {
#line 891
  cmd = make_cmd(p, 1, (void *)(& gid));
#line 892
  mr = dispatch_auth(cmd, (char *)"gid2name", (module **)((void *)0));
  }
#line 894
  if (mr) {
#line 894
    if (! mr->mr_error) {
#line 894
      if (mr) {
#line 894
        if (mr->data) {
#line 894
          tmp___1 = 1;
        } else {
#line 894
          tmp___1 = 0;
        }
#line 894
        tmp___2 = tmp___1;
      } else {
#line 894
        tmp___2 = 0;
      }
#line 894
      if (tmp___2) {
        {
#line 896
        res = (char *)mr->data;
#line 897
        sstrncpy(namebuf___0, (char const   *)res, (size_t )sizeof(namebuf___0));
#line 898
        res = namebuf___0;
#line 900
        gidcache_add(gid, (char const   *)res);
        }
      }
    }
  }
#line 903
  if (cmd->tmp_pool) {
    {
#line 904
    destroy_pool(cmd->tmp_pool);
#line 905
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
  {
#line 908
  memset((void *)(namebuf___0), '\000', (size_t )sizeof(namebuf___0));
#line 909
  snprintf((char */* __restrict  */)(namebuf___0), (size_t )(sizeof(namebuf___0) - 1UL),
           (char const   */* __restrict  */)"%lu", (unsigned long )gid);
#line 910
  res = namebuf___0;
  }
#line 912
  return ((char const   *)res);
}
}
#line 915 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
uid_t pr_auth_name2uid(pool *p , char const   *name ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  uid_t res ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 916
  cmd = (cmd_rec *)((void *)0);
#line 917
  mr = (modret_t *)((void *)0);
#line 918
  res = (uid_t )-1;
#line 920
  cmd = make_cmd(p, 1, name);
#line 921
  mr = dispatch_auth(cmd, (char *)"name2uid", (module **)((void *)0));
  }
#line 923
  if (mr) {
#line 923
    if (! mr->mr_error) {
#line 924
      res = *((uid_t *)mr->data);
    } else {
      {
#line 926
      tmp = __errno_location();
#line 926
      *tmp = 22;
      }
    }
  } else {
    {
#line 926
    tmp = __errno_location();
#line 926
    *tmp = 22;
    }
  }
#line 928
  if (cmd->tmp_pool) {
    {
#line 929
    destroy_pool(cmd->tmp_pool);
#line 930
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 933
  return (res);
}
}
#line 936 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
gid_t pr_auth_name2gid(pool *p , char const   *name ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  gid_t res ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 937
  cmd = (cmd_rec *)((void *)0);
#line 938
  mr = (modret_t *)((void *)0);
#line 939
  res = (gid_t )-1;
#line 941
  cmd = make_cmd(p, 1, name);
#line 942
  mr = dispatch_auth(cmd, (char *)"name2gid", (module **)((void *)0));
  }
#line 944
  if (mr) {
#line 944
    if (! mr->mr_error) {
#line 945
      res = *((gid_t *)mr->data);
    } else {
      {
#line 947
      tmp = __errno_location();
#line 947
      *tmp = 22;
      }
    }
  } else {
    {
#line 947
    tmp = __errno_location();
#line 947
    *tmp = 22;
    }
  }
#line 949
  if (cmd->tmp_pool) {
    {
#line 950
    destroy_pool(cmd->tmp_pool);
#line 951
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 954
  return (res);
}
}
#line 957 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_getgroups(pool *p , char const   *name , array_header **group_ids , array_header **group_names ) 
{ 
  cmd_rec *cmd ;
  modret_t *mr ;
  int res ;
  array_header *tmp ;
  array_header *tmp___0 ;
  register unsigned int i___0 ;
  char *strgids ;
  gid_t *gids ;
  char buf___2[64] ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  register unsigned int i___1 ;
  char *strgroups ;
  char **groups ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 960
  cmd = (cmd_rec *)((void *)0);
#line 961
  mr = (modret_t *)((void *)0);
#line 962
  res = -1;
#line 965
  if (group_ids) {
    {
#line 966
    *group_ids = make_array(permanent_pool, 2U, (size_t )sizeof(gid_t ));
    }
  }
#line 968
  if (group_names) {
    {
#line 969
    *group_names = make_array(permanent_pool, 2U, (size_t )sizeof(char *));
    }
  }
#line 971
  if (group_names) {
#line 971
    tmp = *group_names;
  } else {
#line 971
    tmp = (array_header *)((void *)0);
  }
#line 971
  if (group_ids) {
#line 971
    tmp___0 = *group_ids;
  } else {
#line 971
    tmp___0 = (array_header *)((void *)0);
  }
  {
#line 971
  cmd = make_cmd(p, 3, name, tmp___0, tmp);
#line 974
  mr = dispatch_auth(cmd, (char *)"getgroups", (module **)((void *)0));
  }
#line 976
  if (mr) {
#line 976
    if (! mr->mr_error) {
#line 976
      if (mr) {
#line 976
        if (mr->data) {
#line 976
          tmp___5 = 1;
        } else {
#line 976
          tmp___5 = 0;
        }
#line 976
        tmp___6 = tmp___5;
      } else {
#line 976
        tmp___6 = 0;
      }
#line 976
      if (tmp___6) {
#line 977
        res = *((int *)mr->data);
#line 986
        if (group_ids) {
#line 988
          strgids = (char *)"";
#line 989
          gids = (gid_t *)(*group_ids)->elts;
#line 991
          i___0 = 0U;
          {
#line 991
          while (1) {
            while_continue: /* CIL Label */ ;
#line 991
            if (! (i___0 < (unsigned int )(*group_ids)->nelts)) {
#line 991
              goto while_break;
            }
            {
#line 993
            snprintf((char */* __restrict  */)(buf___2), (size_t )(sizeof(buf___2) - 1UL),
                     (char const   */* __restrict  */)"%lu", (unsigned long )*(gids + i___0));
#line 994
            buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
            }
#line 996
            if (i___0 != 0U) {
#line 996
              tmp___1 = ", ";
            } else {
#line 996
              tmp___1 = "";
            }
            {
#line 996
            strgids = pstrcat(p, strgids, tmp___1, buf___2, (void *)0);
#line 991
            i___0 ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 999
          if ((*group_ids)->nelts == 1) {
#line 999
            tmp___2 = "ID";
          } else {
#line 999
            tmp___2 = "IDs";
          }
          {
#line 999
          pr_log_debug(10, "retrieved group %s: %s", tmp___2, strgids);
          }
        }
#line 1003
        if (group_names) {
#line 1005
          strgroups = (char *)"";
#line 1006
          groups = (char **)(*group_names)->elts;
#line 1008
          i___1 = 0U;
          {
#line 1008
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1008
            if (! (i___1 < (unsigned int )(*group_names)->nelts)) {
#line 1008
              goto while_break___0;
            }
#line 1009
            if (i___1 != 0U) {
#line 1009
              tmp___3 = ", ";
            } else {
#line 1009
              tmp___3 = "";
            }
            {
#line 1009
            strgroups = pstrcat(p, strgroups, tmp___3, *(groups + i___1), (void *)0);
#line 1008
            i___1 ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1011
          if ((*group_names)->nelts == 1) {
#line 1011
            tmp___4 = "name";
          } else {
#line 1011
            tmp___4 = "names";
          }
          {
#line 1011
          pr_log_debug(10, "retrieved group %s: %s", tmp___4, strgroups);
          }
        }
      }
    }
  }
#line 1016
  if (cmd->tmp_pool) {
    {
#line 1017
    destroy_pool(cmd->tmp_pool);
#line 1018
    cmd->tmp_pool = (pool *)((void *)0);
    }
  }
#line 1021
  return (res);
}
}
#line 1027 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
static config_rec *auth_anonymous_group(pool *p , char *user ) 
{ 
  config_rec *c ;
  int ret ;
  config_rec *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1029
  ret = 0;
#line 1034
  if (! session.gids) {
#line 1034
    if (! session.groups) {
      {
#line 1034
      ret = pr_auth_getgroups(p, (char const   *)user, & session.gids, & session.groups);
      }
#line 1034
      if (ret < 1) {
        {
#line 1036
        pr_log_debug(2, "no supplemental groups found for user \'%s\'", user);
        }
      }
    }
  }
  {
#line 1038
  c = find_config(main_server->conf, 1 << 15, "AnonymousGroup", 0);
  }
#line 1040
  if (c) {
    {
#line 1041
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1042
      pr_signals_handle();
#line 1044
      ret = pr_expr_eval_group_and((char **)c->argv);
      }
#line 1041
      if (ret == 0) {
        {
#line 1041
        c = find_config_next(c, c->next, 1 << 15, "AnonymousGroup", 0);
        }
#line 1041
        if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1041
          goto while_break;
        }
      } else {
#line 1041
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1051
  if (ret) {
#line 1051
    tmp = c;
  } else {
#line 1051
    tmp = (config_rec *)((void *)0);
  }
#line 1051
  return (tmp);
}
}
#line 1055 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
config_rec *pr_auth_get_anon_config(pool *p , char **login_name , char **user_name ,
                                    char **anon_name ) 
{ 
  config_rec *c ;
  config_rec *topc ;
  char *config_user_name ;
  char *config_anon_name ;
  unsigned char is_alias ;
  unsigned char force_anon ;
  unsigned char *auth_alias_only ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  xaset_t *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1057
  c = (config_rec *)((void *)0);
#line 1057
  topc = (config_rec *)((void *)0);
#line 1058
  config_anon_name = (char *)((void *)0);
#line 1059
  is_alias = (unsigned char)0;
#line 1059
  force_anon = (unsigned char)0;
#line 1059
  auth_alias_only = (unsigned char *)((void *)0);
#line 1067
  tmp = get_param_ptr(main_server->conf, "UserName", 0);
#line 1067
  config_user_name = (char *)tmp;
  }
#line 1068
  if (config_user_name) {
#line 1068
    if (user_name) {
#line 1069
      *user_name = config_user_name;
    }
  }
  {
#line 1083
  c = find_config(main_server->conf, 1 << 15, "UserAlias", 1);
  }
#line 1084
  if (c) {
    {
#line 1085
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1086
      tmp___0 = strcmp((char const   *)*(c->argv + 0), "*");
      }
#line 1086
      if (tmp___0 == 0) {
#line 1088
        is_alias = (unsigned char)1;
#line 1089
        goto while_break;
      } else {
        {
#line 1086
        tmp___1 = strcmp((char const   *)*(c->argv + 0), (char const   *)*login_name);
        }
#line 1086
        if (tmp___1 == 0) {
#line 1088
          is_alias = (unsigned char)1;
#line 1089
          goto while_break;
        }
      }
      {
#line 1085
      c = find_config_next(c, c->next, 1 << 15, "UserAlias", 1);
      }
#line 1085
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1085
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1097
  topc = c;
  {
#line 1099
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1099
    if (c) {
#line 1099
      if (c->parent) {
        {
#line 1099
        tmp___4 = get_param_ptr((c->parent)->set, "AuthAliasOnly", 0);
#line 1099
        auth_alias_only = (unsigned char *)tmp___4;
        }
#line 1099
        if (! auth_alias_only) {
#line 1099
          goto while_break___0;
        }
      } else {
#line 1099
        goto while_break___0;
      }
    } else {
#line 1099
      goto while_break___0;
    }
    {
#line 1103
    pr_signals_handle();
    }
#line 1106
    if (auth_alias_only) {
#line 1106
      if ((int )*auth_alias_only == 1) {
        {
#line 1108
        c = find_config_next(c, c->next, 1 << 15, "UserAlias", 1);
        }
#line 1109
        goto while_continue___0;
      }
    }
    {
#line 1112
    is_alias = (unsigned char)0;
#line 1114
    find_config_set_top(topc);
#line 1115
    c = find_config_next(c, c->next, 1 << 15, "UserAlias", 1);
    }
#line 1117
    if (c) {
      {
#line 1117
      tmp___2 = strcmp((char const   *)*(c->argv + 0), "*");
      }
#line 1117
      if (tmp___2 == 0) {
#line 1120
        is_alias = (unsigned char)1;
      } else {
        {
#line 1117
        tmp___3 = strcmp((char const   *)*(c->argv + 0), (char const   *)*login_name);
        }
#line 1117
        if (tmp___3 == 0) {
#line 1120
          is_alias = (unsigned char)1;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1123
  if (c) {
#line 1124
    *login_name = (char *)*(c->argv + 1);
#line 1129
    if (c->parent) {
#line 1129
      if ((c->parent)->config_type == 1 << 2) {
#line 1131
        c = c->parent;
      } else {
#line 1133
        c = (config_rec *)((void *)0);
      }
    } else {
#line 1133
      c = (config_rec *)((void *)0);
    }
  }
#line 1138
  if (! c) {
    {
#line 1139
    c = find_config(main_server->conf, 1 << 2, (char const   *)((void *)0), 0);
    }
  } else {
    {
#line 1142
    find_config_set_top(c);
    }
  }
#line 1144
  if (c) {
    {
#line 1145
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1146
      tmp___5 = get_param_ptr(c->subset, "UserName", 0);
#line 1146
      config_anon_name = (char *)tmp___5;
      }
#line 1148
      if (! config_anon_name) {
#line 1149
        config_anon_name = config_user_name;
      }
#line 1151
      if (config_anon_name) {
        {
#line 1151
        tmp___6 = strcmp((char const   *)config_anon_name, (char const   *)*login_name);
        }
#line 1151
        if (tmp___6 == 0) {
#line 1153
          if (anon_name) {
#line 1154
            *anon_name = config_anon_name;
          }
#line 1155
          goto while_break___1;
        }
      }
      {
#line 1145
      c = find_config_next(c, c->next, 1 << 2, (char const   *)((void *)0), 0);
      }
#line 1145
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1145
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1162
  if (! c) {
    {
#line 1163
    c = auth_anonymous_group(p, *login_name);
    }
#line 1165
    if (c) {
#line 1166
      force_anon = (unsigned char)1;
    }
  }
#line 1169
  if (! is_alias) {
#line 1169
    if (! force_anon) {
#line 1170
      if (c) {
#line 1170
        tmp___7 = c->subset;
      } else {
#line 1170
        tmp___7 = main_server->conf;
      }
      {
#line 1170
      tmp___8 = get_param_ptr(tmp___7, "AuthAliasOnly", 0);
#line 1170
      auth_alias_only = (unsigned char *)tmp___8;
      }
#line 1173
      if (auth_alias_only) {
#line 1173
        if ((int )*auth_alias_only == 1) {
#line 1175
          if (c) {
#line 1175
            if (c->config_type == 1 << 2) {
#line 1176
              c = (config_rec *)((void *)0);
            } else {
#line 1178
              *login_name = (char *)((void *)0);
            }
          } else {
#line 1178
            *login_name = (char *)((void *)0);
          }
          {
#line 1180
          tmp___9 = get_param_ptr(main_server->conf, "AuthAliasOnly", 0);
#line 1180
          auth_alias_only = (unsigned char *)tmp___9;
          }
#line 1182
          if (*login_name) {
#line 1182
            if (auth_alias_only) {
#line 1182
              if ((int )*auth_alias_only == 1) {
#line 1185
                *login_name = (char *)((void *)0);
              }
            }
          }
#line 1187
          if (! login_name) {
#line 1187
            goto _L;
          } else
#line 1187
          if (! c) {
            _L: /* CIL Label */ 
#line 1187
            if (anon_name) {
#line 1189
              *anon_name = (char *)((void *)0);
            }
          }
        }
      }
    }
  }
#line 1193
  return (c);
}
}
#line 1196 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_banned_by_ftpusers(xaset_t *ctx , char const   *user ) 
{ 
  int res ;
  unsigned char *use_ftp_users ;
  void *tmp ;
  FILE *fh ;
  char buf___2[256] ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *ptr ;
  unsigned short const   **tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 1197
  res = 0;
#line 1200
  tmp = get_param_ptr(ctx, "UseFtpUsers", 0);
#line 1200
  use_ftp_users = (unsigned char *)tmp;
  }
#line 1202
  if ((unsigned long )use_ftp_users == (unsigned long )((void *)0)) {
#line 1202
    goto _L;
  } else
#line 1202
  if ((int )*use_ftp_users == 1) {
    _L: /* CIL Label */ 
    {
#line 1204
    fh = (FILE *)((void *)0);
#line 1207
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c",
                 1207);
#line 1207
    pr_signals_block();
    }
#line 1207
    if (! session.disable_id_switching) {
      {
#line 1207
      tmp___2 = seteuid((__uid_t )0);
      }
#line 1207
      if (tmp___2) {
        {
#line 1207
        tmp___0 = __errno_location();
#line 1207
        tmp___1 = strerror(*tmp___0);
#line 1207
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___1);
        }
      }
      {
#line 1207
      tmp___5 = setegid((__gid_t )0);
      }
#line 1207
      if (tmp___5) {
        {
#line 1207
        tmp___3 = __errno_location();
#line 1207
        tmp___4 = strerror(*tmp___3);
#line 1207
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___4);
        }
      }
    } else {
      {
#line 1207
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 1207
    pr_signals_unblock();
#line 1208
    fh = fopen((char const   */* __restrict  */)"/etc/ftpusers", (char const   */* __restrict  */)"r");
#line 1209
    pr_signals_block();
    }
#line 1209
    if (! session.disable_id_switching) {
      {
#line 1209
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c",
                   1209);
#line 1209
      tmp___9 = geteuid();
      }
#line 1209
      if (tmp___9 != 0U) {
        {
#line 1209
        tmp___8 = seteuid((__uid_t )0);
        }
#line 1209
        if (tmp___8) {
          {
#line 1209
          tmp___6 = __errno_location();
#line 1209
          tmp___7 = strerror(*tmp___6);
#line 1209
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___7);
          }
        }
      }
      {
#line 1209
      tmp___12 = setegid(session.gid);
      }
#line 1209
      if (tmp___12) {
        {
#line 1209
        tmp___10 = __errno_location();
#line 1209
        tmp___11 = strerror(*tmp___10);
#line 1209
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___11);
        }
      }
      {
#line 1209
      tmp___15 = seteuid(session.uid);
      }
#line 1209
      if (tmp___15) {
        {
#line 1209
        tmp___13 = __errno_location();
#line 1209
        tmp___14 = strerror(*tmp___13);
#line 1209
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___14);
        }
      }
    } else {
      {
#line 1209
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 1209
    pr_signals_unblock();
    }
#line 1211
    if ((unsigned long )fh == (unsigned long )((void *)0)) {
#line 1212
      return (res);
    }
    {
#line 1214
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
    }
    {
#line 1216
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1216
      tmp___18 = fgets((char */* __restrict  */)(buf___2), (int )(sizeof(buf___2) - 1UL),
                       (FILE */* __restrict  */)fh);
      }
#line 1216
      if (! tmp___18) {
#line 1216
        goto while_break;
      }
      {
#line 1219
      pr_signals_handle();
#line 1221
      buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 1222
      pr_str_strip_end(buf___2, (char *)"\r\n");
#line 1224
      ptr = buf___2;
      }
      {
#line 1225
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1225
        tmp___16 = __ctype_b_loc();
        }
#line 1225
        if ((int const   )*(*tmp___16 + (int )*ptr) & 8192) {
#line 1225
          if (! *ptr) {
#line 1225
            goto while_break___0;
          }
        } else {
#line 1225
          goto while_break___0;
        }
#line 1226
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1229
      if (! *ptr) {
#line 1231
        goto while_continue;
      } else
#line 1229
      if ((int )*ptr == 35) {
#line 1231
        goto while_continue;
      }
      {
#line 1234
      tmp___17 = strcmp((char const   *)ptr, user);
      }
#line 1234
      if (tmp___17 == 0) {
#line 1235
        res = 1;
#line 1236
        goto while_break;
      }
      {
#line 1239
      memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1242
    fclose(fh);
    }
  }
#line 1245
  return (res);
}
}
#line 1248 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_is_valid_shell(xaset_t *ctx , char const   *shell ) 
{ 
  int res ;
  unsigned char *require_valid_shell ;
  void *tmp ;
  FILE *fh ;
  char buf___2[256] ;
  int tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1249
  res = 1;
#line 1252
  if ((unsigned long )shell == (unsigned long )((void *)0)) {
#line 1253
    return (res);
  }
  {
#line 1255
  tmp = get_param_ptr(ctx, "RequireValidShell", 0);
#line 1255
  require_valid_shell = (unsigned char *)tmp;
  }
#line 1257
  if ((unsigned long )require_valid_shell == (unsigned long )((void *)0)) {
#line 1257
    goto _L;
  } else
#line 1257
  if ((int )*require_valid_shell == 1) {
    _L: /* CIL Label */ 
    {
#line 1259
    fh = (FILE *)((void *)0);
#line 1262
    fh = fopen((char const   */* __restrict  */)"/etc/shells", (char const   */* __restrict  */)"r");
    }
#line 1263
    if ((unsigned long )fh == (unsigned long )((void *)0)) {
#line 1264
      return (res);
    }
    {
#line 1266
    res = 0;
#line 1267
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
    }
    {
#line 1269
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1269
      tmp___1 = fgets((char */* __restrict  */)(buf___2), (int )(sizeof(buf___2) - 1UL),
                      (FILE */* __restrict  */)fh);
      }
#line 1269
      if (! tmp___1) {
#line 1269
        goto while_break;
      }
      {
#line 1270
      pr_signals_handle();
#line 1272
      buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 1273
      pr_str_strip_end(buf___2, (char *)"\r\n");
#line 1275
      tmp___0 = strcmp((char const   *)(buf___2), shell);
      }
#line 1275
      if (tmp___0 == 0) {
#line 1276
        res = 1;
#line 1277
        goto while_break;
      }
      {
#line 1280
      memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1283
    fclose(fh);
    }
  }
#line 1286
  return (res);
}
}
#line 1289 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_chroot(char const   *path ) 
{ 
  int res ;
  char *tz ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 1296
  tz = pr_env_get(session.pool, "TZ");
  }
#line 1297
  if ((unsigned long )tz == (unsigned long )((void *)0)) {
    {
#line 1298
    tmp___1 = pstrdup(permanent_pool, (char const   *)tzname[0]);
#line 1298
    tmp___2 = pr_env_set(session.pool, "TZ", (char const   *)tmp___1);
    }
#line 1298
    if (tmp___2 < 0) {
      {
#line 1300
      tmp = __errno_location();
#line 1300
      tmp___0 = strerror(*tmp);
#line 1300
      pr_log_debug(0, "error setting TZ environment variable to \'%s\': %s", tzname[0],
                   tmp___0);
      }
    } else {
      {
#line 1304
      pr_log_debug(10, "set TZ environment variable to \'%s\'", tzname[0]);
      }
    }
  }
  {
#line 1309
  pr_log_pri(6, "Preparing to chroot to directory \'%s\'", path);
#line 1311
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c",
               1311);
#line 1311
  pr_signals_block();
  }
#line 1311
  if (! session.disable_id_switching) {
    {
#line 1311
    tmp___5 = seteuid((__uid_t )0);
    }
#line 1311
    if (tmp___5) {
      {
#line 1311
      tmp___3 = __errno_location();
#line 1311
      tmp___4 = strerror(*tmp___3);
#line 1311
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___4);
      }
    }
    {
#line 1311
    tmp___8 = setegid((__gid_t )0);
    }
#line 1311
    if (tmp___8) {
      {
#line 1311
      tmp___6 = __errno_location();
#line 1311
      tmp___7 = strerror(*tmp___6);
#line 1311
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___7);
      }
    }
  } else {
    {
#line 1311
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 1311
  pr_signals_unblock();
#line 1312
  res = pr_fsio_chroot(path);
#line 1313
  pr_signals_block();
  }
#line 1313
  if (! session.disable_id_switching) {
    {
#line 1313
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c",
                 1313);
#line 1313
    tmp___12 = geteuid();
    }
#line 1313
    if (tmp___12 != 0U) {
      {
#line 1313
      tmp___11 = seteuid((__uid_t )0);
      }
#line 1313
      if (tmp___11) {
        {
#line 1313
        tmp___9 = __errno_location();
#line 1313
        tmp___10 = strerror(*tmp___9);
#line 1313
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___10);
        }
      }
    }
    {
#line 1313
    tmp___15 = setegid(session.gid);
    }
#line 1313
    if (tmp___15) {
      {
#line 1313
      tmp___13 = __errno_location();
#line 1313
      tmp___14 = strerror(*tmp___13);
#line 1313
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___14);
      }
    }
    {
#line 1313
    tmp___18 = seteuid(session.uid);
    }
#line 1313
    if (tmp___18) {
      {
#line 1313
      tmp___16 = __errno_location();
#line 1313
      tmp___17 = strerror(*tmp___16);
#line 1313
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___17);
      }
    }
  } else {
    {
#line 1313
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 1313
  pr_signals_unblock();
  }
#line 1315
  if (res < 0) {
    {
#line 1316
    tmp___19 = __errno_location();
#line 1316
    tmp___20 = strerror(*tmp___19);
#line 1316
    pr_log_pri(3, "chroot to \'%s\' failed for user \'%s\': %s", path, session.user,
               tmp___20);
    }
#line 1318
    return (-1);
  }
  {
#line 1321
  pr_log_debug(1, "Environment successfully chroot()ed");
  }
#line 1322
  return (0);
}
}
#line 1325 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int set_groups(pool *p , gid_t primary_gid , array_header *suppl_gids ) 
{ 
  int res ;
  pool *tmp_pool ;
  register unsigned int i___0 ;
  gid_t *gids ;
  gid_t *proc_gids ;
  size_t ngids ;
  size_t nproc_gids ;
  char *strgids ;
  void *tmp ;
  size_t tmp___0 ;
  register unsigned int j ;
  unsigned char skip_gid ;
  size_t tmp___1 ;
  char buf___2[64] ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 1326
  res = 0;
#line 1327
  tmp_pool = (pool *)((void *)0);
#line 1330
  i___0 = 0U;
#line 1331
  gids = (gid_t *)((void *)0);
#line 1331
  proc_gids = (gid_t *)((void *)0);
#line 1332
  ngids = (size_t )0;
#line 1332
  nproc_gids = (size_t )0;
#line 1333
  strgids = (char *)"";
#line 1336
  if (! p) {
#line 1337
    return (0);
  } else
#line 1336
  if (! suppl_gids) {
#line 1337
    return (0);
  }
  {
#line 1339
  tmp_pool = make_sub_pool(p);
#line 1340
  pr_pool_tag(tmp_pool, "set_groups() tmp pool");
  }
#line 1343
  if (suppl_gids) {
#line 1344
    ngids = (size_t )suppl_gids->nelts;
#line 1345
    gids = (gid_t *)suppl_gids->elts;
#line 1347
    if (ngids) {
#line 1347
      if (gids) {
        {
#line 1348
        tmp = pcalloc(tmp_pool, (int )(sizeof(gid_t ) * (unsigned long )ngids));
#line 1348
        proc_gids = (gid_t *)tmp;
#line 1355
        tmp___0 = nproc_gids;
#line 1355
        nproc_gids ++;
#line 1355
        *(proc_gids + tmp___0) = *(gids + 0);
        }
      }
    }
  }
#line 1359
  i___0 = 1U;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    if (! (i___0 < ngids)) {
#line 1359
      goto while_break;
    }
#line 1360
    j = 0U;
#line 1361
    skip_gid = (unsigned char)0;
#line 1366
    j = 0U;
    {
#line 1366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1366
      if (! (j < nproc_gids)) {
#line 1366
        goto while_break___0;
      }
#line 1367
      if (*(proc_gids + j) == *(gids + i___0)) {
#line 1368
        skip_gid = (unsigned char)1;
#line 1369
        goto while_break___0;
      }
#line 1366
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1373
    if (! skip_gid) {
#line 1374
      tmp___1 = nproc_gids;
#line 1374
      nproc_gids ++;
#line 1374
      *(proc_gids + tmp___1) = *(gids + i___0);
    }
#line 1359
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1377
  i___0 = 0U;
  {
#line 1377
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1377
    if (! (i___0 < nproc_gids)) {
#line 1377
      goto while_break___1;
    }
    {
#line 1379
    snprintf((char */* __restrict  */)(buf___2), (size_t )(sizeof(buf___2) - 1UL),
             (char const   */* __restrict  */)"%lu", (unsigned long )*(proc_gids + i___0));
#line 1380
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
    }
#line 1382
    if (i___0 != 0U) {
#line 1382
      tmp___2 = ", ";
    } else {
#line 1382
      tmp___2 = "";
    }
    {
#line 1382
    strgids = pstrcat(p, strgids, tmp___2, buf___2, (void *)0);
#line 1377
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1385
  if (nproc_gids == 1U) {
#line 1385
    tmp___3 = "ID";
  } else {
#line 1385
    tmp___3 = "IDs";
  }
  {
#line 1385
  pr_log_debug(10, "setting group %s: %s", tmp___3, strgids);
#line 1389
  res = setgroups(nproc_gids, (__gid_t const   *)proc_gids);
  }
#line 1390
  if (res < 0) {
    {
#line 1391
    destroy_pool(tmp_pool);
    }
#line 1392
    return (res);
  }
  {
#line 1399
  res = setgid(primary_gid);
  }
#line 1400
  if (res < 0) {
#line 1401
    if (tmp_pool) {
      {
#line 1402
      destroy_pool(tmp_pool);
      }
    }
#line 1403
    return (res);
  }
#line 1407
  if (tmp_pool) {
    {
#line 1408
    destroy_pool(tmp_pool);
    }
  }
#line 1410
  return (res);
}
}
#line 1413 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_cache_set(int bool , unsigned int flags ) 
{ 
  int *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1414
  if (bool != 0) {
#line 1414
    if (bool != 1) {
      {
#line 1416
      tmp = __errno_location();
#line 1416
      *tmp = 22;
      }
#line 1417
      return (-1);
    }
  }
#line 1420
  if (bool == 0) {
#line 1421
    if (flags & 1U) {
      {
#line 1422
      auth_caching &= 4294967294U;
#line 1423
      pr_trace_msg(trace_channel___3, 7, "UID-to-name caching (uidcache) disabled");
      }
    }
#line 1426
    if (flags & 2U) {
      {
#line 1427
      auth_caching &= 4294967293U;
#line 1428
      pr_trace_msg(trace_channel___3, 7, "GID-to-name caching (gidcache) disabled");
      }
    }
#line 1431
    if (flags & 4U) {
      {
#line 1432
      auth_caching &= 4294967291U;
#line 1433
      pr_trace_msg(trace_channel___3, 7, "auth module caching (authcache) disabled");
      }
    }
  }
#line 1438
  if (bool == 1) {
#line 1439
    if (flags & 1U) {
      {
#line 1440
      auth_caching |= 1U;
#line 1441
      pr_trace_msg(trace_channel___3, 7, "UID-to-name caching (uidcache) enabled");
      }
    }
#line 1444
    if (flags & 2U) {
      {
#line 1445
      auth_caching |= 2U;
#line 1446
      pr_trace_msg(trace_channel___3, 7, "GID-to-name caching (gidcache) enabled");
      }
    }
#line 1449
    if (flags & 4U) {
      {
#line 1450
      auth_caching &= 4294967291U;
#line 1451
      pr_trace_msg(trace_channel___3, 7, "auth module caching (authcache) enabled");
      }
    }
  }
#line 1455
  return (0);
}
}
#line 1458 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int pr_auth_add_auth_only_module(char const   *name ) 
{ 
  struct auth_module_elt *elt ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1459
  elt = (struct auth_module_elt *)((void *)0);
#line 1461
  if (! name) {
    {
#line 1462
    tmp = __errno_location();
#line 1462
    *tmp = 22;
    }
#line 1463
    return (-1);
  }
#line 1466
  if (! auth_pool) {
    {
#line 1467
    auth_pool = make_sub_pool(permanent_pool);
#line 1468
    pr_pool_tag(auth_pool, "Auth API");
    }
  }
#line 1471
  if (! (auth_caching & 4U)) {
    {
#line 1475
    pr_trace_msg(trace_channel___3, 9, "not adding \'%s\' to the auth-only list: caching of auth-only modules disabled",
                 name);
    }
#line 1477
    return (0);
  }
#line 1480
  if (! auth_module_list) {
    {
#line 1481
    auth_module_list = xaset_create(auth_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
#line 1484
  elt = (struct auth_module_elt *)auth_module_list->xas_list;
  {
#line 1484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1484
    if (! elt) {
#line 1484
      goto while_break;
    }
    {
#line 1486
    tmp___1 = strcmp(elt->name, name);
    }
#line 1486
    if (tmp___1 == 0) {
      {
#line 1487
      tmp___0 = __errno_location();
#line 1487
      *tmp___0 = 17;
      }
#line 1488
      return (-1);
    }
#line 1484
    elt = elt->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1492
  tmp___2 = pcalloc(auth_pool, (int )sizeof(struct auth_module_elt ));
#line 1492
  elt = (struct auth_module_elt *)tmp___2;
#line 1493
  tmp___3 = pstrdup(auth_pool, name);
#line 1493
  elt->name = (char const   *)tmp___3;
#line 1494
  xaset_insert_end(auth_module_list, (xasetmember_t *)elt);
#line 1496
  pr_trace_msg(trace_channel___3, 5, "added \'%s\' to auth-only module list", name);
  }
#line 1498
  return (0);
}
}
#line 1502 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/auth.c"
int init_auth(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 1503
  if (! auth_pool) {
    {
#line 1504
    auth_pool = make_sub_pool(permanent_pool);
#line 1505
    pr_pool_tag(auth_pool, "Auth API");
    }
  }
#line 1508
  return (0);
}
}
#line 94 "../include/support.h"
char const   *pr_strtime(time_t t ) ;
#line 330 "../include/netaddr.h"
char const   *pr_netaddr_get_dnsstr(pr_netaddr_t *na ) ;
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/display.c"
static void format_size_str(char *buf___2 , size_t buflen , off_t___0 size ) 
{ 
  char units___0[5] ;
  register unsigned int i___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 33
  units___0[0] = (char )'K';
#line 33
  units___0[1] = (char )'M';
#line 33
  units___0[2] = (char )'G';
#line 33
  units___0[3] = (char )'T';
#line 33
  units___0[4] = (char )'P';
#line 34
  i___0 = 0U;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (size > 1024LL)) {
#line 37
      goto while_break;
    }
#line 38
    size /= 1024LL;
#line 39
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  snprintf((char */* __restrict  */)buf___2, buflen, (char const   */* __restrict  */)"%.3llu%cB",
           (unsigned long long )size, (int )units___0[i___0]);
  }
#line 44
  return;
}
}
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/display.c"
static int display_fh(pr_fh_t *fh , char const   *fs , char const   *code ) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  int len ;
  unsigned int *current_clients ;
  unsigned int *max_clients ;
  off_t___0 fs_size ;
  pool *p ;
  xaset_t *s ;
  config_rec *c ;
  char const   *serverfqdn ;
  char *outs ;
  char mg_size[12] ;
  unsigned int tmp___0 ;
  char mg_size_units[12] ;
  unsigned int tmp___1 ;
  char mg_max[12] ;
  unsigned int tmp___2 ;
  char total_files_in[12] ;
  unsigned int tmp___3 ;
  char total_files_out[12] ;
  unsigned int tmp___4 ;
  char total_files_xfer[12] ;
  unsigned int tmp___5 ;
  char mg_class_limit[12] ;
  unsigned int tmp___6 ;
  char mg_cur[12] ;
  unsigned int tmp___7 ;
  char mg_xfer_bytes[12] ;
  unsigned int tmp___8 ;
  char mg_cur_class[12] ;
  unsigned int tmp___9 ;
  char mg_xfer_units[12] ;
  unsigned int tmp___10 ;
  char config_class_users[128] ;
  unsigned int tmp___11 ;
  char *user ;
  char const   *mg_time ;
  char *rfc1413_ident ;
  unsigned char first ;
  char *tmp___12 ;
  time_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int *class_users ;
  config_rec *maxc ;
  unsigned int maxclients ;
  void *tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  void *tmp___22 ;
  pr_netaddr_t *masq_addr ;
  void *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  char *key ;
  char *tmp2 ;
  char const   *val ;
  char time_str[128] ;
  char *fmt ;
  time_t now ;
  struct tm *time_info ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *env_var ;
  size_t tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char *tmp___35 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  void *__cil_tmp90 ;
  void *__cil_tmp91 ;
  void *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;

  {
#line 47
  buf___2[0] = (char )'\000';
#line 47
  tmp = 1U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (tmp >= 1024U) {
#line 47
      goto while_break;
    }
#line 47
    buf___2[tmp] = (char)0;
#line 47
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  current_clients = (unsigned int *)((void *)0);
#line 50
  max_clients = (unsigned int *)((void *)0);
#line 51
  fs_size = (off_t___0 )0;
#line 54
  c = (config_rec *)((void *)0);
#line 55
  serverfqdn = main_server->ServerFQDN;
#line 56
  mg_size[0] = (char )'\000';
#line 56
  tmp___0 = 1U;
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (tmp___0 >= 12U) {
#line 56
      goto while_break___0;
    }
#line 56
    mg_size[tmp___0] = (char)0;
#line 56
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  mg_size_units[0] = (char )'\000';
#line 56
  tmp___1 = 1U;
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 56
    if (tmp___1 >= 12U) {
#line 56
      goto while_break___1;
    }
#line 56
    mg_size_units[tmp___1] = (char)0;
#line 56
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 56
  mg_max[0] = (char )'u';
#line 56
  mg_max[1] = (char )'n';
#line 56
  mg_max[2] = (char )'l';
#line 56
  mg_max[3] = (char )'i';
#line 56
  mg_max[4] = (char )'m';
#line 56
  mg_max[5] = (char )'i';
#line 56
  mg_max[6] = (char )'t';
#line 56
  mg_max[7] = (char )'e';
#line 56
  mg_max[8] = (char )'d';
#line 56
  mg_max[9] = (char )'\000';
#line 56
  tmp___2 = 10U;
  {
#line 56
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 56
    if (tmp___2 >= 12U) {
#line 56
      goto while_break___2;
    }
#line 56
    mg_max[tmp___2] = (char)0;
#line 56
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 58
  total_files_in[0] = (char )'\000';
#line 58
  tmp___3 = 1U;
  {
#line 58
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 58
    if (tmp___3 >= 12U) {
#line 58
      goto while_break___3;
    }
#line 58
    total_files_in[tmp___3] = (char)0;
#line 58
    tmp___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 58
  total_files_out[0] = (char )'\000';
#line 58
  tmp___4 = 1U;
  {
#line 58
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 58
    if (tmp___4 >= 12U) {
#line 58
      goto while_break___4;
    }
#line 58
    total_files_out[tmp___4] = (char)0;
#line 58
    tmp___4 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 58
  total_files_xfer[0] = (char )'\000';
#line 58
  tmp___5 = 1U;
  {
#line 58
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 58
    if (tmp___5 >= 12U) {
#line 58
      goto while_break___5;
    }
#line 58
    total_files_xfer[tmp___5] = (char)0;
#line 58
    tmp___5 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 60
  mg_class_limit[0] = (char )'\000';
#line 60
  tmp___6 = 1U;
  {
#line 60
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 60
    if (tmp___6 >= 12U) {
#line 60
      goto while_break___6;
    }
#line 60
    mg_class_limit[tmp___6] = (char)0;
#line 60
    tmp___6 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 60
  mg_cur[0] = (char )'\000';
#line 60
  tmp___7 = 1U;
  {
#line 60
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 60
    if (tmp___7 >= 12U) {
#line 60
      goto while_break___7;
    }
#line 60
    mg_cur[tmp___7] = (char)0;
#line 60
    tmp___7 ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 60
  mg_xfer_bytes[0] = (char )'\000';
#line 60
  tmp___8 = 1U;
  {
#line 60
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 60
    if (tmp___8 >= 12U) {
#line 60
      goto while_break___8;
    }
#line 60
    mg_xfer_bytes[tmp___8] = (char)0;
#line 60
    tmp___8 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 60
  mg_cur_class[0] = (char )'\000';
#line 60
  tmp___9 = 1U;
  {
#line 60
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 60
    if (tmp___9 >= 12U) {
#line 60
      goto while_break___9;
    }
#line 60
    mg_cur_class[tmp___9] = (char)0;
#line 60
    tmp___9 ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 62
  mg_xfer_units[0] = (char )'\000';
#line 62
  tmp___10 = 1U;
  {
#line 62
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 62
    if (tmp___10 >= 12U) {
#line 62
      goto while_break___10;
    }
#line 62
    mg_xfer_units[tmp___10] = (char)0;
#line 62
    tmp___10 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 62
  config_class_users[0] = (char )'\000';
#line 62
  tmp___11 = 1U;
  {
#line 62
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 62
    if (tmp___11 >= 128U) {
#line 62
      goto while_break___11;
    }
#line 62
    config_class_users[tmp___11] = (char)0;
#line 62
    tmp___11 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 64
  rfc1413_ident = (char *)((void *)0);
#line 65
  first = (unsigned char)1;
#line 69
  if (fs) {
#line 69
    tmp___12 = (char *)fs;
  } else {
#line 69
    tmp___12 = fh->fh_path;
  }
  {
#line 69
  fs_size = pr_fs_getsize(tmp___12);
#line 70
  snprintf((char */* __restrict  */)(mg_size), (size_t )sizeof(mg_size), (char const   */* __restrict  */)"%llu",
           (unsigned long long )fs_size);
#line 71
  format_size_str(mg_size_units, (size_t )sizeof(mg_size_units), fs_size);
#line 77
  p = make_sub_pool(session.pool);
#line 78
  pr_pool_tag(p, "Display Pool");
  }
#line 80
  if (session.anon_config) {
#line 80
    s = (session.anon_config)->subset;
  } else {
#line 80
    s = main_server->conf;
  }
  {
#line 82
  tmp___13 = time((time_t *)((void *)0));
#line 82
  mg_time = pr_strtime(tmp___13);
#line 84
  tmp___14 = get_param_ptr(s, "MaxClients", 0);
#line 84
  max_clients = (unsigned int *)tmp___14;
#line 86
  tmp___15 = get_param_ptr(main_server->conf, "CURRENT-CLIENTS", 0);
#line 86
  current_clients = (unsigned int *)tmp___15;
  }
#line 88
  if (current_clients) {
#line 88
    tmp___16 = *current_clients;
  } else {
#line 88
    tmp___16 = 1U;
  }
  {
#line 88
  snprintf((char */* __restrict  */)(mg_cur), (size_t )sizeof(mg_cur), (char const   */* __restrict  */)"%u",
           tmp___16);
  }
#line 90
  if (session.class) {
#line 90
    if ((session.class)->cls_name) {
      {
#line 91
      class_users = (unsigned int *)((void *)0);
#line 92
      maxc = (config_rec *)((void *)0);
#line 93
      maxclients = 0U;
#line 95
      snprintf((char */* __restrict  */)(config_class_users), (size_t )sizeof(config_class_users),
               (char const   */* __restrict  */)"CURRENT-CLIENTS-CLASS-%s", (session.class)->cls_name);
#line 98
      tmp___17 = get_param_ptr(main_server->conf, (char const   *)(config_class_users),
                               0);
#line 98
      class_users = (unsigned int *)tmp___17;
      }
#line 100
      if (class_users) {
#line 100
        tmp___18 = *class_users;
      } else {
#line 100
        tmp___18 = 0U;
      }
      {
#line 100
      snprintf((char */* __restrict  */)(mg_cur_class), (size_t )sizeof(mg_cur_class),
               (char const   */* __restrict  */)"%u", tmp___18);
#line 108
      maxc = find_config(main_server->conf, 1 << 15, "MaxClientsPerClass", 0);
      }
      {
#line 111
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 111
        if (! maxc) {
#line 111
          goto while_break___12;
        }
        {
#line 112
        tmp___19 = strcmp((char const   *)*(maxc->argv + 0), (char const   *)(session.class)->cls_name);
        }
#line 112
        if (tmp___19 != 0) {
          {
#line 113
          maxc = find_config_next(maxc, maxc->next, 1 << 15, "MaxClientsPerClass",
                                  0);
          }
#line 115
          goto while_continue___12;
        }
#line 118
        maxclients = *((unsigned int *)*(maxc->argv + 1));
#line 119
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 122
      if (maxclients == 0U) {
        {
#line 123
        maxc = find_config(main_server->conf, 1 << 15, "MaxClients", 0);
        }
#line 125
        if (maxc) {
#line 126
          maxclients = *((unsigned int *)*(maxc->argv + 0));
        }
      }
      {
#line 129
      snprintf((char */* __restrict  */)(mg_class_limit), (size_t )sizeof(mg_class_limit),
               (char const   */* __restrict  */)"%u", maxclients);
      }
    } else {
#line 90
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 132
    mg_cur_class[0] = (char)0;
#line 133
    if (max_clients) {
#line 133
      tmp___20 = *max_clients;
    } else {
#line 133
      tmp___20 = 0U;
    }
    {
#line 133
    snprintf((char */* __restrict  */)(mg_class_limit), (size_t )sizeof(mg_class_limit),
             (char const   */* __restrict  */)"%u", tmp___20);
#line 135
    snprintf((char */* __restrict  */)(mg_cur_class), (size_t )sizeof(mg_cur_class),
             (char const   */* __restrict  */)"%u", 0);
    }
  }
  {
#line 138
  snprintf((char */* __restrict  */)(mg_xfer_bytes), (size_t )sizeof(mg_xfer_bytes),
           (char const   */* __restrict  */)"%llu", (unsigned long long )session.total_bytes >> 10);
#line 140
  snprintf((char */* __restrict  */)(mg_xfer_units), (size_t )sizeof(mg_xfer_units),
           (char const   */* __restrict  */)"%lluB", (unsigned long long )session.total_bytes);
  }
#line 143
  if (session.total_bytes >= 10240LL) {
    {
#line 144
    snprintf((char */* __restrict  */)(mg_xfer_units), (size_t )sizeof(mg_xfer_units),
             (char const   */* __restrict  */)"%llukB", (unsigned long long )session.total_bytes >> 10);
    }
  } else
#line 147
  if (session.total_bytes >> 10 >= 10240LL) {
    {
#line 148
    snprintf((char */* __restrict  */)(mg_xfer_units), (size_t )sizeof(mg_xfer_units),
             (char const   */* __restrict  */)"%lluMB", (unsigned long long )session.total_bytes >> 20);
    }
  } else
#line 151
  if (session.total_bytes >> 20 >= 10240LL) {
    {
#line 152
    snprintf((char */* __restrict  */)(mg_xfer_units), (size_t )sizeof(mg_xfer_units),
             (char const   */* __restrict  */)"%lluGB", (unsigned long long )session.total_bytes >> 30);
    }
  }
#line 156
  if (max_clients) {
#line 156
    tmp___21 = *max_clients;
  } else {
#line 156
    tmp___21 = 0U;
  }
  {
#line 156
  snprintf((char */* __restrict  */)(mg_max), (size_t )sizeof(mg_max), (char const   */* __restrict  */)"%u",
           tmp___21);
#line 158
  tmp___22 = get_param_ptr(main_server->conf, "USER", 0);
#line 158
  user = (char *)tmp___22;
  }
#line 159
  if ((unsigned long )user == (unsigned long )((void *)0)) {
#line 160
    user = (char *)"";
  }
  {
#line 162
  c = find_config(main_server->conf, 1 << 15, "MasqueradeAddress", 0);
  }
#line 163
  if (c) {
    {
#line 164
    masq_addr = (pr_netaddr_t *)*(c->argv + 0);
#line 165
    serverfqdn = pr_netaddr_get_dnsstr(masq_addr);
    }
  }
  {
#line 169
  snprintf((char */* __restrict  */)(total_files_in), (size_t )sizeof(total_files_in),
           (char const   */* __restrict  */)"%u", session.total_files_in);
#line 171
  total_files_in[sizeof(total_files_in) - 1UL] = (char )'\000';
#line 173
  snprintf((char */* __restrict  */)(total_files_out), (size_t )sizeof(total_files_out),
           (char const   */* __restrict  */)"%u", session.total_files_out);
#line 175
  total_files_out[sizeof(total_files_out) - 1UL] = (char )'\000';
#line 177
  snprintf((char */* __restrict  */)(total_files_xfer), (size_t )sizeof(total_files_xfer),
           (char const   */* __restrict  */)"%u", session.total_files_xfer);
#line 179
  total_files_xfer[sizeof(total_files_xfer) - 1UL] = (char )'\000';
#line 181
  tmp___23 = pr_table_get(session.notes, "mod_ident.rfc1413-ident", (size_t *)((void *)0));
#line 181
  rfc1413_ident = (char *)tmp___23;
  }
#line 182
  if ((unsigned long )rfc1413_ident == (unsigned long )((void *)0)) {
#line 183
    rfc1413_ident = (char *)"UNKNOWN";
  }
  {
#line 186
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 186
    tmp___35 = pr_fsio_gets(buf___2, (size_t )sizeof(buf___2), fh);
    }
#line 186
    if (! ((unsigned long )tmp___35 != (unsigned long )((void *)0))) {
#line 186
      goto while_break___13;
    }
    {
#line 189
    pr_signals_handle();
#line 191
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 192
    tmp___25 = strlen((char const   *)(buf___2));
#line 192
    len = (int )tmp___25;
    }
    {
#line 194
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 194
      if (len) {
#line 194
        if (! ((int )buf___2[len - 1] == 13)) {
#line 194
          if (! ((int )buf___2[len - 1] == 10)) {
#line 194
            goto while_break___14;
          }
        }
      } else {
#line 194
        goto while_break___14;
      }
#line 195
      buf___2[len - 1] = (char )'\000';
#line 196
      len --;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 200
    tmp___24 = strstr((char const   *)(buf___2), "%{");
    }
    {
#line 201
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 201
      if (! tmp___24) {
#line 201
        goto while_break___15;
      }
      {
#line 205
      pr_signals_handle();
#line 207
      tmp2 = strchr((char const   *)tmp___24, '}');
      }
#line 208
      if (! tmp2) {
        {
#line 209
        tmp___24 = strstr((char const   *)(tmp___24 + 1), "%{");
        }
#line 210
        goto while_continue___15;
      }
      {
#line 213
      key = pstrndup(p, (char const   *)tmp___24, (size_t )((tmp2 - tmp___24) + 1L));
#line 225
      tmp___31 = strncmp((char const   *)key, "%{time:", (size_t )7);
      }
#line 225
      if (tmp___31 == 0) {
        {
#line 230
        tmp___26 = strlen((char const   *)key);
#line 230
        fmt = pstrndup(p, (char const   *)(key + 7), tmp___26 - 8U);
#line 232
        now = time((time_t *)((void *)0));
#line 233
        time_info = pr_localtime((pool *)((void *)0), (time_t const   *)(& now));
#line 235
        memset((void *)(time_str), 0, (size_t )sizeof(time_str));
#line 236
        strftime((char */* __restrict  */)(time_str), (size_t )sizeof(time_str), (char const   */* __restrict  */)fmt,
                 (struct tm  const  */* __restrict  */)time_info);
#line 238
        tmp___27 = pstrdup(p, (char const   *)(time_str));
#line 238
        val = (char const   *)tmp___27;
        }
      } else {
        {
#line 240
        tmp___30 = strncmp((char const   *)key, "%{env:", (size_t )6);
        }
#line 240
        if (tmp___30 == 0) {
          {
#line 243
          tmp___28 = strlen((char const   *)key);
#line 243
          env_var = pstrndup(p, (char const   *)(key + 6), tmp___28 - 7U);
#line 244
          tmp___29 = pr_env_get(p, (char const   *)env_var);
#line 244
          val = (char const   *)tmp___29;
          }
#line 245
          if ((unsigned long )val == (unsigned long )((void *)0)) {
            {
#line 246
            pr_trace_msg("var", 4, "no value set for environment variable \'%s\', using \"(none)\"",
                         env_var);
#line 249
            val = "(none)";
            }
          }
        } else {
          {
#line 253
          val = pr_var_get((char const   *)key);
          }
#line 254
          if ((unsigned long )val == (unsigned long )((void *)0)) {
            {
#line 255
            pr_trace_msg("var", 4, "no value set for name \'%s\', using \"(none)\"",
                         key);
#line 257
            val = "(none)";
            }
          }
        }
      }
      {
#line 261
      outs = sreplace(p, buf___2, key, val, (void *)0);
#line 262
      sstrncpy(buf___2, (char const   *)outs, (size_t )sizeof(buf___2));
#line 264
      tmp___24 = strstr((char const   *)outs, "%{");
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 267
    if (session.class) {
#line 267
      tmp___32 = (char const   *)(session.class)->cls_name;
    } else {
#line 267
      tmp___32 = "(unknown)";
    }
#line 267
    if (session.c) {
#line 267
      if ((session.c)->remote_name) {
#line 267
        tmp___33 = (session.c)->remote_name;
      } else {
#line 267
        tmp___33 = "(unknown)";
      }
    } else {
#line 267
      tmp___33 = "(unknown)";
    }
#line 267
    if (session.cwd[0]) {
#line 267
      tmp___34 = (char const   *)(session.cwd);
    } else {
#line 267
      tmp___34 = "(none)";
    }
    {
#line 267
    outs = sreplace(p, buf___2, "%C", tmp___34, "%E", main_server->ServerAdmin, "%F",
                    mg_size, "%f", mg_size_units, "%i", total_files_in, "%K", mg_xfer_bytes,
                    "%k", mg_xfer_units, "%L", serverfqdn, "%M", mg_max, "%N", mg_cur,
                    "%o", total_files_out, "%R", tmp___33, "%T", mg_time, "%t", total_files_xfer,
                    "%U", user, "%u", rfc1413_ident, "%V", main_server->ServerName,
                    "%x", tmp___32, "%y", mg_cur_class, "%z", mg_class_limit, (void *)0);
#line 291
    sstrncpy(buf___2, (char const   *)outs, (size_t )sizeof(buf___2));
    }
#line 293
    if (first) {
      {
#line 294
      pr_response_send_raw("%s-%s", code, outs);
#line 295
      first = (unsigned char)0;
      }
    } else
#line 298
    if (MultilineRFC2228) {
      {
#line 299
      pr_response_send_raw("%s-%s", code, outs);
      }
    } else {
      {
#line 301
      pr_response_send_raw(" %s", outs);
      }
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 305
  destroy_pool(p);
  }
#line 306
  return (0);
}
}
#line 309 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/display.c"
int pr_display_fh(struct fh_rec *fh , char const   *fs , char const   *code ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 310
  if (! fh) {
    {
#line 311
    tmp = __errno_location();
#line 311
    *tmp = 22;
    }
#line 312
    return (-1);
  } else
#line 310
  if (! code) {
    {
#line 311
    tmp = __errno_location();
#line 311
    *tmp = 22;
    }
#line 312
    return (-1);
  }
  {
#line 315
  tmp___0 = display_fh(fh, fs, code);
  }
#line 315
  return (tmp___0);
}
}
#line 318 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/display.c"
int pr_display_file(char const   *path , char const   *fs , char const   *code ) 
{ 
  pr_fh_t *fh ;
  int res ;
  int xerrno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 319
  fh = (pr_fh_t *)((void *)0);
#line 322
  if (! path) {
    {
#line 323
    tmp = __errno_location();
#line 323
    *tmp = 22;
    }
#line 324
    return (-1);
  } else
#line 322
  if (! code) {
    {
#line 323
    tmp = __errno_location();
#line 323
    *tmp = 22;
    }
#line 324
    return (-1);
  }
  {
#line 327
  fh = pr_fsio_open_canon(path, 0);
  }
#line 328
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
#line 329
    return (-1);
  }
  {
#line 331
  res = display_fh(fh, fs, code);
#line 332
  tmp___0 = __errno_location();
#line 332
  xerrno = *tmp___0;
#line 334
  pr_fsio_close(fh);
#line 336
  tmp___1 = __errno_location();
#line 336
  *tmp___1 = xerrno;
  }
#line 337
  return (res);
}
}
#line 337 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 56 "../include/sets.h"
int xaset_insert_sort(xaset_t *set , xasetmember_t *member , int dups_allowed ) ;
#line 157 "../include/modules.h"
unsigned char command_exists(char *name ) ;
#line 158
int modules_init(void) ;
#line 159
void modules_list(int flags ) ;
#line 163
int modules_session_init(void) ;
#line 167
int pr_module_load(module *m ) ;
#line 168
int pr_module_unload(module *m ) ;
#line 180
int init_stash(void) ;
#line 54 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static xaset_t *symbol_table[40]  ;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static pool *symbol_pool  =    (pool *)((void *)0);
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static struct stash *curr_sym  =    (struct stash *)((void *)0);
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
module *curr_module  =    (module *)((void *)0);
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static unsigned int curr_module_pri  =    0U;
#line 72 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static struct stash *sym_alloc(void) 
{ 
  pool *sub_pool ;
  struct stash *sym ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 80
  sub_pool = pr_pool_create_sz(symbol_pool, 128);
#line 82
  tmp = pcalloc(sub_pool, (int )sizeof(struct stash ));
#line 82
  sym = (struct stash *)tmp;
#line 83
  sym->sym_pool = sub_pool;
#line 84
  pr_pool_tag(sub_pool, "symbol");
  }
#line 86
  return (sym);
}
}
#line 89 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static int sym_cmp(struct stash *s1 , struct stash *s2 ) 
{ 
  int res ;

  {
  {
#line 92
  res = strcmp(s1->sym_name, s2->sym_name);
  }
#line 98
  if (res == 0) {
#line 99
    if ((unsigned long )s1->sym_module != (unsigned long )((void *)0)) {
#line 99
      if ((unsigned long )s2->sym_module != (unsigned long )((void *)0)) {
#line 102
        if ((s1->sym_module)->priority > (s2->sym_module)->priority) {
#line 103
          return (-1);
        }
#line 106
        if ((s1->sym_module)->priority < (s2->sym_module)->priority) {
#line 107
          return (1);
        }
#line 110
        return (res);
      }
    }
#line 113
    if ((unsigned long )s1->sym_module != (unsigned long )((void *)0)) {
#line 113
      if ((unsigned long )s2->sym_module == (unsigned long )((void *)0)) {
#line 115
        return (-1);
      }
    }
#line 118
    if ((unsigned long )s1->sym_module == (unsigned long )((void *)0)) {
#line 118
      if ((unsigned long )s2->sym_module != (unsigned long )((void *)0)) {
#line 120
        return (1);
      }
    }
#line 124
    return (0);
  }
#line 127
  return (res);
}
}
#line 130 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static int symtab_hash(char const   *name ) 
{ 
  unsigned char *cp ;
  int total ;
  int tmp ;

  {
#line 131
  cp = (unsigned char *)((void *)0);
#line 132
  total = 0;
#line 134
  if (! name) {
#line 135
    return (0);
  }
#line 137
  cp = (unsigned char *)name;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! *cp) {
#line 137
      goto while_break;
    }
#line 138
    total += (int )*cp;
#line 137
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (total < 40) {
#line 140
    tmp = total;
  } else {
#line 140
    tmp = total % 40;
  }
#line 140
  return (tmp);
}
}
#line 144 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int pr_stash_add_symbol(pr_stash_type_t sym_type , void *data ) 
{ 
  struct stash *sym ;
  int idx ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  register unsigned int i___0 ;
  char buf___2[1024] ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp12 ;

  {
#line 145
  sym = (struct stash *)((void *)0);
#line 146
  idx = 0;
#line 148
  if (! data) {
    {
#line 149
    tmp = __errno_location();
#line 149
    *tmp = 22;
    }
#line 150
    return (-1);
  }
  {
#line 154
  if ((unsigned int )sym_type == 1U) {
#line 154
    goto case_1;
  }
#line 162
  if ((unsigned int )sym_type == 2U) {
#line 162
    goto case_2;
  }
#line 170
  if ((unsigned int )sym_type == 3U) {
#line 170
    goto case_3;
  }
#line 178
  if ((unsigned int )sym_type == 4U) {
#line 178
    goto case_4;
  }
#line 186
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 155
  sym = sym_alloc();
#line 156
  sym->sym_type = (pr_stash_type_t )1;
#line 157
  sym->sym_name = (char const   *)((conftable *)data)->directive;
#line 158
  sym->sym_module = ((conftable *)data)->m;
#line 159
  sym->ptr.sym_conf = (conftable *)data;
  }
#line 160
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 163
  sym = sym_alloc();
#line 164
  sym->sym_type = (pr_stash_type_t )2;
#line 165
  sym->sym_name = (char const   *)((cmdtable *)data)->command;
#line 166
  sym->sym_module = ((cmdtable *)data)->m;
#line 167
  sym->ptr.sym_cmd = (cmdtable *)data;
  }
#line 168
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 171
  sym = sym_alloc();
#line 172
  sym->sym_type = (pr_stash_type_t )3;
#line 173
  sym->sym_name = (char const   *)((authtable *)data)->name;
#line 174
  sym->sym_module = ((authtable *)data)->m;
#line 175
  sym->ptr.sym_auth = (authtable *)data;
  }
#line 176
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 179
  sym = sym_alloc();
#line 180
  sym->sym_type = (pr_stash_type_t )4;
#line 181
  sym->sym_name = (char const   *)((cmdtable *)data)->command;
#line 182
  sym->sym_module = ((cmdtable *)data)->m;
#line 183
  sym->ptr.sym_hook = (cmdtable *)data;
  }
#line 184
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  tmp___0 = __errno_location();
#line 187
  *tmp___0 = 2;
  }
#line 188
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 192
  if ((unsigned long )sym->sym_name == (unsigned long )((void *)0)) {
    {
#line 193
    destroy_pool(sym->sym_pool);
#line 194
    tmp___1 = __errno_location();
#line 194
    *tmp___1 = 1;
    }
#line 195
    return (-1);
  }
#line 199
  if ((unsigned int )sym_type != 1U) {
    {
#line 200
    idx = symtab_hash(sym->sym_name);
    }
  } else {
    {
#line 206
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 207
    sstrncpy(buf___2, sym->sym_name, (size_t )(sizeof(buf___2) - 1UL));
#line 209
    i___0 = 0U;
    }
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 209
      tmp___3 = strlen((char const   *)(buf___2));
      }
#line 209
      if (! (i___0 < tmp___3)) {
#line 209
        goto while_break;
      }
      {
#line 210
      tmp___2 = tolower((int )buf___2[i___0]);
#line 210
      buf___2[i___0] = (char )tmp___2;
#line 209
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 212
    idx = symtab_hash((char const   *)(buf___2));
    }
  }
#line 215
  if (! symbol_table[idx]) {
    {
#line 216
    symbol_table[idx] = xaset_create(symbol_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))(& sym_cmp));
    }
  }
  {
#line 219
  xaset_insert_sort(symbol_table[idx], (xasetmember_t *)sym, 1);
  }
#line 220
  return (0);
}
}
#line 223 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static struct stash *stash_lookup(pr_stash_type_t sym_type , char const   *name ,
                                  int idx ) 
{ 
  struct stash *sym ;
  int tmp ;

  {
#line 225
  sym = (struct stash *)((void *)0);
#line 227
  if (symbol_table[idx]) {
#line 228
    sym = (struct stash *)(symbol_table[idx])->xas_list;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! sym) {
#line 228
        goto while_break;
      }
#line 230
      if ((unsigned int )sym->sym_type == (unsigned int )sym_type) {
#line 230
        if (! name) {
#line 232
          goto while_break;
        } else {
          {
#line 230
          tmp = strcasecmp(sym->sym_name, name);
          }
#line 230
          if (tmp == 0) {
#line 232
            goto while_break;
          }
        }
      }
#line 228
      sym = sym->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 235
  return (sym);
}
}
#line 238 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
static struct stash *stash_lookup_next(pr_stash_type_t sym_type , char const   *name ,
                                       int idx , void *prev ) 
{ 
  struct stash *sym ;
  int last_hit ;
  int tmp ;

  {
#line 240
  sym = (struct stash *)((void *)0);
#line 241
  last_hit = 0;
#line 243
  if (symbol_table[idx]) {
#line 244
    sym = (struct stash *)(symbol_table[idx])->xas_list;
    {
#line 244
    while (1) {
      while_continue: /* CIL Label */ ;
#line 244
      if (! sym) {
#line 244
        goto while_break;
      }
#line 246
      if (last_hit) {
#line 246
        if ((unsigned int )sym->sym_type == (unsigned int )sym_type) {
#line 246
          if (! name) {
#line 248
            goto while_break;
          } else {
            {
#line 246
            tmp = strcasecmp(sym->sym_name, name);
            }
#line 246
            if (tmp == 0) {
#line 248
              goto while_break;
            }
          }
        }
      }
#line 249
      if ((unsigned long )sym->ptr.sym_generic == (unsigned long )prev) {
#line 250
        last_hit ++;
      }
#line 244
      sym = sym->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 254
  return (sym);
}
}
#line 257 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
void *pr_stash_get_symbol(pr_stash_type_t sym_type , char const   *name , void *prev ,
                          int *idx_cache ) 
{ 
  int idx ;
  struct stash *sym ;
  register unsigned int i___0 ;
  char buf___2[1024] ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  void *__cil_tmp17 ;

  {
#line 260
  sym = (struct stash *)((void *)0);
#line 262
  if (idx_cache) {
#line 262
    if (*idx_cache != -1) {
#line 264
      idx = *idx_cache;
    } else {
#line 262
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 269
    if ((unsigned int )sym_type != 1U) {
      {
#line 270
      idx = symtab_hash(name);
      }
    } else {
      {
#line 276
      memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 277
      sstrncpy(buf___2, name, (size_t )(sizeof(buf___2) - 1UL));
#line 279
      i___0 = 0U;
      }
      {
#line 279
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 279
        tmp___0 = strlen((char const   *)(buf___2));
        }
#line 279
        if (! (i___0 < tmp___0)) {
#line 279
          goto while_break;
        }
        {
#line 280
        tmp = tolower((int )buf___2[i___0]);
#line 280
        buf___2[i___0] = (char )tmp;
#line 279
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 282
      idx = symtab_hash((char const   *)(buf___2));
      }
    }
#line 285
    if (idx_cache) {
#line 286
      *idx_cache = idx;
    }
  }
#line 289
  if (idx >= 40) {
#line 290
    if (*idx_cache) {
#line 291
      *idx_cache = -1;
    }
    {
#line 293
    tmp___1 = __errno_location();
#line 293
    *tmp___1 = 22;
    }
#line 294
    return ((void *)0);
  }
#line 297
  if (prev) {
    {
#line 298
    sym = stash_lookup_next(sym_type, name, idx, prev);
#line 298
    curr_sym = sym;
    }
  } else {
    {
#line 300
    sym = stash_lookup(sym_type, name, idx);
#line 300
    curr_sym = sym;
    }
  }
  {
#line 303
  if ((unsigned int )sym_type == 1U) {
#line 303
    goto case_1;
  }
#line 311
  if ((unsigned int )sym_type == 2U) {
#line 311
    goto case_2;
  }
#line 319
  if ((unsigned int )sym_type == 3U) {
#line 319
    goto case_3;
  }
#line 327
  if ((unsigned int )sym_type == 4U) {
#line 327
    goto case_4;
  }
#line 302
  goto switch_break;
  case_1: /* CIL Label */ 
#line 304
  if (sym) {
#line 305
    return ((void *)sym->ptr.sym_conf);
  }
  {
#line 308
  tmp___2 = __errno_location();
#line 308
  *tmp___2 = 2;
  }
#line 309
  return ((void *)0);
  case_2: /* CIL Label */ 
#line 312
  if (sym) {
#line 313
    return ((void *)sym->ptr.sym_cmd);
  }
  {
#line 316
  tmp___3 = __errno_location();
#line 316
  *tmp___3 = 2;
  }
#line 317
  return ((void *)0);
  case_3: /* CIL Label */ 
#line 320
  if (sym) {
#line 321
    return ((void *)sym->ptr.sym_auth);
  }
  {
#line 324
  tmp___4 = __errno_location();
#line 324
  *tmp___4 = 2;
  }
#line 325
  return ((void *)0);
  case_4: /* CIL Label */ 
#line 328
  if (sym) {
#line 329
    return ((void *)sym->ptr.sym_hook);
  }
  {
#line 332
  tmp___5 = __errno_location();
#line 332
  *tmp___5 = 2;
  }
#line 333
  return ((void *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 336
  tmp___6 = __errno_location();
#line 336
  *tmp___6 = 22;
  }
#line 337
  return ((void *)0);
}
}
#line 340 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int pr_stash_remove_symbol(pr_stash_type_t sym_type , char const   *sym_name , module *sym_module ) 
{ 
  int count ;
  int symtab_idx ;
  int *tmp ;
  register unsigned int i___0 ;
  char buf___2[1024] ;
  int tmp___0 ;
  size_t tmp___1 ;
  int idx ;
  conftable *tab ;
  void *tmp___2 ;
  void *tmp___3 ;
  int idx___0 ;
  cmdtable *tab___0 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int idx___1 ;
  authtable *tab___1 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int idx___2 ;
  cmdtable *tab___2 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  void *__cil_tmp28 ;

  {
#line 342
  count = 0;
#line 342
  symtab_idx = 0;
#line 344
  if (! sym_name) {
    {
#line 345
    tmp = __errno_location();
#line 345
    *tmp = 22;
    }
#line 346
    return (-1);
  }
#line 350
  if ((unsigned int )sym_type != 1U) {
    {
#line 351
    symtab_idx = symtab_hash(sym_name);
    }
  } else {
    {
#line 357
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 358
    sstrncpy(buf___2, sym_name, (size_t )(sizeof(buf___2) - 1UL));
#line 360
    i___0 = 0U;
    }
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 360
      tmp___1 = strlen((char const   *)(buf___2));
      }
#line 360
      if (! (i___0 < tmp___1)) {
#line 360
        goto while_break;
      }
      {
#line 361
      tmp___0 = tolower((int )buf___2[i___0]);
#line 361
      buf___2[i___0] = (char )tmp___0;
#line 360
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 363
    symtab_idx = symtab_hash((char const   *)(buf___2));
    }
  }
  {
#line 367
  if ((unsigned int )sym_type == 1U) {
#line 367
    goto case_1;
  }
#line 397
  if ((unsigned int )sym_type == 2U) {
#line 397
    goto case_2;
  }
#line 425
  if ((unsigned int )sym_type == 3U) {
#line 425
    goto case_3;
  }
#line 453
  if ((unsigned int )sym_type == 4U) {
#line 453
    goto case_4;
  }
#line 476
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 368
  idx = -1;
#line 371
  tmp___2 = pr_stash_get_symbol((pr_stash_type_t )1, sym_name, (void *)0, & idx);
#line 371
  tab = (conftable *)tmp___2;
  }
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 373
    if (! tab) {
#line 373
      goto while_break___0;
    }
    {
#line 374
    pr_signals_handle();
    }
#line 382
    if (! sym_module) {
      {
#line 384
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 385
      destroy_pool(curr_sym->sym_pool);
#line 386
      curr_sym = (struct stash *)((void *)0);
#line 387
      tab = (conftable *)((void *)0);
#line 388
      count ++;
      }
    } else
#line 382
    if ((unsigned long )curr_sym->sym_module == (unsigned long )sym_module) {
      {
#line 384
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 385
      destroy_pool(curr_sym->sym_pool);
#line 386
      curr_sym = (struct stash *)((void *)0);
#line 387
      tab = (conftable *)((void *)0);
#line 388
      count ++;
      }
    }
    {
#line 391
    tmp___3 = pr_stash_get_symbol((pr_stash_type_t )1, sym_name, (void *)tab, & idx);
#line 391
    tab = (conftable *)tmp___3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 394
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 398
  idx___0 = -1;
#line 401
  tmp___4 = pr_stash_get_symbol((pr_stash_type_t )2, sym_name, (void *)0, & idx___0);
#line 401
  tab___0 = (cmdtable *)tmp___4;
  }
  {
#line 403
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 403
    if (! tab___0) {
#line 403
      goto while_break___1;
    }
    {
#line 404
    pr_signals_handle();
    }
#line 411
    if (! sym_module) {
      {
#line 413
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 414
      destroy_pool(curr_sym->sym_pool);
#line 415
      tab___0 = (cmdtable *)((void *)0);
#line 416
      count ++;
      }
    } else
#line 411
    if ((unsigned long )curr_sym->sym_module == (unsigned long )sym_module) {
      {
#line 413
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 414
      destroy_pool(curr_sym->sym_pool);
#line 415
      tab___0 = (cmdtable *)((void *)0);
#line 416
      count ++;
      }
    }
    {
#line 419
    tmp___5 = pr_stash_get_symbol((pr_stash_type_t )2, sym_name, (void *)tab___0,
                                  & idx___0);
#line 419
    tab___0 = (cmdtable *)tmp___5;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 422
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 426
  idx___1 = -1;
#line 429
  tmp___6 = pr_stash_get_symbol((pr_stash_type_t )3, sym_name, (void *)0, & idx___1);
#line 429
  tab___1 = (authtable *)tmp___6;
  }
  {
#line 431
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 431
    if (! tab___1) {
#line 431
      goto while_break___2;
    }
    {
#line 432
    pr_signals_handle();
    }
#line 439
    if (! sym_module) {
      {
#line 441
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 442
      destroy_pool(curr_sym->sym_pool);
#line 443
      tab___1 = (authtable *)((void *)0);
#line 444
      count ++;
      }
    } else
#line 439
    if ((unsigned long )curr_sym->sym_module == (unsigned long )sym_module) {
      {
#line 441
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 442
      destroy_pool(curr_sym->sym_pool);
#line 443
      tab___1 = (authtable *)((void *)0);
#line 444
      count ++;
      }
    }
    {
#line 447
    tmp___7 = pr_stash_get_symbol((pr_stash_type_t )3, sym_name, (void *)tab___1,
                                  & idx___1);
#line 447
    tab___1 = (authtable *)tmp___7;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 450
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 454
  idx___2 = -1;
#line 457
  tmp___8 = pr_stash_get_symbol((pr_stash_type_t )4, sym_name, (void *)0, & idx___2);
#line 457
  tab___2 = (cmdtable *)tmp___8;
  }
  {
#line 459
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 459
    if (! tab___2) {
#line 459
      goto while_break___3;
    }
    {
#line 460
    pr_signals_handle();
    }
#line 462
    if (! sym_module) {
      {
#line 464
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 465
      destroy_pool(curr_sym->sym_pool);
#line 466
      tab___2 = (cmdtable *)((void *)0);
#line 467
      count ++;
      }
    } else
#line 462
    if ((unsigned long )curr_sym->sym_module == (unsigned long )sym_module) {
      {
#line 464
      xaset_remove(symbol_table[symtab_idx], (xasetmember_t *)curr_sym);
#line 465
      destroy_pool(curr_sym->sym_pool);
#line 466
      tab___2 = (cmdtable *)((void *)0);
#line 467
      count ++;
      }
    }
    {
#line 470
    tmp___9 = pr_stash_get_symbol((pr_stash_type_t )4, sym_name, (void *)tab___2,
                                  & idx___2);
#line 470
    tab___2 = (cmdtable *)tmp___9;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 473
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 477
  tmp___10 = __errno_location();
#line 477
  *tmp___10 = 22;
  }
#line 478
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 481
  return (count);
}
}
#line 484 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
modret_t *pr_module_call(module *m , modret_t *(*func)(cmd_rec * ) , cmd_rec *cmd ) 
{ 
  modret_t *res ;
  module *prev_module ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
#line 487
  prev_module = curr_module;
#line 489
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 492
    tmp = __errno_location();
#line 492
    *tmp = 22;
    }
#line 493
    return ((modret_t *)((void *)0));
  } else
#line 489
  if ((unsigned long )func == (unsigned long )((void *)0)) {
    {
#line 492
    tmp = __errno_location();
#line 492
    *tmp = 22;
    }
#line 493
    return ((modret_t *)((void *)0));
  } else
#line 489
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    {
#line 492
    tmp = __errno_location();
#line 492
    *tmp = 22;
    }
#line 493
    return ((modret_t *)((void *)0));
  }
#line 496
  if (! cmd->tmp_pool) {
    {
#line 497
    cmd->tmp_pool = make_sub_pool(cmd->pool);
#line 498
    pr_pool_tag(cmd->tmp_pool, "Module call tmp_pool");
    }
  }
  {
#line 501
  curr_module = m;
#line 502
  res = (*func)(cmd);
#line 503
  curr_module = prev_module;
  }
#line 508
  return (res);
}
}
#line 511 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
modret_t *mod_create_data(cmd_rec *cmd , void *d ) 
{ 
  modret_t *res ;
  void *tmp ;

  {
  {
#line 514
  tmp = pcalloc(cmd->tmp_pool, (int )sizeof(modret_t ));
#line 514
  res = (modret_t *)tmp;
#line 515
  res->data = d;
  }
#line 517
  return (res);
}
}
#line 520 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
modret_t *mod_create_ret(cmd_rec *cmd , unsigned char err , char *n , char *m ) 
{ 
  modret_t *res ;
  void *tmp ;

  {
  {
#line 523
  tmp = pcalloc(cmd->tmp_pool, (int )sizeof(modret_t ));
#line 523
  res = (modret_t *)tmp;
#line 524
  res->mr_handler_module = curr_module;
#line 525
  res->mr_error = (int )err;
  }
#line 527
  if (n) {
    {
#line 528
    res->mr_numeric = pstrdup(cmd->tmp_pool, (char const   *)n);
    }
  }
#line 531
  if (m) {
    {
#line 532
    res->mr_message = pstrdup(cmd->tmp_pool, (char const   *)m);
    }
  }
#line 535
  return (res);
}
}
#line 538 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
modret_t *mod_create_error(cmd_rec *cmd , int mr_errno ) 
{ 
  modret_t *res ;
  void *tmp ;

  {
  {
#line 541
  tmp = pcalloc(cmd->tmp_pool, (int )sizeof(modret_t ));
#line 541
  res = (modret_t *)tmp;
#line 542
  res->mr_handler_module = curr_module;
#line 543
  res->mr_error = mr_errno;
  }
#line 545
  return (res);
}
}
#line 551 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int modules_session_init(void) 
{ 
  module *prev_module ;
  module *m ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 552
  prev_module = curr_module;
#line 554
  m = loaded_modules;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! m) {
#line 554
      goto while_break;
    }
#line 555
    if (m) {
#line 555
      if (m->sess_init) {
        {
#line 556
        curr_module = m;
#line 557
        tmp___1 = (*(m->sess_init))();
        }
#line 557
        if (tmp___1 < 0) {
          {
#line 558
          tmp = __errno_location();
#line 558
          tmp___0 = strerror(*tmp);
#line 558
          pr_log_pri(3, "mod_%s.c: error initializing session: %s", m->name, tmp___0);
          }
#line 560
          return (-1);
        }
      }
    }
#line 554
    m = m->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  curr_module = prev_module;
#line 566
  return (0);
}
}
#line 569 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
unsigned char command_exists(char *name ) 
{ 
  int idx ;
  cmdtable *cmdtab ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 570
  idx = -1;
#line 571
  tmp = pr_stash_get_symbol((pr_stash_type_t )2, (char const   *)name, (void *)0,
                            & idx);
#line 571
  cmdtab = (cmdtable *)tmp;
  }
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (cmdtab) {
#line 573
      if (! ((int )cmdtab->cmd_type != 2)) {
#line 573
        goto while_break;
      }
    } else {
#line 573
      goto while_break;
    }
    {
#line 574
    pr_signals_handle();
#line 575
    tmp___0 = pr_stash_get_symbol((pr_stash_type_t )2, (char const   *)name, (void *)cmdtab,
                                  & idx);
#line 575
    cmdtab = (cmdtable *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  if (cmdtab) {
#line 578
    tmp___1 = 1;
  } else {
#line 578
    tmp___1 = 0;
  }
#line 578
  return ((unsigned char )tmp___1);
}
}
#line 581 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
unsigned char pr_module_exists(char const   *name ) 
{ 
  int tmp___0 ;
  module *tmp___1 ;

  {
  {
#line 582
  tmp___1 = pr_module_get(name);
  }
#line 582
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 582
    tmp___0 = 1;
  } else {
#line 582
    tmp___0 = 0;
  }
#line 582
  return ((unsigned char )tmp___0);
}
}
#line 585 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
module *pr_module_get(char const   *name ) 
{ 
  char buf___2[80] ;
  unsigned int tmp ;
  module *m ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 586
  buf___2[0] = (char )'\000';
#line 586
  tmp = 1U;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (tmp >= 80U) {
#line 586
      goto while_break;
    }
#line 586
    buf___2[tmp] = (char)0;
#line 586
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  if (! name) {
    {
#line 590
    tmp___0 = __errno_location();
#line 590
    *tmp___0 = 22;
    }
#line 591
    return ((module *)((void *)0));
  }
#line 595
  m = loaded_modules;
  {
#line 595
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 595
    if (! m) {
#line 595
      goto while_break___0;
    }
    {
#line 596
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 597
    snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"mod_%s.c",
             m->name);
#line 598
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 600
    tmp___1 = strcmp((char const   *)(buf___2), name);
    }
#line 600
    if (tmp___1 == 0) {
#line 601
      return (m);
    }
#line 595
    m = m->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 604
  tmp___2 = __errno_location();
#line 604
  *tmp___2 = 2;
  }
#line 605
  return ((module *)((void *)0));
}
}
#line 608 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
void modules_list(int flags ) 
{ 
  register unsigned int i___0 ;
  module *m ;
  char *version ;
  module *m___0 ;
  char *version___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 610
  if (flags & 2) {
    {
#line 611
    i___0 = 0U;
#line 613
    printf((char const   */* __restrict  */)"Compiled-in modules:\n");
#line 614
    i___0 = 0U;
    }
    {
#line 614
    while (1) {
      while_continue: /* CIL Label */ ;
#line 614
      if (! static_modules[i___0]) {
#line 614
        goto while_break;
      }
#line 615
      m = static_modules[i___0];
#line 617
      if (flags & 1) {
#line 618
        version = m->module_version;
#line 619
        if (version) {
          {
#line 620
          printf((char const   */* __restrict  */)"  %s\n", version);
          }
        } else {
          {
#line 623
          printf((char const   */* __restrict  */)"  mod_%s.c\n", m->name);
          }
        }
      } else {
        {
#line 627
        printf((char const   */* __restrict  */)"  mod_%s.c\n", m->name);
        }
      }
#line 614
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 634
    printf((char const   */* __restrict  */)"Loaded modules:\n");
#line 635
    m___0 = loaded_modules;
    }
    {
#line 635
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 635
      if (! m___0) {
#line 635
        goto while_break___0;
      }
#line 637
      if (flags & 1) {
#line 638
        version___0 = m___0->module_version;
#line 639
        if (version___0) {
          {
#line 640
          printf((char const   */* __restrict  */)"  %s\n", version___0);
          }
        } else {
          {
#line 643
          printf((char const   */* __restrict  */)"  mod_%s.c\n", m___0->name);
          }
        }
      } else {
        {
#line 647
        printf((char const   */* __restrict  */)"  mod_%s.c\n", m___0->name);
        }
      }
#line 635
      m___0 = m___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 651
  return;
}
}
#line 653 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int pr_module_load(module *m ) 
{ 
  char buf___2[256] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  module *tmp___2 ;
  unsigned int tmp___3 ;
  conftable *conftab ;
  int tmp___4 ;
  cmdtable *cmdtab ;
  int tmp___5 ;
  int tmp___6 ;
  authtable *authtab ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 656
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 658
    tmp = __errno_location();
#line 658
    *tmp = 22;
    }
#line 659
    return (-1);
  } else
#line 656
  if ((unsigned long )m->name == (unsigned long )((void *)0)) {
    {
#line 658
    tmp = __errno_location();
#line 658
    *tmp = 22;
    }
#line 659
    return (-1);
  }
#line 663
  if (m->api_version < 32) {
    {
#line 664
    tmp___0 = __errno_location();
#line 664
    *tmp___0 = 13;
    }
#line 665
    return (-1);
  }
  {
#line 669
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 670
  snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"mod_%s.c",
           m->name);
#line 671
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 673
  tmp___2 = pr_module_get((char const   *)(buf___2));
  }
#line 673
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 674
    tmp___1 = __errno_location();
#line 674
    *tmp___1 = 17;
    }
#line 675
    return (-1);
  }
#line 679
  if (! m->init) {
#line 679
    goto _L;
  } else {
    {
#line 679
    tmp___8 = (*(m->init))();
    }
#line 679
    if (tmp___8 >= 0) {
      _L: /* CIL Label */ 
#line 683
      tmp___3 = curr_module_pri;
#line 683
      curr_module_pri ++;
#line 683
      m->priority = (int )tmp___3;
#line 686
      if (m->conftable) {
#line 689
        conftab = m->conftable;
        {
#line 689
        while (1) {
          while_continue: /* CIL Label */ ;
#line 689
          if (! conftab->directive) {
#line 689
            goto while_break;
          }
          {
#line 690
          conftab->m = m;
#line 692
          tmp___4 = pr_stash_add_symbol((pr_stash_type_t )1, (void *)conftab);
          }
#line 692
          if (tmp___4 < 0) {
#line 693
            return (-1);
          }
#line 689
          conftab ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 698
      if (m->cmdtable) {
#line 701
        cmdtab = m->cmdtable;
        {
#line 701
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 701
          if (! cmdtab->command) {
#line 701
            goto while_break___0;
          }
#line 702
          cmdtab->m = m;
#line 704
          if ((int )cmdtab->cmd_type == 7) {
            {
#line 705
            tmp___5 = pr_stash_add_symbol((pr_stash_type_t )4, (void *)cmdtab);
            }
#line 705
            if (tmp___5 < 0) {
#line 706
              return (-1);
            }
          } else {
            {
#line 711
            tmp___6 = pr_stash_add_symbol((pr_stash_type_t )2, (void *)cmdtab);
            }
#line 711
            if (tmp___6 < 0) {
#line 712
              return (-1);
            }
          }
#line 701
          cmdtab ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 718
      if (m->authtable) {
#line 721
        authtab = m->authtable;
        {
#line 721
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 721
          if (! authtab->name) {
#line 721
            goto while_break___1;
          }
          {
#line 722
          authtab->m = m;
#line 724
          tmp___7 = pr_stash_add_symbol((pr_stash_type_t )3, (void *)authtab);
          }
#line 724
          if (tmp___7 < 0) {
#line 725
            return (-1);
          }
#line 721
          authtab ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 731
      m->next = loaded_modules;
#line 733
      if (loaded_modules) {
#line 734
        loaded_modules->prev = m;
      }
      {
#line 736
      loaded_modules = m;
#line 739
      pr_event_generate("core.module-load", (void const   *)(buf___2));
      }
#line 741
      return (0);
    }
  }
  {
#line 744
  tmp___9 = __errno_location();
#line 744
  *tmp___9 = 1;
  }
#line 745
  return (-1);
}
}
#line 748 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int pr_module_unload(module *m ) 
{ 
  char buf___2[256] ;
  int *tmp ;
  int *tmp___0 ;
  module *tmp___1 ;
  module *tmp___2 ;
  conftable *conftab ;
  cmdtable *cmdtab ;
  authtable *authtab ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 751
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 753
    tmp = __errno_location();
#line 753
    *tmp = 22;
    }
#line 754
    return (-1);
  } else
#line 751
  if ((unsigned long )m->name == (unsigned long )((void *)0)) {
    {
#line 753
    tmp = __errno_location();
#line 753
    *tmp = 22;
    }
#line 754
    return (-1);
  }
  {
#line 761
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 762
  snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"mod_%s.c",
           m->name);
#line 763
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 765
  tmp___1 = pr_module_get((char const   *)(buf___2));
  }
#line 765
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 766
    tmp___0 = __errno_location();
#line 766
    *tmp___0 = 2;
    }
#line 767
    return (-1);
  }
  {
#line 771
  pr_event_generate("core.module-unload", (void const   *)(buf___2));
  }
#line 774
  if (m->prev) {
#line 775
    (m->prev)->next = m->next;
  } else {
#line 781
    loaded_modules = m->next;
  }
#line 784
  if (m->next) {
#line 785
    (m->next)->prev = m->prev;
  }
#line 787
  tmp___2 = (module *)((void *)0);
#line 787
  m->next = tmp___2;
#line 787
  m->prev = tmp___2;
#line 790
  if (m->conftable) {
#line 793
    conftab = m->conftable;
    {
#line 793
    while (1) {
      while_continue: /* CIL Label */ ;
#line 793
      if (! conftab->directive) {
#line 793
        goto while_break;
      }
      {
#line 794
      pr_stash_remove_symbol((pr_stash_type_t )1, (char const   *)conftab->directive,
                             conftab->m);
#line 793
      conftab ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 798
  if (m->cmdtable) {
#line 801
    cmdtab = m->cmdtable;
    {
#line 801
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 801
      if (! cmdtab->command) {
#line 801
        goto while_break___0;
      }
#line 802
      if ((int )cmdtab->cmd_type == 7) {
        {
#line 803
        pr_stash_remove_symbol((pr_stash_type_t )4, (char const   *)cmdtab->command,
                               cmdtab->m);
        }
      } else {
        {
#line 807
        pr_stash_remove_symbol((pr_stash_type_t )2, (char const   *)cmdtab->command,
                               cmdtab->m);
        }
      }
#line 801
      cmdtab ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 812
  if (m->authtable) {
#line 815
    authtab = m->authtable;
    {
#line 815
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 815
      if (! authtab->name) {
#line 815
        goto while_break___1;
      }
      {
#line 816
      pr_stash_remove_symbol((pr_stash_type_t )3, (char const   *)authtab->name, authtab->m);
#line 815
      authtab ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 820
  return (0);
}
}
#line 823 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int modules_init(void) 
{ 
  register unsigned int i___0 ;
  module *m ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 824
  i___0 = 0U;
#line 826
  i___0 = 0U;
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 826
    if (! static_modules[i___0]) {
#line 826
      goto while_break;
    }
    {
#line 827
    m = static_modules[i___0];
#line 829
    tmp___1 = pr_module_load(m);
    }
#line 829
    if (tmp___1 < 0) {
      {
#line 830
      tmp = __errno_location();
#line 830
      tmp___0 = strerror(*tmp);
#line 830
      pr_log_pri(3, "Fatal: unable to load module \'mod_%s.c\': %s", m->name, tmp___0);
#line 832
      exit(1);
      }
    }
#line 826
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  return (0);
}
}
#line 839 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/modules.c"
int init_stash(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 840
  if (symbol_pool) {
    {
#line 841
    destroy_pool(symbol_pool);
    }
  }
  {
#line 843
  symbol_pool = make_sub_pool(permanent_pool);
#line 844
  pr_pool_tag(symbol_pool, "Stash Pool");
#line 845
  memset((void *)(symbol_table), '\000', (size_t )sizeof(symbol_table));
  }
#line 847
  return (0);
}
}
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 348
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 156 "../include/netio.h"
int pr_netio_postopen(pr_netio_stream_t *nstrm___0 ) ;
#line 184
int pr_netio_read(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen , int bufmin ) ;
#line 197
int pr_netio_write(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen ) ;
#line 207
void pr_netio_reset_poll_interval(pr_netio_stream_t *nstrm___0 ) ;
#line 197 "../include/modules.h"
int pr_cmd_read(cmd_rec **res ) ;
#line 60 "../include/response.h"
void pr_response_flush(pr_response_t **head___0 ) ;
#line 111
pool *pr_response_get_pool(void) ;
#line 114
void pr_response_set_pool(pool *p ) ;
#line 60 "../include/timers.h"
int pr_timer_reset(int timerno , module *mod ) ;
#line 146 "../include/inet.h"
void pr_inet_lingering_abort(pool *p , conn_t *c , long linger ) ;
#line 147
void pr_inet_lingering_close(pool *p , conn_t *c , long linger ) ;
#line 152
int pr_inet_set_proto_opts(pool *p , conn_t *c , int mss , int nodelay , int lowdelay ,
                           int throughput , int nopush ) ;
#line 153
int pr_inet_set_socket_opts(pool *p , conn_t *c , int rcvbuf , int sndbuf ) ;
#line 157
int pr_inet_connect(pool *p , conn_t *c , pr_netaddr_t *addr , int port ) ;
#line 160
conn_t *pr_inet_accept(pool *p , conn_t *d , conn_t *c , int rfd , int wfd , unsigned char resolve ) ;
#line 324 "../include/netaddr.h"
int pr_netaddr_set_reverse_dns(int enable ) ;
#line 131 "../include/scoreboard.h"
char const   *pr_scoreboard_entry_get(int field ) ;
#line 38 "/usr/include/sys/sendfile.h"
extern  __attribute__((__nothrow__)) ssize_t sendfile(int __out_fd , int __in_fd ,
                                                      __off64_t *__offset , size_t __count )  __asm__("sendfile64")  ;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static char const   *trace_channel___4  =    "data";
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static pr_netio_stream_t *nstrm  =    (pr_netio_stream_t *)((void *)0);
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static long timeout_linger  =    30L;
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int timeout_idle  =    600;
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int timeout_noxfer  =    300;
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int timeout_stalled  =    3600;
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int stalled_timeout_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 ,
                              void *data ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 64
  pr_event_generate("core.timeout-stalled", (void const   *)((void *)0));
#line 65
  pr_log_pri(5, "Data transfer stall timeout: %d seconds", timeout_stalled);
#line 67
  end_login(1);
  }
#line 71
  return (0);
}
}
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static void data_urgent(int signo ) 
{ 
  char *__cil_tmp2 ;

  {
#line 78
  if (session.sf_flags & (int volatile   )4) {
    {
#line 79
    pr_trace_msg(trace_channel___4, 5, "received SIGURG signal (signal %d), setting \'aborted\' session flag",
                 signo);
#line 81
    session.sf_flags |= (int volatile   )2;
    }
#line 83
    if (nstrm) {
      {
#line 84
      pr_netio_abort(nstrm);
      }
    }
  }
  {
#line 87
  signal(23, & data_urgent);
  }
#line 88
  return;
}
}
#line 90 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int xfrm_ascii_read(char *buf___2 , int *bufsize , int *adjlen ) 
{ 
  char *dest ;
  char *src ;
  int thislen ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 91
  dest = buf___2;
#line 91
  src = buf___2;
#line 92
  thislen = *bufsize;
#line 94
  *adjlen = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    tmp___5 = thislen;
#line 95
    thislen --;
#line 95
    if (! tmp___5) {
#line 95
      goto while_break;
    }
#line 96
    if ((int )*src != 13) {
#line 97
      tmp = dest;
#line 97
      dest ++;
#line 97
      tmp___0 = src;
#line 97
      src ++;
#line 97
      *tmp = *tmp___0;
    } else
#line 99
    if (thislen == 0) {
#line 101
      tmp___1 = dest;
#line 101
      dest ++;
#line 101
      tmp___2 = src;
#line 101
      src ++;
#line 101
      *tmp___1 = *tmp___2;
#line 102
      (*adjlen) ++;
#line 103
      (*bufsize) --;
    } else
#line 105
    if ((int )*(src + 1) == 10) {
#line 106
      (*bufsize) --;
#line 107
      src ++;
    } else {
#line 109
      tmp___3 = dest;
#line 109
      dest ++;
#line 109
      tmp___4 = src;
#line 109
      src ++;
#line 109
      *tmp___3 = *tmp___4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (*bufsize);
}
}
#line 128 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int have_dangling_cr  =    0;
#line 129 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static unsigned int xfrm_ascii_write(char **buf___2 , unsigned int *buflen , unsigned int bufsize ) 
{ 
  char *tmpbuf ;
  unsigned int tmplen ;
  unsigned int lfcount ;
  unsigned int added ;
  int res ;
  register unsigned int i___0 ;
  char *copybuf ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp13 ;

  {
#line 131
  tmpbuf = *buf___2;
#line 132
  tmplen = *buflen;
#line 133
  lfcount = 0U;
#line 134
  added = 0U;
#line 136
  res = 0;
#line 137
  i___0 = 0U;
#line 140
  if (! have_dangling_cr) {
#line 140
    if ((int )*(tmpbuf + 0) == 10) {
#line 141
      lfcount ++;
    }
  }
#line 143
  i___0 = 1U;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i___0 < tmplen)) {
#line 143
      goto while_break;
    }
#line 144
    if ((int )*(tmpbuf + i___0) == 10) {
#line 144
      if ((int )*(tmpbuf + (i___0 - 1U)) != 13) {
#line 145
        lfcount ++;
      }
    }
#line 143
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  if ((int )*(tmpbuf + (tmplen - 1U)) == 13) {
#line 152
    have_dangling_cr = 1;
  } else {
#line 152
    have_dangling_cr = 0;
  }
#line 154
  if (lfcount == 0U) {
#line 156
    return (0U);
  }
#line 172
  res = (int )((bufsize - tmplen) - lfcount);
#line 172
  if (res <= 0) {
    {
#line 173
    tmp = malloc(tmplen);
#line 173
    copybuf = (char *)tmp;
    }
#line 174
    if (! copybuf) {
      {
#line 175
      pr_log_pri(3, "fatal: memory exhausted");
#line 176
      exit(1);
      }
    }
    {
#line 179
    memcpy((void */* __restrict  */)copybuf, (void const   */* __restrict  */)tmpbuf,
           tmplen);
#line 182
    session.xfer.bufsize = (tmplen + lfcount) + 1U;
#line 183
    tmp___0 = pcalloc(session.xfer.p, (int )session.xfer.bufsize);
#line 183
    session.xfer.buf = (char *)tmp___0;
#line 185
    memcpy((void */* __restrict  */)session.xfer.buf, (void const   */* __restrict  */)copybuf,
           tmplen);
#line 187
    free((void *)copybuf);
#line 188
    copybuf = (char *)((void *)0);
#line 190
    tmpbuf = session.xfer.buf;
#line 191
    bufsize = session.xfer.bufsize;
    }
  }
#line 194
  if ((int )*(tmpbuf + 0) == 10) {
    {
#line 199
    memmove((void *)(tmpbuf + 1), (void const   *)(tmpbuf + 0), tmplen);
#line 200
    *(tmpbuf + 0) = (char )'\r';
#line 205
    added ++;
#line 206
    lfcount --;
    }
  }
#line 209
  i___0 = 1U;
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    if (i___0 < bufsize) {
#line 209
      if (! (lfcount > 0U)) {
#line 209
        goto while_break___0;
      }
    } else {
#line 209
      goto while_break___0;
    }
#line 210
    if ((int )*(tmpbuf + i___0) == 10) {
#line 210
      if ((int )*(tmpbuf + (i___0 - 1U)) != 13) {
        {
#line 211
        memmove((void *)(tmpbuf + (i___0 + 1U)), (void const   *)(tmpbuf + i___0),
                (bufsize - i___0) - 1U);
#line 212
        *(tmpbuf + i___0) = (char )'\r';
#line 213
        added ++;
#line 214
        lfcount --;
        }
      }
    }
#line 209
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 218
  *buf___2 = tmpbuf;
#line 219
  *buflen = tmplen + added;
#line 221
  return (added);
}
}
#line 224 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static void data_new_xfer(char *filename , int direction ) 
{ 
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 225
  pr_data_clear_xfer_pool();
#line 227
  session.xfer.p = make_sub_pool(session.pool);
#line 228
  pr_pool_tag(session.xfer.p, "data transfer pool");
#line 230
  session.xfer.filename = pstrdup(session.xfer.p, (char const   *)filename);
#line 231
  session.xfer.direction = direction;
#line 232
  tmp = pr_config_get_xfer_bufsz();
#line 232
  session.xfer.bufsize = (unsigned int )tmp;
#line 233
  tmp___0 = pcalloc(session.xfer.p, (int )(session.xfer.bufsize + 1U));
#line 233
  session.xfer.buf = (char *)tmp___0;
#line 234
  (session.xfer.buf) ++;
#line 235
  session.xfer.buflen = 0U;
  }
#line 236
  return;
}
}
#line 238 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int data_pasv_open(char *reason , off_t___0 size ) 
{ 
  conn_t *c ;
  int rev ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 242
  if (! reason) {
#line 242
    if (session.xfer.filename) {
#line 243
      reason = session.xfer.filename;
    }
  }
#line 248
  if (timeout_stalled) {
    {
#line 249
    pr_timer_add(timeout_stalled, 4, (module *)((void *)0), & stalled_timeout_cb,
                 "TimeoutStalled");
    }
  }
  {
#line 256
  rev = pr_netaddr_set_reverse_dns(ServerUseReverseDNS);
  }
#line 260
  if (session.xfer.direction == 1) {
#line 261
    if (main_server->tcp_rcvbuf_override) {
#line 261
      tmp = main_server->tcp_rcvbuf_len;
    } else {
#line 261
      tmp = 0;
    }
    {
#line 261
    pr_inet_set_socket_opts((session.d)->pool, session.d, tmp, 0);
#line 263
    pr_inet_set_proto_opts(session.pool, session.d, main_server->tcp_mss_len, 0, 0,
                           1, 1);
    }
  } else {
#line 267
    if (main_server->tcp_sndbuf_override) {
#line 267
      tmp___0 = main_server->tcp_sndbuf_len;
    } else {
#line 267
      tmp___0 = 0;
    }
    {
#line 267
    pr_inet_set_socket_opts((session.d)->pool, session.d, 0, tmp___0);
#line 269
    pr_inet_set_proto_opts(session.pool, session.d, main_server->tcp_mss_len, 0, 0,
                           1, 1);
    }
  }
  {
#line 273
  c = pr_inet_accept(session.pool, session.d, session.c, -1, -1, (unsigned char)1);
#line 274
  pr_netaddr_set_reverse_dns(rev);
  }
#line 276
  if (c) {
#line 276
    if (c->mode != 6) {
      {
#line 277
      pr_inet_close(session.pool, session.d);
#line 278
      pr_inet_set_nonblock(session.pool, c);
#line 279
      session.d = c;
#line 281
      tmp___1 = pr_netaddr_get_ipstr((session.d)->local_addr);
#line 281
      pr_log_debug(4, "passive data connection opened - local  : %s:%d", tmp___1,
                   (session.d)->local_port);
#line 283
      tmp___2 = pr_netaddr_get_ipstr((session.d)->remote_addr);
#line 283
      pr_log_debug(4, "passive data connection opened - remote : %s:%d", tmp___2,
                   (session.d)->remote_port);
      }
#line 286
      if (session.xfer.xfer_type != 3) {
#line 287
        if (size) {
#line 288
          if (session.sf_flags & (int volatile   )48) {
#line 288
            tmp___3 = "ASCII";
          } else {
#line 288
            tmp___3 = "BINARY";
          }
          {
#line 288
          pr_response_send("150", "Opening %s mode data connection for %s (%llu bytes)",
                           tmp___3, reason, (unsigned long long )size);
          }
        } else {
#line 291
          if (session.sf_flags & (int volatile   )48) {
#line 291
            tmp___4 = "ASCII";
          } else {
#line 291
            tmp___4 = "BINARY";
          }
          {
#line 291
          pr_response_send("150", "Opening %s mode data connection for %s", tmp___4,
                           reason);
          }
        }
      } else {
        {
#line 315
        pr_response_send("150", "FILE: %s", reason);
        }
      }
#line 318
      return (0);
    }
  }
#line 322
  if (c) {
#line 322
    if (c->mode == 6) {
      {
#line 323
      tmp___5 = strerror(c->xerrno);
#line 323
      pr_log_pri(3, "Error: unable to accept an incoming data connection (%s)", tmp___5);
      }
    }
  }
  {
#line 326
  tmp___6 = strerror((session.d)->xerrno);
#line 326
  pr_response_add_err("425", "Unable to build data connection: %s", tmp___6);
#line 328
  destroy_pool((session.d)->pool);
#line 329
  session.d = (struct conn_struc *)((void *)0);
  }
#line 330
  return (-1);
}
}
#line 333 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
static int data_active_open(char *reason , off_t___0 size ) 
{ 
  conn_t *c ;
  int rev ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 337
  if (! reason) {
#line 337
    if (session.xfer.filename) {
#line 338
      reason = session.xfer.filename;
    }
  }
  {
#line 340
  session.d = pr_inet_create_connection(session.pool, (xaset_t *)((void *)0), -1,
                                        (session.c)->local_addr, (session.c)->local_port - 1,
                                        1);
  }
#line 346
  if (timeout_stalled) {
    {
#line 347
    pr_timer_add(timeout_stalled, 4, (module *)((void *)0), & stalled_timeout_cb,
                 "TimeoutStalled");
    }
  }
  {
#line 350
  rev = pr_netaddr_set_reverse_dns(ServerUseReverseDNS);
  }
#line 354
  if (session.xfer.direction == 1) {
#line 355
    if (main_server->tcp_rcvbuf_override) {
#line 355
      tmp = main_server->tcp_rcvbuf_len;
    } else {
#line 355
      tmp = 0;
    }
    {
#line 355
    pr_inet_set_socket_opts((session.d)->pool, session.d, tmp, 0);
#line 357
    pr_inet_set_proto_opts(session.pool, session.d, main_server->tcp_mss_len, 0, 0,
                           1, 1);
    }
  } else {
#line 361
    if (main_server->tcp_sndbuf_override) {
#line 361
      tmp___0 = main_server->tcp_sndbuf_len;
    } else {
#line 361
      tmp___0 = 0;
    }
    {
#line 361
    pr_inet_set_socket_opts((session.d)->pool, session.d, 0, tmp___0);
#line 363
    pr_inet_set_proto_opts(session.pool, session.d, main_server->tcp_mss_len, 0, 0,
                           1, 1);
    }
  }
  {
#line 367
  tmp___2 = pr_inet_connect((session.d)->pool, session.d, & session.data_addr, (int )session.data_port);
  }
#line 367
  if (tmp___2 == -1) {
    {
#line 369
    tmp___1 = strerror((session.d)->xerrno);
#line 369
    pr_response_add_err("425", "Unable to build data connection: %s", tmp___1);
#line 371
    destroy_pool((session.d)->pool);
#line 372
    session.d = (struct conn_struc *)((void *)0);
    }
#line 373
    return (-1);
  }
  {
#line 376
  c = pr_inet_openrw(session.pool, session.d, (pr_netaddr_t *)((void *)0), 32, (session.d)->listen_fd,
                     -1, -1, 1);
#line 379
  pr_netaddr_set_reverse_dns(rev);
  }
#line 381
  if (c) {
    {
#line 382
    tmp___3 = pr_netaddr_get_ipstr((session.d)->local_addr);
#line 382
    pr_log_debug(4, "active data connection opened - local  : %s:%d", tmp___3, (session.d)->local_port);
#line 384
    tmp___4 = pr_netaddr_get_ipstr((session.d)->remote_addr);
#line 384
    pr_log_debug(4, "active data connection opened - remote : %s:%d", tmp___4, (session.d)->remote_port);
    }
#line 387
    if (session.xfer.xfer_type != 3) {
#line 388
      if (size) {
#line 389
        if (session.sf_flags & (int volatile   )48) {
#line 389
          tmp___5 = "ASCII";
        } else {
#line 389
          tmp___5 = "BINARY";
        }
        {
#line 389
        pr_response_send("150", "Opening %s mode data connection for %s (%llu bytes)",
                         tmp___5, reason, (unsigned long long )size);
        }
      } else {
#line 392
        if (session.sf_flags & (int volatile   )48) {
#line 392
          tmp___6 = "ASCII";
        } else {
#line 392
          tmp___6 = "BINARY";
        }
        {
#line 392
        pr_response_send("150", "Opening %s mode data connection for %s", tmp___6,
                         reason);
        }
      }
    } else {
      {
#line 416
      pr_response_send("150", "FILE: %s", reason);
      }
    }
    {
#line 419
    pr_inet_close(session.pool, session.d);
#line 420
    pr_inet_set_nonblock(session.pool, session.d);
#line 421
    session.d = c;
    }
#line 422
    return (0);
  }
  {
#line 425
  tmp___7 = strerror((session.d)->xerrno);
#line 425
  pr_response_add_err("425", "Unable to build data connection: %s", tmp___7);
#line 427
  destroy_pool((session.d)->pool);
#line 428
  session.d = (struct conn_struc *)((void *)0);
  }
#line 429
  return (-1);
}
}
#line 432 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_set_linger(long linger ) 
{ 


  {
#line 433
  timeout_linger = linger;
#line 434
  return;
}
}
#line 436 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
int pr_data_get_timeout(int id ) 
{ 
  int *tmp ;

  {
  {
#line 438
  if (id == 1) {
#line 438
    goto case_1;
  }
#line 441
  if (id == 2) {
#line 441
    goto case_2;
  }
#line 444
  if (id == 4) {
#line 444
    goto case_4;
  }
#line 437
  goto switch_break;
  case_1: /* CIL Label */ 
#line 439
  return (timeout_idle);
  case_2: /* CIL Label */ 
#line 442
  return (timeout_noxfer);
  case_4: /* CIL Label */ 
#line 445
  return (timeout_stalled);
  switch_break: /* CIL Label */ ;
  }
  {
#line 448
  tmp = __errno_location();
#line 448
  *tmp = 22;
  }
#line 449
  return (-1);
}
}
#line 452 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_set_timeout(int id , int timeout ) 
{ 


  {
  {
#line 454
  if (id == 1) {
#line 454
    goto case_1;
  }
#line 458
  if (id == 2) {
#line 458
    goto case_2;
  }
#line 462
  if (id == 4) {
#line 462
    goto case_4;
  }
#line 453
  goto switch_break;
  case_1: /* CIL Label */ 
#line 455
  timeout_idle = timeout;
#line 456
  goto switch_break;
  case_2: /* CIL Label */ 
#line 459
  timeout_noxfer = timeout;
#line 460
  goto switch_break;
  case_4: /* CIL Label */ 
#line 463
  timeout_stalled = timeout;
#line 464
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 468 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_clear_xfer_pool(void) 
{ 
  int xfer_type___0 ;

  {
#line 471
  if (session.xfer.p) {
    {
#line 472
    destroy_pool(session.xfer.p);
    }
  }
  {
#line 478
  xfer_type___0 = session.xfer.xfer_type;
#line 480
  memset((void *)(& session.xfer), 0, (size_t )sizeof(session.xfer));
#line 481
  session.xfer.xfer_type = xfer_type___0;
  }
#line 482
  return;
}
}
#line 484 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_reset(void) 
{ 


  {
#line 485
  if (session.d) {
#line 485
    if ((session.d)->pool) {
      {
#line 487
      destroy_pool((session.d)->pool);
      }
    }
  }
#line 490
  session.d = (struct conn_struc *)((void *)0);
#line 491
  session.sf_flags &= (int volatile   )848;
#line 492
  return;
}
}
#line 494 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_init(char *filename , int direction ) 
{ 
  char *__cil_tmp3 ;

  {
#line 495
  if ((unsigned long )session.xfer.p == (unsigned long )((void *)0)) {
    {
#line 496
    data_new_xfer(filename, direction);
    }
  } else {
#line 499
    if (! (session.sf_flags & (int volatile   )1)) {
      {
#line 500
      pr_log_debug(0, "data_init oddity: session.xfer exists in non-PASV mode.");
      }
    }
#line 503
    session.xfer.direction = direction;
  }
#line 505
  return;
}
}
#line 507 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
int pr_data_open(char *filename , char *reason , int direction , off_t___0 size ) 
{ 
  int res ;
  struct sigaction act ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 508
  res = 0;
#line 511
  session.sf_flags &= (int volatile   )-3;
#line 513
  if ((unsigned long )session.xfer.p == (unsigned long )((void *)0)) {
    {
#line 514
    data_new_xfer(filename, direction);
    }
  } else {
#line 517
    session.xfer.direction = direction;
  }
#line 520
  if (! reason) {
#line 521
    reason = filename;
  }
#line 524
  if (session.sf_flags & (int volatile   )1) {
#line 524
    goto _L;
  } else
#line 524
  if (session.sf_flags & (int volatile   )1024) {
    _L: /* CIL Label */ 
#line 526
    if (! session.d) {
      {
#line 527
      pr_log_pri(3, "Internal error: PASV mode set, but no data connection listening.");
#line 529
      end_login(1);
      }
    }
    {
#line 532
    res = data_pasv_open(reason, size);
    }
  } else {
#line 536
    if (session.d) {
      {
#line 537
      pr_log_pri(3, "Internal error: non-PASV mode, yet data connection already exists?!?");
#line 539
      end_login(1);
      }
    }
    {
#line 542
    res = data_active_open(reason, size);
    }
  }
#line 545
  if (res >= 0) {
    {
#line 548
    tmp___0 = pr_netio_postopen((session.d)->instrm);
    }
#line 548
    if (tmp___0 < 0) {
      {
#line 549
      tmp = strerror((session.d)->xerrno);
#line 549
      pr_response_add_err("425", "Unable to build data connection: %s", tmp);
#line 551
      destroy_pool((session.d)->pool);
#line 552
      session.d = (struct conn_struc *)((void *)0);
      }
#line 553
      return (-1);
    }
    {
#line 556
    tmp___2 = pr_netio_postopen((session.d)->outstrm);
    }
#line 556
    if (tmp___2 < 0) {
      {
#line 557
      tmp___1 = strerror((session.d)->xerrno);
#line 557
      pr_response_add_err("425", "Unable to build data connection: %s", tmp___1);
#line 559
      destroy_pool((session.d)->pool);
#line 560
      session.d = (struct conn_struc *)((void *)0);
      }
#line 561
      return (-1);
    }
    {
#line 564
    memset((void *)(& session.xfer.start_time), '\000', (size_t )sizeof(session.xfer.start_time));
#line 565
    gettimeofday((struct timeval */* __restrict  */)(& session.xfer.start_time), (__timezone_ptr_t )((void *)0));
    }
#line 567
    if (session.xfer.direction == 1) {
#line 568
      nstrm = (session.d)->instrm;
    } else {
#line 571
      nstrm = (session.d)->outstrm;
    }
#line 573
    session.sf_flags |= (int volatile   )4;
#line 575
    if (timeout_noxfer) {
      {
#line 576
      pr_timer_reset(3, (module *)4294967295U);
      }
    }
    {
#line 581
    pr_netio_set_poll_interval(nstrm, 1U);
#line 590
    act.__sigaction_handler.sa_handler = & data_urgent;
#line 591
    sigemptyset(& act.sa_mask);
#line 592
    act.sa_flags = 0;
#line 594
    act.sa_flags |= 536870912;
#line 597
    tmp___5 = sigaction(23, (struct sigaction  const  */* __restrict  */)(& act),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 597
    if (tmp___5 < 0) {
      {
#line 598
      tmp___3 = __errno_location();
#line 598
      tmp___4 = strerror(*tmp___3);
#line 598
      pr_log_pri(4, "warning: unable to set SIGURG signal handler: %s", tmp___4);
      }
    }
    {
#line 605
    tmp___8 = siginterrupt(23, 1);
    }
#line 605
    if (tmp___8 < 0) {
      {
#line 606
      tmp___6 = __errno_location();
#line 606
      tmp___7 = strerror(*tmp___6);
#line 606
      pr_log_pri(4, "warning: unable to make SIGURG interrupt system calls: %s", tmp___7);
      }
    }
  }
#line 612
  return (res);
}
}
#line 616 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_close(int quiet___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 617
  nstrm = (pr_netio_stream_t *)((void *)0);
#line 619
  if (session.d) {
    {
#line 620
    pr_inet_lingering_close(session.pool, session.d, timeout_linger);
#line 621
    session.d = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 625
  signal(23, (void (*)(int  ))1);
  }
#line 627
  if (timeout_noxfer) {
    {
#line 628
    pr_timer_reset(3, (module *)4294967295U);
    }
  }
#line 630
  if (timeout_stalled) {
    {
#line 631
    pr_timer_remove(4, (module *)4294967295U);
    }
  }
  {
#line 633
  session.sf_flags &= (int volatile   )1910;
#line 634
  session.sf_flags &= (int volatile   )1872;
#line 635
  session_set_idle();
  }
#line 637
  if (! quiet___0) {
    {
#line 638
    pr_response_add("226", "Transfer complete");
    }
  }
#line 639
  return;
}
}
#line 650 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_cleanup(void) 
{ 


  {
#line 652
  if (session.d) {
    {
#line 653
    pr_inet_lingering_close(session.pool, session.d, timeout_linger);
#line 654
    session.d = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 657
  pr_data_clear_xfer_pool();
  }
#line 658
  return;
}
}
#line 664 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
void pr_data_abort(int err , int quiet___0 ) 
{ 
  int true_abort ;
  char *respcode ;
  char *msg ;
  char msgbuf[64] ;
  int tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 665
  true_abort = (int )(session.sf_flags & (int volatile   )2);
#line 666
  nstrm = (pr_netio_stream_t *)((void *)0);
#line 668
  if (session.d) {
#line 669
    if (! true_abort) {
      {
#line 670
      pr_inet_lingering_close(session.pool, session.d, timeout_linger);
      }
    } else {
      {
#line 673
      pr_inet_lingering_abort(session.pool, session.d, timeout_linger);
      }
    }
#line 675
    session.d = (struct conn_struc *)((void *)0);
  }
#line 678
  if (timeout_noxfer) {
    {
#line 679
    pr_timer_reset(3, (module *)4294967295U);
    }
  }
#line 681
  if (timeout_stalled) {
    {
#line 682
    pr_timer_remove(4, (module *)4294967295U);
    }
  }
  {
#line 684
  session.sf_flags &= (int volatile   )1910;
#line 685
  session.sf_flags &= (int volatile   )1874;
#line 686
  session_set_idle();
#line 689
  signal(23, (void (*)(int  ))1);
  }
#line 691
  if (timeout_noxfer) {
    {
#line 692
    pr_timer_reset(3, (module *)4294967295U);
    }
  }
#line 694
  if (! quiet___0) {
#line 695
    respcode = (char *)"426";
#line 696
    msg = (char *)((void *)0);
    {
#line 701
    if (err == 0) {
#line 701
      goto case_0;
    }
#line 707
    if (err == 6) {
#line 707
      goto case_6;
    }
#line 718
    if (err == 12) {
#line 718
      goto case_12;
    }
#line 718
    if (err == 11) {
#line 718
      goto case_12;
    }
#line 730
    if (err == 16) {
#line 730
      goto case_16;
    }
#line 730
    if (err == 26) {
#line 730
      goto case_16;
    }
#line 738
    if (err == 28) {
#line 738
      goto case_28;
    }
#line 747
    if (err == 27) {
#line 747
      goto case_27;
    }
#line 747
    if (err == 122) {
#line 747
      goto case_27;
    }
#line 787
    if (err == 32) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 29) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 14) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 5) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 62) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 71) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 63) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 54) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 35) {
#line 787
      goto case_32;
    }
#line 787
    if (err == 70) {
#line 787
      goto case_32;
    }
#line 822
    if (err == 110) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 104) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 103) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 102) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 37) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 67) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 116) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 69) {
#line 822
      goto case_110;
    }
#line 822
    if (err == 78) {
#line 822
      goto case_110;
    }
#line 699
    goto switch_break;
    case_0: /* CIL Label */ 
#line 702
    respcode = (char *)"426";
#line 703
    msg = (char *)"Data connection closed";
#line 704
    goto switch_break;
    case_6: /* CIL Label */ 
#line 708
    respcode = (char *)"451";
#line 709
    msg = (char *)"Unexpected streams hangup";
#line 710
    goto switch_break;
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 721
    respcode = (char *)"451";
#line 722
    msg = (char *)"Insufficient memory or file locked";
#line 723
    goto switch_break;
    case_16: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 733
    respcode = (char *)"451";
#line 734
    goto switch_break;
    case_28: /* CIL Label */ 
#line 739
    respcode = (char *)"452";
#line 740
    goto switch_break;
    case_27: /* CIL Label */ 
    case_122: /* CIL Label */ 
#line 750
    respcode = (char *)"552";
#line 751
    goto switch_break;
    case_32: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 793
    respcode = (char *)"451";
#line 794
    goto switch_break;
    case_110: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_78: /* CIL Label */ 
#line 827
    respcode = (char *)"450";
#line 828
    msg = (char *)"Link to file server lost";
#line 829
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 833
    if ((unsigned long )msg == (unsigned long )((void *)0)) {
      {
#line 833
      msg = strerror(err);
      }
#line 833
      if ((unsigned long )msg == (unsigned long )((void *)0)) {
        {
#line 836
        tmp = snprintf((char */* __restrict  */)(msgbuf), (size_t )sizeof(msgbuf),
                       (char const   */* __restrict  */)"Unknown or out of range errno [%d]",
                       err);
        }
#line 836
        if (tmp > 0) {
#line 838
          msg = msgbuf;
        }
      }
    }
    {
#line 841
    pr_log_pri(5, "notice: user %s: aborting transfer: %s", session.user, msg);
    }
#line 847
    if (! true_abort) {
#line 848
      if (msg) {
#line 848
        tmp___0 = (char const   *)msg;
      } else {
#line 848
        tmp___0 = "";
      }
      {
#line 848
      pr_response_add_err((char const   *)respcode, "Transfer aborted. %s", tmp___0);
      }
    }
  }
#line 851
  if (true_abort) {
#line 852
    session.sf_flags |= (int volatile   )256;
  }
#line 853
  return;
}
}
#line 865 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
int pr_data_xfer(char *cl_buf , int cl_size ) 
{ 
  int len ;
  int total ;
  int res ;
  cmd_rec *cmd ;
  char *ch ;
  int tmp ;
  pool *resp_pool___0 ;
  pool *resp_pool___1 ;
  char *title_buf ;
  int title_len ;
  char const   *sce_cmd ;
  char const   *sce_cmd_arg ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int xerrno ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *buf___2 ;
  int adjlen ;
  int buflen ;
  int bwrote ;
  int buflen___0 ;
  unsigned int xferbuflen ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 866
  len = 0;
#line 867
  total = 0;
#line 868
  res = 0;
#line 873
  pr_trace_msg(trace_channel___4, 4, "polling for commands on control channel");
#line 874
  pr_netio_set_poll_interval((session.c)->instrm, 0U);
#line 875
  res = pr_netio_poll((session.c)->instrm);
#line 876
  pr_netio_reset_poll_interval((session.c)->instrm);
  }
#line 878
  if (res == 0) {
#line 878
    if (! (session.sf_flags & (int volatile   )2)) {
      {
#line 880
      cmd = (cmd_rec *)((void *)0);
#line 882
      pr_trace_msg(trace_channel___4, 1, "data available for reading on control channel during data transfer, reading control data");
#line 885
      res = pr_cmd_read(& cmd);
      }
#line 886
      if (res >= 0) {
#line 886
        if (cmd) {
#line 890
          ch = *(cmd->argv + 0);
          {
#line 890
          while (1) {
            while_continue: /* CIL Label */ ;
#line 890
            if (! *ch) {
#line 890
              goto while_break;
            }
            {
#line 891
            tmp = toupper((int )*ch);
#line 891
            *ch = (char )tmp;
#line 890
            ch ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 898
          tmp___2 = strcmp((char const   *)*(cmd->argv + 0), "APPE");
          }
#line 898
          if (tmp___2 == 0) {
#line 898
            goto _L;
          } else {
            {
#line 898
            tmp___3 = strcmp((char const   *)*(cmd->argv + 0), "LIST");
            }
#line 898
            if (tmp___3 == 0) {
#line 898
              goto _L;
            } else {
              {
#line 898
              tmp___4 = strcmp((char const   *)*(cmd->argv + 0), "MLSD");
              }
#line 898
              if (tmp___4 == 0) {
#line 898
                goto _L;
              } else {
                {
#line 898
                tmp___5 = strcmp((char const   *)*(cmd->argv + 0), "NLST");
                }
#line 898
                if (tmp___5 == 0) {
#line 898
                  goto _L;
                } else {
                  {
#line 898
                  tmp___6 = strcmp((char const   *)*(cmd->argv + 0), "RETR");
                  }
#line 898
                  if (tmp___6 == 0) {
#line 898
                    goto _L;
                  } else {
                    {
#line 898
                    tmp___7 = strcmp((char const   *)*(cmd->argv + 0), "STOR");
                    }
#line 898
                    if (tmp___7 == 0) {
#line 898
                      goto _L;
                    } else {
                      {
#line 898
                      tmp___8 = strcmp((char const   *)*(cmd->argv + 0), "STOU");
                      }
#line 898
                      if (tmp___8 == 0) {
                        _L: /* CIL Label */ 
                        {
#line 907
                        pr_trace_msg(trace_channel___4, 5, "client sent \'%s\' command during data transfer, denying",
                                     *(cmd->argv + 0));
#line 911
                        resp_err_list = (pr_response_t *)((void *)0);
#line 911
                        resp_list = resp_err_list;
#line 912
                        resp_pool___0 = pr_response_get_pool();
#line 914
                        pr_response_set_pool(cmd->pool);
#line 916
                        pr_response_add_err("450", "%s: data tranfer in progress",
                                            *(cmd->argv + 0));
#line 919
                        pr_response_flush(& resp_err_list);
#line 921
                        destroy_pool(cmd->pool);
#line 922
                        pr_response_set_pool(resp_pool___0);
                        }
                      } else {
                        {
#line 930
                        tmp___1 = strcmp((char const   *)*(cmd->argv + 0), "NOOP");
                        }
#line 930
                        if (tmp___1 == 0) {
                          {
#line 933
                          pr_trace_msg(trace_channel___4, 5, "client sent \'%s\' command during data transfer, ignoring",
                                       *(cmd->argv + 0));
#line 937
                          resp_err_list = (pr_response_t *)((void *)0);
#line 937
                          resp_list = resp_err_list;
#line 938
                          resp_pool___1 = pr_response_get_pool();
#line 940
                          pr_response_set_pool(cmd->pool);
#line 942
                          pr_response_add("200", "%s: data tranfer in progress", *(cmd->argv + 0));
#line 945
                          pr_response_flush(& resp_list);
#line 947
                          destroy_pool(cmd->pool);
#line 948
                          pr_response_set_pool(resp_pool___1);
                          }
                        } else {
                          {
#line 951
                          title_buf = (char *)((void *)0);
#line 952
                          title_len = -1;
#line 953
                          sce_cmd = (char const   *)((void *)0);
#line 953
                          sce_cmd_arg = (char const   *)((void *)0);
#line 955
                          pr_trace_msg(trace_channel___4, 5, "client sent \'%s\' command during data transfer, dispatching",
                                       *(cmd->argv + 0));
#line 959
                          title_len = pr_proctitle_get((char *)((void *)0), (size_t )0);
                          }
#line 960
                          if (title_len > 0) {
                            {
#line 961
                            tmp___0 = pcalloc(cmd->pool, title_len + 1);
#line 961
                            title_buf = (char *)tmp___0;
#line 962
                            pr_proctitle_get(title_buf, (size_t )(title_len + 1));
                            }
                          }
                          {
#line 965
                          sce_cmd = pr_scoreboard_entry_get(6);
#line 966
                          sce_cmd_arg = pr_scoreboard_entry_get(7);
#line 968
                          pr_cmd_dispatch(cmd);
#line 970
                          pr_scoreboard_entry_update(session.pid, 6, "%s", sce_cmd,
                                                     (void *)0, (void *)0);
#line 972
                          pr_scoreboard_entry_update(session.pid, 7, "%s", sce_cmd_arg,
                                                     (void *)0, (void *)0);
                          }
#line 975
                          if (title_len > 0) {
                            {
#line 976
                            pr_proctitle_set_str((char const   *)title_buf);
                            }
                          }
                          {
#line 979
                          destroy_pool(cmd->pool);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          {
#line 983
          pr_trace_msg(trace_channel___4, 3, "invalid command sent, sending error response");
#line 985
          pr_response_send("500", "Invalid command: try being more creative");
          }
        }
      } else {
        {
#line 983
        pr_trace_msg(trace_channel___4, 3, "invalid command sent, sending error response");
#line 985
        pr_response_send("500", "Invalid command: try being more creative");
        }
      }
    }
  }
#line 992
  if ((unsigned long )session.d == (unsigned long )((void *)0)) {
    {
#line 996
    xerrno = 103;
#line 1002
    tmp___9 = strerror(xerrno);
#line 1002
    pr_trace_msg(trace_channel___4, 1, "data connection is null prior to data transfer (possibly from aborted transfer), returning \'%s\' error",
                 tmp___9);
#line 1005
    tmp___10 = __errno_location();
#line 1005
    *tmp___10 = xerrno;
    }
#line 1006
    return (-1);
  }
#line 1009
  if (session.xfer.direction == 1) {
#line 1010
    buf___2 = session.xfer.buf;
#line 1012
    if (session.sf_flags & (int volatile   )48) {
      {
#line 1015
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1016
        buflen = (int )session.xfer.buflen;
#line 1017
        adjlen = 0;
#line 1019
        len = pr_netio_read((session.d)->instrm, buf___2 + buflen, session.xfer.bufsize - (unsigned int )buflen,
                            1);
        }
#line 1021
        if (len < 0) {
#line 1022
          return (-1);
        }
#line 1024
        if (len > 0) {
#line 1025
          buflen += len;
#line 1027
          if (timeout_stalled) {
            {
#line 1028
            pr_timer_reset(4, (module *)4294967295U);
            }
          }
        }
#line 1032
        if (len >= 0) {
#line 1032
          if (buflen > 0) {
#line 1047
            if (len > 0) {
              {
#line 1048
              xfrm_ascii_read(buf___2, & buflen, & adjlen);
              }
            } else
#line 1047
            if (buflen > 1) {
              {
#line 1048
              xfrm_ascii_read(buf___2, & buflen, & adjlen);
              }
            }
#line 1051
            if (buflen > cl_size) {
#line 1055
              adjlen += buflen - cl_size;
#line 1056
              buflen = cl_size;
            }
            {
#line 1059
            memcpy((void */* __restrict  */)cl_buf, (void const   */* __restrict  */)buf___2,
                   (size_t )buflen);
            }
#line 1068
            if (adjlen > 0) {
              {
#line 1069
              memcpy((void */* __restrict  */)buf___2, (void const   */* __restrict  */)(buf___2 + buflen),
                     (size_t )adjlen);
              }
            }
#line 1072
            session.xfer.buflen = (unsigned int )adjlen;
#line 1073
            total += buflen;
          }
        }
#line 1015
        if (len > 0) {
#line 1015
          if (! (buflen == 0)) {
#line 1015
            goto while_break___0;
          }
        } else {
#line 1015
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1084
      len = buflen;
    } else {
      {
#line 1086
      len = pr_netio_read((session.d)->instrm, cl_buf, (size_t )cl_size, 1);
      }
#line 1086
      if (len > 0) {
#line 1090
        if (timeout_stalled) {
          {
#line 1091
          pr_timer_reset(4, (module *)4294967295U);
          }
        }
#line 1093
        total += len;
      }
    }
  } else {
    {
#line 1098
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1098
      if (! cl_size) {
#line 1098
        goto while_break___1;
      }
      {
#line 1099
      bwrote = 0;
#line 1100
      buflen___0 = cl_size;
#line 1103
      tmp___11 = pr_config_get_xfer_bufsz();
      }
#line 1103
      if (buflen___0 > tmp___11) {
        {
#line 1104
        buflen___0 = pr_config_get_xfer_bufsz();
        }
      }
      {
#line 1106
      xferbuflen = (unsigned int )buflen___0;
#line 1109
      memcpy((void */* __restrict  */)session.xfer.buf, (void const   */* __restrict  */)cl_buf,
             (size_t )buflen___0);
      }
#line 1111
      if (session.sf_flags & (int volatile   )48) {
        {
#line 1118
        xfrm_ascii_write(& session.xfer.buf, & xferbuflen, session.xfer.bufsize);
        }
      }
      {
#line 1121
      bwrote = pr_netio_write((session.d)->outstrm, session.xfer.buf, xferbuflen);
      }
#line 1123
      if (bwrote < 0) {
#line 1124
        return (-1);
      }
#line 1126
      if (bwrote > 0) {
#line 1127
        if (timeout_stalled) {
          {
#line 1128
          pr_timer_reset(4, (module *)4294967295U);
          }
        }
#line 1130
        cl_size -= buflen___0;
#line 1131
        cl_buf += buflen___0;
#line 1132
        total += buflen___0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1136
    len = total;
  }
#line 1139
  if (total) {
#line 1139
    if (timeout_idle) {
      {
#line 1141
      pr_timer_reset(2, (module *)4294967295U);
      }
    }
  }
#line 1143
  session.xfer.total_bytes += (off_t___0 )total;
#line 1144
  session.total_bytes += (off_t___0 )total;
#line 1145
  if (len < 0) {
#line 1145
    tmp___12 = -1;
  } else {
#line 1145
    tmp___12 = len;
  }
#line 1145
  return (tmp___12);
}
}
#line 1153 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/data.c"
pr_sendfile_t pr_data_sendfile(int retr_fd , off_t___0 *offset , off_t___0 count ) 
{ 
  int flags ;
  int error ;
  pr_sendfile_t len ;
  pr_sendfile_t total ;
  int tmp ;
  off_t___0 orig_offset ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 1155
  len = 0;
#line 1155
  total = 0;
#line 1161
  if (session.xfer.direction == 1) {
#line 1162
    return (-1);
  }
  {
#line 1164
  flags = fcntl(((session.d)->outstrm)->strm_fd, 3);
  }
#line 1165
  if (flags == -1) {
#line 1166
    return (-1);
  }
#line 1169
  if (flags & 2048) {
    {
#line 1170
    tmp = fcntl(((session.d)->outstrm)->strm_fd, 4, flags ^ 2048);
    }
#line 1170
    if (tmp == -1) {
#line 1171
      return (-1);
    }
  }
  {
#line 1174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1176
    orig_offset = *offset;
#line 1194
    if (count > 2147483647LL) {
#line 1195
      count = (off_t___0 )2147483647;
    }
    {
#line 1210
    len = sendfile(((session.d)->outstrm)->strm_fd, retr_fd, offset, (size_t )count);
    }
#line 1212
    if (len != -1) {
#line 1212
      if ((off_t___0 )len < count) {
#line 1217
        if (session.sf_flags & (int volatile   )2) {
          {
#line 1218
          tmp___0 = __errno_location();
#line 1218
          *tmp___0 = 4;
#line 1220
          session.xfer.total_bytes += (off_t___0 )len;
#line 1221
          session.total_bytes += (off_t___0 )len;
          }
#line 1223
          return (-1);
        }
#line 1226
        count -= (off_t___0 )len;
#line 1229
        if (len > 0) {
#line 1230
          if (timeout_stalled) {
            {
#line 1231
            pr_timer_reset(4, (module *)4294967295U);
            }
          }
#line 1233
          if (timeout_idle) {
            {
#line 1234
            pr_timer_reset(2, (module *)4294967295U);
            }
          }
        }
        {
#line 1237
        session.xfer.total_bytes += (off_t___0 )len;
#line 1238
        session.total_bytes += (off_t___0 )len;
#line 1239
        total += len;
#line 1241
        pr_signals_handle();
        }
#line 1242
        goto __Cont;
      } else {
#line 1212
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1244
    if (len == -1) {
      {
#line 1248
      len = (pr_sendfile_t )(*offset - orig_offset);
#line 1249
      *offset = orig_offset;
#line 1326
      tmp___1 = __errno_location();
      }
#line 1326
      if (*tmp___1 == 4) {
#line 1327
        if (session.sf_flags & (int volatile   )2) {
#line 1328
          session.xfer.total_bytes += (off_t___0 )len;
#line 1329
          session.total_bytes += (off_t___0 )len;
#line 1331
          return (-1);
        }
        {
#line 1334
        pr_signals_handle();
        }
#line 1337
        if ((off_t___0 )len >= count) {
#line 1338
          goto while_break;
        } else {
#line 1341
          count -= (off_t___0 )len;
        }
#line 1343
        *offset += (off_t___0 )len;
#line 1345
        if (timeout_stalled) {
          {
#line 1346
          pr_timer_reset(4, (module *)4294967295U);
          }
        }
#line 1348
        if (timeout_idle) {
          {
#line 1349
          pr_timer_reset(2, (module *)4294967295U);
          }
        }
#line 1351
        session.xfer.total_bytes += (off_t___0 )len;
#line 1352
        session.total_bytes += (off_t___0 )len;
#line 1353
        total += len;
#line 1355
        goto __Cont;
      }
      {
#line 1358
      tmp___2 = __errno_location();
#line 1358
      error = *tmp___2;
#line 1359
      fcntl(((session.d)->outstrm)->strm_fd, 4, flags);
#line 1360
      tmp___3 = __errno_location();
#line 1360
      *tmp___3 = error;
      }
#line 1362
      return (-1);
    }
#line 1365
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1368
  if (flags & 2048) {
    {
#line 1369
    fcntl(((session.d)->outstrm)->strm_fd, 4, flags);
    }
  }
#line 1371
  if (timeout_stalled) {
    {
#line 1372
    pr_timer_reset(4, (module *)4294967295U);
    }
  }
#line 1374
  if (timeout_idle) {
    {
#line 1375
    pr_timer_reset(2, (module *)4294967295U);
    }
  }
#line 1377
  session.xfer.total_bytes += (off_t___0 )len;
#line 1378
  session.total_bytes += (off_t___0 )len;
#line 1379
  total += len;
#line 1381
  return (total);
}
}
#line 165 "../include/netio.h"
int pr_netio_printf_async(pr_netio_stream_t *nstrm___0 , char *fmt  , ...) ;
#line 58 "../include/response.h"
int pr_response_block(int bool ) ;
#line 59
void pr_response_clear(pr_response_t **head___0 ) ;
#line 76
void ( /* format attribute */  pr_response_send_ml_start)(char const   *resp_numeric ,
                                                          char const   *fmt  , ...) ;
#line 83
void ( /* format attribute */  pr_response_send_ml)(char const   *fmt  , ...) ;
#line 90
void ( /* format attribute */  pr_response_send_ml_end)(char const   *fmt  , ...) ;
#line 108
void pr_response_register_handler(char *(*handler_cb)(pool * , char const   *  , ...) ) ;
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
pr_response_t *resp_list  =    (pr_response_t *)((void *)0);
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
pr_response_t *resp_err_list  =    (pr_response_t *)((void *)0);
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
static int resp_blocked  =    0;
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
static pool *resp_pool  =    (pool *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
static char resp_buf[5120]  = {      (char )'\000'};
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
static char resp_ml_numeric[4]  = {      (char )'\000'};
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
static char *(*resp_handler_cb)(pool * , char const   *  , ...)  =    (char *(*)(pool * , char const   *  , ...))((void *)0);
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
static char const   *trace_channel___5  =    "response";
#line 68 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
pool *pr_response_get_pool(void) 
{ 


  {
#line 69
  return (resp_pool);
}
}
#line 72 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void pr_response_set_pool(pool *p ) 
{ 


  {
#line 73
  resp_pool = p;
#line 74
  return;
}
}
#line 76 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void pr_response_register_handler(char *(*handler_cb)(pool * , char const   *  , ...) ) 
{ 


  {
#line 78
  resp_handler_cb = handler_cb;
#line 79
  return;
}
}
#line 81 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
int pr_response_block(int bool ) 
{ 
  int *tmp ;

  {
#line 82
  if (bool == 1) {
#line 84
    resp_blocked = bool;
#line 85
    return (0);
  } else
#line 82
  if (bool == 0) {
#line 84
    resp_blocked = bool;
#line 85
    return (0);
  }
  {
#line 88
  tmp = __errno_location();
#line 88
  *tmp = 22;
  }
#line 89
  return (-1);
}
}
#line 92 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void pr_response_clear(pr_response_t **head___0 ) 
{ 


  {
#line 93
  *head___0 = (pr_response_t *)((void *)0);
#line 94
  return;
}
}
#line 96 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void pr_response_flush(pr_response_t **head___0 ) 
{ 
  unsigned char ml ;
  char *last_numeric ;
  pr_response_t *resp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 97
  ml = (unsigned char)0;
#line 98
  last_numeric = (char *)((void *)0);
#line 99
  resp = (pr_response_t *)((void *)0);
#line 101
  if (resp_blocked) {
#line 102
    return;
  }
#line 104
  resp = *head___0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! resp) {
#line 104
      goto while_break;
    }
#line 105
    if (ml) {
#line 107
      if (! resp->next) {
#line 107
        goto _L___0;
      } else
#line 107
      if (resp->num) {
        {
#line 107
        tmp___2 = strcmp((char const   *)resp->num, (char const   *)last_numeric);
        }
#line 107
        if (tmp___2 != 0) {
          _L___0: /* CIL Label */ 
          {
#line 108
          pr_trace_msg(trace_channel___5, 1, "%s %s\r\n", last_numeric, resp->msg);
          }
#line 108
          if (resp_handler_cb) {
            {
#line 108
            tmp = (*resp_handler_cb)(resp_pool, "%s %s\r\n", last_numeric, resp->msg);
#line 108
            pr_netio_printf((session.c)->outstrm, "%s", tmp);
            }
          } else {
            {
#line 108
            pr_netio_printf((session.c)->outstrm, "%s %s\r\n", last_numeric, resp->msg);
            }
          }
#line 110
          ml = (unsigned char)0;
        } else {
#line 107
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 115
      if (MultilineRFC2228) {
#line 115
        goto _L;
      } else
#line 115
      if (session.sp_flags) {
        _L: /* CIL Label */ 
        {
#line 116
        pr_trace_msg(trace_channel___5, 1, "%s-%s\r\n", last_numeric, resp->msg);
        }
#line 116
        if (resp_handler_cb) {
          {
#line 116
          tmp___0 = (*resp_handler_cb)(resp_pool, "%s-%s\r\n", last_numeric, resp->msg);
#line 116
          pr_netio_printf((session.c)->outstrm, "%s", tmp___0);
          }
        } else {
          {
#line 116
          pr_netio_printf((session.c)->outstrm, "%s-%s\r\n", last_numeric, resp->msg);
          }
        }
      } else {
        {
#line 120
        pr_trace_msg(trace_channel___5, 1, " %s\r\n", resp->msg);
        }
#line 120
        if (resp_handler_cb) {
          {
#line 120
          tmp___1 = (*resp_handler_cb)(resp_pool, " %s\r\n", resp->msg);
#line 120
          pr_netio_printf((session.c)->outstrm, "%s", tmp___1);
          }
        } else {
          {
#line 120
          pr_netio_printf((session.c)->outstrm, " %s\r\n", resp->msg);
          }
        }
      }
    } else
#line 126
    if (resp->next) {
#line 126
      if (! (resp->next)->num) {
#line 126
        goto _L___3;
      } else {
        {
#line 126
        tmp___5 = strcmp((char const   *)resp->num, (char const   *)(resp->next)->num);
        }
#line 126
        if (tmp___5 == 0) {
          _L___3: /* CIL Label */ 
          {
#line 128
          pr_trace_msg(trace_channel___5, 1, "%s-%s\r\n", resp->num, resp->msg);
          }
#line 128
          if (resp_handler_cb) {
            {
#line 128
            tmp___3 = (*resp_handler_cb)(resp_pool, "%s-%s\r\n", resp->num, resp->msg);
#line 128
            pr_netio_printf((session.c)->outstrm, "%s", tmp___3);
            }
          } else {
            {
#line 128
            pr_netio_printf((session.c)->outstrm, "%s-%s\r\n", resp->num, resp->msg);
            }
          }
#line 130
          ml = (unsigned char)1;
#line 131
          last_numeric = resp->num;
        } else {
#line 126
          goto _L___2;
        }
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 134
      pr_trace_msg(trace_channel___5, 1, "%s %s\r\n", resp->num, resp->msg);
      }
#line 134
      if (resp_handler_cb) {
        {
#line 134
        tmp___4 = (*resp_handler_cb)(resp_pool, "%s %s\r\n", resp->num, resp->msg);
#line 134
        pr_netio_printf((session.c)->outstrm, "%s", tmp___4);
        }
      } else {
        {
#line 134
        pr_netio_printf((session.c)->outstrm, "%s %s\r\n", resp->num, resp->msg);
        }
      }
    }
#line 104
    resp = resp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  pr_response_clear(head___0);
  }
#line 141
  return;
}
}
#line 143 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_add_err)(char const   *numeric , char const   *fmt 
                                                    , ...) 
{ 
  pr_response_t *resp ;
  pr_response_t **head___0 ;
  va_list msg ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 144
  resp = (pr_response_t *)((void *)0);
#line 144
  head___0 = (pr_response_t **)((void *)0);
#line 147
  __builtin_va_start(msg, fmt);
#line 148
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 149
  __builtin_va_end(msg);
#line 151
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 153
  tmp = pcalloc(resp_pool, (int )sizeof(pr_response_t ));
#line 153
  resp = (pr_response_t *)tmp;
  }
#line 154
  if (numeric) {
    {
#line 154
    tmp___0 = pstrdup(resp_pool, numeric);
#line 154
    resp->num = tmp___0;
    }
  } else {
#line 154
    resp->num = (char *)((void *)0);
  }
  {
#line 155
  resp->msg = pstrdup(resp_pool, (char const   *)(resp_buf));
  }
#line 157
  if (resp->num) {
#line 157
    tmp___1 = (char const   *)resp->num;
  } else {
#line 157
    tmp___1 = "(null)";
  }
  {
#line 157
  pr_trace_msg(trace_channel___5, 7, "error response added to pending list: %s %s",
               tmp___1, resp->msg);
#line 160
  head___0 = & resp_err_list;
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (*head___0) {
#line 160
      if (! numeric) {
#line 160
        goto _L;
      } else
#line 160
      if (! (*head___0)->num) {
#line 160
        goto _L;
      } else {
        {
#line 160
        tmp___2 = strcmp((char const   *)(*head___0)->num, numeric);
        }
#line 160
        if (tmp___2 <= 0) {
          _L: /* CIL Label */ 
#line 160
          if (numeric) {
#line 160
            if (! (*head___0)->num) {
#line 160
              if ((unsigned long )head___0 == (unsigned long )(& resp_list)) {
#line 160
                goto while_break;
              }
            }
          }
        } else {
#line 160
          goto while_break;
        }
      }
    } else {
#line 160
      goto while_break;
    }
#line 160
    head___0 = & (*head___0)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  resp->next = *head___0;
#line 167
  *head___0 = resp;
#line 168
  return;
}
}
#line 170 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_add)(char const   *numeric , char const   *fmt 
                                                , ...) 
{ 
  pr_response_t *resp ;
  pr_response_t **head___0 ;
  va_list msg ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 171
  resp = (pr_response_t *)((void *)0);
#line 171
  head___0 = (pr_response_t **)((void *)0);
#line 174
  __builtin_va_start(msg, fmt);
#line 175
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 176
  __builtin_va_end(msg);
#line 178
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 180
  tmp = pcalloc(resp_pool, (int )sizeof(pr_response_t ));
#line 180
  resp = (pr_response_t *)tmp;
  }
#line 181
  if (numeric) {
    {
#line 181
    tmp___0 = pstrdup(resp_pool, numeric);
#line 181
    resp->num = tmp___0;
    }
  } else {
#line 181
    resp->num = (char *)((void *)0);
  }
  {
#line 182
  resp->msg = pstrdup(resp_pool, (char const   *)(resp_buf));
  }
#line 184
  if (resp->num) {
#line 184
    tmp___1 = (char const   *)resp->num;
  } else {
#line 184
    tmp___1 = "(null)";
  }
  {
#line 184
  pr_trace_msg(trace_channel___5, 7, "response added to pending list: %s %s", tmp___1,
               resp->msg);
#line 187
  head___0 = & resp_list;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (*head___0) {
#line 187
      if (! numeric) {
#line 187
        goto _L;
      } else
#line 187
      if (! (*head___0)->num) {
#line 187
        goto _L;
      } else {
        {
#line 187
        tmp___2 = strcmp((char const   *)(*head___0)->num, numeric);
        }
#line 187
        if (tmp___2 <= 0) {
          _L: /* CIL Label */ 
#line 187
          if (numeric) {
#line 187
            if (! (*head___0)->num) {
#line 187
              if ((unsigned long )head___0 == (unsigned long )(& resp_list)) {
#line 187
                goto while_break;
              }
            }
          }
        } else {
#line 187
          goto while_break;
        }
      }
    } else {
#line 187
      goto while_break;
    }
#line 187
    head___0 = & (*head___0)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  resp->next = *head___0;
#line 194
  *head___0 = resp;
#line 195
  return;
}
}
#line 197 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_send_async)(char const   *resp_numeric ,
                                                       char const   *fmt  , ...) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  va_list msg ;
  int maxlen ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 198
  buf___2[0] = (char )'\000';
#line 198
  tmp = 1U;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (tmp >= 1024U) {
#line 198
      goto while_break;
    }
#line 198
    buf___2[tmp] = (char)0;
#line 198
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  if (resp_blocked) {
#line 203
    return;
  }
  {
#line 205
  sstrncpy(buf___2, resp_numeric, (size_t )sizeof(buf___2));
#line 206
  sstrcat(buf___2, " ", (size_t )sizeof(buf___2));
#line 208
  tmp___0 = strlen((char const   *)(buf___2));
#line 208
  maxlen = (int )((sizeof(buf___2) - (unsigned long )tmp___0) - 1UL);
#line 210
  __builtin_va_start(msg, fmt);
#line 211
  tmp___1 = strlen((char const   *)(buf___2));
#line 211
  vsnprintf((char */* __restrict  */)(buf___2 + tmp___1), (size_t )maxlen, (char const   */* __restrict  */)fmt,
            msg);
#line 212
  __builtin_va_end(msg);
#line 214
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 215
  sstrcat(buf___2, "\r\n", (size_t )sizeof(buf___2));
#line 217
  tmp___2 = pstrcat(session.pool, "async: ", "%s", (void *)0);
#line 217
  pr_trace_msg(trace_channel___5, 1, (char const   *)tmp___2, buf___2);
  }
#line 217
  if (resp_handler_cb) {
    {
#line 217
    tmp___3 = (*resp_handler_cb)(resp_pool, "%s", buf___2);
#line 217
    pr_netio_printf_async((session.c)->outstrm, (char *)"%s", tmp___3);
    }
  } else {
    {
#line 217
    pr_netio_printf_async((session.c)->outstrm, (char *)"%s", buf___2);
    }
  }
#line 218
  return;
}
}
#line 220 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_send)(char const   *resp_numeric , char const   *fmt 
                                                 , ...) 
{ 
  va_list msg ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 223
  if (resp_blocked) {
#line 224
    return;
  }
  {
#line 226
  __builtin_va_start(msg, fmt);
#line 227
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 228
  __builtin_va_end(msg);
#line 230
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 232
  pr_trace_msg(trace_channel___5, 1, "%s %s\r\n", resp_numeric, resp_buf);
  }
#line 232
  if (resp_handler_cb) {
    {
#line 232
    tmp = (*resp_handler_cb)(resp_pool, "%s %s\r\n", resp_numeric, resp_buf);
#line 232
    pr_netio_printf((session.c)->outstrm, "%s", tmp);
    }
  } else {
    {
#line 232
    pr_netio_printf((session.c)->outstrm, "%s %s\r\n", resp_numeric, resp_buf);
    }
  }
#line 234
  return;
}
}
#line 236 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_send_ml_start)(char const   *resp_numeric ,
                                                          char const   *fmt  , ...) 
{ 
  va_list msg ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 239
  if (resp_blocked) {
#line 240
    return;
  }
  {
#line 242
  __builtin_va_start(msg, fmt);
#line 243
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 244
  __builtin_va_end(msg);
#line 246
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 247
  sstrncpy(resp_ml_numeric, resp_numeric, (size_t )sizeof(resp_ml_numeric));
#line 249
  pr_trace_msg(trace_channel___5, 1, "%s-%s\r\n", resp_ml_numeric, resp_buf);
  }
#line 249
  if (resp_handler_cb) {
    {
#line 249
    tmp = (*resp_handler_cb)(resp_pool, "%s-%s\r\n", resp_ml_numeric, resp_buf);
#line 249
    pr_netio_printf((session.c)->outstrm, "%s", tmp);
    }
  } else {
    {
#line 249
    pr_netio_printf((session.c)->outstrm, "%s-%s\r\n", resp_ml_numeric, resp_buf);
    }
  }
#line 251
  return;
}
}
#line 253 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_send_ml)(char const   *fmt  , ...) 
{ 
  va_list msg ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 256
  if (resp_blocked) {
#line 257
    return;
  }
  {
#line 259
  __builtin_va_start(msg, fmt);
#line 260
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 261
  __builtin_va_end(msg);
#line 263
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 265
  pr_trace_msg(trace_channel___5, 1, " %s\r\n", resp_buf);
  }
#line 265
  if (resp_handler_cb) {
    {
#line 265
    tmp = (*resp_handler_cb)(resp_pool, " %s\r\n", resp_buf);
#line 265
    pr_netio_printf((session.c)->outstrm, "%s", tmp);
    }
  } else {
    {
#line 265
    pr_netio_printf((session.c)->outstrm, " %s\r\n", resp_buf);
    }
  }
#line 266
  return;
}
}
#line 268 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_send_ml_end)(char const   *fmt  , ...) 
{ 
  va_list msg ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 271
  if (resp_blocked) {
#line 272
    return;
  }
  {
#line 274
  __builtin_va_start(msg, fmt);
#line 275
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 276
  __builtin_va_end(msg);
#line 278
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 280
  pr_trace_msg(trace_channel___5, 1, "%s %s\r\n", resp_ml_numeric, resp_buf);
  }
#line 280
  if (resp_handler_cb) {
    {
#line 280
    tmp = (*resp_handler_cb)(resp_pool, "%s %s\r\n", resp_ml_numeric, resp_buf);
#line 280
    pr_netio_printf((session.c)->outstrm, "%s", tmp);
    }
  } else {
    {
#line 280
    pr_netio_printf((session.c)->outstrm, "%s %s\r\n", resp_ml_numeric, resp_buf);
    }
  }
#line 282
  return;
}
}
#line 284 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/response.c"
void ( /* format attribute */  pr_response_send_raw)(char const   *fmt  , ...) 
{ 
  va_list msg ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 287
  if (resp_blocked) {
#line 288
    return;
  }
  {
#line 290
  __builtin_va_start(msg, fmt);
#line 291
  vsnprintf((char */* __restrict  */)(resp_buf), (size_t )sizeof(resp_buf), (char const   */* __restrict  */)fmt,
            msg);
#line 292
  __builtin_va_end(msg);
#line 294
  resp_buf[sizeof(resp_buf) - 1UL] = (char )'\000';
#line 296
  pr_trace_msg(trace_channel___5, 1, "%s\r\n", resp_buf);
  }
#line 296
  if (resp_handler_cb) {
    {
#line 296
    tmp = (*resp_handler_cb)(resp_pool, "%s\r\n", resp_buf);
#line 296
    pr_netio_printf((session.c)->outstrm, "%s", tmp);
    }
  } else {
    {
#line 296
    pr_netio_printf((session.c)->outstrm, "%s\r\n", resp_buf);
    }
  }
#line 297
  return;
}
}
#line 219 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 77 "../include/support.h"
void run_schedule(void) ;
#line 146 "../include/netio.h"
int pr_netio_lingering_abort(pr_netio_stream_t *nstrm___0 , long linger ) ;
#line 149
int pr_netio_lingering_close(pr_netio_stream_t *nstrm___0 , long linger ) ;
#line 186
pr_netio_stream_t *pr_netio_reopen(pr_netio_stream_t *nstrm___0 , int fd___0 , int mode ) ;
#line 188
int pr_netio_shutdown(pr_netio_stream_t *nstrm___0 , int how ) ;
#line 194
char *pr_netio_telnet_gets(char *buf___2 , size_t buflen , pr_netio_stream_t *in_nstrm ,
                           pr_netio_stream_t *out_nstrm ) ;
#line 205
int pr_netio_write_async(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen ) ;
#line 213
pr_netio_t *pr_alloc_netio(pool *parent_pool ) ;
#line 219
int pr_register_netio(pr_netio_t *netio , int strm_types ) ;
#line 223
int pr_unregister_netio(int strm_types ) ;
#line 227
void init_netio(void) ;
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static char const   *trace_channel___6  =    "netio";
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_t *core_ctrl_netio  =    (pr_netio_t *)((void *)0);
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_t *ctrl_netio  =    (pr_netio_t *)((void *)0);
#line 68 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_t *core_data_netio  =    (pr_netio_t *)((void *)0);
#line 68 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_t *data_netio  =    (pr_netio_t *)((void *)0);
#line 69 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_t *core_othr_netio  =    (pr_netio_t *)((void *)0);
#line 69 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_t *othr_netio  =    (pr_netio_t *)((void *)0);
#line 80 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int properly_terminated_prev_command  =    1;
#line 82 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_stream_t *netio_stream_alloc(pool *parent_pool ) 
{ 
  pool *netio_pool ;
  pr_netio_stream_t *nstrm___0 ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 83
  netio_pool = (pool *)((void *)0);
#line 84
  nstrm___0 = (pr_netio_stream_t *)((void *)0);
#line 86
  if (! parent_pool) {
    {
#line 87
    tmp = __errno_location();
#line 87
    *tmp = 22;
    }
#line 88
    return ((pr_netio_stream_t *)((void *)0));
  }
  {
#line 91
  netio_pool = make_sub_pool(parent_pool);
#line 92
  tmp___0 = pcalloc(netio_pool, (int )sizeof(pr_netio_stream_t ));
#line 92
  nstrm___0 = (pr_netio_stream_t *)tmp___0;
#line 94
  nstrm___0->strm_pool = netio_pool;
#line 95
  nstrm___0->strm_fd = -1;
#line 96
  nstrm___0->strm_mode = 0;
#line 97
  nstrm___0->strm_flags = (unsigned long volatile   )0;
#line 98
  nstrm___0->strm_buf = (pr_buffer_t *)((void *)0);
#line 99
  nstrm___0->strm_data = (void *)0;
#line 100
  nstrm___0->strm_errno = 0;
  }
#line 102
  return (nstrm___0);
}
}
#line 105 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_buffer_t *netio_buffer_alloc(pr_netio_stream_t *nstrm___0 ) 
{ 
  pr_buffer_t *pbuf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 106
  pbuf = (pr_buffer_t *)((void *)0);
#line 108
  tmp = pcalloc(nstrm___0->strm_pool, (int )sizeof(pr_buffer_t ));
#line 108
  pbuf = (pr_buffer_t *)tmp;
#line 111
  tmp___0 = pcalloc(nstrm___0->strm_pool, 1024);
#line 111
  pbuf->buf = (char *)tmp___0;
#line 112
  pbuf->buflen = 1024UL;
#line 117
  pbuf->current = pbuf->buf;
#line 118
  pbuf->remaining = 1024;
#line 121
  nstrm___0->strm_buf = pbuf;
  }
#line 123
  return (pbuf);
}
}
#line 129 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static void core_netio_abort_cb(pr_netio_stream_t *nstrm___0 ) 
{ 


  {
#line 130
  nstrm___0->strm_flags |= (unsigned long volatile   )(1 << 2);
#line 131
  return;
}
}
#line 133 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int core_netio_close_cb(pr_netio_stream_t *nstrm___0 ) 
{ 
  int res ;

  {
  {
#line 136
  res = close(nstrm___0->strm_fd);
#line 137
  nstrm___0->strm_fd = -1;
  }
#line 139
  return (res);
}
}
#line 142 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_stream_t *core_netio_open_cb(pr_netio_stream_t *nstrm___0 , int fd___0 ,
                                             int mode ) 
{ 


  {
#line 145
  nstrm___0->strm_fd = fd___0;
#line 151
  return (nstrm___0);
}
}
#line 154 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int core_netio_poll_cb(pr_netio_stream_t *nstrm___0 ) 
{ 
  int res ;
  fd_set rfds ;
  fd_set *rfdsp ;
  fd_set wfds ;
  fd_set *wfdsp ;
  struct timeval tval ;
  unsigned int __i ;
  fd_set *__arr ;
  unsigned int __i___0 ;
  fd_set *__arr___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    __arr = & rfds;
#line 159
    __i = 0U;
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 159
      if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 159
        goto while_break___0;
      }
#line 159
      __arr->fds_bits[__i] = (__fd_mask )0;
#line 159
      __i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 159
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  rfdsp = (fd_set *)((void *)0);
  {
#line 161
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 161
    __arr___0 = & wfds;
#line 161
    __i___0 = 0U;
    {
#line 161
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 161
      if (! ((unsigned long )__i___0 < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 161
        goto while_break___2;
      }
#line 161
      __arr___0->fds_bits[__i___0] = (__fd_mask )0;
#line 161
      __i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 161
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 162
  wfdsp = (fd_set *)((void *)0);
#line 164
  if (nstrm___0->strm_mode == 1) {
#line 165
    if (nstrm___0->strm_fd >= 0) {
#line 166
      rfds.fds_bits[(unsigned long )nstrm___0->strm_fd / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )nstrm___0->strm_fd % (8UL * sizeof(__fd_mask ));
#line 167
      rfdsp = & rfds;
    }
  } else
#line 171
  if (nstrm___0->strm_fd >= 0) {
#line 172
    wfds.fds_bits[(unsigned long )nstrm___0->strm_fd / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )nstrm___0->strm_fd % (8UL * sizeof(__fd_mask ));
#line 173
    wfdsp = & wfds;
  }
#line 177
  if (nstrm___0->strm_flags & (unsigned long volatile   )(1 << 1)) {
#line 177
    tval.tv_sec = (__time_t )nstrm___0->strm_interval;
  } else {
#line 177
    tval.tv_sec = (__time_t )60;
  }
  {
#line 179
  tval.tv_usec = (__suseconds_t )0;
#line 181
  res = select(nstrm___0->strm_fd + 1, (fd_set */* __restrict  */)rfdsp, (fd_set */* __restrict  */)wfdsp,
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tval));
  }
#line 182
  return (res);
}
}
#line 185 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int core_netio_postopen_cb(pr_netio_stream_t *nstrm___0 ) 
{ 


  {
#line 186
  return (0);
}
}
#line 189 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int core_netio_read_cb(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen ) 
{ 
  ssize_t tmp ;

  {
  {
#line 191
  tmp = read(nstrm___0->strm_fd, (void *)buf___2, buflen);
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static pr_netio_stream_t *core_netio_reopen_cb(pr_netio_stream_t *nstrm___0 , int fd___0 ,
                                               int mode ) 
{ 


  {
#line 197
  if (nstrm___0->strm_fd != -1) {
    {
#line 198
    close(nstrm___0->strm_fd);
    }
  }
#line 200
  nstrm___0->strm_fd = fd___0;
#line 201
  nstrm___0->strm_mode = mode;
#line 203
  return (nstrm___0);
}
}
#line 206 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int core_netio_shutdown_cb(pr_netio_stream_t *nstrm___0 , int how ) 
{ 
  int tmp ;

  {
  {
#line 207
  tmp = shutdown(nstrm___0->strm_fd, how);
  }
#line 207
  return (tmp);
}
}
#line 210 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int core_netio_write_cb(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen ) 
{ 
  ssize_t tmp ;

  {
  {
#line 212
  tmp = write(nstrm___0->strm_fd, (void const   *)buf___2, buflen);
  }
#line 212
  return (tmp);
}
}
#line 218 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
void pr_netio_abort(pr_netio_stream_t *nstrm___0 ) 
{ 
  int *tmp ;

  {
#line 220
  if (! nstrm___0) {
    {
#line 221
    tmp = __errno_location();
#line 221
    *tmp = 22;
    }
#line 222
    return;
  }
#line 225
  if (nstrm___0->strm_type == 16) {
#line 226
    if (ctrl_netio) {
      {
#line 226
      (*(ctrl_netio->abort))(nstrm___0);
      }
    } else {
      {
#line 226
      (*(core_ctrl_netio->abort))(nstrm___0);
      }
    }
  }
#line 229
  if (nstrm___0->strm_type == 32) {
#line 230
    if (data_netio) {
      {
#line 230
      (*(data_netio->abort))(nstrm___0);
      }
    } else {
      {
#line 230
      (*(core_data_netio->abort))(nstrm___0);
      }
    }
  }
#line 233
  if (nstrm___0->strm_type == 64) {
#line 234
    if (othr_netio) {
      {
#line 234
      (*(othr_netio->abort))(nstrm___0);
      }
    } else {
      {
#line 234
      (*(core_othr_netio->abort))(nstrm___0);
      }
    }
  }
#line 237
  return;
}
}
#line 240 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_close(pr_netio_stream_t *nstrm___0 ) 
{ 
  int res ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
#line 241
  res = -1;
#line 243
  if (! nstrm___0) {
    {
#line 244
    tmp = __errno_location();
#line 244
    *tmp = 22;
    }
#line 245
    return (-1);
  }
#line 248
  if (nstrm___0->strm_type == 16) {
#line 249
    if (ctrl_netio) {
      {
#line 249
      tmp___0 = (*(ctrl_netio->close))(nstrm___0);
#line 249
      res = tmp___0;
      }
    } else {
      {
#line 249
      tmp___1 = (*(core_ctrl_netio->close))(nstrm___0);
#line 249
      res = tmp___1;
      }
    }
    {
#line 251
    destroy_pool(nstrm___0->strm_pool);
    }
#line 252
    return (res);
  }
#line 255
  if (nstrm___0->strm_type == 32) {
#line 256
    if (data_netio) {
      {
#line 256
      tmp___2 = (*(data_netio->close))(nstrm___0);
#line 256
      res = tmp___2;
      }
    } else {
      {
#line 256
      tmp___3 = (*(core_data_netio->close))(nstrm___0);
#line 256
      res = tmp___3;
      }
    }
    {
#line 258
    destroy_pool(nstrm___0->strm_pool);
    }
#line 259
    return (res);
  }
#line 262
  if (nstrm___0->strm_type == 64) {
#line 263
    if (othr_netio) {
      {
#line 263
      tmp___4 = (*(othr_netio->close))(nstrm___0);
#line 263
      res = tmp___4;
      }
    } else {
      {
#line 263
      tmp___5 = (*(core_othr_netio->close))(nstrm___0);
#line 263
      res = tmp___5;
      }
    }
    {
#line 265
    destroy_pool(nstrm___0->strm_pool);
    }
#line 266
    return (res);
  }
  {
#line 269
  tmp___6 = __errno_location();
#line 269
  *tmp___6 = 1;
  }
#line 270
  return (res);
}
}
#line 273 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int netio_lingering_close(pr_netio_stream_t *nstrm___0 , long linger , int flags ) 
{ 
  int res ;
  int *tmp ;
  struct timeval tv ;
  fd_set rfds ;
  time_t when ;
  time_t tmp___0 ;
  unsigned int __i ;
  fd_set *__arr ;
  time_t now ;
  time_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 277
  if (! nstrm___0) {
    {
#line 278
    tmp = __errno_location();
#line 278
    *tmp = 22;
    }
#line 279
    return (-1);
  }
#line 282
  if (nstrm___0->strm_fd < 0) {
#line 284
    return (0);
  }
#line 286
  if (! (flags & 1)) {
    {
#line 287
    pr_netio_shutdown(nstrm___0, 1);
    }
  }
#line 289
  if (nstrm___0->strm_fd >= 0) {
    {
#line 292
    tmp___0 = time((time_t *)((void *)0));
#line 292
    when = tmp___0 + linger;
#line 294
    tv.tv_sec = linger;
#line 295
    tv.tv_usec = 0L;
    }
    {
#line 301
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 302
      run_schedule();
      }
      {
#line 304
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 304
        __arr = & rfds;
#line 304
        __i = 0U;
        {
#line 304
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 304
          if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 304
            goto while_break___1;
          }
#line 304
          __arr->fds_bits[__i] = (__fd_mask )0;
#line 304
          __i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 304
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 305
      rfds.fds_bits[(unsigned long )nstrm___0->strm_fd / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )nstrm___0->strm_fd % (8UL * sizeof(__fd_mask ));
#line 307
      pr_trace_msg(trace_channel___6, 8, "lingering %lu secs before closing fd %d",
                   (unsigned long )tv.tv_sec, nstrm___0->strm_fd);
#line 311
      res = select(nstrm___0->strm_fd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 312
      if (res == -1) {
        {
#line 313
        tmp___3 = __errno_location();
        }
#line 313
        if (*tmp___3 == 4) {
          {
#line 314
          tmp___1 = time((time_t *)((void *)0));
#line 314
          now = tmp___1;
#line 315
          pr_signals_handle();
          }
#line 321
          if (now < when) {
#line 322
            tv.tv_sec = when - now;
#line 323
            tv.tv_usec = 0L;
#line 324
            goto while_continue;
          }
        } else {
          {
#line 328
          tmp___2 = __errno_location();
#line 328
          nstrm___0->strm_errno = *tmp___2;
          }
#line 329
          return (-1);
        }
      } else
#line 333
      if ((rfds.fds_bits[(unsigned long )nstrm___0->strm_fd / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )nstrm___0->strm_fd % (8UL * sizeof(__fd_mask )))) != 0L) {
        {
#line 334
        pr_trace_msg(trace_channel___6, 8, "received data for reading on fd %d, ignoring",
                     nstrm___0->strm_fd);
        }
      }
#line 339
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 343
  pr_trace_msg(trace_channel___6, 8, "done lingering, closing fd %d", nstrm___0->strm_fd);
  }
#line 346
  if (nstrm___0->strm_type == 16) {
#line 347
    if (ctrl_netio) {
      {
#line 347
      tmp___4 = (*(ctrl_netio->close))(nstrm___0);
#line 347
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 347
      tmp___5 = (*(core_ctrl_netio->close))(nstrm___0);
#line 347
      tmp___6 = tmp___5;
      }
    }
#line 347
    return (tmp___6);
  }
#line 350
  if (nstrm___0->strm_type == 32) {
#line 351
    if (data_netio) {
      {
#line 351
      tmp___7 = (*(data_netio->close))(nstrm___0);
#line 351
      tmp___9 = tmp___7;
      }
    } else {
      {
#line 351
      tmp___8 = (*(core_data_netio->close))(nstrm___0);
#line 351
      tmp___9 = tmp___8;
      }
    }
#line 351
    return (tmp___9);
  }
#line 354
  if (nstrm___0->strm_type == 64) {
#line 355
    if (othr_netio) {
      {
#line 355
      tmp___10 = (*(othr_netio->close))(nstrm___0);
#line 355
      tmp___12 = tmp___10;
      }
    } else {
      {
#line 355
      tmp___11 = (*(core_othr_netio->close))(nstrm___0);
#line 355
      tmp___12 = tmp___11;
      }
    }
#line 355
    return (tmp___12);
  }
  {
#line 358
  tmp___13 = __errno_location();
#line 358
  *tmp___13 = 1;
  }
#line 359
  return (-1);
}
}
#line 362 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_lingering_abort(pr_netio_stream_t *nstrm___0 , long linger ) 
{ 
  int res ;
  int *tmp ;
  fd_set rs ;
  struct timeval tv ;
  unsigned int __i ;
  fd_set *__arr ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 365
  if (! nstrm___0) {
    {
#line 366
    tmp = __errno_location();
#line 366
    *tmp = 22;
    }
#line 367
    return (-1);
  }
  {
#line 371
  pr_response_send_async("426", "Transfer aborted. Data connection closed.");
#line 373
  pr_netio_shutdown(nstrm___0, 1);
  }
#line 375
  if (nstrm___0->strm_fd >= 0) {
#line 380
    tv.tv_sec = 0L;
#line 381
    tv.tv_usec = 300000L;
    {
#line 383
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 384
      run_schedule();
      }
      {
#line 386
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 386
        __arr = & rs;
#line 386
        __i = 0U;
        {
#line 386
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 386
          if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 386
            goto while_break___1;
          }
#line 386
          __arr->fds_bits[__i] = (__fd_mask )0;
#line 386
          __i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 386
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 387
      rs.fds_bits[(unsigned long )nstrm___0->strm_fd / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )nstrm___0->strm_fd % (8UL * sizeof(__fd_mask ));
#line 389
      res = select(nstrm___0->strm_fd + 1, (fd_set */* __restrict  */)(& rs), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 390
      if (res == -1) {
        {
#line 391
        tmp___1 = __errno_location();
        }
#line 391
        if (*tmp___1 == 4) {
          {
#line 392
          pr_signals_handle();
#line 395
          tv.tv_sec = 0L;
#line 396
          tv.tv_usec = 300000L;
          }
#line 397
          goto while_continue;
        } else {
          {
#line 400
          tmp___0 = __errno_location();
#line 400
          nstrm___0->strm_errno = *tmp___0;
          }
#line 401
          return (-1);
        }
      }
#line 405
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 410
  tmp___2 = netio_lingering_close(nstrm___0, linger, 1);
  }
#line 410
  return (tmp___2);
}
}
#line 414 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_lingering_close(pr_netio_stream_t *nstrm___0 , long linger ) 
{ 
  int tmp ;

  {
  {
#line 415
  tmp = netio_lingering_close(nstrm___0, linger, 0);
  }
#line 415
  return (tmp);
}
}
#line 418 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
pr_netio_stream_t *pr_netio_open(pool *parent_pool , int strm_type , int fd___0 ,
                                 int mode ) 
{ 
  pr_netio_stream_t *nstrm___0 ;
  int *tmp ;
  pr_netio_stream_t *tmp___0 ;
  pr_netio_stream_t *tmp___1 ;
  pr_netio_stream_t *tmp___2 ;
  pr_netio_stream_t *tmp___3 ;
  pr_netio_stream_t *tmp___4 ;
  pr_netio_stream_t *tmp___5 ;
  pr_netio_stream_t *tmp___6 ;
  pr_netio_stream_t *tmp___7 ;
  pr_netio_stream_t *tmp___8 ;
  int *tmp___9 ;

  {
#line 420
  nstrm___0 = (pr_netio_stream_t *)((void *)0);
#line 422
  if (! parent_pool) {
    {
#line 423
    tmp = __errno_location();
#line 423
    *tmp = 22;
    }
#line 424
    return ((pr_netio_stream_t *)((void *)0));
  }
  {
#line 428
  nstrm___0 = netio_stream_alloc(parent_pool);
  }
#line 430
  if (strm_type == 16) {
#line 431
    nstrm___0->strm_type = 16;
#line 432
    nstrm___0->strm_mode = mode;
#line 433
    if (ctrl_netio) {
      {
#line 433
      tmp___0 = (*(ctrl_netio->open))(nstrm___0, fd___0, mode);
#line 433
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 433
      tmp___1 = (*(core_ctrl_netio->open))(nstrm___0, fd___0, mode);
#line 433
      tmp___2 = tmp___1;
      }
    }
#line 433
    return (tmp___2);
  }
#line 437
  if (strm_type == 32) {
#line 438
    nstrm___0->strm_type = 32;
#line 439
    nstrm___0->strm_mode = mode;
#line 440
    if (data_netio) {
      {
#line 440
      tmp___3 = (*(data_netio->open))(nstrm___0, fd___0, mode);
#line 440
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 440
      tmp___4 = (*(core_data_netio->open))(nstrm___0, fd___0, mode);
#line 440
      tmp___5 = tmp___4;
      }
    }
#line 440
    return (tmp___5);
  }
#line 444
  if (strm_type == 64) {
#line 445
    nstrm___0->strm_type = 64;
#line 446
    nstrm___0->strm_mode = mode;
#line 447
    if (othr_netio) {
      {
#line 447
      tmp___6 = (*(othr_netio->open))(nstrm___0, fd___0, mode);
#line 447
      tmp___8 = tmp___6;
      }
    } else {
      {
#line 447
      tmp___7 = (*(core_othr_netio->open))(nstrm___0, fd___0, mode);
#line 447
      tmp___8 = tmp___7;
      }
    }
#line 447
    return (tmp___8);
  }
  {
#line 451
  destroy_pool(nstrm___0->strm_pool);
#line 452
  nstrm___0->strm_pool = (pool *)((void *)0);
#line 454
  tmp___9 = __errno_location();
#line 454
  *tmp___9 = 1;
  }
#line 455
  return ((pr_netio_stream_t *)((void *)0));
}
}
#line 458 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
pr_netio_stream_t *pr_netio_reopen(pr_netio_stream_t *nstrm___0 , int fd___0 , int mode ) 
{ 
  int *tmp ;
  pr_netio_stream_t *tmp___0 ;
  pr_netio_stream_t *tmp___1 ;
  pr_netio_stream_t *tmp___2 ;
  pr_netio_stream_t *tmp___3 ;
  pr_netio_stream_t *tmp___4 ;
  pr_netio_stream_t *tmp___5 ;
  pr_netio_stream_t *tmp___6 ;
  pr_netio_stream_t *tmp___7 ;
  pr_netio_stream_t *tmp___8 ;
  int *tmp___9 ;

  {
#line 460
  if (! nstrm___0) {
    {
#line 461
    tmp = __errno_location();
#line 461
    *tmp = 22;
    }
#line 462
    return ((pr_netio_stream_t *)((void *)0));
  }
#line 465
  if (nstrm___0->strm_type == 16) {
#line 466
    if (ctrl_netio) {
      {
#line 466
      tmp___0 = (*(ctrl_netio->reopen))(nstrm___0, fd___0, mode);
#line 466
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 466
      tmp___1 = (*(core_ctrl_netio->reopen))(nstrm___0, fd___0, mode);
#line 466
      tmp___2 = tmp___1;
      }
    }
#line 466
    return (tmp___2);
  }
#line 469
  if (nstrm___0->strm_type == 32) {
#line 470
    if (data_netio) {
      {
#line 470
      tmp___3 = (*(data_netio->reopen))(nstrm___0, fd___0, mode);
#line 470
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 470
      tmp___4 = (*(core_data_netio->reopen))(nstrm___0, fd___0, mode);
#line 470
      tmp___5 = tmp___4;
      }
    }
#line 470
    return (tmp___5);
  }
#line 473
  if (nstrm___0->strm_type == 64) {
#line 474
    if (othr_netio) {
      {
#line 474
      tmp___6 = (*(othr_netio->reopen))(nstrm___0, fd___0, mode);
#line 474
      tmp___8 = tmp___6;
      }
    } else {
      {
#line 474
      tmp___7 = (*(core_othr_netio->reopen))(nstrm___0, fd___0, mode);
#line 474
      tmp___8 = tmp___7;
      }
    }
#line 474
    return (tmp___8);
  }
  {
#line 477
  tmp___9 = __errno_location();
#line 477
  *tmp___9 = 1;
  }
#line 478
  return ((pr_netio_stream_t *)((void *)0));
}
}
#line 481 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
void pr_netio_reset_poll_interval(pr_netio_stream_t *nstrm___0 ) 
{ 
  int *tmp ;

  {
#line 482
  if (! nstrm___0) {
    {
#line 483
    tmp = __errno_location();
#line 483
    *tmp = 22;
    }
#line 484
    return;
  }
#line 488
  nstrm___0->strm_flags &= (unsigned long volatile   )(~ (1 << 1));
#line 489
  return;
}
}
#line 491 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
void pr_netio_set_poll_interval(pr_netio_stream_t *nstrm___0 , unsigned int secs ) 
{ 
  int *tmp ;

  {
#line 493
  if (! nstrm___0) {
    {
#line 494
    tmp = __errno_location();
#line 494
    *tmp = 22;
    }
#line 495
    return;
  }
#line 498
  nstrm___0->strm_flags |= (unsigned long volatile   )(1 << 1);
#line 499
  nstrm___0->strm_interval = secs;
#line 500
  return;
}
}
#line 502 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_poll(pr_netio_stream_t *nstrm___0 ) 
{ 
  int res ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp15 ;

  {
#line 503
  res = 0;
#line 506
  if (! nstrm___0) {
    {
#line 507
    tmp = __errno_location();
#line 507
    *tmp = 22;
    }
#line 508
    return (-1);
  }
#line 511
  if (nstrm___0->strm_fd == -1) {
    {
#line 512
    tmp___0 = __errno_location();
#line 512
    *tmp___0 = 9;
    }
#line 513
    return (-1);
  }
#line 517
  if (nstrm___0->strm_flags & (unsigned long volatile   )(1 << 2)) {
#line 518
    nstrm___0->strm_flags &= (unsigned long volatile   )(~ (1 << 2));
#line 519
    return (1);
  }
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 523
    run_schedule();
#line 524
    pr_signals_handle();
    }
    {
#line 527
    if (nstrm___0->strm_type == 16) {
#line 527
      goto case_16;
    }
#line 532
    if (nstrm___0->strm_type == 32) {
#line 532
      goto case_32;
    }
#line 537
    if (nstrm___0->strm_type == 64) {
#line 537
      goto case_64;
    }
#line 526
    goto switch_break;
    case_16: /* CIL Label */ 
#line 528
    if (ctrl_netio) {
      {
#line 528
      tmp___1 = (*(ctrl_netio->poll))(nstrm___0);
#line 528
      res = tmp___1;
      }
    } else {
      {
#line 528
      tmp___2 = (*(core_ctrl_netio->poll))(nstrm___0);
#line 528
      res = tmp___2;
      }
    }
#line 530
    goto switch_break;
    case_32: /* CIL Label */ 
#line 533
    if (data_netio) {
      {
#line 533
      tmp___3 = (*(data_netio->poll))(nstrm___0);
#line 533
      res = tmp___3;
      }
    } else {
      {
#line 533
      tmp___4 = (*(core_data_netio->poll))(nstrm___0);
#line 533
      res = tmp___4;
      }
    }
#line 535
    goto switch_break;
    case_64: /* CIL Label */ 
#line 538
    if (othr_netio) {
      {
#line 538
      tmp___5 = (*(othr_netio->poll))(nstrm___0);
#line 538
      res = tmp___5;
      }
    } else {
      {
#line 538
      tmp___6 = (*(core_othr_netio->poll))(nstrm___0);
#line 538
      res = tmp___6;
      }
    }
#line 540
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 544
    if (res == -1) {
#line 544
      goto case_neg_1;
    }
#line 574
    if (res == 0) {
#line 574
      goto case_0;
    }
#line 593
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 545
    tmp___7 = __errno_location();
    }
#line 545
    if (*tmp___7 == 4) {
#line 546
      if (nstrm___0->strm_flags & (unsigned long volatile   )(1 << 2)) {
#line 547
        nstrm___0->strm_flags &= (unsigned long volatile   )(~ (1 << 2));
#line 548
        return (1);
      }
      {
#line 552
      pr_signals_handle();
      }
#line 553
      goto while_continue;
    }
    {
#line 557
    tmp___8 = __errno_location();
#line 557
    nstrm___0->strm_errno = *tmp___8;
#line 563
    tmp___9 = __errno_location();
    }
#line 563
    if (*tmp___9 == 32) {
#line 563
      if (nstrm___0->strm_type == 16) {
#line 563
        if (session.sf_flags & (int volatile   )4) {
          {
#line 566
          pr_trace_msg(trace_channel___6, 5, "received EPIPE on control connection, setting \'aborted\' session flag");
#line 569
          session.sf_flags |= (int volatile   )2;
          }
        }
      }
    }
#line 572
    return (-1);
    case_0: /* CIL Label */ 
#line 576
    if (nstrm___0->strm_flags & (unsigned long volatile   )(1 << 2)) {
#line 577
      nstrm___0->strm_flags &= (unsigned long volatile   )(~ (1 << 2));
#line 578
      return (1);
    }
#line 585
    if (nstrm___0->strm_flags & (unsigned long volatile   )(1 << 1)) {
#line 585
      if (nstrm___0->strm_interval == 0U) {
        {
#line 587
        tmp___10 = __errno_location();
#line 587
        *tmp___10 = -1;
        }
#line 588
        return (-1);
      }
    }
#line 591
    goto while_continue;
    switch_default: /* CIL Label */ 
#line 594
    return (0);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  return (-1);
}
}
#line 602 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_postopen(pr_netio_stream_t *nstrm___0 ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 603
  if (! nstrm___0) {
    {
#line 604
    tmp = __errno_location();
#line 604
    *tmp = 22;
    }
#line 605
    return (-1);
  }
#line 608
  if (nstrm___0->strm_type == 16) {
#line 609
    if (ctrl_netio) {
      {
#line 609
      tmp___0 = (*(ctrl_netio->postopen))(nstrm___0);
#line 609
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 609
      tmp___1 = (*(core_ctrl_netio->postopen))(nstrm___0);
#line 609
      tmp___2 = tmp___1;
      }
    }
#line 609
    return (tmp___2);
  }
#line 612
  if (nstrm___0->strm_type == 32) {
#line 613
    if (data_netio) {
      {
#line 613
      tmp___3 = (*(data_netio->postopen))(nstrm___0);
#line 613
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 613
      tmp___4 = (*(core_data_netio->postopen))(nstrm___0);
#line 613
      tmp___5 = tmp___4;
      }
    }
#line 613
    return (tmp___5);
  }
#line 616
  if (nstrm___0->strm_type == 64) {
#line 617
    if (othr_netio) {
      {
#line 617
      tmp___6 = (*(othr_netio->postopen))(nstrm___0);
#line 617
      tmp___8 = tmp___6;
      }
    } else {
      {
#line 617
      tmp___7 = (*(core_othr_netio->postopen))(nstrm___0);
#line 617
      tmp___8 = tmp___7;
      }
    }
#line 617
    return (tmp___8);
  }
  {
#line 620
  tmp___9 = __errno_location();
#line 620
  *tmp___9 = 1;
  }
#line 621
  return (-1);
}
}
#line 624 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_printf(pr_netio_stream_t *nstrm___0 , char const   *fmt  , ...) 
{ 
  va_list msg ;
  char buf___2[5120] ;
  unsigned int tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp9 ;

  {
#line 626
  buf___2[0] = (char )'\000';
#line 626
  tmp = 1U;
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    if (tmp >= 5120U) {
#line 626
      goto while_break;
    }
#line 626
    buf___2[tmp] = (char)0;
#line 626
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  if (! nstrm___0) {
    {
#line 629
    tmp___0 = __errno_location();
#line 629
    *tmp___0 = 22;
    }
#line 630
    return (-1);
  }
  {
#line 633
  __builtin_va_start(msg, fmt);
#line 634
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 635
  __builtin_va_end(msg);
#line 636
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 638
  tmp___1 = strlen((char const   *)(buf___2));
#line 638
  tmp___2 = pr_netio_write(nstrm___0, buf___2, tmp___1);
  }
#line 638
  return (tmp___2);
}
}
#line 641 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_printf_async(pr_netio_stream_t *nstrm___0 , char *fmt  , ...) 
{ 
  va_list msg ;
  char buf___2[5120] ;
  unsigned int tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp9 ;

  {
#line 643
  buf___2[0] = (char )'\000';
#line 643
  tmp = 1U;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (tmp >= 5120U) {
#line 643
      goto while_break;
    }
#line 643
    buf___2[tmp] = (char)0;
#line 643
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  if (! nstrm___0) {
    {
#line 646
    tmp___0 = __errno_location();
#line 646
    *tmp___0 = 22;
    }
#line 647
    return (-1);
  }
  {
#line 650
  __builtin_va_start(msg, fmt);
#line 651
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 652
  __builtin_va_end(msg);
#line 653
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 655
  tmp___1 = strlen((char const   *)(buf___2));
#line 655
  tmp___2 = pr_netio_write_async(nstrm___0, buf___2, tmp___1);
  }
#line 655
  return (tmp___2);
}
}
#line 658 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_write(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen ) 
{ 
  int bwritten ;
  int total ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 659
  bwritten = 0;
#line 659
  total = 0;
#line 662
  if (! nstrm___0) {
    {
#line 663
    tmp = __errno_location();
#line 663
    *tmp = 22;
    }
#line 664
    return (-1);
  }
#line 667
  if (nstrm___0->strm_fd == -1) {
    {
#line 668
    tmp___0 = __errno_location();
    }
#line 668
    if (nstrm___0->strm_errno) {
#line 668
      *tmp___0 = nstrm___0->strm_errno;
    } else {
#line 668
      *tmp___0 = 9;
    }
#line 669
    return (-1);
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! buflen) {
#line 672
      goto while_break;
    }
    {
#line 674
    tmp___1 = pr_netio_poll(nstrm___0);
    }
    {
#line 675
    if (tmp___1 == 1) {
#line 675
      goto case_1;
    }
#line 678
    if (tmp___1 == -1) {
#line 678
      goto case_neg_1;
    }
#line 681
    goto switch_default;
    case_1: /* CIL Label */ 
#line 676
    return (-2);
    case_neg_1: /* CIL Label */ 
#line 679
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 683
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 684
      pr_signals_handle();
#line 685
      run_schedule();
      }
      {
#line 688
      if (nstrm___0->strm_type == 16) {
#line 688
        goto case_16;
      }
#line 693
      if (nstrm___0->strm_type == 32) {
#line 693
        goto case_32;
      }
#line 701
      if (nstrm___0->strm_type == 64) {
#line 701
        goto case_64;
      }
#line 687
      goto switch_break___0;
      case_16: /* CIL Label */ 
#line 689
      if (ctrl_netio) {
        {
#line 689
        tmp___2 = (*(ctrl_netio->write))(nstrm___0, buf___2, buflen);
#line 689
        bwritten = tmp___2;
        }
      } else {
        {
#line 689
        tmp___3 = (*(core_ctrl_netio->write))(nstrm___0, buf___2, buflen);
#line 689
        bwritten = tmp___3;
        }
      }
#line 691
      goto switch_break___0;
      case_32: /* CIL Label */ 
#line 694
      if (session.sf_flags & (int volatile   )2) {
#line 695
        goto switch_break___0;
      }
#line 697
      if (data_netio) {
        {
#line 697
        tmp___4 = (*(data_netio->write))(nstrm___0, buf___2, buflen);
#line 697
        bwritten = tmp___4;
        }
      } else {
        {
#line 697
        tmp___5 = (*(core_data_netio->write))(nstrm___0, buf___2, buflen);
#line 697
        bwritten = tmp___5;
        }
      }
#line 699
      goto switch_break___0;
      case_64: /* CIL Label */ 
#line 702
      if (othr_netio) {
        {
#line 702
        tmp___6 = (*(othr_netio->write))(nstrm___0, buf___2, buflen);
#line 702
        bwritten = tmp___6;
        }
      } else {
        {
#line 702
        tmp___7 = (*(core_othr_netio->write))(nstrm___0, buf___2, buflen);
#line 702
        bwritten = tmp___7;
        }
      }
#line 704
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 683
      if (bwritten == -1) {
        {
#line 683
        tmp___8 = __errno_location();
        }
#line 683
        if (! (*tmp___8 == 4)) {
#line 683
          goto while_break___0;
        }
      } else {
#line 683
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 711
    if (bwritten == -1) {
      {
#line 712
      tmp___9 = __errno_location();
#line 712
      nstrm___0->strm_errno = *tmp___9;
      }
#line 713
      return (-1);
    }
#line 716
    buf___2 += bwritten;
#line 717
    total += bwritten;
#line 718
    buflen -= (size_t )bwritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  return (total);
}
}
#line 724 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_write_async(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen ) 
{ 
  int flags ;
  int bwritten ;
  int total ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 725
  flags = 0;
#line 726
  bwritten = 0;
#line 726
  total = 0;
#line 729
  if (! nstrm___0) {
    {
#line 730
    tmp = __errno_location();
#line 730
    *tmp = 22;
    }
#line 731
    return (-1);
  }
#line 734
  if (nstrm___0->strm_fd == -1) {
    {
#line 735
    tmp___0 = __errno_location();
    }
#line 735
    if (nstrm___0->strm_errno) {
#line 735
      *tmp___0 = nstrm___0->strm_errno;
    } else {
#line 735
      *tmp___0 = 9;
    }
#line 736
    return (-1);
  }
  {
#line 740
  flags = fcntl(nstrm___0->strm_fd, 3);
  }
#line 740
  if (flags == -1) {
#line 741
    return (-1);
  }
  {
#line 743
  tmp___1 = fcntl(nstrm___0->strm_fd, 4, flags | 2048);
  }
#line 743
  if (tmp___1 == -1) {
#line 744
    return (-1);
  }
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! buflen) {
#line 746
      goto while_break;
    }
    {
#line 747
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 756
      pr_signals_handle();
      }
      {
#line 759
      if (nstrm___0->strm_type == 16) {
#line 759
        goto case_16;
      }
#line 764
      if (nstrm___0->strm_type == 32) {
#line 764
        goto case_32;
      }
#line 769
      if (nstrm___0->strm_type == 64) {
#line 769
        goto case_64;
      }
#line 758
      goto switch_break;
      case_16: /* CIL Label */ 
#line 760
      if (ctrl_netio) {
        {
#line 760
        tmp___2 = (*(ctrl_netio->write))(nstrm___0, buf___2, buflen);
#line 760
        bwritten = tmp___2;
        }
      } else {
        {
#line 760
        tmp___3 = (*(core_ctrl_netio->write))(nstrm___0, buf___2, buflen);
#line 760
        bwritten = tmp___3;
        }
      }
#line 762
      goto switch_break;
      case_32: /* CIL Label */ 
#line 765
      if (data_netio) {
        {
#line 765
        tmp___4 = (*(data_netio->write))(nstrm___0, buf___2, buflen);
#line 765
        bwritten = tmp___4;
        }
      } else {
        {
#line 765
        tmp___5 = (*(core_data_netio->write))(nstrm___0, buf___2, buflen);
#line 765
        bwritten = tmp___5;
        }
      }
#line 767
      goto switch_break;
      case_64: /* CIL Label */ 
#line 770
      if (othr_netio) {
        {
#line 770
        tmp___6 = (*(othr_netio->write))(nstrm___0, buf___2, buflen);
#line 770
        bwritten = tmp___6;
        }
      } else {
        {
#line 770
        tmp___7 = (*(core_othr_netio->write))(nstrm___0, buf___2, buflen);
#line 770
        bwritten = tmp___7;
        }
      }
#line 772
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 747
      if (bwritten == -1) {
        {
#line 747
        tmp___8 = __errno_location();
        }
#line 747
        if (! (*tmp___8 == 4)) {
#line 747
          goto while_break___0;
        }
      } else {
#line 747
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 777
    if (bwritten < 0) {
      {
#line 778
      tmp___9 = __errno_location();
#line 778
      nstrm___0->strm_errno = *tmp___9;
#line 779
      fcntl(nstrm___0->strm_fd, 4, flags);
      }
#line 781
      if (nstrm___0->strm_errno == 11) {
#line 783
        return (total);
      }
#line 785
      return (-1);
    }
#line 788
    buf___2 += bwritten;
#line 789
    total += bwritten;
#line 790
    buflen -= (size_t )bwritten;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 793
  fcntl(nstrm___0->strm_fd, 4, flags);
  }
#line 794
  return (total);
}
}
#line 797 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_read(pr_netio_stream_t *nstrm___0 , char *buf___2 , size_t buflen , int bufmin ) 
{ 
  int bread ;
  int total ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp19 ;

  {
#line 799
  bread = 0;
#line 799
  total = 0;
#line 802
  if (! nstrm___0) {
    {
#line 803
    tmp = __errno_location();
#line 803
    *tmp = 22;
    }
#line 804
    return (-1);
  }
#line 807
  if (nstrm___0->strm_fd == -1) {
    {
#line 808
    tmp___0 = __errno_location();
    }
#line 808
    if (nstrm___0->strm_errno) {
#line 808
      *tmp___0 = nstrm___0->strm_errno;
    } else {
#line 808
      *tmp___0 = 9;
    }
#line 809
    return (-1);
  }
#line 812
  if (bufmin < 1) {
#line 813
    bufmin = 1;
  }
#line 815
  if ((size_t )bufmin > buflen) {
#line 816
    bufmin = (int )buflen;
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (bufmin > 0)) {
#line 818
      goto while_break;
    }
    polling: 
    {
#line 821
    tmp___1 = pr_netio_poll(nstrm___0);
    }
    {
#line 822
    if (tmp___1 == 1) {
#line 822
      goto case_1;
    }
#line 825
    if (tmp___1 == -1) {
#line 825
      goto case_neg_1;
    }
#line 828
    goto switch_default;
    case_1: /* CIL Label */ 
#line 823
    return (-2);
    case_neg_1: /* CIL Label */ 
#line 826
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 829
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 830
      pr_signals_handle();
#line 832
      run_schedule();
      }
      {
#line 835
      if (nstrm___0->strm_type == 16) {
#line 835
        goto case_16;
      }
#line 840
      if (nstrm___0->strm_type == 32) {
#line 840
        goto case_32;
      }
#line 848
      if (nstrm___0->strm_type == 64) {
#line 848
        goto case_64;
      }
#line 834
      goto switch_break___0;
      case_16: /* CIL Label */ 
#line 836
      if (ctrl_netio) {
        {
#line 836
        tmp___2 = (*(ctrl_netio->read))(nstrm___0, buf___2, buflen);
#line 836
        bread = tmp___2;
        }
      } else {
        {
#line 836
        tmp___3 = (*(core_ctrl_netio->read))(nstrm___0, buf___2, buflen);
#line 836
        bread = tmp___3;
        }
      }
#line 838
      goto switch_break___0;
      case_32: /* CIL Label */ 
#line 841
      if (session.sf_flags & (int volatile   )2) {
#line 842
        goto switch_break___0;
      }
#line 844
      if (data_netio) {
        {
#line 844
        tmp___4 = (*(data_netio->read))(nstrm___0, buf___2, buflen);
#line 844
        bread = tmp___4;
        }
      } else {
        {
#line 844
        tmp___5 = (*(core_data_netio->read))(nstrm___0, buf___2, buflen);
#line 844
        bread = tmp___5;
        }
      }
#line 846
      goto switch_break___0;
      case_64: /* CIL Label */ 
#line 849
      if (othr_netio) {
        {
#line 849
        tmp___6 = (*(othr_netio->read))(nstrm___0, buf___2, buflen);
#line 849
        bread = tmp___6;
        }
      } else {
        {
#line 849
        tmp___7 = (*(core_othr_netio->read))(nstrm___0, buf___2, buflen);
#line 849
        bread = tmp___7;
        }
      }
#line 851
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 855
      if (bread == -1) {
        {
#line 855
        tmp___8 = __errno_location();
        }
#line 855
        if (*tmp___8 == 11) {
#line 856
          goto polling;
        }
      }
#line 829
      if (bread == -1) {
        {
#line 829
        tmp___9 = __errno_location();
        }
#line 829
        if (! (*tmp___9 == 4)) {
#line 829
          goto while_break___0;
        }
      } else {
#line 829
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 860
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 863
    if (bread == -1) {
      {
#line 864
      tmp___10 = __errno_location();
#line 864
      nstrm___0->strm_errno = *tmp___10;
      }
#line 865
      return (-1);
    }
#line 869
    if (bread == 0) {
#line 870
      if (nstrm___0->strm_type == 16) {
        {
#line 871
        pr_trace_msg(trace_channel___6, 7, "read %d bytes from control stream fd %d, handling as EOF",
                     bread, nstrm___0->strm_fd);
        }
      }
#line 876
      nstrm___0->strm_errno = 0;
#line 877
      goto while_break;
    }
#line 880
    buf___2 += bread;
#line 881
    total += bread;
#line 882
    bufmin -= bread;
#line 883
    buflen -= (size_t )bread;
  }
  while_break: /* CIL Label */ ;
  }
#line 886
  return (total);
}
}
#line 889 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_netio_shutdown(pr_netio_stream_t *nstrm___0 , int how ) 
{ 
  int res ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
#line 890
  res = -1;
#line 892
  if (! nstrm___0) {
    {
#line 893
    tmp = __errno_location();
#line 893
    *tmp = 22;
    }
#line 894
    return (-1);
  }
#line 897
  if (nstrm___0->strm_type == 16) {
#line 898
    if (ctrl_netio) {
      {
#line 898
      tmp___0 = (*(ctrl_netio->shutdown))(nstrm___0, how);
#line 898
      res = tmp___0;
      }
    } else {
      {
#line 898
      tmp___1 = (*(core_ctrl_netio->shutdown))(nstrm___0, how);
#line 898
      res = tmp___1;
      }
    }
#line 900
    return (res);
  }
#line 903
  if (nstrm___0->strm_type == 32) {
#line 904
    if (data_netio) {
      {
#line 904
      tmp___2 = (*(data_netio->shutdown))(nstrm___0, how);
#line 904
      res = tmp___2;
      }
    } else {
      {
#line 904
      tmp___3 = (*(core_data_netio->shutdown))(nstrm___0, how);
#line 904
      res = tmp___3;
      }
    }
#line 906
    return (res);
  }
#line 909
  if (nstrm___0->strm_type == 64) {
#line 910
    if (othr_netio) {
      {
#line 910
      tmp___4 = (*(othr_netio->shutdown))(nstrm___0, how);
#line 910
      res = tmp___4;
      }
    } else {
      {
#line 910
      tmp___5 = (*(core_othr_netio->shutdown))(nstrm___0, how);
#line 910
      res = tmp___5;
      }
    }
#line 912
    return (res);
  }
  {
#line 915
  tmp___6 = __errno_location();
#line 915
  *tmp___6 = 1;
  }
#line 916
  return (res);
}
}
#line 919 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
char *pr_netio_gets(char *buf___2 , size_t buflen , pr_netio_stream_t *nstrm___0 ) 
{ 
  char *bp ;
  int toread ;
  pr_buffer_t *pbuf ;
  int *tmp ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 920
  bp = buf___2;
#line 922
  pbuf = (pr_buffer_t *)((void *)0);
#line 924
  if (buflen == 0U) {
    {
#line 925
    tmp = __errno_location();
#line 925
    *tmp = 22;
    }
#line 926
    return ((char *)((void *)0));
  }
#line 929
  buflen --;
#line 931
  if (nstrm___0->strm_buf) {
#line 932
    pbuf = nstrm___0->strm_buf;
  } else {
    {
#line 934
    pbuf = netio_buffer_alloc(nstrm___0);
    }
  }
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! buflen) {
#line 936
      goto while_break;
    }
#line 939
    if (! pbuf->current) {
#line 939
      goto _L;
    } else
#line 939
    if ((unsigned long )pbuf->remaining == pbuf->buflen) {
      _L: /* CIL Label */ 
#line 942
      if ((unsigned long )buflen < pbuf->buflen) {
#line 942
        tmp___0 = (unsigned long )buflen;
      } else {
#line 942
        tmp___0 = pbuf->buflen;
      }
      {
#line 942
      toread = pr_netio_read(nstrm___0, pbuf->buf, (size_t )tmp___0, 1);
      }
#line 945
      if (toread <= 0) {
#line 946
        if ((unsigned long )bp != (unsigned long )buf___2) {
#line 947
          *bp = (char )'\000';
#line 948
          return (buf___2);
        } else {
#line 951
          return ((char *)((void *)0));
        }
      }
#line 954
      pbuf->remaining = (int )(pbuf->buflen - (unsigned long )toread);
#line 955
      pbuf->current = pbuf->buf;
    } else {
#line 958
      toread = (int )(pbuf->buflen - (unsigned long )pbuf->remaining);
    }
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 960
      if (buflen) {
#line 960
        if ((int )*(pbuf->current) != 10) {
#line 960
          tmp___3 = toread;
#line 960
          toread --;
#line 960
          if (! tmp___3) {
#line 960
            goto while_break___0;
          }
        } else {
#line 960
          goto while_break___0;
        }
      } else {
#line 960
        goto while_break___0;
      }
#line 961
      if ((int )*(pbuf->current) & 128) {
#line 962
        (pbuf->current) ++;
      } else {
#line 965
        tmp___1 = bp;
#line 965
        bp ++;
#line 965
        tmp___2 = pbuf->current;
#line 965
        (pbuf->current) ++;
#line 965
        *tmp___1 = *tmp___2;
#line 966
        buflen --;
      }
#line 968
      (pbuf->remaining) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 971
    if (buflen) {
#line 971
      if (toread) {
#line 971
        if ((int )*(pbuf->current) == 10) {
#line 972
          buflen --;
#line 973
          toread --;
#line 974
          tmp___4 = bp;
#line 974
          bp ++;
#line 974
          tmp___5 = pbuf->current;
#line 974
          (pbuf->current) ++;
#line 974
          *tmp___4 = *tmp___5;
#line 975
          (pbuf->remaining) ++;
#line 976
          goto while_break;
        }
      }
    }
#line 979
    if (! toread) {
#line 980
      pbuf->current = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 983
  *bp = (char )'\000';
#line 984
  return (buf___2);
}
}
#line 987 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
static int telnet_mode  =    0;
#line 989 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
char *pr_netio_telnet_gets(char *buf___2 , size_t buflen , pr_netio_stream_t *in_nstrm ,
                           pr_netio_stream_t *out_nstrm ) 
{ 
  char *bp ;
  unsigned char cp ;
  int toread ;
  int handle_iac ;
  int saw_newline ;
  pr_buffer_t *pbuf ;
  int *tmp ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 991
  bp = buf___2;
#line 993
  handle_iac = 1;
#line 993
  saw_newline = 0;
#line 994
  pbuf = (pr_buffer_t *)((void *)0);
#line 996
  if (buflen == 0U) {
    {
#line 997
    tmp = __errno_location();
#line 997
    *tmp = 22;
    }
#line 998
    return ((char *)((void *)0));
  }
#line 1005
  buflen --;
#line 1007
  if (in_nstrm->strm_buf) {
#line 1008
    pbuf = in_nstrm->strm_buf;
  } else {
    {
#line 1010
    pbuf = netio_buffer_alloc(in_nstrm);
    }
  }
  {
#line 1012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1012
    if (! buflen) {
#line 1012
      goto while_break;
    }
#line 1015
    if (! pbuf->current) {
#line 1015
      goto _L;
    } else
#line 1015
    if ((unsigned long )pbuf->remaining == pbuf->buflen) {
      _L: /* CIL Label */ 
#line 1018
      if ((unsigned long )buflen < pbuf->buflen) {
#line 1018
        tmp___0 = (unsigned long )buflen;
      } else {
#line 1018
        tmp___0 = pbuf->buflen;
      }
      {
#line 1018
      toread = pr_netio_read(in_nstrm, pbuf->buf, (size_t )tmp___0, 1);
      }
#line 1021
      if (toread <= 0) {
#line 1022
        if ((unsigned long )bp != (unsigned long )buf___2) {
#line 1023
          *bp = (char )'\000';
#line 1024
          return (buf___2);
        } else {
#line 1027
          return ((char *)((void *)0));
        }
      }
#line 1031
      pbuf->remaining = (int )(pbuf->buflen - (unsigned long )toread);
#line 1032
      pbuf->current = pbuf->buf;
    } else {
#line 1035
      toread = (int )(pbuf->buflen - (unsigned long )pbuf->remaining);
    }
    {
#line 1037
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1037
      if (buflen) {
#line 1037
        if (toread > 0) {
#line 1037
          if ((int )*(pbuf->current) != 10) {
#line 1037
            tmp___4 = toread;
#line 1037
            toread --;
#line 1037
            if (! tmp___4) {
#line 1037
              goto while_break___0;
            }
          } else {
#line 1037
            goto while_break___0;
          }
        } else {
#line 1037
          goto while_break___0;
        }
      } else {
#line 1037
        goto while_break___0;
      }
#line 1038
      tmp___1 = pbuf->current;
#line 1038
      (pbuf->current) ++;
#line 1038
      cp = (unsigned char )*tmp___1;
#line 1039
      (pbuf->remaining) ++;
#line 1041
      if (handle_iac == 1) {
        {
#line 1043
        if (telnet_mode == 255) {
#line 1043
          goto case_255;
        }
#line 1079
        if (telnet_mode == 252) {
#line 1079
          goto case_252___0;
        }
#line 1079
        if (telnet_mode == 251) {
#line 1079
          goto case_252___0;
        }
#line 1085
        if (telnet_mode == 254) {
#line 1085
          goto case_254___0;
        }
#line 1085
        if (telnet_mode == 253) {
#line 1085
          goto case_254___0;
        }
#line 1092
        goto switch_default___0;
        case_255: /* CIL Label */ 
        {
#line 1050
        if ((int )cp == 242) {
#line 1050
          goto case_242;
        }
#line 1050
        if ((int )cp == 244) {
#line 1050
          goto case_242;
        }
#line 1050
        if ((int )cp == 254) {
#line 1050
          goto case_242;
        }
#line 1050
        if ((int )cp == 253) {
#line 1050
          goto case_242;
        }
#line 1050
        if ((int )cp == 252) {
#line 1050
          goto case_242;
        }
#line 1050
        if ((int )cp == 251) {
#line 1050
          goto case_242;
        }
#line 1063
        goto switch_default;
        case_242: /* CIL Label */ 
        case_244: /* CIL Label */ 
        case_254: /* CIL Label */ 
        case_253: /* CIL Label */ 
        case_252: /* CIL Label */ 
        case_251: /* CIL Label */ 
#line 1060
        telnet_mode = (int )cp;
#line 1061
        goto while_continue___0;
        switch_default: /* CIL Label */ 
#line 1070
        tmp___2 = bp;
#line 1070
        bp ++;
#line 1070
        *tmp___2 = (char)-1;
#line 1071
        buflen --;
#line 1073
        telnet_mode = 0;
#line 1074
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 1076
        goto switch_break;
        case_252___0: /* CIL Label */ 
        case_251___0: /* CIL Label */ 
        {
#line 1080
        pr_netio_printf(out_nstrm, "%c%c%c", 255, 254, (int )cp);
#line 1081
        telnet_mode = 0;
        }
#line 1082
        goto while_continue___0;
        case_254___0: /* CIL Label */ 
        case_253___0: /* CIL Label */ 
        {
#line 1086
        pr_netio_printf(out_nstrm, "%c%c%c", 255, 252, (int )cp);
#line 1087
        telnet_mode = 0;
        }
#line 1088
        goto while_continue___0;
        switch_default___0: /* CIL Label */ 
#line 1093
        if ((int )cp == 255) {
#line 1094
          telnet_mode = (int )cp;
#line 1095
          goto while_continue___0;
        }
#line 1097
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1101
      tmp___3 = bp;
#line 1101
      bp ++;
#line 1101
      *tmp___3 = (char )cp;
#line 1102
      buflen --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1105
    if (buflen) {
#line 1105
      if (toread) {
#line 1105
        if ((int )*(pbuf->current) == 10) {
#line 1106
          buflen --;
#line 1107
          toread --;
#line 1108
          tmp___5 = bp;
#line 1108
          bp ++;
#line 1108
          tmp___6 = pbuf->current;
#line 1108
          (pbuf->current) ++;
#line 1108
          *tmp___5 = *tmp___6;
#line 1109
          (pbuf->remaining) ++;
#line 1111
          saw_newline = 1;
#line 1112
          goto while_break;
        }
      }
    }
#line 1115
    if (! toread) {
#line 1116
      pbuf->current = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1119
  if (! saw_newline) {
    {
#line 1125
    properly_terminated_prev_command = 0;
#line 1126
    tmp___7 = __errno_location();
#line 1126
    *tmp___7 = 7;
    }
#line 1127
    return ((char *)((void *)0));
  }
#line 1130
  if (! properly_terminated_prev_command) {
    {
#line 1131
    properly_terminated_prev_command = 1;
#line 1132
    pr_log_pri(5, "client sent too-long command, ignoring");
#line 1133
    tmp___8 = __errno_location();
#line 1133
    *tmp___8 = 7;
    }
#line 1134
    return ((char *)((void *)0));
  }
#line 1137
  properly_terminated_prev_command = 1;
#line 1138
  *bp = (char )'\000';
#line 1139
  return (buf___2);
}
}
#line 1142 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_register_netio(pr_netio_t *netio , int strm_types ) 
{ 
  pr_netio_t *core_netio ;
  int *tmp ;

  {
#line 1144
  if (! netio) {
#line 1145
    core_netio = (pr_netio_t *)((void *)0);
#line 1149
    if (! core_ctrl_netio) {
      {
#line 1150
      core_ctrl_netio = pr_alloc_netio(permanent_pool);
#line 1150
      core_netio = core_ctrl_netio;
      }
    }
#line 1152
    if (! core_data_netio) {
#line 1153
      if (core_netio) {
#line 1153
        core_data_netio = core_netio;
      } else {
        {
#line 1153
        core_netio = pr_alloc_netio(permanent_pool);
#line 1153
        core_data_netio = core_netio;
        }
      }
    }
#line 1156
    if (! core_othr_netio) {
#line 1157
      if (core_netio) {
#line 1157
        core_othr_netio = core_netio;
      } else {
        {
#line 1157
        core_netio = pr_alloc_netio(permanent_pool);
#line 1157
        core_othr_netio = core_netio;
        }
      }
    }
#line 1160
    return (0);
  }
#line 1163
  if (! netio->abort) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->close) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->open) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->poll) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->postopen) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->read) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->reopen) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->shutdown) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  } else
#line 1163
  if (! netio->write) {
    {
#line 1166
    tmp = __errno_location();
#line 1166
    *tmp = 22;
    }
#line 1167
    return (-1);
  }
#line 1170
  if (strm_types & 16) {
#line 1171
    ctrl_netio = netio;
  }
#line 1173
  if (strm_types & 32) {
#line 1174
    data_netio = netio;
  }
#line 1176
  if (strm_types & 64) {
#line 1177
    othr_netio = netio;
  }
#line 1179
  return (0);
}
}
#line 1182 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
int pr_unregister_netio(int strm_types ) 
{ 
  int *tmp ;

  {
#line 1184
  if (! strm_types) {
    {
#line 1185
    tmp = __errno_location();
#line 1185
    *tmp = 22;
    }
#line 1186
    return (-1);
  }
#line 1191
  if (strm_types & 16) {
#line 1192
    ctrl_netio = (pr_netio_t *)((void *)0);
  }
#line 1194
  if (strm_types & 32) {
#line 1195
    data_netio = (pr_netio_t *)((void *)0);
  }
#line 1197
  if (strm_types & 64) {
#line 1198
    othr_netio = (pr_netio_t *)((void *)0);
  }
#line 1200
  return (0);
}
}
#line 1203
pid_t mpid ;
#line 1205 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
pr_netio_t *pr_alloc_netio(pool *parent_pool ) 
{ 
  pr_netio_t *netio ;
  pool *netio_pool ;
  int *tmp ;
  __pid_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1206
  netio = (pr_netio_t *)((void *)0);
#line 1207
  netio_pool = (pool *)((void *)0);
#line 1209
  if (! parent_pool) {
    {
#line 1210
    tmp = __errno_location();
#line 1210
    *tmp = 22;
    }
#line 1211
    return ((pr_netio_t *)((void *)0));
  }
  {
#line 1214
  netio_pool = make_sub_pool(parent_pool);
#line 1224
  tmp___0 = getpid();
  }
#line 1224
  if (mpid == tmp___0) {
    {
#line 1225
    pr_pool_tag(netio_pool, "Shared Netio Pool");
    }
  } else {
    {
#line 1228
    pr_pool_tag(netio_pool, "netio pool");
    }
  }
  {
#line 1231
  tmp___1 = pcalloc(netio_pool, (int )sizeof(pr_netio_t ));
#line 1231
  netio = (pr_netio_t *)tmp___1;
#line 1232
  netio->pool = netio_pool;
#line 1235
  netio->abort = & core_netio_abort_cb;
#line 1236
  netio->close = & core_netio_close_cb;
#line 1237
  netio->open = & core_netio_open_cb;
#line 1238
  netio->poll = & core_netio_poll_cb;
#line 1239
  netio->postopen = & core_netio_postopen_cb;
#line 1240
  netio->read = & core_netio_read_cb;
#line 1241
  netio->reopen = & core_netio_reopen_cb;
#line 1242
  netio->shutdown = & core_netio_shutdown_cb;
#line 1243
  netio->write = & core_netio_write_cb;
  }
#line 1245
  return (netio);
}
}
#line 1248 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netio.c"
void init_netio(void) 
{ 


  {
  {
#line 1249
  signal(13, (void (*)(int  ))1);
#line 1250
  signal(23, (void (*)(int  ))1);
#line 1252
  pr_register_netio((pr_netio_t *)((void *)0), 0);
  }
#line 1253
  return;
}
}
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/feat.c"
static pool *feat_pool  =    (pool *)((void *)0);
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/feat.c"
static pr_table_t *feat_tab  =    (pr_table_t *)((void *)0);
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/feat.c"
int pr_feat_add(char const   *feat ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 36
  if (! feat) {
    {
#line 37
    tmp = __errno_location();
#line 37
    *tmp = 22;
    }
#line 38
    return (-1);
  }
#line 42
  if (! feat_pool) {
    {
#line 43
    feat_pool = make_sub_pool(permanent_pool);
#line 44
    pr_pool_tag(feat_pool, "Feat API");
#line 45
    feat_tab = pr_table_alloc(feat_pool, 0);
    }
  }
  {
#line 49
  tmp___1 = pr_table_exists(feat_tab, feat);
  }
#line 49
  if (tmp___1 > 0) {
    {
#line 50
    tmp___0 = __errno_location();
#line 50
    *tmp___0 = 17;
    }
#line 51
    return (-1);
  }
  {
#line 54
  tmp___2 = pstrdup(feat_pool, feat);
#line 54
  tmp___3 = pr_table_add(feat_tab, (char const   *)tmp___2, (void *)"", (size_t )0);
  }
#line 54
  return (tmp___3);
}
}
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/feat.c"
int pr_feat_remove(char const   *feat ) 
{ 
  void *res ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 60
  if (! feat_tab) {
    {
#line 61
    tmp = __errno_location();
#line 61
    *tmp = 1;
    }
#line 62
    return (-1);
  }
#line 65
  if (! feat) {
    {
#line 66
    tmp___0 = __errno_location();
#line 66
    *tmp___0 = 22;
    }
#line 67
    return (-1);
  }
  {
#line 70
  res = pr_table_remove(feat_tab, feat, (size_t *)((void *)0));
  }
#line 72
  if (res) {
#line 73
    return (0);
  }
  {
#line 75
  tmp___1 = __errno_location();
#line 75
  *tmp___1 = 2;
  }
#line 76
  return (-1);
}
}
#line 79 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/feat.c"
char const   *pr_feat_get(void) 
{ 
  int *tmp ;
  void *tmp___0 ;

  {
#line 80
  if (! feat_tab) {
    {
#line 81
    tmp = __errno_location();
#line 81
    *tmp = 1;
    }
#line 82
    return ((char const   *)((void *)0));
  }
  {
#line 85
  pr_table_rewind(feat_tab);
#line 86
  tmp___0 = pr_table_next(feat_tab);
  }
#line 86
  return ((char const   *)tmp___0);
}
}
#line 89 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/feat.c"
char const   *pr_feat_get_next(void) 
{ 
  int *tmp ;
  void *tmp___0 ;

  {
#line 90
  if (! feat_tab) {
    {
#line 91
    tmp = __errno_location();
#line 91
    *tmp = 1;
    }
#line 92
    return ((char const   *)((void *)0));
  }
  {
#line 95
  tmp___0 = pr_table_next(feat_tab);
  }
#line 95
  return ((char const   *)tmp___0);
}
}
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/help.c"
static pool *help_pool  =    (pool *)((void *)0);
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/help.c"
static array_header *help_list  =    (array_header *)((void *)0);
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/help.c"
void pr_help_add(char const   *cmd , char const   *syntax , int impl ) 
{ 
  struct help_rec *help ;
  register unsigned int i___0 ;
  struct help_rec *helps ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 43
  if (! cmd) {
#line 44
    return;
  } else
#line 43
  if (! syntax) {
#line 44
    return;
  }
#line 47
  if (! help_pool) {
    {
#line 48
    help_pool = make_sub_pool(permanent_pool);
#line 49
    pr_pool_tag(help_pool, "Help Pool");
#line 50
    help_list = make_array(help_pool, 0U, (size_t )sizeof(struct help_rec ));
    }
  }
#line 58
  if (help_list->nelts > 0) {
#line 59
    i___0 = 0U;
#line 60
    helps = (struct help_rec *)help_list->elts;
#line 62
    i___0 = 0U;
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      if (! (i___0 < (unsigned int )help_list->nelts)) {
#line 62
        goto while_break;
      }
      {
#line 63
      tmp = strcmp((helps + i___0)->cmd, cmd);
      }
#line 63
      if (tmp == 0) {
#line 64
        if ((helps + i___0)->impl == 0) {
#line 65
          (helps + i___0)->impl = impl;
        }
#line 67
        return;
      }
#line 62
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 71
  tmp___0 = push_array(help_list);
#line 71
  help = (struct help_rec *)tmp___0;
#line 72
  tmp___1 = pstrdup(help_pool, cmd);
#line 72
  help->cmd = (char const   *)tmp___1;
#line 73
  tmp___2 = pstrdup(help_pool, syntax);
#line 73
  help->syntax = (char const   *)tmp___2;
#line 74
  help->impl = impl;
  }
#line 75
  return;
}
}
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/help.c"
int pr_help_add_response(cmd_rec *cmd , char const   *target ) 
{ 
  register unsigned int i___0 ;
  struct help_rec *helps ;
  char *outa[8] ;
  char *outstr ;
  char buf___2[9] ;
  unsigned int tmp ;
  int col ;
  int tmp___0 ;
  int tmp___1 ;
  register unsigned int j ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 78
  if (help_list) {
#line 80
    helps = (struct help_rec *)help_list->elts;
#line 82
    buf___2[0] = (char )'\000';
#line 82
    tmp = 1U;
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
#line 82
      if (tmp >= 9U) {
#line 82
        goto while_break;
      }
#line 82
      buf___2[tmp] = (char)0;
#line 82
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    col = 0;
#line 85
    if (! target) {
      {
#line 86
      pr_response_add("214", "The following commands are recognized (* =>\'s unimplemented):");
#line 89
      memset((void *)(outa), '\000', (size_t )sizeof(outa));
#line 91
      i___0 = 0U;
      }
      {
#line 91
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 91
        if (! (i___0 < (unsigned int )help_list->nelts)) {
#line 91
          goto while_break___0;
        }
#line 92
        outstr = (char *)"";
#line 94
        if ((helps + i___0)->impl) {
#line 95
          tmp___0 = col;
#line 95
          col ++;
#line 95
          outa[tmp___0] = (char *)(helps + i___0)->cmd;
        } else {
          {
#line 97
          tmp___1 = col;
#line 97
          col ++;
#line 97
          outa[tmp___1] = pstrcat(cmd->tmp_pool, (helps + i___0)->cmd, "*", (void *)0);
          }
        }
#line 100
        if ((i___0 + 1U) % 8U == 0U) {
#line 100
          goto _L;
        } else
#line 100
        if ((unsigned long )(helps + (i___0 + 1U))->cmd == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 104
          j = 0U;
          {
#line 104
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 104
            if (! (j < 8U)) {
#line 104
              goto while_break___1;
            }
#line 105
            if (outa[j]) {
              {
#line 106
              snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2),
                       (char const   */* __restrict  */)"%-8s", outa[j]);
#line 107
              buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 108
              outstr = pstrcat(cmd->tmp_pool, outstr, buf___2, (void *)0);
              }
            } else {
#line 111
              goto while_break___1;
            }
#line 104
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 114
          if (*outstr) {
            {
#line 115
            pr_response_add((char const   *)((void *)0), "%s", outstr);
            }
          }
          {
#line 117
          memset((void *)(outa), '\000', (size_t )sizeof(outa));
#line 118
          col = 0;
#line 119
          outstr = (char *)"";
          }
        }
#line 91
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 123
      if ((cmd->server)->ServerAdmin) {
#line 123
        tmp___2 = (char const   *)(cmd->server)->ServerAdmin;
      } else {
#line 123
        tmp___2 = "ftp-admin";
      }
      {
#line 123
      pr_response_add((char const   *)((void *)0), "Direct comments to %s", tmp___2);
      }
    } else {
#line 129
      i___0 = 0U;
      {
#line 129
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 129
        if (! (i___0 < (unsigned int )help_list->nelts)) {
#line 129
          goto while_break___2;
        }
        {
#line 130
        tmp___3 = strcasecmp((helps + i___0)->cmd, target);
        }
#line 130
        if (tmp___3 == 0) {
          {
#line 131
          pr_response_add("214", "Syntax: %s %s", (helps + i___0)->cmd, (helps + i___0)->syntax);
          }
#line 133
          return (0);
        }
#line 129
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 138
    tmp___4 = __errno_location();
#line 138
    *tmp___4 = 2;
    }
#line 139
    return (-1);
  }
  {
#line 142
  tmp___5 = __errno_location();
#line 142
  *tmp___5 = 2;
  }
#line 143
  return (-1);
}
}
#line 651 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 115 "../include/scoreboard.h"
char const   *pr_get_scoreboard(void) ;
#line 118
int pr_close_scoreboard(void) ;
#line 119
void pr_delete_scoreboard(void) ;
#line 124
pid_t pr_scoreboard_get_daemon_pid(void) ;
#line 125
time_t pr_scoreboard_get_daemon_uptime(void) ;
#line 129
int pr_scoreboard_entry_del(unsigned char verbose ) ;
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static pid_t scoreboard_opener  =    0;
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int scoreboard_fd  =    -1;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static char scoreboard_file[4096]  = 
#line 41
  {      (char )'/',      (char )'u',      (char )'s',      (char )'r', 
        (char )'/',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )'/',      (char )'v', 
        (char )'a',      (char )'r',      (char )'/',      (char )'p', 
        (char )'r',      (char )'o',      (char )'f',      (char )'t', 
        (char )'p',      (char )'d',      (char )'/',      (char )'p', 
        (char )'r',      (char )'o',      (char )'f',      (char )'t', 
        (char )'p',      (char )'d',      (char )'.',      (char )'s', 
        (char )'c',      (char )'o',      (char )'r',      (char )'e', 
        (char )'b',      (char )'o',      (char )'a',      (char )'r', 
        (char )'d',      (char )'\000'};
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static off_t___0 current_pos  =    (off_t___0 )0;
#line 44 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static pr_scoreboard_header_t header  ;
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static pr_scoreboard_entry_t entry  ;
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int have_entry  =    0;
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static struct flock entry_lock  ;
#line 49 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static unsigned char scoreboard_read_locked  =    (unsigned char)0;
#line 50 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static unsigned char scoreboard_write_locked  =    (unsigned char)0;
#line 55
static char *handle_score_str(char const   *fmt , va_list cmdap ) ;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static char buf___0[80]  = {      (char )'\000'};
#line 54 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static char *handle_score_str(char const   *fmt , va_list cmdap ) 
{ 


  {
  {
#line 56
  memset((void *)(buf___0), '\000', (size_t )sizeof(buf___0));
#line 57
  vsnprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)fmt,
            cmdap);
#line 58
  buf___0[sizeof(buf___0) - 1UL] = (char )'\000';
  }
#line 59
  return (buf___0);
}
}
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int read_scoreboard_header(pr_scoreboard_header_t *sch ) 
{ 
  int res ;
  int rd_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 63
  res = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    res = read(scoreboard_fd, (void *)sch, (size_t )sizeof(pr_scoreboard_header_t ));
    }
#line 66
    if (! ((unsigned long )res != sizeof(pr_scoreboard_header_t ))) {
#line 66
      goto while_break;
    }
    {
#line 68
    tmp = __errno_location();
#line 68
    rd_errno = *tmp;
    }
#line 70
    if (res == 0) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      *tmp___0 = 5;
      }
#line 72
      return (-1);
    }
    {
#line 75
    tmp___1 = __errno_location();
    }
#line 75
    if (*tmp___1 == 4) {
      {
#line 76
      pr_signals_handle();
      }
#line 77
      goto while_continue;
    }
    {
#line 80
    tmp___2 = __errno_location();
#line 80
    *tmp___2 = rd_errno;
    }
#line 81
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (sch->sch_magic != 3735928559UL) {
    {
#line 89
    pr_close_scoreboard();
    }
#line 90
    return (-2);
  }
#line 93
  if (sch->sch_version < 17039362UL) {
    {
#line 94
    pr_close_scoreboard();
    }
#line 95
    return (-3);
  }
#line 98
  if (sch->sch_version > 17039362UL) {
    {
#line 99
    pr_close_scoreboard();
    }
#line 100
    return (-4);
  }
#line 103
  return (0);
}
}
#line 106 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static char const   *get_lock_type(struct flock *lock ) 
{ 
  char const   *lock_type ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 110
  if ((int )lock->l_type == 0) {
#line 110
    goto case_0;
  }
#line 114
  if ((int )lock->l_type == 1) {
#line 114
    goto case_1;
  }
#line 118
  if ((int )lock->l_type == 2) {
#line 118
    goto case_2;
  }
#line 122
  goto switch_default;
  case_0: /* CIL Label */ 
#line 111
  lock_type = "read";
#line 112
  goto switch_break;
  case_1: /* CIL Label */ 
#line 115
  lock_type = "write";
#line 116
  goto switch_break;
  case_2: /* CIL Label */ 
#line 119
  lock_type = "unlock";
#line 120
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 123
  lock_type = "[unknown]";
  switch_break: /* CIL Label */ ;
  }
#line 126
  return (lock_type);
}
}
#line 129 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int rlock_scoreboard(void) 
{ 
  struct flock lock ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 132
  lock.l_type = (short)0;
#line 133
  lock.l_whence = (short)0;
#line 134
  lock.l_start = (__off64_t )0;
#line 135
  lock.l_len = (__off64_t )0;
#line 137
  pr_trace_msg("lock", 9, "attempting to read-lock scoreboard fd %d", scoreboard_fd);
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    tmp___4 = fcntl(scoreboard_fd, 14, & lock);
    }
#line 140
    if (! (tmp___4 < 0)) {
#line 140
      goto while_break;
    }
    {
#line 141
    tmp = __errno_location();
#line 141
    xerrno = *tmp;
    }
#line 143
    if (xerrno == 4) {
      {
#line 144
      pr_signals_handle();
      }
#line 145
      goto while_continue;
    }
    {
#line 148
    tmp___0 = strerror(xerrno);
#line 148
    pr_trace_msg("lock", 3, "read-lock of scoreboard fd %d failed: %s", scoreboard_fd,
                 tmp___0);
    }
#line 150
    if (xerrno == 13) {
      {
#line 152
      tmp___2 = fcntl(scoreboard_fd, 12, & lock);
      }
#line 152
      if (tmp___2 == 0) {
        {
#line 153
        tmp___1 = get_lock_type(& lock);
#line 153
        pr_trace_msg("lock", 3, "process ID %lu has blocking %s lock on scoreboard fd %d",
                     (unsigned long )lock.l_pid, tmp___1, scoreboard_fd);
        }
      }
    }
    {
#line 159
    tmp___3 = __errno_location();
#line 159
    *tmp___3 = xerrno;
    }
#line 160
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  pr_trace_msg("lock", 9, "read-lock of scoreboard fd %d successful", scoreboard_fd);
#line 166
  scoreboard_read_locked = (unsigned char)1;
  }
#line 167
  return (0);
}
}
#line 170 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int unlock_entry(void) 
{ 
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 172
  entry_lock.l_type = (short)2;
#line 173
  entry_lock.l_whence = (short)1;
#line 174
  entry_lock.l_len = (__off64_t )sizeof(pr_scoreboard_entry_t );
#line 176
  pr_trace_msg("lock", 9, "attempting to unlock scoreboard fd %d entry, offset %llu",
               scoreboard_fd, (unsigned long long )entry_lock.l_start);
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 179
    tmp___2 = fcntl(scoreboard_fd, 14, & entry_lock);
    }
#line 179
    if (! (tmp___2 < 0)) {
#line 179
      goto while_break;
    }
    {
#line 180
    tmp = __errno_location();
#line 180
    xerrno = *tmp;
    }
#line 182
    if (xerrno == 4) {
      {
#line 183
      pr_signals_handle();
      }
#line 184
      goto while_continue;
    }
    {
#line 187
    tmp___0 = strerror(xerrno);
#line 187
    pr_trace_msg("lock", 3, "unlock of scoreboard fd %d entry failed: %s", scoreboard_fd,
                 tmp___0);
#line 190
    tmp___1 = __errno_location();
#line 190
    *tmp___1 = xerrno;
    }
#line 191
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  pr_trace_msg("lock", 9, "unlock of scoreboard fd %d entry, offset %llu succeeded",
               scoreboard_fd, (unsigned long long )entry_lock.l_start);
  }
#line 198
  return (0);
}
}
#line 201 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int unlock_scoreboard(void) 
{ 
  struct flock lock ;
  int xerrno ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 204
  lock.l_type = (short)2;
#line 205
  lock.l_whence = (short)0;
#line 206
  lock.l_start = (__off64_t )0;
#line 207
  lock.l_len = (__off64_t )0;
#line 209
  scoreboard_write_locked = (unsigned char)0;
#line 209
  scoreboard_read_locked = scoreboard_write_locked;
#line 211
  pr_trace_msg("lock", 9, "attempting to unlock scoreboard fd %d", scoreboard_fd);
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 214
    tmp___3 = fcntl(scoreboard_fd, 13, & lock);
    }
#line 214
    if (! (tmp___3 < 0)) {
#line 214
      goto while_break;
    }
    {
#line 215
    tmp = __errno_location();
#line 215
    xerrno = *tmp;
#line 217
    tmp___0 = __errno_location();
    }
#line 217
    if (*tmp___0 == 4) {
      {
#line 218
      pr_signals_handle();
      }
#line 219
      goto while_continue;
    }
    {
#line 222
    tmp___1 = strerror(xerrno);
#line 222
    pr_trace_msg("lock", 3, "unlock of scoreboard fd %d failed: %s", scoreboard_fd,
                 tmp___1);
#line 225
    tmp___2 = __errno_location();
#line 225
    *tmp___2 = xerrno;
    }
#line 226
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  pr_trace_msg("lock", 9, "unlock of scoreboard fd %d successful", scoreboard_fd);
  }
#line 232
  return (0);
}
}
#line 235 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int wlock_entry(void) 
{ 
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 236
  entry_lock.l_type = (short)1;
#line 237
  entry_lock.l_whence = (short)1;
#line 238
  entry_lock.l_len = (__off64_t )sizeof(pr_scoreboard_entry_t );
#line 240
  pr_trace_msg("lock", 9, "attempting to write-lock scoreboard fd %d entry, offset %llu",
               scoreboard_fd, (unsigned long long )entry_lock.l_start);
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    tmp___2 = fcntl(scoreboard_fd, 14, & entry_lock);
    }
#line 243
    if (! (tmp___2 < 0)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = __errno_location();
#line 244
    xerrno = *tmp;
    }
#line 246
    if (xerrno == 4) {
      {
#line 247
      pr_signals_handle();
      }
#line 248
      goto while_continue;
    }
    {
#line 251
    tmp___0 = strerror(xerrno);
#line 251
    pr_trace_msg("lock", 3, "write-lock of scoreboard fd %d entry failed: %s", scoreboard_fd,
                 tmp___0);
#line 254
    tmp___1 = __errno_location();
#line 254
    *tmp___1 = xerrno;
    }
#line 255
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  pr_trace_msg("lock", 9, "write-lock of scoreboard fd %d entry, offset %llu succeeded",
               scoreboard_fd, (unsigned long long )entry_lock.l_start);
  }
#line 262
  return (0);
}
}
#line 265 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int wlock_scoreboard(void) 
{ 
  struct flock lock ;
  int xerrno ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 268
  lock.l_type = (short)1;
#line 269
  lock.l_whence = (short)0;
#line 270
  lock.l_start = (__off64_t )0;
#line 271
  lock.l_len = (__off64_t )0;
#line 273
  pr_trace_msg("lock", 9, "attempting to write-lock scoreboard fd %d", scoreboard_fd);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 276
    tmp___4 = fcntl(scoreboard_fd, 14, & lock);
    }
#line 276
    if (! (tmp___4 < 0)) {
#line 276
      goto while_break;
    }
    {
#line 277
    tmp = __errno_location();
#line 277
    xerrno = *tmp;
    }
#line 279
    if (xerrno == 4) {
      {
#line 280
      pr_signals_handle();
      }
#line 281
      goto while_continue;
    }
    {
#line 284
    tmp___0 = strerror(xerrno);
#line 284
    pr_trace_msg("lock", 3, "write-lock of scoreboard fd %d failed: %s", scoreboard_fd,
                 tmp___0);
    }
#line 286
    if (xerrno == 13) {
      {
#line 288
      tmp___2 = fcntl(scoreboard_fd, 12, & lock);
      }
#line 288
      if (tmp___2 == 0) {
        {
#line 289
        tmp___1 = get_lock_type(& lock);
#line 289
        pr_trace_msg("lock", 3, "process ID %lu has blocking %s lock on scoreboard fd %d",
                     (unsigned long )lock.l_pid, tmp___1, scoreboard_fd);
        }
      }
    }
    {
#line 295
    tmp___3 = __errno_location();
#line 295
    *tmp___3 = xerrno;
    }
#line 296
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 299
  pr_trace_msg("lock", 9, "write-lock of scoreboard fd %d successful", scoreboard_fd);
#line 302
  scoreboard_write_locked = (unsigned char)1;
  }
#line 303
  return (0);
}
}
#line 306 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static int write_entry(void) 
{ 
  int *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 307
  if (scoreboard_fd < 0) {
    {
#line 308
    tmp = __errno_location();
#line 308
    *tmp = 22;
    }
#line 309
    return (-1);
  }
  {
#line 312
  lseek(scoreboard_fd, entry_lock.l_start, 0);
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    tmp___1 = write(scoreboard_fd, (void const   *)(& entry), (size_t )sizeof(entry));
    }
#line 314
    if (! ((unsigned long )tmp___1 != sizeof(entry))) {
#line 314
      goto while_break;
    }
    {
#line 315
    tmp___0 = __errno_location();
    }
#line 315
    if (*tmp___0 == 4) {
      {
#line 316
      pr_signals_handle();
      }
#line 317
      goto while_continue;
    }
#line 320
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  lseek(scoreboard_fd, entry_lock.l_start, 0);
  }
#line 326
  return (0);
}
}
#line 331 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_close_scoreboard(void) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 332
  if (scoreboard_fd == -1) {
#line 333
    return (0);
  }
#line 335
  if (scoreboard_read_locked) {
    {
#line 336
    unlock_scoreboard();
    }
  } else
#line 335
  if (scoreboard_write_locked) {
    {
#line 336
    unlock_scoreboard();
    }
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 338
    tmp___0 = close(scoreboard_fd);
    }
#line 338
    if (! (tmp___0 < 0)) {
#line 338
      goto while_break;
    }
    {
#line 339
    tmp = __errno_location();
    }
#line 339
    if (*tmp == 4) {
      {
#line 340
      pr_signals_handle();
      }
#line 341
      goto while_continue;
    }
#line 344
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  scoreboard_fd = -1;
#line 348
  scoreboard_opener = 0;
#line 350
  return (0);
}
}
#line 353 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
void pr_delete_scoreboard(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  struct stat st ;
  int tmp___1 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 354
  if (scoreboard_fd > -1) {
    {
#line 355
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 355
      tmp___0 = close(scoreboard_fd);
      }
#line 355
      if (! (tmp___0 < 0)) {
#line 355
        goto while_break;
      }
      {
#line 356
      tmp = __errno_location();
      }
#line 356
      if (*tmp == 4) {
        {
#line 357
        pr_signals_handle();
        }
#line 358
        goto while_continue;
      }
#line 361
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 365
  scoreboard_fd = -1;
#line 366
  scoreboard_opener = 0;
#line 368
  if (scoreboard_file[0]) {
    {
#line 371
    tmp___1 = stat((char const   */* __restrict  */)(scoreboard_file), (struct stat */* __restrict  */)(& st));
    }
#line 371
    if (tmp___1 == 0) {
      {
#line 372
      pr_log_debug(3, "deleting existing scoreboard \'%s\'", scoreboard_file);
      }
    }
    {
#line 375
    unlink((char const   *)(scoreboard_file));
    }
  }
#line 377
  return;
}
}
#line 379 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
char const   *pr_get_scoreboard(void) 
{ 


  {
#line 380
  return ((char const   *)(scoreboard_file));
}
}
#line 383 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_open_scoreboard(int flags ) 
{ 
  int res ;
  struct stat st ;
  int *tmp ;
  __pid_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int wr_errno ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  ssize_t tmp___10 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 387
  if (flags != 2) {
    {
#line 388
    tmp = __errno_location();
#line 388
    *tmp = 22;
    }
#line 389
    return (-1);
  }
#line 396
  if (scoreboard_fd >= 0) {
    {
#line 396
    tmp___0 = getpid();
    }
#line 396
    if (scoreboard_opener == tmp___0) {
      {
#line 398
      pr_log_debug(7, "scoreboard already opened");
      }
#line 399
      return (0);
    }
  }
  {
#line 403
  tmp___2 = lstat((char const   */* __restrict  */)(scoreboard_file), (struct stat */* __restrict  */)(& st));
  }
#line 403
  if (tmp___2 == 0) {
#line 404
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 405
      scoreboard_fd = -1;
#line 406
      tmp___1 = __errno_location();
#line 406
      *tmp___1 = 1;
      }
#line 407
      return (-1);
    }
  }
  {
#line 411
  pr_log_debug(7, "opening scoreboard \'%s\'", scoreboard_file);
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 413
    scoreboard_fd = open((char const   *)(scoreboard_file), flags | 64, 420);
    }
#line 413
    if (! (scoreboard_fd < 0)) {
#line 413
      goto while_break;
    }
    {
#line 415
    tmp___3 = __errno_location();
    }
#line 415
    if (*tmp___3 == 4) {
      {
#line 416
      pr_signals_handle();
      }
#line 417
      goto while_continue;
    }
#line 420
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 427
    tmp___5 = fchmod(scoreboard_fd, (__mode_t )420);
    }
#line 427
    if (! (tmp___5 < 0)) {
#line 427
      goto while_break___0;
    }
    {
#line 428
    tmp___4 = __errno_location();
    }
#line 428
    if (*tmp___4 == 4) {
      {
#line 429
      pr_signals_handle();
      }
#line 430
      goto while_continue___0;
    }
#line 433
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 436
  scoreboard_opener = getpid();
#line 439
  res = read_scoreboard_header(& header);
  }
#line 440
  if (res == -1) {
#line 445
    header.sch_magic = 3735928559UL;
#line 446
    header.sch_version = 17039362UL;
#line 448
    if ((int )ServerType == 1) {
      {
#line 449
      header.sch_pid = getpid();
#line 450
      header.sch_uptime = time((time_t *)((void *)0));
      }
    } else {
#line 453
      header.sch_pid = 0;
#line 454
      header.sch_uptime = (time_t )0;
    }
    {
#line 458
    tmp___6 = wlock_scoreboard();
    }
#line 458
    if (tmp___6 < 0) {
#line 459
      return (-1);
    }
    {
#line 461
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 461
      tmp___10 = write(scoreboard_fd, (void const   *)(& header), (size_t )sizeof(header));
      }
#line 461
      if (! ((unsigned long )tmp___10 != sizeof(header))) {
#line 461
        goto while_break___1;
      }
      {
#line 462
      tmp___7 = __errno_location();
#line 462
      wr_errno = *tmp___7;
#line 464
      tmp___8 = __errno_location();
      }
#line 464
      if (*tmp___8 == 4) {
        {
#line 465
        pr_signals_handle();
        }
#line 466
        goto while_continue___1;
      }
      {
#line 469
      unlock_scoreboard();
#line 471
      tmp___9 = __errno_location();
#line 471
      *tmp___9 = wr_errno;
      }
#line 472
      return (-1);
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 475
    unlock_scoreboard();
    }
#line 476
    return (0);
  } else {
#line 479
    return (res);
  }
#line 481
  return (0);
}
}
#line 484 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_restore_scoreboard(void) 
{ 
  int *tmp ;

  {
#line 486
  if (scoreboard_fd < 0) {
    {
#line 487
    tmp = __errno_location();
#line 487
    *tmp = 22;
    }
#line 488
    return (-1);
  }
  {
#line 494
  lseek(scoreboard_fd, current_pos, 0);
  }
#line 495
  return (0);
}
}
#line 498 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_rewind_scoreboard(void) 
{ 
  int *tmp ;

  {
#line 500
  if (scoreboard_fd < 0) {
    {
#line 501
    tmp = __errno_location();
#line 501
    *tmp = 22;
    }
#line 502
    return (-1);
  }
  {
#line 505
  current_pos = lseek(scoreboard_fd, (__off64_t )0, 1);
#line 510
  lseek(scoreboard_fd, (__off64_t )sizeof(pr_scoreboard_header_t ), 0);
  }
#line 511
  return (0);
}
}
#line 514 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_set_scoreboard(char const   *path ) 
{ 
  char dir[4096] ;
  unsigned int tmp ;
  struct stat st ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 515
  dir[0] = (char )'\000';
#line 515
  tmp = 1U;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (tmp >= 4096U) {
#line 515
      goto while_break;
    }
#line 515
    dir[tmp] = (char)0;
#line 515
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  tmp___0 = (char *)((void *)0);
#line 519
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 520
    tmp___1 = __errno_location();
#line 520
    *tmp___1 = 22;
    }
#line 521
    return (-1);
  }
#line 524
  if ((int const   )*path != 47) {
    {
#line 525
    tmp___2 = __errno_location();
#line 525
    *tmp___2 = 22;
    }
#line 526
    return (-1);
  }
  {
#line 529
  sstrncpy(dir, path, (size_t )sizeof(dir));
#line 531
  tmp___0 = strrchr((char const   *)(dir + 1), '/');
  }
#line 532
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 533
    tmp___3 = __errno_location();
#line 533
    *tmp___3 = 22;
    }
#line 534
    return (-1);
  }
#line 537
  *tmp___0 = (char )'\000';
#line 542
  if ((int )*(tmp___0 + 1) == 0) {
    {
#line 543
    *tmp___0 = (char )'/';
#line 544
    tmp___4 = __errno_location();
#line 544
    *tmp___4 = 22;
    }
#line 545
    return (-1);
  }
  {
#line 550
  tmp___5 = stat((char const   */* __restrict  */)(dir), (struct stat */* __restrict  */)(& st));
  }
#line 550
  if (tmp___5 < 0) {
#line 551
    return (-1);
  }
#line 553
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 554
    tmp___6 = __errno_location();
#line 554
    *tmp___6 = 20;
    }
#line 555
    return (-1);
  }
#line 558
  if (st.st_mode & (unsigned int )((128 >> 3) >> 3)) {
    {
#line 559
    tmp___7 = __errno_location();
#line 559
    *tmp___7 = 1;
    }
#line 560
    return (-1);
  }
  {
#line 563
  sstrncpy(scoreboard_file, path, (size_t )sizeof(scoreboard_file));
  }
#line 564
  return (0);
}
}
#line 567 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_scoreboard_entry_add(void) 
{ 
  unsigned char found_slot ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int res ;
  __off64_t tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp11 ;

  {
#line 568
  found_slot = (unsigned char)0;
#line 570
  if (scoreboard_fd < 0) {
    {
#line 571
    tmp = __errno_location();
#line 571
    *tmp = 22;
    }
#line 572
    return (-1);
  }
#line 575
  if (have_entry) {
    {
#line 576
    tmp___0 = __errno_location();
#line 576
    *tmp___0 = 1;
    }
#line 577
    return (-1);
  }
  {
#line 581
  tmp___1 = wlock_scoreboard();
  }
#line 581
  if (tmp___1 < 0) {
#line 582
    return (-1);
  }
  {
#line 585
  pr_signals_block();
  }
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    res = 0;
    {
#line 592
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 592
      res = read(scoreboard_fd, (void *)(& entry), (size_t )sizeof(entry));
      }
#line 592
      if (! ((unsigned long )res == sizeof(entry))) {
#line 592
        goto while_break___0;
      }
#line 598
      if (! entry.sce_pid) {
        {
#line 599
        tmp___2 = lseek(scoreboard_fd, (__off64_t )0, 1);
#line 599
        entry_lock.l_start = tmp___2 - (__off64_t )sizeof(entry);
#line 600
        found_slot = (unsigned char)1;
        }
#line 601
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 605
    if (res == 0) {
      {
#line 606
      entry_lock.l_start = lseek(scoreboard_fd, (__off64_t )0, 1);
#line 607
      found_slot = (unsigned char)1;
      }
    }
#line 610
    if (found_slot) {
#line 611
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 614
  memset((void *)(& entry), '\000', (size_t )sizeof(entry));
  }
#line 616
  if (session.pid) {
#line 616
    entry.sce_pid = session.pid;
  } else {
    {
#line 616
    tmp___3 = getpid();
#line 616
    entry.sce_pid = tmp___3;
    }
  }
  {
#line 617
  entry.sce_uid = geteuid();
#line 618
  entry.sce_gid = getegid();
#line 620
  have_entry = 1;
#line 622
  tmp___6 = write_entry();
  }
#line 622
  if (tmp___6 < 0) {
    {
#line 623
    tmp___4 = __errno_location();
#line 623
    tmp___5 = strerror(*tmp___4);
#line 623
    pr_log_pri(5, "error writing scoreboard entry: %s", tmp___5);
    }
  }
  {
#line 626
  pr_signals_unblock();
#line 629
  unlock_scoreboard();
  }
#line 631
  return (0);
}
}
#line 634 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_scoreboard_entry_del(unsigned char verbose ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;

  {
#line 636
  if (scoreboard_fd < 0) {
    {
#line 637
    tmp = __errno_location();
#line 637
    *tmp = 22;
    }
#line 638
    return (-1);
  }
#line 641
  if (! have_entry) {
    {
#line 642
    tmp___0 = __errno_location();
#line 642
    *tmp___0 = 1;
    }
#line 643
    return (-1);
  }
  {
#line 646
  memset((void *)(& entry), '\000', (size_t )sizeof(entry));
#line 649
  wlock_entry();
#line 650
  tmp___3 = write_entry();
  }
#line 650
  if (tmp___3 < 0) {
#line 650
    if (verbose) {
      {
#line 652
      tmp___1 = __errno_location();
#line 652
      tmp___2 = strerror(*tmp___1);
#line 652
      pr_log_pri(5, "error deleting scoreboard entry: %s", tmp___2);
      }
    }
  }
  {
#line 656
  have_entry = 0;
#line 657
  unlock_entry();
  }
#line 659
  return (0);
}
}
#line 662 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
pid_t pr_scoreboard_get_daemon_pid(void) 
{ 


  {
#line 663
  return (header.sch_pid);
}
}
#line 666 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
time_t pr_scoreboard_get_daemon_uptime(void) 
{ 


  {
#line 667
  return (header.sch_uptime);
}
}
#line 671 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
static pr_scoreboard_entry_t scan_entry  ;
#line 670 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
pr_scoreboard_entry_t *pr_scoreboard_entry_read(void) 
{ 
  int res ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 672
  res = 0;
#line 674
  if (scoreboard_fd < 0) {
    {
#line 675
    tmp = __errno_location();
#line 675
    *tmp = 22;
    }
#line 676
    return ((pr_scoreboard_entry_t *)((void *)0));
  }
#line 680
  if (! scoreboard_read_locked) {
    {
#line 683
    tmp___0 = rlock_scoreboard();
    }
#line 683
    if (tmp___0 < 0) {
#line 684
      return ((pr_scoreboard_entry_t *)((void *)0));
    }
  }
  {
#line 687
  memset((void *)(& scan_entry), '\000', (size_t )sizeof(scan_entry));
  }
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 691
      res = read(scoreboard_fd, (void *)(& scan_entry), (size_t )sizeof(scan_entry));
      }
#line 691
      if (! (res <= 0)) {
#line 691
        goto while_break___0;
      }
#line 692
      if (res < 0) {
        {
#line 692
        tmp___1 = __errno_location();
        }
#line 692
        if (*tmp___1 == 4) {
          {
#line 693
          pr_signals_handle();
          }
#line 694
          goto while_continue___0;
        } else {
          {
#line 697
          unlock_scoreboard();
          }
#line 698
          return ((pr_scoreboard_entry_t *)((void *)0));
        }
      } else {
        {
#line 697
        unlock_scoreboard();
        }
#line 698
        return ((pr_scoreboard_entry_t *)((void *)0));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 702
    if (scan_entry.sce_pid) {
      {
#line 703
      unlock_scoreboard();
      }
#line 704
      return (& scan_entry);
    } else {
#line 707
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 710
  unlock_scoreboard();
  }
#line 711
  return ((pr_scoreboard_entry_t *)((void *)0));
}
}
#line 718 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
char const   *pr_scoreboard_entry_get(int field ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 720
  if (scoreboard_fd < 0) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 722
    return ((char const   *)((void *)0));
  }
#line 725
  if (! have_entry) {
    {
#line 726
    tmp___0 = __errno_location();
#line 726
    *tmp___0 = 1;
    }
#line 727
    return ((char const   *)((void *)0));
  }
  {
#line 731
  if (field == 1) {
#line 731
    goto case_1;
  }
#line 734
  if (field == 2) {
#line 734
    goto case_2;
  }
#line 737
  if (field == 3) {
#line 737
    goto case_3;
  }
#line 740
  if (field == 4) {
#line 740
    goto case_4;
  }
#line 743
  if (field == 5) {
#line 743
    goto case_5;
  }
#line 746
  if (field == 6) {
#line 746
    goto case_6;
  }
#line 749
  if (field == 7) {
#line 749
    goto case_7;
  }
#line 730
  goto switch_break;
  case_1: /* CIL Label */ 
#line 732
  return ((char const   *)(entry.sce_user));
  case_2: /* CIL Label */ 
#line 735
  return ((char const   *)(entry.sce_client_addr));
  case_3: /* CIL Label */ 
#line 738
  return ((char const   *)(entry.sce_client_name));
  case_4: /* CIL Label */ 
#line 741
  return ((char const   *)(entry.sce_class));
  case_5: /* CIL Label */ 
#line 744
  return ((char const   *)(entry.sce_cwd));
  case_6: /* CIL Label */ 
#line 747
  return ((char const   *)(entry.sce_cmd));
  case_7: /* CIL Label */ 
#line 750
  return ((char const   *)(entry.sce_cmd_arg));
  switch_break: /* CIL Label */ ;
  }
  {
#line 753
  tmp___1 = __errno_location();
#line 753
  *tmp___1 = 2;
  }
#line 754
  return ((char const   *)((void *)0));
}
}
#line 757 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_scoreboard_entry_update(pid_t pid  , ...) 
{ 
  va_list ap ;
  char *tmp ;
  int entry_tag ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  pr_netaddr_t *remote_addr ;
  pr_netaddr_t *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *remote_name ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *cmdstr ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *argstr ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  pr_netaddr_t *server_addr ;
  pr_netaddr_t *tmp___18 ;
  int server_port ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  time_t tmp___25 ;
  time_t tmp___27 ;
  off_t___0 tmp___28 ;
  off_t___0 tmp___29 ;
  off_t___0 tmp___30 ;
  unsigned long tmp___31 ;
  int *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 759
  tmp = (char *)((void *)0);
#line 760
  entry_tag = 0;
#line 762
  if (scoreboard_fd < 0) {
    {
#line 763
    tmp___0 = __errno_location();
#line 763
    *tmp___0 = 22;
    }
#line 764
    return (-1);
  }
#line 767
  if (! have_entry) {
    {
#line 768
    tmp___1 = __errno_location();
#line 768
    *tmp___1 = 1;
    }
#line 769
    return (-1);
  }
  {
#line 775
  __builtin_va_start(ap, pid);
  }
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 777
    tmp___33 = __builtin_va_arg(ap, int );
#line 777
    entry_tag = tmp___33;
    }
#line 777
    if (! (entry_tag != 0)) {
#line 777
      goto while_break;
    }
    {
#line 778
    pr_signals_handle();
    }
    {
#line 781
    if (entry_tag == 1) {
#line 781
      goto case_1;
    }
#line 787
    if (entry_tag == 2) {
#line 787
      goto case_2;
    }
#line 797
    if (entry_tag == 3) {
#line 797
      goto case_3;
    }
#line 807
    if (entry_tag == 4) {
#line 807
      goto case_4;
    }
#line 813
    if (entry_tag == 5) {
#line 813
      goto case_5;
    }
#line 819
    if (entry_tag == 6) {
#line 819
      goto case_6;
    }
#line 830
    if (entry_tag == 7) {
#line 830
      goto case_7;
    }
#line 841
    if (entry_tag == 8) {
#line 841
      goto case_8;
    }
#line 845
    if (entry_tag == 9) {
#line 845
      goto case_9;
    }
#line 856
    if (entry_tag == 10) {
#line 856
      goto case_10;
    }
#line 862
    if (entry_tag == 13) {
#line 862
      goto case_13;
    }
#line 869
    if (entry_tag == 14) {
#line 869
      goto case_14;
    }
#line 876
    if (entry_tag == 11) {
#line 876
      goto case_11;
    }
#line 880
    if (entry_tag == 12) {
#line 880
      goto case_12;
    }
#line 884
    if (entry_tag == 15) {
#line 884
      goto case_15;
    }
#line 888
    if (entry_tag == 16) {
#line 888
      goto case_16;
    }
#line 892
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 782
    tmp___2 = __builtin_va_arg(ap, char *);
#line 782
    tmp = tmp___2;
#line 783
    memset((void *)(entry.sce_user), '\000', (size_t )sizeof(entry.sce_user));
#line 784
    sstrncpy(entry.sce_user, (char const   *)tmp, (size_t )sizeof(entry.sce_user));
    }
#line 785
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 788
    tmp___4 = __builtin_va_arg(ap, pr_netaddr_t *);
#line 788
    remote_addr = tmp___4;
    }
#line 790
    if (remote_addr) {
      {
#line 790
      tmp___5 = pr_netaddr_get_ipstr(remote_addr);
#line 790
      tmp___6 = tmp___5;
      }
    } else {
#line 790
      tmp___6 = "(unknown)";
    }
    {
#line 790
    snprintf((char */* __restrict  */)(entry.sce_client_addr), (size_t )sizeof(entry.sce_client_addr),
             (char const   */* __restrict  */)"%s", tmp___6);
#line 793
    entry.sce_client_addr[sizeof(entry.sce_client_addr) - 1UL] = (char )'\000';
    }
#line 795
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 798
    tmp___8 = __builtin_va_arg(ap, char *);
#line 798
    remote_name = tmp___8;
    }
#line 800
    if (remote_name) {
#line 800
      tmp___9 = (char const   *)remote_name;
    } else {
#line 800
      tmp___9 = "(unknown)";
    }
    {
#line 800
    snprintf((char */* __restrict  */)(entry.sce_client_name), (size_t )sizeof(entry.sce_client_name),
             (char const   */* __restrict  */)"%s", tmp___9);
#line 802
    entry.sce_client_name[sizeof(entry.sce_client_name) - 1UL] = (char )'\000';
    }
#line 805
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 808
    tmp___10 = __builtin_va_arg(ap, char *);
#line 808
    tmp = tmp___10;
#line 809
    memset((void *)(entry.sce_class), '\000', (size_t )sizeof(entry.sce_class));
#line 810
    sstrncpy(entry.sce_class, (char const   *)tmp, (size_t )sizeof(entry.sce_class));
    }
#line 811
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 814
    tmp___11 = __builtin_va_arg(ap, char *);
#line 814
    tmp = tmp___11;
#line 815
    memset((void *)(entry.sce_cwd), '\000', (size_t )sizeof(entry.sce_cwd));
#line 816
    sstrncpy(entry.sce_cwd, (char const   *)tmp, (size_t )sizeof(entry.sce_cwd));
    }
#line 817
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 820
    cmdstr = (char *)((void *)0);
#line 821
    tmp___12 = __builtin_va_arg(ap, char *);
#line 821
    tmp = tmp___12;
#line 822
    cmdstr = handle_score_str((char const   *)tmp, ap);
#line 824
    memset((void *)(entry.sce_cmd), '\000', (size_t )sizeof(entry.sce_cmd));
#line 825
    sstrncpy(entry.sce_cmd, (char const   *)cmdstr, (size_t )sizeof(entry.sce_cmd));
#line 826
    tmp___13 = __builtin_va_arg(ap, void *);
#line 826
    tmp = tmp___13;
    }
#line 828
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 831
    argstr = (char *)((void *)0);
#line 832
    tmp___14 = __builtin_va_arg(ap, char *);
#line 832
    tmp = tmp___14;
#line 833
    argstr = handle_score_str((char const   *)tmp, ap);
#line 835
    memset((void *)(entry.sce_cmd_arg), '\000', (size_t )sizeof(entry.sce_cmd_arg));
#line 836
    sstrncpy(entry.sce_cmd_arg, (char const   *)argstr, (size_t )sizeof(entry.sce_cmd_arg));
#line 837
    tmp___15 = __builtin_va_arg(ap, void *);
#line 837
    tmp = tmp___15;
    }
#line 839
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 842
    tmp___16 = __builtin_va_arg(ap, int );
#line 842
    entry.sce_server_port = tmp___16;
    }
#line 843
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 846
    tmp___18 = __builtin_va_arg(ap, pr_netaddr_t *);
#line 846
    server_addr = tmp___18;
#line 847
    tmp___20 = __builtin_va_arg(ap, int );
#line 847
    server_port = tmp___20;
    }
#line 849
    if (server_addr) {
      {
#line 849
      tmp___21 = pr_netaddr_get_ipstr(server_addr);
#line 849
      tmp___22 = tmp___21;
      }
    } else {
#line 849
      tmp___22 = "(unknown)";
    }
    {
#line 849
    snprintf((char */* __restrict  */)(entry.sce_server_addr), (size_t )sizeof(entry.sce_server_addr),
             (char const   */* __restrict  */)"%s:%d", tmp___22, server_port);
#line 852
    entry.sce_server_addr[sizeof(entry.sce_server_addr) - 1UL] = (char )'\000';
    }
#line 854
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 857
    tmp___23 = __builtin_va_arg(ap, char *);
#line 857
    tmp = tmp___23;
#line 858
    memset((void *)(entry.sce_server_label), '\000', (size_t )sizeof(entry.sce_server_label));
#line 859
    sstrncpy(entry.sce_server_label, (char const   *)tmp, (size_t )sizeof(entry.sce_server_label));
    }
#line 860
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 864
    tmp___25 = __builtin_va_arg(ap, time_t );
#line 866
    time(& entry.sce_begin_idle);
    }
#line 867
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 871
    tmp___27 = __builtin_va_arg(ap, time_t );
#line 873
    time(& entry.sce_begin_session);
    }
#line 874
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 877
    tmp___28 = __builtin_va_arg(ap, off_t___0 );
#line 877
    entry.sce_xfer_done = tmp___28;
    }
#line 878
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 881
    tmp___29 = __builtin_va_arg(ap, off_t___0 );
#line 881
    entry.sce_xfer_size = tmp___29;
    }
#line 882
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 885
    tmp___30 = __builtin_va_arg(ap, off_t___0 );
#line 885
    entry.sce_xfer_len = tmp___30;
    }
#line 886
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 889
    tmp___31 = __builtin_va_arg(ap, unsigned long );
#line 889
    entry.sce_xfer_elapsed = tmp___31;
    }
#line 890
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 893
    tmp___32 = __errno_location();
#line 893
    *tmp___32 = 2;
    }
#line 894
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  wlock_entry();
#line 900
  tmp___36 = write_entry();
  }
#line 900
  if (tmp___36 < 0) {
    {
#line 901
    tmp___34 = __errno_location();
#line 901
    tmp___35 = strerror(*tmp___34);
#line 901
    pr_log_pri(5, "error writing scoreboard entry: %s", tmp___35);
    }
  }
  {
#line 904
  unlock_entry();
  }
#line 906
  return (0);
}
}
#line 909 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c"
int pr_scoreboard_scrub(void) 
{ 
  int fd___0 ;
  off_t___0 curr_offset ;
  struct flock lock ;
  pr_scoreboard_entry_t sce ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  __uid_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  ssize_t tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  ssize_t tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  __uid_t tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  int tmp___45 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
  {
#line 910
  fd___0 = -1;
#line 911
  curr_offset = (off_t___0 )0;
#line 915
  pr_log_debug(9, "scrubbing scoreboard");
#line 920
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c",
               920);
#line 920
  pr_signals_block();
  }
#line 920
  if (! session.disable_id_switching) {
    {
#line 920
    tmp___1 = seteuid((__uid_t )0);
    }
#line 920
    if (tmp___1) {
      {
#line 920
      tmp = __errno_location();
#line 920
      tmp___0 = strerror(*tmp);
#line 920
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 920
    tmp___4 = setegid((__gid_t )0);
    }
#line 920
    if (tmp___4) {
      {
#line 920
      tmp___2 = __errno_location();
#line 920
      tmp___3 = strerror(*tmp___2);
#line 920
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 920
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 920
  pr_signals_unblock();
#line 921
  tmp___5 = pr_get_scoreboard();
#line 921
  fd___0 = open(tmp___5, 2);
#line 922
  pr_signals_block();
  }
#line 922
  if (! session.disable_id_switching) {
    {
#line 922
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c",
                 922);
#line 922
    tmp___9 = geteuid();
    }
#line 922
    if (tmp___9 != 0U) {
      {
#line 922
      tmp___8 = seteuid((__uid_t )0);
      }
#line 922
      if (tmp___8) {
        {
#line 922
        tmp___6 = __errno_location();
#line 922
        tmp___7 = strerror(*tmp___6);
#line 922
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___7);
        }
      }
    }
    {
#line 922
    tmp___12 = setegid(session.gid);
    }
#line 922
    if (tmp___12) {
      {
#line 922
      tmp___10 = __errno_location();
#line 922
      tmp___11 = strerror(*tmp___10);
#line 922
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___11);
      }
    }
    {
#line 922
    tmp___15 = seteuid(session.uid);
    }
#line 922
    if (tmp___15) {
      {
#line 922
      tmp___13 = __errno_location();
#line 922
      tmp___14 = strerror(*tmp___13);
#line 922
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___14);
      }
    }
  } else {
    {
#line 922
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 922
  pr_signals_unblock();
  }
#line 924
  if (fd___0 < 0) {
    {
#line 925
    tmp___16 = __errno_location();
#line 925
    tmp___17 = strerror(*tmp___16);
#line 925
    tmp___18 = pr_get_scoreboard();
#line 925
    pr_log_debug(1, "unable to scrub ScoreboardFile \'%s\': %s", tmp___18, tmp___17);
    }
#line 927
    return (-1);
  }
#line 931
  lock.l_type = (short)1;
#line 932
  lock.l_whence = (short)0;
#line 933
  lock.l_start = (__off64_t )0;
#line 934
  lock.l_len = (__off64_t )0;
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 936
    tmp___20 = fcntl(fd___0, 14, & lock);
    }
#line 936
    if (! (tmp___20 < 0)) {
#line 936
      goto while_break;
    }
    {
#line 937
    tmp___19 = __errno_location();
    }
#line 937
    if (*tmp___19 == 4) {
      {
#line 938
      pr_signals_handle();
      }
#line 939
      goto while_continue;
    }
#line 942
    return (-1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 946
  curr_offset = lseek(fd___0, (__off64_t )sizeof(pr_scoreboard_header_t ), 0);
#line 948
  memset((void *)(& sce), 0, (size_t )sizeof(sce));
#line 950
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c",
               950);
#line 950
  pr_signals_block();
  }
#line 950
  if (! session.disable_id_switching) {
    {
#line 950
    tmp___23 = seteuid((__uid_t )0);
    }
#line 950
    if (tmp___23) {
      {
#line 950
      tmp___21 = __errno_location();
#line 950
      tmp___22 = strerror(*tmp___21);
#line 950
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___22);
      }
    }
    {
#line 950
    tmp___26 = setegid((__gid_t )0);
    }
#line 950
    if (tmp___26) {
      {
#line 950
      tmp___24 = __errno_location();
#line 950
      tmp___25 = strerror(*tmp___24);
#line 950
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___25);
      }
    }
  } else {
    {
#line 950
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 950
  pr_signals_unblock();
  }
  {
#line 951
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 951
    tmp___33 = read(fd___0, (void *)(& sce), (size_t )sizeof(sce));
    }
#line 951
    if (! ((unsigned long )tmp___33 == sizeof(sce))) {
#line 951
      goto while_break___0;
    }
    {
#line 952
    pr_signals_handle();
    }
#line 957
    if (sce.sce_pid) {
      {
#line 957
      tmp___31 = kill(sce.sce_pid, 0);
      }
#line 957
      if (tmp___31 < 0) {
        {
#line 957
        tmp___32 = __errno_location();
        }
#line 957
        if (*tmp___32 == 3) {
          {
#line 962
          pr_log_debug(9, "scrubbing scoreboard slot for PID %u", (unsigned int )sce.sce_pid);
#line 966
          lseek(fd___0, curr_offset, 0);
#line 968
          memset((void *)(& sce), 0, (size_t )sizeof(sce));
          }
          {
#line 969
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 969
            tmp___30 = write(fd___0, (void const   *)(& sce), (size_t )sizeof(sce));
            }
#line 969
            if (! ((unsigned long )tmp___30 != sizeof(sce))) {
#line 969
              goto while_break___1;
            }
            {
#line 970
            tmp___27 = __errno_location();
            }
#line 970
            if (*tmp___27 == 4) {
              {
#line 971
              pr_signals_handle();
              }
#line 972
              goto while_continue___1;
            }
            {
#line 975
            tmp___28 = __errno_location();
#line 975
            tmp___29 = strerror(*tmp___28);
#line 975
            pr_log_debug(0, "error scrubbing scoreboard: %s", tmp___29);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 981
    curr_offset = lseek(fd___0, (__off64_t )0, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 983
  pr_signals_block();
  }
#line 983
  if (! session.disable_id_switching) {
    {
#line 983
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/scoreboard.c",
                 983);
#line 983
    tmp___37 = geteuid();
    }
#line 983
    if (tmp___37 != 0U) {
      {
#line 983
      tmp___36 = seteuid((__uid_t )0);
      }
#line 983
      if (tmp___36) {
        {
#line 983
        tmp___34 = __errno_location();
#line 983
        tmp___35 = strerror(*tmp___34);
#line 983
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___35);
        }
      }
    }
    {
#line 983
    tmp___40 = setegid(session.gid);
    }
#line 983
    if (tmp___40) {
      {
#line 983
      tmp___38 = __errno_location();
#line 983
      tmp___39 = strerror(*tmp___38);
#line 983
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___39);
      }
    }
    {
#line 983
    tmp___43 = seteuid(session.uid);
    }
#line 983
    if (tmp___43) {
      {
#line 983
      tmp___41 = __errno_location();
#line 983
      tmp___42 = strerror(*tmp___41);
#line 983
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___42);
      }
    }
  } else {
    {
#line 983
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 983
  pr_signals_unblock();
#line 986
  lock.l_type = (short)2;
#line 987
  lock.l_whence = (short)0;
#line 988
  lock.l_start = (__off64_t )0;
#line 989
  lock.l_len = (__off64_t )0;
  }
  {
#line 991
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 991
    tmp___45 = fcntl(fd___0, 13, & lock);
    }
#line 991
    if (! (tmp___45 < 0)) {
#line 991
      goto while_break___2;
    }
    {
#line 992
    tmp___44 = __errno_location();
    }
#line 992
    if (*tmp___44 == 4) {
      {
#line 993
      pr_signals_handle();
      }
#line 994
      goto while_continue___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 999
  close(fd___0);
  }
#line 1001
  return (0);
}
}
#line 52 "../include/netacl.h"
pr_netacl_t *pr_netacl_dup(pool *p , pr_netacl_t *acl ) ;
#line 58
int pr_netacl_match(pr_netacl_t *acl , pr_netaddr_t *addr ) ;
#line 70
char const   *pr_netacl_get_str(pool *p , pr_netacl_t *acl ) ;
#line 49 "../include/class.h"
pr_class_t *pr_class_find(char const   *name ) ;
#line 55
pr_class_t *pr_class_get(pr_class_t *prev ) ;
#line 61
pr_class_t *pr_class_match_addr(pr_netaddr_t *addr ) ;
#line 83
void init_class(void) ;
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
static char const   *trace_channel___7  =    "class";
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
static pr_class_t *class_list  =    (pr_class_t *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
static pr_class_t *curr_cls  =    (pr_class_t *)((void *)0);
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
pr_class_t *pr_class_get(pr_class_t *prev ) 
{ 


  {
#line 40
  if (prev) {
#line 41
    return (prev->cls_next);
  }
#line 43
  return (class_list);
}
}
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
pr_class_t *pr_class_match_addr(pr_netaddr_t *addr ) 
{ 
  pr_class_t *cls ;
  pool *tmp_pool ;
  int *tmp ;
  array_header *acl_list ;
  pr_netacl_t **acls ;
  register int i___0 ;
  int next_class ;
  int res ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 50
  if (! addr) {
    {
#line 51
    tmp = __errno_location();
#line 51
    *tmp = 22;
    }
#line 52
    return ((pr_class_t *)((void *)0));
  }
  {
#line 55
  tmp_pool = make_sub_pool(permanent_pool);
#line 57
  cls = class_list;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! cls) {
#line 57
      goto while_break;
    }
#line 58
    acl_list = cls->cls_acls;
#line 59
    acls = (pr_netacl_t **)acl_list->elts;
#line 61
    next_class = 0;
#line 68
    i___0 = 0;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 68
      if (! (i___0 < acl_list->nelts)) {
#line 68
        goto while_break___0;
      }
#line 71
      if (next_class) {
#line 72
        goto while_break___0;
      }
#line 74
      if ((unsigned long )*(acls + i___0) == (unsigned long )((void *)0)) {
#line 75
        goto __Cont;
      }
      {
#line 78
      if (cls->cls_satisfy == 0U) {
#line 78
        goto case_0;
      }
#line 91
      if (cls->cls_satisfy == 1U) {
#line 91
        goto case_1;
      }
#line 77
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 79
      tmp___0 = pr_netacl_get_str(tmp_pool, *(acls + i___0));
#line 79
      tmp___1 = pr_netaddr_get_ipstr(addr);
#line 79
      pr_trace_msg(trace_channel___7, 6, "checking addr \'%s\' against class \'%s\', ACL %s (requires any ACL matching)",
                   tmp___1, cls->cls_name, tmp___0);
#line 84
      res = pr_netacl_match(*(acls + i___0), addr);
      }
#line 85
      if (res == 1) {
        {
#line 86
        destroy_pool(tmp_pool);
        }
#line 87
        return (cls);
      }
#line 89
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 92
      tmp___2 = pr_netacl_get_str(tmp_pool, *(acls + i___0));
#line 92
      tmp___3 = pr_netaddr_get_ipstr(addr);
#line 92
      pr_trace_msg(trace_channel___7, 6, "checking addr \'%s\' against class \'%s\', ACL %s (requires all ACLs matching)",
                   tmp___3, cls->cls_name, tmp___2);
#line 97
      res = pr_netacl_match(*(acls + i___0), addr);
      }
#line 99
      if (res <= 0) {
#line 100
        next_class = 1;
      }
#line 101
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 68
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    if (next_class == 0) {
#line 108
      if (cls->cls_satisfy == 1U) {
#line 108
        if (i___0 == acl_list->nelts) {
          {
#line 111
          destroy_pool(tmp_pool);
          }
#line 112
          return (cls);
        }
      }
    }
#line 57
    cls = cls->cls_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  destroy_pool(tmp_pool);
#line 118
  tmp___4 = __errno_location();
#line 118
  *tmp___4 = 2;
  }
#line 119
  return ((pr_class_t *)((void *)0));
}
}
#line 122 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
pr_class_t *pr_class_find(char const   *name ) 
{ 
  pr_class_t *cls ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 125
  if (! name) {
    {
#line 126
    tmp = __errno_location();
#line 126
    *tmp = 22;
    }
#line 127
    return ((pr_class_t *)((void *)0));
  }
#line 130
  cls = class_list;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! cls) {
#line 130
      goto while_break;
    }
    {
#line 131
    tmp___0 = strcmp((char const   *)cls->cls_name, name);
    }
#line 131
    if (tmp___0 == 0) {
#line 132
      return (cls);
    }
#line 130
    cls = cls->cls_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___1 = __errno_location();
#line 134
  *tmp___1 = 2;
  }
#line 135
  return ((pr_class_t *)((void *)0));
}
}
#line 138 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
int pr_class_add_acl(pr_netacl_t *acl ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 140
  if (! acl) {
    {
#line 141
    tmp = __errno_location();
#line 141
    *tmp = 22;
    }
#line 142
    return (-1);
  }
#line 145
  if (! curr_cls) {
    {
#line 146
    tmp___0 = __errno_location();
#line 146
    *tmp___0 = 1;
    }
#line 147
    return (-1);
  }
#line 151
  if (! curr_cls->cls_acls) {
    {
#line 152
    curr_cls->cls_acls = make_array(curr_cls->cls_pool, 1U, (size_t )sizeof(pr_netacl_t *));
    }
  }
  {
#line 155
  tmp___1 = push_array(curr_cls->cls_acls);
#line 155
  *((pr_netacl_t **)tmp___1) = pr_netacl_dup(curr_cls->cls_pool, acl);
  }
#line 158
  return (0);
}
}
#line 161 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
int pr_class_set_satisfy(int satisfy ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 163
  if (! curr_cls) {
    {
#line 164
    tmp = __errno_location();
#line 164
    *tmp = 1;
    }
#line 165
    return (-1);
  }
#line 168
  if (satisfy != 0) {
#line 168
    if (satisfy != 1) {
      {
#line 170
      tmp___0 = __errno_location();
#line 170
      *tmp___0 = 22;
      }
#line 171
      return (-1);
    }
  }
#line 175
  curr_cls->cls_satisfy = (unsigned int )satisfy;
#line 177
  return (0);
}
}
#line 180 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
int pr_class_open(pool *p , char const   *name ) 
{ 
  pr_class_t *cls ;
  pool *cls_pool ;
  int *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 184
  if (! p) {
    {
#line 185
    tmp = __errno_location();
#line 185
    *tmp = 22;
    }
#line 186
    return (-1);
  } else
#line 184
  if (! name) {
    {
#line 185
    tmp = __errno_location();
#line 185
    *tmp = 22;
    }
#line 186
    return (-1);
  }
  {
#line 192
  cls_pool = make_sub_pool(p);
#line 193
  pr_pool_tag(cls_pool, "<Class> Pool");
#line 195
  tmp___0 = pcalloc(cls_pool, (int )sizeof(pr_class_t ));
#line 195
  cls = (pr_class_t *)tmp___0;
#line 196
  cls->cls_pool = cls_pool;
#line 197
  cls->cls_name = pstrdup(cls->cls_pool, name);
#line 198
  cls->cls_satisfy = 0U;
#line 201
  main_server->config_type = 1 << 7;
#line 203
  curr_cls = cls;
  }
#line 204
  return (0);
}
}
#line 207 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
int pr_class_close(void) 
{ 
  int *tmp ;
  pr_class_t *ci ;

  {
#line 210
  if (! curr_cls) {
#line 211
    return (0);
  }
#line 216
  if (! curr_cls->cls_acls) {
    {
#line 217
    destroy_pool(curr_cls->cls_pool);
#line 218
    curr_cls = (pr_class_t *)((void *)0);
#line 221
    main_server->config_type = 1;
#line 223
    tmp = __errno_location();
#line 223
    *tmp = 22;
    }
#line 224
    return (-1);
  }
  {
#line 228
  push_array(curr_cls->cls_acls);
  }
#line 231
  if (class_list) {
#line 232
    ci = class_list;
    {
#line 233
    while (1) {
      while_continue: /* CIL Label */ ;
#line 233
      if (ci) {
#line 233
        if (! ci->cls_next) {
#line 233
          goto while_break;
        }
      } else {
#line 233
        goto while_break;
      }
#line 234
      ci = ci->cls_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 236
    ci->cls_next = curr_cls;
  } else {
#line 239
    class_list = curr_cls;
  }
#line 241
  curr_cls = (pr_class_t *)((void *)0);
#line 244
  main_server->config_type = 1;
#line 246
  return (0);
}
}
#line 249 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/class.c"
void init_class(void) 
{ 


  {
#line 250
  class_list = (pr_class_t *)((void *)0);
#line 251
  return;
}
}
#line 188 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 64 "../include/netacl.h"
int pr_netacl_get_negated(pr_netacl_t *acl ) ;
#line 67
pr_netacl_type_t pr_netacl_get_type(pr_netacl_t *acl ) ;
#line 215 "../include/netaddr.h"
pr_netaddr_t *pr_netaddr_alloc(pool *p ) ;
#line 249
int pr_netaddr_ncmp(pr_netaddr_t const   *na1 , pr_netaddr_t const   *na2 , unsigned int bitlen ) ;
#line 261
int pr_netaddr_fnmatch(pr_netaddr_t *na , char const   *pattern , int flags ) ;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
static char const   *trace_channel___8  =    "netacl";
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
pr_netacl_type_t pr_netacl_get_type(pr_netacl_t *acl ) 
{ 


  {
#line 46
  return (acl->type);
}
}
#line 52 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
int pr_netacl_match(pr_netacl_t *acl , pr_netaddr_t *addr ) 
{ 
  pool *tmp_pool ;
  int *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 55
  if ((unsigned long )acl == (unsigned long )((void *)0)) {
    {
#line 57
    tmp = __errno_location();
#line 57
    *tmp = 22;
    }
#line 58
    return (-2);
  } else
#line 55
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 57
    tmp = __errno_location();
#line 57
    *tmp = 22;
    }
#line 58
    return (-2);
  }
  {
#line 61
  tmp_pool = make_sub_pool(permanent_pool);
  }
  {
#line 64
  if ((unsigned int )acl->type == 0U) {
#line 64
    goto case_0;
  }
#line 70
  if ((unsigned int )acl->type == 1U) {
#line 70
    goto case_1;
  }
#line 76
  if ((unsigned int )acl->type == 2U) {
#line 76
    goto case_2;
  }
#line 95
  if ((unsigned int )acl->type == 3U) {
#line 95
    goto case_3;
  }
#line 115
  if ((unsigned int )acl->type == 4U) {
#line 115
    goto case_4;
  }
#line 136
  if ((unsigned int )acl->type == 5U) {
#line 136
    goto case_5;
  }
#line 157
  if ((unsigned int )acl->type == 6U) {
#line 157
    goto case_6;
  }
#line 63
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 65
  tmp___0 = pr_netacl_get_str(tmp_pool, acl);
#line 65
  tmp___1 = pr_netaddr_get_ipstr(addr);
#line 65
  pr_trace_msg(trace_channel___8, 10, "addr \'%s\' matched rule \'ALL\' (\'%s\')",
               tmp___1, tmp___0);
#line 67
  destroy_pool(tmp_pool);
  }
#line 68
  return (1);
  case_1: /* CIL Label */ 
  {
#line 71
  tmp___2 = pr_netaddr_get_ipstr(addr);
#line 71
  pr_trace_msg(trace_channel___8, 10, "addr \'%s\' matched rule \'NONE\'", tmp___2);
#line 73
  destroy_pool(tmp_pool);
  }
#line 74
  return (-1);
  case_2: /* CIL Label */ 
  {
#line 77
  tmp___4 = pr_netaddr_ncmp((pr_netaddr_t const   *)addr, (pr_netaddr_t const   *)acl->addr,
                            acl->masklen);
  }
#line 77
  if (tmp___4 == 0) {
    {
#line 78
    tmp___3 = pr_netaddr_get_ipstr(addr);
#line 78
    pr_trace_msg(trace_channel___8, 10, "addr \'%s\' matched IP mask rule \'%s\'",
                 tmp___3, acl->aclstr);
#line 80
    destroy_pool(tmp_pool);
    }
#line 82
    if (acl->negated) {
#line 83
      return (-1);
    }
#line 85
    return (1);
  } else
#line 88
  if (acl->negated) {
    {
#line 89
    destroy_pool(tmp_pool);
    }
#line 90
    return (1);
  }
#line 93
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 96
  tmp___6 = pr_netaddr_cmp((pr_netaddr_t const   *)addr, (pr_netaddr_t const   *)acl->addr);
  }
#line 96
  if (tmp___6 == 0) {
    {
#line 97
    tmp___5 = pr_netaddr_get_ipstr(addr);
#line 97
    pr_trace_msg(trace_channel___8, 10, "addr \'%s\' matched IP address rule \'%s\'",
                 tmp___5, acl->aclstr);
#line 100
    destroy_pool(tmp_pool);
    }
#line 102
    if (acl->negated) {
#line 103
      return (-1);
    }
#line 105
    return (1);
  } else
#line 108
  if (acl->negated) {
    {
#line 109
    destroy_pool(tmp_pool);
    }
#line 110
    return (1);
  }
#line 113
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 116
  tmp___9 = pr_netaddr_get_dnsstr(addr);
#line 116
  tmp___10 = strcmp(tmp___9, (char const   *)acl->pattern);
  }
#line 116
  if (tmp___10 == 0) {
    {
#line 117
    tmp___7 = pr_netaddr_get_dnsstr(addr);
#line 117
    tmp___8 = pr_netaddr_get_ipstr(addr);
#line 117
    pr_trace_msg(trace_channel___8, 10, "addr \'%s\' (%s) matched DNS name rule \'%s\'",
                 tmp___8, tmp___7, acl->aclstr);
#line 121
    destroy_pool(tmp_pool);
    }
#line 123
    if (acl->negated) {
#line 124
      return (-1);
    }
#line 126
    return (1);
  } else
#line 129
  if (acl->negated) {
    {
#line 130
    destroy_pool(tmp_pool);
    }
#line 131
    return (1);
  }
#line 134
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 137
  tmp___12 = pr_netaddr_fnmatch(addr, (char const   *)acl->pattern, 2);
  }
#line 137
  if (tmp___12 == 1) {
    {
#line 139
    tmp___11 = pr_netaddr_get_ipstr(addr);
#line 139
    pr_trace_msg(trace_channel___8, 10, "addr \'%s\' matched IP glob rule \'%s\'",
                 tmp___11, acl->aclstr);
#line 142
    destroy_pool(tmp_pool);
    }
#line 144
    if (acl->negated) {
#line 145
      return (-1);
    }
#line 147
    return (1);
  } else
#line 150
  if (acl->negated) {
    {
#line 151
    destroy_pool(tmp_pool);
    }
#line 152
    return (1);
  }
#line 155
  goto switch_break;
  case_6: /* CIL Label */ 
#line 158
  if (ServerUseReverseDNS) {
    {
#line 159
    tmp___15 = pr_netaddr_fnmatch(addr, (char const   *)acl->pattern, 1);
    }
#line 159
    if (tmp___15 == 1) {
      {
#line 161
      tmp___13 = pr_netaddr_get_dnsstr(addr);
#line 161
      tmp___14 = pr_netaddr_get_ipstr(addr);
#line 161
      pr_trace_msg(trace_channel___8, 10, "addr \'%s\' (%s) matched DNS glob rule \'%s\'",
                   tmp___14, tmp___13, acl->aclstr);
#line 165
      destroy_pool(tmp_pool);
      }
#line 167
      if (acl->negated) {
#line 168
        return (-1);
      }
#line 170
      return (1);
    } else
#line 173
    if (acl->negated) {
      {
#line 174
      destroy_pool(tmp_pool);
      }
#line 175
      return (1);
    }
  } else {
    {
#line 180
    tmp___16 = pr_netaddr_get_dnsstr(addr);
#line 180
    tmp___17 = pr_netaddr_get_ipstr(addr);
#line 180
    pr_trace_msg(trace_channel___8, 10, "skipping comparing addr \'%s\' (%s) against DNS glob rule \'%s\' because UseReverseDNS is off",
                 tmp___17, tmp___16, acl->aclstr);
    }
  }
#line 185
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 188
  destroy_pool(tmp_pool);
  }
#line 189
  return (0);
}
}
#line 192 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
pr_netacl_t *pr_netacl_create(pool *p , char *aclstr ) 
{ 
  pr_netacl_t *acl ;
  char *cp ;
  char *aclstr_dup ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  long tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  unsigned char tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  unsigned char tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 196
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 198
    tmp = __errno_location();
#line 198
    *tmp = 22;
    }
#line 199
    return ((pr_netacl_t *)((void *)0));
  } else
#line 196
  if ((unsigned long )aclstr == (unsigned long )((void *)0)) {
    {
#line 198
    tmp = __errno_location();
#line 198
    *tmp = 22;
    }
#line 199
    return ((pr_netacl_t *)((void *)0));
  }
  {
#line 202
  tmp___1 = strlen((char const   *)aclstr);
  }
#line 202
  if (tmp___1 == 0U) {
    {
#line 203
    tmp___0 = __errno_location();
#line 203
    *tmp___0 = 22;
    }
#line 204
    return ((pr_netacl_t *)((void *)0));
  }
  {
#line 208
  tmp___2 = pcalloc(p, (int )sizeof(pr_netacl_t ));
#line 208
  acl = (pr_netacl_t *)tmp___2;
#line 210
  aclstr_dup = pstrdup(p, (char const   *)aclstr);
#line 212
  tmp___20 = strcasecmp((char const   *)aclstr, "all");
  }
#line 212
  if (tmp___20 == 0) {
    {
#line 213
    aclstr_dup = pstrdup(p, "all");
#line 214
    acl->type = (pr_netacl_type_t )0;
    }
  } else {
    {
#line 216
    tmp___19 = strcasecmp((char const   *)aclstr, "none");
    }
#line 216
    if (tmp___19 == 0) {
      {
#line 217
      aclstr_dup = pstrdup(p, "none");
#line 218
      acl->type = (pr_netacl_type_t )1;
      }
    } else {
      {
#line 220
      cp = strchr((char const   *)aclstr, '/');
      }
#line 220
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 223
        acl->type = (pr_netacl_type_t )2;
#line 224
        *cp = (char )'\000';
#line 227
        if ((int )*aclstr == 33) {
#line 228
          acl->negated = 1;
#line 229
          aclstr ++;
        }
        {
#line 236
        tmp___5 = strspn((char const   *)aclstr, "0123456789ABCDEFabcdef.:");
#line 236
        tmp___6 = strlen((char const   *)aclstr);
        }
#line 236
        if (tmp___5 != tmp___6) {
          {
#line 237
          tmp___4 = __errno_location();
#line 237
          *tmp___4 = 22;
          }
#line 238
          return ((pr_netacl_t *)((void *)0));
        }
        {
#line 241
        acl->addr = pr_netaddr_get_addr(p, (char const   *)aclstr, (array_header **)((void *)0));
        }
#line 242
        if (! acl->addr) {
#line 243
          return ((pr_netacl_t *)((void *)0));
        }
        {
#line 246
        tmp___7 = strtol((char const   */* __restrict  */)(cp + 1), (char **/* __restrict  */)(& tmp___3),
                         10);
#line 246
        acl->masklen = (unsigned int )tmp___7;
        }
#line 248
        if (tmp___3) {
#line 248
          if (*tmp___3) {
            {
#line 250
            tmp___8 = __errno_location();
#line 250
            *tmp___8 = 22;
            }
#line 251
            return ((pr_netacl_t *)((void *)0));
          }
        }
        {
#line 254
        *cp = (char )'/';
#line 257
        tmp___9 = pr_netaddr_get_family((pr_netaddr_t const   *)acl->addr);
        }
        {
#line 258
        if (tmp___9 == 2) {
#line 258
          goto case_2;
        }
#line 271
        if (tmp___9 == 10) {
#line 271
          goto case_10;
        }
#line 292
        goto switch_default;
        case_2: /* CIL Label */ 
#line 262
        if (acl->masklen > 32U) {
          {
#line 263
          tmp___10 = __errno_location();
#line 263
          *tmp___10 = 22;
          }
#line 264
          return ((pr_netacl_t *)((void *)0));
        }
#line 267
        goto switch_break;
        case_10: /* CIL Label */ 
        {
#line 272
        tmp___13 = pr_netaddr_use_ipv6();
        }
#line 272
        if (tmp___13) {
#line 273
          if (acl->masklen > 128U) {
            {
#line 274
            tmp___11 = __errno_location();
#line 274
            *tmp___11 = 22;
            }
#line 275
            return ((pr_netacl_t *)((void *)0));
          } else {
            {
#line 277
            tmp___12 = pr_netaddr_is_v4mappedv6((pr_netaddr_t const   *)acl->addr);
            }
#line 277
            if (tmp___12 == 1) {
#line 277
              if (acl->masklen > 32U) {
                {
#line 283
                pr_log_pri(4, "warning: possibly using IPv6-style netmask on IPv4-mapped IPv6 address, which will not work as expected");
#line 284
                pr_trace_msg(trace_channel___8, 1, "possibly using IPv6-style netmask on IPv4-mapped IPv6 address (%s), which will not work as expected",
                             aclstr);
                }
#line 286
                goto switch_break;
              }
            }
          }
        }
        switch_default: /* CIL Label */ 
#line 293
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 297
        tmp___16 = pr_netaddr_use_ipv6();
        }
#line 297
        if (tmp___16) {
          {
#line 297
          tmp___17 = strspn((char const   *)aclstr, "0123456789ABCDEFabcdef.:!");
#line 297
          tmp___18 = strlen((char const   *)aclstr);
          }
#line 297
          if (tmp___17 != tmp___18) {
#line 304
            if ((int )*aclstr == 33) {
#line 305
              acl->negated = 1;
#line 306
              aclstr ++;
            }
            {
#line 312
            tmp___14 = strpbrk((char const   *)aclstr, "{[*?");
            }
#line 312
            if (tmp___14) {
              {
#line 313
              acl->type = (pr_netacl_type_t )6;
#line 314
              acl->pattern = pstrdup(p, (char const   *)aclstr);
              }
            } else
#line 316
            if ((int )*aclstr == 46) {
              {
#line 317
              acl->type = (pr_netacl_type_t )6;
#line 318
              acl->pattern = pstrcat(p, "*", aclstr, (void *)0);
              }
            } else {
              {
#line 321
              acl->type = (pr_netacl_type_t )4;
#line 322
              acl->pattern = pstrdup(p, (char const   *)aclstr);
              }
            }
          } else {
#line 297
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 328
          if ((int )*aclstr == 33) {
#line 329
            acl->negated = 1;
#line 330
            aclstr ++;
          }
          {
#line 334
          tmp___15 = strlen((char const   *)aclstr);
          }
#line 334
          if ((int )*(aclstr + (tmp___15 - 1U)) == 46) {
            {
#line 335
            acl->type = (pr_netacl_type_t )5;
#line 336
            acl->pattern = pstrcat(p, aclstr, "*", (void *)0);
            }
          } else {
            {
#line 339
            acl->type = (pr_netacl_type_t )3;
#line 340
            acl->addr = pr_netaddr_get_addr(p, (char const   *)aclstr, (array_header **)((void *)0));
            }
#line 342
            if (! acl->addr) {
#line 343
              return ((pr_netacl_t *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 347
  acl->aclstr = (char const   *)aclstr_dup;
#line 348
  return (acl);
}
}
#line 351 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
pr_netacl_t *pr_netacl_dup(pool *p , pr_netacl_t *acl ) 
{ 
  pr_netacl_t *acl2 ;
  int *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct sockaddr *tmp___2 ;
  char *tmp___3 ;

  {
#line 354
  if (! p) {
    {
#line 355
    tmp = __errno_location();
#line 355
    *tmp = 22;
    }
#line 356
    return ((pr_netacl_t *)((void *)0));
  } else
#line 354
  if (! acl) {
    {
#line 355
    tmp = __errno_location();
#line 355
    *tmp = 22;
    }
#line 356
    return ((pr_netacl_t *)((void *)0));
  }
  {
#line 359
  tmp___0 = pcalloc(p, (int )sizeof(pr_netacl_t ));
#line 359
  acl2 = (pr_netacl_t *)tmp___0;
#line 362
  acl2->type = acl->type;
  }
#line 364
  if (acl->pattern) {
    {
#line 365
    acl2->pattern = pstrdup(p, (char const   *)acl->pattern);
    }
  }
#line 367
  acl2->negated = acl->negated;
#line 369
  if (acl->addr) {
    {
#line 370
    acl2->addr = pr_netaddr_alloc(p);
#line 372
    tmp___1 = pr_netaddr_get_family((pr_netaddr_t const   *)acl->addr);
#line 372
    pr_netaddr_set_family(acl2->addr, tmp___1);
#line 373
    tmp___2 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)acl->addr);
#line 373
    pr_netaddr_set_sockaddr(acl2->addr, tmp___2);
    }
  }
#line 376
  acl2->masklen = acl->masklen;
#line 378
  if (acl->aclstr) {
    {
#line 379
    tmp___3 = pstrdup(p, acl->aclstr);
#line 379
    acl2->aclstr = (char const   *)tmp___3;
    }
  }
#line 381
  return (acl2);
}
}
#line 384 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
int pr_netacl_get_negated(pr_netacl_t *acl ) 
{ 
  int *tmp ;

  {
#line 385
  if (! acl) {
    {
#line 386
    tmp = __errno_location();
#line 386
    *tmp = 22;
    }
#line 387
    return (-1);
  }
#line 390
  return (acl->negated);
}
}
#line 393 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netacl.c"
char const   *pr_netacl_get_str(pool *p , pr_netacl_t *acl ) 
{ 
  char *res ;
  int *tmp ;
  char masklenstr[64] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 394
  res = (char *)"";
#line 396
  if (! p) {
    {
#line 397
    tmp = __errno_location();
#line 397
    *tmp = 22;
    }
#line 398
    return ((char const   *)((void *)0));
  } else
#line 396
  if (! acl) {
    {
#line 397
    tmp = __errno_location();
#line 397
    *tmp = 22;
    }
#line 398
    return ((char const   *)((void *)0));
  }
  {
#line 403
  if ((unsigned int )acl->type == 0U) {
#line 403
    goto case_0;
  }
#line 408
  if ((unsigned int )acl->type == 1U) {
#line 408
    goto case_1;
  }
#line 413
  if ((unsigned int )acl->type == 2U) {
#line 413
    goto case_2;
  }
#line 424
  if ((unsigned int )acl->type == 3U) {
#line 424
    goto case_3;
  }
#line 429
  if ((unsigned int )acl->type == 4U) {
#line 429
    goto case_4;
  }
#line 434
  if ((unsigned int )acl->type == 5U) {
#line 434
    goto case_5;
  }
#line 439
  if ((unsigned int )acl->type == 6U) {
#line 439
    goto case_6;
  }
#line 402
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 404
  res = pstrcat(p, res, acl->aclstr, (void *)0);
#line 405
  res = pstrcat(p, res, " <all>", (void *)0);
  }
#line 406
  return ((char const   *)res);
  case_1: /* CIL Label */ 
  {
#line 409
  res = pstrcat(p, res, acl->aclstr, (void *)0);
#line 410
  res = pstrcat(p, res, " <none>", (void *)0);
  }
#line 411
  return ((char const   *)res);
  case_2: /* CIL Label */ 
  {
#line 416
  res = pstrcat(p, res, acl->aclstr, (void *)0);
#line 417
  memset((void *)(masklenstr), '\000', (size_t )sizeof(masklenstr));
#line 418
  snprintf((char */* __restrict  */)(masklenstr), (size_t )(sizeof(masklenstr) - 1UL),
           (char const   */* __restrict  */)"%u", acl->masklen);
#line 419
  res = pstrcat(p, res, " <IP address mask, ", masklenstr, "-bit mask", (void *)0);
  }
#line 421
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 425
  res = pstrcat(p, res, acl->aclstr, (void *)0);
#line 426
  res = pstrcat(p, res, " <IP address match", (void *)0);
  }
#line 427
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 430
  res = pstrcat(p, res, acl->aclstr, (void *)0);
#line 431
  res = pstrcat(p, res, " <DNS hostname match", (void *)0);
  }
#line 432
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 435
  res = pstrcat(p, res, acl->pattern, (void *)0);
#line 436
  res = pstrcat(p, res, " <IP address glob", (void *)0);
  }
#line 437
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 440
  res = pstrcat(p, res, acl->pattern, (void *)0);
#line 441
  res = pstrcat(p, res, " <DNS hostname glob", (void *)0);
  }
#line 442
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 445
  if (! acl->negated) {
    {
#line 446
    res = pstrcat(p, res, ">", (void *)0);
    }
  } else {
    {
#line 448
    res = pstrcat(p, res, ", inverted>", (void *)0);
    }
  }
#line 450
  return ((char const   *)res);
}
}
#line 84 "../include/pool.h"
void register_cleanup(pool *p , void *data , void (*plain_cleanup_cb)(void * ) , void (*child_cleanup_cb)(void * ) ) ;
#line 148 "../include/inet.h"
int pr_inet_set_default_family(pool *p , int family ) ;
#line 155
int pr_inet_resetlisten(pool *p , conn_t *c ) ;
#line 156
int pr_inet_accept_nowait(pool *p , conn_t *c ) ;
#line 277 "../include/netaddr.h"
size_t pr_netaddr_get_inaddr_len(pr_netaddr_t const   *na ) ;
#line 347
int pr_netaddr_is_loopback(pr_netaddr_t const   *na ) ;
#line 91 "../include/bindings.h"
conn_t *pr_ipbind_accept_conn(fd_set *readfds , int *listenfd ) ;
#line 97
int pr_ipbind_create(server_rec *server , pr_netaddr_t *addr ) ;
#line 104
int pr_ipbind_close(pr_netaddr_t *addr , unsigned int port , unsigned char close_namebinds ) ;
#line 110
int pr_ipbind_close_listeners(void) ;
#line 117
int pr_ipbind_add_binds(server_rec *serv ) ;
#line 122
pr_ipbind_t *pr_ipbind_find(pr_netaddr_t *addr , unsigned int port , unsigned char skip_inactive ) ;
#line 129
pr_ipbind_t *pr_ipbind_get(pr_ipbind_t *prev ) ;
#line 134
server_rec *pr_ipbind_get_server(pr_netaddr_t *addr , unsigned int port ) ;
#line 140
int pr_ipbind_listen(fd_set *readfds ) ;
#line 145
int pr_ipbind_open(pr_netaddr_t *addr , unsigned int port , conn_t *listen_conn ,
                   unsigned char isdefault , unsigned char islocalhost , unsigned char open_namebinds ) ;
#line 151
int pr_namebind_close(char const   *name , pr_netaddr_t *addr , unsigned int port ) ;
#line 158
int pr_namebind_create(server_rec *server , char const   *name , pr_netaddr_t *addr ,
                       unsigned int port ) ;
#line 165
pr_namebind_t *pr_namebind_find(char const   *name , pr_netaddr_t *addr , unsigned int port ,
                                unsigned char skip_inactive ) ;
#line 171
server_rec *pr_namebind_get_server(char const   *name , pr_netaddr_t *addr , unsigned int port ) ;
#line 176
int pr_namebind_open(char const   *name , pr_netaddr_t *addr , unsigned int port ) ;
#line 180
void init_bindings(void) ;
#line 184
void free_bindings(void) ;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static pr_ipbind_t *ipbind_table[256]  ;
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static pool *binding_pool  =    (pool *)((void *)0);
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static pr_ipbind_t *ipbind_default_server  =    (pr_ipbind_t *)((void *)0);
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static pr_ipbind_t *ipbind_localhost_server  =    (pr_ipbind_t *)((void *)0);
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static void server_cleanup_cb(void *conn ) 
{ 


  {
#line 62
  *((conn_t **)conn) = (conn_t *)((void *)0);
#line 63
  return;
}
}
#line 68 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static unsigned int ipbind_hash_addr(pr_netaddr_t *addr ) 
{ 
  size_t offset ;
  size_t tmp ;
  unsigned int key ;
  void *tmp___0 ;

  {
  {
#line 69
  tmp = pr_netaddr_get_inaddr_len((pr_netaddr_t const   *)addr);
#line 69
  offset = tmp;
#line 75
  tmp___0 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)addr);
#line 75
  key = *((unsigned int *)(((char *)tmp___0 + offset) - 4));
#line 78
  key ^= key >> 16;
  }
#line 79
  return (((key >> 8) ^ key) % 256U);
}
}
#line 91 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static array_header *listener_list  =    (array_header *)((void *)0);
#line 93 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
conn_t *pr_ipbind_accept_conn(fd_set *readfds , int *listenfd ) 
{ 
  conn_t **listeners ;
  register unsigned int i___0 ;
  int *tmp ;
  int *tmp___0 ;
  conn_t *listener ;
  int fd___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp12 ;

  {
#line 94
  listeners = (conn_t **)listener_list->elts;
#line 95
  i___0 = 0U;
#line 97
  if (! readfds) {
    {
#line 98
    tmp = __errno_location();
#line 98
    *tmp = 22;
    }
#line 99
    return ((conn_t *)((void *)0));
  }
#line 102
  if (! listenfd) {
    {
#line 103
    tmp___0 = __errno_location();
#line 103
    *tmp___0 = 22;
    }
#line 104
    return ((conn_t *)((void *)0));
  }
#line 107
  i___0 = 0U;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i___0 < (unsigned int )listener_list->nelts)) {
#line 107
      goto while_break;
    }
    {
#line 108
    listener = *(listeners + i___0);
#line 110
    pr_signals_handle();
    }
#line 111
    if ((readfds->fds_bits[(unsigned long )listener->listen_fd / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )listener->listen_fd % (8UL * sizeof(__fd_mask )))) != 0L) {
#line 111
      if (listener->mode == 1) {
        {
#line 113
        tmp___1 = pr_inet_accept_nowait(listener->pool, listener);
#line 113
        fd___0 = tmp___1;
        }
#line 115
        if (fd___0 == -1) {
#line 120
          if (listener->mode == 6) {
            {
#line 121
            tmp___2 = strerror(listener->xerrno);
#line 121
            pr_log_pri(3, "error: unable to accept an incoming connection (%s)", tmp___2);
#line 123
            listener->xerrno = 0;
#line 124
            listener->mode = 1;
            }
#line 125
            return ((conn_t *)((void *)0));
          }
        }
#line 129
        *listenfd = fd___0;
#line 130
        return (listener);
      }
    }
#line 107
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___3 = __errno_location();
#line 134
  *tmp___3 = 2;
  }
#line 135
  return ((conn_t *)((void *)0));
}
}
#line 138 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_ipbind_add_binds(server_rec *serv ) 
{ 
  int res ;
  config_rec *c ;
  conn_t *listen_conn ;
  pr_netaddr_t *addr ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 139
  res = 0;
#line 140
  c = (config_rec *)((void *)0);
#line 141
  listen_conn = (conn_t *)((void *)0);
#line 142
  addr = (pr_netaddr_t *)((void *)0);
#line 144
  if (! serv) {
#line 145
    return (-1);
  }
  {
#line 147
  c = find_config(serv->conf, 1 << 15, "_bind", 0);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! c) {
#line 149
      goto while_break;
    }
    {
#line 150
    listen_conn = (conn_t *)((void *)0);
#line 152
    addr = pr_netaddr_get_addr(serv->pool, (char const   *)*(c->argv + 0), (array_header **)((void *)0));
    }
#line 153
    if (! addr) {
      {
#line 154
      pr_log_pri(5, "notice: unable to determine IP address of \'%s\'", (char *)*(c->argv + 0));
#line 156
      c = find_config_next(c, c->next, 1 << 15, "_bind", 0);
      }
#line 157
      goto while_continue;
    }
#line 163
    if (SocketBindTight) {
#line 163
      if (serv->ServerPort) {
        {
#line 165
        listen_conn = pr_inet_create_connection(serv->pool, server_list, -1, addr,
                                                (int )serv->ServerPort, 0);
#line 168
        res = pr_ipbind_create(serv, addr);
        }
#line 168
        if (res < 0) {
          {
#line 168
          tmp = __errno_location();
#line 168
          tmp___0 = strerror(*tmp);
#line 168
          pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     168, serv->ServerAddress, tmp___0);
          }
        }
        {
#line 169
        res = pr_ipbind_open(addr, serv->ServerPort, listen_conn, (unsigned char)0,
                             (unsigned char)0, (unsigned char)1);
        }
#line 169
        if (res < 0) {
          {
#line 169
          tmp___1 = __errno_location();
#line 169
          tmp___2 = strerror(*tmp___1);
#line 169
          tmp___3 = pr_netaddr_get_ipstr(addr);
#line 169
          pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     169, tmp___3, tmp___2);
          }
        }
      } else {
#line 163
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 173
      res = pr_ipbind_create(serv, addr);
      }
#line 173
      if (res < 0) {
        {
#line 173
        tmp___4 = __errno_location();
#line 173
        tmp___5 = strerror(*tmp___4);
#line 173
        pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                   173, serv->ServerAddress, tmp___5);
        }
      }
      {
#line 174
      res = pr_ipbind_open(addr, serv->ServerPort, serv->listen, (unsigned char)0,
                           (unsigned char)0, (unsigned char)1);
      }
#line 174
      if (res < 0) {
        {
#line 174
        tmp___6 = __errno_location();
#line 174
        tmp___7 = strerror(*tmp___6);
#line 174
        tmp___8 = pr_netaddr_get_ipstr(addr);
#line 174
        pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                   174, tmp___8, tmp___7);
        }
      }
    }
    {
#line 177
    c = find_config_next(c, c->next, 1 << 15, "_bind", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (0);
}
}
#line 184 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_ipbind_close(pr_netaddr_t *addr , unsigned int port , unsigned char close_namebinds ) 
{ 
  int res ;
  register unsigned int i___0 ;
  pr_ipbind_t *ipbind ;
  unsigned char have_ipbind ;
  char const   *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  struct conn_struc *tmp___5 ;
  register unsigned int j ;
  pr_namebind_t **namebinds ;
  pr_namebind_t *nb ;
  int *tmp___6 ;
  char *tmp___7 ;
  pr_ipbind_t *ipbind___0 ;
  struct conn_struc *tmp___8 ;
  register unsigned int j___0 ;
  pr_namebind_t **namebinds___0 ;
  pr_namebind_t *nb___0 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 186
  res = 0;
#line 187
  i___0 = 0U;
#line 189
  if (addr) {
    {
#line 190
    ipbind = (pr_ipbind_t *)((void *)0);
#line 191
    have_ipbind = (unsigned char)0;
#line 193
    i___0 = ipbind_hash_addr(addr);
    }
#line 195
    if ((unsigned long )ipbind_table[i___0] == (unsigned long )((void *)0)) {
      {
#line 196
      tmp = pr_netaddr_get_ipstr(addr);
#line 196
      pr_log_pri(5, "notice: no ipbind found for %s:%d", tmp, port);
#line 198
      tmp___0 = __errno_location();
#line 198
      *tmp___0 = 2;
      }
#line 199
      return (-1);
    }
#line 202
    ipbind = ipbind_table[i___0];
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (! ipbind) {
#line 202
        goto while_break;
      }
      {
#line 203
      tmp___1 = pr_netaddr_cmp((pr_netaddr_t const   *)ipbind->ib_addr, (pr_netaddr_t const   *)addr);
      }
#line 203
      if (tmp___1 == 0) {
#line 203
        if (! ipbind->ib_port) {
#line 205
          have_ipbind = (unsigned char)1;
#line 206
          goto while_break;
        } else
#line 203
        if (ipbind->ib_port == port) {
#line 205
          have_ipbind = (unsigned char)1;
#line 206
          goto while_break;
        }
      }
#line 202
      ipbind = ipbind->ib_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 210
    if (! have_ipbind) {
      {
#line 211
      tmp___2 = pr_netaddr_get_ipstr(addr);
#line 211
      pr_log_pri(5, "notice: no ipbind found for %s:%d", tmp___2, port);
#line 213
      tmp___3 = __errno_location();
#line 213
      *tmp___3 = 2;
      }
#line 214
      return (-1);
    }
#line 218
    if (! ipbind->ib_isactive) {
      {
#line 219
      tmp___4 = __errno_location();
#line 219
      *tmp___4 = 1;
      }
#line 220
      return (-1);
    }
#line 232
    if (SocketBindTight) {
#line 232
      if ((unsigned long )ipbind->ib_listener != (unsigned long )((void *)0)) {
        {
#line 233
        pr_inet_close((ipbind->ib_server)->pool, ipbind->ib_listener);
#line 234
        tmp___5 = (struct conn_struc *)((void *)0);
#line 234
        (ipbind->ib_server)->listen = tmp___5;
#line 234
        ipbind->ib_listener = tmp___5;
        }
      }
    }
#line 243
    ipbind->ib_isactive = (unsigned char)0;
#line 245
    if (close_namebinds) {
#line 245
      if (ipbind->ib_namebinds) {
#line 246
        j = 0U;
#line 247
        namebinds = (pr_namebind_t **)((void *)0);
#line 249
        namebinds = (pr_namebind_t **)(ipbind->ib_namebinds)->elts;
#line 250
        j = 0U;
        {
#line 250
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 250
          if (! (j < (unsigned int )(ipbind->ib_namebinds)->nelts)) {
#line 250
            goto while_break___0;
          }
          {
#line 251
          nb = *(namebinds + j);
#line 253
          res = pr_namebind_close(nb->nb_name, (nb->nb_server)->addr, (nb->nb_server)->ServerPort);
          }
#line 253
          if (res < 0) {
            {
#line 253
            tmp___6 = __errno_location();
#line 253
            tmp___7 = strerror(*tmp___6);
#line 253
            pr_log_pri(5, "%s:%d: notice, unable to close namebind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                       254, nb->nb_name, tmp___7);
            }
          }
#line 250
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 264
    i___0 = 0U;
    {
#line 264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 264
      if (! (i___0 < 256U)) {
#line 264
        goto while_break___1;
      }
#line 265
      ipbind___0 = (pr_ipbind_t *)((void *)0);
#line 266
      ipbind___0 = ipbind_table[i___0];
      {
#line 266
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 266
        if (! ipbind___0) {
#line 266
          goto while_break___2;
        }
#line 268
        if (SocketBindTight) {
#line 268
          if ((unsigned long )ipbind___0->ib_listener != (unsigned long )((void *)0)) {
            {
#line 269
            pr_inet_close(main_server->pool, ipbind___0->ib_listener);
#line 270
            tmp___8 = (struct conn_struc *)((void *)0);
#line 270
            (ipbind___0->ib_server)->listen = tmp___8;
#line 270
            ipbind___0->ib_listener = tmp___8;
            }
          }
        }
#line 277
        ipbind___0->ib_isactive = (unsigned char)0;
#line 279
        if (close_namebinds) {
#line 279
          if (ipbind___0->ib_namebinds) {
#line 280
            j___0 = 0U;
#line 281
            namebinds___0 = (pr_namebind_t **)((void *)0);
#line 283
            namebinds___0 = (pr_namebind_t **)(ipbind___0->ib_namebinds)->elts;
#line 284
            j___0 = 0U;
            {
#line 284
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 284
              if (! (j___0 < (unsigned int )(ipbind___0->ib_namebinds)->nelts)) {
#line 284
                goto while_break___3;
              }
              {
#line 285
              nb___0 = *(namebinds___0 + j___0);
#line 287
              res = pr_namebind_close(nb___0->nb_name, (nb___0->nb_server)->addr,
                                      (nb___0->nb_server)->ServerPort);
              }
#line 287
              if (res < 0) {
                {
#line 287
                tmp___9 = __errno_location();
#line 287
                tmp___10 = strerror(*tmp___9);
#line 287
                pr_log_pri(5, "%s:%d: notice, unable to close namebind \'%s\': %s",
                           "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                           288, nb___0->nb_name, tmp___10);
                }
              }
#line 284
              j___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
#line 266
        ipbind___0 = ipbind___0->ib_next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 264
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 295
  return (0);
}
}
#line 299 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_ipbind_close_listeners(void) 
{ 
  conn_t **listeners ;
  register unsigned int i___0 ;
  conn_t *listener ;

  {
#line 301
  i___0 = 0U;
#line 303
  if (! listener_list) {
#line 305
    return (0);
  } else
#line 303
  if (listener_list->nelts == 0) {
#line 305
    return (0);
  }
#line 307
  listeners = (conn_t **)listener_list->elts;
#line 308
  i___0 = 0U;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i___0 < (unsigned int )listener_list->nelts)) {
#line 308
      goto while_break;
    }
    {
#line 309
    listener = *(listeners + i___0);
#line 311
    pr_signals_handle();
    }
#line 313
    if (listener->listen_fd != -1) {
      {
#line 314
      close(listener->listen_fd);
#line 315
      listener->listen_fd = -1;
      }
    }
#line 308
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (0);
}
}
#line 322 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_ipbind_create(server_rec *server , pr_netaddr_t *addr ) 
{ 
  int res ;
  pr_ipbind_t *ipbind ;
  config_rec *c ;
  server_rec *s ;
  register unsigned int i___0 ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 323
  res = 0;
#line 324
  ipbind = (pr_ipbind_t *)((void *)0);
#line 325
  c = (config_rec *)((void *)0);
#line 326
  s = (server_rec *)((void *)0);
#line 327
  i___0 = 0U;
#line 329
  if (! server) {
    {
#line 331
    tmp = __errno_location();
#line 331
    *tmp = 22;
    }
#line 332
    return (-1);
  } else
#line 329
  if (! addr) {
    {
#line 331
    tmp = __errno_location();
#line 331
    *tmp = 22;
    }
#line 332
    return (-1);
  }
  {
#line 335
  i___0 = ipbind_hash_addr(addr);
#line 338
  ipbind = ipbind_table[i___0];
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! ipbind) {
#line 338
      goto while_break;
    }
    {
#line 339
    tmp___2 = pr_netaddr_cmp((pr_netaddr_t const   *)ipbind->ib_addr, (pr_netaddr_t const   *)addr);
    }
#line 339
    if (tmp___2 == 0) {
#line 339
      if (ipbind->ib_port == server->ServerPort) {
        {
#line 343
        tmp___0 = pr_netaddr_get_ipstr(addr);
#line 343
        pr_log_pri(5, "notice: \'%s\' (%s:%u) already bound to \'%s\'", server->ServerName,
                   tmp___0, server->ServerPort, (ipbind->ib_server)->ServerName);
#line 347
        tmp___1 = __errno_location();
#line 347
        *tmp___1 = 98;
        }
#line 348
        return (-1);
      }
    }
#line 338
    ipbind = ipbind->ib_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  if (! binding_pool) {
    {
#line 353
    binding_pool = make_sub_pool(permanent_pool);
#line 354
    pr_pool_tag(binding_pool, "Bindings Pool");
    }
  }
  {
#line 357
  tmp___3 = pcalloc(server->pool, (int )sizeof(pr_ipbind_t ));
#line 357
  ipbind = (pr_ipbind_t *)tmp___3;
#line 358
  ipbind->ib_server = server;
#line 359
  ipbind->ib_addr = addr;
#line 360
  ipbind->ib_port = server->ServerPort;
#line 361
  ipbind->ib_namebinds = (array_header *)((void *)0);
#line 362
  ipbind->ib_isdefault = (unsigned char)0;
#line 363
  ipbind->ib_islocalhost = (unsigned char)0;
#line 364
  ipbind->ib_isactive = (unsigned char)0;
  }
#line 367
  if (ipbind_table[i___0]) {
#line 368
    ipbind->ib_next = ipbind_table[i___0];
  }
  {
#line 370
  ipbind_table[i___0] = ipbind;
#line 373
  c = find_config(server->conf, 1 << 8, (char const   *)((void *)0), 0);
  }
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 375
    if (! c) {
#line 375
      goto while_break___0;
    }
    {
#line 376
    s = (server_rec *)*(c->argv + 0);
#line 377
    res = pr_namebind_create(s, (char const   *)c->name, server->addr, server->ServerPort);
    }
#line 377
    if (res < 0) {
      {
#line 377
      tmp___4 = __errno_location();
#line 377
      tmp___5 = strerror(*tmp___4);
#line 377
      pr_log_pri(5, "%s:%d: notice: unable to create namebind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 377, c->name, tmp___5);
      }
    }
    {
#line 378
    c = find_config_next(c, c->next, 1 << 8, (char const   *)((void *)0), 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 381
  return (0);
}
}
#line 384 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
pr_ipbind_t *pr_ipbind_find(pr_netaddr_t *addr , unsigned int port , unsigned char skip_inactive ) 
{ 
  pr_ipbind_t *ipbind ;
  register unsigned int i___0 ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 386
  ipbind = (pr_ipbind_t *)((void *)0);
#line 387
  tmp = ipbind_hash_addr(addr);
#line 387
  i___0 = tmp;
#line 389
  ipbind = ipbind_table[i___0];
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! ipbind) {
#line 389
      goto while_break;
    }
#line 391
    if (skip_inactive) {
#line 391
      if (! ipbind->ib_isactive) {
#line 393
        goto __Cont;
      }
    }
    {
#line 395
    tmp___0 = pr_netaddr_cmp((pr_netaddr_t const   *)ipbind->ib_addr, (pr_netaddr_t const   *)addr);
    }
#line 395
    if (tmp___0 == 0) {
#line 395
      if (! ipbind->ib_port) {
#line 397
        return (ipbind);
      } else
#line 395
      if (ipbind->ib_port == port) {
#line 397
        return (ipbind);
      }
    }
    __Cont: /* CIL Label */ 
#line 389
    ipbind = ipbind->ib_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return ((pr_ipbind_t *)((void *)0));
}
}
#line 404 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static unsigned int i  =    0U;
#line 403 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
pr_ipbind_t *pr_ipbind_get(pr_ipbind_t *prev ) 
{ 


  {
#line 406
  if (prev) {
#line 409
    if (prev->ib_next) {
#line 410
      return (prev->ib_next);
    }
#line 415
    if (i == 256U) {
#line 416
      return ((pr_ipbind_t *)((void *)0));
    }
#line 422
    i ++;
  } else {
#line 426
    i = 0U;
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < 256U)) {
#line 429
      goto while_break;
    }
#line 430
    if (ipbind_table[i]) {
#line 431
      return (ipbind_table[i]);
    }
#line 429
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return ((pr_ipbind_t *)((void *)0));
}
}
#line 437 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
server_rec *pr_ipbind_get_server(pr_netaddr_t *addr , unsigned int port ) 
{ 
  pr_ipbind_t *ipbind ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 438
  ipbind = (pr_ipbind_t *)((void *)0);
#line 443
  ipbind = pr_ipbind_find(addr, port, (unsigned char)1);
  }
#line 444
  if ((unsigned long )ipbind != (unsigned long )((void *)0)) {
#line 445
    return (ipbind->ib_server);
  }
#line 448
  if (ipbind_default_server) {
#line 448
    if (ipbind_default_server->ib_isactive) {
      {
#line 450
      tmp = pr_netaddr_get_ipstr(addr);
#line 450
      pr_log_debug(7, "no matching vhost found for %s#%u, using DefaultServer \'%s\'",
                   tmp, port, (ipbind_default_server->ib_server)->ServerName);
      }
#line 453
      return (ipbind_default_server->ib_server);
    }
  }
#line 459
  if (ipbind_localhost_server) {
    {
#line 459
    tmp___0 = pr_netaddr_is_loopback((pr_netaddr_t const   *)addr);
    }
#line 459
    if (tmp___0) {
#line 461
      return (ipbind_localhost_server->ib_server);
    }
  }
#line 463
  return ((server_rec *)((void *)0));
}
}
#line 466 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_ipbind_listen(fd_set *readfds ) 
{ 
  int maxfd ;
  register unsigned int i___0 ;
  unsigned int __i ;
  fd_set *__arr ;
  pr_ipbind_t *ipbind ;
  void *tmp ;
  char *__cil_tmp8 ;

  {
#line 467
  maxfd = 0;
#line 468
  i___0 = 0U;
#line 471
  if (! readfds) {
#line 472
    return (-1);
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    __arr = readfds;
#line 474
    __i = 0U;
    {
#line 474
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 474
      if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 474
        goto while_break___0;
      }
#line 474
      __arr->fds_bits[__i] = (__fd_mask )0;
#line 474
      __i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  if (! binding_pool) {
    {
#line 477
    binding_pool = make_sub_pool(permanent_pool);
#line 478
    pr_pool_tag(binding_pool, "Bindings Pool");
    }
  }
#line 482
  if (! listener_list) {
    {
#line 483
    listener_list = make_array(binding_pool, 1U, (size_t )sizeof(conn_t *));
    }
  } else {
#line 489
    listener_list->nelts = 0;
  }
#line 494
  i___0 = 0U;
  {
#line 494
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 494
    if (! (i___0 < 256U)) {
#line 494
      goto while_break___1;
    }
#line 495
    ipbind = (pr_ipbind_t *)((void *)0);
#line 497
    ipbind = ipbind_table[i___0];
    {
#line 497
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 497
      if (! ipbind) {
#line 497
        goto while_break___2;
      }
#line 500
      if (SocketBindTight) {
#line 500
        if (! ipbind->ib_isactive) {
#line 502
          goto __Cont;
        }
      }
#line 504
      if (ipbind->ib_listener) {
#line 506
        if ((ipbind->ib_listener)->mode == 0) {
          {
#line 507
          pr_inet_listen((ipbind->ib_listener)->pool, ipbind->ib_listener, tcpBackLog);
          }
        }
#line 510
        if ((ipbind->ib_listener)->mode == 3) {
          {
#line 511
          pr_inet_resetlisten((ipbind->ib_listener)->pool, ipbind->ib_listener);
          }
        }
#line 513
        if ((ipbind->ib_listener)->mode == 1) {
#line 514
          readfds->fds_bits[(unsigned long )(ipbind->ib_listener)->listen_fd / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )(ipbind->ib_listener)->listen_fd % (8UL * sizeof(__fd_mask ));
#line 515
          if ((ipbind->ib_listener)->listen_fd > maxfd) {
#line 516
            maxfd = (ipbind->ib_listener)->listen_fd;
          }
          {
#line 519
          tmp = push_array(listener_list);
#line 519
          *((conn_t **)tmp) = ipbind->ib_listener;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 497
      ipbind = ipbind->ib_next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 494
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 525
  return (maxfd);
}
}
#line 528 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_ipbind_open(pr_netaddr_t *addr , unsigned int port , conn_t *listen_conn ,
                   unsigned char isdefault , unsigned char islocalhost , unsigned char open_namebinds ) 
{ 
  int res ;
  pr_ipbind_t *ipbind ;
  int *tmp ;
  int *tmp___0 ;
  struct conn_struc *tmp___1 ;
  register unsigned int i___0 ;
  pr_namebind_t **namebinds ;
  pr_namebind_t *nb ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 531
  res = 0;
#line 532
  ipbind = (pr_ipbind_t *)((void *)0);
#line 534
  if (! addr) {
    {
#line 535
    tmp = __errno_location();
#line 535
    *tmp = 22;
    }
#line 536
    return (-1);
  }
  {
#line 540
  ipbind = pr_ipbind_find(addr, port, (unsigned char)0);
  }
#line 541
  if ((unsigned long )ipbind == (unsigned long )((void *)0)) {
    {
#line 542
    tmp___0 = __errno_location();
#line 542
    *tmp___0 = 2;
    }
#line 543
    return (-1);
  }
#line 546
  if (listen_conn) {
#line 547
    listen_conn->next = (struct conn_struc *)((void *)0);
  }
#line 549
  tmp___1 = listen_conn;
#line 549
  (ipbind->ib_server)->listen = tmp___1;
#line 549
  ipbind->ib_listener = tmp___1;
#line 550
  ipbind->ib_listener = listen_conn;
#line 551
  ipbind->ib_isdefault = isdefault;
#line 552
  ipbind->ib_islocalhost = islocalhost;
#line 563
  if (isdefault) {
#line 564
    ipbind_default_server = ipbind;
  }
#line 566
  if (islocalhost) {
#line 567
    ipbind_localhost_server = ipbind;
  }
#line 570
  if (open_namebinds) {
#line 570
    if (ipbind->ib_namebinds) {
#line 572
      i___0 = 0U;
#line 573
      namebinds = (pr_namebind_t **)((void *)0);
#line 579
      namebinds = (pr_namebind_t **)(ipbind->ib_namebinds)->elts;
#line 580
      i___0 = 0U;
      {
#line 580
      while (1) {
        while_continue: /* CIL Label */ ;
#line 580
        if (! (i___0 < (unsigned int )(ipbind->ib_namebinds)->nelts)) {
#line 580
          goto while_break;
        }
        {
#line 581
        nb = *(namebinds + i___0);
#line 583
        res = pr_namebind_open(nb->nb_name, (nb->nb_server)->addr, (nb->nb_server)->ServerPort);
        }
#line 583
        if (res < 0) {
          {
#line 583
          tmp___2 = __errno_location();
#line 583
          tmp___3 = strerror(*tmp___2);
#line 583
          pr_log_pri(5, "%s:%d: notice: unable to open namebind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     584, nb->nb_name, tmp___3);
          }
        }
#line 580
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 589
  ipbind->ib_isactive = (unsigned char)1;
#line 591
  return (0);
}
}
#line 594 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_namebind_close(char const   *name , pr_netaddr_t *addr , unsigned int port ) 
{ 
  pr_namebind_t *namebind ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 596
  namebind = (pr_namebind_t *)((void *)0);
#line 598
  if (! name) {
    {
#line 600
    tmp = __errno_location();
#line 600
    *tmp = 22;
    }
#line 601
    return (-1);
  } else
#line 598
  if (! addr) {
    {
#line 600
    tmp = __errno_location();
#line 600
    *tmp = 22;
    }
#line 601
    return (-1);
  }
  {
#line 604
  namebind = pr_namebind_find(name, addr, port, (unsigned char)0);
  }
#line 605
  if ((unsigned long )namebind == (unsigned long )((void *)0)) {
    {
#line 606
    tmp___0 = __errno_location();
#line 606
    *tmp___0 = 2;
    }
#line 607
    return (-1);
  }
#line 610
  namebind->nb_isactive = (unsigned char)0;
#line 611
  return (0);
}
}
#line 614 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_namebind_create(server_rec *server , char const   *name , pr_netaddr_t *addr ,
                       unsigned int port ) 
{ 
  pr_ipbind_t *ipbind ;
  pr_namebind_t *namebind ;
  pr_namebind_t **namebinds ;
  int *tmp ;
  int *tmp___0 ;
  register unsigned int i___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;

  {
#line 616
  ipbind = (pr_ipbind_t *)((void *)0);
#line 617
  namebind = (pr_namebind_t *)((void *)0);
#line 617
  namebinds = (pr_namebind_t **)((void *)0);
#line 619
  if (! server) {
    {
#line 621
    tmp = __errno_location();
#line 621
    *tmp = 22;
    }
#line 622
    return (-1);
  } else
#line 619
  if (! name) {
    {
#line 621
    tmp = __errno_location();
#line 621
    *tmp = 22;
    }
#line 622
    return (-1);
  }
  {
#line 626
  ipbind = pr_ipbind_find(addr, port, (unsigned char)0);
  }
#line 627
  if ((unsigned long )ipbind == (unsigned long )((void *)0)) {
    {
#line 628
    tmp___0 = __errno_location();
#line 628
    *tmp___0 = 2;
    }
#line 629
    return (-1);
  }
#line 633
  if (! ipbind->ib_namebinds) {
    {
#line 634
    ipbind->ib_namebinds = make_array(binding_pool, 0U, (size_t )sizeof(pr_namebind_t *));
    }
  } else {
#line 637
    i___0 = 0U;
#line 638
    namebinds = (pr_namebind_t **)(ipbind->ib_namebinds)->elts;
#line 641
    i___0 = 0U;
    {
#line 641
    while (1) {
      while_continue: /* CIL Label */ ;
#line 641
      if (! (i___0 < (unsigned int )(ipbind->ib_namebinds)->nelts)) {
#line 641
        goto while_break;
      }
#line 642
      namebind = *(namebinds + i___0);
#line 643
      if (namebind) {
#line 643
        if (namebind->nb_name) {
          {
#line 643
          tmp___2 = strcmp(namebind->nb_name, name);
          }
#line 643
          if (! tmp___2) {
            {
#line 644
            tmp___1 = __errno_location();
#line 644
            *tmp___1 = 17;
            }
#line 645
            return (-1);
          }
        }
      }
#line 641
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 650
  tmp___3 = pcalloc(server->pool, (int )sizeof(pr_namebind_t ));
#line 650
  namebind = (pr_namebind_t *)tmp___3;
#line 651
  namebind->nb_name = name;
#line 652
  namebind->nb_server = server;
#line 653
  namebind->nb_isactive = (unsigned char)0;
  }
#line 656
  if ((namebind->nb_server)->ServerAdmin) {
#line 656
    (namebind->nb_server)->ServerAdmin = (namebind->nb_server)->ServerAdmin;
  } else {
#line 656
    if (server->ServerAdmin) {
#line 656
      tmp___4 = server->ServerAdmin;
    } else {
#line 656
      tmp___4 = main_server->ServerAdmin;
    }
#line 656
    (namebind->nb_server)->ServerAdmin = tmp___4;
  }
#line 664
  if ((namebind->nb_server)->ServerName) {
#line 664
    (namebind->nb_server)->ServerName = (namebind->nb_server)->ServerName;
  } else {
#line 664
    (namebind->nb_server)->ServerName = (char const   *)((char *)name);
  }
#line 666
  if (server->ServerAddress) {
#line 666
    (namebind->nb_server)->ServerAddress = server->ServerAddress;
  } else {
#line 666
    (namebind->nb_server)->ServerAddress = main_server->ServerAddress;
  }
#line 668
  if (server->ServerFQDN) {
#line 668
    (namebind->nb_server)->ServerFQDN = server->ServerFQDN;
  } else {
#line 668
    (namebind->nb_server)->ServerFQDN = main_server->ServerFQDN;
  }
#line 671
  if (server->tcp_mss_len) {
#line 671
    (namebind->nb_server)->tcp_mss_len = server->tcp_mss_len;
  } else {
#line 671
    (namebind->nb_server)->tcp_mss_len = main_server->tcp_mss_len;
  }
#line 673
  if (server->tcp_rcvbuf_len) {
#line 673
    (namebind->nb_server)->tcp_rcvbuf_len = server->tcp_rcvbuf_len;
  } else {
#line 673
    (namebind->nb_server)->tcp_rcvbuf_len = main_server->tcp_rcvbuf_len;
  }
#line 675
  if (server->tcp_rcvbuf_override) {
#line 675
    (namebind->nb_server)->tcp_rcvbuf_override = (unsigned char)1;
  } else {
#line 675
    (namebind->nb_server)->tcp_rcvbuf_override = main_server->tcp_rcvbuf_override;
  }
#line 677
  if (server->tcp_sndbuf_len) {
#line 677
    (namebind->nb_server)->tcp_sndbuf_len = server->tcp_sndbuf_len;
  } else {
#line 677
    (namebind->nb_server)->tcp_sndbuf_len = main_server->tcp_sndbuf_len;
  }
#line 679
  if (server->tcp_sndbuf_override) {
#line 679
    (namebind->nb_server)->tcp_sndbuf_override = (unsigned char)1;
  } else {
#line 679
    (namebind->nb_server)->tcp_sndbuf_override = main_server->tcp_sndbuf_override;
  }
#line 682
  if (server->addr) {
#line 682
    (namebind->nb_server)->addr = server->addr;
  } else {
#line 682
    (namebind->nb_server)->addr = main_server->addr;
  }
#line 684
  if (server->ServerPort) {
#line 684
    (namebind->nb_server)->ServerPort = server->ServerPort;
  } else {
#line 684
    (namebind->nb_server)->ServerPort = main_server->ServerPort;
  }
#line 686
  if (server->listen) {
#line 686
    namebind->nb_listener = server->listen;
  } else {
#line 686
    namebind->nb_listener = main_server->listen;
  }
  {
#line 689
  tmp___5 = push_array(ipbind->ib_namebinds);
#line 689
  *((pr_namebind_t **)tmp___5) = namebind;
  }
#line 690
  return (0);
}
}
#line 693 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
pr_namebind_t *pr_namebind_find(char const   *name , pr_netaddr_t *addr , unsigned int port ,
                                unsigned char skip_inactive ) 
{ 
  pr_ipbind_t *ipbind ;
  pr_namebind_t *namebind ;
  int *tmp ;
  int *tmp___0 ;
  register unsigned int i___0 ;
  pr_namebind_t **namebinds ;
  int tmp___1 ;

  {
#line 695
  ipbind = (pr_ipbind_t *)((void *)0);
#line 696
  namebind = (pr_namebind_t *)((void *)0);
#line 698
  if (! name) {
    {
#line 700
    tmp = __errno_location();
#line 700
    *tmp = 22;
    }
#line 701
    return ((pr_namebind_t *)((void *)0));
  } else
#line 698
  if (! addr) {
    {
#line 700
    tmp = __errno_location();
#line 700
    *tmp = 22;
    }
#line 701
    return ((pr_namebind_t *)((void *)0));
  }
  {
#line 705
  ipbind = pr_ipbind_find(addr, port, skip_inactive);
  }
#line 706
  if ((unsigned long )ipbind == (unsigned long )((void *)0)) {
    {
#line 707
    tmp___0 = __errno_location();
#line 707
    *tmp___0 = 2;
    }
#line 708
    return ((pr_namebind_t *)((void *)0));
  }
#line 711
  if (! ipbind->ib_namebinds) {
#line 712
    return ((pr_namebind_t *)((void *)0));
  } else {
#line 715
    i___0 = 0U;
#line 716
    namebinds = (pr_namebind_t **)(ipbind->ib_namebinds)->elts;
#line 718
    i___0 = 0U;
    {
#line 718
    while (1) {
      while_continue: /* CIL Label */ ;
#line 718
      if (! (i___0 < (unsigned int )(ipbind->ib_namebinds)->nelts)) {
#line 718
        goto while_break;
      }
#line 719
      namebind = *(namebinds + i___0);
#line 722
      if (skip_inactive) {
#line 722
        if (namebind) {
#line 722
          if (! namebind->nb_isactive) {
#line 725
            goto __Cont;
          }
        }
      }
#line 733
      if (namebind) {
#line 733
        if (namebind->nb_name) {
          {
#line 733
          tmp___1 = strcmp(namebind->nb_name, name);
          }
#line 733
          if (tmp___1 == 0) {
#line 736
            return (namebind);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 718
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 740
  return ((pr_namebind_t *)((void *)0));
}
}
#line 743 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
server_rec *pr_namebind_get_server(char const   *name , pr_netaddr_t *addr , unsigned int port ) 
{ 
  pr_namebind_t *namebind ;

  {
  {
#line 745
  namebind = (pr_namebind_t *)((void *)0);
#line 748
  namebind = pr_namebind_find(name, addr, port, (unsigned char)1);
  }
#line 749
  if ((unsigned long )namebind == (unsigned long )((void *)0)) {
#line 750
    return ((server_rec *)((void *)0));
  }
#line 752
  return (namebind->nb_server);
}
}
#line 755 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
int pr_namebind_open(char const   *name , pr_netaddr_t *addr , unsigned int port ) 
{ 
  pr_namebind_t *namebind ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 756
  namebind = (pr_namebind_t *)((void *)0);
#line 758
  if (! name) {
    {
#line 760
    tmp = __errno_location();
#line 760
    *tmp = 22;
    }
#line 761
    return (-1);
  } else
#line 758
  if (! addr) {
    {
#line 760
    tmp = __errno_location();
#line 760
    *tmp = 22;
    }
#line 761
    return (-1);
  }
  {
#line 764
  namebind = pr_namebind_find(name, addr, port, (unsigned char)0);
  }
#line 765
  if ((unsigned long )namebind == (unsigned long )((void *)0)) {
    {
#line 766
    tmp___0 = __errno_location();
#line 766
    *tmp___0 = 2;
    }
#line 767
    return (-1);
  }
#line 770
  namebind->nb_isactive = (unsigned char)1;
#line 771
  return (0);
}
}
#line 774 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
void free_bindings(void) 
{ 


  {
#line 775
  if (binding_pool) {
    {
#line 776
    destroy_pool(binding_pool);
#line 777
    binding_pool = (pool *)((void *)0);
#line 778
    listener_list = (array_header *)((void *)0);
    }
  }
  {
#line 781
  memset((void *)(ipbind_table), 0, (size_t )sizeof(ipbind_table));
  }
#line 782
  return;
}
}
#line 784 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static void init_inetd_bindings(void) 
{ 
  int res ;
  server_rec *serv ;
  unsigned char *default_server ;
  unsigned char is_default ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 785
  res = 0;
#line 786
  serv = (server_rec *)((void *)0);
#line 787
  default_server = (unsigned char *)((void *)0);
#line 787
  is_default = (unsigned char)0;
#line 789
  main_server->listen = pr_inet_create_connection(main_server->pool, server_list,
                                                  0, (pr_netaddr_t *)((void *)0),
                                                  0, 0);
#line 793
  tmp___2 = pr_inet_get_conn_info(main_server->listen, 0);
  }
#line 793
  if (tmp___2 == -1) {
    {
#line 794
    tmp = __errno_location();
#line 794
    tmp___0 = strerror(*tmp);
#line 794
    pr_log_pri(3, "fatal: %s", tmp___0);
#line 796
    tmp___1 = __errno_location();
    }
#line 796
    if (*tmp___1 == 88) {
      {
#line 797
      pr_log_pri(3, "(Running from command line? Use `ServerType standalone\' in config file!)");
      }
    }
    {
#line 799
    exit(1);
    }
  }
  {
#line 802
  tmp___3 = get_param_ptr(main_server->conf, "DefaultServer", 0);
#line 802
  default_server = (unsigned char *)tmp___3;
  }
#line 803
  if ((unsigned long )default_server != (unsigned long )((void *)0)) {
#line 803
    if ((int )*default_server == 1) {
#line 805
      is_default = (unsigned char)1;
    }
  }
  {
#line 807
  res = pr_ipbind_create(main_server, main_server->addr);
  }
#line 807
  if (res < 0) {
    {
#line 807
    tmp___4 = __errno_location();
#line 807
    tmp___5 = strerror(*tmp___4);
#line 807
    pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
               807, main_server->ServerAddress, tmp___5);
    }
  }
  {
#line 808
  res = pr_ipbind_open(main_server->addr, main_server->ServerPort, main_server->listen,
                       is_default, (unsigned char)1, (unsigned char)1);
  }
#line 808
  if (res < 0) {
    {
#line 808
    tmp___6 = __errno_location();
#line 808
    tmp___7 = strerror(*tmp___6);
#line 808
    tmp___8 = pr_netaddr_get_ipstr(main_server->addr);
#line 808
    pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
               809, tmp___8, tmp___7);
    }
  }
  {
#line 810
  res = pr_ipbind_add_binds(main_server);
  }
#line 810
  if (res < 0) {
    {
#line 810
    tmp___9 = __errno_location();
#line 810
    tmp___10 = strerror(*tmp___9);
#line 810
    pr_log_pri(5, "%s:%d: notice: unable to add binds to ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
               810, main_server->ServerAddress, tmp___10);
    }
  }
#line 813
  serv = main_server->next;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! serv) {
#line 813
      goto while_break;
    }
    {
#line 821
    serv->listen = main_server->listen;
#line 822
    register_cleanup((serv->listen)->pool, (void *)(& serv->listen), & server_cleanup_cb,
                     & server_cleanup_cb);
#line 825
    is_default = (unsigned char)0;
#line 826
    tmp___11 = get_param_ptr(serv->conf, "DefaultServer", 0);
#line 826
    default_server = (unsigned char *)tmp___11;
    }
#line 827
    if ((unsigned long )default_server != (unsigned long )((void *)0)) {
#line 827
      if ((int )*default_server == 1) {
#line 829
        is_default = (unsigned char)1;
      }
    }
    {
#line 831
    res = pr_ipbind_create(serv, serv->addr);
    }
#line 831
    if (res < 0) {
      {
#line 831
      tmp___12 = __errno_location();
#line 831
      tmp___13 = strerror(*tmp___12);
#line 831
      pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 831, serv->ServerAddress, tmp___13);
      }
    }
    {
#line 832
    res = pr_ipbind_open(serv->addr, serv->ServerPort, serv->listen, is_default, (unsigned char)0,
                         (unsigned char)1);
    }
#line 832
    if (res < 0) {
      {
#line 832
      tmp___14 = __errno_location();
#line 832
      tmp___15 = strerror(*tmp___14);
#line 832
      tmp___16 = pr_netaddr_get_ipstr(serv->addr);
#line 832
      pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 833, tmp___16, tmp___15);
      }
    }
    {
#line 834
    res = pr_ipbind_add_binds(serv);
    }
#line 834
    if (res < 0) {
      {
#line 834
      tmp___17 = __errno_location();
#line 834
      tmp___18 = strerror(*tmp___17);
#line 834
      pr_log_pri(5, "%s:%d: notice: unable to add binds to ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 834, serv->ServerAddress, tmp___18);
      }
    }
#line 813
    serv = serv->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 837
  return;
}
}
#line 840 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
static void init_standalone_bindings(void) 
{ 
  int res ;
  server_rec *serv ;
  unsigned char *default_server ;
  unsigned char is_default ;
  int tmp ;
  unsigned char tmp___0 ;
  pr_netaddr_t *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  unsigned char tmp___12 ;
  pr_netaddr_t *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 841
  res = 0;
#line 842
  serv = (server_rec *)((void *)0);
#line 843
  default_server = (unsigned char *)((void *)0);
#line 843
  is_default = (unsigned char)0;
#line 848
  if (main_server->ServerPort) {
#line 854
    if (! SocketBindTight) {
      {
#line 856
      tmp___0 = pr_netaddr_use_ipv6();
      }
#line 856
      if (tmp___0) {
        {
#line 857
        pr_inet_set_default_family((pool *)((void *)0), 10);
        }
      } else {
        {
#line 860
        tmp = pr_netaddr_get_family((pr_netaddr_t const   *)main_server->addr);
#line 860
        pr_inet_set_default_family((pool *)((void *)0), tmp);
        }
      }
    }
#line 869
    if (SocketBindTight) {
#line 869
      tmp___1 = main_server->addr;
    } else {
#line 869
      tmp___1 = (pr_netaddr_t *)((void *)0);
    }
    {
#line 869
    main_server->listen = pr_inet_create_connection(main_server->pool, server_list,
                                                    -1, tmp___1, (int )main_server->ServerPort,
                                                    0);
    }
  } else {
#line 875
    main_server->listen = (struct conn_struc *)((void *)0);
  }
  {
#line 877
  tmp___2 = get_param_ptr(main_server->conf, "DefaultServer", 0);
#line 877
  default_server = (unsigned char *)tmp___2;
  }
#line 878
  if ((unsigned long )default_server != (unsigned long )((void *)0)) {
#line 878
    if ((int )*default_server == 1) {
#line 880
      is_default = (unsigned char)1;
    }
  }
#line 882
  if (main_server->ServerPort) {
#line 882
    goto _L;
  } else
#line 882
  if (is_default) {
    _L: /* CIL Label */ 
    {
#line 884
    res = pr_ipbind_create(main_server, main_server->addr);
    }
#line 884
    if (res < 0) {
      {
#line 884
      tmp___3 = __errno_location();
#line 884
      tmp___4 = strerror(*tmp___3);
#line 884
      pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 884, main_server->ServerAddress, tmp___4);
      }
    }
    {
#line 885
    res = pr_ipbind_open(main_server->addr, main_server->ServerPort, main_server->listen,
                         is_default, (unsigned char)1, (unsigned char)1);
    }
#line 885
    if (res < 0) {
      {
#line 885
      tmp___5 = __errno_location();
#line 885
      tmp___6 = strerror(*tmp___5);
#line 885
      tmp___7 = pr_netaddr_get_ipstr(main_server->addr);
#line 885
      pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 886, tmp___7, tmp___6);
      }
    }
    {
#line 887
    res = pr_ipbind_add_binds(main_server);
    }
#line 887
    if (res < 0) {
      {
#line 887
      tmp___8 = __errno_location();
#line 887
      tmp___9 = strerror(*tmp___8);
#line 887
      pr_log_pri(5, "%s:%d: notice: unable to add binds to ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                 887, main_server->ServerAddress, tmp___9);
      }
    }
  }
#line 890
  serv = main_server->next;
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (! serv) {
#line 890
      goto while_break;
    }
#line 891
    if (serv->ServerPort != main_server->ServerPort) {
#line 891
      goto _L___0;
    } else
#line 891
    if (SocketBindTight) {
#line 891
      goto _L___0;
    } else
#line 891
    if (! main_server->listen) {
      _L___0: /* CIL Label */ 
      {
#line 893
      is_default = (unsigned char)0;
#line 895
      tmp___10 = get_param_ptr(serv->conf, "DefaultServer", 0);
#line 895
      default_server = (unsigned char *)tmp___10;
      }
#line 896
      if ((unsigned long )default_server != (unsigned long )((void *)0)) {
#line 896
        if ((int )*default_server == 1) {
#line 898
          is_default = (unsigned char)1;
        }
      }
#line 900
      if (serv->ServerPort) {
#line 901
        if (! SocketBindTight) {
          {
#line 903
          tmp___12 = pr_netaddr_use_ipv6();
          }
#line 903
          if (tmp___12) {
            {
#line 904
            pr_inet_set_default_family((pool *)((void *)0), 10);
            }
          } else {
            {
#line 907
            tmp___11 = pr_netaddr_get_family((pr_netaddr_t const   *)serv->addr);
#line 907
            pr_inet_set_default_family((pool *)((void *)0), tmp___11);
            }
          }
        }
#line 914
        if (SocketBindTight) {
#line 914
          tmp___13 = serv->addr;
        } else {
#line 914
          tmp___13 = (pr_netaddr_t *)((void *)0);
        }
        {
#line 914
        serv->listen = pr_inet_create_connection(serv->pool, server_list, -1, tmp___13,
                                                 (int )serv->ServerPort, 0);
#line 917
        res = pr_ipbind_create(serv, serv->addr);
        }
#line 917
        if (res < 0) {
          {
#line 917
          tmp___14 = __errno_location();
#line 917
          tmp___15 = strerror(*tmp___14);
#line 917
          pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     917, serv->ServerAddress, tmp___15);
          }
        }
        {
#line 918
        res = pr_ipbind_open(serv->addr, serv->ServerPort, serv->listen, is_default,
                             (unsigned char)0, (unsigned char)1);
        }
#line 918
        if (res < 0) {
          {
#line 918
          tmp___16 = __errno_location();
#line 918
          tmp___17 = strerror(*tmp___16);
#line 918
          tmp___18 = pr_netaddr_get_ipstr(serv->addr);
#line 918
          pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     919, tmp___18, tmp___17);
          }
        }
        {
#line 920
        res = pr_ipbind_add_binds(serv);
        }
#line 920
        if (res < 0) {
          {
#line 920
          tmp___19 = __errno_location();
#line 920
          tmp___20 = strerror(*tmp___19);
#line 920
          pr_log_pri(5, "%s:%d: notice: unable to add binds to ipbind \'%s\': %s",
                     "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c", 920,
                     serv->ServerAddress, tmp___20);
          }
        }
      } else
#line 922
      if (is_default) {
        {
#line 923
        serv->listen = (struct conn_struc *)((void *)0);
#line 925
        res = pr_ipbind_create(serv, serv->addr);
        }
#line 925
        if (res < 0) {
          {
#line 925
          tmp___21 = __errno_location();
#line 925
          tmp___22 = strerror(*tmp___21);
#line 925
          pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     925, serv->ServerAddress, tmp___22);
          }
        }
        {
#line 926
        res = pr_ipbind_open(serv->addr, serv->ServerPort, serv->listen, is_default,
                             (unsigned char)0, (unsigned char)1);
        }
#line 926
        if (res < 0) {
          {
#line 926
          tmp___23 = __errno_location();
#line 926
          tmp___24 = strerror(*tmp___23);
#line 926
          tmp___25 = pr_netaddr_get_ipstr(serv->addr);
#line 926
          pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                     927, tmp___25, tmp___24);
          }
        }
        {
#line 928
        res = pr_ipbind_add_binds(serv);
        }
#line 928
        if (res < 0) {
          {
#line 928
          tmp___26 = __errno_location();
#line 928
          tmp___27 = strerror(*tmp___26);
#line 928
          pr_log_pri(5, "%s:%d: notice: unable to add binds to ipbind \'%s\': %s",
                     "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c", 928,
                     serv->ServerAddress, tmp___27);
          }
        }
      } else {
#line 931
        serv->listen = (struct conn_struc *)((void *)0);
      }
    } else {
      {
#line 941
      is_default = (unsigned char)0;
#line 942
      tmp___28 = get_param_ptr(serv->conf, "DefaultServer", 0);
#line 942
      default_server = (unsigned char *)tmp___28;
      }
#line 943
      if ((unsigned long )default_server != (unsigned long )((void *)0)) {
#line 943
        if ((int )*default_server == 1) {
#line 945
          is_default = (unsigned char)1;
        }
      }
      {
#line 947
      serv->listen = main_server->listen;
#line 948
      register_cleanup((serv->listen)->pool, (void *)(& serv->listen), & server_cleanup_cb,
                       & server_cleanup_cb);
#line 951
      res = pr_ipbind_create(serv, serv->addr);
      }
#line 951
      if (res < 0) {
        {
#line 951
        tmp___29 = __errno_location();
#line 951
        tmp___30 = strerror(*tmp___29);
#line 951
        pr_log_pri(5, "%s:%d: notice: unable to create ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                   951, serv->ServerAddress, tmp___30);
        }
      }
      {
#line 952
      res = pr_ipbind_open(serv->addr, serv->ServerPort, (conn_t *)((void *)0), is_default,
                           (unsigned char)0, (unsigned char)1);
      }
#line 952
      if (res < 0) {
        {
#line 952
        tmp___31 = __errno_location();
#line 952
        tmp___32 = strerror(*tmp___31);
#line 952
        tmp___33 = pr_netaddr_get_ipstr(serv->addr);
#line 952
        pr_log_pri(5, "%s:%d: notice: unable to open ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                   953, tmp___33, tmp___32);
        }
      }
      {
#line 954
      res = pr_ipbind_add_binds(serv);
      }
#line 954
      if (res < 0) {
        {
#line 954
        tmp___34 = __errno_location();
#line 954
        tmp___35 = strerror(*tmp___34);
#line 954
        pr_log_pri(5, "%s:%d: notice: unable to add binds to ipbind \'%s\': %s", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c",
                   954, serv->ServerAddress, tmp___35);
        }
      }
    }
#line 890
    serv = serv->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  return;
}
}
#line 962 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/bindings.c"
void init_bindings(void) 
{ 
  int sock ;

  {
  {
#line 968
  sock = socket(10, 1, 6);
  }
#line 969
  if (sock < 0) {
    {
#line 970
    pr_netaddr_disable_ipv6();
    }
  } else {
    {
#line 973
    close(sock);
    }
  }
#line 977
  if ((int )ServerType == 0) {
    {
#line 978
    init_inetd_bindings();
    }
  } else
#line 980
  if ((int )ServerType == 1) {
    {
#line 981
    init_standalone_bindings();
    }
  }
#line 983
  return;
}
}
#line 34 "../include/xferlog.h"
void xferlog_close(void) ;
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/xferlog.c"
static int xferlogfd  =    -1;
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/xferlog.c"
void xferlog_close(void) 
{ 


  {
#line 36
  if (xferlogfd != -1) {
    {
#line 37
    close(xferlogfd);
    }
  }
#line 39
  xferlogfd = -1;
#line 40
  return;
}
}
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/xferlog.c"
int xferlog_open(char const   *path ) 
{ 
  char *__cil_tmp2 ;

  {
#line 44
  if (! path) {
#line 45
    if (xferlogfd != -1) {
      {
#line 46
      xferlog_close();
      }
    }
#line 48
    return (0);
  }
#line 51
  if (xferlogfd == -1) {
    {
#line 52
    pr_log_debug(6, "opening TransferLog \'%s\'", path);
#line 53
    pr_log_openfile(path, & xferlogfd, (mode_t )420);
    }
  }
#line 56
  return (xferlogfd);
}
}
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/xferlog.c"
int xferlog_write(long xfertime , char const   *remhost , off_t___0 fsize , char *fname ,
                  char xfertype , char direction , char access_mode , char *user ,
                  char abort_flag ) 
{ 
  char buf___2[2048] ;
  unsigned int tmp ;
  char fbuf[2048] ;
  unsigned int tmp___0 ;
  int have_ident ;
  char *rfc1413_ident ;
  register unsigned int i___0 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  time_t tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 63
  buf___2[0] = (char )'\000';
#line 63
  tmp = 1U;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (tmp >= 2048U) {
#line 63
      goto while_break;
    }
#line 63
    buf___2[tmp] = (char)0;
#line 63
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  fbuf[0] = (char )'\000';
#line 63
  tmp___0 = 1U;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (tmp___0 >= 2048U) {
#line 63
      goto while_break___0;
    }
#line 63
    fbuf[tmp___0] = (char)0;
#line 63
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 64
  have_ident = 0;
#line 65
  rfc1413_ident = (char *)((void *)0);
#line 66
  i___0 = 0U;
#line 68
  if (xferlogfd == -1) {
#line 69
    return (0);
  } else
#line 68
  if (! remhost) {
#line 69
    return (0);
  } else
#line 68
  if (! user) {
#line 69
    return (0);
  } else
#line 68
  if (! fname) {
#line 69
    return (0);
  }
#line 71
  i___0 = 0U;
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 71
    if ((unsigned long )(i___0 + 1U) < sizeof(fbuf)) {
#line 71
      if (! ((int )*(fname + i___0) != 0)) {
#line 71
        goto while_break___1;
      }
    } else {
#line 71
      goto while_break___1;
    }
    {
#line 72
    tmp___3 = __ctype_b_loc();
    }
#line 72
    if ((int const   )*(*tmp___3 + (int )*(fname + i___0)) & 8192) {
#line 72
      fbuf[i___0] = (char )'_';
    } else {
      {
#line 72
      tmp___4 = __ctype_b_loc();
      }
#line 72
      if ((int const   )*(*tmp___4 + (int )*(fname + i___0)) & 2) {
#line 72
        fbuf[i___0] = (char )'_';
      } else {
#line 72
        fbuf[i___0] = *(fname + i___0);
      }
    }
#line 71
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 75
  fbuf[i___0] = (char )'\000';
#line 77
  tmp___5 = pr_table_get(session.notes, "mod_ident.rfc1413-ident", (size_t *)((void *)0));
#line 77
  rfc1413_ident = (char *)tmp___5;
  }
#line 78
  if (rfc1413_ident) {
    {
#line 79
    have_ident = 1;
#line 85
    tmp___6 = strcmp((char const   *)rfc1413_ident, "UNKNOWN");
    }
#line 85
    if (tmp___6 == 0) {
#line 86
      rfc1413_ident = (char *)"*";
    }
  } else {
#line 92
    rfc1413_ident = (char *)"*";
  }
#line 95
  if (have_ident) {
#line 95
    tmp___7 = '1';
  } else {
#line 95
    tmp___7 = '0';
  }
  {
#line 95
  tmp___8 = time((time_t *)((void *)0));
#line 95
  tmp___9 = pr_strtime(tmp___8);
#line 95
  snprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%s %ld %s %llu %s %c _ %c %c %s ftp %c %s %c\n",
           tmp___9, xfertime, remhost, (unsigned long long )fsize, fbuf, (int )xfertype,
           (int )direction, (int )access_mode, user, tmp___7, rfc1413_ident, (int )abort_flag);
#line 110
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 112
  tmp___10 = strlen((char const   *)(buf___2));
#line 112
  tmp___11 = write(xferlogfd, (void const   *)(buf___2), tmp___10);
  }
#line 112
  return (tmp___11);
}
}
#line 845 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 377 "../include/netaddr.h"
char *pr_netaddr_validate_dns_str(char *buf___2 ) ;
#line 113 "../include/log.h"
int ( /* format attribute */  pr_log_writefile)(int logfd , char const   *ident ,
                                                char const   *fmt  , ...) ;
#line 151
void log_stderr(int bool ) ;
#line 153
void init_log(void) ;
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int syslog_open  =    0;
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int syslog_discard  =    0;
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int logstderr  =    1;
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int debug_level  =    0;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int facility  =    3 << 3;
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int set_facility  =    -1;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static char systemlog_fn[4096]  = {      (char )'\000'};
#line 44 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static char systemlog_host[256]  = {      (char )'\000'};
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int systemlog_fd  =    -1;
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int syslog_sockfd  =    -1;
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static int fd  =    -1;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int log_wtmp(char *line , char const   *name , char const   *host , pr_netaddr_t *ip ) 
{ 
  struct stat buf___2 ;
  struct utmp ut ;
  int res ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 59
  res = 0;
#line 129
  if (fd < 0) {
    {
#line 129
    fd = open("/var/log/wtmp", 1025, 0);
    }
#line 129
    if (fd < 0) {
      {
#line 131
      tmp = __errno_location();
#line 131
      tmp___0 = strerror(*tmp);
#line 131
      pr_log_pri(4, "wtmp %s: %s", "/var/log/wtmp", tmp___0);
      }
#line 132
      return (-1);
    }
  }
  {
#line 135
  tmp___9 = fstat(fd, & buf___2);
  }
#line 135
  if (tmp___9 == 0) {
    {
#line 136
    memset((void *)(& ut), 0, (size_t )sizeof(ut));
    }
#line 139
    if (ip) {
      {
#line 143
      tmp___1 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)ip);
#line 143
      memcpy((void */* __restrict  */)(& ut.ut_addr_v6), (void const   */* __restrict  */)tmp___1,
             (size_t )sizeof(ut.ut_addr_v6));
      }
    }
    {
#line 152
    sstrncpy(ut.ut_line, (char const   *)line, (size_t )sizeof(ut.ut_line));
    }
#line 153
    if (name) {
#line 153
      if (*name) {
        {
#line 154
        sstrncpy(ut.ut_user, name, (size_t )sizeof(ut.ut_user));
        }
      }
    }
#line 155
    if (session.pid) {
#line 155
      ut.ut_pid = session.pid;
    } else {
      {
#line 155
      tmp___2 = getpid();
#line 155
      ut.ut_pid = tmp___2;
      }
    }
#line 156
    if (name) {
#line 156
      if (*name) {
#line 157
        ut.ut_type = (short)7;
      } else {
#line 159
        ut.ut_type = (short)8;
      }
    } else {
#line 159
      ut.ut_type = (short)8;
    }
#line 167
    if (host) {
#line 167
      if (*host) {
        {
#line 168
        sstrncpy(ut.ut_host, host, (size_t )sizeof(ut.ut_host));
        }
      }
    }
    {
#line 171
    ut.ut_tv.tv_sec = time((time_t *)((void *)0));
#line 172
    tmp___6 = write(fd, (void const   *)((char *)(& ut)), (size_t )sizeof(ut));
    }
#line 172
    if ((unsigned long )tmp___6 != sizeof(ut)) {
      {
#line 173
      tmp___5 = ftruncate(fd, buf___2.st_size);
      }
#line 173
      if (tmp___5 < 0) {
        {
#line 174
        tmp___3 = __errno_location();
#line 174
        tmp___4 = strerror(*tmp___3);
#line 174
        pr_log_debug(0, "error truncating \'%s\': %s", "/var/log/wtmp", tmp___4);
        }
      }
    }
  } else {
    {
#line 180
    tmp___7 = __errno_location();
#line 180
    tmp___8 = strerror(*tmp___7);
#line 180
    pr_log_debug(0, "%s fstat(): %s", "/var/log/wtmp", tmp___8);
#line 181
    res = -1;
    }
  }
#line 185
  return (res);
}
}
#line 188 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int pr_log_openfile(char const   *log_file , int *log_fd , mode_t log_mode ) 
{ 
  pool *tmp_pool ;
  char *tmp ;
  char *lf ;
  unsigned char have_stat ;
  unsigned char *allow_log_symlinks ;
  struct stat sbuf___0 ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int flags ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 189
  tmp_pool = (pool *)((void *)0);
#line 190
  tmp = (char *)((void *)0);
#line 191
  have_stat = (unsigned char)0;
#line 191
  allow_log_symlinks = (unsigned char *)((void *)0);
#line 195
  if (! log_file) {
    {
#line 196
    tmp___0 = __errno_location();
#line 196
    *tmp___0 = 22;
    }
#line 197
    return (-1);
  } else
#line 195
  if (! log_fd) {
    {
#line 196
    tmp___0 = __errno_location();
#line 196
    *tmp___0 = 22;
    }
#line 197
    return (-1);
  }
  {
#line 201
  tmp_pool = make_sub_pool(permanent_pool);
#line 202
  pr_pool_tag(tmp_pool, "log_openfile() tmp pool");
#line 203
  lf = pstrdup(tmp_pool, log_file);
#line 205
  tmp = strrchr((char const   *)lf, '/');
  }
#line 206
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 207
    pr_log_debug(0, "inappropriate log file: %s", lf);
#line 208
    destroy_pool(tmp_pool);
    }
#line 209
    return (-1);
  }
  {
#line 215
  *tmp = (char )'\000';
#line 217
  tmp___3 = stat((char const   */* __restrict  */)lf, (struct stat */* __restrict  */)(& sbuf___0));
  }
#line 217
  if (tmp___3 == -1) {
    {
#line 218
    tmp___1 = __errno_location();
#line 218
    tmp___2 = strerror(*tmp___1);
#line 218
    pr_log_debug(0, "error: unable to stat() %s: %s", lf, tmp___2);
#line 220
    destroy_pool(tmp_pool);
    }
#line 221
    return (-1);
  }
#line 225
  if (! ((sbuf___0.st_mode & 61440U) == 16384U)) {
    {
#line 226
    pr_log_debug(0, "error: %s is not a directory", lf);
#line 227
    destroy_pool(tmp_pool);
    }
#line 228
    return (-1);
  }
#line 232
  if (sbuf___0.st_mode & (unsigned int )((128 >> 3) >> 3)) {
    {
#line 233
    pr_log_pri(5, "error: %s is a world writeable directory", lf);
#line 234
    destroy_pool(tmp_pool);
    }
#line 235
    return (-2);
  }
  {
#line 241
  *tmp = (char )'/';
#line 243
  tmp___4 = get_param_ptr(main_server->conf, "AllowLogSymlinks", 0);
#line 243
  allow_log_symlinks = (unsigned char *)tmp___4;
  }
#line 246
  if (! allow_log_symlinks) {
#line 246
    goto _L___0;
  } else
#line 246
  if ((int )*allow_log_symlinks == 0) {
    _L___0: /* CIL Label */ 
    {
#line 247
    flags = 1089;
#line 254
    flags |= 131072;
#line 267
    *log_fd = open((char const   *)lf, flags, log_mode);
    }
#line 268
    if (*log_fd == -1) {
      {
#line 270
      tmp___6 = __errno_location();
      }
#line 270
      if (*tmp___6 != 17) {
        {
#line 271
        destroy_pool(tmp_pool);
#line 280
        tmp___5 = __errno_location();
        }
        {
#line 282
        if (*tmp___5 == 40) {
#line 282
          goto case_40;
        }
#line 287
        if (*tmp___5 == 31) {
#line 287
          goto case_31;
        }
#line 280
        goto switch_break;
        case_40: /* CIL Label */ 
#line 283
        return (-3);
        case_31: /* CIL Label */ 
#line 288
        return (-3);
        switch_break: /* CIL Label */ ;
        }
#line 292
        return (-1);
      } else {
        {
#line 321
        destroy_pool(tmp_pool);
        }
#line 322
        return (-1);
      }
    }
#line 328
    if (! have_stat) {
      {
#line 328
      tmp___7 = fstat(*log_fd, & sbuf___0);
      }
#line 328
      if (tmp___7 != -1) {
#line 329
        have_stat = (unsigned char)1;
      }
    }
#line 331
    if (! have_stat) {
#line 331
      goto _L;
    } else
#line 331
    if ((sbuf___0.st_mode & 61440U) == 40960U) {
      _L: /* CIL Label */ 
#line 332
      if (! have_stat) {
#line 332
        tmp___8 = "error: unable to stat %s";
      } else {
#line 332
        tmp___8 = "error: %s is a symbolic link";
      }
      {
#line 332
      pr_log_debug(0, tmp___8, lf);
#line 335
      close(*log_fd);
#line 336
      *log_fd = -1;
#line 337
      destroy_pool(tmp_pool);
      }
#line 338
      return (-3);
    }
  } else {
    {
#line 342
    *log_fd = open((char const   *)lf, 1089, log_mode);
    }
#line 343
    if (*log_fd == -1) {
      {
#line 344
      destroy_pool(tmp_pool);
      }
#line 345
      return (-1);
    }
  }
  {
#line 349
  destroy_pool(tmp_pool);
  }
#line 350
  return (0);
}
}
#line 353 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int ( /* format attribute */  pr_log_writefile)(int logfd , char const   *ident ,
                                                char const   *fmt  , ...) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  time_t timestamp ;
  time_t tmp___0 ;
  struct tm *t ;
  va_list msg ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  pid_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int *tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 354
  buf___2[0] = (char )'\000';
#line 354
  tmp = 1U;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (tmp >= 1024U) {
#line 354
      goto while_break;
    }
#line 354
    buf___2[tmp] = (char)0;
#line 354
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 355
  tmp___0 = time((time_t *)((void *)0));
#line 355
  timestamp = tmp___0;
#line 356
  t = (struct tm *)((void *)0);
  }
#line 359
  if (logfd < 0) {
    {
#line 360
    tmp___1 = __errno_location();
#line 360
    *tmp___1 = 22;
    }
#line 361
    return (-1);
  }
  {
#line 364
  t = pr_localtime((pool *)((void *)0), (time_t const   *)(& timestamp));
  }
#line 365
  if (! t) {
#line 366
    return (-1);
  }
  {
#line 369
  strftime((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%b %d %H:%M:%S ",
           (struct tm  const  */* __restrict  */)t);
#line 370
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
  }
#line 373
  if (session.pid) {
#line 373
    tmp___3 = session.pid;
  } else {
    {
#line 373
    tmp___2 = getpid();
#line 373
    tmp___3 = tmp___2;
    }
  }
  {
#line 373
  tmp___4 = strlen((char const   *)(buf___2));
#line 373
  tmp___5 = strlen((char const   *)(buf___2));
#line 373
  snprintf((char */* __restrict  */)(buf___2 + tmp___5), (size_t )(sizeof(buf___2) - (unsigned long )tmp___4),
           (char const   */* __restrict  */)"%s[%u]: ", ident, (unsigned int )tmp___3);
#line 375
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 378
  __builtin_va_start(msg, fmt);
#line 379
  tmp___6 = strlen((char const   *)(buf___2));
#line 379
  tmp___7 = strlen((char const   *)(buf___2));
#line 379
  vsnprintf((char */* __restrict  */)(buf___2 + tmp___7), (size_t )(sizeof(buf___2) - (unsigned long )tmp___6),
            (char const   */* __restrict  */)fmt, msg);
#line 380
  __builtin_va_end(msg);
#line 382
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 383
  tmp___8 = strlen((char const   *)(buf___2));
#line 383
  buf___2[tmp___8] = (char )'\n';
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 385
    tmp___10 = strlen((char const   *)(buf___2));
#line 385
    tmp___11 = write(logfd, (void const   *)(buf___2), tmp___10);
    }
#line 385
    if (! (tmp___11 < 0)) {
#line 385
      goto while_break___0;
    }
    {
#line 386
    tmp___9 = __errno_location();
    }
#line 386
    if (*tmp___9 == 4) {
      {
#line 387
      pr_signals_handle();
      }
#line 388
      goto while_continue___0;
    }
#line 391
    return (-1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 394
  return (0);
}
}
#line 397 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int log_opensyslog(char const   *fn ) 
{ 
  int res ;
  char *__cil_tmp3 ;

  {
#line 398
  res = 0;
#line 400
  if (set_facility != -1) {
#line 401
    facility = set_facility;
  }
#line 403
  if (fn) {
    {
#line 404
    memset((void *)(systemlog_fn), '\000', (size_t )sizeof(systemlog_fn));
#line 405
    sstrncpy(systemlog_fn, fn, (size_t )sizeof(systemlog_fn));
    }
  }
#line 408
  if (! systemlog_fn[0]) {
    {
#line 411
    pr_closelog(syslog_sockfd);
#line 413
    syslog_sockfd = pr_openlog("proftpd", 9, facility);
    }
#line 414
    if (syslog_sockfd < 0) {
#line 415
      return (-1);
    }
#line 417
    systemlog_fd = -1;
  } else {
    {
#line 419
    res = pr_log_openfile((char const   *)(systemlog_fn), & systemlog_fd, (mode_t )416);
    }
#line 419
    if (res < 0) {
      {
#line 421
      memset((void *)(systemlog_fn), '\000', (size_t )sizeof(systemlog_fn));
      }
#line 422
      return (res);
    }
  }
#line 425
  syslog_open = 1;
#line 426
  return (0);
}
}
#line 429 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void log_closesyslog(void) 
{ 


  {
  {
#line 430
  close(systemlog_fd);
#line 431
  systemlog_fd = -1;
#line 433
  pr_closelog(syslog_sockfd);
#line 434
  syslog_sockfd = -1;
#line 436
  syslog_open = 0;
  }
#line 437
  return;
}
}
#line 439 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void log_setfacility(int f ) 
{ 


  {
#line 440
  set_facility = f;
#line 441
  return;
}
}
#line 443 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void log_discard(void) 
{ 


  {
#line 444
  syslog_discard = 1;
#line 445
  return;
}
}
#line 447 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
static void log_write(int priority , int f , char *s ) 
{ 
  unsigned int *max_priority ;
  char serverinfo[1024] ;
  unsigned int tmp ;
  pr_netaddr_t *remote_addr ;
  pr_netaddr_t *tmp___0 ;
  char const   *remote_name ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char buf___2[2048] ;
  unsigned int tmp___5 ;
  time_t tt ;
  time_t tmp___6 ;
  struct tm *t ;
  __pid_t tmp___7 ;
  pid_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  __pid_t tmp___11 ;
  pid_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int *tmp___15 ;
  size_t tmp___16 ;
  ssize_t tmp___17 ;
  void *tmp___18 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 448
  max_priority = (unsigned int *)((void *)0);
#line 449
  serverinfo[0] = (char )'\000';
#line 449
  tmp = 1U;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (tmp >= 1024U) {
#line 449
      goto while_break;
    }
#line 449
    serverinfo[tmp] = (char)0;
#line 449
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 451
  memset((void *)(serverinfo), '\000', (size_t )sizeof(serverinfo));
  }
#line 453
  if (main_server) {
#line 453
    if (main_server->ServerFQDN) {
      {
#line 455
      tmp___0 = pr_netaddr_get_sess_remote_addr();
#line 455
      remote_addr = tmp___0;
#line 456
      tmp___1 = pr_netaddr_get_sess_remote_name();
#line 456
      remote_name = tmp___1;
#line 458
      snprintf((char */* __restrict  */)(serverinfo), (size_t )sizeof(serverinfo),
               (char const   */* __restrict  */)"%s", main_server->ServerFQDN);
#line 459
      serverinfo[sizeof(serverinfo) - 1UL] = (char )'\000';
      }
#line 461
      if (remote_addr) {
#line 461
        if (remote_name) {
          {
#line 462
          tmp___2 = pr_netaddr_get_ipstr(remote_addr);
#line 462
          tmp___3 = strlen((char const   *)(serverinfo));
#line 462
          tmp___4 = strlen((char const   *)(serverinfo));
#line 462
          snprintf((char */* __restrict  */)(serverinfo + tmp___4), (size_t )(sizeof(serverinfo) - (unsigned long )tmp___3),
                   (char const   */* __restrict  */)" (%s[%s])", remote_name, tmp___2);
#line 466
          serverinfo[sizeof(serverinfo) - 1UL] = (char )'\000';
          }
        }
      }
    }
  }
#line 470
  if (logstderr) {
    {
#line 472
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - %s\n",
            serverinfo, s);
    }
#line 473
    return;
  } else
#line 470
  if (! main_server) {
    {
#line 472
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - %s\n",
            serverinfo, s);
    }
#line 473
    return;
  }
#line 476
  if (syslog_discard) {
#line 477
    return;
  }
#line 479
  if (systemlog_fd != -1) {
#line 480
    buf___2[0] = (char )'\000';
#line 480
    tmp___5 = 1U;
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (tmp___5 >= 2048U) {
#line 480
        goto while_break___0;
      }
#line 480
      buf___2[tmp___5] = (char)0;
#line 480
      tmp___5 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 481
    tmp___6 = time((time_t *)((void *)0));
#line 481
    tt = tmp___6;
#line 484
    t = pr_localtime((pool *)((void *)0), (time_t const   *)(& tt));
    }
#line 485
    if (! t) {
#line 486
      return;
    }
    {
#line 488
    strftime((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)"%b %d %H:%M:%S ",
             (struct tm  const  */* __restrict  */)t);
#line 489
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
    }
#line 491
    if (serverinfo[0]) {
#line 492
      if (session.pid) {
#line 492
        tmp___8 = session.pid;
      } else {
        {
#line 492
        tmp___7 = getpid();
#line 492
        tmp___8 = tmp___7;
        }
      }
      {
#line 492
      tmp___9 = strlen((char const   *)(buf___2));
#line 492
      tmp___10 = strlen((char const   *)(buf___2));
#line 492
      snprintf((char */* __restrict  */)(buf___2 + tmp___10), (size_t )(sizeof(buf___2) - (unsigned long )tmp___9),
               (char const   */* __restrict  */)"%s proftpd[%u] %s: %s\n", systemlog_host,
               (unsigned int )tmp___8, serverinfo, s);
      }
    } else {
#line 497
      if (session.pid) {
#line 497
        tmp___12 = session.pid;
      } else {
        {
#line 497
        tmp___11 = getpid();
#line 497
        tmp___12 = tmp___11;
        }
      }
      {
#line 497
      tmp___13 = strlen((char const   *)(buf___2));
#line 497
      tmp___14 = strlen((char const   *)(buf___2));
#line 497
      snprintf((char */* __restrict  */)(buf___2 + tmp___14), (size_t )(sizeof(buf___2) - (unsigned long )tmp___13),
               (char const   */* __restrict  */)"%s proftpd[%u]: %s\n", systemlog_host,
               (unsigned int )tmp___12, s);
      }
    }
#line 502
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
    {
#line 503
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 503
      tmp___16 = strlen((char const   *)(buf___2));
#line 503
      tmp___17 = write(systemlog_fd, (void const   *)(buf___2), tmp___16);
      }
#line 503
      if (! (tmp___17 < 0)) {
#line 503
        goto while_break___1;
      }
      {
#line 504
      tmp___15 = __errno_location();
      }
#line 504
      if (*tmp___15 == 4) {
        {
#line 505
        pr_signals_handle();
        }
#line 506
        goto while_continue___1;
      }
#line 509
      return;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 511
    return;
  }
#line 514
  if (set_facility != -1) {
#line 515
    f = set_facility;
  }
#line 517
  if (! syslog_open) {
    {
#line 518
    syslog_sockfd = pr_openlog("proftpd", 9, f);
#line 519
    syslog_open = 1;
    }
  } else
#line 521
  if (f != facility) {
    {
#line 522
    pr_setlogfacility(f);
    }
  }
  {
#line 525
  tmp___18 = get_param_ptr(main_server->conf, "SyslogLevel", 0);
#line 525
  max_priority = (unsigned int *)tmp___18;
  }
#line 526
  if ((unsigned long )max_priority != (unsigned long )((void *)0)) {
#line 526
    if ((unsigned int )priority > *max_priority) {
#line 528
      return;
    }
  }
#line 530
  if (serverinfo[0]) {
    {
#line 531
    pr_syslog(syslog_sockfd, priority, "%s - %s\n", serverinfo, s);
    }
  } else {
    {
#line 533
    pr_syslog(syslog_sockfd, priority, "%s\n", s);
    }
  }
#line 534
  return;
}
}
#line 536 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void ( /* format attribute */  pr_log_pri)(int priority , char const   *fmt  , ...) 
{ 
  char buf___2[2048] ;
  unsigned int tmp ;
  va_list msg ;
  void *__cil_tmp6 ;

  {
#line 537
  buf___2[0] = (char )'\000';
#line 537
  tmp = 1U;
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (tmp >= 2048U) {
#line 537
      goto while_break;
    }
#line 537
    buf___2[tmp] = (char)0;
#line 537
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 540
  __builtin_va_start(msg, fmt);
#line 541
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 542
  __builtin_va_end(msg);
#line 545
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 547
  log_write(priority, facility, buf___2);
  }
#line 548
  return;
}
}
#line 553 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void ( /* format attribute */  pr_log_auth)(int priority , char const   *fmt  , ...) 
{ 
  char buf___2[2048] ;
  unsigned int tmp ;
  va_list msg ;
  void *__cil_tmp6 ;

  {
#line 554
  buf___2[0] = (char )'\000';
#line 554
  tmp = 1U;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (tmp >= 2048U) {
#line 554
      goto while_break;
    }
#line 554
    buf___2[tmp] = (char)0;
#line 554
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 557
  __builtin_va_start(msg, fmt);
#line 558
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 559
  __builtin_va_end(msg);
#line 562
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 564
  log_write(priority, 10 << 3, buf___2);
  }
#line 565
  return;
}
}
#line 571 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void log_stderr(int bool ) 
{ 


  {
#line 572
  logstderr = bool;
#line 573
  return;
}
}
#line 579 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int pr_log_setdebuglevel(int level ) 
{ 
  int old_level ;

  {
#line 580
  old_level = debug_level;
#line 581
  debug_level = level;
#line 582
  return (old_level);
}
}
#line 588 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
int pr_log_str2sysloglevel(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 590
  tmp___6 = strcasecmp(name, "emerg");
  }
#line 590
  if (tmp___6 == 0) {
#line 591
    return (0);
  } else {
    {
#line 593
    tmp___5 = strcasecmp(name, "alert");
    }
#line 593
    if (tmp___5 == 0) {
#line 594
      return (1);
    } else {
      {
#line 596
      tmp___4 = strcasecmp(name, "crit");
      }
#line 596
      if (tmp___4 == 0) {
#line 597
        return (2);
      } else {
        {
#line 599
        tmp___3 = strcasecmp(name, "error");
        }
#line 599
        if (tmp___3 == 0) {
#line 600
          return (3);
        } else {
          {
#line 602
          tmp___2 = strcasecmp(name, "warn");
          }
#line 602
          if (tmp___2 == 0) {
#line 603
            return (4);
          } else {
            {
#line 605
            tmp___1 = strcasecmp(name, "notice");
            }
#line 605
            if (tmp___1 == 0) {
#line 606
              return (5);
            } else {
              {
#line 608
              tmp___0 = strcasecmp(name, "info");
              }
#line 608
              if (tmp___0 == 0) {
#line 609
                return (6);
              } else {
                {
#line 611
                tmp = strcasecmp(name, "debug");
                }
#line 611
                if (tmp == 0) {
#line 612
                  return (7);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 614
  tmp___7 = __errno_location();
#line 614
  *tmp___7 = 2;
  }
#line 615
  return (-1);
}
}
#line 618 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void ( /* format attribute */  pr_log_debug)(int level , char const   *fmt  , ...) 
{ 
  char buf___2[2048] ;
  unsigned int tmp ;
  va_list msg ;
  void *__cil_tmp6 ;

  {
#line 619
  buf___2[0] = (char )'\000';
#line 619
  tmp = 1U;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if (tmp >= 2048U) {
#line 619
      goto while_break;
    }
#line 619
    buf___2[tmp] = (char)0;
#line 619
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  if (debug_level < level) {
#line 623
    return;
  }
#line 625
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 626
    return;
  }
  {
#line 628
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 629
  __builtin_va_start(msg, fmt);
#line 630
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 631
  __builtin_va_end(msg);
#line 634
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 636
  log_write(7, facility, buf___2);
  }
#line 637
  return;
}
}
#line 639 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/log.c"
void init_log(void) 
{ 
  char buf___2[256] ;
  int tmp ;
  char *tmp___0 ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 642
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 643
  tmp = gethostname(buf___2, (size_t )sizeof(buf___2));
  }
#line 643
  if (tmp == -1) {
    {
#line 644
    sstrncpy(buf___2, "localhost", (size_t )sizeof(buf___2));
    }
  }
  {
#line 646
  tmp___0 = pr_netaddr_validate_dns_str(buf___2);
#line 646
  sstrncpy(systemlog_host, (char const   *)tmp___0, (size_t )sizeof(systemlog_host));
#line 648
  memset((void *)(systemlog_fn), '\000', (size_t )sizeof(systemlog_fn));
#line 649
  log_closesyslog();
  }
#line 650
  return;
}
}
#line 42 "../include/str.h"
char *pr_str_get_word(char **cp , int flags ) ;
#line 37 "../include/parser.h"
int pr_parser_prepare(pool *p , xaset_t **parsed_servers ) ;
#line 42
int pr_parser_cleanup(void) ;
#line 55
config_rec *pr_parser_config_ctxt_get(void) ;
#line 83
int pr_parser_parse_file(pool *p , char const   *path , config_rec *start , int flags ) ;
#line 93
cmd_rec *pr_parser_parse_line(pool *p ) ;
#line 117
server_rec *pr_parser_server_ctxt_get(void) ;
#line 32 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
pool *global_config_pool ;
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static pool *parser_pool  =    (pool *)((void *)0);
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static array_header *parser_confstack  =    (array_header *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static config_rec **parser_curr_config  =    (config_rec **)((void *)0);
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static array_header *parser_servstack  =    (array_header *)((void *)0);
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static server_rec **parser_curr_server  =    (server_rec **)((void *)0);
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static unsigned int parser_sid  =    0U;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static xaset_t **parser_server_list  =    (xaset_t **)((void *)0);
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static char const   *trace_channel___9  =    "config";
#line 54 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static unsigned int parser_curr_lineno  =    0U;
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static struct config_src *parser_sources  =    (struct config_src *)((void *)0);
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static void add_config_ctxt(config_rec *c ) 
{ 
  void *tmp ;

  {
#line 68
  if (! *parser_curr_config) {
#line 69
    *parser_curr_config = c;
  } else {
    {
#line 72
    tmp = push_array(parser_confstack);
#line 72
    parser_curr_config = (config_rec **)tmp;
#line 73
    *parser_curr_config = c;
    }
  }
#line 75
  return;
}
}
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static struct config_src *add_config_source(pr_fh_t *fh ) 
{ 
  pool *p ;
  pool *tmp ;
  struct config_src *cs ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 78
  tmp = pr_pool_create_sz(parser_pool, 512);
#line 78
  p = tmp;
#line 79
  tmp___0 = pcalloc(p, (int )sizeof(struct config_src ));
#line 79
  cs = (struct config_src *)tmp___0;
#line 81
  pr_pool_tag(p, "configuration source pool");
#line 82
  cs->cs_next = (struct config_src *)((void *)0);
#line 83
  cs->cs_pool = p;
#line 84
  cs->cs_fh = fh;
#line 85
  cs->cs_lineno = 0U;
  }
#line 87
  if (! parser_sources) {
#line 88
    parser_sources = cs;
  } else {
#line 91
    cs->cs_next = parser_sources;
#line 92
    parser_sources = cs;
  }
#line 95
  return (cs);
}
}
#line 98 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static char *get_config_word(pool *p , char *word ) 
{ 
  char *env ;
  size_t tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 106
  tmp___2 = strlen((char const   *)word);
  }
#line 106
  if (tmp___2 > 7U) {
    {
#line 106
    tmp___3 = strncmp((char const   *)word, "%{env:", (size_t )6);
    }
#line 106
    if (tmp___3 == 0) {
      {
#line 106
      tmp___4 = strlen((char const   *)word);
      }
#line 106
      if ((int )*(word + (tmp___4 - 1U)) == 125) {
        {
#line 111
        tmp = strlen((char const   *)word);
#line 111
        *(word + (tmp - 1U)) = (char )'\000';
#line 113
        env = pr_env_get(p, (char const   *)(word + 6));
        }
#line 115
        if (env) {
          {
#line 115
          tmp___0 = pstrdup(p, (char const   *)env);
#line 115
          tmp___1 = (char const   *)tmp___0;
          }
        } else {
#line 115
          tmp___1 = "";
        }
#line 115
        return ((char *)tmp___1);
      }
    }
  }
  {
#line 118
  tmp___5 = pstrdup(p, (char const   *)word);
  }
#line 118
  return (tmp___5);
}
}
#line 121 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
static void remove_config_source(void) 
{ 
  struct config_src *cs ;

  {
#line 122
  cs = parser_sources;
#line 124
  if (cs) {
    {
#line 125
    parser_sources = cs->cs_next;
#line 126
    destroy_pool(cs->cs_pool);
    }
  }
#line 129
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
int pr_parser_cleanup(void) 
{ 
  int *tmp ;

  {
#line 136
  if (parser_pool) {
#line 137
    if (parser_servstack->nelts > 1) {
      {
#line 139
      tmp = __errno_location();
#line 139
      *tmp = 1;
      }
#line 140
      return (-1);
    } else
#line 137
    if (parser_curr_config) {
#line 137
      if (*parser_curr_config) {
        {
#line 139
        tmp = __errno_location();
#line 139
        *tmp = 1;
        }
#line 140
        return (-1);
      }
    }
    {
#line 143
    destroy_pool(parser_pool);
#line 144
    parser_pool = (pool *)((void *)0);
    }
  }
#line 147
  parser_servstack = (array_header *)((void *)0);
#line 148
  parser_curr_server = (server_rec **)((void *)0);
#line 150
  parser_confstack = (array_header *)((void *)0);
#line 151
  parser_curr_config = (config_rec **)((void *)0);
#line 154
  parser_sid = 0U;
#line 156
  return (0);
}
}
#line 159 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
config_rec *pr_parser_config_ctxt_close(int *empty ) 
{ 
  config_rec *c ;

  {
#line 160
  c = *parser_curr_config;
#line 167
  if ((unsigned long )parser_curr_config == (unsigned long )((config_rec **)parser_confstack->elts)) {
#line 168
    if (! c->subset) {
#line 168
      goto _L;
    } else
#line 168
    if (! (c->subset)->xas_list) {
      _L: /* CIL Label */ 
      {
#line 169
      xaset_remove(c->set, (xasetmember_t *)c);
#line 170
      destroy_pool(c->pool);
      }
#line 172
      if (empty) {
#line 173
        *empty = 1;
      }
    }
#line 176
    if (*parser_curr_config) {
#line 177
      *parser_curr_config = (config_rec *)((void *)0);
    }
#line 179
    return ((config_rec *)((void *)0));
  }
#line 182
  if (! c->subset) {
#line 182
    goto _L___0;
  } else
#line 182
  if (! (c->subset)->xas_list) {
    _L___0: /* CIL Label */ 
    {
#line 183
    xaset_remove(c->set, (xasetmember_t *)c);
#line 184
    destroy_pool(c->pool);
    }
#line 186
    if (empty) {
#line 187
      *empty = 1;
    }
  }
#line 190
  parser_curr_config --;
#line 191
  (parser_confstack->nelts) --;
#line 193
  return (*parser_curr_config);
}
}
#line 196 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
config_rec *pr_parser_config_ctxt_get(void) 
{ 
  int *tmp ;

  {
#line 197
  if (parser_curr_config) {
#line 198
    return (*parser_curr_config);
  }
  {
#line 200
  tmp = __errno_location();
#line 200
  *tmp = 2;
  }
#line 201
  return ((config_rec *)((void *)0));
}
}
#line 204 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
config_rec *pr_parser_config_ctxt_open(char const   *name ) 
{ 
  config_rec *c ;
  config_rec *parent ;
  pool *c_pool ;
  pool *parent_pool ;
  xaset_t **set ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  pool *set_pool ;
  pool *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 205
  c = (config_rec *)((void *)0);
#line 205
  parent = *parser_curr_config;
#line 206
  c_pool = (pool *)((void *)0);
#line 206
  parent_pool = (pool *)((void *)0);
#line 207
  set = (xaset_t **)((void *)0);
#line 209
  if (! name) {
    {
#line 210
    tmp = __errno_location();
#line 210
    *tmp = 22;
    }
#line 211
    return ((config_rec *)((void *)0));
  }
#line 214
  if (parent) {
#line 215
    parent_pool = parent->pool;
#line 216
    set = & parent->subset;
  } else {
#line 219
    parent_pool = (*parser_curr_server)->pool;
#line 220
    set = & (*parser_curr_server)->conf;
  }
  {
#line 230
  tmp___0 = strcmp(name, "<Global>");
  }
#line 230
  if (tmp___0 == 0) {
#line 231
    if (! global_config_pool) {
      {
#line 232
      global_config_pool = make_sub_pool(permanent_pool);
#line 233
      pr_pool_tag(global_config_pool, "<Global> Pool");
      }
    }
#line 236
    parent_pool = global_config_pool;
  }
  {
#line 239
  c_pool = make_sub_pool(parent_pool);
#line 240
  pr_pool_tag(c_pool, "sub-config pool");
#line 242
  tmp___1 = pcalloc(c_pool, (int )sizeof(config_rec ));
#line 242
  c = (config_rec *)tmp___1;
  }
#line 244
  if (! *set) {
    {
#line 245
    tmp___2 = make_sub_pool(parent_pool);
#line 245
    set_pool = tmp___2;
#line 246
    *set = xaset_create(set_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
#line 247
    (*set)->pool = set_pool;
    }
  }
  {
#line 250
  xaset_insert(*set, (xasetmember_t *)c);
#line 252
  c->pool = c_pool;
#line 253
  c->set = *set;
#line 254
  c->parent = parent;
#line 255
  c->name = pstrdup(c->pool, name);
  }
#line 257
  if (parent) {
#line 258
    if (parent->config_type == 1 << 5) {
#line 259
      c->flags |= (long )(1 << 2);
    }
  }
  {
#line 262
  add_config_ctxt(c);
  }
#line 263
  return (c);
}
}
#line 266 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
unsigned int pr_parser_get_lineno(void) 
{ 


  {
#line 267
  return (parser_curr_lineno);
}
}
#line 270 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
int pr_parser_parse_file(pool *p , char const   *path , config_rec *start , int flags ) 
{ 
  pr_fh_t *fh ;
  struct config_src *cs ;
  cmd_rec *cmd ;
  pool *tmp_pool ;
  char *report_path ;
  int *tmp ;
  pool *tmp___0 ;
  conftable *conftab ;
  char found ;
  void *tmp___1 ;
  modret_t *mr ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 278
  if (! path) {
    {
#line 279
    tmp = __errno_location();
#line 279
    *tmp = 22;
    }
#line 280
    return (-1);
  }
#line 283
  if (p) {
#line 283
    tmp___0 = p;
  } else {
#line 283
    tmp___0 = permanent_pool;
  }
  {
#line 283
  tmp_pool = make_sub_pool(tmp___0);
#line 284
  pr_pool_tag(tmp_pool, "parser file pool");
#line 286
  report_path = (char *)path;
  }
#line 287
  if (session.chroot_path) {
    {
#line 288
    report_path = pdircat(tmp_pool, session.chroot_path, path, (void *)0);
    }
  }
#line 290
  if (! (flags & 1)) {
    {
#line 291
    pr_trace_msg(trace_channel___9, 3, "parsing \'%s\' configuration", report_path);
    }
  }
  {
#line 293
  fh = pr_fsio_open(path, 0);
  }
#line 294
  if ((unsigned long )fh == (unsigned long )((void *)0)) {
    {
#line 295
    destroy_pool(tmp_pool);
    }
#line 296
    return (-1);
  }
  {
#line 302
  cs = add_config_source(fh);
  }
#line 304
  if (start) {
    {
#line 305
    add_config_ctxt(start);
    }
  }
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 307
    cmd = pr_parser_parse_line(tmp_pool);
    }
#line 307
    if (! ((unsigned long )cmd != (unsigned long )((void *)0))) {
#line 307
      goto while_break;
    }
    {
#line 308
    pr_signals_handle();
    }
#line 310
    if (cmd->argc) {
      {
#line 312
      found = (char)0;
#line 314
      cmd->server = *parser_curr_server;
#line 315
      cmd->config = *parser_curr_config;
#line 317
      tmp___1 = pr_stash_get_symbol((pr_stash_type_t )1, (char const   *)*(cmd->argv + 0),
                                    (void *)0, & cmd->stash_index);
#line 317
      conftab = (conftable *)tmp___1;
      }
      {
#line 320
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 320
        if (! conftab) {
#line 320
          goto while_break___0;
        }
        {
#line 323
        pr_signals_handle();
#line 325
        *(cmd->argv + 0) = conftab->directive;
#line 327
        pr_trace_msg(trace_channel___9, 7, "dispatching directive \'%s\' to module mod_%s",
                     conftab->directive, (conftab->m)->name);
#line 331
        mr = pr_module_call(conftab->m, conftab->handler, cmd);
        }
#line 332
        if ((unsigned long )mr != (unsigned long )((void *)0)) {
#line 333
          if (mr) {
#line 333
            if (mr->mr_error) {
#line 335
              if (! (flags & 1)) {
#line 336
                if (mr) {
#line 336
                  tmp___2 = mr->mr_message;
                } else {
#line 336
                  tmp___2 = (char *)((void *)0);
                }
                {
#line 336
                pr_log_pri(3, "Fatal: %s on line %u of \'%s\'", tmp___2, cs->cs_lineno,
                           report_path);
#line 338
                exit(1);
                }
              } else {
#line 341
                if (mr) {
#line 341
                  tmp___3 = mr->mr_message;
                } else {
#line 341
                  tmp___3 = (char *)((void *)0);
                }
                {
#line 341
                pr_log_pri(4, "warning: %s on line %u of \'%s\'", tmp___3, cs->cs_lineno,
                           report_path);
                }
              }
            }
          }
        }
#line 346
        if (! ((unsigned long )mr == (unsigned long )((void *)0))) {
#line 347
          found = (char)1;
        }
        {
#line 349
        tmp___4 = pr_stash_get_symbol((pr_stash_type_t )1, (char const   *)*(cmd->argv + 0),
                                      (void *)conftab, & cmd->stash_index);
#line 349
        conftab = (conftable *)tmp___4;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 353
      if (cmd->tmp_pool) {
        {
#line 354
        destroy_pool(cmd->tmp_pool);
        }
      }
#line 356
      if (! found) {
#line 358
        if (! (flags & 1)) {
          {
#line 359
          pr_log_pri(3, "Fatal: unknown configuration directive \'%s\' on line %u of \'%s\'",
                     *(cmd->argv + 0), cs->cs_lineno, report_path);
#line 362
          exit(1);
          }
        } else {
          {
#line 365
          pr_log_pri(4, "warning: unknown configuration directive \'%s\' on line %u of \'%s\'",
                     *(cmd->argv + 0), cs->cs_lineno, report_path);
          }
        }
      }
    }
    {
#line 371
    destroy_pool(cmd->pool);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 375
  remove_config_source();
#line 377
  pr_fsio_close(fh);
#line 379
  destroy_pool(tmp_pool);
  }
#line 380
  return (0);
}
}
#line 383 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
cmd_rec *pr_parser_parse_line(pool *p ) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  char *word ;
  cmd_rec *cmd ;
  pool *sub_pool ;
  array_header *arr ;
  int *tmp___0 ;
  char *bufp ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *cp ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 384
  buf___2[0] = (char )'\000';
#line 384
  tmp = 1U;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (tmp >= 1024U) {
#line 384
      goto while_break;
    }
#line 384
    buf___2[tmp] = (char)0;
#line 384
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  word = (char *)((void *)0);
#line 385
  cmd = (cmd_rec *)((void *)0);
#line 386
  sub_pool = (pool *)((void *)0);
#line 387
  arr = (array_header *)((void *)0);
#line 389
  if (! p) {
    {
#line 390
    tmp___0 = __errno_location();
#line 390
    *tmp___0 = 22;
    }
#line 391
    return ((cmd_rec *)((void *)0));
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 394
    tmp___10 = pr_parser_read_line(buf___2, (size_t )(sizeof(buf___2) - 1UL));
    }
#line 394
    if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 394
      goto while_break___0;
    }
    {
#line 395
    bufp = buf___2;
#line 397
    pr_signals_handle();
#line 400
    sub_pool = make_sub_pool(p);
#line 401
    pr_pool_tag(sub_pool, "parser cmd subpool");
#line 403
    tmp___1 = pcalloc(sub_pool, (int )sizeof(cmd_rec ));
#line 403
    cmd = (cmd_rec *)tmp___1;
#line 404
    cmd->pool = sub_pool;
#line 405
    cmd->stash_index = -1;
#line 408
    arr = make_array(cmd->pool, 4U, (size_t )sizeof(char **));
    }
    {
#line 409
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 409
      word = pr_str_get_word(& bufp, 0);
      }
#line 409
      if (! ((unsigned long )word != (unsigned long )((void *)0))) {
#line 409
        goto while_break___1;
      }
      {
#line 410
      tmp___3 = get_config_word(cmd->pool, word);
#line 410
      tmp___2 = tmp___3;
#line 412
      tmp___4 = push_array(arr);
#line 412
      *((char **)tmp___4) = tmp___2;
#line 413
      (cmd->argc) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 417
    tmp___5 = push_array(arr);
#line 417
    *((char **)tmp___5) = (char *)((void *)0);
#line 423
    cmd->argv = (char **)arr->elts;
    }
#line 436
    if (cmd->argc) {
#line 436
      if ((int )*(*(cmd->argv + 0)) == 60) {
        {
#line 438
        cp = *(cmd->argv + (cmd->argc - 1));
#line 440
        tmp___9 = strlen((char const   *)cp);
        }
#line 440
        if ((int )*((cp + tmp___9) - 1) == 62) {
#line 440
          if (cmd->argc > 1) {
            {
#line 443
            tmp___7 = strcmp((char const   *)cp, ">");
            }
#line 443
            if (tmp___7 == 0) {
#line 444
              *(cmd->argv + (cmd->argc - 1)) = (char *)((void *)0);
#line 445
              (cmd->argc) --;
            } else {
              {
#line 448
              tmp___6 = strlen((char const   *)cp);
#line 448
              *((cp + tmp___6) - 1) = (char )'\000';
              }
            }
            {
#line 450
            cp = *(cmd->argv + 0);
#line 451
            tmp___8 = strlen((char const   *)cp);
            }
#line 451
            if ((int )*((cp + tmp___8) - 1) != 62) {
              {
#line 452
              *(cmd->argv + 0) = pstrcat(cmd->pool, cp, ">", (void *)0);
              }
            }
          }
        }
      }
    }
#line 456
    return (cmd);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 459
  return ((cmd_rec *)((void *)0));
}
}
#line 462 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
int pr_parser_prepare(pool *p , xaset_t **parsed_servers ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 464
  if (! p) {
#line 465
    if (! parser_pool) {
      {
#line 466
      parser_pool = make_sub_pool(permanent_pool);
#line 467
      pr_pool_tag(parser_pool, "Parser Pool");
      }
    }
#line 470
    p = parser_pool;
  }
#line 473
  if (! parsed_servers) {
#line 474
    parser_server_list = & server_list;
  } else {
#line 477
    parser_server_list = parsed_servers;
  }
  {
#line 479
  parser_servstack = make_array(p, 1U, (size_t )sizeof(server_rec *));
#line 480
  tmp = push_array(parser_servstack);
#line 480
  parser_curr_server = (server_rec **)tmp;
#line 481
  *parser_curr_server = main_server;
#line 483
  parser_confstack = make_array(p, 10U, (size_t )sizeof(config_rec *));
#line 484
  tmp___0 = push_array(parser_confstack);
#line 484
  parser_curr_config = (config_rec **)tmp___0;
#line 485
  *parser_curr_config = (config_rec *)((void *)0);
  }
#line 487
  return (0);
}
}
#line 497 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
char *pr_parser_read_line(char *buf___2 , size_t bufsz ) 
{ 
  struct config_src *cs ;
  int *tmp ;
  int *tmp___0 ;
  int have_eol ;
  char *bufp ;
  size_t buflen ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp12 ;

  {
#line 501
  cs = parser_sources;
#line 503
  if (! buf___2) {
    {
#line 504
    tmp = __errno_location();
#line 504
    *tmp = 22;
    }
#line 505
    return ((char *)((void *)0));
  }
#line 508
  if (! cs->cs_fh) {
    {
#line 509
    tmp___0 = __errno_location();
#line 509
    *tmp___0 = 1;
    }
#line 510
    return ((char *)((void *)0));
  }
#line 513
  parser_curr_lineno = cs->cs_lineno;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 517
    tmp___3 = pr_fsio_getline(buf___2, (int )bufsz, cs->cs_fh, & cs->cs_lineno);
    }
#line 517
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 517
      goto while_break;
    }
    {
#line 518
    have_eol = 0;
#line 519
    bufp = (char *)((void *)0);
#line 520
    tmp___1 = strlen((char const   *)buf___2);
#line 520
    buflen = tmp___1;
#line 522
    parser_curr_lineno = cs->cs_lineno;
    }
#line 525
    if (buflen) {
#line 525
      if ((int )*(buf___2 + (buflen - 1U)) == 10) {
        {
#line 527
        have_eol = 1;
#line 528
        *(buf___2 + (buflen - 1U)) = (char )'\000';
#line 529
        buflen = strlen((char const   *)buf___2);
        }
      }
    }
    {
#line 532
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 532
      if (buflen) {
#line 532
        if (! ((int )*(buf___2 + (buflen - 1U)) == 13)) {
#line 532
          goto while_break___0;
        }
      } else {
#line 532
        goto while_break___0;
      }
      {
#line 534
      pr_signals_handle();
#line 535
      *(buf___2 + (buflen - 1U)) = (char )'\000';
#line 536
      buflen = strlen((char const   *)buf___2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 539
    if (! have_eol) {
      {
#line 540
      pr_log_pri(4, "warning: handling possibly truncated configuration data at line %u of \'%s\'",
                 cs->cs_lineno, (cs->cs_fh)->fh_path);
      }
    }
#line 546
    bufp = buf___2;
    {
#line 546
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 546
      if (*bufp) {
        {
#line 546
        tmp___2 = __ctype_b_loc();
        }
#line 546
        if (! ((int const   )*(*tmp___2 + (int )*bufp) & 8192)) {
#line 546
          goto while_break___1;
        }
      } else {
#line 546
        goto while_break___1;
      }
#line 546
      bufp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 552
    if ((int )*bufp == 35) {
#line 553
      goto while_continue;
    } else
#line 552
    if (! *bufp) {
#line 553
      goto while_continue;
    } else {
#line 560
      buf___2 = bufp;
#line 562
      return (buf___2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return ((char *)((void *)0));
}
}
#line 569 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
server_rec *pr_parser_server_ctxt_close(void) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 570
  if (! parser_curr_server) {
    {
#line 571
    tmp = __errno_location();
#line 571
    *tmp = 2;
    }
#line 572
    return ((server_rec *)((void *)0));
  }
#line 576
  if ((unsigned long )parser_curr_server == (unsigned long )((server_rec **)parser_servstack->elts)) {
    {
#line 577
    tmp___0 = __errno_location();
#line 577
    *tmp___0 = 1;
    }
#line 578
    return ((server_rec *)((void *)0));
  }
#line 581
  parser_curr_server --;
#line 582
  (parser_servstack->nelts) --;
#line 584
  return (*parser_curr_server);
}
}
#line 587 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
server_rec *pr_parser_server_ctxt_get(void) 
{ 
  int *tmp ;

  {
#line 588
  if (parser_curr_server) {
#line 589
    return (*parser_curr_server);
  }
  {
#line 591
  tmp = __errno_location();
#line 591
  *tmp = 2;
  }
#line 592
  return ((server_rec *)((void *)0));
}
}
#line 595 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/parser.c"
server_rec *pr_parser_server_ctxt_open(char const   *addrstr ) 
{ 
  server_rec *s ;
  pool *p ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 599
  p = make_sub_pool(permanent_pool);
#line 600
  pr_pool_tag(p, "<VirtualHost> Pool");
#line 602
  tmp = pcalloc(p, (int )sizeof(server_rec ));
#line 602
  s = (server_rec *)tmp;
#line 603
  s->pool = p;
#line 604
  s->config_type = 1 << 4;
#line 605
  parser_sid ++;
#line 605
  s->sid = parser_sid;
#line 610
  xaset_insert_end(*parser_server_list, (xasetmember_t *)s);
#line 611
  s->set = *parser_server_list;
  }
#line 612
  if (addrstr) {
    {
#line 613
    tmp___0 = pstrdup(s->pool, addrstr);
#line 613
    s->ServerAddress = (char const   *)tmp___0;
    }
  }
  {
#line 617
  tmp___1 = pr_inet_getservport(s->pool, "ftp", "tcp");
#line 617
  s->ServerPort = (unsigned int )tmp___1;
#line 619
  tmp___2 = push_array(parser_servstack);
#line 619
  parser_curr_server = (server_rec **)tmp___2;
#line 620
  *parser_curr_server = s;
  }
#line 622
  return (s);
}
}
#line 43 "../include/child.h"
int child_add(pid_t pid , int fd___0 ) ;
#line 44
unsigned long child_count(void) ;
#line 45
pr_child_t *child_get(pr_child_t *ch ) ;
#line 46
int child_remove(pid_t pid ) ;
#line 47
void child_signal(int signo ) ;
#line 48
void child_update(void) ;
#line 33 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
static pool *child_pool  =    (pool *)((void *)0);
#line 34 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
static xaset_t *child_list  =    (xaset_t *)((void *)0);
#line 35 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
static unsigned long child_listlen  =    0UL;
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
int child_add(pid_t pid , int fd___0 ) 
{ 
  pool *p ;
  pr_child_t *ch ;
  pool *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 42
  if (! child_pool) {
    {
#line 43
    child_pool = make_sub_pool(permanent_pool);
#line 44
    pr_pool_tag(child_pool, "Child Pool");
    }
  }
#line 47
  if (! child_list) {
    {
#line 48
    tmp = make_sub_pool(child_pool);
#line 48
    child_list = xaset_create(tmp, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
  {
#line 50
  p = make_sub_pool(child_pool);
#line 51
  pr_pool_tag(p, "child session pool");
#line 53
  tmp___0 = pcalloc(p, (int )sizeof(pr_child_t ));
#line 53
  ch = (pr_child_t *)tmp___0;
#line 54
  ch->ch_pool = p;
#line 55
  ch->ch_pid = pid;
#line 56
  time(& ch->ch_when);
#line 57
  ch->ch_pipefd = fd___0;
#line 58
  ch->ch_dead = (unsigned char)0;
#line 60
  xaset_insert(child_list, (xasetmember_t *)ch);
#line 61
  child_listlen ++;
  }
#line 63
  return (0);
}
}
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
unsigned long child_count(void) 
{ 


  {
#line 67
  return (child_listlen);
}
}
#line 70 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
pr_child_t *child_get(pr_child_t *ch ) 
{ 


  {
#line 71
  if (! ch) {
#line 72
    return ((pr_child_t *)child_list->xas_list);
  }
#line 74
  return (ch->next);
}
}
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
int child_remove(pid_t pid ) 
{ 
  pr_child_t *ch ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 80
  if (! child_list) {
    {
#line 81
    tmp = __errno_location();
#line 81
    *tmp = 1;
    }
#line 82
    return (-1);
  }
#line 85
  ch = (pr_child_t *)child_list->xas_list;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ch) {
#line 85
      goto while_break;
    }
#line 86
    if (ch->ch_pid == pid) {
#line 87
      ch->ch_dead = (unsigned char)1;
#line 88
      child_listlen --;
#line 89
      return (0);
    }
#line 85
    ch = ch->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  tmp___0 = __errno_location();
#line 93
  *tmp___0 = 2;
  }
#line 94
  return (-1);
}
}
#line 97 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
void child_signal(int signo ) 
{ 
  pr_child_t *ch ;

  {
#line 100
  if (! child_list) {
#line 101
    return;
  }
#line 103
  ch = (pr_child_t *)child_list->xas_list;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ch) {
#line 103
      goto while_break;
    }
    {
#line 104
    kill(ch->ch_pid, signo);
#line 103
    ch = ch->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 110 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/child.c"
void child_update(void) 
{ 
  pr_child_t *ch ;
  pr_child_t *chn ;

  {
#line 111
  chn = (pr_child_t *)((void *)0);
#line 113
  if (! child_list) {
#line 114
    return;
  }
#line 117
  ch = (pr_child_t *)child_list->xas_list;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ch) {
#line 117
      goto while_break;
    }
#line 118
    chn = ch->next;
#line 120
    if (ch->ch_dead) {
#line 121
      if (ch->ch_pipefd != -1) {
        {
#line 122
        close(ch->ch_pipefd);
        }
      }
      {
#line 124
      xaset_remove(child_list, (xasetmember_t *)ch);
#line 125
      destroy_pool(ch->ch_pool);
      }
    }
#line 117
    ch = chn;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if (! child_list->xas_list) {
    {
#line 131
    destroy_pool(child_list->pool);
#line 132
    child_list = (xaset_t *)((void *)0);
    }
  }
#line 135
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 490 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 111 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 115
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 129
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 186
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 200
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 210
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 353 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 284 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 333
extern void setprotoent(int __stay_open ) ;
#line 339
extern void endprotoent(void) ;
#line 352
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 67 "../include/timers.h"
int pr_timer_sleep(int seconds ) ;
#line 135 "../include/inet.h"
void pr_inet_clear(void) ;
#line 139
conn_t *pr_inet_copy_connection(pool *p , conn_t *c ) ;
#line 149
int pr_inet_set_async(pool *p , conn_t *c ) ;
#line 164
void init_inet(void) ;
#line 270 "../include/netaddr.h"
size_t pr_netaddr_get_sockaddr_len(pr_netaddr_t const   *na ) ;
#line 311
int pr_netaddr_set_sockaddr_any(pr_netaddr_t *na ) ;
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static pool *inet_pool  =    (pool *)((void *)0);
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static int ip_proto  =    0;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static int ipv6_proto  =    41;
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static int tcp_proto  =    6;
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static int inet_errno  =    0;
#line 50 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static int inet_family  =    0;
#line 52 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static char const   *trace_channel___10  =    "inet";
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
void pr_inet_clear(void) 
{ 


  {
  {
#line 58
  destroy_pool(inet_pool);
#line 59
  inet_pool = (pool *)((void *)0);
  }
#line 60
  return;
}
}
#line 68 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_set_default_family(pool *p , int family ) 
{ 
  int old_family ;

  {
#line 69
  old_family = inet_family;
#line 70
  inet_family = family;
#line 71
  return (old_family);
}
}
#line 75 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_getservport(pool *p , char const   *serv , char const   *proto ) 
{ 
  struct servent *servent ;
  struct servent *tmp ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 76
  tmp = getservbyname(serv, proto);
#line 76
  servent = tmp;
  }
#line 79
  if (servent) {
    {
#line 79
    tmp___0 = ntohs((uint16_t )servent->s_port);
#line 79
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 79
    tmp___1 = -1;
  }
#line 79
  return (tmp___1);
}
}
#line 82 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static void conn_cleanup_cb(void *cv ) 
{ 
  conn_t *c ;

  {
#line 83
  c = (conn_t *)cv;
#line 89
  if (c->instrm) {
    {
#line 90
    pr_netio_close(c->instrm);
#line 91
    c->instrm = (pr_netio_stream_t *)((void *)0);
    }
  }
#line 94
  if (c->outstrm) {
#line 94
    if ((unsigned long )c->outstrm != (unsigned long )c->instrm) {
      {
#line 95
      pr_netio_close(c->outstrm);
#line 96
      c->outstrm = (pr_netio_stream_t *)((void *)0);
      }
    }
  }
#line 99
  if (c->listen_fd != -1) {
    {
#line 100
    close(c->listen_fd);
#line 101
    c->listen_fd = -1;
    }
  }
#line 104
  if (c->rfd != -1) {
    {
#line 105
    close(c->rfd);
#line 106
    c->rfd = -1;
    }
  }
#line 109
  if (c->wfd != -1) {
    {
#line 110
    close(c->wfd);
#line 111
    c->wfd = -1;
    }
  }
#line 113
  return;
}
}
#line 118 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
conn_t *pr_inet_copy_connection(pool *p , conn_t *c ) 
{ 
  conn_t *res ;
  pool *sub_pool ;
  void *tmp ;
  pr_netio_stream_t *tmp___0 ;
  int tmp___1 ;
  struct sockaddr *tmp___2 ;
  int tmp___3 ;
  struct sockaddr *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp12 ;

  {
  {
#line 119
  res = (conn_t *)((void *)0);
#line 120
  sub_pool = (pool *)((void *)0);
#line 122
  sub_pool = make_sub_pool(p);
#line 123
  pr_pool_tag(sub_pool, "pr_inet_copy_connection() subpool");
#line 125
  tmp = pcalloc(sub_pool, (int )sizeof(conn_t ));
#line 125
  res = (conn_t *)tmp;
#line 127
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)c, (size_t )sizeof(conn_t ));
#line 128
  res->pool = sub_pool;
#line 129
  tmp___0 = (pr_netio_stream_t *)((void *)0);
#line 129
  res->outstrm = tmp___0;
#line 129
  res->instrm = tmp___0;
  }
#line 131
  if (c->local_addr) {
    {
#line 132
    res->local_addr = pr_netaddr_alloc(res->pool);
#line 134
    tmp___1 = pr_netaddr_get_family((pr_netaddr_t const   *)c->local_addr);
#line 134
    pr_netaddr_set_family(res->local_addr, tmp___1);
#line 136
    tmp___2 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)c->local_addr);
#line 136
    pr_netaddr_set_sockaddr(res->local_addr, tmp___2);
    }
  }
#line 140
  if (c->remote_addr) {
    {
#line 141
    res->remote_addr = pr_netaddr_alloc(res->pool);
#line 143
    tmp___3 = pr_netaddr_get_family((pr_netaddr_t const   *)c->remote_addr);
#line 143
    pr_netaddr_set_family(res->remote_addr, tmp___3);
#line 145
    tmp___4 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)c->remote_addr);
#line 145
    pr_netaddr_set_sockaddr(res->remote_addr, tmp___4);
    }
  }
#line 149
  if (c->remote_name) {
    {
#line 150
    tmp___5 = pstrdup(res->pool, c->remote_name);
#line 150
    res->remote_name = (char const   *)tmp___5;
    }
  }
  {
#line 152
  register_cleanup(res->pool, (void *)res, & conn_cleanup_cb, & conn_cleanup_cb);
  }
#line 153
  return (res);
}
}
#line 159 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static conn_t *inet_initialize_connection(pool *p , xaset_t *servers , int fd___0 ,
                                          pr_netaddr_t *bind_addr , int port , int retry_bind ,
                                          int reporting ) 
{ 
  pool *sub_pool ;
  conn_t *c ;
  pr_netaddr_t na ;
  int addr_family ;
  int res ;
  int one ;
  int hold_errno ;
  int *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;
  socklen_t salen ;
  register unsigned int i___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  struct sockaddr *tmp___11 ;
  int level ;
  int off ;
  socklen_t len ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  unsigned char tmp___18 ;
  uint16_t tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  struct sockaddr *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  __uid_t tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  __uid_t tmp___50 ;
  int *tmp___51 ;
  char *tmp___52 ;
  int tmp___53 ;
  int *tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  __uid_t tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int *tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  struct sockaddr *tmp___70 ;
  unsigned int tmp___71 ;
  uint16_t tmp___72 ;
  struct sockaddr *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  char const   *tmp___76 ;
  void *__cil_tmp98 ;
  void *__cil_tmp99 ;
  void *__cil_tmp100 ;
  void *__cil_tmp101 ;
  void *__cil_tmp102 ;
  void *__cil_tmp103 ;
  void *__cil_tmp104 ;
  void *__cil_tmp105 ;
  void *__cil_tmp106 ;
  void *__cil_tmp107 ;
  void *__cil_tmp108 ;
  void *__cil_tmp109 ;
  void *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;

  {
#line 161
  sub_pool = (pool *)((void *)0);
#line 165
  res = 0;
#line 165
  one = 1;
#line 167
  if (! servers) {
#line 167
    goto _L;
  } else
#line 167
  if (! servers->xas_list) {
    _L: /* CIL Label */ 
#line 167
    if (! main_server) {
      {
#line 168
      tmp = __errno_location();
#line 168
      *tmp = 22;
      }
#line 169
      return ((conn_t *)((void *)0));
    }
  }
#line 172
  if (! inet_pool) {
    {
#line 173
    inet_pool = make_sub_pool(permanent_pool);
#line 174
    pr_pool_tag(inet_pool, "Inet Pool");
    }
  }
  {
#line 178
  pr_netaddr_clear(& na);
#line 180
  sub_pool = make_sub_pool(p);
#line 181
  pr_pool_tag(sub_pool, "inet_initialize_connection() subpool");
#line 183
  tmp___0 = pcalloc(sub_pool, (int )sizeof(conn_t ));
#line 183
  c = (conn_t *)tmp___0;
#line 184
  c->pool = sub_pool;
#line 186
  c->local_port = port;
#line 187
  tmp___1 = -1;
#line 187
  c->wfd = tmp___1;
#line 187
  c->rfd = tmp___1;
  }
#line 189
  if (bind_addr) {
    {
#line 190
    addr_family = pr_netaddr_get_family((pr_netaddr_t const   *)bind_addr);
    }
  } else
#line 192
  if (inet_family) {
#line 193
    addr_family = inet_family;
  } else {
    {
#line 201
    tmp___2 = pr_netaddr_use_ipv6();
    }
#line 201
    if (tmp___2) {
#line 202
      addr_family = 10;
    } else {
#line 205
      addr_family = 2;
    }
  }
#line 213
  if (fd___0 == -1) {
    {
#line 215
    i___0 = 0U;
#line 243
    fd___0 = socket(addr_family, 1, tcp_proto);
    }
#line 261
    if (fd___0 == -1) {
      {
#line 264
      tmp___3 = __errno_location();
#line 264
      inet_errno = *tmp___3;
      }
#line 265
      if (reporting) {
        {
#line 266
        tmp___4 = strerror(inet_errno);
#line 266
        pr_log_pri(3, "socket() failed in connection initialization: %s", tmp___4);
        }
      }
      {
#line 268
      destroy_pool(c->pool);
      }
#line 269
      return ((conn_t *)((void *)0));
    }
    {
#line 273
    tmp___7 = setsockopt(fd___0, 1, 2, (void const   *)((void *)(& one)), (socklen_t )sizeof(one));
    }
#line 273
    if (tmp___7 < 0) {
      {
#line 275
      tmp___5 = __errno_location();
#line 275
      tmp___6 = strerror(*tmp___5);
#line 275
      pr_log_pri(5, "error setting SO_REUSEADDR: %s", tmp___6);
      }
    }
    {
#line 279
    tmp___10 = setsockopt(fd___0, 1, 9, (void const   *)((void *)(& one)), (socklen_t )sizeof(one));
    }
#line 279
    if (tmp___10 < 0) {
      {
#line 281
      tmp___8 = __errno_location();
#line 281
      tmp___9 = strerror(*tmp___8);
#line 281
      pr_log_pri(5, "error setting SO_KEEPALIVE: %s", tmp___9);
      }
    }
    {
#line 284
    memset((void *)(& na), 0, (size_t )sizeof(na));
#line 285
    pr_netaddr_set_family(& na, addr_family);
    }
#line 287
    if (bind_addr) {
      {
#line 288
      tmp___11 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)bind_addr);
#line 288
      pr_netaddr_set_sockaddr(& na, tmp___11);
      }
    } else {
      {
#line 291
      pr_netaddr_set_sockaddr_any(& na);
      }
    }
    {
#line 294
    tmp___18 = pr_netaddr_use_ipv6();
    }
#line 294
    if (tmp___18) {
#line 294
      if (addr_family == 10) {
        {
#line 296
        level = ipv6_proto;
#line 298
        len = (socklen_t )sizeof(off);
#line 309
        tmp___17 = getsockopt(fd___0, level, 26, (void */* __restrict  */)((void *)(& off)),
                              (socklen_t */* __restrict  */)(& len));
        }
#line 309
        if (tmp___17 >= 0) {
#line 310
          if (off != 0) {
            {
#line 311
            off = 0;
#line 313
            pr_trace_msg(trace_channel___10, 5, "disabling IPV6_V6ONLY on server socket %d",
                         fd___0);
#line 316
            tmp___14 = setsockopt(fd___0, level, 26, (void const   *)((void *)(& off)),
                                  len);
            }
#line 316
            if (tmp___14 < 0) {
              {
#line 318
              tmp___12 = __errno_location();
#line 318
              tmp___13 = strerror(*tmp___12);
#line 318
              pr_log_pri(5, "error setting IPV6_V6ONLY: %s", tmp___13);
              }
            }
          }
        } else {
          {
#line 324
          tmp___15 = __errno_location();
#line 324
          tmp___16 = strerror(*tmp___15);
#line 324
          pr_trace_msg(trace_channel___10, 3, "error getting IPV6_V6ONLY setting on socket %d: %s",
                       fd___0, tmp___16);
          }
        }
      }
    }
    {
#line 331
    tmp___19 = htons((uint16_t )port);
#line 331
    pr_netaddr_set_port(& na, (unsigned int )tmp___19);
    }
#line 333
    if (port != 0) {
#line 333
      if (port < 1024) {
        {
#line 335
        pr_signals_block();
#line 336
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c",
                     336);
#line 336
        pr_signals_block();
        }
#line 336
        if (! session.disable_id_switching) {
          {
#line 336
          tmp___22 = seteuid((__uid_t )0);
          }
#line 336
          if (tmp___22) {
            {
#line 336
            tmp___20 = __errno_location();
#line 336
            tmp___21 = strerror(*tmp___20);
#line 336
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___21);
            }
          }
          {
#line 336
          tmp___25 = setegid((__gid_t )0);
          }
#line 336
          if (tmp___25) {
            {
#line 336
            tmp___23 = __errno_location();
#line 336
            tmp___24 = strerror(*tmp___23);
#line 336
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___24);
            }
          }
        } else {
          {
#line 336
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 336
        pr_signals_unblock();
        }
      }
    }
#line 345
    i___0 = 10U;
    {
#line 345
    while (1) {
      while_continue: /* CIL Label */ ;
#line 345
      if (! i___0) {
#line 345
        goto while_break;
      }
      {
#line 346
      tmp___26 = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& na));
#line 346
      tmp___27 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 346
      res = bind(fd___0, (struct sockaddr  const  */* __restrict  */)tmp___27, tmp___26);
#line 348
      tmp___28 = __errno_location();
#line 348
      hold_errno = *tmp___28;
      }
#line 350
      if (res == -1) {
        {
#line 350
        tmp___29 = __errno_location();
        }
#line 350
        if (*tmp___29 == 4) {
          {
#line 352
          pr_signals_handle();
#line 353
          i___0 ++;
          }
#line 354
          goto __Cont;
        }
      }
#line 357
      if (res != -1) {
#line 360
        goto while_break;
      } else {
        {
#line 357
        tmp___30 = __errno_location();
        }
#line 357
        if (*tmp___30 != 98) {
#line 360
          goto while_break;
        } else
#line 357
        if (port != 0) {
#line 357
          if (! retry_bind) {
#line 360
            goto while_break;
          }
        }
      }
#line 362
      if (port != 0) {
#line 362
        if (port < 1024) {
          {
#line 364
          pr_signals_block();
          }
#line 364
          if (! session.disable_id_switching) {
            {
#line 364
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c",
                         364);
#line 364
            tmp___34 = geteuid();
            }
#line 364
            if (tmp___34 != 0U) {
              {
#line 364
              tmp___33 = seteuid((__uid_t )0);
              }
#line 364
              if (tmp___33) {
                {
#line 364
                tmp___31 = __errno_location();
#line 364
                tmp___32 = strerror(*tmp___31);
#line 364
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___32);
                }
              }
            }
            {
#line 364
            tmp___37 = setegid(session.gid);
            }
#line 364
            if (tmp___37) {
              {
#line 364
              tmp___35 = __errno_location();
#line 364
              tmp___36 = strerror(*tmp___35);
#line 364
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___36);
              }
            }
            {
#line 364
            tmp___40 = seteuid(session.uid);
            }
#line 364
            if (tmp___40) {
              {
#line 364
              tmp___38 = __errno_location();
#line 364
              tmp___39 = strerror(*tmp___38);
#line 364
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___39);
              }
            }
          } else {
            {
#line 364
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 364
          pr_signals_unblock();
#line 365
          pr_signals_unblock();
          }
        }
      }
      {
#line 368
      pr_timer_sleep(1);
      }
#line 370
      if (port != 0) {
#line 370
        if (port < 1024) {
          {
#line 372
          pr_signals_block();
#line 373
          pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c",
                       373);
#line 373
          pr_signals_block();
          }
#line 373
          if (! session.disable_id_switching) {
            {
#line 373
            tmp___43 = seteuid((__uid_t )0);
            }
#line 373
            if (tmp___43) {
              {
#line 373
              tmp___41 = __errno_location();
#line 373
              tmp___42 = strerror(*tmp___41);
#line 373
              pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___42);
              }
            }
            {
#line 373
            tmp___46 = setegid((__gid_t )0);
            }
#line 373
            if (tmp___46) {
              {
#line 373
              tmp___44 = __errno_location();
#line 373
              tmp___45 = strerror(*tmp___44);
#line 373
              pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___45);
              }
            }
          } else {
            {
#line 373
            pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
            }
          }
          {
#line 373
          pr_signals_unblock();
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 345
      i___0 --;
    }
    while_break: /* CIL Label */ ;
    }
#line 377
    if (res == -1) {
#line 378
      if (port != 0) {
#line 378
        if (port < 1024) {
          {
#line 380
          pr_signals_block();
          }
#line 380
          if (! session.disable_id_switching) {
            {
#line 380
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c",
                         380);
#line 380
            tmp___50 = geteuid();
            }
#line 380
            if (tmp___50 != 0U) {
              {
#line 380
              tmp___49 = seteuid((__uid_t )0);
              }
#line 380
              if (tmp___49) {
                {
#line 380
                tmp___47 = __errno_location();
#line 380
                tmp___48 = strerror(*tmp___47);
#line 380
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___48);
                }
              }
            }
            {
#line 380
            tmp___53 = setegid(session.gid);
            }
#line 380
            if (tmp___53) {
              {
#line 380
              tmp___51 = __errno_location();
#line 380
              tmp___52 = strerror(*tmp___51);
#line 380
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___52);
              }
            }
            {
#line 380
            tmp___56 = seteuid(session.uid);
            }
#line 380
            if (tmp___56) {
              {
#line 380
              tmp___54 = __errno_location();
#line 380
              tmp___55 = strerror(*tmp___54);
#line 380
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___55);
              }
            }
          } else {
            {
#line 380
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 380
          pr_signals_unblock();
#line 381
          pr_signals_unblock();
          }
        }
      }
#line 384
      if (reporting) {
        {
#line 385
        tmp___57 = strerror(hold_errno);
#line 385
        tmp___58 = pr_netaddr_get_ipstr(& na);
#line 385
        pr_log_pri(3, "Failed binding to %s, port %d: %s", tmp___58, port, tmp___57);
#line 387
        pr_log_pri(3, "Check the ServerType directive to ensure you are configured correctly.");
        }
      }
      {
#line 391
      inet_errno = hold_errno;
#line 392
      destroy_pool(c->pool);
#line 393
      close(fd___0);
      }
#line 394
      return ((conn_t *)((void *)0));
    }
#line 397
    if (port != 0) {
#line 397
      if (port < 1024) {
        {
#line 399
        pr_signals_block();
        }
#line 399
        if (! session.disable_id_switching) {
          {
#line 399
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c",
                       399);
#line 399
          tmp___62 = geteuid();
          }
#line 399
          if (tmp___62 != 0U) {
            {
#line 399
            tmp___61 = seteuid((__uid_t )0);
            }
#line 399
            if (tmp___61) {
              {
#line 399
              tmp___59 = __errno_location();
#line 399
              tmp___60 = strerror(*tmp___59);
#line 399
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___60);
              }
            }
          }
          {
#line 399
          tmp___65 = setegid(session.gid);
          }
#line 399
          if (tmp___65) {
            {
#line 399
            tmp___63 = __errno_location();
#line 399
            tmp___64 = strerror(*tmp___63);
#line 399
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___64);
            }
          }
          {
#line 399
          tmp___68 = seteuid(session.uid);
          }
#line 399
          if (tmp___68) {
            {
#line 399
            tmp___66 = __errno_location();
#line 399
            tmp___67 = strerror(*tmp___66);
#line 399
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___67);
            }
          }
        } else {
          {
#line 399
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 399
        pr_signals_unblock();
#line 400
        pr_signals_unblock();
        }
      }
    }
    {
#line 407
    salen = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& na));
#line 408
    tmp___73 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 408
    tmp___74 = getsockname(fd___0, (struct sockaddr */* __restrict  */)tmp___73, (socklen_t */* __restrict  */)(& salen));
    }
#line 408
    if (tmp___74 != -1) {
#line 409
      if (! c->local_addr) {
        {
#line 410
        c->local_addr = pr_netaddr_alloc(c->pool);
        }
      }
      {
#line 412
      tmp___69 = pr_netaddr_get_family((pr_netaddr_t const   *)(& na));
#line 412
      pr_netaddr_set_family(c->local_addr, tmp___69);
#line 413
      tmp___70 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 413
      pr_netaddr_set_sockaddr(c->local_addr, tmp___70);
#line 414
      tmp___71 = pr_netaddr_get_port((pr_netaddr_t const   *)(& na));
#line 414
      tmp___72 = ntohs((uint16_t )tmp___71);
#line 414
      c->local_port = (int )tmp___72;
      }
    }
  } else {
    {
#line 419
    tmp___75 = pr_netaddr_get_family((pr_netaddr_t const   *)(& na));
    }
#line 419
    if (tmp___75 == 0) {
      {
#line 420
      pr_netaddr_set_family(& na, addr_family);
      }
    }
  }
  {
#line 423
  c->listen_fd = fd___0;
#line 424
  register_cleanup(c->pool, (void *)c, & conn_cleanup_cb, & conn_cleanup_cb);
#line 426
  tmp___76 = pr_netaddr_get_ipstr(& na);
#line 426
  pr_trace_msg("binding", 4, "bound address %s, port %d to socket fd %d", tmp___76,
               port, fd___0);
  }
#line 429
  return (c);
}
}
#line 432 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
conn_t *pr_inet_create_connection(pool *p , xaset_t *servers , int fd___0 , pr_netaddr_t *bind_addr ,
                                  int port , int retry_bind ) 
{ 
  conn_t *c ;

  {
  {
#line 434
  c = (conn_t *)((void *)0);
#line 436
  c = inet_initialize_connection(p, servers, fd___0, bind_addr, port, retry_bind,
                                 1);
  }
#line 443
  if (! c) {
    {
#line 444
    end_login(1);
    }
  }
#line 446
  return (c);
}
}
#line 452 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
conn_t *pr_inet_create_connection_portrange(pool *p , xaset_t *servers , pr_netaddr_t *bind_addr ,
                                            int low_port , int high_port ) 
{ 
  int range_len ;
  int i___0 ;
  int *range ;
  int *ports ;
  int attempt ;
  int random_index ;
  conn_t *c ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 457
  c = (conn_t *)((void *)0);
#line 460
  if (! inet_pool) {
    {
#line 461
    inet_pool = make_sub_pool(permanent_pool);
#line 462
    pr_pool_tag(inet_pool, "Inet Pool");
    }
  }
  {
#line 465
  range_len = (high_port - low_port) + 1;
#line 466
  tmp = pcalloc(inet_pool, (int )((unsigned long )range_len * sizeof(int )));
#line 466
  range = (int *)tmp;
#line 467
  tmp___0 = pcalloc(inet_pool, (int )((unsigned long )range_len * sizeof(int )));
#line 467
  ports = (int *)tmp___0;
#line 469
  i___0 = range_len;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    tmp___1 = i___0;
#line 470
    i___0 --;
#line 470
    if (! tmp___1) {
#line 470
      goto while_break;
    }
#line 471
    *(range + i___0) = low_port + i___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  attempt = 3;
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (attempt > 0) {
#line 473
      if (! (! c)) {
#line 473
        goto while_break___0;
      }
    } else {
#line 473
      goto while_break___0;
    }
#line 474
    i___0 = range_len - 1;
    {
#line 474
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 474
      if (i___0 >= 0) {
#line 474
        if (! (! c)) {
#line 474
          goto while_break___1;
        }
      } else {
#line 474
        goto while_break___1;
      }
#line 480
      if (attempt == 3) {
        {
#line 482
        tmp___2 = rand();
#line 482
        random_index = (int )(((1.0 * (double )i___0) * (double )tmp___2) / ((double )2147483647 + 1.0));
#line 488
        *(ports + i___0) = *(range + random_index);
        }
        {
#line 494
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 494
          random_index ++;
#line 494
          if (! (random_index < i___0)) {
#line 494
            goto while_break___2;
          }
#line 495
          *(range + (random_index - 1)) = *(range + random_index);
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 498
      c = inet_initialize_connection(p, servers, -1, bind_addr, *(ports + i___0),
                                     0, 0);
      }
#line 501
      if (! c) {
#line 501
        if (inet_errno != 98) {
          {
#line 502
          tmp___3 = strerror(inet_errno);
#line 502
          pr_log_pri(3, "error initializing connection: %s", tmp___3);
#line 504
          end_login(1);
          }
        }
      }
#line 474
      i___0 --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 473
    attempt --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 509
  return (c);
}
}
#line 512 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
void pr_inet_close(pool *p , conn_t *c ) 
{ 


  {
  {
#line 521
  destroy_pool(c->pool);
  }
#line 522
  return;
}
}
#line 525 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
void pr_inet_lingering_close(pool *p , conn_t *c , long linger ) 
{ 


  {
  {
#line 526
  pr_inet_set_block(p, c);
  }
#line 528
  if (c->outstrm) {
    {
#line 529
    pr_netio_lingering_close(c->outstrm, linger);
    }
  }
#line 534
  if ((unsigned long )c->instrm != (unsigned long )c->outstrm) {
    {
#line 535
    pr_netio_close(c->instrm);
    }
  }
  {
#line 537
  c->outstrm = (pr_netio_stream_t *)((void *)0);
#line 538
  c->instrm = (pr_netio_stream_t *)((void *)0);
#line 540
  destroy_pool(c->pool);
  }
#line 541
  return;
}
}
#line 544 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
void pr_inet_lingering_abort(pool *p , conn_t *c , long linger ) 
{ 


  {
  {
#line 545
  pr_inet_set_block(p, c);
  }
#line 547
  if (c->instrm) {
    {
#line 548
    pr_netio_lingering_abort(c->instrm, linger);
    }
  }
#line 557
  if ((unsigned long )c->outstrm != (unsigned long )c->instrm) {
    {
#line 558
    pr_netio_close(c->outstrm);
    }
  }
  {
#line 560
  c->instrm = (pr_netio_stream_t *)((void *)0);
#line 561
  c->outstrm = (pr_netio_stream_t *)((void *)0);
#line 563
  destroy_pool(c->pool);
  }
#line 564
  return;
}
}
#line 566 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_set_proto_opts(pool *p , conn_t *c , int mss , int nodelay , int lowdelay ,
                           int throughput , int nopush ) 
{ 
  int tos ;
  int ip_level ;
  int tcp_level ;
  unsigned char *no_delay ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 568
  tos = 0;
#line 577
  ip_level = 0;
#line 583
  tcp_level = 6;
#line 593
  tmp = get_param_ptr(main_server->conf, "tcpNoDelay", 0);
#line 593
  no_delay = (unsigned char *)tmp;
  }
#line 596
  if (! no_delay) {
#line 596
    goto _L;
  } else
#line 596
  if ((int )*no_delay == 1) {
    _L: /* CIL Label */ 
#line 598
    if (c->listen_fd != -1) {
      {
#line 599
      tmp___2 = setsockopt(c->listen_fd, tcp_level, 1, (void const   *)((void *)(& nodelay)),
                           (socklen_t )sizeof(nodelay));
      }
#line 599
      if (tmp___2 < 0) {
        {
#line 601
        tmp___0 = __errno_location();
#line 601
        tmp___1 = strerror(*tmp___0);
#line 601
        pr_log_pri(5, "error setting listen fd TCP_NODELAY: %s", tmp___1);
        }
      }
    }
  }
#line 609
  if (c->listen_fd != -1) {
#line 609
    if (mss) {
      {
#line 611
      tmp___5 = setsockopt(c->listen_fd, tcp_level, 2, (void const   *)(& mss), (socklen_t )sizeof(mss));
      }
#line 611
      if (tmp___5 < 0) {
        {
#line 613
        tmp___3 = __errno_location();
#line 613
        tmp___4 = strerror(*tmp___3);
#line 613
        pr_log_pri(5, "error setting listen fd TCP_MAXSEG(%d): %s", mss, tmp___4);
        }
      }
    }
  }
#line 620
  if (lowdelay) {
#line 621
    tos = 16;
  }
#line 625
  if (throughput) {
#line 626
    tos = 8;
  }
  {
#line 634
  tmp___9 = pr_netaddr_get_family((pr_netaddr_t const   *)c->local_addr);
  }
#line 634
  if (tmp___9 == 2) {
#line 635
    if (c->listen_fd != -1) {
      {
#line 636
      tmp___8 = setsockopt(c->listen_fd, ip_level, 1, (void const   *)((void *)(& tos)),
                           (socklen_t )sizeof(tos));
      }
#line 636
      if (tmp___8 < 0) {
        {
#line 638
        tmp___6 = __errno_location();
#line 638
        tmp___7 = strerror(*tmp___6);
#line 638
        pr_log_pri(5, "error setting listen fd IP_TOS: %s", tmp___7);
        }
      }
    }
  }
#line 656
  return (0);
}
}
#line 660 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_set_socket_opts(pool *p , conn_t *c , int rcvbuf , int sndbuf ) 
{ 
  int keepalive ;
  int crcvbuf ;
  int csndbuf ;
  socklen_t len ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 669
  if (c->listen_fd != -1) {
    {
#line 670
    keepalive = 0;
#line 674
    tmp___1 = setsockopt(c->listen_fd, 1, 9, (void const   *)((void *)(& keepalive)),
                         (socklen_t )sizeof(int ));
    }
#line 674
    if (tmp___1 < 0) {
      {
#line 676
      tmp = __errno_location();
#line 676
      tmp___0 = strerror(*tmp);
#line 676
      pr_log_pri(5, "error setting listen fd SO_KEEPALIVE: %s", tmp___0);
      }
    }
    {
#line 679
    len = (socklen_t )sizeof(csndbuf);
#line 680
    getsockopt(c->listen_fd, 1, 7, (void */* __restrict  */)((void *)(& csndbuf)),
               (socklen_t */* __restrict  */)(& len));
    }
#line 682
    if (sndbuf) {
#line 682
      if (sndbuf > csndbuf) {
        {
#line 684
        tmp___4 = setsockopt(c->listen_fd, 1, 7, (void const   *)((void *)(& sndbuf)),
                             (socklen_t )sizeof(sndbuf));
        }
#line 684
        if (tmp___4 < 0) {
          {
#line 686
          tmp___2 = __errno_location();
#line 686
          tmp___3 = strerror(*tmp___2);
#line 686
          pr_log_pri(5, "error setting listen fd SO_SNDBUF: %s", tmp___3);
          }
        }
      }
    }
#line 690
    if (sndbuf) {
#line 690
      c->sndbuf = sndbuf;
    } else {
#line 690
      c->sndbuf = csndbuf;
    }
    {
#line 692
    len = (socklen_t )sizeof(crcvbuf);
#line 693
    getsockopt(c->listen_fd, 1, 8, (void */* __restrict  */)((void *)(& crcvbuf)),
               (socklen_t */* __restrict  */)(& len));
    }
#line 695
    if (rcvbuf) {
#line 695
      if (rcvbuf > crcvbuf) {
        {
#line 697
        tmp___7 = setsockopt(c->listen_fd, 1, 8, (void const   *)((void *)(& rcvbuf)),
                             (socklen_t )sizeof(rcvbuf));
        }
#line 697
        if (tmp___7 < 0) {
          {
#line 699
          tmp___5 = __errno_location();
#line 699
          tmp___6 = strerror(*tmp___5);
#line 699
          pr_log_pri(5, "error setting listen fd SO_RCVFBUF: %s", tmp___6);
          }
        }
      }
    }
#line 703
    if (rcvbuf) {
#line 703
      c->rcvbuf = rcvbuf;
    } else {
#line 703
      c->rcvbuf = crcvbuf;
    }
  }
#line 706
  return (0);
}
}
#line 710 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static void set_oobinline(int fd___0 ) 
{ 
  int on ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 711
  on = 1;
#line 712
  if (fd___0 != -1) {
    {
#line 713
    tmp___1 = setsockopt(fd___0, 1, 10, (void const   *)((void *)(& on)), (socklen_t )sizeof(on));
    }
#line 713
    if (tmp___1 < 0) {
      {
#line 714
      tmp = __errno_location();
#line 714
      tmp___0 = strerror(*tmp);
#line 714
      pr_log_pri(5, "error setting SO_OOBINLINE: %s", tmp___0);
      }
    }
  }
#line 716
  return;
}
}
#line 720 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
static void set_owner(int fd___0 ) 
{ 
  __pid_t tmp ;
  pid_t tmp___0 ;

  {
#line 721
  if (fd___0 != -1) {
#line 722
    if (session.pid) {
#line 722
      tmp___0 = session.pid;
    } else {
      {
#line 722
      tmp = getpid();
#line 722
      tmp___0 = tmp;
      }
    }
    {
#line 722
    fcntl(fd___0, 8, tmp___0);
    }
  }
#line 723
  return;
}
}
#line 728 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_set_async(pool *p , conn_t *c ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 731
  pr_trace_msg(trace_channel___10, 7, "setting SO_OOBINLINE for listening socket %d",
               c->listen_fd);
#line 733
  set_oobinline(c->listen_fd);
#line 735
  pr_trace_msg(trace_channel___10, 7, "setting SO_OOBINLINE for reading socket %d",
               c->rfd);
#line 737
  set_oobinline(c->rfd);
#line 739
  pr_trace_msg(trace_channel___10, 7, "setting SO_OOBINLINE for writing socket %d",
               c->wfd);
#line 741
  set_oobinline(c->wfd);
#line 745
  set_owner(c->listen_fd);
#line 746
  set_owner(c->rfd);
#line 747
  set_owner(c->wfd);
  }
#line 750
  return (0);
}
}
#line 755 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_set_nonblock(pool *p , conn_t *c ) 
{ 
  int flags ;
  int res ;
  int *tmp ;

  {
  {
#line 757
  res = -1;
#line 759
  tmp = __errno_location();
#line 759
  *tmp = 9;
  }
#line 761
  if (c->mode == 1) {
    {
#line 762
    flags = fcntl(c->listen_fd, 3);
#line 763
    res = fcntl(c->listen_fd, 4, flags | 2048);
    }
  } else {
#line 766
    if (c->rfd != -1) {
      {
#line 767
      flags = fcntl(c->rfd, 3);
#line 768
      res = fcntl(c->rfd, 4, flags | 2048);
      }
    }
#line 771
    if (c->wfd != -1) {
      {
#line 772
      flags = fcntl(c->wfd, 3);
#line 773
      res = fcntl(c->wfd, 4, flags | 2048);
      }
    }
  }
#line 777
  return (res);
}
}
#line 780 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_set_block(pool *p , conn_t *c ) 
{ 
  int flags ;
  int res ;
  int *tmp ;

  {
  {
#line 782
  res = -1;
#line 784
  tmp = __errno_location();
#line 784
  *tmp = 9;
  }
#line 786
  if (c->mode == 1) {
    {
#line 787
    flags = fcntl(c->listen_fd, 3);
#line 788
    res = fcntl(c->listen_fd, 4, (unsigned int )flags & 4294965247U);
    }
  } else {
#line 791
    if (c->rfd != -1) {
      {
#line 792
      flags = fcntl(c->rfd, 3);
#line 793
      res = fcntl(c->rfd, 4, (unsigned int )flags & 4294965247U);
      }
    }
#line 796
    if (c->wfd != -1) {
      {
#line 797
      flags = fcntl(c->wfd, 3);
#line 798
      res = fcntl(c->wfd, 4, (unsigned int )flags & 4294965247U);
      }
    }
  }
#line 802
  return (res);
}
}
#line 807 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_listen(pool *p , conn_t *c , int backlog ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;

  {
#line 808
  if (! c) {
#line 809
    return (-1);
  } else
#line 808
  if (c->mode == 1) {
#line 809
    return (-1);
  }
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    tmp___3 = listen(c->listen_fd, backlog);
    }
#line 812
    if (tmp___3 == -1) {
      {
#line 813
      tmp = __errno_location();
      }
#line 813
      if (*tmp == 4) {
        {
#line 814
        pr_signals_handle();
        }
#line 815
        goto while_continue;
      }
      {
#line 818
      tmp___0 = __errno_location();
#line 818
      tmp___1 = strerror(*tmp___0);
#line 818
      tmp___2 = pr_netaddr_get_ipstr(c->local_addr);
#line 818
      pr_log_pri(3, "unable to listen on %s#%u: %s", tmp___2, c->local_port, tmp___1);
#line 820
      end_login(1);
      }
    } else {
#line 823
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 825
  c->mode = 1;
#line 826
  return (0);
}
}
#line 832 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_resetlisten(pool *p , conn_t *c ) 
{ 


  {
  {
#line 833
  c->mode = 1;
#line 834
  pr_inet_set_block(c->pool, c);
  }
#line 835
  return (0);
}
}
#line 838 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_connect(pool *p , conn_t *c , pr_netaddr_t *addr , int port ) 
{ 
  pr_netaddr_t remote_na ;
  int res ;
  uint16_t tmp ;
  size_t tmp___0 ;
  struct sockaddr *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;

  {
  {
#line 840
  res = 0;
#line 842
  pr_inet_set_block(p, c);
#line 848
  memcpy((void */* __restrict  */)(& remote_na), (void const   */* __restrict  */)addr,
         (size_t )sizeof(remote_na));
#line 849
  tmp = htons((uint16_t )port);
#line 849
  pr_netaddr_set_port(& remote_na, (unsigned int )tmp);
#line 851
  c->mode = 4;
  }
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 854
    tmp___0 = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& remote_na));
#line 854
    tmp___1 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& remote_na));
#line 854
    res = connect(c->listen_fd, (struct sockaddr  const  */* __restrict  */)tmp___1,
                  tmp___0);
    }
#line 854
    if (res == -1) {
      {
#line 854
      tmp___2 = __errno_location();
      }
#line 854
      if (*tmp___2 == 4) {
        {
#line 856
        pr_signals_handle();
        }
#line 857
        goto while_continue;
      } else {
#line 860
        goto while_break;
      }
    } else {
#line 860
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  if (res == -1) {
    {
#line 864
    c->mode = 6;
#line 865
    tmp___3 = __errno_location();
#line 865
    c->xerrno = *tmp___3;
    }
#line 866
    return (-1);
  }
  {
#line 869
  c->mode = 2;
#line 871
  tmp___5 = pr_inet_get_conn_info(c, c->listen_fd);
  }
#line 871
  if (tmp___5 < 0) {
    {
#line 872
    tmp___4 = __errno_location();
#line 872
    c->xerrno = *tmp___4;
    }
#line 873
    return (-1);
  }
  {
#line 876
  pr_inet_set_block(c->pool, c);
  }
#line 877
  return (1);
}
}
#line 884 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_connect_nowait(pool *p , conn_t *c , pr_netaddr_t *addr , int port ) 
{ 
  pr_netaddr_t remote_na ;
  uint16_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  struct sockaddr *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;

  {
  {
#line 887
  pr_inet_set_nonblock(p, c);
#line 893
  memcpy((void */* __restrict  */)(& remote_na), (void const   */* __restrict  */)addr,
         (size_t )sizeof(remote_na));
#line 894
  tmp = htons((uint16_t )port);
#line 894
  pr_netaddr_set_port(& remote_na, (unsigned int )tmp);
#line 896
  c->mode = 4;
#line 897
  tmp___3 = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& remote_na));
#line 897
  tmp___4 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& remote_na));
#line 897
  tmp___5 = connect(c->listen_fd, (struct sockaddr  const  */* __restrict  */)tmp___4,
                    tmp___3);
  }
#line 897
  if (tmp___5 == -1) {
    {
#line 899
    tmp___1 = __errno_location();
    }
#line 899
    if (*tmp___1 != 115) {
      {
#line 899
      tmp___2 = __errno_location();
      }
#line 899
      if (*tmp___2 != 114) {
        {
#line 900
        c->mode = 6;
#line 901
        tmp___0 = __errno_location();
#line 901
        c->xerrno = *tmp___0;
        }
#line 902
        return (-1);
      }
    }
#line 905
    return (0);
  }
  {
#line 908
  c->mode = 2;
#line 910
  tmp___7 = pr_inet_get_conn_info(c, c->listen_fd);
  }
#line 910
  if (tmp___7 < 0) {
    {
#line 911
    tmp___6 = __errno_location();
#line 911
    c->xerrno = *tmp___6;
    }
#line 912
    return (-1);
  }
  {
#line 915
  pr_inet_set_block(c->pool, c);
  }
#line 916
  return (1);
}
}
#line 925 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_accept_nowait(pool *p , conn_t *c ) 
{ 
  int fd___0 ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 928
  if (c->mode == 1) {
    {
#line 929
    pr_inet_set_nonblock(c->pool, c);
    }
  }
#line 936
  c->mode = 3;
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 938
    pr_signals_handle();
#line 939
    fd___0 = accept(c->listen_fd, (struct sockaddr */* __restrict  */)((void *)0),
                    (socklen_t */* __restrict  */)((void *)0));
    }
#line 941
    if (fd___0 == -1) {
      {
#line 942
      tmp = __errno_location();
      }
#line 942
      if (*tmp == 4) {
#line 943
        goto while_continue;
      }
      {
#line 945
      tmp___1 = __errno_location();
      }
#line 945
      if (*tmp___1 != 11) {
        {
#line 946
        c->mode = 6;
#line 947
        tmp___0 = __errno_location();
#line 947
        c->xerrno = *tmp___0;
        }
#line 948
        return (-1);
      }
#line 951
      c->mode = 1;
#line 952
      c->xerrno = 0;
#line 953
      return (-1);
    }
#line 956
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 962
  pr_inet_set_block(c->pool, c);
  }
#line 964
  return (fd___0);
}
}
#line 970 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
conn_t *pr_inet_accept(pool *p , conn_t *d , conn_t *c , int rfd , int wfd , unsigned char resolve ) 
{ 
  conn_t *res ;
  unsigned char *allow_foreign_addr ;
  int fd___0 ;
  pr_netaddr_t na ;
  socklen_t nalen ;
  int tmp ;
  xaset_t *tmp___0 ;
  void *tmp___1 ;
  struct sockaddr *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  struct sockaddr *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 972
  res = (conn_t *)((void *)0);
#line 973
  allow_foreign_addr = (unsigned char *)((void *)0);
#line 974
  fd___0 = -1;
#line 980
  pr_netaddr_clear(& na);
#line 982
  tmp = pr_netaddr_get_family((pr_netaddr_t const   *)c->remote_addr);
#line 982
  pr_netaddr_set_family(& na, tmp);
#line 983
  nalen = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& na));
#line 985
  d->mode = 3;
  }
#line 987
  if (session.anon_config) {
#line 987
    tmp___0 = (session.anon_config)->subset;
  } else {
#line 987
    tmp___0 = main_server->conf;
  }
  {
#line 987
  tmp___1 = get_param_ptr(tmp___0, "AllowForeignAddress", 0);
#line 987
  allow_foreign_addr = (unsigned char *)tmp___1;
  }
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 996
    pr_signals_handle();
#line 998
    tmp___2 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 998
    fd___0 = accept(d->listen_fd, (struct sockaddr */* __restrict  */)tmp___2, (socklen_t */* __restrict  */)(& nalen));
    }
#line 999
    if (fd___0 != -1) {
#line 1000
      if (! allow_foreign_addr) {
#line 1000
        goto _L;
      } else
#line 1000
      if ((int )*allow_foreign_addr == 0) {
        _L: /* CIL Label */ 
        {
#line 1000
        tmp___5 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1000
        tmp___6 = getpeername(fd___0, (struct sockaddr */* __restrict  */)tmp___5,
                              (socklen_t */* __restrict  */)(& nalen));
        }
#line 1000
        if (tmp___6 != -1) {
          {
#line 1003
          tmp___4 = pr_netaddr_cmp((pr_netaddr_t const   *)(& na), (pr_netaddr_t const   *)c->remote_addr);
          }
#line 1003
          if (tmp___4 != 0) {
            {
#line 1004
            tmp___3 = pr_netaddr_get_ipstr(& na);
#line 1004
            pr_log_pri(5, "SECURITY VIOLATION: Passive connection from %s rejected.",
                       tmp___3);
#line 1007
            close(fd___0);
            }
#line 1008
            goto while_continue;
          }
        }
      }
      {
#line 1012
      d->mode = 2;
#line 1013
      res = pr_inet_openrw(p, d, (pr_netaddr_t *)((void *)0), 32, fd___0, rfd, wfd,
                           (int )resolve);
      }
    } else {
      {
#line 1017
      tmp___7 = __errno_location();
      }
#line 1017
      if (*tmp___7 == 4) {
#line 1018
        goto while_continue;
      }
      {
#line 1020
      d->mode = 6;
#line 1021
      tmp___8 = __errno_location();
#line 1021
      d->xerrno = *tmp___8;
      }
    }
#line 1024
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1027
  return (res);
}
}
#line 1030 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
int pr_inet_get_conn_info(conn_t *c , int fd___0 ) 
{ 
  pr_netaddr_t na ;
  socklen_t nalen ;
  int *tmp ;
  unsigned char tmp___0 ;
  struct sockaddr *tmp___1 ;
  struct sockaddr *tmp___2 ;
  unsigned int tmp___3 ;
  uint16_t tmp___4 ;
  struct sockaddr *tmp___5 ;
  int tmp___6 ;
  unsigned char tmp___7 ;
  struct sockaddr *tmp___8 ;
  struct sockaddr *tmp___9 ;
  unsigned int tmp___10 ;
  uint16_t tmp___11 ;
  struct sockaddr *tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;

  {
#line 1035
  if (fd___0 < 0) {
    {
#line 1036
    tmp = __errno_location();
#line 1036
    *tmp = 9;
    }
#line 1037
    return (-1);
  }
  {
#line 1041
  pr_netaddr_clear(& na);
#line 1044
  tmp___0 = pr_netaddr_use_ipv6();
  }
#line 1044
  if (tmp___0) {
    {
#line 1045
    pr_netaddr_set_family(& na, 10);
    }
  } else {
    {
#line 1048
    pr_netaddr_set_family(& na, 2);
    }
  }
  {
#line 1052
  nalen = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& na));
#line 1054
  tmp___5 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1054
  tmp___6 = getsockname(fd___0, (struct sockaddr */* __restrict  */)tmp___5, (socklen_t */* __restrict  */)(& nalen));
  }
#line 1054
  if (tmp___6 != -1) {
#line 1055
    if (! c->local_addr) {
      {
#line 1056
      c->local_addr = pr_netaddr_alloc(c->pool);
      }
    }
    {
#line 1063
    tmp___1 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1063
    pr_netaddr_set_family(c->local_addr, (int )tmp___1->sa_family);
#line 1065
    tmp___2 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1065
    pr_netaddr_set_sockaddr(c->local_addr, tmp___2);
#line 1066
    tmp___3 = pr_netaddr_get_port((pr_netaddr_t const   *)(& na));
#line 1066
    tmp___4 = ntohs((uint16_t )tmp___3);
#line 1066
    c->local_port = (int )tmp___4;
    }
  } else {
#line 1069
    return (-1);
  }
  {
#line 1073
  tmp___7 = pr_netaddr_use_ipv6();
  }
#line 1073
  if (tmp___7) {
    {
#line 1074
    pr_netaddr_set_family(& na, 10);
    }
  } else {
    {
#line 1077
    pr_netaddr_set_family(& na, 2);
    }
  }
  {
#line 1081
  nalen = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)(& na));
#line 1083
  tmp___12 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1083
  tmp___13 = getpeername(fd___0, (struct sockaddr */* __restrict  */)tmp___12, (socklen_t */* __restrict  */)(& nalen));
  }
#line 1083
  if (tmp___13 != -1) {
    {
#line 1084
    c->remote_addr = pr_netaddr_alloc(c->pool);
#line 1086
    tmp___8 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1086
    pr_netaddr_set_family(c->remote_addr, (int )tmp___8->sa_family);
#line 1088
    tmp___9 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(& na));
#line 1088
    pr_netaddr_set_sockaddr(c->remote_addr, tmp___9);
#line 1089
    tmp___10 = pr_netaddr_get_port((pr_netaddr_t const   *)(& na));
#line 1089
    tmp___11 = ntohs((uint16_t )tmp___10);
#line 1089
    c->remote_port = (int )tmp___11;
    }
  } else {
#line 1092
    return (-1);
  }
#line 1094
  return (0);
}
}
#line 1112 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
conn_t *pr_inet_openrw(pool *p , conn_t *c , pr_netaddr_t *addr , int strm_type ,
                       int fd___0 , int rfd , int wfd , int resolve ) 
{ 
  conn_t *res ;
  int close_fd ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 1114
  res = (conn_t *)((void *)0);
#line 1115
  close_fd = 1;
#line 1117
  res = pr_inet_copy_connection(p, c);
#line 1119
  res->listen_fd = -1;
#line 1126
  tmp = pr_inet_get_conn_info(res, fd___0);
  }
#line 1126
  if (tmp < 0) {
    {
#line 1126
    tmp___0 = __errno_location();
    }
#line 1126
    if (*tmp___0 != 9) {
#line 1127
      return ((conn_t *)((void *)0));
    }
  }
#line 1129
  if (addr) {
#line 1130
    if (! res->remote_addr) {
      {
#line 1131
      res->remote_addr = pr_netaddr_alloc(res->pool);
      }
    }
    {
#line 1133
    memcpy((void */* __restrict  */)res->remote_addr, (void const   */* __restrict  */)addr,
           (size_t )sizeof(pr_netaddr_t ));
    }
  }
#line 1136
  if (resolve) {
#line 1136
    if (res->remote_addr) {
      {
#line 1137
      res->remote_name = pr_netaddr_get_dnsstr(res->remote_addr);
      }
    }
  }
#line 1139
  if (! res->remote_name) {
    {
#line 1140
    res->remote_name = pr_netaddr_get_ipstr(res->remote_addr);
    }
  }
#line 1142
  if (fd___0 == -1) {
#line 1142
    if (c->listen_fd != -1) {
#line 1143
      fd___0 = c->listen_fd;
    }
  }
#line 1145
  if (rfd != -1) {
#line 1146
    if (fd___0 != rfd) {
      {
#line 1147
      dup2(fd___0, rfd);
      }
    } else {
#line 1149
      close_fd = 0;
    }
  } else {
    {
#line 1152
    rfd = dup(fd___0);
    }
  }
#line 1154
  if (wfd != -1) {
#line 1155
    if (fd___0 != wfd) {
#line 1156
      if (wfd == 1) {
        {
#line 1157
        fflush(stdout);
        }
      }
      {
#line 1158
      dup2(fd___0, wfd);
      }
    } else {
#line 1161
      close_fd = 0;
    }
  } else {
    {
#line 1164
    wfd = dup(fd___0);
    }
  }
#line 1167
  if (rfd != -1) {
#line 1167
    if (wfd != -1) {
#line 1167
      if (close_fd) {
        {
#line 1168
        close(fd___0);
        }
      }
    }
  }
  {
#line 1170
  res->rfd = rfd;
#line 1171
  res->wfd = wfd;
#line 1173
  res->instrm = pr_netio_open(res->pool, strm_type, res->rfd, 1);
#line 1174
  res->outstrm = pr_netio_open(res->pool, strm_type, res->wfd, 2);
#line 1177
  pr_inet_set_socket_opts(res->pool, res, 0, 0);
#line 1178
  pr_inet_set_block(res->pool, res);
#line 1180
  res->mode = 2;
  }
#line 1199
  return (res);
}
}
#line 1202 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/inet.c"
void init_inet(void) 
{ 
  struct protoent *pr ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1203
  pr = (struct protoent *)((void *)0);
#line 1206
  setprotoent(0);
#line 1209
  pr = getprotobyname("ip");
  }
#line 1210
  if ((unsigned long )pr != (unsigned long )((void *)0)) {
#line 1211
    ip_proto = pr->p_proto;
  }
  {
#line 1214
  pr = getprotobyname("ipv6");
  }
#line 1215
  if ((unsigned long )pr != (unsigned long )((void *)0)) {
#line 1216
    ipv6_proto = pr->p_proto;
  }
  {
#line 1219
  pr = getprotobyname("tcp");
  }
#line 1220
  if ((unsigned long )pr != (unsigned long )((void *)0)) {
#line 1221
    tcp_proto = pr->p_proto;
  }
  {
#line 1224
  endprotoent();
  }
#line 1227
  if (inet_pool) {
    {
#line 1228
    destroy_pool(inet_pool);
    }
  }
  {
#line 1229
  inet_pool = make_sub_pool(permanent_pool);
#line 1230
  pr_pool_tag(inet_pool, "Inet Pool");
  }
#line 1231
  return;
}
}
#line 207 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 352
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 355
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 91 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *hstrerror(int __err_num ) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 149
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 631
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 637
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 640
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 218 "../include/netaddr.h"
pr_netaddr_t *pr_netaddr_dup(pool *p , pr_netaddr_t *na ) ;
#line 342
unsigned int pr_netaddr_get_addrno(pr_netaddr_t const   *na ) ;
#line 368
pr_netaddr_t *pr_netaddr_get_sess_local_addr(void) ;
#line 371
void pr_netaddr_set_sess_addrs(void) ;
#line 374
void pr_netaddr_clear_cache(void) ;
#line 380
void init_netaddr(void) ;
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static pr_netaddr_t sess_local_addr  ;
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static int have_sess_local_addr  =    0;
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static pr_netaddr_t sess_remote_addr  ;
#line 40 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static char sess_remote_name[1024]  ;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static int have_sess_remote_addr  =    0;
#line 44 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static int reverse_dns  =    1;
#line 48 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static int use_ipv6  =    1;
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static pool *netaddr_pool  =    (pool *)((void *)0);
#line 54 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static pr_table_t *netaddr_tab  =    (pr_table_t *)((void *)0);
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static char const   *trace_channel___11  =    "dns";
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static pr_netaddr_t *netaddr_cache_get(pool *p , char const   *name ) 
{ 
  pr_netaddr_t *res ;
  void *v ;
  void *tmp ;
  char const   *tmp___0 ;
  pr_netaddr_t *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 60
  res = (pr_netaddr_t *)((void *)0);
#line 62
  if (netaddr_tab) {
    {
#line 63
    tmp = pr_table_get(netaddr_tab, name, (size_t *)((void *)0));
#line 63
    v = tmp;
    }
#line 64
    if (v) {
      {
#line 65
      res = (pr_netaddr_t *)v;
#line 66
      tmp___0 = pr_netaddr_get_ipstr(res);
#line 66
      pr_trace_msg(trace_channel___11, 4, "using IP address \'%s\' from netaddr cache for name \'%s\'",
                   tmp___0, name);
      }
#line 73
      if (p) {
        {
#line 74
        tmp___1 = pr_netaddr_dup(p, res);
        }
#line 74
        return (tmp___1);
      }
#line 77
      return (res);
    } else {
      {
#line 80
      pr_trace_msg(trace_channel___11, 2, "no IP address found in netaddr cache for name \'%s\'",
                   name);
      }
    }
  }
#line 85
  return ((pr_netaddr_t *)((void *)0));
}
}
#line 88 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static void netaddr_cache_set(char const   *name , pr_netaddr_t *na ) 
{ 
  int count ;
  void *v ;
  pr_netaddr_t *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 89
  if (netaddr_tab) {
    {
#line 90
    count = 0;
#line 91
    v = (void *)0;
#line 94
    tmp = pr_netaddr_dup(netaddr_pool, na);
#line 94
    v = (void *)tmp;
#line 96
    count = pr_table_exists(netaddr_tab, name);
    }
#line 97
    if (count <= 0) {
      {
#line 98
      tmp___4 = pstrdup(netaddr_pool, name);
#line 98
      tmp___5 = pr_table_add(netaddr_tab, (char const   *)tmp___4, v, (size_t )sizeof(pr_netaddr_t *));
      }
#line 98
      if (tmp___5 < 0) {
        {
#line 100
        tmp___0 = __errno_location();
#line 100
        tmp___1 = strerror(*tmp___0);
#line 100
        tmp___2 = pr_netaddr_get_ipstr(na);
#line 100
        pr_trace_msg(trace_channel___11, 3, "error adding IP address \'%s\' for name \'%s\' to the netaddr cache: %s",
                     tmp___2, name, tmp___1);
        }
      } else {
        {
#line 105
        tmp___3 = pr_netaddr_get_ipstr((pr_netaddr_t *)v);
#line 105
        pr_trace_msg(trace_channel___11, 5, "stashed IP address \'%s\' for name \'%s\' in the netaddr cache",
                     tmp___3, name);
        }
      }
    } else {
      {
#line 111
      tmp___9 = pstrdup(netaddr_pool, name);
#line 111
      tmp___10 = pr_table_set(netaddr_tab, (char const   *)tmp___9, v, (size_t )sizeof(pr_netaddr_t *));
      }
#line 111
      if (tmp___10 < 0) {
        {
#line 113
        tmp___6 = __errno_location();
#line 113
        tmp___7 = strerror(*tmp___6);
#line 113
        tmp___8 = pr_netaddr_get_ipstr(na);
#line 113
        pr_trace_msg(trace_channel___11, 3, "error setting IP address \'%s\' for name \'%s\' to the netaddr cache: %s",
                     tmp___8, name, tmp___7);
        }
      }
    }
  }
#line 120
  return;
}
}
#line 299 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
static void *get_v4inaddr(pr_netaddr_t const   *na ) 
{ 
  void *tmp ;

  {
  {
#line 311
  tmp = pr_netaddr_get_inaddr(na);
  }
#line 311
  return ((void *)((char *)tmp + 12));
}
}
#line 317 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
char *pr_netaddr_validate_dns_str(char *buf___2 ) 
{ 
  char *p ;
  int *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 320
  if ((unsigned long )buf___2 == (unsigned long )((void *)0)) {
    {
#line 321
    tmp = __errno_location();
#line 321
    *tmp = 22;
    }
#line 322
    return ((char *)((void *)0));
  }
#line 326
  p = buf___2;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (p) {
#line 326
      if (! *p) {
#line 326
        goto while_break;
      }
    } else {
#line 326
      goto while_break;
    }
    {
#line 329
    tmp___0 = __ctype_b_loc();
    }
#line 329
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8)) {
#line 329
      if ((int )*p != 46) {
#line 329
        if ((int )*p != 45) {
#line 329
          if ((int )*p != 58) {
#line 340
            *p = (char )'_';
          }
        }
      }
    }
#line 326
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (buf___2);
}
}
#line 347 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_set_reverse_dns(int enable ) 
{ 
  int old_enable ;

  {
#line 348
  old_enable = reverse_dns;
#line 349
  reverse_dns = enable;
#line 350
  return (old_enable);
}
}
#line 353 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
pr_netaddr_t *pr_netaddr_alloc(pool *p ) 
{ 
  int *tmp ;
  void *tmp___0 ;

  {
#line 354
  if (! p) {
    {
#line 355
    tmp = __errno_location();
#line 355
    *tmp = 22;
    }
#line 356
    return ((pr_netaddr_t *)((void *)0));
  }
  {
#line 359
  tmp___0 = pcalloc(p, (int )sizeof(pr_netaddr_t ));
  }
#line 359
  return ((pr_netaddr_t *)tmp___0);
}
}
#line 362 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void pr_netaddr_clear(pr_netaddr_t *na ) 
{ 


  {
#line 363
  if (! na) {
#line 364
    return;
  }
  {
#line 366
  memset((void *)na, 0, (size_t )sizeof(pr_netaddr_t ));
  }
#line 367
  return;
}
}
#line 369 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
pr_netaddr_t *pr_netaddr_dup(pool *p , pr_netaddr_t *na ) 
{ 
  pr_netaddr_t *dup_na ;
  int *tmp ;
  int tmp___0 ;
  struct sockaddr *tmp___1 ;

  {
#line 372
  if (! p) {
    {
#line 373
    tmp = __errno_location();
#line 373
    *tmp = 22;
    }
#line 374
    return ((pr_netaddr_t *)((void *)0));
  } else
#line 372
  if (! na) {
    {
#line 373
    tmp = __errno_location();
#line 373
    *tmp = 22;
    }
#line 374
    return ((pr_netaddr_t *)((void *)0));
  }
  {
#line 377
  dup_na = pr_netaddr_alloc(p);
#line 379
  tmp___0 = pr_netaddr_get_family((pr_netaddr_t const   *)na);
#line 379
  pr_netaddr_set_family(dup_na, tmp___0);
#line 380
  tmp___1 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)na);
#line 380
  pr_netaddr_set_sockaddr(dup_na, tmp___1);
  }
#line 382
  if (na->na_have_ipstr) {
    {
#line 383
    sstrncpy(dup_na->na_ipstr, (char const   *)(na->na_ipstr), (size_t )sizeof(dup_na->na_ipstr));
#line 384
    dup_na->na_have_ipstr = 1;
    }
  }
#line 387
  if (na->na_have_dnsstr) {
    {
#line 388
    sstrncpy(dup_na->na_dnsstr, (char const   *)(na->na_dnsstr), (size_t )sizeof(dup_na->na_dnsstr));
#line 389
    dup_na->na_have_dnsstr = 1;
    }
  }
#line 392
  return (dup_na);
}
}
#line 395 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
pr_netaddr_t *pr_netaddr_get_addr(pool *p , char const   *name , array_header **addrs ) 
{ 
  struct sockaddr_in v4 ;
  pr_netaddr_t *na ;
  int res ;
  int *tmp ;
  void *tmp___0 ;
  struct sockaddr_in6 v6 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  struct addrinfo hints ;
  struct addrinfo *info ;
  int gai_res ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  pr_netaddr_t **elt ;
  void *tmp___16 ;
  void *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 399
  na = (pr_netaddr_t *)((void *)0);
#line 402
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 404
    tmp = __errno_location();
#line 404
    *tmp = 22;
    }
#line 405
    return ((pr_netaddr_t *)((void *)0));
  } else
#line 402
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 404
    tmp = __errno_location();
#line 404
    *tmp = 22;
    }
#line 405
    return ((pr_netaddr_t *)((void *)0));
  }
  {
#line 408
  pr_trace_msg(trace_channel___11, 10, "resolving name \'%s\' to IP address", name);
  }
#line 418
  if ((unsigned long )addrs == (unsigned long )((void *)0)) {
    {
#line 419
    na = netaddr_cache_get(p, name);
    }
#line 420
    if (na) {
#line 421
      return (na);
    }
  }
  {
#line 434
  tmp___0 = pcalloc(p, (int )sizeof(pr_netaddr_t ));
#line 434
  na = (pr_netaddr_t *)tmp___0;
  }
#line 437
  if (use_ipv6) {
    {
#line 439
    memset((void *)(& v6), 0, (size_t )sizeof(v6));
#line 440
    v6.sin6_family = (sa_family_t )10;
#line 446
    res = inet_pton(10, (char const   */* __restrict  */)name, (void */* __restrict  */)(& v6.sin6_addr));
    }
#line 447
    if (res > 0) {
      {
#line 448
      pr_netaddr_set_family(na, 10);
#line 449
      pr_netaddr_set_sockaddr(na, (struct sockaddr *)(& v6));
      }
#line 450
      if (addrs) {
#line 451
        *addrs = (array_header *)((void *)0);
      }
      {
#line 453
      tmp___1 = pr_netaddr_get_ipstr(na);
#line 453
      pr_trace_msg(trace_channel___11, 7, "\'%s\' resolved to IPv6 address %s", name,
                   tmp___1);
#line 456
      netaddr_cache_set(name, na);
#line 457
      tmp___2 = pr_netaddr_get_ipstr(na);
#line 457
      netaddr_cache_set(tmp___2, na);
      }
#line 458
      return (na);
    }
  }
  {
#line 463
  memset((void *)(& v4), 0, (size_t )sizeof(v4));
#line 464
  v4.sin_family = (sa_family_t )2;
#line 470
  res = inet_pton(2, (char const   */* __restrict  */)name, (void */* __restrict  */)(& v4.sin_addr));
  }
#line 471
  if (res > 0) {
    {
#line 472
    pr_netaddr_set_family(na, 2);
#line 473
    pr_netaddr_set_sockaddr(na, (struct sockaddr *)(& v4));
    }
#line 474
    if (addrs) {
#line 475
      *addrs = (array_header *)((void *)0);
    }
    {
#line 477
    tmp___3 = pr_netaddr_get_ipstr(na);
#line 477
    pr_trace_msg(trace_channel___11, 7, "\'%s\' resolved to IPv4 address %s", name,
                 tmp___3);
#line 480
    netaddr_cache_set(name, na);
#line 481
    tmp___4 = pr_netaddr_get_ipstr(na);
#line 481
    netaddr_cache_set(tmp___4, na);
    }
#line 482
    return (na);
  } else
#line 484
  if (res == 0) {
    {
#line 493
    info = (struct addrinfo *)((void *)0);
#line 494
    gai_res = 0;
#line 496
    memset((void *)(& hints), 0, (size_t )sizeof(hints));
#line 498
    hints.ai_family = 2;
#line 499
    hints.ai_socktype = 1;
#line 501
    pr_trace_msg(trace_channel___11, 7, "attempting to resolve \'%s\' to IPv4 address via DNS",
                 name);
#line 503
    gai_res = getaddrinfo((char const   */* __restrict  */)name, (char const   */* __restrict  */)((void *)0),
                          (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& info));
    }
#line 504
    if (gai_res != 0) {
#line 505
      if (gai_res != -11) {
        {
#line 506
        tmp___5 = gai_strerror(gai_res);
#line 506
        pr_trace_msg(trace_channel___11, 1, "IPv4 getaddrinfo \'%s\' error: %s", name,
                     tmp___5);
        }
      } else {
        {
#line 510
        tmp___6 = __errno_location();
#line 510
        tmp___7 = strerror(*tmp___6);
#line 510
        tmp___8 = __errno_location();
#line 510
        pr_trace_msg(trace_channel___11, 1, "IPv4 getaddrinfo \'%s\' system error: [%d] %s",
                     name, *tmp___8, tmp___7);
        }
      }
#line 515
      return ((pr_netaddr_t *)((void *)0));
    }
#line 518
    if (info) {
      {
#line 520
      pr_netaddr_set_family(na, info->ai_family);
#line 521
      pr_netaddr_set_sockaddr(na, info->ai_addr);
#line 523
      tmp___9 = pr_netaddr_get_ipstr(na);
      }
#line 523
      if (info->ai_family == 2) {
#line 523
        tmp___10 = "IPv4";
      } else {
#line 523
        tmp___10 = "IPv6";
      }
      {
#line 523
      pr_trace_msg(trace_channel___11, 7, "resolved \'%s\' to %s address %s", name,
                   tmp___10, tmp___9);
#line 527
      netaddr_cache_set(name, na);
#line 528
      tmp___11 = pr_netaddr_get_ipstr(na);
#line 528
      netaddr_cache_set(tmp___11, na);
#line 530
      freeaddrinfo(info);
      }
    }
#line 534
    if (use_ipv6) {
#line 534
      if (addrs) {
        {
#line 546
        gai_res = 0;
#line 548
        memset((void *)(& hints), 0, (size_t )sizeof(hints));
#line 550
        hints.ai_family = 10;
#line 551
        hints.ai_socktype = 1;
#line 553
        pr_trace_msg(trace_channel___11, 7, "attempting to resolve \'%s\' to IPv6 address via DNS",
                     name);
#line 555
        gai_res = getaddrinfo((char const   */* __restrict  */)name, (char const   */* __restrict  */)((void *)0),
                              (struct addrinfo  const  */* __restrict  */)(& hints),
                              (struct addrinfo **/* __restrict  */)(& info));
        }
#line 556
        if (gai_res != 0) {
#line 557
          if (gai_res != -11) {
            {
#line 558
            tmp___12 = gai_strerror(gai_res);
#line 558
            pr_trace_msg(trace_channel___11, 1, "IPv6 getaddrinfo \'%s\' error: %s",
                         name, tmp___12);
            }
          } else {
            {
#line 562
            tmp___13 = __errno_location();
#line 562
            tmp___14 = strerror(*tmp___13);
#line 562
            tmp___15 = __errno_location();
#line 562
            pr_trace_msg(trace_channel___11, 1, "IPv6 getaddrinfo \'%s\' system error: [%d] %s",
                         name, *tmp___15, tmp___14);
            }
          }
#line 567
          return (na);
        }
#line 570
        if (info) {
          {
#line 573
          *addrs = make_array(p, 0U, (size_t )sizeof(pr_netaddr_t *));
#line 574
          tmp___16 = push_array(*addrs);
#line 574
          elt = (pr_netaddr_t **)tmp___16;
#line 576
          tmp___17 = pcalloc(p, (int )sizeof(pr_netaddr_t ));
#line 576
          *elt = (pr_netaddr_t *)tmp___17;
#line 577
          pr_netaddr_set_family(*elt, info->ai_family);
#line 578
          pr_netaddr_set_sockaddr(*elt, info->ai_addr);
#line 580
          tmp___18 = pr_netaddr_get_ipstr(*elt);
          }
#line 580
          if (info->ai_family == 2) {
#line 580
            tmp___19 = "IPv4";
          } else {
#line 580
            tmp___19 = "IPv6";
          }
          {
#line 580
          pr_trace_msg(trace_channel___11, 7, "resolved \'%s\' to %s address %s",
                       name, tmp___19, tmp___18);
#line 584
          freeaddrinfo(info);
          }
        }
      }
    }
#line 589
    return (na);
  }
  {
#line 592
  pr_trace_msg(trace_channel___11, 8, "failed to resolve \'%s\' to an IP address",
               name);
  }
#line 594
  return ((pr_netaddr_t *)((void *)0));
}
}
#line 597 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_get_family(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;

  {
#line 598
  if (! na) {
    {
#line 599
    tmp = __errno_location();
#line 599
    *tmp = 22;
    }
#line 600
    return (-1);
  }
#line 603
  return ((int )na->na_family);
}
}
#line 606 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_set_family(pr_netaddr_t *na , int family ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 607
  if (! na) {
    {
#line 608
    tmp = __errno_location();
#line 608
    *tmp = 22;
    }
#line 609
    return (-1);
  }
  {
#line 614
  if (family == 2) {
#line 614
    goto case_2;
  }
#line 619
  if (family == 10) {
#line 619
    goto case_10;
  }
#line 626
  goto switch_default;
  case_2: /* CIL Label */ 
#line 615
  na->na_addr.v4.sin_family = (sa_family_t )2;
#line 616
  goto switch_break;
  case_10: /* CIL Label */ 
#line 620
  if (use_ipv6) {
#line 621
    na->na_addr.v6.sin6_family = (sa_family_t )10;
#line 622
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 628
  tmp___0 = __errno_location();
#line 628
  *tmp___0 = 97;
  }
#line 632
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 635
  na->na_family = family;
#line 636
  return (0);
}
}
#line 639 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
size_t pr_netaddr_get_sockaddr_len(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 640
  if (! na) {
    {
#line 641
    tmp = __errno_location();
#line 641
    *tmp = 22;
    }
#line 642
    return ((size_t )-1);
  }
  {
#line 645
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 646
  if (tmp___0 == 2) {
#line 646
    goto case_2;
  }
#line 650
  if (tmp___0 == 10) {
#line 650
    goto case_10;
  }
#line 645
  goto switch_break;
  case_2: /* CIL Label */ 
#line 647
  return ((size_t )sizeof(struct sockaddr_in ));
  case_10: /* CIL Label */ 
#line 651
  if (use_ipv6) {
#line 652
    return ((size_t )sizeof(struct sockaddr_in6 ));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 656
  tmp___1 = __errno_location();
#line 656
  *tmp___1 = 1;
  }
#line 657
  return ((size_t )-1);
}
}
#line 660 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
size_t pr_netaddr_get_inaddr_len(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 661
  if (! na) {
    {
#line 662
    tmp = __errno_location();
#line 662
    *tmp = 22;
    }
#line 663
    return ((size_t )-1);
  }
  {
#line 666
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 667
  if (tmp___0 == 2) {
#line 667
    goto case_2;
  }
#line 671
  if (tmp___0 == 10) {
#line 671
    goto case_10;
  }
#line 666
  goto switch_break;
  case_2: /* CIL Label */ 
#line 668
  return ((size_t )sizeof(struct in_addr ));
  case_10: /* CIL Label */ 
#line 672
  if (use_ipv6) {
#line 673
    return ((size_t )sizeof(struct in6_addr ));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 677
  tmp___1 = __errno_location();
#line 677
  *tmp___1 = 1;
  }
#line 678
  return ((size_t )-1);
}
}
#line 681 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
struct sockaddr *pr_netaddr_get_sockaddr(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 682
  if (! na) {
    {
#line 683
    tmp = __errno_location();
#line 683
    *tmp = 22;
    }
#line 684
    return ((struct sockaddr *)((void *)0));
  }
  {
#line 687
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 688
  if (tmp___0 == 2) {
#line 688
    goto case_2;
  }
#line 692
  if (tmp___0 == 10) {
#line 692
    goto case_10;
  }
#line 687
  goto switch_break;
  case_2: /* CIL Label */ 
#line 689
  return ((struct sockaddr *)(& na->na_addr.v4));
  case_10: /* CIL Label */ 
#line 693
  if (use_ipv6) {
#line 694
    return ((struct sockaddr *)(& na->na_addr.v6));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 698
  tmp___1 = __errno_location();
#line 698
  *tmp___1 = 1;
  }
#line 699
  return ((struct sockaddr *)((void *)0));
}
}
#line 702 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_set_sockaddr(pr_netaddr_t *na , struct sockaddr *addr ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 703
  if (! na) {
    {
#line 704
    tmp = __errno_location();
#line 704
    *tmp = 22;
    }
#line 705
    return (-1);
  } else
#line 703
  if (! addr) {
    {
#line 704
    tmp = __errno_location();
#line 704
    *tmp = 22;
    }
#line 705
    return (-1);
  }
  {
#line 708
  memset((void *)(& na->na_addr), 0, (size_t )sizeof(na->na_addr));
  }
  {
#line 710
  if (na->na_family == 2) {
#line 710
    goto case_2;
  }
#line 715
  if (na->na_family == 10) {
#line 715
    goto case_10;
  }
#line 709
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 711
  memcpy((void */* __restrict  */)(& na->na_addr.v4), (void const   */* __restrict  */)addr,
         (size_t )sizeof(struct sockaddr_in ));
  }
#line 712
  return (0);
  case_10: /* CIL Label */ 
#line 716
  if (use_ipv6) {
    {
#line 717
    memcpy((void */* __restrict  */)(& na->na_addr.v6), (void const   */* __restrict  */)addr,
           (size_t )sizeof(struct sockaddr_in6 ));
    }
#line 718
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 723
  tmp___0 = __errno_location();
#line 723
  *tmp___0 = 1;
  }
#line 724
  return (-1);
}
}
#line 727 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_set_sockaddr_any(pr_netaddr_t *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  struct in_addr in4addr_any ;
  int *tmp___1 ;
  void *__cil_tmp6 ;

  {
#line 728
  if (! na) {
    {
#line 729
    tmp = __errno_location();
#line 729
    *tmp = 22;
    }
#line 730
    return (-1);
  }
  {
#line 733
  tmp___0 = pr_netaddr_get_family((pr_netaddr_t const   *)na);
  }
  {
#line 734
  if (tmp___0 == 2) {
#line 734
    goto case_2;
  }
#line 746
  if (tmp___0 == 10) {
#line 746
    goto case_10;
  }
#line 733
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 736
  in4addr_any.s_addr = htonl((in_addr_t )0);
#line 737
  na->na_addr.v4.sin_family = (sa_family_t )2;
#line 741
  memcpy((void */* __restrict  */)(& na->na_addr.v4.sin_addr), (void const   */* __restrict  */)(& in4addr_any),
         (size_t )sizeof(struct in_addr ));
  }
#line 742
  return (0);
  case_10: /* CIL Label */ 
#line 747
  if (use_ipv6) {
    {
#line 748
    na->na_addr.v6.sin6_family = (sa_family_t )10;
#line 752
    memcpy((void */* __restrict  */)(& na->na_addr.v6.sin6_addr), (void const   */* __restrict  */)(& in6addr_any),
           (size_t )sizeof(struct in6_addr ));
    }
#line 753
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 758
  tmp___1 = __errno_location();
#line 758
  *tmp___1 = 1;
  }
#line 759
  return (-1);
}
}
#line 762 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void *pr_netaddr_get_inaddr(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 763
  if (! na) {
    {
#line 764
    tmp = __errno_location();
#line 764
    *tmp = 22;
    }
#line 765
    return ((void *)0);
  }
  {
#line 768
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 769
  if (tmp___0 == 2) {
#line 769
    goto case_2;
  }
#line 773
  if (tmp___0 == 10) {
#line 773
    goto case_10;
  }
#line 768
  goto switch_break;
  case_2: /* CIL Label */ 
#line 770
  return ((void *)(& na->na_addr.v4.sin_addr));
  case_10: /* CIL Label */ 
#line 774
  if (use_ipv6) {
#line 775
    return ((void *)(& na->na_addr.v6.sin6_addr));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 779
  tmp___1 = __errno_location();
#line 779
  *tmp___1 = 1;
  }
#line 780
  return ((void *)0);
}
}
#line 783 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
unsigned int pr_netaddr_get_port(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 784
  if (! na) {
    {
#line 785
    tmp = __errno_location();
#line 785
    *tmp = 22;
    }
#line 786
    return (0U);
  }
  {
#line 789
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 790
  if (tmp___0 == 2) {
#line 790
    goto case_2;
  }
#line 794
  if (tmp___0 == 10) {
#line 794
    goto case_10;
  }
#line 789
  goto switch_break;
  case_2: /* CIL Label */ 
#line 791
  return ((unsigned int )na->na_addr.v4.sin_port);
  case_10: /* CIL Label */ 
#line 795
  if (use_ipv6) {
#line 796
    return ((unsigned int )na->na_addr.v6.sin6_port);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 800
  tmp___1 = __errno_location();
#line 800
  *tmp___1 = 1;
  }
#line 801
  return (0U);
}
}
#line 804 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_set_port(pr_netaddr_t *na , unsigned int port ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 805
  if (! na) {
    {
#line 806
    tmp = __errno_location();
#line 806
    *tmp = 22;
    }
#line 807
    return (-1);
  }
  {
#line 810
  tmp___0 = pr_netaddr_get_family((pr_netaddr_t const   *)na);
  }
  {
#line 811
  if (tmp___0 == 2) {
#line 811
    goto case_2;
  }
#line 816
  if (tmp___0 == 10) {
#line 816
    goto case_10;
  }
#line 810
  goto switch_break;
  case_2: /* CIL Label */ 
#line 812
  na->na_addr.v4.sin_port = (in_port_t )port;
#line 813
  return (0);
  case_10: /* CIL Label */ 
#line 817
  if (use_ipv6) {
#line 818
    na->na_addr.v6.sin6_port = (in_port_t )port;
#line 819
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 824
  tmp___1 = __errno_location();
#line 824
  *tmp___1 = 1;
  }
#line 825
  return (-1);
}
}
#line 828 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_cmp(pr_netaddr_t const   *na1 , pr_netaddr_t const   *na2 ) 
{ 
  pool *tmp_pool ;
  pr_netaddr_t *a ;
  pr_netaddr_t *b ;
  int res ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  unsigned int tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  unsigned int tmp___8 ;
  void *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  int *tmp___21 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 829
  tmp_pool = (pool *)((void *)0);
#line 833
  if (na1) {
#line 833
    if (! na2) {
#line 834
      return (1);
    }
  }
#line 836
  if (! na1) {
#line 836
    if (na2) {
#line 837
      return (-1);
    }
  }
#line 839
  if (! na1) {
#line 839
    if (! na2) {
#line 840
      return (0);
    }
  }
  {
#line 842
  tmp___14 = pr_netaddr_get_family(na1);
#line 842
  tmp___15 = pr_netaddr_get_family(na2);
  }
#line 842
  if (tmp___14 != tmp___15) {
    {
#line 849
    tmp___0 = pr_netaddr_is_v4mappedv6(na1);
    }
#line 849
    if (tmp___0 != 1) {
      {
#line 849
      tmp___1 = pr_netaddr_is_v4mappedv6(na2);
      }
#line 849
      if (tmp___1 != 1) {
        {
#line 851
        tmp = __errno_location();
#line 851
        *tmp = 22;
        }
#line 852
        return (-1);
      }
    }
    {
#line 855
    tmp___13 = pr_netaddr_is_v4mappedv6(na1);
    }
#line 855
    if (tmp___13 == 1) {
      {
#line 856
      tmp_pool = make_sub_pool(permanent_pool);
#line 858
      tmp___2 = pr_netaddr_get_ipstr((pr_netaddr_t *)na1);
#line 858
      pr_trace_msg(trace_channel___11, 5, "addr \'%s\' is an IPv4-mapped IPv6 address",
                   tmp___2);
#line 864
      a = pr_netaddr_alloc(tmp_pool);
#line 865
      pr_netaddr_set_family(a, 2);
#line 866
      tmp___3 = pr_netaddr_get_port(na1);
#line 866
      pr_netaddr_set_port(a, tmp___3);
#line 867
      tmp___4 = get_v4inaddr(na1);
#line 867
      memcpy((void */* __restrict  */)(& a->na_addr.v4.sin_addr), (void const   */* __restrict  */)tmp___4,
             (size_t )sizeof(struct in_addr ));
#line 870
      b = (pr_netaddr_t *)na2;
#line 872
      tmp___5 = pr_netaddr_get_ipstr(a);
#line 872
      tmp___6 = pr_netaddr_get_ipstr(b);
#line 872
      pr_trace_msg(trace_channel___11, 6, "comparing IPv4 address \'%s\' against IPv4-mapped IPv6 address \'%s\'",
                   tmp___6, tmp___5);
      }
    } else {
      {
#line 876
      tmp___12 = pr_netaddr_is_v4mappedv6(na2);
      }
#line 876
      if (tmp___12 == 1) {
        {
#line 877
        tmp_pool = make_sub_pool(permanent_pool);
#line 879
        tmp___7 = pr_netaddr_get_ipstr((pr_netaddr_t *)na2);
#line 879
        pr_trace_msg(trace_channel___11, 5, "addr \'%s\' is an IPv4-mapped IPv6 address",
                     tmp___7);
#line 885
        a = (pr_netaddr_t *)na1;
#line 887
        b = pr_netaddr_alloc(tmp_pool);
#line 888
        pr_netaddr_set_family(b, 2);
#line 889
        tmp___8 = pr_netaddr_get_port(na2);
#line 889
        pr_netaddr_set_port(b, tmp___8);
#line 890
        tmp___9 = get_v4inaddr(na2);
#line 890
        memcpy((void */* __restrict  */)(& b->na_addr.v4.sin_addr), (void const   */* __restrict  */)tmp___9,
               (size_t )sizeof(struct in_addr ));
#line 893
        tmp___10 = pr_netaddr_get_ipstr(b);
#line 893
        tmp___11 = pr_netaddr_get_ipstr(a);
#line 893
        pr_trace_msg(trace_channel___11, 6, "comparing IPv4 address \'%s\' against IPv4-mapped IPv6 address \'%s\'",
                     tmp___11, tmp___10);
        }
      } else {
#line 898
        a = (pr_netaddr_t *)na1;
#line 899
        b = (pr_netaddr_t *)na2;
      }
    }
  } else {
#line 903
    a = (pr_netaddr_t *)na1;
#line 904
    b = (pr_netaddr_t *)na2;
  }
  {
#line 907
  tmp___16 = pr_netaddr_get_family((pr_netaddr_t const   *)a);
  }
  {
#line 908
  if (tmp___16 == 2) {
#line 908
    goto case_2;
  }
#line 925
  if (tmp___16 == 10) {
#line 925
    goto case_10;
  }
#line 907
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 909
  res = memcmp((void const   *)(& a->na_addr.v4.sin_addr), (void const   *)(& b->na_addr.v4.sin_addr),
               (size_t )sizeof(struct in_addr ));
  }
#line 912
  if (res != 0) {
    {
#line 913
    tmp___17 = pr_netaddr_get_ipstr(b);
#line 913
    tmp___18 = pr_netaddr_get_ipstr(a);
#line 913
    pr_trace_msg(trace_channel___11, 4, "addr %s does not match addr %s", tmp___18,
                 tmp___17);
    }
  }
#line 917
  if (tmp_pool) {
    {
#line 918
    destroy_pool(tmp_pool);
#line 919
    tmp_pool = (pool *)((void *)0);
    }
  }
#line 922
  return (res);
  case_10: /* CIL Label */ 
#line 926
  if (use_ipv6) {
    {
#line 927
    res = memcmp((void const   *)(& a->na_addr.v6.sin6_addr), (void const   *)(& b->na_addr.v6.sin6_addr),
                 (size_t )sizeof(struct in6_addr ));
    }
#line 930
    if (res != 0) {
      {
#line 931
      tmp___19 = pr_netaddr_get_ipstr(b);
#line 931
      tmp___20 = pr_netaddr_get_ipstr(a);
#line 931
      pr_trace_msg(trace_channel___11, 4, "addr %s does not match addr %s", tmp___20,
                   tmp___19);
      }
    }
#line 935
    if (tmp_pool) {
      {
#line 936
      destroy_pool(tmp_pool);
#line 937
      tmp_pool = (pool *)((void *)0);
      }
    }
#line 940
    return (res);
  }
  switch_break: /* CIL Label */ ;
  }
#line 945
  if (tmp_pool) {
    {
#line 946
    destroy_pool(tmp_pool);
    }
  }
  {
#line 948
  tmp___21 = __errno_location();
#line 948
  *tmp___21 = 1;
  }
#line 949
  return (-1);
}
}
#line 952 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_ncmp(pr_netaddr_t const   *na1 , pr_netaddr_t const   *na2 , unsigned int bitlen ) 
{ 
  pool *tmp_pool ;
  pr_netaddr_t *a ;
  pr_netaddr_t *b ;
  unsigned int nbytes ;
  unsigned int nbits ;
  unsigned char const   *in1 ;
  unsigned char const   *in2 ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  int res ;
  int tmp___20 ;
  unsigned char mask ;
  unsigned char in1byte ;
  unsigned char in2byte ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 954
  tmp_pool = (pool *)((void *)0);
#line 959
  if (na1) {
#line 959
    if (! na2) {
#line 960
      return (1);
    }
  }
#line 962
  if (! na1) {
#line 962
    if (na2) {
#line 963
      return (-1);
    }
  }
#line 965
  if (! na1) {
#line 965
    if (! na2) {
#line 966
      return (0);
    }
  }
  {
#line 968
  tmp___12 = pr_netaddr_get_family(na1);
#line 968
  tmp___13 = pr_netaddr_get_family(na2);
  }
#line 968
  if (tmp___12 != tmp___13) {
    {
#line 975
    tmp___0 = pr_netaddr_is_v4mappedv6(na1);
    }
#line 975
    if (tmp___0 != 1) {
      {
#line 975
      tmp___1 = pr_netaddr_is_v4mappedv6(na2);
      }
#line 975
      if (tmp___1 != 1) {
        {
#line 977
        tmp = __errno_location();
#line 977
        *tmp = 22;
        }
#line 978
        return (-1);
      }
    }
    {
#line 981
    tmp___11 = pr_netaddr_is_v4mappedv6(na1);
    }
#line 981
    if (tmp___11 == 1) {
      {
#line 982
      tmp_pool = make_sub_pool(permanent_pool);
#line 987
      a = pr_netaddr_alloc(tmp_pool);
#line 988
      pr_netaddr_set_family(a, 2);
#line 989
      tmp___2 = pr_netaddr_get_port(na1);
#line 989
      pr_netaddr_set_port(a, tmp___2);
#line 990
      tmp___3 = get_v4inaddr(na1);
#line 990
      memcpy((void */* __restrict  */)(& a->na_addr.v4.sin_addr), (void const   */* __restrict  */)tmp___3,
             (size_t )sizeof(struct in_addr ));
#line 993
      b = (pr_netaddr_t *)na2;
#line 995
      tmp___4 = pr_netaddr_get_ipstr(a);
#line 995
      tmp___5 = pr_netaddr_get_ipstr(b);
#line 995
      pr_trace_msg(trace_channel___11, 6, "comparing IPv4 address \'%s\' against IPv4-mapped IPv6 address \'%s\'",
                   tmp___5, tmp___4);
      }
    } else {
      {
#line 999
      tmp___10 = pr_netaddr_is_v4mappedv6(na2);
      }
#line 999
      if (tmp___10 == 1) {
        {
#line 1000
        tmp_pool = make_sub_pool(permanent_pool);
#line 1005
        a = (pr_netaddr_t *)na1;
#line 1007
        b = pr_netaddr_alloc(tmp_pool);
#line 1008
        pr_netaddr_set_family(b, 2);
#line 1009
        tmp___6 = pr_netaddr_get_port(na2);
#line 1009
        pr_netaddr_set_port(b, tmp___6);
#line 1010
        tmp___7 = get_v4inaddr(na2);
#line 1010
        memcpy((void */* __restrict  */)(& b->na_addr.v4.sin_addr), (void const   */* __restrict  */)tmp___7,
               (size_t )sizeof(struct in_addr ));
#line 1013
        tmp___8 = pr_netaddr_get_ipstr(b);
#line 1013
        tmp___9 = pr_netaddr_get_ipstr(a);
#line 1013
        pr_trace_msg(trace_channel___11, 6, "comparing IPv4 address \'%s\' against IPv4-mapped IPv6 address \'%s\'",
                     tmp___9, tmp___8);
        }
      } else {
#line 1018
        a = (pr_netaddr_t *)na1;
#line 1019
        b = (pr_netaddr_t *)na2;
      }
    }
  } else {
#line 1023
    a = (pr_netaddr_t *)na1;
#line 1024
    b = (pr_netaddr_t *)na2;
  }
  {
#line 1027
  tmp___14 = pr_netaddr_get_family((pr_netaddr_t const   *)a);
  }
  {
#line 1028
  if (tmp___14 == 2) {
#line 1028
    goto case_2;
  }
#line 1041
  if (tmp___14 == 10) {
#line 1041
    goto case_10;
  }
#line 1056
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1032
  if (bitlen > 32U) {
    {
#line 1033
    tmp___15 = __errno_location();
#line 1033
    *tmp___15 = 22;
    }
#line 1034
    return (-1);
  }
#line 1037
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1042
  if (use_ipv6) {
#line 1046
    if (bitlen > 128U) {
      {
#line 1047
      tmp___16 = __errno_location();
#line 1047
      *tmp___16 = 22;
      }
#line 1048
      return (-1);
    }
#line 1051
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 1057
  tmp___17 = __errno_location();
#line 1057
  *tmp___17 = 1;
  }
#line 1058
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1062
  tmp___18 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)a);
#line 1062
  in1 = (unsigned char const   *)tmp___18;
#line 1063
  tmp___19 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)b);
#line 1063
  in2 = (unsigned char const   *)tmp___19;
#line 1068
  nbytes = bitlen / 8U;
#line 1069
  nbits = bitlen % 8U;
  }
#line 1072
  if (nbytes > 0U) {
    {
#line 1073
    tmp___20 = memcmp((void const   *)in1, (void const   *)in2, nbytes);
#line 1073
    res = tmp___20;
    }
#line 1076
    if (res != 0) {
#line 1077
      if (tmp_pool) {
        {
#line 1078
        destroy_pool(tmp_pool);
        }
      }
#line 1080
      return (res);
    }
  }
#line 1085
  if (nbits > 0U) {
#line 1089
    in1byte = (unsigned char )*(in1 + nbytes);
#line 1090
    in2byte = (unsigned char )*(in2 + nbytes);
#line 1093
    mask = (unsigned char )((255 << (8U - nbits)) & 255);
#line 1095
    if (((int )in1byte & (int )mask) > ((int )in2byte & (int )mask)) {
#line 1096
      if (tmp_pool) {
        {
#line 1097
        destroy_pool(tmp_pool);
        }
      }
#line 1099
      return (1);
    }
#line 1102
    if (((int )in1byte & (int )mask) < ((int )in2byte & (int )mask)) {
#line 1103
      if (tmp_pool) {
        {
#line 1104
        destroy_pool(tmp_pool);
        }
      }
#line 1106
      return (-1);
    }
  }
#line 1110
  if (tmp_pool) {
    {
#line 1111
    destroy_pool(tmp_pool);
    }
  }
#line 1116
  return (0);
}
}
#line 1119 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_fnmatch(pr_netaddr_t *na , char const   *pattern , int flags ) 
{ 
  int match_flags ;
  int *tmp ;
  char const   *dnsstr ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *ipstr ;
  char const   *tmp___2 ;
  int tmp___3 ;
  pool *tmp_pool ;
  pr_netaddr_t *a ;
  unsigned int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 1128
  match_flags = (1 << 1) | (1 << 4);
#line 1130
  if (! na) {
    {
#line 1131
    tmp = __errno_location();
#line 1131
    *tmp = 22;
    }
#line 1132
    return (-1);
  } else
#line 1130
  if (! pattern) {
    {
#line 1131
    tmp = __errno_location();
#line 1131
    *tmp = 22;
    }
#line 1132
    return (-1);
  }
#line 1135
  if (flags & 1) {
    {
#line 1136
    tmp___0 = pr_netaddr_get_dnsstr(na);
#line 1136
    dnsstr = tmp___0;
#line 1138
    tmp___1 = pr_fnmatch(pattern, dnsstr, match_flags);
    }
#line 1138
    if (tmp___1 == 0) {
      {
#line 1139
      pr_trace_msg(trace_channel___11, 6, "DNS name \'%s\' matches pattern \'%s\'",
                   dnsstr, pattern);
      }
#line 1141
      return (1);
    }
  }
#line 1145
  if (flags & 2) {
    {
#line 1146
    tmp___2 = pr_netaddr_get_ipstr(na);
#line 1146
    ipstr = tmp___2;
#line 1148
    tmp___3 = pr_fnmatch(pattern, ipstr, match_flags);
    }
#line 1148
    if (tmp___3 == 0) {
      {
#line 1149
      pr_trace_msg(trace_channel___11, 6, "DNS name \'%s\' matches pattern \'%s\'",
                   ipstr, pattern);
      }
#line 1151
      return (1);
    }
    {
#line 1157
    tmp___7 = pr_netaddr_is_v4mappedv6((pr_netaddr_t const   *)na);
    }
#line 1157
    if (tmp___7 == 1) {
      {
#line 1161
      pr_trace_msg(trace_channel___11, 5, "addr \'%s\' is an IPv4-mapped IPv6 address",
                   ipstr);
#line 1164
      tmp_pool = make_sub_pool(permanent_pool);
#line 1165
      a = pr_netaddr_alloc(tmp_pool);
#line 1166
      pr_netaddr_set_family(a, 2);
#line 1167
      tmp___4 = pr_netaddr_get_port((pr_netaddr_t const   *)na);
#line 1167
      pr_netaddr_set_port(a, tmp___4);
#line 1168
      tmp___5 = get_v4inaddr((pr_netaddr_t const   *)na);
#line 1168
      memcpy((void */* __restrict  */)(& a->na_addr.v4.sin_addr), (void const   */* __restrict  */)tmp___5,
             (size_t )sizeof(struct in_addr ));
#line 1171
      ipstr = pr_netaddr_get_ipstr(a);
#line 1173
      tmp___6 = pr_fnmatch(pattern, ipstr, match_flags);
      }
#line 1173
      if (tmp___6 == 0) {
        {
#line 1174
        pr_trace_msg(trace_channel___11, 6, "DNS name \'%s\' matches pattern \'%s\'",
                     ipstr, pattern);
#line 1177
        destroy_pool(tmp_pool);
        }
#line 1178
        return (1);
      }
      {
#line 1181
      destroy_pool(tmp_pool);
      }
    }
  }
  {
#line 1185
  tmp___8 = pr_netaddr_get_ipstr(na);
#line 1185
  pr_trace_msg(trace_channel___11, 4, "addr %s does not match pattern \'%s\'", tmp___8,
               pattern);
  }
#line 1187
  return (0);
}
}
#line 1190 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
char const   *pr_netaddr_get_ipstr(pr_netaddr_t *na ) 
{ 
  char buf___2[46] ;
  int res ;
  int *tmp ;
  size_t tmp___0 ;
  struct sockaddr *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1196
  res = 0;
#line 1198
  if (! na) {
    {
#line 1199
    tmp = __errno_location();
#line 1199
    *tmp = 22;
    }
#line 1200
    return ((char const   *)((void *)0));
  }
#line 1206
  if (na->na_have_ipstr) {
#line 1207
    return ((char const   *)(na->na_ipstr));
  }
  {
#line 1209
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 1210
  tmp___0 = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)na);
#line 1210
  tmp___1 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)na);
#line 1210
  res = getnameinfo((struct sockaddr  const  */* __restrict  */)tmp___1, tmp___0,
                    (char */* __restrict  */)(buf___2), (socklen_t )sizeof(buf___2),
                    (char */* __restrict  */)((void *)0), (socklen_t )0, 1U);
  }
#line 1213
  if (res != 0) {
#line 1214
    if (res != -11) {
      {
#line 1215
      tmp___2 = gai_strerror(res);
#line 1215
      pr_log_pri(6, "getnameinfo error: %s", tmp___2);
      }
    } else {
      {
#line 1218
      tmp___3 = __errno_location();
#line 1218
      tmp___4 = strerror(*tmp___3);
#line 1218
      tmp___5 = __errno_location();
#line 1218
      pr_log_pri(6, "getnameinfo system error: [%d] %s", *tmp___5, tmp___4);
      }
    }
#line 1222
    return ((char const   *)((void *)0));
  }
  {
#line 1228
  memset((void *)(na->na_ipstr), '\000', (size_t )sizeof(na->na_ipstr));
#line 1229
  sstrncpy(na->na_ipstr, (char const   *)(buf___2), (size_t )sizeof(na->na_ipstr));
#line 1230
  na->na_have_ipstr = 1;
  }
#line 1232
  return ((char const   *)(na->na_ipstr));
}
}
#line 1239 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
char const   *pr_netaddr_get_dnsstr(pr_netaddr_t *na ) 
{ 
  char *name ;
  char buf___2[256] ;
  pr_netaddr_t *cache ;
  int *tmp ;
  char const   *tmp___0 ;
  int res ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  struct sockaddr *tmp___3 ;
  char **checkaddr ;
  struct hostent *hent ;
  unsigned char ok ;
  int family ;
  int tmp___4 ;
  void *inaddr ;
  void *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char **alias ;
  int tmp___8 ;
  char **alias___0 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 1240
  name = (char *)((void *)0);
#line 1242
  cache = (pr_netaddr_t *)((void *)0);
#line 1244
  if (! na) {
    {
#line 1245
    tmp = __errno_location();
#line 1245
    *tmp = 22;
    }
#line 1246
    return ((char const   *)((void *)0));
  }
  {
#line 1249
  tmp___0 = pr_netaddr_get_ipstr(na);
#line 1249
  cache = netaddr_cache_get((pool *)((void *)0), tmp___0);
  }
#line 1250
  if (cache) {
#line 1250
    if (cache->na_have_dnsstr) {
      {
#line 1252
      memset((void *)(na->na_dnsstr), '\000', (size_t )sizeof(na->na_dnsstr));
#line 1253
      sstrncpy(na->na_dnsstr, (char const   *)(cache->na_dnsstr), (size_t )sizeof(na->na_dnsstr));
#line 1254
      na->na_have_dnsstr = 1;
      }
#line 1256
      return ((char const   *)(na->na_dnsstr));
    }
  }
#line 1262
  if (na->na_have_dnsstr) {
#line 1263
    return ((char const   *)(na->na_dnsstr));
  }
#line 1265
  if (reverse_dns) {
    {
#line 1266
    res = 0;
#line 1268
    tmp___1 = pr_netaddr_get_ipstr(na);
#line 1268
    pr_trace_msg(trace_channel___11, 3, "verifying DNS name for IP address %s via reverse DNS lookup",
                 tmp___1);
#line 1272
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 1273
    tmp___2 = pr_netaddr_get_sockaddr_len((pr_netaddr_t const   *)na);
#line 1273
    tmp___3 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)na);
#line 1273
    res = getnameinfo((struct sockaddr  const  */* __restrict  */)tmp___3, tmp___2,
                      (char */* __restrict  */)(buf___2), (socklen_t )sizeof(buf___2),
                      (char */* __restrict  */)((void *)0), (socklen_t )0, 8U);
#line 1275
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
    }
#line 1277
    if (res == 0) {
      {
#line 1279
      hent = (struct hostent *)((void *)0);
#line 1280
      ok = (unsigned char)0;
#line 1281
      tmp___4 = pr_netaddr_get_family((pr_netaddr_t const   *)na);
#line 1281
      family = tmp___4;
#line 1282
      tmp___5 = pr_netaddr_get_inaddr((pr_netaddr_t const   *)na);
#line 1282
      inaddr = tmp___5;
#line 1285
      tmp___6 = pr_netaddr_is_v4mappedv6((pr_netaddr_t const   *)na);
      }
#line 1285
      if (tmp___6 == 1) {
        {
#line 1286
        family = 2;
#line 1287
        inaddr = get_v4inaddr((pr_netaddr_t const   *)na);
        }
      }
      {
#line 1290
      hent = gethostbyname2((char const   *)(buf___2), family);
      }
#line 1295
      if ((unsigned long )hent != (unsigned long )((void *)0)) {
#line 1297
        if (hent->h_name) {
#line 1297
          tmp___7 = (char const   *)hent->h_name;
        } else {
#line 1297
          tmp___7 = "(null)";
        }
        {
#line 1297
        pr_trace_msg(trace_channel___11, 10, "checking addresses associated with host \'%s\'",
                     tmp___7);
        }
        {
#line 1302
        if (hent->h_addrtype == 2) {
#line 1302
          goto case_2;
        }
#line 1325
        if (hent->h_addrtype == 10) {
#line 1325
          goto case_10;
        }
#line 1301
        goto switch_break;
        case_2: /* CIL Label */ 
#line 1303
        if (family == 2) {
#line 1305
          checkaddr = hent->h_addr_list;
          {
#line 1305
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1305
            if (! *checkaddr) {
#line 1305
              goto while_break;
            }
            {
#line 1306
            tmp___8 = memcmp((void const   *)*checkaddr, (void const   *)inaddr, (size_t )hent->h_length);
            }
#line 1306
            if (tmp___8 == 0) {
#line 1309
              alias = hent->h_aliases;
              {
#line 1309
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 1309
                if (! *alias) {
#line 1309
                  goto while_break___0;
                }
#line 1310
                if (hent->h_name) {
                  {
#line 1311
                  pr_trace_msg(trace_channel___11, 10, "host \'%s\' has alias \'%s\'",
                               hent->h_name, *alias);
#line 1313
                  netaddr_cache_set((char const   *)*alias, na);
                  }
                }
#line 1309
                alias ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 1317
              ok = (unsigned char)1;
#line 1318
              goto while_break;
            }
#line 1305
            checkaddr ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 1322
        goto switch_break;
        case_10: /* CIL Label */ 
#line 1326
        if (use_ipv6) {
#line 1326
          if (family == 10) {
#line 1328
            checkaddr = hent->h_addr_list;
            {
#line 1328
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1328
              if (! *checkaddr) {
#line 1328
                goto while_break___1;
              }
              {
#line 1329
              tmp___9 = memcmp((void const   *)*checkaddr, (void const   *)inaddr,
                               (size_t )hent->h_length);
              }
#line 1329
              if (tmp___9 == 0) {
#line 1332
                alias___0 = hent->h_aliases;
                {
#line 1332
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 1332
                  if (! *alias___0) {
#line 1332
                    goto while_break___2;
                  }
#line 1333
                  if (hent->h_name) {
                    {
#line 1334
                    pr_trace_msg(trace_channel___11, 10, "host \'%s\' has alias \'%s\'",
                                 hent->h_name, *alias___0);
#line 1336
                    netaddr_cache_set((char const   *)*alias___0, na);
                    }
                  }
#line 1332
                  alias___0 ++;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 1340
                ok = (unsigned char)1;
#line 1341
                goto while_break___1;
              }
#line 1328
              checkaddr ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 1345
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 1349
        if (ok) {
          {
#line 1350
          name = buf___2;
#line 1351
          tmp___10 = pr_netaddr_get_ipstr(na);
#line 1351
          pr_trace_msg(trace_channel___11, 8, "using DNS name \'%s\' for IP address \'%s\'",
                       name, tmp___10);
          }
        } else {
          {
#line 1356
          name = (char *)((void *)0);
#line 1357
          tmp___11 = pr_netaddr_get_ipstr(na);
#line 1357
          pr_trace_msg(trace_channel___11, 8, "unable to verify any DNS names for IP address \'%s\'",
                       tmp___11);
          }
        }
      } else {
        {
#line 1363
        tmp___12 = __errno_location();
#line 1363
        tmp___13 = hstrerror(*tmp___12);
#line 1363
        pr_log_debug(1, "notice: unable to resolve \'%s\': %s", buf___2, tmp___13);
        }
      }
    }
  } else {
    {
#line 1368
    pr_log_debug(10, "UseReverseDNS off, returning IP address instead of DNS name");
    }
  }
#line 1371
  if (name) {
    {
#line 1372
    name = pr_netaddr_validate_dns_str(name);
    }
  } else {
    {
#line 1375
    tmp___14 = pr_netaddr_get_ipstr(na);
#line 1375
    name = (char *)tmp___14;
    }
  }
  {
#line 1381
  memset((void *)(na->na_dnsstr), '\000', (size_t )sizeof(na->na_dnsstr));
#line 1382
  sstrncpy(na->na_dnsstr, (char const   *)name, (size_t )sizeof(na->na_dnsstr));
#line 1383
  na->na_have_dnsstr = 1;
#line 1386
  netaddr_cache_set((char const   *)name, na);
#line 1387
  tmp___15 = pr_netaddr_get_ipstr(na);
#line 1387
  netaddr_cache_set(tmp___15, na);
  }
#line 1389
  return ((char const   *)(na->na_dnsstr));
}
}
#line 1393 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
char const   *pr_netaddr_get_localaddr_str(pool *p ) 
{ 
  char buf___2[256] ;
  unsigned int tmp ;
  struct hostent *host ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1394
  buf___2[0] = (char )'\000';
#line 1394
  tmp = 1U;
  {
#line 1394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1394
    if (tmp >= 256U) {
#line 1394
      goto while_break;
    }
#line 1394
    buf___2[tmp] = (char)0;
#line 1394
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1397
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1398
    tmp___0 = __errno_location();
#line 1398
    *tmp___0 = 22;
    }
#line 1399
    return ((char const   *)((void *)0));
  }
  {
#line 1402
  tmp___5 = gethostname(buf___2, (size_t )(sizeof(buf___2) - 1UL));
  }
#line 1402
  if (tmp___5 != -1) {
    {
#line 1403
    buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 1409
    host = gethostbyname((char const   *)(buf___2));
    }
#line 1411
    if (host) {
      {
#line 1412
      tmp___1 = pstrdup(p, (char const   *)host->h_name);
#line 1412
      tmp___2 = pr_netaddr_validate_dns_str(tmp___1);
      }
#line 1412
      return ((char const   *)tmp___2);
    }
    {
#line 1414
    tmp___3 = pstrdup(p, (char const   *)(buf___2));
#line 1414
    tmp___4 = pr_netaddr_validate_dns_str(tmp___3);
    }
#line 1414
    return ((char const   *)tmp___4);
  }
  {
#line 1417
  tmp___6 = __errno_location();
#line 1417
  tmp___7 = strerror(*tmp___6);
#line 1417
  pr_trace_msg(trace_channel___11, 1, "gethostname(2) error: %s", tmp___7);
  }
#line 1418
  return ((char const   *)((void *)0));
}
}
#line 1421 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_is_loopback(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;
  int tmp___8 ;

  {
#line 1422
  if (! na) {
    {
#line 1423
    tmp = __errno_location();
#line 1423
    *tmp = 22;
    }
#line 1424
    return (-1);
  }
  {
#line 1427
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 1428
  if (tmp___0 == 2) {
#line 1428
    goto case_2;
  }
#line 1433
  if (tmp___0 == 10) {
#line 1433
    goto case_10;
  }
#line 1427
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1429
  tmp___1 = pr_netaddr_get_inaddr(na);
#line 1429
  tmp___2 = ntohl(((struct in_addr *)tmp___1)->s_addr);
  }
#line 1429
  return (((unsigned long )tmp___2 & 4278190080UL) == 2130706432UL);
  case_10: /* CIL Label */ 
  {
#line 1447
  tmp___3 = pr_netaddr_get_inaddr(na);
  }
#line 1447
  if (*((uint32_t const   *)(((struct in6_addr *)tmp___3)->in6_u.u6_addr32) + 0) == 0U) {
    {
#line 1447
    tmp___4 = pr_netaddr_get_inaddr(na);
    }
#line 1447
    if (*((uint32_t const   *)(((struct in6_addr *)tmp___4)->in6_u.u6_addr32) + 1) == 0U) {
      {
#line 1447
      tmp___5 = pr_netaddr_get_inaddr(na);
      }
#line 1447
      if (*((uint32_t const   *)(((struct in6_addr *)tmp___5)->in6_u.u6_addr32) + 2) == 0U) {
        {
#line 1447
        tmp___6 = pr_netaddr_get_inaddr(na);
#line 1447
        tmp___7 = htonl((uint32_t )1);
        }
#line 1447
        if (*((uint32_t const   *)(((struct in6_addr *)tmp___6)->in6_u.u6_addr32) + 3) == (uint32_t const   )tmp___7) {
#line 1447
          tmp___8 = 1;
        } else {
#line 1447
          tmp___8 = 0;
        }
      } else {
#line 1447
        tmp___8 = 0;
      }
    } else {
#line 1447
      tmp___8 = 0;
    }
  } else {
#line 1447
    tmp___8 = 0;
  }
#line 1447
  return (tmp___8);
  switch_break: /* CIL Label */ ;
  }
#line 1453
  return (0);
}
}
#line 1459 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
unsigned int pr_netaddr_get_addrno(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 1460
  if (! na) {
    {
#line 1461
    tmp = __errno_location();
#line 1461
    *tmp = 22;
    }
#line 1462
    return (4294967295U);
  }
  {
#line 1465
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 1466
  if (tmp___0 == 2) {
#line 1466
    goto case_2;
  }
#line 1470
  if (tmp___0 == 10) {
#line 1470
    goto case_10;
  }
#line 1465
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1467
  return ((unsigned int )na->na_addr.v4.sin_addr.s_addr);
  case_10: /* CIL Label */ 
#line 1481
  return (0U);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1487
  tmp___1 = __errno_location();
#line 1487
  *tmp___1 = 1;
  }
#line 1488
  return (4294967295U);
}
}
#line 1491 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
int pr_netaddr_is_v4mappedv6(pr_netaddr_t const   *na ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int res ;
  int *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 1492
  if (! na) {
    {
#line 1493
    tmp = __errno_location();
#line 1493
    *tmp = 22;
    }
#line 1494
    return (-1);
  }
  {
#line 1497
  tmp___0 = pr_netaddr_get_family(na);
  }
  {
#line 1498
  if (tmp___0 == 2) {
#line 1498
    goto case_2;
  }
#line 1505
  if (tmp___0 == 10) {
#line 1505
    goto case_10;
  }
#line 1497
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1501
  tmp___1 = __errno_location();
#line 1501
  *tmp___1 = 22;
  }
#line 1502
  return (-1);
  case_10: /* CIL Label */ 
#line 1508
  if (! use_ipv6) {
    {
#line 1509
    tmp___2 = __errno_location();
#line 1509
    *tmp___2 = 22;
    }
#line 1510
    return (-1);
  }
  {
#line 1517
  tmp___3 = pr_netaddr_get_inaddr(na);
  }
#line 1517
  if (*((uint32_t const   *)(((struct in6_addr *)tmp___3)->in6_u.u6_addr32) + 0) == 0U) {
    {
#line 1517
    tmp___4 = pr_netaddr_get_inaddr(na);
    }
#line 1517
    if (*((uint32_t const   *)(((struct in6_addr *)tmp___4)->in6_u.u6_addr32) + 1) == 0U) {
      {
#line 1517
      tmp___5 = pr_netaddr_get_inaddr(na);
#line 1517
      tmp___6 = htonl((uint32_t )65535);
      }
#line 1517
      if (*((uint32_t const   *)(((struct in6_addr *)tmp___5)->in6_u.u6_addr32) + 2) == (uint32_t const   )tmp___6) {
#line 1517
        tmp___7 = 1;
      } else {
#line 1517
        tmp___7 = 0;
      }
    } else {
#line 1517
      tmp___7 = 0;
    }
  } else {
#line 1517
    tmp___7 = 0;
  }
#line 1517
  res = tmp___7;
#line 1520
  return (res);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1525
  tmp___8 = __errno_location();
#line 1525
  *tmp___8 = 1;
  }
#line 1526
  return (-1);
}
}
#line 1529 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
pr_netaddr_t *pr_netaddr_get_sess_local_addr(void) 
{ 
  int *tmp ;

  {
#line 1530
  if (have_sess_local_addr) {
#line 1531
    return (& sess_local_addr);
  }
  {
#line 1534
  tmp = __errno_location();
#line 1534
  *tmp = 2;
  }
#line 1535
  return ((pr_netaddr_t *)((void *)0));
}
}
#line 1538 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
pr_netaddr_t *pr_netaddr_get_sess_remote_addr(void) 
{ 
  int *tmp ;

  {
#line 1539
  if (have_sess_remote_addr) {
#line 1540
    return (& sess_remote_addr);
  }
  {
#line 1543
  tmp = __errno_location();
#line 1543
  *tmp = 2;
  }
#line 1544
  return ((pr_netaddr_t *)((void *)0));
}
}
#line 1547 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
char const   *pr_netaddr_get_sess_remote_name(void) 
{ 
  int *tmp ;

  {
#line 1548
  if (have_sess_remote_addr) {
#line 1549
    return ((char const   *)(sess_remote_name));
  }
  {
#line 1552
  tmp = __errno_location();
#line 1552
  *tmp = 2;
  }
#line 1553
  return ((char const   *)((void *)0));
}
}
#line 1556 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void pr_netaddr_set_sess_addrs(void) 
{ 
  int tmp ;
  struct sockaddr *tmp___0 ;
  int tmp___1 ;
  struct sockaddr *tmp___2 ;

  {
  {
#line 1557
  tmp = pr_netaddr_get_family((pr_netaddr_t const   *)(session.c)->local_addr);
#line 1557
  pr_netaddr_set_family(& sess_local_addr, tmp);
#line 1559
  tmp___0 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(session.c)->local_addr);
#line 1559
  pr_netaddr_set_sockaddr(& sess_local_addr, tmp___0);
#line 1561
  have_sess_local_addr = 1;
#line 1563
  tmp___1 = pr_netaddr_get_family((pr_netaddr_t const   *)(session.c)->remote_addr);
#line 1563
  pr_netaddr_set_family(& sess_remote_addr, tmp___1);
#line 1565
  tmp___2 = pr_netaddr_get_sockaddr((pr_netaddr_t const   *)(session.c)->remote_addr);
#line 1565
  pr_netaddr_set_sockaddr(& sess_remote_addr, tmp___2);
#line 1568
  memset((void *)(sess_remote_name), '\000', (size_t )sizeof(sess_remote_name));
#line 1569
  sstrncpy(sess_remote_name, (session.c)->remote_name, (size_t )sizeof(sess_remote_name));
#line 1570
  have_sess_remote_addr = 1;
  }
#line 1571
  return;
}
}
#line 1573 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
unsigned char pr_netaddr_use_ipv6(void) 
{ 


  {
#line 1574
  if (use_ipv6) {
#line 1575
    return ((unsigned char)1);
  }
#line 1577
  return ((unsigned char)0);
}
}
#line 1580 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void pr_netaddr_disable_ipv6(void) 
{ 


  {
#line 1582
  use_ipv6 = 0;
#line 1584
  return;
}
}
#line 1586 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void pr_netaddr_enable_ipv6(void) 
{ 


  {
#line 1588
  use_ipv6 = 1;
#line 1590
  return;
}
}
#line 1592 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void pr_netaddr_clear_cache(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 1593
  if (netaddr_tab) {
    {
#line 1594
    pr_trace_msg(trace_channel___11, 5, "emptying netaddr cache");
#line 1595
    pr_table_empty(netaddr_tab);
#line 1596
    pr_table_free(netaddr_tab);
#line 1599
    netaddr_tab = pr_table_alloc(netaddr_pool, 0);
    }
  }
#line 1601
  return;
}
}
#line 1603 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/netaddr.c"
void init_netaddr(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 1604
  if (netaddr_pool) {
    {
#line 1605
    pr_netaddr_clear_cache();
#line 1606
    destroy_pool(netaddr_pool);
#line 1607
    netaddr_pool = (pool *)((void *)0);
    }
  }
  {
#line 1610
  netaddr_pool = make_sub_pool(permanent_pool);
#line 1611
  pr_pool_tag(netaddr_pool, "Netaddr API");
#line 1613
  netaddr_tab = pr_table_alloc(netaddr_pool, 0);
  }
#line 1614
  return;
}
}
#line 557 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) pathconf)(char const   *__path ,
                                                                                      int __name ) ;
#line 561
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 236 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 66 "../include/support.h"
char *dir_interpolate(pool *p , char const   *path ) ;
#line 75
void schedule(void (*f)(void * , void * , void * , void * ) , int nloops , void *a1 ,
              void *a2 , void *a3 , void *a4 ) ;
#line 82
int file_exists(char *path ) ;
#line 83
int dir_exists(char *path ) ;
#line 85
char *make_arg_str(pool *p , int argc , char **argv ) ;
#line 87
char *safe_token(char **s ) ;
#line 88
int check_shutmsg(time_t *shut___0 , time_t *deny___0 , time_t *disc___0 , char *msg ,
                  size_t msg_size ) ;
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static xaset_t *scheds  =    (xaset_t *)((void *)0);
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static sigset_t mask_sigset___0  ;
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static void mask_signals(unsigned char block ) 
{ 


  {
#line 69
  if (block) {
    {
#line 70
    sigemptyset(& mask_sigset___0);
#line 72
    sigaddset(& mask_sigset___0, 15);
#line 73
    sigaddset(& mask_sigset___0, 17);
#line 74
    sigaddset(& mask_sigset___0, 10);
#line 75
    sigaddset(& mask_sigset___0, 2);
#line 76
    sigaddset(& mask_sigset___0, 3);
#line 77
    sigaddset(& mask_sigset___0, 14);
#line 79
    sigaddset(& mask_sigset___0, 29);
#line 82
    sigaddset(& mask_sigset___0, 7);
#line 84
    sigaddset(& mask_sigset___0, 1);
#line 86
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& mask_sigset___0), (sigset_t */* __restrict  */)((void *)0));
    }
  } else {
    {
#line 89
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& mask_sigset___0), (sigset_t */* __restrict  */)((void *)0));
    }
  }
#line 90
  return;
}
}
#line 92 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
void pr_signals_block(void) 
{ 


  {
  {
#line 93
  mask_signals((unsigned char)1);
  }
#line 94
  return;
}
}
#line 96 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
void pr_signals_unblock(void) 
{ 


  {
  {
#line 97
  mask_signals((unsigned char)0);
  }
#line 98
  return;
}
}
#line 100 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
void schedule(void (*f)(void * , void * , void * , void * ) , int nloops , void *a1 ,
              void *a2 , void *a3 , void *a4 ) 
{ 
  pool *p ;
  pool *sub_pool ;
  sched_t *s ;
  void *tmp ;
  char *__cil_tmp11 ;

  {
#line 105
  if (! scheds) {
    {
#line 106
    p = make_sub_pool(permanent_pool);
#line 107
    pr_pool_tag(p, "Schedules Pool");
#line 108
    scheds = xaset_create(p, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  } else {
#line 111
    p = scheds->pool;
  }
  {
#line 113
  sub_pool = make_sub_pool(p);
#line 115
  tmp = pcalloc(sub_pool, (int )sizeof(sched_t ));
#line 115
  s = (sched_t *)tmp;
#line 116
  s->pool = sub_pool;
#line 117
  s->f = f;
#line 118
  s->a1 = a1;
#line 119
  s->a2 = a2;
#line 120
  s->a3 = a3;
#line 121
  s->a4 = a4;
#line 122
  s->loops = nloops;
#line 123
  xaset_insert(scheds, (xasetmember_t *)s);
  }
#line 124
  return;
}
}
#line 126 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
void run_schedule(void) 
{ 
  sched_t *s ;
  sched_t *snext ;
  int tmp ;

  {
#line 129
  if (! scheds) {
#line 130
    return;
  } else
#line 129
  if (! scheds->xas_list) {
#line 130
    return;
  }
#line 132
  s = (sched_t *)scheds->xas_list;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! s) {
#line 132
      goto while_break;
    }
#line 133
    snext = s->next;
#line 135
    tmp = s->loops;
#line 135
    (s->loops) --;
#line 135
    if (tmp <= 0) {
      {
#line 136
      (*(s->f))(s->a1, s->a2, s->a3, s->a4);
#line 137
      xaset_remove(scheds, (xasetmember_t *)s);
#line 138
      destroy_pool(s->pool);
      }
    }
#line 132
    s = snext;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 153 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
int get_name_max(char *dirname , int dir_fd ) 
{ 
  int name_max ;
  char *msgfmt ;
  long tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 154
  name_max = 0;
#line 156
  msgfmt = (char *)"";
#line 159
  if (dir_fd > 0) {
    {
#line 160
    tmp = fpathconf(dir_fd, 3);
#line 160
    name_max = (int )tmp;
#line 161
    msgfmt = (char *)"fpathconf(%s, _PC_NAME_MAX) = %d, errno = %d";
    }
  } else
#line 165
  if ((unsigned long )dirname != (unsigned long )((void *)0)) {
    {
#line 166
    tmp___0 = pathconf((char const   *)dirname, 3);
#line 166
    name_max = (int )tmp___0;
#line 167
    msgfmt = (char *)"pathconf(%s, _PC_NAME_MAX) = %d, errno = %d";
    }
  } else {
#line 171
    return (-1);
  }
#line 173
  if (name_max < 0) {
    {
#line 177
    tmp___1 = __errno_location();
    }
#line 177
    if (dirname) {
#line 177
      tmp___2 = (char const   *)dirname;
    } else {
#line 177
      tmp___2 = "(NULL)";
    }
    {
#line 177
    pr_log_debug(1, (char const   *)msgfmt, tmp___2, name_max, *tmp___1);
    }
  }
#line 184
  return (name_max);
}
}
#line 190 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *dir_interpolate(pool *p , char const   *path ) 
{ 
  struct passwd *pw ;
  char *user ;
  char *tmp ;
  char *ret ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 193
  ret = (char *)path;
#line 195
  if (! ret) {
#line 196
    return ((char *)((void *)0));
  }
#line 198
  if ((int )*ret == 126) {
    {
#line 199
    user = pstrdup(p, (char const   *)(ret + 1));
#line 200
    tmp = strchr((char const   *)user, '/');
    }
#line 202
    if (tmp) {
#line 203
      tmp___0 = tmp;
#line 203
      tmp ++;
#line 203
      *tmp___0 = (char )'\000';
    }
#line 205
    if (! *user) {
#line 206
      user = session.user;
    }
    {
#line 208
    pw = pr_auth_getpwnam(p, (char const   *)user);
    }
#line 210
    if (! pw) {
      {
#line 211
      tmp___1 = __errno_location();
#line 211
      *tmp___1 = 2;
      }
#line 212
      return ((char *)((void *)0));
    }
    {
#line 215
    ret = pdircat(p, pw->pw_dir, tmp, (void *)0);
    }
  }
#line 218
  return (ret);
}
}
#line 224 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *dir_best_path(pool *p , char const   *path ) 
{ 
  char workpath___0[4097] ;
  unsigned int tmp ;
  char realpath_buf[4097] ;
  unsigned int tmp___0 ;
  char *target ;
  char *ntarget ;
  int fini ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 225
  workpath___0[0] = (char )'\000';
#line 225
  tmp = 1U;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (tmp >= 4097U) {
#line 225
      goto while_break;
    }
#line 225
    workpath___0[tmp] = (char)0;
#line 225
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  realpath_buf[0] = (char )'\000';
#line 226
  tmp___0 = 1U;
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (tmp___0 >= 4097U) {
#line 226
      goto while_break___0;
    }
#line 226
    realpath_buf[tmp___0] = (char)0;
#line 226
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 227
  target = (char *)((void *)0);
#line 228
  fini = 0;
#line 230
  if ((int const   )*path == 126) {
    {
#line 231
    tmp___3 = pr_fs_interpolate(path, workpath___0, (size_t )(sizeof(workpath___0) - 1UL));
    }
#line 231
    if (tmp___3 != 1) {
      {
#line 232
      tmp___1 = pr_fs_getcwd();
#line 232
      tmp___2 = pr_fs_dircat(workpath___0, (int )sizeof(workpath___0), tmp___1, path);
      }
#line 232
      if (tmp___2 < 0) {
#line 233
        return ((char *)((void *)0));
      }
    }
  } else {
    {
#line 237
    tmp___4 = pr_fs_getcwd();
#line 237
    tmp___5 = pr_fs_dircat(workpath___0, (int )sizeof(workpath___0), tmp___4, path);
    }
#line 237
    if (tmp___5 < 0) {
#line 238
      return ((char *)((void *)0));
    }
  }
  {
#line 241
  tmp___6 = pstrdup(p, (char const   *)(workpath___0));
#line 241
  pr_fs_clean_path((char const   *)tmp___6, workpath___0, (size_t )(sizeof(workpath___0) - 1UL));
  }
  {
#line 243
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 243
    if (! fini) {
#line 243
      if (! workpath___0[0]) {
#line 243
        goto while_break___1;
      }
    } else {
#line 243
      goto while_break___1;
    }
    {
#line 244
    tmp___7 = pr_fs_resolve_path((char const   *)(workpath___0), realpath_buf, (size_t )(sizeof(realpath_buf) - 1UL),
                                 0);
    }
#line 244
    if (tmp___7 != -1) {
#line 246
      goto while_break___1;
    }
    {
#line 248
    ntarget = strrchr((char const   *)(workpath___0), '/');
    }
#line 249
    if (ntarget) {
#line 250
      if (target) {
        {
#line 251
        tmp___8 = pr_fs_dircat(workpath___0, (int )sizeof(workpath___0), (char const   *)(workpath___0),
                               (char const   *)target);
        }
#line 251
        if (tmp___8 < 0) {
#line 252
          return ((char *)((void *)0));
        }
      }
#line 255
      target = ntarget;
#line 256
      tmp___9 = target;
#line 256
      target ++;
#line 256
      *tmp___9 = (char )'\000';
    } else {
#line 259
      fini ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 262
  if (! fini) {
#line 262
    if (workpath___0[0]) {
#line 263
      if (target) {
        {
#line 264
        tmp___10 = pr_fs_dircat(workpath___0, (int )sizeof(workpath___0), (char const   *)(realpath_buf),
                                (char const   *)target);
        }
#line 264
        if (tmp___10 < 0) {
#line 265
          return ((char *)((void *)0));
        }
      } else {
        {
#line 268
        sstrncpy(workpath___0, (char const   *)(realpath_buf), (size_t )sizeof(workpath___0));
        }
      }
    } else {
#line 262
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 271
    tmp___11 = pr_fs_dircat(workpath___0, (int )sizeof(workpath___0), "/", (char const   *)target);
    }
#line 271
    if (tmp___11 < 0) {
#line 272
      return ((char *)((void *)0));
    }
  }
  {
#line 275
  tmp___12 = pstrdup(p, (char const   *)(workpath___0));
  }
#line 275
  return (tmp___12);
}
}
#line 278 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *dir_canonical_path(pool *p , char const   *path ) 
{ 
  char buf___2[4097] ;
  unsigned int tmp ;
  char work[4097] ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 279
  buf___2[0] = (char )'\000';
#line 279
  tmp = 1U;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (tmp >= 4097U) {
#line 279
      goto while_break;
    }
#line 279
    buf___2[tmp] = (char)0;
#line 279
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  work[0] = (char )'\000';
#line 280
  tmp___0 = 1U;
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (tmp___0 >= 4097U) {
#line 280
      goto while_break___0;
    }
#line 280
    work[tmp___0] = (char)0;
#line 280
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 282
  if ((int const   )*path == 126) {
    {
#line 283
    tmp___3 = pr_fs_interpolate(path, work, (size_t )(sizeof(work) - 1UL));
    }
#line 283
    if (tmp___3 != 1) {
      {
#line 284
      tmp___1 = pr_fs_getcwd();
#line 284
      tmp___2 = pr_fs_dircat(work, (int )sizeof(work), tmp___1, path);
      }
#line 284
      if (tmp___2 < 0) {
#line 285
        return ((char *)((void *)0));
      }
    }
  } else {
    {
#line 289
    tmp___4 = pr_fs_getcwd();
#line 289
    tmp___5 = pr_fs_dircat(work, (int )sizeof(work), tmp___4, path);
    }
#line 289
    if (tmp___5 < 0) {
#line 290
      return ((char *)((void *)0));
    }
  }
  {
#line 293
  pr_fs_clean_path((char const   *)(work), buf___2, (size_t )(sizeof(buf___2) - 1UL));
#line 294
  tmp___6 = pstrdup(p, (char const   *)(buf___2));
  }
#line 294
  return (tmp___6);
}
}
#line 297 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *dir_canonical_vpath(pool *p , char const   *path ) 
{ 
  char buf___2[4097] ;
  unsigned int tmp ;
  char work[4097] ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
#line 298
  buf___2[0] = (char )'\000';
#line 298
  tmp = 1U;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (tmp >= 4097U) {
#line 298
      goto while_break;
    }
#line 298
    buf___2[tmp] = (char)0;
#line 298
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  work[0] = (char )'\000';
#line 299
  tmp___0 = 1U;
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 299
    if (tmp___0 >= 4097U) {
#line 299
      goto while_break___0;
    }
#line 299
    work[tmp___0] = (char)0;
#line 299
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 301
  if ((int const   )*path == 126) {
    {
#line 302
    tmp___3 = pr_fs_interpolate(path, work, (size_t )(sizeof(work) - 1UL));
    }
#line 302
    if (tmp___3 != 1) {
      {
#line 303
      tmp___1 = pr_fs_getvwd();
#line 303
      tmp___2 = pr_fs_dircat(work, (int )sizeof(work), tmp___1, path);
      }
#line 303
      if (tmp___2 < 0) {
#line 304
        return ((char *)((void *)0));
      }
    }
  } else {
    {
#line 308
    tmp___4 = pr_fs_getvwd();
#line 308
    tmp___5 = pr_fs_dircat(work, (int )sizeof(work), tmp___4, path);
    }
#line 308
    if (tmp___5 < 0) {
#line 309
      return ((char *)((void *)0));
    }
  }
  {
#line 312
  pr_fs_clean_path((char const   *)(work), buf___2, (size_t )(sizeof(buf___2) - 1UL));
#line 313
  tmp___6 = pstrdup(p, (char const   *)(buf___2));
  }
#line 313
  return (tmp___6);
}
}
#line 319 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *dir_realpath(pool *p , char const   *path ) 
{ 
  char buf___2[4097] ;
  unsigned int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp7 ;

  {
#line 320
  buf___2[0] = (char )'\000';
#line 320
  tmp = 1U;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (tmp >= 4097U) {
#line 320
      goto while_break;
    }
#line 320
    buf___2[tmp] = (char)0;
#line 320
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  tmp___0 = pr_fs_resolve_partial(path, buf___2, (size_t )(sizeof(buf___2) - 1UL),
                                  0);
  }
#line 322
  if (tmp___0 == -1) {
#line 323
    return ((char *)((void *)0));
  }
  {
#line 325
  tmp___1 = pstrdup(p, (char const   *)(buf___2));
  }
#line 325
  return (tmp___1);
}
}
#line 332 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *dir_abs_path(pool *p , char const   *path , int interpolate ) 
{ 
  char *res ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 333
  res = (char *)((void *)0);
#line 335
  if (interpolate) {
    {
#line 336
    tmp = dir_interpolate(p, path);
#line 336
    path = (char const   *)tmp;
    }
  }
#line 338
  if (! path) {
#line 339
    return ((char *)((void *)0));
  }
#line 341
  if ((int const   )*path != 47) {
#line 342
    if (session.chroot_path) {
      {
#line 343
      tmp___0 = pr_fs_getcwd();
#line 343
      res = pdircat(p, session.chroot_path, tmp___0, path, (void *)0);
      }
    } else {
      {
#line 346
      tmp___1 = pr_fs_getcwd();
#line 346
      res = pdircat(p, tmp___1, path, (void *)0);
      }
    }
  } else
#line 350
  if (session.chroot_path) {
    {
#line 351
    tmp___2 = strlen((char const   *)session.chroot_path);
#line 351
    tmp___3 = strncmp(path, (char const   *)session.chroot_path, tmp___2);
    }
#line 351
    if (tmp___3 != 0) {
      {
#line 353
      res = pdircat(p, session.chroot_path, path, (void *)0);
      }
    } else {
      {
#line 356
      res = pstrdup(p, path);
      }
    }
  } else {
    {
#line 360
    res = pstrdup(p, path);
    }
  }
#line 364
  return (res);
}
}
#line 371 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static mode_t _symlink(char *path , ino_t last_inode , int rcount ) 
{ 
  char buf___2[4097] ;
  struct stat sbuf___0 ;
  int i___0 ;
  int *tmp ;
  int *tmp___0 ;
  mode_t tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 376
  rcount ++;
#line 376
  if (rcount >= 32) {
    {
#line 377
    tmp = __errno_location();
#line 377
    *tmp = 40;
    }
#line 378
    return ((mode_t )0);
  }
  {
#line 381
  memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 383
  i___0 = pr_fsio_readlink((char const   *)path, buf___2, (size_t )(sizeof(buf___2) - 1UL));
  }
#line 384
  if (i___0 == -1) {
#line 385
    return ((mode_t )0);
  }
  {
#line 386
  buf___2[i___0] = (char )'\000';
#line 388
  tmp___2 = pr_fsio_lstat((char const   *)(buf___2), & sbuf___0);
  }
#line 388
  if (tmp___2 != -1) {
#line 389
    if (sbuf___0.st_ino) {
#line 389
      if (sbuf___0.st_ino == last_inode) {
        {
#line 390
        tmp___0 = __errno_location();
#line 390
        *tmp___0 = 40;
        }
#line 391
        return ((mode_t )0);
      }
    }
#line 394
    if ((sbuf___0.st_mode & 61440U) == 40960U) {
      {
#line 395
      tmp___1 = _symlink(buf___2, sbuf___0.st_ino, rcount);
      }
#line 395
      return (tmp___1);
    }
#line 396
    return (sbuf___0.st_mode);
  }
#line 399
  return ((mode_t )0);
}
}
#line 402 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
mode_t file_mode(char *path ) 
{ 
  struct stat sbuf___0 ;
  mode_t res ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 404
  res = (mode_t )0;
#line 406
  pr_fs_clear_cache();
#line 407
  tmp = pr_fsio_lstat((char const   *)path, & sbuf___0);
  }
#line 407
  if (tmp != -1) {
#line 408
    if ((sbuf___0.st_mode & 61440U) == 40960U) {
      {
#line 409
      res = _symlink(path, (ino_t )0, 0);
      }
#line 411
      if (res == 0U) {
#line 413
        res = sbuf___0.st_mode;
      }
    } else {
#line 416
      res = sbuf___0.st_mode;
    }
  }
#line 419
  return (res);
}
}
#line 427 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static int _exists(char *path , int dirp ) 
{ 
  mode_t fmode ;

  {
  {
#line 430
  fmode = file_mode(path);
  }
#line 430
  if (fmode != 0U) {
#line 431
    if (dirp == 1) {
#line 431
      if (! ((fmode & 61440U) == 16384U)) {
#line 432
        return (0);
      } else {
#line 431
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 434
    if (dirp == 0) {
#line 434
      if ((fmode & 61440U) == 16384U) {
#line 435
        return (0);
      }
    }
#line 437
    return (1);
  }
#line 440
  return (0);
}
}
#line 443 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
int file_exists(char *path ) 
{ 
  int tmp ;

  {
  {
#line 444
  tmp = _exists(path, 0);
  }
#line 444
  return (tmp);
}
}
#line 447 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
int dir_exists(char *path ) 
{ 
  int tmp ;

  {
  {
#line 448
  tmp = _exists(path, 1);
  }
#line 448
  return (tmp);
}
}
#line 451 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
int exists(char *path ) 
{ 
  int tmp ;

  {
  {
#line 452
  tmp = _exists(path, -1);
  }
#line 452
  return (tmp);
}
}
#line 460 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *safe_token(char **s ) 
{ 
  char *res ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *__cil_tmp7 ;

  {
#line 461
  res = (char *)"";
#line 463
  if (! s) {
#line 464
    return (res);
  } else
#line 463
  if (! *s) {
#line 464
    return (res);
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 466
    tmp = __ctype_b_loc();
    }
#line 466
    if ((int const   )*(*tmp + (int )*(*s)) & 8192) {
#line 466
      if (! *(*s)) {
#line 466
        goto while_break;
      }
    } else {
#line 466
      goto while_break;
    }
#line 467
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  if (*(*s)) {
#line 470
    res = *s;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 472
      tmp___0 = __ctype_b_loc();
      }
#line 472
      if ((int const   )*(*tmp___0 + (int )*(*s)) & 8192) {
#line 472
        goto while_break___0;
      } else
#line 472
      if (! *(*s)) {
#line 472
        goto while_break___0;
      }
#line 473
      (*s) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    if (*(*s)) {
#line 476
      tmp___1 = *s;
#line 476
      (*s) ++;
#line 476
      *tmp___1 = (char )'\000';
    }
    {
#line 478
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 478
      tmp___2 = __ctype_b_loc();
      }
#line 478
      if ((int const   )*(*tmp___2 + (int )*(*s)) & 8192) {
#line 478
        if (! *(*s)) {
#line 478
          goto while_break___1;
        }
      } else {
#line 478
        goto while_break___1;
      }
#line 479
      (*s) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 482
  return (res);
}
}
#line 489 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
int check_shutmsg(time_t *shut___0 , time_t *deny___0 , time_t *disc___0 , char *msg ,
                  size_t msg_size ) 
{ 
  FILE *fp ;
  char *deny_str ;
  char *disc_str ;
  char *cp ;
  char buf___2[1025] ;
  unsigned int tmp ;
  char hr[3] ;
  unsigned int tmp___0 ;
  char mn[3] ;
  unsigned int tmp___1 ;
  time_t now ;
  time_t shuttime ;
  struct tm tm ;
  struct tm *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 492
  buf___2[0] = (char )'\000';
#line 492
  tmp = 1U;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (tmp >= 1025U) {
#line 492
      goto while_break;
    }
#line 492
    buf___2[tmp] = (char)0;
#line 492
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  hr[0] = (char )'\000';
#line 493
  tmp___0 = 1U;
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 493
    if (tmp___0 >= 3U) {
#line 493
      goto while_break___0;
    }
#line 493
    hr[tmp___0] = (char)0;
#line 493
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 493
  mn[0] = (char )'\000';
#line 493
  tmp___1 = 1U;
  {
#line 493
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 493
    if (tmp___1 >= 3U) {
#line 493
      goto while_break___1;
    }
#line 493
    mn[tmp___1] = (char)0;
#line 493
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 494
  shuttime = (time_t )0;
#line 497
  tmp___18 = file_exists((char *)"/etc/shutmsg");
  }
#line 497
  if (tmp___18) {
    {
#line 497
    fp = fopen((char const   */* __restrict  */)"/etc/shutmsg", (char const   */* __restrict  */)"r");
    }
#line 497
    if (fp) {
      {
#line 498
      cp = fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2), (FILE */* __restrict  */)fp);
      }
#line 498
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 499
        buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 499
        pr_str_strip_end(cp, (char *)"\r\n");
#line 502
        time(& now);
#line 503
        tmp___2 = localtime((time_t const   *)(& now));
#line 503
        tm = *tmp___2;
#line 505
        tmp___3 = safe_token(& cp);
#line 505
        tmp___4 = atoi((char const   *)tmp___3);
#line 505
        tm.tm_year = tmp___4 - 1900;
#line 506
        tmp___5 = safe_token(& cp);
#line 506
        tmp___6 = atoi((char const   *)tmp___5);
#line 506
        tm.tm_mon = tmp___6 - 1;
#line 507
        tmp___7 = safe_token(& cp);
#line 507
        tm.tm_mday = atoi((char const   *)tmp___7);
#line 508
        tmp___8 = safe_token(& cp);
#line 508
        tm.tm_hour = atoi((char const   *)tmp___8);
#line 509
        tmp___9 = safe_token(& cp);
#line 509
        tm.tm_min = atoi((char const   *)tmp___9);
#line 510
        tmp___10 = safe_token(& cp);
#line 510
        tm.tm_sec = atoi((char const   *)tmp___10);
#line 512
        deny_str = safe_token(& cp);
#line 513
        disc_str = safe_token(& cp);
#line 515
        shuttime = mktime(& tm);
        }
#line 515
        if (shuttime == -1L) {
          {
#line 516
          fclose(fp);
          }
#line 517
          return (0);
        }
#line 520
        if (deny___0) {
          {
#line 521
          tmp___13 = strlen((char const   *)deny_str);
          }
#line 521
          if (tmp___13 == 4U) {
            {
#line 522
            sstrncpy(hr, (char const   *)deny_str, (size_t )sizeof(hr));
#line 522
            hr[2] = (char )'\000';
#line 522
            deny_str += 2;
#line 523
            sstrncpy(mn, (char const   *)deny_str, (size_t )sizeof(mn));
#line 523
            mn[2] = (char )'\000';
#line 525
            tmp___11 = atoi((char const   *)(hr));
#line 525
            tmp___12 = atoi((char const   *)(mn));
#line 525
            *deny___0 = shuttime - (time_t )(tmp___11 * 3600 + tmp___12 * 60);
            }
          } else {
#line 527
            *deny___0 = shuttime;
          }
        }
#line 530
        if (disc___0) {
          {
#line 531
          tmp___16 = strlen((char const   *)disc_str);
          }
#line 531
          if (tmp___16 == 4U) {
            {
#line 532
            sstrncpy(hr, (char const   *)disc_str, (size_t )sizeof(hr));
#line 532
            hr[2] = (char )'\000';
#line 532
            disc_str += 2;
#line 533
            sstrncpy(mn, (char const   *)disc_str, (size_t )sizeof(mn));
#line 533
            mn[2] = (char )'\000';
#line 535
            tmp___14 = atoi((char const   *)(hr));
#line 535
            tmp___15 = atoi((char const   *)(mn));
#line 535
            *disc___0 = shuttime - (time_t )(tmp___14 * 3600 + tmp___15 * 60);
            }
          } else {
#line 537
            *disc___0 = shuttime;
          }
        }
        {
#line 540
        tmp___17 = fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2),
                         (FILE */* __restrict  */)fp);
        }
#line 540
        if (tmp___17) {
#line 540
          if (msg) {
            {
#line 541
            buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 542
            pr_str_strip_end(buf___2, (char *)"\r\n");
#line 543
            sstrncpy(msg, (char const   *)(buf___2), msg_size - 1U);
            }
          }
        }
      }
      {
#line 547
      fclose(fp);
      }
#line 548
      if (shut___0) {
#line 549
        *shut___0 = shuttime;
      }
#line 550
      return (1);
    }
  }
#line 553
  return (0);
}
}
#line 562 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char *make_arg_str(pool *p , int argc , char **argv ) 
{ 
  char *res ;
  int tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  char **tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 563
  res = (char *)"";
#line 566
  tmp = strcmp((char const   *)*(argv + 0), "PASS");
  }
#line 566
  if (tmp == 0) {
#line 568
    argc = 2;
#line 569
    *(argv + 1) = (char *)"(hidden)";
  } else {
    {
#line 566
    tmp___0 = strcmp((char const   *)*(argv + 0), "ADAT");
    }
#line 566
    if (tmp___0 == 0) {
#line 568
      argc = 2;
#line 569
      *(argv + 1) = (char *)"(hidden)";
    }
  }
#line 572
  if (argc > 0) {
    {
#line 573
    while (1) {
      while_continue: /* CIL Label */ ;
#line 573
      tmp___5 = argc;
#line 573
      argc --;
#line 573
      if (! tmp___5) {
#line 573
        goto while_break;
      }
#line 574
      if (*res) {
        {
#line 575
        tmp___1 = argv;
#line 575
        argv ++;
#line 575
        tmp___2 = pr_fs_decode_path(p, (char const   *)*tmp___1);
#line 575
        res = pstrcat(p, res, " ", tmp___2, (void *)0);
        }
      } else {
        {
#line 577
        tmp___3 = argv;
#line 577
        argv ++;
#line 577
        tmp___4 = pr_fs_decode_path(p, (char const   *)*tmp___3);
#line 577
        res = pstrcat(p, res, tmp___4, (void *)0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 581
    res = pstrdup(p, (char const   *)res);
    }
  }
#line 584
  return (res);
}
}
#line 594 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
unsigned char memscrub_ctr  =    (unsigned char)0;
#line 596 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
void pr_memscrub(void *ptr , size_t ptrlen ) 
{ 
  unsigned char *p ;
  size_t loop ;
  unsigned char *tmp ;
  unsigned char tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 607
  if (! ptr) {
#line 608
    return;
  } else
#line 607
  if (ptrlen == 0U) {
#line 608
    return;
  }
#line 611
  p = (unsigned char *)ptr;
#line 612
  loop = ptrlen;
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 614
    tmp___1 = loop;
#line 614
    loop --;
#line 614
    if (! tmp___1) {
#line 614
      goto while_break;
    }
#line 615
    tmp = p;
#line 615
    p ++;
#line 615
    tmp___0 = memscrub_ctr;
#line 615
    memscrub_ctr = (unsigned char )((int )memscrub_ctr + 1);
#line 615
    *tmp = tmp___0;
#line 616
    memscrub_ctr = (unsigned char )((int )memscrub_ctr + (17 + (int )((unsigned char )((intptr_t )p & 15))));
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 619
  tmp___2 = memchr((void const   *)ptr, (int )memscrub_ctr, ptrlen);
  }
#line 619
  if (tmp___2) {
#line 620
    memscrub_ctr = (unsigned char )((int )memscrub_ctr + 63);
  }
#line 622
  return;
}
}
#line 624 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
struct tm *pr_gmtime(pool *p , time_t const   *t ) 
{ 
  struct tm *sys_tm ;
  struct tm *dup_tm ;
  void *tmp ;

  {
  {
#line 627
  sys_tm = gmtime(t);
  }
#line 632
  if (p) {
    {
#line 633
    tmp = pcalloc(p, (int )sizeof(struct tm ));
#line 633
    dup_tm = (struct tm *)tmp;
#line 634
    memcpy((void */* __restrict  */)dup_tm, (void const   */* __restrict  */)sys_tm,
           (size_t )sizeof(struct tm ));
    }
  } else {
#line 637
    dup_tm = sys_tm;
  }
#line 640
  return (dup_tm);
}
}
#line 643 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
struct tm *pr_localtime(pool *p , time_t const   *t ) 
{ 
  struct tm *sys_tm ;
  struct tm *dup_tm ;
  char *tzname_dup[2] ;
  void *tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 674
  memcpy((void */* __restrict  */)(& tzname_dup), (void const   */* __restrict  */)(tzname),
         (size_t )sizeof(tzname_dup));
#line 677
  sys_tm = localtime(t);
  }
#line 679
  if (p) {
    {
#line 683
    tmp = pcalloc(p, (int )sizeof(struct tm ));
#line 683
    dup_tm = (struct tm *)tmp;
#line 684
    memcpy((void */* __restrict  */)dup_tm, (void const   */* __restrict  */)sys_tm,
           (size_t )sizeof(struct tm ));
    }
  } else {
#line 691
    dup_tm = sys_tm;
  }
  {
#line 696
  memcpy((void */* __restrict  */)(tzname), (void const   */* __restrict  */)(tzname_dup),
         (size_t )sizeof(tzname_dup));
  }
#line 699
  return (dup_tm);
}
}
#line 703 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static char buf___1[64]  ;
#line 704 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static char *mons[12]  = 
#line 704
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 706 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
static char *days[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 702 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/support.c"
char const   *pr_strtime(time_t t ) 
{ 
  struct tm *tr ;
  char *__cil_tmp3 ;

  {
  {
#line 709
  memset((void *)(buf___1), '\000', (size_t )sizeof(buf___1));
#line 711
  tr = pr_localtime((pool *)((void *)0), (time_t const   *)(& t));
  }
#line 712
  if ((unsigned long )tr != (unsigned long )((void *)0)) {
    {
#line 713
    snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%s %s %2d %02d:%02d:%02d %d",
             days[tr->tm_wday], mons[tr->tm_mon], tr->tm_mday, tr->tm_hour, tr->tm_min,
             tr->tm_sec, tr->tm_year + 1900);
    }
  } else {
#line 718
    buf___1[0] = (char )'\000';
  }
#line 721
  buf___1[sizeof(buf___1) - 1UL] = (char )'\000';
#line 723
  return ((char const   *)(buf___1));
}
}
#line 52 "../include/expr.h"
int pr_expr_eval_class_and(char **expr ) ;
#line 56
int pr_expr_eval_user_and(char **expr ) ;
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
array_header *pr_expr_create(pool *p , int *argc , char **argv ) 
{ 
  array_header *acl ;
  int cnt ;
  char *s ;
  char *ent ;
  int *tmp ;
  char *sep ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;

  {
#line 32
  acl = (array_header *)((void *)0);
#line 36
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 40
    tmp = __errno_location();
#line 40
    *tmp = 22;
    }
#line 41
    return ((array_header *)((void *)0));
  } else
#line 36
  if ((unsigned long )argc == (unsigned long )((void *)0)) {
    {
#line 40
    tmp = __errno_location();
#line 40
    *tmp = 22;
    }
#line 41
    return ((array_header *)((void *)0));
  } else
#line 36
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
    {
#line 40
    tmp = __errno_location();
#line 40
    *tmp = 22;
    }
#line 41
    return ((array_header *)((void *)0));
  } else
#line 36
  if ((unsigned long )*argv == (unsigned long )((void *)0)) {
    {
#line 40
    tmp = __errno_location();
#line 40
    *tmp = 22;
    }
#line 41
    return ((array_header *)((void *)0));
  }
#line 44
  cnt = *argc;
#line 46
  if (cnt > 0) {
    {
#line 47
    acl = make_array(p, (unsigned int )cnt, (size_t )sizeof(char *));
    }
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      tmp___3 = cnt;
#line 50
      cnt --;
#line 50
      if (tmp___3) {
#line 50
        argv ++;
#line 50
        if (! *argv) {
#line 50
          goto while_break;
        }
      } else {
#line 50
        goto while_break;
      }
      {
#line 51
      sep = (char *)",";
#line 53
      s = pstrdup(p, (char const   *)*argv);
#line 55
      tmp___2 = strstr((char const   *)s, (char const   *)sep);
      }
#line 55
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        {
#line 56
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 56
          ent = pr_str_get_token(& s, sep);
          }
#line 56
          if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 56
            goto while_break___0;
          }
          {
#line 57
          pr_signals_handle();
          }
#line 59
          if (*ent) {
            {
#line 60
            tmp___0 = push_array(acl);
#line 60
            *((char **)tmp___0) = ent;
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 64
        tmp___1 = push_array(acl);
#line 64
        *((char **)tmp___1) = s;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 68
    *argc = acl->nelts;
  } else {
    {
#line 71
    acl = make_array(p, 0U, (size_t )sizeof(char *));
#line 72
    *argc = 0;
    }
  }
#line 75
  return (acl);
}
}
#line 81 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
int pr_expr_eval_class_and(char **expr ) 
{ 
  int found ;
  char *class ;
  int *tmp ;
  int tmp___0 ;

  {
#line 85
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 87
    tmp = __errno_location();
#line 87
    *tmp = 22;
    }
#line 88
    return (-1);
  } else
#line 85
  if ((unsigned long )*expr == (unsigned long )((void *)0)) {
    {
#line 87
    tmp = __errno_location();
#line 87
    *tmp = 22;
    }
#line 88
    return (-1);
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! *expr) {
#line 91
      goto while_break;
    }
#line 92
    class = *expr;
#line 93
    found = 0;
#line 95
    if ((int )*class == 33) {
#line 96
      found = ! found;
#line 97
      class ++;
    }
#line 100
    if ((unsigned long )session.class == (unsigned long )((void *)0)) {
#line 100
      if (! found) {
#line 102
        return (0);
      }
    }
#line 104
    if (session.class) {
      {
#line 104
      tmp___0 = strcmp((char const   *)(session.class)->cls_name, (char const   *)class);
      }
#line 104
      if (tmp___0 == 0) {
#line 106
        found = ! found;
      }
    }
#line 108
    if (! found) {
#line 109
      return (0);
    }
#line 91
    expr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (1);
}
}
#line 118 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
int pr_expr_eval_class_or(char **expr ) 
{ 
  int found ;
  char *class ;
  int *tmp ;
  int tmp___0 ;

  {
#line 122
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 124
    tmp = __errno_location();
#line 124
    *tmp = 22;
    }
#line 125
    return (-1);
  } else
#line 122
  if ((unsigned long )*expr == (unsigned long )((void *)0)) {
    {
#line 124
    tmp = __errno_location();
#line 124
    *tmp = 22;
    }
#line 125
    return (-1);
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! *expr) {
#line 128
      goto while_break;
    }
#line 129
    class = *expr;
#line 130
    found = 0;
#line 132
    if ((int )*class == 33) {
#line 133
      found = ! found;
#line 134
      class ++;
    }
#line 137
    if ((unsigned long )session.class == (unsigned long )((void *)0)) {
#line 138
      return (found);
    }
    {
#line 140
    tmp___0 = strcmp((char const   *)(session.class)->cls_name, (char const   *)class);
    }
#line 140
    if (tmp___0 == 0) {
#line 141
      found = ! found;
    }
#line 143
    if (found) {
#line 144
      return (1);
    }
#line 128
    expr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (0);
}
}
#line 153 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
int pr_expr_eval_group_and(char **expr ) 
{ 
  int found ;
  char *grp ;
  int *tmp ;
  register int i___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 157
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 159
    tmp = __errno_location();
#line 159
    *tmp = 22;
    }
#line 160
    return (-1);
  } else
#line 157
  if ((unsigned long )*expr == (unsigned long )((void *)0)) {
    {
#line 159
    tmp = __errno_location();
#line 159
    *tmp = 22;
    }
#line 160
    return (-1);
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! *expr) {
#line 163
      goto while_break;
    }
#line 164
    grp = *expr;
#line 165
    found = 0;
#line 167
    if ((int )*grp == 33) {
#line 168
      found = ! found;
#line 169
      grp ++;
    }
#line 172
    if (session.group) {
      {
#line 172
      tmp___1 = strcmp((char const   *)session.group, (char const   *)grp);
      }
#line 172
      if (tmp___1 == 0) {
#line 174
        found = ! found;
      } else {
#line 172
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 176
    if (session.groups) {
#line 177
      i___0 = 0;
#line 179
      i___0 = (session.groups)->nelts - 1;
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! (i___0 >= 0)) {
#line 179
          goto while_break___0;
        }
        {
#line 180
        tmp___0 = strcmp((char const   *)*((char **)(session.groups)->elts + i___0),
                         (char const   *)grp);
        }
#line 180
        if (tmp___0 == 0) {
#line 181
          found = ! found;
#line 182
          goto while_break___0;
        }
#line 179
        i___0 --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 187
    if (! found) {
#line 188
      return (0);
    }
#line 163
    expr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (1);
}
}
#line 197 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
int pr_expr_eval_group_or(char **expr ) 
{ 
  int found ;
  char *grp ;
  int *tmp ;
  register int i___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 201
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 203
    tmp = __errno_location();
#line 203
    *tmp = 22;
    }
#line 204
    return (-1);
  } else
#line 201
  if ((unsigned long )*expr == (unsigned long )((void *)0)) {
    {
#line 203
    tmp = __errno_location();
#line 203
    *tmp = 22;
    }
#line 204
    return (-1);
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! *expr) {
#line 207
      goto while_break;
    }
#line 208
    grp = *expr;
#line 209
    found = 0;
#line 211
    if ((int )*grp == 33) {
#line 212
      found = ! found;
#line 213
      grp ++;
    }
#line 216
    if (session.group) {
      {
#line 216
      tmp___1 = strcmp((char const   *)session.group, (char const   *)grp);
      }
#line 216
      if (tmp___1 == 0) {
#line 218
        found = ! found;
      } else {
#line 216
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 220
    if (session.groups) {
#line 221
      i___0 = 0;
#line 223
      i___0 = (session.groups)->nelts - 1;
      {
#line 223
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 223
        if (! (i___0 >= 0)) {
#line 223
          goto while_break___0;
        }
        {
#line 224
        tmp___0 = strcmp((char const   *)*((char **)(session.groups)->elts + i___0),
                         (char const   *)grp);
        }
#line 224
        if (tmp___0 == 0) {
#line 225
          found = ! found;
#line 226
          goto while_break___0;
        }
#line 223
        i___0 --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 231
    if (found) {
#line 232
      return (1);
    }
#line 207
    expr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (0);
}
}
#line 241 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
int pr_expr_eval_user_and(char **expr ) 
{ 
  int found ;
  char *user ;
  int *tmp ;
  int tmp___0 ;

  {
#line 245
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 247
    tmp = __errno_location();
#line 247
    *tmp = 22;
    }
#line 248
    return (-1);
  } else
#line 245
  if ((unsigned long )*expr == (unsigned long )((void *)0)) {
    {
#line 247
    tmp = __errno_location();
#line 247
    *tmp = 22;
    }
#line 248
    return (-1);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! *expr) {
#line 251
      goto while_break;
    }
#line 252
    user = *expr;
#line 253
    found = 0;
#line 255
    if ((int )*user == 33) {
#line 256
      found = ! found;
#line 257
      user ++;
    }
#line 260
    if (session.user) {
      {
#line 260
      tmp___0 = strcmp((char const   *)session.user, (char const   *)user);
      }
#line 260
      if (tmp___0 == 0) {
#line 262
        found = ! found;
      }
    }
#line 264
    if (! found) {
#line 265
      return (0);
    }
#line 251
    expr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (1);
}
}
#line 274 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/expr.c"
int pr_expr_eval_user_or(char **expr ) 
{ 
  int found ;
  char *user ;
  int *tmp ;
  int tmp___0 ;

  {
#line 278
  if ((unsigned long )expr == (unsigned long )((void *)0)) {
    {
#line 280
    tmp = __errno_location();
#line 280
    *tmp = 22;
    }
#line 281
    return (-1);
  } else
#line 278
  if ((unsigned long )*expr == (unsigned long )((void *)0)) {
    {
#line 280
    tmp = __errno_location();
#line 280
    *tmp = 22;
    }
#line 281
    return (-1);
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! *expr) {
#line 284
      goto while_break;
    }
#line 285
    user = *expr;
#line 286
    found = 0;
#line 288
    if ((int )*user == 33) {
#line 289
      found = ! found;
#line 290
      user ++;
    }
#line 293
    if (session.user) {
      {
#line 293
      tmp___0 = strcmp((char const   *)session.user, (char const   *)user);
      }
#line 293
      if (tmp___0 == 0) {
#line 295
        found = ! found;
      }
    }
#line 297
    if (found) {
#line 298
      return (1);
    }
#line 284
    expr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (0);
}
}
#line 53 "../include/str.h"
int pr_str_is_boolean(char const   *str ) ;
#line 267 "../include/table.h"
pr_table_t *pr_table_nalloc(pool *p , int flags , unsigned int nchains ) ;
#line 272
void *pr_table_pcalloc(pr_table_t *tab , size_t sz ) ;
#line 213 "../include/dirtree.h"
void kludge_disable_umask(void) ;
#line 214
void kludge_enable_umask(void) ;
#line 219
void init_config(void) ;
#line 220
int fixup_servers(xaset_t *list ) ;
#line 223
config_rec *add_config(server_rec *s , char const   *name ) ;
#line 227
config_rec *pr_conf_add_server_config_param_str(server_rec *s , char const   *name ,
                                                int num  , ...) ;
#line 238
unsigned int pr_config_get_id(char const   *name ) ;
#line 252
unsigned int pr_config_set_id(char const   *name ) ;
#line 257
void *get_param_ptr_next(char const   *name , int recurse ) ;
#line 258
xaset_t *get_dir_ctxt(pool *p , char *dir_path ) ;
#line 260
config_rec *dir_match_path(pool *p , char *path ) ;
#line 264
int dir_check_limits(config_rec *c , char *cmd , int hidden ) ;
#line 268
int is_fnmatch(char const   *str ) ;
#line 279
void pr_config_dump(void (*dumpf)(char const   *  , ...) , xaset_t *s , char *indent ) ;
#line 41 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
xaset_t *server_list  =    (xaset_t *)((void *)0);
#line 42 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
server_rec *main_server  =    (server_rec *)((void *)0);
#line 43 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int tcpBackLog  =    5;
#line 44 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int SocketBindTight  =    0;
#line 45 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
char ServerType  =    (char)1;
#line 46 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int ServerMaxInstances  =    0;
#line 47 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int ServerUseReverseDNS  =    1;
#line 48 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
char MultilineRFC2228  =    (char)0;
#line 51 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int tcp_rcvbufsz  =    0;
#line 52 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int tcp_sndbufsz  =    0;
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int xfer_bufsz  =    0;
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static xaset_t *find_config_top  =    (xaset_t *)((void *)0);
#line 61
static void merge_down(xaset_t *s , int dynamic ) ;
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static config_rec *_last_param_ptr  =    (config_rec *)((void *)0);
#line 64 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static unsigned char _kludge_disable_umask  =    (unsigned char)0;
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static pool *defines_pool  =    (pool *)((void *)0);
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static array_header *defines_list  =    (array_header *)((void *)0);
#line 69 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static pool *config_tab_pool  =    (pool *)((void *)0);
#line 70 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static pr_table_t *config_tab  =    (pr_table_t *)((void *)0);
#line 71 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static unsigned int config_id  =    0U;
#line 73 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int allow_dyn_config(void) 
{ 
  config_rec *c ;
  unsigned int ctxt_precedence ;
  unsigned char have_user_limit ;
  unsigned char have_group_limit ;
  unsigned char have_class_limit ;
  unsigned char have_all_limit ;
  unsigned char allow ;
  xaset_t *tmp ;
  xaset_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 74
  c = (config_rec *)((void *)0);
#line 75
  ctxt_precedence = 0U;
#line 78
  allow = (unsigned char)1;
#line 80
  have_all_limit = (unsigned char)0;
#line 80
  have_class_limit = have_all_limit;
#line 80
  have_group_limit = have_class_limit;
#line 80
  have_user_limit = have_group_limit;
#line 83
  if (session.dir_config) {
#line 83
    tmp___0 = (session.dir_config)->subset;
  } else {
#line 83
    if (session.anon_config) {
#line 83
      tmp = (session.anon_config)->subset;
    } else {
#line 83
      tmp = main_server->conf;
    }
#line 83
    tmp___0 = tmp;
  }
  {
#line 83
  c = find_config(tmp___0, 1 << 15, "AllowOverride", 0);
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! c) {
#line 85
      goto while_break;
    }
#line 86
    if (c->argc == 3) {
      {
#line 87
      tmp___6 = strcmp((char const   *)*(c->argv + 2), "user");
      }
#line 87
      if (tmp___6) {
        {
#line 102
        tmp___5 = strcmp((char const   *)*(c->argv + 2), "group");
        }
#line 102
        if (tmp___5) {
          {
#line 117
          tmp___4 = strcmp((char const   *)*(c->argv + 2), "class");
          }
#line 117
          if (! tmp___4) {
            {
#line 119
            tmp___3 = pr_expr_eval_class_or((char **)(c->argv + 3));
            }
#line 119
            if (tmp___3 == 1) {
#line 120
              if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 123
                ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 125
                allow = (unsigned char )*((int *)*(c->argv + 0));
#line 127
                have_all_limit = (unsigned char)0;
#line 127
                have_group_limit = have_all_limit;
#line 127
                have_user_limit = have_group_limit;
#line 128
                have_class_limit = (unsigned char)1;
              }
            }
          }
        } else {
          {
#line 104
          tmp___2 = pr_expr_eval_group_and((char **)(c->argv + 3));
          }
#line 104
          if (tmp___2 == 1) {
#line 105
            if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 108
              ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 110
              allow = (unsigned char )*((int *)*(c->argv + 0));
#line 112
              have_all_limit = (unsigned char)0;
#line 112
              have_class_limit = have_all_limit;
#line 112
              have_user_limit = have_class_limit;
#line 113
              have_group_limit = (unsigned char)1;
            }
          }
        }
      } else {
        {
#line 89
        tmp___1 = pr_expr_eval_user_or((char **)(c->argv + 3));
        }
#line 89
        if (tmp___1 == 1) {
#line 90
          if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 93
            ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 95
            allow = (unsigned char )*((int *)*(c->argv + 0));
#line 97
            have_all_limit = (unsigned char)0;
#line 97
            have_class_limit = have_all_limit;
#line 97
            have_group_limit = have_class_limit;
#line 98
            have_user_limit = (unsigned char)1;
          }
        }
      }
    } else
#line 135
    if (*((unsigned int *)*(c->argv + 1)) > ctxt_precedence) {
#line 138
      ctxt_precedence = *((unsigned int *)*(c->argv + 1));
#line 140
      allow = (unsigned char )*((int *)*(c->argv + 0));
#line 142
      have_class_limit = (unsigned char)0;
#line 142
      have_group_limit = have_class_limit;
#line 142
      have_user_limit = have_group_limit;
#line 143
      have_all_limit = (unsigned char)1;
    }
    {
#line 147
    c = find_config_next(c, c->next, 1 << 15, "AllowOverride", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if (have_user_limit) {
#line 151
    goto _L;
  } else
#line 151
  if (have_group_limit) {
#line 151
    goto _L;
  } else
#line 151
  if (have_class_limit) {
#line 151
    goto _L;
  } else
#line 151
  if (have_all_limit) {
    _L: /* CIL Label */ 
#line 153
    if (have_user_limit) {
#line 153
      tmp___9 = (char const   *)session.user;
    } else {
#line 153
      if (have_group_limit) {
#line 153
        tmp___8 = (char const   *)session.group;
      } else {
#line 153
        if (have_class_limit) {
#line 153
          tmp___7 = (char const   *)(session.class)->cls_name;
        } else {
#line 153
          tmp___7 = "";
        }
#line 153
        tmp___8 = tmp___7;
      }
#line 153
      tmp___9 = tmp___8;
    }
#line 153
    if (have_user_limit) {
#line 153
      tmp___12 = "user ";
    } else {
#line 153
      if (have_group_limit) {
#line 153
        tmp___11 = "group ";
      } else {
#line 153
        if (have_class_limit) {
#line 153
          tmp___10 = "class ";
        } else {
#line 153
          tmp___10 = "all";
        }
#line 153
        tmp___11 = tmp___10;
      }
#line 153
      tmp___12 = tmp___11;
    }
#line 153
    if (allow) {
#line 153
      tmp___13 = "allows";
    } else {
#line 153
      tmp___13 = "denies";
    }
    {
#line 153
    pr_log_debug(4, "AllowOverride %s %s%s .ftpaccess files", tmp___13, tmp___12,
                 tmp___9);
    }
  }
#line 161
  return ((int )allow);
}
}
#line 169 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int is_dotdir(char const   *dir ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 170
  tmp = strcmp(dir, ".");
  }
#line 170
  if (tmp == 0) {
#line 172
    return (1);
  } else {
    {
#line 170
    tmp___0 = strcmp(dir, "./");
    }
#line 170
    if (tmp___0 == 0) {
#line 172
      return (1);
    } else {
      {
#line 170
      tmp___1 = strcmp(dir, "..");
      }
#line 170
      if (tmp___1 == 0) {
#line 172
        return (1);
      } else {
        {
#line 170
        tmp___2 = strcmp(dir, "../");
        }
#line 170
        if (tmp___2 == 0) {
#line 172
          return (1);
        }
      }
    }
  }
#line 174
  return (0);
}
}
#line 178 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int is_fnmatch(char const   *str ) 
{ 
  int have_bracket ;
  char const   *tmp ;

  {
#line 179
  have_bracket = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! *str) {
#line 181
      goto while_break;
    }
    {
#line 184
    if ((int const   )*str == 42) {
#line 184
      goto case_42;
    }
#line 184
    if ((int const   )*str == 63) {
#line 184
      goto case_42;
    }
#line 187
    if ((int const   )*str == 92) {
#line 187
      goto case_92;
    }
#line 192
    if ((int const   )*str == 91) {
#line 192
      goto case_91;
    }
#line 196
    if ((int const   )*str == 93) {
#line 196
      goto case_93;
    }
#line 201
    goto switch_default;
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 185
    return (1);
    case_92: /* CIL Label */ 
#line 188
    tmp = str;
#line 188
    str ++;
#line 188
    if ((int const   )*tmp == 0) {
#line 189
      return (0);
    }
#line 190
    goto switch_break;
    case_91: /* CIL Label */ 
#line 193
    have_bracket ++;
#line 194
    goto switch_break;
    case_93: /* CIL Label */ 
#line 197
    if (have_bracket) {
#line 198
      return (1);
    }
#line 199
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 202
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 205
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return (0);
}
}
#line 225 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
xaset_t *get_dir_ctxt(pool *p , char *dir_path ) 
{ 
  config_rec *c ;
  char *full_path ;
  xaset_t *tmp ;
  xaset_t *tmp___0 ;

  {
#line 226
  c = (config_rec *)((void *)0);
#line 227
  full_path = dir_path;
#line 229
  if (session.chroot_path) {
#line 230
    if ((int )*dir_path != 47) {
      {
#line 231
      full_path = pdircat(p, session.chroot_path, session.cwd, dir_path, (void *)0);
      }
    } else {
      {
#line 234
      full_path = pdircat(p, session.chroot_path, dir_path, (void *)0);
      }
    }
  } else
#line 236
  if ((int )*dir_path != 47) {
    {
#line 237
    full_path = pdircat(p, session.cwd, dir_path, (void *)0);
    }
  }
  {
#line 239
  c = dir_match_path(p, full_path);
  }
#line 241
  if (c) {
#line 241
    tmp___0 = c->subset;
  } else {
#line 241
    if (session.anon_config) {
#line 241
      tmp = (session.anon_config)->subset;
    } else {
#line 241
      tmp = main_server->conf;
    }
#line 241
    tmp___0 = tmp;
  }
#line 241
  return (tmp___0);
}
}
#line 248 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
char *path_subst_uservar(pool *path_pool , char **path ) 
{ 
  char *new_path ;
  char *substr ;
  char *substr_path ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int i___0 ;
  char *substr_end ;
  char *substr_dup ;
  char *endp ;
  char ref_char[2] ;
  long tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 249
  new_path = (char *)((void *)0);
#line 249
  substr = (char *)((void *)0);
#line 249
  substr_path = (char *)((void *)0);
#line 252
  if (! path_pool) {
    {
#line 253
    tmp = __errno_location();
#line 253
    *tmp = 22;
    }
#line 254
    return ((char *)((void *)0));
  } else
#line 252
  if (! path) {
    {
#line 253
    tmp = __errno_location();
#line 253
    *tmp = 22;
    }
#line 254
    return ((char *)((void *)0));
  } else
#line 252
  if (! *path) {
    {
#line 253
    tmp = __errno_location();
#line 253
    *tmp = 22;
    }
#line 254
    return ((char *)((void *)0));
  }
  {
#line 258
  tmp___0 = strstr((char const   *)*path, "%u");
  }
#line 258
  if (! tmp___0) {
#line 259
    return (*path);
  }
#line 268
  substr_path = *path;
#line 269
  if (substr_path) {
    {
#line 269
    tmp___1 = strstr((char const   *)substr_path, "%u[");
#line 269
    substr = tmp___1;
    }
  } else {
#line 269
    substr = (char *)((void *)0);
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! substr) {
#line 270
      goto while_break;
    }
    {
#line 271
    i___0 = 0;
#line 272
    substr_end = (char *)((void *)0);
#line 272
    substr_dup = (char *)((void *)0);
#line 272
    endp = (char *)((void *)0);
#line 273
    ref_char[0] = (char )'\000';
#line 273
    ref_char[1] = (char )'\000';
#line 278
    substr_end = strchr((char const   *)substr, ']');
    }
#line 279
    if ((unsigned long )substr_end == (unsigned long )((void *)0)) {
#line 281
      goto while_break;
    }
    {
#line 285
    substr_dup = pstrdup(path_pool, (char const   *)substr);
#line 290
    *(substr_dup + ((substr_end - substr) + 1L)) = (char )'\000';
#line 295
    substr += 3;
    }
#line 300
    if ((unsigned long )substr_end == (unsigned long )substr) {
#line 303
      substr_path = substr;
#line 305
      goto while_continue;
    }
    {
#line 311
    *substr_end = (char )'\000';
#line 314
    tmp___2 = strtol((char const   */* __restrict  */)substr, (char **/* __restrict  */)(& endp),
                     10);
#line 314
    i___0 = (int )tmp___2;
    }
#line 316
    if (endp) {
#line 316
      if (*endp) {
#line 317
        substr_path = substr;
#line 318
        goto while_continue;
      }
    }
#line 322
    if (i___0 < 0) {
#line 325
      *substr_end = (char )']';
#line 330
      substr_path = substr;
#line 332
      goto while_continue;
    } else {
      {
#line 322
      tmp___3 = strlen((char const   *)session.user);
      }
#line 322
      if ((size_t )i___0 > tmp___3 - 1U) {
#line 325
        *substr_end = (char )']';
#line 330
        substr_path = substr;
#line 332
        goto while_continue;
      }
    }
    {
#line 335
    ref_char[0] = *(session.user + i___0);
#line 338
    *substr_end = (char )']';
#line 343
    substr_path = sreplace(path_pool, substr_path, substr_dup, ref_char, (void *)0);
    }
#line 344
    if (substr_path) {
      {
#line 344
      tmp___4 = strstr((char const   *)substr_path, "%u[");
#line 344
      substr = tmp___4;
      }
    } else {
#line 344
      substr = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  if (substr_path) {
    {
#line 348
    tmp___5 = strstr((char const   *)substr_path, "%u");
    }
#line 348
    if (tmp___5) {
      {
#line 350
      new_path = sreplace(path_pool, substr_path, "%u", session.user, (void *)0);
      }
    } else {
#line 353
      new_path = substr_path;
    }
  } else {
#line 353
    new_path = substr_path;
  }
#line 355
  return (new_path);
}
}
#line 363 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
unsigned char dir_hide_file(char const   *path ) 
{ 
  char *file_name ;
  char *dir_name ;
  config_rec *c ;
  regex_t *regexp ;
  pool *tmp_pool ;
  pool *tmp ;
  unsigned int ctxt_precedence ;
  unsigned char have_user_regex ;
  unsigned char have_group_regex ;
  unsigned char have_class_regex ;
  unsigned char have_all_regex ;
  unsigned char inverted ;
  xaset_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 365
  file_name = (char *)((void *)0);
#line 365
  dir_name = (char *)((void *)0);
#line 366
  c = (config_rec *)((void *)0);
#line 367
  regexp = (regex_t *)((void *)0);
#line 368
  tmp = make_sub_pool(session.pool);
#line 368
  tmp_pool = tmp;
#line 369
  ctxt_precedence = 0U;
#line 370
  inverted = (unsigned char)0;
  }
#line 373
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 374
    return ((unsigned char)0);
  }
  {
#line 377
  pr_pool_tag(tmp_pool, "dir_hide_file() tmp pool");
#line 379
  have_all_regex = (unsigned char)0;
#line 379
  have_class_regex = have_all_regex;
#line 379
  have_group_regex = have_class_regex;
#line 379
  have_user_regex = have_group_regex;
#line 383
  dir_name = pstrdup(tmp_pool, path);
#line 385
  file_name = strrchr((char const   *)dir_name, '/');
  }
#line 386
  if ((unsigned long )file_name != (unsigned long )((void *)0)) {
#line 387
    *file_name = (char )'\000';
#line 388
    file_name ++;
  } else {
#line 391
    file_name = dir_name;
  }
  {
#line 394
  tmp___0 = get_dir_ctxt(tmp_pool, dir_name);
#line 394
  c = find_config(tmp___0, 1 << 15, "HideFiles", 0);
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! c) {
#line 397
      goto while_break;
    }
#line 398
    if (c->argc >= 4) {
      {
#line 401
      tmp___6 = strcmp((char const   *)*(c->argv + 3), "user");
      }
#line 401
      if (tmp___6 == 0) {
        {
#line 402
        tmp___1 = pr_expr_eval_user_or((char **)(c->argv + 4));
        }
#line 402
        if (tmp___1 == 1) {
#line 404
          if (*((unsigned int *)*(c->argv + 2)) > ctxt_precedence) {
#line 405
            ctxt_precedence = *((unsigned int *)*(c->argv + 2));
#line 407
            regexp = *((regex_t **)*(c->argv + 0));
#line 408
            inverted = *((unsigned char *)*(c->argv + 1));
#line 410
            have_all_regex = (unsigned char)0;
#line 410
            have_class_regex = have_all_regex;
#line 410
            have_group_regex = have_class_regex;
#line 411
            have_user_regex = (unsigned char)1;
          }
        }
      } else {
        {
#line 416
        tmp___5 = strcmp((char const   *)*(c->argv + 3), "group");
        }
#line 416
        if (tmp___5 == 0) {
          {
#line 417
          tmp___2 = pr_expr_eval_group_and((char **)(c->argv + 4));
          }
#line 417
          if (tmp___2 == 1) {
#line 418
            if (*((unsigned int *)*(c->argv + 2)) > ctxt_precedence) {
#line 419
              ctxt_precedence = *((unsigned int *)*(c->argv + 2));
#line 421
              regexp = *((regex_t **)*(c->argv + 0));
#line 422
              inverted = *((unsigned char *)*(c->argv + 1));
#line 424
              have_all_regex = (unsigned char)0;
#line 424
              have_class_regex = have_all_regex;
#line 424
              have_user_regex = have_class_regex;
#line 425
              have_group_regex = (unsigned char)1;
            }
          }
        } else {
          {
#line 434
          tmp___4 = strcmp((char const   *)*(c->argv + 3), "class");
          }
#line 434
          if (tmp___4 == 0) {
            {
#line 435
            tmp___3 = pr_expr_eval_class_or((char **)(c->argv + 4));
            }
#line 435
            if (tmp___3 == 1) {
#line 436
              if (*((unsigned int *)*(c->argv + 2)) > ctxt_precedence) {
#line 437
                ctxt_precedence = *((unsigned int *)*(c->argv + 2));
#line 439
                regexp = *((regex_t **)*(c->argv + 0));
#line 440
                inverted = *((unsigned char *)*(c->argv + 1));
#line 442
                have_all_regex = (unsigned char)0;
#line 442
                have_group_regex = have_all_regex;
#line 442
                have_user_regex = have_group_regex;
#line 443
                have_class_regex = (unsigned char)1;
              }
            }
          }
        }
      }
    } else
#line 448
    if (c->argc == 1) {
      {
#line 451
      destroy_pool(tmp_pool);
      }
#line 452
      return ((unsigned char)0);
    } else
#line 455
    if (*((unsigned int *)*(c->argv + 2)) > ctxt_precedence) {
#line 456
      ctxt_precedence = *((unsigned int *)*(c->argv + 2));
#line 458
      regexp = *((regex_t **)*(c->argv + 0));
#line 459
      inverted = *((unsigned char *)*(c->argv + 1));
#line 461
      have_class_regex = (unsigned char)0;
#line 461
      have_group_regex = have_class_regex;
#line 461
      have_user_regex = have_group_regex;
#line 462
      have_all_regex = (unsigned char)1;
    }
    {
#line 466
    c = find_config_next(c, c->next, 1 << 15, "HideFiles", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  if (have_user_regex) {
#line 469
    goto _L;
  } else
#line 469
  if (have_group_regex) {
#line 469
    goto _L;
  } else
#line 469
  if (have_class_regex) {
#line 469
    goto _L;
  } else
#line 469
  if (have_all_regex) {
    _L: /* CIL Label */ 
#line 472
    if (have_user_regex) {
#line 472
      tmp___9 = "user";
    } else {
#line 472
      if (have_group_regex) {
#line 472
        tmp___8 = "group";
      } else {
#line 472
        if (have_class_regex) {
#line 472
          tmp___7 = "class";
        } else {
#line 472
          tmp___7 = "session";
        }
#line 472
        tmp___8 = tmp___7;
      }
#line 472
      tmp___9 = tmp___8;
    }
    {
#line 472
    pr_log_debug(4, "checking HideFiles pattern for current %s", tmp___9);
#line 476
    tmp___12 = regexec((regex_t const   */* __restrict  */)regexp, (char const   */* __restrict  */)file_name,
                       (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 476
    if (tmp___12 != 0) {
      {
#line 477
      destroy_pool(tmp_pool);
      }
#line 483
      if (inverted) {
#line 483
        tmp___10 = 1;
      } else {
#line 483
        tmp___10 = 0;
      }
#line 483
      return ((unsigned char )tmp___10);
    } else {
      {
#line 486
      destroy_pool(tmp_pool);
      }
#line 492
      if (inverted) {
#line 492
        tmp___11 = 0;
      } else {
#line 492
        tmp___11 = 1;
      }
#line 492
      return ((unsigned char )tmp___11);
    }
  }
  {
#line 496
  destroy_pool(tmp_pool);
  }
#line 500
  return ((unsigned char)0);
}
}
#line 503 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void define_restart_ev(void const   *event_data , void *user_data ) 
{ 
  char *__cil_tmp3 ;

  {
#line 504
  if (defines_pool) {
    {
#line 505
    destroy_pool(defines_pool);
#line 506
    defines_pool = (pool *)((void *)0);
#line 507
    defines_list = (array_header *)((void *)0);
    }
  }
  {
#line 510
  pr_event_unregister((module *)((void *)0), "core.restart", & define_restart_ev);
  }
#line 511
  return;
}
}
#line 513 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int pr_define_add(char const   *definition ) 
{ 
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 515
  if (! defines_list) {
    {
#line 516
    defines_pool = make_sub_pool(permanent_pool);
#line 517
    pr_pool_tag(defines_pool, "Defines Pool");
#line 518
    defines_list = make_array(defines_pool, 0U, (size_t )sizeof(char *));
#line 520
    pr_event_register((module *)((void *)0), "core.restart", & define_restart_ev,
                      (void *)0);
    }
  }
  {
#line 523
  tmp = push_array(defines_list);
#line 523
  *((char **)tmp) = pstrdup(defines_pool, definition);
  }
#line 524
  return (0);
}
}
#line 527 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
unsigned char pr_define_exists(char const   *definition ) 
{ 
  char **defines ;
  register unsigned int i___0 ;
  int tmp ;
  int *tmp___0 ;

  {
#line 529
  if (defines_list) {
#line 530
    defines = (char **)defines_list->elts;
#line 531
    i___0 = 0U;
#line 533
    i___0 = 0U;
    {
#line 533
    while (1) {
      while_continue: /* CIL Label */ ;
#line 533
      if (! (i___0 < (unsigned int )defines_list->nelts)) {
#line 533
        goto while_break;
      }
#line 534
      if (*(defines + i___0)) {
        {
#line 534
        tmp = strcmp((char const   *)*(defines + i___0), definition);
        }
#line 534
        if (tmp == 0) {
#line 536
          return ((unsigned char)1);
        }
      }
#line 533
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 540
  tmp___0 = __errno_location();
#line 540
  *tmp___0 = 2;
  }
#line 541
  return ((unsigned char)0);
}
}
#line 544 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void kludge_disable_umask(void) 
{ 


  {
#line 545
  _kludge_disable_umask = (unsigned char)1;
#line 546
  return;
}
}
#line 548 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void kludge_enable_umask(void) 
{ 


  {
#line 549
  _kludge_disable_umask = (unsigned char)0;
#line 550
  return;
}
}
#line 552 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
cmd_rec *pr_cmd_alloc(pool *p , int argc  , ...) 
{ 
  pool *newpool ;
  cmd_rec *cmd ;
  va_list args ;
  void *tmp ;
  register unsigned int i___0 ;
  void *tmp___0 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 553
  newpool = (pool *)((void *)0);
#line 554
  cmd = (cmd_rec *)((void *)0);
#line 557
  newpool = make_sub_pool(p);
#line 558
  pr_pool_tag(newpool, "pr_cmd_alloc() subpool");
#line 560
  tmp = pcalloc(newpool, (int )sizeof(cmd_rec ));
#line 560
  cmd = (cmd_rec *)tmp;
#line 561
  cmd->argc = argc;
#line 562
  cmd->stash_index = -1;
#line 563
  cmd->pool = newpool;
#line 564
  cmd->tmp_pool = make_sub_pool(cmd->pool);
#line 565
  pr_pool_tag(cmd->tmp_pool, "pr_cmd_alloc() tmp pool");
  }
#line 567
  if (argc) {
    {
#line 568
    i___0 = 0U;
#line 570
    tmp___0 = pcalloc(newpool, (int )(sizeof(void *) * (unsigned long )(argc + 1)));
#line 570
    cmd->argv = (char **)tmp___0;
#line 571
    __builtin_va_start(args, argc);
#line 573
    i___0 = 0U;
    }
    {
#line 573
    while (1) {
      while_continue: /* CIL Label */ ;
#line 573
      if (! (i___0 < (unsigned int )argc)) {
#line 573
        goto while_break;
      }
      {
#line 574
      tmp___2 = __builtin_va_arg(args, char *);
#line 574
      *(cmd->argv + i___0) = (char *)((void *)tmp___2);
#line 573
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 576
    __builtin_va_end(args);
#line 578
    *(cmd->argv + argc) = (char *)((void *)0);
    }
  }
  {
#line 584
  cmd->notes = pr_table_nalloc(cmd->pool, 0, 8U);
  }
#line 586
  return (cmd);
}
}
#line 590 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *add_config_set(xaset_t **set , char const   *name ) 
{ 
  pool *conf_pool ;
  pool *set_pool ;
  config_rec *c ;
  config_rec *parent ;
  void *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 591
  conf_pool = (pool *)((void *)0);
#line 591
  set_pool = (pool *)((void *)0);
#line 592
  parent = (config_rec *)((void *)0);
#line 594
  if (! *set) {
    {
#line 597
    set_pool = make_sub_pool(permanent_pool);
#line 598
    pr_pool_tag(set_pool, "config set pool");
#line 600
    *set = xaset_create(set_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
#line 601
    (*set)->pool = set_pool;
#line 607
    conf_pool = pr_pool_create_sz(set_pool, 128);
    }
  } else {
#line 612
    if ((*set)->xas_list) {
#line 613
      parent = ((config_rec *)(*set)->xas_list)->parent;
    }
    {
#line 620
    conf_pool = pr_pool_create_sz((*set)->pool, 128);
    }
  }
  {
#line 623
  pr_pool_tag(conf_pool, "config_rec pool");
#line 625
  tmp = pcalloc(conf_pool, (int )sizeof(config_rec ));
#line 625
  c = (config_rec *)tmp;
#line 627
  c->pool = conf_pool;
#line 628
  c->set = *set;
#line 629
  c->parent = parent;
  }
#line 631
  if (name) {
    {
#line 632
    c->name = pstrdup(conf_pool, name);
#line 633
    c->config_id = pr_config_set_id(name);
    }
  }
  {
#line 636
  xaset_insert_end(*set, (xasetmember_t *)c);
  }
#line 638
  return (c);
}
}
#line 644 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *add_config(server_rec *s , char const   *name ) 
{ 
  config_rec *parent ;
  config_rec *c ;
  pool *p ;
  xaset_t **set ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 645
  parent = (config_rec *)((void *)0);
#line 645
  c = (config_rec *)((void *)0);
#line 646
  p = (pool *)((void *)0);
#line 647
  set = (xaset_t **)((void *)0);
#line 649
  if (! s) {
    {
#line 650
    s = pr_parser_server_ctxt_get();
    }
  }
  {
#line 652
  c = pr_parser_config_ctxt_get();
  }
#line 654
  if (c) {
#line 655
    parent = c;
#line 656
    p = c->pool;
#line 657
    set = & c->subset;
  } else {
#line 660
    parent = (config_rec *)((void *)0);
#line 662
    if (! s->conf) {
      {
#line 663
      p = make_sub_pool(s->pool);
#line 664
      pr_pool_tag(p, "add_config() subpool");
      }
    } else
#line 662
    if (! (s->conf)->xas_list) {
      {
#line 663
      p = make_sub_pool(s->pool);
#line 664
      pr_pool_tag(p, "add_config() subpool");
      }
    } else {
#line 667
      p = ((config_rec *)(s->conf)->xas_list)->pool;
    }
#line 669
    set = & s->conf;
  }
#line 672
  if (! *set) {
    {
#line 673
    *set = xaset_create(p, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
  {
#line 675
  c = add_config_set(set, name);
#line 676
  c->parent = parent;
  }
#line 678
  return (c);
}
}
#line 683 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static size_t _strmatch(char *s1 , char *s2 ) 
{ 
  register size_t len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 684
  len = (size_t )0;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (*s1) {
#line 686
      if (*s2) {
#line 686
        tmp = s1;
#line 686
        s1 ++;
#line 686
        tmp___0 = s2;
#line 686
        s2 ++;
#line 686
        if (! ((int )*tmp == (int )*tmp___0)) {
#line 686
          goto while_break;
        }
      } else {
#line 686
        goto while_break;
      }
    } else {
#line 686
      goto while_break;
    }
#line 687
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  return (len);
}
}
#line 692 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static config_rec *recur_match_path(pool *p , xaset_t *s , char *path ) 
{ 
  char *tmp_path ;
  config_rec *c ;
  config_rec *res ;
  int *tmp ;
  size_t path_len ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 693
  tmp_path = (char *)((void *)0);
#line 694
  c = (config_rec *)((void *)0);
#line 694
  res = (config_rec *)((void *)0);
#line 696
  if (! s) {
    {
#line 697
    tmp = __errno_location();
#line 697
    *tmp = 22;
    }
#line 698
    return ((config_rec *)((void *)0));
  }
#line 701
  c = (config_rec *)s->xas_list;
  {
#line 701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (! c) {
#line 701
      goto while_break;
    }
#line 702
    if (c->config_type == 1 << 1) {
#line 705
      tmp_path = c->name;
#line 707
      if (*(c->argv + 1)) {
#line 708
        if ((int )*((char *)*(c->argv + 1)) == 126) {
          {
#line 709
          tmp___0 = dir_canonical_path(c->pool, (char const   *)((char *)*(c->argv + 1)));
#line 709
          *(c->argv + 1) = (void *)tmp___0;
          }
        }
        {
#line 711
        tmp_path = pdircat(p, (char *)*(c->argv + 1), tmp_path, (void *)0);
        }
      }
      {
#line 715
      tmp___1 = strcmp((char const   *)tmp_path, (char const   *)path);
      }
#line 715
      if (tmp___1 == 0) {
        {
#line 716
        pr_trace_msg("directory", 8, "<Directory %s> is an exact path match for \'%s\'",
                     c->name, path);
        }
#line 718
        return (c);
      }
      {
#line 732
      path_len = strlen((char const   *)tmp_path);
      }
#line 733
      if (path_len > 2U) {
#line 733
        if ((int )*(tmp_path + (path_len - 2U)) != 47) {
#line 733
          if ((int )*(tmp_path + (path_len - 1U)) != 42) {
#line 738
            if (*tmp_path) {
#line 738
              if ((int )*((tmp_path + path_len) - 1) == 47) {
#line 738
                if (path_len > 1U) {
                  {
#line 739
                  *((tmp_path + path_len) - 1) = (char )'\000';
#line 741
                  tmp___2 = strcmp((char const   *)tmp_path, (char const   *)path);
                  }
#line 741
                  if (tmp___2 == 0) {
                    {
#line 742
                    pr_trace_msg("directory", 8, "<Directory %s> is an exact path match for \'%s\'",
                                 c->name, path);
                    }
#line 744
                    return (c);
                  }
                }
              }
            }
            {
#line 748
            tmp_path = pdircat(p, tmp_path, "*", (void *)0);
            }
          } else {
#line 733
            goto _L___0;
          }
        } else {
#line 733
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 750
      if (path_len == 1U) {
        {
#line 752
        tmp_path = pstrcat(p, tmp_path, "*", (void *)0);
        }
      }
      {
#line 755
      pr_trace_msg("directory", 9, "checking if <Directory %s> is a glob match for %s",
                   tmp_path, path);
#line 758
      tmp___3 = pr_fnmatch((char const   *)tmp_path, (char const   *)path, 0);
      }
#line 758
      if (tmp___3 == 0) {
        {
#line 759
        pr_trace_msg("directory", 8, "<Directory %s> is a glob match for \'%s\'",
                     tmp_path, path);
        }
#line 762
        if (c->subset) {
          {
#line 766
          res = recur_match_path(p, c->subset, path);
          }
#line 767
          if (res) {
            {
#line 768
            pr_trace_msg("directory", 8, "found closer matching <Directory %s> for \'%s\' in <Directory %s> sub-config",
                         res->name, path, tmp_path);
            }
#line 771
            return (res);
          }
        }
        {
#line 775
        pr_trace_msg("directory", 8, "found <Directory %s> for \'%s\'", c->name, path);
        }
#line 777
        return (c);
      }
    }
#line 701
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 782
  tmp___4 = __errno_location();
#line 782
  *tmp___4 = 2;
  }
#line 783
  return ((config_rec *)((void *)0));
}
}
#line 786 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *dir_match_path(pool *p , char *path ) 
{ 
  config_rec *res ;
  char *tmp ;
  size_t tmplen ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 787
  res = (config_rec *)((void *)0);
#line 788
  tmp = (char *)((void *)0);
#line 791
  if (! p) {
#line 792
    return ((config_rec *)((void *)0));
  } else
#line 791
  if (! path) {
#line 792
    return ((config_rec *)((void *)0));
  } else
#line 791
  if (! *path) {
#line 792
    return ((config_rec *)((void *)0));
  }
  {
#line 795
  tmp = pstrdup(p, (char const   *)path);
#line 796
  tmplen = strlen((char const   *)tmp);
  }
#line 798
  if ((int )*((tmp + tmplen) - 1) == 42) {
    {
#line 799
    *((tmp + tmplen) - 1) = (char )'\000';
#line 800
    tmplen = strlen((char const   *)tmp);
    }
  }
#line 803
  if ((int )*((tmp + tmplen) - 1) == 47) {
#line 803
    if (tmplen > 1U) {
#line 804
      *((tmp + tmplen) - 1) = (char )'\000';
    }
  }
#line 806
  if (session.anon_config) {
    {
#line 807
    res = recur_match_path(p, (session.anon_config)->subset, tmp);
    }
#line 809
    if (! res) {
#line 810
      if (session.chroot_path) {
        {
#line 810
        tmp___0 = strlen((char const   *)session.chroot_path);
#line 810
        tmp___1 = strncmp((char const   *)session.chroot_path, (char const   *)tmp,
                          tmp___0);
        }
#line 810
        if (! tmp___1) {
#line 812
          return ((config_rec *)((void *)0));
        }
      }
    }
  }
#line 816
  if (! res) {
    {
#line 817
    res = recur_match_path(p, main_server->conf, tmp);
    }
  }
#line 820
  if (res) {
    {
#line 821
    pr_trace_msg("directory", 3, "matched <Directory %s> for path \'%s\'", res->name,
                 tmp);
    }
  } else {
    {
#line 825
    tmp___2 = __errno_location();
#line 825
    tmp___3 = strerror(*tmp___2);
#line 825
    pr_trace_msg("directory", 3, "no matching <Directory> found for \'%s\': %s", tmp,
                 tmp___3);
    }
  }
#line 829
  return (res);
}
}
#line 833 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int dir_check_op(pool *p , xaset_t *c , int op , char const   *path , uid_t uid ,
                        gid_t gid , mode_t mode ) 
{ 
  int res ;
  uid_t *u ;
  gid_t *g ;
  unsigned char *hide_no_access ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  unsigned char *allow_all ;
  void *tmp___8 ;
  unsigned char *deny_all ;
  void *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 835
  res = 1;
#line 836
  u = (uid_t *)((void *)0);
#line 837
  g = (gid_t *)((void *)0);
#line 838
  hide_no_access = (unsigned char *)((void *)0);
#line 841
  if (! c) {
#line 842
    return (1);
  }
  {
#line 845
  if (op == 1) {
#line 845
    goto case_1;
  }
#line 893
  if (op == 2) {
#line 893
    goto case_2;
  }
#line 844
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 846
  tmp = get_param_ptr(c, "HideUser", 0);
#line 846
  u = (uid_t *)tmp;
  }
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (u) {
#line 848
      if (*u != 4294967295U) {
#line 848
        if (! (*u != uid)) {
#line 848
          if (! (*u == session.uid)) {
#line 848
            goto while_break;
          }
        }
      } else {
#line 848
        goto while_break;
      }
    } else {
#line 848
      goto while_break;
    }
    {
#line 851
    tmp___0 = get_param_ptr_next("HideUser", 0);
#line 851
    u = (uid_t *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  if (u) {
#line 853
    if (*u == uid) {
#line 855
      res = 0;
#line 856
      goto switch_break;
    }
  }
  {
#line 859
  tmp___1 = get_param_ptr(c, "HideGroup", 0);
#line 859
  g = (gid_t *)tmp___1;
  }
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (g) {
#line 861
      if (*g != 4294967295U) {
#line 861
        if (! (*g != gid)) {
#line 861
          if (! (*g == session.gid)) {
#line 861
            goto while_break___0;
          }
        }
      } else {
#line 861
        goto while_break___0;
      }
    } else {
#line 861
      goto while_break___0;
    }
    {
#line 864
    tmp___2 = get_param_ptr_next("HideGroup", 0);
#line 864
    g = (gid_t *)tmp___2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 866
  if (g) {
#line 866
    if (*g == gid) {
#line 868
      res = 0;
#line 869
      goto switch_break;
    }
  }
  {
#line 872
  tmp___3 = get_param_ptr(c, "HideNoAccess", 0);
#line 872
  hide_no_access = (unsigned char *)tmp___3;
  }
#line 873
  if (hide_no_access) {
#line 873
    if ((int )*hide_no_access == 1) {
#line 876
      if ((mode & 61440U) == 16384U) {
        {
#line 880
        tmp___5 = pr_fsio_access(path, 1, session.uid, session.gid, session.gids);
        }
#line 880
        if (tmp___5 == 0) {
#line 880
          res = 1;
        } else {
#line 880
          res = 0;
        }
      } else {
        {
#line 887
        tmp___7 = pr_fsio_access(path, 4, session.uid, session.gid, session.gids);
        }
#line 887
        if (tmp___7 == 0) {
#line 887
          res = 1;
        } else {
#line 887
          res = 0;
        }
      }
    }
  }
#line 891
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 894
  tmp___8 = get_param_ptr(c, "AllowAll", 0);
#line 894
  allow_all = (unsigned char *)tmp___8;
#line 895
  tmp___9 = get_param_ptr(c, "DenyAll", 0);
#line 895
  deny_all = (unsigned char *)tmp___9;
  }
#line 897
  if (allow_all) {
#line 897
    if (! ((int )*allow_all == 1)) {
#line 897
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 902
  if (deny_all) {
#line 902
    if ((int )*deny_all == 1) {
      {
#line 904
      res = 0;
#line 905
      tmp___10 = __errno_location();
#line 905
      *tmp___10 = 13;
      }
    }
  }
#line 908
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 911
  return (res);
}
}
#line 914 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_user_access(xaset_t *set , char *name ) 
{ 
  int res ;
  config_rec *c ;
  config_rec *tmp ;
  regex_t *preg ;
  int tmp___0 ;

  {
  {
#line 915
  res = 0;
#line 916
  tmp = find_config(set, 1 << 15, (char const   *)name, 0);
#line 916
  c = tmp;
  }
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! c) {
#line 918
      goto while_break;
    }
#line 920
    if ((int )*((unsigned char *)*(c->argv + 0)) == 2) {
      {
#line 921
      preg = (regex_t *)*(c->argv + 1);
#line 923
      tmp___0 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)session.user,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 923
      if (tmp___0 == 0) {
#line 924
        res = 1;
#line 925
        goto while_break;
      }
    } else
#line 931
    if ((int )*((unsigned char *)*(c->argv + 0)) == 1) {
      {
#line 932
      res = pr_expr_eval_user_or((char **)(c->argv + 1));
      }
#line 934
      if (res == 1) {
#line 935
        goto while_break;
      }
    } else
#line 937
    if ((int )*((unsigned char *)*(c->argv + 0)) == 0) {
      {
#line 938
      res = pr_expr_eval_user_and((char **)(c->argv + 1));
      }
#line 940
      if (res == 1) {
#line 941
        goto while_break;
      }
    }
    {
#line 944
    c = find_config_next(c, c->next, 1 << 15, (char const   *)name, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return (res);
}
}
#line 950 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_group_access(xaset_t *set , char *name ) 
{ 
  int res ;
  config_rec *c ;
  config_rec *tmp ;
  regex_t *preg ;
  register int i___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 951
  res = 0;
#line 952
  tmp = find_config(set, 1 << 15, (char const   *)name, 0);
#line 952
  c = tmp;
  }
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 954
    if (! c) {
#line 954
      goto while_break;
    }
#line 956
    if ((int )*((unsigned char *)*(c->argv + 0)) == 2) {
#line 957
      preg = (regex_t *)*(c->argv + 1);
#line 959
      if (session.group) {
        {
#line 959
        tmp___1 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)session.group,
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 959
        if (tmp___1 == 0) {
#line 960
          res = 1;
#line 961
          goto while_break;
        } else {
#line 959
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 963
      if (session.groups) {
#line 964
        i___0 = 0;
#line 966
        i___0 = (session.groups)->nelts - 1;
        {
#line 966
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 966
          if (! (i___0 >= 0)) {
#line 966
            goto while_break___0;
          }
          {
#line 967
          tmp___0 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)*((char **)(session.groups)->elts + i___0),
                            (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                            0);
          }
#line 967
          if (tmp___0 == 0) {
#line 969
            res = 1;
#line 970
            goto while_break___0;
          }
#line 966
          i___0 --;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 977
    if ((int )*((unsigned char *)*(c->argv + 0)) == 1) {
      {
#line 978
      res = pr_expr_eval_group_or((char **)(c->argv + 1));
      }
#line 980
      if (res == 1) {
#line 981
        goto while_break;
      }
    } else
#line 983
    if ((int )*((unsigned char *)*(c->argv + 0)) == 0) {
      {
#line 984
      res = pr_expr_eval_group_and((char **)(c->argv + 1));
      }
#line 986
      if (res == 1) {
#line 987
        goto while_break;
      }
    }
    {
#line 990
    c = find_config_next(c, c->next, 1 << 15, (char const   *)name, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  return (res);
}
}
#line 996 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_class_access(xaset_t *set , char *name ) 
{ 
  int res ;
  config_rec *c ;
  config_rec *tmp ;
  regex_t *preg ;
  int tmp___0 ;

  {
  {
#line 997
  res = 0;
#line 998
  tmp = find_config(set, 1 << 15, (char const   *)name, 0);
#line 998
  c = tmp;
  }
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! c) {
#line 1000
      goto while_break;
    }
#line 1002
    if ((int )*((unsigned char *)*(c->argv + 0)) == 2) {
#line 1003
      preg = (regex_t *)*(c->argv + 1);
#line 1005
      if (session.class) {
        {
#line 1005
        tmp___0 = regexec((regex_t const   */* __restrict  */)preg, (char const   */* __restrict  */)(session.class)->cls_name,
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 1005
        if (tmp___0 == 0) {
#line 1007
          res = 1;
#line 1008
          goto while_break;
        }
      }
    } else
#line 1014
    if ((int )*((unsigned char *)*(c->argv + 0)) == 1) {
      {
#line 1015
      res = pr_expr_eval_class_or((char **)(c->argv + 1));
      }
#line 1017
      if (res == 1) {
#line 1018
        goto while_break;
      }
    } else
#line 1020
    if ((int )*((unsigned char *)*(c->argv + 0)) == 0) {
      {
#line 1021
      res = pr_expr_eval_class_and((char **)(c->argv + 1));
      }
#line 1023
      if (res == 1) {
#line 1024
        goto while_break;
      }
    }
    {
#line 1027
    c = find_config_next(c, c->next, 1 << 15, (char const   *)name, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1030
  return (res);
}
}
#line 1050 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_ip_negative(config_rec const   *c ) 
{ 
  int aclc ;
  pr_netacl_t **aclv ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1054
  aclc = (int )c->argc;
#line 1054
  aclv = (pr_netacl_t **)c->argv;
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! aclc) {
#line 1054
      goto while_break;
    }
    {
#line 1055
    tmp = pr_netacl_get_negated(*aclv);
    }
#line 1055
    if (tmp == 0) {
#line 1056
      goto __Cont;
    }
    {
#line 1058
    tmp___0 = pr_netacl_match(*aclv, (session.c)->remote_addr);
    }
    {
#line 1059
    if (tmp___0 == 1) {
#line 1059
      goto case_1;
    }
#line 1065
    if (tmp___0 == -1) {
#line 1065
      goto case_neg_1;
    }
#line 1073
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1063
    return (0);
    case_neg_1: /* CIL Label */ 
    {
#line 1069
    pr_log_pri(3, "ooops, it looks like !NONE was used in an ACL somehow.");
    }
#line 1071
    return (0);
    switch_default: /* CIL Label */ 
#line 1075
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1054
    aclc --;
#line 1054
    aclv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1083
  return (1);
}
}
#line 1089 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_ip_positive(config_rec const   *c ) 
{ 
  int aclc ;
  pr_netacl_t **aclv ;
  int tmp ;
  int tmp___0 ;

  {
#line 1093
  aclc = (int )c->argc;
#line 1093
  aclv = (pr_netacl_t **)c->argv;
  {
#line 1093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (! aclc) {
#line 1093
      goto while_break;
    }
    {
#line 1094
    tmp = pr_netacl_get_negated(*aclv);
    }
#line 1094
    if (tmp == 1) {
#line 1095
      goto __Cont;
    }
    {
#line 1097
    tmp___0 = pr_netacl_match(*aclv, (session.c)->remote_addr);
    }
    {
#line 1098
    if (tmp___0 == 1) {
#line 1098
      goto case_1;
    }
#line 1102
    if (tmp___0 == -1) {
#line 1102
      goto case_neg_1;
    }
#line 1108
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1100
    return (1);
    case_neg_1: /* CIL Label */ 
#line 1106
    return (0);
    switch_default: /* CIL Label */ 
#line 1110
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1093
    aclc --;
#line 1093
    aclv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1115
  return (0);
}
}
#line 1118 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_ip_access(xaset_t *set , char *name ) 
{ 
  int res ;
  config_rec *c ;
  config_rec *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1119
  res = 0;
#line 1121
  tmp = find_config(set, 1 << 15, (char const   *)name, 0);
#line 1121
  c = tmp;
  }
  {
#line 1123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1123
    if (! c) {
#line 1123
      goto while_break;
    }
    {
#line 1127
    tmp___0 = _check_ip_negative((config_rec const   *)c);
    }
#line 1127
    if (tmp___0 != 1) {
#line 1128
      return (0);
    }
    {
#line 1131
    tmp___1 = _check_ip_positive((config_rec const   *)c);
    }
#line 1131
    if (tmp___1 == 1) {
#line 1132
      res = 1;
    }
    {
#line 1137
    c = find_config_next(c, c->next, 1 << 15, (char const   *)name, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  return (res);
}
}
#line 1145 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_limit_allow(config_rec *c ) 
{ 
  unsigned char *allow_all ;
  config_rec *tmp ;
  int tmp___0 ;
  config_rec *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1146
  allow_all = (unsigned char *)((void *)0);
#line 1156
  if (! session.user) {
    {
#line 1157
    tmp = find_config(c->subset, 1 << 15, "AllowUser", 0);
    }
#line 1157
    if (tmp) {
#line 1158
      return (1);
    }
  } else {
    {
#line 1160
    tmp___0 = _check_user_access(c->subset, (char *)"AllowUser");
    }
#line 1160
    if (tmp___0) {
#line 1161
      return (1);
    }
  }
#line 1163
  if (! session.groups) {
    {
#line 1164
    tmp___1 = find_config(c->subset, 1 << 15, "AllowGroup", 0);
    }
#line 1164
    if (tmp___1) {
#line 1165
      return (1);
    }
  } else {
    {
#line 1167
    tmp___2 = _check_group_access(c->subset, (char *)"AllowGroup");
    }
#line 1167
    if (tmp___2) {
#line 1168
      return (1);
    }
  }
#line 1170
  if (session.class) {
    {
#line 1170
    tmp___3 = _check_class_access(c->subset, (char *)"AllowClass");
    }
#line 1170
    if (tmp___3) {
#line 1172
      return (1);
    }
  }
  {
#line 1174
  tmp___4 = _check_ip_access(c->subset, (char *)"Allow");
  }
#line 1174
  if (tmp___4) {
#line 1175
    return (1);
  }
  {
#line 1177
  tmp___5 = get_param_ptr(c->subset, "AllowAll", 0);
#line 1177
  allow_all = (unsigned char *)tmp___5;
  }
#line 1178
  if (allow_all) {
#line 1178
    if ((int )*allow_all == 1) {
#line 1179
      return (1);
    }
  }
#line 1181
  return (0);
}
}
#line 1184 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_limit_deny(config_rec *c ) 
{ 
  unsigned char *deny_all ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1185
  tmp = get_param_ptr(c->subset, "DenyAll", 0);
#line 1185
  deny_all = (unsigned char *)tmp;
  }
#line 1187
  if (deny_all) {
#line 1187
    if ((int )*deny_all == 1) {
#line 1188
      return (1);
    }
  }
#line 1190
  if (session.user) {
    {
#line 1190
    tmp___0 = _check_user_access(c->subset, (char *)"DenyUser");
    }
#line 1190
    if (tmp___0) {
#line 1192
      return (1);
    }
  }
#line 1194
  if (session.groups) {
    {
#line 1194
    tmp___1 = _check_group_access(c->subset, (char *)"DenyGroup");
    }
#line 1194
    if (tmp___1) {
#line 1196
      return (1);
    }
  }
#line 1198
  if (session.class) {
    {
#line 1198
    tmp___2 = _check_class_access(c->subset, (char *)"DenyClass");
    }
#line 1198
    if (tmp___2) {
#line 1200
      return (1);
    }
  }
  {
#line 1202
  tmp___3 = _check_ip_access(c->subset, (char *)"Deny");
  }
#line 1202
  if (tmp___3) {
#line 1203
    return (1);
  }
#line 1205
  return (0);
}
}
#line 1212 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_limit(config_rec *c ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int order ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;

  {
  {
#line 1213
  tmp___0 = get_param_ptr(c->subset, "Order", 0);
#line 1213
  tmp = (int *)tmp___0;
  }
#line 1214
  if (tmp) {
#line 1214
    tmp___1 = *tmp;
  } else {
#line 1214
    tmp___1 = 0;
  }
#line 1214
  order = tmp___1;
#line 1216
  if (order == 1) {
    {
#line 1219
    tmp___2 = _check_limit_deny(c);
    }
#line 1219
    if (tmp___2) {
#line 1221
      return (-2);
    }
    {
#line 1223
    tmp___3 = _check_limit_allow(c);
    }
#line 1223
    if (tmp___3) {
#line 1225
      return (1);
    }
#line 1228
    return (-1);
  }
  {
#line 1232
  tmp___4 = _check_limit_allow(c);
  }
#line 1232
  if (tmp___4) {
#line 1234
    return (1);
  }
  {
#line 1236
  tmp___5 = _check_limit_deny(c);
  }
#line 1236
  if (tmp___5) {
#line 1238
    return (-2);
  }
#line 1241
  return (0);
}
}
#line 1250 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int login_check_limits(xaset_t *set , int recurse , int and , int *found ) 
{ 
  int res ;
  int rfound ;
  config_rec *c ;
  int argc ;
  char **argv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int rres ;
  int tmp___6 ;
  char *__cil_tmp19 ;

  {
#line 1251
  res = and;
#line 1257
  *found = 0;
#line 1259
  if (! set) {
#line 1260
    return (1);
  } else
#line 1259
  if (! set->xas_list) {
#line 1260
    return (1);
  }
#line 1263
  c = (config_rec *)set->xas_list;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! c) {
#line 1263
      goto while_break;
    }
#line 1264
    if (c->config_type == 1 << 3) {
#line 1265
      argc = c->argc;
#line 1265
      argv = (char **)c->argv;
      {
#line 1265
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1265
        if (! argc) {
#line 1265
          goto while_break___0;
        }
        {
#line 1266
        tmp = strcasecmp("LOGIN", (char const   *)*argv);
        }
#line 1266
        if (tmp == 0) {
#line 1267
          goto while_break___0;
        }
#line 1265
        argc --;
#line 1265
        argv ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1271
      if (argc) {
#line 1272
        if (and) {
          {
#line 1273
          tmp___0 = _check_limit(c);
          }
          {
#line 1274
          if (tmp___0 == 1) {
#line 1274
            goto case_1;
          }
#line 1280
          if (tmp___0 == -2) {
#line 1280
            goto case_neg_2;
          }
#line 1280
          if (tmp___0 == -1) {
#line 1280
            goto case_neg_2;
          }
#line 1273
          goto switch_break;
          case_1: /* CIL Label */ 
#line 1275
          if (res) {
#line 1275
            tmp___1 = 1;
          } else {
#line 1275
            tmp___1 = 0;
          }
#line 1275
          res = tmp___1;
#line 1276
          (*found) ++;
#line 1277
          goto switch_break;
          case_neg_2: /* CIL Label */ 
          case_neg_1: /* CIL Label */ 
#line 1281
          if (res) {
#line 1281
            tmp___2 = 0;
          } else {
#line 1281
            tmp___2 = 0;
          }
#line 1281
          res = tmp___2;
#line 1282
          (*found) ++;
#line 1283
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 1286
          if (! res) {
#line 1287
            goto while_break;
          }
        } else {
          {
#line 1290
          tmp___3 = _check_limit(c);
          }
          {
#line 1291
          if (tmp___3 == 1) {
#line 1291
            goto case_1___0;
          }
#line 1295
          if (tmp___3 == -2) {
#line 1295
            goto case_neg_2___0;
          }
#line 1295
          if (tmp___3 == -1) {
#line 1295
            goto case_neg_2___0;
          }
#line 1290
          goto switch_break___0;
          case_1___0: /* CIL Label */ 
#line 1292
          res = 1;
          case_neg_2___0: /* CIL Label */ 
          case_neg_1___0: /* CIL Label */ 
#line 1296
          (*found) ++;
#line 1297
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 1263
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1304
  if (res) {
#line 1304
    if (and) {
#line 1304
      goto _L;
    } else {
#line 1304
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1304
  if (! res) {
#line 1304
    if (! and) {
#line 1304
      if (*found) {
        _L: /* CIL Label */ 
#line 1304
        if (recurse) {
#line 1305
          c = (config_rec *)set->xas_list;
          {
#line 1305
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1305
            if (! c) {
#line 1305
              goto while_break___1;
            }
#line 1306
            if (c->config_type == 1 << 2) {
#line 1306
              if (c->subset) {
#line 1306
                if ((c->subset)->xas_list) {
#line 1309
                  if (and) {
#line 1310
                    if (res) {
                      {
#line 1310
                      tmp___4 = login_check_limits(c->subset, recurse, and, & rfound);
                      }
#line 1310
                      if (tmp___4) {
#line 1310
                        tmp___5 = 1;
                      } else {
#line 1310
                        tmp___5 = 0;
                      }
                    } else {
#line 1310
                      tmp___5 = 0;
                    }
#line 1310
                    res = tmp___5;
#line 1311
                    *found += rfound;
#line 1312
                    if (! res) {
#line 1313
                      goto while_break___1;
                    }
                  } else {
                    {
#line 1318
                    rres = login_check_limits(c->subset, recurse, and, & rfound);
                    }
#line 1319
                    if (rfound) {
#line 1320
                      if (res) {
#line 1320
                        tmp___6 = 1;
                      } else
#line 1320
                      if (rres) {
#line 1320
                        tmp___6 = 1;
                      } else {
#line 1320
                        tmp___6 = 0;
                      }
#line 1320
                      res = tmp___6;
                    }
#line 1322
                    *found += rfound;
#line 1323
                    if (res) {
#line 1324
                      goto while_break___1;
                    }
                  }
                }
              }
            }
#line 1305
            c = c->next;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1330
  if (! *found) {
#line 1330
    if (! and) {
#line 1331
      return (1);
    }
  }
#line 1333
  return (res);
}
}
#line 1338 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int _check_limits(xaset_t *set , char *cmd , int hidden ) 
{ 
  int res ;
  int ignore_hidden ;
  config_rec *lc ;
  int *tmp ;
  register unsigned int i___0 ;
  int tmp___0 ;
  unsigned char *ignore ;
  void *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp16 ;

  {
  {
#line 1339
  res = 1;
#line 1339
  ignore_hidden = -1;
#line 1340
  lc = (config_rec *)((void *)0);
#line 1342
  tmp = __errno_location();
#line 1342
  *tmp = 0;
  }
#line 1344
  if (! set) {
#line 1345
    return (res);
  }
#line 1347
  lc = (config_rec *)set->xas_list;
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if (lc) {
#line 1347
      if (! (res == 1)) {
#line 1347
        goto while_break;
      }
    } else {
#line 1347
      goto while_break;
    }
    {
#line 1348
    pr_signals_handle();
    }
#line 1350
    if (lc->config_type == 1 << 3) {
#line 1351
      i___0 = 0U;
#line 1353
      i___0 = 0U;
      {
#line 1353
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1353
        if (! (i___0 < (unsigned int )lc->argc)) {
#line 1353
          goto while_break___0;
        }
        {
#line 1354
        tmp___0 = strcasecmp((char const   *)cmd, (char const   *)((char *)*(lc->argv + i___0)));
        }
#line 1354
        if (tmp___0 == 0) {
#line 1355
          goto while_break___0;
        }
#line 1353
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1359
      if (i___0 == (unsigned int )lc->argc) {
#line 1360
        goto __Cont;
      }
#line 1369
      if (hidden) {
#line 1369
        if (ignore_hidden == -1) {
          {
#line 1370
          tmp___1 = get_param_ptr(lc->subset, "IgnoreHidden", 0);
#line 1370
          ignore = (unsigned char *)tmp___1;
          }
#line 1373
          if (ignore) {
#line 1374
            ignore_hidden = (int )*ignore;
          }
#line 1376
          if (ignore_hidden == 1) {
            {
#line 1377
            res = 0;
#line 1378
            tmp___2 = __errno_location();
#line 1378
            *tmp___2 = 2;
            }
#line 1379
            goto while_break;
          }
        }
      }
      {
#line 1383
      tmp___3 = _check_limit(lc);
      }
      {
#line 1384
      if (tmp___3 == 1) {
#line 1384
        goto case_1;
      }
#line 1389
      if (tmp___3 == -2) {
#line 1389
        goto case_neg_2;
      }
#line 1389
      if (tmp___3 == -1) {
#line 1389
        goto case_neg_2;
      }
#line 1393
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1385
      res ++;
#line 1386
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 1390
      res = 0;
#line 1391
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1394
      goto __Cont;
      switch_break: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1347
    lc = lc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1399
  if (! res) {
    {
#line 1399
    tmp___5 = __errno_location();
    }
#line 1399
    if (! *tmp___5) {
      {
#line 1400
      tmp___4 = __errno_location();
#line 1400
      *tmp___4 = 13;
      }
    }
  }
#line 1402
  return (res);
}
}
#line 1405 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int dir_check_limits(config_rec *c , char *cmd , int hidden ) 
{ 
  int res ;

  {
#line 1406
  res = 1;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (c) {
#line 1408
      if (! (res == 1)) {
#line 1408
        goto while_break;
      }
    } else {
#line 1408
      goto while_break;
    }
    {
#line 1409
    res = _check_limits(c->subset, cmd, hidden);
#line 1408
    c = c->parent;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1412
  if (! c) {
#line 1412
    if (res == 1) {
      {
#line 1416
      res = _check_limits(main_server->conf, cmd, hidden);
      }
    }
  }
#line 1419
  return (res);
}
}
#line 1422 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void build_dyn_config(pool *p , char *_path , struct stat *stp , unsigned char recurse ) 
{ 
  char *fullpath ;
  char *path ;
  char *dynpath ;
  char *cp ;
  struct stat st ;
  config_rec *d ;
  xaset_t **set ;
  int isfile ;
  int removed ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  config_rec *newd ;
  config_rec *dnext ;
  void *tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 1424
  fullpath = (char *)((void *)0);
#line 1424
  path = (char *)((void *)0);
#line 1424
  dynpath = (char *)((void *)0);
#line 1424
  cp = (char *)((void *)0);
#line 1426
  d = (config_rec *)((void *)0);
#line 1427
  set = (xaset_t **)((void *)0);
#line 1428
  removed = 0;
#line 1434
  if (! _path) {
#line 1435
    return;
  }
  {
#line 1438
  tmp = allow_dyn_config();
  }
#line 1438
  if (! tmp) {
#line 1439
    return;
  }
  {
#line 1441
  path = pstrdup(p, (char const   *)_path);
#line 1443
  memcpy((void */* __restrict  */)(& st), (void const   */* __restrict  */)stp, (size_t )sizeof(st));
  }
#line 1445
  if ((st.st_mode & 61440U) == 16384U) {
    {
#line 1446
    dynpath = pdircat(p, path, "/.ftpaccess", (void *)0);
    }
  } else {
#line 1449
    dynpath = (char *)((void *)0);
  }
  {
#line 1451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1451
    if (! path) {
#line 1451
      goto while_break;
    }
    {
#line 1452
    pr_signals_handle();
    }
#line 1454
    if (session.chroot_path) {
      {
#line 1455
      fullpath = pdircat(p, session.chroot_path, path, (void *)0);
#line 1457
      tmp___1 = strcmp((char const   *)fullpath, "/");
      }
#line 1457
      if (tmp___1) {
        {
#line 1457
        tmp___2 = strlen((char const   *)fullpath);
        }
#line 1457
        if ((int )*((fullpath + tmp___2) - 1) == 47) {
          {
#line 1459
          tmp___0 = strlen((char const   *)fullpath);
#line 1459
          *((fullpath + tmp___0) - 1) = (char )'\000';
          }
        }
      }
    } else {
#line 1463
      fullpath = path;
    }
#line 1465
    if (dynpath) {
      {
#line 1466
      isfile = pr_fsio_stat((char const   *)dynpath, & st);
      }
    } else {
#line 1469
      isfile = -1;
    }
    {
#line 1471
    d = dir_match_path(p, fullpath);
    }
#line 1473
    if (! d) {
#line 1473
      if (isfile != -1) {
#line 1475
        if (session.anon_config) {
#line 1475
          set = & (session.anon_config)->subset;
        } else {
#line 1475
          set = & main_server->conf;
        }
        {
#line 1478
        d = add_config_set(set, (char const   *)fullpath);
#line 1479
        d->config_type = 1 << 1;
#line 1480
        d->argc = 1;
#line 1481
        tmp___3 = pcalloc(d->pool, (int )(2UL * sizeof(void *)));
#line 1481
        d->argv = (void **)tmp___3;
        }
      } else {
#line 1473
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1483
    if (d) {
#line 1486
      if (isfile != -1) {
        {
#line 1486
        tmp___7 = strcmp((char const   *)d->name, (char const   *)fullpath);
        }
#line 1486
        if (tmp___7 != 0) {
          {
#line 1488
          set = & d->subset;
#line 1489
          newd = add_config_set(set, (char const   *)fullpath);
#line 1490
          newd->config_type = 1 << 1;
#line 1491
          newd->argc = 1;
#line 1492
          tmp___4 = pcalloc(newd->pool, (int )(2UL * sizeof(void *)));
#line 1492
          newd->argv = (void **)tmp___4;
#line 1493
          newd->parent = d;
#line 1495
          d = newd;
          }
        } else {
#line 1486
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1497
        tmp___5 = strcmp((char const   *)d->name, (char const   *)fullpath);
        }
#line 1497
        if (tmp___5 == 0) {
#line 1497
          if (isfile == -1) {
#line 1497
            goto _L;
          } else {
#line 1497
            if (*(d->argv + 0)) {
#line 1497
              tmp___6 = *((time_t *)*(d->argv + 0));
            } else {
#line 1497
              tmp___6 = (time_t )0;
            }
#line 1497
            if (st.st_mtim.tv_sec > tmp___6) {
              _L: /* CIL Label */ 
#line 1501
              if (d->parent) {
#line 1501
                set = & (d->parent)->subset;
              } else {
#line 1501
                set = & main_server->conf;
              }
#line 1503
              if (d->subset) {
#line 1503
                if ((d->subset)->xas_list) {
#line 1507
                  newd = (config_rec *)(d->subset)->xas_list;
                  {
#line 1507
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 1507
                    if (! newd) {
#line 1507
                      goto while_break___0;
                    }
#line 1508
                    dnext = newd->next;
#line 1510
                    if (newd->flags & (long )(1 << 2)) {
                      {
#line 1511
                      xaset_remove(d->subset, (xasetmember_t *)newd);
#line 1512
                      removed ++;
                      }
                    }
#line 1507
                    newd = dnext;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                }
              }
#line 1517
              if (d->subset) {
#line 1517
                if (! (d->subset)->xas_list) {
                  {
#line 1519
                  destroy_pool((d->subset)->pool);
#line 1520
                  d->subset = (xaset_t *)((void *)0);
#line 1521
                  *(d->argv + 0) = (void *)0;
                  }
#line 1526
                  if (isfile == -1) {
                    {
#line 1527
                    xaset_remove(*set, (xasetmember_t *)d);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1532
    if (isfile != -1) {
#line 1532
      if (d) {
#line 1532
        if (st.st_size > 0LL) {
#line 1532
          if (*(d->argv + 0)) {
#line 1532
            tmp___11 = *((time_t *)*(d->argv + 0));
          } else {
#line 1532
            tmp___11 = (time_t )0;
          }
#line 1532
          if (st.st_mtim.tv_sec > tmp___11) {
            {
#line 1538
            *(d->argv + 0) = pcalloc(d->pool, (int )sizeof(time_t ));
#line 1539
            *((time_t *)*(d->argv + 0)) = st.st_mtim.tv_sec;
#line 1541
            pr_parser_prepare(p, (xaset_t **)((void *)0));
#line 1543
            d->config_type = 1 << 5;
#line 1545
            tmp___10 = pr_parser_parse_file(p, (char const   *)dynpath, d, 1);
            }
#line 1545
            if (tmp___10 < 0) {
              {
#line 1546
              tmp___8 = __errno_location();
#line 1546
              tmp___9 = strerror(*tmp___8);
#line 1546
              pr_log_debug(0, "error parsing \'%s\': %s", dynpath, tmp___9);
              }
            }
            {
#line 1549
            d->config_type = 1 << 1;
#line 1550
            pr_parser_cleanup();
#line 1552
            merge_down(*set, 1);
            }
          }
        }
      }
    }
#line 1555
    if (isfile == -1) {
#line 1555
      if (removed) {
#line 1555
        if (d) {
#line 1555
          if (set) {
            {
#line 1559
            pr_log_debug(5, "dynamic configuration removed for %s", fullpath);
#line 1560
            merge_down(*set, 0);
            }
          }
        }
      }
    }
#line 1563
    if (! recurse) {
#line 1564
      goto while_break;
    }
    {
#line 1566
    cp = strrchr((char const   *)path, '/');
    }
#line 1567
    if (cp) {
      {
#line 1568
      tmp___12 = strcmp((char const   *)path, "/");
      }
#line 1568
      if (tmp___12 != 0) {
#line 1576
        if ((unsigned long )cp != (unsigned long )path) {
#line 1577
          *cp = (char )'\000';
        } else {
#line 1583
          *(cp + 1) = (char )'\000';
#line 1584
          recurse = (unsigned char)0;
        }
      } else {
#line 1591
        recurse = (unsigned char)0;
      }
    } else {
#line 1595
      path = (char *)((void *)0);
    }
#line 1598
    if (path) {
#line 1599
      if (*path) {
        {
#line 1599
        tmp___14 = strlen((char const   *)path);
        }
#line 1599
        if ((int )*((path + tmp___14) - 1) == 42) {
          {
#line 1600
          tmp___13 = strlen((char const   *)path);
#line 1600
          *((path + tmp___13) - 1) = (char )'\000';
          }
        }
      }
      {
#line 1602
      dynpath = pdircat(p, path, "/.ftpaccess", (void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1605
  return;
}
}
#line 1620 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int dir_check_full(pool *pp , char *cmd , char *group , char *path , int *hidden ) 
{ 
  char *fullpath ;
  char *owner ;
  config_rec *c ;
  struct stat st ;
  pool *p ;
  mode_t _umask ;
  int res ;
  int isfile ;
  int op_hidden ;
  int regex_hidden ;
  int *tmp ;
  unsigned char tmp___0 ;
  mode_t *dir_umask ;
  xaset_t *tmp___1 ;
  xaset_t *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  mode_t *file_umask ;
  xaset_t *tmp___6 ;
  xaset_t *tmp___7 ;
  void *tmp___8 ;
  xaset_t *tmp___9 ;
  xaset_t *tmp___10 ;
  void *tmp___11 ;
  struct passwd *pw ;
  xaset_t *tmp___12 ;
  xaset_t *tmp___13 ;
  void *tmp___14 ;
  struct group *gr ;
  char *tmp___15 ;
  xaset_t *tmp___16 ;
  xaset_t *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  xaset_t *tmp___21 ;
  xaset_t *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  __mode_t tmp___30 ;
  int tmp___31 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;

  {
#line 1625
  _umask = (mode_t )-1;
#line 1626
  res = 1;
#line 1627
  op_hidden = 0;
#line 1627
  regex_hidden = 0;
#line 1629
  if (! path) {
    {
#line 1630
    tmp = __errno_location();
#line 1630
    *tmp = 22;
    }
#line 1631
    return (-1);
  }
  {
#line 1634
  p = make_sub_pool(pp);
#line 1635
  pr_pool_tag(p, "dir_check_full() subpool");
#line 1637
  fullpath = path;
  }
#line 1639
  if (session.chroot_path) {
    {
#line 1640
    fullpath = pdircat(p, session.chroot_path, fullpath, (void *)0);
    }
  }
  {
#line 1642
  pr_log_debug(5, "in dir_check_full(): path = \'%s\', fullpath = \'%s\'.", path,
               fullpath);
#line 1646
  pr_fs_clear_cache();
#line 1647
  isfile = pr_fsio_stat((char const   *)path, & st);
  }
#line 1648
  if (isfile == -1) {
    {
#line 1649
    memset((void *)(& st), '\000', (size_t )sizeof(st));
    }
  }
  {
#line 1651
  build_dyn_config(p, path, & st, (unsigned char)1);
#line 1654
  tmp___0 = dir_hide_file((char const   *)path);
#line 1654
  regex_hidden = (int )tmp___0;
#line 1659
  c = dir_match_path(p, fullpath);
#line 1659
  session.dir_config = c;
  }
#line 1660
  if (session.dir_config) {
    {
#line 1661
    pr_trace_msg("directory", 2, "matched <Directory %s> for \'%s\'", (session.dir_config)->name,
                 fullpath);
    }
  }
#line 1665
  if (! c) {
#line 1665
    if (session.anon_config) {
#line 1666
      c = session.anon_config;
    }
  }
#line 1668
  if (! _kludge_disable_umask) {
#line 1670
    if ((st.st_mode & 61440U) == 16384U) {
#line 1670
      goto _L;
    } else {
      {
#line 1670
      tmp___4 = strcmp((char const   *)cmd, "MKD");
      }
#line 1670
      if (tmp___4 == 0) {
#line 1670
        goto _L;
      } else {
        {
#line 1670
        tmp___5 = strcmp((char const   *)cmd, "XMKD");
        }
#line 1670
        if (tmp___5 == 0) {
          _L: /* CIL Label */ 
#line 1673
          if (session.dir_config) {
#line 1673
            tmp___2 = (session.dir_config)->subset;
          } else {
#line 1673
            if (session.anon_config) {
#line 1673
              tmp___1 = (session.anon_config)->subset;
            } else {
#line 1673
              tmp___1 = main_server->conf;
            }
#line 1673
            tmp___2 = tmp___1;
          }
          {
#line 1673
          tmp___3 = get_param_ptr(tmp___2, "DirUmask", 0);
#line 1673
          dir_umask = (mode_t *)tmp___3;
          }
#line 1674
          if (dir_umask) {
#line 1674
            _umask = *dir_umask;
          } else {
#line 1674
            _umask = (mode_t )-1;
          }
        }
      }
    }
#line 1678
    if (_umask == 4294967295U) {
#line 1679
      if (session.dir_config) {
#line 1679
        tmp___7 = (session.dir_config)->subset;
      } else {
#line 1679
        if (session.anon_config) {
#line 1679
          tmp___6 = (session.anon_config)->subset;
        } else {
#line 1679
          tmp___6 = main_server->conf;
        }
#line 1679
        tmp___7 = tmp___6;
      }
      {
#line 1679
      tmp___8 = get_param_ptr(tmp___7, "Umask", 0);
#line 1679
      file_umask = (mode_t *)tmp___8;
      }
#line 1680
      if (file_umask) {
#line 1680
        _umask = *file_umask;
      } else {
#line 1680
        _umask = (mode_t )18;
      }
    }
  }
#line 1684
  session.fsuid = (uid_t )-1;
#line 1685
  session.fsgid = (gid_t )-1;
#line 1687
  if (session.dir_config) {
#line 1687
    tmp___10 = (session.dir_config)->subset;
  } else {
#line 1687
    if (session.anon_config) {
#line 1687
      tmp___9 = (session.anon_config)->subset;
    } else {
#line 1687
      tmp___9 = main_server->conf;
    }
#line 1687
    tmp___10 = tmp___9;
  }
  {
#line 1687
  tmp___11 = get_param_ptr(tmp___10, "UserOwner", 0);
#line 1687
  owner = (char *)tmp___11;
  }
#line 1688
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
    {
#line 1692
    pw = pr_auth_getpwnam(p, (char const   *)owner);
    }
#line 1693
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 1694
      session.fsuid = pw->pw_uid;
    }
  }
#line 1697
  if (session.dir_config) {
#line 1697
    tmp___13 = (session.dir_config)->subset;
  } else {
#line 1697
    if (session.anon_config) {
#line 1697
      tmp___12 = (session.anon_config)->subset;
    } else {
#line 1697
      tmp___12 = main_server->conf;
    }
#line 1697
    tmp___13 = tmp___12;
  }
  {
#line 1697
  tmp___14 = get_param_ptr(tmp___13, "GroupOwner", 0);
#line 1697
  owner = (char *)tmp___14;
  }
#line 1698
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
    {
#line 1702
    gr = pr_auth_getgrnam(p, (char const   *)owner);
    }
#line 1703
    if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 1704
      session.fsgid = gr->gr_gid;
    }
  }
#line 1707
  if (isfile != -1) {
#line 1709
    if (session.chroot_path) {
#line 1709
      tmp___15 = path;
    } else {
#line 1709
      tmp___15 = fullpath;
    }
#line 1709
    if (session.dir_config) {
#line 1709
      tmp___17 = (session.dir_config)->subset;
    } else {
#line 1709
      if (session.anon_config) {
#line 1709
        tmp___16 = (session.anon_config)->subset;
      } else {
#line 1709
        tmp___16 = main_server->conf;
      }
#line 1709
      tmp___17 = tmp___16;
    }
    {
#line 1709
    tmp___18 = dir_check_op(p, tmp___17, 1, (char const   *)tmp___15, st.st_uid, st.st_gid,
                            st.st_mode);
    }
#line 1709
    if (tmp___18) {
#line 1709
      tmp___19 = 0;
    } else {
#line 1709
      tmp___19 = 1;
    }
#line 1709
    op_hidden = tmp___19;
#line 1712
    if (session.chroot_path) {
#line 1712
      tmp___20 = path;
    } else {
#line 1712
      tmp___20 = fullpath;
    }
#line 1712
    if (session.dir_config) {
#line 1712
      tmp___22 = (session.dir_config)->subset;
    } else {
#line 1712
      if (session.anon_config) {
#line 1712
        tmp___21 = (session.anon_config)->subset;
      } else {
#line 1712
        tmp___21 = main_server->conf;
      }
#line 1712
      tmp___22 = tmp___21;
    }
    {
#line 1712
    res = dir_check_op(p, tmp___22, 2, (char const   *)tmp___20, st.st_uid, st.st_gid,
                       st.st_mode);
    }
  }
#line 1716
  if (res) {
#line 1721
    if (op_hidden) {
#line 1721
      tmp___23 = 1;
    } else
#line 1721
    if (regex_hidden) {
#line 1721
      tmp___23 = 1;
    } else {
#line 1721
      tmp___23 = 0;
    }
    {
#line 1721
    res = dir_check_limits(c, cmd, tmp___23);
    }
#line 1726
    if (res == 1) {
#line 1726
      if (group) {
#line 1727
        if (op_hidden) {
#line 1727
          tmp___24 = 1;
        } else
#line 1727
        if (regex_hidden) {
#line 1727
          tmp___24 = 1;
        } else {
#line 1727
          tmp___24 = 0;
        }
        {
#line 1727
        res = dir_check_limits(c, group, tmp___24);
        }
      }
    }
#line 1733
    if (res == 1) {
      {
#line 1733
      tmp___26 = strcmp((char const   *)cmd, "EPRT");
      }
#line 1733
      if (tmp___26 != 0) {
        {
#line 1733
        tmp___27 = strcmp((char const   *)cmd, "EPSV");
        }
#line 1733
        if (tmp___27 != 0) {
          {
#line 1733
          tmp___28 = strcmp((char const   *)cmd, "PASV");
          }
#line 1733
          if (tmp___28 != 0) {
            {
#line 1733
            tmp___29 = strcmp((char const   *)cmd, "PORT");
            }
#line 1733
            if (tmp___29 != 0) {
#line 1738
              if (op_hidden) {
#line 1738
                tmp___25 = 1;
              } else
#line 1738
              if (regex_hidden) {
#line 1738
                tmp___25 = 1;
              } else {
#line 1738
                tmp___25 = 0;
              }
              {
#line 1738
              res = dir_check_limits(c, (char *)"ALL", tmp___25);
              }
            }
          }
        }
      }
    }
  }
#line 1741
  if (res) {
#line 1741
    if (_umask != 4294967295U) {
      {
#line 1743
      tmp___30 = umask(_umask);
#line 1743
      pr_log_debug(5, "in dir_check_full(): setting umask to %04o (was %04o)", _umask,
                   tmp___30);
      }
    }
  }
  {
#line 1747
  destroy_pool(p);
  }
#line 1749
  if (hidden) {
#line 1750
    if (op_hidden) {
#line 1750
      tmp___31 = 1;
    } else
#line 1750
    if (regex_hidden) {
#line 1750
      tmp___31 = 1;
    } else {
#line 1750
      tmp___31 = 0;
    }
#line 1750
    *hidden = tmp___31;
  }
#line 1752
  return (res);
}
}
#line 1760 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int dir_check(pool *pp , char *cmd , char *group , char *path , int *hidden ) 
{ 
  char *fullpath ;
  char *owner ;
  config_rec *c ;
  struct stat st ;
  pool *p ;
  mode_t _umask ;
  int res ;
  int isfile ;
  int op_hidden ;
  int regex_hidden ;
  int *tmp ;
  struct config_struc *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  unsigned char tmp___4 ;
  mode_t *dir_umask ;
  xaset_t *tmp___5 ;
  xaset_t *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  mode_t *file_umask ;
  xaset_t *tmp___10 ;
  xaset_t *tmp___11 ;
  void *tmp___12 ;
  xaset_t *tmp___13 ;
  xaset_t *tmp___14 ;
  void *tmp___15 ;
  struct passwd *pw ;
  xaset_t *tmp___16 ;
  xaset_t *tmp___17 ;
  void *tmp___18 ;
  struct group *gr ;
  char *tmp___19 ;
  xaset_t *tmp___20 ;
  xaset_t *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  xaset_t *tmp___25 ;
  xaset_t *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  __mode_t tmp___34 ;
  int tmp___35 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
#line 1765
  _umask = (mode_t )-1;
#line 1766
  res = 1;
#line 1767
  op_hidden = 0;
#line 1767
  regex_hidden = 0;
#line 1769
  if (! path) {
    {
#line 1770
    tmp = __errno_location();
#line 1770
    *tmp = 22;
    }
#line 1771
    return (-1);
  }
  {
#line 1774
  p = make_sub_pool(pp);
#line 1775
  pr_pool_tag(p, "dir_check() subpool");
#line 1777
  fullpath = path;
  }
#line 1779
  if (session.chroot_path) {
    {
#line 1780
    fullpath = pdircat(p, session.chroot_path, fullpath, (void *)0);
    }
  }
#line 1782
  if (session.dir_config) {
#line 1782
    c = session.dir_config;
  } else {
#line 1782
    if (session.anon_config) {
#line 1782
      tmp___0 = session.anon_config;
    } else {
#line 1782
      tmp___0 = (struct config_struc *)((void *)0);
    }
#line 1782
    c = tmp___0;
  }
#line 1785
  if (! c) {
    {
#line 1786
    destroy_pool(p);
#line 1787
    tmp___1 = dir_check_full(pp, cmd, group, path, hidden);
    }
#line 1787
    return (tmp___1);
  } else {
    {
#line 1785
    tmp___2 = strlen((char const   *)c->name);
#line 1785
    tmp___3 = strncmp((char const   *)c->name, (char const   *)fullpath, tmp___2);
    }
#line 1785
    if (tmp___3 != 0) {
      {
#line 1786
      destroy_pool(p);
#line 1787
      tmp___1 = dir_check_full(pp, cmd, group, path, hidden);
      }
#line 1787
      return (tmp___1);
    }
  }
  {
#line 1791
  pr_fs_clear_cache();
#line 1792
  isfile = pr_fsio_stat((char const   *)path, & st);
  }
#line 1793
  if (isfile == -1) {
    {
#line 1794
    memset((void *)(& st), 0, (size_t )sizeof(st));
    }
  }
  {
#line 1796
  build_dyn_config(p, path, & st, (unsigned char)0);
#line 1799
  tmp___4 = dir_hide_file((char const   *)path);
#line 1799
  regex_hidden = (int )tmp___4;
#line 1804
  c = dir_match_path(p, fullpath);
#line 1804
  session.dir_config = c;
  }
#line 1805
  if (session.dir_config) {
    {
#line 1806
    pr_trace_msg("directory", 2, "matched <Directory %s> for \'%s\'", (session.dir_config)->name,
                 fullpath);
    }
  }
#line 1810
  if (! c) {
#line 1810
    if (session.anon_config) {
#line 1811
      c = session.anon_config;
    }
  }
#line 1813
  if (! _kludge_disable_umask) {
#line 1815
    if ((st.st_mode & 61440U) == 16384U) {
#line 1815
      goto _L;
    } else {
      {
#line 1815
      tmp___8 = strcmp((char const   *)cmd, "MKD");
      }
#line 1815
      if (tmp___8 == 0) {
#line 1815
        goto _L;
      } else {
        {
#line 1815
        tmp___9 = strcmp((char const   *)cmd, "XMKD");
        }
#line 1815
        if (tmp___9 == 0) {
          _L: /* CIL Label */ 
#line 1818
          if (session.dir_config) {
#line 1818
            tmp___6 = (session.dir_config)->subset;
          } else {
#line 1818
            if (session.anon_config) {
#line 1818
              tmp___5 = (session.anon_config)->subset;
            } else {
#line 1818
              tmp___5 = main_server->conf;
            }
#line 1818
            tmp___6 = tmp___5;
          }
          {
#line 1818
          tmp___7 = get_param_ptr(tmp___6, "DirUmask", 0);
#line 1818
          dir_umask = (mode_t *)tmp___7;
          }
#line 1819
          if (dir_umask) {
#line 1819
            _umask = *dir_umask;
          } else {
#line 1819
            _umask = (mode_t )-1;
          }
        }
      }
    }
#line 1823
    if (_umask == 4294967295U) {
#line 1824
      if (session.dir_config) {
#line 1824
        tmp___11 = (session.dir_config)->subset;
      } else {
#line 1824
        if (session.anon_config) {
#line 1824
          tmp___10 = (session.anon_config)->subset;
        } else {
#line 1824
          tmp___10 = main_server->conf;
        }
#line 1824
        tmp___11 = tmp___10;
      }
      {
#line 1824
      tmp___12 = get_param_ptr(tmp___11, "Umask", 0);
#line 1824
      file_umask = (mode_t *)tmp___12;
      }
#line 1825
      if (file_umask) {
#line 1825
        _umask = *file_umask;
      } else {
#line 1825
        _umask = (mode_t )18;
      }
    }
  }
#line 1829
  session.fsuid = (uid_t )-1;
#line 1830
  session.fsgid = (gid_t )-1;
#line 1832
  if (session.dir_config) {
#line 1832
    tmp___14 = (session.dir_config)->subset;
  } else {
#line 1832
    if (session.anon_config) {
#line 1832
      tmp___13 = (session.anon_config)->subset;
    } else {
#line 1832
      tmp___13 = main_server->conf;
    }
#line 1832
    tmp___14 = tmp___13;
  }
  {
#line 1832
  tmp___15 = get_param_ptr(tmp___14, "UserOwner", 0);
#line 1832
  owner = (char *)tmp___15;
  }
#line 1833
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
    {
#line 1837
    pw = pr_auth_getpwnam(p, (char const   *)owner);
    }
#line 1838
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 1839
      session.fsuid = pw->pw_uid;
    }
  }
#line 1842
  if (session.dir_config) {
#line 1842
    tmp___17 = (session.dir_config)->subset;
  } else {
#line 1842
    if (session.anon_config) {
#line 1842
      tmp___16 = (session.anon_config)->subset;
    } else {
#line 1842
      tmp___16 = main_server->conf;
    }
#line 1842
    tmp___17 = tmp___16;
  }
  {
#line 1842
  tmp___18 = get_param_ptr(tmp___17, "GroupOwner", 0);
#line 1842
  owner = (char *)tmp___18;
  }
#line 1843
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
    {
#line 1847
    gr = pr_auth_getgrnam(p, (char const   *)owner);
    }
#line 1848
    if ((unsigned long )gr != (unsigned long )((void *)0)) {
#line 1849
      session.fsgid = gr->gr_gid;
    }
  }
#line 1852
  if (isfile != -1) {
#line 1856
    if (session.chroot_path) {
#line 1856
      tmp___19 = path;
    } else {
#line 1856
      tmp___19 = fullpath;
    }
#line 1856
    if (session.dir_config) {
#line 1856
      tmp___21 = (session.dir_config)->subset;
    } else {
#line 1856
      if (session.anon_config) {
#line 1856
        tmp___20 = (session.anon_config)->subset;
      } else {
#line 1856
        tmp___20 = main_server->conf;
      }
#line 1856
      tmp___21 = tmp___20;
    }
    {
#line 1856
    tmp___22 = dir_check_op(p, tmp___21, 1, (char const   *)tmp___19, st.st_uid, st.st_gid,
                            st.st_mode);
    }
#line 1856
    if (tmp___22) {
#line 1856
      tmp___23 = 0;
    } else {
#line 1856
      tmp___23 = 1;
    }
#line 1856
    op_hidden = tmp___23;
#line 1859
    if (session.chroot_path) {
#line 1859
      tmp___24 = path;
    } else {
#line 1859
      tmp___24 = fullpath;
    }
#line 1859
    if (session.dir_config) {
#line 1859
      tmp___26 = (session.dir_config)->subset;
    } else {
#line 1859
      if (session.anon_config) {
#line 1859
        tmp___25 = (session.anon_config)->subset;
      } else {
#line 1859
        tmp___25 = main_server->conf;
      }
#line 1859
      tmp___26 = tmp___25;
    }
    {
#line 1859
    res = dir_check_op(p, tmp___26, 2, (char const   *)tmp___24, st.st_uid, st.st_gid,
                       st.st_mode);
    }
  }
#line 1863
  if (res) {
#line 1864
    if (op_hidden) {
#line 1864
      tmp___27 = 1;
    } else
#line 1864
    if (regex_hidden) {
#line 1864
      tmp___27 = 1;
    } else {
#line 1864
      tmp___27 = 0;
    }
    {
#line 1864
    res = dir_check_limits(c, cmd, tmp___27);
    }
#line 1869
    if (res == 1) {
#line 1869
      if (group) {
#line 1870
        if (op_hidden) {
#line 1870
          tmp___28 = 1;
        } else
#line 1870
        if (regex_hidden) {
#line 1870
          tmp___28 = 1;
        } else {
#line 1870
          tmp___28 = 0;
        }
        {
#line 1870
        res = dir_check_limits(c, group, tmp___28);
        }
      }
    }
#line 1876
    if (res == 1) {
      {
#line 1876
      tmp___30 = strcmp((char const   *)cmd, "EPRT");
      }
#line 1876
      if (tmp___30 != 0) {
        {
#line 1876
        tmp___31 = strcmp((char const   *)cmd, "EPSV");
        }
#line 1876
        if (tmp___31 != 0) {
          {
#line 1876
          tmp___32 = strcmp((char const   *)cmd, "PASV");
          }
#line 1876
          if (tmp___32 != 0) {
            {
#line 1876
            tmp___33 = strcmp((char const   *)cmd, "PORT");
            }
#line 1876
            if (tmp___33 != 0) {
#line 1881
              if (op_hidden) {
#line 1881
                tmp___29 = 1;
              } else
#line 1881
              if (regex_hidden) {
#line 1881
                tmp___29 = 1;
              } else {
#line 1881
                tmp___29 = 0;
              }
              {
#line 1881
              res = dir_check_limits(c, (char *)"ALL", tmp___29);
              }
            }
          }
        }
      }
    }
  }
#line 1884
  if (res) {
#line 1884
    if (_umask != 4294967295U) {
      {
#line 1886
      tmp___34 = umask(_umask);
#line 1886
      pr_log_debug(5, "in dir_check(): setting umask to %04o (was %04o)", _umask,
                   tmp___34);
      }
    }
  }
  {
#line 1889
  destroy_pool(p);
  }
#line 1891
  if (hidden) {
#line 1892
    if (op_hidden) {
#line 1892
      tmp___35 = 1;
    } else
#line 1892
    if (regex_hidden) {
#line 1892
      tmp___35 = 1;
    } else {
#line 1892
      tmp___35 = 0;
    }
#line 1892
    *hidden = tmp___35;
  }
#line 1894
  return (res);
}
}
#line 1901 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int dir_check_canon(pool *pp , char *cmd , char *group , char *path , int *hidden ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1902
  tmp = dir_best_path(pp, (char const   *)path);
#line 1902
  tmp___0 = dir_check(pp, cmd, group, tmp, hidden);
  }
#line 1902
  return (tmp___0);
}
}
#line 1908 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void _reparent_all(config_rec *newparent , xaset_t *set ) 
{ 
  config_rec *c ;
  config_rec *cnext ;

  {
#line 1911
  if (! newparent->subset) {
    {
#line 1912
    newparent->subset = xaset_create(newparent->pool, (int (*)(xasetmember_t *v1 ,
                                                               xasetmember_t *v2 ))((void *)0));
    }
  }
#line 1914
  c = (config_rec *)set->xas_list;
  {
#line 1914
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1914
    if (! c) {
#line 1914
      goto while_break;
    }
    {
#line 1915
    cnext = c->next;
#line 1916
    xaset_remove(set, (xasetmember_t *)c);
#line 1917
    xaset_insert(newparent->subset, (xasetmember_t *)c);
#line 1918
    c->set = newparent->subset;
#line 1919
    c->parent = newparent;
#line 1914
    c = cnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1921
  return;
}
}
#line 1927 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static config_rec *_find_best_dir(xaset_t *set , char *path , size_t *matchlen ) 
{ 
  config_rec *c ;
  config_rec *res ;
  config_rec *rres ;
  size_t len ;
  size_t pathlen ;
  size_t imatchlen ;
  size_t tmatchlen ;
  int tmp ;

  {
#line 1928
  res = (config_rec *)((void *)0);
#line 1931
  *matchlen = (size_t )0;
#line 1933
  if (! set) {
#line 1935
    return ((config_rec *)((void *)0));
  } else
#line 1933
  if (! set->xas_list) {
#line 1935
    return ((config_rec *)((void *)0));
  }
  {
#line 1937
  pathlen = strlen((char const   *)path);
#line 1939
  c = (config_rec *)set->xas_list;
  }
  {
#line 1939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1939
    if (! c) {
#line 1939
      goto while_break;
    }
#line 1940
    if (c->config_type == 1 << 1) {
#line 1951
      if ((unsigned long )c->name == (unsigned long )path) {
#line 1952
        goto __Cont;
      }
      {
#line 1954
      len = strlen((char const   *)c->name);
      }
      {
#line 1955
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1955
        if (len > 0U) {
#line 1955
          if (! ((int )*((c->name + len) - 1) == 42)) {
#line 1955
            if (! ((int )*((c->name + len) - 1) == 47)) {
#line 1955
              goto while_break___0;
            }
          }
        } else {
#line 1955
          goto while_break___0;
        }
#line 1957
        len --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1970
      if (pathlen > len) {
#line 1970
        if ((int )*(path + len) != 47) {
#line 1972
          goto __Cont;
        }
      }
#line 1974
      if (len < pathlen) {
        {
#line 1974
        tmp = strncmp((char const   *)c->name, (char const   *)path, len);
        }
#line 1974
        if (tmp == 0) {
          {
#line 1976
          rres = _find_best_dir(c->subset, path, & imatchlen);
#line 1977
          tmatchlen = _strmatch(path, c->name);
          }
#line 1978
          if (! rres) {
#line 1978
            if (tmatchlen > *matchlen) {
#line 1980
              res = c;
#line 1981
              *matchlen = tmatchlen;
            } else {
#line 1978
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1983
          if (imatchlen > *matchlen) {
#line 1984
            res = rres;
#line 1985
            *matchlen = imatchlen;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1939
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1991
  return (res);
}
}
#line 1998 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void _reorder_dirs(xaset_t *set , int flags ) 
{ 
  config_rec *c ;
  config_rec *cnext ;
  config_rec *newparent ;
  int defer ;
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 1999
  c = (config_rec *)((void *)0);
#line 1999
  cnext = (config_rec *)((void *)0);
#line 1999
  newparent = (config_rec *)((void *)0);
#line 2000
  defer = 0;
#line 2003
  if (! set) {
#line 2004
    return;
  } else
#line 2003
  if (! set->xas_list) {
#line 2004
    return;
  }
#line 2006
  if (! (flags & (1 << 3))) {
#line 2007
    defer = 1;
  }
#line 2009
  c = (config_rec *)set->xas_list;
  {
#line 2009
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2009
    if (! c) {
#line 2009
      goto while_break;
    }
#line 2010
    cnext = c->next;
#line 2012
    if (c->config_type == 1 << 1) {
#line 2013
      if (flags) {
#line 2013
        if (! (c->flags & (long )flags)) {
#line 2014
          goto __Cont;
        }
      }
#line 2016
      if (defer) {
#line 2016
        if (c->flags & (long )(1 << 3)) {
#line 2017
          goto __Cont;
        }
      }
#line 2022
      if (c->parent) {
#line 2022
        if ((c->parent)->config_type == 1 << 2) {
          {
#line 2022
          tmp___0 = strcmp((char const   *)c->name, "*");
          }
#line 2022
          if (tmp___0 == 0) {
#line 2026
            if (c->subset) {
              {
#line 2027
              _reparent_all(c->parent, c->subset);
              }
            }
            {
#line 2029
            xaset_remove((c->parent)->subset, (xasetmember_t *)c);
            }
          } else {
#line 2022
            goto _L___0;
          }
        } else {
#line 2022
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 2032
        newparent = _find_best_dir(set, c->name, & tmp);
        }
#line 2033
        if (newparent) {
#line 2034
          if (! newparent->subset) {
            {
#line 2035
            newparent->subset = xaset_create(newparent->pool, (int (*)(xasetmember_t *v1 ,
                                                                       xasetmember_t *v2 ))((void *)0));
            }
          }
          {
#line 2037
          xaset_remove(c->set, (xasetmember_t *)c);
#line 2038
          xaset_insert(newparent->subset, (xasetmember_t *)c);
#line 2039
          c->set = newparent->subset;
#line 2040
          c->parent = newparent;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 2009
    c = cnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 2047
  c = (config_rec *)set->xas_list;
  {
#line 2047
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2047
    if (! c) {
#line 2047
      goto while_break___0;
    }
#line 2048
    if (c->config_type == 1 << 1) {
      {
#line 2049
      _reorder_dirs(c->subset, flags);
      }
    } else
#line 2048
    if (c->config_type == 1 << 2) {
      {
#line 2049
      _reorder_dirs(c->subset, flags);
      }
    }
#line 2047
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2050
  return;
}
}
#line 2052 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void config_dumpf(char const   *fmt  , ...) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  va_list msg ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2053
  buf___2[0] = (char )'\000';
#line 2053
  tmp = 1U;
  {
#line 2053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2053
    if (tmp >= 1024U) {
#line 2053
      goto while_break;
    }
#line 2053
    buf___2[tmp] = (char)0;
#line 2053
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2056
  __builtin_va_start(msg, fmt);
#line 2057
  vsnprintf((char */* __restrict  */)(buf___2), (size_t )sizeof(buf___2), (char const   */* __restrict  */)fmt,
            msg);
#line 2058
  __builtin_va_end(msg);
#line 2060
  buf___2[sizeof(buf___2) - 1UL] = (char )'\000';
#line 2062
  pr_log_debug(5, "%s", buf___2);
  }
#line 2063
  return;
}
}
#line 2065 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void pr_config_dump(void (*dumpf)(char const   *  , ...) , xaset_t *s , char *indent ) 
{ 
  config_rec *c ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2067
  c = (config_rec *)((void *)0);
#line 2069
  if (! s) {
#line 2070
    return;
  }
#line 2072
  if (! indent) {
#line 2073
    indent = (char *)"";
  }
#line 2075
  c = (config_rec *)s->xas_list;
  {
#line 2075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2075
    if (! c) {
#line 2075
      goto while_break;
    }
#line 2078
    if ((int )*(c->name) != 95) {
      {
#line 2079
      (*dumpf)("%s%s", indent, c->name);
      }
    }
#line 2081
    if (c->subset) {
      {
#line 2082
      tmp = pstrcat(c->pool, indent, " ", (void *)0);
#line 2082
      pr_config_dump(dumpf, c->subset, tmp);
      }
    }
#line 2075
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2085
  return;
}
}
#line 2111 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void merge_down(xaset_t *s , int dynamic ) 
{ 
  config_rec *c ;
  config_rec *dst ;
  config_rec *newconf ;
  int argc ;
  void **argv ;
  void **sargv ;
  config_rec *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void **tmp___2 ;
  void **tmp___3 ;
  int tmp___4 ;
  void **tmp___5 ;

  {
#line 2116
  if (! s) {
#line 2118
    return;
  } else
#line 2116
  if (! s->xas_list) {
#line 2118
    return;
  }
#line 2120
  c = (config_rec *)s->xas_list;
  {
#line 2120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2120
    if (! c) {
#line 2120
      goto while_break;
    }
#line 2121
    if (c->flags & 1L) {
#line 2121
      goto _L___0;
    } else
#line 2121
    if (c->flags & (long )(1 << 1)) {
      _L___0: /* CIL Label */ 
#line 2123
      dst = (config_rec *)s->xas_list;
      {
#line 2123
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2123
        if (! dst) {
#line 2123
          goto while_break___0;
        }
#line 2124
        if (dst->config_type == 1 << 2) {
#line 2124
          goto _L;
        } else
#line 2124
        if (dst->config_type == 1 << 1) {
          _L: /* CIL Label */ 
#line 2130
          if (c->flags & 1L) {
            {
#line 2130
            tmp = find_config(dst->subset, c->config_type, (char const   *)c->name,
                              0);
            }
#line 2130
            if (tmp) {
#line 2132
              goto __Cont;
            }
          }
#line 2134
          if (! dst->subset) {
            {
#line 2135
            dst->subset = xaset_create(dst->pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
            }
          }
          {
#line 2137
          newconf = add_config_set(& dst->subset, (char const   *)c->name);
#line 2138
          newconf->config_type = c->config_type;
          }
#line 2139
          if (dynamic) {
#line 2139
            tmp___0 = 1 << 2;
          } else {
#line 2139
            tmp___0 = 0;
          }
          {
#line 2139
          newconf->flags = c->flags | (long )tmp___0;
#line 2140
          newconf->argc = c->argc;
#line 2141
          tmp___1 = pcalloc(newconf->pool, (int )((unsigned long )(c->argc + 1) * sizeof(void *)));
#line 2141
          newconf->argv = (void **)tmp___1;
#line 2142
          argv = newconf->argv;
#line 2143
          sargv = c->argv;
#line 2144
          argc = newconf->argc;
          }
          {
#line 2146
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2146
            tmp___4 = argc;
#line 2146
            argc --;
#line 2146
            if (! tmp___4) {
#line 2146
              goto while_break___1;
            }
#line 2147
            tmp___2 = argv;
#line 2147
            argv ++;
#line 2147
            tmp___3 = sargv;
#line 2147
            sargv ++;
#line 2147
            *tmp___2 = *tmp___3;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2150
          tmp___5 = argv;
#line 2150
          argv ++;
#line 2150
          *tmp___5 = (void *)0;
        }
        __Cont: /* CIL Label */ 
#line 2123
        dst = dst->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2120
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2156
  c = (config_rec *)s->xas_list;
  {
#line 2156
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2156
    if (! c) {
#line 2156
      goto while_break___2;
    }
#line 2157
    if (c->subset) {
#line 2157
      if (c->config_type == 1 << 2) {
        {
#line 2160
        merge_down(c->subset, dynamic);
        }
      } else
#line 2157
      if (c->config_type == 1 << 1) {
        {
#line 2160
        merge_down(c->subset, dynamic);
        }
      }
    }
#line 2156
    c = c->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2163
  return;
}
}
#line 2168 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void resolve_anonymous_dirs(xaset_t *clist ) 
{ 
  config_rec *c ;
  char *realdir ;

  {
#line 2172
  if (! clist) {
#line 2173
    return;
  }
#line 2175
  c = (config_rec *)clist->xas_list;
  {
#line 2175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2175
    if (! c) {
#line 2175
      goto while_break;
    }
#line 2176
    if (c->config_type == 1 << 1) {
#line 2177
      if (*(c->argv + 1)) {
        {
#line 2178
        realdir = dir_best_path(c->pool, (char const   *)*(c->argv + 1));
        }
#line 2179
        if (realdir) {
#line 2180
          *(c->argv + 1) = (void *)realdir;
        } else {
          {
#line 2183
          realdir = dir_canonical_path(c->pool, (char const   *)*(c->argv + 1));
          }
#line 2184
          if (realdir) {
#line 2185
            *(c->argv + 1) = (void *)realdir;
          }
        }
      }
#line 2189
      if (c->subset) {
        {
#line 2190
        resolve_anonymous_dirs(c->subset);
        }
      }
    }
#line 2175
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2193
  return;
}
}
#line 2196 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void resolve_deferred_dirs(server_rec *s ) 
{ 
  config_rec *c ;
  char *realdir ;

  {
#line 2199
  if (! s) {
#line 2201
    return;
  } else
#line 2199
  if (! s->conf) {
#line 2201
    return;
  }
#line 2203
  c = (config_rec *)(s->conf)->xas_list;
  {
#line 2203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2203
    if (! c) {
#line 2203
      goto while_break;
    }
#line 2204
    if (c->config_type == 1 << 1) {
#line 2204
      if (c->flags & (long )(1 << 3)) {
        {
#line 2209
        c->name = path_subst_uservar(c->pool, & c->name);
#line 2211
        realdir = dir_best_path(c->pool, (char const   *)c->name);
        }
#line 2212
        if (realdir) {
#line 2213
          c->name = realdir;
        } else {
          {
#line 2216
          realdir = dir_canonical_path(c->pool, (char const   *)c->name);
          }
#line 2217
          if (realdir) {
#line 2218
            c->name = realdir;
          }
        }
      }
    }
#line 2203
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2222
  return;
}
}
#line 2224 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void copy_recur(xaset_t **set , pool *p , config_rec *c , config_rec *new_parent ) 
{ 
  config_rec *newconf ;
  int argc ;
  void **argv ;
  void **sargv ;
  void *tmp ;
  void **tmp___0 ;
  void **tmp___1 ;
  int tmp___2 ;
  void **tmp___3 ;

  {
#line 2230
  if (! *set) {
    {
#line 2231
    *set = xaset_create(p, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
  {
#line 2233
  newconf = add_config_set(set, (char const   *)c->name);
#line 2234
  newconf->config_type = c->config_type;
#line 2235
  newconf->flags = c->flags;
#line 2236
  newconf->parent = new_parent;
#line 2237
  newconf->argc = c->argc;
  }
#line 2239
  if (c->argc) {
    {
#line 2240
    tmp = pcalloc(newconf->pool, (int )((unsigned long )(c->argc + 1) * sizeof(void *)));
#line 2240
    newconf->argv = (void **)tmp;
#line 2241
    argv = newconf->argv;
#line 2242
    sargv = c->argv;
#line 2243
    argc = newconf->argc;
    }
    {
#line 2245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2245
      tmp___2 = argc;
#line 2245
      argc --;
#line 2245
      if (! tmp___2) {
#line 2245
        goto while_break;
      }
#line 2246
      tmp___0 = argv;
#line 2246
      argv ++;
#line 2246
      tmp___1 = sargv;
#line 2246
      sargv ++;
#line 2246
      *tmp___0 = *tmp___1;
    }
    while_break: /* CIL Label */ ;
    }
#line 2248
    if (argv) {
#line 2249
      tmp___3 = argv;
#line 2249
      argv ++;
#line 2249
      *tmp___3 = (void *)0;
    }
  }
#line 2252
  if (c->subset) {
#line 2253
    c = (config_rec *)(c->subset)->xas_list;
    {
#line 2253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2253
      if (! c) {
#line 2253
        goto while_break___0;
      }
      {
#line 2254
      copy_recur(& newconf->subset, p, c, newconf);
#line 2253
      c = c->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2255
  return;
}
}
#line 2257 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void copy_global_to_all(xaset_t *set ) 
{ 
  server_rec *s ;
  config_rec *c ;

  {
#line 2261
  if (! set) {
#line 2262
    return;
  } else
#line 2261
  if (! set->xas_list) {
#line 2262
    return;
  }
#line 2264
  c = (config_rec *)set->xas_list;
  {
#line 2264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2264
    if (! c) {
#line 2264
      goto while_break;
    }
#line 2265
    s = (server_rec *)server_list->xas_list;
    {
#line 2265
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2265
      if (! s) {
#line 2265
        goto while_break___0;
      }
      {
#line 2266
      copy_recur(& s->conf, s->pool, c, (config_rec *)((void *)0));
#line 2265
      s = s->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2264
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2267
  return;
}
}
#line 2269 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void fixup_globals(xaset_t *list ) 
{ 
  server_rec *s ;
  server_rec *smain ;
  config_rec *c ;
  config_rec *cnext ;
  int tmp ;
  char *__cil_tmp7 ;

  {
#line 2270
  s = (server_rec *)((void *)0);
#line 2270
  smain = (server_rec *)((void *)0);
#line 2271
  c = (config_rec *)((void *)0);
#line 2271
  cnext = (config_rec *)((void *)0);
#line 2273
  smain = (server_rec *)list->xas_list;
#line 2274
  s = smain;
  {
#line 2274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2274
    if (! s) {
#line 2274
      goto while_break;
    }
#line 2278
    if (! s->conf) {
#line 2280
      goto __Cont;
    } else
#line 2278
    if (! (s->conf)->xas_list) {
#line 2280
      goto __Cont;
    }
#line 2282
    c = (config_rec *)(s->conf)->xas_list;
    {
#line 2282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2282
      if (! c) {
#line 2282
        goto while_break___0;
      }
#line 2283
      cnext = c->next;
#line 2285
      if (c->config_type == 1 << 6) {
        {
#line 2285
        tmp = strcmp((char const   *)c->name, "<Global>");
        }
#line 2285
        if (tmp == 0) {
#line 2290
          if (c->subset) {
#line 2290
            if ((c->subset)->xas_list) {
              {
#line 2292
              copy_global_to_all(c->subset);
              }
            }
          }
          {
#line 2294
          xaset_remove(s->conf, (xasetmember_t *)c);
          }
#line 2296
          if (! (s->conf)->xas_list) {
            {
#line 2297
            destroy_pool((s->conf)->pool);
#line 2298
            s->conf = (xaset_t *)((void *)0);
            }
          }
        }
      }
#line 2282
      c = cnext;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2274
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2303
  return;
}
}
#line 2305 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void fixup_dirs(server_rec *s , int flags ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2306
  if (! s) {
#line 2307
    return;
  }
#line 2309
  if (! s->conf) {
#line 2310
    if (! (flags & (1 << 4))) {
      {
#line 2311
      pr_log_debug(5, "%s", "");
#line 2312
      pr_log_debug(5, "Config for %s:", s->ServerName);
      }
    }
#line 2315
    return;
  }
  {
#line 2318
  _reorder_dirs(s->conf, flags);
#line 2321
  merge_down(s->conf, 0);
  }
#line 2323
  if (! (flags & (1 << 4))) {
    {
#line 2324
    pr_log_debug(5, "%s", "");
#line 2325
    pr_log_debug(5, "Config for %s:", s->ServerName);
#line 2326
    pr_config_dump(& config_dumpf, s->conf, (char *)((void *)0));
    }
  }
#line 2329
  return;
}
}
#line 2332 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *find_config_next(config_rec *prev , config_rec *c , int type , char const   *name ,
                             int recurse ) 
{ 
  config_rec *top ;
  unsigned int cid ;
  config_rec *res ;
  config_rec *subc ;
  int tmp ;
  int tmp___0 ;

  {
#line 2334
  top = c;
#line 2335
  cid = 0U;
#line 2341
  if (! c) {
#line 2341
    if (! prev) {
#line 2343
      return ((config_rec *)((void *)0));
    }
  }
#line 2345
  if (! prev) {
#line 2346
    prev = top;
  }
#line 2348
  if (name) {
    {
#line 2349
    cid = pr_config_get_id(name);
    }
  }
#line 2351
  if (recurse) {
    {
#line 2352
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2353
      res = (config_rec *)((void *)0);
#line 2355
      pr_signals_handle();
#line 2357
      c = top;
      }
      {
#line 2357
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2357
        if (! c) {
#line 2357
          goto while_break___0;
        }
#line 2358
        if (c->subset) {
#line 2358
          if ((c->subset)->xas_list) {
#line 2360
            subc = (config_rec *)((void *)0);
#line 2362
            subc = (config_rec *)(c->subset)->xas_list;
            {
#line 2362
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2362
              if (! subc) {
#line 2362
                goto while_break___1;
              }
              {
#line 2365
              res = find_config_next((config_rec *)((void *)0), subc, type, name,
                                     recurse + 1);
              }
#line 2366
              if (res) {
#line 2367
                return (res);
              }
#line 2362
              subc = subc->next;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 2357
        c = c->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2380
      c = top;
      {
#line 2380
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2380
        if (! c) {
#line 2380
          goto while_break___2;
        }
#line 2381
        if (type == -1) {
#line 2381
          goto _L;
        } else
#line 2381
        if (type == c->config_type) {
          _L: /* CIL Label */ 
#line 2384
          if (! name) {
#line 2385
            return (c);
          }
#line 2387
          if (cid != 0U) {
#line 2387
            if (cid == c->config_id) {
#line 2389
              return (c);
            }
          }
          {
#line 2392
          tmp = strcmp(name, (char const   *)c->name);
          }
#line 2392
          if (tmp == 0) {
#line 2393
            return (c);
          }
        }
#line 2380
        c = c->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2398
      if (prev->parent) {
#line 2398
        if (recurse == 1) {
#line 2398
          if ((prev->parent)->next) {
#line 2398
            if ((unsigned long )(prev->parent)->set != (unsigned long )find_config_top) {
#line 2402
              top = (prev->parent)->next;
#line 2402
              prev = top;
#line 2403
              c = top;
#line 2404
              goto __Cont;
            }
          }
        }
      }
#line 2407
      goto while_break;
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2411
    c = top;
    {
#line 2411
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2411
      if (! c) {
#line 2411
        goto while_break___3;
      }
#line 2412
      if (type == -1) {
#line 2412
        goto _L___0;
      } else
#line 2412
      if (type == c->config_type) {
        _L___0: /* CIL Label */ 
#line 2415
        if (! name) {
#line 2416
          return (c);
        }
#line 2418
        if (cid != 0U) {
#line 2418
          if (cid == c->config_id) {
#line 2420
            return (c);
          }
        }
        {
#line 2423
        tmp___0 = strcmp(name, (char const   *)c->name);
        }
#line 2423
        if (tmp___0 == 0) {
#line 2424
          return (c);
        }
      }
#line 2411
      c = c->next;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2429
  return ((config_rec *)((void *)0));
}
}
#line 2432 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void find_config_set_top(config_rec *c ) 
{ 


  {
#line 2433
  if (c) {
#line 2433
    if (c->parent) {
#line 2435
      find_config_top = (c->parent)->set;
    } else {
#line 2438
      find_config_top = (xaset_t *)((void *)0);
    }
  } else {
#line 2438
    find_config_top = (xaset_t *)((void *)0);
  }
#line 2440
  return;
}
}
#line 2443 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *find_config(xaset_t *set , int type , char const   *name , int recurse ) 
{ 
  config_rec *tmp ;

  {
#line 2444
  if (! set) {
#line 2446
    return ((config_rec *)((void *)0));
  } else
#line 2444
  if (! set->xas_list) {
#line 2446
    return ((config_rec *)((void *)0));
  }
  {
#line 2448
  find_config_set_top((config_rec *)set->xas_list);
#line 2450
  tmp = find_config_next((config_rec *)((void *)0), (config_rec *)set->xas_list, type,
                         name, recurse);
  }
#line 2450
  return (tmp);
}
}
#line 2454 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void *get_param_ptr(xaset_t *set , char const   *name , int recurse ) 
{ 
  config_rec *c ;

  {
#line 2457
  if (! set) {
#line 2458
    _last_param_ptr = (config_rec *)((void *)0);
#line 2459
    return ((void *)0);
  }
  {
#line 2462
  c = find_config(set, 1 << 15, name, recurse);
  }
#line 2464
  if (c) {
#line 2464
    if (c->argc) {
#line 2466
      _last_param_ptr = c;
#line 2467
      return (*(c->argv + 0));
    }
  }
#line 2470
  _last_param_ptr = (config_rec *)((void *)0);
#line 2471
  return ((void *)0);
}
}
#line 2474 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void *get_param_ptr_next(char const   *name , int recurse ) 
{ 
  config_rec *c ;

  {
#line 2477
  if (! _last_param_ptr) {
#line 2479
    _last_param_ptr = (config_rec *)((void *)0);
#line 2480
    return ((void *)0);
  } else
#line 2477
  if (! _last_param_ptr->next) {
#line 2479
    _last_param_ptr = (config_rec *)((void *)0);
#line 2480
    return ((void *)0);
  }
  {
#line 2483
  c = find_config_next(_last_param_ptr, _last_param_ptr->next, 1 << 15, name, recurse);
  }
#line 2486
  if (c) {
#line 2486
    if (c->argv) {
#line 2488
      _last_param_ptr = c;
#line 2489
      return (*(c->argv + 0));
    }
  }
#line 2492
  _last_param_ptr = (config_rec *)((void *)0);
#line 2493
  return ((void *)0);
}
}
#line 2496 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int remove_config(xaset_t *set , char const   *name , int recurse ) 
{ 
  server_rec *s ;
  server_rec *tmp ;
  config_rec *c ;
  int found ;
  xaset_t *fset ;

  {
  {
#line 2497
  tmp = pr_parser_server_ctxt_get();
#line 2497
  s = tmp;
#line 2499
  found = 0;
  }
#line 2502
  if (! s) {
#line 2503
    s = main_server;
  }
  {
#line 2505
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2505
    c = find_config(set, -1, name, recurse);
    }
#line 2505
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 2505
      goto while_break;
    }
    {
#line 2506
    found ++;
#line 2508
    fset = c->set;
#line 2509
    xaset_remove(fset, (xasetmember_t *)c);
    }
#line 2514
    if (! fset->xas_list) {
#line 2517
      if (c->parent) {
#line 2517
        if ((unsigned long )(c->parent)->subset == (unsigned long )fset) {
#line 2518
          (c->parent)->subset = (xaset_t *)((void *)0);
        } else {
#line 2517
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2520
      if ((unsigned long )s->conf == (unsigned long )fset) {
#line 2521
        s->conf = (xaset_t *)((void *)0);
      }
      {
#line 2524
      destroy_pool(fset->pool);
      }
    } else {
      {
#line 2529
      destroy_pool(c->pool);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2533
  return (found);
}
}
#line 2536 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *add_config_param_set(xaset_t **set , char const   *name , int num  , ...) 
{ 
  config_rec *c ;
  config_rec *tmp ;
  void **argv ;
  va_list ap ;
  void *tmp___0 ;
  void **tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2538
  tmp = add_config_set(set, name);
#line 2538
  c = tmp;
  }
#line 2542
  if (c) {
    {
#line 2543
    c->config_type = 1 << 15;
#line 2544
    c->argc = num;
#line 2545
    tmp___0 = pcalloc(c->pool, (int )((unsigned long )(num + 1) * sizeof(void *)));
#line 2545
    c->argv = (void **)tmp___0;
#line 2547
    argv = c->argv;
#line 2548
    __builtin_va_start(ap, num);
    }
    {
#line 2550
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2550
      tmp___3 = num;
#line 2550
      num --;
#line 2550
      if (! (tmp___3 > 0)) {
#line 2550
        goto while_break;
      }
      {
#line 2551
      tmp___1 = argv;
#line 2551
      argv ++;
#line 2551
      tmp___2 = __builtin_va_arg(ap, void *);
#line 2551
      *tmp___1 = tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2553
    __builtin_va_end(ap);
    }
  }
#line 2556
  return (c);
}
}
#line 2559 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *add_config_param_str(char const   *name , int num  , ...) 
{ 
  config_rec *c ;
  config_rec *tmp ;
  char *arg ;
  void **argv ;
  va_list ap ;
  void *tmp___0 ;
  char *tmp___1 ;
  void **tmp___2 ;
  char *tmp___3 ;
  void **tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2560
  tmp = add_config((server_rec *)((void *)0), name);
#line 2560
  c = tmp;
#line 2561
  arg = (char *)((void *)0);
#line 2562
  argv = (void **)((void *)0);
  }
#line 2565
  if (c) {
    {
#line 2566
    c->config_type = 1 << 15;
#line 2567
    c->argc = num;
#line 2568
    tmp___0 = pcalloc(c->pool, (int )((unsigned long )(num + 1) * sizeof(char *)));
#line 2568
    c->argv = (void **)tmp___0;
#line 2570
    argv = c->argv;
#line 2571
    __builtin_va_start(ap, num);
    }
    {
#line 2573
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2573
      tmp___5 = num;
#line 2573
      num --;
#line 2573
      if (! (tmp___5 > 0)) {
#line 2573
        goto while_break;
      }
      {
#line 2574
      tmp___1 = __builtin_va_arg(ap, char *);
#line 2574
      arg = tmp___1;
      }
#line 2575
      if (arg) {
        {
#line 2576
        tmp___2 = argv;
#line 2576
        argv ++;
#line 2576
        tmp___3 = pstrdup(c->pool, (char const   *)arg);
#line 2576
        *tmp___2 = (void *)tmp___3;
        }
      } else {
#line 2578
        tmp___4 = argv;
#line 2578
        argv ++;
#line 2578
        *tmp___4 = (void *)0;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2581
    __builtin_va_end(ap);
    }
  }
#line 2584
  return (c);
}
}
#line 2587 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *pr_conf_add_server_config_param_str(server_rec *s , char const   *name ,
                                                int num  , ...) 
{ 
  config_rec *c ;
  config_rec *tmp ;
  char *arg ;
  void **argv ;
  va_list ap ;
  void *tmp___0 ;
  char *tmp___1 ;
  void **tmp___2 ;
  char *tmp___3 ;
  void **tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2589
  tmp = add_config(s, name);
#line 2589
  c = tmp;
#line 2590
  arg = (char *)((void *)0);
#line 2591
  argv = (void **)((void *)0);
  }
#line 2594
  if (c) {
    {
#line 2595
    c->config_type = 1 << 15;
#line 2596
    c->argc = num;
#line 2597
    tmp___0 = pcalloc(c->pool, (int )((unsigned long )(num + 1) * sizeof(char *)));
#line 2597
    c->argv = (void **)tmp___0;
#line 2599
    argv = c->argv;
#line 2600
    __builtin_va_start(ap, num);
    }
    {
#line 2602
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2602
      tmp___5 = num;
#line 2602
      num --;
#line 2602
      if (! (tmp___5 > 0)) {
#line 2602
        goto while_break;
      }
      {
#line 2603
      tmp___1 = __builtin_va_arg(ap, char *);
#line 2603
      arg = tmp___1;
      }
#line 2604
      if (arg) {
        {
#line 2605
        tmp___2 = argv;
#line 2605
        argv ++;
#line 2605
        tmp___3 = pstrdup(c->pool, (char const   *)arg);
#line 2605
        *tmp___2 = (void *)tmp___3;
        }
      } else {
#line 2607
        tmp___4 = argv;
#line 2607
        argv ++;
#line 2607
        *tmp___4 = (void *)0;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2610
    __builtin_va_end(ap);
    }
  }
#line 2613
  return (c);
}
}
#line 2616 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
config_rec *add_config_param(char const   *name , int num  , ...) 
{ 
  config_rec *c ;
  config_rec *tmp ;
  void **argv ;
  va_list ap ;
  void *tmp___0 ;
  void **tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2617
  tmp = add_config((server_rec *)((void *)0), name);
#line 2617
  c = tmp;
  }
#line 2621
  if (c) {
    {
#line 2622
    c->config_type = 1 << 15;
#line 2623
    c->argc = num;
#line 2624
    tmp___0 = pcalloc(c->pool, (int )((unsigned long )(num + 1) * sizeof(void *)));
#line 2624
    c->argv = (void **)tmp___0;
#line 2626
    argv = c->argv;
#line 2627
    __builtin_va_start(ap, num);
    }
    {
#line 2629
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2629
      tmp___3 = num;
#line 2629
      num --;
#line 2629
      if (! (tmp___3 > 0)) {
#line 2629
        goto while_break;
      }
      {
#line 2630
      tmp___1 = argv;
#line 2630
      argv ++;
#line 2630
      tmp___2 = __builtin_va_arg(ap, void *);
#line 2630
      *tmp___1 = tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2632
    __builtin_va_end(ap);
    }
  }
#line 2635
  return (c);
}
}
#line 2638 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static int config_cmp(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 2639
  tmp = strcmp((char const   *)*((char **)a), (char const   *)*((char **)b));
  }
#line 2639
  return (tmp);
}
}
#line 2642 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int parse_config_path(pool *p , char const   *path ) 
{ 
  struct stat st ;
  int have_glob ;
  int *tmp ;
  int tmp___0 ;
  void *dirh ;
  struct dirent *dent ;
  array_header *file_list ;
  char *dup_path ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  register unsigned int i___0 ;
  char *file ;
  int tmp___17 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 2646
  if (! path) {
    {
#line 2647
    tmp = __errno_location();
#line 2647
    *tmp = 22;
    }
#line 2648
    return (-1);
  }
  {
#line 2651
  have_glob = is_fnmatch(path);
  }
#line 2653
  if (! have_glob) {
    {
#line 2653
    tmp___0 = pr_fsio_lstat(path, & st);
    }
#line 2653
    if (tmp___0 < 0) {
#line 2654
      return (-1);
    }
  }
#line 2656
  if (have_glob) {
#line 2656
    goto _L;
  } else
#line 2656
  if (! ((st.st_mode & 61440U) == 40960U)) {
#line 2656
    if ((st.st_mode & 61440U) == 16384U) {
      _L: /* CIL Label */ 
      {
#line 2661
      tmp___1 = pstrdup(p, path);
#line 2661
      dup_path = tmp___1;
#line 2662
      tmp___3 = strrchr((char const   *)dup_path, '/');
#line 2662
      tmp___2 = tmp___3;
      }
#line 2664
      if (have_glob) {
#line 2664
        if (tmp___2) {
          {
#line 2665
          tmp___4 = tmp___2;
#line 2665
          tmp___2 ++;
#line 2665
          *tmp___4 = (char )'\000';
#line 2667
          tmp___6 = is_fnmatch((char const   *)dup_path);
          }
#line 2667
          if (tmp___6) {
            {
#line 2668
            pr_log_pri(3, "error: wildcard patterns not allowed in configuration directory name \'%s\'",
                       dup_path);
#line 2670
            tmp___5 = __errno_location();
#line 2670
            *tmp___5 = 22;
            }
#line 2671
            return (-1);
          }
          {
#line 2675
          pr_fsio_lstat((char const   *)dup_path, & st);
          }
#line 2677
          if ((st.st_mode & 61440U) == 40960U) {
            {
#line 2678
            pr_log_pri(3, "error: cannot read configuration path \'%s\'", dup_path);
#line 2680
            tmp___7 = __errno_location();
#line 2680
            *tmp___7 = 22;
            }
#line 2681
            return (-1);
          } else
#line 2677
          if (! ((st.st_mode & 61440U) == 16384U)) {
            {
#line 2678
            pr_log_pri(3, "error: cannot read configuration path \'%s\'", dup_path);
#line 2680
            tmp___7 = __errno_location();
#line 2680
            *tmp___7 = 22;
            }
#line 2681
            return (-1);
          }
          {
#line 2684
          tmp___9 = is_fnmatch((char const   *)tmp___2);
          }
#line 2684
          if (! tmp___9) {
            {
#line 2685
            pr_log_pri(3, "error: wildcard pattern required for file \'%s\'", tmp___2);
#line 2687
            tmp___8 = __errno_location();
#line 2687
            *tmp___8 = 22;
            }
#line 2688
            return (-1);
          }
        }
      }
      {
#line 2692
      pr_log_pri(6, "processing configuration directory \'%s\'", dup_path);
#line 2695
      dirh = pr_fsio_opendir((char const   *)dup_path);
      }
#line 2696
      if (! dirh) {
        {
#line 2697
        tmp___10 = __errno_location();
#line 2697
        tmp___11 = strerror(*tmp___10);
#line 2697
        pr_log_pri(3, "error: unable to open configuration directory \'%s\': %s",
                   dup_path, tmp___11);
#line 2700
        tmp___12 = __errno_location();
#line 2700
        *tmp___12 = 22;
        }
#line 2701
        return (-1);
      }
      {
#line 2704
      file_list = make_array(p, 0U, (size_t )sizeof(char *));
      }
      {
#line 2706
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2706
        dent = pr_fsio_readdir(dirh);
        }
#line 2706
        if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 2706
          goto while_break;
        }
        {
#line 2707
        tmp___14 = strcmp((char const   *)(dent->d_name), ".");
        }
#line 2707
        if (tmp___14 != 0) {
          {
#line 2707
          tmp___15 = strcmp((char const   *)(dent->d_name), "..");
          }
#line 2707
          if (tmp___15 != 0) {
#line 2707
            if (! have_glob) {
              {
#line 2711
              tmp___13 = push_array(file_list);
#line 2711
              *((char **)tmp___13) = pdircat(p, dup_path, dent->d_name, (void *)0);
              }
            } else {
              {
#line 2707
              tmp___16 = pr_fnmatch((char const   *)tmp___2, (char const   *)(dent->d_name),
                                    1 << 2);
              }
#line 2707
              if (tmp___16 == 0) {
                {
#line 2711
                tmp___13 = push_array(file_list);
#line 2711
                *((char **)tmp___13) = pdircat(p, dup_path, dent->d_name, (void *)0);
                }
              }
            }
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2715
      pr_fsio_closedir(dirh);
      }
#line 2717
      if (file_list->nelts) {
        {
#line 2720
        qsort(file_list->elts, (size_t )file_list->nelts, (size_t )sizeof(char *),
              & config_cmp);
#line 2723
        i___0 = 0U;
        }
        {
#line 2723
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2723
          if (! (i___0 < (unsigned int )file_list->nelts)) {
#line 2723
            goto while_break___0;
          }
          {
#line 2724
          file = *((char **)file_list->elts + i___0);
#line 2725
          pr_parser_parse_file(p, (char const   *)file, (config_rec *)((void *)0),
                               0);
#line 2723
          i___0 ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 2729
      return (0);
    }
  }
  {
#line 2732
  tmp___17 = pr_parser_parse_file(p, path, (config_rec *)((void *)0), 0);
  }
#line 2732
  return (tmp___17);
}
}
#line 2739 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int fixup_servers(xaset_t *list ) 
{ 
  config_rec *c ;
  server_rec *s ;
  server_rec *next_s ;
  char *tmp ;
  unsigned char *default_server ;
  array_header *addrs ;
  register unsigned int i___0 ;
  pr_netaddr_t **elts ;
  char const   *ipstr ;
  char const   *tmp___0 ;
  char *ipbuf ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned char tmp___4 ;
  server_rec *m ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  void *tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 2740
  c = (config_rec *)((void *)0);
#line 2741
  s = (server_rec *)((void *)0);
#line 2741
  next_s = (server_rec *)((void *)0);
#line 2743
  fixup_globals(list);
#line 2745
  s = (server_rec *)list->xas_list;
  }
#line 2746
  if (s) {
#line 2746
    if (! s->ServerName) {
      {
#line 2747
      tmp = pstrdup(s->pool, "ProFTPD");
#line 2747
      s->ServerName = (char const   *)tmp;
      }
    }
  }
  {
#line 2749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2749
    if (! s) {
#line 2749
      goto while_break;
    }
#line 2750
    default_server = (unsigned char *)((void *)0);
#line 2752
    next_s = s->next;
#line 2753
    if (! s->ServerAddress) {
      {
#line 2754
      addrs = (array_header *)((void *)0);
#line 2756
      s->ServerAddress = pr_netaddr_get_localaddr_str(s->pool);
#line 2758
      s->addr = pr_netaddr_get_addr(s->pool, s->ServerAddress, & addrs);
      }
#line 2760
      if (addrs) {
#line 2762
        elts = (pr_netaddr_t **)addrs->elts;
#line 2765
        i___0 = 0U;
        {
#line 2765
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2765
          if (! (i___0 < (unsigned int )addrs->nelts)) {
#line 2765
            goto while_break___0;
          }
          {
#line 2766
          tmp___0 = pr_netaddr_get_ipstr(*(elts + i___0));
#line 2766
          ipstr = tmp___0;
#line 2769
          tmp___4 = pr_netaddr_use_ipv6();
          }
#line 2769
          if (tmp___4) {
            {
#line 2770
            tmp___1 = pcalloc(s->pool, 46);
#line 2770
            ipbuf = (char *)tmp___1;
#line 2771
            tmp___3 = pr_netaddr_get_family((pr_netaddr_t const   *)*(elts + i___0));
            }
#line 2771
            if (tmp___3 == 2) {
              {
#line 2776
              snprintf((char */* __restrict  */)ipbuf, (size_t )sizeof(ipbuf), (char const   */* __restrict  */)"::ffff:%s",
                       ipstr);
#line 2777
              tmp___2 = pstrdup(s->pool, (char const   *)ipbuf);
#line 2777
              ipstr = (char const   *)tmp___2;
              }
            }
          }
#line 2782
          if (ipstr) {
            {
#line 2783
            pr_conf_add_server_config_param_str(s, "_bind", 1, ipstr);
            }
          }
#line 2765
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 2788
      s->addr = pr_netaddr_get_addr(s->pool, s->ServerAddress, (array_header **)((void *)0));
      }
    }
#line 2790
    if ((unsigned long )s->addr == (unsigned long )((void *)0)) {
      {
#line 2791
      pr_log_pri(4, "warning: unable to determine IP address of \'%s\'", s->ServerAddress);
#line 2793
      xaset_remove(list, (xasetmember_t *)s);
#line 2794
      destroy_pool(s->pool);
      }
#line 2795
      goto __Cont;
    }
    {
#line 2798
    s->ServerFQDN = pr_netaddr_get_dnsstr(s->addr);
    }
#line 2800
    if (! s->ServerFQDN) {
#line 2801
      s->ServerFQDN = s->ServerAddress;
    }
#line 2803
    if (! s->ServerAdmin) {
      {
#line 2804
      s->ServerAdmin = pstrcat(s->pool, "root@", s->ServerFQDN, (void *)0);
      }
    }
#line 2806
    if (! s->ServerName) {
      {
#line 2807
      m = (server_rec *)list->xas_list;
#line 2808
      tmp___5 = pstrdup(s->pool, m->ServerName);
#line 2808
      s->ServerName = (char const   *)tmp___5;
      }
    }
#line 2811
    if (! s->tcp_rcvbuf_len) {
#line 2812
      s->tcp_rcvbuf_len = tcp_rcvbufsz;
    }
#line 2814
    if (! s->tcp_sndbuf_len) {
#line 2815
      s->tcp_sndbuf_len = tcp_sndbufsz;
    }
    {
#line 2817
    c = find_config(s->conf, 1 << 15, "MasqueradeAddress", 0);
    }
#line 2818
    if ((unsigned long )c != (unsigned long )((void *)0)) {
      {
#line 2819
      tmp___6 = pr_netaddr_get_ipstr((pr_netaddr_t *)*(c->argv + 0));
#line 2819
      tmp___7 = pr_netaddr_get_ipstr(s->addr);
#line 2819
      pr_log_pri(6, "%s:%d masquerading as %s", tmp___7, s->ServerPort, tmp___6);
      }
    }
    {
#line 2827
    tmp___8 = get_param_ptr(s->conf, "DefaultServer", 0);
#line 2827
    default_server = (unsigned char *)tmp___8;
    }
#line 2829
    if (default_server) {
#line 2829
      if ((int )*default_server == 1) {
#line 2830
        if (! SocketBindTight) {
          {
#line 2831
          pr_netaddr_set_sockaddr_any(s->addr);
          }
        } else {
          {
#line 2833
          pr_log_pri(5, "SocketBindTight in effect, ignoring DefaultServer");
          }
        }
      }
    }
    {
#line 2837
    fixup_dirs(s, 0);
    }
    __Cont: /* CIL Label */ 
#line 2749
    s = next_s;
  }
  while_break: /* CIL Label */ ;
  }
#line 2844
  if ((unsigned long )list->xas_list == (unsigned long )((void *)0)) {
    {
#line 2845
    pr_log_pri(5, "error: no valid servers configured");
    }
#line 2846
    return (-1);
  }
  {
#line 2849
  pr_inet_clear();
  }
#line 2850
  return (0);
}
}
#line 2853 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static void set_tcp_bufsz(void) 
{ 
  int sockfd ;
  socklen_t optlen ;
  struct protoent *p ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 2855
  optlen = (socklen_t )0;
#line 2856
  p = (struct protoent *)((void *)0);
#line 2858
  p = getprotobyname("tcp");
  }
#line 2859
  if (! p) {
    {
#line 2860
    tcp_rcvbufsz = 8192;
#line 2861
    tcp_sndbufsz = 8192;
#line 2863
    tmp = __errno_location();
#line 2863
    tmp___0 = strerror(*tmp);
#line 2863
    pr_log_debug(3, "getprotobyname error for \'tcp\': %s", tmp___0);
#line 2864
    pr_log_debug(4, "using default TCP receive/send buffer sizes");
    }
#line 2865
    return;
  }
  {
#line 2868
  sockfd = socket(2, 1, p->p_proto);
  }
#line 2869
  if (sockfd < 0) {
    {
#line 2870
    tcp_rcvbufsz = 8192;
#line 2871
    tcp_sndbufsz = 8192;
#line 2873
    tmp___1 = __errno_location();
#line 2873
    tmp___2 = strerror(*tmp___1);
#line 2873
    pr_log_debug(3, "socket error: %s", tmp___2);
#line 2874
    pr_log_debug(4, "using default TCP receive/send buffer sizes");
    }
  }
  {
#line 2879
  optlen = (socklen_t )sizeof(tcp_rcvbufsz);
#line 2880
  tmp___5 = getsockopt(sockfd, 1, 8, (void */* __restrict  */)((void *)(& tcp_rcvbufsz)),
                       (socklen_t */* __restrict  */)(& optlen));
  }
#line 2880
  if (tmp___5 < 0) {
    {
#line 2882
    tcp_rcvbufsz = 8192;
#line 2884
    tmp___3 = __errno_location();
#line 2884
    tmp___4 = strerror(*tmp___3);
#line 2884
    pr_log_debug(3, "getsockopt error for SO_RCVBUF: %s", tmp___4);
#line 2885
    pr_log_debug(4, "using default TCP receive buffer size of %d bytes", tcp_rcvbufsz);
    }
  } else {
    {
#line 2889
    pr_log_debug(5, "using TCP receive buffer size of %d bytes", tcp_rcvbufsz);
    }
  }
  {
#line 2901
  optlen = (socklen_t )sizeof(tcp_sndbufsz);
#line 2902
  tmp___8 = getsockopt(sockfd, 1, 7, (void */* __restrict  */)((void *)(& tcp_sndbufsz)),
                       (socklen_t */* __restrict  */)(& optlen));
  }
#line 2902
  if (tmp___8 < 0) {
    {
#line 2904
    tcp_sndbufsz = 8192;
#line 2906
    tmp___6 = __errno_location();
#line 2906
    tmp___7 = strerror(*tmp___6);
#line 2906
    pr_log_debug(3, "getsockopt error for SO_SNDBUF: %s", tmp___7);
#line 2907
    pr_log_debug(4, "using default TCP send buffer size of %d bytes", tcp_sndbufsz);
    }
  } else {
    {
#line 2911
    pr_log_debug(5, "using TCP send buffer size of %d bytes", tcp_sndbufsz);
    }
  }
  {
#line 2927
  xfer_bufsz = 1024;
#line 2930
  close(sockfd);
  }
#line 2931
  return;
}
}
#line 2933 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
void init_config(void) 
{ 
  pool *conf_pool ;
  pool *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  server_rec *s ;
  server_rec *s_next ;
  void *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 2934
  tmp = make_sub_pool(permanent_pool);
#line 2934
  conf_pool = tmp;
#line 2935
  pr_pool_tag(conf_pool, "Config Pool");
  }
#line 2938
  if (global_config_pool) {
    {
#line 2939
    destroy_pool(global_config_pool);
#line 2940
    global_config_pool = (pool *)((void *)0);
    }
  }
#line 2943
  if (config_tab) {
    {
#line 2947
    tmp___2 = pr_table_empty(config_tab);
    }
#line 2947
    if (tmp___2 < 0) {
      {
#line 2948
      tmp___0 = __errno_location();
#line 2948
      tmp___1 = strerror(*tmp___0);
#line 2948
      pr_log_debug(0, "error emptying config ID table: %s", tmp___1);
      }
    }
    {
#line 2952
    tmp___5 = pr_table_free(config_tab);
    }
#line 2952
    if (tmp___5 < 0) {
      {
#line 2953
      tmp___3 = __errno_location();
#line 2953
      tmp___4 = strerror(*tmp___3);
#line 2953
      pr_log_debug(0, "error destroying config ID table: %s", tmp___4);
      }
    }
    {
#line 2957
    config_tab = pr_table_alloc(config_tab_pool, 0);
#line 2963
    config_id = 0U;
    }
  } else {
    {
#line 2967
    config_tab_pool = make_sub_pool(permanent_pool);
#line 2968
    pr_pool_tag(config_tab_pool, "Config ID Table Pool");
#line 2969
    config_tab = pr_table_alloc(config_tab_pool, 0);
    }
  }
#line 2972
  if (server_list) {
#line 2976
    s = (server_rec *)server_list->xas_list;
    {
#line 2976
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2976
      if (! s) {
#line 2976
        goto while_break;
      }
      {
#line 2977
      s_next = s->next;
#line 2978
      destroy_pool(s->pool);
#line 2976
      s = s_next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2981
    destroy_pool(server_list->pool);
#line 2982
    server_list = (xaset_t *)((void *)0);
    }
  }
  {
#line 2990
  server_list = xaset_create(conf_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
#line 2992
  conf_pool = make_sub_pool(permanent_pool);
#line 2993
  pr_pool_tag(conf_pool, "main_server pool");
#line 2995
  tmp___6 = pcalloc(conf_pool, (int )sizeof(server_rec ));
#line 2995
  main_server = (server_rec *)tmp___6;
#line 2996
  xaset_insert(server_list, (xasetmember_t *)main_server);
#line 2998
  main_server->pool = conf_pool;
#line 2999
  main_server->set = server_list;
#line 3000
  main_server->sid = 1U;
#line 3003
  tmp___7 = pr_inet_getservport(main_server->pool, "ftp", "tcp");
#line 3003
  main_server->ServerPort = (unsigned int )tmp___7;
#line 3006
  set_tcp_bufsz();
  }
#line 3007
  return;
}
}
#line 3013 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
unsigned char check_context(cmd_rec *cmd , int allowed ) 
{ 
  int ctxt ;
  int tmp ;
  int tmp___0 ;

  {
#line 3014
  if (cmd->config) {
#line 3014
    if ((cmd->config)->config_type != 1 << 15) {
#line 3014
      tmp___0 = (cmd->config)->config_type;
    } else {
#line 3014
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3014
    if ((cmd->server)->config_type) {
#line 3014
      tmp = (cmd->server)->config_type;
    } else {
#line 3014
      tmp = 1;
    }
#line 3014
    tmp___0 = tmp;
  }
#line 3014
  ctxt = tmp___0;
#line 3018
  if (ctxt & allowed) {
#line 3019
    return ((unsigned char)1);
  }
#line 3022
  return ((unsigned char)0);
}
}
#line 3026 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
static char cbuf[20]  ;
#line 3025 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
char *get_context_name(cmd_rec *cmd ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3028
  if (! cmd->config) {
#line 3028
    goto _L;
  } else
#line 3028
  if ((cmd->config)->config_type == 1 << 15) {
    _L: /* CIL Label */ 
#line 3029
    if ((cmd->server)->config_type == 1 << 4) {
#line 3030
      return ((char *)"<VirtualHost>");
    } else {
#line 3032
      return ((char *)"server config");
    }
  }
  {
#line 3036
  if ((cmd->config)->config_type == 1 << 1) {
#line 3036
    goto case_exp;
  }
#line 3039
  if ((cmd->config)->config_type == 1 << 2) {
#line 3039
    goto case_exp___0;
  }
#line 3042
  if ((cmd->config)->config_type == 1 << 7) {
#line 3042
    goto case_exp___1;
  }
#line 3045
  if ((cmd->config)->config_type == 1 << 3) {
#line 3045
    goto case_exp___2;
  }
#line 3048
  if ((cmd->config)->config_type == 1 << 5) {
#line 3048
    goto case_exp___3;
  }
#line 3051
  if ((cmd->config)->config_type == 1 << 6) {
#line 3051
    goto case_exp___4;
  }
#line 3054
  if ((cmd->config)->config_type == 1 << 14) {
#line 3054
    goto case_exp___5;
  }
#line 3057
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 3037
  return ((char *)"<Directory>");
  case_exp___0: /* CIL Label */ 
#line 3040
  return ((char *)"<Anonymous>");
  case_exp___1: /* CIL Label */ 
#line 3043
  return ((char *)"<Class>");
  case_exp___2: /* CIL Label */ 
#line 3046
  return ((char *)"<Limit>");
  case_exp___3: /* CIL Label */ 
#line 3049
  return ((char *)".ftpaccess");
  case_exp___4: /* CIL Label */ 
#line 3052
  return ((char *)"<Global>");
  case_exp___5: /* CIL Label */ 
#line 3055
  return ((char *)"user data");
  switch_default: /* CIL Label */ 
  {
#line 3061
  memset((void *)(cbuf), '\000', (size_t )sizeof(cbuf));
#line 3062
  snprintf((char */* __restrict  */)(cbuf), (size_t )sizeof(cbuf), (char const   */* __restrict  */)"%d",
           (cmd->config)->config_type);
  }
#line 3063
  return (cbuf);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3067 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int get_boolean(cmd_rec *cmd , int av ) 
{ 
  char *cp ;
  int tmp ;

  {
  {
#line 3068
  cp = *(cmd->argv + av);
#line 3070
  tmp = pr_str_is_boolean((char const   *)cp);
  }
#line 3070
  return (tmp);
}
}
#line 3073 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
char *get_full_cmd(cmd_rec *cmd ) 
{ 
  pool *p ;
  char *res ;
  char *tmp ;
  register unsigned int i___0 ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3074
  p = cmd->tmp_pool;
#line 3075
  res = (char *)"";
#line 3077
  if (cmd->arg) {
#line 3077
    if (*(cmd->arg)) {
      {
#line 3078
      tmp = pr_fs_decode_path(p, (char const   *)cmd->arg);
#line 3078
      res = pstrcat(p, *(cmd->argv + 0), " ", tmp, (void *)0);
      }
    } else {
#line 3077
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3080
  if (cmd->argc > 1) {
#line 3081
    i___0 = 0U;
#line 3082
    res = *(cmd->argv + 0);
#line 3084
    i___0 = 1U;
    {
#line 3084
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3084
      if (! (i___0 < (unsigned int )cmd->argc)) {
#line 3084
        goto while_break;
      }
      {
#line 3085
      tmp___0 = pr_fs_decode_path(p, (char const   *)*(cmd->argv + i___0));
#line 3085
      res = pstrcat(p, res, tmp___0, " ", (void *)0);
#line 3084
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3087
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3087
      tmp___2 = strlen((char const   *)res);
      }
#line 3087
      if ((int )*(res + (tmp___2 - 1U)) == 32) {
#line 3087
        if (! *res) {
#line 3087
          goto while_break___0;
        }
      } else {
#line 3087
        goto while_break___0;
      }
      {
#line 3088
      tmp___1 = strlen((char const   *)res);
#line 3088
      *(res + (tmp___1 - 1U)) = (char )'\000';
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 3091
    res = pstrdup(p, (char const   *)*(cmd->argv + 0));
    }
  }
#line 3093
  return (res);
}
}
#line 3096 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
unsigned int pr_config_get_id(char const   *name ) 
{ 
  void *ptr ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 3099
  if (! name) {
    {
#line 3100
    tmp = __errno_location();
#line 3100
    *tmp = 22;
    }
#line 3101
    return (0U);
  }
#line 3104
  if (! config_tab) {
    {
#line 3105
    tmp___0 = __errno_location();
#line 3105
    *tmp___0 = 1;
    }
#line 3106
    return (0U);
  }
  {
#line 3109
  ptr = pr_table_get(config_tab, name, (size_t *)0);
  }
#line 3110
  if (! ptr) {
    {
#line 3111
    tmp___1 = __errno_location();
#line 3111
    *tmp___1 = 2;
    }
#line 3112
    return (0U);
  }
#line 3115
  return (*((unsigned int *)ptr));
}
}
#line 3118 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
unsigned int pr_config_set_id(char const   *name ) 
{ 
  unsigned int *ptr ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp11 ;

  {
#line 3121
  if (! name) {
    {
#line 3122
    tmp = __errno_location();
#line 3122
    *tmp = 22;
    }
#line 3123
    return (0U);
  }
#line 3126
  if (! config_tab) {
    {
#line 3127
    tmp___0 = __errno_location();
#line 3127
    *tmp___0 = 1;
    }
#line 3128
    return (0U);
  }
  {
#line 3131
  tmp___1 = pr_table_pcalloc(config_tab, (size_t )sizeof(unsigned int ));
#line 3131
  ptr = (unsigned int *)tmp___1;
#line 3132
  config_id ++;
#line 3132
  *ptr = config_id;
#line 3134
  tmp___6 = pr_table_add(config_tab, name, (void *)ptr, (size_t )sizeof(unsigned int *));
  }
#line 3134
  if (tmp___6 < 0) {
    {
#line 3135
    tmp___5 = __errno_location();
    }
#line 3135
    if (*tmp___5 == 17) {
      {
#line 3136
      tmp___2 = pr_config_get_id(name);
      }
#line 3136
      return (tmp___2);
    } else {
      {
#line 3139
      tmp___3 = __errno_location();
#line 3139
      tmp___4 = strerror(*tmp___3);
#line 3139
      pr_log_debug(0, "error adding \'%s\' to config ID table: %s", name, tmp___4);
      }
#line 3141
      return (0U);
    }
  }
#line 3145
  return (*ptr);
}
}
#line 3148 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/dirtree.c"
int pr_config_get_xfer_bufsz(void) 
{ 


  {
#line 3149
  return (xfer_bufsz);
}
}
#line 549 "/usr/include/regex.h"
extern void regfree(regex_t *__preg ) ;
#line 35 "../include/regexp.h"
void init_regexp(void) ;
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
static pool *regexp_pool  =    (pool *)((void *)0);
#line 37 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
static array_header *regexp_list  =    (array_header *)((void *)0);
#line 39 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
static void regexp_cleanup(void) 
{ 
  register unsigned int i___0 ;
  regex_t **regexp ;

  {
#line 41
  if (regexp_pool) {
#line 42
    i___0 = 0U;
#line 43
    regexp = (regex_t **)regexp_list->elts;
#line 45
    i___0 = 0U;
    {
#line 45
    while (1) {
      while_continue: /* CIL Label */ ;
#line 45
      if (! (i___0 < (unsigned int )regexp_list->nelts)) {
#line 45
        goto while_break;
      }
#line 46
      if (*(regexp + i___0)) {
        {
#line 49
        regfree(*(regexp + i___0));
#line 52
        free((void *)*(regexp + i___0));
        }
      }
#line 45
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 56
    destroy_pool(regexp_pool);
#line 57
    regexp_pool = (pool *)((void *)0);
#line 58
    regexp_list = (array_header *)((void *)0);
    }
  }
#line 60
  return;
}
}
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
static void regexp_exit_ev(void const   *event_data , void *user_data ) 
{ 


  {
  {
#line 63
  regexp_cleanup();
  }
#line 64
  return;
}
}
#line 67 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
static void regexp_restart_ev(void const   *event_data , void *user_data ) 
{ 


  {
  {
#line 68
  regexp_cleanup();
  }
#line 69
  return;
}
}
#line 72 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
regex_t *pr_regexp_alloc(void) 
{ 
  regex_t *preg ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 73
  preg = (regex_t *)((void *)0);
#line 79
  if (! regexp_pool) {
    {
#line 80
    regexp_pool = make_sub_pool(permanent_pool);
#line 81
    pr_pool_tag(regexp_pool, "Regexp Pool");
#line 82
    regexp_list = make_array(regexp_pool, 0U, (size_t )sizeof(regex_t *));
    }
  }
  {
#line 85
  tmp = calloc((size_t )1, (size_t )sizeof(regex_t ));
#line 85
  preg = (regex_t *)tmp;
  }
#line 86
  if ((unsigned long )preg == (unsigned long )((void *)0)) {
    {
#line 87
    pr_log_pri(3, "fatal: memory exhausted");
#line 88
    exit(1);
    }
  }
  {
#line 92
  tmp___0 = push_array(regexp_list);
#line 92
  *((regex_t **)tmp___0) = preg;
  }
#line 94
  return (preg);
}
}
#line 97 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
void pr_regexp_free(regex_t *regex ) 
{ 
  register unsigned int i___0 ;
  regex_t **regexp ;

  {
#line 98
  i___0 = 0U;
#line 99
  regexp = (regex_t **)((void *)0);
#line 101
  if (! regex) {
#line 102
    return;
  } else
#line 101
  if (! regexp_list) {
#line 102
    return;
  }
#line 104
  regexp = (regex_t **)regexp_list->elts;
#line 106
  i___0 = 0U;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i___0 < (unsigned int )regexp_list->nelts)) {
#line 106
      goto while_break;
    }
#line 107
    if ((unsigned long )*(regexp + i___0) == (unsigned long )regex) {
      {
#line 110
      regfree(*(regexp + i___0));
#line 113
      free((void *)*(regexp + i___0));
#line 115
      *(regexp + i___0) = (regex_t *)((void *)0);
      }
    }
#line 106
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/regexp.c"
void init_regexp(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 129
  pr_event_register((module *)((void *)0), "core.restart", & regexp_restart_ev, (void *)0);
#line 130
  pr_event_register((module *)((void *)0), "core.exit", & regexp_exit_ev, (void *)0);
  }
#line 131
  return;
}
}
#line 79 "../include/table.h"
int pr_table_count(pr_table_t *tab ) ;
#line 93
int pr_table_do(pr_table_t *tab , int (*cb)(void const   *key_data , size_t key_datasz ,
                                            void *value_data , size_t value_datasz ,
                                            void *user_data ) , void *user_data ,
                int flags ) ;
#line 224
void pr_table_dump(void (*dumpf)(char const   *fmt  , ...) , pr_table_t *tab ) ;
#line 254
void *pr_table_kremove(pr_table_t *tab , void const   *key_data , size_t key_datasz ,
                       size_t *value_datasz ) ;
#line 261
int pr_table_kset(pr_table_t *tab , void const   *key_data , size_t key_datasz , void *value_data ,
                  size_t value_datasz ) ;
#line 275
int table_handling_signal(int bool ) ;
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static int handling_signal  =    0;
#line 71 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static int key_cmp(void const   *key1 , size_t keysz1 , void const   *key2 , size_t keysz2 ) 
{ 
  int tmp ;

  {
  {
#line 73
  tmp = strcmp((char const   *)key1, (char const   *)key2);
  }
#line 73
  return (tmp);
}
}
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static unsigned int key_hash(void const   *key , size_t keysz ) 
{ 
  unsigned int i___0 ;
  size_t sz ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *k ;
  unsigned int c ;
  size_t tmp___1 ;

  {
#line 78
  i___0 = 0U;
#line 79
  if (! keysz) {
    {
#line 79
    tmp = strlen((char const   *)key);
#line 79
    tmp___0 = tmp;
    }
  } else {
#line 79
    tmp___0 = keysz;
  }
#line 79
  sz = tmp___0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    tmp___1 = sz;
#line 81
    sz --;
#line 81
    if (! tmp___1) {
#line 81
      goto while_break;
    }
#line 82
    k = (char const   *)key;
#line 83
    c = (unsigned int )*k;
#line 84
    k ++;
#line 86
    if (! handling_signal) {
      {
#line 88
      pr_signals_handle();
      }
    }
#line 91
    i___0 = i___0 * 33U + c;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (i___0);
}
}
#line 100 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static void entry_insert(pr_table_entry_t **h , pr_table_entry_t *e ) 
{ 
  pr_table_entry_t *ei ;

  {
#line 103
  ei = *h;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (ei) {
#line 103
      if (! ei->next) {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
#line 103
    ei = ei->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  ei->next = e;
#line 107
  e->prev = ei;
#line 108
  return;
}
}
#line 111 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static void entry_remove(pr_table_entry_t **h , pr_table_entry_t *e ) 
{ 
  struct tab_entry *tmp ;

  {
#line 113
  if (e->next) {
#line 114
    (e->next)->prev = e->prev;
  }
#line 116
  if (e->prev) {
#line 117
    (e->prev)->next = e->next;
  }
#line 119
  if ((unsigned long )e == (unsigned long )*h) {
#line 119
    if ((unsigned long )e->next == (unsigned long )((void *)0)) {
#line 122
      *h = (pr_table_entry_t *)((void *)0);
    } else {
#line 125
      *h = e->next;
    }
  } else {
#line 125
    *h = e->next;
  }
#line 127
  tmp = (struct tab_entry *)((void *)0);
#line 127
  e->next = tmp;
#line 127
  e->prev = tmp;
#line 128
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static pr_table_key_t *tab_key_alloc(pr_table_t *tab ) 
{ 
  pr_table_key_t *k ;
  void *tmp ;

  {
#line 138
  if (tab->free_keys) {
#line 139
    k = tab->free_keys;
#line 140
    tab->free_keys = k->next;
#line 141
    k->next = (struct tab_key *)((void *)0);
#line 143
    return (k);
  }
  {
#line 147
  tmp = pcalloc(tab->pool, (int )sizeof(pr_table_key_t ));
#line 147
  k = (pr_table_key_t *)tmp;
  }
#line 149
  return (k);
}
}
#line 152 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static void tab_key_free(pr_table_t *tab , pr_table_key_t *k ) 
{ 
  pr_table_key_t *i___0 ;

  {
  {
#line 154
  memset((void *)k, 0, (size_t )sizeof(pr_table_key_t ));
  }
#line 157
  if (tab->free_keys) {
#line 158
    i___0 = tab->free_keys;
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! ((unsigned long )i___0->next != (unsigned long )((void *)0))) {
#line 161
        goto while_break;
      }
#line 162
      if (! handling_signal) {
        {
#line 163
        pr_signals_handle();
        }
      }
#line 166
      i___0 = i___0->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 169
    i___0->next = k;
  } else {
#line 172
    tab->free_keys = k;
  }
#line 173
  return;
}
}
#line 178 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static pr_table_entry_t *tab_entry_alloc(pr_table_t *tab ) 
{ 
  pr_table_entry_t *e ;
  void *tmp ;

  {
#line 182
  if (tab->free_ents) {
#line 183
    e = tab->free_ents;
#line 184
    tab->free_ents = e->next;
#line 185
    e->next = (struct tab_entry *)((void *)0);
#line 187
    return (e);
  }
  {
#line 191
  tmp = pcalloc(tab->pool, (int )sizeof(pr_table_entry_t ));
#line 191
  e = (pr_table_entry_t *)tmp;
  }
#line 193
  return (e);
}
}
#line 196 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static void tab_entry_free(pr_table_t *tab , pr_table_entry_t *e ) 
{ 
  pr_table_entry_t *i___0 ;

  {
  {
#line 198
  memset((void *)e, 0, (size_t )sizeof(pr_table_entry_t ));
  }
#line 201
  if (tab->free_ents) {
#line 202
    i___0 = tab->free_ents;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 205
      if (! ((unsigned long )i___0->next != (unsigned long )((void *)0))) {
#line 205
        goto while_break;
      }
#line 206
      if (! handling_signal) {
        {
#line 207
        pr_signals_handle();
        }
      }
#line 210
      i___0 = i___0->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 213
    i___0->next = e;
  } else {
#line 216
    tab->free_ents = e;
  }
#line 217
  return;
}
}
#line 219 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static void tab_entry_insert(pr_table_t *tab , pr_table_entry_t *e ) 
{ 
  pr_table_entry_t *h ;

  {
#line 220
  h = *(tab->chains + e->idx);
#line 222
  if (h) {
#line 222
    if ((unsigned long )h != (unsigned long )e) {
      {
#line 229
      (*(tab->entinsert))(& h, e);
#line 230
      *(tab->chains + e->idx) = h;
      }
    }
  }
#line 233
  ((e->key)->nents) ++;
#line 234
  (tab->nents) ++;
#line 235
  return;
}
}
#line 237 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static pr_table_entry_t *tab_entry_next(pr_table_t *tab ) 
{ 
  pr_table_entry_t *ent ;
  register unsigned int i___0 ;
  register unsigned int i___1 ;

  {
#line 238
  ent = (pr_table_entry_t *)((void *)0);
#line 240
  if (tab->tab_iter_ent) {
#line 241
    ent = (tab->tab_iter_ent)->next;
#line 243
    if (! ent) {
#line 249
      ent = (pr_table_entry_t *)((void *)0);
#line 252
      i___0 = (tab->tab_iter_ent)->idx + 1U;
      {
#line 252
      while (1) {
        while_continue: /* CIL Label */ ;
#line 252
        if (! (i___0 < tab->nchains)) {
#line 252
          goto while_break;
        }
#line 253
        if (*(tab->chains + i___0)) {
#line 254
          ent = *(tab->chains + i___0);
#line 255
          goto while_break;
        }
#line 252
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
#line 264
    i___1 = 0U;
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 264
      if (! (i___1 < tab->nchains)) {
#line 264
        goto while_break___0;
      }
#line 265
      if (*(tab->chains + i___1)) {
#line 266
        ent = *(tab->chains + i___1);
#line 267
        goto while_break___0;
      }
#line 264
      i___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 272
  tab->tab_iter_ent = ent;
#line 273
  return (ent);
}
}
#line 276 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
static void tab_entry_remove(pr_table_t *tab , pr_table_entry_t *e ) 
{ 
  pr_table_entry_t *h ;

  {
  {
#line 277
  h = *(tab->chains + e->idx);
#line 279
  (*(tab->entremove))(& h, e);
#line 280
  *(tab->chains + e->idx) = h;
#line 281
  ((e->key)->nents) --;
  }
#line 283
  if ((e->key)->nents == 0U) {
    {
#line 284
    tab_key_free(tab, e->key);
#line 285
    e->key = (pr_table_key_t *)((void *)0);
    }
  }
#line 288
  (tab->nents) --;
#line 289
  return;
}
}
#line 294 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_kadd(pr_table_t *tab , void const   *key_data , size_t key_datasz , void *value_data ,
                  size_t value_datasz ) 
{ 
  unsigned int h ;
  unsigned int idx ;
  pr_table_entry_t *e ;
  pr_table_entry_t *n ;
  int *tmp ;
  pr_table_entry_t *ei ;
  int *tmp___0 ;
  int tmp___1 ;
  pr_table_key_t *k ;

  {
#line 299
  if ((unsigned long )tab == (unsigned long )((void *)0)) {
    {
#line 302
    tmp = __errno_location();
#line 302
    *tmp = 22;
    }
#line 303
    return (-1);
  } else
#line 299
  if ((unsigned long )key_data == (unsigned long )((void *)0)) {
    {
#line 302
    tmp = __errno_location();
#line 302
    *tmp = 22;
    }
#line 303
    return (-1);
  } else
#line 299
  if (value_datasz > 0U) {
#line 299
    if ((unsigned long )value_data == (unsigned long )((void *)0)) {
      {
#line 302
      tmp = __errno_location();
#line 302
      *tmp = 22;
      }
#line 303
      return (-1);
    }
  }
  {
#line 306
  h = (*(tab->keyhash))(key_data, key_datasz);
#line 311
  idx = h % tab->nchains;
#line 314
  n = tab_entry_alloc(tab);
#line 315
  n->value_data = value_data;
#line 316
  n->value_datasz = value_datasz;
#line 317
  n->idx = idx;
#line 320
  e = *(tab->chains + idx);
  }
#line 322
  if (e) {
#line 330
    ei = e;
    {
#line 330
    while (1) {
      while_continue: /* CIL Label */ ;
#line 330
      if (! ei) {
#line 330
        goto while_break;
      }
#line 331
      if ((ei->key)->hash != h) {
#line 332
        goto __Cont;
      }
      {
#line 338
      tmp___1 = (*(tab->keycmp))((void const   *)(ei->key)->key_data, (size_t )0,
                                 key_data, (size_t )0);
      }
#line 338
      if (tmp___1 == 0) {
#line 341
        if (! (tab->flags & 1UL)) {
          {
#line 342
          tmp___0 = __errno_location();
#line 342
          *tmp___0 = 17;
          }
#line 343
          return (-1);
        } else {
#line 346
          n->key = ei->key;
        }
      }
      __Cont: /* CIL Label */ 
#line 330
      ei = ei->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 353
    *(tab->chains + idx) = n;
  }
#line 356
  if (! n->key) {
    {
#line 360
    k = tab_key_alloc(tab);
#line 362
    k->key_data = (void *)key_data;
#line 363
    k->key_datasz = key_datasz;
#line 364
    k->hash = h;
#line 365
    k->nents = 0U;
#line 367
    n->key = k;
    }
  }
  {
#line 370
  tab_entry_insert(tab, n);
  }
#line 371
  return (0);
}
}
#line 374 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_kexists(pr_table_t *tab , void const   *key_data , size_t key_datasz ) 
{ 
  unsigned int h ;
  unsigned int idx ;
  pr_table_entry_t *head___0 ;
  pr_table_entry_t *ent ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 378
  if (! tab) {
    {
#line 379
    tmp = __errno_location();
#line 379
    *tmp = 22;
    }
#line 380
    return (-1);
  } else
#line 378
  if (! key_data) {
    {
#line 379
    tmp = __errno_location();
#line 379
    *tmp = 22;
    }
#line 380
    return (-1);
  }
#line 383
  if (tab->nents == 0U) {
    {
#line 384
    tmp___0 = __errno_location();
#line 384
    *tmp___0 = 2;
    }
#line 385
    return (-1);
  }
#line 388
  if (tab->flags & 2UL) {
#line 393
    if (tab->cache_ent) {
#line 393
      if ((unsigned long )((tab->cache_ent)->key)->key_data == (unsigned long )key_data) {
#line 395
        return ((int )((tab->cache_ent)->key)->nents);
      }
    }
  }
  {
#line 398
  h = (*(tab->keyhash))(key_data, key_datasz);
#line 399
  idx = h % tab->nchains;
#line 401
  head___0 = *(tab->chains + idx);
  }
#line 403
  if (! head___0) {
#line 404
    tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 405
    return (0);
  }
#line 408
  ent = head___0;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! ent) {
#line 408
      goto while_break;
    }
#line 409
    if ((unsigned long )ent->key == (unsigned long )((void *)0)) {
#line 411
      goto __Cont;
    } else
#line 409
    if ((ent->key)->hash != h) {
#line 411
      goto __Cont;
    }
    {
#line 414
    tmp___1 = (*(tab->keycmp))((void const   *)(ent->key)->key_data, (ent->key)->key_datasz,
                               key_data, key_datasz);
    }
#line 414
    if (tmp___1 == 0) {
#line 417
      if (tab->flags & 2UL) {
#line 418
        tab->cache_ent = ent;
      }
#line 420
      return ((int )(ent->key)->nents);
    }
    __Cont: /* CIL Label */ 
#line 408
    ent = ent->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 424
  tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 426
  tmp___2 = __errno_location();
#line 426
  *tmp___2 = 22;
  }
#line 427
  return (0);
}
}
#line 430 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void *pr_table_kget(pr_table_t *tab , void const   *key_data , size_t key_datasz ,
                    size_t *value_datasz ) 
{ 
  unsigned int h ;
  pr_table_entry_t *head___0 ;
  pr_table_entry_t *ent ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  unsigned int idx ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 435
  if (! tab) {
    {
#line 436
    tmp = __errno_location();
#line 436
    *tmp = 22;
    }
#line 437
    return ((void *)0);
  }
#line 441
  if (! key_data) {
    {
#line 442
    tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 443
    tab->val_iter_ent = (pr_table_entry_t *)((void *)0);
#line 445
    tmp___0 = __errno_location();
#line 445
    *tmp___0 = 2;
    }
#line 446
    return ((void *)0);
  }
#line 449
  if (tab->nents == 0U) {
    {
#line 450
    tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 451
    tab->val_iter_ent = (pr_table_entry_t *)((void *)0);
#line 453
    tmp___1 = __errno_location();
#line 453
    *tmp___1 = 2;
    }
#line 454
    return ((void *)0);
  }
  {
#line 457
  h = (*(tab->keyhash))(key_data, key_datasz);
  }
#line 463
  if (tab->val_iter_ent) {
#line 463
    if ((unsigned long )((tab->val_iter_ent)->key)->key_data == (unsigned long )key_data) {
#line 465
      head___0 = (tab->val_iter_ent)->next;
    } else {
#line 463
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 467
  if (tab->flags & 2UL) {
#line 467
    if (tab->cache_ent) {
#line 467
      if ((unsigned long )((tab->cache_ent)->key)->key_data == (unsigned long )key_data) {
#line 472
        head___0 = tab->cache_ent;
      } else {
#line 475
        idx = h % tab->nchains;
#line 476
        head___0 = *(tab->chains + idx);
      }
    } else {
#line 475
      idx = h % tab->nchains;
#line 476
      head___0 = *(tab->chains + idx);
    }
  } else {
#line 475
    idx = h % tab->nchains;
#line 476
    head___0 = *(tab->chains + idx);
  }
#line 479
  if (! head___0) {
    {
#line 480
    tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 481
    tab->val_iter_ent = (pr_table_entry_t *)((void *)0);
#line 483
    tmp___2 = __errno_location();
#line 483
    *tmp___2 = 2;
    }
#line 484
    return ((void *)0);
  }
#line 487
  ent = head___0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! ent) {
#line 487
      goto while_break;
    }
#line 488
    if ((unsigned long )ent->key == (unsigned long )((void *)0)) {
#line 490
      goto __Cont;
    } else
#line 488
    if ((ent->key)->hash != h) {
#line 490
      goto __Cont;
    }
    {
#line 493
    tmp___3 = (*(tab->keycmp))((void const   *)(ent->key)->key_data, (ent->key)->key_datasz,
                               key_data, key_datasz);
    }
#line 493
    if (tmp___3 == 0) {
#line 496
      if (tab->flags & 2UL) {
#line 497
        tab->cache_ent = ent;
      }
#line 499
      if (tab->flags & 1UL) {
#line 500
        tab->val_iter_ent = ent;
      }
#line 502
      if (value_datasz) {
#line 503
        *value_datasz = ent->value_datasz;
      }
#line 505
      return (ent->value_data);
    }
    __Cont: /* CIL Label */ 
#line 487
    ent = ent->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 510
  tab->val_iter_ent = (pr_table_entry_t *)((void *)0);
#line 512
  tmp___4 = __errno_location();
#line 512
  *tmp___4 = 2;
  }
#line 513
  return ((void *)0);
}
}
#line 516 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void *pr_table_kremove(pr_table_t *tab , void const   *key_data , size_t key_datasz ,
                       size_t *value_datasz ) 
{ 
  unsigned int h ;
  unsigned int idx ;
  pr_table_entry_t *head___0 ;
  pr_table_entry_t *ent ;
  int *tmp ;
  int *tmp___0 ;
  void *value_data ;
  int *tmp___1 ;
  void *value_data___0 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
#line 521
  if (! tab) {
    {
#line 522
    tmp = __errno_location();
#line 522
    *tmp = 22;
    }
#line 523
    return ((void *)0);
  } else
#line 521
  if (! key_data) {
    {
#line 522
    tmp = __errno_location();
#line 522
    *tmp = 22;
    }
#line 523
    return ((void *)0);
  }
#line 526
  if (tab->nents == 0U) {
    {
#line 527
    tmp___0 = __errno_location();
#line 527
    *tmp___0 = 2;
    }
#line 528
    return ((void *)0);
  }
#line 535
  if (tab->flags & 2UL) {
#line 535
    if (tab->cache_ent) {
#line 535
      if ((unsigned long )((tab->cache_ent)->key)->key_data == (unsigned long )key_data) {
#line 538
        value_data = (tab->cache_ent)->value_data;
#line 540
        if (value_datasz) {
#line 541
          *value_datasz = (tab->cache_ent)->value_datasz;
        }
        {
#line 543
        tab_entry_remove(tab, tab->cache_ent);
#line 544
        tab_entry_free(tab, tab->cache_ent);
#line 545
        tab->cache_ent = (pr_table_entry_t *)((void *)0);
        }
#line 547
        return (value_data);
      }
    }
  }
  {
#line 550
  h = (*(tab->keyhash))(key_data, key_datasz);
#line 551
  idx = h % tab->nchains;
#line 553
  head___0 = *(tab->chains + idx);
  }
#line 555
  if (! head___0) {
    {
#line 556
    tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 558
    tmp___1 = __errno_location();
#line 558
    *tmp___1 = 2;
    }
#line 559
    return ((void *)0);
  }
#line 562
  ent = head___0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! ent) {
#line 562
      goto while_break;
    }
#line 563
    if ((unsigned long )ent->key == (unsigned long )((void *)0)) {
#line 565
      goto __Cont;
    } else
#line 563
    if ((ent->key)->hash != h) {
#line 565
      goto __Cont;
    }
    {
#line 568
    tmp___2 = (*(tab->keycmp))((void const   *)(ent->key)->key_data, (ent->key)->key_datasz,
                               key_data, key_datasz);
    }
#line 568
    if (tmp___2 == 0) {
#line 570
      value_data___0 = ent->value_data;
#line 572
      if (value_datasz) {
#line 573
        *value_datasz = ent->value_datasz;
      }
      {
#line 575
      tab_entry_remove(tab, ent);
#line 576
      tab_entry_free(tab, ent);
#line 577
      tab->cache_ent = (pr_table_entry_t *)((void *)0);
      }
#line 579
      return (value_data___0);
    }
    __Cont: /* CIL Label */ 
#line 562
    ent = ent->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 583
  tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 585
  tmp___3 = __errno_location();
#line 585
  *tmp___3 = 22;
  }
#line 586
  return ((void *)0);
}
}
#line 589 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_kset(pr_table_t *tab , void const   *key_data , size_t key_datasz , void *value_data ,
                  size_t value_datasz ) 
{ 
  unsigned int h ;
  pr_table_entry_t *head___0 ;
  pr_table_entry_t *ent ;
  int *tmp ;
  int *tmp___0 ;
  unsigned int idx ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 596
  if ((unsigned long )tab == (unsigned long )((void *)0)) {
    {
#line 599
    tmp = __errno_location();
#line 599
    *tmp = 22;
    }
#line 600
    return (-1);
  } else
#line 596
  if ((unsigned long )key_data == (unsigned long )((void *)0)) {
    {
#line 599
    tmp = __errno_location();
#line 599
    *tmp = 22;
    }
#line 600
    return (-1);
  } else
#line 596
  if (value_datasz > 0U) {
#line 596
    if ((unsigned long )value_data == (unsigned long )((void *)0)) {
      {
#line 599
      tmp = __errno_location();
#line 599
      *tmp = 22;
      }
#line 600
      return (-1);
    }
  }
#line 603
  if (tab->nents == 0U) {
    {
#line 604
    tmp___0 = __errno_location();
#line 604
    *tmp___0 = 2;
    }
#line 605
    return (-1);
  }
  {
#line 608
  h = (*(tab->keyhash))(key_data, key_datasz);
  }
#line 614
  if (tab->val_iter_ent) {
#line 614
    if ((unsigned long )((tab->val_iter_ent)->key)->key_data == (unsigned long )key_data) {
#line 616
      head___0 = (tab->val_iter_ent)->next;
    } else {
#line 614
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 618
  if (tab->flags & 2UL) {
#line 618
    if (tab->cache_ent) {
#line 618
      if ((unsigned long )((tab->cache_ent)->key)->key_data == (unsigned long )key_data) {
#line 623
        head___0 = (tab->cache_ent)->next;
      } else {
#line 626
        idx = h % tab->nchains;
#line 628
        head___0 = *(tab->chains + idx);
      }
    } else {
#line 626
      idx = h % tab->nchains;
#line 628
      head___0 = *(tab->chains + idx);
    }
  } else {
#line 626
    idx = h % tab->nchains;
#line 628
    head___0 = *(tab->chains + idx);
  }
#line 631
  if (! head___0) {
    {
#line 632
    tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 633
    tab->val_iter_ent = (pr_table_entry_t *)((void *)0);
#line 635
    tmp___1 = __errno_location();
#line 635
    *tmp___1 = 2;
    }
#line 636
    return (-1);
  }
#line 639
  ent = head___0;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! ent) {
#line 639
      goto while_break;
    }
#line 640
    if ((unsigned long )ent->key == (unsigned long )((void *)0)) {
#line 642
      goto __Cont;
    } else
#line 640
    if ((ent->key)->hash != h) {
#line 642
      goto __Cont;
    }
    {
#line 645
    tmp___3 = (*(tab->keycmp))((void const   *)(ent->key)->key_data, (ent->key)->key_datasz,
                               key_data, key_datasz);
    }
#line 645
    if (tmp___3 == 0) {
#line 648
      if ((unsigned long )ent->value_data == (unsigned long )value_data) {
        {
#line 649
        tmp___2 = __errno_location();
#line 649
        *tmp___2 = 17;
        }
#line 650
        return (-1);
      }
#line 653
      ent->value_data = value_data;
#line 654
      ent->value_datasz = value_datasz;
#line 656
      if (tab->flags & 2UL) {
#line 657
        tab->cache_ent = ent;
      }
#line 659
      if (tab->flags & 1UL) {
#line 660
        tab->val_iter_ent = ent;
      }
#line 662
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 639
    ent = ent->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 666
  tab->cache_ent = (pr_table_entry_t *)((void *)0);
#line 667
  tab->val_iter_ent = (pr_table_entry_t *)((void *)0);
#line 669
  tmp___4 = __errno_location();
#line 669
  *tmp___4 = 22;
  }
#line 670
  return (-1);
}
}
#line 673 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_add(pr_table_t *tab , char const   *key_data , void *value_data , size_t value_datasz ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 676
  if ((unsigned long )tab == (unsigned long )((void *)0)) {
    {
#line 678
    tmp = __errno_location();
#line 678
    *tmp = 22;
    }
#line 679
    return (-1);
  } else
#line 676
  if ((unsigned long )key_data == (unsigned long )((void *)0)) {
    {
#line 678
    tmp = __errno_location();
#line 678
    *tmp = 22;
    }
#line 679
    return (-1);
  }
#line 682
  if (value_data) {
#line 682
    if (value_datasz == 0U) {
      {
#line 684
      tmp___0 = strlen((char const   *)((char *)value_data));
#line 684
      value_datasz = tmp___0 + 1U;
      }
    }
  }
  {
#line 686
  tmp___1 = strlen(key_data);
#line 686
  tmp___2 = pr_table_kadd(tab, (void const   *)key_data, tmp___1 + 1U, value_data,
                          value_datasz);
  }
#line 686
  return (tmp___2);
}
}
#line 690 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_add_dup(pr_table_t *tab , char const   *key_data , void *value_data ,
                     size_t value_datasz ) 
{ 
  void *dup_data ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 694
  if (! tab) {
    {
#line 695
    tmp = __errno_location();
#line 695
    *tmp = 22;
    }
#line 696
    return (-1);
  } else
#line 694
  if (! key_data) {
    {
#line 695
    tmp = __errno_location();
#line 695
    *tmp = 22;
    }
#line 696
    return (-1);
  }
#line 699
  if (! value_data) {
#line 699
    if (value_datasz != 0U) {
      {
#line 700
      tmp___0 = __errno_location();
#line 700
      *tmp___0 = 22;
      }
#line 701
      return (-1);
    }
  }
#line 704
  if (value_data) {
#line 704
    if (value_datasz == 0U) {
      {
#line 705
      tmp___1 = strlen((char const   *)((char *)value_data));
#line 705
      value_datasz = tmp___1 + 1U;
      }
    }
  }
  {
#line 707
  dup_data = pcalloc(tab->pool, (int )value_datasz);
#line 708
  memcpy((void */* __restrict  */)dup_data, (void const   */* __restrict  */)value_data,
         value_datasz);
#line 710
  tmp___2 = pr_table_add(tab, key_data, dup_data, value_datasz);
  }
#line 710
  return (tmp___2);
}
}
#line 713 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
pr_table_t *pr_table_nalloc(pool *p , int flags , unsigned int nchains ) 
{ 
  pr_table_t *tab ;
  pool *tab_pool ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 717
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 719
    tmp = __errno_location();
#line 719
    *tmp = 22;
    }
#line 720
    return ((pr_table_t *)((void *)0));
  } else
#line 717
  if (nchains == 0U) {
    {
#line 719
    tmp = __errno_location();
#line 719
    *tmp = 22;
    }
#line 720
    return ((pr_table_t *)((void *)0));
  }
  {
#line 723
  tab_pool = make_sub_pool(p);
#line 724
  pr_pool_tag(tab_pool, "table pool");
#line 726
  tmp___0 = pcalloc(tab_pool, (int )sizeof(pr_table_t ));
#line 726
  tab = (pr_table_t *)tmp___0;
#line 727
  tab->pool = tab_pool;
#line 728
  tab->flags = (unsigned long )flags;
#line 729
  tab->nchains = nchains;
#line 730
  tmp___1 = pcalloc(tab_pool, (int )(sizeof(pr_table_entry_t *) * (unsigned long )tab->nchains));
#line 730
  tab->chains = (pr_table_entry_t **)tmp___1;
#line 733
  tab->keycmp = & key_cmp;
#line 734
  tab->keyhash = & key_hash;
#line 735
  tab->entinsert = & entry_insert;
#line 736
  tab->entremove = & entry_remove;
  }
#line 738
  return (tab);
}
}
#line 741 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
pr_table_t *pr_table_alloc(pool *p , int flags ) 
{ 
  pr_table_t *tmp ;

  {
  {
#line 742
  tmp = pr_table_nalloc(p, flags, 32U);
  }
#line 742
  return (tmp);
}
}
#line 745 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_count(pr_table_t *tab ) 
{ 
  int *tmp ;

  {
#line 746
  if (! tab) {
    {
#line 747
    tmp = __errno_location();
#line 747
    *tmp = 22;
    }
#line 748
    return (-1);
  }
#line 751
  return ((int )tab->nents);
}
}
#line 754 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_do(pr_table_t *tab , int (*cb)(void const   *key_data , size_t key_datasz ,
                                            void *value_data , size_t value_datasz ,
                                            void *user_data ) , void *user_data ,
                int flags ) 
{ 
  register unsigned int i___0 ;
  int *tmp ;
  pr_table_entry_t *ent ;
  int res ;
  int *tmp___0 ;

  {
#line 759
  if (! tab) {
    {
#line 760
    tmp = __errno_location();
#line 760
    *tmp = 22;
    }
#line 761
    return (-1);
  } else
#line 759
  if (! cb) {
    {
#line 760
    tmp = __errno_location();
#line 760
    *tmp = 22;
    }
#line 761
    return (-1);
  }
#line 764
  if (tab->nents == 0U) {
#line 765
    return (0);
  }
#line 767
  i___0 = 0U;
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (i___0 < tab->nchains)) {
#line 767
      goto while_break;
    }
#line 768
    ent = *(tab->chains + i___0);
    {
#line 770
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 770
      if (! ent) {
#line 770
        goto while_break___0;
      }
#line 773
      if (! handling_signal) {
        {
#line 774
        pr_signals_handle();
        }
      }
      {
#line 777
      res = (*cb)((void const   *)(ent->key)->key_data, (ent->key)->key_datasz, ent->value_data,
                  ent->value_datasz, user_data);
      }
#line 779
      if (res < 0) {
#line 779
        if (! (flags & 16)) {
          {
#line 781
          tmp___0 = __errno_location();
#line 781
          *tmp___0 = 1;
          }
#line 782
          return (-1);
        }
      }
#line 785
      ent = ent->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 767
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 789
  return (0);
}
}
#line 792 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_empty(pr_table_t *tab ) 
{ 
  register unsigned int i___0 ;
  int *tmp ;
  pr_table_entry_t *e ;

  {
#line 795
  if (! tab) {
    {
#line 796
    tmp = __errno_location();
#line 796
    *tmp = 22;
    }
#line 797
    return (-1);
  }
#line 800
  if (tab->nents == 0U) {
#line 801
    return (0);
  }
#line 803
  i___0 = 0U;
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 803
    if (! (i___0 < tab->nchains)) {
#line 803
      goto while_break;
    }
#line 804
    e = *(tab->chains + i___0);
    {
#line 806
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 806
      if (! e) {
#line 806
        goto while_break___0;
      }
#line 807
      if (! handling_signal) {
        {
#line 808
        pr_signals_handle();
        }
      }
      {
#line 811
      tab_entry_remove(tab, e);
#line 812
      tab_entry_free(tab, e);
#line 814
      e = *(tab->chains + i___0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 817
    *(tab->chains + i___0) = (pr_table_entry_t *)((void *)0);
#line 803
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  return (0);
}
}
#line 823 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_exists(pr_table_t *tab , char const   *key_data ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 824
  if (! tab) {
    {
#line 825
    tmp = __errno_location();
#line 825
    *tmp = 22;
    }
#line 826
    return (-1);
  } else
#line 824
  if (! key_data) {
    {
#line 825
    tmp = __errno_location();
#line 825
    *tmp = 22;
    }
#line 826
    return (-1);
  }
  {
#line 829
  tmp___0 = strlen(key_data);
#line 829
  tmp___1 = pr_table_kexists(tab, (void const   *)key_data, tmp___0 + 1U);
  }
#line 829
  return (tmp___1);
}
}
#line 832 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_free(pr_table_t *tab ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 834
  if (! tab) {
    {
#line 835
    tmp = __errno_location();
#line 835
    *tmp = 22;
    }
#line 836
    return (-1);
  }
#line 839
  if (tab->nents != 0U) {
    {
#line 840
    tmp___0 = __errno_location();
#line 840
    *tmp___0 = 1;
    }
#line 841
    return (-1);
  }
  {
#line 844
  destroy_pool(tab->pool);
  }
#line 845
  return (0);
}
}
#line 848 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void *pr_table_get(pr_table_t *tab , char const   *key_data , size_t *value_datasz ) 
{ 
  size_t key_datasz ;
  int *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 850
  key_datasz = (size_t )0;
#line 852
  if (! tab) {
    {
#line 853
    tmp = __errno_location();
#line 853
    *tmp = 22;
    }
#line 854
    return ((void *)0);
  }
#line 857
  if (key_data) {
    {
#line 858
    tmp___0 = strlen(key_data);
#line 858
    key_datasz = tmp___0 + 1U;
    }
  }
  {
#line 860
  tmp___1 = pr_table_kget(tab, (void const   *)key_data, key_datasz, value_datasz);
  }
#line 860
  return (tmp___1);
}
}
#line 863 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void *pr_table_next(pr_table_t *tab ) 
{ 
  pr_table_entry_t *ent ;
  pr_table_entry_t *prev ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 866
  if (! tab) {
    {
#line 867
    tmp = __errno_location();
#line 867
    *tmp = 22;
    }
#line 868
    return ((void *)0);
  }
  {
#line 871
  prev = tab->tab_iter_ent;
#line 873
  ent = tab_entry_next(tab);
  }
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! ent) {
#line 874
      goto while_break;
    }
#line 875
    if (! handling_signal) {
      {
#line 876
      pr_signals_handle();
      }
    }
#line 879
    if (prev) {
#line 879
      if ((unsigned long )ent->key == (unsigned long )prev->key) {
        {
#line 881
        ent = tab_entry_next(tab);
        }
#line 882
        goto while_continue;
      }
    }
#line 885
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  if (! ent) {
    {
#line 889
    tmp___0 = __errno_location();
#line 889
    *tmp___0 = 1;
    }
#line 890
    return ((void *)0);
  }
#line 893
  return ((ent->key)->key_data);
}
}
#line 896 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void *pr_table_remove(pr_table_t *tab , char const   *key_data , size_t *value_datasz ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 899
  if (! tab) {
    {
#line 900
    tmp = __errno_location();
#line 900
    *tmp = 22;
    }
#line 901
    return ((void *)0);
  } else
#line 899
  if (! key_data) {
    {
#line 900
    tmp = __errno_location();
#line 900
    *tmp = 22;
    }
#line 901
    return ((void *)0);
  }
  {
#line 904
  tmp___0 = strlen(key_data);
#line 904
  tmp___1 = pr_table_kremove(tab, (void const   *)key_data, tmp___0 + 1U, value_datasz);
  }
#line 904
  return (tmp___1);
}
}
#line 907 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_rewind(pr_table_t *tab ) 
{ 
  int *tmp ;

  {
#line 908
  if (! tab) {
    {
#line 909
    tmp = __errno_location();
#line 909
    *tmp = 22;
    }
#line 910
    return (-1);
  }
#line 913
  tab->tab_iter_ent = (pr_table_entry_t *)((void *)0);
#line 914
  return (0);
}
}
#line 917 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_set(pr_table_t *tab , char const   *key_data , void *value_data , size_t value_datasz ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 920
  if (! tab) {
    {
#line 921
    tmp = __errno_location();
#line 921
    *tmp = 22;
    }
#line 922
    return (-1);
  } else
#line 920
  if (! key_data) {
    {
#line 921
    tmp = __errno_location();
#line 921
    *tmp = 22;
    }
#line 922
    return (-1);
  }
#line 925
  if (value_data) {
#line 925
    if (value_datasz == 0U) {
      {
#line 927
      tmp___0 = strlen((char const   *)((char *)value_data));
#line 927
      value_datasz = tmp___0 + 1U;
      }
    }
  }
  {
#line 929
  tmp___1 = strlen(key_data);
#line 929
  tmp___2 = pr_table_kset(tab, (void const   *)key_data, tmp___1 + 1U, value_data,
                          value_datasz);
  }
#line 929
  return (tmp___2);
}
}
#line 933 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int pr_table_ctl(pr_table_t *tab , int cmd , void *arg ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  unsigned int new_nchains ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 935
  if (! tab) {
    {
#line 936
    tmp = __errno_location();
#line 936
    *tmp = 22;
    }
#line 937
    return (-1);
  }
#line 941
  if (tab->nents != 0U) {
    {
#line 942
    tmp___0 = __errno_location();
#line 942
    *tmp___0 = 1;
    }
#line 943
    return (-1);
  }
  {
#line 947
  if (cmd == 5) {
#line 947
    goto case_5;
  }
#line 953
  if (cmd == 3) {
#line 953
    goto case_3;
  }
#line 962
  if (cmd == 4) {
#line 962
    goto case_4;
  }
#line 968
  if (cmd == 1) {
#line 968
    goto case_1;
  }
#line 974
  if (cmd == 2) {
#line 974
    goto case_2;
  }
#line 980
  if (cmd == 6) {
#line 980
    goto case_6;
  }
#line 1004
  goto switch_default;
  case_5: /* CIL Label */ 
#line 948
  if (arg) {
#line 948
    tab->keyhash = (unsigned int (*)(void const   * , size_t  ))arg;
  } else {
#line 948
    tab->keyhash = & key_hash;
  }
#line 951
  return (0);
  case_3: /* CIL Label */ 
#line 954
  if (! arg) {
    {
#line 955
    tmp___1 = __errno_location();
#line 955
    *tmp___1 = 22;
    }
#line 956
    return (-1);
  }
#line 959
  tab->flags = *((unsigned long *)arg);
#line 960
  return (0);
  case_4: /* CIL Label */ 
#line 963
  if (arg) {
#line 963
    tab->keycmp = (int (*)(void const   * , size_t  , void const   * , size_t  ))arg;
  } else {
#line 963
    tab->keycmp = & key_cmp;
  }
#line 966
  return (0);
  case_1: /* CIL Label */ 
#line 969
  if (arg) {
#line 969
    tab->entinsert = (void (*)(pr_table_entry_t ** , pr_table_entry_t * ))arg;
  } else {
#line 969
    tab->entinsert = & entry_insert;
  }
#line 972
  return (0);
  case_2: /* CIL Label */ 
#line 975
  if (arg) {
#line 975
    tab->entremove = (void (*)(pr_table_entry_t ** , pr_table_entry_t * ))arg;
  } else {
#line 975
    tab->entremove = & entry_remove;
  }
#line 978
  return (0);
  case_6: /* CIL Label */ 
#line 983
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 984
    tmp___2 = __errno_location();
#line 984
    *tmp___2 = 22;
    }
#line 985
    return (-1);
  }
#line 988
  new_nchains = *((unsigned int *)arg);
#line 989
  if (new_nchains == 0U) {
    {
#line 990
    tmp___3 = __errno_location();
#line 990
    *tmp___3 = 22;
    }
#line 991
    return (-1);
  }
  {
#line 994
  tab->nchains = new_nchains;
#line 999
  tmp___4 = pcalloc(tab->pool, (int )(sizeof(pr_table_entry_t *) * (unsigned long )tab->nchains));
#line 999
  tab->chains = (pr_table_entry_t **)tmp___4;
  }
#line 1001
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 1005
  tmp___5 = __errno_location();
#line 1005
  *tmp___5 = 22;
  }
#line 1006
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1009
  tmp___6 = __errno_location();
#line 1009
  *tmp___6 = 13;
  }
#line 1010
  return (-1);
}
}
#line 1013 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void *pr_table_pcalloc(pr_table_t *tab , size_t sz ) 
{ 
  int *tmp ;
  void *tmp___0 ;

  {
#line 1014
  if (! tab) {
    {
#line 1016
    tmp = __errno_location();
#line 1016
    *tmp = 22;
    }
#line 1017
    return ((void *)0);
  } else
#line 1014
  if (sz == 0U) {
    {
#line 1016
    tmp = __errno_location();
#line 1016
    *tmp = 22;
    }
#line 1017
    return ((void *)0);
  }
  {
#line 1020
  tmp___0 = pcalloc(tab->pool, (int )sz);
  }
#line 1020
  return (tmp___0);
}
}
#line 1023 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
void pr_table_dump(void (*dumpf)(char const   *fmt  , ...) , pr_table_t *tab ) 
{ 
  register unsigned int i___0 ;
  register unsigned int j ;
  pr_table_entry_t *ent ;
  unsigned int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1026
  if ((unsigned long )tab == (unsigned long )((void *)0)) {
#line 1028
    return;
  } else
#line 1026
  if ((unsigned long )dumpf == (unsigned long )((void *)0)) {
#line 1028
    return;
  }
#line 1030
  if (tab->flags == 0UL) {
    {
#line 1031
    (*dumpf)("%s", "[table flags]: None");
    }
  } else
#line 1034
  if (tab->flags & 1UL) {
#line 1034
    if (tab->flags & 2UL) {
      {
#line 1036
      (*dumpf)("%s", "[table flags]: MultiValue, UseCache");
      }
    } else {
#line 1034
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1039
    if (tab->flags & 1UL) {
      {
#line 1040
      (*dumpf)("%s", "[table flags]: MultiValue");
      }
    }
#line 1042
    if (tab->flags & 2UL) {
      {
#line 1043
      (*dumpf)("%s", "[table flags]: UseCache");
      }
    }
  }
#line 1047
  if (tab->nents == 0U) {
    {
#line 1048
    (*dumpf)("[empty table]");
    }
#line 1049
    return;
  } else {
    {
#line 1052
    (*dumpf)("[table count]: %u", tab->nents);
    }
  }
#line 1054
  i___0 = 0U;
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! (i___0 < tab->nchains)) {
#line 1054
      goto while_break;
    }
#line 1055
    j = 0U;
#line 1056
    ent = *(tab->chains + i___0);
    {
#line 1058
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1058
      if (! ent) {
#line 1058
        goto while_break___0;
      }
#line 1059
      if (! handling_signal) {
        {
#line 1060
        pr_signals_handle();
        }
      }
      {
#line 1063
      tmp = j;
#line 1063
      j ++;
#line 1063
      (*dumpf)("[chain %u#%u] \'%s\' => \'%s\' (%u)", i___0, tmp, (ent->key)->key_data,
               ent->value_data, ent->value_datasz);
#line 1065
      ent = ent->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1054
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  return;
}
}
#line 1072 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/table.c"
int table_handling_signal(int bool ) 
{ 
  int *tmp ;

  {
#line 1073
  if (bool == 1) {
#line 1075
    handling_signal = bool;
#line 1076
    return (0);
  } else
#line 1073
  if (bool == 0) {
#line 1075
    handling_signal = bool;
#line 1076
    return (0);
  }
  {
#line 1079
  tmp = __errno_location();
#line 1079
  *tmp = 22;
  }
#line 1080
  return (-1);
}
}
#line 40 "../include/str.h"
char *pr_str_strip(pool *p , char *str ) ;
#line 31 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *sreplace(pool *p , char *s  , ...) 
{ 
  va_list args ;
  char *m ;
  char *r ;
  char *src ;
  char *cp ;
  char **mptr ;
  char **rptr ;
  char *marr[33] ;
  char *rarr[33] ;
  char buf___2[4096] ;
  unsigned int tmp ;
  char *pbuf ;
  size_t mlen ;
  size_t rlen ;
  int blen ;
  int dyn ;
  int *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int count ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 33
  src = s;
#line 36
  buf___2[0] = (char )'\000';
#line 36
  tmp = 1U;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (tmp >= 4096U) {
#line 36
      goto while_break;
    }
#line 36
    buf___2[tmp] = (char)0;
#line 36
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  pbuf = (char *)((void *)0);
#line 37
  mlen = (size_t )0;
#line 37
  rlen = (size_t )0;
#line 39
  dyn = 1;
#line 41
  if (! p) {
    {
#line 42
    tmp___0 = __errno_location();
#line 42
    *tmp___0 = 22;
    }
#line 43
    return ((char *)((void *)0));
  } else
#line 41
  if (! s) {
    {
#line 42
    tmp___0 = __errno_location();
#line 42
    *tmp___0 = 22;
    }
#line 43
    return ((char *)((void *)0));
  }
  {
#line 46
  cp = buf___2;
#line 47
  *cp = (char )'\000';
#line 49
  memset((void *)(marr), '\000', (size_t )sizeof(marr));
#line 50
  memset((void *)(rarr), '\000', (size_t )sizeof(rarr));
#line 51
  tmp___1 = strlen((char const   *)src);
#line 51
  blen = (int )(tmp___1 + 1U);
#line 53
  __builtin_va_start(args, s);
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 55
    tmp___8 = __builtin_va_arg(args, char *);
#line 55
    m = tmp___8;
    }
#line 55
    if ((unsigned long )m != (unsigned long )((void *)0)) {
#line 55
      if (! ((unsigned long )mlen < sizeof(marr) - 1UL)) {
#line 55
        goto while_break___0;
      }
    } else {
#line 55
      goto while_break___0;
    }
    {
#line 56
    tmp___2 = (char *)((void *)0);
#line 57
    count = 0;
#line 59
    tmp___3 = __builtin_va_arg(args, char *);
#line 59
    r = tmp___3;
    }
#line 59
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 60
      goto while_break___0;
    }
    {
#line 66
    tmp___2 = strstr((char const   *)s, (char const   *)m);
    }
    {
#line 67
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 67
      if (! tmp___2) {
#line 67
        goto while_break___1;
      }
      {
#line 68
      pr_signals_handle();
#line 69
      count ++;
      }
#line 70
      if (count > 8) {
#line 74
        return (s);
      }
      {
#line 82
      tmp___4 = strlen((char const   *)m);
#line 82
      tmp___2 += tmp___4;
#line 83
      tmp___2 = strstr((char const   *)tmp___2, (char const   *)m);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 89
    if (count) {
      {
#line 90
      tmp___5 = strlen((char const   *)r);
#line 90
      tmp___6 = strlen((char const   *)m);
#line 90
      blen = (int )((size_t )blen + (size_t )count * (tmp___5 - tmp___6));
      }
#line 91
      if (blen < 0) {
#line 98
        return (s);
      }
#line 100
      marr[mlen] = m;
#line 101
      tmp___7 = mlen;
#line 101
      mlen ++;
#line 101
      rarr[tmp___7] = r;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 105
  __builtin_va_end(args);
  }
#line 116
  if (blen < 8192) {
    {
#line 117
    blen ++;
#line 117
    tmp___9 = pcalloc(p, blen);
#line 117
    pbuf = (char *)tmp___9;
#line 117
    cp = pbuf;
    }
  }
#line 119
  if (! pbuf) {
#line 120
    pbuf = buf___2;
#line 120
    cp = pbuf;
#line 121
    dyn = 0;
#line 122
    blen = (int )sizeof(buf___2);
  }
  {
#line 125
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 125
    if (! *src) {
#line 125
      goto while_break___2;
    }
#line 126
    mptr = marr;
#line 126
    rptr = rarr;
    {
#line 126
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 126
      if (! *mptr) {
#line 126
        goto while_break___3;
      }
      {
#line 127
      mlen = strlen((char const   *)*mptr);
#line 128
      rlen = strlen((char const   *)*rptr);
#line 130
      tmp___11 = strncmp((char const   *)src, (char const   *)*mptr, mlen);
      }
#line 130
      if (tmp___11 == 0) {
        {
#line 131
        tmp___10 = strlen((char const   *)pbuf);
#line 131
        sstrncpy(cp, (char const   *)*rptr, (size_t )blen - tmp___10);
        }
#line 133
        if (((cp + rlen) - pbuf) + 1L > (long )blen) {
          {
#line 134
          pr_log_pri(3, "WARNING: attempt to overflow internal ProFTPD buffers");
#line 136
          cp = pbuf;
          }
#line 138
          if (blen >= 8192) {
#line 139
            blen = 8192;
          }
#line 141
          cp += blen - 1;
#line 142
          goto done;
        } else {
#line 145
          cp += rlen;
        }
#line 148
        src += mlen;
#line 149
        goto while_break___3;
      }
#line 126
      mptr ++;
#line 126
      rptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 153
    if (! *mptr) {
#line 154
      if ((cp - pbuf) + 1L >= (long )blen) {
        {
#line 155
        pr_log_pri(3, "WARNING: attempt to overflow internal ProFTPD buffers");
#line 157
        cp = pbuf;
        }
#line 159
        if (blen >= 8192) {
#line 160
          blen = 8192;
        }
#line 162
        cp += blen - 1;
#line 163
        goto done;
      }
#line 166
      tmp___12 = cp;
#line 166
      cp ++;
#line 166
      tmp___13 = src;
#line 166
      src ++;
#line 166
      *tmp___12 = *tmp___13;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  done: 
#line 171
  *cp = (char )'\000';
#line 173
  if (dyn) {
#line 174
    return (pbuf);
  }
  {
#line 176
  tmp___14 = pstrdup(p, (char const   *)(buf___2));
  }
#line 176
  return (tmp___14);
}
}
#line 182 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *sstrcat(char *dst , char const   *src , size_t n ) 
{ 
  register char *d ;
  int *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;

  {
#line 185
  if (! dst) {
    {
#line 186
    tmp = __errno_location();
#line 186
    *tmp = 22;
    }
#line 187
    return ((char *)((void *)0));
  } else
#line 185
  if (! src) {
    {
#line 186
    tmp = __errno_location();
#line 186
    *tmp = 22;
    }
#line 187
    return ((char *)((void *)0));
  } else
#line 185
  if (n == 0U) {
    {
#line 186
    tmp = __errno_location();
#line 186
    *tmp = 22;
    }
#line 187
    return ((char *)((void *)0));
  }
#line 190
  d = dst;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (*d) {
#line 190
      if (! (n > 1U)) {
#line 190
        goto while_break;
      }
    } else {
#line 190
      goto while_break;
    }
#line 190
    d ++;
#line 190
    n --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    tmp___2 = n;
#line 192
    n --;
#line 192
    if (tmp___2 > 1U) {
#line 192
      if (! *src) {
#line 192
        goto while_break___0;
      }
    } else {
#line 192
      goto while_break___0;
    }
#line 193
    tmp___0 = d;
#line 193
    d ++;
#line 193
    tmp___1 = src;
#line 193
    src ++;
#line 193
    *tmp___0 = (char )*tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 195
  *d = (char)0;
#line 196
  return (dst);
}
}
#line 199 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pstrdup(pool *p , char const   *str ) 
{ 
  char *res ;
  size_t len ;
  int *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 203
  if (! p) {
    {
#line 204
    tmp = __errno_location();
#line 204
    *tmp = 22;
    }
#line 205
    return ((char *)((void *)0));
  } else
#line 203
  if (! str) {
    {
#line 204
    tmp = __errno_location();
#line 204
    *tmp = 22;
    }
#line 205
    return ((char *)((void *)0));
  }
  {
#line 208
  tmp___0 = strlen(str);
#line 208
  len = tmp___0 + 1U;
#line 210
  tmp___1 = palloc(p, (int )len);
#line 210
  res = (char *)tmp___1;
#line 211
  sstrncpy(res, str, len);
  }
#line 212
  return (res);
}
}
#line 215 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pstrndup(pool *p , char const   *str , size_t n ) 
{ 
  char *res ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 218
  if (! p) {
    {
#line 219
    tmp = __errno_location();
#line 219
    *tmp = 22;
    }
#line 220
    return ((char *)((void *)0));
  } else
#line 218
  if (! str) {
    {
#line 219
    tmp = __errno_location();
#line 219
    *tmp = 22;
    }
#line 220
    return ((char *)((void *)0));
  }
  {
#line 223
  tmp___0 = palloc(p, (int )(n + 1U));
#line 223
  res = (char *)tmp___0;
#line 224
  sstrncpy(res, str, n + 1U);
  }
#line 225
  return (res);
}
}
#line 228 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pdircat(pool *p  , ...) 
{ 
  char *argp ;
  char *res ;
  char last ;
  int count ;
  size_t len ;
  va_list ap ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp16 ;

  {
#line 232
  count = 0;
#line 233
  len = (size_t )0;
#line 236
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 237
    tmp = __errno_location();
#line 237
    *tmp = 22;
    }
#line 238
    return ((char *)((void *)0));
  }
  {
#line 241
  __builtin_va_start(ap, p);
#line 243
  last = (char)0;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 245
    tmp___3 = __builtin_va_arg(ap, char *);
#line 245
    res = tmp___3;
    }
#line 245
    if (! ((unsigned long )res != (unsigned long )((void *)0))) {
#line 245
      goto while_break;
    }
#line 249
    tmp___0 = count;
#line 249
    count ++;
#line 249
    if (tmp___0) {
      _L___1: /* CIL Label */ 
#line 252
      if (last) {
#line 252
        if ((int )last != 47) {
#line 252
          if ((int )*res != 47) {
#line 253
            len ++;
          } else {
#line 252
            goto _L___0;
          }
        } else {
#line 252
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 255
      if (last) {
#line 255
        if ((int )last == 47) {
#line 255
          if ((int )*res == 47) {
#line 256
            len --;
          }
        }
      }
    } else
#line 249
    if (! *res) {
#line 250
      len ++;
    } else {
#line 249
      goto _L___1;
    }
    {
#line 258
    tmp___1 = strlen((char const   *)res);
#line 258
    len += tmp___1;
    }
#line 259
    if (*res) {
      {
#line 259
      tmp___2 = strlen((char const   *)res);
#line 259
      last = *(res + (tmp___2 - 1U));
      }
    } else {
#line 259
      last = (char)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 262
  __builtin_va_end(ap);
#line 263
  tmp___4 = pcalloc(p, (int )(len + 1U));
#line 263
  res = (char *)tmp___4;
#line 265
  __builtin_va_start(ap, p);
#line 267
  last = (char)0;
  }
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 269
    tmp___6 = __builtin_va_arg(ap, char *);
#line 269
    argp = tmp___6;
    }
#line 269
    if (! ((unsigned long )argp != (unsigned long )((void *)0))) {
#line 269
      goto while_break___0;
    }
#line 270
    if (last) {
#line 270
      if ((int )last == 47) {
#line 270
        if ((int )*argp == 47) {
#line 271
          argp ++;
        } else {
#line 270
          goto _L___3;
        }
      } else {
#line 270
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 273
    if (last) {
#line 273
      if ((int )last != 47) {
#line 273
        if ((int )*argp != 47) {
          {
#line 274
          sstrcat(res, "/", len + 1U);
          }
        }
      }
    }
    {
#line 276
    sstrcat(res, (char const   *)argp, len + 1U);
    }
#line 277
    if (*res) {
      {
#line 277
      tmp___5 = strlen((char const   *)res);
#line 277
      last = *(res + (tmp___5 - 1U));
      }
    } else {
#line 277
      last = (char)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 280
  __builtin_va_end(ap);
  }
#line 282
  return (res);
}
}
#line 285 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pstrcat(pool *p  , ...) 
{ 
  char *argp ;
  char *res ;
  size_t len ;
  va_list ap ;
  int *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 288
  len = (size_t )0;
#line 291
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 292
    tmp = __errno_location();
#line 292
    *tmp = 22;
    }
#line 293
    return ((char *)((void *)0));
  }
  {
#line 296
  __builtin_va_start(ap, p);
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    tmp___1 = __builtin_va_arg(ap, char *);
#line 298
    res = tmp___1;
    }
#line 298
    if (! ((unsigned long )res != (unsigned long )((void *)0))) {
#line 298
      goto while_break;
    }
    {
#line 299
    tmp___0 = strlen((char const   *)res);
#line 299
    len += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  __builtin_va_end(ap);
#line 303
  tmp___2 = pcalloc(p, (int )(len + 1U));
#line 303
  res = (char *)tmp___2;
#line 305
  __builtin_va_start(ap, p);
  }
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 307
    tmp___3 = __builtin_va_arg(ap, char *);
#line 307
    argp = tmp___3;
    }
#line 307
    if (! ((unsigned long )argp != (unsigned long )((void *)0))) {
#line 307
      goto while_break___0;
    }
    {
#line 308
    sstrcat(res, (char const   *)argp, len + 1U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 310
  __builtin_va_end(ap);
  }
#line 312
  return (res);
}
}
#line 315 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pr_str_strip(pool *p , char *str ) 
{ 
  char c ;
  char *dupstr ;
  char *start ;
  char *finish ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 318
  if (! p) {
    {
#line 319
    tmp = __errno_location();
#line 319
    *tmp = 22;
    }
#line 320
    return ((char *)((void *)0));
  } else
#line 318
  if (! str) {
    {
#line 319
    tmp = __errno_location();
#line 319
    *tmp = 22;
    }
#line 320
    return ((char *)((void *)0));
  }
#line 324
  start = str;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    tmp___0 = __ctype_b_loc();
    }
#line 324
    if (! ((int const   )*(*tmp___0 + (int )*start) & 8192)) {
#line 324
      goto while_break;
    }
#line 324
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  tmp___1 = strlen((char const   *)str);
#line 327
  finish = str + (tmp___1 - 1U);
  }
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 327
    tmp___2 = __ctype_b_loc();
    }
#line 327
    if (! ((int const   )*(*tmp___2 + (int )*finish) & 8192)) {
#line 327
      goto while_break___0;
    }
#line 327
    finish --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 332
  finish ++;
#line 332
  c = *finish;
#line 333
  *finish = (char )'\000';
#line 336
  dupstr = pstrdup(p, (char const   *)start);
#line 339
  *finish = c;
  }
#line 341
  return (dupstr);
}
}
#line 344 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pr_str_strip_end(char *s , char *ch ) 
{ 
  size_t len ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 347
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 349
    tmp = __errno_location();
#line 349
    *tmp = 22;
    }
#line 350
    return ((char *)((void *)0));
  } else
#line 347
  if ((unsigned long )ch == (unsigned long )((void *)0)) {
    {
#line 349
    tmp = __errno_location();
#line 349
    *tmp = 22;
    }
#line 350
    return ((char *)((void *)0));
  }
  {
#line 353
  len = strlen((char const   *)s);
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (len) {
      {
#line 355
      tmp___0 = strchr((char const   *)ch, (int )*((s + len) - 1));
      }
#line 355
      if (! tmp___0) {
#line 355
        goto while_break;
      }
    } else {
#line 355
      goto while_break;
    }
    {
#line 356
    pr_signals_handle();
#line 358
    *((s + len) - 1) = (char )'\000';
#line 359
    len --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  return (s);
}
}
#line 365 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pr_str_get_word(char **cp , int flags ) 
{ 
  char *res ;
  char *dst ;
  char quote_mode ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 367
  quote_mode = (char)0;
#line 369
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 372
    tmp = __errno_location();
#line 372
    *tmp = 22;
    }
#line 373
    return ((char *)((void *)0));
  } else
#line 369
  if (! *cp) {
    {
#line 372
    tmp = __errno_location();
#line 372
    *tmp = 22;
    }
#line 373
    return ((char *)((void *)0));
  } else
#line 369
  if (! *(*cp)) {
    {
#line 372
    tmp = __errno_location();
#line 372
    *tmp = 22;
    }
#line 373
    return ((char *)((void *)0));
  }
#line 376
  if (! (flags & 2)) {
    {
#line 377
    while (1) {
      while_continue: /* CIL Label */ ;
#line 377
      if (*(*cp)) {
        {
#line 377
        tmp___0 = __ctype_b_loc();
        }
#line 377
        if (! ((int const   )*(*tmp___0 + (int )*(*cp)) & 8192)) {
#line 377
          goto while_break;
        }
      } else {
#line 377
        goto while_break;
      }
#line 378
      (*cp) ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 381
  if (! *(*cp)) {
#line 382
    return ((char *)((void *)0));
  }
#line 384
  dst = *cp;
#line 384
  res = dst;
#line 386
  if (! (flags & 1)) {
#line 388
    if ((int )*(*cp) == 35) {
#line 389
      return ((char *)((void *)0));
    }
  }
#line 392
  if ((int )*(*cp) == 34) {
#line 393
    quote_mode = (char )((int )quote_mode + 1);
#line 394
    (*cp) ++;
  }
  {
#line 397
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (*(*cp)) {
#line 397
      if (quote_mode) {
#line 397
        tmp___4 = (int )*(*cp) != 34;
      } else {
        {
#line 397
        tmp___2 = __ctype_b_loc();
        }
#line 397
        if ((int const   )*(*tmp___2 + (int )*(*cp)) & 8192) {
#line 397
          tmp___3 = 0;
        } else {
#line 397
          tmp___3 = 1;
        }
#line 397
        tmp___4 = tmp___3;
      }
#line 397
      if (! tmp___4) {
#line 397
        goto while_break___0;
      }
    } else {
#line 397
      goto while_break___0;
    }
#line 398
    if ((int )*(*cp) == 92) {
#line 398
      if (quote_mode) {
#line 401
        if (*(*cp + 1)) {
#line 402
          (*cp) ++;
#line 402
          *dst = *(*cp);
        }
      }
    }
#line 405
    tmp___1 = dst;
#line 405
    dst ++;
#line 405
    *tmp___1 = *(*cp);
#line 406
    (*cp) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 409
  if (*(*cp)) {
#line 410
    (*cp) ++;
  }
#line 411
  *dst = (char )'\000';
#line 413
  return (res);
}
}
#line 420 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
char *pr_str_get_token(char **s , char *sep ) 
{ 
  char *res ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 423
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 427
    tmp = __errno_location();
#line 427
    *tmp = 22;
    }
#line 428
    return ((char *)((void *)0));
  } else
#line 423
  if ((unsigned long )*s == (unsigned long )((void *)0)) {
    {
#line 427
    tmp = __errno_location();
#line 427
    *tmp = 22;
    }
#line 428
    return ((char *)((void *)0));
  } else
#line 423
  if ((int )*(*s) == 0) {
    {
#line 427
    tmp = __errno_location();
#line 427
    *tmp = 22;
    }
#line 428
    return ((char *)((void *)0));
  } else
#line 423
  if ((unsigned long )sep == (unsigned long )((void *)0)) {
    {
#line 427
    tmp = __errno_location();
#line 427
    *tmp = 22;
    }
#line 428
    return ((char *)((void *)0));
  }
#line 431
  res = *s;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (*(*s)) {
      {
#line 433
      tmp___0 = strchr((char const   *)sep, (int )*(*s));
      }
#line 433
      if (tmp___0) {
#line 433
        goto while_break;
      }
    } else {
#line 433
      goto while_break;
    }
#line 434
    (*s) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  if (*(*s)) {
#line 438
    tmp___1 = *s;
#line 438
    (*s) ++;
#line 438
    *tmp___1 = (char )'\000';
  }
#line 440
  return (res);
}
}
#line 443 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/str.c"
int pr_str_is_boolean(char const   *str ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 444
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 445
    tmp = __errno_location();
#line 445
    *tmp = 22;
    }
#line 446
    return (-1);
  }
  {
#line 449
  tmp___0 = strcasecmp(str, "on");
  }
#line 449
  if (tmp___0 == 0) {
#line 450
    return (1);
  }
  {
#line 452
  tmp___1 = strcasecmp(str, "off");
  }
#line 452
  if (tmp___1 == 0) {
#line 453
    return (0);
  }
  {
#line 455
  tmp___2 = strcasecmp(str, "yes");
  }
#line 455
  if (tmp___2 == 0) {
#line 456
    return (1);
  }
  {
#line 458
  tmp___3 = strcasecmp(str, "no");
  }
#line 458
  if (tmp___3 == 0) {
#line 459
    return (0);
  }
  {
#line 461
  tmp___4 = strcasecmp(str, "true");
  }
#line 461
  if (tmp___4 == 0) {
#line 462
    return (1);
  }
  {
#line 464
  tmp___5 = strcasecmp(str, "false");
  }
#line 464
  if (tmp___5 == 0) {
#line 465
    return (0);
  }
  {
#line 467
  tmp___6 = strcasecmp(str, "1");
  }
#line 467
  if (tmp___6 == 0) {
#line 468
    return (1);
  }
  {
#line 470
  tmp___7 = strcasecmp(str, "0");
  }
#line 470
  if (tmp___7 == 0) {
#line 471
    return (0);
  }
  {
#line 473
  tmp___8 = __errno_location();
#line 473
  *tmp___8 = 22;
  }
#line 474
  return (-1);
}
}
#line 40 "../include/pool.h"
void init_pools(void) ;
#line 41
void free_pools(void) ;
#line 50
void *pallocsz(struct pool *p , int sz ) ;
#line 52
void *pcallocsz(struct pool *p , int sz ) ;
#line 70
void clear_array(array_header *arr ) ;
#line 72
void array_cat(array_header *dst , array_header const   *src ) ;
#line 73
array_header *append_arrays(pool *p , array_header const   *first , array_header const   *second ) ;
#line 76
array_header *copy_array_hdr(pool *p , array_header const   *arr ) ;
#line 81
void pr_alarms_block(void) ;
#line 82
void pr_alarms_unblock(void) ;
#line 85
void unregister_cleanup(pool *p , void *data , void (*cleanup_cb)(void * ) ) ;
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
union block_hdr *block_freelist  =    (union block_hdr *)((void *)0);
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static unsigned int stat_malloc  =    0U;
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static unsigned int stat_freehit  =    0U;
#line 71 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void *null_alloc(size_t size ) 
{ 
  void *ret ;
  char *__cil_tmp3 ;

  {
#line 72
  ret = (void *)0;
#line 74
  if (size == 0U) {
    {
#line 75
    ret = malloc(size);
    }
  }
#line 76
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 77
    pr_log_pri(3, "fatal: Memory exhausted");
#line 78
    exit(1);
    }
  }
#line 81
  return (ret);
}
}
#line 84 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void *smalloc(size_t size ) 
{ 
  void *ret ;

  {
  {
#line 87
  ret = malloc(size);
  }
#line 88
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 89
    ret = null_alloc(size);
    }
  }
#line 91
  return (ret);
}
}
#line 97 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static union block_hdr *malloc_block(int size ) 
{ 
  union block_hdr *blok ;
  void *tmp ;

  {
  {
#line 98
  tmp = smalloc((size_t )((unsigned long )size + sizeof(union block_hdr )));
#line 98
  blok = (union block_hdr *)tmp;
#line 101
  blok->h.next = (union block_hdr *)((void *)0);
#line 102
  blok->h.first_avail = (char *)(blok + 1);
#line 103
  blok->h.endp = blok->h.first_avail + size;
  }
#line 105
  return (blok);
}
}
#line 108 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void chk_on_blk_list(union block_hdr *blok , union block_hdr *free_blk , char const   *pool_tag ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! free_blk) {
#line 113
      goto while_break;
    }
#line 114
    if ((unsigned long )free_blk == (unsigned long )blok) {
#line 115
      if (pool_tag) {
#line 115
        tmp = pool_tag;
      } else {
#line 115
        tmp = "<unnamed>";
      }
      {
#line 115
      pr_log_pri(3, "Fatal: DEBUG: Attempt to free already free block in pool \'%s\'",
                 tmp);
#line 117
      exit(1);
      }
    }
#line 120
    free_blk = free_blk->h.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 126 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void free_blocks(union block_hdr *blok , char const   *pool_tag ) 
{ 
  union block_hdr *old_free_list ;

  {
#line 131
  old_free_list = block_freelist;
#line 133
  if (! blok) {
#line 134
    return;
  }
#line 136
  block_freelist = blok;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! blok->h.next) {
#line 140
      goto while_break;
    }
    {
#line 141
    chk_on_blk_list(blok, old_free_list, pool_tag);
#line 142
    blok->h.first_avail = (char *)(blok + 1);
#line 143
    blok = blok->h.next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  chk_on_blk_list(blok, old_free_list, pool_tag);
#line 147
  blok->h.first_avail = (char *)(blok + 1);
#line 148
  blok->h.next = old_free_list;
  }
#line 149
  return;
}
}
#line 160 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static union block_hdr *new_block(int minsz , int exact ) 
{ 
  union block_hdr **lastptr ;
  union block_hdr *blok ;
  union block_hdr *tmp ;

  {
#line 161
  lastptr = & block_freelist;
#line 162
  blok = block_freelist;
#line 164
  if (! exact) {
#line 165
    minsz = 1 + (minsz - 1) / 512;
#line 166
    minsz *= 512;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! blok) {
#line 171
      goto while_break;
    }
#line 172
    if ((long )minsz <= blok->h.endp - blok->h.first_avail) {
#line 173
      *lastptr = blok->h.next;
#line 174
      blok->h.next = (union block_hdr *)((void *)0);
#line 176
      stat_freehit ++;
#line 177
      return (blok);
    } else {
#line 180
      lastptr = & blok->h.next;
#line 181
      blok = blok->h.next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  stat_malloc ++;
#line 187
  tmp = malloc_block(minsz);
  }
#line 187
  return (tmp);
}
}
#line 192
static void run_cleanups(struct cleanup *c ) ;
#line 208 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
pool *permanent_pool  =    (pool *)((void *)0);
#line 209 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
pool *global_config_pool  =    (pool *)((void *)0);
#line 325 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void pr_pool_tag(struct pool *p , char const   *tag ) 
{ 


  {
#line 326
  if (! p) {
#line 327
    return;
  } else
#line 326
  if (! tag) {
#line 327
    return;
  }
#line 329
  p->tag = tag;
#line 330
  return;
}
}
#line 333 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void pool_release_free_block_list(void) 
{ 
  union block_hdr *blok ;
  union block_hdr *next ;

  {
  {
#line 336
  pr_alarms_block();
#line 338
  blok = block_freelist;
  }
#line 339
  if (blok) {
#line 340
    next = blok->h.next;
    {
#line 340
    while (1) {
      while_continue: /* CIL Label */ ;
#line 340
      if (! next) {
#line 340
        goto while_break;
      }
      {
#line 341
      free((void *)blok);
#line 340
      blok = next;
#line 340
      next = blok->h.next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 343
  block_freelist = (union block_hdr *)((void *)0);
#line 345
  pr_alarms_unblock();
  }
#line 346
  return;
}
}
#line 348 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
struct pool *make_sub_pool(struct pool *p ) 
{ 
  union block_hdr *blok ;
  pool *new_pool ;
  union block_hdr *tmp ;

  {
  {
#line 352
  pr_alarms_block();
#line 354
  blok = new_block(0, 0);
#line 356
  new_pool = (pool *)blok->h.first_avail;
#line 357
  blok->h.first_avail += (1UL + (sizeof(struct pool ) - 1UL) / sizeof(union align )) * sizeof(union align );
#line 359
  memset((void *)new_pool, 0, (size_t )sizeof(struct pool ));
#line 360
  new_pool->free_first_avail = blok->h.first_avail;
#line 361
  tmp = blok;
#line 361
  new_pool->last = tmp;
#line 361
  new_pool->first = tmp;
  }
#line 363
  if (p) {
#line 364
    new_pool->parent = p;
#line 365
    new_pool->sub_next = p->sub_pools;
#line 367
    if (new_pool->sub_next) {
#line 368
      (new_pool->sub_next)->sub_prev = new_pool;
    }
#line 370
    p->sub_pools = new_pool;
  }
  {
#line 373
  pr_alarms_unblock();
  }
#line 375
  return (new_pool);
}
}
#line 378 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
struct pool *pr_pool_create_sz(struct pool *p , int sz ) 
{ 
  union block_hdr *blok ;
  pool *new_pool ;
  union block_hdr *tmp ;

  {
  {
#line 382
  pr_alarms_block();
#line 384
  blok = new_block((int )((unsigned long )sz + (1UL + (sizeof(struct pool ) - 1UL) / sizeof(union align )) * sizeof(union align )),
                   1);
#line 386
  new_pool = (pool *)blok->h.first_avail;
#line 387
  blok->h.first_avail += (1UL + (sizeof(struct pool ) - 1UL) / sizeof(union align )) * sizeof(union align );
#line 389
  memset((void *)new_pool, 0, (size_t )sizeof(struct pool ));
#line 390
  new_pool->free_first_avail = blok->h.first_avail;
#line 391
  tmp = blok;
#line 391
  new_pool->last = tmp;
#line 391
  new_pool->first = tmp;
  }
#line 393
  if (p) {
#line 394
    new_pool->parent = p;
#line 395
    new_pool->sub_next = p->sub_pools;
#line 397
    if (new_pool->sub_next) {
#line 398
      (new_pool->sub_next)->sub_prev = new_pool;
    }
#line 400
    p->sub_pools = new_pool;
  }
  {
#line 403
  pr_alarms_unblock();
  }
#line 405
  return (new_pool);
}
}
#line 410 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void init_pools(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 411
  if (! permanent_pool) {
    {
#line 412
    permanent_pool = make_sub_pool((struct pool *)((void *)0));
    }
  }
  {
#line 413
  pr_pool_tag(permanent_pool, "permanent_pool");
  }
#line 414
  return;
}
}
#line 416 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void free_pools(void) 
{ 


  {
  {
#line 417
  destroy_pool(permanent_pool);
#line 418
  permanent_pool = (pool *)((void *)0);
#line 419
  pool_release_free_block_list();
  }
#line 420
  return;
}
}
#line 422 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void clear_pool(struct pool *p ) 
{ 


  {
#line 425
  if (! p) {
#line 426
    return;
  }
  {
#line 428
  pr_alarms_block();
#line 431
  run_cleanups(p->cleanups);
#line 432
  p->cleanups = (struct cleanup *)((void *)0);
  }
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (! p->sub_pools) {
#line 435
      goto while_break;
    }
    {
#line 436
    destroy_pool(p->sub_pools);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 437
  p->sub_pools = (struct pool *)((void *)0);
#line 439
  free_blocks((p->first)->h.next, p->tag);
#line 440
  (p->first)->h.next = (union block_hdr *)((void *)0);
#line 442
  p->last = p->first;
#line 443
  (p->first)->h.first_avail = p->free_first_avail;
#line 445
  pr_alarms_unblock();
  }
#line 446
  return;
}
}
#line 448 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void destroy_pool(struct pool *p ) 
{ 


  {
#line 449
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 450
    return;
  }
  {
#line 452
  pr_alarms_block();
  }
#line 454
  if (p->parent) {
#line 455
    if ((unsigned long )(p->parent)->sub_pools == (unsigned long )p) {
#line 456
      (p->parent)->sub_pools = p->sub_next;
    }
#line 458
    if (p->sub_prev) {
#line 459
      (p->sub_prev)->sub_next = p->sub_next;
    }
#line 461
    if (p->sub_next) {
#line 462
      (p->sub_next)->sub_prev = p->sub_prev;
    }
  }
  {
#line 464
  clear_pool(p);
#line 465
  free_blocks(p->first, p->tag);
#line 467
  pr_alarms_unblock();
  }
#line 468
  return;
}
}
#line 473 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void *alloc_pool(struct pool *p , int reqsz , int exact ) 
{ 
  int nclicks ;
  int sz ;
  union block_hdr *blok ;
  char *first_avail ;
  char *new_first_avail ;

  {
#line 476
  nclicks = (int )(1UL + (unsigned long )(reqsz - 1) / sizeof(union align ));
#line 477
  sz = (int )((unsigned long )nclicks * sizeof(union align ));
#line 483
  blok = p->last;
#line 484
  first_avail = blok->h.first_avail;
#line 487
  if (reqsz <= 0) {
#line 488
    return ((void *)0);
  }
#line 490
  new_first_avail = first_avail + sz;
#line 492
  if ((unsigned long )new_first_avail <= (unsigned long )blok->h.endp) {
#line 493
    blok->h.first_avail = new_first_avail;
#line 494
    return ((void *)first_avail);
  }
  {
#line 498
  pr_alarms_block();
#line 500
  blok = new_block(sz, exact);
#line 501
  (p->last)->h.next = blok;
#line 502
  p->last = blok;
#line 504
  first_avail = blok->h.first_avail;
#line 505
  blok->h.first_avail += sz;
#line 507
  pr_alarms_unblock();
  }
#line 508
  return ((void *)first_avail);
}
}
#line 511 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void *palloc(struct pool *p , int sz ) 
{ 
  void *tmp ;

  {
  {
#line 512
  tmp = alloc_pool(p, sz, 0);
  }
#line 512
  return (tmp);
}
}
#line 515 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void *pallocsz(struct pool *p , int sz ) 
{ 
  void *tmp ;

  {
  {
#line 516
  tmp = alloc_pool(p, sz, 1);
  }
#line 516
  return (tmp);
}
}
#line 519 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void *pcalloc(struct pool *p , int sz ) 
{ 
  void *res ;
  void *tmp ;

  {
  {
#line 520
  tmp = palloc(p, sz);
#line 520
  res = tmp;
#line 521
  memset(res, '\000', (size_t )sz);
  }
#line 522
  return (res);
}
}
#line 525 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void *pcallocsz(struct pool *p , int sz ) 
{ 
  void *res ;
  void *tmp ;

  {
  {
#line 526
  tmp = pallocsz(p, sz);
#line 526
  res = tmp;
#line 527
  memset(res, '\000', (size_t )sz);
  }
#line 528
  return (res);
}
}
#line 535 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
array_header *make_array(pool *p , unsigned int nelts , size_t elt_size ) 
{ 
  array_header *res ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 538
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 540
    tmp = __errno_location();
#line 540
    *tmp = 22;
    }
#line 541
    return ((array_header *)((void *)0));
  } else
#line 538
  if (elt_size == 0U) {
    {
#line 540
    tmp = __errno_location();
#line 540
    *tmp = 22;
    }
#line 541
    return ((array_header *)((void *)0));
  }
  {
#line 544
  tmp___0 = palloc(p, (int )sizeof(array_header ));
#line 544
  res = (array_header *)tmp___0;
  }
#line 546
  if (nelts < 1U) {
#line 547
    nelts = 1U;
  }
  {
#line 549
  res->elts = pcalloc(p, (int )(nelts * elt_size));
#line 550
  res->pool = p;
#line 551
  res->elt_size = (int )elt_size;
#line 552
  res->nelts = 0;
#line 553
  res->nalloc = (int )nelts;
  }
#line 555
  return (res);
}
}
#line 558 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void clear_array(array_header *arr ) 
{ 


  {
#line 559
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
#line 560
    return;
  }
  {
#line 563
  arr->elts = pcalloc(arr->pool, arr->nalloc * arr->elt_size);
#line 564
  arr->nelts = 0;
  }
#line 565
  return;
}
}
#line 567 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void *push_array(array_header *arr ) 
{ 
  int *tmp ;
  char *new_data ;
  void *tmp___0 ;

  {
#line 568
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
    {
#line 569
    tmp = __errno_location();
#line 569
    *tmp = 22;
    }
#line 570
    return ((void *)0);
  }
#line 573
  if (arr->nelts == arr->nalloc) {
    {
#line 574
    tmp___0 = pcalloc(arr->pool, (arr->nalloc * arr->elt_size) * 2);
#line 574
    new_data = (char *)tmp___0;
#line 576
    memcpy((void */* __restrict  */)new_data, (void const   */* __restrict  */)arr->elts,
           (size_t )(arr->nalloc * arr->elt_size));
#line 577
    arr->elts = (void *)new_data;
#line 578
    arr->nalloc *= 2;
    }
  }
#line 581
  (arr->nelts) ++;
#line 582
  return ((void *)((char *)arr->elts + arr->elt_size * (arr->nelts - 1)));
}
}
#line 585 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void array_cat(array_header *dst , array_header const   *src ) 
{ 
  size_t elt_size ;
  int new_size ;
  char *new_data ;
  void *tmp ;

  {
#line 588
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 590
    return;
  } else
#line 588
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 590
    return;
  }
#line 593
  elt_size = (size_t )dst->elt_size;
#line 595
  if (dst->nelts + (int )src->nelts > dst->nalloc) {
#line 596
    new_size = dst->nalloc * 2;
#line 599
    if (new_size == 0) {
#line 600
      new_size ++;
    }
    {
#line 602
    while (1) {
      while_continue: /* CIL Label */ ;
#line 602
      if (! (dst->nelts + (int )src->nelts > new_size)) {
#line 602
        goto while_break;
      }
#line 603
      new_size *= 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 605
    tmp = pcalloc(dst->pool, (int )(elt_size * (size_t )new_size));
#line 605
    new_data = (char *)tmp;
#line 606
    memcpy((void */* __restrict  */)new_data, (void const   */* __restrict  */)dst->elts,
           (size_t )dst->nalloc * elt_size);
#line 608
    dst->elts = (void *)new_data;
#line 609
    dst->nalloc = new_size;
    }
  }
  {
#line 612
  memcpy((void */* __restrict  */)((char *)dst->elts + (size_t )dst->nelts * elt_size),
         (void const   */* __restrict  */)((char *)src->elts), elt_size * (size_t )src->nelts);
#line 614
  dst->nelts += (int )src->nelts;
  }
#line 615
  return;
}
}
#line 617 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
array_header *copy_array(pool *p , array_header const   *arr ) 
{ 
  array_header *res ;
  int *tmp ;

  {
#line 620
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 622
    tmp = __errno_location();
#line 622
    *tmp = 22;
    }
#line 623
    return ((array_header *)((void *)0));
  } else
#line 620
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
    {
#line 622
    tmp = __errno_location();
#line 622
    *tmp = 22;
    }
#line 623
    return ((array_header *)((void *)0));
  }
  {
#line 626
  res = make_array(p, (unsigned int )arr->nalloc, (size_t )arr->elt_size);
#line 628
  memcpy((void */* __restrict  */)res->elts, (void const   */* __restrict  */)arr->elts,
         (size_t )(arr->elt_size * arr->nelts));
#line 629
  res->nelts = (int )arr->nelts;
  }
#line 630
  return (res);
}
}
#line 634 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
array_header *copy_array_str(pool *p , array_header const   *arr ) 
{ 
  register unsigned int i___0 ;
  array_header *res ;
  int *tmp ;

  {
#line 638
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 640
    tmp = __errno_location();
#line 640
    *tmp = 22;
    }
#line 641
    return ((array_header *)((void *)0));
  } else
#line 638
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
    {
#line 640
    tmp = __errno_location();
#line 640
    *tmp = 22;
    }
#line 641
    return ((array_header *)((void *)0));
  }
  {
#line 644
  res = copy_array(p, arr);
#line 646
  i___0 = 0U;
  }
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (! (i___0 < (unsigned int )arr->nelts)) {
#line 646
      goto while_break;
    }
    {
#line 647
    *((char **)res->elts + i___0) = pstrdup(p, (char const   *)*((char **)res->elts + i___0));
#line 646
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return (res);
}
}
#line 652 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
array_header *copy_array_hdr(pool *p , array_header const   *arr ) 
{ 
  array_header *res ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 655
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 657
    tmp = __errno_location();
#line 657
    *tmp = 22;
    }
#line 658
    return ((array_header *)((void *)0));
  } else
#line 655
  if ((unsigned long )arr == (unsigned long )((void *)0)) {
    {
#line 657
    tmp = __errno_location();
#line 657
    *tmp = 22;
    }
#line 658
    return ((array_header *)((void *)0));
  }
  {
#line 661
  tmp___0 = palloc(p, (int )sizeof(array_header ));
#line 661
  res = (array_header *)tmp___0;
#line 663
  res->elts = (void *)arr->elts;
#line 664
  res->pool = p;
#line 665
  res->elt_size = (int )arr->elt_size;
#line 666
  res->nelts = (int )arr->nelts;
#line 667
  res->nalloc = (int )arr->nelts;
  }
#line 669
  return (res);
}
}
#line 672 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
array_header *append_arrays(pool *p , array_header const   *first , array_header const   *second ) 
{ 
  array_header *res ;
  int *tmp ;

  {
#line 676
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 679
    tmp = __errno_location();
#line 679
    *tmp = 22;
    }
#line 680
    return ((array_header *)((void *)0));
  } else
#line 676
  if ((unsigned long )first == (unsigned long )((void *)0)) {
    {
#line 679
    tmp = __errno_location();
#line 679
    *tmp = 22;
    }
#line 680
    return ((array_header *)((void *)0));
  } else
#line 676
  if ((unsigned long )second == (unsigned long )((void *)0)) {
    {
#line 679
    tmp = __errno_location();
#line 679
    *tmp = 22;
    }
#line 680
    return ((array_header *)((void *)0));
  }
  {
#line 683
  res = copy_array_hdr(p, first);
#line 685
  array_cat(res, second);
  }
#line 686
  return (res);
}
}
#line 700 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void register_cleanup(pool *p , void *data , void (*plain_cleanup_cb)(void * ) , void (*child_cleanup_cb)(void * ) ) 
{ 
  cleanup_t *c ;
  void *tmp ;

  {
  {
#line 702
  tmp = pcalloc(p, (int )sizeof(cleanup_t ));
#line 702
  c = (cleanup_t *)tmp;
#line 703
  c->data = data;
#line 704
  c->plain_cleanup_cb = plain_cleanup_cb;
#line 705
  c->child_cleanup_cb = child_cleanup_cb;
#line 708
  c->next = p->cleanups;
#line 709
  p->cleanups = c;
  }
#line 710
  return;
}
}
#line 712 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
void unregister_cleanup(pool *p , void *data , void (*cleanup_cb)(void * ) ) 
{ 
  cleanup_t *c ;
  cleanup_t **lastp ;

  {
#line 713
  c = p->cleanups;
#line 714
  lastp = & p->cleanups;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! c) {
#line 716
      goto while_break;
    }
#line 717
    if ((unsigned long )c->data == (unsigned long )data) {
#line 717
      if ((unsigned long )c->plain_cleanup_cb == (unsigned long )cleanup_cb) {
#line 722
        *lastp = c->next;
#line 723
        goto while_break;
      }
    }
#line 726
    lastp = & c->next;
#line 727
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return;
}
}
#line 731 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/pool.c"
static void run_cleanups(struct cleanup *c ) 
{ 


  {
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! c) {
#line 732
      goto while_break;
    }
    {
#line 733
    (*(c->plain_cleanup_cb))(c->data);
#line 734
    c = c->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return;
}
}
#line 53 "../include/sets.h"
xaset_t *xaset_copy(pool *p , xaset_t *set , size_t msize , xasetmember_t *(*copyfunc)(xasetmember_t *mem ) ) ;
#line 38 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/sets.c"
xaset_t *xaset_create(pool *p , int (*cmpfunc)(xasetmember_t *v1 , xasetmember_t *v2 ) ) 
{ 
  xaset_t *new_set ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 41
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 41
    if ((unsigned long )permanent_pool == (unsigned long )((void *)0)) {
      {
#line 43
      tmp = __errno_location();
#line 43
      *tmp = 1;
      }
#line 44
      return ((xaset_t *)((void *)0));
    }
  }
#line 47
  if (p) {
#line 47
    p = p;
  } else {
#line 47
    p = permanent_pool;
  }
  {
#line 49
  tmp___0 = palloc(p, (int )sizeof(xaset_t ));
#line 49
  new_set = (xaset_t *)tmp___0;
  }
#line 51
  if (! new_set) {
#line 52
    return ((xaset_t *)((void *)0));
  }
#line 54
  new_set->xas_list = (xasetmember_t *)((void *)0);
#line 55
  new_set->pool = p;
#line 56
  new_set->xas_compare = cmpfunc;
#line 58
  return (new_set);
}
}
#line 65 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/sets.c"
int xaset_insert(xaset_t *set , xasetmember_t *member ) 
{ 
  int *tmp ;

  {
#line 67
  if ((unsigned long )set == (unsigned long )((void *)0)) {
    {
#line 69
    tmp = __errno_location();
#line 69
    *tmp = 22;
    }
#line 70
    return (-1);
  } else
#line 67
  if ((unsigned long )member == (unsigned long )((void *)0)) {
    {
#line 69
    tmp = __errno_location();
#line 69
    *tmp = 22;
    }
#line 70
    return (-1);
  }
#line 73
  member->next = set->xas_list;
#line 75
  if (set->xas_list) {
#line 76
    (set->xas_list)->prev = member;
  }
#line 78
  set->xas_list = member;
#line 79
  return (0);
}
}
#line 84 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/sets.c"
int xaset_insert_end(xaset_t *set , xasetmember_t *member ) 
{ 
  xasetmember_t **tmp ;
  xasetmember_t *prev ;
  int *tmp___0 ;

  {
#line 85
  prev = (xasetmember_t *)((void *)0);
#line 87
  if ((unsigned long )set == (unsigned long )((void *)0)) {
    {
#line 89
    tmp___0 = __errno_location();
#line 89
    *tmp___0 = 22;
    }
#line 90
    return (-1);
  } else
#line 87
  if ((unsigned long )member == (unsigned long )((void *)0)) {
    {
#line 89
    tmp___0 = __errno_location();
#line 89
    *tmp___0 = 22;
    }
#line 90
    return (-1);
  }
#line 93
  tmp = & set->xas_list;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! *tmp) {
#line 93
      goto while_break;
    }
#line 93
    prev = *tmp;
#line 93
    tmp = & (*tmp)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  *tmp = member;
#line 97
  member->prev = prev;
#line 98
  member->next = (xasetmember_t *)((void *)0);
#line 100
  if (prev) {
#line 101
    prev->next = member;
  }
#line 103
  return (0);
}
}
#line 112 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/sets.c"
int xaset_insert_sort(xaset_t *set , xasetmember_t *member , int dups_allowed ) 
{ 
  xasetmember_t **setp ;
  xasetmember_t *mprev ;
  int *tmp ;
  int res ;

  {
#line 113
  setp = (xasetmember_t **)((void *)0);
#line 113
  mprev = (xasetmember_t *)((void *)0);
#line 115
  if (! set) {
    {
#line 116
    tmp = __errno_location();
#line 116
    *tmp = 22;
    }
#line 117
    return (-1);
  } else
#line 115
  if (! member) {
    {
#line 116
    tmp = __errno_location();
#line 116
    *tmp = 22;
    }
#line 117
    return (-1);
  } else
#line 115
  if (! set->xas_compare) {
    {
#line 116
    tmp = __errno_location();
#line 116
    *tmp = 22;
    }
#line 117
    return (-1);
  }
#line 120
  setp = & set->xas_list;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! *setp) {
#line 120
      goto while_break;
    }
    {
#line 123
    res = (*(set->xas_compare))(member, *setp);
    }
#line 124
    if (res <= 0) {
#line 125
      if (res == 0) {
#line 125
        if (! dups_allowed) {
#line 127
          return (0);
        }
      }
#line 128
      goto while_break;
    }
#line 131
    mprev = *setp;
#line 120
    setp = & (*setp)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  if (*setp) {
#line 135
    (*setp)->prev = member;
  }
#line 137
  member->prev = mprev;
#line 138
  member->next = *setp;
#line 139
  *setp = member;
#line 141
  return (0);
}
}
#line 148 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/sets.c"
int xaset_remove(xaset_t *set , xasetmember_t *member ) 
{ 
  xasetmember_t *m ;
  int *tmp ;
  int *tmp___0 ;
  xasetmember_t *tmp___1 ;

  {
#line 149
  m = (xasetmember_t *)((void *)0);
#line 151
  if ((unsigned long )set == (unsigned long )((void *)0)) {
    {
#line 153
    tmp = __errno_location();
#line 153
    *tmp = 22;
    }
#line 154
    return (-1);
  } else
#line 151
  if ((unsigned long )member == (unsigned long )((void *)0)) {
    {
#line 153
    tmp = __errno_location();
#line 153
    *tmp = 22;
    }
#line 154
    return (-1);
  }
#line 158
  m = set->xas_list;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! m) {
#line 158
      goto while_break;
    }
#line 159
    if ((unsigned long )m == (unsigned long )member) {
#line 160
      goto while_break;
    }
#line 158
    m = m->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 164
    tmp___0 = __errno_location();
#line 164
    *tmp___0 = 2;
    }
#line 165
    return (-1);
  }
#line 168
  if (member->prev) {
#line 169
    (member->prev)->next = member->next;
  } else {
#line 172
    set->xas_list = member->next;
  }
#line 174
  if (member->next) {
#line 175
    (member->next)->prev = member->prev;
  }
#line 177
  tmp___1 = (xasetmember_t *)((void *)0);
#line 177
  member->prev = tmp___1;
#line 177
  member->next = tmp___1;
#line 178
  return (0);
}
}
#line 186 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/sets.c"
xaset_t *xaset_copy(pool *p , xaset_t *set , size_t msize , xasetmember_t *(*copyfunc)(xasetmember_t *mem ) ) 
{ 
  xaset_t *new_set ;
  xasetmember_t *n ;
  xasetmember_t *m ;
  xasetmember_t **pos ;
  int *tmp ;
  int *tmp___0 ;
  xasetmember_t *tmp___1 ;
  void *tmp___2 ;

  {
#line 190
  if ((unsigned long )set == (unsigned long )((void *)0)) {
    {
#line 191
    tmp = __errno_location();
#line 191
    *tmp = 22;
    }
#line 192
    return ((xaset_t *)((void *)0));
  }
#line 195
  if (! copyfunc) {
#line 195
    if (! msize) {
      {
#line 196
      tmp___0 = __errno_location();
#line 196
      *tmp___0 = 22;
      }
#line 197
      return ((xaset_t *)((void *)0));
    }
  }
#line 200
  if (p) {
#line 200
    p = p;
  } else {
#line 200
    p = set->pool;
  }
  {
#line 202
  new_set = xaset_create(p, set->xas_compare);
  }
#line 203
  if ((unsigned long )new_set == (unsigned long )((void *)0)) {
#line 204
    return ((xaset_t *)((void *)0));
  }
#line 206
  pos = & new_set->xas_list;
#line 210
  m = set->xas_list;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! m) {
#line 210
      goto while_break;
    }
#line 211
    if (copyfunc) {
      {
#line 211
      tmp___1 = (*copyfunc)(m);
#line 211
      n = tmp___1;
      }
    } else {
      {
#line 211
      tmp___2 = palloc(p, (int )msize);
#line 211
      n = (xasetmember_t *)tmp___2;
      }
    }
#line 212
    if (! n) {
#line 213
      return ((xaset_t *)((void *)0));
    }
#line 215
    if (! copyfunc) {
      {
#line 216
      memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)m, msize);
      }
    }
#line 219
    n->prev = *pos;
#line 220
    n->next = (xasetmember_t *)((void *)0);
#line 221
    if (*pos) {
#line 222
      pos = & (*pos)->next;
    }
#line 223
    *pos = n;
#line 210
    m = m->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return (new_set);
}
}
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 257 "/usr/include/signal.h"
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 70 "../include/timers.h"
void handle_alarm(void) ;
#line 71
void timers_init(void) ;
#line 36 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
unsigned int volatile   recvd_signal_flags ;
#line 52 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int _current_timeout  =    0;
#line 53 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int _total_time  =    0;
#line 54 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int _sleep_sem  =    0;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int alarms_blocked  =    0;
#line 55 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int alarm_pending  =    0;
#line 56 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static xaset_t *timers  =    (xaset_t *)((void *)0);
#line 57 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static xaset_t *recycled  =    (xaset_t *)((void *)0);
#line 58 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static xaset_t *free_timers  =    (xaset_t *)((void *)0);
#line 59 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int _indispatch  =    0;
#line 60 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int dynamic_timerno  =    1024;
#line 61 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static unsigned int nalarms  =    0U;
#line 62 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static time_t _alarmed_time  =    (time_t )0;
#line 64 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static pool *timer_pool  =    (pool *)((void *)0);
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int timer_cmp(struct timer *t1 , struct timer *t2 ) 
{ 


  {
#line 67
  if (t1->count < t2->count) {
#line 68
    return (-1);
  }
#line 70
  if (t1->count > t2->count) {
#line 71
    return (1);
  }
#line 73
  return (0);
}
}
#line 81 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int process_timers(int elapsed ) 
{ 
  struct timer *t ;
  struct timer *next ;
  long tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 82
  t = (struct timer *)((void *)0);
#line 82
  next = (struct timer *)((void *)0);
#line 84
  if (! recycled) {
    {
#line 85
    recycled = xaset_create(timer_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
#line 87
  if (! elapsed) {
#line 87
    if (! recycled->xas_list) {
#line 90
      if (! timers) {
#line 91
        return (0);
      }
#line 93
      if (timers->xas_list) {
#line 93
        tmp = ((struct timer *)timers->xas_list)->count;
      } else {
#line 93
        tmp = 0L;
      }
#line 93
      return ((int )tmp);
    }
  }
#line 97
  if (_indispatch) {
#line 98
    return (0);
  }
  {
#line 100
  pr_alarms_block();
#line 101
  _indispatch ++;
  }
#line 103
  if (elapsed) {
#line 104
    t = (struct timer *)timers->xas_list;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! t) {
#line 104
        goto while_break;
      }
#line 106
      next = t->next;
#line 108
      if (t->remove) {
        {
#line 110
        xaset_remove(timers, (xasetmember_t *)t);
#line 111
        xaset_insert(free_timers, (xasetmember_t *)t);
        }
      } else {
#line 113
        tmp___2 = t->count - (long )elapsed;
#line 113
        t->count = tmp___2;
#line 113
        if (tmp___2 <= 0L) {
#line 116
          if (t->mod) {
#line 116
            tmp___0 = (char const   *)(t->mod)->name;
          } else {
#line 116
            tmp___0 = "[none]";
          }
          {
#line 116
          pr_trace_msg("timer", 4, "%ld seconds for timer ID %d (\'%s\', for module \'%s\') elapsed, invoking callback (%p)",
                       t->interval, t->timerno, t->desc, tmp___0, t->callback);
#line 121
          tmp___1 = (*(t->callback))((unsigned long )t->interval, (unsigned long )t->timerno,
                                     (unsigned long )(t->interval - t->count), (void *)t->mod);
          }
#line 121
          if (tmp___1 == 0) {
            {
#line 127
            xaset_remove(timers, (xasetmember_t *)t);
#line 128
            xaset_insert(free_timers, (xasetmember_t *)t);
            }
          } else {
            {
#line 134
            pr_trace_msg("timer", 6, "restarting timer ID %d (\'%s\'), as per callback",
                         t->timerno, t->desc);
#line 137
            xaset_remove(timers, (xasetmember_t *)t);
#line 138
            t->count = t->interval;
#line 139
            xaset_insert(recycled, (xasetmember_t *)t);
            }
          }
        }
      }
#line 104
      t = next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 146
    t = (struct timer *)recycled->xas_list;
#line 146
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 146
      goto while_break___0;
    }
    {
#line 147
    xaset_remove(recycled, (xasetmember_t *)t);
#line 148
    xaset_insert_sort(timers, (xasetmember_t *)t, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 151
  _indispatch --;
#line 152
  pr_alarms_unblock();
  }
#line 157
  if (timers->xas_list) {
#line 157
    tmp___3 = ((struct timer *)timers->xas_list)->count;
  } else {
#line 157
    tmp___3 = 0L;
  }
#line 157
  return ((int )tmp___3);
}
}
#line 160 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static void sig_alarm(int signo ) 
{ 
  struct sigaction act ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 163
  act.__sigaction_handler.sa_handler = & sig_alarm;
#line 164
  sigemptyset(& act.sa_mask);
#line 165
  act.sa_flags = 0;
#line 168
  act.sa_flags |= 536870912;
#line 172
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 175
  siginterrupt(14, 1);
#line 178
  recvd_signal_flags |= (unsigned int volatile   )1024;
#line 179
  nalarms ++;
#line 182
  _total_time += _current_timeout;
  }
#line 183
  if (_current_timeout) {
    {
#line 184
    _alarmed_time = time((time_t *)((void *)0));
#line 185
    alarm((unsigned int )_current_timeout);
    }
  }
#line 187
  return;
}
}
#line 189 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static void set_sig_alarm(void) 
{ 
  struct sigaction act ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 192
  act.__sigaction_handler.sa_handler = & sig_alarm;
#line 193
  sigemptyset(& act.sa_mask);
#line 194
  act.sa_flags = 0;
#line 196
  act.sa_flags |= 536870912;
#line 200
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 203
  siginterrupt(14, 1);
  }
#line 205
  return;
}
}
#line 207 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
void handle_alarm(void) 
{ 
  int new_timeout ;
  int alarm_elapsed ;
  time_t tmp ;

  {
#line 208
  new_timeout = 0;
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! nalarms) {
#line 221
      goto while_break;
    }
#line 222
    nalarms = 0U;
#line 224
    if (! alarms_blocked) {
      {
#line 227
      alarm(0U);
      }
#line 228
      if (_alarmed_time) {
        {
#line 228
        tmp = time((time_t *)((void *)0));
#line 228
        alarm_elapsed = (int )((time_t )((int )tmp) - _alarmed_time);
        }
      } else {
#line 228
        alarm_elapsed = 0;
      }
      {
#line 229
      new_timeout = _total_time + alarm_elapsed;
#line 230
      _total_time = 0;
#line 231
      new_timeout = process_timers(new_timeout);
#line 233
      _alarmed_time = time((time_t *)((void *)0));
#line 234
      _current_timeout = new_timeout;
#line 234
      alarm((unsigned int )_current_timeout);
      }
    } else {
#line 237
      alarm_pending ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 241 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
int pr_timer_reset(int timerno , module *mod ) 
{ 
  struct timer *t ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 242
  t = (struct timer *)((void *)0);
#line 244
  if (! timers) {
    {
#line 245
    tmp = __errno_location();
#line 245
    *tmp = 1;
    }
#line 246
    return (-1);
  }
#line 249
  if (_indispatch) {
    {
#line 250
    tmp___0 = __errno_location();
#line 250
    *tmp___0 = 4;
    }
#line 251
    return (-1);
  }
  {
#line 254
  pr_alarms_block();
  }
#line 256
  if (! recycled) {
    {
#line 257
    recycled = xaset_create(timer_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
#line 259
  t = (struct timer *)timers->xas_list;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! t) {
#line 259
      goto while_break;
    }
#line 260
    if (t->timerno == timerno) {
#line 260
      if ((unsigned long )t->mod == (unsigned long )mod) {
#line 260
        goto _L;
      } else
#line 260
      if ((unsigned long )mod == (unsigned long )((module *)4294967295U)) {
        _L: /* CIL Label */ 
        {
#line 262
        t->count = t->interval;
#line 263
        xaset_remove(timers, (xasetmember_t *)t);
#line 264
        xaset_insert(recycled, (xasetmember_t *)t);
#line 265
        nalarms ++;
#line 271
        handle_alarm();
        }
#line 272
        goto while_break;
      }
    }
#line 259
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  pr_alarms_unblock();
  }
#line 278
  if (t) {
#line 278
    tmp___1 = t->timerno;
  } else {
#line 278
    tmp___1 = 0;
  }
#line 278
  return (tmp___1);
}
}
#line 281 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
int pr_timer_remove(int timerno , module *mod ) 
{ 
  struct timer *t ;
  char const   *tmp ;
  int *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 282
  t = (struct timer *)((void *)0);
#line 285
  if (! timers) {
#line 286
    return (0);
  }
  {
#line 288
  pr_alarms_block();
#line 290
  t = (struct timer *)timers->xas_list;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! t) {
#line 290
      goto while_break;
    }
#line 291
    if (t->timerno == timerno) {
#line 291
      if ((unsigned long )t->mod == (unsigned long )mod) {
#line 291
        goto _L;
      } else
#line 291
      if ((unsigned long )mod == (unsigned long )((module *)4294967295U)) {
        _L: /* CIL Label */ 
#line 293
        if (_indispatch) {
#line 294
          t->remove = (char )((int )t->remove + 1);
        } else {
          {
#line 297
          xaset_remove(timers, (xasetmember_t *)t);
#line 298
          xaset_insert(free_timers, (xasetmember_t *)t);
#line 299
          nalarms ++;
#line 305
          handle_alarm();
          }
        }
#line 307
        goto while_break;
      }
    }
#line 290
    t = t->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  pr_alarms_unblock();
  }
#line 313
  if (t) {
#line 314
    if (t->mod) {
#line 314
      tmp = (char const   *)(t->mod)->name;
    } else {
#line 314
      tmp = "[none]";
    }
    {
#line 314
    pr_trace_msg("timer", 7, "removed timer ID %d (\'%s\', for module \'%s\')", t->timerno,
                 t->desc, tmp);
    }
#line 316
    return (t->timerno);
  }
  {
#line 319
  tmp___0 = __errno_location();
#line 319
  *tmp___0 = 2;
  }
#line 320
  return (-1);
}
}
#line 323 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
int pr_timer_add(int seconds , int timerno , module *mod , int (*cb)(unsigned long p1 ,
                                                                     unsigned long p2 ,
                                                                     unsigned long p3 ,
                                                                     void *data ) ,
                 char const   *desc ) 
{ 
  struct timer *t ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 325
  t = (struct timer *)((void *)0);
#line 327
  if (seconds <= 0) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 22;
    }
#line 331
    return (-1);
  } else
#line 327
  if ((unsigned long )cb == (unsigned long )((void *)0)) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 22;
    }
#line 331
    return (-1);
  } else
#line 327
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 22;
    }
#line 331
    return (-1);
  }
#line 334
  if (! timers) {
    {
#line 335
    timers = xaset_create(timer_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))(& timer_cmp));
    }
  }
#line 338
  if (timerno != -1) {
#line 339
    t = (struct timer *)timers->xas_list;
    {
#line 339
    while (1) {
      while_continue: /* CIL Label */ ;
#line 339
      if (! t) {
#line 339
        goto while_break;
      }
#line 340
      if (t->timerno == timerno) {
        {
#line 341
        tmp___0 = __errno_location();
#line 341
        *tmp___0 = 1;
        }
#line 342
        return (-1);
      }
#line 339
      t = t->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 347
  if (! free_timers) {
    {
#line 348
    free_timers = xaset_create(timer_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
    }
  }
  {
#line 351
  pr_alarms_block();
#line 352
  t = (struct timer *)free_timers->xas_list;
  }
#line 353
  if ((unsigned long )t != (unsigned long )((void *)0)) {
    {
#line 354
    xaset_remove(free_timers, (xasetmember_t *)t);
    }
  } else {
#line 358
    if ((unsigned long )timer_pool == (unsigned long )((void *)0)) {
      {
#line 359
      timer_pool = make_sub_pool(permanent_pool);
#line 360
      pr_pool_tag(timer_pool, "Timer Pool");
      }
    }
    {
#line 364
    tmp___1 = palloc(timer_pool, (int )sizeof(struct timer ));
#line 364
    t = (struct timer *)tmp___1;
    }
  }
#line 367
  if (timerno == -1) {
#line 369
    if (dynamic_timerno < 1024) {
#line 370
      dynamic_timerno = 1024;
    }
#line 371
    tmp___2 = dynamic_timerno;
#line 371
    dynamic_timerno ++;
#line 371
    timerno = tmp___2;
  }
#line 374
  t->timerno = timerno;
#line 375
  tmp___3 = (long )seconds;
#line 375
  t->interval = tmp___3;
#line 375
  t->count = tmp___3;
#line 376
  t->callback = cb;
#line 377
  t->mod = mod;
#line 378
  t->remove = (char)0;
#line 379
  t->desc = desc;
#line 385
  if (_indispatch) {
#line 386
    if (! recycled) {
      {
#line 387
      recycled = xaset_create(timer_pool, (int (*)(xasetmember_t *v1 , xasetmember_t *v2 ))((void *)0));
      }
    }
    {
#line 388
    xaset_insert(recycled, (xasetmember_t *)t);
    }
  } else {
    {
#line 391
    xaset_insert_sort(timers, (xasetmember_t *)t, 1);
#line 392
    nalarms ++;
#line 393
    set_sig_alarm();
#line 399
    handle_alarm();
    }
  }
  {
#line 402
  pr_alarms_unblock();
  }
#line 404
  if (t->mod) {
#line 404
    tmp___4 = (char const   *)(t->mod)->name;
  } else {
#line 404
    tmp___4 = "[none]";
  }
  {
#line 404
  pr_trace_msg("timer", 7, "added timer ID %d (\'%s\', for module \'%s\'), triggering in %ld seconds",
               t->timerno, t->desc, tmp___4, t->interval);
  }
#line 407
  return (timerno);
}
}
#line 416 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
void pr_alarms_block(void) 
{ 


  {
#line 417
  alarms_blocked ++;
#line 418
  return;
}
}
#line 420 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
void pr_alarms_unblock(void) 
{ 


  {
#line 421
  alarms_blocked --;
#line 422
  if (alarms_blocked == 0) {
#line 422
    if (alarm_pending) {
      {
#line 423
      alarm_pending = 0;
#line 424
      nalarms ++;
#line 425
      handle_alarm();
      }
    }
  }
#line 427
  return;
}
}
#line 429 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
static int sleep_cb(unsigned long p1 , unsigned long p2 , unsigned long p3 , void *data ) 
{ 


  {
#line 430
  _sleep_sem ++;
#line 431
  return (0);
}
}
#line 434 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
int pr_timer_sleep(int seconds ) 
{ 
  int timerno ;
  sigset_t oset ;
  int *tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 435
  timerno = 0;
#line 438
  _sleep_sem = 0;
#line 440
  if (alarms_blocked) {
    {
#line 441
    tmp = __errno_location();
#line 441
    *tmp = 1;
    }
#line 442
    return (-1);
  } else
#line 440
  if (_indispatch) {
    {
#line 441
    tmp = __errno_location();
#line 441
    *tmp = 1;
    }
#line 442
    return (-1);
  }
  {
#line 445
  timerno = pr_timer_add(seconds, -1, (module *)((void *)0), & sleep_cb, "sleep");
  }
#line 446
  if (timerno == -1) {
#line 447
    return (-1);
  }
  {
#line 449
  sigemptyset(& oset);
  }
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (! _sleep_sem)) {
#line 450
      goto while_break;
    }
    {
#line 451
    sigsuspend((sigset_t const   *)(& oset));
#line 452
    handle_alarm();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (0);
}
}
#line 458 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/timers.c"
void timers_init(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 461
  _current_timeout = 0;
#line 462
  _total_time = 0;
#line 463
  nalarms = 0U;
#line 464
  _alarmed_time = (time_t )0;
#line 467
  timers = (xaset_t *)((void *)0);
#line 468
  recycled = (xaset_t *)((void *)0);
#line 469
  free_timers = (xaset_t *)((void *)0);
#line 472
  if (timer_pool) {
    {
#line 473
    destroy_pool(timer_pool);
    }
  }
  {
#line 475
  timer_pool = make_sub_pool(permanent_pool);
#line 476
  pr_pool_tag(timer_pool, "Timer Pool");
  }
#line 478
  return;
}
}
#line 382 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 815
extern void perror(char const   *__s ) ;
#line 827
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 548
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 600
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 78
extern int opterr ;
#line 82
extern int optopt ;
#line 74 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits )  __asm__("setrlimit64")  ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 190 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 286
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 182 "../include/proftpd.h"
uid_t daemon_uid  ;
#line 183 "../include/proftpd.h"
gid_t daemon_gid  ;
#line 184 "../include/proftpd.h"
array_header *daemon_gids  ;
#line 192 "../include/proftpd.h"
session_t___0 session  ;
#line 253
void set_daemon_rlimits(void) ;
#line 254
void set_session_rlimits(void) ;
#line 73 "../include/support.h"
int set_protocol_name(char const   *name ) ;
#line 189 "../include/modules.h"
int (*cmd_auth_chk)(cmd_rec * )  ;
#line 199
int pr_cmd_dispatch_phase(cmd_rec *cmd , int phase , int send_response ) ;
#line 159 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 63 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void (*cmd_handler)(server_rec * , conn_t * )  ;
#line 66 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
unsigned char persistent_passwd  =    (unsigned char)1;
#line 76 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
unsigned long max_connects  =    0UL;
#line 77 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
unsigned int max_connect_interval  =    1U;
#line 82 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
unsigned char is_master  =    (unsigned char)1;
#line 84 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
pid_t mpid  =    0;
#line 90 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static time_t shut  =    (time_t )0;
#line 90 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static time_t deny  =    (time_t )0;
#line 90 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static time_t disc  =    (time_t )0;
#line 91 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static char shutmsg[81]  = {      (char )'\000'};
#line 93 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static unsigned char have_dead_child  =    (unsigned char)0;
#line 95 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static char sbuf[1024]  = {      (char )'\000'};
#line 105 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int nodaemon  =    0;
#line 106 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int quiet  =    0;
#line 107 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int shutdownp  =    0;
#line 108 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int syntax_check  =    0;
#line 110 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static char const   *protocol_name  =    "FTP";
#line 111 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static char const   *protocol_name_lc  =    "ftp";
#line 114
static void cmd_loop(server_rec *server , conn_t *c ) ;
#line 117
static void sig_disconnect(int signo ) ;
#line 118
static void sig_evnt(int signo ) ;
#line 119
static void sig_terminate(int signo ) ;
#line 124 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
unsigned int volatile   recvd_signal_flags  =    (unsigned int volatile   )0;
#line 127 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int term_signo  =    0;
#line 130
static void handle_abort(void) ;
#line 131
static void handle_chld(void) ;
#line 132
static void handle_evnt(void) ;
#line 136
static void handle_xcpu(void) ;
#line 137
static void handle_terminate(void) ;
#line 138
static void handle_terminate_other(void) ;
#line 139
static void finish_terminate(void) ;
#line 141
static cmd_rec *make_ftp_cmd(pool *p , char *buf___2 , int flags ) ;
#line 143 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static char const   *config_filename  =    "/usr/local/etc/proftpd.conf";
#line 146 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int semaphore_fds(fd_set *rfd , int maxfd ) 
{ 
  pr_child_t *ch ;
  unsigned long tmp ;

  {
  {
#line 148
  tmp = child_count();
  }
#line 148
  if (tmp) {
    {
#line 151
    ch = child_get((pr_child_t *)((void *)0));
    }
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! ch) {
#line 151
        goto while_break;
      }
#line 152
      if (ch->ch_pipefd != -1) {
#line 153
        rfd->fds_bits[(unsigned long )ch->ch_pipefd / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )ch->ch_pipefd % (8UL * sizeof(__fd_mask ));
#line 154
        if (ch->ch_pipefd > maxfd) {
#line 155
          maxfd = ch->ch_pipefd;
        }
      }
      {
#line 151
      ch = child_get(ch);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 160
  return (maxfd);
}
}
#line 163 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void session_set_idle(void) 
{ 
  time_t tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 164
  tmp = time((time_t *)((void *)0));
#line 164
  pr_scoreboard_entry_update(session.pid, 13, tmp, 6, "%s", "idle", (void *)0, (void *)0);
#line 168
  pr_scoreboard_entry_update(session.pid, 7, "%s", "", (void *)0, (void *)0);
#line 171
  pr_proctitle_set("%s - %s: IDLE", session.user, session.proc_prefix);
  }
#line 172
  return;
}
}
#line 174 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void set_auth_check(int (*chk)(cmd_rec * ) ) 
{ 


  {
#line 175
  cmd_auth_chk = chk;
#line 176
  return;
}
}
#line 178 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void pr_cmd_set_handler(void (*handler)(server_rec * , conn_t * ) ) 
{ 


  {
#line 179
  if ((unsigned long )handler == (unsigned long )((void *)0)) {
#line 180
    cmd_handler = & cmd_loop;
  } else {
#line 183
    cmd_handler = handler;
  }
#line 185
  return;
}
}
#line 187 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void end_login_noexit(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  __pid_t tmp___7 ;
  pid_t tmp___8 ;
  pr_netaddr_t *tmp___9 ;
  char const   *tmp___10 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 190
  if ((int )ServerType == 1) {
#line 195
    if (! is_master) {
      {
#line 195
      tmp___1 = pr_scoreboard_entry_del((unsigned char)1);
      }
#line 195
      if (tmp___1 < 0) {
        {
#line 195
        tmp___2 = __errno_location();
        }
#line 195
        if (*tmp___2 != 22) {
          {
#line 198
          tmp = __errno_location();
#line 198
          tmp___0 = strerror(*tmp);
#line 198
          pr_log_debug(1, "error deleting scoreboard entry: %s", tmp___0);
          }
        }
      }
    }
  } else
#line 201
  if ((int )ServerType == 0) {
    {
#line 203
    tmp___5 = pr_scoreboard_entry_del((unsigned char)1);
    }
#line 203
    if (tmp___5 < 0) {
      {
#line 203
      tmp___6 = __errno_location();
      }
#line 203
      if (*tmp___6 != 22) {
        {
#line 205
        tmp___3 = __errno_location();
#line 205
        tmp___4 = strerror(*tmp___3);
#line 205
        pr_log_debug(1, "error deleting scoreboard entry: %s", tmp___4);
        }
      }
    }
  }
#line 210
  if (session.user) {
#line 215
    if (session.pid) {
#line 215
      tmp___8 = session.pid;
    } else {
      {
#line 215
      tmp___7 = getpid();
#line 215
      tmp___8 = tmp___7;
      }
    }
    {
#line 215
    snprintf((char */* __restrict  */)(sbuf), (size_t )sizeof(sbuf), (char const   */* __restrict  */)"%s%d",
             protocol_name_lc, tmp___8);
#line 218
    sbuf[sizeof(sbuf) - 1UL] = (char )'\000';
    }
#line 220
    if (session.wtmp_log) {
      {
#line 221
      tmp___9 = pr_netaddr_get_sess_remote_addr();
#line 221
      tmp___10 = pr_netaddr_get_sess_remote_name();
#line 221
      log_wtmp(sbuf, "", tmp___10, tmp___9);
      }
    }
  }
#line 228
  if (session.d) {
    {
#line 229
    pr_inet_close(session.pool, session.d);
#line 230
    session.d = (struct conn_struc *)((void *)0);
    }
  }
#line 233
  if (session.c) {
    {
#line 234
    pr_inet_close(session.pool, session.c);
#line 235
    session.c = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 239
  pr_event_generate("core.exit", (void const   *)((void *)0));
  }
#line 241
  if (! is_master) {
    {
#line 243
    pr_log_pri(6, "%s session closed.", protocol_name);
    }
  } else
#line 241
  if ((int )ServerType == 0) {
#line 241
    if (! syntax_check) {
      {
#line 243
      pr_log_pri(6, "%s session closed.", protocol_name);
      }
    }
  }
  {
#line 246
  log_closesyslog();
  }
#line 247
  return;
}
}
#line 252 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void end_login(int exitcode ) 
{ 


  {
  {
#line 253
  end_login_noexit();
#line 265
  _exit(exitcode);
  }
}
}
#line 268 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void session_exit(int pri , void *lv , int exitval , void *dummy ) 
{ 
  char *msg ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 269
  msg = (char *)lv;
#line 271
  pr_log_pri(pri, "%s", msg);
  }
#line 273
  if ((int )ServerType == 1) {
#line 273
    if (is_master) {
      {
#line 275
      pr_log_pri(5, "ProFTPD 1.3.2 standalone mode SHUTDOWN");
#line 278
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   278);
#line 278
      pr_signals_block();
      }
#line 278
      if (! session.disable_id_switching) {
        {
#line 278
        tmp___1 = seteuid((__uid_t )0);
        }
#line 278
        if (tmp___1) {
          {
#line 278
          tmp = __errno_location();
#line 278
          tmp___0 = strerror(*tmp);
#line 278
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
          }
        }
        {
#line 278
        tmp___4 = setegid((__gid_t )0);
        }
#line 278
        if (tmp___4) {
          {
#line 278
          tmp___2 = __errno_location();
#line 278
          tmp___3 = strerror(*tmp___2);
#line 278
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
          }
        }
      } else {
        {
#line 278
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 278
      pr_signals_unblock();
#line 279
      pr_delete_scoreboard();
      }
#line 280
      if (! nodaemon) {
        {
#line 281
        pr_pidfile_remove();
        }
      }
      {
#line 282
      pr_signals_block();
      }
#line 282
      if (! session.disable_id_switching) {
        {
#line 282
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     282);
#line 282
        tmp___8 = geteuid();
        }
#line 282
        if (tmp___8 != 0U) {
          {
#line 282
          tmp___7 = seteuid((__uid_t )0);
          }
#line 282
          if (tmp___7) {
            {
#line 282
            tmp___5 = __errno_location();
#line 282
            tmp___6 = strerror(*tmp___5);
#line 282
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___6);
            }
          }
        }
        {
#line 282
        tmp___11 = setegid(session.gid);
        }
#line 282
        if (tmp___11) {
          {
#line 282
          tmp___9 = __errno_location();
#line 282
          tmp___10 = strerror(*tmp___9);
#line 282
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
          }
        }
        {
#line 282
        tmp___14 = seteuid(session.uid);
        }
#line 282
        if (tmp___14) {
          {
#line 282
          tmp___12 = __errno_location();
#line 282
          tmp___13 = strerror(*tmp___12);
#line 282
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
          }
        }
      } else {
        {
#line 282
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 282
      pr_signals_unblock();
      }
    }
  }
  {
#line 285
  end_login(exitval);
  }
#line 286
  return;
}
}
#line 288 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void shutdown_exit(void *d1 , void *d2 , void *d3 , void *d4 ) 
{ 
  char *user ;
  time_t now ;
  char *msg ;
  char const   *serveraddress ;
  config_rec *c ;
  unsigned char *authenticated ;
  void *tmp ;
  char const   *tmp___0 ;
  pr_netaddr_t *masq_addr ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 289
  tmp___12 = check_shutmsg(& shut, & deny, & disc, shutmsg, (size_t )sizeof(shutmsg));
  }
#line 289
  if (tmp___12 == 1) {
    {
#line 294
    c = (config_rec *)((void *)0);
#line 295
    tmp = get_param_ptr(main_server->conf, "authenticated", 0);
#line 295
    authenticated = (unsigned char *)tmp;
    }
#line 298
    if (session.c) {
#line 298
      if ((session.c)->local_addr) {
        {
#line 298
        tmp___0 = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 298
        serveraddress = tmp___0;
        }
      } else {
#line 298
        serveraddress = main_server->ServerAddress;
      }
    } else {
#line 298
      serveraddress = main_server->ServerAddress;
    }
    {
#line 302
    c = find_config(main_server->conf, 1 << 15, "MasqueradeAddress", 0);
    }
#line 302
    if ((unsigned long )c != (unsigned long )((void *)0)) {
      {
#line 305
      masq_addr = (pr_netaddr_t *)*(c->argv + 0);
#line 306
      serveraddress = pr_netaddr_get_ipstr(masq_addr);
      }
    }
    {
#line 309
    time(& now);
    }
#line 310
    if (authenticated) {
#line 310
      if ((int )*authenticated == 1) {
        {
#line 311
        tmp___1 = get_param_ptr(main_server->conf, "USER", 0);
#line 311
        user = (char *)tmp___1;
        }
      } else {
#line 313
        user = (char *)"NONE";
      }
    } else {
#line 313
      user = (char *)"NONE";
    }
    {
#line 315
    tmp___2 = pr_strtime(now);
#line 315
    tmp___3 = pstrdup(permanent_pool, tmp___2);
    }
#line 315
    if (session.c) {
#line 315
      if ((session.c)->remote_name) {
#line 315
        tmp___4 = (session.c)->remote_name;
      } else {
#line 315
        tmp___4 = "(unknown)";
      }
    } else {
#line 315
      tmp___4 = "(unknown)";
    }
#line 315
    if (session.cwd[0]) {
#line 315
      tmp___5 = (char const   *)(session.cwd);
    } else {
#line 315
      tmp___5 = "(none)";
    }
    {
#line 315
    tmp___6 = pr_strtime(disc);
#line 315
    tmp___7 = pstrdup(permanent_pool, tmp___6);
#line 315
    tmp___8 = pr_strtime(deny);
#line 315
    tmp___9 = pstrdup(permanent_pool, tmp___8);
#line 315
    tmp___10 = pr_strtime(shut);
#line 315
    tmp___11 = pstrdup(permanent_pool, tmp___10);
#line 315
    msg = sreplace(permanent_pool, shutmsg, "%s", tmp___11, "%r", tmp___9, "%d", tmp___7,
                   "%C", tmp___5, "%L", serveraddress, "%R", tmp___4, "%T", tmp___3,
                   "%U", user, "%V", main_server->ServerName, (void *)0);
#line 328
    pr_response_send_async("421", "FTP server shutting down - %s", msg);
#line 329
    session_exit(5, (void *)msg, 0, (void *)0);
    }
  }
  {
#line 332
  signal(10, & sig_disconnect);
  }
#line 333
  return;
}
}
#line 335 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int get_command_class(char const   *name ) 
{ 
  int idx ;
  cmdtable *c ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 336
  idx = -1;
#line 337
  tmp = pr_stash_get_symbol((pr_stash_type_t )2, name, (void *)0, & idx);
#line 337
  c = (cmdtable *)tmp;
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (c) {
#line 339
      if (! ((int )c->cmd_type != 2)) {
#line 339
        goto while_break;
      }
    } else {
#line 339
      goto while_break;
    }
    {
#line 340
    pr_signals_handle();
#line 341
    tmp___0 = pr_stash_get_symbol((pr_stash_type_t )2, name, (void *)c, & idx);
#line 341
    c = (cmdtable *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if (c) {
#line 347
    tmp___1 = c->class;
  } else {
#line 347
    tmp___1 = (((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6);
  }
#line 347
  return (tmp___1);
}
}
#line 356
static int _dispatch(cmd_rec *cmd , int cmd_type , int validate , char *match ) ;
#line 356 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int match_index_cache  =    -1;
#line 357 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static char *last_match  =    (char *)((void *)0);
#line 350 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int _dispatch(cmd_rec *cmd , int cmd_type , int validate , char *match ) 
{ 
  char *cmdargstr ;
  cmdtable *c ;
  modret_t *mr ;
  int success ;
  int send_error ;
  int *index_cache ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *args ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  char *method ;
  register unsigned int i___0 ;
  char *tmp___29 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 351
  cmdargstr = (char *)((void *)0);
#line 354
  success = 0;
#line 355
  send_error = 0;
#line 360
  if (cmd_type == 1) {
#line 360
    tmp = 1;
  } else
#line 360
  if (cmd_type == 2) {
#line 360
    tmp = 1;
  } else
#line 360
  if (cmd_type == 4) {
#line 360
    tmp = 1;
  } else {
#line 360
    tmp = 0;
  }
#line 360
  send_error = tmp;
#line 363
  if (! match) {
#line 364
    match = *(cmd->argv + 0);
#line 365
    index_cache = & cmd->stash_index;
  } else {
#line 368
    if ((unsigned long )last_match != (unsigned long )match) {
#line 369
      match_index_cache = -1;
#line 370
      last_match = match;
    }
#line 373
    index_cache = & match_index_cache;
  }
  {
#line 376
  tmp___0 = pr_stash_get_symbol((pr_stash_type_t )2, (char const   *)match, (void *)0,
                                index_cache);
#line 376
  c = (cmdtable *)tmp___0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (c) {
#line 378
      if (! (! success)) {
#line 378
        goto while_break;
      }
    } else {
#line 378
      goto while_break;
    }
    {
#line 379
    pr_signals_handle();
#line 381
    session.curr_cmd = *(cmd->argv + 0);
#line 382
    session.curr_phase = cmd_type;
    }
#line 384
    if ((int )c->cmd_type == cmd_type) {
#line 385
      if (c->group) {
        {
#line 386
        cmd->group = pstrdup(cmd->pool, (char const   *)c->group);
        }
      }
#line 388
      if (c->requires_auth) {
#line 388
        if (cmd_auth_chk) {
          {
#line 388
          tmp___1 = (*cmd_auth_chk)(cmd);
          }
#line 388
          if (! tmp___1) {
#line 389
            return (-1);
          }
        }
      }
      {
#line 391
      cmd->tmp_pool = make_sub_pool(cmd->pool);
#line 393
      cmdargstr = make_arg_str(cmd->tmp_pool, cmd->argc, cmd->argv);
      }
#line 395
      if (cmd_type == 2) {
#line 398
        if (session.user) {
          {
#line 399
          tmp___2 = strchr((char const   *)cmdargstr, ' ');
#line 399
          args = tmp___2;
#line 401
          pr_scoreboard_entry_update(session.pid, 6, "%s", *(cmd->argv + 0), (void *)0,
                                     (void *)0);
          }
#line 403
          if (args) {
#line 403
            tmp___3 = (char const   *)(args + 1);
          } else {
#line 403
            tmp___3 = "";
          }
          {
#line 403
          pr_scoreboard_entry_update(session.pid, 7, "%s", tmp___3, (void *)0, (void *)0);
#line 406
          pr_proctitle_set("%s - %s: %s", session.user, session.proc_prefix, cmdargstr);
          }
        } else {
#line 411
          if ((session.c)->remote_port) {
#line 411
            tmp___4 = (session.c)->remote_port;
          } else {
#line 411
            tmp___4 = 0;
          }
#line 411
          if ((session.c)->remote_addr) {
            {
#line 411
            tmp___5 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 411
            tmp___6 = tmp___5;
            }
          } else {
#line 411
            tmp___6 = "?";
          }
          {
#line 411
          pr_proctitle_set("%s:%d: %s", tmp___6, tmp___4, cmdargstr);
          }
        }
      }
#line 417
      if (cmd_type == 1) {
#line 417
        tmp___12 = "PRE_CMD";
      } else {
#line 417
        if (cmd_type == 2) {
#line 417
          tmp___11 = "CMD";
        } else {
#line 417
          if (cmd_type == 3) {
#line 417
            tmp___10 = "POST_CMD";
          } else {
#line 417
            if (cmd_type == 4) {
#line 417
              tmp___9 = "POST_CMD_ERR";
            } else {
#line 417
              if (cmd_type == 5) {
#line 417
                tmp___8 = "LOG_CMD";
              } else {
#line 417
                if (cmd_type == 6) {
#line 417
                  tmp___7 = "LOG_CMD_ERR";
                } else {
#line 417
                  tmp___7 = "(unknown)";
                }
#line 417
                tmp___8 = tmp___7;
              }
#line 417
              tmp___9 = tmp___8;
            }
#line 417
            tmp___10 = tmp___9;
          }
#line 417
          tmp___11 = tmp___10;
        }
#line 417
        tmp___12 = tmp___11;
      }
      {
#line 417
      pr_log_debug(4, "dispatching %s command \'%s\' to mod_%s", tmp___12, cmdargstr,
                   (c->m)->name);
      }
#line 427
      if (cmd_type == 1) {
#line 427
        tmp___18 = "PRE_CMD";
      } else {
#line 427
        if (cmd_type == 2) {
#line 427
          tmp___17 = "CMD";
        } else {
#line 427
          if (cmd_type == 3) {
#line 427
            tmp___16 = "POST_CMD";
          } else {
#line 427
            if (cmd_type == 4) {
#line 427
              tmp___15 = "POST_CMD_ERR";
            } else {
#line 427
              if (cmd_type == 5) {
#line 427
                tmp___14 = "LOG_CMD";
              } else {
#line 427
                if (cmd_type == 6) {
#line 427
                  tmp___13 = "LOG_CMD_ERR";
                } else {
#line 427
                  tmp___13 = "(unknown)";
                }
#line 427
                tmp___14 = tmp___13;
              }
#line 427
              tmp___15 = tmp___14;
            }
#line 427
            tmp___16 = tmp___15;
          }
#line 427
          tmp___17 = tmp___16;
        }
#line 427
        tmp___18 = tmp___17;
      }
      {
#line 427
      pr_trace_msg("command", 7, "dispatching %s command \'%s\' to mod_%s.c", tmp___18,
                   cmdargstr, (c->m)->name);
#line 437
      cmd->class |= c->class;
      }
#line 444
      if (! c->group) {
        {
#line 445
        kludge_disable_umask();
        }
      } else {
        {
#line 444
        tmp___19 = strcmp((char const   *)c->group, "WRITE");
        }
#line 444
        if (tmp___19 != 0) {
          {
#line 445
          kludge_disable_umask();
          }
        }
      }
      {
#line 446
      mr = pr_module_call(c->m, c->handler, cmd);
#line 447
      kludge_enable_umask();
      }
#line 449
      if (mr) {
#line 449
        if (! mr->mr_error) {
#line 450
          success = 1;
        } else {
#line 449
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 452
      if (mr) {
#line 452
        if (mr->mr_error) {
#line 453
          if (cmd_type == 3) {
#line 453
            goto _L___0;
          } else
#line 453
          if (cmd_type == 5) {
#line 453
            goto _L___0;
          } else
#line 453
          if (cmd_type == 6) {
            _L___0: /* CIL Label */ 
#line 456
            if (mr) {
#line 456
              tmp___21 = mr->mr_message;
            } else {
#line 456
              tmp___21 = (char *)((void *)0);
            }
#line 456
            if (tmp___21) {
#line 457
              if (mr) {
#line 457
                tmp___20 = mr->mr_message;
              } else {
#line 457
                tmp___20 = (char *)((void *)0);
              }
              {
#line 457
              pr_log_pri(5, "%s", tmp___20);
              }
            }
          } else
#line 459
          if (send_error) {
#line 460
            if (mr) {
#line 460
              tmp___26 = mr->mr_numeric;
            } else {
#line 460
              tmp___26 = (char *)((void *)0);
            }
#line 460
            if (tmp___26) {
#line 460
              if (mr) {
#line 460
                tmp___27 = mr->mr_message;
              } else {
#line 460
                tmp___27 = (char *)((void *)0);
              }
#line 460
              if (tmp___27) {
#line 462
                if (mr) {
#line 462
                  tmp___22 = mr->mr_message;
                } else {
#line 462
                  tmp___22 = (char *)((void *)0);
                }
#line 462
                if (mr) {
#line 462
                  tmp___23 = mr->mr_numeric;
                } else {
#line 462
                  tmp___23 = (char *)((void *)0);
                }
                {
#line 462
                pr_response_add_err((char const   *)tmp___23, "%s", tmp___22);
                }
              } else {
#line 460
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 464
              if (mr) {
#line 464
                tmp___25 = mr->mr_message;
              } else {
#line 464
                tmp___25 = (char *)((void *)0);
              }
#line 464
              if (tmp___25) {
#line 465
                if (mr) {
#line 465
                  tmp___24 = mr->mr_message;
                } else {
#line 465
                  tmp___24 = (char *)((void *)0);
                }
                {
#line 465
                pr_response_send_raw("%s", tmp___24);
                }
              }
            }
          }
#line 469
          success = -1;
        }
      }
#line 472
      if (session.user) {
#line 472
        if (! (session.sf_flags & (int volatile   )4)) {
#line 472
          if (cmd_type == 2) {
            {
#line 475
            session_set_idle();
            }
          }
        }
      }
      {
#line 478
      destroy_pool(cmd->tmp_pool);
      }
    }
#line 481
    if (! success) {
      {
#line 482
      tmp___28 = pr_stash_get_symbol((pr_stash_type_t )2, (char const   *)match, (void *)c,
                                     index_cache);
#line 482
      c = (cmdtable *)tmp___28;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (! c) {
#line 486
    if (! success) {
#line 486
      if (validate) {
        {
#line 492
        tmp___29 = strchr((char const   *)*(cmd->argv + 0), '_');
        }
#line 492
        if ((unsigned long )tmp___29 == (unsigned long )((void *)0)) {
#line 493
          method = *(cmd->argv + 0);
        } else {
          {
#line 498
          method = pstrdup(cmd->pool, (char const   *)*(cmd->argv + 0));
#line 499
          i___0 = 0U;
          }
          {
#line 499
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 499
            if (! *(method + i___0)) {
#line 499
              goto while_break___0;
            }
#line 500
            if ((int )*(method + i___0) == 95) {
#line 501
              *(method + i___0) = (char )' ';
            }
#line 499
            i___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 505
        pr_response_add_err("500", "%s not understood", method);
#line 506
        success = -1;
        }
      }
    }
  }
#line 509
  return (success);
}
}
#line 515 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static long get_max_cmd_len(size_t buflen ) 
{ 
  long res ;
  int *bufsz ;
  size_t default_cmd_bufsz ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 517
  bufsz = (int *)((void *)0);
#line 524
  default_cmd_bufsz = (size_t )512;
#line 525
  if (default_cmd_bufsz > buflen) {
#line 526
    default_cmd_bufsz = buflen;
  }
  {
#line 529
  tmp = get_param_ptr(main_server->conf, "CommandBufferSize", 0);
#line 529
  bufsz = (int *)tmp;
  }
#line 530
  if ((unsigned long )bufsz == (unsigned long )((void *)0)) {
#line 531
    res = (long )default_cmd_bufsz;
  } else
#line 533
  if (*bufsz <= 0) {
    {
#line 534
    pr_log_pri(4, "invalid CommandBufferSize size (%d) given, using default buffer size (%lu) instead",
               *bufsz, (unsigned long )default_cmd_bufsz);
#line 537
    res = (long )default_cmd_bufsz;
    }
  } else
#line 539
  if ((size_t )(*bufsz + 1) > buflen) {
    {
#line 540
    pr_log_pri(4, "invalid CommandBufferSize size (%d) given, using default buffer size (%lu) instead",
               *bufsz, (unsigned long )default_cmd_bufsz);
#line 543
    res = (long )default_cmd_bufsz;
    }
  } else {
    {
#line 546
    pr_log_debug(1, "setting CommandBufferSize to %d", *bufsz);
#line 547
    res = (long )*bufsz;
    }
  }
#line 550
  return (res);
}
}
#line 553 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
int set_protocol_name(char const   *name ) 
{ 
  register unsigned int i___0 ;
  size_t namelen ;
  char *lc ;
  int *tmp ;
  int tmp___0 ;

  {
#line 558
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 559
    tmp = __errno_location();
#line 559
    *tmp = 22;
    }
#line 560
    return (-1);
  }
  {
#line 563
  protocol_name = name;
#line 568
  namelen = strlen(name);
#line 569
  lc = pstrdup(permanent_pool, name);
#line 571
  i___0 = 0U;
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i___0 < namelen)) {
#line 571
      goto while_break;
    }
    {
#line 572
    tmp___0 = tolower((int )*(lc + i___0));
#line 572
    *(lc + i___0) = (char )tmp___0;
#line 571
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  protocol_name_lc = (char const   *)lc;
#line 577
  return (0);
}
}
#line 581 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static long cmd_bufsz  =    -1L;
#line 580 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
int pr_cmd_read(cmd_rec **res ) 
{ 
  char buf___2[1024] ;
  unsigned int tmp ;
  char *cp ;
  size_t buflen ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int flags ;
  cmd_rec *cmd ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 582
  buf___2[0] = (char )'\000';
#line 582
  tmp = 1U;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (tmp >= 1024U) {
#line 582
      goto while_break;
    }
#line 582
    buf___2[tmp] = (char)0;
#line 582
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 587
    tmp___0 = __errno_location();
#line 587
    *tmp___0 = 22;
    }
#line 588
    return (-1);
  }
  {
#line 591
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 592
    pr_signals_handle();
#line 594
    memset((void *)(buf___2), '\000', (size_t )sizeof(buf___2));
#line 596
    tmp___2 = pr_netio_telnet_gets(buf___2, (size_t )(sizeof(buf___2) - 1UL), (session.c)->instrm,
                                   (session.c)->outstrm);
    }
#line 596
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 599
      tmp___1 = __errno_location();
      }
#line 599
      if (*tmp___1 == 7) {
#line 603
        goto while_continue___0;
      }
#line 606
      if (((session.c)->instrm)->strm_errno == 0) {
        {
#line 607
        pr_trace_msg("command", 6, "client sent EOF, closing control connection");
        }
      }
#line 611
      return (-1);
    }
#line 614
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 617
  if (cmd_bufsz == -1L) {
    {
#line 618
    cmd_bufsz = get_max_cmd_len((size_t )sizeof(buf___2));
    }
  }
  {
#line 620
  buf___2[cmd_bufsz - 1L] = (char )'\000';
#line 621
  buflen = strlen((char const   *)(buf___2));
  }
#line 623
  if (buflen) {
#line 623
    if ((int )buf___2[buflen - 1U] == 10) {
#line 623
      goto _L;
    } else
#line 623
    if ((int )buf___2[buflen - 1U] == 13) {
      _L: /* CIL Label */ 
#line 625
      buf___2[buflen - 1U] = (char )'\000';
#line 626
      buflen --;
#line 628
      if (buflen) {
#line 628
        if ((int )buf___2[buflen - 1U] == 10) {
#line 630
          buf___2[buflen - 1U] = (char )'\000';
        } else
#line 628
        if ((int )buf___2[buflen - 1U] == 13) {
#line 630
          buf___2[buflen - 1U] = (char )'\000';
        }
      }
    }
  }
#line 633
  cp = buf___2;
#line 634
  if ((int )*cp == 13) {
#line 635
    cp ++;
  }
#line 637
  if (*cp) {
    {
#line 638
    flags = 0;
#line 647
    tmp___3 = strncasecmp((char const   *)cp, "SITE", (size_t )4);
    }
#line 647
    if (tmp___3 == 0) {
#line 648
      flags |= 2;
    }
    {
#line 650
    cmd = make_ftp_cmd(session.pool, cp, flags);
    }
#line 652
    if (cmd) {
#line 653
      *res = cmd;
    }
  }
#line 657
  return (0);
}
}
#line 660 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
int pr_cmd_dispatch_phase(cmd_rec *cmd , int phase , int send_response ) 
{ 
  char *cp ;
  int success ;
  pool *resp_pool___0 ;
  int tmp ;
  int *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 661
  cp = (char *)((void *)0);
#line 662
  success = 0;
#line 663
  resp_pool___0 = (pool *)((void *)0);
#line 665
  cmd->server = main_server;
#line 666
  resp_err_list = (pr_response_t *)((void *)0);
#line 666
  resp_list = resp_err_list;
#line 677
  resp_pool___0 = pr_response_get_pool();
#line 680
  pr_response_set_pool(cmd->pool);
#line 682
  cp = *(cmd->argv + 0);
  }
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! *cp) {
#line 682
      goto while_break;
    }
    {
#line 683
    tmp = toupper((int )*cp);
#line 683
    *cp = (char )tmp;
#line 682
    cp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (! cmd->class) {
    {
#line 686
    cmd->class = get_command_class((char const   *)*(cmd->argv + 0));
    }
  }
#line 688
  if (phase == 0) {
    {
#line 691
    success = _dispatch(cmd, 1, 0, (char *)"*");
    }
#line 693
    if (! success) {
      {
#line 694
      success = _dispatch(cmd, 1, 0, (char *)((void *)0));
      }
    }
#line 696
    if (success < 0) {
      {
#line 700
      _dispatch(cmd, 4, 0, (char *)"*");
#line 701
      _dispatch(cmd, 4, 0, (char *)((void *)0));
#line 703
      _dispatch(cmd, 6, 0, (char *)"*");
#line 704
      _dispatch(cmd, 6, 0, (char *)((void *)0));
#line 706
      pr_response_flush(& resp_err_list);
      }
#line 707
      return (success);
    }
    {
#line 710
    success = _dispatch(cmd, 2, 0, (char *)"*");
    }
#line 712
    if (! success) {
      {
#line 713
      success = _dispatch(cmd, 2, 1, (char *)((void *)0));
      }
    }
#line 715
    if (success == 1) {
      {
#line 716
      success = _dispatch(cmd, 3, 0, (char *)"*");
      }
#line 717
      if (! success) {
        {
#line 718
        success = _dispatch(cmd, 3, 0, (char *)((void *)0));
        }
      }
      {
#line 720
      _dispatch(cmd, 5, 0, (char *)"*");
#line 721
      _dispatch(cmd, 5, 0, (char *)((void *)0));
#line 723
      pr_response_flush(& resp_list);
      }
    } else
#line 725
    if (success < 0) {
      {
#line 729
      success = _dispatch(cmd, 4, 0, (char *)"*");
      }
#line 730
      if (! success) {
        {
#line 731
        success = _dispatch(cmd, 4, 0, (char *)((void *)0));
        }
      }
      {
#line 733
      _dispatch(cmd, 6, 0, (char *)"*");
#line 734
      _dispatch(cmd, 6, 0, (char *)((void *)0));
#line 736
      pr_response_flush(& resp_err_list);
      }
    }
  } else {
    {
#line 743
    if (phase == 4) {
#line 743
      goto case_4;
    }
#line 743
    if (phase == 3) {
#line 743
      goto case_4;
    }
#line 743
    if (phase == 1) {
#line 743
      goto case_4;
    }
#line 749
    if (phase == 2) {
#line 749
      goto case_2;
    }
#line 756
    if (phase == 6) {
#line 756
      goto case_6;
    }
#line 756
    if (phase == 5) {
#line 756
      goto case_6;
    }
#line 761
    goto switch_default;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 744
    success = _dispatch(cmd, phase, 0, (char *)"*");
    }
#line 745
    if (! success) {
      {
#line 746
      success = _dispatch(cmd, phase, 0, (char *)((void *)0));
      }
    }
#line 747
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 750
    success = _dispatch(cmd, phase, 0, (char *)"*");
    }
#line 751
    if (! success) {
      {
#line 752
      success = _dispatch(cmd, phase, 1, (char *)((void *)0));
      }
    }
#line 753
    goto switch_break;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 757
    _dispatch(cmd, phase, 0, (char *)"*");
#line 758
    _dispatch(cmd, phase, 0, (char *)((void *)0));
    }
#line 759
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 762
    tmp___0 = __errno_location();
#line 762
    *tmp___0 = 22;
    }
#line 763
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 766
    if (send_response) {
#line 767
      if (success == 1) {
        {
#line 768
        pr_response_flush(& resp_list);
        }
      } else
#line 770
      if (success < 0) {
        {
#line 771
        pr_response_flush(& resp_err_list);
        }
      }
    }
  }
  {
#line 777
  pr_response_set_pool(resp_pool___0);
  }
#line 779
  return (success);
}
}
#line 782 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
int pr_cmd_dispatch(cmd_rec *cmd ) 
{ 
  int tmp ;

  {
  {
#line 783
  tmp = pr_cmd_dispatch_phase(cmd, 0, 1);
  }
#line 783
  return (tmp);
}
}
#line 786 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static cmd_rec *make_ftp_cmd(pool *p , char *buf___2 , int flags ) 
{ 
  char *cp ;
  char *wrd ;
  cmd_rec *cmd ;
  pool *subpool ;
  array_header *tarr ;
  int str_flags ;
  unsigned short const   **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 787
  cp = buf___2;
#line 791
  str_flags = 1 | flags;
#line 796
  tmp = __ctype_b_loc();
  }
#line 796
  if ((int const   )*(*tmp + (int )*(buf___2 + 0)) & 8192) {
#line 797
    return ((cmd_rec *)((void *)0));
  }
  {
#line 800
  wrd = pr_str_get_word(& cp, str_flags);
  }
#line 801
  if ((unsigned long )wrd == (unsigned long )((void *)0)) {
#line 802
    return ((cmd_rec *)((void *)0));
  }
  {
#line 804
  subpool = make_sub_pool(p);
#line 805
  tmp___0 = pcalloc(subpool, (int )sizeof(cmd_rec ));
#line 805
  cmd = (cmd_rec *)tmp___0;
#line 806
  cmd->pool = subpool;
#line 807
  cmd->tmp_pool = (pool *)((void *)0);
#line 808
  cmd->stash_index = -1;
#line 810
  tarr = make_array(cmd->pool, 2U, (size_t )sizeof(char *));
#line 812
  tmp___1 = push_array(tarr);
#line 812
  *((char **)tmp___1) = pstrdup(cmd->pool, (char const   *)wrd);
#line 813
  (cmd->argc) ++;
#line 814
  cmd->arg = pstrdup(cmd->pool, (char const   *)cp);
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 816
    wrd = pr_str_get_word(& cp, str_flags);
    }
#line 816
    if (! ((unsigned long )wrd != (unsigned long )((void *)0))) {
#line 816
      goto while_break;
    }
    {
#line 817
    tmp___2 = push_array(tarr);
#line 817
    *((char **)tmp___2) = pstrdup(cmd->pool, (char const   *)wrd);
#line 818
    (cmd->argc) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 821
  tmp___3 = push_array(tarr);
#line 821
  *((char **)tmp___3) = (char *)((void *)0);
#line 822
  cmd->argv = (char **)tarr->elts;
#line 827
  cmd->notes = pr_table_nalloc(cmd->pool, 0, 8U);
  }
#line 828
  return (cmd);
}
}
#line 831 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void send_session_banner(server_rec *server ) 
{ 
  config_rec *c ;
  char *display ;
  char const   *serveraddress ;
  config_rec *masq ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  pr_netaddr_t *masq_addr ;
  unsigned char *defer_welcome ;
  void *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 832
  c = (config_rec *)((void *)0);
#line 833
  display = (char *)((void *)0);
#line 834
  serveraddress = (char const   *)((void *)0);
#line 835
  masq = (config_rec *)((void *)0);
#line 837
  tmp = get_param_ptr(server->conf, "DisplayConnect", 0);
#line 837
  display = (char *)tmp;
  }
#line 838
  if ((unsigned long )display != (unsigned long )((void *)0)) {
    {
#line 839
    tmp___2 = pr_display_file((char const   *)display, (char const   *)((void *)0),
                              "220");
    }
#line 839
    if (tmp___2 < 0) {
      {
#line 840
      tmp___0 = __errno_location();
#line 840
      tmp___1 = strerror(*tmp___0);
#line 840
      pr_log_debug(6, "unable to display DisplayConnect file \'%s\': %s", display,
                   tmp___1);
      }
    }
  }
  {
#line 844
  serveraddress = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 846
  masq = find_config(server->conf, 1 << 15, "MasqueradeAddress", 0);
  }
#line 847
  if ((unsigned long )masq != (unsigned long )((void *)0)) {
    {
#line 848
    masq_addr = (pr_netaddr_t *)*(masq->argv + 0);
#line 849
    serveraddress = pr_netaddr_get_ipstr(masq_addr);
    }
  }
  {
#line 852
  c = find_config(server->conf, 1 << 15, "ServerIdent", 0);
  }
#line 852
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 852
    goto _L___0;
  } else
#line 852
  if ((int )*((unsigned char *)*(c->argv + 0)) == 0) {
    _L___0: /* CIL Label */ 
    {
#line 854
    tmp___3 = get_param_ptr(main_server->conf, "DeferWelcome", 0);
#line 854
    defer_welcome = (unsigned char *)tmp___3;
    }
#line 857
    if (c) {
#line 857
      if (c->argc > 1) {
        {
#line 859
        pr_response_send("220", "%s", (char *)*(c->argv + 1));
        }
      } else {
#line 857
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 861
    if (defer_welcome) {
#line 861
      if ((int )*defer_welcome == 1) {
        {
#line 863
        pr_response_send("220", "ProFTPD 1.3.2 Server ready.");
        }
      } else {
        {
#line 867
        pr_response_send("220", "ProFTPD 1.3.2 Server (%s) [%s]", server->ServerName,
                         serveraddress);
        }
      }
    } else {
      {
#line 867
      pr_response_send("220", "ProFTPD 1.3.2 Server (%s) [%s]", server->ServerName,
                       serveraddress);
      }
    }
  } else {
    {
#line 872
    pr_response_send("220", "%s FTP server ready", serveraddress);
    }
  }
#line 874
  return;
}
}
#line 876 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void cmd_loop(server_rec *server , conn_t *c ) 
{ 
  int res ;
  cmd_rec *cmd ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 879
  pr_inet_set_async(session.pool, session.c);
  }
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 882
    res = 0;
#line 883
    cmd = (cmd_rec *)((void *)0);
#line 885
    pr_signals_handle();
#line 887
    res = pr_cmd_read(& cmd);
    }
#line 888
    if (res < 0) {
#line 889
      if (((session.c)->instrm)->strm_errno == 4) {
#line 891
        goto while_continue;
      }
      {
#line 895
      end_login(0);
      }
    }
    {
#line 902
    tmp = pr_data_get_timeout(1);
    }
#line 902
    if (tmp > 0) {
      {
#line 903
      pr_timer_reset(2, (module *)4294967295U);
      }
    }
#line 906
    if (cmd) {
      {
#line 907
      pr_cmd_dispatch(cmd);
#line 908
      destroy_pool(cmd->pool);
      }
    } else {
      {
#line 911
      pr_response_send("500", "Invalid command: try being more creative");
      }
    }
    {
#line 915
    pr_inet_clear();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 919 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void core_restart_cb(void *d1 , void *d2 , void *d3 , void *d4 ) 
{ 
  int maxfd ;
  fd_set childfds ;
  unsigned int __i ;
  fd_set *__arr ;
  int i___0 ;
  pr_child_t *ch ;
  unsigned int __i___0 ;
  fd_set *__arr___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  __uid_t tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
#line 920
  if (is_master) {
#line 920
    if (mpid) {
      {
#line 924
      pr_log_pri(5, "received SIGHUP -- master server reparsing configuration file");
      }
      {
#line 928
      while (1) {
        while_continue: /* CIL Label */ ;
#line 928
        __arr = & childfds;
#line 928
        __i = 0U;
        {
#line 928
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 928
          if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 928
            goto while_break___0;
          }
#line 928
          __arr->fds_bits[__i] = (__fd_mask )0;
#line 928
          __i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 928
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 929
      maxfd = -1;
#line 931
      maxfd = semaphore_fds(& childfds, maxfd);
      }
#line 932
      if (maxfd > -1) {
        {
#line 933
        pr_log_pri(5, "waiting for child processes to complete initialization");
        }
        {
#line 936
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 936
          if (! (maxfd != -1)) {
#line 936
            goto while_break___1;
          }
          {
#line 939
          i___0 = select(maxfd + 1, (fd_set */* __restrict  */)(& childfds), (fd_set */* __restrict  */)((void *)0),
                         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
          }
#line 941
          if (i___0 > 0) {
            {
#line 944
            ch = child_get((pr_child_t *)((void *)0));
            }
            {
#line 944
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 944
              if (! ch) {
#line 944
                goto while_break___2;
              }
#line 945
              if (ch->ch_pipefd != -1) {
#line 945
                if ((childfds.fds_bits[(unsigned long )ch->ch_pipefd / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )ch->ch_pipefd % (8UL * sizeof(__fd_mask )))) != 0L) {
                  {
#line 947
                  close(ch->ch_pipefd);
#line 948
                  ch->ch_pipefd = -1;
                  }
                }
              }
              {
#line 944
              ch = child_get(ch);
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
          {
#line 953
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 953
            __arr___0 = & childfds;
#line 953
            __i___0 = 0U;
            {
#line 953
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 953
              if (! ((unsigned long )__i___0 < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 953
                goto while_break___4;
              }
#line 953
              __arr___0->fds_bits[__i___0] = (__fd_mask )0;
#line 953
              __i___0 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 953
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 954
          maxfd = -1;
#line 955
          maxfd = semaphore_fds(& childfds, maxfd);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 959
      free_bindings();
#line 962
      pr_event_generate("core.restart", (void const   *)((void *)0));
#line 964
      init_log();
#line 965
      init_netaddr();
#line 966
      init_class();
#line 967
      init_config();
#line 973
      pr_netaddr_clear_cache();
#line 975
      pr_parser_prepare((pool *)((void *)0), (xaset_t **)((void *)0));
#line 977
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   977);
#line 977
      pr_signals_block();
      }
#line 977
      if (! session.disable_id_switching) {
        {
#line 977
        tmp___1 = seteuid((__uid_t )0);
        }
#line 977
        if (tmp___1) {
          {
#line 977
          tmp = __errno_location();
#line 977
          tmp___0 = strerror(*tmp);
#line 977
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
          }
        }
        {
#line 977
        tmp___4 = setegid((__gid_t )0);
        }
#line 977
        if (tmp___4) {
          {
#line 977
          tmp___2 = __errno_location();
#line 977
          tmp___3 = strerror(*tmp___2);
#line 977
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
          }
        }
      } else {
        {
#line 977
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 977
      pr_signals_unblock();
#line 978
      tmp___17 = pr_parser_parse_file((pool *)((void *)0), config_filename, (config_rec *)((void *)0),
                                      0);
      }
#line 978
      if (tmp___17 == -1) {
        {
#line 979
        pr_signals_block();
        }
#line 979
        if (! session.disable_id_switching) {
          {
#line 979
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       979);
#line 979
          tmp___8 = geteuid();
          }
#line 979
          if (tmp___8 != 0U) {
            {
#line 979
            tmp___7 = seteuid((__uid_t )0);
            }
#line 979
            if (tmp___7) {
              {
#line 979
              tmp___5 = __errno_location();
#line 979
              tmp___6 = strerror(*tmp___5);
#line 979
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___6);
              }
            }
          }
          {
#line 979
          tmp___11 = setegid(session.gid);
          }
#line 979
          if (tmp___11) {
            {
#line 979
            tmp___9 = __errno_location();
#line 979
            tmp___10 = strerror(*tmp___9);
#line 979
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___10);
            }
          }
          {
#line 979
          tmp___14 = seteuid(session.uid);
          }
#line 979
          if (tmp___14) {
            {
#line 979
            tmp___12 = __errno_location();
#line 979
            tmp___13 = strerror(*tmp___12);
#line 979
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___13);
            }
          }
        } else {
          {
#line 979
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 979
        pr_signals_unblock();
#line 980
        tmp___15 = __errno_location();
#line 980
        tmp___16 = strerror(*tmp___15);
#line 980
        pr_log_pri(3, "Fatal: unable to read configuration file \'%s\': %s", config_filename,
                   tmp___16);
#line 983
        end_login(1);
        }
      }
      {
#line 985
      pr_signals_block();
      }
#line 985
      if (! session.disable_id_switching) {
        {
#line 985
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     985);
#line 985
        tmp___21 = geteuid();
        }
#line 985
        if (tmp___21 != 0U) {
          {
#line 985
          tmp___20 = seteuid((__uid_t )0);
          }
#line 985
          if (tmp___20) {
            {
#line 985
            tmp___18 = __errno_location();
#line 985
            tmp___19 = strerror(*tmp___18);
#line 985
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___19);
            }
          }
        }
        {
#line 985
        tmp___24 = setegid(session.gid);
        }
#line 985
        if (tmp___24) {
          {
#line 985
          tmp___22 = __errno_location();
#line 985
          tmp___23 = strerror(*tmp___22);
#line 985
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___23);
          }
        }
        {
#line 985
        tmp___27 = seteuid(session.uid);
        }
#line 985
        if (tmp___27) {
          {
#line 985
          tmp___25 = __errno_location();
#line 985
          tmp___26 = strerror(*tmp___25);
#line 985
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___26);
          }
        }
      } else {
        {
#line 985
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 985
      pr_signals_unblock();
#line 987
      tmp___28 = pr_parser_cleanup();
      }
#line 987
      if (tmp___28 < 0) {
        {
#line 988
        pr_log_pri(3, "Fatal: error processing configuration file \'%s\': unclosed configuration section",
                   config_filename);
#line 990
        end_login(1);
        }
      }
      {
#line 1000
      endpwent();
#line 1001
      endgrent();
#line 1004
      set_daemon_rlimits();
#line 1007
      fixup_servers(server_list);
#line 1009
      pr_event_generate("core.postparse", (void const   *)((void *)0));
#line 1014
      init_bindings();
      }
    } else {
      {
#line 1019
      pr_log_pri(3, "received SIGHUP, cannot restart child process");
      }
    }
  } else {
    {
#line 1019
    pr_log_pri(3, "received SIGHUP, cannot restart child process");
    }
  }
#line 1021
  return;
}
}
#line 1024 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int dup_low_fd(int fd___0 ) 
{ 
  int i___0 ;
  int need_close[3] ;
  void *__cil_tmp4 ;

  {
#line 1025
  need_close[0] = -1;
#line 1025
  need_close[1] = -1;
#line 1025
  need_close[2] = -1;
#line 1027
  i___0 = 0;
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1027
    if (! (i___0 < 3)) {
#line 1027
      goto while_break;
    }
#line 1028
    if (fd___0 == i___0) {
      {
#line 1029
      fd___0 = dup(fd___0);
#line 1030
      need_close[i___0] = 1;
      }
    }
#line 1027
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1033
  i___0 = 0;
  {
#line 1033
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1033
    if (! (i___0 < 3)) {
#line 1033
      goto while_break___0;
    }
#line 1034
    if (need_close[i___0] > -1) {
      {
#line 1035
      close(i___0);
      }
    }
#line 1033
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1037
  return (fd___0);
}
}
#line 1041 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void set_server_privs(void) 
{ 
  uid_t server_uid ;
  uid_t current_euid ;
  __uid_t tmp ;
  gid_t server_gid ;
  gid_t current_egid ;
  __gid_t tmp___0 ;
  unsigned char switch_server_id ;
  uid_t *uid ;
  void *tmp___1 ;
  gid_t *gid ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  __uid_t tmp___27 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
  {
#line 1042
  tmp = geteuid();
#line 1042
  current_euid = tmp;
#line 1043
  tmp___0 = getegid();
#line 1043
  current_egid = tmp___0;
#line 1044
  switch_server_id = (unsigned char)0;
#line 1046
  tmp___1 = get_param_ptr(main_server->conf, "UserID", 0);
#line 1046
  uid = (uid_t *)tmp___1;
#line 1047
  tmp___2 = get_param_ptr(main_server->conf, "GroupID", 0);
#line 1047
  gid = (gid_t *)tmp___2;
  }
#line 1049
  if (uid) {
#line 1050
    server_uid = *uid;
#line 1051
    switch_server_id = (unsigned char)1;
  } else {
#line 1054
    server_uid = current_euid;
  }
#line 1056
  if (gid) {
#line 1057
    server_gid = *gid;
#line 1058
    switch_server_id = (unsigned char)1;
  } else {
#line 1061
    server_gid = current_egid;
  }
#line 1063
  if (switch_server_id) {
    {
#line 1064
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 1064);
#line 1064
    pr_signals_block();
    }
#line 1064
    if (! session.disable_id_switching) {
      {
#line 1064
      tmp___5 = seteuid((__uid_t )0);
      }
#line 1064
      if (tmp___5) {
        {
#line 1064
        tmp___3 = __errno_location();
#line 1064
        tmp___4 = strerror(*tmp___3);
#line 1064
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___4);
        }
      }
      {
#line 1064
      tmp___8 = setegid((__gid_t )0);
      }
#line 1064
      if (tmp___8) {
        {
#line 1064
        tmp___6 = __errno_location();
#line 1064
        tmp___7 = strerror(*tmp___6);
#line 1064
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___7);
        }
      }
    } else {
      {
#line 1064
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 1064
    pr_signals_unblock();
#line 1069
    pr_log_debug(9, "SETUP PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 1069);
#line 1069
    pr_signals_block();
#line 1069
    tmp___27 = getuid();
    }
#line 1069
    if (tmp___27 != 0U) {
      {
#line 1069
      session.uid = getuid();
#line 1069
      session.ouid = session.uid;
#line 1069
      session.gid = getgid();
#line 1069
      tmp___11 = setgid(session.gid);
      }
#line 1069
      if (tmp___11) {
        {
#line 1069
        tmp___9 = __errno_location();
#line 1069
        tmp___10 = strerror(*tmp___9);
#line 1069
        pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___10);
        }
      }
      {
#line 1069
      tmp___14 = setuid(session.uid);
      }
#line 1069
      if (tmp___14) {
        {
#line 1069
        tmp___12 = __errno_location();
#line 1069
        tmp___13 = strerror(*tmp___12);
#line 1069
        pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___13);
        }
      }
      {
#line 1069
      tmp___17 = seteuid(session.uid);
      }
#line 1069
      if (tmp___17) {
        {
#line 1069
        tmp___15 = __errno_location();
#line 1069
        tmp___16 = strerror(*tmp___15);
#line 1069
        pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___16);
        }
      }
    } else {
      {
#line 1069
      session.ouid = getuid();
#line 1069
      session.uid = server_uid;
#line 1069
      session.gid = server_gid;
#line 1069
      tmp___20 = setuid((__uid_t )0);
      }
#line 1069
      if (tmp___20) {
        {
#line 1069
        tmp___18 = __errno_location();
#line 1069
        tmp___19 = strerror(*tmp___18);
#line 1069
        pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___19);
        }
      }
      {
#line 1069
      tmp___23 = setgid(server_gid);
      }
#line 1069
      if (tmp___23) {
        {
#line 1069
        tmp___21 = __errno_location();
#line 1069
        tmp___22 = strerror(*tmp___21);
#line 1069
        pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___22);
        }
      }
      {
#line 1069
      tmp___26 = seteuid(server_uid);
      }
#line 1069
      if (tmp___26) {
        {
#line 1069
        tmp___24 = __errno_location();
#line 1069
        tmp___25 = strerror(*tmp___24);
#line 1069
        pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___25);
        }
      }
    }
    {
#line 1069
    pr_signals_unblock();
    }
  }
#line 1071
  return;
}
}
#line 1073 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void fork_server(int fd___0 , conn_t *l , unsigned char nofork ) 
{ 
  conn_t *conn ;
  int i___0 ;
  int rev ;
  int semfds[2] ;
  int xerrno ;
  pid_t pid ;
  sigset_t sig_set___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  time_t tmp___4 ;
  __pid_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  __uid_t tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  time_t now ;
  config_rec *c ;
  char *reason ;
  char const   *serveraddress ;
  char const   *tmp___24 ;
  pr_netaddr_t *masq_addr ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;

  {
#line 1074
  conn = (conn_t *)((void *)0);
#line 1076
  semfds[0] = -1;
#line 1076
  semfds[1] = -1;
#line 1077
  xerrno = 0;
#line 1083
  if (! nofork) {
    {
#line 1092
    tmp___1 = pipe((int *)(semfds));
    }
#line 1092
    if (tmp___1 == -1) {
      {
#line 1093
      tmp = __errno_location();
#line 1093
      tmp___0 = strerror(*tmp);
#line 1093
      pr_log_pri(3, "pipe(): %s", tmp___0);
#line 1094
      close(fd___0);
      }
#line 1095
      return;
    }
#line 1102
    if (semfds[1] < 3) {
      {
#line 1103
      semfds[1] = dup_low_fd(semfds[1]);
      }
    }
    {
#line 1110
    sigemptyset(& sig_set___0);
#line 1111
    sigaddset(& sig_set___0, 15);
#line 1112
    sigaddset(& sig_set___0, 17);
#line 1113
    sigaddset(& sig_set___0, 10);
#line 1114
    sigaddset(& sig_set___0, 12);
#line 1116
    sigprocmask(0, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1118
    pid = fork();
    }
    {
#line 1119
    if (pid == 0) {
#line 1119
      goto case_0;
    }
#line 1129
    if (pid == -1) {
#line 1129
      goto case_neg_1;
    }
#line 1140
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1122
    is_master = (unsigned char)0;
#line 1123
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1126
    close(semfds[0]);
    }
#line 1127
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 1130
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1131
    tmp___2 = __errno_location();
#line 1131
    tmp___3 = strerror(*tmp___2);
#line 1131
    pr_log_pri(3, "fork(): %s", tmp___3);
#line 1134
    close(fd___0);
#line 1135
    close(semfds[0]);
#line 1136
    close(semfds[1]);
    }
#line 1138
    return;
    switch_default: /* CIL Label */ 
    {
#line 1142
    close(fd___0);
#line 1144
    child_add(pid, semfds[0]);
#line 1145
    close(semfds[1]);
#line 1150
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
    }
#line 1151
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1155
  session.pid = getpid();
#line 1158
  pr_ipbind_close_listeners();
#line 1179
  tmp___4 = time((time_t *)((void *)0));
#line 1179
  tmp___5 = getpid();
#line 1179
  srand((unsigned int )(tmp___4 * (time_t )tmp___5));
#line 1184
  signal(10, & sig_disconnect);
#line 1185
  signal(12, & sig_evnt);
#line 1187
  signal(17, (void (*)(int  ))0);
#line 1188
  signal(1, (void (*)(int  ))1);
#line 1200
  log_closesyslog();
#line 1206
  conn = pr_inet_openrw(permanent_pool, l, (pr_netaddr_t *)((void *)0), 16, fd___0,
                        0, 1, 0);
  }
#line 1210
  if (! conn) {
    {
#line 1211
    tmp___6 = __errno_location();
#line 1211
    xerrno = *tmp___6;
    }
  }
  {
#line 1215
  pr_signals_block();
#line 1216
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
               1216);
#line 1216
  pr_signals_block();
  }
#line 1216
  if (! session.disable_id_switching) {
    {
#line 1216
    tmp___9 = seteuid((__uid_t )0);
    }
#line 1216
    if (tmp___9) {
      {
#line 1216
      tmp___7 = __errno_location();
#line 1216
      tmp___8 = strerror(*tmp___7);
#line 1216
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___8);
      }
    }
    {
#line 1216
    tmp___12 = setegid((__gid_t )0);
    }
#line 1216
    if (tmp___12) {
      {
#line 1216
      tmp___10 = __errno_location();
#line 1216
      tmp___11 = strerror(*tmp___10);
#line 1216
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___11);
      }
    }
  } else {
    {
#line 1216
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 1216
  pr_signals_unblock();
#line 1218
  log_opensyslog((char const   *)((void *)0));
#line 1220
  pr_signals_block();
  }
#line 1220
  if (! session.disable_id_switching) {
    {
#line 1220
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 1220);
#line 1220
    tmp___16 = geteuid();
    }
#line 1220
    if (tmp___16 != 0U) {
      {
#line 1220
      tmp___15 = seteuid((__uid_t )0);
      }
#line 1220
      if (tmp___15) {
        {
#line 1220
        tmp___13 = __errno_location();
#line 1220
        tmp___14 = strerror(*tmp___13);
#line 1220
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___14);
        }
      }
    }
    {
#line 1220
    tmp___19 = setegid(session.gid);
    }
#line 1220
    if (tmp___19) {
      {
#line 1220
      tmp___17 = __errno_location();
#line 1220
      tmp___18 = strerror(*tmp___17);
#line 1220
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___18);
      }
    }
    {
#line 1220
    tmp___22 = seteuid(session.uid);
    }
#line 1220
    if (tmp___22) {
      {
#line 1220
      tmp___20 = __errno_location();
#line 1220
      tmp___21 = strerror(*tmp___20);
#line 1220
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___21);
      }
    }
  } else {
    {
#line 1220
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 1220
  pr_signals_unblock();
#line 1221
  pr_signals_unblock();
  }
#line 1223
  if (! conn) {
    {
#line 1224
    tmp___23 = strerror(xerrno);
#line 1224
    pr_log_pri(3, "Fatal: unable to open incoming connection: %s", tmp___23);
#line 1226
    exit(1);
    }
  }
  {
#line 1229
  pr_inet_set_proto_opts(permanent_pool, conn, 0, 1, 1, 0, 0);
#line 1231
  pr_event_generate("core.connect", (void const   *)conn);
#line 1234
  main_server = pr_ipbind_get_server(conn->local_addr, (unsigned int )conn->local_port);
#line 1270
  session.pool = make_sub_pool(permanent_pool);
#line 1271
  pr_pool_tag(session.pool, "Session Pool");
#line 1273
  session.c = conn;
#line 1274
  session.data_port = (unsigned short )(conn->remote_port - 1);
#line 1275
  session.sf_flags = (int volatile   )0;
#line 1276
  session.sp_flags = (int volatile   )0;
#line 1277
  session.proc_prefix = (char *)"(connecting)";
#line 1283
  close(semfds[1]);
  }
#line 1286
  if (ServerUseReverseDNS) {
    {
#line 1287
    rev = pr_netaddr_set_reverse_dns(ServerUseReverseDNS);
    }
#line 1289
    if (conn->remote_addr) {
      {
#line 1290
      conn->remote_name = pr_netaddr_get_dnsstr(conn->remote_addr);
      }
    }
    {
#line 1292
    pr_netaddr_set_reverse_dns(rev);
    }
  }
  {
#line 1295
  pr_netaddr_set_sess_addrs();
  }
#line 1298
  if (shutdownp) {
    {
#line 1301
    time(& now);
    }
#line 1302
    if (! deny) {
#line 1302
      goto _L;
    } else
#line 1302
    if (deny <= now) {
      _L: /* CIL Label */ 
#line 1303
      c = (config_rec *)((void *)0);
#line 1304
      reason = (char *)((void *)0);
#line 1307
      if (session.c) {
#line 1307
        if ((session.c)->local_addr) {
          {
#line 1307
          tmp___24 = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 1307
          serveraddress = tmp___24;
          }
        } else {
#line 1307
          serveraddress = main_server->ServerAddress;
        }
      } else {
#line 1307
        serveraddress = main_server->ServerAddress;
      }
      {
#line 1311
      c = find_config(main_server->conf, 1 << 15, "MasqueradeAddress", 0);
      }
#line 1311
      if ((unsigned long )c != (unsigned long )((void *)0)) {
        {
#line 1314
        masq_addr = (pr_netaddr_t *)*(c->argv + 0);
#line 1315
        serveraddress = pr_netaddr_get_ipstr(masq_addr);
        }
      }
      {
#line 1318
      tmp___25 = pr_strtime(now);
#line 1318
      tmp___26 = pstrdup(permanent_pool, tmp___25);
      }
#line 1318
      if (session.c) {
#line 1318
        if ((session.c)->remote_name) {
#line 1318
          tmp___27 = (session.c)->remote_name;
        } else {
#line 1318
          tmp___27 = "(unknown)";
        }
      } else {
#line 1318
        tmp___27 = "(unknown)";
      }
#line 1318
      if (session.cwd[0]) {
#line 1318
        tmp___28 = (char const   *)(session.cwd);
      } else {
#line 1318
        tmp___28 = "(none)";
      }
      {
#line 1318
      tmp___29 = pr_strtime(disc);
#line 1318
      tmp___30 = pstrdup(permanent_pool, tmp___29);
#line 1318
      tmp___31 = pr_strtime(deny);
#line 1318
      tmp___32 = pstrdup(permanent_pool, tmp___31);
#line 1318
      tmp___33 = pr_strtime(shut);
#line 1318
      tmp___34 = pstrdup(permanent_pool, tmp___33);
#line 1318
      reason = sreplace(permanent_pool, shutmsg, "%s", tmp___34, "%r", tmp___32, "%d",
                        tmp___30, "%C", tmp___28, "%L", serveraddress, "%R", tmp___27,
                        "%T", tmp___26, "%U", "NONE", "%V", main_server->ServerName,
                        (void *)0);
#line 1331
      tmp___35 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1331
      pr_log_auth(5, "connection refused (%s) from %s [%s]", reason, (session.c)->remote_name,
                  tmp___35);
#line 1335
      pr_response_send("500", "FTP server shut down (%s) -- please try again later",
                       reason);
#line 1337
      exit(0);
      }
    }
  }
#line 1344
  if (! main_server) {
    {
#line 1345
    tmp___36 = pr_netaddr_get_ipstr(conn->local_addr);
#line 1345
    pr_log_debug(2, "No server configuration found for IP address %s", tmp___36);
#line 1347
    pr_log_debug(2, "Use the DefaultServer directive to designate a default server configuration to handle requests like this");
#line 1350
    tmp___37 = pr_netaddr_get_dnsstr(conn->local_addr);
#line 1350
    pr_response_send("500", "Sorry, no server available to handle request on %s",
                     tmp___37);
#line 1353
    exit(0);
    }
  }
#line 1356
  if (main_server->listen) {
#line 1357
    if ((main_server->listen)->listen_fd == conn->rfd) {
#line 1359
      (main_server->listen)->listen_fd = -1;
    } else
#line 1357
    if ((main_server->listen)->listen_fd == conn->wfd) {
#line 1359
      (main_server->listen)->listen_fd = -1;
    }
    {
#line 1361
    destroy_pool((main_server->listen)->pool);
#line 1362
    main_server->listen = (struct conn_struc *)((void *)0);
    }
  }
  {
#line 1366
  set_server_privs();
#line 1369
  session.class = pr_class_match_addr((session.c)->remote_addr);
  }
#line 1370
  if ((unsigned long )session.class != (unsigned long )((void *)0)) {
    {
#line 1371
    pr_log_debug(2, "session requested from client in \'%s\' class", (session.class)->cls_name);
    }
  } else {
    {
#line 1375
    pr_log_debug(5, "session requested from client in unknown class");
    }
  }
  {
#line 1383
  tmp___39 = login_check_limits(main_server->conf, 1, 0, & i___0);
  }
#line 1383
  if (! tmp___39) {
    {
#line 1384
    tmp___38 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1384
    pr_log_pri(5, "Connection from %s [%s] denied.", (session.c)->remote_name, tmp___38);
#line 1387
    exit(0);
    }
  }
  {
#line 1391
  session.notes = pr_table_alloc(session.pool, 0);
  }
#line 1392
  if ((unsigned long )session.notes == (unsigned long )((void *)0)) {
    {
#line 1393
    tmp___40 = __errno_location();
#line 1393
    tmp___41 = strerror(*tmp___40);
#line 1393
    pr_log_debug(3, "error creating session.notes table: %s", tmp___41);
    }
  }
  {
#line 1398
  timers_init();
#line 1401
  set_session_rlimits();
#line 1404
  pr_log_debug(7, "performing module session initializations");
#line 1405
  tmp___42 = modules_session_init();
  }
#line 1405
  if (tmp___42 < 0) {
    {
#line 1406
    end_login(1);
    }
  }
  {
#line 1408
  tmp___43 = pr_netaddr_get_ipstr((session.c)->local_addr);
#line 1408
  pr_log_debug(4, "connected - local  : %s:%d", tmp___43, (session.c)->local_port);
#line 1410
  tmp___44 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1410
  pr_log_debug(4, "connected - remote : %s:%d", tmp___44, (session.c)->remote_port);
  }
#line 1413
  if ((session.c)->remote_port) {
#line 1413
    tmp___45 = (session.c)->remote_port;
  } else {
#line 1413
    tmp___45 = 0;
  }
#line 1413
  if ((session.c)->remote_addr) {
    {
#line 1413
    tmp___46 = pr_netaddr_get_ipstr((session.c)->remote_addr);
#line 1413
    tmp___47 = tmp___46;
    }
  } else {
#line 1413
    tmp___47 = "?";
  }
#line 1413
  if ((session.c)->remote_name) {
#line 1413
    tmp___48 = (session.c)->remote_name;
  } else {
#line 1413
    tmp___48 = "?";
  }
  {
#line 1413
  pr_proctitle_set("connected: %s (%s:%d)", tmp___48, tmp___47, tmp___45);
#line 1417
  pr_log_pri(6, "%s session opened.", protocol_name);
#line 1419
  send_session_banner(main_server);
#line 1421
  (*cmd_handler)(main_server, conn);
  }
#line 1430
  return;
}
}
#line 1432 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void disc_children(void) 
{ 
  sigset_t sig_set___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  time_t tmp___15 ;
  unsigned long tmp___16 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 1434
  if (disc) {
    {
#line 1434
    tmp___15 = time((time_t *)((void *)0));
    }
#line 1434
    if (disc <= tmp___15) {
      {
#line 1434
      tmp___16 = child_count();
      }
#line 1434
      if (tmp___16) {
        {
#line 1437
        sigemptyset(& sig_set___0);
#line 1438
        sigaddset(& sig_set___0, 15);
#line 1439
        sigaddset(& sig_set___0, 17);
#line 1440
        sigaddset(& sig_set___0, 10);
#line 1441
        sigaddset(& sig_set___0, 12);
#line 1443
        sigprocmask(0, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1445
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     1445);
#line 1445
        pr_signals_block();
        }
#line 1445
        if (! session.disable_id_switching) {
          {
#line 1445
          tmp___1 = seteuid((__uid_t )0);
          }
#line 1445
          if (tmp___1) {
            {
#line 1445
            tmp = __errno_location();
#line 1445
            tmp___0 = strerror(*tmp);
#line 1445
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
            }
          }
          {
#line 1445
          tmp___4 = setegid((__gid_t )0);
          }
#line 1445
          if (tmp___4) {
            {
#line 1445
            tmp___2 = __errno_location();
#line 1445
            tmp___3 = strerror(*tmp___2);
#line 1445
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
            }
          }
        } else {
          {
#line 1445
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 1445
        pr_signals_unblock();
#line 1446
        child_signal(10);
#line 1447
        pr_signals_block();
        }
#line 1447
        if (! session.disable_id_switching) {
          {
#line 1447
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       1447);
#line 1447
          tmp___8 = geteuid();
          }
#line 1447
          if (tmp___8 != 0U) {
            {
#line 1447
            tmp___7 = seteuid((__uid_t )0);
            }
#line 1447
            if (tmp___7) {
              {
#line 1447
              tmp___5 = __errno_location();
#line 1447
              tmp___6 = strerror(*tmp___5);
#line 1447
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___6);
              }
            }
          }
          {
#line 1447
          tmp___11 = setegid(session.gid);
          }
#line 1447
          if (tmp___11) {
            {
#line 1447
            tmp___9 = __errno_location();
#line 1447
            tmp___10 = strerror(*tmp___9);
#line 1447
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___10);
            }
          }
          {
#line 1447
          tmp___14 = seteuid(session.uid);
          }
#line 1447
          if (tmp___14) {
            {
#line 1447
            tmp___12 = __errno_location();
#line 1447
            tmp___13 = strerror(*tmp___12);
#line 1447
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___13);
            }
          }
        } else {
          {
#line 1447
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 1447
        pr_signals_unblock();
#line 1449
        sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
        }
      }
    }
  }
#line 1451
  return;
}
}
#line 1461
static void daemon_loop(void) ;
#line 1461 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static int running  =    0;
#line 1453 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void daemon_loop(void) 
{ 
  fd_set listenfds ;
  conn_t *listen_conn ;
  int fd___0 ;
  int maxfd ;
  int i___0 ;
  int err_count ;
  unsigned long nconnects ;
  time_t last_error ;
  struct timeval tv ;
  unsigned int __i ;
  fd_set *__arr ;
  int tmp ;
  time_t now ;
  time_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  int *tmp___4 ;
  sigset_t sig_set___0 ;
  time_t this_error ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  pr_child_t *ch ;
  time_t now___0 ;
  time_t tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 1457
  err_count = 0;
#line 1458
  nconnects = 0UL;
#line 1463
  pr_proctitle_set("(accepting connections)");
#line 1465
  time(& last_error);
  }
  {
#line 1467
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1468
    run_schedule();
    }
    {
#line 1470
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1470
      __arr = & listenfds;
#line 1470
      __i = 0U;
      {
#line 1470
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1470
        if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 1470
          goto while_break___1;
        }
#line 1470
        __arr->fds_bits[__i] = (__fd_mask )0;
#line 1470
        __i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1470
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1471
    maxfd = 0;
#line 1472
    maxfd = pr_ipbind_listen(& listenfds);
#line 1475
    maxfd = semaphore_fds(& listenfds, maxfd);
#line 1478
    tmp = check_shutmsg(& shut, & deny, & disc, shutmsg, (size_t )sizeof(shutmsg));
    }
    {
#line 1479
    if (tmp == 1) {
#line 1479
      goto case_1;
    }
#line 1485
    if (tmp == 0) {
#line 1485
      goto case_0;
    }
#line 1478
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1480
    if (! shutdownp) {
      {
#line 1481
      disc_children();
      }
    }
#line 1482
    shutdownp = 1;
#line 1483
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1486
    shutdownp = 0;
#line 1487
    disc = (time_t )0;
#line 1487
    deny = disc;
#line 1488
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1491
    if (shutdownp) {
#line 1492
      tv.tv_sec = 5L;
#line 1493
      tv.tv_usec = 0L;
    } else {
#line 1497
      tv.tv_sec = (__time_t )30;
#line 1498
      tv.tv_usec = 0L;
    }
#line 1505
    if (shutdownp) {
#line 1505
      if (! running) {
        {
#line 1512
        tmp___0 = time((time_t *)((void *)0));
#line 1512
        now = tmp___0;
#line 1514
        tmp___3 = difftime(deny, now);
        }
#line 1514
        if (tmp___3 < 0.0) {
          {
#line 1515
          pr_log_pri(3, "/etc/shutmsg present: all incoming connections will be refused.");
          }
        } else {
          {
#line 1519
          tmp___1 = ctime((time_t const   *)(& deny));
#line 1519
          tmp___2 = pr_str_strip_end(tmp___1, (char *)"\r\n");
#line 1519
          pr_log_pri(3, "/etc/shutmsg present: incoming connections will be denied starting %s",
                     tmp___2);
          }
        }
      }
    }
    {
#line 1524
    running = 1;
#line 1526
    i___0 = select(maxfd + 1, (fd_set */* __restrict  */)(& listenfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 1528
    if (i___0 == -1) {
      {
#line 1528
      tmp___4 = __errno_location();
      }
#line 1528
      if (*tmp___4 == 4) {
        {
#line 1529
        pr_signals_handle();
        }
#line 1530
        goto while_continue;
      }
    }
#line 1533
    if (have_dead_child) {
      {
#line 1536
      sigemptyset(& sig_set___0);
#line 1537
      sigaddset(& sig_set___0, 17);
#line 1538
      sigaddset(& sig_set___0, 15);
#line 1539
      pr_alarms_block();
#line 1540
      sigprocmask(0, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1542
      have_dead_child = (unsigned char)0;
#line 1543
      child_update();
#line 1545
      sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1546
      pr_alarms_unblock();
      }
    }
#line 1549
    if (i___0 == -1) {
      {
#line 1552
      time(& this_error);
      }
#line 1554
      if (this_error - last_error <= 5L) {
#line 1554
        tmp___5 = err_count;
#line 1554
        err_count ++;
#line 1554
        if (tmp___5 > 10) {
          {
#line 1555
          pr_log_pri(3, "Fatal: select() failing repeatedly, shutting down.");
#line 1557
          exit(1);
          }
        } else {
#line 1554
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1559
      if (this_error - last_error > 5L) {
#line 1560
        last_error = this_error;
#line 1561
        err_count = 0;
      }
      {
#line 1564
      tmp___6 = __errno_location();
#line 1564
      tmp___7 = strerror(*tmp___6);
#line 1564
      pr_log_pri(5, "select() failed in daemon_loop(): %s", tmp___7);
      }
    }
#line 1568
    if (i___0 == 0) {
#line 1569
      goto while_continue;
    }
    {
#line 1574
    nconnects = 1UL;
#line 1577
    tmp___9 = child_count();
    }
#line 1577
    if (tmp___9) {
      {
#line 1579
      tmp___8 = time((time_t *)((void *)0));
#line 1579
      now___0 = tmp___8;
#line 1581
      ch = child_get((pr_child_t *)((void *)0));
      }
      {
#line 1581
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1581
        if (! ch) {
#line 1581
          goto while_break___2;
        }
#line 1582
        if (ch->ch_pipefd != -1) {
#line 1582
          if ((listenfds.fds_bits[(unsigned long )ch->ch_pipefd / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )ch->ch_pipefd % (8UL * sizeof(__fd_mask )))) != 0L) {
            {
#line 1584
            close(ch->ch_pipefd);
#line 1585
            ch->ch_pipefd = -1;
            }
          }
        }
#line 1591
        if ((unsigned long )ch->ch_when >= (unsigned long )now___0 - (unsigned long )max_connect_interval) {
#line 1592
          nconnects ++;
        }
        {
#line 1581
        ch = child_get(ch);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 1596
    pr_signals_handle();
#line 1599
    listen_conn = pr_ipbind_accept_conn(& listenfds, & fd___0);
    }
#line 1606
    if (listen_conn) {
#line 1609
      if (ServerMaxInstances) {
        {
#line 1609
        tmp___10 = child_count();
        }
#line 1609
        if (tmp___10 >= (unsigned long )ServerMaxInstances) {
          {
#line 1610
          pr_event_generate("core.max-instances", (void const   *)((void *)0));
#line 1612
          pr_log_pri(4, "MaxInstances (%d) reached, new connection denied", ServerMaxInstances);
#line 1615
          close(fd___0);
          }
        } else {
#line 1609
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1618
      if (max_connects) {
#line 1618
        if (nconnects > max_connects) {
          {
#line 1619
          pr_event_generate("core.max-connection-rate", (void const   *)((void *)0));
#line 1621
          pr_log_pri(4, "MaxConnectionRate (%lu/%u secs) reached, new connection denied",
                     max_connects, max_connect_interval);
#line 1624
          close(fd___0);
          }
        } else {
          {
#line 1628
          fork_server(fd___0, listen_conn, (unsigned char)0);
          }
        }
      } else {
        {
#line 1628
        fork_server(fd___0, listen_conn, (unsigned char)0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1642 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void pr_signals_handle(void) 
{ 
  struct timeval tv ;
  unsigned long interval_usecs ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 1643
  table_handling_signal(1);
#line 1645
  tmp___1 = __errno_location();
  }
#line 1645
  if (*tmp___1 == 4) {
#line 1645
    if (0.2 > (double )0) {
#line 1648
      interval_usecs = (unsigned long )(0.2 * (double )1000000);
#line 1650
      tv.tv_sec = (__time_t )(interval_usecs / 1000000UL);
#line 1651
      tv.tv_usec = (__suseconds_t )(interval_usecs - (unsigned long )(tv.tv_sec * 1000000L));
#line 1653
      if (tv.tv_usec != 1L) {
#line 1653
        tmp = "microsecs";
      } else {
#line 1653
        tmp = "microsec";
      }
#line 1653
      if (tv.tv_sec != 1L) {
#line 1653
        tmp___0 = "secs";
      } else {
#line 1653
        tmp___0 = "sec";
      }
      {
#line 1653
      pr_trace_msg("signal", 8, "interrupted system call, delaying for %lu %s, %lu %s",
                   (unsigned long )tv.tv_sec, tmp___0, (unsigned long )tv.tv_usec,
                   tmp);
#line 1658
      pr_signals_block();
#line 1659
      select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 1660
      pr_signals_unblock();
      }
    }
  }
  {
#line 1663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1663
    if (! recvd_signal_flags) {
#line 1663
      goto while_break;
    }
#line 1665
    if (recvd_signal_flags & (unsigned int volatile   )1024) {
      {
#line 1666
      recvd_signal_flags &= (unsigned int volatile   )-1025;
#line 1667
      pr_trace_msg("signal", 9, "handling SIGALRM (signal %d)", 14);
#line 1668
      handle_alarm();
      }
    }
#line 1671
    if (recvd_signal_flags & (unsigned int volatile   )512) {
      {
#line 1672
      recvd_signal_flags &= (unsigned int volatile   )-513;
#line 1673
      pr_trace_msg("signal", 9, "handling SIGCHLD (signal %d)", 17);
#line 1674
      handle_chld();
      }
    }
#line 1677
    if (recvd_signal_flags & (unsigned int volatile   )256) {
      {
#line 1678
      recvd_signal_flags &= (unsigned int volatile   )-257;
#line 1681
      pr_trace_msg("signal", 9, "handling SIGUSR2 (signal %d)", 12);
#line 1682
      handle_evnt();
      }
    }
#line 1685
    if (recvd_signal_flags & (unsigned int volatile   )8) {
      {
#line 1686
      recvd_signal_flags &= (unsigned int volatile   )-9;
#line 1687
      pr_trace_msg("signal", 9, "handling SIGSEGV (signal %d)", 11);
#line 1688
      handle_terminate_other();
      }
    }
#line 1691
    if (recvd_signal_flags & (unsigned int volatile   )16) {
      {
#line 1692
      recvd_signal_flags &= (unsigned int volatile   )-17;
#line 1693
      pr_trace_msg("signal", 9, "handling signal %d", term_signo);
#line 1694
      handle_terminate();
      }
    }
#line 1697
    if (recvd_signal_flags & (unsigned int volatile   )64) {
      {
#line 1698
      recvd_signal_flags &= (unsigned int volatile   )-65;
#line 1699
      pr_trace_msg("signal", 9, "handling signal %d", term_signo);
#line 1700
      handle_terminate_other();
      }
    }
#line 1703
    if (recvd_signal_flags & (unsigned int volatile   )32) {
      {
#line 1704
      recvd_signal_flags &= (unsigned int volatile   )-33;
#line 1705
      pr_trace_msg("signal", 9, "handling SIGXCPU (signal %d)", 24);
#line 1706
      handle_xcpu();
      }
    }
#line 1709
    if (recvd_signal_flags & (unsigned int volatile   )128) {
      {
#line 1710
      recvd_signal_flags &= (unsigned int volatile   )-129;
#line 1711
      pr_trace_msg("signal", 9, "handling SIGABRT (signal %d)", 6);
#line 1712
      handle_abort();
      }
    }
#line 1715
    if (recvd_signal_flags & (unsigned int volatile   )1) {
      {
#line 1716
      pr_trace_msg("signal", 9, "handling SIGHUP (signal %d)", 1);
#line 1719
      schedule(& core_restart_cb, 0, (void *)0, (void *)0, (void *)0, (void *)0);
#line 1721
      recvd_signal_flags &= (unsigned int volatile   )-2;
      }
    }
#line 1724
    if (recvd_signal_flags & (unsigned int volatile   )2) {
      {
#line 1725
      pr_trace_msg("signal", 9, "handling SIGUSR1 (signal %d)", 10);
#line 1726
      session_exit(5, (void *)"Parent process requested shutdown", 0, (void *)0);
#line 1727
      recvd_signal_flags &= (unsigned int volatile   )-3;
      }
    }
#line 1730
    if (recvd_signal_flags & (unsigned int volatile   )4) {
      {
#line 1731
      pr_trace_msg("signal", 9, "handling SIGUSR1 (signal %d)", 10);
#line 1734
      schedule(& shutdown_exit, 0, (void *)0, (void *)0, (void *)0, (void *)0);
#line 1736
      recvd_signal_flags &= (unsigned int volatile   )-5;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1740
  table_handling_signal(0);
  }
#line 1741
  return;
}
}
#line 1747 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void sig_restart(int signo ) 
{ 


  {
  {
#line 1748
  recvd_signal_flags |= (unsigned int volatile   )1;
#line 1749
  signal(1, & sig_restart);
  }
#line 1750
  return;
}
}
#line 1752 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void sig_evnt(int signo ) 
{ 


  {
  {
#line 1753
  recvd_signal_flags |= (unsigned int volatile   )256;
#line 1754
  signal(12, & sig_evnt);
  }
#line 1755
  return;
}
}
#line 1763 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void sig_disconnect(int signo ) 
{ 


  {
#line 1768
  if (session.sf_flags & (int volatile   )64) {
#line 1770
    recvd_signal_flags |= (unsigned int volatile   )2;
  } else
#line 1768
  if (session.sf_flags & (int volatile   )4) {
#line 1770
    recvd_signal_flags |= (unsigned int volatile   )2;
  } else {
#line 1772
    recvd_signal_flags |= (unsigned int volatile   )4;
  }
  {
#line 1774
  signal(10, (void (*)(int  ))1);
  }
#line 1775
  return;
}
}
#line 1777 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void sig_child(int signo ) 
{ 


  {
  {
#line 1778
  recvd_signal_flags |= (unsigned int volatile   )512;
#line 1806
  handle_chld();
#line 1807
  signal(17, & sig_child);
  }
#line 1808
  return;
}
}
#line 1826 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void sig_abort(int signo ) 
{ 


  {
  {
#line 1827
  recvd_signal_flags |= (unsigned int volatile   )128;
#line 1828
  signal(6, (void (*)(int  ))0);
  }
#line 1836
  return;
}
}
#line 1838 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void handle_abort(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1839
  pr_log_pri(5, "ProFTPD received SIGABRT signal, no core dump");
#line 1840
  finish_terminate();
  }
#line 1841
  return;
}
}
#line 1878 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void sig_terminate(int signo ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1881
  pr_scoreboard_entry_del((unsigned char)0);
#line 1884
  term_signo = signo;
  }
#line 1886
  if (signo == 11) {
    {
#line 1887
    recvd_signal_flags |= (unsigned int volatile   )8;
#line 1893
    pr_trace_msg("signal", 9, "handling SIGSEGV (signal %d)", signo);
#line 1894
    pr_log_pri(5, "ProFTPD terminating (signal %d)", signo);
#line 1895
    pr_log_pri(6, "%s session closed.", protocol_name);
#line 1901
    signal(11, (void (*)(int  ))0);
    }
  } else
#line 1904
  if (signo == 15) {
#line 1905
    recvd_signal_flags |= (unsigned int volatile   )16;
  } else
#line 1907
  if (signo == 24) {
#line 1908
    recvd_signal_flags |= (unsigned int volatile   )32;
  } else {
#line 1911
    recvd_signal_flags |= (unsigned int volatile   )64;
  }
#line 1913
  return;
}
}
#line 1915 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void handle_chld(void) 
{ 
  sigset_t sig_set___0 ;
  pid_t pid ;
  int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 1919
  sigemptyset(& sig_set___0);
#line 1920
  sigaddset(& sig_set___0, 15);
#line 1921
  sigaddset(& sig_set___0, 17);
#line 1923
  pr_alarms_block();
#line 1928
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
  }
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1930
    pid = waitpid(-1, (int *)((void *)0), 1);
    }
#line 1930
    if (! (pid > 0)) {
#line 1930
      goto while_break;
    }
    {
#line 1931
    tmp = child_remove(pid);
    }
#line 1931
    if (tmp == 0) {
#line 1932
      have_dead_child = (unsigned char)1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1935
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
#line 1936
  pr_alarms_unblock();
  }
#line 1937
  return;
}
}
#line 1939 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void handle_evnt(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1940
  pr_event_generate("core.signal.USR2", (void const   *)((void *)0));
  }
#line 1941
  return;
}
}
#line 1943 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void handle_xcpu(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1944
  pr_log_pri(5, "ProFTPD CPU limit exceeded (signal %d)", 24);
#line 1945
  finish_terminate();
  }
#line 1946
  return;
}
}
#line 1948 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void handle_terminate_other(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 1949
  pr_log_pri(3, "ProFTPD terminating (signal %d)", term_signo);
#line 1950
  finish_terminate();
  }
#line 1951
  return;
}
}
#line 1953 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void handle_terminate(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  unsigned long tmp___15 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1956
  if (is_master) {
    {
#line 1959
    tmp___15 = child_count();
    }
#line 1959
    if (tmp___15) {
      {
#line 1960
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   1960);
#line 1960
      pr_signals_block();
      }
#line 1960
      if (! session.disable_id_switching) {
        {
#line 1960
        tmp___1 = seteuid((__uid_t )0);
        }
#line 1960
        if (tmp___1) {
          {
#line 1960
          tmp = __errno_location();
#line 1960
          tmp___0 = strerror(*tmp);
#line 1960
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
          }
        }
        {
#line 1960
        tmp___4 = setegid((__gid_t )0);
        }
#line 1960
        if (tmp___4) {
          {
#line 1960
          tmp___2 = __errno_location();
#line 1960
          tmp___3 = strerror(*tmp___2);
#line 1960
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
          }
        }
      } else {
        {
#line 1960
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 1960
      pr_signals_unblock();
#line 1961
      child_signal(15);
#line 1962
      pr_signals_block();
      }
#line 1962
      if (! session.disable_id_switching) {
        {
#line 1962
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     1962);
#line 1962
        tmp___8 = geteuid();
        }
#line 1962
        if (tmp___8 != 0U) {
          {
#line 1962
          tmp___7 = seteuid((__uid_t )0);
          }
#line 1962
          if (tmp___7) {
            {
#line 1962
            tmp___5 = __errno_location();
#line 1962
            tmp___6 = strerror(*tmp___5);
#line 1962
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___6);
            }
          }
        }
        {
#line 1962
        tmp___11 = setegid(session.gid);
        }
#line 1962
        if (tmp___11) {
          {
#line 1962
          tmp___9 = __errno_location();
#line 1962
          tmp___10 = strerror(*tmp___9);
#line 1962
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
          }
        }
        {
#line 1962
        tmp___14 = seteuid(session.uid);
        }
#line 1962
        if (tmp___14) {
          {
#line 1962
          tmp___12 = __errno_location();
#line 1962
          tmp___13 = strerror(*tmp___12);
#line 1962
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
          }
        }
      } else {
        {
#line 1962
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 1962
      pr_signals_unblock();
      }
    }
    {
#line 1965
    pr_log_pri(5, "ProFTPD killed (signal %d)", term_signo);
    }
  }
  {
#line 1968
  finish_terminate();
  }
#line 1969
  return;
}
}
#line 1971 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void finish_terminate(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  __uid_t tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  __pid_t tmp___31 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 1973
  if (is_master) {
    {
#line 1973
    tmp___31 = getpid();
    }
#line 1973
    if (mpid == tmp___31) {
      {
#line 1975
      pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   1975);
#line 1975
      pr_signals_block();
      }
#line 1975
      if (! session.disable_id_switching) {
        {
#line 1975
        tmp___1 = seteuid((__uid_t )0);
        }
#line 1975
        if (tmp___1) {
          {
#line 1975
          tmp = __errno_location();
#line 1975
          tmp___0 = strerror(*tmp);
#line 1975
          pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
          }
        }
        {
#line 1975
        tmp___4 = setegid((__gid_t )0);
        }
#line 1975
        if (tmp___4) {
          {
#line 1975
          tmp___2 = __errno_location();
#line 1975
          tmp___3 = strerror(*tmp___2);
#line 1975
          pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
          }
        }
      } else {
        {
#line 1975
        pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
        }
      }
      {
#line 1975
      pr_signals_unblock();
      }
#line 1978
      if ((int )ServerType == 1) {
#line 1978
        if (! nodaemon) {
          {
#line 1980
          pr_pidfile_remove();
          }
        }
      }
      {
#line 1989
      pr_event_generate("core.exit", (void const   *)((void *)0));
#line 1995
      pr_event_unregister((module *)((void *)0), "core.exit", (void (*)(void const   * ,
                                                                        void * ))((void *)0));
#line 1997
      pr_signals_block();
      }
#line 1997
      if (! session.disable_id_switching) {
        {
#line 1997
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     1997);
#line 1997
        tmp___8 = geteuid();
        }
#line 1997
        if (tmp___8 != 0U) {
          {
#line 1997
          tmp___7 = seteuid((__uid_t )0);
          }
#line 1997
          if (tmp___7) {
            {
#line 1997
            tmp___5 = __errno_location();
#line 1997
            tmp___6 = strerror(*tmp___5);
#line 1997
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___6);
            }
          }
        }
        {
#line 1997
        tmp___11 = setegid(session.gid);
        }
#line 1997
        if (tmp___11) {
          {
#line 1997
          tmp___9 = __errno_location();
#line 1997
          tmp___10 = strerror(*tmp___9);
#line 1997
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
          }
        }
        {
#line 1997
        tmp___14 = seteuid(session.uid);
        }
#line 1997
        if (tmp___14) {
          {
#line 1997
          tmp___12 = __errno_location();
#line 1997
          tmp___13 = strerror(*tmp___12);
#line 1997
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
          }
        }
      } else {
        {
#line 1997
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 1997
      pr_signals_unblock();
      }
#line 1999
      if ((int )ServerType == 1) {
        {
#line 2000
        pr_log_pri(5, "ProFTPD 1.3.2 standalone mode SHUTDOWN");
#line 2004
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2004);
#line 2004
        pr_signals_block();
        }
#line 2004
        if (! session.disable_id_switching) {
          {
#line 2004
          tmp___17 = seteuid((__uid_t )0);
          }
#line 2004
          if (tmp___17) {
            {
#line 2004
            tmp___15 = __errno_location();
#line 2004
            tmp___16 = strerror(*tmp___15);
#line 2004
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___16);
            }
          }
          {
#line 2004
          tmp___20 = setegid((__gid_t )0);
          }
#line 2004
          if (tmp___20) {
            {
#line 2004
            tmp___18 = __errno_location();
#line 2004
            tmp___19 = strerror(*tmp___18);
#line 2004
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___19);
            }
          }
        } else {
          {
#line 2004
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2004
        pr_signals_unblock();
#line 2005
        pr_delete_scoreboard();
#line 2006
        pr_signals_block();
        }
#line 2006
        if (! session.disable_id_switching) {
          {
#line 2006
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2006);
#line 2006
          tmp___24 = geteuid();
          }
#line 2006
          if (tmp___24 != 0U) {
            {
#line 2006
            tmp___23 = seteuid((__uid_t )0);
            }
#line 2006
            if (tmp___23) {
              {
#line 2006
              tmp___21 = __errno_location();
#line 2006
              tmp___22 = strerror(*tmp___21);
#line 2006
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___22);
              }
            }
          }
          {
#line 2006
          tmp___27 = setegid(session.gid);
          }
#line 2006
          if (tmp___27) {
            {
#line 2006
            tmp___25 = __errno_location();
#line 2006
            tmp___26 = strerror(*tmp___25);
#line 2006
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___26);
            }
          }
          {
#line 2006
          tmp___30 = seteuid(session.uid);
          }
#line 2006
          if (tmp___30) {
            {
#line 2006
            tmp___28 = __errno_location();
#line 2006
            tmp___29 = strerror(*tmp___28);
#line 2006
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___29);
            }
          }
        } else {
          {
#line 2006
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2006
        pr_signals_unblock();
        }
      }
    }
  }
  {
#line 2010
  end_login(1);
  }
#line 2011
  return;
}
}
#line 2026 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void install_signal_handlers(void) 
{ 
  sigset_t sig_set___0 ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 2042
  sigemptyset(& sig_set___0);
#line 2044
  sigaddset(& sig_set___0, 17);
#line 2045
  sigaddset(& sig_set___0, 2);
#line 2046
  sigaddset(& sig_set___0, 3);
#line 2047
  sigaddset(& sig_set___0, 4);
#line 2048
  sigaddset(& sig_set___0, 6);
#line 2049
  sigaddset(& sig_set___0, 8);
#line 2050
  sigaddset(& sig_set___0, 11);
#line 2051
  sigaddset(& sig_set___0, 14);
#line 2052
  sigaddset(& sig_set___0, 15);
#line 2053
  sigaddset(& sig_set___0, 1);
#line 2054
  sigaddset(& sig_set___0, 12);
#line 2056
  sigaddset(& sig_set___0, 16);
#line 2059
  sigaddset(& sig_set___0, 29);
#line 2062
  sigaddset(& sig_set___0, 7);
#line 2065
  signal(17, & sig_child);
#line 2066
  signal(1, & sig_restart);
#line 2067
  signal(2, & sig_terminate);
#line 2068
  signal(3, & sig_terminate);
#line 2069
  signal(4, & sig_terminate);
#line 2070
  signal(6, & sig_abort);
#line 2071
  signal(8, & sig_terminate);
#line 2075
  signal(11, & sig_terminate);
#line 2077
  signal(15, & sig_terminate);
#line 2078
  signal(24, & sig_terminate);
#line 2079
  signal(23, (void (*)(int  ))1);
#line 2081
  signal(16, & sig_terminate);
#line 2084
  signal(29, (void (*)(int  ))1);
#line 2087
  signal(7, & sig_terminate);
#line 2089
  signal(12, & sig_evnt);
#line 2094
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& sig_set___0), (sigset_t */* __restrict  */)((void *)0));
  }
#line 2095
  return;
}
}
#line 2097 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void set_daemon_rlimits(void) 
{ 
  config_rec *c ;
  struct rlimit rlim ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  __uid_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  __uid_t tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  struct rlimit *cpu_rlimit ;
  int *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  __uid_t tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int *tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  int *tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  __uid_t tmp___53 ;
  int *tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  int *tmp___57 ;
  char *tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  struct rlimit *memory_rlimit ;
  int *tmp___61 ;
  char *tmp___62 ;
  int tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;
  int tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  __uid_t tmp___70 ;
  int *tmp___71 ;
  char *tmp___72 ;
  int tmp___73 ;
  int *tmp___74 ;
  char *tmp___75 ;
  int tmp___76 ;
  int *tmp___77 ;
  char *tmp___78 ;
  int tmp___79 ;
  int *tmp___80 ;
  char *tmp___81 ;
  int tmp___82 ;
  __uid_t tmp___83 ;
  int *tmp___84 ;
  char *tmp___85 ;
  int tmp___86 ;
  int *tmp___87 ;
  char *tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  struct rlimit *nofile_rlimit ;
  int *tmp___91 ;
  char *tmp___92 ;
  int tmp___93 ;
  int *tmp___94 ;
  char *tmp___95 ;
  int tmp___96 ;
  int *tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  __uid_t tmp___100 ;
  int *tmp___101 ;
  char *tmp___102 ;
  int tmp___103 ;
  int *tmp___104 ;
  char *tmp___105 ;
  int tmp___106 ;
  int *tmp___107 ;
  char *tmp___108 ;
  int tmp___109 ;
  int *tmp___110 ;
  char *tmp___111 ;
  int tmp___112 ;
  __uid_t tmp___113 ;
  int *tmp___114 ;
  char *tmp___115 ;
  int tmp___116 ;
  int *tmp___117 ;
  char *tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  void *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;

  {
  {
#line 2098
  c = (config_rec *)((void *)0);
#line 2101
  tmp___30 = getrlimit((__rlimit_resource_t )4, & rlim);
  }
#line 2101
  if (tmp___30 < 0) {
    {
#line 2102
    tmp = __errno_location();
#line 2102
    tmp___0 = strerror(*tmp);
#line 2102
    pr_log_pri(3, "error: getrlimit(RLIMIT_CORE): %s", tmp___0);
    }
  } else {
    {
#line 2109
    rlim.rlim_max = (rlim_t )0;
#line 2109
    rlim.rlim_cur = rlim.rlim_max;
#line 2112
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 2112);
#line 2112
    pr_signals_block();
    }
#line 2112
    if (! session.disable_id_switching) {
      {
#line 2112
      tmp___3 = seteuid((__uid_t )0);
      }
#line 2112
      if (tmp___3) {
        {
#line 2112
        tmp___1 = __errno_location();
#line 2112
        tmp___2 = strerror(*tmp___1);
#line 2112
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___2);
        }
      }
      {
#line 2112
      tmp___6 = setegid((__gid_t )0);
      }
#line 2112
      if (tmp___6) {
        {
#line 2112
        tmp___4 = __errno_location();
#line 2112
        tmp___5 = strerror(*tmp___4);
#line 2112
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___5);
        }
      }
    } else {
      {
#line 2112
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 2112
    pr_signals_unblock();
#line 2113
    tmp___19 = setrlimit((__rlimit_resource_t )4, (struct rlimit  const  *)(& rlim));
    }
#line 2113
    if (tmp___19 < 0) {
      {
#line 2114
      pr_signals_block();
      }
#line 2114
      if (! session.disable_id_switching) {
        {
#line 2114
        pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2114);
#line 2114
        tmp___10 = geteuid();
        }
#line 2114
        if (tmp___10 != 0U) {
          {
#line 2114
          tmp___9 = seteuid((__uid_t )0);
          }
#line 2114
          if (tmp___9) {
            {
#line 2114
            tmp___7 = __errno_location();
#line 2114
            tmp___8 = strerror(*tmp___7);
#line 2114
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                       tmp___8);
            }
          }
        }
        {
#line 2114
        tmp___13 = setegid(session.gid);
        }
#line 2114
        if (tmp___13) {
          {
#line 2114
          tmp___11 = __errno_location();
#line 2114
          tmp___12 = strerror(*tmp___11);
#line 2114
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___12);
          }
        }
        {
#line 2114
        tmp___16 = seteuid(session.uid);
        }
#line 2114
        if (tmp___16) {
          {
#line 2114
          tmp___14 = __errno_location();
#line 2114
          tmp___15 = strerror(*tmp___14);
#line 2114
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___15);
          }
        }
      } else {
        {
#line 2114
        pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
        }
      }
      {
#line 2114
      pr_signals_unblock();
#line 2115
      tmp___17 = __errno_location();
#line 2115
      tmp___18 = strerror(*tmp___17);
#line 2115
      pr_log_pri(3, "error: setrlimit(RLIMIT_CORE): %s", tmp___18);
      }
#line 2117
      return;
    }
    {
#line 2119
    pr_signals_block();
    }
#line 2119
    if (! session.disable_id_switching) {
      {
#line 2119
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   2119);
#line 2119
      tmp___23 = geteuid();
      }
#line 2119
      if (tmp___23 != 0U) {
        {
#line 2119
        tmp___22 = seteuid((__uid_t )0);
        }
#line 2119
        if (tmp___22) {
          {
#line 2119
          tmp___20 = __errno_location();
#line 2119
          tmp___21 = strerror(*tmp___20);
#line 2119
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___21);
          }
        }
      }
      {
#line 2119
      tmp___26 = setegid(session.gid);
      }
#line 2119
      if (tmp___26) {
        {
#line 2119
        tmp___24 = __errno_location();
#line 2119
        tmp___25 = strerror(*tmp___24);
#line 2119
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___25);
        }
      }
      {
#line 2119
      tmp___29 = seteuid(session.uid);
      }
#line 2119
      if (tmp___29) {
        {
#line 2119
        tmp___27 = __errno_location();
#line 2119
        tmp___28 = strerror(*tmp___27);
#line 2119
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___28);
        }
      }
    } else {
      {
#line 2119
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 2119
    pr_signals_unblock();
    }
  }
  {
#line 2123
  c = find_config(main_server->conf, 1 << 15, "RLimitCPU", 0);
  }
  {
#line 2126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2126
    if (! c) {
#line 2126
      goto while_break;
    }
#line 2128
    if ((unsigned long )*(c->argv + 1) == (unsigned long )((void *)0)) {
#line 2128
      goto _L;
    } else {
      {
#line 2128
      tmp___60 = strcmp((char const   *)*(c->argv + 1), "daemon");
      }
#line 2128
      if (! tmp___60) {
        _L: /* CIL Label */ 
        {
#line 2129
        cpu_rlimit = (struct rlimit *)*(c->argv + 0);
#line 2131
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2131);
#line 2131
        pr_signals_block();
        }
#line 2131
        if (! session.disable_id_switching) {
          {
#line 2131
          tmp___33 = seteuid((__uid_t )0);
          }
#line 2131
          if (tmp___33) {
            {
#line 2131
            tmp___31 = __errno_location();
#line 2131
            tmp___32 = strerror(*tmp___31);
#line 2131
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___32);
            }
          }
          {
#line 2131
          tmp___36 = setegid((__gid_t )0);
          }
#line 2131
          if (tmp___36) {
            {
#line 2131
            tmp___34 = __errno_location();
#line 2131
            tmp___35 = strerror(*tmp___34);
#line 2131
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___35);
            }
          }
        } else {
          {
#line 2131
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2131
        pr_signals_unblock();
#line 2132
        tmp___49 = setrlimit((__rlimit_resource_t )0, (struct rlimit  const  *)cpu_rlimit);
        }
#line 2132
        if (tmp___49 < 0) {
          {
#line 2133
          pr_signals_block();
          }
#line 2133
          if (! session.disable_id_switching) {
            {
#line 2133
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                         2133);
#line 2133
            tmp___40 = geteuid();
            }
#line 2133
            if (tmp___40 != 0U) {
              {
#line 2133
              tmp___39 = seteuid((__uid_t )0);
              }
#line 2133
              if (tmp___39) {
                {
#line 2133
                tmp___37 = __errno_location();
#line 2133
                tmp___38 = strerror(*tmp___37);
#line 2133
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___38);
                }
              }
            }
            {
#line 2133
            tmp___43 = setegid(session.gid);
            }
#line 2133
            if (tmp___43) {
              {
#line 2133
              tmp___41 = __errno_location();
#line 2133
              tmp___42 = strerror(*tmp___41);
#line 2133
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___42);
              }
            }
            {
#line 2133
            tmp___46 = seteuid(session.uid);
            }
#line 2133
            if (tmp___46) {
              {
#line 2133
              tmp___44 = __errno_location();
#line 2133
              tmp___45 = strerror(*tmp___44);
#line 2133
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___45);
              }
            }
          } else {
            {
#line 2133
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 2133
          pr_signals_unblock();
#line 2134
          tmp___47 = __errno_location();
#line 2134
          tmp___48 = strerror(*tmp___47);
#line 2134
          pr_log_pri(3, "error: setrlimit(RLIMIT_CPU): %s", tmp___48);
          }
#line 2136
          return;
        }
        {
#line 2138
        pr_signals_block();
        }
#line 2138
        if (! session.disable_id_switching) {
          {
#line 2138
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2138);
#line 2138
          tmp___53 = geteuid();
          }
#line 2138
          if (tmp___53 != 0U) {
            {
#line 2138
            tmp___52 = seteuid((__uid_t )0);
            }
#line 2138
            if (tmp___52) {
              {
#line 2138
              tmp___50 = __errno_location();
#line 2138
              tmp___51 = strerror(*tmp___50);
#line 2138
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___51);
              }
            }
          }
          {
#line 2138
          tmp___56 = setegid(session.gid);
          }
#line 2138
          if (tmp___56) {
            {
#line 2138
            tmp___54 = __errno_location();
#line 2138
            tmp___55 = strerror(*tmp___54);
#line 2138
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___55);
            }
          }
          {
#line 2138
          tmp___59 = seteuid(session.uid);
          }
#line 2138
          if (tmp___59) {
            {
#line 2138
            tmp___57 = __errno_location();
#line 2138
            tmp___58 = strerror(*tmp___57);
#line 2138
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___58);
            }
          }
        } else {
          {
#line 2138
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2138
        pr_signals_unblock();
#line 2140
        pr_log_debug(2, "set RLimitCPU for daemon");
        }
      }
    }
    {
#line 2143
    c = find_config_next(c, c->next, 1 << 15, "RLimitCPU", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2147
  c = find_config(main_server->conf, 1 << 15, "RLimitMemory", 0);
  }
  {
#line 2150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2150
    if (! c) {
#line 2150
      goto while_break___0;
    }
#line 2152
    if ((unsigned long )*(c->argv + 1) == (unsigned long )((void *)0)) {
#line 2152
      goto _L___0;
    } else {
      {
#line 2152
      tmp___90 = strcmp((char const   *)*(c->argv + 1), "daemon");
      }
#line 2152
      if (! tmp___90) {
        _L___0: /* CIL Label */ 
        {
#line 2153
        memory_rlimit = (struct rlimit *)*(c->argv + 0);
#line 2155
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2155);
#line 2155
        pr_signals_block();
        }
#line 2155
        if (! session.disable_id_switching) {
          {
#line 2155
          tmp___63 = seteuid((__uid_t )0);
          }
#line 2155
          if (tmp___63) {
            {
#line 2155
            tmp___61 = __errno_location();
#line 2155
            tmp___62 = strerror(*tmp___61);
#line 2155
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___62);
            }
          }
          {
#line 2155
          tmp___66 = setegid((__gid_t )0);
          }
#line 2155
          if (tmp___66) {
            {
#line 2155
            tmp___64 = __errno_location();
#line 2155
            tmp___65 = strerror(*tmp___64);
#line 2155
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___65);
            }
          }
        } else {
          {
#line 2155
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2155
        pr_signals_unblock();
#line 2157
        tmp___79 = setrlimit((__rlimit_resource_t )2, (struct rlimit  const  *)memory_rlimit);
        }
#line 2157
        if (tmp___79 < 0) {
          {
#line 2158
          pr_signals_block();
          }
#line 2158
          if (! session.disable_id_switching) {
            {
#line 2158
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                         2158);
#line 2158
            tmp___70 = geteuid();
            }
#line 2158
            if (tmp___70 != 0U) {
              {
#line 2158
              tmp___69 = seteuid((__uid_t )0);
              }
#line 2158
              if (tmp___69) {
                {
#line 2158
                tmp___67 = __errno_location();
#line 2158
                tmp___68 = strerror(*tmp___67);
#line 2158
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___68);
                }
              }
            }
            {
#line 2158
            tmp___73 = setegid(session.gid);
            }
#line 2158
            if (tmp___73) {
              {
#line 2158
              tmp___71 = __errno_location();
#line 2158
              tmp___72 = strerror(*tmp___71);
#line 2158
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___72);
              }
            }
            {
#line 2158
            tmp___76 = seteuid(session.uid);
            }
#line 2158
            if (tmp___76) {
              {
#line 2158
              tmp___74 = __errno_location();
#line 2158
              tmp___75 = strerror(*tmp___74);
#line 2158
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___75);
              }
            }
          } else {
            {
#line 2158
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 2158
          pr_signals_unblock();
#line 2159
          tmp___77 = __errno_location();
#line 2159
          tmp___78 = strerror(*tmp___77);
#line 2159
          pr_log_pri(3, "error: setrlimit(RLIMIT_DATA): %s", tmp___78);
          }
#line 2161
          return;
        }
        {
#line 2178
        pr_signals_block();
        }
#line 2178
        if (! session.disable_id_switching) {
          {
#line 2178
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2178);
#line 2178
          tmp___83 = geteuid();
          }
#line 2178
          if (tmp___83 != 0U) {
            {
#line 2178
            tmp___82 = seteuid((__uid_t )0);
            }
#line 2178
            if (tmp___82) {
              {
#line 2178
              tmp___80 = __errno_location();
#line 2178
              tmp___81 = strerror(*tmp___80);
#line 2178
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___81);
              }
            }
          }
          {
#line 2178
          tmp___86 = setegid(session.gid);
          }
#line 2178
          if (tmp___86) {
            {
#line 2178
            tmp___84 = __errno_location();
#line 2178
            tmp___85 = strerror(*tmp___84);
#line 2178
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___85);
            }
          }
          {
#line 2178
          tmp___89 = seteuid(session.uid);
          }
#line 2178
          if (tmp___89) {
            {
#line 2178
            tmp___87 = __errno_location();
#line 2178
            tmp___88 = strerror(*tmp___87);
#line 2178
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___88);
            }
          }
        } else {
          {
#line 2178
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2178
        pr_signals_unblock();
#line 2180
        pr_log_debug(2, "set RLimitMemory for daemon");
        }
      }
    }
    {
#line 2183
    c = find_config_next(c, c->next, 1 << 15, "RLimitMemory", 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2187
  c = find_config(main_server->conf, 1 << 15, "RLimitOpenFiles", 0);
  }
  {
#line 2190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2190
    if (! c) {
#line 2190
      goto while_break___1;
    }
#line 2192
    if ((unsigned long )*(c->argv + 1) == (unsigned long )((void *)0)) {
#line 2192
      goto _L___1;
    } else {
      {
#line 2192
      tmp___120 = strcmp((char const   *)*(c->argv + 1), "daemon");
      }
#line 2192
      if (! tmp___120) {
        _L___1: /* CIL Label */ 
        {
#line 2193
        nofile_rlimit = (struct rlimit *)*(c->argv + 0);
#line 2195
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2195);
#line 2195
        pr_signals_block();
        }
#line 2195
        if (! session.disable_id_switching) {
          {
#line 2195
          tmp___93 = seteuid((__uid_t )0);
          }
#line 2195
          if (tmp___93) {
            {
#line 2195
            tmp___91 = __errno_location();
#line 2195
            tmp___92 = strerror(*tmp___91);
#line 2195
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___92);
            }
          }
          {
#line 2195
          tmp___96 = setegid((__gid_t )0);
          }
#line 2195
          if (tmp___96) {
            {
#line 2195
            tmp___94 = __errno_location();
#line 2195
            tmp___95 = strerror(*tmp___94);
#line 2195
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___95);
            }
          }
        } else {
          {
#line 2195
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2195
        pr_signals_unblock();
#line 2197
        tmp___109 = setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)nofile_rlimit);
        }
#line 2197
        if (tmp___109 < 0) {
          {
#line 2198
          pr_signals_block();
          }
#line 2198
          if (! session.disable_id_switching) {
            {
#line 2198
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                         2198);
#line 2198
            tmp___100 = geteuid();
            }
#line 2198
            if (tmp___100 != 0U) {
              {
#line 2198
              tmp___99 = seteuid((__uid_t )0);
              }
#line 2198
              if (tmp___99) {
                {
#line 2198
                tmp___97 = __errno_location();
#line 2198
                tmp___98 = strerror(*tmp___97);
#line 2198
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___98);
                }
              }
            }
            {
#line 2198
            tmp___103 = setegid(session.gid);
            }
#line 2198
            if (tmp___103) {
              {
#line 2198
              tmp___101 = __errno_location();
#line 2198
              tmp___102 = strerror(*tmp___101);
#line 2198
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___102);
              }
            }
            {
#line 2198
            tmp___106 = seteuid(session.uid);
            }
#line 2198
            if (tmp___106) {
              {
#line 2198
              tmp___104 = __errno_location();
#line 2198
              tmp___105 = strerror(*tmp___104);
#line 2198
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___105);
              }
            }
          } else {
            {
#line 2198
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 2198
          pr_signals_unblock();
#line 2199
          tmp___107 = __errno_location();
#line 2199
          tmp___108 = strerror(*tmp___107);
#line 2199
          pr_log_pri(3, "error: setrlimit(RLIMIT_NOFILE): %s", tmp___108);
          }
#line 2201
          return;
        }
        {
#line 2211
        pr_signals_block();
        }
#line 2211
        if (! session.disable_id_switching) {
          {
#line 2211
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2211);
#line 2211
          tmp___113 = geteuid();
          }
#line 2211
          if (tmp___113 != 0U) {
            {
#line 2211
            tmp___112 = seteuid((__uid_t )0);
            }
#line 2211
            if (tmp___112) {
              {
#line 2211
              tmp___110 = __errno_location();
#line 2211
              tmp___111 = strerror(*tmp___110);
#line 2211
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___111);
              }
            }
          }
          {
#line 2211
          tmp___116 = setegid(session.gid);
          }
#line 2211
          if (tmp___116) {
            {
#line 2211
            tmp___114 = __errno_location();
#line 2211
            tmp___115 = strerror(*tmp___114);
#line 2211
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___115);
            }
          }
          {
#line 2211
          tmp___119 = seteuid(session.uid);
          }
#line 2211
          if (tmp___119) {
            {
#line 2211
            tmp___117 = __errno_location();
#line 2211
            tmp___118 = strerror(*tmp___117);
#line 2211
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___118);
            }
          }
        } else {
          {
#line 2211
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2211
        pr_signals_unblock();
#line 2213
        pr_log_debug(2, "set RLimitOpenFiles for daemon");
        }
      }
    }
    {
#line 2216
    c = find_config_next(c, c->next, 1 << 15, "RLimitOpenFiles", 0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2219
  return;
}
}
#line 2221 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
void set_session_rlimits(void) 
{ 
  config_rec *c ;
  struct rlimit *cpu_rlimit ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  __uid_t tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  struct rlimit *memory_rlimit ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  __uid_t tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  __uid_t tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  int *tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  struct rlimit *nofile_rlimit ;
  int *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  int *tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  int *tmp___65 ;
  char *tmp___66 ;
  int tmp___67 ;
  __uid_t tmp___68 ;
  int *tmp___69 ;
  char *tmp___70 ;
  int tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  int *tmp___75 ;
  char *tmp___76 ;
  int tmp___77 ;
  int *tmp___78 ;
  char *tmp___79 ;
  int tmp___80 ;
  __uid_t tmp___81 ;
  int *tmp___82 ;
  char *tmp___83 ;
  int tmp___84 ;
  int *tmp___85 ;
  char *tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;

  {
  {
#line 2222
  c = (config_rec *)((void *)0);
#line 2225
  c = find_config(main_server->conf, 1 << 15, "RLimitCPU", 0);
  }
  {
#line 2228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2228
    if (! c) {
#line 2228
      goto while_break;
    }
#line 2230
    if ((unsigned long )*(c->argv + 1) == (unsigned long )((void *)0)) {
#line 2230
      goto _L;
    } else {
      {
#line 2230
      tmp___28 = strcmp((char const   *)*(c->argv + 1), "session");
      }
#line 2230
      if (! tmp___28) {
        _L: /* CIL Label */ 
        {
#line 2231
        cpu_rlimit = (struct rlimit *)*(c->argv + 0);
#line 2233
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2233);
#line 2233
        pr_signals_block();
        }
#line 2233
        if (! session.disable_id_switching) {
          {
#line 2233
          tmp___1 = seteuid((__uid_t )0);
          }
#line 2233
          if (tmp___1) {
            {
#line 2233
            tmp = __errno_location();
#line 2233
            tmp___0 = strerror(*tmp);
#line 2233
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
            }
          }
          {
#line 2233
          tmp___4 = setegid((__gid_t )0);
          }
#line 2233
          if (tmp___4) {
            {
#line 2233
            tmp___2 = __errno_location();
#line 2233
            tmp___3 = strerror(*tmp___2);
#line 2233
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
            }
          }
        } else {
          {
#line 2233
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2233
        pr_signals_unblock();
#line 2234
        tmp___17 = setrlimit((__rlimit_resource_t )0, (struct rlimit  const  *)cpu_rlimit);
        }
#line 2234
        if (tmp___17 < 0) {
          {
#line 2235
          pr_signals_block();
          }
#line 2235
          if (! session.disable_id_switching) {
            {
#line 2235
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                         2235);
#line 2235
            tmp___8 = geteuid();
            }
#line 2235
            if (tmp___8 != 0U) {
              {
#line 2235
              tmp___7 = seteuid((__uid_t )0);
              }
#line 2235
              if (tmp___7) {
                {
#line 2235
                tmp___5 = __errno_location();
#line 2235
                tmp___6 = strerror(*tmp___5);
#line 2235
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___6);
                }
              }
            }
            {
#line 2235
            tmp___11 = setegid(session.gid);
            }
#line 2235
            if (tmp___11) {
              {
#line 2235
              tmp___9 = __errno_location();
#line 2235
              tmp___10 = strerror(*tmp___9);
#line 2235
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___10);
              }
            }
            {
#line 2235
            tmp___14 = seteuid(session.uid);
            }
#line 2235
            if (tmp___14) {
              {
#line 2235
              tmp___12 = __errno_location();
#line 2235
              tmp___13 = strerror(*tmp___12);
#line 2235
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___13);
              }
            }
          } else {
            {
#line 2235
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 2235
          pr_signals_unblock();
#line 2236
          tmp___15 = __errno_location();
#line 2236
          tmp___16 = strerror(*tmp___15);
#line 2236
          pr_log_pri(3, "error: setrlimit(RLIMIT_CPU): %s", tmp___16);
          }
#line 2238
          return;
        }
        {
#line 2240
        pr_signals_block();
        }
#line 2240
        if (! session.disable_id_switching) {
          {
#line 2240
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2240);
#line 2240
          tmp___21 = geteuid();
          }
#line 2240
          if (tmp___21 != 0U) {
            {
#line 2240
            tmp___20 = seteuid((__uid_t )0);
            }
#line 2240
            if (tmp___20) {
              {
#line 2240
              tmp___18 = __errno_location();
#line 2240
              tmp___19 = strerror(*tmp___18);
#line 2240
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___19);
              }
            }
          }
          {
#line 2240
          tmp___24 = setegid(session.gid);
          }
#line 2240
          if (tmp___24) {
            {
#line 2240
            tmp___22 = __errno_location();
#line 2240
            tmp___23 = strerror(*tmp___22);
#line 2240
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___23);
            }
          }
          {
#line 2240
          tmp___27 = seteuid(session.uid);
          }
#line 2240
          if (tmp___27) {
            {
#line 2240
            tmp___25 = __errno_location();
#line 2240
            tmp___26 = strerror(*tmp___25);
#line 2240
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___26);
            }
          }
        } else {
          {
#line 2240
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2240
        pr_signals_unblock();
#line 2242
        pr_log_debug(2, "set RLimitCPU for session");
        }
      }
    }
    {
#line 2245
    c = find_config_next(c, c->next, 1 << 15, "RLimitCPU", 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2249
  c = find_config(main_server->conf, 1 << 15, "RLimitMemory", 0);
  }
  {
#line 2252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2252
    if (! c) {
#line 2252
      goto while_break___0;
    }
#line 2254
    if ((unsigned long )*(c->argv + 1) == (unsigned long )((void *)0)) {
#line 2254
      goto _L___0;
    } else {
      {
#line 2254
      tmp___58 = strcmp((char const   *)*(c->argv + 1), "session");
      }
#line 2254
      if (! tmp___58) {
        _L___0: /* CIL Label */ 
        {
#line 2255
        memory_rlimit = (struct rlimit *)*(c->argv + 0);
#line 2257
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2257);
#line 2257
        pr_signals_block();
        }
#line 2257
        if (! session.disable_id_switching) {
          {
#line 2257
          tmp___31 = seteuid((__uid_t )0);
          }
#line 2257
          if (tmp___31) {
            {
#line 2257
            tmp___29 = __errno_location();
#line 2257
            tmp___30 = strerror(*tmp___29);
#line 2257
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___30);
            }
          }
          {
#line 2257
          tmp___34 = setegid((__gid_t )0);
          }
#line 2257
          if (tmp___34) {
            {
#line 2257
            tmp___32 = __errno_location();
#line 2257
            tmp___33 = strerror(*tmp___32);
#line 2257
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___33);
            }
          }
        } else {
          {
#line 2257
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2257
        pr_signals_unblock();
#line 2259
        tmp___47 = setrlimit((__rlimit_resource_t )2, (struct rlimit  const  *)memory_rlimit);
        }
#line 2259
        if (tmp___47 < 0) {
          {
#line 2260
          pr_signals_block();
          }
#line 2260
          if (! session.disable_id_switching) {
            {
#line 2260
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                         2260);
#line 2260
            tmp___38 = geteuid();
            }
#line 2260
            if (tmp___38 != 0U) {
              {
#line 2260
              tmp___37 = seteuid((__uid_t )0);
              }
#line 2260
              if (tmp___37) {
                {
#line 2260
                tmp___35 = __errno_location();
#line 2260
                tmp___36 = strerror(*tmp___35);
#line 2260
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___36);
                }
              }
            }
            {
#line 2260
            tmp___41 = setegid(session.gid);
            }
#line 2260
            if (tmp___41) {
              {
#line 2260
              tmp___39 = __errno_location();
#line 2260
              tmp___40 = strerror(*tmp___39);
#line 2260
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___40);
              }
            }
            {
#line 2260
            tmp___44 = seteuid(session.uid);
            }
#line 2260
            if (tmp___44) {
              {
#line 2260
              tmp___42 = __errno_location();
#line 2260
              tmp___43 = strerror(*tmp___42);
#line 2260
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___43);
              }
            }
          } else {
            {
#line 2260
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 2260
          pr_signals_unblock();
#line 2261
          tmp___45 = __errno_location();
#line 2261
          tmp___46 = strerror(*tmp___45);
#line 2261
          pr_log_pri(3, "error: setrlimit(RLIMIT_DATA): %s", tmp___46);
          }
#line 2263
          return;
        }
        {
#line 2280
        pr_signals_block();
        }
#line 2280
        if (! session.disable_id_switching) {
          {
#line 2280
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2280);
#line 2280
          tmp___51 = geteuid();
          }
#line 2280
          if (tmp___51 != 0U) {
            {
#line 2280
            tmp___50 = seteuid((__uid_t )0);
            }
#line 2280
            if (tmp___50) {
              {
#line 2280
              tmp___48 = __errno_location();
#line 2280
              tmp___49 = strerror(*tmp___48);
#line 2280
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___49);
              }
            }
          }
          {
#line 2280
          tmp___54 = setegid(session.gid);
          }
#line 2280
          if (tmp___54) {
            {
#line 2280
            tmp___52 = __errno_location();
#line 2280
            tmp___53 = strerror(*tmp___52);
#line 2280
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___53);
            }
          }
          {
#line 2280
          tmp___57 = seteuid(session.uid);
          }
#line 2280
          if (tmp___57) {
            {
#line 2280
            tmp___55 = __errno_location();
#line 2280
            tmp___56 = strerror(*tmp___55);
#line 2280
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___56);
            }
          }
        } else {
          {
#line 2280
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2280
        pr_signals_unblock();
#line 2282
        pr_log_debug(2, "set RLimitMemory for session");
        }
      }
    }
    {
#line 2285
    c = find_config_next(c, c->next, 1 << 15, "RLimitMemory", 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2289
  c = find_config(main_server->conf, 1 << 15, "RLimitOpenFiles", 0);
  }
  {
#line 2292
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2292
    if (! c) {
#line 2292
      goto while_break___1;
    }
#line 2294
    if ((unsigned long )*(c->argv + 1) == (unsigned long )((void *)0)) {
#line 2294
      goto _L___1;
    } else {
      {
#line 2294
      tmp___88 = strcmp((char const   *)*(c->argv + 1), "session");
      }
#line 2294
      if (! tmp___88) {
        _L___1: /* CIL Label */ 
        {
#line 2295
        nofile_rlimit = (struct rlimit *)*(c->argv + 0);
#line 2297
        pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                     2297);
#line 2297
        pr_signals_block();
        }
#line 2297
        if (! session.disable_id_switching) {
          {
#line 2297
          tmp___61 = seteuid((__uid_t )0);
          }
#line 2297
          if (tmp___61) {
            {
#line 2297
            tmp___59 = __errno_location();
#line 2297
            tmp___60 = strerror(*tmp___59);
#line 2297
            pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___60);
            }
          }
          {
#line 2297
          tmp___64 = setegid((__gid_t )0);
          }
#line 2297
          if (tmp___64) {
            {
#line 2297
            tmp___62 = __errno_location();
#line 2297
            tmp___63 = strerror(*tmp___62);
#line 2297
            pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___63);
            }
          }
        } else {
          {
#line 2297
          pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
          }
        }
        {
#line 2297
        pr_signals_unblock();
#line 2299
        tmp___77 = setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)nofile_rlimit);
        }
#line 2299
        if (tmp___77 < 0) {
          {
#line 2300
          pr_signals_block();
          }
#line 2300
          if (! session.disable_id_switching) {
            {
#line 2300
            pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                         2300);
#line 2300
            tmp___68 = geteuid();
            }
#line 2300
            if (tmp___68 != 0U) {
              {
#line 2300
              tmp___67 = seteuid((__uid_t )0);
              }
#line 2300
              if (tmp___67) {
                {
#line 2300
                tmp___65 = __errno_location();
#line 2300
                tmp___66 = strerror(*tmp___65);
#line 2300
                pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                           tmp___66);
                }
              }
            }
            {
#line 2300
            tmp___71 = setegid(session.gid);
            }
#line 2300
            if (tmp___71) {
              {
#line 2300
              tmp___69 = __errno_location();
#line 2300
              tmp___70 = strerror(*tmp___69);
#line 2300
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                         tmp___70);
              }
            }
            {
#line 2300
            tmp___74 = seteuid(session.uid);
            }
#line 2300
            if (tmp___74) {
              {
#line 2300
              tmp___72 = __errno_location();
#line 2300
              tmp___73 = strerror(*tmp___72);
#line 2300
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                         tmp___73);
              }
            }
          } else {
            {
#line 2300
            pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
            }
          }
          {
#line 2300
          pr_signals_unblock();
#line 2301
          tmp___75 = __errno_location();
#line 2301
          tmp___76 = strerror(*tmp___75);
#line 2301
          pr_log_pri(3, "error: setrlimit(RLIMIT_NOFILE): %s", tmp___76);
          }
#line 2303
          return;
        }
        {
#line 2313
        pr_signals_block();
        }
#line 2313
        if (! session.disable_id_switching) {
          {
#line 2313
          pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                       2313);
#line 2313
          tmp___81 = geteuid();
          }
#line 2313
          if (tmp___81 != 0U) {
            {
#line 2313
            tmp___80 = seteuid((__uid_t )0);
            }
#line 2313
            if (tmp___80) {
              {
#line 2313
              tmp___78 = __errno_location();
#line 2313
              tmp___79 = strerror(*tmp___78);
#line 2313
              pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s",
                         tmp___79);
              }
            }
          }
          {
#line 2313
          tmp___84 = setegid(session.gid);
          }
#line 2313
          if (tmp___84) {
            {
#line 2313
            tmp___82 = __errno_location();
#line 2313
            tmp___83 = strerror(*tmp___82);
#line 2313
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s",
                       tmp___83);
            }
          }
          {
#line 2313
          tmp___87 = seteuid(session.uid);
          }
#line 2313
          if (tmp___87) {
            {
#line 2313
            tmp___85 = __errno_location();
#line 2313
            tmp___86 = strerror(*tmp___85);
#line 2313
            pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s",
                       tmp___86);
            }
          }
        } else {
          {
#line 2313
          pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
          }
        }
        {
#line 2313
        pr_signals_unblock();
#line 2315
        pr_log_debug(2, "set RLimitOpenFiles for session");
        }
      }
    }
    {
#line 2318
    c = find_config_next(c, c->next, 1 << 15, "RLimitOpenFiles", 0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2321
  return;
}
}
#line 2323 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void daemonize(void) 
{ 
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2330
  tmp = fork();
  }
  {
#line 2331
  if (tmp == -1) {
#line 2331
    goto case_neg_1;
  }
#line 2335
  if (tmp == 0) {
#line 2335
    goto case_0;
  }
#line 2338
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 2332
  perror("fork");
#line 2333
  exit(1);
  }
  case_0: /* CIL Label */ 
#line 2336
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2339
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 2346
  setsid();
#line 2360
  tmp___0 = fileno(stdin);
#line 2360
  close(tmp___0);
#line 2361
  tmp___1 = fileno(stdout);
#line 2361
  close(tmp___1);
#line 2362
  tmp___2 = fileno(stderr);
#line 2362
  close(tmp___2);
#line 2367
  tmp___3 = getpid();
#line 2367
  setpgid(0, tmp___3);
#line 2380
  mpid = getpid();
#line 2382
  pr_fsio_chdir("/", 0);
  }
#line 2383
  return;
}
}
#line 2385 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void inetd_main(void) 
{ 
  int res ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  __uid_t tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 2386
  res = 0;
#line 2389
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
               2389);
#line 2389
  pr_signals_block();
  }
#line 2389
  if (! session.disable_id_switching) {
    {
#line 2389
    tmp___1 = seteuid((__uid_t )0);
    }
#line 2389
    if (tmp___1) {
      {
#line 2389
      tmp = __errno_location();
#line 2389
      tmp___0 = strerror(*tmp);
#line 2389
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___0);
      }
    }
    {
#line 2389
    tmp___4 = setegid((__gid_t )0);
    }
#line 2389
    if (tmp___4) {
      {
#line 2389
      tmp___2 = __errno_location();
#line 2389
      tmp___3 = strerror(*tmp___2);
#line 2389
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___3);
      }
    }
  } else {
    {
#line 2389
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 2389
  pr_signals_unblock();
#line 2390
  res = pr_open_scoreboard(2);
  }
#line 2390
  if (res < 0) {
    {
#line 2391
    pr_signals_block();
    }
#line 2391
    if (! session.disable_id_switching) {
      {
#line 2391
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   2391);
#line 2391
      tmp___8 = geteuid();
      }
#line 2391
      if (tmp___8 != 0U) {
        {
#line 2391
        tmp___7 = seteuid((__uid_t )0);
        }
#line 2391
        if (tmp___7) {
          {
#line 2391
          tmp___5 = __errno_location();
#line 2391
          tmp___6 = strerror(*tmp___5);
#line 2391
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___6);
          }
        }
      }
      {
#line 2391
      tmp___11 = setegid(session.gid);
      }
#line 2391
      if (tmp___11) {
        {
#line 2391
        tmp___9 = __errno_location();
#line 2391
        tmp___10 = strerror(*tmp___9);
#line 2391
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___10);
        }
      }
      {
#line 2391
      tmp___14 = seteuid(session.uid);
      }
#line 2391
      if (tmp___14) {
        {
#line 2391
        tmp___12 = __errno_location();
#line 2391
        tmp___13 = strerror(*tmp___12);
#line 2391
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___13);
        }
      }
    } else {
      {
#line 2391
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 2391
    pr_signals_unblock();
    }
    {
#line 2394
    if (res == -2) {
#line 2394
      goto case_neg_2;
    }
#line 2399
    if (res == -4) {
#line 2399
      goto case_neg_4;
    }
#line 2399
    if (res == -3) {
#line 2399
      goto case_neg_4;
    }
#line 2411
    goto switch_default;
    case_neg_2: /* CIL Label */ 
    {
#line 2395
    pr_log_pri(3, "error opening scoreboard: bad/corrupted file");
    }
#line 2396
    return;
    case_neg_4: /* CIL Label */ 
    case_neg_3: /* CIL Label */ 
    {
#line 2400
    pr_log_pri(3, "error opening scoreboard: wrong version, writing new scoreboard");
#line 2406
    pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 2406);
#line 2406
    pr_signals_block();
    }
#line 2406
    if (! session.disable_id_switching) {
      {
#line 2406
      tmp___17 = seteuid((__uid_t )0);
      }
#line 2406
      if (tmp___17) {
        {
#line 2406
        tmp___15 = __errno_location();
#line 2406
        tmp___16 = strerror(*tmp___15);
#line 2406
        pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___16);
        }
      }
      {
#line 2406
      tmp___20 = setegid((__gid_t )0);
      }
#line 2406
      if (tmp___20) {
        {
#line 2406
        tmp___18 = __errno_location();
#line 2406
        tmp___19 = strerror(*tmp___18);
#line 2406
        pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___19);
        }
      }
    } else {
      {
#line 2406
      pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
      }
    }
    {
#line 2406
    pr_signals_unblock();
#line 2407
    pr_delete_scoreboard();
#line 2408
    pr_open_scoreboard(2);
    }
#line 2409
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2412
    tmp___21 = __errno_location();
#line 2412
    tmp___22 = strerror(*tmp___21);
#line 2412
    pr_log_pri(3, "error opening scoreboard: %s", tmp___22);
    }
#line 2414
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2417
  pr_signals_block();
  }
#line 2417
  if (! session.disable_id_switching) {
    {
#line 2417
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 2417);
#line 2417
    tmp___26 = geteuid();
    }
#line 2417
    if (tmp___26 != 0U) {
      {
#line 2417
      tmp___25 = seteuid((__uid_t )0);
      }
#line 2417
      if (tmp___25) {
        {
#line 2417
        tmp___23 = __errno_location();
#line 2417
        tmp___24 = strerror(*tmp___23);
#line 2417
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___24);
        }
      }
    }
    {
#line 2417
    tmp___29 = setegid(session.gid);
    }
#line 2417
    if (tmp___29) {
      {
#line 2417
      tmp___27 = __errno_location();
#line 2417
      tmp___28 = strerror(*tmp___27);
#line 2417
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___28);
      }
    }
    {
#line 2417
    tmp___32 = seteuid(session.uid);
    }
#line 2417
    if (tmp___32) {
      {
#line 2417
      tmp___30 = __errno_location();
#line 2417
      tmp___31 = strerror(*tmp___30);
#line 2417
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___31);
      }
    }
  } else {
    {
#line 2417
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 2417
  pr_signals_unblock();
#line 2418
  pr_close_scoreboard();
#line 2420
  pr_event_generate("core.startup", (void const   *)((void *)0));
#line 2422
  init_bindings();
#line 2425
  tmp___33 = check_shutmsg(& shut, & deny, & disc, shutmsg, (size_t )sizeof(shutmsg));
  }
#line 2425
  if (tmp___33 == 1) {
#line 2426
    shutdownp = 1;
  }
  {
#line 2431
  fork_server(0, main_server->listen, (unsigned char)1);
  }
#line 2432
  return;
}
}
#line 2434 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void standalone_main(void) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  __uid_t tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  __uid_t tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 2435
  res = 0;
#line 2437
  if (nodaemon) {
#line 2438
    if (quiet) {
#line 2438
      tmp = 0;
    } else {
#line 2438
      tmp = 1;
    }
    {
#line 2438
    log_stderr(tmp);
#line 2439
    tmp___0 = fileno(stdin);
#line 2439
    close(tmp___0);
#line 2440
    tmp___1 = fileno(stdout);
#line 2440
    close(tmp___1);
    }
  } else {
    {
#line 2443
    log_stderr(0);
#line 2444
    daemonize();
    }
  }
  {
#line 2447
  pr_log_debug(9, "ROOT PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
               2447);
#line 2447
  pr_signals_block();
  }
#line 2447
  if (! session.disable_id_switching) {
    {
#line 2447
    tmp___4 = seteuid((__uid_t )0);
    }
#line 2447
    if (tmp___4) {
      {
#line 2447
      tmp___2 = __errno_location();
#line 2447
      tmp___3 = strerror(*tmp___2);
#line 2447
      pr_log_pri(3, "PRIVS_ROOT: unable to seteuid(): %s", tmp___3);
      }
    }
    {
#line 2447
    tmp___7 = setegid((__gid_t )0);
    }
#line 2447
    if (tmp___7) {
      {
#line 2447
      tmp___5 = __errno_location();
#line 2447
      tmp___6 = strerror(*tmp___5);
#line 2447
      pr_log_pri(3, "PRIVS_ROOT: unable to setegid(): %s", tmp___6);
      }
    }
  } else {
    {
#line 2447
    pr_log_debug(9, "ROOT PRIVS: ID switching disabled");
    }
  }
  {
#line 2447
  pr_signals_unblock();
#line 2448
  pr_delete_scoreboard();
#line 2449
  res = pr_open_scoreboard(2);
  }
#line 2449
  if (res < 0) {
    {
#line 2450
    pr_signals_block();
    }
#line 2450
    if (! session.disable_id_switching) {
      {
#line 2450
      pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                   2450);
#line 2450
      tmp___11 = geteuid();
      }
#line 2450
      if (tmp___11 != 0U) {
        {
#line 2450
        tmp___10 = seteuid((__uid_t )0);
        }
#line 2450
        if (tmp___10) {
          {
#line 2450
          tmp___8 = __errno_location();
#line 2450
          tmp___9 = strerror(*tmp___8);
#line 2450
          pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___9);
          }
        }
      }
      {
#line 2450
      tmp___14 = setegid(session.gid);
      }
#line 2450
      if (tmp___14) {
        {
#line 2450
        tmp___12 = __errno_location();
#line 2450
        tmp___13 = strerror(*tmp___12);
#line 2450
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___13);
        }
      }
      {
#line 2450
      tmp___17 = seteuid(session.uid);
      }
#line 2450
      if (tmp___17) {
        {
#line 2450
        tmp___15 = __errno_location();
#line 2450
        tmp___16 = strerror(*tmp___15);
#line 2450
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___16);
        }
      }
    } else {
      {
#line 2450
      pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
      }
    }
    {
#line 2450
    pr_signals_unblock();
    }
    {
#line 2453
    if (res == -2) {
#line 2453
      goto case_neg_2;
    }
#line 2458
    if (res == -3) {
#line 2458
      goto case_neg_3;
    }
#line 2463
    if (res == -4) {
#line 2463
      goto case_neg_4;
    }
#line 2468
    goto switch_default;
    case_neg_2: /* CIL Label */ 
    {
#line 2454
    pr_log_pri(3, "error opening scoreboard: bad/corrupted file");
    }
#line 2456
    return;
    case_neg_3: /* CIL Label */ 
    {
#line 2459
    pr_log_pri(3, "error opening scoreboard: bad version (too old)");
    }
#line 2461
    return;
    case_neg_4: /* CIL Label */ 
    {
#line 2464
    pr_log_pri(3, "error opening scoreboard: bad version (too new)");
    }
#line 2466
    return;
    switch_default: /* CIL Label */ 
    {
#line 2469
    tmp___18 = __errno_location();
#line 2469
    tmp___19 = strerror(*tmp___18);
#line 2469
    pr_log_pri(3, "error opening scoreboard: %s", tmp___19);
    }
#line 2470
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 2473
  pr_signals_block();
  }
#line 2473
  if (! session.disable_id_switching) {
    {
#line 2473
    pr_log_debug(9, "RELINQUISH PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
                 2473);
#line 2473
    tmp___23 = geteuid();
    }
#line 2473
    if (tmp___23 != 0U) {
      {
#line 2473
      tmp___22 = seteuid((__uid_t )0);
      }
#line 2473
      if (tmp___22) {
        {
#line 2473
        tmp___20 = __errno_location();
#line 2473
        tmp___21 = strerror(*tmp___20);
#line 2473
        pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(PR_ROOT_UID): %s", tmp___21);
        }
      }
    }
    {
#line 2473
    tmp___26 = setegid(session.gid);
    }
#line 2473
    if (tmp___26) {
      {
#line 2473
      tmp___24 = __errno_location();
#line 2473
      tmp___25 = strerror(*tmp___24);
#line 2473
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to setegid(session.gid): %s", tmp___25);
      }
    }
    {
#line 2473
    tmp___29 = seteuid(session.uid);
    }
#line 2473
    if (tmp___29) {
      {
#line 2473
      tmp___27 = __errno_location();
#line 2473
      tmp___28 = strerror(*tmp___27);
#line 2473
      pr_log_pri(3, "PRIVS_RELINQUISH: unable to seteuid(session.uid): %s", tmp___28);
      }
    }
  } else {
    {
#line 2473
    pr_log_debug(9, "PRIVS_RELINQUISH: ID switching disabled");
    }
  }
  {
#line 2473
  pr_signals_unblock();
#line 2474
  pr_close_scoreboard();
#line 2476
  pr_event_generate("core.startup", (void const   *)((void *)0));
#line 2478
  init_bindings();
#line 2480
  pr_log_pri(5, "ProFTPD %s (built %s) standalone mode STARTUP", "1.3.2 (stable)",
             "2009. 09. 16. (\354\210\230) 15:22:21 KST");
#line 2483
  pr_pidfile_write();
#line 2484
  daemon_loop();
  }
#line 2485
  return;
}
}
#line 2491 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static struct option opts[16]  = 
#line 2491
  {      {"nocollision", 0, (int *)((void *)0), 'N'}, 
        {"nodaemon", 0, (int *)((void *)0), 'n'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"debug", 1, (int *)((void *)0), 'd'}, 
        {"define", 1, (int *)((void *)0), 'D'}, 
        {"config", 1, (int *)((void *)0), 'c'}, 
        {"persistent", 1, (int *)((void *)0), 'p'}, 
        {"list", 0, (int *)((void *)0), 'l'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"settings", 0, (int *)((void *)0), 'V'}, 
        {"version-status", 0, (int *)((void *)0), 1}, 
        {"configtest", 0, (int *)((void *)0), 't'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"ipv4", 0, (int *)((void *)0), '4'}, 
        {"ipv6", 0, (int *)((void *)0), '6'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 2511 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void show_settings(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 2512
  printf((char const   */* __restrict  */)"Compile-time Settings:\n");
#line 2513
  printf((char const   */* __restrict  */)"  Version: 1.3.2 (stable)\n");
#line 2514
  printf((char const   */* __restrict  */)"  Platform: LINUX\n");
#line 2515
  printf((char const   */* __restrict  */)"  Built: 2009. 09. 16. (\354\210\230) 15:22:21 KST\n");
#line 2516
  printf((char const   */* __restrict  */)"  Built With:\n    configure \n\n");
#line 2518
  printf((char const   */* __restrict  */)"  CFLAGS: -O2 -Wall\n");
#line 2519
  printf((char const   */* __restrict  */)"  LDFLAGS: -L$(top_srcdir)/lib \n");
#line 2520
  printf((char const   */* __restrict  */)"  LIBS:  -L$(top_srcdir)/lib/libcap -lcap -lsupp -lcrypt \n");
#line 2522
  printf((char const   */* __restrict  */)"\n  Files:\n");
#line 2523
  printf((char const   */* __restrict  */)"    Configuration File:\n");
#line 2524
  printf((char const   */* __restrict  */)"      /usr/local/etc/proftpd.conf\n");
#line 2525
  printf((char const   */* __restrict  */)"    Pid File:\n");
#line 2526
  printf((char const   */* __restrict  */)"      /usr/local/var/proftpd.pid\n");
#line 2527
  printf((char const   */* __restrict  */)"    Scoreboard File:\n");
#line 2528
  printf((char const   */* __restrict  */)"      /usr/local/var/proftpd/proftpd.scoreboard\n");
#line 2537
  printf((char const   */* __restrict  */)"\n  Features:\n");
#line 2541
  printf((char const   */* __restrict  */)"    - Autoshadow support\n");
#line 2547
  printf((char const   */* __restrict  */)"    - Controls support\n");
#line 2551
  printf((char const   */* __restrict  */)"    + curses support\n");
#line 2559
  printf((char const   */* __restrict  */)"    - Developer support\n");
#line 2565
  printf((char const   */* __restrict  */)"    - DSO support\n");
#line 2569
  printf((char const   */* __restrict  */)"    + IPv6 support\n");
#line 2575
  printf((char const   */* __restrict  */)"    + Largefile support\n");
#line 2583
  printf((char const   */* __restrict  */)"    - Lastlog support\n");
#line 2587
  printf((char const   */* __restrict  */)"    + ncurses support\n");
#line 2595
  printf((char const   */* __restrict  */)"    - NLS support\n");
#line 2601
  printf((char const   */* __restrict  */)"    - OpenSSL support\n");
#line 2607
  printf((char const   */* __restrict  */)"    - POSIX ACL support\n");
#line 2611
  printf((char const   */* __restrict  */)"    + Shadow file support\n");
#line 2617
  printf((char const   */* __restrict  */)"    + Sendfile support\n");
#line 2623
  printf((char const   */* __restrict  */)"    + Trace support\n");
#line 2629
  printf((char const   */* __restrict  */)"\n  Tunable Options:\n");
#line 2630
  printf((char const   */* __restrict  */)"    PR_TUNABLE_BUFFER_SIZE = %u\n", 1024);
#line 2631
  printf((char const   */* __restrict  */)"    PR_TUNABLE_GLOBBING_MAX = %u\n", 8);
#line 2632
  printf((char const   */* __restrict  */)"    PR_TUNABLE_HASH_TABLE_SIZE = %u\n",
         40);
#line 2633
  printf((char const   */* __restrict  */)"    PR_TUNABLE_NEW_POOL_SIZE = %u\n", 512);
#line 2634
  printf((char const   */* __restrict  */)"    PR_TUNABLE_SCOREBOARD_BUFFER_SIZE = %u\n",
         80);
#line 2636
  printf((char const   */* __restrict  */)"    PR_TUNABLE_SCOREBOARD_SCRUB_TIMER = %u\n",
         30);
#line 2638
  printf((char const   */* __restrict  */)"    PR_TUNABLE_SELECT_TIMEOUT = %u\n",
         30);
#line 2639
  printf((char const   */* __restrict  */)"    PR_TUNABLE_TIMEOUTIDENT = %u\n", 10);
#line 2640
  printf((char const   */* __restrict  */)"    PR_TUNABLE_TIMEOUTIDLE = %u\n", 600);
#line 2641
  printf((char const   */* __restrict  */)"    PR_TUNABLE_TIMEOUTLINGER = %u\n", 30);
#line 2642
  printf((char const   */* __restrict  */)"    PR_TUNABLE_TIMEOUTLOGIN = %u\n", 300);
#line 2643
  printf((char const   */* __restrict  */)"    PR_TUNABLE_TIMEOUTNOXFER = %u\n", 300);
#line 2644
  printf((char const   */* __restrict  */)"    PR_TUNABLE_TIMEOUTSTALLED = %u\n",
         3600);
#line 2645
  printf((char const   */* __restrict  */)"    PR_TUNABLE_XFER_SCOREBOARD_UPDATES = %u\n\n",
         10);
  }
#line 2647
  return;
}
}
#line 2649 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static struct option_help opts_help[16]  = 
#line 2649
  {      {"--help", "-h", "Display proftpd usage"}, 
        {"--nocollision", "-N", "Disable address/port collision checking"}, 
        {"--nodaemon", "-n", "Disable background daemon mode (and send all output to stderr)"}, 
        {"--quiet",
      "-q", "Don\'t send output to stderr when running with -n or --nodaemon"}, 
        {"--debug", "-d [level]", "Set debugging level (0-10, 10 = most debugging)"}, 
        {"--define",
      "-D [definition]", "Set arbitrary IfDefine definition"}, 
        {"--config", "-c [config-file]", "Specify alternate configuration file"}, 
        {"--persistent", "-p [0|1]", "Enable/disable default persistent passwd support"}, 
        {"--list",
      "-l", "List all compiled-in modules"}, 
        {"--configtest", "-t", "Test the syntax of the specified config"}, 
        {"--settings", "-V", "Print compile-time settings and exit"}, 
        {"--version", "-v", "Print version number and exit"}, 
        {"--version-status", "-vv", "Print extended version information and exit"}, 
        {"--ipv4", "-4", "Support IPv4 connections only"}, 
        {"--ipv6", "-6", "Support IPv6 connections"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 2685 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
static void show_usage(int exit_code ) 
{ 
  struct option_help *h ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2688
  printf((char const   */* __restrict  */)"usage: proftpd [options]\n");
#line 2689
  h = opts_help;
  }
  {
#line 2689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2689
    if (! h->long_opt) {
#line 2689
      goto while_break;
    }
    {
#line 2691
    printf((char const   */* __restrict  */)" %s, %s\n ", h->short_opt, h->long_opt);
#line 2695
    printf((char const   */* __restrict  */)"    %s\n", h->desc);
#line 2689
    h ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2698
  exit(exit_code);
  }
}
}
#line 2701 "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c"
int main(int argc , char **argv , char **envp ) 
{ 
  int optc ;
  int show_version ;
  char const   *cmdopts ;
  mode_t *main_umask ;
  socklen_t peerlen ;
  struct sockaddr peer ;
  time_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  uid_t *uid ;
  void *tmp___12 ;
  gid_t *gid ;
  void *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  __uid_t tmp___38 ;
  __uid_t tmp___39 ;
  __uid_t tmp___40 ;
  __gid_t tmp___41 ;
  __gid_t tmp___42 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
  {
#line 2702
  show_version = 0;
#line 2703
  cmdopts = "D:NVc:d:hlnp:qtv46";
#line 2704
  main_umask = (mode_t *)((void *)0);
#line 2715
  tzset();
#line 2718
  memset((void *)(& session), 0, (size_t )sizeof(session));
#line 2720
  pr_proctitle_init(argc, argv, envp);
#line 2723
  tmp = time((time_t *)((void *)0));
#line 2723
  tmp___0 = getpid();
#line 2723
  srand((unsigned int )(tmp * (time_t )tmp___0));
#line 2726
  peerlen = (socklen_t )sizeof(peer);
#line 2727
  memset((void *)(& peer), 0, peerlen);
#line 2728
  tmp___1 = fileno(stdin);
#line 2728
  tmp___2 = getpeername(tmp___1, (struct sockaddr */* __restrict  */)(& peer), (socklen_t */* __restrict  */)(& peerlen));
  }
#line 2728
  if (tmp___2 != -1) {
    {
#line 2729
    log_stderr(0);
    }
  }
  {
#line 2732
  log_opensyslog((char const   *)((void *)0));
#line 2735
  init_pools();
#line 2763
  opterr = 0;
  }
  {
#line 2764
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2764
    optc = getopt_long(argc, (char * const  *)argv, cmdopts, (struct option  const  *)(opts),
                       (int *)((void *)0));
    }
#line 2764
    if (! (optc != -1)) {
#line 2764
      goto while_break;
    }
    {
#line 2773
    if (optc == 68) {
#line 2773
      goto case_68;
    }
#line 2782
    if (optc == 86) {
#line 2782
      goto case_86;
    }
#line 2787
    if (optc == 78) {
#line 2787
      goto case_78;
    }
#line 2791
    if (optc == 110) {
#line 2791
      goto case_110;
    }
#line 2795
    if (optc == 113) {
#line 2795
      goto case_113;
    }
#line 2799
    if (optc == 100) {
#line 2799
      goto case_100;
    }
#line 2807
    if (optc == 99) {
#line 2807
      goto case_99;
    }
#line 2820
    if (optc == 108) {
#line 2820
      goto case_108;
    }
#line 2825
    if (optc == 116) {
#line 2825
      goto case_116;
    }
#line 2831
    if (optc == 112) {
#line 2831
      goto case_112;
    }
#line 2841
    if (optc == 118) {
#line 2841
      goto case_118;
    }
#line 2845
    if (optc == 1) {
#line 2845
      goto case_1;
    }
#line 2849
    if (optc == 104) {
#line 2849
      goto case_104;
    }
#line 2853
    if (optc == 4) {
#line 2853
      goto case_4;
    }
#line 2857
    if (optc == 6) {
#line 2857
      goto case_6;
    }
#line 2861
    if (optc == 63) {
#line 2861
      goto case_63;
    }
#line 2771
    goto switch_break;
    case_68: /* CIL Label */ 
#line 2774
    if (! optarg) {
      {
#line 2775
      pr_log_pri(3, "Fatal: -D requires definition argument");
#line 2776
      exit(1);
      }
    }
    {
#line 2779
    pr_define_add((char const   *)optarg);
    }
#line 2780
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 2783
    show_settings();
#line 2784
    exit(0);
    }
#line 2785
    goto switch_break;
    case_78: /* CIL Label */ 
#line 2788
    AddressCollisionCheck = (char)0;
#line 2789
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2792
    nodaemon ++;
#line 2793
    goto switch_break;
    case_113: /* CIL Label */ 
#line 2796
    quiet ++;
#line 2797
    goto switch_break;
    case_100: /* CIL Label */ 
#line 2800
    if (! optarg) {
      {
#line 2801
      pr_log_pri(3, "Fatal: -d requires debugging level argument.");
#line 2802
      exit(1);
      }
    }
    {
#line 2804
    tmp___3 = atoi((char const   *)optarg);
#line 2804
    pr_log_setdebuglevel(tmp___3);
    }
#line 2805
    goto switch_break;
    case_99: /* CIL Label */ 
#line 2808
    if (! optarg) {
      {
#line 2809
      pr_log_pri(3, "Fatal: -c requires configuration path argument.");
#line 2811
      exit(1);
      }
    }
    {
#line 2817
    tmp___4 = strdup((char const   *)optarg);
#line 2817
    config_filename = (char const   *)tmp___4;
    }
#line 2818
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 2821
    modules_list(2);
#line 2822
    exit(0);
    }
#line 2823
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 2826
    syntax_check = 1;
#line 2827
    printf((char const   */* __restrict  */)"Checking syntax of configuration file\n");
#line 2828
    fflush(stdout);
    }
#line 2829
    goto switch_break;
    case_112: /* CIL Label */ 
#line 2832
    if (! optarg) {
      {
#line 2834
      pr_log_pri(3, "Fatal: -p requires boolean (0|1) argument.");
#line 2835
      exit(1);
      }
    } else {
      {
#line 2832
      tmp___5 = atoi((char const   *)optarg);
#line 2832
      persistent_passwd = (unsigned char )tmp___5;
      }
#line 2832
      if ((int )persistent_passwd != 1) {
#line 2832
        if ((int )persistent_passwd != 0) {
          {
#line 2834
          pr_log_pri(3, "Fatal: -p requires boolean (0|1) argument.");
#line 2835
          exit(1);
          }
        }
      }
    }
#line 2838
    goto switch_break;
    case_118: /* CIL Label */ 
#line 2842
    show_version ++;
#line 2843
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2846
    show_version = 2;
#line 2847
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 2850
    show_usage(0);
    }
#line 2851
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 2854
    pr_netaddr_disable_ipv6();
    }
#line 2855
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 2858
    pr_netaddr_enable_ipv6();
    }
#line 2859
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 2862
    pr_log_pri(3, "unknown option: %c", (int )((char )optopt));
#line 2863
    show_usage(1);
    }
#line 2864
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2869
  if (*(argv + optind)) {
    {
#line 2870
    pr_log_pri(3, "unknown parameter: \'%s\'", *(argv + optind));
#line 2871
    exit(1);
    }
  }
#line 2874
  if (show_version) {
#line 2874
    if (show_version == 1) {
      {
#line 2876
      printf((char const   */* __restrict  */)"ProFTPD Version 1.3.2\n");
#line 2877
      exit(0);
      }
    }
  }
  {
#line 2880
  mpid = getpid();
#line 2883
  init_pools();
#line 2884
  init_regexp();
#line 2885
  init_log();
#line 2886
  init_inet();
#line 2887
  init_netio();
#line 2888
  init_netaddr();
#line 2889
  init_fs();
#line 2890
  init_class();
#line 2891
  free_bindings();
#line 2892
  init_config();
#line 2893
  init_stash();
#line 2899
  var_init();
#line 2900
  modules_init();
#line 2906
  tmp___6 = pr_fs_valid_path(config_filename);
  }
#line 2906
  if (tmp___6 < 0) {
    {
#line 2907
    pr_log_pri(3, "Fatal: -c requires an absolute path");
#line 2908
    exit(1);
    }
  }
  {
#line 2911
  pr_parser_prepare((pool *)((void *)0), (xaset_t **)((void *)0));
#line 2913
  pr_event_generate("core.preparse", (void const   *)((void *)0));
#line 2915
  tmp___9 = pr_parser_parse_file((pool *)((void *)0), config_filename, (config_rec *)((void *)0),
                                 0);
  }
#line 2915
  if (tmp___9 == -1) {
    {
#line 2916
    tmp___7 = __errno_location();
#line 2916
    tmp___8 = strerror(*tmp___7);
#line 2916
    pr_log_pri(3, "Fatal: unable to read configuration file \'%s\': %s", config_filename,
               tmp___8);
#line 2918
    exit(1);
    }
  }
  {
#line 2921
  tmp___10 = pr_parser_cleanup();
  }
#line 2921
  if (tmp___10 < 0) {
    {
#line 2922
    pr_log_pri(3, "Fatal: error processing configuration file \'%s\': unclosed configuration section",
               config_filename);
#line 2924
    exit(1);
    }
  }
  {
#line 2927
  tmp___11 = fixup_servers(server_list);
  }
#line 2927
  if (tmp___11 < 0) {
    {
#line 2928
    pr_log_pri(3, "Fatal: error processing configuration file \'%s\'", config_filename);
#line 2930
    exit(1);
    }
  }
  {
#line 2937
  pr_event_generate("core.postparse", (void const   *)((void *)0));
  }
#line 2939
  if (show_version) {
#line 2939
    if (show_version == 2) {
      {
#line 2942
      printf((char const   */* __restrict  */)"ProFTPD Version: %s", "1.3.2 (stable)\n");
#line 2943
      printf((char const   */* __restrict  */)"  Scoreboard Version: %08x\n", 17039362);
#line 2944
      printf((char const   */* __restrict  */)"  Built: %s\n\n", "2009. 09. 16. (\354\210\230) 15:22:21 KST");
#line 2946
      modules_list(1);
#line 2947
      exit(0);
      }
    }
  }
#line 2951
  if (syntax_check) {
    {
#line 2952
    printf((char const   */* __restrict  */)"Syntax check complete.\n");
#line 2953
    end_login(0);
    }
  }
  {
#line 2959
  endpwent();
#line 2960
  endgrent();
#line 2964
  tmp___12 = get_param_ptr(main_server->conf, "UserID", 0);
#line 2964
  uid = (uid_t *)tmp___12;
#line 2965
  tmp___13 = get_param_ptr(main_server->conf, "GroupID", 0);
#line 2965
  gid = (gid_t *)tmp___13;
  }
#line 2967
  if (uid) {
#line 2968
    daemon_uid = *uid;
  } else {
#line 2970
    daemon_uid = (uid_t )0;
  }
#line 2972
  if (gid) {
#line 2973
    daemon_gid = *gid;
  } else {
#line 2975
    daemon_gid = (gid_t )0;
  }
#line 2978
  if (daemon_uid != 0U) {
    {
#line 2980
    daemon_gids = make_array(permanent_pool, 2U, (size_t )sizeof(gid_t ));
#line 2982
    tmp___14 = get_param_ptr(main_server->conf, "UserName", 0);
#line 2982
    tmp___15 = pr_auth_getgroups(permanent_pool, (char const   *)tmp___14, & daemon_gids,
                                 (array_header **)((void *)0));
    }
#line 2982
    if (tmp___15 < 0) {
      {
#line 2984
      pr_log_debug(2, "unable to retrieve daemon supplemental groups");
      }
    }
    {
#line 2986
    tmp___18 = set_groups(permanent_pool, daemon_gid, daemon_gids);
    }
#line 2986
    if (tmp___18 < 0) {
      {
#line 2987
      tmp___16 = __errno_location();
#line 2987
      tmp___17 = strerror(*tmp___16);
#line 2987
      pr_log_pri(3, "unable to set daemon groups: %s", tmp___17);
      }
    }
  }
  {
#line 2991
  tmp___19 = get_param_ptr(main_server->conf, "Umask", 0);
#line 2991
  main_umask = (mode_t *)tmp___19;
  }
#line 2991
  if ((unsigned long )main_umask == (unsigned long )((void *)0)) {
    {
#line 2993
    umask((mode_t )18);
    }
  } else {
    {
#line 2995
    umask(*main_umask);
    }
  }
  {
#line 3002
  pr_log_debug(9, "SETUP PRIVS at %s:%d", "/home/pronto/abs/test-suite/proftpd-1.3.2/src/main.c",
               3002);
#line 3002
  pr_signals_block();
#line 3002
  tmp___38 = getuid();
  }
#line 3002
  if (tmp___38 != 0U) {
    {
#line 3002
    session.uid = getuid();
#line 3002
    session.ouid = session.uid;
#line 3002
    session.gid = getgid();
#line 3002
    tmp___22 = setgid(session.gid);
    }
#line 3002
    if (tmp___22) {
      {
#line 3002
      tmp___20 = __errno_location();
#line 3002
      tmp___21 = strerror(*tmp___20);
#line 3002
      pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___21);
      }
    }
    {
#line 3002
    tmp___25 = setuid(session.uid);
    }
#line 3002
    if (tmp___25) {
      {
#line 3002
      tmp___23 = __errno_location();
#line 3002
      tmp___24 = strerror(*tmp___23);
#line 3002
      pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___24);
      }
    }
    {
#line 3002
    tmp___28 = seteuid(session.uid);
    }
#line 3002
    if (tmp___28) {
      {
#line 3002
      tmp___26 = __errno_location();
#line 3002
      tmp___27 = strerror(*tmp___26);
#line 3002
      pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___27);
      }
    }
  } else {
    {
#line 3002
    session.ouid = getuid();
#line 3002
    session.uid = daemon_uid;
#line 3002
    session.gid = daemon_gid;
#line 3002
    tmp___31 = setuid((__uid_t )0);
    }
#line 3002
    if (tmp___31) {
      {
#line 3002
      tmp___29 = __errno_location();
#line 3002
      tmp___30 = strerror(*tmp___29);
#line 3002
      pr_log_pri(3, "PRIVS_SETUP: unable to setuid(): %s", tmp___30);
      }
    }
    {
#line 3002
    tmp___34 = setgid(daemon_gid);
    }
#line 3002
    if (tmp___34) {
      {
#line 3002
      tmp___32 = __errno_location();
#line 3002
      tmp___33 = strerror(*tmp___32);
#line 3002
      pr_log_pri(3, "PRIVS_SETUP: unable to setgid(): %s", tmp___33);
      }
    }
    {
#line 3002
    tmp___37 = seteuid(daemon_uid);
    }
#line 3002
    if (tmp___37) {
      {
#line 3002
      tmp___35 = __errno_location();
#line 3002
      tmp___36 = strerror(*tmp___35);
#line 3002
      pr_log_pri(3, "PRIVS_SETUP: unable to seteuid(): %s", tmp___36);
      }
    }
  }
  {
#line 3002
  pr_signals_unblock();
#line 3009
  tmp___40 = geteuid();
  }
#line 3009
  if (tmp___40 != daemon_uid) {
    {
#line 3010
    tmp___39 = geteuid();
#line 3010
    pr_log_pri(3, "unable to set uid to %lu, current uid: %lu", (unsigned long )daemon_uid,
               (unsigned long )tmp___39);
#line 3012
    exit(1);
    }
  }
  {
#line 3015
  tmp___42 = getegid();
  }
#line 3015
  if (tmp___42 != daemon_gid) {
    {
#line 3016
    tmp___41 = getegid();
#line 3016
    pr_log_pri(3, "unable to set gid to %lu, current gid: %lu", (unsigned long )daemon_gid,
               (unsigned long )tmp___41);
#line 3018
    exit(1);
    }
  }
  {
#line 3023
  install_signal_handlers();
#line 3026
  set_daemon_rlimits();
  }
  {
#line 3030
  if ((int )ServerType == 1) {
#line 3030
    goto case_1___0;
  }
#line 3034
  if ((int )ServerType == 0) {
#line 3034
    goto case_0;
  }
#line 3029
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 3031
  standalone_main();
  }
#line 3032
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 3038
  mpid = 0;
#line 3039
  inetd_main();
  }
#line 3040
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 3048
  return (0);
}
}
