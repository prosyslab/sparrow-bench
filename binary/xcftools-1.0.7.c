/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 7 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
enum __anonenum_GimpLayerModeEffects_1 {
    GIMP_NORMAL_MODE = 0,
    GIMP_DISSOLVE_MODE = 1,
    GIMP_BEHIND_MODE = 2,
    GIMP_MULTIPLY_MODE = 3,
    GIMP_SCREEN_MODE = 4,
    GIMP_OVERLAY_MODE = 5,
    GIMP_DIFFERENCE_MODE = 6,
    GIMP_ADDITION_MODE = 7,
    GIMP_SUBTRACT_MODE = 8,
    GIMP_DARKEN_ONLY_MODE = 9,
    GIMP_LIGHTEN_ONLY_MODE = 10,
    GIMP_HUE_MODE = 11,
    GIMP_SATURATION_MODE = 12,
    GIMP_COLOR_MODE = 13,
    GIMP_VALUE_MODE = 14,
    GIMP_DIVIDE_MODE = 15,
    GIMP_DODGE_MODE = 16,
    GIMP_BURN_MODE = 17,
    GIMP_HARDLIGHT_MODE = 18,
    GIMP_SOFTLIGHT_MODE = 19,
    GIMP_GRAIN_EXTRACT_MODE = 20,
    GIMP_GRAIN_MERGE_MODE = 21,
    GIMP_COLOR_ERASE_MODE = 22,
    GIMP_ERASE_MODE = 23,
    GIMP_REPLACE_MODE = 24,
    GIMP_ANTI_ERASE_MODE = 25,
    GIMP_NORMAL_NOPARTIAL_MODE = -1
} ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
typedef enum __anonenum_GimpLayerModeEffects_1 GimpLayerModeEffects;
#line 39
enum __anonenum_GimpImageBaseType_2 {
    GIMP_RGB = 0,
    GIMP_GRAY = 1,
    GIMP_INDEXED = 2
} ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
typedef enum __anonenum_GimpImageBaseType_2 GimpImageBaseType;
#line 47
enum __anonenum_GimpImageType_3 {
    GIMP_RGB_IMAGE = 0,
    GIMP_RGBA_IMAGE = 1,
    GIMP_GRAY_IMAGE = 2,
    GIMP_GRAYA_IMAGE = 3,
    GIMP_INDEXED_IMAGE = 4,
    GIMP_INDEXEDA_IMAGE = 5
} ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
typedef enum __anonenum_GimpImageType_3 GimpImageType;
#line 90
enum __anonenum_XcfCompressionType_5 {
    COMPRESS_NONE = 0,
    COMPRESS_RLE = 1,
    COMPRESS_ZLIB = 2,
    COMPRESS_FRACTAL = 3
} ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
typedef enum __anonenum_XcfCompressionType_5 XcfCompressionType;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 36 "/usr/include/stdint.h"
typedef signed char int8_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 123 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
struct rect {
   int t ;
   int b ;
   int l ;
   int r ;
};
#line 159 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
struct tileDimensions {
   struct rect c ;
   unsigned int width ;
   unsigned int height ;
   unsigned int tilesx ;
   unsigned int tilesy ;
   unsigned int ntiles ;
};
#line 168
struct _convertParams;
#line 168 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
struct xcfTiles {
   struct _convertParams  const  *params ;
   uint32_t *tileptrs ;
   uint32_t hierarchy ;
};
#line 174 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
struct xcfLayer {
   struct tileDimensions dim ;
   char const   *name ;
   GimpLayerModeEffects mode ;
   GimpImageType type ;
   unsigned int opacity ;
   int isVisible ;
   int hasMask ;
   uint32_t propptr ;
   struct xcfTiles pixels ;
   struct xcfTiles mask ;
};
#line 186 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
struct xcfImage {
   int version ;
   unsigned int width ;
   unsigned int height ;
   GimpImageBaseType type ;
   XcfCompressionType compression ;
   int numLayers ;
   struct xcfLayer *layers ;
   uint32_t colormapptr ;
};
#line 44 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
typedef uint32_t rgba;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
typedef int summary_t;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
typedef int refcount_t;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
struct Tile {
   refcount_t refcount ;
   summary_t summary ;
   unsigned int count ;
   rgba pixels[(1 << 6) * (1 << 6)] ;
};
#line 39 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
struct _convertParams {
   int bpp ;
   int shift[4] ;
   uint32_t base_pixel ;
   rgba const   *lookup ;
};
#line 39 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
typedef struct _convertParams  const  convertParams;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_57 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_58 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_57 __wait_terminated ;
   struct __anonstruct___wait_stopped_58 __wait_stopped ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 105 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 104 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 58 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
enum __anonenum_PropType_4 {
    PROP_END = 0,
    PROP_COLORMAP = 1,
    PROP_ACTIVE_LAYER = 2,
    PROP_ACTIVE_CHANNEL = 3,
    PROP_SELECTION = 4,
    PROP_FLOATING_SELECTION = 5,
    PROP_OPACITY = 6,
    PROP_MODE = 7,
    PROP_VISIBLE = 8,
    PROP_LINKED = 9,
    PROP_PRESERVE_TRANSPARENCY = 10,
    PROP_APPLY_MASK = 11,
    PROP_EDIT_MASK = 12,
    PROP_SHOW_MASK = 13,
    PROP_SHOW_MASKED = 14,
    PROP_OFFSETS = 15,
    PROP_COLOR = 16,
    PROP_COMPRESSION = 17,
    PROP_GUIDES = 18,
    PROP_RESOLUTION = 19,
    PROP_TATTOO = 20,
    PROP_PARASITES = 21,
    PROP_UNIT = 22,
    PROP_PATHS = 23,
    PROP_USER_UNIT = 24,
    PROP_VECTORS = 25,
    PROP_TEXT_LAYER_FLAGS = 26
} ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
typedef enum __anonenum_PropType_4 PropType;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.h"
enum out_color_mode {
    COLOR_BY_FILENAME = 0,
    COLOR_BY_CONTENTS = 1,
    COLOR_INDEXED = 2,
    COLOR_RGB = 3,
    COLOR_GRAY = 4,
    COLOR_MONO = 5
} ;
#line 28
enum __anonenum_partial_transparency_mode_31 {
    ALLOW_PARTIAL_TRANSPARENCY = 0,
    DISSOLVE_PARTIAL_TRANSPARENCY = 1,
    FORBID_PARTIAL_TRANSPARENCY = 2,
    PARTIAL_TRANSPARENCY_IMPOSSIBLE = 3
} ;
#line 28
enum __anonenum_window_mode_32 {
    USE_CANVAS = 0,
    MANUAL_OFFSET = 1,
    MANUAL_CROP = 2,
    AUTOCROP = 4
} ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.h"
struct FlattenSpec {
   struct tileDimensions dim ;
   rgba default_pixel ;
   int numLayers ;
   struct xcfLayer *layers ;
   char const   *transmap_filename ;
   char const   *output_filename ;
   enum out_color_mode out_color_mode ;
   enum __anonenum_partial_transparency_mode_31 partial_transparency_mode ;
   enum __anonenum_window_mode_32 window_mode ;
   int process_in_memory ;
   int gimpish_indexed ;
};
#line 229 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
enum __anonenum_hue_40 {
    HUE_RED_GREEN_BLUE = 0,
    HUE_RED_BLUE_GREEN = 1,
    HUE_BLUE_RED_GREEN = 2,
    HUE_BLUE_GREEN_RED = 3,
    HUE_GREEN_BLUE_RED = 4,
    HUE_GREEN_RED_BLUE = 5
} ;
#line 229 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
struct HSV {
   enum __anonenum_hue_40 hue ;
   unsigned int ch1 ;
   unsigned int ch2 ;
   unsigned int ch3 ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.h"
typedef void (*lineCallback)(unsigned int num , rgba *pixels );
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 105 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
union __anonunion_65___0 {
   int __in ;
   int __i ;
};
#line 104 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
union __anonunion_66___0 {
   int __in ;
   int __i ;
};
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
void nls_init(void) ;
#line 3 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/nlsini.c"
void nls_init(void) 
{ 


  {
  {
#line 4
  bindtextdomain("xcftools", "/usr/local/share/locale");
#line 5
  textdomain("xcftools");
  }
#line 5
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
char const   *showGimpImageType(GimpImageType x ) ;
#line 97
char const   *showXcfCompressionType(XcfCompressionType x ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
char const   *progname ;
#line 106
void *xcfmalloc(size_t size ) ;
#line 107
void xcffree(void *block ) ;
#line 113
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalBadXCF)(char const   *format 
                                                                           , ...) ;
#line 115
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalUnsupportedXCF)(char const   *format 
                                                                                   , ...) ;
#line 135
uint8_t *xcf_file ;
#line 139
void ( /* format attribute */  xcfCheckspace)(uint32_t addr , int spaceafter , char const   *format 
                                              , ...) ;
#line 141
uint32_t xcfOffset(uint32_t addr , int spaceafter ) ;
#line 143
int xcfNextprop(uint32_t *master , uint32_t *body ) ;
#line 144
char const   *xcfString(uint32_t ptr , uint32_t *after ) ;
#line 186
struct xcfImage XCF ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
uint8_t scaletable[256][256] ;
#line 61
int ok_scaletable ;
#line 62
void mk_scaletable(void) ;
#line 67
rgba const   graytable[256] ;
#line 68 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
rgba colormap[256]  ;
#line 69
unsigned int colormapLength ;
#line 70
void initLayer(struct xcfLayer *layer ) ;
#line 71
void initColormap(void) ;
#line 73
int degrayPixel(rgba pixel ) ;
#line 112
struct Tile *newTile(struct rect r ) ;
#line 113
struct Tile *forkTile(struct Tile *tile ) ;
#line 114
void freeTile(struct Tile *tile ) ;
#line 117
summary_t __attribute__((__pure__))  tileSummary(struct Tile *tile ) ;
#line 119
void fillTile(struct Tile *tile , rgba data ) ;
#line 124
void applyMask(struct Tile *tile , struct Tile *mask ) ;
#line 126
struct Tile *getLayerTile(struct xcfLayer *layer , struct rect  const  *where ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
unsigned int colormapLength  =    0U;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
int degrayPixel(rgba pixel ) 
{ 


  {
#line 31
  if (((pixel >> 8) & 255U) == ((pixel >> 16) & 255U)) {
#line 31
    if (((pixel >> 8) & 255U) == ((pixel >> 24) & 255U)) {
#line 33
      return ((int )((pixel >> 8) & 255U));
    }
  }
#line 34
  return (-1);
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertRGB  =    {3, {8, 16, 24}, (uint32_t )255, (rgba const   *)0};
#line 48 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertRGBA  =    {4, {8, 16, 24, 0}, (uint32_t )0, (rgba const   *)0};
#line 49 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertGRAY  =    {1, {-1}, (uint32_t )255, graytable};
#line 50 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertGRAYA  =    {2, {-1, 0}, (uint32_t )0, graytable};
#line 51 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertINDEXED  =    {1, {-1}, (uint32_t )255, (rgba const   *)(colormap)};
#line 52 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertINDEXEDA  =    {2, {-1, 0}, (uint32_t )0, (rgba const   *)(colormap)};
#line 54 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertColormap  =    {3, {8, 16, 24}, (uint32_t )0, (rgba const   *)0};
#line 55 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static convertParams convertChannel  =    {1, {0}, (uint32_t )0, (rgba const   *)0};
#line 59 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
__inline static int tileDirectoryOneLevel(struct tileDimensions *dim , uint32_t ptr ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 62
  if (ptr == 0U) {
#line 63
    return (0);
  }
  {
#line 64
  tmp = ntohl(*((uint32_t *)(xcf_file + ptr)));
  }
#line 64
  if (tmp != (uint32_t )(dim->c.r - dim->c.l)) {
    {
#line 66
    FatalBadXCF("Drawable size mismatch at %X", ptr);
    }
  } else {
    {
#line 64
    tmp___0 = ntohl(*((uint32_t *)(xcf_file + (ptr + 4U))));
    }
#line 64
    if (tmp___0 != (uint32_t )(dim->c.b - dim->c.t)) {
      {
#line 66
      FatalBadXCF("Drawable size mismatch at %X", ptr);
      }
    }
  }
#line 67
  ptr += 8U;
#line 67
  return ((int )ptr);
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static void initTileDirectory(struct tileDimensions *dim , struct xcfTiles *tiles ,
                              char const   *type ) 
{ 
  uint32_t ptr ;
  uint32_t data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  unsigned int i ;
  void *tmp___6 ;

  {
  {
#line 77
  ptr = tiles->hierarchy;
#line 78
  tiles->hierarchy = (uint32_t )0;
#line 79
  tmp = tileDirectoryOneLevel(dim, ptr);
#line 79
  ptr = (uint32_t )tmp;
  }
#line 79
  if (ptr == 0U) {
#line 79
    return;
  }
#line 80
  if ((unsigned long )tiles->params == (unsigned long )(& convertChannel)) {
    {
#line 84
    xcfString(ptr, & ptr);
    }
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 85
      tmp___0 = xcfNextprop(& ptr, & data);
      }
#line 85
      if (! (tmp___0 != 0)) {
#line 85
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 87
    ptr = xcfOffset(ptr, 16);
#line 88
    tmp___1 = tileDirectoryOneLevel(dim, ptr);
#line 88
    ptr = (uint32_t )tmp___1;
    }
#line 88
    if (ptr == 0U) {
#line 88
      return;
    }
  }
  {
#line 95
  data = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 96
  tmp___3 = ntohl(*((uint32_t *)(xcf_file + ptr)));
  }
#line 96
  if (tmp___3 != (uint32_t )(tiles->params)->bpp) {
    {
#line 97
    tmp___2 = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 97
    FatalBadXCF("%u bytes per pixel for %s drawable", tmp___2, type);
    }
  }
  {
#line 98
  ptr = xcfOffset(ptr + 4U, 12);
#line 99
  tmp___4 = tileDirectoryOneLevel(dim, ptr);
#line 99
  ptr = (uint32_t )tmp___4;
  }
#line 99
  if (ptr == 0U) {
#line 99
    return;
  }
  {
#line 101
  xcfCheckspace(ptr, (int )(dim->ntiles * 4U + 4U), "Tile directory at %X", ptr);
#line 102
  tmp___5 = ntohl(*((uint32_t *)(xcf_file + (ptr + dim->ntiles * 4U))));
  }
#line 102
  if (tmp___5 != 0U) {
    {
#line 103
    FatalBadXCF("Wrong sized tile directory at %X", ptr);
    }
  }
  {
#line 113
  tmp___6 = xcfmalloc((unsigned long )dim->ntiles * sizeof(uint32_t ));
#line 113
  tiles->tileptrs = (uint32_t *)tmp___6;
#line 114
  i = 0U;
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! (i < dim->ntiles)) {
#line 114
      goto while_break___0;
    }
    {
#line 115
    *(tiles->tileptrs + i) = ntohl(*((uint32_t *)(xcf_file + (ptr + i * 4U))));
#line 114
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
void initLayer(struct xcfLayer *layer ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 122
  if (layer->dim.ntiles == 0U) {
#line 124
    return;
  } else
#line 122
  if (layer->pixels.hierarchy == 0U) {
#line 122
    if (layer->mask.hierarchy == 0U) {
#line 124
      return;
    }
  }
  {
#line 127
  if ((unsigned int )layer->type == 0U) {
#line 127
    goto case_0;
  }
#line 128
  if ((unsigned int )layer->type == 1U) {
#line 128
    goto case_1;
  }
#line 129
  if ((unsigned int )layer->type == 2U) {
#line 129
    goto case_2;
  }
#line 130
  if ((unsigned int )layer->type == 3U) {
#line 130
    goto case_3;
  }
#line 131
  if ((unsigned int )layer->type == 4U) {
#line 131
    goto case_4;
  }
#line 132
  if ((unsigned int )layer->type == 5U) {
#line 132
    goto case_5;
  }
#line 133
  goto switch_default;
  case_0: /* CIL Label */ 
#line 127
  layer->pixels.params = & convertRGB;
#line 127
  goto switch_break;
  case_1: /* CIL Label */ 
#line 128
  layer->pixels.params = & convertRGBA;
#line 128
  goto switch_break;
  case_2: /* CIL Label */ 
#line 129
  layer->pixels.params = & convertGRAY;
#line 129
  goto switch_break;
  case_3: /* CIL Label */ 
#line 130
  layer->pixels.params = & convertGRAYA;
#line 130
  goto switch_break;
  case_4: /* CIL Label */ 
#line 131
  layer->pixels.params = & convertINDEXED;
#line 131
  goto switch_break;
  case_5: /* CIL Label */ 
#line 132
  layer->pixels.params = & convertINDEXEDA;
#line 132
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 134
  tmp = showGimpImageType(layer->type);
#line 134
  tmp___0 = gettext(tmp);
#line 134
  tmp___1 = gettext("Layer type %s");
#line 134
  FatalUnsupportedXCF((char const   *)tmp___1, tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp___2 = showGimpImageType(layer->type);
#line 136
  tmp___3 = gettext(tmp___2);
#line 136
  initTileDirectory(& layer->dim, & layer->pixels, (char const   *)tmp___3);
#line 138
  layer->mask.params = & convertChannel;
#line 139
  initTileDirectory(& layer->dim, & layer->mask, "layer mask");
  }
#line 140
  return;
}
}
#line 141
static void copyStraightPixels(rgba *dest , unsigned int npixels , uint32_t ptr ,
                               convertParams *params ) ;
#line 143 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
void initColormap(void) 
{ 
  uint32_t ncolors ;
  char *tmp ;

  {
#line 146
  if (XCF.colormapptr == 0U) {
#line 147
    colormapLength = 0U;
#line 148
    return;
  }
  {
#line 150
  ncolors = ntohl(*((uint32_t *)(xcf_file + XCF.colormapptr)));
  }
#line 151
  if (ncolors > 256U) {
    {
#line 152
    tmp = gettext("Color map has more than 256 entries");
#line 152
    FatalUnsupportedXCF((char const   *)tmp);
    }
  }
  {
#line 153
  copyStraightPixels(colormap, ncolors, XCF.colormapptr + 4U, & convertColormap);
#line 154
  colormapLength = ncolors;
  }
#line 166
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
struct Tile *newTile(struct rect r ) 
{ 
  unsigned int npixels ;
  struct Tile *data ;
  void *tmp ;

  {
  {
#line 173
  npixels = (unsigned int )(r.b - r.t) * (unsigned int )(r.r - r.l);
#line 174
  tmp = xcfmalloc(sizeof(struct Tile ) - sizeof(rgba ) * (unsigned long )((unsigned int )((1 << 6) * (1 << 6)) - npixels));
#line 174
  data = (struct Tile *)tmp;
#line 177
  data->count = npixels;
#line 178
  data->refcount = 1;
#line 179
  data->summary = 0;
  }
#line 180
  return (data);
}
}
#line 183 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
struct Tile *forkTile(struct Tile *tile ) 
{ 
  char *tmp ;

  {
#line 186
  (tile->refcount) ++;
#line 186
  if (tile->refcount <= 0) {
    {
#line 187
    tmp = gettext("Unbelievably many layers?\nMore likely to be a bug in %s");
#line 187
    FatalUnsupportedXCF((char const   *)tmp, progname);
    }
  }
#line 189
  return (tile);
}
}
#line 192 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
void freeTile(struct Tile *tile ) 
{ 


  {
#line 195
  (tile->refcount) --;
#line 195
  if (tile->refcount == 0) {
    {
#line 196
    xcffree((void *)tile);
    }
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
summary_t __attribute__((__pure__))  tileSummary(struct Tile *tile ) 
{ 
  unsigned int i ;
  summary_t summary ;

  {
#line 204
  if ((tile->summary & 8) != 0) {
#line 205
    return ((summary_t __attribute__((__pure__))  )tile->summary);
  }
#line 206
  summary = 7;
#line 207
  i = 0U;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (summary) {
#line 207
      if (! (i < tile->count)) {
#line 207
        goto while_break;
      }
    } else {
#line 207
      goto while_break;
    }
#line 208
    if ((int )((uint8_t )tile->pixels[i]) == 255) {
#line 209
      summary &= -5;
    } else
#line 210
    if ((int )((uint8_t )tile->pixels[i]) == 0) {
#line 211
      summary &= -3;
    } else {
#line 213
      summary = 0;
    }
#line 207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  summary += 8;
#line 216
  tile->summary = summary;
#line 217
  return ((summary_t __attribute__((__pure__))  )summary);
}
}
#line 220 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
void fillTile(struct Tile *tile , rgba data ) 
{ 
  unsigned int i ;

  {
#line 224
  i = 0U;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (i < tile->count)) {
#line 224
      goto while_break;
    }
#line 225
    tile->pixels[i] = data;
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if ((int )((uint8_t )data) == 255) {
#line 227
    tile->summary = 11;
  } else
#line 228
  if ((int )((uint8_t )data) == 0) {
#line 229
    tile->summary = 13;
  } else {
#line 231
    tile->summary = 8;
  }
#line 232
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static void copyStraightPixels(rgba *dest , unsigned int npixels , uint32_t ptr ,
                               convertParams *params ) 
{ 
  unsigned int bpp ;
  rgba const   *lookup ;
  rgba base_pixel ;
  uint8_t *bp ;
  rgba pixel ;
  unsigned int i ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  rgba *tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 240
  bpp = (unsigned int )params->bpp;
#line 241
  lookup = (rgba const   *)params->lookup;
#line 242
  base_pixel = (rgba )params->base_pixel;
#line 243
  bp = xcf_file + ptr;
#line 244
  xcfCheckspace(ptr, (int )(bpp * npixels), "pixel array (%u x %d bpp) at %X", npixels,
                bpp, ptr);
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    tmp___2 = npixels;
#line 246
    npixels --;
#line 246
    if (! tmp___2) {
#line 246
      goto while_break;
    }
#line 247
    pixel = base_pixel;
#line 249
    i = 0U;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! (i < bpp)) {
#line 249
        goto while_break___0;
      }
#line 250
      if (params->shift[i] < 0) {
#line 251
        tmp = bp;
#line 251
        bp ++;
#line 251
        pixel += (rgba )*(lookup + *tmp);
      } else {
#line 253
        tmp___0 = bp;
#line 253
        bp ++;
#line 253
        pixel += (rgba )((int )*tmp___0 << params->shift[i]);
      }
#line 249
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    tmp___1 = dest;
#line 256
    dest ++;
#line 256
    *tmp___1 = pixel;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
__inline static void copyRLEpixels(rgba *dest , unsigned int npixels , uint32_t ptr ,
                                   convertParams *params ) 
{ 
  unsigned int i ;
  unsigned int j ;
  rgba base_pixel ;
  unsigned int tmp ;
  int shift ;
  int countspec ;
  unsigned int count ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  rgba data ;
  uint32_t tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  uint32_t tmp___7 ;
  unsigned int tmp___8 ;
  rgba const   *lookup ;
  unsigned int tmp___9 ;

  {
#line 264
  base_pixel = (rgba )params->base_pixel;
#line 273
  if (params->shift[0] < -1) {
#line 274
    base_pixel = (rgba )0;
  }
#line 275
  j = npixels;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    tmp = j;
#line 275
    j --;
#line 275
    if (! tmp) {
#line 275
      goto while_break;
    }
#line 276
    *(dest + j) = base_pixel;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  i = 0U;
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 278
    if (! (i < (unsigned int )params->bpp)) {
#line 278
      goto while_break___0;
    }
#line 279
    shift = params->shift[i];
#line 280
    if (shift < 0) {
#line 281
      shift = 0;
    }
#line 282
    j = 0U;
    {
#line 282
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (j < npixels)) {
#line 282
        goto while_break___1;
      }
      {
#line 285
      xcfCheckspace(ptr, 2, "RLE data stream");
#line 286
      tmp___0 = ptr;
#line 286
      ptr ++;
#line 286
      countspec = (int )((int8_t )*(xcf_file + tmp___0));
      }
#line 287
      if (countspec >= 0) {
#line 287
        count = (unsigned int )(countspec + 1);
      } else {
#line 287
        count = (unsigned int )(- countspec);
      }
#line 288
      if (count == 128U) {
        {
#line 289
        xcfCheckspace(ptr, 3, "RLE long count");
#line 290
        tmp___1 = ptr;
#line 290
        ptr ++;
#line 290
        count = (unsigned int )((int )*(xcf_file + tmp___1) << 8);
#line 291
        tmp___2 = ptr;
#line 291
        ptr ++;
#line 291
        count += (unsigned int )*(xcf_file + tmp___2);
        }
      }
#line 293
      if (j + count > npixels) {
        {
#line 294
        FatalBadXCF("Overlong RLE run at %X (plane %u, %u left)", ptr, i, npixels - j);
        }
      }
#line 296
      if (countspec >= 0) {
#line 297
        tmp___3 = ptr;
#line 297
        ptr ++;
#line 297
        data = (uint32_t )*(xcf_file + tmp___3) << shift;
        {
#line 298
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 298
          tmp___5 = count;
#line 298
          count --;
#line 298
          if (! tmp___5) {
#line 298
            goto while_break___2;
          }
#line 299
          tmp___4 = j;
#line 299
          j ++;
#line 299
          *(dest + tmp___4) += data;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 301
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 301
          tmp___8 = count;
#line 301
          count --;
#line 301
          if (! tmp___8) {
#line 301
            goto while_break___3;
          }
#line 302
          tmp___6 = j;
#line 302
          j ++;
#line 302
          tmp___7 = ptr;
#line 302
          ptr ++;
#line 302
          *(dest + tmp___6) += (uint32_t )*(xcf_file + tmp___7) << shift;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 305
    if (i == 0U) {
#line 305
      if (params->shift[0] < 0) {
#line 306
        lookup = (rgba const   *)params->lookup;
#line 307
        base_pixel = (rgba )params->base_pixel;
#line 308
        j = npixels;
        {
#line 308
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 308
          tmp___9 = j;
#line 308
          j --;
#line 308
          if (! tmp___9) {
#line 308
            goto while_break___4;
          }
#line 309
          *(dest + j) = (rgba )(*(lookup + (*(dest + j) - base_pixel)) + (rgba const   )base_pixel);
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 278
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
__inline static void copyTilePixels(struct Tile *dest , uint32_t ptr , convertParams *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 328
  if ((int )((uint8_t )params->base_pixel) == 255) {
#line 329
    dest->summary = 11;
  } else {
#line 331
    dest->summary = 0;
  }
  {
#line 333
  if ((unsigned int )XCF.compression == 0U) {
#line 333
    goto case_0;
  }
#line 336
  if ((unsigned int )XCF.compression == 1U) {
#line 336
    goto case_1;
  }
#line 339
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 334
  copyStraightPixels(dest->pixels, dest->count, ptr, params);
  }
#line 335
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 337
  copyRLEpixels(dest->pixels, dest->count, ptr, params);
  }
#line 338
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  tmp = showXcfCompressionType(XCF.compression);
#line 340
  tmp___0 = gettext(tmp);
#line 340
  tmp___1 = gettext("%s compression");
#line 340
  FatalUnsupportedXCF((char const   *)tmp___1, tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 415 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static struct Tile tmptile  ;
#line 345 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
static struct Tile *getMaskOrLayerTile(struct tileDimensions *dim , struct xcfTiles *tiles ,
                                       struct rect want ) 
{ 
  struct Tile *tile ;
  struct Tile *tmp ;
  int tx ;
  int ty ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int width ;
  rgba *pixvert ;
  rgba *pixhoriz ;
  int y ;
  int ty___0 ;
  int l0 ;
  int l1 ;
  int x ;
  int tx___0 ;
  int c0 ;
  int c1 ;
  unsigned int lstart ;
  unsigned int lnum ;
  unsigned int cstart ;
  unsigned int cnum ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int dwidth ;
  unsigned int i ;
  unsigned int j ;

  {
  {
#line 349
  tmp = newTile(want);
#line 349
  tile = tmp;
  }
#line 351
  if (want.l < want.r) {
#line 351
    if (! (want.t < want.b)) {
      {
#line 351
      __assert_fail("want.l < want.r && want.t < want.b", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c",
                    351U, "getMaskOrLayerTile");
      }
    }
  } else {
    {
#line 351
    __assert_fail("want.l < want.r && want.t < want.b", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c",
                  351U, "getMaskOrLayerTile");
    }
  }
#line 352
  if ((unsigned long )tiles->tileptrs == (unsigned long )((uint32_t *)0)) {
    {
#line 353
    fillTile(tile, (rgba )0);
    }
#line 354
    return (tile);
  }
#line 361
  if (want.l >= dim->c.l) {
#line 361
    if (want.r <= dim->c.r) {
#line 361
      if (want.t >= dim->c.t) {
#line 361
        if (want.b <= dim->c.b) {
#line 361
          if ((want.l - dim->c.l) % (1 << 6) == 0) {
#line 361
            if ((want.t - dim->c.t) % (1 << 6) == 0) {
#line 364
              tx = (want.l - dim->c.l) >> 6;
#line 365
              ty = (want.t - dim->c.t) >> 6;
#line 366
              if ((unsigned int )(tx + 1) == dim->tilesx) {
#line 366
                tmp___0 = dim->c.r;
              } else {
#line 366
                tmp___0 = dim->c.l + (tx + 1) * (1 << 6);
              }
#line 366
              if (want.r == tmp___0) {
#line 366
                if ((unsigned int )(ty + 1) == dim->tilesy) {
#line 366
                  tmp___1 = dim->c.b;
                } else {
#line 366
                  tmp___1 = dim->c.t + (ty + 1) * (1 << 6);
                }
#line 366
                if (want.b == tmp___1) {
                  {
#line 368
                  copyTilePixels(tile, *(tiles->tileptrs + ((unsigned int )tx + (unsigned int )ty * dim->tilesx)),
                                 tiles->params);
                  }
#line 369
                  return (tile);
                }
              }
            }
          }
        }
      }
    }
  }
#line 375
  width = (unsigned int )(want.r - want.l);
#line 376
  pixvert = tile->pixels;
#line 383
  if (want.l >= dim->c.l) {
#line 383
    if (want.r <= dim->c.r) {
#line 383
      if (want.t >= dim->c.t) {
#line 383
        if (want.b <= dim->c.b) {
#line 392
          tile->summary = -1;
        } else {
#line 383
          goto _L___1;
        }
      } else {
#line 383
        goto _L___1;
      }
    } else {
#line 383
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 384
    if (want.l < dim->c.l) {
#line 384
      pixvert += dim->c.l - want.l;
#line 384
      want.l = dim->c.l;
    }
#line 386
    if (want.r > dim->c.r) {
#line 386
      want.r = dim->c.r;
    }
#line 387
    if (want.t < dim->c.t) {
#line 387
      pixvert += (unsigned int )(dim->c.t - want.t) * width;
#line 387
      want.t = dim->c.t;
    }
#line 389
    if (want.b > dim->c.b) {
#line 389
      want.b = dim->c.b;
    }
    {
#line 390
    fillTile(tile, (rgba )0);
    }
  }
#line 399
  y = want.t;
#line 399
  ty___0 = (want.t - dim->c.t) >> 6;
#line 399
  if ((unsigned int )ty___0 == dim->tilesy) {
#line 399
    l0 = dim->c.b;
  } else {
#line 399
    l0 = dim->c.t + ty___0 * (1 << 6);
  }
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (y < want.b)) {
#line 399
      goto while_break;
    }
#line 402
    if ((unsigned int )(ty___0 + 1) == dim->tilesy) {
#line 402
      l1 = dim->c.b;
    } else {
#line 402
      l1 = dim->c.t + (ty___0 + 1) * (1 << 6);
    }
#line 403
    lstart = (unsigned int )(y - l0);
#line 404
    if (l1 > want.b) {
#line 404
      tmp___2 = want.b;
    } else {
#line 404
      tmp___2 = l1;
    }
#line 404
    lnum = (unsigned int )(tmp___2 - y);
#line 406
    pixhoriz = pixvert;
#line 407
    x = want.l;
#line 407
    tx___0 = (want.l - dim->c.l) >> 6;
#line 407
    if ((unsigned int )tx___0 == dim->tilesx) {
#line 407
      c0 = dim->c.r;
    } else {
#line 407
      c0 = dim->c.l + tx___0 * (1 << 6);
    }
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 407
      if (! (x < want.r)) {
#line 407
        goto while_break___0;
      }
#line 410
      if ((unsigned int )(tx___0 + 1) == dim->tilesx) {
#line 410
        c1 = dim->c.r;
      } else {
#line 410
        c1 = dim->c.l + (tx___0 + 1) * (1 << 6);
      }
#line 411
      cstart = (unsigned int )(x - c0);
#line 412
      if (c1 > want.r) {
#line 412
        tmp___3 = want.r;
      } else {
#line 412
        tmp___3 = c1;
      }
      {
#line 412
      cnum = (unsigned int )(tmp___3 - x);
#line 416
      dwidth = (unsigned int )(c1 - c0);
#line 418
      tmptile.count = (unsigned int )((c1 - c0) * (l1 - l0));
#line 424
      copyTilePixels(& tmptile, *(tiles->tileptrs + ((unsigned int )tx___0 + (unsigned int )ty___0 * dim->tilesx)),
                     tiles->params);
#line 426
      i = 0U;
      }
      {
#line 426
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 426
        if (! (i < lnum)) {
#line 426
          goto while_break___1;
        }
#line 427
        j = 0U;
        {
#line 427
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 427
          if (! (j < cnum)) {
#line 427
            goto while_break___2;
          }
#line 428
          *(pixhoriz + (i * width + j)) = tmptile.pixels[(i + lstart) * dwidth + (j + cstart)];
#line 427
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 426
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 430
      tile->summary &= tmptile.summary;
#line 407
      pixhoriz += cnum;
#line 407
      tx___0 ++;
#line 407
      c0 = c1;
#line 407
      x = c0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 399
    pixvert += lnum * width;
#line 399
    ty___0 ++;
#line 399
    l0 = l1;
#line 399
    y = l0;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (tile);
}
}
#line 438 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
void applyMask(struct Tile *tile , struct Tile *mask ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 442
  if (! (tile->count == mask->count)) {
    {
#line 442
    __assert_fail("(tile)->count==(mask)->count", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c",
                  442U, "applyMask");
    }
  }
#line 443
  if (! (tile->count == mask->count)) {
    {
#line 443
    __assert_fail("tile->count == mask->count", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c",
                  443U, "applyMask");
    }
  }
#line 444
  if (ok_scaletable) {
#line 444
    tmp = 1;
  } else {
    {
#line 444
    mk_scaletable();
#line 444
    tmp = 0;
    }
  }
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! (tile->refcount == 1)) {
      {
#line 445
      __assert_fail("(tile)->refcount==1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c",
                    445U, "applyMask");
      }
    }
#line 445
    tile->summary = 0;
#line 445
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  i = 0U;
  {
#line 446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 446
    if (! (i < tile->count)) {
#line 446
      goto while_break___0;
    }
#line 447
    tile->pixels[i] = (tile->pixels[i] & 4294967040U) + (unsigned int )scaletable[mask->pixels[i]][(uint8_t )tile->pixels[i]];
#line 446
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 450
  freeTile(mask);
  }
#line 451
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c"
struct Tile *getLayerTile(struct xcfLayer *layer , struct rect  const  *where ) 
{ 
  struct Tile *data ;
  struct Tile *mask ;
  struct Tile *tmp ;
  uint8_t const   *ourtable ;
  int i ;
  int tmp___0 ;

  {
#line 463
  if (where->l >= (int const   )layer->dim.c.r) {
    {
#line 465
    data = newTile((struct rect )*where);
#line 466
    fillTile(data, (rgba )0);
    }
#line 467
    return (data);
  } else
#line 463
  if (where->r <= (int const   )layer->dim.c.l) {
    {
#line 465
    data = newTile((struct rect )*where);
#line 466
    fillTile(data, (rgba )0);
    }
#line 467
    return (data);
  } else
#line 463
  if (where->t >= (int const   )layer->dim.c.b) {
    {
#line 465
    data = newTile((struct rect )*where);
#line 466
    fillTile(data, (rgba )0);
    }
#line 467
    return (data);
  } else
#line 463
  if (where->b <= (int const   )layer->dim.c.t) {
    {
#line 465
    data = newTile((struct rect )*where);
#line 466
    fillTile(data, (rgba )0);
    }
#line 467
    return (data);
  } else
#line 463
  if (layer->opacity == 0U) {
    {
#line 465
    data = newTile((struct rect )*where);
#line 466
    fillTile(data, (rgba )0);
    }
#line 467
    return (data);
  }
  {
#line 470
  data = getMaskOrLayerTile(& layer->dim, & layer->pixels, (struct rect )*where);
  }
#line 471
  if ((data->summary & 4) != 0) {
#line 472
    return (data);
  }
#line 473
  if (layer->hasMask) {
    {
#line 474
    tmp = getMaskOrLayerTile(& layer->dim, & layer->mask, (struct rect )*where);
#line 474
    mask = tmp;
#line 475
    applyMask(data, mask);
    }
  }
#line 477
  if (layer->opacity < 255U) {
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (data->refcount == 1)) {
        {
#line 480
        __assert_fail("(data)->refcount==1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.c",
                      480U, "getLayerTile");
        }
      }
#line 480
      data->summary &= -4;
#line 480
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 481
    if (ok_scaletable) {
#line 481
      tmp___0 = 1;
    } else {
      {
#line 481
      mk_scaletable();
#line 481
      tmp___0 = 0;
      }
    }
#line 482
    ourtable = (uint8_t const   *)(scaletable[layer->opacity]);
#line 483
    i = 0;
    {
#line 483
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 483
      if (! ((unsigned int )i < data->count)) {
#line 483
        goto while_break___0;
      }
#line 484
      data->pixels[i] = (data->pixels[i] & 4294967040U) + (unsigned int )*(ourtable + (uint8_t )data->pixels[i]);
#line 483
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 487
  return (data);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 195
extern FILE *tmpfile(void) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
void read_or_mmap_xcf(char const   *filename , char const   *unzipper ) ;
#line 98
void free_or_close_xcf(void) ;
#line 109
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalGeneric)(int status ,
                                                                            char const   *format 
                                                                            , ...) ;
#line 111
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalUnexpected)(char const   *format 
                                                                               , ...) ;
#line 136
size_t xcf_length ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
static FILE *xcfstream  =    (FILE *)0;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
void free_or_close_xcf(void) 
{ 


  {
#line 36
  if (xcf_file) {
#line 37
    if (xcfstream) {
      {
#line 38
      munmap((void *)xcf_file, xcf_length);
#line 39
      fclose(xcfstream);
#line 40
      xcf_file = (uint8_t *)0;
#line 41
      xcfstream = (FILE *)0;
      }
    } else {
      {
#line 43
      free((void *)xcf_file);
#line 44
      xcf_file = (uint8_t *)0;
      }
    }
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
void read_or_mmap_xcf(char const   *filename , char const   *unzipper ) 
{ 
  struct stat statbuf ;
  int tmp ;
  int tmp___0 ;
  char const   *pc ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int pid ;
  int status ;
  int outfd ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  __pid_t tmp___8 ;
  union __anonunion_65 __constr_expr_0 ;
  char *tmp___9 ;
  union __anonunion_66 __constr_expr_1 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int saved ;
  int *tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  void *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  size_t blocksize ;
  void *tmp___24 ;
  char *tmp___25 ;
  size_t actual ;
  size_t tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  {
#line 54
  free_or_close_xcf();
#line 56
  tmp___0 = strcmp(filename, "-");
  }
#line 56
  if (tmp___0 != 0) {
    {
#line 57
    tmp = access(filename, 4);
    }
#line 57
    if (tmp != 0) {
      {
#line 58
      FatalGeneric(21, "!%s", filename);
      }
    }
  }
#line 61
  if (! unzipper) {
    {
#line 63
    tmp___1 = strlen(filename);
#line 63
    pc = filename + tmp___1;
    }
#line 64
    if (pc - filename > 2L) {
      {
#line 64
      tmp___3 = strcmp(pc - 2, "gz");
      }
#line 64
      if (tmp___3 == 0) {
#line 65
        unzipper = "zcat";
      } else {
#line 64
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 66
    if (pc - filename > 3L) {
      {
#line 66
      tmp___2 = strcmp(pc - 3, "bz2");
      }
#line 66
      if (tmp___2 == 0) {
#line 67
        unzipper = "bzcat";
      } else {
#line 69
        unzipper = "";
      }
    } else {
#line 69
      unzipper = "";
    }
  } else {
    {
#line 70
    tmp___4 = strcmp(unzipper, "cat");
    }
#line 70
    if (tmp___4 == 0) {
#line 71
      unzipper = "";
    }
  }
#line 73
  if (*unzipper) {
    {
#line 76
    xcfstream = tmpfile();
    }
#line 77
    if (! xcfstream) {
      {
#line 78
      tmp___5 = gettext("!Cannot create temporary unzipped file");
#line 78
      FatalUnexpected((char const   *)tmp___5);
      }
    }
    {
#line 79
    outfd = fileno(xcfstream);
#line 89
    pid = fork();
    }
#line 89
    if (pid == 0) {
      {
#line 91
      tmp___6 = dup2(outfd, 1);
      }
#line 91
      if (tmp___6 < 0) {
        {
#line 92
        perror("Cannot dup2 in unzip process");
#line 93
        exit(127);
        }
      }
      {
#line 95
      fclose(xcfstream);
#line 96
      execlp(unzipper, unzipper, filename, (void *)0);
#line 97
      tmp___7 = gettext("Cannot execute ");
#line 97
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7);
#line 98
      perror(unzipper);
#line 99
      exit(126);
      }
    }
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 102
      tmp___8 = wait((union wait *)(& status));
      }
#line 102
      if (! (tmp___8 != pid)) {
#line 102
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 104
    __constr_expr_1.__in = status;
#line 104
    if ((__constr_expr_1.__i & 127) == 0) {
#line 105
      __constr_expr_0.__in = status;
#line 105
      status = (__constr_expr_0.__i & 65280) >> 8;
#line 106
      if (status > 0) {
        {
#line 107
        fclose(xcfstream);
#line 108
        xcfstream = (FILE *)0;
#line 109
        FatalGeneric(status, (char const   *)((void *)0));
        }
      }
    } else {
      {
#line 112
      fclose(xcfstream);
#line 113
      xcfstream = (FILE *)0;
#line 114
      tmp___9 = gettext("%s terminated abnormally");
#line 114
      FatalGeneric(126, (char const   *)tmp___9, unzipper);
      }
    }
  } else {
    {
#line 119
    tmp___12 = strcmp(filename, "-");
    }
#line 119
    if (tmp___12 == 0) {
      {
#line 120
      tmp___10 = dup(0);
#line 120
      xcfstream = fdopen(tmp___10, "rb");
      }
#line 121
      if (! xcfstream) {
        {
#line 122
        FatalUnexpected("!Cannot dup stdin for input");
        }
      }
    } else {
      {
#line 124
      xcfstream = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
      }
#line 125
      if (! xcfstream) {
        {
#line 126
        tmp___11 = gettext("!Cannot open %s");
#line 126
        FatalGeneric(21, (char const   *)tmp___11, filename);
        }
      }
    }
  }
  {
#line 129
  tmp___29 = fileno(xcfstream);
#line 129
  tmp___30 = fstat(tmp___29, & statbuf);
  }
#line 129
  if (tmp___30 == 0) {
#line 129
    if ((statbuf.st_mode & 61440U) == 32768U) {
      {
#line 131
      xcf_length = (size_t )statbuf.st_size;
#line 133
      tmp___13 = fileno(xcfstream);
#line 133
      tmp___14 = mmap((void *)0, xcf_length, 1, 1, tmp___13, (__off_t )0);
#line 133
      xcf_file = (uint8_t *)tmp___14;
      }
#line 134
      if ((unsigned long )xcf_file != (unsigned long )((void *)-1)) {
#line 135
        return;
      }
      {
#line 136
      tmp___17 = __errno_location();
      }
#line 136
      if (*tmp___17 != 19) {
        {
#line 137
        tmp___15 = __errno_location();
#line 137
        saved = *tmp___15;
#line 138
        fclose(xcfstream);
#line 139
        xcf_file = (uint8_t *)0;
#line 140
        tmp___16 = __errno_location();
#line 140
        *tmp___16 = saved;
#line 141
        FatalUnexpected("!Could not mmap input");
        }
      }
      {
#line 144
      tmp___18 = malloc(xcf_length);
#line 144
      xcf_file = (uint8_t *)tmp___18;
      }
#line 145
      if ((unsigned long )xcf_file == (unsigned long )((uint8_t *)0)) {
        {
#line 146
        tmp___19 = gettext("Out of memory for xcf data");
#line 146
        FatalUnexpected((char const   *)tmp___19);
        }
      }
      {
#line 147
      tmp___23 = fread((void */* __restrict  */)xcf_file, (size_t )1, xcf_length,
                       (FILE */* __restrict  */)xcfstream);
      }
#line 147
      if (tmp___23 != xcf_length) {
        {
#line 148
        tmp___22 = feof(xcfstream);
        }
#line 148
        if (tmp___22) {
          {
#line 149
          tmp___20 = gettext("XCF file shrunk while reading it");
#line 149
          FatalUnexpected((char const   *)tmp___20);
          }
        } else {
          {
#line 151
          tmp___21 = gettext("!Could not read xcf data");
#line 151
          FatalUnexpected((char const   *)tmp___21);
          }
        }
      }
      {
#line 153
      fclose(xcfstream);
#line 154
      xcfstream = (FILE *)0;
      }
    } else {
#line 129
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 156
    blocksize = (size_t )524288;
#line 157
    xcf_length = (size_t )0;
#line 158
    xcf_file = (uint8_t *)0;
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 160
      tmp___24 = realloc((void *)xcf_file, blocksize);
#line 160
      xcf_file = (uint8_t *)tmp___24;
      }
#line 161
      if ((unsigned long )xcf_file == (unsigned long )((uint8_t *)0)) {
        {
#line 162
        tmp___25 = gettext("Out of memory for xcf data");
#line 162
        FatalUnexpected((char const   *)tmp___25);
        }
      }
      {
#line 163
      tmp___26 = fread((void */* __restrict  */)(xcf_file + xcf_length), (size_t )1,
                       blocksize - xcf_length, (FILE */* __restrict  */)xcfstream);
#line 163
      actual = tmp___26;
#line 165
      xcf_length += actual;
#line 166
      tmp___27 = feof(xcfstream);
      }
#line 166
      if (tmp___27) {
#line 167
        goto while_break___0;
      }
#line 168
      if (xcf_length < blocksize) {
        {
#line 169
        tmp___28 = gettext("!Could not read xcf data");
#line 169
        FatalUnexpected((char const   *)tmp___28);
        }
      }
#line 171
      blocksize += (blocksize >> 1) & 0xffffffffffffc000UL;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 173
    fclose(xcfstream);
#line 174
    xcfstream = (FILE *)0;
    }
  }
#line 176
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/pixels.h"
uint8_t scaletable[256][256]  ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/scaletab.c"
int ok_scaletable  =    0;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/scaletab.c"
void mk_scaletable(void) 
{ 
  unsigned int p ;
  unsigned int q ;
  unsigned int r ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;

  {
#line 29
  if (ok_scaletable) {
#line 29
    return;
  }
#line 30
  p = 0U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (p < 128U)) {
#line 30
      goto while_break;
    }
#line 31
    q = 0U;
    {
#line 31
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 31
      if (! (q <= p)) {
#line 31
        goto while_break___0;
      }
#line 32
      r = (p * q + 127U) / 255U;
#line 33
      tmp = (uint8_t )r;
#line 33
      scaletable[q][p] = tmp;
#line 33
      scaletable[p][q] = tmp;
#line 34
      tmp___0 = (uint8_t )(q - r);
#line 34
      scaletable[q][255U - p] = tmp___0;
#line 34
      scaletable[255U - p][q] = tmp___0;
#line 35
      tmp___1 = (uint8_t )(p - r);
#line 35
      scaletable[255U - q][p] = tmp___1;
#line 35
      scaletable[p][255U - q] = tmp___1;
#line 36
      tmp___2 = (uint8_t )((255U - q) - (p - r));
#line 36
      scaletable[255U - q][255U - p] = tmp___2;
#line 36
      scaletable[255U - p][255U - q] = tmp___2;
#line 31
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 30
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  ok_scaletable = 1;
#line 39
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.h"
char const   *showGimpLayerModeEffects(GimpLayerModeEffects x ) ;
#line 45
char const   *showGimpImageBaseType(GimpImageBaseType x ) ;
#line 88
char const   *showPropType(PropType x ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf[35]  ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
char const   *showGimpLayerModeEffects(GimpLayerModeEffects x ) 
{ 


  {
  {
#line 10
  if ((int )x == 0) {
#line 10
    goto case_0;
  }
#line 11
  if ((int )x == 1) {
#line 11
    goto case_1;
  }
#line 12
  if ((int )x == 2) {
#line 12
    goto case_2;
  }
#line 13
  if ((int )x == 3) {
#line 13
    goto case_3;
  }
#line 14
  if ((int )x == 4) {
#line 14
    goto case_4;
  }
#line 15
  if ((int )x == 5) {
#line 15
    goto case_5;
  }
#line 16
  if ((int )x == 6) {
#line 16
    goto case_6;
  }
#line 17
  if ((int )x == 7) {
#line 17
    goto case_7;
  }
#line 18
  if ((int )x == 8) {
#line 18
    goto case_8;
  }
#line 19
  if ((int )x == 9) {
#line 19
    goto case_9;
  }
#line 20
  if ((int )x == 10) {
#line 20
    goto case_10;
  }
#line 21
  if ((int )x == 11) {
#line 21
    goto case_11;
  }
#line 22
  if ((int )x == 12) {
#line 22
    goto case_12;
  }
#line 23
  if ((int )x == 13) {
#line 23
    goto case_13;
  }
#line 24
  if ((int )x == 14) {
#line 24
    goto case_14;
  }
#line 25
  if ((int )x == 15) {
#line 25
    goto case_15;
  }
#line 26
  if ((int )x == 16) {
#line 26
    goto case_16;
  }
#line 27
  if ((int )x == 17) {
#line 27
    goto case_17;
  }
#line 28
  if ((int )x == 18) {
#line 28
    goto case_18;
  }
#line 29
  if ((int )x == 19) {
#line 29
    goto case_19;
  }
#line 30
  if ((int )x == 20) {
#line 30
    goto case_20;
  }
#line 31
  if ((int )x == 21) {
#line 31
    goto case_21;
  }
#line 32
  if ((int )x == 22) {
#line 32
    goto case_22;
  }
#line 33
  if ((int )x == 23) {
#line 33
    goto case_23;
  }
#line 34
  if ((int )x == 24) {
#line 34
    goto case_24;
  }
#line 35
  if ((int )x == 25) {
#line 35
    goto case_25;
  }
#line 36
  if ((int )x == -1) {
#line 36
    goto case_neg_1;
  }
#line 37
  goto switch_default;
  case_0: /* CIL Label */ 
#line 10
  return ("Normal");
  case_1: /* CIL Label */ 
#line 11
  return ("Dissolve");
  case_2: /* CIL Label */ 
#line 12
  return ("Behind");
  case_3: /* CIL Label */ 
#line 13
  return ("Multiply");
  case_4: /* CIL Label */ 
#line 14
  return ("Screen");
  case_5: /* CIL Label */ 
#line 15
  return ("Overlay");
  case_6: /* CIL Label */ 
#line 16
  return ("Difference");
  case_7: /* CIL Label */ 
#line 17
  return ("Addition");
  case_8: /* CIL Label */ 
#line 18
  return ("Subtract");
  case_9: /* CIL Label */ 
#line 19
  return ("DarkenOnly");
  case_10: /* CIL Label */ 
#line 20
  return ("LightenOnly");
  case_11: /* CIL Label */ 
#line 21
  return ("Hue");
  case_12: /* CIL Label */ 
#line 22
  return ("Saturation");
  case_13: /* CIL Label */ 
#line 23
  return ("Color");
  case_14: /* CIL Label */ 
#line 24
  return ("Value");
  case_15: /* CIL Label */ 
#line 25
  return ("Divide");
  case_16: /* CIL Label */ 
#line 26
  return ("Dodge");
  case_17: /* CIL Label */ 
#line 27
  return ("Burn");
  case_18: /* CIL Label */ 
#line 28
  return ("Hardlight");
  case_19: /* CIL Label */ 
#line 29
  return ("Softlight");
  case_20: /* CIL Label */ 
#line 30
  return ("GrainExtract");
  case_21: /* CIL Label */ 
#line 31
  return ("GrainMerge");
  case_22: /* CIL Label */ 
#line 32
  return ("ColorErase");
  case_23: /* CIL Label */ 
#line 33
  return ("Erase");
  case_24: /* CIL Label */ 
#line 34
  return ("Replace");
  case_25: /* CIL Label */ 
#line 35
  return ("AntiErase");
  case_neg_1: /* CIL Label */ 
#line 36
  return ("NormalNopartial");
  switch_default: /* CIL Label */ 
  {
#line 37
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"(GimpLayerModeEffects:%d)",
          (int )x);
  }
#line 38
  return ((char const   *)(buf));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___0[32]  ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
char const   *showGimpImageBaseType(GimpImageBaseType x ) 
{ 


  {
  {
#line 46
  if ((unsigned int )x == 0U) {
#line 46
    goto case_0;
  }
#line 47
  if ((unsigned int )x == 1U) {
#line 47
    goto case_1;
  }
#line 48
  if ((unsigned int )x == 2U) {
#line 48
    goto case_2;
  }
#line 49
  goto switch_default;
  case_0: /* CIL Label */ 
#line 46
  return ("RGB color");
  case_1: /* CIL Label */ 
#line 47
  return ("Grayscale");
  case_2: /* CIL Label */ 
#line 48
  return ("Indexed color");
  switch_default: /* CIL Label */ 
  {
#line 49
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"(GimpImageBaseType:%d)",
          (int )x);
  }
#line 50
  return ((char const   *)(buf___0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 56 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___1[28]  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
char const   *showGimpImageType(GimpImageType x ) 
{ 


  {
  {
#line 58
  if ((unsigned int )x == 0U) {
#line 58
    goto case_0;
  }
#line 59
  if ((unsigned int )x == 1U) {
#line 59
    goto case_1;
  }
#line 60
  if ((unsigned int )x == 2U) {
#line 60
    goto case_2;
  }
#line 61
  if ((unsigned int )x == 3U) {
#line 61
    goto case_3;
  }
#line 62
  if ((unsigned int )x == 4U) {
#line 62
    goto case_4;
  }
#line 63
  if ((unsigned int )x == 5U) {
#line 63
    goto case_5;
  }
#line 64
  goto switch_default;
  case_0: /* CIL Label */ 
#line 58
  return ("RGB");
  case_1: /* CIL Label */ 
#line 59
  return ("RGB-alpha");
  case_2: /* CIL Label */ 
#line 60
  return ("Grayscale");
  case_3: /* CIL Label */ 
#line 61
  return ("Grayscale-alpha");
  case_4: /* CIL Label */ 
#line 62
  return ("Indexed");
  case_5: /* CIL Label */ 
#line 63
  return ("Indexed-alpha");
  switch_default: /* CIL Label */ 
  {
#line 64
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"(GimpImageType:%d)",
          (int )x);
  }
#line 65
  return ((char const   *)(buf___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___2[23]  ;
#line 68 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
char const   *showPropType(PropType x ) 
{ 


  {
  {
#line 73
  if ((unsigned int )x == 0U) {
#line 73
    goto case_0;
  }
#line 74
  if ((unsigned int )x == 1U) {
#line 74
    goto case_1;
  }
#line 75
  if ((unsigned int )x == 2U) {
#line 75
    goto case_2;
  }
#line 76
  if ((unsigned int )x == 3U) {
#line 76
    goto case_3;
  }
#line 77
  if ((unsigned int )x == 4U) {
#line 77
    goto case_4;
  }
#line 78
  if ((unsigned int )x == 5U) {
#line 78
    goto case_5;
  }
#line 79
  if ((unsigned int )x == 6U) {
#line 79
    goto case_6;
  }
#line 80
  if ((unsigned int )x == 7U) {
#line 80
    goto case_7;
  }
#line 81
  if ((unsigned int )x == 8U) {
#line 81
    goto case_8;
  }
#line 82
  if ((unsigned int )x == 9U) {
#line 82
    goto case_9;
  }
#line 83
  if ((unsigned int )x == 10U) {
#line 83
    goto case_10;
  }
#line 84
  if ((unsigned int )x == 11U) {
#line 84
    goto case_11;
  }
#line 85
  if ((unsigned int )x == 12U) {
#line 85
    goto case_12;
  }
#line 86
  if ((unsigned int )x == 13U) {
#line 86
    goto case_13;
  }
#line 87
  if ((unsigned int )x == 14U) {
#line 87
    goto case_14;
  }
#line 88
  if ((unsigned int )x == 15U) {
#line 88
    goto case_15;
  }
#line 89
  if ((unsigned int )x == 16U) {
#line 89
    goto case_16;
  }
#line 90
  if ((unsigned int )x == 17U) {
#line 90
    goto case_17;
  }
#line 91
  if ((unsigned int )x == 18U) {
#line 91
    goto case_18;
  }
#line 92
  if ((unsigned int )x == 19U) {
#line 92
    goto case_19;
  }
#line 93
  if ((unsigned int )x == 20U) {
#line 93
    goto case_20;
  }
#line 94
  if ((unsigned int )x == 21U) {
#line 94
    goto case_21;
  }
#line 95
  if ((unsigned int )x == 22U) {
#line 95
    goto case_22;
  }
#line 96
  if ((unsigned int )x == 23U) {
#line 96
    goto case_23;
  }
#line 97
  if ((unsigned int )x == 24U) {
#line 97
    goto case_24;
  }
#line 98
  if ((unsigned int )x == 25U) {
#line 98
    goto case_25;
  }
#line 99
  if ((unsigned int )x == 26U) {
#line 99
    goto case_26;
  }
#line 100
  goto switch_default;
  case_0: /* CIL Label */ 
#line 73
  return ("End");
  case_1: /* CIL Label */ 
#line 74
  return ("Colormap");
  case_2: /* CIL Label */ 
#line 75
  return ("ActiveLayer");
  case_3: /* CIL Label */ 
#line 76
  return ("ActiveChannel");
  case_4: /* CIL Label */ 
#line 77
  return ("Selection");
  case_5: /* CIL Label */ 
#line 78
  return ("FloatingSelection");
  case_6: /* CIL Label */ 
#line 79
  return ("Opacity");
  case_7: /* CIL Label */ 
#line 80
  return ("Mode");
  case_8: /* CIL Label */ 
#line 81
  return ("Visible");
  case_9: /* CIL Label */ 
#line 82
  return ("Linked");
  case_10: /* CIL Label */ 
#line 83
  return ("PreserveTransparency");
  case_11: /* CIL Label */ 
#line 84
  return ("ApplyMask");
  case_12: /* CIL Label */ 
#line 85
  return ("EditMask");
  case_13: /* CIL Label */ 
#line 86
  return ("ShowMask");
  case_14: /* CIL Label */ 
#line 87
  return ("ShowMasked");
  case_15: /* CIL Label */ 
#line 88
  return ("Offsets");
  case_16: /* CIL Label */ 
#line 89
  return ("Color");
  case_17: /* CIL Label */ 
#line 90
  return ("Compression");
  case_18: /* CIL Label */ 
#line 91
  return ("Guides");
  case_19: /* CIL Label */ 
#line 92
  return ("Resolution");
  case_20: /* CIL Label */ 
#line 93
  return ("Tattoo");
  case_21: /* CIL Label */ 
#line 94
  return ("Parasites");
  case_22: /* CIL Label */ 
#line 95
  return ("Unit");
  case_23: /* CIL Label */ 
#line 96
  return ("Paths");
  case_24: /* CIL Label */ 
#line 97
  return ("UserUnit");
  case_25: /* CIL Label */ 
#line 98
  return ("Vectors");
  case_26: /* CIL Label */ 
#line 99
  return ("TextLayerFlags");
  switch_default: /* CIL Label */ 
  {
#line 100
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"(PropType:%d)",
          (int )x);
  }
#line 101
  return ((char const   *)(buf___2));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___3[33]  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
char const   *showXcfCompressionType(XcfCompressionType x ) 
{ 


  {
  {
#line 109
  if ((unsigned int )x == 0U) {
#line 109
    goto case_0;
  }
#line 110
  if ((unsigned int )x == 1U) {
#line 110
    goto case_1;
  }
#line 111
  if ((unsigned int )x == 2U) {
#line 111
    goto case_2;
  }
#line 112
  if ((unsigned int )x == 3U) {
#line 112
    goto case_3;
  }
#line 113
  goto switch_default;
  case_0: /* CIL Label */ 
#line 109
  return ("None");
  case_1: /* CIL Label */ 
#line 110
  return ("RLE");
  case_2: /* CIL Label */ 
#line 111
  return ("Zlib");
  case_3: /* CIL Label */ 
#line 112
  return ("Fractal");
  switch_default: /* CIL Label */ 
  {
#line 113
  sprintf((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)"(XcfCompressionType:%d)",
          (int )x);
  }
#line 114
  return ((char const   *)(buf___3));
  switch_break: /* CIL Label */ ;
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
int verboseFlag ;
#line 118
 __attribute__((__noreturn__)) void gpl_blurb(void) ;
#line 120
FILE *openout(char const   *name ) ;
#line 121
void closeout(FILE *f , char const   *name ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
char const   *progname  =    "$0";
#line 26 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
int verboseFlag  =    0;
#line 29
static  __attribute__((__noreturn__)) void vFatalGeneric(int status , char const   *format ,
                                                         va_list args ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
static void vFatalGeneric(int status , char const   *format , va_list args ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 32
  if (format) {
#line 33
    if ((int const   )*format == 33) {
      {
#line 34
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(format + 1),
               args);
#line 35
      tmp = __errno_location();
#line 35
      tmp___0 = strerror(*tmp);
#line 35
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
              tmp___0);
      }
    } else {
      {
#line 37
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
               args);
#line 38
      fputc('\n', stderr);
      }
    }
  }
  {
#line 41
  exit(status);
  }
}
}
#line 44
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalGeneric)(int status ,
                                                                            char const   *format 
                                                                            , ...) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void ( /* format attribute */  FatalGeneric)(int status , char const   *format  , ...) 
{ 
  va_list v ;

  {
  {
#line 47
  __builtin_va_start(v, format);
  }
#line 48
  if (format) {
    {
#line 48
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
  }
  {
#line 49
  vFatalGeneric(status, format, v);
  }
}
}
#line 52
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalUnexpected)(char const   *format 
                                                                               , ...) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void ( /* format attribute */  FatalUnexpected)(char const   *format  , ...) 
{ 
  va_list v ;

  {
  {
#line 55
  __builtin_va_start(v, format);
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 57
  vFatalGeneric(127, format, v);
  }
}
}
#line 60
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalBadXCF)(char const   *format 
                                                                           , ...) ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void ( /* format attribute */  FatalBadXCF)(char const   *format  , ...) 
{ 
  va_list v ;
  char *tmp ;

  {
  {
#line 63
  __builtin_va_start(v, format);
#line 64
  tmp = gettext("Corrupted or malformed XCF file");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s:\n ",
          progname, tmp);
#line 65
  vFatalGeneric(125, format, v);
  }
}
}
#line 68 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void ( /* format attribute */  xcfCheckspace)(uint32_t addr , int spaceafter , char const   *format 
                                              , ...) 
{ 
  va_list v ;
  char *tmp ;

  {
#line 71
  if (xcf_length < (size_t )spaceafter) {
    {
#line 72
    __builtin_va_start(v, format);
#line 73
    tmp = gettext("Corrupted or truncated XCF file");
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n ",
            progname, tmp);
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(0x%lX bytes): ",
            xcf_length);
#line 75
    vFatalGeneric(125, format, v);
    }
  } else
#line 71
  if ((size_t )addr > xcf_length - (size_t )spaceafter) {
    {
#line 72
    __builtin_va_start(v, format);
#line 73
    tmp = gettext("Corrupted or truncated XCF file");
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n ",
            progname, tmp);
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(0x%lX bytes): ",
            xcf_length);
#line 75
    vFatalGeneric(125, format, v);
    }
  }
#line 77
  return;
}
}
#line 80
 __attribute__((__noreturn__)) void ( /* format attribute */  FatalUnsupportedXCF)(char const   *format 
                                                                                   , ...) ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void ( /* format attribute */  FatalUnsupportedXCF)(char const   *format  , ...) 
{ 
  va_list v ;
  char *tmp ;

  {
  {
#line 83
  __builtin_va_start(v, format);
#line 84
  tmp = gettext("The image contains features not understood by this program:");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n ",
          progname, tmp);
#line 86
  vFatalGeneric(123, format, v);
  }
}
}
#line 89
 __attribute__((__noreturn__)) void gpl_blurb(void) ;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void gpl_blurb(void) 
{ 
  char *tmp ;

  {
  {
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Xcftools 1.0.7\n");
#line 93
  tmp = gettext("Type \"%s -h\" to get an option summary.\n");
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, progname);
#line 95
  exit(1);
  }
}
}
#line 100 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void *xcfmalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 103
  tmp = malloc(size);
#line 103
  ptr = tmp;
  }
#line 104
  if (! ptr) {
    {
#line 105
    tmp___0 = gettext("Out of memory");
#line 105
    FatalUnexpected((char const   *)tmp___0);
    }
  }
#line 106
  return (ptr);
}
}
#line 109 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void xcffree(void *block ) 
{ 


  {
#line 112
  if (xcf_file) {
#line 112
    if ((unsigned long )((uint8_t *)block) >= (unsigned long )xcf_file) {
#line 112
      if (! ((unsigned long )((uint8_t *)block) < (unsigned long )(xcf_file + xcf_length))) {
        {
#line 117
        free(block);
        }
      }
    } else {
      {
#line 117
      free(block);
      }
    }
  } else {
    {
#line 117
    free(block);
    }
  }
#line 118
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
FILE *openout(char const   *name ) 
{ 
  FILE *newfile ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 126
  tmp = strcmp(name, "-");
  }
#line 126
  if (tmp == 0) {
#line 127
    return (stdout);
  }
  {
#line 128
  newfile = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"wb");
  }
#line 129
  if ((unsigned long )newfile == (unsigned long )((void *)0)) {
    {
#line 130
    tmp___0 = gettext("!Cannot create file %s");
#line 130
    FatalUnexpected((char const   *)tmp___0, name);
    }
  }
#line 131
  return (newfile);
}
}
#line 134 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
void closeout(FILE *f , char const   *name ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 137
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 138
    return;
  }
  {
#line 139
  tmp___6 = fflush(f);
  }
#line 139
  if (tmp___6 == 0) {
    {
#line 140
    tmp = __errno_location();
#line 140
    *tmp = 0;
#line 141
    tmp___5 = ferror(f);
    }
#line 141
    if (tmp___5) {
      {
#line 144
      tmp___4 = __errno_location();
      }
#line 144
      if (*tmp___4 == 0) {
        {
#line 149
        tmp___2 = fputc('\000', f);
        }
#line 149
        if (tmp___2 != -1) {
          {
#line 149
          tmp___3 = fflush(f);
          }
#line 149
          if (tmp___3 == 0) {
            {
#line 151
            tmp___1 = __errno_location();
#line 151
            *tmp___1 = 5;
            }
          }
        }
      }
    } else {
      {
#line 142
      tmp___0 = fclose(f);
      }
#line 142
      if (tmp___0 == 0) {
#line 143
        return;
      }
    }
  }
  {
#line 154
  tmp___7 = gettext("!Error writing file %s");
#line 154
  FatalUnexpected((char const   *)tmp___7, name);
  }
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.h"
void flattenIncrementally(struct FlattenSpec *spec , void (*callback)(unsigned int num ,
                                                                      rgba *pixels ) ) ;
#line 74
rgba **flattenAll(struct FlattenSpec *spec ) ;
#line 75
void shipoutWithCallback(struct FlattenSpec *spec , rgba **pixels , void (*callback)(unsigned int num ,
                                                                                     rgba *pixels ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static rgba ( __attribute__((__noinline__)) composite_one)(rgba bot , rgba top )  __attribute__((__const__)) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static rgba ( __attribute__((__noinline__)) composite_one)(rgba bot , rgba top ) 
{ 
  unsigned int tfrac ;
  unsigned int alpha ;

  {
#line 31
  tfrac = (unsigned int )((uint8_t )top);
#line 32
  alpha = 255U;
#line 33
  if (! ((int )((uint8_t )bot) == 255)) {
#line 34
    alpha = (unsigned int )(255 ^ (int )scaletable[255 - (int )((uint8_t )bot)][255 - (int )((uint8_t )top)]);
#line 38
    tfrac = (unsigned int )(256 * (int )((uint8_t )top) - 1) / alpha;
  }
#line 62
  return ((((((alpha + ((uint32_t )scaletable[tfrac][255U & (top >> 8)] << 8)) + ((uint32_t )scaletable[tfrac][255U & (top >> 16)] << 16)) + ((uint32_t )scaletable[tfrac][255U & (top >> 24)] << 24)) + ((uint32_t )scaletable[255U ^ tfrac][255U & (bot >> 8)] << 8)) + ((uint32_t )scaletable[255U ^ tfrac][255U & (bot >> 16)] << 16)) + ((uint32_t )scaletable[255U ^ tfrac][255U & (bot >> 24)] << 24));
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static struct Tile *( __attribute__((__noinline__)) merge_normal)(struct Tile *bot ,
                                                                  struct Tile *top ) 
{ 
  unsigned int i ;
  int tmp ;
  unsigned int i___0 ;

  {
#line 80
  if (! (bot->count == top->count)) {
    {
#line 80
    __assert_fail("(bot)->count==(top)->count", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                  80U, "merge_normal");
    }
  }
#line 83
  if (bot->summary & 4) {
    {
#line 85
    freeTile(bot);
    }
#line 86
    return (top);
  } else
#line 83
  if (top->summary & 2) {
    {
#line 85
    freeTile(bot);
    }
#line 86
    return (top);
  }
#line 88
  if (top->summary & 4) {
    {
#line 89
    freeTile(top);
    }
#line 90
    return (bot);
  }
#line 94
  i = 0U;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (i == top->count) {
      {
#line 96
      freeTile(bot);
      }
#line 97
      return (top);
    }
#line 99
    if (! ((int )((uint8_t )bot->pixels[i]) == 0)) {
#line 99
      if (! ((int )((uint8_t )top->pixels[i]) == 255)) {
#line 100
        goto while_break;
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if (ok_scaletable) {
#line 103
    tmp = 1;
  } else
#line 103
  if (! (! (top->summary & 1))) {
#line 103
    tmp = 1;
  } else {
    {
#line 103
    mk_scaletable();
#line 103
    tmp = 0;
    }
  }
#line 106
  if ((top->summary & 4) == 0) {
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 108
      if (! (bot->refcount == 1)) {
        {
#line 108
        __assert_fail("(bot)->refcount==1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                      108U, "merge_normal");
        }
      }
#line 108
      bot->summary = 0;
#line 108
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 109
    i___0 = 0U;
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      if (! (i___0 < top->count)) {
#line 109
        goto while_break___1;
      }
#line 110
      if (! ((int )((uint8_t )top->pixels[i___0]) == 0)) {
#line 111
        if ((int )((uint8_t )top->pixels[i___0]) == 255) {
#line 112
          bot->pixels[i___0] = top->pixels[i___0];
        } else
#line 111
        if ((int )((uint8_t )bot->pixels[i___0]) == 0) {
#line 112
          bot->pixels[i___0] = top->pixels[i___0];
        } else {
          {
#line 114
          bot->pixels[i___0] = composite_one(bot->pixels[i___0], top->pixels[i___0]);
          }
        }
      }
#line 109
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 118
  freeTile(top);
  }
#line 119
  return (bot);
}
}
#line 126
__inline static unsigned int ucombine_ADDITION(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 126 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_ADDITION(uint8_t bot , uint8_t top ) 
{ 
  int tmp ;

  {
#line 129
  if ((int )bot + (int )top > 255) {
#line 129
    tmp = 255;
  } else {
#line 129
    tmp = (int )bot + (int )top;
  }
#line 129
  return ((unsigned int )tmp);
}
}
#line 132
__inline static unsigned int ucombine_SUBTRACT(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 132 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_SUBTRACT(uint8_t bot , uint8_t top ) 
{ 
  int tmp ;

  {
#line 135
  if ((int )top > (int )bot) {
#line 135
    tmp = 0;
  } else {
#line 135
    tmp = (int )bot - (int )top;
  }
#line 135
  return ((unsigned int )tmp);
}
}
#line 138
__inline static unsigned int ucombine_LIGHTEN_ONLY(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 138 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_LIGHTEN_ONLY(uint8_t bot , uint8_t top ) 
{ 
  int tmp ;

  {
#line 141
  if ((int )top > (int )bot) {
#line 141
    tmp = (int )top;
  } else {
#line 141
    tmp = (int )bot;
  }
#line 141
  return ((unsigned int )tmp);
}
}
#line 144
__inline static unsigned int ucombine_DARKEN_ONLY(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 144 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_DARKEN_ONLY(uint8_t bot , uint8_t top ) 
{ 
  int tmp ;

  {
#line 147
  if ((int )top < (int )bot) {
#line 147
    tmp = (int )top;
  } else {
#line 147
    tmp = (int )bot;
  }
#line 147
  return ((unsigned int )tmp);
}
}
#line 150
__inline static unsigned int ucombine_DIFFERENCE(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_DIFFERENCE(uint8_t bot , uint8_t top ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )top > (int )bot) {
#line 153
    tmp = (int )top - (int )bot;
  } else {
#line 153
    tmp = (int )bot - (int )top;
  }
#line 153
  return ((unsigned int )tmp);
}
}
#line 156
__inline static unsigned int ucombine_MULTIPLY(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 156 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_MULTIPLY(uint8_t bot , uint8_t top ) 
{ 


  {
#line 159
  return ((unsigned int )scaletable[bot][top]);
}
}
#line 162
__inline static unsigned int ucombine_DIVIDE(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_DIVIDE(uint8_t bot , uint8_t top ) 
{ 
  int result ;
  int tmp ;

  {
#line 165
  result = ((int )bot * 256) / (1 + (int )top);
#line 166
  if (result >= 256) {
#line 166
    tmp = 255;
  } else {
#line 166
    tmp = result;
  }
#line 166
  return ((unsigned int )tmp);
}
}
#line 169
__inline static unsigned int ucombine_SCREEN(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_SCREEN(uint8_t bot , uint8_t top ) 
{ 


  {
#line 173
  return ((unsigned int )(255 ^ (int )scaletable[255 - (int )bot][255 - (int )top]));
}
}
#line 176
__inline static unsigned int ucombine_OVERLAY(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 176 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_OVERLAY(uint8_t bot , uint8_t top ) 
{ 


  {
#line 179
  return ((unsigned int )((int )scaletable[bot][bot] + 2 * (int )scaletable[top][scaletable[bot][255 - (int )bot]]));
}
}
#line 191
__inline static unsigned int ucombine_DODGE(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 191 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_DODGE(uint8_t bot , uint8_t top ) 
{ 
  unsigned int tmp ;

  {
  {
#line 194
  tmp = ucombine_DIVIDE(bot, (uint8_t )(255 - (int )top));
  }
#line 194
  return (tmp);
}
}
#line 197
__inline static unsigned int ucombine_BURN(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 197 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_BURN(uint8_t bot , uint8_t top ) 
{ 
  unsigned int tmp ;

  {
  {
#line 200
  tmp = ucombine_DIVIDE((uint8_t )(255 - (int )bot), top);
  }
#line 200
  return (255U - tmp);
}
}
#line 203
__inline static unsigned int ucombine_HARDLIGHT(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 203 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_HARDLIGHT(uint8_t bot , uint8_t top ) 
{ 


  {
#line 206
  if ((int )top >= 128) {
#line 207
    return ((unsigned int )(255 ^ (int )scaletable[255 - (int )bot][2 * (255 - (int )top)]));
  } else {
#line 209
    return ((unsigned int )scaletable[bot][2 * (int )top]);
  }
}
}
#line 215
__inline static unsigned int ucombine_GRAIN_EXTRACT(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 215 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_GRAIN_EXTRACT(uint8_t bot , uint8_t top ) 
{ 
  int temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 218
  temp = ((int )bot - (int )top) + 128;
#line 219
  if (temp < 0) {
#line 219
    tmp___0 = 0;
  } else {
#line 219
    if (temp >= 256) {
#line 219
      tmp = 255;
    } else {
#line 219
      tmp = temp;
    }
#line 219
    tmp___0 = tmp;
  }
#line 219
  return ((unsigned int )tmp___0);
}
}
#line 222
__inline static unsigned int ucombine_GRAIN_MERGE(uint8_t bot , uint8_t top )  __attribute__((__const__)) ;
#line 222 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
__inline static unsigned int ucombine_GRAIN_MERGE(uint8_t bot , uint8_t top ) 
{ 
  int temp ;
  int tmp ;
  int tmp___0 ;

  {
#line 225
  temp = ((int )bot + (int )top) - 128;
#line 226
  if (temp < 0) {
#line 226
    tmp___0 = 0;
  } else {
#line 226
    if (temp >= 256) {
#line 226
      tmp = 255;
    } else {
#line 226
      tmp = temp;
    }
#line 226
    tmp___0 = tmp;
  }
#line 226
  return ((unsigned int )tmp___0);
}
}
#line 235 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static void RGBtoHSV(rgba rgb , struct HSV *hsv ) 
{ 
  unsigned int RED ;
  unsigned int GREEN ;
  unsigned int BLUE ;

  {
#line 238
  RED = (unsigned int )((uint8_t )(rgb >> 8));
#line 239
  GREEN = (unsigned int )((uint8_t )(rgb >> 16));
#line 240
  BLUE = (unsigned int )((uint8_t )(rgb >> 24));
#line 243
  if (GREEN <= RED) {
#line 244
    if (BLUE <= RED) {
#line 245
      if (GREEN <= BLUE) {
#line 246
        hsv->ch1 = GREEN;
#line 246
        hsv->ch2 = BLUE;
#line 246
        hsv->ch3 = RED;
#line 246
        hsv->hue = (enum __anonenum_hue_40 )4;
      } else {
#line 248
        hsv->ch1 = BLUE;
#line 248
        hsv->ch2 = GREEN;
#line 248
        hsv->ch3 = RED;
#line 248
        hsv->hue = (enum __anonenum_hue_40 )3;
      }
    } else {
#line 250
      hsv->ch1 = GREEN;
#line 250
      hsv->ch2 = RED;
#line 250
      hsv->ch3 = BLUE;
#line 250
      hsv->hue = (enum __anonenum_hue_40 )5;
    }
  } else
#line 251
  if (BLUE <= RED) {
#line 252
    hsv->ch1 = BLUE;
#line 252
    hsv->ch2 = RED;
#line 252
    hsv->ch3 = GREEN;
#line 252
    hsv->hue = (enum __anonenum_hue_40 )2;
  } else
#line 253
  if (BLUE <= GREEN) {
#line 254
    hsv->ch1 = RED;
#line 254
    hsv->ch2 = BLUE;
#line 254
    hsv->ch3 = GREEN;
#line 254
    hsv->hue = (enum __anonenum_hue_40 )1;
  } else {
#line 256
    hsv->ch1 = RED;
#line 256
    hsv->ch2 = GREEN;
#line 256
    hsv->ch3 = BLUE;
#line 256
    hsv->hue = (enum __anonenum_hue_40 )0;
  }
#line 258
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static struct HSV hsvTop  ;
#line 312 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static struct HSV hsvBot  ;
#line 263 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static void ( __attribute__((__noinline__)) merge_exotic)(struct Tile *bot , struct Tile  const  *top ,
                                                          GimpLayerModeEffects mode ) 
{ 
  unsigned int i ;
  int tmp ;
  uint32_t RED ;
  uint32_t GREEN ;
  uint32_t BLUE ;
  unsigned int mfNum ;
  unsigned int mfDenom ;
  unsigned int L ;
  unsigned int sNum ;
  unsigned int sDenom ;
  unsigned int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  rgba bp ;
  unsigned int tfrac ;
  unsigned int pseudotop ;
  unsigned int tmp___4 ;
  unsigned int alpha ;

  {
#line 268
  if (! (bot->count == (unsigned int )top->count)) {
    {
#line 268
    __assert_fail("(bot)->count==(top)->count", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                  268U, "merge_exotic");
    }
  }
#line 269
  if ((bot->summary & 4) != 0) {
#line 269
    return;
  }
#line 270
  if ((top->summary & 4) != 0) {
#line 270
    return;
  }
#line 271
  if (! (bot->refcount == 1)) {
    {
#line 271
    __assert_fail("bot->refcount == 1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                  271U, "merge_exotic");
    }
  }
#line 274
  if (ok_scaletable) {
#line 274
    tmp = 1;
  } else {
    {
#line 274
    mk_scaletable();
#line 274
    tmp = 0;
    }
  }
#line 276
  i = 0U;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (i < (unsigned int )top->count)) {
#line 276
      goto while_break;
    }
#line 278
    if ((int )((uint8_t )bot->pixels[i]) == 0) {
#line 279
      goto __Cont;
    } else
#line 278
    if ((int )((uint8_t )top->pixels[i]) == 0) {
#line 279
      goto __Cont;
    }
    {
#line 290
    if ((int )mode == 1) {
#line 290
      goto case_1;
    }
#line 290
    if ((int )mode == 0) {
#line 290
      goto case_1;
    }
#line 292
    if ((int )mode == 7) {
#line 292
      goto case_7;
    }
#line 293
    if ((int )mode == 8) {
#line 293
      goto case_8;
    }
#line 294
    if ((int )mode == 10) {
#line 294
      goto case_10;
    }
#line 295
    if ((int )mode == 9) {
#line 295
      goto case_9;
    }
#line 296
    if ((int )mode == 6) {
#line 296
      goto case_6;
    }
#line 297
    if ((int )mode == 3) {
#line 297
      goto case_3;
    }
#line 298
    if ((int )mode == 15) {
#line 298
      goto case_15;
    }
#line 299
    if ((int )mode == 4) {
#line 299
      goto case_4;
    }
#line 301
    if ((int )mode == 5) {
#line 301
      goto case_5;
    }
#line 301
    if ((int )mode == 19) {
#line 301
      goto case_5;
    }
#line 302
    if ((int )mode == 16) {
#line 302
      goto case_16;
    }
#line 303
    if ((int )mode == 17) {
#line 303
      goto case_17;
    }
#line 304
    if ((int )mode == 18) {
#line 304
      goto case_18;
    }
#line 305
    if ((int )mode == 20) {
#line 305
      goto case_20;
    }
#line 306
    if ((int )mode == 21) {
#line 306
      goto case_21;
    }
#line 310
    if ((int )mode == 13) {
#line 310
      goto case_13;
    }
#line 310
    if ((int )mode == 14) {
#line 310
      goto case_13;
    }
#line 310
    if ((int )mode == 12) {
#line 310
      goto case_13;
    }
#line 310
    if ((int )mode == 11) {
#line 310
      goto case_13;
    }
#line 387
    goto switch_default___0;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 291
    FatalUnexpected("Normal and Dissolve mode can\'t happen here!");
    }
    case_7: /* CIL Label */ 
    {
#line 292
    RED = ucombine_ADDITION((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 292
    GREEN = ucombine_ADDITION((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 292
    BLUE = ucombine_ADDITION((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 292
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 293
    RED = ucombine_SUBTRACT((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 293
    GREEN = ucombine_SUBTRACT((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 293
    BLUE = ucombine_SUBTRACT((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 293
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 294
    RED = ucombine_LIGHTEN_ONLY((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 294
    GREEN = ucombine_LIGHTEN_ONLY((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 294
    BLUE = ucombine_LIGHTEN_ONLY((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 294
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 295
    RED = ucombine_DARKEN_ONLY((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 295
    GREEN = ucombine_DARKEN_ONLY((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 295
    BLUE = ucombine_DARKEN_ONLY((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 295
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 296
    RED = ucombine_DIFFERENCE((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 296
    GREEN = ucombine_DIFFERENCE((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 296
    BLUE = ucombine_DIFFERENCE((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 296
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 297
    RED = ucombine_MULTIPLY((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 297
    GREEN = ucombine_MULTIPLY((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 297
    BLUE = ucombine_MULTIPLY((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 297
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 298
    RED = ucombine_DIVIDE((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 298
    GREEN = ucombine_DIVIDE((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 298
    BLUE = ucombine_DIVIDE((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 298
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 299
    RED = ucombine_SCREEN((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 299
    GREEN = ucombine_SCREEN((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 299
    BLUE = ucombine_SCREEN((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 299
    goto switch_break;
    case_5: /* CIL Label */ 
    case_19: /* CIL Label */ 
    {
#line 301
    RED = ucombine_OVERLAY((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 301
    GREEN = ucombine_OVERLAY((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 301
    BLUE = ucombine_OVERLAY((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 301
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 302
    RED = ucombine_DODGE((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 302
    GREEN = ucombine_DODGE((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 302
    BLUE = ucombine_DODGE((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 302
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 303
    RED = ucombine_BURN((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 303
    GREEN = ucombine_BURN((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 303
    BLUE = ucombine_BURN((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 303
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 304
    RED = ucombine_HARDLIGHT((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 304
    GREEN = ucombine_HARDLIGHT((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 304
    BLUE = ucombine_HARDLIGHT((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 304
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 305
    RED = ucombine_GRAIN_EXTRACT((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 305
    GREEN = ucombine_GRAIN_EXTRACT((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 305
    BLUE = ucombine_GRAIN_EXTRACT((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 305
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 306
    RED = ucombine_GRAIN_MERGE((uint8_t )(bot->pixels[i] >> 8), (uint8_t )(top->pixels[i] >> 8));
#line 306
    GREEN = ucombine_GRAIN_MERGE((uint8_t )(bot->pixels[i] >> 16), (uint8_t )(top->pixels[i] >> 16));
#line 306
    BLUE = ucombine_GRAIN_MERGE((uint8_t )(bot->pixels[i] >> 24), (uint8_t )(top->pixels[i] >> 24));
    }
#line 306
    goto switch_break;
    case_13: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    {
#line 313
    RGBtoHSV(top->pixels[i], & hsvTop);
    }
#line 314
    if ((int )mode == 11) {
#line 314
      if (hsvTop.ch1 == hsvTop.ch3) {
#line 315
        goto __Cont;
      }
    }
    {
#line 316
    RGBtoHSV(bot->pixels[i], & hsvBot);
    }
#line 317
    if ((int )mode == 14) {
#line 318
      if (hsvBot.ch3) {
#line 319
        hsvBot.ch1 = (hsvBot.ch1 * hsvTop.ch3 + hsvBot.ch3 / 2U) / hsvBot.ch3;
#line 320
        hsvBot.ch2 = (hsvBot.ch2 * hsvTop.ch3 + hsvBot.ch3 / 2U) / hsvBot.ch3;
#line 321
        hsvBot.ch3 = hsvTop.ch3;
      } else {
#line 323
        hsvBot.ch3 = hsvTop.ch3;
#line 323
        hsvBot.ch2 = hsvBot.ch3;
#line 323
        hsvBot.ch1 = hsvBot.ch2;
      }
    } else {
#line 327
      if ((int )mode == 11) {
#line 328
        mfNum = hsvTop.ch2 - hsvTop.ch1;
#line 329
        mfDenom = hsvTop.ch3 - hsvTop.ch1;
#line 330
        hsvBot.hue = hsvTop.hue;
      } else
#line 327
      if ((int )mode == 13) {
#line 328
        mfNum = hsvTop.ch2 - hsvTop.ch1;
#line 329
        mfDenom = hsvTop.ch3 - hsvTop.ch1;
#line 330
        hsvBot.hue = hsvTop.hue;
      } else {
#line 332
        mfNum = hsvBot.ch2 - hsvBot.ch1;
#line 333
        mfDenom = hsvBot.ch3 - hsvBot.ch1;
      }
#line 335
      if ((int )mode == 12) {
#line 336
        if (hsvTop.ch3 == 0U) {
#line 337
          hsvBot.ch1 = hsvBot.ch3;
        } else {
#line 339
          hsvBot.ch1 = (hsvTop.ch1 * hsvBot.ch3 + hsvTop.ch3 / 2U) / hsvTop.ch3;
        }
      } else
#line 340
      if ((int )mode == 13) {
#line 345
        L = hsvTop.ch1 + hsvTop.ch3;
#line 346
        sNum = hsvTop.ch3 - hsvTop.ch1;
#line 347
        if (L < 256U) {
#line 347
          tmp___0 = L;
        } else {
#line 347
          tmp___0 = 510U - L;
        }
#line 347
        sDenom = tmp___0;
#line 348
        if (sDenom == 0U) {
#line 348
          sDenom = 1U;
        }
#line 349
        L = hsvBot.ch1 + hsvBot.ch3;
#line 350
        if (L < 256U) {
#line 356
          hsvBot.ch1 = ((L * (sDenom - sNum) + sDenom) - 1U) / (2U * sDenom);
#line 357
          hsvBot.ch3 = L - hsvBot.ch1;
        } else {
#line 360
          hsvBot.ch3 = 255U - (((510U - L) * (sDenom - sNum) + sDenom) - 1U) / (2U * sDenom);
#line 361
          hsvBot.ch1 = L - hsvBot.ch3;
        }
#line 363
        if (! (hsvBot.ch3 <= 255U)) {
          {
#line 363
          __assert_fail("hsvBot.ch3 <= 255", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                        363U, "merge_exotic");
          }
        }
#line 364
        if (! (hsvBot.ch3 >= hsvBot.ch1)) {
          {
#line 364
          __assert_fail("hsvBot.ch3 >= hsvBot.ch1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                        364U, "merge_exotic");
          }
        }
      }
#line 366
      if (mfDenom == 0U) {
#line 367
        hsvBot.ch2 = hsvBot.ch1;
      } else {
#line 369
        hsvBot.ch2 = hsvBot.ch1 + (mfNum * (hsvBot.ch3 - hsvBot.ch1) + mfDenom / 2U) / mfDenom;
      }
    }
    {
#line 375
    if ((unsigned int )hsvBot.hue == 0U) {
#line 375
      goto case_0___0;
    }
#line 376
    if ((unsigned int )hsvBot.hue == 1U) {
#line 376
      goto case_1___0;
    }
#line 377
    if ((unsigned int )hsvBot.hue == 2U) {
#line 377
      goto case_2;
    }
#line 378
    if ((unsigned int )hsvBot.hue == 3U) {
#line 378
      goto case_3___0;
    }
#line 379
    if ((unsigned int )hsvBot.hue == 4U) {
#line 379
      goto case_4___0;
    }
#line 380
    if ((unsigned int )hsvBot.hue == 5U) {
#line 380
      goto case_5___0;
    }
#line 382
    goto switch_default;
    case_0___0: /* CIL Label */ 
#line 375
    RED = hsvBot.ch1;
#line 375
    GREEN = hsvBot.ch2;
#line 375
    BLUE = hsvBot.ch3;
#line 375
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 376
    RED = hsvBot.ch1;
#line 376
    BLUE = hsvBot.ch2;
#line 376
    GREEN = hsvBot.ch3;
#line 376
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 377
    BLUE = hsvBot.ch1;
#line 377
    RED = hsvBot.ch2;
#line 377
    GREEN = hsvBot.ch3;
#line 377
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 378
    BLUE = hsvBot.ch1;
#line 378
    GREEN = hsvBot.ch2;
#line 378
    RED = hsvBot.ch3;
#line 378
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 379
    GREEN = hsvBot.ch1;
#line 379
    BLUE = hsvBot.ch2;
#line 379
    RED = hsvBot.ch3;
#line 379
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 380
    GREEN = hsvBot.ch1;
#line 380
    RED = hsvBot.ch2;
#line 380
    BLUE = hsvBot.ch3;
#line 380
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 383
    FatalUnexpected("Hue hextant is %d", (unsigned int )hsvBot.hue);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 385
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 388
    tmp___1 = showGimpLayerModeEffects(mode);
#line 388
    tmp___2 = gettext(tmp___1);
#line 388
    tmp___3 = gettext("\'%s\' layer mode");
#line 388
    FatalUnsupportedXCF((char const   *)tmp___3, tmp___2);
    }
    switch_break: /* CIL Label */ ;
    }
#line 391
    if ((int )((uint8_t )(bot->pixels[i] & top->pixels[i])) == 255) {
#line 392
      bot->pixels[i] = (((bot->pixels[i] & 255U) + (RED << 8)) + (GREEN << 16)) + (BLUE << 24);
    } else {
#line 397
      bp = bot->pixels[i];
#line 405
      tfrac = (unsigned int )((uint8_t )top->pixels[i]);
#line 406
      if (! ((int )((uint8_t )bp) == 255)) {
#line 407
        if (tfrac < (unsigned int )((uint8_t )bp)) {
#line 407
          tmp___4 = tfrac;
        } else {
#line 407
          tmp___4 = (unsigned int )((uint8_t )bp);
        }
#line 407
        pseudotop = tmp___4;
#line 408
        alpha = (unsigned int )(255 ^ (int )scaletable[255 - (int )((uint8_t )bp)][255U - pseudotop]);
#line 409
        tfrac = (256U * pseudotop - 1U) / alpha;
      }
#line 411
      bot->pixels[i] = ((((((bp & 255U) + ((rgba )scaletable[tfrac][RED] << 8)) + ((rgba )scaletable[tfrac][GREEN] << 16)) + ((rgba )scaletable[tfrac][BLUE] << 24)) + ((rgba )scaletable[255U ^ tfrac][255U & (bp >> 8)] << 8)) + ((rgba )scaletable[255U ^ tfrac][255U & (bp >> 16)] << 16)) + ((rgba )scaletable[255U ^ tfrac][255U & (bp >> 24)] << 24);
    }
    __Cont: /* CIL Label */ 
#line 276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static void dissolveTile(struct Tile *tile ) 
{ 
  unsigned int i ;
  summary_t summary ;
  int tmp ;

  {
#line 428
  if (! (tile->refcount == 1)) {
    {
#line 428
    __assert_fail("tile->refcount == 1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                  428U, "dissolveTile");
    }
  }
#line 429
  if (tile->summary & 1) {
#line 430
    return;
  }
#line 431
  summary = 15;
#line 433
  i = 0U;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (i < tile->count)) {
#line 433
      goto while_break;
    }
#line 434
    if ((int )((uint8_t )tile->pixels[i]) == 255) {
#line 435
      summary &= -5;
    } else
#line 436
    if ((int )((uint8_t )tile->pixels[i]) == 0) {
#line 437
      summary &= -3;
    } else {
      {
#line 438
      tmp = rand();
      }
#line 438
      if ((int )((uint8_t )tile->pixels[i]) > tmp % 255) {
#line 439
        tile->pixels[i] |= 255U;
#line 440
        summary &= -5;
      } else {
#line 442
        tile->pixels[i] = (rgba )0;
#line 443
        summary &= -3;
      }
    }
#line 433
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  tile->summary = summary;
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static void roundAlpha(struct Tile *tile ) 
{ 
  unsigned int i ;
  summary_t summary ;

  {
#line 454
  if (! (tile->refcount == 1)) {
    {
#line 454
    __assert_fail("tile->refcount == 1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                  454U, "roundAlpha");
    }
  }
#line 455
  if (tile->summary & 1) {
#line 456
    return;
  }
#line 457
  summary = 15;
#line 459
  i = 0U;
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! (i < tile->count)) {
#line 459
      goto while_break;
    }
#line 460
    if ((int )((uint8_t )tile->pixels[i]) >= 128) {
#line 461
      tile->pixels[i] |= 255U;
#line 462
      summary &= -5;
    } else {
#line 464
      tile->pixels[i] = (rgba )0;
#line 465
      summary &= -3;
    }
#line 459
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  tile->summary = summary;
#line 469
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static struct Tile *flattenTopdown(struct FlattenSpec *spec , struct Tile *top , unsigned int nlayers ,
                                   struct rect  const  *where ) 
{ 
  struct Tile *tile ;
  summary_t __attribute__((__pure__))  tmp ;
  struct Tile *below ;
  struct Tile *above ;
  unsigned int i ;
  rgba tile_or ;
  summary_t summary ;
  unsigned int tmp___0 ;

  {
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    tmp___0 = nlayers;
#line 480
    nlayers --;
#line 480
    if (! tmp___0) {
#line 480
      goto while_break;
    }
    {
#line 481
    tmp = tileSummary(top);
    }
#line 481
    if (tmp & (int __attribute__((__pure__))  )2) {
#line 482
      return (top);
    }
#line 483
    if (! (spec->layers + nlayers)->isVisible) {
#line 484
      goto while_continue;
    }
    {
#line 486
    tile = getLayerTile(spec->layers + nlayers, where);
    }
#line 488
    if (tile->summary & 4) {
#line 489
      goto while_continue;
    }
    {
#line 492
    if ((int )(spec->layers + nlayers)->mode == -1) {
#line 492
      goto case_neg_1;
    }
#line 496
    if ((int )(spec->layers + nlayers)->mode == 1) {
#line 496
      goto case_1;
    }
#line 500
    if ((int )(spec->layers + nlayers)->mode == 0) {
#line 500
      goto case_0;
    }
#line 503
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 493
    roundAlpha(tile);
    }
#line 495
    if (0) {
      case_1: /* CIL Label */ 
      {
#line 497
      dissolveTile(tile);
      }
    }
    case_0: /* CIL Label */ 
    {
#line 501
    top = merge_normal(tile, top);
    }
#line 502
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 507
    if (! (top->summary & 4)) {
#line 508
      tile_or = (rgba )0;
      {
#line 509
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 509
        if (! (tile->refcount == 1)) {
          {
#line 509
          __assert_fail("(tile)->refcount==1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                        509U, "flattenTopdown");
          }
        }
#line 509
        tile->summary = 0;
#line 509
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 510
      i = 0U;
      {
#line 510
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 510
        if (! (i < top->count)) {
#line 510
          goto while_break___1;
        }
#line 511
        if ((int )((uint8_t )top->pixels[i]) == 255) {
#line 512
          tile->pixels[i] = (rgba )0;
        } else {
#line 514
          tile_or |= tile->pixels[i];
        }
#line 510
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 518
      if ((int )((uint8_t )tile_or) == 0) {
        {
#line 519
        freeTile(tile);
        }
#line 520
        goto switch_break;
      }
    }
#line 524
    if (top->summary & 1) {
      {
#line 525
      above = forkTile(top);
      }
    } else {
      {
#line 527
      summary = 4;
#line 528
      above = newTile((struct rect )*where);
#line 529
      i = 0U;
      }
      {
#line 529
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 529
        if (! (i < top->count)) {
#line 529
          goto while_break___2;
        }
#line 530
        if ((int )((uint8_t )top->pixels[i]) == 255) {
#line 531
          above->pixels[i] = (rgba )-1;
#line 532
          summary = 0;
        } else {
#line 534
          above->pixels[i] = (rgba )0;
        }
#line 529
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 535
      above->summary = 9 + summary;
    }
    {
#line 537
    below = flattenTopdown(spec, above, nlayers, where);
    }
#line 538
    if (below->refcount > 1) {
#line 539
      if (! ((unsigned long )below == (unsigned long )top)) {
        {
#line 539
        __assert_fail("below == top", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                      539U, "flattenTopdown");
        }
      }
      {
#line 544
      freeTile(below);
      }
#line 545
      return (top);
    }
    {
#line 547
    merge_exotic(below, (struct Tile  const  *)tile, (spec->layers + nlayers)->mode);
#line 548
    freeTile(tile);
#line 549
    top = merge_normal(below, top);
    }
#line 550
    return (top);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (top);
}
}
#line 557 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static void addBackground(struct FlattenSpec *spec , struct Tile *tile , unsigned int ncols ) 
{ 
  unsigned int i ;
  summary_t __attribute__((__pure__))  tmp ;
  char *tmp___0 ;
  summary_t __attribute__((__pure__))  tmp___1 ;
  int tmp___2 ;
  rgba fillwith ;
  int tmp___3 ;
  int tmp___4 ;
  summary_t __attribute__((__pure__))  tmp___5 ;

  {
  {
#line 562
  tmp = tileSummary(tile);
  }
#line 562
  if (tmp & (int __attribute__((__pure__))  )2) {
#line 563
    return;
  }
  {
#line 566
  if ((unsigned int )spec->partial_transparency_mode == 2U) {
#line 566
    goto case_2;
  }
#line 570
  if ((unsigned int )spec->partial_transparency_mode == 1U) {
#line 570
    goto case_1;
  }
#line 574
  if ((unsigned int )spec->partial_transparency_mode == 3U) {
#line 574
    goto case_3;
  }
#line 574
  if ((unsigned int )spec->partial_transparency_mode == 0U) {
#line 574
    goto case_3;
  }
#line 565
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 567
  tmp___1 = tileSummary(tile);
  }
#line 567
  if (! (tmp___1 & (int __attribute__((__pure__))  )1)) {
    {
#line 568
    tmp___0 = gettext("Flattened image has partially transparent pixels");
#line 568
    FatalGeneric(102, (char const   *)tmp___0);
    }
  }
#line 569
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 571
  dissolveTile(tile);
  }
#line 572
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 575
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 578
  if (spec->default_pixel == 200U) {
#line 579
    if (ok_scaletable) {
#line 579
      tmp___2 = 1;
    } else
#line 579
    if (! (! (tile->summary & 1))) {
#line 579
      tmp___2 = 1;
    } else {
      {
#line 579
      mk_scaletable();
#line 579
      tmp___2 = 0;
      }
    }
#line 580
    i = 0U;
    {
#line 580
    while (1) {
      while_continue: /* CIL Label */ ;
#line 580
      if (! (i < tile->count)) {
#line 580
        goto while_break;
      }
#line 581
      if (! ((int )((uint8_t )tile->pixels[i]) == 255)) {
#line 582
        if ((i / ncols ^ i % ncols) & 8U) {
#line 582
          tmp___3 = 102;
        } else {
#line 582
          tmp___3 = 153;
        }
#line 582
        fillwith = (rgba )tmp___3;
#line 583
        fillwith = (rgba )(graytable[fillwith] + 255U);
#line 584
        if ((int )((uint8_t )tile->pixels[i]) == 0) {
#line 585
          tile->pixels[i] = fillwith;
        } else {
          {
#line 587
          tile->pixels[i] = composite_one(fillwith, tile->pixels[i]);
          }
        }
      }
#line 580
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 589
    tile->summary = 11;
#line 591
    return;
  }
#line 593
  if (! ((int )((uint8_t )spec->default_pixel) == 255)) {
#line 593
    return;
  }
  {
#line 594
  tmp___5 = tileSummary(tile);
  }
#line 594
  if (tmp___5 & (int __attribute__((__pure__))  )4) {
    {
#line 595
    fillTile(tile, spec->default_pixel);
    }
  } else {
#line 597
    if (ok_scaletable) {
#line 597
      tmp___4 = 1;
    } else
#line 597
    if (! (! (tile->summary & 1))) {
#line 597
      tmp___4 = 1;
    } else {
      {
#line 597
      mk_scaletable();
#line 597
      tmp___4 = 0;
      }
    }
#line 598
    i = 0U;
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! (i < tile->count)) {
#line 598
        goto while_break___0;
      }
#line 599
      if ((int )((uint8_t )tile->pixels[i]) == 0) {
#line 600
        tile->pixels[i] = spec->default_pixel;
      } else
#line 601
      if (! ((int )((uint8_t )tile->pixels[i]) == 255)) {
        {
#line 604
        tile->pixels[i] = composite_one(spec->default_pixel, tile->pixels[i]);
        }
      }
#line 598
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 606
    tile->summary = 11;
  }
#line 609
  return;
}
}
#line 618 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static struct Tile toptile  ;
#line 611 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
void flattenIncrementally(struct FlattenSpec *spec , void (*callback)(unsigned int num ,
                                                                      rgba *pixels ) ) 
{ 
  rgba *rows[1 << 6] ;
  unsigned int i ;
  unsigned int y ;
  unsigned int nrows ;
  unsigned int ncols ;
  struct rect where ;
  struct Tile *tile ;
  void *tmp ;

  {
  {
#line 620
  toptile.count = (unsigned int )((1 << 6) * (1 << 6));
#line 621
  fillTile(& toptile, (rgba )0);
#line 623
  where.t = spec->dim.c.t;
  }
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (where.t < spec->dim.c.b)) {
#line 623
      goto while_break;
    }
#line 624
    where.b = (where.t & - (1 << 6)) + (1 << 6);
#line 625
    if (where.b > spec->dim.c.b) {
#line 625
      where.b = spec->dim.c.b;
    }
#line 626
    nrows = (unsigned int )(where.b - where.t);
#line 627
    y = 0U;
    {
#line 627
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 627
      if (! (y < nrows)) {
#line 627
        goto while_break___0;
      }
      {
#line 628
      tmp = xcfmalloc((size_t )(4 * (spec->dim.c.r - spec->dim.c.l)));
#line 628
      rows[y] = (rgba *)tmp;
#line 627
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 630
    where.l = spec->dim.c.l;
    {
#line 630
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 630
      if (! (where.l < spec->dim.c.r)) {
#line 630
        goto while_break___1;
      }
#line 631
      where.r = (where.l & - (1 << 6)) + (1 << 6);
#line 632
      if (where.r > spec->dim.c.r) {
#line 632
        where.r = spec->dim.c.r;
      }
#line 633
      ncols = (unsigned int )(where.r - where.l);
#line 635
      toptile.count = ncols * nrows;
#line 636
      toptile.refcount = 2;
#line 637
      if (! (toptile.summary == 13)) {
        {
#line 637
        __assert_fail("toptile.summary == 8 + 4 + 1", "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c",
                      638U, "flattenIncrementally");
        }
      }
      {
#line 639
      tile = flattenTopdown(spec, & toptile, (unsigned int )spec->numLayers, (struct rect  const  *)(& where));
#line 640
      (toptile.refcount) --;
#line 641
      addBackground(spec, tile, ncols);
#line 643
      i = 0U;
      }
      {
#line 643
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 643
        if (! (i < tile->count)) {
#line 643
          goto while_break___2;
        }
#line 644
        if ((int )((uint8_t )tile->pixels[i]) == 0) {
#line 645
          tile->pixels[i] = (rgba )0;
        }
#line 643
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 646
      y = 0U;
      {
#line 646
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 646
        if (! (y < nrows)) {
#line 646
          goto while_break___3;
        }
        {
#line 647
        memcpy((void */* __restrict  */)(rows[y] + (where.l - spec->dim.c.l)), (void const   */* __restrict  */)(tile->pixels + y * ncols),
               (size_t )(ncols * 4U));
#line 646
        y ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 650
      if ((unsigned long )tile == (unsigned long )(& toptile)) {
        {
#line 651
        fillTile(& toptile, (rgba )0);
        }
      } else {
        {
#line 653
        freeTile(tile);
        }
      }
#line 630
      where.l = where.r;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 656
    y = 0U;
    {
#line 656
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 656
      if (! (y < nrows)) {
#line 656
        goto while_break___4;
      }
      {
#line 657
      (*callback)(spec->dim.width, rows[y]);
#line 656
      y ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 623
    where.t = where.b;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static rgba **collectPointer  ;
#line 663 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
static void collector(unsigned int num , rgba *row ) 
{ 
  rgba **tmp ;

  {
#line 666
  tmp = collectPointer;
#line 666
  collectPointer ++;
#line 666
  *tmp = row;
#line 667
  return;
}
}
#line 669 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
rgba **flattenAll(struct FlattenSpec *spec ) 
{ 
  rgba **rows ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 672
  tmp = xcfmalloc((unsigned long )spec->dim.height * sizeof(rgba *));
#line 672
  rows = (rgba **)tmp;
  }
#line 673
  if (verboseFlag) {
    {
#line 674
    tmp___0 = gettext("Flattening image ...");
#line 674
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 675
  collectPointer = rows;
#line 676
  flattenIncrementally(spec, & collector);
  }
#line 677
  if (verboseFlag) {
    {
#line 678
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 679
  return (rows);
}
}
#line 682 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.c"
void shipoutWithCallback(struct FlattenSpec *spec , rgba **pixels , void (*callback)(unsigned int num ,
                                                                                     rgba *pixels ) ) 
{ 
  unsigned int i ;

  {
#line 687
  i = 0U;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (i < spec->dim.height)) {
#line 687
      goto while_break;
    }
    {
#line 688
    (*callback)(spec->dim.width, *(pixels + i));
#line 687
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 690
  xcffree((void *)pixels);
  }
#line 691
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/table.c"
rgba const   graytable[256]  = 
#line 6 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/table.c"
  {      (rgba const   )0U,      (rgba const   )(((1U << 8) | (1U << 16)) | (1U << 24)),      (rgba const   )(((2U << 8) | (2U << 16)) | (2U << 24)),      (rgba const   )(((3U << 8) | (3U << 16)) | (3U << 24)), 
        (rgba const   )(((4U << 8) | (4U << 16)) | (4U << 24)),      (rgba const   )(((5U << 8) | (5U << 16)) | (5U << 24)),      (rgba const   )(((6U << 8) | (6U << 16)) | (6U << 24)),      (rgba const   )(((7U << 8) | (7U << 16)) | (7U << 24)), 
        (rgba const   )(((8U << 8) | (8U << 16)) | (8U << 24)),      (rgba const   )(((9U << 8) | (9U << 16)) | (9U << 24)),      (rgba const   )(((10U << 8) | (10U << 16)) | (10U << 24)),      (rgba const   )(((11U << 8) | (11U << 16)) | (11U << 24)), 
        (rgba const   )(((12U << 8) | (12U << 16)) | (12U << 24)),      (rgba const   )(((13U << 8) | (13U << 16)) | (13U << 24)),      (rgba const   )(((14U << 8) | (14U << 16)) | (14U << 24)),      (rgba const   )(((15U << 8) | (15U << 16)) | (15U << 24)), 
        (rgba const   )(((16U << 8) | (16U << 16)) | (16U << 24)),      (rgba const   )(((17U << 8) | (17U << 16)) | (17U << 24)),      (rgba const   )(((18U << 8) | (18U << 16)) | (18U << 24)),      (rgba const   )(((19U << 8) | (19U << 16)) | (19U << 24)), 
        (rgba const   )(((20U << 8) | (20U << 16)) | (20U << 24)),      (rgba const   )(((21U << 8) | (21U << 16)) | (21U << 24)),      (rgba const   )(((22U << 8) | (22U << 16)) | (22U << 24)),      (rgba const   )(((23U << 8) | (23U << 16)) | (23U << 24)), 
        (rgba const   )(((24U << 8) | (24U << 16)) | (24U << 24)),      (rgba const   )(((25U << 8) | (25U << 16)) | (25U << 24)),      (rgba const   )(((26U << 8) | (26U << 16)) | (26U << 24)),      (rgba const   )(((27U << 8) | (27U << 16)) | (27U << 24)), 
        (rgba const   )(((28U << 8) | (28U << 16)) | (28U << 24)),      (rgba const   )(((29U << 8) | (29U << 16)) | (29U << 24)),      (rgba const   )(((30U << 8) | (30U << 16)) | (30U << 24)),      (rgba const   )(((31U << 8) | (31U << 16)) | (31U << 24)), 
        (rgba const   )(((32U << 8) | (32U << 16)) | (32U << 24)),      (rgba const   )(((33U << 8) | (33U << 16)) | (33U << 24)),      (rgba const   )(((34U << 8) | (34U << 16)) | (34U << 24)),      (rgba const   )(((35U << 8) | (35U << 16)) | (35U << 24)), 
        (rgba const   )(((36U << 8) | (36U << 16)) | (36U << 24)),      (rgba const   )(((37U << 8) | (37U << 16)) | (37U << 24)),      (rgba const   )(((38U << 8) | (38U << 16)) | (38U << 24)),      (rgba const   )(((39U << 8) | (39U << 16)) | (39U << 24)), 
        (rgba const   )(((40U << 8) | (40U << 16)) | (40U << 24)),      (rgba const   )(((41U << 8) | (41U << 16)) | (41U << 24)),      (rgba const   )(((42U << 8) | (42U << 16)) | (42U << 24)),      (rgba const   )(((43U << 8) | (43U << 16)) | (43U << 24)), 
        (rgba const   )(((44U << 8) | (44U << 16)) | (44U << 24)),      (rgba const   )(((45U << 8) | (45U << 16)) | (45U << 24)),      (rgba const   )(((46U << 8) | (46U << 16)) | (46U << 24)),      (rgba const   )(((47U << 8) | (47U << 16)) | (47U << 24)), 
        (rgba const   )(((48U << 8) | (48U << 16)) | (48U << 24)),      (rgba const   )(((49U << 8) | (49U << 16)) | (49U << 24)),      (rgba const   )(((50U << 8) | (50U << 16)) | (50U << 24)),      (rgba const   )(((51U << 8) | (51U << 16)) | (51U << 24)), 
        (rgba const   )(((52U << 8) | (52U << 16)) | (52U << 24)),      (rgba const   )(((53U << 8) | (53U << 16)) | (53U << 24)),      (rgba const   )(((54U << 8) | (54U << 16)) | (54U << 24)),      (rgba const   )(((55U << 8) | (55U << 16)) | (55U << 24)), 
        (rgba const   )(((56U << 8) | (56U << 16)) | (56U << 24)),      (rgba const   )(((57U << 8) | (57U << 16)) | (57U << 24)),      (rgba const   )(((58U << 8) | (58U << 16)) | (58U << 24)),      (rgba const   )(((59U << 8) | (59U << 16)) | (59U << 24)), 
        (rgba const   )(((60U << 8) | (60U << 16)) | (60U << 24)),      (rgba const   )(((61U << 8) | (61U << 16)) | (61U << 24)),      (rgba const   )(((62U << 8) | (62U << 16)) | (62U << 24)),      (rgba const   )(((63U << 8) | (63U << 16)) | (63U << 24)), 
        (rgba const   )(((64U << 8) | (64U << 16)) | (64U << 24)),      (rgba const   )(((65U << 8) | (65U << 16)) | (65U << 24)),      (rgba const   )(((66U << 8) | (66U << 16)) | (66U << 24)),      (rgba const   )(((67U << 8) | (67U << 16)) | (67U << 24)), 
        (rgba const   )(((68U << 8) | (68U << 16)) | (68U << 24)),      (rgba const   )(((69U << 8) | (69U << 16)) | (69U << 24)),      (rgba const   )(((70U << 8) | (70U << 16)) | (70U << 24)),      (rgba const   )(((71U << 8) | (71U << 16)) | (71U << 24)), 
        (rgba const   )(((72U << 8) | (72U << 16)) | (72U << 24)),      (rgba const   )(((73U << 8) | (73U << 16)) | (73U << 24)),      (rgba const   )(((74U << 8) | (74U << 16)) | (74U << 24)),      (rgba const   )(((75U << 8) | (75U << 16)) | (75U << 24)), 
        (rgba const   )(((76U << 8) | (76U << 16)) | (76U << 24)),      (rgba const   )(((77U << 8) | (77U << 16)) | (77U << 24)),      (rgba const   )(((78U << 8) | (78U << 16)) | (78U << 24)),      (rgba const   )(((79U << 8) | (79U << 16)) | (79U << 24)), 
        (rgba const   )(((80U << 8) | (80U << 16)) | (80U << 24)),      (rgba const   )(((81U << 8) | (81U << 16)) | (81U << 24)),      (rgba const   )(((82U << 8) | (82U << 16)) | (82U << 24)),      (rgba const   )(((83U << 8) | (83U << 16)) | (83U << 24)), 
        (rgba const   )(((84U << 8) | (84U << 16)) | (84U << 24)),      (rgba const   )(((85U << 8) | (85U << 16)) | (85U << 24)),      (rgba const   )(((86U << 8) | (86U << 16)) | (86U << 24)),      (rgba const   )(((87U << 8) | (87U << 16)) | (87U << 24)), 
        (rgba const   )(((88U << 8) | (88U << 16)) | (88U << 24)),      (rgba const   )(((89U << 8) | (89U << 16)) | (89U << 24)),      (rgba const   )(((90U << 8) | (90U << 16)) | (90U << 24)),      (rgba const   )(((91U << 8) | (91U << 16)) | (91U << 24)), 
        (rgba const   )(((92U << 8) | (92U << 16)) | (92U << 24)),      (rgba const   )(((93U << 8) | (93U << 16)) | (93U << 24)),      (rgba const   )(((94U << 8) | (94U << 16)) | (94U << 24)),      (rgba const   )(((95U << 8) | (95U << 16)) | (95U << 24)), 
        (rgba const   )(((96U << 8) | (96U << 16)) | (96U << 24)),      (rgba const   )(((97U << 8) | (97U << 16)) | (97U << 24)),      (rgba const   )(((98U << 8) | (98U << 16)) | (98U << 24)),      (rgba const   )(((99U << 8) | (99U << 16)) | (99U << 24)), 
        (rgba const   )(((100U << 8) | (100U << 16)) | (100U << 24)),      (rgba const   )(((101U << 8) | (101U << 16)) | (101U << 24)),      (rgba const   )(((102U << 8) | (102U << 16)) | (102U << 24)),      (rgba const   )(((103U << 8) | (103U << 16)) | (103U << 24)), 
        (rgba const   )(((104U << 8) | (104U << 16)) | (104U << 24)),      (rgba const   )(((105U << 8) | (105U << 16)) | (105U << 24)),      (rgba const   )(((106U << 8) | (106U << 16)) | (106U << 24)),      (rgba const   )(((107U << 8) | (107U << 16)) | (107U << 24)), 
        (rgba const   )(((108U << 8) | (108U << 16)) | (108U << 24)),      (rgba const   )(((109U << 8) | (109U << 16)) | (109U << 24)),      (rgba const   )(((110U << 8) | (110U << 16)) | (110U << 24)),      (rgba const   )(((111U << 8) | (111U << 16)) | (111U << 24)), 
        (rgba const   )(((112U << 8) | (112U << 16)) | (112U << 24)),      (rgba const   )(((113U << 8) | (113U << 16)) | (113U << 24)),      (rgba const   )(((114U << 8) | (114U << 16)) | (114U << 24)),      (rgba const   )(((115U << 8) | (115U << 16)) | (115U << 24)), 
        (rgba const   )(((116U << 8) | (116U << 16)) | (116U << 24)),      (rgba const   )(((117U << 8) | (117U << 16)) | (117U << 24)),      (rgba const   )(((118U << 8) | (118U << 16)) | (118U << 24)),      (rgba const   )(((119U << 8) | (119U << 16)) | (119U << 24)), 
        (rgba const   )(((120U << 8) | (120U << 16)) | (120U << 24)),      (rgba const   )(((121U << 8) | (121U << 16)) | (121U << 24)),      (rgba const   )(((122U << 8) | (122U << 16)) | (122U << 24)),      (rgba const   )(((123U << 8) | (123U << 16)) | (123U << 24)), 
        (rgba const   )(((124U << 8) | (124U << 16)) | (124U << 24)),      (rgba const   )(((125U << 8) | (125U << 16)) | (125U << 24)),      (rgba const   )(((126U << 8) | (126U << 16)) | (126U << 24)),      (rgba const   )(((127U << 8) | (127U << 16)) | (127U << 24)), 
        (rgba const   )(((128U << 8) | (128U << 16)) | (128U << 24)),      (rgba const   )(((129U << 8) | (129U << 16)) | (129U << 24)),      (rgba const   )(((130U << 8) | (130U << 16)) | (130U << 24)),      (rgba const   )(((131U << 8) | (131U << 16)) | (131U << 24)), 
        (rgba const   )(((132U << 8) | (132U << 16)) | (132U << 24)),      (rgba const   )(((133U << 8) | (133U << 16)) | (133U << 24)),      (rgba const   )(((134U << 8) | (134U << 16)) | (134U << 24)),      (rgba const   )(((135U << 8) | (135U << 16)) | (135U << 24)), 
        (rgba const   )(((136U << 8) | (136U << 16)) | (136U << 24)),      (rgba const   )(((137U << 8) | (137U << 16)) | (137U << 24)),      (rgba const   )(((138U << 8) | (138U << 16)) | (138U << 24)),      (rgba const   )(((139U << 8) | (139U << 16)) | (139U << 24)), 
        (rgba const   )(((140U << 8) | (140U << 16)) | (140U << 24)),      (rgba const   )(((141U << 8) | (141U << 16)) | (141U << 24)),      (rgba const   )(((142U << 8) | (142U << 16)) | (142U << 24)),      (rgba const   )(((143U << 8) | (143U << 16)) | (143U << 24)), 
        (rgba const   )(((144U << 8) | (144U << 16)) | (144U << 24)),      (rgba const   )(((145U << 8) | (145U << 16)) | (145U << 24)),      (rgba const   )(((146U << 8) | (146U << 16)) | (146U << 24)),      (rgba const   )(((147U << 8) | (147U << 16)) | (147U << 24)), 
        (rgba const   )(((148U << 8) | (148U << 16)) | (148U << 24)),      (rgba const   )(((149U << 8) | (149U << 16)) | (149U << 24)),      (rgba const   )(((150U << 8) | (150U << 16)) | (150U << 24)),      (rgba const   )(((151U << 8) | (151U << 16)) | (151U << 24)), 
        (rgba const   )(((152U << 8) | (152U << 16)) | (152U << 24)),      (rgba const   )(((153U << 8) | (153U << 16)) | (153U << 24)),      (rgba const   )(((154U << 8) | (154U << 16)) | (154U << 24)),      (rgba const   )(((155U << 8) | (155U << 16)) | (155U << 24)), 
        (rgba const   )(((156U << 8) | (156U << 16)) | (156U << 24)),      (rgba const   )(((157U << 8) | (157U << 16)) | (157U << 24)),      (rgba const   )(((158U << 8) | (158U << 16)) | (158U << 24)),      (rgba const   )(((159U << 8) | (159U << 16)) | (159U << 24)), 
        (rgba const   )(((160U << 8) | (160U << 16)) | (160U << 24)),      (rgba const   )(((161U << 8) | (161U << 16)) | (161U << 24)),      (rgba const   )(((162U << 8) | (162U << 16)) | (162U << 24)),      (rgba const   )(((163U << 8) | (163U << 16)) | (163U << 24)), 
        (rgba const   )(((164U << 8) | (164U << 16)) | (164U << 24)),      (rgba const   )(((165U << 8) | (165U << 16)) | (165U << 24)),      (rgba const   )(((166U << 8) | (166U << 16)) | (166U << 24)),      (rgba const   )(((167U << 8) | (167U << 16)) | (167U << 24)), 
        (rgba const   )(((168U << 8) | (168U << 16)) | (168U << 24)),      (rgba const   )(((169U << 8) | (169U << 16)) | (169U << 24)),      (rgba const   )(((170U << 8) | (170U << 16)) | (170U << 24)),      (rgba const   )(((171U << 8) | (171U << 16)) | (171U << 24)), 
        (rgba const   )(((172U << 8) | (172U << 16)) | (172U << 24)),      (rgba const   )(((173U << 8) | (173U << 16)) | (173U << 24)),      (rgba const   )(((174U << 8) | (174U << 16)) | (174U << 24)),      (rgba const   )(((175U << 8) | (175U << 16)) | (175U << 24)), 
        (rgba const   )(((176U << 8) | (176U << 16)) | (176U << 24)),      (rgba const   )(((177U << 8) | (177U << 16)) | (177U << 24)),      (rgba const   )(((178U << 8) | (178U << 16)) | (178U << 24)),      (rgba const   )(((179U << 8) | (179U << 16)) | (179U << 24)), 
        (rgba const   )(((180U << 8) | (180U << 16)) | (180U << 24)),      (rgba const   )(((181U << 8) | (181U << 16)) | (181U << 24)),      (rgba const   )(((182U << 8) | (182U << 16)) | (182U << 24)),      (rgba const   )(((183U << 8) | (183U << 16)) | (183U << 24)), 
        (rgba const   )(((184U << 8) | (184U << 16)) | (184U << 24)),      (rgba const   )(((185U << 8) | (185U << 16)) | (185U << 24)),      (rgba const   )(((186U << 8) | (186U << 16)) | (186U << 24)),      (rgba const   )(((187U << 8) | (187U << 16)) | (187U << 24)), 
        (rgba const   )(((188U << 8) | (188U << 16)) | (188U << 24)),      (rgba const   )(((189U << 8) | (189U << 16)) | (189U << 24)),      (rgba const   )(((190U << 8) | (190U << 16)) | (190U << 24)),      (rgba const   )(((191U << 8) | (191U << 16)) | (191U << 24)), 
        (rgba const   )(((192U << 8) | (192U << 16)) | (192U << 24)),      (rgba const   )(((193U << 8) | (193U << 16)) | (193U << 24)),      (rgba const   )(((194U << 8) | (194U << 16)) | (194U << 24)),      (rgba const   )(((195U << 8) | (195U << 16)) | (195U << 24)), 
        (rgba const   )(((196U << 8) | (196U << 16)) | (196U << 24)),      (rgba const   )(((197U << 8) | (197U << 16)) | (197U << 24)),      (rgba const   )(((198U << 8) | (198U << 16)) | (198U << 24)),      (rgba const   )(((199U << 8) | (199U << 16)) | (199U << 24)), 
        (rgba const   )(((200U << 8) | (200U << 16)) | (200U << 24)),      (rgba const   )(((201U << 8) | (201U << 16)) | (201U << 24)),      (rgba const   )(((202U << 8) | (202U << 16)) | (202U << 24)),      (rgba const   )(((203U << 8) | (203U << 16)) | (203U << 24)), 
        (rgba const   )(((204U << 8) | (204U << 16)) | (204U << 24)),      (rgba const   )(((205U << 8) | (205U << 16)) | (205U << 24)),      (rgba const   )(((206U << 8) | (206U << 16)) | (206U << 24)),      (rgba const   )(((207U << 8) | (207U << 16)) | (207U << 24)), 
        (rgba const   )(((208U << 8) | (208U << 16)) | (208U << 24)),      (rgba const   )(((209U << 8) | (209U << 16)) | (209U << 24)),      (rgba const   )(((210U << 8) | (210U << 16)) | (210U << 24)),      (rgba const   )(((211U << 8) | (211U << 16)) | (211U << 24)), 
        (rgba const   )(((212U << 8) | (212U << 16)) | (212U << 24)),      (rgba const   )(((213U << 8) | (213U << 16)) | (213U << 24)),      (rgba const   )(((214U << 8) | (214U << 16)) | (214U << 24)),      (rgba const   )(((215U << 8) | (215U << 16)) | (215U << 24)), 
        (rgba const   )(((216U << 8) | (216U << 16)) | (216U << 24)),      (rgba const   )(((217U << 8) | (217U << 16)) | (217U << 24)),      (rgba const   )(((218U << 8) | (218U << 16)) | (218U << 24)),      (rgba const   )(((219U << 8) | (219U << 16)) | (219U << 24)), 
        (rgba const   )(((220U << 8) | (220U << 16)) | (220U << 24)),      (rgba const   )(((221U << 8) | (221U << 16)) | (221U << 24)),      (rgba const   )(((222U << 8) | (222U << 16)) | (222U << 24)),      (rgba const   )(((223U << 8) | (223U << 16)) | (223U << 24)), 
        (rgba const   )(((224U << 8) | (224U << 16)) | (224U << 24)),      (rgba const   )(((225U << 8) | (225U << 16)) | (225U << 24)),      (rgba const   )(((226U << 8) | (226U << 16)) | (226U << 24)),      (rgba const   )(((227U << 8) | (227U << 16)) | (227U << 24)), 
        (rgba const   )(((228U << 8) | (228U << 16)) | (228U << 24)),      (rgba const   )(((229U << 8) | (229U << 16)) | (229U << 24)),      (rgba const   )(((230U << 8) | (230U << 16)) | (230U << 24)),      (rgba const   )(((231U << 8) | (231U << 16)) | (231U << 24)), 
        (rgba const   )(((232U << 8) | (232U << 16)) | (232U << 24)),      (rgba const   )(((233U << 8) | (233U << 16)) | (233U << 24)),      (rgba const   )(((234U << 8) | (234U << 16)) | (234U << 24)),      (rgba const   )(((235U << 8) | (235U << 16)) | (235U << 24)), 
        (rgba const   )(((236U << 8) | (236U << 16)) | (236U << 24)),      (rgba const   )(((237U << 8) | (237U << 16)) | (237U << 24)),      (rgba const   )(((238U << 8) | (238U << 16)) | (238U << 24)),      (rgba const   )(((239U << 8) | (239U << 16)) | (239U << 24)), 
        (rgba const   )(((240U << 8) | (240U << 16)) | (240U << 24)),      (rgba const   )(((241U << 8) | (241U << 16)) | (241U << 24)),      (rgba const   )(((242U << 8) | (242U << 16)) | (242U << 24)),      (rgba const   )(((243U << 8) | (243U << 16)) | (243U << 24)), 
        (rgba const   )(((244U << 8) | (244U << 16)) | (244U << 24)),      (rgba const   )(((245U << 8) | (245U << 16)) | (245U << 24)),      (rgba const   )(((246U << 8) | (246U << 16)) | (246U << 24)),      (rgba const   )(((247U << 8) | (247U << 16)) | (247U << 24)), 
        (rgba const   )(((248U << 8) | (248U << 16)) | (248U << 24)),      (rgba const   )(((249U << 8) | (249U << 16)) | (249U << 24)),      (rgba const   )(((250U << 8) | (250U << 16)) | (250U << 24)),      (rgba const   )(((251U << 8) | (251U << 16)) | (251U << 24)), 
        (rgba const   )(((252U << 8) | (252U << 16)) | (252U << 24)),      (rgba const   )(((253U << 8) | (253U << 16)) | (253U << 24)),      (rgba const   )(((254U << 8) | (254U << 16)) | (254U << 24)),      (rgba const   )(((255U << 8) | (255U << 16)) | (255U << 24))};
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 137 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
int use_utf8 ;
#line 196
void getBasicXcfInfo(void) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatten.h"
void init_flatspec(struct FlattenSpec *spec ) ;
#line 61
void add_layer_request(struct FlattenSpec *spec , char const   *layer ) ;
#line 62
struct xcfLayer *lastlayerspec(struct FlattenSpec *spec , char const   *option ) ;
#line 67
void complete_flatspec(struct FlattenSpec *spec , enum out_color_mode (*guess_callback)(struct FlattenSpec * ,
                                                                                        rgba ** ) ) ;
#line 68
void analyse_colormode(struct FlattenSpec *spec , rgba **allPixels , enum out_color_mode (*guess_callback)(struct FlattenSpec * ,
                                                                                                           rgba ** ) ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.oi"
static struct option  const  longopts[30]  = 
#line 7 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.oi"
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"bzip", 0, (int *)0, 'j'}, 
        {"gzip", 0, (int *)0, 'z'}, 
        {"unpack", 1, (int *)0, 'Z'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"alpha", 1, (int *)0, 'a'}, 
        {"background", 1, (int *)0, 'b'}, 
        {"force-alpha", 0, (int *)0, 'A'}, 
        {"color", 0, (int *)0, 'c'}, 
        {"colour", 0, (int *)0, 'c'}, 
        {"gray", 0, (int *)0, 'g'}, 
        {"grey", 0, (int *)0, 'g'}, 
        {"mono", 0, (int *)0, 'm'}, 
        {"pnm", 0, (int *)0, 'n'}, 
        {"truecolor", 0, (int *)0, 'T'}, 
        {"for-gif", 0, (int *)0, 'G'}, 
        {"dissolve", 0, (int *)0, 'D'}, 
        {"full-image", 0, (int *)0, 'f'}, 
        {"size", 1, (int *)0, 'S'}, 
        {"offset", 1, (int *)0, 'O'}, 
        {"autocrop", 0, (int *)0, 'C'}, 
        {"mode", 1, (int *)0, 300}, 
        {"percent", 1, (int *)0, 301}, 
        {"opacity", 1, (int *)0, 302}, 
        {"mask", 0, (int *)0, 303}, 
        {"nomask", 0, (int *)0, 304}, 
        {"utf8", 0, (int *)0, 'u'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 42 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.oi"
static void opt_usage(FILE *f ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;

  {
  {
#line 45
  i = 2;
#line 47
  tmp = gettext("color");
#line 47
  tmp___0 = strlen((char const   *)tmp);
#line 47
  j = (int )(tmp___0 + 3UL);
  }
#line 47
  if (j > i) {
#line 47
    i = j;
  }
  {
#line 48
  tmp___1 = gettext("command");
#line 48
  tmp___2 = strlen((char const   *)tmp___1);
#line 48
  j = (int )(tmp___2 + 3UL);
  }
#line 48
  if (j > i) {
#line 48
    i = j;
  }
  {
#line 49
  tmp___3 = gettext("filename");
#line 49
  tmp___4 = strlen((char const   *)tmp___3);
#line 49
  j = (int )(tmp___4 + 3UL);
  }
#line 49
  if (j > i) {
#line 49
    i = j;
  }
  {
#line 50
  tmp___5 = gettext("mode");
#line 50
  tmp___6 = strlen((char const   *)tmp___5);
#line 50
  j = (int )(tmp___6 + 7UL);
  }
#line 50
  if (j > i) {
#line 50
    i = j;
  }
  {
#line 51
  tmp___7 = gettext("n");
#line 51
  tmp___8 = strlen((char const   *)tmp___7);
#line 51
  j = (int )(tmp___8 + 10UL);
  }
#line 51
  if (j > i) {
#line 51
    i = j;
  }
  {
#line 52
  tmp___9 = gettext("wxh");
#line 52
  tmp___10 = strlen((char const   *)tmp___9);
#line 52
  j = (int )(tmp___10 + 3UL);
  }
#line 52
  if (j > i) {
#line 52
    i = j;
  }
  {
#line 53
  tmp___11 = gettext("x,y");
#line 53
  tmp___12 = strlen((char const   *)tmp___11);
#line 53
  j = (int )(tmp___12 + 3UL);
  }
#line 53
  if (j > i) {
#line 53
    i = j;
  }
  {
#line 54
  tmp___13 = gettext("show this message");
#line 54
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -h%-*s %s (--help)\n",
          i - 2, "", tmp___13);
#line 56
  tmp___14 = gettext("show version");
#line 56
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -V%-*s %s (--version)\n",
          i - 2, "", tmp___14);
#line 58
  tmp___15 = gettext("show progress messages");
#line 58
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -v%-*s %s (--verbose)\n",
          i - 2, "", tmp___15);
#line 60
  tmp___16 = gettext("input is bzip2 compressed");
#line 60
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -j%-*s %s (--bzip)\n",
          i - 2, "", tmp___16);
#line 62
  tmp___17 = gettext("input is gzip compressed");
#line 62
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -z%-*s %s (--gzip)\n",
          i - 2, "", tmp___17);
#line 64
  tmp___18 = gettext("use \'command\' to decompress input");
#line 64
  tmp___19 = gettext("command");
#line 64
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -Z %-*s %s (--unpack)\n",
          i - 3, tmp___19, tmp___18);
#line 66
  tmp___20 = gettext("name output file");
#line 66
  tmp___21 = gettext("filename");
#line 66
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -o %-*s %s (--output)\n",
          i - 3, tmp___21, tmp___20);
#line 68
  tmp___22 = gettext("write transparency map");
#line 68
  tmp___23 = gettext("filename");
#line 68
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -a %-*s %s (--alpha)\n",
          i - 3, tmp___23, tmp___22);
#line 70
  tmp___24 = gettext("select background color");
#line 70
  tmp___25 = gettext("color");
#line 70
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -b %-*s %s (--background)\n",
          i - 3, tmp___25, tmp___24);
#line 72
  tmp___26 = gettext("force alpha channel in output");
#line 72
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -A%-*s %s (--force-alpha)\n",
          i - 2, "", tmp___26);
#line 74
  tmp___27 = gettext("select color output");
#line 74
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -c%-*s %s (--color)\n",
          i - 2, "", tmp___27);
#line 76
  tmp___28 = gettext("select grayscale output");
#line 76
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -g%-*s %s (--gray)\n",
          i - 2, "", tmp___28);
#line 78
  tmp___29 = gettext("select monochrome output");
#line 78
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -m%-*s %s (--mono)\n",
          i - 2, "", tmp___29);
#line 80
  tmp___30 = gettext("select -c/-g/-m by image contents");
#line 80
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -n%-*s %s (--pnm)\n",
          i - 2, "", tmp___30);
#line 82
  tmp___31 = gettext("treat indexed images as RGB for flattening");
#line 82
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -T%-*s %s (--truecolor)\n",
          i - 2, "", tmp___31);
#line 84
  tmp___32 = gettext("disallow partial transparency");
#line 84
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -G%-*s %s (--for-gif)\n",
          i - 2, "", tmp___32);
#line 86
  tmp___33 = gettext("dissolve partial transparency");
#line 86
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -D%-*s %s (--dissolve)\n",
          i - 2, "", tmp___33);
#line 88
  tmp___34 = gettext("flatten to memory; then analyse");
#line 88
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -f%-*s %s (--full-image)\n",
          i - 2, "", tmp___34);
#line 90
  tmp___35 = gettext("crop image while converting");
#line 90
  tmp___36 = gettext("wxh");
#line 90
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -S %-*s %s (--size)\n",
          i - 3, tmp___36, tmp___35);
#line 92
  tmp___37 = gettext("translate converted part of image");
#line 92
  tmp___38 = gettext("x,y");
#line 92
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -O %-*s %s (--offset)\n",
          i - 3, tmp___38, tmp___37);
#line 94
  tmp___39 = gettext("autocrop to visible layer boundaries");
#line 94
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -C%-*s %s (--autocrop)\n",
          i - 2, "", tmp___39);
#line 96
  tmp___40 = gettext("Layer-selection options");
#line 96
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s:\n", tmp___40);
#line 97
  tmp___41 = gettext("set layer mode");
#line 97
  tmp___42 = gettext("mode");
#line 97
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  --mode %-*s %s\n",
          i - 7, tmp___42, tmp___41);
#line 99
  tmp___43 = gettext("set opacity in percent");
#line 99
  tmp___44 = gettext("n");
#line 99
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  --percent %-*s %s\n",
          i - 10, tmp___44, tmp___43);
#line 101
  tmp___45 = gettext("set opacity in 1/255 units");
#line 101
  tmp___46 = gettext("n");
#line 101
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  --opacity %-*s %s\n",
          i - 10, tmp___46, tmp___45);
#line 103
  tmp___47 = gettext("enable layer mask");
#line 103
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  --mask%-*s %s\n",
          i - 6, "", tmp___47);
#line 105
  tmp___48 = gettext("disable layer mask");
#line 105
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  --nomask%-*s %s\n",
          i - 8, "", tmp___48);
#line 107
  tmp___49 = gettext("use UTF-8 for layer names");
#line 107
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -u%-*s %s (--utf8)\n",
          i - 2, "", tmp___49);
  }
#line 109
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static void usage(FILE *where ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 39
  tmp = gettext("Usage: %s [options] filename.xcf[.gz] [layers]\n");
#line 39
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tmp, progname);
#line 41
  tmp___0 = gettext("Options:\n");
#line 41
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tmp___0);
#line 42
  opt_usage(where);
  }
#line 43
  if ((unsigned long )where == (unsigned long )stderr) {
    {
#line 44
    exit(1);
    }
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static int suppress_byline  ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static struct FlattenSpec flatspec  ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static FILE *outfile  =    (FILE *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static FILE *transfile  =    (FILE *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static void start_writing(FILE **f , int version ) 
{ 
  char const   *format[7] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 56
  format[0] = "(format zero)";
#line 56
  format[1] = "PBM-ascii";
#line 56
  format[2] = "PGM-ascii";
#line 56
  format[3] = "PPM-ascii";
#line 56
  format[4] = "PBM";
#line 56
  format[5] = "PGM";
#line 56
  format[6] = "PPM";
#line 64
  if (verboseFlag) {
#line 65
    if ((unsigned long )f == (unsigned long )(& outfile)) {
      {
#line 65
      tmp = gettext("Writing converted image as %s\n");
#line 65
      tmp___1 = tmp;
      }
    } else {
      {
#line 65
      tmp___0 = gettext("Writing transparency map as %s\n");
#line 65
      tmp___1 = tmp___0;
      }
    }
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            format[version]);
    }
  }
#line 69
  if ((unsigned long )f == (unsigned long )(& outfile)) {
#line 69
    tmp___2 = flatspec.output_filename;
  } else {
#line 69
    tmp___2 = flatspec.transmap_filename;
  }
  {
#line 69
  *f = openout(tmp___2);
#line 71
  fprintf((FILE */* __restrict  */)*f, (char const   */* __restrict  */)"P%d", version);
  }
#line 72
  if (! suppress_byline) {
#line 74
    if ((unsigned long )f == (unsigned long )(& outfile)) {
      {
#line 75
      tmp___3 = gettext(" # Converted by xcf2pnm %s");
#line 75
      fprintf((FILE */* __restrict  */)*f, (char const   */* __restrict  */)tmp___3,
              "1.0.7");
      }
    } else {
      {
#line 77
      tmp___4 = gettext(" # Transparency map by xcf2pnm %s");
#line 77
      fprintf((FILE */* __restrict  */)*f, (char const   */* __restrict  */)tmp___4,
              "1.0.7");
      }
    }
  }
#line 78
  if (version == 4) {
#line 78
    tmp___5 = "";
  } else {
#line 78
    tmp___5 = "255\n";
  }
  {
#line 78
  fprintf((FILE */* __restrict  */)*f, (char const   */* __restrict  */)"\n%d %d\n%s",
          flatspec.dim.width, flatspec.dim.height, tmp___5);
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
int put_pbm_row(FILE *file , unsigned int num , rgba *pixels , rgba mask ) 
{ 
  unsigned int out ;
  unsigned int i ;
  int bitsleft ;

  {
#line 88
  bitsleft = 8;
#line 89
  out = 0U;
#line 90
  i = 0U;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < num)) {
#line 90
      goto while_break;
    }
#line 91
    out <<= 1;
#line 92
    if ((*(pixels + i) & mask) == 0U) {
#line 93
      out ++;
    } else
#line 94
    if (! ((*(pixels + i) & mask) == mask)) {
#line 97
      return (0);
    }
#line 98
    bitsleft --;
#line 98
    if (bitsleft == 0) {
      {
#line 99
      _IO_putc((int )out, file);
#line 100
      out = 0U;
#line 101
      bitsleft = 8;
      }
    }
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (bitsleft < 8) {
    {
#line 105
    _IO_putc((int )(out << bitsleft), file);
    }
  }
#line 106
  return (1);
}
}
#line 109 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static void callback_common(unsigned int num , rgba *pixels ) 
{ 
  unsigned int i ;
  unsigned int i___0 ;
  char *tmp ;

  {
#line 112
  if (flatspec.transmap_filename) {
#line 113
    if ((unsigned int )flatspec.partial_transparency_mode == 0U) {
#line 115
      if ((unsigned long )transfile == (unsigned long )((void *)0)) {
        {
#line 115
        start_writing(& transfile, 5);
        }
      }
#line 116
      i = 0U;
      {
#line 116
      while (1) {
        while_continue: /* CIL Label */ ;
#line 116
        if (! (i < num)) {
#line 116
          goto while_break;
        }
        {
#line 117
        _IO_putc((int )((uint8_t )*(pixels + i)), transfile);
#line 116
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 119
      if ((unsigned long )transfile == (unsigned long )((void *)0)) {
        {
#line 120
        start_writing(& transfile, 4);
        }
      }
      {
#line 125
      put_pbm_row(transfile, num, pixels, 1U);
      }
    }
  } else
#line 127
  if ((int )((uint8_t )flatspec.default_pixel) < 128) {
#line 129
    i___0 = 0U;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (i___0 < num)) {
#line 129
        goto while_break___0;
      }
#line 130
      if (! ((int )((uint8_t )*(pixels + i___0)) == 255)) {
        {
#line 131
        tmp = gettext("Transparency found, but -a option not given");
#line 131
        FatalGeneric(100, (char const   *)tmp);
        }
      }
#line 129
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 133
  xcffree((void *)pixels);
  }
#line 134
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static void ppm_callback(unsigned int num , rgba *pixels ) 
{ 
  unsigned int i ;

  {
#line 140
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 140
    start_writing(& outfile, 6);
    }
  }
#line 141
  i = 0U;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < num)) {
#line 141
      goto while_break;
    }
    {
#line 142
    _IO_putc((int )((*(pixels + i) >> 8) & 255U), outfile);
#line 143
    _IO_putc((int )((*(pixels + i) >> 16) & 255U), outfile);
#line 144
    _IO_putc((int )((*(pixels + i) >> 24) & 255U), outfile);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  callback_common(num, pixels);
  }
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static void pgm_callback(unsigned int num , rgba *pixels ) 
{ 
  unsigned int i ;
  int gray ;
  int tmp ;
  char *tmp___0 ;

  {
#line 153
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 153
    start_writing(& outfile, 5);
    }
  }
#line 154
  i = 0U;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < num)) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp = degrayPixel(*(pixels + i));
#line 155
    gray = tmp;
    }
#line 156
    if (gray == -1) {
      {
#line 157
      tmp___0 = gettext("Grayscale output selected, but colored pixel(s) found");
#line 157
      FatalGeneric(103, (char const   *)tmp___0);
      }
    }
    {
#line 159
    _IO_putc(gray, outfile);
#line 154
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  callback_common(num, pixels);
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static void pbm_callback(unsigned int num , rgba *pixels ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 167
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 167
    start_writing(& outfile, 4);
    }
  }
  {
#line 168
  tmp___0 = put_pbm_row(outfile, num, pixels, ((255U << 8) + (255U << 16)) + (255U << 24));
  }
#line 168
  if (! tmp___0) {
    {
#line 172
    tmp = gettext("Monochrome output selected, but not all pixels are black or white");
#line 172
    FatalGeneric(103, (char const   *)tmp);
    }
  }
  {
#line 174
  callback_common(num, pixels);
  }
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static enum out_color_mode guess_color_mode(char const   *string ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 180
  tmp___3 = strlen(string);
  }
#line 180
  if (tmp___3 >= 3UL) {
    {
#line 181
    tmp = strlen(string);
#line 181
    string += tmp - 3UL;
#line 182
    tmp___0 = strcmp(string, "ppm");
    }
#line 182
    if (tmp___0 == 0) {
#line 182
      return ((enum out_color_mode )3);
    }
    {
#line 183
    tmp___1 = strcmp(string, "pgm");
    }
#line 183
    if (tmp___1 == 0) {
#line 183
      return ((enum out_color_mode )4);
    }
    {
#line 184
    tmp___2 = strcmp(string, "pbm");
    }
#line 184
    if (tmp___2 == 0) {
#line 184
      return ((enum out_color_mode )5);
    }
  }
#line 186
  return ((enum out_color_mode )0);
}
}
#line 189 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
static lineCallback selectCallback(void) 
{ 
  char *tmp ;

  {
#line 192
  if (flatspec.transmap_filename) {
#line 192
    if ((int )((uint8_t )flatspec.default_pixel) >= 128) {
      {
#line 193
      tmp = gettext("The -a option was given, but the image has no transparency");
#line 193
      FatalGeneric(101, (char const   *)tmp);
      }
    }
  }
  {
#line 199
  if ((unsigned int )flatspec.out_color_mode == 4U) {
#line 199
    goto case_4;
  }
#line 200
  if ((unsigned int )flatspec.out_color_mode == 5U) {
#line 200
    goto case_5;
  }
#line 197
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 198
  return (& ppm_callback);
  case_4: /* CIL Label */ 
#line 199
  return (& pgm_callback);
  case_5: /* CIL Label */ 
#line 200
  return (& pbm_callback);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 204 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
int main(int argc , char **argv ) 
{ 
  int option ;
  char const   *unzipper ;
  char const   *infile ;
  unsigned int r ;
  unsigned int g ;
  unsigned int b ;
  unsigned long hex ;
  int met ;
  char const   *filenames[4] ;
  char const   **fnp ;
  int any ;
  FILE *colortable ;
  FILE *tmp ;
  int clen ;
  char colorbuf[80] ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  unsigned int w ;
  unsigned int h ;
  int n ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int x ;
  int y ;
  int n___0 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  GimpLayerModeEffects m ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  struct xcfLayer *tmp___20 ;
  unsigned int pct ;
  int n___1 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  struct xcfLayer *tmp___23 ;
  unsigned int alpha ;
  int n___2 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  struct xcfLayer *tmp___26 ;
  struct xcfLayer *tmp___27 ;
  struct xcfLayer *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  rgba **allPixels ;
  rgba **tmp___32 ;
  lineCallback tmp___33 ;
  lineCallback tmp___34 ;

  {
  {
#line 208
  unzipper = (char const   *)((void *)0);
#line 209
  infile = (char const   *)((void *)0);
#line 211
  setlocale(6, "");
#line 212
  progname = (char const   *)*(argv + 0);
#line 213
  nls_init();
  }
#line 215
  if (argc <= 1) {
    {
#line 215
    gpl_blurb();
    }
  }
  {
#line 217
  init_flatspec(& flatspec);
#line 218
  flatspec.out_color_mode = (enum out_color_mode )0;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    option = getopt_long(argc, (char * const  *)argv, "-@#hVvjzZ:o:a:b:AcgmnTGDfS:O:Cu",
                         longopts, (int *)((void *)0));
    }
#line 219
    if (! (option >= 0)) {
#line 219
      goto while_break;
    }
    {
#line 21
    if (option == 104) {
#line 21 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/options.i"
      goto case_104;
    }
#line 28
    if (option == 86) {
#line 28
      goto case_86;
    }
#line 36
    if (option == 118) {
#line 36
      goto case_118;
    }
#line 42
    if (option == 106) {
#line 42
      goto case_106;
    }
#line 51
    if (option == 122) {
#line 51
      goto case_122;
    }
#line 60
    if (option == 90) {
#line 60
      goto case_90;
    }
#line 83
    if (option == 111) {
#line 83
      goto case_111;
    }
#line 92
    if (option == 97) {
#line 92
      goto case_97;
    }
#line 108
    if (option == 98) {
#line 108
      goto case_98;
    }
#line 179
    if (option == 65) {
#line 179
      goto case_65;
    }
#line 186
    if (option == 99) {
#line 186
      goto case_99;
    }
#line 198
    if (option == 103) {
#line 198
      goto case_103;
    }
#line 209
    if (option == 109) {
#line 209
      goto case_109;
    }
#line 222
    if (option == 110) {
#line 222
      goto case_110;
    }
#line 237
    if (option == 84) {
#line 237
      goto case_84;
    }
#line 249
    if (option == 71) {
#line 249
      goto case_71;
    }
#line 262
    if (option == 68) {
#line 262
      goto case_68;
    }
#line 272
    if (option == 102) {
#line 272
      goto case_102;
    }
#line 282
    if (option == 83) {
#line 282
      goto case_83;
    }
#line 299
    if (option == 79) {
#line 299
      goto case_79;
    }
#line 318
    if (option == 67) {
#line 318
      goto case_67;
    }
#line 337
    if (option == 300) {
#line 337
      goto case_300;
    }
#line 360
    if (option == 301) {
#line 360
      goto case_301;
    }
#line 374
    if (option == 302) {
#line 374
      goto case_302;
    }
#line 388
    if (option == 303) {
#line 388
      goto case_303;
    }
#line 394
    if (option == 304) {
#line 394
      goto case_304;
    }
#line 405
    if (option == 117) {
#line 405
      goto case_117;
    }
#line 223
    if (option == 1) {
#line 223 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
      goto case_1;
    }
#line 229
    if (option == 63) {
#line 229
      goto case_63;
    }
#line 231
    if (option == 64) {
#line 231
      goto case_64;
    }
#line 235
    if (option == 35) {
#line 235
      goto case_35;
    }
#line 239
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 25 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/options.i"
    usage(stdout);
#line 26
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 33
    printf((char const   */* __restrict  */)"xcf2pnm - Xcftools 1.0.7\n");
#line 34
    exit(0);
    }
    case_118: /* CIL Label */ 
#line 39
    verboseFlag = 1;
#line 40
    goto switch_break;
    case_106: /* CIL Label */ 
#line 48
    unzipper = "bzcat";
#line 49
    goto switch_break;
    case_122: /* CIL Label */ 
#line 57
    unzipper = "zcat";
#line 58
    goto switch_break;
    case_90: /* CIL Label */ 
#line 78
    unzipper = (char const   *)optarg;
#line 79
    goto switch_break;
    case_111: /* CIL Label */ 
#line 88
    flatspec.output_filename = (char const   *)optarg;
#line 89
    goto switch_break;
    case_97: /* CIL Label */ 
#line 104
    flatspec.transmap_filename = (char const   *)optarg;
#line 105
    goto switch_break;
    case_98: /* CIL Label */ 
#line 122
    met = 0;
#line 123
    if ((int )*optarg == 35) {
      {
#line 124
      sscanf((char const   */* __restrict  */)(optarg + 1), (char const   */* __restrict  */)"%lx%n",
             & hex, & met);
      }
    }
#line 125
    if (met == 3) {
      {
#line 125
      tmp___8 = strlen((char const   *)optarg);
      }
#line 125
      if (tmp___8 == 4UL) {
#line 126
        r = (unsigned int )(((hex >> 8) & 15UL) * 17UL);
#line 127
        g = (unsigned int )(((hex >> 4) & 15UL) * 17UL);
#line 128
        b = (unsigned int )((hex & 15UL) * 17UL);
      } else {
#line 125
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 129
    if (met == 6) {
      {
#line 129
      tmp___7 = strlen((char const   *)optarg);
      }
#line 129
      if (tmp___7 == 7UL) {
#line 130
        r = (unsigned int )((hex >> 16) & 255UL);
#line 131
        g = (unsigned int )((hex >> 8) & 255UL);
#line 132
        b = (unsigned int )(hex & 255UL);
      } else {
#line 129
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 133
      tmp___6 = strcasecmp((char const   *)optarg, "black");
      }
#line 133
      if (tmp___6 == 0) {
#line 134
        b = 0U;
#line 134
        g = b;
#line 134
        r = g;
      } else {
        {
#line 135
        tmp___5 = strcasecmp((char const   *)optarg, "white");
        }
#line 135
        if (tmp___5 == 0) {
#line 136
          b = 255U;
#line 136
          g = b;
#line 136
          r = g;
        } else {
#line 138
          filenames[0] = "/etc/X11/rgb.txt";
#line 138
          filenames[1] = "/usr/lib/X11/rgb.txt";
#line 138
          filenames[2] = "/usr/share/X11/rgb.txt";
#line 138
          filenames[3] = (char const   *)((void *)0);
#line 143
          r = 4294967295U;
#line 144
          any = 0;
#line 145
          fnp = filenames;
          {
#line 145
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 145
            if (r == 4294967295U) {
#line 145
              if (fnp) {
#line 145
                if (! *fnp) {
#line 145
                  goto while_break___0;
                }
              } else {
#line 145
                goto while_break___0;
              }
            } else {
#line 145
              goto while_break___0;
            }
            {
#line 146
            tmp = fopen((char const   */* __restrict  */)*fnp, (char const   */* __restrict  */)"rt");
#line 146
            colortable = tmp;
            }
#line 147
            if (colortable) {
#line 148
              any = 1;
              {
#line 151
              while (1) {
                while_continue___1: /* CIL Label */ ;
                {
#line 152
                tmp___0 = fgets((char */* __restrict  */)(colorbuf), (int )sizeof(colorbuf),
                                (FILE */* __restrict  */)colortable);
                }
#line 152
                if (! tmp___0) {
#line 153
                  r = 4294967295U;
#line 154
                  goto while_break___1;
                }
                {
#line 156
                tmp___1 = strlen((char const   *)(colorbuf));
#line 156
                clen = (int )tmp___1;
                }
                {
#line 157
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 157
                  if (clen) {
                    {
#line 157
                    tmp___2 = __ctype_b_loc();
                    }
#line 157
                    if (! ((int const   )*(*tmp___2 + (int )colorbuf[clen - 1]) & 8192)) {
#line 157
                      goto while_break___2;
                    }
                  } else {
#line 157
                    goto while_break___2;
                  }
#line 158
                  clen --;
                }
                while_break___2: /* CIL Label */ ;
                }
                {
#line 159
                colorbuf[clen] = (char )'\000';
#line 160
                clen = 0;
#line 161
                sscanf((char const   */* __restrict  */)(colorbuf), (char const   */* __restrict  */)" %u %u %u %n",
                       & r, & g, & b, & clen);
                }
#line 151
                if (! (clen == 0)) {
                  {
#line 151
                  tmp___3 = strcasecmp((char const   *)(colorbuf + clen), (char const   *)optarg);
                  }
#line 151
                  if (! (tmp___3 != 0)) {
#line 151
                    goto while_break___1;
                  }
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 163
              fclose(colortable);
              }
            }
#line 145
            fnp ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 166
          if (! any) {
            {
#line 167
            tmp___4 = gettext("Could not find X11 color database\n");
#line 167
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
            }
          }
        }
      }
    }
#line 170
    if (r == 4294967295U) {
      {
#line 171
      tmp___9 = gettext("Unknown background color \'%s\'");
#line 171
      FatalGeneric(20, (char const   *)tmp___9, optarg);
      }
    }
#line 172
    flatspec.default_pixel = ((255U + (r << 8)) + (g << 16)) + (b << 24);
#line 176
    goto switch_break;
    case_65: /* CIL Label */ 
#line 183
    flatspec.default_pixel = 2U;
#line 184
    goto switch_break;
    case_99: /* CIL Label */ 
#line 195
    flatspec.out_color_mode = (enum out_color_mode )3;
#line 196
    goto switch_break;
    case_103: /* CIL Label */ 
#line 205
    flatspec.out_color_mode = (enum out_color_mode )4;
#line 206
    goto switch_break;
    case_109: /* CIL Label */ 
#line 217
    flatspec.out_color_mode = (enum out_color_mode )5;
#line 218
    goto switch_break;
    case_110: /* CIL Label */ 
#line 233
    flatspec.out_color_mode = (enum out_color_mode )1;
#line 234
    goto switch_break;
    case_84: /* CIL Label */ 
#line 246
    flatspec.gimpish_indexed = 0;
#line 247
    goto switch_break;
    case_71: /* CIL Label */ 
#line 259
    flatspec.partial_transparency_mode = (enum __anonenum_partial_transparency_mode_31 )2;
#line 260
    goto switch_break;
    case_68: /* CIL Label */ 
#line 269
    flatspec.partial_transparency_mode = (enum __anonenum_partial_transparency_mode_31 )1;
#line 270
    goto switch_break;
    case_102: /* CIL Label */ 
#line 279
    flatspec.process_in_memory = 1;
#line 280
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 287
    n = 0;
#line 288
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ux%u%n",
           & w, & h, & n);
    }
#line 289
    if (n) {
      {
#line 289
      tmp___11 = strlen((char const   *)optarg);
      }
#line 289
      if ((size_t )n == tmp___11) {
#line 290
        if ((unsigned int )flatspec.window_mode == 4U) {
#line 290
          flatspec.window_mode = (enum __anonenum_window_mode_32 )0;
        }
#line 291
        flatspec.window_mode = (enum __anonenum_window_mode_32 )((unsigned int )flatspec.window_mode | 2U);
#line 292
        flatspec.dim.width = w;
#line 293
        flatspec.dim.height = h;
      } else {
        {
#line 295
        tmp___10 = gettext("-S option must have an argument of the form wxh");
#line 295
        FatalGeneric(20, (char const   *)tmp___10);
        }
      }
    } else {
      {
#line 295
      tmp___10 = gettext("-S option must have an argument of the form wxh");
#line 295
      FatalGeneric(20, (char const   *)tmp___10);
      }
    }
#line 296
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 306
    n___0 = 0;
#line 307
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%d,%d%n",
           & x, & y, & n___0);
    }
#line 308
    if (n___0) {
      {
#line 308
      tmp___13 = strlen((char const   *)optarg);
      }
#line 308
      if ((size_t )n___0 == tmp___13) {
#line 309
        if ((unsigned int )flatspec.window_mode == 4U) {
#line 309
          flatspec.window_mode = (enum __anonenum_window_mode_32 )0;
        }
#line 310
        flatspec.window_mode = (enum __anonenum_window_mode_32 )((unsigned int )flatspec.window_mode | 1U);
#line 311
        flatspec.dim.c.l = x;
#line 312
        flatspec.dim.c.t = y;
      } else {
        {
#line 314
        tmp___12 = gettext("-O option must have an argument of the form x,y");
#line 314
        FatalGeneric(20, (char const   *)tmp___12);
        }
      }
    } else {
      {
#line 314
      tmp___12 = gettext("-O option must have an argument of the form x,y");
#line 314
      FatalGeneric(20, (char const   *)tmp___12);
      }
    }
#line 315
    goto switch_break;
    case_67: /* CIL Label */ 
#line 330
    flatspec.window_mode = (enum __anonenum_window_mode_32 )4;
#line 331
    goto switch_break;
    case_300: /* CIL Label */ 
#line 346
    m = (GimpLayerModeEffects )0;
    {
#line 346
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 346
      if (! ((int )m < 25)) {
#line 346
        goto while_break___3;
      }
      {
#line 347
      tmp___14 = showGimpLayerModeEffects(m);
#line 347
      tmp___15 = gettext(tmp___14);
#line 347
      tmp___16 = strcmp((char const   *)optarg, (char const   *)tmp___15);
      }
#line 347
      if (tmp___16 == 0) {
#line 348
        goto found_localized;
      }
#line 346
      m = (GimpLayerModeEffects )((int )m + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 351
    m = (GimpLayerModeEffects )0;
    {
#line 351
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 351
      tmp___18 = showGimpLayerModeEffects(m);
#line 351
      tmp___19 = strcmp((char const   *)optarg, tmp___18);
      }
#line 351
      if (! (tmp___19 != 0)) {
#line 351
        goto while_break___4;
      }
#line 352
      if ((int )m > 25) {
        {
#line 353
        tmp___17 = gettext("Layer mode \'%s\' is unknown");
#line 353
        FatalGeneric(20, (char const   *)tmp___17, optarg);
        }
      }
#line 351
      m = (GimpLayerModeEffects )((int )m + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
    found_localized: 
    {
#line 356
    tmp___20 = lastlayerspec(& flatspec, "--mode");
#line 356
    tmp___20->mode = m;
    }
#line 357
    goto switch_break;
    case_301: /* CIL Label */ 
    {
#line 367
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%u%n",
           & pct, & n___1);
#line 368
    tmp___22 = strlen((char const   *)optarg);
    }
#line 368
    if ((size_t )n___1 != tmp___22) {
      {
#line 369
      tmp___21 = gettext("The argument to --percent is not a percentage");
#line 369
      FatalGeneric(20, (char const   *)tmp___21);
      }
    } else
#line 368
    if (pct > 100U) {
      {
#line 369
      tmp___21 = gettext("The argument to --percent is not a percentage");
#line 369
      FatalGeneric(20, (char const   *)tmp___21);
      }
    }
    {
#line 370
    tmp___23 = lastlayerspec(& flatspec, "--percent");
#line 370
    tmp___23->opacity = (pct * 255U) / 100U;
    }
#line 371
    goto switch_break;
    case_302: /* CIL Label */ 
    {
#line 380
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%u%n",
           & alpha, & n___2);
#line 381
    tmp___25 = strlen((char const   *)optarg);
    }
#line 381
    if ((size_t )n___2 != tmp___25) {
      {
#line 382
      tmp___24 = gettext("The argument to --opacity is not a number between 0 and 255");
#line 382
      FatalGeneric(20, (char const   *)tmp___24);
      }
    } else
#line 381
    if (alpha > 255U) {
      {
#line 382
      tmp___24 = gettext("The argument to --opacity is not a number between 0 and 255");
#line 382
      FatalGeneric(20, (char const   *)tmp___24);
      }
    }
    {
#line 384
    tmp___26 = lastlayerspec(& flatspec, "--percent");
#line 384
    tmp___26->opacity = alpha;
    }
#line 385
    goto switch_break;
    case_303: /* CIL Label */ 
    {
#line 391
    tmp___27 = lastlayerspec(& flatspec, "--mask");
#line 391
    tmp___27->hasMask = 1;
    }
#line 392
    goto switch_break;
    case_304: /* CIL Label */ 
    {
#line 397
    tmp___28 = lastlayerspec(& flatspec, "--nomask");
#line 397
    tmp___28->hasMask = 0;
    }
#line 398
    goto switch_break;
    case_117: /* CIL Label */ 
#line 411
    use_utf8 = 1;
#line 412
    goto switch_break;
    case_1: /* CIL Label */ 
#line 224
    if (infile) {
      {
#line 225
      add_layer_request(& flatspec, (char const   *)optarg);
      }
    } else {
#line 227 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf2pnm.c"
      infile = (char const   *)optarg;
    }
#line 228
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 230
    usage(stderr);
    }
    case_64: /* CIL Label */ 
#line 233
    suppress_byline = 1;
#line 234
    goto switch_break;
    case_35: /* CIL Label */ 
#line 237
    flatspec.default_pixel = 200U;
#line 238
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 240
    FatalUnexpected("Getopt(_long) unexpectedly returned \'%c\'", option);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 243
    usage(stderr);
    }
  }
#line 246
  if ((unsigned int )flatspec.out_color_mode == 0U) {
    {
#line 246
    tmp___29 = strlen(flatspec.output_filename);
    }
#line 246
    if (tmp___29 > 4UL) {
      {
#line 246
      tmp___30 = strlen(flatspec.output_filename);
      }
#line 246
      if ((int const   )*(flatspec.output_filename + (tmp___30 - 4UL)) == 46) {
        {
#line 249
        flatspec.out_color_mode = guess_color_mode(flatspec.output_filename);
        }
      }
    }
  }
#line 254
  if ((unsigned int )flatspec.out_color_mode == 0U) {
    {
#line 254
    tmp___31 = strlen(progname);
    }
#line 254
    if (tmp___31 > 3UL) {
      {
#line 256
      flatspec.out_color_mode = guess_color_mode(progname);
      }
    }
  }
#line 258
  if ((unsigned int )flatspec.out_color_mode == 0U) {
#line 259
    flatspec.out_color_mode = (enum out_color_mode )1;
  }
  {
#line 261
  read_or_mmap_xcf(infile, unzipper);
#line 262
  getBasicXcfInfo();
#line 263
  initColormap();
#line 265
  complete_flatspec(& flatspec, (enum out_color_mode (*)(struct FlattenSpec * , rgba ** ))((void *)0));
  }
#line 266
  if (flatspec.process_in_memory) {
    {
#line 267
    tmp___32 = flattenAll(& flatspec);
#line 267
    allPixels = tmp___32;
#line 268
    analyse_colormode(& flatspec, allPixels, (enum out_color_mode (*)(struct FlattenSpec * ,
                                                                      rgba ** ))((void *)0));
#line 269
    tmp___33 = selectCallback();
#line 269
    shipoutWithCallback(& flatspec, allPixels, tmp___33);
    }
  } else {
    {
#line 271
    tmp___34 = selectCallback();
#line 271
    flattenIncrementally(& flatspec, tmp___34);
    }
  }
  {
#line 273
  closeout(outfile, flatspec.output_filename);
#line 274
  closeout(transfile, flatspec.transmap_filename);
  }
#line 275
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
size_t xcf_length  ;
#line 166
void computeDimensions(struct tileDimensions *d ) ;
#line 186 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcftools.h"
struct xcfImage XCF  ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
uint8_t *xcf_file  =    (uint8_t *)0;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
int use_utf8  =    0;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
uint32_t xcfOffset(uint32_t addr , int spaceafter ) 
{ 
  uint32_t apparent ;

  {
  {
#line 36
  xcfCheckspace(addr, 4, "(xcfOffset)");
#line 37
  apparent = ntohl(*((uint32_t *)(xcf_file + addr)));
#line 38
  xcfCheckspace(apparent, spaceafter, "Too large offset (%X) at position %X", apparent,
                addr);
  }
#line 41
  return (apparent);
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
int xcfNextprop(uint32_t *master , uint32_t *body ) 
{ 
  uint32_t ptr ;
  uint32_t length ;
  uint32_t total ;
  uint32_t minlength ;
  PropType type ;
  uint32_t tmp ;
  uint32_t ncolors ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 49
  ptr = *master;
#line 50
  xcfCheckspace(ptr, 8, "(property header)");
#line 51
  tmp = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 51
  type = (PropType )tmp;
#line 52
  length = ntohl(*((uint32_t *)(xcf_file + (ptr + 4U))));
#line 53
  *body = ptr + 8U;
  }
  {
#line 56
  if ((unsigned int )type == 1U) {
#line 56
    goto case_1;
  }
#line 71
  if ((unsigned int )type == 17U) {
#line 71
    goto case_17;
  }
#line 72
  if ((unsigned int )type == 6U) {
#line 72
    goto case_6;
  }
#line 73
  if ((unsigned int )type == 11U) {
#line 73
    goto case_11;
  }
#line 74
  if ((unsigned int )type == 15U) {
#line 74
    goto case_15;
  }
#line 75
  if ((unsigned int )type == 7U) {
#line 75
    goto case_7;
  }
#line 76
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 59
  xcfCheckspace(ptr + 8U, 4, "(colormap length)");
#line 60
  ncolors = ntohl(*((uint32_t *)(xcf_file + (ptr + 8U))));
  }
#line 61
  if (ncolors > 256U) {
    {
#line 62
    FatalBadXCF("Colormap has %u entries", ncolors);
    }
  }
#line 68
  minlength = 4U + 3U * ncolors;
#line 68
  length = minlength;
#line 69
  goto switch_break;
  case_17: /* CIL Label */ 
#line 71
  minlength = (uint32_t )1;
#line 71
  goto switch_break;
  case_6: /* CIL Label */ 
#line 72
  minlength = (uint32_t )4;
#line 72
  goto switch_break;
  case_11: /* CIL Label */ 
#line 73
  minlength = (uint32_t )4;
#line 73
  goto switch_break;
  case_15: /* CIL Label */ 
#line 74
  minlength = (uint32_t )8;
#line 74
  goto switch_break;
  case_7: /* CIL Label */ 
#line 75
  minlength = (uint32_t )4;
#line 75
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 76
  minlength = (uint32_t )0;
#line 76
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 78
  if (length < minlength) {
    {
#line 79
    tmp___0 = showPropType(type);
#line 79
    FatalBadXCF("Short %s property at %X (%u<%u)", tmp___0, ptr, length, minlength);
    }
  }
#line 81
  *master = (ptr + 8U) + length;
#line 82
  if ((unsigned int )type != 0U) {
#line 82
    tmp___1 = 8;
  } else {
#line 82
    tmp___1 = 0;
  }
#line 82
  total = (8U + length) + (uint32_t )tmp___1;
#line 83
  if (total < length) {
    {
#line 84
    FatalBadXCF("Overlong property at %X", ptr);
    }
  }
  {
#line 85
  xcfCheckspace(ptr, (int )total, "Overlong property at %X", ptr);
  }
#line 86
  return ((int )type);
}
}
#line 170 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
static int warned  =    0;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
char const   *xcfString(uint32_t ptr , uint32_t *after ) 
{ 
  uint32_t length ;
  unsigned int i ;
  char *utf8master ;
  size_t targetsize ;
  int sloppy_translation ;
  iconv_t cd ;
  iconv_t tmp ;
  char *buffer ;
  void *tmp___0 ;
  char *inbuf ;
  char *outbuf ;
  size_t incount ;
  size_t outcount ;
  size_t result ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 96
  xcfCheckspace(ptr, 4, "(string length)");
#line 97
  length = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 98
  ptr += 4U;
#line 99
  xcfCheckspace(ptr, (int )length, "(string)");
#line 100
  utf8master = (char *)(xcf_file + ptr);
  }
#line 101
  if (after) {
#line 101
    *after = ptr + length;
  }
#line 102
  if (length == 0U) {
    {
#line 103
    FatalBadXCF("String at %X not zero-terminated", ptr - 4U);
    }
  } else
#line 102
  if ((int )*(utf8master + (length - 1U)) != 0) {
    {
#line 103
    FatalBadXCF("String at %X not zero-terminated", ptr - 4U);
    }
  }
#line 104
  length --;
#line 106
  if (use_utf8) {
#line 106
    return ((char const   *)utf8master);
  }
#line 111
  i = 0U;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (i == length) {
#line 113
      return ((char const   *)utf8master);
    }
#line 114
    if ((int )*(utf8master + i) == 0) {
      {
#line 115
      FatalBadXCF("String at %X has embedded zeroes", ptr - 4U);
      }
    }
#line 116
    if ((int )((int8_t )*(utf8master + i)) < 0) {
#line 117
      goto while_break;
    }
#line 111
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  targetsize = (size_t )(length + 1U);
#line 122
  sloppy_translation = 0;
#line 123
  tmp = iconv_open("//TRANSLIT", "UTF-8");
#line 123
  cd = tmp;
  }
#line 124
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
    {
#line 125
    cd = iconv_open("", "UTF-8");
#line 126
    sloppy_translation = 1;
    }
  }
#line 128
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
    {
#line 129
    iconv_close(cd);
    }
  } else {
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 132
      tmp___0 = xcfmalloc(targetsize);
#line 132
      buffer = (char *)tmp___0;
#line 133
      inbuf = utf8master;
#line 134
      outbuf = buffer;
#line 135
      incount = (size_t )length;
#line 136
      outcount = targetsize;
      }
      {
#line 137
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 138
        tmp___1 = iconv(cd, (char **/* __restrict  */)(& inbuf), (size_t */* __restrict  */)(& incount),
                        (char **/* __restrict  */)(& outbuf), (size_t */* __restrict  */)(& outcount));
#line 138
        result = tmp___1;
        }
#line 139
        if (result == 0xffffffffffffffffUL) {
          {
#line 139
          tmp___3 = __errno_location();
          }
#line 139
          if (*tmp___3 == 84) {
#line 139
            if (sloppy_translation) {
#line 139
              if (outcount > 0UL) {
#line 141
                tmp___2 = outbuf;
#line 141
                outbuf ++;
#line 141
                *tmp___2 = (char )'?';
#line 142
                outcount --;
                {
#line 143
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 143
                  if (! ((int )((int8_t )*inbuf) < 0)) {
#line 143
                    goto while_break___2;
                  }
#line 143
                  inbuf ++;
#line 143
                  incount --;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 144
                goto while_continue___1;
              }
            }
          }
        }
#line 146
        if (result != 0xffffffffffffffffUL) {
#line 147
          if (outcount == 0UL) {
            {
#line 148
            tmp___4 = __errno_location();
#line 148
            *tmp___4 = 7;
            }
          } else {
            {
#line 150
            *outbuf = (char)0;
#line 151
            iconv_close(cd);
            }
#line 152
            return ((char const   *)buffer);
          }
        }
#line 155
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 157
      tmp___5 = __errno_location();
      }
#line 157
      if (*tmp___5 == 84) {
        {
#line 158
        FatalBadXCF("Bad UTF-8 encoding \'%s\' at %lX", inbuf, (uintptr_t )((inbuf - utf8master) + (long )ptr));
        }
      } else {
        {
#line 157
        tmp___6 = __errno_location();
        }
#line 157
        if (*tmp___6 == 22) {
          {
#line 158
          FatalBadXCF("Bad UTF-8 encoding \'%s\' at %lX", inbuf, (uintptr_t )((inbuf - utf8master) + (long )ptr));
          }
        }
      }
      {
#line 160
      tmp___7 = __errno_location();
      }
#line 160
      if (*tmp___7 == 7) {
        {
#line 161
        targetsize += 1UL + incount;
#line 162
        xcffree((void *)buffer);
        }
#line 163
        goto while_continue___0;
      }
      {
#line 165
      FatalUnexpected("!iconv on layer name at %X", ptr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 171
  if (! warned) {
    {
#line 172
    tmp___8 = gettext("Warning: one or more layer names could not be\n         translated to the local character set.\n");
#line 172
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8);
#line 174
    warned = 1;
    }
  }
#line 177
  return ((char const   *)utf8master);
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
void computeDimensions(struct tileDimensions *d ) 
{ 


  {
#line 185
  d->c.r = (int )((unsigned int )d->c.l + d->width);
#line 186
  d->c.b = (int )((unsigned int )d->c.t + d->height);
#line 187
  d->tilesx = ((d->width + (unsigned int )(1 << 6)) - 1U) / (unsigned int )(1 << 6);
#line 188
  d->tilesy = ((d->height + (unsigned int )(1 << 6)) - 1U) / (unsigned int )(1 << 6);
#line 189
  d->ntiles = d->tilesx * d->tilesy;
#line 190
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
void getBasicXcfInfo(void) 
{ 
  uint32_t ptr ;
  uint32_t data ;
  uint32_t layerfile ;
  PropType type ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  struct xcfLayer *L ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  int tmp___13 ;

  {
  {
#line 201
  xcfCheckspace((uint32_t )0, 42, "(very short)");
#line 202
  tmp___1 = strcmp((char const   *)((char *)xcf_file), "gimp xcf file");
  }
#line 202
  if (tmp___1 == 0) {
#line 203
    XCF.version = 0;
  } else
#line 204
  if ((int )*(xcf_file + 13) == 0) {
    {
#line 204
    tmp___0 = sscanf((char const   */* __restrict  */)((char *)xcf_file), (char const   */* __restrict  */)"gimp xcf v%d",
                     & XCF.version);
    }
#line 204
    if (! (tmp___0 == 1)) {
      {
#line 208
      tmp = gettext("Not an XCF file at all (magic not recognized)");
#line 208
      FatalBadXCF((char const   *)tmp);
      }
    }
  } else {
    {
#line 208
    tmp = gettext("Not an XCF file at all (magic not recognized)");
#line 208
    FatalBadXCF((char const   *)tmp);
    }
  }
#line 210
  if (XCF.version < 0) {
    {
#line 211
    tmp___2 = gettext("Warning: XCF version %d not supported (trying anyway...)\n");
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            XCF.version);
    }
  } else
#line 210
  if (XCF.version > 2) {
    {
#line 211
    tmp___2 = gettext("Warning: XCF version %d not supported (trying anyway...)\n");
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            XCF.version);
    }
  }
  {
#line 216
  XCF.compression = (XcfCompressionType )0;
#line 217
  XCF.colormapptr = (uint32_t )0;
#line 219
  ptr = (uint32_t )14;
#line 220
  XCF.width = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 220
  ptr += 4U;
#line 221
  XCF.height = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 221
  ptr += 4U;
#line 222
  tmp___3 = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 222
  XCF.type = (GimpImageBaseType )tmp___3;
#line 222
  ptr += 4U;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp___4 = xcfNextprop(& ptr, & data);
#line 223
    type = (PropType )tmp___4;
    }
#line 223
    if (! ((unsigned int )type != 0U)) {
#line 223
      goto while_break;
    }
    {
#line 225
    if ((unsigned int )type == 1U) {
#line 225
      goto case_1;
    }
#line 228
    if ((unsigned int )type == 17U) {
#line 228
      goto case_17;
    }
#line 231
    goto switch_default;
    case_1: /* CIL Label */ 
#line 226
    XCF.colormapptr = data;
#line 227
    goto switch_break;
    case_17: /* CIL Label */ 
#line 229
    XCF.compression = (XcfCompressionType )*(xcf_file + data);
#line 230
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 233
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  layerfile = ptr;
#line 238
  XCF.numLayers = 0;
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 238
    tmp___5 = xcfOffset(ptr, 32);
    }
#line 238
    if (! tmp___5) {
#line 238
      goto while_break___0;
    }
#line 238
    (XCF.numLayers) ++;
#line 238
    ptr += 4U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 240
  tmp___6 = xcfmalloc((unsigned long )XCF.numLayers * sizeof(struct xcfLayer ));
#line 240
  XCF.layers = (struct xcfLayer *)tmp___6;
#line 241
  i = 0;
  }
  {
#line 241
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 241
    if (! (i < XCF.numLayers)) {
#line 241
      goto while_break___1;
    }
    {
#line 242
    L = XCF.layers + i;
#line 243
    ptr = ntohl(*((uint32_t *)(xcf_file + (layerfile + (uint32_t )(4 * ((XCF.numLayers - 1) - i))))));
#line 244
    L->mode = (GimpLayerModeEffects )0;
#line 245
    L->opacity = 255U;
#line 246
    L->isVisible = 1;
#line 247
    L->hasMask = 0;
#line 248
    L->dim.width = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 248
    ptr += 4U;
#line 249
    L->dim.height = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 249
    ptr += 4U;
#line 250
    tmp___7 = ntohl(*((uint32_t *)(xcf_file + ptr)));
#line 250
    L->type = (GimpImageType )tmp___7;
#line 250
    ptr += 4U;
#line 251
    L->name = xcfString(ptr, & ptr);
#line 252
    L->propptr = ptr;
    }
    {
#line 253
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 253
      tmp___13 = xcfNextprop(& ptr, & data);
#line 253
      type = (PropType )tmp___13;
      }
#line 253
      if (! ((unsigned int )type != 0U)) {
#line 253
        goto while_break___2;
      }
      {
#line 255
      if ((unsigned int )type == 6U) {
#line 255
        goto case_6;
      }
#line 260
      if ((unsigned int )type == 8U) {
#line 260
        goto case_8;
      }
#line 263
      if ((unsigned int )type == 11U) {
#line 263
        goto case_11;
      }
#line 266
      if ((unsigned int )type == 15U) {
#line 266
        goto case_15;
      }
#line 270
      if ((unsigned int )type == 7U) {
#line 270
        goto case_7;
      }
#line 273
      goto switch_default___0;
      case_6: /* CIL Label */ 
      {
#line 256
      L->opacity = ntohl(*((uint32_t *)(xcf_file + data)));
      }
#line 257
      if (L->opacity > 255U) {
#line 258
        L->opacity = 255U;
      }
#line 259
      goto switch_break___0;
      case_8: /* CIL Label */ 
      {
#line 261
      tmp___8 = ntohl(*((uint32_t *)(xcf_file + data)));
#line 261
      L->isVisible = tmp___8 != 0U;
      }
#line 262
      goto switch_break___0;
      case_11: /* CIL Label */ 
      {
#line 264
      tmp___9 = ntohl(*((uint32_t *)(xcf_file + data)));
#line 264
      L->hasMask = tmp___9 != 0U;
      }
#line 265
      goto switch_break___0;
      case_15: /* CIL Label */ 
      {
#line 267
      tmp___10 = ntohl(*((uint32_t *)(xcf_file + data)));
#line 267
      L->dim.c.l = (int32_t )tmp___10;
#line 268
      tmp___11 = ntohl(*((uint32_t *)(xcf_file + (data + 4U))));
#line 268
      L->dim.c.t = (int32_t )tmp___11;
      }
#line 269
      goto switch_break___0;
      case_7: /* CIL Label */ 
      {
#line 271
      tmp___12 = ntohl(*((uint32_t *)(xcf_file + data)));
#line 271
      L->mode = (GimpLayerModeEffects )tmp___12;
      }
#line 272
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 275
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 278
    xcfCheckspace(ptr, 8, "(end of layer %s)", L->name);
#line 279
    L->pixels.tileptrs = (uint32_t *)0;
#line 280
    L->pixels.hierarchy = xcfOffset(ptr, 16);
#line 281
    L->mask.tileptrs = (uint32_t *)0;
#line 282
    L->mask.hierarchy = xcfOffset(ptr + 4U, 16);
#line 284
    computeDimensions(& L->dim);
#line 241
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
void init_flatspec(struct FlattenSpec *spec ) 
{ 


  {
#line 27
  spec->window_mode = (enum __anonenum_window_mode_32 )0;
#line 28
  spec->default_pixel = 1U;
#line 29
  spec->numLayers = 0;
#line 30
  spec->layers = (struct xcfLayer *)((void *)0);
#line 31
  spec->transmap_filename = (char const   *)((void *)0);
#line 32
  spec->output_filename = "-";
#line 33
  spec->out_color_mode = (enum out_color_mode )1;
#line 34
  spec->partial_transparency_mode = (enum __anonenum_partial_transparency_mode_31 )0;
#line 35
  spec->process_in_memory = 0;
#line 36
  spec->gimpish_indexed = 1;
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
void add_layer_request(struct FlattenSpec *spec , char const   *layer ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 42
  tmp = realloc((void *)spec->layers, sizeof(struct xcfLayer ) * (unsigned long )(1 + spec->numLayers));
#line 42
  spec->layers = (struct xcfLayer *)tmp;
  }
#line 44
  if ((unsigned long )spec->layers == (unsigned long )((void *)0)) {
    {
#line 45
    tmp___0 = gettext("Out of memory");
#line 45
    FatalUnexpected((char const   *)tmp___0);
    }
  }
#line 46
  (spec->layers + spec->numLayers)->name = layer;
#line 47
  (spec->layers + spec->numLayers)->mode = (GimpLayerModeEffects )-1;
#line 48
  (spec->layers + spec->numLayers)->opacity = 9999U;
#line 49
  (spec->layers + spec->numLayers)->hasMask = -1;
#line 50
  (spec->numLayers) ++;
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
struct xcfLayer *lastlayerspec(struct FlattenSpec *spec , char const   *option ) 
{ 
  char *tmp ;

  {
#line 56
  if (spec->numLayers == 0) {
    {
#line 57
    tmp = gettext("The %s option must follow a layer name on the command line");
#line 57
    FatalGeneric(20, (char const   *)tmp, option);
    }
  }
#line 59
  return (spec->layers + (spec->numLayers - 1));
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
static int typeHasTransparency(GimpImageType type ) 
{ 


  {
  {
#line 68
  if ((unsigned int )type == 4U) {
#line 68
    goto case_4;
  }
#line 68
  if ((unsigned int )type == 2U) {
#line 68
    goto case_4;
  }
#line 68
  if ((unsigned int )type == 0U) {
#line 68
    goto case_4;
  }
#line 72
  if ((unsigned int )type == 5U) {
#line 72
    goto case_5;
  }
#line 72
  if ((unsigned int )type == 3U) {
#line 72
    goto case_5;
  }
#line 72
  if ((unsigned int )type == 1U) {
#line 72
    goto case_5;
  }
#line 65
  goto switch_break;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 69
  return (0);
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 73
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 75
  return (1);
}
}
#line 78 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
static enum out_color_mode color_by_layers(struct FlattenSpec *spec ) 
{ 
  int colormap_is_colored ;
  enum out_color_mode grayish ;
  int i ;
  int degrayed ;
  int tmp ;
  int tmp___0 ;

  {
#line 81
  colormap_is_colored = 0;
#line 85
  if (spec->default_pixel == 200U) {
#line 86
    grayish = (enum out_color_mode )4;
  } else {
    {
#line 88
    tmp = degrayPixel(spec->default_pixel);
#line 88
    degrayed = tmp;
    }
#line 89
    if (degrayed < 0) {
#line 90
      return ((enum out_color_mode )3);
    } else
#line 91
    if (spec->gimpish_indexed) {
#line 91
      if (degrayed == 0) {
#line 93
        grayish = (enum out_color_mode )5;
      } else
#line 91
      if (degrayed == 255) {
#line 93
        grayish = (enum out_color_mode )5;
      } else {
#line 95
        grayish = (enum out_color_mode )4;
      }
    } else {
#line 95
      grayish = (enum out_color_mode )4;
    }
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((unsigned int )i < colormapLength)) {
#line 98
      goto while_break;
    }
#line 99
    if (colormap[i] == 0U) {
#line 100
      goto __Cont;
    } else
#line 99
    if (colormap[i] == 4294967040U) {
#line 100
      goto __Cont;
    }
    {
#line 101
    tmp___0 = degrayPixel(colormap[i]);
    }
#line 101
    if (tmp___0 == -1) {
#line 102
      colormap_is_colored = 1;
#line 103
      goto while_break;
    } else {
#line 105
      grayish = (enum out_color_mode )4;
    }
    __Cont: /* CIL Label */ 
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    if (! (i < spec->numLayers)) {
#line 108
      goto while_break___0;
    }
    {
#line 111
    if ((unsigned int )(spec->layers + i)->type == 1U) {
#line 111
      goto case_1;
    }
#line 111
    if ((unsigned int )(spec->layers + i)->type == 0U) {
#line 111
      goto case_1;
    }
#line 114
    if ((unsigned int )(spec->layers + i)->type == 3U) {
#line 114
      goto case_3;
    }
#line 114
    if ((unsigned int )(spec->layers + i)->type == 2U) {
#line 114
      goto case_3;
    }
#line 118
    if ((unsigned int )(spec->layers + i)->type == 5U) {
#line 118
      goto case_5;
    }
#line 118
    if ((unsigned int )(spec->layers + i)->type == 4U) {
#line 118
      goto case_5;
    }
#line 109
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 112
    return ((enum out_color_mode )3);
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 115
    grayish = (enum out_color_mode )4;
#line 116
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 119
    if (colormap_is_colored) {
#line 119
      return ((enum out_color_mode )3);
    }
#line 120
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return (grayish);
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
void complete_flatspec(struct FlattenSpec *spec , enum out_color_mode (*guess_callback)(struct FlattenSpec * ,
                                                                                        rgba ** ) ) 
{ 
  unsigned int i ;
  int anyPartial ;
  GimpLayerModeEffects mode ;
  int opacity ;
  int hasMask ;
  unsigned int j ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int first ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned int tmp___10 ;

  {
#line 133
  if (spec->numLayers == 0) {
#line 134
    spec->layers = XCF.layers;
#line 135
    spec->numLayers = XCF.numLayers;
  } else {
#line 137
    i = 0U;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! (i < (unsigned int )spec->numLayers)) {
#line 137
        goto while_break;
      }
#line 142
      j = 0U;
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 143
        if (j == (unsigned int )XCF.numLayers) {
          {
#line 144
          tmp = gettext("The image has no layer called \'%s\'");
#line 144
          FatalGeneric(22, (char const   *)tmp, (spec->layers + i)->name);
          }
        }
        {
#line 146
        tmp___0 = strcmp((spec->layers + i)->name, (XCF.layers + j)->name);
        }
#line 146
        if (tmp___0 == 0) {
#line 147
          goto while_break___0;
        }
#line 142
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 149
      if ((int )(spec->layers + i)->mode == (int )((GimpLayerModeEffects )-1)) {
#line 149
        mode = (XCF.layers + j)->mode;
      } else {
#line 149
        mode = (spec->layers + i)->mode;
      }
#line 151
      if ((spec->layers + i)->opacity == 9999U) {
#line 151
        opacity = (int )(XCF.layers + j)->opacity;
      } else {
#line 151
        opacity = (int )(spec->layers + i)->opacity;
      }
#line 153
      if ((spec->layers + i)->hasMask == -1) {
#line 153
        hasMask = (XCF.layers + j)->hasMask;
      } else {
#line 153
        hasMask = (spec->layers + i)->hasMask;
      }
#line 155
      if (hasMask) {
#line 155
        if (! (XCF.layers + j)->hasMask) {
#line 155
          if ((XCF.layers + j)->mask.hierarchy == 0U) {
            {
#line 157
            tmp___1 = gettext("Layer \'%s\' has no layer mask to enable");
#line 157
            FatalGeneric(22, (char const   *)tmp___1, (spec->layers + i)->name);
            }
          }
        }
      }
#line 159
      *(spec->layers + i) = *(XCF.layers + j);
#line 160
      (spec->layers + i)->mode = mode;
#line 161
      (spec->layers + i)->opacity = (unsigned int )opacity;
#line 162
      (spec->layers + i)->hasMask = hasMask;
#line 163
      (spec->layers + i)->isVisible = 1;
#line 137
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 170
  i = 0U;
  {
#line 170
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 170
    if (! (i < (unsigned int )spec->numLayers)) {
#line 170
      goto while_break___1;
    }
#line 171
    if ((spec->layers + i)->isVisible) {
#line 172
      if ((int )(spec->layers + i)->mode != 1) {
#line 173
        (spec->layers + i)->mode = (GimpLayerModeEffects )0;
      }
#line 174
      goto while_break___1;
    }
#line 170
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 179
  if ((unsigned int )XCF.type == 2U) {
#line 179
    if (spec->gimpish_indexed) {
#line 180
      i = 0U;
      {
#line 180
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 180
        if (! (i < (unsigned int )spec->numLayers)) {
#line 180
          goto while_break___2;
        }
#line 181
        if ((int )(spec->layers + i)->mode != 1) {
#line 182
          (spec->layers + i)->mode = (GimpLayerModeEffects )-1;
        }
#line 180
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 184
      spec->gimpish_indexed = 0;
    }
  } else {
#line 184
    spec->gimpish_indexed = 0;
  }
#line 187
  if ((unsigned int )spec->window_mode == 4U) {
#line 188
    first = 1;
#line 189
    i = 0U;
    {
#line 189
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 189
      if (! (i < (unsigned int )spec->numLayers)) {
#line 189
        goto while_break___3;
      }
#line 190
      if ((spec->layers + i)->isVisible) {
        {
#line 191
        computeDimensions(& (spec->layers + i)->dim);
        }
#line 192
        if (first) {
#line 193
          spec->dim = (spec->layers + i)->dim;
#line 194
          first = 0;
        } else {
#line 196
          if (spec->dim.c.l > (spec->layers + i)->dim.c.l) {
#line 197
            spec->dim.c.l = (spec->layers + i)->dim.c.l;
          }
#line 198
          if (spec->dim.c.r < (spec->layers + i)->dim.c.r) {
#line 199
            spec->dim.c.r = (spec->layers + i)->dim.c.r;
          }
#line 200
          if (spec->dim.c.t > (spec->layers + i)->dim.c.t) {
#line 201
            spec->dim.c.t = (spec->layers + i)->dim.c.t;
          }
#line 202
          if (spec->dim.c.b < (spec->layers + i)->dim.c.b) {
#line 203
            spec->dim.c.b = (spec->layers + i)->dim.c.b;
          }
        }
      }
#line 189
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 206
    if (first) {
#line 207
      spec->window_mode = (enum __anonenum_window_mode_32 )0;
    } else {
#line 209
      spec->dim.width = (unsigned int )(spec->dim.c.r - spec->dim.c.l);
#line 210
      spec->dim.height = (unsigned int )(spec->dim.c.b - spec->dim.c.t);
    }
  }
#line 213
  if ((unsigned int )spec->window_mode != 4U) {
#line 214
    if (((unsigned int )spec->window_mode & 1U) == 0U) {
#line 215
      tmp___2 = 0;
#line 215
      spec->dim.c.l = tmp___2;
#line 215
      spec->dim.c.t = tmp___2;
    }
#line 216
    if (((unsigned int )spec->window_mode & 2U) == 0U) {
#line 217
      spec->dim.height = XCF.height;
#line 218
      spec->dim.width = XCF.width;
    }
  }
  {
#line 221
  computeDimensions(& spec->dim);
#line 224
  i = 0U;
  }
  {
#line 224
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 224
    if (! (i < (unsigned int )spec->numLayers)) {
#line 224
      goto while_break___4;
    }
#line 225
    if ((spec->layers + i)->isVisible) {
#line 225
      if (spec->dim.c.l >= (spec->layers + i)->dim.c.r) {
#line 227
        (spec->layers + i)->isVisible = 0;
      } else
#line 225
      if (spec->dim.c.r <= (spec->layers + i)->dim.c.l) {
#line 227
        (spec->layers + i)->isVisible = 0;
      } else
#line 225
      if (spec->dim.c.t >= (spec->layers + i)->dim.c.b) {
#line 227
        (spec->layers + i)->isVisible = 0;
      } else
#line 225
      if (spec->dim.c.b <= (spec->layers + i)->dim.c.t) {
#line 227
        (spec->layers + i)->isVisible = 0;
      }
    }
#line 224
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 231
  anyPartial = 0;
#line 232
  i = (unsigned int )spec->numLayers;
  {
#line 232
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 232
    tmp___4 = i;
#line 232
    i --;
#line 232
    if (! tmp___4) {
#line 232
      goto while_break___5;
    }
#line 233
    if (! (spec->layers + i)->isVisible) {
#line 234
      goto __Cont;
    }
    {
#line 235
    tmp___3 = typeHasTransparency((spec->layers + i)->type);
    }
#line 235
    if (tmp___3) {
#line 236
      if ((int )(spec->layers + i)->mode == 0) {
#line 237
        anyPartial = 1;
      }
    } else
#line 238
    if (spec->dim.c.l >= (spec->layers + i)->dim.c.l) {
#line 238
      if (spec->dim.c.r <= (spec->layers + i)->dim.c.r) {
#line 238
        if (spec->dim.c.t >= (spec->layers + i)->dim.c.t) {
#line 238
          if (spec->dim.c.b <= (spec->layers + i)->dim.c.b) {
#line 238
            if (! (spec->layers + i)->hasMask) {
#line 238
              if ((int )(spec->layers + i)->mode == 0) {
#line 238
                goto _L;
              } else
#line 238
              if ((int )(spec->layers + i)->mode == -1) {
#line 238
                goto _L;
              } else
#line 238
              if ((int )(spec->layers + i)->mode == 1) {
                _L: /* CIL Label */ 
                {
#line 247
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 247
                  if (! i) {
#line 247
                    goto while_break___6;
                  }
#line 247
                  i --;
#line 247
                  (spec->layers + i)->isVisible = 0;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 248
                if (spec->default_pixel != 2U) {
#line 249
                  spec->default_pixel = (colormap[0] & 4294967040U) + 255U;
                }
#line 250
                anyPartial = 0;
#line 251
                goto while_break___5;
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 254
  if ((unsigned int )spec->partial_transparency_mode == 0U) {
#line 254
    if (! anyPartial) {
#line 256
      spec->partial_transparency_mode = (enum __anonenum_partial_transparency_mode_31 )3;
    } else
#line 254
    if ((int )((uint8_t )spec->default_pixel) >= 128) {
#line 256
      spec->partial_transparency_mode = (enum __anonenum_partial_transparency_mode_31 )3;
    }
  }
#line 259
  i = (unsigned int )spec->numLayers;
  {
#line 259
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 259
    tmp___10 = i;
#line 259
    i --;
#line 259
    if (! tmp___10) {
#line 259
      goto while_break___7;
    }
#line 260
    if ((spec->layers + i)->isVisible) {
      {
#line 261
      initLayer(spec->layers + i);
      }
#line 262
      if (verboseFlag) {
        {
#line 263
        tmp___5 = showGimpLayerModeEffects((spec->layers + i)->mode);
#line 263
        tmp___6 = gettext(tmp___5);
#line 263
        tmp___7 = showGimpImageType((spec->layers + i)->type);
#line 263
        tmp___8 = gettext(tmp___7);
#line 263
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dx%d%+d%+d %s %s",
                (spec->layers + i)->dim.width, (spec->layers + i)->dim.height, (spec->layers + i)->dim.c.l - spec->dim.c.l,
                (spec->layers + i)->dim.c.t - spec->dim.c.t, tmp___8, tmp___6);
        }
#line 269
        if ((spec->layers + i)->opacity < 255U) {
          {
#line 270
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"/%02d%%",
                  ((spec->layers + i)->opacity * 100U) / 255U);
          }
        }
#line 271
        if ((XCF.layers + i)->hasMask) {
          {
#line 272
          tmp___9 = gettext("/mask");
#line 272
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9);
          }
        }
        {
#line 273
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s\n",
                (spec->layers + i)->name);
        }
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 278
  if ((unsigned int )spec->out_color_mode == 1U) {
#line 278
    if (! spec->process_in_memory) {
#line 280
      if (guess_callback) {
        {
#line 281
        spec->out_color_mode = (*guess_callback)(spec, (rgba **)((void *)0));
        }
      }
#line 282
      if ((unsigned int )spec->out_color_mode == 1U) {
        {
#line 283
        spec->out_color_mode = color_by_layers(spec);
        }
      }
    }
  }
#line 285
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/flatspec.c"
void analyse_colormode(struct FlattenSpec *spec , rgba **allPixels , enum out_color_mode (*guess_callback)(struct FlattenSpec * ,
                                                                                                           rgba ** ) ) 
{ 
  unsigned int x ;
  unsigned int y ;
  int status ;
  int known_absent ;
  int assume_present ;
  enum out_color_mode tmp ;
  rgba *row ;
  rgba full ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 298
  known_absent = 0;
#line 299
  assume_present = 0;
#line 301
  if ((unsigned int )spec->out_color_mode == 1U) {
#line 301
    if (guess_callback) {
      {
#line 302
      spec->out_color_mode = (*guess_callback)(spec, allPixels);
      }
    }
  }
#line 304
  if ((unsigned int )spec->out_color_mode == 3U) {
#line 304
    assume_present |= 3;
  }
#line 305
  if ((unsigned int )spec->out_color_mode == 2U) {
#line 305
    assume_present |= 3;
  }
#line 306
  if ((unsigned int )spec->out_color_mode == 4U) {
#line 306
    assume_present |= 2;
  }
  {
#line 307
  tmp = color_by_layers(spec);
  }
  {
#line 308
  if ((unsigned int )tmp == 4U) {
#line 308
    goto case_4;
  }
#line 309
  if ((unsigned int )tmp == 5U) {
#line 309
    goto case_5;
  }
#line 310
  goto switch_default;
  case_4: /* CIL Label */ 
#line 308
  known_absent |= 1;
#line 308
  goto switch_break;
  case_5: /* CIL Label */ 
#line 309
  known_absent |= 3;
#line 309
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 310
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 312
  if ((unsigned int )spec->partial_transparency_mode == 1U) {
#line 314
    known_absent |= 4;
  } else
#line 312
  if ((unsigned int )spec->partial_transparency_mode == 3U) {
#line 314
    known_absent |= 4;
  }
#line 315
  if ((int )((uint8_t )spec->default_pixel) >= 128) {
#line 315
    known_absent |= 12;
  } else
#line 316
  if (spec->default_pixel == 2U) {
#line 316
    assume_present |= 8;
  }
#line 318
  status = 15 - (known_absent | assume_present);
#line 320
  y = 0U;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (status) {
#line 320
      if (! (y < spec->dim.height)) {
#line 320
        goto while_break;
      }
    } else {
#line 320
      goto while_break;
    }
#line 321
    row = *(allPixels + y);
#line 322
    if ((status & 3) != 0) {
#line 324
      x = 0U;
      {
#line 324
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 324
        if (status) {
#line 324
          if (! (x < spec->dim.width)) {
#line 324
            goto while_break___0;
          }
        } else {
#line 324
          goto while_break___0;
        }
#line 325
        if ((int )((uint8_t )*(row + x)) == 0) {
#line 326
          status &= -9;
        } else {
#line 328
          full = *(row + x) | 255U;
#line 329
          if (! ((int )((uint8_t )*(row + x)) == 255)) {
#line 329
            status &= -13;
          }
#line 330
          if (! (full == 255U)) {
#line 330
            if (! (full == 4294967295U)) {
              {
#line 332
              tmp___0 = degrayPixel(*(row + x));
              }
#line 332
              if (tmp___0 != -1) {
#line 333
                status &= -3;
              } else {
#line 335
                status &= -4;
              }
            }
          }
        }
#line 324
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 340
      x = 0U;
      {
#line 340
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 340
        if (status) {
#line 340
          if (! (x < spec->dim.width)) {
#line 340
            goto while_break___1;
          }
        } else {
#line 340
          goto while_break___1;
        }
#line 341
        if ((int )((uint8_t )*(row + x)) == 0) {
#line 342
          status &= -9;
        } else
#line 343
        if (! ((int )((uint8_t )*(row + x)) == 255)) {
#line 344
          status &= -13;
        }
#line 340
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 320
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  status |= known_absent;
  {
#line 353
  if ((unsigned int )spec->out_color_mode == 3U) {
#line 353
    goto case_3;
  }
#line 353
  if ((unsigned int )spec->out_color_mode == 2U) {
#line 353
    goto case_3;
  }
#line 355
  if ((unsigned int )spec->out_color_mode == 4U) {
#line 355
    goto case_4___0;
  }
#line 360
  if ((unsigned int )spec->out_color_mode == 5U) {
#line 360
    goto case_5___0;
  }
#line 366
  if ((unsigned int )spec->out_color_mode == 1U) {
#line 366
    goto case_1;
  }
#line 366
  if ((unsigned int )spec->out_color_mode == 0U) {
#line 366
    goto case_1;
  }
#line 351
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 354
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 356
  if ((status & 1) == 0) {
    {
#line 357
    tmp___1 = gettext("Grayscale output selected, but colored pixel(s) found");
#line 357
    FatalGeneric(103, (char const   *)tmp___1);
    }
  }
#line 359
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 361
  if ((status & 2) == 0) {
    {
#line 362
    tmp___2 = gettext("Monochrome output selected, but not all pixels are black or white");
#line 362
    FatalGeneric(103, (char const   *)tmp___2);
    }
  }
#line 364
  goto switch_break___0;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 367
  if ((status & 1) == 0) {
#line 368
    spec->out_color_mode = (enum out_color_mode )3;
  } else
#line 369
  if ((status & 2) == 0) {
#line 370
    spec->out_color_mode = (enum out_color_mode )4;
  } else {
#line 372
    spec->out_color_mode = (enum out_color_mode )5;
  }
#line 373
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 376
  if ((status & 12) == 12) {
#line 377
    spec->default_pixel = (colormap[0] & 4294967040U) + 255U;
  } else
#line 378
  if ((status & 12) == 4) {
#line 379
    spec->partial_transparency_mode = (enum __anonenum_partial_transparency_mode_31 )3;
  }
#line 380
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/io-unix.c"
static FILE *xcfstream___0  =    (FILE *)0;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcfinfo.oi"
static struct option  const  longopts___0[8]  = 
#line 6 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcfinfo.oi"
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"bzip", 0, (int *)0, 'j'}, 
        {"gzip", 0, (int *)0, 'z'}, 
        {"unpack", 1, (int *)0, 'Z'}, 
        {"utf8", 0, (int *)0, 'u'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 19 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcfinfo.oi"
static void opt_usage___0(FILE *f ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 22
  i = 2;
#line 24
  tmp = gettext("command");
#line 24
  tmp___0 = strlen((char const   *)tmp);
#line 24
  j = (int )(tmp___0 + 3UL);
  }
#line 24
  if (j > i) {
#line 24
    i = j;
  }
  {
#line 25
  tmp___1 = gettext("show this message");
#line 25
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -h%-*s %s (--help)\n",
          i - 2, "", tmp___1);
#line 27
  tmp___2 = gettext("show version");
#line 27
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -V%-*s %s (--version)\n",
          i - 2, "", tmp___2);
#line 29
  tmp___3 = gettext("show progress messages");
#line 29
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -v%-*s %s (--verbose)\n",
          i - 2, "", tmp___3);
#line 31
  tmp___4 = gettext("input is bzip2 compressed");
#line 31
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -j%-*s %s (--bzip)\n",
          i - 2, "", tmp___4);
#line 33
  tmp___5 = gettext("input is gzip compressed");
#line 33
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -z%-*s %s (--gzip)\n",
          i - 2, "", tmp___5);
#line 35
  tmp___6 = gettext("use \'command\' to decompress input");
#line 35
  tmp___7 = gettext("command");
#line 35
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -Z %-*s %s (--unpack)\n",
          i - 3, tmp___7, tmp___6);
#line 37
  tmp___8 = gettext("use UTF-8 for layer names");
#line 37
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  -u%-*s %s (--utf8)\n",
          i - 2, "", tmp___8);
  }
#line 39
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcfinfo.c"
static void usage___0(FILE *where ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 37
  tmp = gettext("Usage: %s [options] filename.xcf[.gz]\n");
#line 37
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tmp, progname);
#line 38
  tmp___0 = gettext("Options:\n");
#line 38
  fprintf((FILE */* __restrict  */)where, (char const   */* __restrict  */)tmp___0);
#line 39
  opt_usage___0(where);
  }
#line 40
  if ((unsigned long )where == (unsigned long )stderr) {
    {
#line 41
    exit(1);
    }
  }
#line 43
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___4[35]  ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___5[32]  ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___6[28]  ;
#line 71 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___7[23]  ;
#line 107 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/enums.c"
static char buf___8[33]  ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
static  __attribute__((__noreturn__)) void vFatalGeneric___0(int status , char const   *format ,
                                                             va_list args ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/utils.c"
static void vFatalGeneric___0(int status , char const   *format , va_list args ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 32
  if (format) {
#line 33
    if ((int const   )*format == 33) {
      {
#line 34
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(format + 1),
               args);
#line 35
      tmp = __errno_location();
#line 35
      tmp___0 = strerror(*tmp);
#line 35
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
              tmp___0);
      }
    } else {
      {
#line 37
      vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
               args);
#line 38
      fputc('\n', stderr);
      }
    }
  }
  {
#line 41
  exit(status);
  }
}
}
#line 170 "/home/june/repo/benchmarks/collector2/temp/xcftools-1.0.7/xcf-general.c"
static int warned___0  =    0;
