/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 37 "/usr/include/stdint.h"
typedef short int16_t;
#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 61 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 207 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvt.h"
typedef struct termios ttymode_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 105 "/usr/include/X11/X.h"
typedef XID GContext;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 172 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExtCodes_69 {
   int extension ;
   int major_opcode ;
   int first_event ;
   int first_error ;
};
#line 172 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExtCodes_69 XExtCodes;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_71 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_71 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_72 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_72 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_73 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_73 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_74 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_74 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_75 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_75 ScreenFormat;
#line 442 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_84 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 442 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_84 XRectangle;
#line 487 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_89 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 487 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_89 XModifierKeymap;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 503
struct _XrmHashBucketRec;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_91 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_92 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_93 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_94 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_95 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_96 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_97 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_98 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_99 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_100 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_101 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_102 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_103 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_103 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_104 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_105 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_105 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_106 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_107 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_108 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_109 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_109 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_110 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_110 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_111 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_111 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_112 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_112 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_113 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_113 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_114 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_114 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_115 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_115 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_116 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_116 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_117 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_117 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_119 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_118 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_119 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_118 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_120 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_120 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_121 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_121 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_122 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_122 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_123 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_123 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_124 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_124 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_125 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_125 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_126 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_126 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_127 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_127 XFontStruct;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_150 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_149 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_150 min_aspect ;
   struct __anonstruct_min_aspect_150 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_149 XSizeHints;
#line 273
struct _XRegion;
#line 273 "/usr/include/X11/Xutil.h"
typedef struct _XRegion *Region;
#line 98 "/usr/include/X11/Xmd.h"
typedef int INT32;
#line 102 "/usr/include/X11/Xmd.h"
typedef short INT16;
#line 104 "/usr/include/X11/Xmd.h"
typedef signed char INT8;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 113 "/usr/include/X11/Xmd.h"
typedef unsigned short CARD16;
#line 114 "/usr/include/X11/Xmd.h"
typedef unsigned char CARD8;
#line 119 "/usr/include/X11/Xmd.h"
typedef CARD8 BYTE;
#line 120 "/usr/include/X11/Xmd.h"
typedef CARD8 BOOL;
#line 259 "/usr/include/X11/Xproto.h"
typedef CARD16 KeyButMask;
#line 425 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGenericReply_172 {
   BYTE type ;
   BYTE data1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 data00 ;
   CARD32 data01 ;
   CARD32 data02 ;
   CARD32 data03 ;
   CARD32 data04 ;
   CARD32 data05 ;
};
#line 425 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGenericReply_172 xGenericReply;
#line 466 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetGeometryReply_174 {
   BYTE type ;
   CARD8 depth ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   CARD16 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 466 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetGeometryReply_174 xGetGeometryReply;
#line 480 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryTreeReply_175 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   CARD32 parent ;
   CARD16 nChildren ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 480 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryTreeReply_175 xQueryTreeReply;
#line 493 "/usr/include/X11/Xproto.h"
struct __anonstruct_xInternAtomReply_176 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 atom ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 493 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xInternAtomReply_176 xInternAtomReply;
#line 506 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetAtomNameReply_177 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nameLength ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 506 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetAtomNameReply_177 xGetAtomNameReply;
#line 520 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPropertyReply_178 {
   BYTE type ;
   CARD8 format ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 propertyType ;
   CARD32 bytesAfter ;
   CARD32 nItems ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 520 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPropertyReply_178 xGetPropertyReply;
#line 533 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListPropertiesReply_179 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nProperties ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 533 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListPropertiesReply_179 xListPropertiesReply;
#line 547 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetSelectionOwnerReply_180 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 owner ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 547 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetSelectionOwnerReply_180 xGetSelectionOwnerReply;
#line 560 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGrabPointerReply_181 {
   BYTE type ;
   BYTE status ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 560 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGrabPointerReply_181 xGrabPointerReply;
#line 573 "/usr/include/X11/Xproto.h"
typedef xGrabPointerReply xGrabKeyboardReply;
#line 575 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryPointerReply_182 {
   BYTE type ;
   BOOL sameScreen ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 winX ;
   INT16 winY ;
   CARD16 mask ;
   CARD16 pad1 ;
   CARD32 pad ;
};
#line 575 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryPointerReply_182 xQueryPointerReply;
#line 587 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetMotionEventsReply_183 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 nEvents ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 587 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetMotionEventsReply_183 xGetMotionEventsReply;
#line 600 "/usr/include/X11/Xproto.h"
struct __anonstruct_xTranslateCoordsReply_184 {
   BYTE type ;
   BOOL sameScreen ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 child ;
   INT16 dstX ;
   INT16 dstY ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 600 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xTranslateCoordsReply_184 xTranslateCoordsReply;
#line 613 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetInputFocusReply_185 {
   BYTE type ;
   CARD8 revertTo ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 focus ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 613 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetInputFocusReply_185 xGetInputFocusReply;
#line 654 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryTextExtentsReply_187 {
   BYTE type ;
   CARD8 drawDirection ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   INT16 fontAscent ;
   INT16 fontDescent ;
   INT16 overallAscent ;
   INT16 overallDescent ;
   INT32 overallWidth ;
   INT32 overallLeft ;
   INT32 overallRight ;
   CARD32 pad ;
};
#line 654 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryTextExtentsReply_187 xQueryTextExtentsReply;
#line 665 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListFontsReply_188 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nFonts ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 665 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListFontsReply_188 xListFontsReply;
#line 699 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetFontPathReply_190 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPaths ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 699 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetFontPathReply_190 xGetFontPathReply;
#line 713 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetImageReply_191 {
   BYTE type ;
   CARD8 depth ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 visual ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 713 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetImageReply_191 xGetImageReply;
#line 726 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListInstalledColormapsReply_192 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nColormaps ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 726 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListInstalledColormapsReply_192 xListInstalledColormapsReply;
#line 740 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorReply_193 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 red ;
   CARD16 green ;
   CARD16 blue ;
   CARD16 pad2 ;
   CARD32 pixel ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 740 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorReply_193 xAllocColorReply;
#line 753 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocNamedColorReply_194 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pixel ;
   CARD16 exactRed ;
   CARD16 exactGreen ;
   CARD16 exactBlue ;
   CARD16 screenRed ;
   CARD16 screenGreen ;
   CARD16 screenBlue ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 753 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocNamedColorReply_194 xAllocNamedColorReply;
#line 765 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorCellsReply_195 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPixels ;
   CARD16 nMasks ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 765 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorCellsReply_195 xAllocColorCellsReply;
#line 778 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorPlanesReply_196 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPixels ;
   CARD16 pad2 ;
   CARD32 redMask ;
   CARD32 greenMask ;
   CARD32 blueMask ;
   CARD32 pad3 ;
   CARD32 pad4 ;
};
#line 778 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorPlanesReply_196 xAllocColorPlanesReply;
#line 790 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryColorsReply_197 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nColors ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 790 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryColorsReply_197 xQueryColorsReply;
#line 804 "/usr/include/X11/Xproto.h"
struct __anonstruct_xLookupColorReply_198 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 exactRed ;
   CARD16 exactGreen ;
   CARD16 exactBlue ;
   CARD16 screenRed ;
   CARD16 screenGreen ;
   CARD16 screenBlue ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 804 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xLookupColorReply_198 xLookupColorReply;
#line 816 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryBestSizeReply_199 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 width ;
   CARD16 height ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 816 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryBestSizeReply_199 xQueryBestSizeReply;
#line 829 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryExtensionReply_200 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   BOOL present ;
   CARD8 major_opcode ;
   CARD8 first_event ;
   CARD8 first_error ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 829 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryExtensionReply_200 xQueryExtensionReply;
#line 845 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListExtensionsReply_201 {
   BYTE type ;
   CARD8 nExtensions ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 845 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListExtensionsReply_201 xListExtensionsReply;
#line 859 "/usr/include/X11/Xproto.h"
struct __anonstruct_xSetMappingReply_202 {
   BYTE type ;
   CARD8 success ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 859 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xSetMappingReply_202 xSetMappingReply;
#line 871 "/usr/include/X11/Xproto.h"
typedef xSetMappingReply xSetPointerMappingReply;
#line 872 "/usr/include/X11/Xproto.h"
typedef xSetMappingReply xSetModifierMappingReply;
#line 874 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPointerMappingReply_203 {
   BYTE type ;
   CARD8 nElts ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 874 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPointerMappingReply_203 xGetPointerMappingReply;
#line 887 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetKeyboardMappingReply_204 {
   BYTE type ;
   CARD8 keySymsPerKeyCode ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 887 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetKeyboardMappingReply_204 xGetKeyboardMappingReply;
#line 900 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetModifierMappingReply_205 {
   BYTE type ;
   CARD8 numKeyPerModifier ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 900 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetModifierMappingReply_205 xGetModifierMappingReply;
#line 925 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPointerControlReply_207 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 accelNumerator ;
   CARD16 accelDenominator ;
   CARD16 threshold ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 925 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPointerControlReply_207 xGetPointerControlReply;
#line 939 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetScreenSaverReply_208 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 timeout ;
   CARD16 interval ;
   BOOL preferBlanking ;
   BOOL allowExposures ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 939 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetScreenSaverReply_208 xGetScreenSaverReply;
#line 954 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListHostsReply_209 {
   BYTE type ;
   BOOL enabled ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nHosts ;
   CARD16 pad1 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 954 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListHostsReply_209 xListHostsReply;
#line 976 "/usr/include/X11/Xproto.h"
struct __anonstruct_xError_210 {
   BYTE type ;
   BYTE errorCode ;
   CARD16 sequenceNumber ;
   CARD32 resourceID ;
   CARD16 minorCode ;
   CARD8 majorCode ;
   BYTE pad1 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 976 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xError_210 xError;
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_u_212 {
   BYTE type ;
   BYTE detail ;
   CARD16 sequenceNumber ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_keyButtonPointer_213 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 root ;
   CARD32 event ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 eventX ;
   INT16 eventY ;
   KeyButMask state ;
   BOOL sameScreen ;
   BYTE pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_enterLeave_214 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 root ;
   CARD32 event ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 eventX ;
   INT16 eventY ;
   KeyButMask state ;
   BYTE mode ;
   BYTE flags ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_focus_215 {
   CARD32 pad00 ;
   CARD32 window ;
   BYTE mode ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_expose_216 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD16 x ;
   CARD16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 count ;
   CARD16 pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_graphicsExposure_217 {
   CARD32 pad00 ;
   CARD32 drawable ;
   CARD16 x ;
   CARD16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 minorEvent ;
   CARD16 count ;
   BYTE majorEvent ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_noExposure_218 {
   CARD32 pad00 ;
   CARD32 drawable ;
   CARD16 minorEvent ;
   BYTE majorEvent ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_visibility_219 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD8 state ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_createNotify_220 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   BOOL override ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_destroyNotify_221 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_unmapNotify_222 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   BOOL fromConfigure ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mapNotify_223 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   BOOL override ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mapRequest_224 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_reparent_225 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 parent ;
   INT16 x ;
   INT16 y ;
   BOOL override ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_configureNotify_226 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 aboveSibling ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   BOOL override ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_configureRequest_227 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
   CARD32 sibling ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   CARD16 valueMask ;
   CARD32 pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_gravity_228 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   INT16 x ;
   INT16 y ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_resizeRequest_229 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD16 width ;
   CARD16 height ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_circulate_230 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 parent ;
   BYTE place ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_property_231 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD32 atom ;
   CARD32 time ;
   BYTE state ;
   BYTE pad1 ;
   CARD16 pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionClear_232 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 window ;
   CARD32 atom ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionRequest_233 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 owner ;
   CARD32 requestor ;
   CARD32 selection ;
   CARD32 target ;
   CARD32 property ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionNotify_234 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 requestor ;
   CARD32 selection ;
   CARD32 target ;
   CARD32 property ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_colormap_235 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD32 colormap ;
   BOOL new ;
   BYTE state ;
   BYTE pad1 ;
   BYTE pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mappingNotify_236 {
   CARD32 pad00 ;
   CARD8 request ;
   CARD8 firstKeyCode ;
   CARD8 count ;
   BYTE pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_l_239 {
   CARD32 type ;
   INT32 longs0 ;
   INT32 longs1 ;
   INT32 longs2 ;
   INT32 longs3 ;
   INT32 longs4 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_s_240 {
   CARD32 type ;
   INT16 shorts0 ;
   INT16 shorts1 ;
   INT16 shorts2 ;
   INT16 shorts3 ;
   INT16 shorts4 ;
   INT16 shorts5 ;
   INT16 shorts6 ;
   INT16 shorts7 ;
   INT16 shorts8 ;
   INT16 shorts9 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_b_241 {
   CARD32 type ;
   INT8 bytes[20] ;
};
#line 996 "/usr/include/X11/Xproto.h"
union __anonunion_u_238 {
   struct __anonstruct_l_239 l ;
   struct __anonstruct_s_240 s ;
   struct __anonstruct_b_241 b ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_clientMessage_237 {
   CARD32 pad00 ;
   CARD32 window ;
   union __anonunion_u_238 u ;
};
#line 996 "/usr/include/X11/Xproto.h"
union __anonunion_u_211 {
   struct __anonstruct_u_212 u ;
   struct __anonstruct_keyButtonPointer_213 keyButtonPointer ;
   struct __anonstruct_enterLeave_214 enterLeave ;
   struct __anonstruct_focus_215 focus ;
   struct __anonstruct_expose_216 expose ;
   struct __anonstruct_graphicsExposure_217 graphicsExposure ;
   struct __anonstruct_noExposure_218 noExposure ;
   struct __anonstruct_visibility_219 visibility ;
   struct __anonstruct_createNotify_220 createNotify ;
   struct __anonstruct_destroyNotify_221 destroyNotify ;
   struct __anonstruct_unmapNotify_222 unmapNotify ;
   struct __anonstruct_mapNotify_223 mapNotify ;
   struct __anonstruct_mapRequest_224 mapRequest ;
   struct __anonstruct_reparent_225 reparent ;
   struct __anonstruct_configureNotify_226 configureNotify ;
   struct __anonstruct_configureRequest_227 configureRequest ;
   struct __anonstruct_gravity_228 gravity ;
   struct __anonstruct_resizeRequest_229 resizeRequest ;
   struct __anonstruct_circulate_230 circulate ;
   struct __anonstruct_property_231 property ;
   struct __anonstruct_selectionClear_232 selectionClear ;
   struct __anonstruct_selectionRequest_233 selectionRequest ;
   struct __anonstruct_selectionNotify_234 selectionNotify ;
   struct __anonstruct_colormap_235 colormap ;
   struct __anonstruct_mappingNotify_236 mappingNotify ;
   struct __anonstruct_clientMessage_237 clientMessage ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct _xEvent {
   union __anonunion_u_211 u ;
};
#line 996 "/usr/include/X11/Xproto.h"
typedef struct _xEvent xEvent;
#line 1264 "/usr/include/X11/Xproto.h"
union __anonunion_xReply_244 {
   xGenericReply generic ;
   xGetGeometryReply geom ;
   xQueryTreeReply tree ;
   xInternAtomReply atom ;
   xGetAtomNameReply atomName ;
   xGetPropertyReply property ;
   xListPropertiesReply listProperties ;
   xGetSelectionOwnerReply selection ;
   xGrabPointerReply grabPointer ;
   xGrabKeyboardReply grabKeyboard ;
   xQueryPointerReply pointer ;
   xGetMotionEventsReply motionEvents ;
   xTranslateCoordsReply coords ;
   xGetInputFocusReply inputFocus ;
   xQueryTextExtentsReply textExtents ;
   xListFontsReply fonts ;
   xGetFontPathReply fontPath ;
   xGetImageReply image ;
   xListInstalledColormapsReply colormaps ;
   xAllocColorReply allocColor ;
   xAllocNamedColorReply allocNamedColor ;
   xAllocColorCellsReply colorCells ;
   xAllocColorPlanesReply colorPlanes ;
   xQueryColorsReply colors ;
   xLookupColorReply lookupColor ;
   xQueryBestSizeReply bestSize ;
   xQueryExtensionReply extension ;
   xListExtensionsReply extensions ;
   xSetModifierMappingReply setModifierMapping ;
   xGetModifierMappingReply getModifierMapping ;
   xSetPointerMappingReply setPointerMapping ;
   xGetKeyboardMappingReply getKeyboardMapping ;
   xGetPointerMappingReply getPointerMapping ;
   xGetPointerControlReply pointerControl ;
   xGetScreenSaverReply screenSaver ;
   xListHostsReply hosts ;
   xError error ;
   xEvent event ;
};
#line 1264 "/usr/include/X11/Xproto.h"
typedef union __anonunion_xReply_244 xReply;
#line 65 "/usr/include/X11/Xlibint.h"
struct _XGC {
   XExtData *ext_data ;
   GContext gid ;
   int rects ;
   int dashes ;
   unsigned long dirty ;
   XGCValues values ;
};
#line 75
struct _XFreeFuncs;
#line 75
struct _XSQEvent;
#line 75
struct _XExten;
#line 75
struct _XLockInfo;
#line 75
struct _XInternalAsync;
#line 75
struct _XLockPtrs;
#line 75
struct _XKeytrans;
#line 75
struct _XDisplayAtoms;
#line 75
struct _XContextDB;
#line 75 "/usr/include/X11/Xlibint.h"
struct __anonstruct_cms_317 {
   XPointer defaultCCCs ;
   XPointer clientCmaps ;
   XPointer perVisualIntensityMaps ;
};
#line 75
struct _XIMFilter;
#line 75
struct _XConnectionInfo;
#line 75
struct _XConnWatchInfo;
#line 75
struct _XkbInfoRec;
#line 75
struct _XtransConnInfo;
#line 75
struct _X11XCBPrivate;
#line 75 "/usr/include/X11/Xlibint.h"
struct _XDisplay {
   XExtData *ext_data ;
   struct _XFreeFuncs *free_funcs ;
   int fd ;
   int conn_checker ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID resource_base ;
   XID resource_mask ;
   XID resource_id ;
   int resource_shift ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int vnumber ;
   int release ;
   struct _XSQEvent *head ;
   struct _XSQEvent *tail ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   char *last_req ;
   char *buffer ;
   char *bufptr ;
   char *bufmax ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*synchandler)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long volatile   flags ;
   int min_keycode ;
   int max_keycode ;
   KeySym *keysyms ;
   XModifierKeymap *modifiermap ;
   int keysyms_per_keycode ;
   char *xdefaults ;
   char *scratch_buffer ;
   unsigned long scratch_length ;
   int ext_number ;
   struct _XExten *ext_procs ;
   int (*event_vec[128])(Display * , XEvent * , xEvent * ) ;
   int (*wire_vec[128])(Display * , XEvent * , xEvent * ) ;
   KeySym lock_meaning ;
   struct _XLockInfo *lock ;
   struct _XInternalAsync *async_handlers ;
   unsigned long bigreq_size ;
   struct _XLockPtrs *lock_fns ;
   void (*idlist_alloc)(Display * , XID * , int  ) ;
   struct _XKeytrans *key_bindings ;
   Font cursor_font ;
   struct _XDisplayAtoms *atoms ;
   unsigned int mode_switch ;
   unsigned int num_lock ;
   struct _XContextDB *context_db ;
   int (**error_vec)(Display * , XErrorEvent * , xError * ) ;
   struct __anonstruct_cms_317 cms ;
   struct _XIMFilter *im_filters ;
   struct _XSQEvent *qfree ;
   unsigned long next_event_serial_num ;
   struct _XExten *flushes ;
   struct _XConnectionInfo *im_fd_info ;
   int im_fd_length ;
   struct _XConnWatchInfo *conn_watchers ;
   int watcher_count ;
   XPointer filedes ;
   int (*savedsynchandler)(Display * ) ;
   XID resource_max ;
   int xcmisc_opcode ;
   struct _XkbInfoRec *xkb_info ;
   struct _XtransConnInfo *trans_conn ;
   struct _X11XCBPrivate *xcb ;
   unsigned int next_cookie ;
   int (*generic_event_vec[128])(Display * , XGenericEventCookie * , xEvent * ) ;
   int (*generic_event_copy_vec[128])(Display * , XGenericEventCookie * , XGenericEventCookie * ) ;
   void *cookiejar ;
};
#line 216 "/usr/include/X11/Xlibint.h"
struct _XSQEvent {
   struct _XSQEvent *next ;
   XEvent event ;
   unsigned long qserial_num ;
};
#line 258 "/usr/include/X11/Xlibint.h"
struct _XLockPtrs {
   void (*lock_display)(Display *dpy ) ;
   void (*unlock_display)(Display *dpy ) ;
};
#line 655 "/usr/include/X11/Xlibint.h"
struct _XInternalAsync {
   struct _XInternalAsync *next ;
   int (*handler)(Display * , xReply * , char * , int  , XPointer  ) ;
   XPointer data ;
};
#line 705 "/usr/include/X11/Xlibint.h"
struct _XFreeFuncs {
   void (*atoms)(Display * ) ;
   int (*modifiermap)(XModifierKeymap * ) ;
   void (*key_bindings)(Display * ) ;
   void (*context_db)(Display * ) ;
   void (*defaultCCCs)(Display * ) ;
   void (*clientCmaps)(Display * ) ;
   void (*intensityMaps)(Display * ) ;
   void (*im_filters)(Display * ) ;
   void (*xkb)(Display * ) ;
};
#line 790 "/usr/include/X11/Xlibint.h"
struct _XExten {
   struct _XExten *next ;
   XExtCodes codes ;
   int (*create_GC)(Display * , GC  , XExtCodes * ) ;
   int (*copy_GC)(Display * , GC  , XExtCodes * ) ;
   int (*flush_GC)(Display * , GC  , XExtCodes * ) ;
   int (*free_GC)(Display * , GC  , XExtCodes * ) ;
   int (*create_Font)(Display * , XFontStruct * , XExtCodes * ) ;
   int (*free_Font)(Display * , XFontStruct * , XExtCodes * ) ;
   int (*close_display)(Display * , XExtCodes * ) ;
   int (*error)(Display * , xError * , XExtCodes * , int * ) ;
   char *(*error_string)(Display * , int  , XExtCodes * , char * , int  ) ;
   char *name ;
   void (*error_values)(Display * , XErrorEvent * , void * ) ;
   void (*before_flush)(Display * , XExtCodes * , char const   * , long  ) ;
   struct _XExten *next_flush ;
};
#line 1202 "/usr/include/X11/Xlibint.h"
struct _XConnectionInfo {
   int fd ;
   void (*read_callback)(Display * , int  , XPointer  ) ;
   XPointer call_data ;
   XPointer *watch_data ;
   struct _XConnectionInfo *next ;
};
#line 1210 "/usr/include/X11/Xlibint.h"
struct _XConnWatchInfo {
   void (*fn)(Display * , XPointer  , int  , int  , XPointer * ) ;
   XPointer client_data ;
   struct _XConnWatchInfo *next ;
};
#line 96 "/usr/include/X11/ICE/ICElib.h"
struct _IceConn;
#line 96 "/usr/include/X11/ICE/ICElib.h"
typedef struct _IceConn *IceConn;
#line 49 "/usr/include/X11/SM/SMlib.h"
struct _SmcConn;
#line 49 "/usr/include/X11/SM/SMlib.h"
typedef struct _SmcConn *SmcConn;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_353 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_353 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 148 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.h"
enum enc_label {
    ENC_NOENC = 0,
    ENC_KOI8R = 1,
    ENC_KOI8U = 2,
    ENC_ISO8859_1 = 3,
    ENC_ISO8859_2 = 4,
    ENC_ISO8859_3 = 5,
    ENC_ISO8859_4 = 6,
    ENC_ISO8859_5 = 7,
    ENC_ISO8859_6 = 8,
    ENC_ISO8859_7 = 9,
    ENC_ISO8859_8 = 10,
    ENC_ISO8859_9 = 11,
    ENC_ISO8859_10 = 12,
    ENC_ISO8859_11 = 13,
    ENC_ISO8859_12 = 14,
    ENC_ISO8859_13 = 15,
    ENC_ISO8859_14 = 16,
    ENC_ISO8859_15 = 17
} ;
#line 49 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct rxvt_vars;
#line 50
struct rxvt_hidden;
#line 52 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_row_col_t_357 {
   int32_t row ;
   int32_t col ;
};
#line 52 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_row_col_t_357 row_col_t;
#line 57 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef unsigned char text_t;
#line 76 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_TermWin_t_358 {
   uint16_t fwidth ;
   uint16_t fheight ;
   uint16_t propfont ;
   uint16_t ncol ;
   uint16_t nrow ;
   uint16_t mapped ;
   uint16_t int_bwidth ;
   uint16_t ext_bwidth ;
   uint16_t maxTabWidth ;
   uint16_t minVisibleTabs ;
   uint16_t lineSpace ;
   char focus : 1 ;
   char enter ;
   Window parent ;
   GC gc ;
   XFontStruct *font ;
   XFontStruct *bfont ;
   int opacity ;
   int opacity_degree ;
   Window parenttree[6] ;
   int shade ;
   int fade ;
   SmcConn sm_conn ;
   IceConn ice_conn ;
   int ice_fd ;
   char *sm_client_id ;
   unsigned long vBellDuration ;
};
#line 76 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_TermWin_t_358 TermWin_t;
#line 208 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_screen_t_359 {
   text_t **text ;
   int16_t *tlen ;
   uint32_t **rend ;
   row_col_t cur ;
   uint16_t tscroll ;
   uint16_t bscroll ;
   uint16_t charset ;
   unsigned int flags ;
   row_col_t s_cur ;
   uint16_t s_charset ;
   char s_charset_char ;
   uint32_t s_rstyle ;
};
#line 208 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_screen_t_359 screen_t;
#line 224
enum __anonenum_op_361 {
    SELECTION_CLEAR = 0,
    SELECTION_INIT = 1,
    SELECTION_BEGIN = 2,
    SELECTION_CONT = 3,
    SELECTION_DONE = 4
} ;
#line 224 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_selection_t_360 {
   unsigned char *text ;
   uint32_t len ;
   enum __anonenum_op_361 op ;
   short vt ;
   short screen ;
   short clicks ;
   row_col_t beg ;
   row_col_t mark ;
   row_col_t end ;
};
#line 224 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_selection_t_360 selection_t;
#line 242
enum __anonenum_sstyle_t_362 {
    OLD_SELECT = 0,
    OLD_WORD_SELECT = 1,
    NEW_SELECT = 2
} ;
#line 242 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef enum __anonenum_sstyle_t_362 sstyle_t;
#line 436 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_scrollBar_t_363 {
   char state ;
   char init ;
   short beg ;
   short end ;
   short top ;
   short bot ;
   short style ;
   short width ;
   Window win ;
   int (*update)(struct rxvt_vars * , int  , int  , int  , int  ) ;
   GC gc ;
   unsigned long rxvt_fg ;
   unsigned long rxvt_bg ;
   unsigned long rxvt_topshadow ;
   unsigned long rxvt_botshadow ;
   unsigned long xterm_fg ;
   unsigned long xterm_bg ;
   unsigned long xterm_shadow ;
   unsigned long plain_fg ;
   unsigned long plain_bg ;
   unsigned long next_fg ;
   unsigned long next_bg ;
   unsigned long next_white ;
   unsigned long next_dark ;
   GC next_stippleGC ;
   Pixmap next_dimple ;
   Pixmap next_upArrow ;
   Pixmap next_upArrowHi ;
   Pixmap next_downArrow ;
   Pixmap next_downArrowHi ;
   unsigned long sgi_fg ;
   unsigned long sgi_bg ;
   unsigned long sgi_black ;
   unsigned long sgi_white ;
   unsigned long sgi_lmedium ;
   unsigned long sgi_dark ;
   unsigned long sgi_vdark ;
   GC sgi_stippleGC ;
   Pixmap sgi_dimple ;
   Pixmap sgi_upArrow ;
   Pixmap sgi_upArrowHi ;
   Pixmap sgi_upArrowLow ;
   Pixmap sgi_downArrow ;
   Pixmap sgi_downArrowHi ;
   Pixmap sgi_downArrowLow ;
};
#line 436 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_scrollBar_t_363 scrollBar_t;
#line 500 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_tabBar_t_364 {
   char state ;
   short ltab ;
   short atab ;
   short ptab ;
   short fvtab ;
   short lvtab ;
   Window win ;
   GC gc ;
   unsigned long fg ;
   unsigned long bg ;
   unsigned long ifg ;
   unsigned long ibg ;
   char rsfg ;
   char rsbg ;
   char rsifg ;
   char rsibg ;
   unsigned long frame ;
   unsigned long delimit ;
};
#line 500 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_tabBar_t_364 tabBar_t;
#line 562
enum __anonenum_termenv_t_365 {
    TERMENV_XTERM = 0,
    TERMENV_RXVT = 1,
    TERMENV_VT102 = 2,
    TERMENV_VT100 = 3,
    TERMENV_ANSI = 4,
    TERMENV_DUMB = 5
} ;
#line 562 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef enum __anonenum_termenv_t_365 termenv_t;
#line 572 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_term_t_366 {
   short vts_idx ;
   unsigned char profileNum ;
   int globalTabNum ;
   uint16_t saveLines ;
   uint16_t num_scr ;
   uint16_t nscrolled ;
   uint16_t view_start ;
   uint16_t mapped ;
   unsigned char init_screen : 1 ;
   Window vt ;
   unsigned long p_fg ;
   unsigned long p_bg ;
   unsigned long p_fgfade ;
   unsigned long p_bgfade ;
   text_t **drawn_text ;
   uint32_t **drawn_rend ;
   text_t **buf_text ;
   uint32_t **buf_rend ;
   screen_t screen ;
   screen_t swap ;
   uint32_t rstyle ;
   uint16_t prev_ncol ;
   uint16_t prev_nrow ;
   short tab_width ;
   char *tab_title ;
   char *title_format ;
   char *winTitleFormat ;
   int cmd_fd ;
   int tty_fd ;
   unsigned char current_screen : 1 ;
   unsigned char hidden_pointer : 1 ;
   pid_t cmd_pid ;
   char *ttydev ;
   unsigned char next_tty_action ;
   uint32_t PrivateModes ;
   uint32_t SavedModes ;
   struct utmp ut ;
   char ut_id[5] ;
   int utmp_pos ;
   unsigned char next_utmp_action ;
   ttymode_t tio ;
   unsigned int ttymode ;
   char rvideo ;
   char charsets[4] ;
   unsigned char hold : 2 ;
   unsigned char holdOption : 3 ;
   unsigned char gotEIO : 1 ;
   unsigned char dead : 1 ;
   unsigned char highlight : 1 ;
   int status ;
   termenv_t termenv ;
   int scrolled_lines ;
   short monitor_tab ;
   int monitor_nbytes_read ;
   struct timeval monitor_start ;
   unsigned char want_refresh : 1 ;
   int nbytes_last_read ;
   unsigned char *v_buffer ;
   unsigned char *v_bufstr ;
   unsigned char *v_bufptr ;
   unsigned char *v_bufend ;
   unsigned char *cmdbuf_escstart ;
   unsigned char *cmdbuf_escfail ;
   unsigned char *cmdbuf_ptr ;
   unsigned char *cmdbuf_endp ;
   unsigned char cmdbuf_base[8192] ;
};
#line 572 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_term_t_366 term_t;
#line 786 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_action_t_367 {
   unsigned short type ;
   unsigned short len ;
   unsigned char *str ;
};
#line 786 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_action_t_367 action_t;
#line 793
enum __anonenum_macroFnNames_368 {
    MacroFnDummy = 0,
    MacroFnEsc = 1,
    MacroFnStr = 2,
    MacroFnNewTab = 3,
    MacroFnExec = 4,
    MacroFnClose = 5,
    MacroFnGoto = 6,
    MacroFnMove = 7,
    MacroFnScroll = 8,
    MacroFnCopy = 9,
    MacroFnPaste = 10,
    MacroFnPasteFile = 11,
    MacroFnMonitorTab = 12,
    MacroFnToggleSubwin = 13,
    MacroFnFont = 14,
    MacroFnToggleVeryBold = 15,
    MacroFnToggleBoldColors = 16,
    MacroFnToggleVeryBright = 17,
    MacroFnToggleTransp = 18,
    MacroFnToggleBcst = 19,
    MacroFnToggleHold = 20,
    MacroFnToggleFullscreen = 21,
    MacroFnRaise = 22,
    MacroFnSetTitle = 23,
    MacroFnUseFifo = 24,
    MacroFnPrintScreen = 25,
    MacroFnSaveConfig = 26,
    MacroFnToggleMacros = 27,
    NMACRO_FUNCS = 28
} ;
#line 825 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef unsigned char macro_priority_t;
#line 826 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct __anonstruct_macros_t_369 {
   KeySym keysym ;
   unsigned char modFlags ;
   macro_priority_t priority ;
   action_t action ;
};
#line 826 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct __anonstruct_macros_t_369 macros_t;
#line 839 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct _profile_t {
   unsigned long fg ;
   unsigned long bg ;
   unsigned long fg_fade ;
   unsigned long bg_fade ;
   int saveLines ;
   unsigned char holdOption : 3 ;
};
#line 839 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct _profile_t profile_t;
#line 866 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
struct rxvt_vars {
   struct rxvt_hidden *h ;
   TermWin_t TermWin ;
   scrollBar_t scrollBar ;
   tabBar_t tabBar ;
   Display *Xdisplay ;
   uint32_t Options[4] ;
   XSizeHints szHint ;
   macros_t *macros ;
   unsigned short nmacros ;
   unsigned short maxMacros ;
   Colormap Xcmap ;
   unsigned long *pixColorsFocus ;
   unsigned long *pixColorsUnfocus ;
   unsigned long *pixColors ;
   int ntabs ;
   int fgbg_tabnum ;
   profile_t profile[5] ;
   Cursor term_pointer ;
   int Xdepth ;
   int sb_shadow ;
   int Xfd ;
   term_t vterm[15] ;
   term_t *vts[15] ;
   short tabClicked ;
   unsigned char cleanDeadChilds : 1 ;
   unsigned char gotEIO : 1 ;
   short ndead_childs ;
   short nAsyncChilds ;
   short asyncChilds[16] ;
   int num_fds ;
   int fifo_fd ;
   char fifo_buf[512] ;
   char *fbuf_ptr ;
   char *fifo_name ;
   selection_t selection ;
   sstyle_t selection_style ;
   int numlock_state ;
   char *tabstop ;
   enum enc_label encoding_method ;
   char **global_argv ;
   int global_argc ;
};
#line 866 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef struct rxvt_vars rxvt_t;
#line 596 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvt.h"
struct mouse_event {
   int clicks ;
   Time time ;
   unsigned int state ;
   unsigned int button ;
};
#line 824
enum page_dirn {
    UP = 0,
    DN = 1,
    NO_DIR = 2
} ;
#line 1498 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvt.h"
struct rxvt_hidden {
   unsigned char want_clip_refresh : 1 ;
   unsigned char want_resize : 2 ;
   unsigned char am_transparent : 1 ;
   unsigned char am_pixmap_trans : 1 ;
   unsigned char hidden_cursor : 1 ;
   unsigned char hate_those_clicks : 1 ;
   unsigned char num_scr_allow : 1 ;
   unsigned char bypass_keystate : 1 ;
   unsigned char want_full_refresh : 1 ;
   Region refreshRegion ;
   int skip_pages ;
   int refresh_limit ;
   unsigned char refresh_type : 5 ;
   unsigned char meta_char ;
   unsigned char scrollbar_align ;
   unsigned char selection_wait ;
   unsigned char selection_type ;
   uint16_t prev_ncol ;
   uint16_t prev_nrow ;
   uint32_t pixcolor_set[9] ;
   int scroll_selection_delay ;
   int scroll_selection_lines ;
   enum page_dirn scroll_selection_dir ;
   int selection_save_x ;
   int selection_save_y ;
   int selection_save_state ;
   int pending_scroll_selection ;
   int csrO ;
   int scroll_arrow_delay ;
   int max_skipped_pages ;
   int fnum ;
   int last_bot ;
   int last_top ;
   int last_state ;
   int scroller_len ;
   int currmaxcol ;
   int window_vt_x ;
   int window_vt_y ;
   int pointerBlankDelay ;
   unsigned char allowedxerror : 1 ;
   int xerror_return ;
   unsigned int ModMetaMask ;
   unsigned int ModNumLockMask ;
   unsigned long colorfgbg ;
   gid_t ttygid ;
   Atom xa[20] ;
   Time selection_time ;
   Time selection_request_time ;
   Cursor bar_pointer ;
   Cursor blank_pointer ;
   char const   *key_backspace ;
   char const   *key_delete ;
   struct mouse_event MEvent ;
   row_col_t oldcursor ;
   void (*multichar_decode)(unsigned char *str , int len ) ;
   long blinkInterval ;
   struct timeval lastcursorchange ;
   struct timeval lastmotion ;
   unsigned long bgRefreshInterval ;
   struct timeval lastCNotify ;
   struct timeval timeout[1] ;
   char *env_windowid ;
   char *env_display ;
   char *env_term ;
   char *env_tabtitle ;
   char *env_colorfgbg ;
   char *buffer ;
   char *locale ;
   char *newfont[6] ;
   char const   *rs[389] ;
   Pixmap rootPixmap ;
   unsigned int rpWidth ;
   unsigned int rpHeight ;
   XRectangle prevPos ;
   int bgGrabbed ;
};
#line 135 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
struct NFONT_LIST {
   enum enc_label encoding ;
   char *font[6] ;
};
#line 209 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
struct FALLBACK_FONT_LIST {
   enum enc_label encoding ;
   char *fontname ;
};
#line 214 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
struct ENCODING_NAME {
   enum enc_label encoding ;
   char *encname ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 502 "/usr/include/X11/Xlib.h"
struct _XPrivate;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_90 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_90 *_XPrivDisplay;
#line 987 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
enum __anonenum_resize_reason_t_370 {
    HIDE_MENUBAR = 0,
    SHOW_MENUBAR = 1,
    HIDE_TABBAR = 2,
    SHOW_TABBAR = 3,
    HIDE_SCROLLBAR = 4,
    SHOW_SCROLLBAR = 5,
    RESIZE_FONT = 6,
    X_CONFIGURE = 7
} ;
#line 987 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef enum __anonenum_resize_reason_t_370 resize_reason_t;
#line 1251 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
union __anonunion_376 {
   int __in ;
   int __i ;
};
#line 1251 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
union __anonunion_377 {
   int __in ;
   int __i ;
};
#line 267 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
union __anonunion_376___0 {
   int __in ;
   int __i ;
};
#line 278 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
union __anonunion_377___0 {
   int __in ;
   int __i ;
};
#line 278 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
union __anonunion_378 {
   int __in ;
   int __i ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 1076 "/usr/include/X11/Xlib.h"
struct __anonstruct_XChar2b_129 {
   unsigned char byte1 ;
   unsigned char byte2 ;
};
#line 1076 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XChar2b_129 XChar2b;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_152 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_152 XTextProperty;
#line 174
enum __anonenum_XICCEncodingStyle_153 {
    XStringStyle = 0,
    XCompoundTextStyle = 1,
    XTextStyle = 2,
    XStdICCTextStyle = 3,
    XUTF8StringStyle = 4
} ;
#line 174 "/usr/include/X11/Xutil.h"
typedef enum __anonenum_XICCEncodingStyle_153 XICCEncodingStyle;
#line 41 "/usr/include/wordexp.h"
struct __anonstruct_wordexp_t_377 {
   size_t we_wordc ;
   char **we_wordv ;
   size_t we_offs ;
};
#line 41 "/usr/include/wordexp.h"
typedef struct __anonstruct_wordexp_t_377 wordexp_t;
#line 5584 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
enum __anonenum_closeto_380 {
    LEFT = 0,
    RIGHT = 1
} ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_81 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_81 XColor;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_83 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_83 XPoint;
#line 447 "/usr/include/X11/Xlib.h"
struct __anonstruct_XArc_85 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
   short angle1 ;
   short angle2 ;
};
#line 447 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XArc_85 XArc;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct lastlog {
   int32_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 90 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
struct __anonstruct_optList_376 {
   uint32_t const   flag ;
   int const   doff ;
   char const   *kw ;
   char const   *opt ;
   char const   *arg ;
   char const   *desc ;
   char const   multiple : 1 ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_44 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_44 fd_set;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_77 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_77 XWindowAttributes;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 47 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
struct _DeadKeyChar {
   KeySym ks ;
   KeySym dk ;
   KeySym ach ;
};
#line 47 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
typedef struct _DeadKeyChar DeadKeyChar;
#line 1523 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
union __anonunion_376___1 {
   int __in ;
   int __i ;
};
#line 1523 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
union __anonunion_377___1 {
   int __in ;
   int __i ;
};
#line 6318 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
struct __anonstruct_argtopriv_380 {
   int const   argval ;
   uint32_t const   bit ;
};
#line 82 "/usr/include/wchar.h"
union __anonunion___value_3 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 82 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_2 {
   int __count ;
   union __anonunion___value_3 __value ;
};
#line 82 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_2 __mbstate_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 41 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
typedef uint32_t unicode_t;
#line 521 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
typedef unsigned int chartype;
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_8 __sigset_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_11 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_12 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_13 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_14 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_15 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_16 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_17 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_10 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_11 _kill ;
   struct __anonstruct__timer_12 _timer ;
   struct __anonstruct__rt_13 _rt ;
   struct __anonstruct__sigchld_14 _sigchld ;
   struct __anonstruct__sigfault_15 _sigfault ;
   struct __anonstruct__sigpoll_16 _sigpoll ;
   struct __anonstruct__sigsys_17 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_9 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_10 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_9 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_29 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_29 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_76 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_76 XSetWindowAttributes;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_151 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_151 XWMHints;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_155 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_155 XClassHint;
#line 238 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvt.h"
struct __anonstruct_MWMHints_322 {
   int flags ;
   int functions ;
   int decorations ;
   int input_mode ;
   int status ;
};
#line 238 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvt.h"
typedef struct __anonstruct_MWMHints_322 MWMHints;
#line 40 "/usr/include/X11/ICE/ICElib.h"
typedef void *IcePointer;
#line 76
enum __anonenum_IceCloseStatus_328 {
    IceClosedNow = 0,
    IceClosedASAP = 1,
    IceConnectionInUse = 2,
    IceStartedShutdownNegotiation = 3
} ;
#line 76 "/usr/include/X11/ICE/ICElib.h"
typedef enum __anonenum_IceCloseStatus_328 IceCloseStatus;
#line 83
enum __anonenum_IceProcessMessagesStatus_329 {
    IceProcessMessagesSuccess = 0,
    IceProcessMessagesIOError = 1,
    IceProcessMessagesConnectionClosed = 2
} ;
#line 83 "/usr/include/X11/ICE/ICElib.h"
typedef enum __anonenum_IceProcessMessagesStatus_329 IceProcessMessagesStatus;
#line 89 "/usr/include/X11/ICE/ICElib.h"
struct __anonstruct_IceReplyWaitInfo_330 {
   unsigned long sequence_of_request ;
   int major_opcode_of_request ;
   int minor_opcode_of_request ;
   IcePointer reply ;
};
#line 89 "/usr/include/X11/ICE/ICElib.h"
typedef struct __anonstruct_IceReplyWaitInfo_330 IceReplyWaitInfo;
#line 197 "/usr/include/X11/ICE/ICElib.h"
typedef void (*IceIOErrorHandler)(IceConn  );
#line 42 "/usr/include/X11/SM/SMlib.h"
typedef IcePointer SmPointer;
#line 57 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_SmPropValue_333 {
   int length ;
   SmPointer value ;
};
#line 57 "/usr/include/X11/SM/SMlib.h"
typedef struct __anonstruct_SmPropValue_333 SmPropValue;
#line 62 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_SmProp_334 {
   char *name ;
   char *type ;
   int num_vals ;
   SmPropValue *vals ;
};
#line 62 "/usr/include/X11/SM/SMlib.h"
typedef struct __anonstruct_SmProp_334 SmProp;
#line 75
enum __anonenum_SmcCloseStatus_335 {
    SmcClosedNow = 0,
    SmcClosedASAP = 1,
    SmcConnectionInUse = 2
} ;
#line 75 "/usr/include/X11/SM/SMlib.h"
typedef enum __anonenum_SmcCloseStatus_335 SmcCloseStatus;
#line 133 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_save_yourself_337 {
   void (*callback)(SmcConn  , SmPointer  , int  , int  , int  , int  ) ;
   SmPointer client_data ;
};
#line 133 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_die_338 {
   void (*callback)(SmcConn  , SmPointer  ) ;
   SmPointer client_data ;
};
#line 133 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_save_complete_339 {
   void (*callback)(SmcConn  , SmPointer  ) ;
   SmPointer client_data ;
};
#line 133 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_shutdown_cancelled_340 {
   void (*callback)(SmcConn  , SmPointer  ) ;
   SmPointer client_data ;
};
#line 133 "/usr/include/X11/SM/SMlib.h"
struct __anonstruct_SmcCallbacks_336 {
   struct __anonstruct_save_yourself_337 save_yourself ;
   struct __anonstruct_die_338 die ;
   struct __anonstruct_save_complete_339 save_complete ;
   struct __anonstruct_shutdown_cancelled_340 shutdown_cancelled ;
};
#line 133 "/usr/include/X11/SM/SMlib.h"
typedef struct __anonstruct_SmcCallbacks_336 SmcCallbacks;
#line 110 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
struct __anonstruct_vals_376 {
   SmPropValue program[1] ;
   SmPropValue user[1] ;
   SmPropValue hint[1] ;
   SmPropValue priority[1] ;
   SmPropValue restart[32] ;
};
#line 44 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.h"
enum __anonenum_dbgmask_t_355 {
    DBG_COMMAND = 1,
    DBG_SCREEN = 2,
    DBG_PTYTTY = 4,
    DBG_INIT = 8,
    DBG_MAIN = 16,
    DBG_LOGGING = 32,
    DBG_MACROS = 64,
    DBG_MENUBAR = 128,
    DBG_TABBAR = 256,
    DBG_SCROLLBAR = 512,
    DBG_IMAGES = 1024,
    DBG_PIXMAP = 2048,
    DBG_TRANSPARENT = 4096,
    DBG_ENCODING = 8192,
    DBG_GKRELOT = 16384,
    DBG_MEMORY = 32768,
    DBG_SESSION = 65536,
    DBG_STRING = 131072,
    DBG_RESOURCE = 262144,
    DBG_XFTACS = 524288,
    DBG_MISC = 1048576
} ;
#line 44 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.h"
typedef enum __anonenum_dbgmask_t_355 dbgmask_t;
#line 67 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 793 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
enum __anonenum_macroFnNames_368 macroFnNames  ;
#line 49 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_decode_dummy(unsigned char *str , int len ) ;
#line 50
void rxvt_set_default_locale(rxvt_t *r ) ;
#line 51
char *rxvt_get_encoding_from_locale(rxvt_t *r ) ;
#line 52
void rxvt_set_default_font_x11(rxvt_t *r ) ;
#line 53
char *rxvt_fallback_mfont_x11(rxvt_t *r ) ;
#line 58
char *rxvt_encoding_name(rxvt_t *r ) ;
#line 129
void *rxvt_malloc(size_t size ) ;
#line 472
int rxvt_msg(uint32_t level , uint32_t mask , char const   *fmt  , ...) ;
#line 140 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
static struct NFONT_LIST nfont_list[18]  = 
#line 140 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
  {      {(enum enc_label )0, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                           (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )1,
      {(char *)"-misc-fixed-medium-r-normal--14-130-75-75-c-70-koi8-r", (char *)"-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-koi8-r",
       (char *)"-misc-fixed-medium-r-normal--13-120-75-75-c-80-koi8-r", (char *)"-misc-fixed-medium-r-normal--15-140-75-75-c-90-koi8-r",
       (char *)"-misc-fixed-medium-r-normal--18-120-100-100-c-90-koi8-r", (char *)"-misc-fixed-medium-r-normal--20-200-75-75-c-100-koi8-r"}}, 
        {(enum enc_label )2,
      {(char *)"-cronyx-fixed-medium-r-normal--14-130-75-75-c-70-koi8-u", (char *)"-cronyx-fixed-medium-r-semicondensed--13-120-75-75-c-60-koi8-u",
       (char *)"-cronyx-fixed-medium-r-normal--13-120-75-75-c-80-koi8-u", (char *)"-cronyx-fixed-medium-r-normal--15-140-75-75-c-90-koi8-u",
       (char *)"-cronyx-fixed-medium-r-normal--18-120-100-100-c-90-koi8-u", (char *)"-cronyx-fixed-medium-r-normal--20-200-75-75-c-100-koi8-u"}}, 
        {(enum enc_label )3,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )4, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                           (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )5,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )6, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                           (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )7,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )8, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                           (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )9,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )10, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                            (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )11,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )12, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                            (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )13,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )14, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                            (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )15,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )16, {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                            (char *)((void *)0), (char *)((void *)0), (char *)((void *)0)}}, 
        {(enum enc_label )17,
      {(char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
       (char *)((void *)0), (char *)((void *)0)}}};
#line 169 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
static char *isofont[6]  = {      (char *)"-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-%d",      (char *)"-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso8859-%d",      (char *)"-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso8859-%d",      (char *)"-misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-%d", 
        (char *)"-misc-fixed-medium-r-normal--13-120-75-75-c-70-iso8859-%d",      (char *)"-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-%d"};
#line 219 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
static struct ENCODING_NAME encoding_name[18]  = 
#line 219
  {      {(enum enc_label )0, (char *)"NOENC"}, 
        {(enum enc_label )1, (char *)"KOI8R"}, 
        {(enum enc_label )2, (char *)"KOI8U"}, 
        {(enum enc_label )3, (char *)"ISO8859-1"}, 
        {(enum enc_label )4, (char *)"ISO8859-2"}, 
        {(enum enc_label )5, (char *)"ISO8859-3"}, 
        {(enum enc_label )6, (char *)"ISO8859-4"}, 
        {(enum enc_label )7, (char *)"ISO8859-5"}, 
        {(enum enc_label )8, (char *)"ISO8859-6"}, 
        {(enum enc_label )9, (char *)"ISO8859-7"}, 
        {(enum enc_label )10, (char *)"ISO8859-8"}, 
        {(enum enc_label )11, (char *)"ISO8859-9"}, 
        {(enum enc_label )12, (char *)"ISO8859-10"}, 
        {(enum enc_label )13, (char *)"ISO8859-11"}, 
        {(enum enc_label )14, (char *)"ISO8859-12"}, 
        {(enum enc_label )15, (char *)"ISO8859-13"}, 
        {(enum enc_label )16, (char *)"ISO8859-14"}, 
        {(enum enc_label )17, (char *)"ISO8859-15"}};
#line 282 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
static struct FALLBACK_FONT_LIST fallback_mfont_list_x11[18]  = 
#line 282
  {      {(enum enc_label )0, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-1"}, 
        {(enum enc_label )1, (char *)"-*-*-*-r-*-*-*-*-*-c-*-koi8-r"}, 
        {(enum enc_label )2, (char *)"-*-*-*-r-*-*-*-*-*-c-*-koi8-u"}, 
        {(enum enc_label )3, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-1"}, 
        {(enum enc_label )4, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-2"}, 
        {(enum enc_label )5, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-3"}, 
        {(enum enc_label )6, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-4"}, 
        {(enum enc_label )7, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-5"}, 
        {(enum enc_label )8, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-6"}, 
        {(enum enc_label )9, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-7"}, 
        {(enum enc_label )10, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-8"}, 
        {(enum enc_label )11, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-9"}, 
        {(enum enc_label )12, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-10"}, 
        {(enum enc_label )13, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-11"}, 
        {(enum enc_label )14, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-12"}, 
        {(enum enc_label )15, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-13"}, 
        {(enum enc_label )16, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-14"}, 
        {(enum enc_label )17, (char *)"-*-*-*-r-*-*-*-*-*-c-*-iso8859-15"}};
#line 313 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
char **def_fontName  ;
#line 314 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
char **def_mfontName  ;
#line 420 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
void rxvt_decode_dummy(unsigned char *str , int len ) 
{ 


  {
#line 424
  return;
}
}
#line 428 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
void rxvt_set_default_locale(rxvt_t *r ) 
{ 
  char *locale ;
  char *lc ;
  char const   *tmp ;

  {
  {
#line 436
  locale = getenv("LC_ALL");
  }
#line 437
  if ((unsigned long )((void *)0) == (unsigned long )locale) {
    {
#line 438
    locale = getenv("LC_CTYPE");
    }
  }
#line 439
  if ((unsigned long )((void *)0) == (unsigned long )locale) {
    {
#line 440
    locale = getenv("LANG");
    }
  }
  {
#line 443
  lc = setlocale(0, "");
  }
#line 444
  if ((unsigned long )((void *)0) == (unsigned long )locale) {
#line 445
    locale = lc;
  }
#line 448
  if (locale) {
#line 448
    tmp = (char const   *)locale;
  } else {
#line 448
    tmp = "none";
  }
  {
#line 448
  rxvt_msg((uint32_t )3, (uint32_t )8192, "set default locale to %s\n", tmp);
#line 449
  (r->h)->locale = locale;
  }
#line 450
  return;
}
}
#line 459 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
char *rxvt_get_encoding_from_locale(rxvt_t *r ) 
{ 
  char *enc ;

  {
#line 464
  if ((unsigned long )((void *)0) == (unsigned long )(r->h)->locale) {
#line 465
    return ((char *)((void *)0));
  }
  {
#line 468
  enc = nl_langinfo(14);
  }
#line 468
  if ((unsigned long )((void *)0) == (unsigned long )enc) {
#line 469
    return ((char *)((void *)0));
  }
#line 484
  if (0 == (int )*enc) {
#line 485
    return ((char *)((void *)0));
  }
#line 487
  return (enc);
}
}
#line 492 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
char *rxvt_encoding_name(rxvt_t *r ) 
{ 


  {
#line 498
  return (encoding_name[r->encoding_method].encname);
}
}
#line 532 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
char *rxvt_fallback_mfont_x11(rxvt_t *r ) 
{ 


  {
#line 538
  return (fallback_mfont_list_x11[r->encoding_method].fontname);
}
}
#line 543 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/encoding.c"
void rxvt_set_default_font_x11(rxvt_t *r ) 
{ 
  register int i ;
  char *ptr ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 552
  def_fontName = nfont_list[r->encoding_method].font;
#line 598
  if ((unsigned long )((void *)0) == (unsigned long )*(def_fontName + 0)) {
#line 599
    i = 0;
    {
#line 599
    while (1) {
      while_continue: /* CIL Label */ ;
#line 599
      if (! (i < 6)) {
#line 599
        goto while_break;
      }
      {
#line 600
      tmp = strlen((char const   *)isofont[i]);
#line 600
      tmp___0 = rxvt_malloc(tmp + 4UL);
#line 600
      ptr = (char *)tmp___0;
#line 608
      sprintf((char */* __restrict  */)ptr, (char const   */* __restrict  */)isofont[i],
              1);
#line 609
      *(def_fontName + i) = ptr;
#line 599
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 614
  i = 0;
  {
#line 614
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 614
    if (! (i < 6)) {
#line 614
      goto while_break___0;
    }
#line 615
    if ((unsigned long )((void *)0) == (unsigned long )(r->h)->rs[280 + i]) {
#line 616
      (r->h)->rs[280 + i] = (char const   *)*(def_fontName + i);
    }
#line 614
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 622
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 373
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 1530 "/usr/include/X11/Xlib.h"
extern char *XKeysymToString(KeySym  ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1722
extern KeySym XStringToKeysym(char const   * ) ;
#line 2157
extern int XClearArea(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                      int  ) ;
#line 528 "/usr/include/X11/Xutil.h"
extern void XConvertCase(KeySym  , KeySym * , KeySym * ) ;
#line 30 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_cmd_write(rxvt_t *r , int page , unsigned char const   *str , unsigned int count ) ;
#line 35
void rxvt_tt_write(rxvt_t *r , int page , unsigned char const   *d , int len ) ;
#line 37
void rxvt_resize_on_subwin(rxvt_t *r , resize_reason_t reason ) ;
#line 38
void rxvt_resize_on_font(rxvt_t *r , char *fontname ) ;
#line 74
int rxvt_parse_macros(rxvt_t *r , char const   *str , char const   *arg , macro_priority_t priority ) ;
#line 75
void rxvt_cleanup_macros(rxvt_t *r ) ;
#line 76
int rxvt_set_action(action_t *action , char *astring ) ;
#line 77
int rxvt_process_macros(rxvt_t *r , KeySym keysym , XKeyEvent *ev ) ;
#line 78
int rxvt_dispatch_action(rxvt_t *r , action_t *action , XEvent *ev ) ;
#line 81
void rxvt_toggle_subwin(rxvt_t *r , unsigned char const   *str ) ;
#line 100
void rxvt_init_fifo(rxvt_t *r ) ;
#line 107
int ewmh_message(Display *dpy , Window root_win , Window client_win , Atom msgAtom ,
                 long d0 , long d1 , long d2 , long d3 , long d4 ) ;
#line 108
int rxvt_async_exec(rxvt_t *r , char const   *cmd ) ;
#line 131
void *rxvt_realloc(void *ptr , size_t size ) ;
#line 132
void rxvt_free(void *ptr ) ;
#line 140
void rxvt_exit_request(rxvt_t *r ) ;
#line 194
int rxvt_str_match(char const   *s1 , char const   *s2 ) ;
#line 196
char *rxvt_str_trim(char *str ) ;
#line 197
int rxvt_str_escaped(char *str ) ;
#line 198
int rxvt_percent_interpolate(rxvt_t *r , int page , char const   *src , int len ,
                             char *dst , int maxLen ) ;
#line 265
void rxvt_scr_touch(rxvt_t *r , int page , int refresh ) ;
#line 267
int rxvt_scr_page(rxvt_t *r , int page , enum page_dirn direction , int nlines ) ;
#line 269
void rxvt_scr_printscreen(rxvt_t *r , int page , int fullhist , int pretty , int linecont ,
                          char const   *pipeName ) ;
#line 276
void rxvt_selection_request(rxvt_t *r , int page , Time tm , int x , int y ) ;
#line 277
void rxvt_selection_request_by_sel(rxvt_t *r , int page , Time tm , int x , int y ,
                                   int sel ) ;
#line 283
void rxvt_paste_file(rxvt_t *r , int page , Time tm , int x , int y , char *filename ) ;
#line 336
int rxvt_scrollbar_visible(rxvt_t *r ) ;
#line 341
int rxvt_scrollbar_hide(rxvt_t *r ) ;
#line 342
int rxvt_scrollbar_show(rxvt_t *r ) ;
#line 343
int rxvt_scrollbar_update(rxvt_t *r , int update ) ;
#line 386
void rxvt_toggle_transparency(rxvt_t *r ) ;
#line 404
int rxvt_save_options(rxvt_t *r , char const   *filename ) ;
#line 435
void rxvt_append_page(rxvt_t *r , int profile , char const   *title , char const   *command ) ;
#line 436
void rxvt_kill_page(rxvt_t *r , short page ) ;
#line 437
void rxvt_remove_page(rxvt_t *r , short page ) ;
#line 438
void rxvt_activate_page(rxvt_t *r , short index___0 ) ;
#line 439
void rxvt_tabbar_set_visible_tabs(rxvt_t *r , int refresh ) ;
#line 441
void rxvt_tabbar_set_title(rxvt_t *r , short page , unsigned char const   *str ) ;
#line 445
int rxvt_tabbar_visible(rxvt_t *r ) ;
#line 447
int rxvt_tabbar_hide(rxvt_t *r ) ;
#line 448
int rxvt_tabbar_show(rxvt_t *r ) ;
#line 456
void rxvt_adjust_fd_number(rxvt_t *r ) ;
#line 459
void rxvt_tabbar_move_tab(rxvt_t *r , short newPage ) ;
#line 31 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
static char const   * const  macroNames[28]  = 
#line 31 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
  {      (char const   */* const  */)"Dummy",      (char const   */* const  */)"Esc",      (char const   */* const  */)"Str",      (char const   */* const  */)"NewTab", 
        (char const   */* const  */)"Exec",      (char const   */* const  */)"Close",      (char const   */* const  */)"GotoTab",      (char const   */* const  */)"MoveTab", 
        (char const   */* const  */)"Scroll",      (char const   */* const  */)"Copy",      (char const   */* const  */)"Paste",      (char const   */* const  */)"PasteFile", 
        (char const   */* const  */)"MonitorTab",      (char const   */* const  */)"ToggleSubwin",      (char const   */* const  */)"ResizeFont",      (char const   */* const  */)"ToggleVeryBold", 
        (char const   */* const  */)"ToggleBoldColors",      (char const   */* const  */)"ToggleVeryBright",      (char const   */* const  */)"ToggleTransparency",      (char const   */* const  */)"ToggleBroadcast", 
        (char const   */* const  */)"ToggleHold",      (char const   */* const  */)"ToggleFullscreen",      (char const   */* const  */)"Raise",      (char const   */* const  */)"SetTitle", 
        (char const   */* const  */)"UseFifo",      (char const   */* const  */)"PrintScreen",      (char const   */* const  */)"SaveConfig",      (char const   */* const  */)"ToggleMacros"};
#line 67
int macro_cmp(void const   *p1 , void const   *p2 ) ;
#line 68
int rxvt_add_macro(rxvt_t *r , KeySym keysym , unsigned char modFlags , char *astring ,
                   int addmacro , macro_priority_t priority ) ;
#line 69
unsigned char macro_set_number(unsigned char flag , unsigned char num ) ;
#line 95 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
void rxvt_toggle_subwin(rxvt_t *r , unsigned char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 98
  if ((unsigned long )((void *)0) == (unsigned long )str) {
#line 98
    goto _L___2;
  } else
#line 98
  if (0 == (int )*str) {
#line 98
    goto _L___2;
  } else {
    {
#line 98
    tmp___3 = strchr((char const   *)str, 't');
    }
#line 98
    if (tmp___3) {
#line 98
      goto _L___2;
    } else {
      {
#line 98
      tmp___4 = strchr((char const   *)str, 'T');
      }
#line 98
      if (tmp___4) {
        _L___2: /* CIL Label */ 
        {
#line 105
        tmp___2 = rxvt_tabbar_visible(r);
        }
#line 105
        if (tmp___2) {
#line 105
          if ((unsigned long )((void *)0) == (unsigned long )str) {
#line 105
            goto _L___1;
          } else
#line 105
          if (43 != (int )*str) {
            _L___1: /* CIL Label */ 
            {
#line 112
            tmp = rxvt_tabbar_hide(r);
            }
#line 112
            if (tmp) {
              {
#line 112
              rxvt_resize_on_subwin(r, (resize_reason_t )2);
              }
            }
          } else {
#line 105
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 114
          tmp___1 = rxvt_tabbar_visible(r);
          }
#line 114
          if (! tmp___1) {
#line 114
            if ((unsigned long )((void *)0) == (unsigned long )str) {
#line 114
              goto _L;
            } else
#line 114
            if (45 != (int )*str) {
              _L: /* CIL Label */ 
              {
#line 121
              tmp___0 = rxvt_tabbar_show(r);
              }
#line 121
              if (tmp___0) {
                {
#line 121
                rxvt_resize_on_subwin(r, (resize_reason_t )3);
                }
              }
            }
          }
        }
#line 124
        return;
      }
    }
  }
  {
#line 130
  tmp___5 = strchr((char const   *)str, 'b');
  }
#line 130
  if (tmp___5) {
#line 130
    goto _L___3;
  } else {
    {
#line 130
    tmp___6 = strchr((char const   *)str, 'B');
    }
#line 130
    if (tmp___6) {
      _L___3: /* CIL Label */ 
      {
#line 135
      if ((int const   )*str == 43) {
#line 135
        goto case_43;
      }
#line 140
      if ((int const   )*str == 45) {
#line 140
        goto case_45;
      }
#line 145
      goto switch_default;
      case_43: /* CIL Label */ 
#line 137
      r->Options[((1UL << 17) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & ~ (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL));
#line 138
      goto switch_break;
      case_45: /* CIL Label */ 
#line 142
      r->Options[((1UL << 17) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] | (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL));
#line 143
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 147
      r->Options[((1UL << 17) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] ^ (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL));
      switch_break: /* CIL Label */ ;
      }
      {
#line 151
      rxvt_tabbar_set_visible_tabs(r, 0);
      }
#line 152
      if (0UL != r->tabBar.win) {
        {
#line 153
        XClearArea(r->Xdisplay, r->tabBar.win, 0, 0, 0U, 0U, 1);
        }
      }
#line 155
      return;
    }
  }
  {
#line 160
  tmp___11 = strchr((char const   *)str, 's');
  }
#line 160
  if (tmp___11) {
#line 160
    goto _L___5;
  } else {
    {
#line 160
    tmp___12 = strchr((char const   *)str, 'S');
    }
#line 160
    if (tmp___12) {
      _L___5: /* CIL Label */ 
      {
#line 162
      tmp___10 = rxvt_scrollbar_visible(r);
      }
#line 162
      if (tmp___10) {
#line 162
        if ((int const   )*str != 43) {
          {
#line 164
          tmp___7 = rxvt_scrollbar_hide(r);
          }
#line 164
          if (tmp___7) {
            {
#line 165
            rxvt_resize_on_subwin(r, (resize_reason_t )4);
            }
          }
        } else {
#line 162
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        {
#line 167
        tmp___9 = rxvt_scrollbar_visible(r);
        }
#line 167
        if (! tmp___9) {
#line 167
          if ((int const   )*str != 45) {
            {
#line 169
            tmp___8 = rxvt_scrollbar_show(r);
            }
#line 169
            if (tmp___8) {
              {
#line 170
              rxvt_resize_on_subwin(r, (resize_reason_t )5);
              }
            }
          }
        }
      }
#line 173
      return;
    }
  }
#line 194
  return;
}
}
#line 204 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
int macro_cmp(void const   *p1 , void const   *p2 ) 
{ 
  macros_t const   *macro1 ;
  macros_t const   *macro2 ;

  {
#line 207
  macro1 = (macros_t const   *)p1;
#line 207
  macro2 = (macros_t const   *)p2;
#line 211
  if (macro1->keysym == macro2->keysym) {
#line 213
    if ((((unsigned int )macro1->modFlags & ~ (1U << 3)) & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) == (((unsigned int )macro2->modFlags & ~ (1U << 3)) & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3)))) {
#line 217
      return ((int )((((unsigned int )macro1->modFlags & ~ (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) >> 4) - (((unsigned int )macro2->modFlags & ~ (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) >> 4)));
    } else {
#line 220
      return ((int )((((unsigned int )macro1->modFlags & ~ (1U << 3)) & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) - (((unsigned int )macro2->modFlags & ~ (1U << 3)) & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3)))));
    }
  } else {
#line 224
    return ((int )(macro1->keysym - macro2->keysym));
  }
}
}
#line 229 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
unsigned char macro_set_number(unsigned char flag , unsigned char num ) 
{ 


  {
#line 232
  flag = (unsigned char )((unsigned int )flag & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3)));
#line 233
  flag = (unsigned char )((int )flag | ((int )num << 4));
#line 235
  return (flag);
}
}
#line 251 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
int rxvt_parse_macros(rxvt_t *r , char const   *str , char const   *arg , macro_priority_t priority ) 
{ 
  char newarg[500] ;
  char keyname[500] ;
  char *keyname_nomods ;
  unsigned char modFlags ;
  KeySym keysym ;
  int addmacro ;
  char *keyend ;
  int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  KeySym upper ;
  KeySym tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 258
  modFlags = (unsigned char)0;
#line 261
  addmacro = 0;
#line 263
  if ((unsigned long )((void *)0) == (unsigned long )arg) {
    {
#line 271
    n = rxvt_str_match(str, "macro.");
    }
#line 271
    if (n == 0) {
#line 272
      return (0);
    }
    {
#line 273
    str += n;
#line 275
    keyend = strchr(str, ':');
    }
#line 275
    if ((unsigned long )((void *)0) == (unsigned long )keyend) {
#line 276
      return (-1);
    }
#line 278
    if (keyend - (char *)str < 499L) {
#line 278
      n = (int )(keyend - (char *)str);
    } else {
#line 278
      n = 499;
    }
    {
#line 280
    strncpy((char */* __restrict  */)(keyname), (char const   */* __restrict  */)str,
            (size_t )n);
#line 281
    keyname[n] = (char)0;
#line 283
    strncpy((char */* __restrict  */)(newarg), (char const   */* __restrict  */)((char const   *)(keyend + 1)),
            (size_t )499);
    }
  } else {
    {
#line 290
    strncpy((char */* __restrict  */)(keyname), (char const   */* __restrict  */)str,
            (size_t )499);
#line 291
    keyname[499] = (char )'\000';
#line 293
    strncpy((char */* __restrict  */)(newarg), (char const   */* __restrict  */)arg,
            (size_t )499);
    }
  }
  {
#line 297
  newarg[499] = (char )'\000';
#line 298
  rxvt_str_trim(newarg);
#line 300
  rxvt_msg((uint32_t )3, (uint32_t )64, "Got macro \'%s\' -- \'%s\'\n", keyname, newarg);
#line 306
  keyname_nomods = strrchr((char const   *)(keyname), '+');
  }
#line 306
  if ((unsigned long )((void *)0) == (unsigned long )keyname_nomods) {
#line 310
    keyname_nomods = keyname;
  } else {
    {
#line 317
    tmp = keyname_nomods;
#line 317
    keyname_nomods ++;
#line 317
    *tmp = (char)0;
#line 324
    tmp___0 = strcasestr((char const   *)(keyname), "ctrl");
    }
#line 324
    if (tmp___0) {
#line 325
      modFlags = (unsigned char )((unsigned int )modFlags | 1U);
    }
    {
#line 326
    tmp___1 = strcasestr((char const   *)(keyname), "meta");
    }
#line 326
    if (tmp___1) {
#line 327
      modFlags = (unsigned char )((unsigned int )modFlags | (1U << 1));
    } else {
      {
#line 326
      tmp___2 = strcasestr((char const   *)(keyname), "alt");
      }
#line 326
      if (tmp___2) {
#line 327
        modFlags = (unsigned char )((unsigned int )modFlags | (1U << 1));
      }
    }
    {
#line 328
    tmp___3 = strcasestr((char const   *)(keyname), "shift");
    }
#line 328
    if (tmp___3) {
#line 329
      modFlags = (unsigned char )((unsigned int )modFlags | (1U << 2));
    }
    {
#line 330
    tmp___4 = strcasestr((char const   *)(keyname), "primary");
    }
#line 330
    if (tmp___4) {
#line 331
      modFlags = (unsigned char )((unsigned int )modFlags | (1U << 3));
    }
    {
#line 332
    tmp___5 = strcasestr((char const   *)(keyname), "add");
    }
#line 332
    if (tmp___5) {
#line 333
      addmacro = 1;
    }
  }
  {
#line 342
  tmp___6 = XStringToKeysym((char const   *)keyname_nomods);
#line 342
  XConvertCase(tmp___6, & keysym, & upper);
  }
#line 345
  if (0UL == keysym) {
    {
#line 347
    rxvt_msg((uint32_t )1, (uint32_t )64, "Invalid keysym %s. Skipping macro.", keyname_nomods);
    }
#line 349
    return (-1);
  }
  {
#line 352
  tmp___9 = rxvt_add_macro(r, keysym, modFlags, newarg, addmacro, priority);
  }
#line 352
  if (tmp___9) {
#line 352
    tmp___8 = 1;
  } else {
#line 352
    tmp___8 = -1;
  }
#line 352
  return (tmp___8);
}
}
#line 367 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
int rxvt_add_macro(rxvt_t *r , KeySym keysym , unsigned char modFlags , char *astring ,
                   int addmacro , macro_priority_t priority ) 
{ 
  unsigned int nmacros_increment ;
  unsigned short i ;
  unsigned short replaceIndex ;
  unsigned short dummyIndex ;
  unsigned char macroNum ;
  action_t action ;
  unsigned char num ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
#line 371
  nmacros_increment = 64U;
#line 376
  replaceIndex = r->nmacros;
#line 376
  dummyIndex = r->nmacros;
#line 380
  macroNum = (unsigned char)0;
#line 390
  i = (unsigned short)0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! ((int )i < (int )r->nmacros)) {
#line 390
      goto while_break;
    }
#line 392
    if ((r->macros + i)->keysym == keysym) {
#line 392
      if ((((unsigned int )(r->macros + i)->modFlags & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) & ~ (1U << 3)) == (((unsigned int )modFlags & (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) & ~ (1U << 3))) {
#line 398
        if (addmacro) {
#line 398
          if ((int )(r->macros + i)->priority == (int )priority) {
#line 406
            num = (unsigned char )(((unsigned int )(r->macros + i)->modFlags & ~ (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) >> 4);
#line 407
            if ((int )num > (int )macroNum) {
#line 408
              macroNum = num;
            }
#line 410
            if ((int )macroNum == 15) {
              {
#line 412
              rxvt_msg((uint32_t )1, (uint32_t )64, "Macro chain too long");
              }
#line 413
              return (0);
            }
#line 416
            replaceIndex = i;
          } else {
#line 398
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 423
        if ((int )priority > (int )(r->macros + i)->priority) {
#line 424
          return (1);
        } else {
#line 435
          if ((int )replaceIndex < (int )r->nmacros) {
#line 442
            (r->macros + replaceIndex)->keysym = (KeySym )0;
          }
#line 444
          replaceIndex = i;
        }
      } else {
#line 392
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 448
    if ((r->macros + i)->keysym == 0UL) {
#line 452
      dummyIndex = i;
    }
#line 390
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if (addmacro) {
#line 464
    if ((int )replaceIndex == (int )r->nmacros) {
      {
#line 466
      tmp = XKeysymToString(keysym);
      }
#line 466
      if ((unsigned int )modFlags & (1U << 2)) {
#line 466
        tmp___0 = "Shift+";
      } else {
#line 466
        tmp___0 = "";
      }
#line 466
      if ((unsigned int )modFlags & (1U << 1)) {
#line 466
        tmp___1 = "Meta+";
      } else {
#line 466
        tmp___1 = "";
      }
#line 466
      if ((unsigned int )modFlags & 1U) {
#line 466
        tmp___2 = "Ctrl+";
      } else {
#line 466
        tmp___2 = "";
      }
      {
#line 466
      rxvt_msg((uint32_t )1, (uint32_t )64, "No previous macro to add to (key %s%s%s%s)",
               tmp___2, tmp___1, tmp___0, tmp);
      }
#line 472
      return (0);
    } else
#line 475
    if ((int )(r->macros + replaceIndex)->priority != (int )priority) {
      {
#line 477
      tmp___3 = XKeysymToString(keysym);
      }
#line 477
      if ((unsigned int )modFlags & (1U << 2)) {
#line 477
        tmp___4 = "Shift+";
      } else {
#line 477
        tmp___4 = "";
      }
#line 477
      if ((unsigned int )modFlags & (1U << 1)) {
#line 477
        tmp___5 = "Meta+";
      } else {
#line 477
        tmp___5 = "";
      }
#line 477
      if ((unsigned int )modFlags & 1U) {
#line 477
        tmp___6 = "Ctrl+";
      } else {
#line 477
        tmp___6 = "";
      }
      {
#line 477
      rxvt_msg((uint32_t )1, (uint32_t )64, "Can not add to a macro defined at a different location (key %s%s%s%s)",
               tmp___6, tmp___5, tmp___4, tmp___3);
      }
#line 484
      return (0);
    } else
#line 487
    if ((int )(r->macros + replaceIndex)->action.type == 0) {
      {
#line 490
      tmp___7 = XKeysymToString(keysym);
      }
#line 490
      if ((unsigned int )modFlags & (1U << 2)) {
#line 490
        tmp___8 = "Shift+";
      } else {
#line 490
        tmp___8 = "";
      }
#line 490
      if ((unsigned int )modFlags & (1U << 1)) {
#line 490
        tmp___9 = "Meta+";
      } else {
#line 490
        tmp___9 = "";
      }
#line 490
      if ((unsigned int )modFlags & 1U) {
#line 490
        tmp___10 = "Ctrl+";
      } else {
#line 490
        tmp___10 = "";
      }
      {
#line 490
      rxvt_msg((uint32_t )1, (uint32_t )64, "Can not add actions to a Dummy macro(key %s%s%s%s)",
               tmp___10, tmp___9, tmp___8, tmp___7);
      }
#line 497
      return (0);
    }
    {
#line 503
    replaceIndex = dummyIndex;
#line 509
    modFlags = macro_set_number(modFlags, (unsigned char )((int )macroNum + 1));
    }
  } else {
    {
#line 514
    modFlags = macro_set_number(modFlags, (unsigned char)0);
    }
#line 517
    if ((int )dummyIndex < (int )replaceIndex) {
#line 518
      replaceIndex = dummyIndex;
    }
  }
#line 526
  if ((int )replaceIndex == (int )r->nmacros) {
#line 528
    if ((int )r->nmacros == (int )r->maxMacros) {
      {
#line 531
      r->maxMacros = (unsigned short )((unsigned int )r->maxMacros + nmacros_increment);
#line 532
      tmp___11 = rxvt_realloc((void *)r->macros, (unsigned long )r->maxMacros * sizeof(macros_t ));
#line 532
      r->macros = (macros_t *)tmp___11;
      }
    }
#line 536
    r->nmacros = (unsigned short )((int )r->nmacros + 1);
  } else
#line 541
  if ((r->macros + replaceIndex)->action.str) {
    {
#line 542
    rxvt_free((void *)(r->macros + replaceIndex)->action.str);
    }
  }
  {
#line 551
  action.str = (unsigned char *)((void *)0);
#line 553
  tmp___12 = rxvt_set_action(& action, astring);
  }
#line 553
  if (! tmp___12) {
#line 554
    return (0);
  }
#line 559
  (r->macros + replaceIndex)->keysym = keysym;
#line 560
  (r->macros + replaceIndex)->modFlags = modFlags;
#line 561
  (r->macros + replaceIndex)->action = action;
#line 562
  (r->macros + replaceIndex)->priority = priority;
#line 573
  return (1);
}
}
#line 581 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
void rxvt_cleanup_macros(rxvt_t *r ) 
{ 
  unsigned int i ;
  unsigned int nDummyMacros ;
  void *tmp ;

  {
#line 584
  nDummyMacros = 0U;
#line 586
  if ((int )r->nmacros == 0) {
#line 586
    return;
  }
#line 588
  i = 0U;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! (i < (unsigned int )r->nmacros)) {
#line 588
      goto while_break;
    }
#line 590
    if ((int )(r->macros + i)->action.type == 0) {
#line 590
      goto _L;
    } else
#line 590
    if (0UL == (r->macros + i)->keysym) {
      _L: /* CIL Label */ 
#line 604
      (r->macros + i)->keysym = (KeySym )0;
#line 605
      (r->macros + i)->modFlags = (unsigned char)0;
#line 607
      if ((unsigned long )((void *)0) != (unsigned long )(r->macros + i)->action.str) {
        {
#line 609
        rxvt_free((void *)(r->macros + i)->action.str);
#line 610
        (r->macros + i)->action.str = (unsigned char *)((void *)0);
        }
      }
#line 613
      nDummyMacros ++;
    }
#line 588
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  qsort((void *)r->macros, (size_t )r->nmacros, sizeof(macros_t ), & macro_cmp);
#line 625
  memmove((void *)r->macros, (void const   *)(r->macros + nDummyMacros), (unsigned long )((unsigned int )r->nmacros - nDummyMacros) * sizeof(macros_t ));
#line 627
  r->nmacros = (unsigned short )((unsigned int )r->nmacros - nDummyMacros);
  }
#line 630
  if ((int )r->nmacros < (int )r->maxMacros) {
    {
#line 632
    tmp = rxvt_realloc((void *)r->macros, (unsigned long )r->nmacros * sizeof(macros_t ));
#line 632
    r->macros = (macros_t *)tmp;
#line 633
    r->maxMacros = r->nmacros;
    }
  }
#line 639
  return;
}
}
#line 650 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
int rxvt_set_action(action_t *action , char *astring ) 
{ 
  unsigned short type ;
  unsigned short len ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short tmp___3 ;
  void *tmp___4 ;

  {
#line 660
  type = (unsigned short)0;
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! ((int )type < 28)) {
#line 660
      goto while_break;
    }
    {
#line 662
    tmp___1 = rxvt_str_match((char const   *)astring, (char const   *)macroNames[type]);
#line 662
    len = (unsigned short )tmp___1;
    }
#line 662
    if (len) {
#line 665
      if (*(astring + len)) {
        {
#line 665
        tmp = __ctype_b_loc();
        }
#line 665
        if (! ((int const   )*(*tmp + (int )*(astring + len)) & 8192)) {
#line 667
          goto __Cont;
        }
      }
#line 670
      astring += (int )len;
      {
#line 671
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 671
        if (*astring) {
          {
#line 671
          tmp___0 = __ctype_b_loc();
          }
#line 671
          if (! ((int const   )*(*tmp___0 + (int )*astring) & 8192)) {
#line 671
            goto while_break___0;
          }
        } else {
#line 671
          goto while_break___0;
        }
#line 671
        astring ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 674
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 660
    type = (unsigned short )((int )type + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if ((int )type == 28) {
    {
#line 680
    rxvt_msg((uint32_t )1, (uint32_t )64, "Action %s is not of known type", astring);
    }
#line 681
    return (0);
  }
  {
#line 687
  action->type = type;
#line 693
  tmp___2 = rxvt_str_escaped(astring);
#line 693
  len = (unsigned short )tmp___2;
  }
#line 696
  if ((int )type != 2) {
#line 696
    if ((int )type != 1) {
#line 696
      if ((int )len > 0) {
#line 696
        if (*(astring + ((int )len - 1))) {
#line 697
          tmp___3 = len;
#line 697
          len = (unsigned short )((int )len + 1);
#line 697
          *(astring + tmp___3) = (char)0;
        }
      }
    }
  }
#line 701
  action->len = len;
#line 704
  if ((int )len > 0) {
    {
#line 706
    tmp___4 = rxvt_realloc((void *)action->str, (unsigned long )len * sizeof(unsigned char ));
#line 706
    action->str = (unsigned char *)tmp___4;
#line 708
    memcpy((void */* __restrict  */)((void *)action->str), (void const   */* __restrict  */)((void const   *)astring),
           (size_t )len);
    }
  } else
#line 711
  if ((unsigned long )((void *)0) != (unsigned long )action->str) {
    {
#line 713
    rxvt_free((void *)action->str);
#line 714
    action->str = (unsigned char *)((void *)0);
    }
  }
#line 716
  return (1);
}
}
#line 728 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
int rxvt_process_macros(rxvt_t *r , KeySym keysym , XKeyEvent *ev ) 
{ 
  macros_t ck ;
  macros_t *macro ;
  int status ;
  KeySym upper ;
  void *tmp ;

  {
#line 737
  if ((int )r->nmacros == 0) {
#line 738
    return (0);
  }
#line 741
  ck.modFlags = (unsigned char)0;
#line 742
  if (ev->state & 1U) {
#line 742
    ck.modFlags = (unsigned char )((unsigned int )ck.modFlags | (1U << 2));
  }
#line 743
  if (ev->state & (unsigned int )(1 << 2)) {
#line 743
    ck.modFlags = (unsigned char )((unsigned int )ck.modFlags | 1U);
  }
#line 744
  if (ev->state & (r->h)->ModMetaMask) {
#line 744
    ck.modFlags = (unsigned char )((unsigned int )ck.modFlags | (1U << 1));
  }
  {
#line 749
  XConvertCase(keysym, & ck.keysym, & upper);
#line 753
  tmp = bsearch((void const   *)(& ck), (void const   *)r->macros, (size_t )r->nmacros,
                sizeof(macros_t ), & macro_cmp);
#line 753
  macro = (macros_t *)tmp;
  }
#line 755
  if ((unsigned long )((void *)0) == (unsigned long )macro) {
#line 776
    return (0);
  } else
#line 755
  if ((unsigned int )macro->modFlags & (1U << 3)) {
#line 755
    if ((int )(r->vts[r->tabBar.atab])->current_screen != 0) {
#line 776
      return (0);
    } else {
#line 755
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 755
  if ((unsigned long )r->Options[((1UL << 22) | 1UL) & 3UL] & (((1UL << 22) | 1UL) & 0xfffffffffffffffcUL)) {
#line 755
    if ((int )macro->action.type != 27) {
#line 776
      return (0);
    }
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 781
    status = rxvt_dispatch_action(r, & macro->action, (XEvent *)ev);
    }
#line 778
    if (status == 1) {
#line 778
      macro ++;
#line 778
      if (macro - r->macros < (long )r->nmacros) {
#line 778
        if (! (((unsigned int )macro->modFlags & ~ (((1U | (1U << 1)) | (1U << 2)) | (1U << 3))) >> 4)) {
#line 778
          goto while_break;
        }
      } else {
#line 778
        goto while_break;
      }
    } else {
#line 778
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 789
  return (status);
}
}
#line 798 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/macros.c"
int rxvt_dispatch_action(rxvt_t *r , action_t *action , XEvent *ev ) 
{ 
  int maxLen ;
  char *expstr ;
  unsigned long __lengthofexpstr ;
  void *tmp ;
  char *astr ;
  int alen ;
  int retval ;
  int MaxMacroTitle ;
  char *titlestring ;
  unsigned long __lengthoftitlestring ;
  void *tmp___0 ;
  char *command ;
  char *title ;
  int profile ;
  char *pnum_end ;
  unsigned long tmp___1 ;
  unsigned short const   **tmp___2 ;
  int i ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  int tmp___6 ;
  int tabno ;
  int tmp___7 ;
  int tabno___0 ;
  short tabno___1 ;
  int tmp___8 ;
  int amount ;
  int tmp___9 ;
  int tmp___10 ;
  enum page_dirn direction ;
  int tmp___11 ;
  int tmp___12 ;
  int sel ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  short doit ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int MaxFontLen ;
  char *fontname ;
  unsigned long __lengthoffontname ;
  void *tmp___19 ;
  long state ;
  long tmp___20 ;
  char op ;
  char *tmp___21 ;
  unsigned long holdMask ;
  union __anonunion_376 __constr_expr_0 ;
  union __anonunion_377 __constr_expr_1 ;
  int k ;
  Atom tmp___22 ;
  Atom tmp___23 ;
  Atom tmp___24 ;
  int state___0 ;
  long tmp___25 ;
  char *s ;
  int pretty ;
  int scrollback ;
  int linecont ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  char *tmp___28 ;
  char cfile[4096] ;
  unsigned int tmp___29 ;
  char *home ;
  char *tmp___30 ;
  int tmp___32 ;

  {
  {
#line 801
  maxLen = 1024;
#line 802
  __lengthofexpstr = (unsigned long )maxLen;
#line 802
  tmp = __builtin_alloca(sizeof(*expstr) * __lengthofexpstr);
#line 802
  expstr = (char *)tmp;
#line 804
  retval = 1;
  }
#line 807
  if ((unsigned long )((void *)0) == (unsigned long )action->str) {
#line 809
    astr = (char *)((void *)0);
#line 810
    alen = 0;
  } else {
    {
#line 815
    astr = expstr;
#line 816
    alen = rxvt_percent_interpolate(r, (int )r->tabBar.atab, (char const   *)((char *)action->str),
                                    (int )action->len, astr, maxLen);
    }
  }
  {
#line 823
  if ((int )action->type == 1) {
#line 823
    goto case_1;
  }
#line 835
  if ((int )action->type == 2) {
#line 835
    goto case_2;
  }
#line 847
  if ((int )action->type == 3) {
#line 847
    goto case_3;
  }
#line 910
  if ((int )action->type == 4) {
#line 910
    goto case_4;
  }
#line 923
  if ((int )action->type == 5) {
#line 923
    goto case_5;
  }
#line 949
  if ((int )action->type == 6) {
#line 949
    goto case_6;
  }
#line 991
  if ((int )action->type == 7) {
#line 991
    goto case_7;
  }
#line 1007
  if ((int )action->type == 8) {
#line 1007
    goto case_8;
  }
#line 1036
  if ((int )action->type == 10) {
#line 1036
    goto case_10;
  }
#line 1065
  if ((int )action->type == 11) {
#line 1065
    goto case_11;
  }
#line 1080
  if ((int )action->type == 12) {
#line 1080
    goto case_12;
  }
#line 1142
  if ((int )action->type == 13) {
#line 1142
    goto case_13;
  }
#line 1146
  if ((int )action->type == 14) {
#line 1146
    goto case_14;
  }
#line 1164
  if ((int )action->type == 15) {
#line 1164
    goto case_15;
  }
#line 1170
  if ((int )action->type == 16) {
#line 1170
    goto case_16;
  }
#line 1176
  if ((int )action->type == 17) {
#line 1176
    goto case_17;
  }
#line 1182
  if ((int )action->type == 18) {
#line 1182
    goto case_18;
  }
#line 1190
  if ((int )action->type == 19) {
#line 1190
    goto case_19;
  }
#line 1221
  if ((int )action->type == 20) {
#line 1221
    goto case_20;
  }
#line 1273
  if ((int )action->type == 21) {
#line 1273
    goto case_21;
  }
#line 1281
  if ((int )action->type == 22) {
#line 1281
    goto case_22;
  }
#line 1288
  if ((int )action->type == 23) {
#line 1288
    goto case_23;
  }
#line 1300
  if ((int )action->type == 24) {
#line 1300
    goto case_24;
  }
#line 1331
  if ((int )action->type == 25) {
#line 1331
    goto case_25;
  }
#line 1373
  if ((int )action->type == 26) {
#line 1373
    goto case_26;
  }
#line 1394
  if ((int )action->type == 27) {
#line 1394
    goto case_27;
  }
#line 1398
  goto switch_default___2;
  case_1: /* CIL Label */ 
#line 825
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 825
    if (alen > 1) {
      {
#line 826
      rxvt_cmd_write(r, (int )r->tabBar.atab, (unsigned char const   *)((unsigned char *)astr),
                     (unsigned int )(alen - 1));
      }
    } else {
      {
#line 829
      rxvt_msg((uint32_t )1, (uint32_t )64, "Macro %s requires argument.", macroNames[action->type]);
#line 831
      retval = -1;
      }
    }
  } else {
    {
#line 829
    rxvt_msg((uint32_t )1, (uint32_t )64, "Macro %s requires argument.", macroNames[action->type]);
#line 831
    retval = -1;
    }
  }
#line 833
  goto switch_break;
  case_2: /* CIL Label */ 
#line 837
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 837
    if (alen > 1) {
      {
#line 838
      rxvt_tt_write(r, (int )r->tabBar.atab, (unsigned char const   *)((unsigned char *)astr),
                    alen - 1);
      }
    } else {
      {
#line 841
      rxvt_msg((uint32_t )1, (uint32_t )64, "Macro %s requires argument.", macroNames[action->type]);
#line 843
      retval = -1;
      }
    }
  } else {
    {
#line 841
    rxvt_msg((uint32_t )1, (uint32_t )64, "Macro %s requires argument.", macroNames[action->type]);
#line 843
    retval = -1;
    }
  }
#line 845
  goto switch_break;
  case_3: /* CIL Label */ 
#line 848
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
    {
#line 860
    MaxMacroTitle = 80;
#line 861
    __lengthoftitlestring = (unsigned long )MaxMacroTitle;
#line 861
    tmp___0 = __builtin_alloca(sizeof(*titlestring) * __lengthoftitlestring);
#line 861
    titlestring = (char *)tmp___0;
#line 862
    command = astr;
#line 863
    title = (char *)((void *)0);
#line 865
    profile = 0;
    }
#line 868
    if ((int )*command == 45) {
      {
#line 871
      command ++;
#line 871
      tmp___1 = strtoul((char const   */* __restrict  */)command, (char **/* __restrict  */)(& pnum_end),
                        0);
#line 871
      profile = (int )tmp___1;
      }
#line 873
      if (profile < 0) {
#line 874
        profile = (int )(r->vts[r->tabBar.atab])->profileNum;
      } else
#line 873
      if (profile >= 5) {
#line 874
        profile = (int )(r->vts[r->tabBar.atab])->profileNum;
      }
#line 877
      command = pnum_end;
      {
#line 878
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 878
        tmp___2 = __ctype_b_loc();
        }
#line 878
        if (! ((int const   )*(*tmp___2 + (int )*command) & 8192)) {
#line 878
          goto while_break;
        }
#line 878
        command ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 882
    if ((int )*command == 34) {
#line 887
      i = 0;
#line 887
      command ++;
      {
#line 887
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 887
        if (i < MaxMacroTitle - 2) {
#line 887
          if (*command) {
#line 887
            if (! ((int )*command != 34)) {
#line 887
              goto while_break___0;
            }
          } else {
#line 887
            goto while_break___0;
          }
        } else {
#line 887
          goto while_break___0;
        }
#line 892
        *(titlestring + i) = *command;
#line 887
        i ++;
#line 887
        command ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 893
      *(titlestring + i) = (char )'\000';
#line 894
      title = titlestring;
#line 897
      if (*command) {
#line 897
        command ++;
      }
      {
#line 898
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 898
        tmp___3 = __ctype_b_loc();
        }
#line 898
        if (! ((int const   )*(*tmp___3 + (int )*command) & 8192)) {
#line 898
          goto while_break___1;
        }
#line 898
        command ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 902
    if (*command) {
#line 902
      tmp___4 = command;
    } else {
#line 902
      tmp___4 = (char *)((void *)0);
    }
    {
#line 902
    rxvt_append_page(r, profile, (char const   *)title, (char const   *)tmp___4);
    }
  } else {
    {
#line 906
    rxvt_append_page(r, 0, (char const   *)((void *)0), (char const   *)((void *)0));
    }
  }
#line 908
  goto switch_break;
  case_4: /* CIL Label */ 
#line 911
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
    {
#line 912
    tmp___6 = rxvt_async_exec(r, (char const   *)astr);
    }
#line 912
    if (tmp___6) {
#line 912
      retval = 1;
    } else {
#line 912
      retval = -1;
    }
  } else {
    {
#line 916
    rxvt_msg((uint32_t )1, (uint32_t )64, "Macro %s requires argument.", macroNames[action->type]);
#line 918
    retval = -1;
    }
  }
#line 921
  goto switch_break;
  case_5: /* CIL Label */ 
#line 924
  if (alen > 0) {
#line 924
    if (*astr) {
      {
#line 927
      tmp___7 = atoi((char const   *)astr);
#line 927
      tabno = tmp___7 - 1;
      }
#line 929
      if (tabno == -1) {
#line 929
        tabno = (int )r->tabBar.atab;
      }
#line 931
      if (tabno >= 0) {
#line 931
        if (tabno <= (int )r->tabBar.ltab) {
#line 931
          if (! ((unsigned long )r->Options[((1UL << 2) | 1UL) & 3UL] & (((1UL << 2) | 1UL) & 0xfffffffffffffffcUL))) {
            {
#line 939
            rxvt_kill_page(r, (short )tabno);
            }
          } else
#line 931
          if ((int )(r->vts[tabno])->current_screen == 0) {
            {
#line 939
            rxvt_kill_page(r, (short )tabno);
            }
          } else {
#line 942
            retval = -1;
          }
        } else {
#line 942
          retval = -1;
        }
      } else {
#line 942
        retval = -1;
      }
    } else {
      {
#line 945
      rxvt_exit_request(r);
      }
    }
  } else {
    {
#line 945
    rxvt_exit_request(r);
    }
  }
#line 947
  goto switch_break;
  case_6: /* CIL Label */ 
#line 954
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 954
    if (*astr) {
      {
#line 956
      tabno___0 = atoi((char const   *)astr);
      }
#line 958
      if ((int )*astr == 43) {
#line 958
        goto _L;
      } else
#line 958
      if ((int )*astr == 45) {
        _L: /* CIL Label */ 
#line 963
        tabno___0 += (int )r->tabBar.atab;
#line 966
        tabno___0 %= (int )r->tabBar.ltab + 1;
#line 967
        if (tabno___0 < 0) {
#line 967
          tabno___0 += (int )r->tabBar.ltab + 1;
        }
      } else
#line 969
      if (tabno___0 == 0) {
#line 974
        tabno___0 = (int )r->tabBar.ptab;
      } else {
#line 976
        tabno___0 --;
#line 976
        if (tabno___0 > (int )r->tabBar.ltab) {
#line 982
          tabno___0 = (int )r->tabBar.ltab;
        }
      }
    } else {
#line 985
      tabno___0 = (int )r->tabBar.ptab;
    }
  } else {
#line 985
    tabno___0 = (int )r->tabBar.ptab;
  }
  {
#line 987
  rxvt_activate_page(r, (short )tabno___0);
  }
#line 988
  goto switch_break;
  case_7: /* CIL Label */ 
#line 993
  if (alen > 0) {
#line 993
    if (*astr) {
      {
#line 995
      tmp___8 = atoi((char const   *)astr);
#line 995
      tabno___1 = (short )tmp___8;
      }
#line 997
      if ((int )*astr == 43) {
        {
#line 998
        rxvt_tabbar_move_tab(r, (short )((int )tabno___1 + (int )r->tabBar.atab));
        }
      } else
#line 997
      if ((int )*astr == 45) {
        {
#line 998
        rxvt_tabbar_move_tab(r, (short )((int )tabno___1 + (int )r->tabBar.atab));
        }
      } else {
        {
#line 1000
        rxvt_tabbar_move_tab(r, (short )((int )tabno___1 - 1));
        }
      }
    } else {
#line 1004
      retval = -1;
    }
  } else {
#line 1004
    retval = -1;
  }
#line 1005
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1009
  if (alen > 1) {
    {
#line 1011
    tmp___9 = atoi((char const   *)astr);
#line 1011
    tmp___10 = abs(tmp___9);
#line 1011
    amount = tmp___10;
    }
#line 1012
    if ((int )*astr == 45) {
#line 1012
      tmp___11 = 0;
    } else {
#line 1012
      tmp___11 = 1;
    }
    {
#line 1012
    direction = (enum page_dirn )tmp___11;
#line 1016
    tmp___12 = tolower((int )*(astr + (alen - 2)));
    }
#line 1016
    if (tmp___12 == 112) {
#line 1018
      amount *= (int )r->TermWin.nrow - 1;
    }
    {
#line 1026
    rxvt_scr_page(r, (int )r->tabBar.atab, direction, amount);
#line 1028
    rxvt_scrollbar_update(r, 1);
    }
  }
#line 1031
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1038
  sel = (int )((Atom )1);
#line 1040
  if ((unsigned long )((void *)0) != (unsigned long )ev) {
#line 1042
    if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 1042
      if (*astr) {
        {
#line 1044
        tmp___15 = strcmp("PRIMARY", (char const   *)astr);
        }
#line 1044
        if (tmp___15 == 0) {
#line 1045
          sel = (int )((Atom )1);
        } else {
          {
#line 1046
          tmp___14 = strcmp("SECONDARY", (char const   *)astr);
          }
#line 1046
          if (tmp___14 == 0) {
#line 1047
            sel = (int )((Atom )2);
          } else {
            {
#line 1048
            tmp___13 = strcmp("CLIPBOARD", (char const   *)astr);
            }
#line 1048
            if (tmp___13 == 0) {
#line 1049
              sel = 19;
            } else {
#line 1051
              goto switch_break;
            }
          }
        }
        {
#line 1052
        rxvt_selection_request_by_sel(r, (int )r->tabBar.atab, ev->xkey.time, 0, 0,
                                      sel);
        }
      } else {
        {
#line 1056
        rxvt_selection_request(r, (int )r->tabBar.atab, ev->xkey.time, 0, 0);
        }
      }
    } else {
      {
#line 1056
      rxvt_selection_request(r, (int )r->tabBar.atab, ev->xkey.time, 0, 0);
      }
    }
  } else {
#line 1060
    retval = -1;
  }
#line 1062
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1067
  if ((unsigned long )((void *)0) != (unsigned long )ev) {
#line 1069
    if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 1069
      if (*astr) {
        {
#line 1070
        rxvt_paste_file(r, (int )r->tabBar.atab, ev->xkey.time, 0, 0, astr);
        }
      } else {
#line 1072
        goto switch_break;
      }
    } else {
#line 1072
      goto switch_break;
    }
  } else {
#line 1075
    retval = -1;
  }
#line 1077
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1082
  if ((unsigned long )((void *)0) != (unsigned long )ev) {
#line 1084
    if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 1084
      if (*astr) {
        {
#line 1086
        doit = (short)0;
#line 1089
        tmp___18 = strcmp("ACTIVITY", (char const   *)astr);
        }
#line 1089
        if (tmp___18 == 0) {
#line 1091
          if ((int )(r->vts[r->tabBar.atab])->monitor_tab == 1) {
#line 1091
            (r->vts[r->tabBar.atab])->monitor_tab = (short)0;
          } else {
#line 1091
            (r->vts[r->tabBar.atab])->monitor_tab = (short)1;
          }
          {
#line 1093
          doit = (short)1;
#line 1094
          rxvt_msg((uint32_t )3, (uint32_t )64, "Macro %s ACTIVITY : activity monitoring request on tab %i.",
                   macroNames[action->type], (int )(r->vts[r->tabBar.atab])->vts_idx);
          }
        } else {
          {
#line 1097
          tmp___17 = strcmp("INACTIVITY", (char const   *)astr);
          }
#line 1097
          if (tmp___17 == 0) {
#line 1099
            if ((int )(r->vts[r->tabBar.atab])->monitor_tab == 2) {
#line 1099
              (r->vts[r->tabBar.atab])->monitor_tab = (short)0;
            } else {
#line 1099
              (r->vts[r->tabBar.atab])->monitor_tab = (short)2;
            }
            {
#line 1101
            doit = (short)1;
#line 1102
            rxvt_msg((uint32_t )3, (uint32_t )64, "Macro %s INACTIVITY : inactivity monitoring request on tab %i.",
                     macroNames[action->type], (int )(r->vts[r->tabBar.atab])->vts_idx);
            }
          } else {
            {
#line 1105
            tmp___16 = strcmp("AUTO", (char const   *)astr);
            }
#line 1105
            if (tmp___16 == 0) {
#line 1107
              if ((int )(r->vts[r->tabBar.atab])->monitor_tab == 3) {
#line 1107
                (r->vts[r->tabBar.atab])->monitor_tab = (short)0;
              } else {
#line 1107
                (r->vts[r->tabBar.atab])->monitor_tab = (short)3;
              }
              {
#line 1109
              doit = (short)1;
#line 1110
              rxvt_msg((uint32_t )3, (uint32_t )64, "Macro %s AUTO : request for automatic (in-)activity monitoring on tab %i.",
                       macroNames[action->type], (int )(r->vts[r->tabBar.atab])->vts_idx);
              }
            } else {
              {
#line 1116
              rxvt_msg((uint32_t )3, (uint32_t )64, "Macro %s requires argument or invalid argument provided.",
                       macroNames[action->type]);
              }
#line 1118
              goto switch_break;
            }
          }
        }
#line 1121
        if ((int )doit != 0) {
#line 1123
          if ((int )(r->vts[r->tabBar.atab])->monitor_tab == 0) {
            {
#line 1125
            rxvt_msg((uint32_t )3, (uint32_t )64, "Macro %s was already active, deactivating previous macro call.",
                     macroNames[action->type]);
            }
          } else {
            {
#line 1129
            (r->vts[r->tabBar.atab])->monitor_nbytes_read = 0;
#line 1130
            gettimeofday((struct timeval */* __restrict  */)(& (r->vts[r->tabBar.atab])->monitor_start),
                         (__timezone_ptr_t )((void *)0));
            }
          }
        }
      }
    }
  } else {
#line 1137
    retval = -1;
  }
#line 1139
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1143
  rxvt_toggle_subwin(r, (unsigned char const   *)((unsigned char *)astr));
  }
#line 1144
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1148
  MaxFontLen = 8;
#line 1150
  __lengthoffontname = (unsigned long )MaxFontLen;
#line 1150
  tmp___19 = __builtin_alloca(sizeof(*fontname) * __lengthoffontname);
#line 1150
  fontname = (char *)tmp___19;
  }
#line 1151
  if (alen >= MaxFontLen - 1) {
#line 1151
    goto switch_break;
  }
  {
#line 1156
  *(fontname + 0) = (char )'#';
#line 1157
  strncpy((char */* __restrict  */)(fontname + 1), (char const   */* __restrict  */)((char const   *)astr),
          (size_t )(MaxFontLen - 1));
#line 1158
  *(fontname + (MaxFontLen - 1)) = (char )'\000';
#line 1160
  rxvt_resize_on_font(r, fontname);
  }
#line 1161
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1165
  r->Options[((1UL << 18) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] ^ (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL));
#line 1167
  rxvt_scr_touch(r, (int )r->tabBar.atab, 1);
  }
#line 1168
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 1171
  r->Options[((1UL << 19) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 19) | 1UL) & 3UL] ^ (((1UL << 19) | 1UL) & 0xfffffffffffffffcUL));
#line 1173
  rxvt_scr_touch(r, (int )r->tabBar.atab, 1);
  }
#line 1174
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1177
  r->Options[((1UL << 20) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 20) | 1UL) & 3UL] ^ (((1UL << 20) | 1UL) & 0xfffffffffffffffcUL));
#line 1179
  rxvt_scr_touch(r, (int )r->tabBar.atab, 1);
  }
#line 1180
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 1184
  rxvt_toggle_transparency(r);
  }
#line 1188
  goto switch_break;
  case_19: /* CIL Label */ 
#line 1191
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 1191
    if (*astr) {
      {
#line 1193
      tmp___20 = strtol((char const   */* __restrict  */)astr, (char **/* __restrict  */)((void *)0),
                        0);
#line 1193
      state = tmp___20;
      }
      {
#line 1197
      if (state == 1L) {
#line 1197
        goto case_1___0;
      }
#line 1201
      if (state == 0L) {
#line 1201
        goto case_0;
      }
#line 1205
      if (state == -1L) {
#line 1205
        goto case_neg_1;
      }
#line 1209
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 1198
      r->Options[((1UL << 16) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 16) | 1UL) & 3UL] | (((1UL << 16) | 1UL) & 0xfffffffffffffffcUL));
#line 1199
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 1202
      r->Options[((1UL << 16) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 16) | 1UL) & 3UL] & ~ (((1UL << 16) | 1UL) & 0xfffffffffffffffcUL));
#line 1203
      goto switch_break___0;
      case_neg_1: /* CIL Label */ 
#line 1206
      r->Options[((1UL << 16) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 16) | 1UL) & 3UL] ^ (((1UL << 16) | 1UL) & 0xfffffffffffffffcUL));
#line 1207
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 1210
      rxvt_msg((uint32_t )1, (uint32_t )64, "Badly formed argument \'%s\' to %s\n",
               astr, macroNames[action->type]);
#line 1213
      retval = -1;
      }
#line 1214
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 1218
      r->Options[((1UL << 16) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 16) | 1UL) & 3UL] ^ (((1UL << 16) | 1UL) & 0xfffffffffffffffcUL));
    }
  } else {
#line 1218
    r->Options[((1UL << 16) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 16) | 1UL) & 3UL] ^ (((1UL << 16) | 1UL) & 0xfffffffffffffffcUL));
  }
#line 1219
  goto switch_break;
  case_20: /* CIL Label */ 
#line 1222
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
#line 1222
    if (*astr) {
      {
#line 1225
      tmp___21 = astr;
#line 1225
      astr ++;
#line 1225
      op = *tmp___21;
#line 1228
      holdMask = strtoul((char const   */* __restrict  */)astr, (char **/* __restrict  */)((void *)0),
                         0);
      }
      {
#line 1231
      if ((int )op == 43) {
#line 1231
        goto case_43;
      }
#line 1235
      if ((int )op == 45) {
#line 1235
        goto case_45;
      }
#line 1239
      if ((int )op == 33) {
#line 1239
        goto case_33;
      }
#line 1243
      goto switch_default___0;
      case_43: /* CIL Label */ 
#line 1232
      (r->vts[r->tabBar.atab])->holdOption = (unsigned char )((unsigned long )(r->vts[r->tabBar.atab])->holdOption | holdMask);
#line 1233
      goto switch_break___1;
      case_45: /* CIL Label */ 
#line 1236
      (r->vts[r->tabBar.atab])->holdOption = (unsigned char )((unsigned long )(r->vts[r->tabBar.atab])->holdOption & ~ holdMask);
#line 1237
      goto switch_break___1;
      case_33: /* CIL Label */ 
#line 1240
      (r->vts[r->tabBar.atab])->holdOption = (unsigned char )((unsigned long )(r->vts[r->tabBar.atab])->holdOption ^ holdMask);
#line 1241
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 1244
      rxvt_msg((uint32_t )1, (uint32_t )64, "Badly formed argument \'%s\' to %s\n",
               astr, macroNames[action->type]);
#line 1246
      retval = -1;
      }
#line 1247
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 1251
      if ((r->vts[r->tabBar.atab])->dead) {
#line 1251
        if ((int )(r->vts[r->tabBar.atab])->hold > 1) {
#line 1251
          if (! (1U & (unsigned int )(r->vts[r->tabBar.atab])->holdOption)) {
#line 1251
            if ((1U << 1) & (unsigned int )(r->vts[r->tabBar.atab])->holdOption) {
#line 1251
              __constr_expr_0.__in = (r->vts[r->tabBar.atab])->status;
#line 1251
              if ((__constr_expr_0.__i & 127) == 0) {
#line 1251
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 1251
            if ((1U << 2) & (unsigned int )(r->vts[r->tabBar.atab])->holdOption) {
#line 1251
              __constr_expr_1.__in = (r->vts[r->tabBar.atab])->status;
#line 1251
              if (! ((__constr_expr_1.__i & 65280) >> 8 != 0)) {
                {
#line 1255
                rxvt_remove_page(r, r->tabBar.atab);
                }
              }
            } else {
              {
#line 1255
              rxvt_remove_page(r, r->tabBar.atab);
              }
            }
          }
        }
      }
    } else {
#line 1222
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 1266
    k = (int )r->tabBar.ltab;
    {
#line 1266
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1266
      if (! (k >= 0)) {
#line 1266
        goto while_break___2;
      }
#line 1267
      if ((r->vts[k])->dead) {
#line 1267
        if ((int )(r->vts[k])->hold > 1) {
          {
#line 1268
          rxvt_remove_page(r, (short )k);
          }
        }
      }
#line 1266
      k --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1271
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 1274
  tmp___22 = XInternAtom(r->Xdisplay, "_NET_WM_STATE_FULLSCREEN", 1);
#line 1274
  tmp___23 = XInternAtom(r->Xdisplay, "_NET_WM_STATE", 1);
#line 1274
  ewmh_message(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
               r->TermWin.parent, tmp___23, 2L, (long )tmp___22, 0L, 0L, 0L);
  }
#line 1279
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1282
  tmp___24 = XInternAtom(r->Xdisplay, "_NET_ACTIVE_WINDOW", 1);
#line 1282
  ewmh_message(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
               r->TermWin.parent, tmp___24, 1L, 0L, (long )r->TermWin.parent, 0L,
               0L);
  }
#line 1285
  goto switch_break;
  case_23: /* CIL Label */ 
#line 1289
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
    {
#line 1290
    rxvt_tabbar_set_title(r, r->tabBar.atab, (unsigned char const   *)((unsigned char *)astr));
    }
  } else
#line 1292
  if ((unsigned long )((void *)0) != (unsigned long )r->selection.text) {
    {
#line 1293
    rxvt_tabbar_set_title(r, r->tabBar.atab, (unsigned char const   *)r->selection.text);
    }
  } else {
#line 1296
    retval = -1;
  }
#line 1297
  goto switch_break;
  case_24: /* CIL Label */ 
#line 1301
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
    {
#line 1303
    tmp___25 = strtol((char const   */* __restrict  */)astr, (char **/* __restrict  */)((void *)0),
                      0);
#line 1303
    state___0 = (int )tmp___25;
    }
#line 1305
    if (state___0 == -1) {
#line 1306
      if ((unsigned long )r->Options[(1UL << 29) & 3UL] & ((1UL << 29) & 0xfffffffffffffffcUL)) {
#line 1306
        state___0 = 0;
      } else {
#line 1306
        state___0 = 1;
      }
    }
#line 1308
    if (state___0 == 1) {
#line 1308
      if (! ((unsigned long )r->Options[(1UL << 29) & 3UL] & ((1UL << 29) & 0xfffffffffffffffcUL))) {
        {
#line 1310
        r->Options[(1UL << 29) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 29) & 3UL] | ((1UL << 29) & 0xfffffffffffffffcUL));
#line 1311
        rxvt_init_fifo(r);
        }
      } else {
#line 1308
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1314
    if (state___0 == 0) {
#line 1314
      if ((unsigned long )r->Options[(1UL << 29) & 3UL] & ((1UL << 29) & 0xfffffffffffffffcUL)) {
#line 1316
        if (r->fifo_fd != -1) {
          {
#line 1318
          close(r->fifo_fd);
          }
#line 1319
          if (r->num_fds == r->fifo_fd + 1) {
            {
#line 1320
            rxvt_adjust_fd_number(r);
            }
          }
          {
#line 1322
          r->fifo_fd = -1;
#line 1323
          unlink((char const   *)r->fifo_name);
          }
        }
#line 1325
        r->Options[(1UL << 29) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 29) & 3UL] & ~ ((1UL << 29) & 0xfffffffffffffffcUL));
      }
    }
  }
#line 1328
  goto switch_break;
  case_25: /* CIL Label */ 
#line 1342
  s = astr;
#line 1343
  pretty = 0;
#line 1343
  scrollback = 0;
#line 1343
  linecont = 1;
#line 1348
  if (*s) {
#line 1348
    if ((int )*s == 45) {
      {
#line 1350
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1350
        s ++;
#line 1350
        if (*s) {
          {
#line 1350
          tmp___26 = __ctype_b_loc();
          }
#line 1350
          if ((int const   )*(*tmp___26 + (int )*s) & 8192) {
#line 1350
            goto while_break___3;
          }
        } else {
#line 1350
          goto while_break___3;
        }
        {
#line 1354
        if ((int )*s == 115) {
#line 1354
          goto case_115;
        }
#line 1355
        if ((int )*s == 112) {
#line 1355
          goto case_112;
        }
#line 1356
        if ((int )*s == 110) {
#line 1356
          goto case_110;
        }
#line 1357
        goto switch_default___1;
        case_115: /* CIL Label */ 
#line 1354
        scrollback = 1;
#line 1354
        goto switch_break___2;
        case_112: /* CIL Label */ 
#line 1355
        pretty = 1;
#line 1355
        goto switch_break___2;
        case_110: /* CIL Label */ 
#line 1356
        linecont = 0;
#line 1356
        goto switch_break___2;
        switch_default___1: /* CIL Label */ 
        {
#line 1358
        rxvt_msg((uint32_t )1, (uint32_t )64, "Bad option %c to macro %s", (int )*s,
                 macroNames[action->type]);
#line 1360
        retval = -1;
        }
        switch_break___2: /* CIL Label */ ;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1364
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1364
        tmp___27 = __ctype_b_loc();
        }
#line 1364
        if (! ((int const   )*(*tmp___27 + (int )*s) & 8192)) {
#line 1364
          goto while_break___4;
        }
#line 1364
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1367
  if (*s) {
#line 1367
    tmp___28 = s;
  } else {
#line 1367
    tmp___28 = (char *)((void *)0);
  }
  {
#line 1367
  rxvt_scr_printscreen(r, (int )r->tabBar.atab, scrollback, pretty, linecont, (char const   *)tmp___28);
  }
#line 1370
  goto switch_break;
  case_26: /* CIL Label */ 
#line 1375
  cfile[0] = (char )'\000';
#line 1375
  tmp___29 = 1U;
  {
#line 1375
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1375
    if (tmp___29 >= 4096U) {
#line 1375
      goto while_break___5;
    }
#line 1375
    cfile[tmp___29] = (char)0;
#line 1375
    tmp___29 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1377
  if ((unsigned long )((void *)0) != (unsigned long )astr) {
    {
#line 1378
    strncpy((char */* __restrict  */)(cfile), (char const   */* __restrict  */)((char const   *)astr),
            (size_t )4095);
    }
  } else {
    {
#line 1381
    tmp___30 = getenv("HOME");
#line 1381
    home = tmp___30;
    }
#line 1383
    if ((unsigned long )((void *)0) == (unsigned long )home) {
#line 1383
      return (-1);
    }
    {
#line 1385
    snprintf((char */* __restrict  */)(cfile), (size_t )4095, (char const   */* __restrict  */)"%s/%s",
             home, ".mrxvtrc.save");
    }
  }
  {
#line 1388
  cfile[4095] = (char)0;
#line 1390
  tmp___32 = rxvt_save_options(r, (char const   *)(cfile));
  }
#line 1390
  if (tmp___32) {
#line 1390
    retval = 1;
  } else {
#line 1390
    retval = -1;
  }
#line 1391
  goto switch_break;
  case_27: /* CIL Label */ 
#line 1395
  r->Options[((1UL << 22) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 22) | 1UL) & 3UL] ^ (((1UL << 22) | 1UL) & 0xfffffffffffffffcUL));
#line 1396
  goto switch_break;
  switch_default___2: /* CIL Label */ 
  {
#line 1401
  rxvt_msg((uint32_t )1, (uint32_t )64, "Support for macro type \'%s\' not compiled.",
           macroNames[action->type]);
#line 1403
  retval = -1;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1406
  return (retval);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 2354 "/usr/include/X11/Xlib.h"
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 193 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
char *rxvt_r_basename(char const   *str ) ;
#line 195
char const   *rxvt_str_skip_space(char const   *str ) ;
#line 199
char **rxvt_splitcommastring(char const   *cs ) ;
#line 201
void rxvt_draw_shadow(Display *Xdisplay , Window win , GC gc , unsigned long topShadow ,
                      unsigned long botShadow , int x , int y , int w , int h ) ;
#line 32 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
char *rxvt_r_basename(char const   *str ) 
{ 
  char *base ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 35
  tmp = strrchr(str, '/');
#line 35
  base = tmp;
  }
#line 37
  if (base) {
#line 37
    tmp___0 = (char const   *)(base + 1);
  } else {
#line 37
    tmp___0 = str;
  }
#line 37
  return ((char *)tmp___0);
}
}
#line 50 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
int rxvt_str_match(char const   *s1 , char const   *s2 ) 
{ 
  int n ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 53
  if ((unsigned long )((void *)0) == (unsigned long )s1) {
#line 54
    return (0);
  } else
#line 53
  if ((unsigned long )((void *)0) == (unsigned long )s2) {
#line 54
    return (0);
  } else {
    {
#line 57
    tmp = strlen(s2);
#line 57
    n = (int )tmp;
#line 59
    tmp___2 = strncmp(s1, s2, (size_t )n);
    }
#line 59
    if (tmp___2 == 0) {
#line 59
      tmp___1 = n;
    } else {
#line 59
      tmp___1 = 0;
    }
#line 59
    return (tmp___1);
  }
}
}
#line 65 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
char const   *rxvt_str_skip_space(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
#line 68
  if (str) {
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      if (*str) {
        {
#line 69
        tmp = __ctype_b_loc();
        }
#line 69
        if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 69
          goto while_break;
        }
      } else {
#line 69
        goto while_break;
      }
#line 70
      str ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 71
  return (str);
}
}
#line 80 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
char *rxvt_str_trim(char *str ) 
{ 
  char *r ;
  char *s ;
  int n ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 86
  if (! str) {
#line 87
    return (str);
  } else
#line 86
  if (! *str) {
#line 87
    return (str);
  }
#line 90
  s = str;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (*s) {
      {
#line 90
      tmp = __ctype_b_loc();
      }
#line 90
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 90
        goto while_break;
      }
    } else {
#line 90
      goto while_break;
    }
#line 90
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  n = 0;
#line 93
  r = s;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    tmp___0 = r;
#line 93
    r ++;
#line 93
    if (! *tmp___0) {
#line 93
      goto while_break___0;
    }
#line 93
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  r -= 2;
#line 97
  if (n > 0) {
#line 97
    if ((int )*r == 10) {
#line 98
      n --;
#line 98
      r --;
    }
  }
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (n > 0) {
      {
#line 100
      tmp___1 = __ctype_b_loc();
      }
#line 100
      if (! ((int const   )*(*tmp___1 + (int )*r) & 8192)) {
#line 100
        goto while_break___1;
      }
    } else {
#line 100
      goto while_break___1;
    }
#line 100
    r --;
#line 100
    n --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 103
  if ((int )*s == 34) {
#line 103
    if ((int )*r == 34) {
#line 103
      if (n > 1) {
#line 105
        s ++;
#line 106
        n -= 2;
      }
    }
  }
#line 109
  r = str;
  {
#line 109
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 109
    if (! n) {
#line 109
      goto while_break___2;
    }
#line 110
    tmp___2 = r;
#line 110
    r ++;
#line 110
    tmp___3 = s;
#line 110
    s ++;
#line 110
    *tmp___2 = *tmp___3;
#line 109
    n --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 111
  *r = (char )'\000';
#line 113
  return (str);
}
}
#line 126 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
int rxvt_str_escaped(char *str ) 
{ 
  char ch ;
  char *s ;
  char *d ;
  int i ;
  int num ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 132
  if ((unsigned long )((void *)0) == (unsigned long )str) {
#line 132
    return (0);
  } else
#line 132
  if ((int )*str == 0) {
#line 132
    return (0);
  }
#line 134
  s = str;
#line 134
  d = s;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    tmp___7 = s;
#line 159
    s ++;
#line 159
    ch = *tmp___7;
#line 159
    if (! ch) {
#line 159
      goto while_break;
    }
#line 161
    if ((int )ch == 92) {
#line 163
      tmp = s;
#line 163
      s ++;
#line 163
      ch = *tmp;
#line 164
      if ((int )ch >= 48) {
#line 164
        if ((int )ch <= 55) {
#line 166
          num = (int )ch - 48;
#line 167
          i = 0;
          {
#line 167
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 167
            if (! (i < 2)) {
#line 167
              goto while_break___0;
            }
#line 169
            ch = *s;
#line 170
            if ((int )ch < 48) {
#line 171
              goto while_break___0;
            } else
#line 170
            if ((int )ch > 55) {
#line 171
              goto while_break___0;
            }
#line 172
            num = (num * 8 + (int )ch) - 48;
#line 167
            i ++;
#line 167
            s ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 174
          ch = (char )num;
        } else {
#line 164
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 176
      if ((int )ch == 97) {
#line 177
        ch = (char)7;
      } else
#line 178
      if ((int )ch == 98) {
#line 179
        ch = (char)8;
      } else
#line 180
      if ((int )ch == 69) {
#line 181
        ch = (char)27;
      } else
#line 180
      if ((int )ch == 101) {
#line 181
        ch = (char)27;
      } else
#line 182
      if ((int )ch == 110) {
#line 183
        ch = (char )'\n';
      } else
#line 184
      if ((int )ch == 114) {
#line 185
        ch = (char )'\r';
      } else
#line 186
      if ((int )ch == 116) {
#line 187
        ch = (char)9;
      } else
#line 189
      if ((int )ch != 92) {
#line 189
        if ((int )ch != 94) {
#line 190
          tmp___0 = d;
#line 190
          d ++;
#line 190
          *tmp___0 = (char )'\\';
        }
      }
    } else
#line 193
    if ((int )ch == 94) {
#line 195
      tmp___1 = s;
#line 195
      s ++;
#line 195
      ch = *tmp___1;
#line 197
      if ((int )ch == 63) {
#line 198
        ch = (char)127;
      } else {
        {
#line 199
        tmp___4 = toupper((int )ch);
        }
#line 199
        if (tmp___4 >= 65) {
          {
#line 199
          tmp___5 = toupper((int )ch);
          }
#line 199
          if (tmp___5 <= 90) {
            {
#line 200
            tmp___2 = toupper((int )ch);
#line 200
            ch = (char )(tmp___2 - 64);
            }
          } else {
#line 202
            tmp___3 = d;
#line 202
            d ++;
#line 202
            *tmp___3 = (char )'^';
          }
        } else {
#line 202
          tmp___3 = d;
#line 202
          d ++;
#line 202
          *tmp___3 = (char )'^';
        }
      }
    }
#line 205
    tmp___6 = d;
#line 205
    d ++;
#line 205
    *tmp___6 = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  *d = (char )'\000';
#line 219
  return ((int )(d - str));
}
}
#line 227 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
int rxvt_percent_interpolate(rxvt_t *r , int page , char const   *src , int len ,
                             char *dst , int maxLen ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  union __anonunion_376___0 __constr_expr_2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  union __anonunion_378 __constr_expr_4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  __pid_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 231
  i = 0;
#line 231
  j = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (i < len - 1) {
#line 240
      if (! (j < maxLen - 1)) {
#line 240
        goto while_break;
      }
    } else {
#line 240
      goto while_break;
    }
#line 242
    if ((int const   )*(src + i) == 37) {
#line 244
      i ++;
      {
#line 246
      if ((int const   )*(src + i) == 37) {
#line 246
        goto case_37;
      }
#line 251
      if ((int const   )*(src + i) == 110) {
#line 251
        goto case_110;
      }
#line 257
      if ((int const   )*(src + i) == 116) {
#line 257
        goto case_116;
      }
#line 264
      if ((int const   )*(src + i) == 83) {
#line 264
        goto case_83;
      }
#line 275
      if ((int const   )*(src + i) == 78) {
#line 275
        goto case_78;
      }
#line 287
      if ((int const   )*(src + i) == 115) {
#line 287
        goto case_115;
      }
#line 298
      if ((int const   )*(src + i) == 112) {
#line 298
        goto case_112;
      }
#line 305
      if ((int const   )*(src + i) == 80) {
#line 305
        goto case_80;
      }
#line 311
      if ((int const   )*(src + i) == 71) {
#line 311
        goto case_71;
      }
#line 318
      if ((int const   )*(src + i) == 84) {
#line 318
        goto case_84;
      }
#line 325
      goto switch_default;
      case_37: /* CIL Label */ 
#line 248
      tmp = j;
#line 248
      j ++;
#line 248
      tmp___0 = i;
#line 248
      i ++;
#line 248
      *(dst + tmp) = (char )*(src + tmp___0);
#line 249
      goto switch_break;
      case_110: /* CIL Label */ 
      {
#line 253
      tmp___1 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                         (char const   */* __restrict  */)"%d", page + 1);
#line 253
      j += tmp___1;
#line 254
      i ++;
      }
#line 255
      goto switch_break;
      case_116: /* CIL Label */ 
      {
#line 259
      tmp___2 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                         (char const   */* __restrict  */)"%s", (r->vts[page])->tab_title);
#line 259
      j += tmp___2;
#line 261
      i ++;
      }
#line 262
      goto switch_break;
      case_83: /* CIL Label */ 
#line 266
      if ((r->vts[page])->dead) {
        {
#line 267
        __constr_expr_2.__in = (r->vts[page])->status;
#line 267
        tmp___3 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                           (char const   */* __restrict  */)"%d", (__constr_expr_2.__i & 65280) >> 8);
#line 267
        j += tmp___3;
        }
      } else {
#line 270
        tmp___4 = j;
#line 270
        j ++;
#line 270
        *(dst + tmp___4) = (char )*(src + i);
      }
#line 272
      i ++;
#line 273
      goto switch_break;
      case_78: /* CIL Label */ 
#line 277
      if ((r->vts[page])->dead) {
#line 278
        __constr_expr_4.__in = (r->vts[page])->status;
#line 278
        if ((__constr_expr_4.__i & 127) == 0) {
#line 278
          tmp___5 = "normally";
        } else {
#line 278
          tmp___5 = "abnormally";
        }
        {
#line 278
        tmp___6 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                           (char const   */* __restrict  */)"%s", tmp___5);
#line 278
        j += tmp___6;
        }
      } else {
#line 282
        tmp___7 = j;
#line 282
        j ++;
#line 282
        *(dst + tmp___7) = (char )*(src + i);
      }
#line 284
      i ++;
#line 285
      goto switch_break;
      case_115: /* CIL Label */ 
#line 292
      if ((unsigned long )((void *)0) != (unsigned long )r->selection.text) {
        {
#line 293
        tmp___8 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                           (char const   */* __restrict  */)"%s", r->selection.text);
#line 293
        j += tmp___8;
        }
      }
#line 295
      i ++;
#line 296
      goto switch_break;
      case_112: /* CIL Label */ 
      {
#line 300
      tmp___9 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                         (char const   */* __restrict  */)"%d", (r->vts[page])->cmd_pid);
#line 300
      j += tmp___9;
#line 302
      i ++;
      }
#line 303
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 307
      tmp___10 = getpid();
#line 307
      tmp___11 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                          (char const   */* __restrict  */)"%d", tmp___10);
#line 307
      j += tmp___11;
#line 308
      i ++;
      }
#line 309
      goto switch_break;
      case_71: /* CIL Label */ 
      {
#line 313
      tmp___12 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                          (char const   */* __restrict  */)"%d", (r->vts[page])->globalTabNum + 1);
#line 313
      j += tmp___12;
#line 315
      i ++;
      }
#line 316
      goto switch_break;
      case_84: /* CIL Label */ 
      {
#line 320
      tmp___13 = snprintf((char */* __restrict  */)(dst + j), (size_t )(maxLen - j),
                          (char const   */* __restrict  */)"%d", r->ntabs + 1);
#line 320
      j += tmp___13;
#line 322
      i ++;
      }
#line 323
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 326
      tmp___14 = i;
#line 326
      i ++;
#line 326
      rxvt_msg((uint32_t )1, (uint32_t )1048576, "Unrecognized flag %%%c in \'%s\'",
               (int const   )*(src + tmp___14), src);
      }
#line 327
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 331
      tmp___15 = j;
#line 331
      j ++;
#line 331
      tmp___16 = i;
#line 331
      i ++;
#line 331
      *(dst + tmp___15) = (char )*(src + tmp___16);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  if (i == len - 1) {
#line 335
    if (j < maxLen - 1) {
#line 336
      tmp___17 = j;
#line 336
      j ++;
#line 336
      tmp___18 = i;
#line 336
      i ++;
#line 336
      *(dst + tmp___17) = (char )*(src + tmp___18);
    }
  }
#line 339
  if (j > maxLen - 1) {
#line 340
    j = maxLen - 1;
  }
#line 341
  if (j == 0) {
#line 342
    tmp___19 = j;
#line 342
    j ++;
#line 342
    *(dst + tmp___19) = (char)0;
  } else
#line 341
  if (*(dst + (j - 1))) {
#line 342
    tmp___19 = j;
#line 342
    j ++;
#line 342
    *(dst + tmp___19) = (char)0;
  }
#line 345
  return (j);
}
}
#line 355 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
char **rxvt_splitcommastring(char const   *cs ) 
{ 
  int l ;
  int n ;
  int p ;
  char const   *s ;
  char const   *t ;
  char **ret ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 362
  s = cs;
#line 362
  if ((unsigned long )((void *)0) == (unsigned long )s) {
#line 363
    s = "";
  }
#line 365
  n = 1;
#line 365
  t = s;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! *t) {
#line 365
      goto while_break;
    }
#line 366
    if ((int const   )*t == 44) {
#line 367
      n ++;
    }
#line 365
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  tmp = rxvt_malloc((unsigned long )(n + 1) * sizeof(char *));
#line 371
  ret = (char **)tmp;
#line 372
  *(ret + n) = (char *)((void *)0);
#line 374
  l = 0;
#line 374
  t = s;
  }
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 374
    if (! (l < n)) {
#line 374
      goto while_break___0;
    }
    {
#line 376
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 376
      if (*t) {
#line 376
        if (! ((int const   )*t != 44)) {
#line 376
          goto while_break___1;
        }
      } else {
#line 376
        goto while_break___1;
      }
#line 376
      t ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 377
    p = (int )(t - s);
#line 379
    tmp___0 = rxvt_malloc((size_t )(p + 1));
#line 379
    *(ret + l) = (char *)tmp___0;
#line 380
    strncpy((char */* __restrict  */)*(ret + l), (char const   */* __restrict  */)s,
            (size_t )p);
#line 381
    *(*(ret + l) + p) = (char )'\000';
#line 382
    rxvt_str_trim(*(ret + l));
#line 383
    t ++;
#line 383
    s = t;
#line 374
    l ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 385
  return (ret);
}
}
#line 542 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/misc.c"
void rxvt_draw_shadow(Display *Xdisplay , Window win , GC gc , unsigned long topShadow ,
                      unsigned long botShadow , int x , int y , int w , int h ) 
{ 
  int shadow ;
  int tmp ;

  {
#line 547
  if (w == 0) {
#line 547
    shadow = 1;
  } else
#line 547
  if (h == 0) {
#line 547
    shadow = 1;
  } else {
#line 547
    shadow = 1;
  }
#line 548
  w += x - 1;
#line 549
  h += y - 1;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    tmp = shadow;
#line 550
    shadow --;
#line 550
    if (! (tmp > 0)) {
#line 550
      goto while_break;
    }
    {
#line 552
    XSetForeground(Xdisplay, gc, topShadow);
#line 553
    XDrawLine(Xdisplay, win, gc, x, y, w, y);
#line 554
    XDrawLine(Xdisplay, win, gc, x, y, x, h);
#line 556
    XSetForeground(Xdisplay, gc, botShadow);
#line 557
    XDrawLine(Xdisplay, win, gc, w, h, w, y + 1);
#line 558
    XDrawLine(Xdisplay, win, gc, w, h, x + 1, h);
#line 550
    x ++;
#line 550
    y ++;
#line 550
    w --;
#line 550
    h --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 130 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void *rxvt_calloc(size_t number , size_t size ) ;
#line 30 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtmem.c"
static char const   *abort_msg  =    "mrxvt: memory allocation failure.  Aborting";
#line 668 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtmem.c"
void *rxvt_malloc(size_t size ) 
{ 
  void *p ;

  {
#line 674
  if (0UL == size) {
#line 675
    size = (size_t )1;
  }
  {
#line 677
  p = malloc(size);
  }
#line 678
  if (p) {
#line 679
    return (p);
  }
  {
#line 681
  rxvt_msg((uint32_t )0, (uint32_t )32768, abort_msg);
#line 682
  exit(1);
  }
}
}
#line 688 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtmem.c"
void *rxvt_calloc(size_t number , size_t size ) 
{ 
  void *p ;

  {
  {
#line 693
  p = calloc(number, size);
  }
#line 694
  if (p) {
#line 695
    return (p);
  }
  {
#line 697
  rxvt_msg((uint32_t )0, (uint32_t )32768, abort_msg);
#line 698
  exit(1);
  }
}
}
#line 704 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtmem.c"
void *rxvt_realloc(void *ptr , size_t size ) 
{ 
  void *p ;

  {
#line 709
  if (ptr) {
    {
#line 710
    p = realloc(ptr, size);
    }
  } else {
    {
#line 712
    p = malloc(size);
    }
  }
#line 713
  if (p) {
#line 714
    return (p);
  }
  {
#line 716
  rxvt_msg((uint32_t )0, (uint32_t )32768, abort_msg);
#line 717
  exit(1);
  }
}
}
#line 723 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtmem.c"
void rxvt_free(void *ptr ) 
{ 


  {
  {
#line 729
  free(ptr);
  }
#line 730
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 1644 "/usr/include/X11/Xlib.h"
extern Window XGetSelectionOwner(Display * , Atom  ) ;
#line 2022
extern int XBell(Display * , int  ) ;
#line 2050
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2187
extern int XConvertSelection(Display * , Atom  , Atom  , Atom  , Window  , Time  ) ;
#line 2196
extern int XCopyArea(Display * , Drawable  , Drawable  , GC  , int  , int  , unsigned int  ,
                     unsigned int  , int  , int  ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2334
extern int XDrawImageString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                            int  ) ;
#line 2344
extern int XDrawImageString16(Display * , Drawable  , GC  , int  , int  , XChar2b const   * ,
                              int  ) ;
#line 2390
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2426
extern int XDrawString16(Display * , Drawable  , GC  , int  , int  , XChar2b const   * ,
                         int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2528
extern int XFree(void * ) ;
#line 2625
extern int XGetGCValues(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3172
extern int XSetClipMask(Display * , GC  , Pixmap  ) ;
#line 3221
extern int XSetFillStyle(Display * , GC  , int  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 403 "/usr/include/X11/Xutil.h"
extern int XDestroyRegion(Region  ) ;
#line 708
extern int XSetRegion(Display * , GC  , Region  ) ;
#line 31 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
FILE *rxvt_popen_printer(rxvt_t *r , char const   *pipeName ) ;
#line 32
int rxvt_pclose_printer(FILE *stream ) ;
#line 34
void rxvt_tt_printf(rxvt_t *r , int page , char const   *fmt  , ...) ;
#line 95
int rxvt_set_vt_colors(rxvt_t *r , int page ) ;
#line 145
void rxvt_tt_winsize(int fd , unsigned short col , unsigned short row , pid_t pid ) ;
#line 221
void rxvt_draw_string_x11(rxvt_t *r , Window win , GC gc , Region refreshRegion ,
                          int x , int y , char *str , int len , int (*draw_string___0)() ) ;
#line 231
void rxvt_init_screen(rxvt_t *r ) ;
#line 232
void rxvt_scr_reset(rxvt_t *r , int page ) ;
#line 233
void rxvt_scr_release(rxvt_t *r , int page ) ;
#line 234
void rxvt_scr_poweron(rxvt_t *r , int page ) ;
#line 235
void rxvt_scr_cursor(rxvt_t *r , int page , int mode ) ;
#line 236
int rxvt_scr_change_screen(rxvt_t *r , int page , int scrn ) ;
#line 237
void rxvt_scr_color(rxvt_t *r , int page , unsigned int color , int fgbg ) ;
#line 238
void rxvt_scr_rendition(rxvt_t *r , int page , int set , int style ) ;
#line 239
int rxvt_scroll_text(rxvt_t *r , int page , int row1 , int row2 , int count , int spec ) ;
#line 240
void rxvt_scr_add_lines(rxvt_t *r , int page , unsigned char const   *str , int nlines ,
                        int len ) ;
#line 241
void rxvt_scr_backspace(rxvt_t *r , int page ) ;
#line 242
void rxvt_scr_tab(rxvt_t *r , int page , int count ) ;
#line 243
void rxvt_scr_backindex(rxvt_t *r , int page ) ;
#line 244
void rxvt_scr_forwardindex(rxvt_t *r , int page ) ;
#line 245
void rxvt_scr_gotorc(rxvt_t *r , int page , int row , int col , int relative ) ;
#line 246
void rxvt_scr_index(rxvt_t *r , int page , enum page_dirn direction ) ;
#line 247
void rxvt_scr_erase_line(rxvt_t *r , int page , int mode ) ;
#line 248
void rxvt_scr_erase_screen(rxvt_t *r , int page , int mode ) ;
#line 249
void rxvt_scr_E(rxvt_t *r , int page ) ;
#line 250
void rxvt_scr_insdel_lines(rxvt_t *r , int page , int count , int insdel ) ;
#line 251
void rxvt_scr_insdel_chars(rxvt_t *r , int page , int count , int insdel ) ;
#line 252
void rxvt_scr_scroll_region(rxvt_t *r , int page , int top , int bot ) ;
#line 253
void rxvt_scr_cursor_visible(rxvt_t *r , int page , int mode ) ;
#line 254
void rxvt_scr_autowrap(rxvt_t *r , int page , int mode ) ;
#line 255
void rxvt_scr_relative_origin(rxvt_t *r , int page , int mode ) ;
#line 256
void rxvt_scr_insert_mode(rxvt_t *r , int page , int mode ) ;
#line 257
void rxvt_scr_set_tab(rxvt_t *r , int page , int mode ) ;
#line 258
void rxvt_scr_rvideo_mode(rxvt_t *r , int page , int mode ) ;
#line 259
void rxvt_scr_report_position(rxvt_t *r , int page ) ;
#line 260
void rxvt_scr_charset_choose(rxvt_t *r , int page , int set ) ;
#line 261
void rxvt_scr_charset_set(rxvt_t *r , int page , int set , unsigned int ch ) ;
#line 264
void rxvt_scr_expose(rxvt_t *r , int page , int x , int y , int width , int height ,
                     int refresh ) ;
#line 266
int rxvt_scr_move_to(rxvt_t *r , int page , int y , int len ) ;
#line 268
void rxvt_scr_bell(rxvt_t *r , int page ) ;
#line 270
void rxvt_scr_refresh(rxvt_t *r , int page , unsigned char refresh_type ) ;
#line 271
void rxvt_scr_clear(rxvt_t *r , int page ) ;
#line 273
void rxvt_selection_check(rxvt_t *r , int page , int check_more ) ;
#line 274
int rxvt_selection_paste(rxvt_t *r , Window win , Atom prop , int delete_prop ) ;
#line 275
void rxvt_selection_property(rxvt_t *r , Window win , Atom prop ) ;
#line 278
void rxvt_process_selectionclear(rxvt_t *r , int page ) ;
#line 279
void rxvt_selection_make(rxvt_t *r , int page , Time tm ) ;
#line 280
void rxvt_selection_click(rxvt_t *r , int page , int clicks , int x , int y ) ;
#line 281
void rxvt_selection_extend(rxvt_t *r , int page , int x , int y , int flag ) ;
#line 282
void rxvt_selection_rotate(rxvt_t *r , int page , int x , int y ) ;
#line 284
void rxvt_process_selectionrequest(rxvt_t *r , int page , XSelectionRequestEvent const   *rq ) ;
#line 285
void rxvt_pixel_position(rxvt_t *r , int *x , int *y ) ;
#line 455
void rxvt_tabbar_draw_buttons(rxvt_t *r ) ;
#line 62 "/usr/include/wordexp.h"
extern int wordexp(char const   * __restrict  __words , wordexp_t * __restrict  __pwordexp ,
                   int __flags ) ;
#line 66
extern void wordfree(wordexp_t *__wordexp ) ;
#line 169 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_blank_line(text_t *et , uint32_t *er , unsigned int width , uint32_t efs ) ;
#line 170
void rxvt_blank_screen_mem(rxvt_t *r , int page , text_t **tp , uint32_t **rp , unsigned int row ,
                           uint32_t efs ) ;
#line 171
void rxvt_scr_reset_realloc(rxvt_t *r , int page ) ;
#line 172
void rxvt_scr_delete_row(rxvt_t *r , int page ) ;
#line 173
void rxvt_scr_add_row(rxvt_t *r , int page , unsigned int total_rows , unsigned int prev_total_rows ) ;
#line 174
__inline static void rxvt_clear_area(rxvt_t *r , int page , int x , int y , unsigned int w ,
                                     unsigned int h ) ;
#line 175
__inline static void rxvt_fill_rectangle(rxvt_t *r , int page , int x , int y , unsigned int w ,
                                         unsigned int h ) ;
#line 176
void rxvt_scr_draw_string(rxvt_t *r , int page , int x , int y , char *str , int len ,
                          int drawfunc , uint16_t fore , uint16_t back , uint32_t rend ,
                          Region refreshRegion ) ;
#line 181
void rxvt_scr_adjust_col(rxvt_t *r , int page , unsigned int total_rows ) ;
#line 182
void rxvt_set_font_style(rxvt_t *r , int page ) ;
#line 183
int rxvt_scr_change_view(rxvt_t *r , int page , uint16_t oldviewstart ) ;
#line 184
void rxvt_scr_reverse_selection(rxvt_t *r , int page ) ;
#line 185
void rxvt_paste_str(rxvt_t *r , int page , unsigned char const   *data , unsigned int nitems ) ;
#line 186
int rxvt_selection_request_other(rxvt_t *r , int page , Atom target , int selnum ) ;
#line 187
void rxvt_selection_start_colrow(rxvt_t *r , int page , int col , int row ) ;
#line 188
void rxvt_selection_delimit_word(rxvt_t *r , int page , enum page_dirn dirn , row_col_t const   *mark ,
                                 row_col_t *ret ) ;
#line 192
void rxvt_selection_extend_colrow(rxvt_t *r , int page , int32_t col , int32_t row ,
                                  int button3 , int buttonpress , int clickchange ) ;
#line 194
void rxvt_selection_trim(rxvt_t *r , int page ) ;
#line 219 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_blank_line(text_t *et , uint32_t *er , unsigned int width , uint32_t efs ) 
{ 
  uint32_t *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 222
  memset((void *)et, ' ', (size_t )width);
#line 223
  efs &= 4291035135U;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    tmp___0 = width;
#line 224
    width --;
#line 224
    if (! tmp___0) {
#line 224
      goto while_break;
    }
#line 225
    tmp = er;
#line 225
    er ++;
#line 225
    *tmp = efs;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 231 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_blank_screen_mem(rxvt_t *r , int page , text_t **tp , uint32_t **rp , unsigned int row ,
                           uint32_t efs ) 
{ 
  int width ;
  uint32_t *er ;
  void *tmp ;
  void *tmp___0 ;
  uint32_t *tmp___1 ;
  int tmp___2 ;

  {
#line 235
  width = (int )r->TermWin.ncol;
#line 246
  if ((unsigned long )*(tp + row) == (unsigned long )((void *)0)) {
    {
#line 248
    tmp = rxvt_malloc(sizeof(text_t ) * (unsigned long )width);
#line 248
    *(tp + row) = (text_t *)tmp;
#line 249
    tmp___0 = rxvt_malloc(sizeof(uint32_t ) * (unsigned long )width);
#line 249
    *(rp + row) = (uint32_t *)tmp___0;
    }
  }
  {
#line 251
  memset((void *)*(tp + row), ' ', (size_t )width);
#line 252
  efs &= 4291035135U;
#line 253
  er = *(rp + row);
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    tmp___2 = width;
#line 253
    width --;
#line 253
    if (! tmp___2) {
#line 253
      goto while_break;
    }
#line 254
    tmp___1 = er;
#line 254
    er ++;
#line 254
    *tmp___1 = efs;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 263 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_init_screen(rxvt_t *r ) 
{ 
  int p ;
  int ncol ;
  void *tmp ;

  {
  {
#line 267
  ncol = (int )r->TermWin.ncol;
#line 272
  tmp = rxvt_malloc((unsigned long )ncol * sizeof(char ));
#line 272
  r->tabstop = (char *)tmp;
#line 273
  p = 0;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (p < ncol)) {
#line 273
      goto while_break;
    }
#line 274
    if (p % 8 == 0) {
#line 274
      *(r->tabstop + p) = (char)1;
    } else {
#line 274
      *(r->tabstop + p) = (char)0;
    }
#line 273
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 278 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_alloc(rxvt_t *r , int page ) 
{ 
  unsigned int ncol ;
  unsigned int nrow ;
  unsigned int total_rows ;
  unsigned int p ;
  unsigned int q ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 286
  ncol = (unsigned int )r->TermWin.ncol;
#line 287
  nrow = (unsigned int )r->TermWin.nrow;
#line 288
  total_rows = nrow + (unsigned int )(r->vts[page])->saveLines;
#line 296
  tmp = rxvt_calloc((size_t )total_rows, sizeof(text_t *));
#line 296
  (r->vts[page])->buf_text = (text_t **)tmp;
#line 297
  tmp___0 = rxvt_calloc((size_t )total_rows, sizeof(uint32_t *));
#line 297
  (r->vts[page])->buf_rend = (uint32_t **)tmp___0;
#line 299
  tmp___1 = rxvt_calloc((size_t )nrow, sizeof(text_t *));
#line 299
  (r->vts[page])->drawn_text = (text_t **)tmp___1;
#line 300
  tmp___2 = rxvt_calloc((size_t )nrow, sizeof(uint32_t *));
#line 300
  (r->vts[page])->drawn_rend = (uint32_t **)tmp___2;
#line 302
  tmp___3 = rxvt_calloc((size_t )total_rows, sizeof(text_t *));
#line 302
  (r->vts[page])->screen.text = (text_t **)tmp___3;
#line 303
  tmp___4 = rxvt_calloc((size_t )total_rows, sizeof(int16_t ));
#line 303
  (r->vts[page])->screen.tlen = (int16_t *)tmp___4;
#line 304
  tmp___5 = rxvt_calloc((size_t )total_rows, sizeof(uint32_t *));
#line 304
  (r->vts[page])->screen.rend = (uint32_t **)tmp___5;
#line 307
  tmp___6 = rxvt_calloc((size_t )nrow, sizeof(text_t *));
#line 307
  (r->vts[page])->swap.text = (text_t **)tmp___6;
#line 308
  tmp___7 = rxvt_calloc((size_t )nrow, sizeof(int16_t ));
#line 308
  (r->vts[page])->swap.tlen = (int16_t *)tmp___7;
#line 309
  tmp___8 = rxvt_calloc((size_t )nrow, sizeof(uint32_t *));
#line 309
  (r->vts[page])->swap.rend = (uint32_t **)tmp___8;
#line 312
  p = 0U;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (p < nrow)) {
#line 312
      goto while_break;
    }
    {
#line 314
    q = p + (unsigned int )(r->vts[page])->saveLines;
#line 315
    rxvt_blank_screen_mem(r, page, (r->vts[page])->screen.text, (r->vts[page])->screen.rend,
                          q, (uint32_t )(1 << 9));
#line 317
    *((r->vts[page])->screen.tlen + q) = (int16_t )0;
#line 319
    rxvt_blank_screen_mem(r, page, (r->vts[page])->swap.text, (r->vts[page])->swap.rend,
                          p, (uint32_t )(1 << 9));
#line 321
    *((r->vts[page])->swap.tlen + p) = (int16_t )0;
#line 324
    rxvt_blank_screen_mem(r, page, (r->vts[page])->drawn_text, (r->vts[page])->drawn_rend,
                          p, (uint32_t )(1 << 9));
#line 312
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  (r->vts[page])->nscrolled = (uint16_t )0;
#line 328
  (r->vts[page])->screen.flags = (unsigned int )((1 << 1) | (1 << 2));
#line 329
  (r->vts[page])->screen.cur.row = 0;
#line 330
  (r->vts[page])->screen.cur.col = 0;
#line 331
  (r->vts[page])->screen.charset = (uint16_t )0;
#line 332
  (r->vts[page])->current_screen = (unsigned char)0;
#line 333
  rxvt_scr_cursor(r, page, 's');
#line 335
  (r->vts[page])->swap.flags = (unsigned int )((1 << 1) | (1 << 2));
#line 336
  (r->vts[page])->swap.cur.row = 0;
#line 337
  (r->vts[page])->swap.cur.col = 0;
#line 338
  (r->vts[page])->swap.charset = (uint16_t )0;
#line 339
  (r->vts[page])->current_screen = (unsigned char)1;
#line 340
  rxvt_scr_cursor(r, page, 's');
#line 341
  (r->vts[page])->current_screen = (unsigned char)0;
#line 344
  (r->vts[page])->rstyle = (uint32_t )(1 << 9);
#line 345
  (r->vts[page])->rvideo = (char)0;
#line 346
  memset((void *)(& (r->vts[page])->charsets), 'B', sizeof((r->vts[page])->charsets));
#line 354
  (r->vts[page])->init_screen = (unsigned char)1;
  }
#line 355
  return;
}
}
#line 360 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_reset_realloc(rxvt_t *r , int page ) 
{ 
  unsigned int total_rows ;
  unsigned int nrow ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 367
  nrow = (unsigned int )r->TermWin.nrow;
#line 368
  total_rows = nrow + (unsigned int )(r->vts[page])->saveLines;
#line 370
  tmp = rxvt_realloc((void *)(r->vts[page])->screen.text, (unsigned long )total_rows * sizeof(text_t *));
#line 370
  (r->vts[page])->screen.text = (text_t **)tmp;
#line 372
  tmp___0 = rxvt_realloc((void *)(r->vts[page])->screen.tlen, (unsigned long )total_rows * sizeof(int16_t ));
#line 372
  (r->vts[page])->screen.tlen = (int16_t *)tmp___0;
#line 374
  tmp___1 = rxvt_realloc((void *)(r->vts[page])->screen.rend, (unsigned long )total_rows * sizeof(uint32_t *));
#line 374
  (r->vts[page])->screen.rend = (uint32_t **)tmp___1;
#line 378
  tmp___2 = rxvt_realloc((void *)(r->vts[page])->swap.text, (unsigned long )nrow * sizeof(text_t *));
#line 378
  (r->vts[page])->swap.text = (text_t **)tmp___2;
#line 380
  tmp___3 = rxvt_realloc((void *)(r->vts[page])->swap.tlen, (unsigned long )total_rows * sizeof(int16_t ));
#line 380
  (r->vts[page])->swap.tlen = (int16_t *)tmp___3;
#line 382
  tmp___4 = rxvt_realloc((void *)(r->vts[page])->swap.rend, (unsigned long )nrow * sizeof(uint32_t *));
#line 382
  (r->vts[page])->swap.rend = (uint32_t **)tmp___4;
#line 386
  tmp___5 = rxvt_realloc((void *)(r->vts[page])->buf_text, (unsigned long )total_rows * sizeof(text_t *));
#line 386
  (r->vts[page])->buf_text = (text_t **)tmp___5;
#line 388
  tmp___6 = rxvt_realloc((void *)(r->vts[page])->buf_rend, (unsigned long )total_rows * sizeof(uint32_t *));
#line 388
  (r->vts[page])->buf_rend = (uint32_t **)tmp___6;
#line 391
  tmp___7 = rxvt_realloc((void *)(r->vts[page])->drawn_text, (unsigned long )nrow * sizeof(text_t *));
#line 391
  (r->vts[page])->drawn_text = (text_t **)tmp___7;
#line 393
  tmp___8 = rxvt_realloc((void *)(r->vts[page])->drawn_rend, (unsigned long )nrow * sizeof(uint32_t *));
#line 393
  (r->vts[page])->drawn_rend = (uint32_t **)tmp___8;
  }
#line 395
  return;
}
}
#line 399 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_delete_row(rxvt_t *r , int page ) 
{ 
  unsigned int nrow ;
  unsigned int prev_nrow ;
  unsigned int p ;
  unsigned int q ;
  register int i ;

  {
#line 408
  nrow = (unsigned int )r->TermWin.nrow;
#line 409
  prev_nrow = (unsigned int )(r->vts[page])->prev_nrow;
#line 412
  if ((unsigned int )(r->vts[page])->nscrolled < prev_nrow - nrow) {
#line 412
    i = (int )(r->vts[page])->nscrolled;
  } else {
#line 412
    i = (int )(prev_nrow - nrow);
  }
  {
#line 413
  rxvt_scroll_text(r, page, 0, (int )prev_nrow - 1, i, 1);
#line 415
  p = nrow;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (p < prev_nrow)) {
#line 415
      goto while_break;
    }
#line 417
    q = p + (unsigned int )(r->vts[page])->saveLines;
#line 418
    if (*((r->vts[page])->screen.text + q)) {
      {
#line 421
      rxvt_free((void *)*((r->vts[page])->screen.text + q));
#line 422
      *((r->vts[page])->screen.text + q) = (text_t *)((void *)0);
#line 423
      rxvt_free((void *)*((r->vts[page])->screen.rend + q));
#line 424
      *((r->vts[page])->screen.rend + q) = (uint32_t *)((void *)0);
      }
    }
#line 427
    if (*((r->vts[page])->swap.text + p)) {
      {
#line 430
      rxvt_free((void *)*((r->vts[page])->swap.text + p));
#line 431
      *((r->vts[page])->swap.text + p) = (text_t *)((void *)0);
#line 432
      rxvt_free((void *)*((r->vts[page])->swap.rend + p));
#line 433
      *((r->vts[page])->swap.rend + p) = (uint32_t *)((void *)0);
      }
    }
    {
#line 438
    rxvt_free((void *)*((r->vts[page])->drawn_text + p));
#line 439
    *((r->vts[page])->drawn_text + p) = (text_t *)((void *)0);
#line 440
    rxvt_free((void *)*((r->vts[page])->drawn_rend + p));
#line 441
    *((r->vts[page])->drawn_rend + p) = (uint32_t *)((void *)0);
#line 415
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  if ((int32_t )nrow - 1 < (r->vts[page])->screen.cur.row) {
#line 445
    (r->vts[page])->screen.cur.row = (int32_t )nrow - 1;
  }
#line 447
  if ((int32_t )nrow - 1 < (r->vts[page])->swap.cur.row) {
#line 447
    (r->vts[page])->swap.cur.row = (int32_t )nrow - 1;
  }
  {
#line 450
  rxvt_scr_reset_realloc(r, page);
  }
#line 451
  return;
}
}
#line 455 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_add_row(rxvt_t *r , int page , unsigned int total_rows , unsigned int prev_total_rows ) 
{ 
  unsigned int nrow ;
  unsigned int prev_nrow ;
  unsigned int p ;
  register int i ;

  {
  {
#line 465
  nrow = (unsigned int )r->TermWin.nrow;
#line 466
  prev_nrow = (unsigned int )(r->vts[page])->prev_nrow;
#line 469
  rxvt_scr_reset_realloc(r, page);
  }
#line 471
  if ((unsigned int )(r->vts[page])->nscrolled < nrow - prev_nrow) {
#line 471
    i = (int )(r->vts[page])->nscrolled;
  } else {
#line 471
    i = (int )(nrow - prev_nrow);
  }
#line 472
  p = prev_total_rows;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (p < total_rows)) {
#line 472
      goto while_break;
    }
#line 474
    *((r->vts[page])->screen.tlen + p) = (int16_t )0;
#line 475
    *((r->vts[page])->screen.text + p) = (text_t *)((void *)0);
#line 476
    *((r->vts[page])->screen.rend + p) = (uint32_t *)((void *)0);
#line 472
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  p = prev_total_rows;
  {
#line 479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 479
    if (! (p < total_rows - (unsigned int )i)) {
#line 479
      goto while_break___0;
    }
    {
#line 480
    rxvt_blank_screen_mem(r, page, (r->vts[page])->screen.text, (r->vts[page])->screen.rend,
                          p, (uint32_t )(1 << 9));
#line 479
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 483
  p = prev_nrow;
  {
#line 483
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 483
    if (! (p < nrow)) {
#line 483
      goto while_break___1;
    }
    {
#line 486
    *((r->vts[page])->swap.tlen + p) = (int16_t )0;
#line 487
    *((r->vts[page])->swap.text + p) = (text_t *)((void *)0);
#line 488
    *((r->vts[page])->swap.rend + p) = (uint32_t *)((void *)0);
#line 489
    rxvt_blank_screen_mem(r, page, (r->vts[page])->swap.text, (r->vts[page])->swap.rend,
                          p, (uint32_t )(1 << 9));
#line 493
    *((r->vts[page])->drawn_text + p) = (text_t *)((void *)0);
#line 494
    *((r->vts[page])->drawn_rend + p) = (uint32_t *)((void *)0);
#line 495
    rxvt_blank_screen_mem(r, page, (r->vts[page])->drawn_text, (r->vts[page])->drawn_rend,
                          p, (uint32_t )(1 << 9));
#line 483
    p ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 499
  if (i > 0) {
    {
#line 501
    rxvt_scroll_text(r, page, 0, (int )nrow - 1, - i, 1);
#line 502
    (r->vts[page])->screen.cur.row += i;
#line 503
    (r->vts[page])->screen.s_cur.row += i;
#line 504
    (r->vts[page])->nscrolled = (uint16_t )((int )(r->vts[page])->nscrolled - i);
    }
  }
#line 508
  if (nrow - 1U < (unsigned int )(r->vts[page])->screen.cur.row) {
#line 508
    (r->vts[page])->screen.cur.row = (int32_t )(nrow - 1U);
  }
#line 511
  if (nrow - 1U < (unsigned int )(r->vts[page])->swap.cur.row) {
#line 511
    (r->vts[page])->swap.cur.row = (int32_t )(nrow - 1U);
  }
#line 513
  return;
}
}
#line 518 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_adjust_col(rxvt_t *r , int page , unsigned int total_rows ) 
{ 
  unsigned int nrow ;
  unsigned int ncol ;
  unsigned int prev_ncol ;
  unsigned int p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 525
  nrow = (unsigned int )r->TermWin.nrow;
#line 526
  ncol = (unsigned int )r->TermWin.ncol;
#line 527
  prev_ncol = (unsigned int )(r->vts[page])->prev_ncol;
#line 532
  p = 0U;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (p < total_rows)) {
#line 532
      goto while_break;
    }
#line 534
    if (*((r->vts[page])->screen.text + p)) {
      {
#line 536
      tmp = rxvt_realloc((void *)*((r->vts[page])->screen.text + p), (unsigned long )ncol * sizeof(text_t ));
#line 536
      *((r->vts[page])->screen.text + p) = (text_t *)tmp;
#line 538
      tmp___0 = rxvt_realloc((void *)*((r->vts[page])->screen.rend + p), (unsigned long )ncol * sizeof(uint32_t ));
#line 538
      *((r->vts[page])->screen.rend + p) = (uint32_t *)tmp___0;
      }
#line 540
      if ((int )((int16_t )ncol) < (int )*((r->vts[page])->screen.tlen + p)) {
#line 540
        *((r->vts[page])->screen.tlen + p) = (int16_t )ncol;
      }
#line 541
      if (ncol > prev_ncol) {
        {
#line 542
        rxvt_blank_line(*((r->vts[page])->screen.text + p) + prev_ncol, *((r->vts[page])->screen.rend + p) + prev_ncol,
                        ncol - prev_ncol, (uint32_t )(1 << 9));
        }
      }
    }
#line 532
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  p = 0U;
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 549
    if (! (p < nrow)) {
#line 549
      goto while_break___0;
    }
    {
#line 551
    tmp___1 = rxvt_realloc((void *)*((r->vts[page])->drawn_text + p), (unsigned long )ncol * sizeof(text_t ));
#line 551
    *((r->vts[page])->drawn_text + p) = (text_t *)tmp___1;
#line 553
    tmp___2 = rxvt_realloc((void *)*((r->vts[page])->drawn_rend + p), (unsigned long )ncol * sizeof(uint32_t ));
#line 553
    *((r->vts[page])->drawn_rend + p) = (uint32_t *)tmp___2;
    }
#line 556
    if (*((r->vts[page])->swap.text + p)) {
      {
#line 558
      tmp___3 = rxvt_realloc((void *)*((r->vts[page])->swap.text + p), (unsigned long )ncol * sizeof(text_t ));
#line 558
      *((r->vts[page])->swap.text + p) = (text_t *)tmp___3;
#line 560
      tmp___4 = rxvt_realloc((void *)*((r->vts[page])->swap.rend + p), (unsigned long )ncol * sizeof(uint32_t ));
#line 560
      *((r->vts[page])->swap.rend + p) = (uint32_t *)tmp___4;
      }
#line 562
      if ((int )((int16_t )ncol) < (int )*((r->vts[page])->swap.tlen + p)) {
#line 562
        *((r->vts[page])->swap.tlen + p) = (int16_t )ncol;
      }
#line 563
      if (ncol > prev_ncol) {
        {
#line 564
        rxvt_blank_line(*((r->vts[page])->swap.text + p) + prev_ncol, *((r->vts[page])->swap.rend + p) + prev_ncol,
                        ncol - prev_ncol, (uint32_t )(1 << 9));
        }
      }
    }
#line 570
    if (ncol > prev_ncol) {
      {
#line 571
      rxvt_blank_line(*((r->vts[page])->drawn_text + p) + prev_ncol, *((r->vts[page])->drawn_rend + p) + prev_ncol,
                      ncol - prev_ncol, (uint32_t )(1 << 9));
      }
    }
#line 549
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 576
  if ((int )((int16_t )ncol) - 1 < (r->vts[page])->screen.cur.col) {
#line 576
    (r->vts[page])->screen.cur.col = (int )((int16_t )ncol) - 1;
  }
#line 578
  if ((int )((int16_t )ncol) - 1 < (r->vts[page])->swap.cur.col) {
#line 578
    (r->vts[page])->swap.cur.col = (int )((int16_t )ncol) - 1;
  }
#line 586
  if (r->tabstop) {
#line 586
    if (ncol > prev_ncol) {
      {
#line 589
      tmp___5 = rxvt_realloc((void *)r->tabstop, (unsigned long )ncol * sizeof(char ));
#line 589
      r->tabstop = (char *)tmp___5;
#line 590
      p = prev_ncol;
      }
      {
#line 590
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 590
        if (! (p < ncol)) {
#line 590
          goto while_break___1;
        }
#line 591
        if (p % 8U == 0U) {
#line 591
          *(r->tabstop + p) = (char)1;
        } else {
#line 591
          *(r->tabstop + p) = (char)0;
        }
#line 590
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 593
  return;
}
}
#line 598 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_reset(rxvt_t *r , int page ) 
{ 
  unsigned int ncol ;
  unsigned int nrow ;
  unsigned int prev_ncol ;
  unsigned int prev_nrow ;
  unsigned int total_rows ;
  unsigned int prev_total_rows ;

  {
#line 607
  (r->vts[page])->view_start = (uint16_t )0;
#line 609
  (r->vts[page])->num_scr = (uint16_t )0;
#line 611
  prev_ncol = (unsigned int )(r->vts[page])->prev_ncol;
#line 612
  prev_nrow = (unsigned int )(r->vts[page])->prev_nrow;
#line 613
  if ((int )r->TermWin.ncol == 0) {
#line 614
    r->TermWin.ncol = (uint16_t )80;
  }
#line 615
  if ((int )r->TermWin.nrow == 0) {
#line 616
    r->TermWin.nrow = (uint16_t )24;
  }
#line 617
  ncol = (unsigned int )r->TermWin.ncol;
#line 618
  nrow = (unsigned int )r->TermWin.nrow;
#line 619
  if ((r->vts[page])->init_screen) {
#line 619
    if (ncol == prev_ncol) {
#line 619
      if (nrow == prev_nrow) {
#line 621
        return;
      }
    }
  }
#line 624
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 626
  total_rows = nrow + (unsigned int )(r->vts[page])->saveLines;
#line 627
  prev_total_rows = prev_nrow + (unsigned int )(r->vts[page])->saveLines;
#line 629
  (r->vts[page])->screen.tscroll = (uint16_t )0;
#line 630
  (r->vts[page])->screen.bscroll = (uint16_t )(nrow - 1U);
#line 632
  if ((int )(r->vts[page])->init_screen == 0) {
    {
#line 635
    rxvt_scr_alloc(r, page);
    }
  } else {
#line 640
    if (nrow < prev_nrow) {
      {
#line 642
      rxvt_scr_delete_row(r, page);
      }
    } else
#line 644
    if (nrow > prev_nrow) {
      {
#line 646
      rxvt_scr_add_row(r, page, total_rows, prev_total_rows);
      }
    }
#line 649
    if (ncol != prev_ncol) {
      {
#line 651
      rxvt_scr_adjust_col(r, page, total_rows);
      }
    }
  }
  {
#line 655
  (r->vts[page])->prev_nrow = (uint16_t )nrow;
#line 656
  (r->vts[page])->prev_ncol = (uint16_t )ncol;
#line 658
  rxvt_tt_winsize((r->vts[page])->cmd_fd, r->TermWin.ncol, r->TermWin.nrow, (r->vts[page])->cmd_pid);
  }
#line 659
  return;
}
}
#line 669 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_release(rxvt_t *r , int page ) 
{ 
  unsigned int total_rows ;
  int i ;

  {
#line 677
  total_rows = (unsigned int )((int )r->TermWin.nrow + (int )(r->vts[page])->saveLines);
#line 679
  i = 0;
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    if (! ((unsigned int )i < total_rows)) {
#line 679
      goto while_break;
    }
#line 681
    if (*((r->vts[page])->screen.text + i)) {
      {
#line 684
      rxvt_free((void *)*((r->vts[page])->screen.text + i));
#line 685
      *((r->vts[page])->screen.text + i) = (text_t *)((void *)0);
#line 687
      rxvt_free((void *)*((r->vts[page])->screen.rend + i));
#line 688
      *((r->vts[page])->screen.rend + i) = (uint32_t *)((void *)0);
      }
    }
#line 679
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 692
  i = 0;
  {
#line 692
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 692
    if (! (i < (int )r->TermWin.nrow)) {
#line 692
      goto while_break___0;
    }
    {
#line 695
    rxvt_free((void *)*((r->vts[page])->drawn_text + i));
#line 696
    *((r->vts[page])->drawn_text + i) = (text_t *)((void *)0);
#line 698
    rxvt_free((void *)*((r->vts[page])->drawn_rend + i));
#line 699
    *((r->vts[page])->drawn_rend + i) = (uint32_t *)((void *)0);
#line 702
    rxvt_free((void *)*((r->vts[page])->swap.text + i));
#line 703
    *((r->vts[page])->swap.text + i) = (text_t *)((void *)0);
#line 705
    rxvt_free((void *)*((r->vts[page])->swap.rend + i));
#line 706
    *((r->vts[page])->swap.rend + i) = (uint32_t *)((void *)0);
#line 692
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 710
  rxvt_free((void *)(r->vts[page])->screen.text);
#line 710
  (r->vts[page])->screen.text = (text_t **)((void *)0);
#line 711
  rxvt_free((void *)(r->vts[page])->screen.tlen);
#line 711
  (r->vts[page])->screen.tlen = (int16_t *)((void *)0);
#line 712
  rxvt_free((void *)(r->vts[page])->screen.rend);
#line 712
  (r->vts[page])->screen.rend = (uint32_t **)((void *)0);
#line 713
  rxvt_free((void *)(r->vts[page])->drawn_text);
#line 713
  (r->vts[page])->drawn_text = (text_t **)((void *)0);
#line 714
  rxvt_free((void *)(r->vts[page])->drawn_rend);
#line 714
  (r->vts[page])->drawn_rend = (uint32_t **)((void *)0);
#line 716
  rxvt_free((void *)(r->vts[page])->swap.text);
#line 716
  (r->vts[page])->swap.text = (text_t **)((void *)0);
#line 717
  rxvt_free((void *)(r->vts[page])->swap.tlen);
#line 717
  (r->vts[page])->swap.tlen = (int16_t *)((void *)0);
#line 718
  rxvt_free((void *)(r->vts[page])->swap.rend);
#line 718
  (r->vts[page])->swap.rend = (uint32_t **)((void *)0);
#line 720
  rxvt_free((void *)(r->vts[page])->buf_text);
#line 720
  (r->vts[page])->buf_text = (text_t **)((void *)0);
#line 721
  rxvt_free((void *)(r->vts[page])->buf_rend);
#line 721
  (r->vts[page])->buf_rend = (uint32_t **)((void *)0);
#line 724
  (r->vts[page])->init_screen = (unsigned char)0;
  }
#line 727
  if (page == (int )r->selection.vt) {
    {
#line 729
    rxvt_process_selectionclear(r, page);
    }
  }
#line 731
  return;
}
}
#line 738 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_poweron(rxvt_t *r , int page ) 
{ 
  uint16_t tmp ;

  {
  {
#line 743
  rxvt_scr_release(r, page);
#line 744
  tmp = (uint16_t )0;
#line 744
  (r->vts[page])->prev_ncol = tmp;
#line 744
  (r->vts[page])->prev_nrow = tmp;
#line 745
  rxvt_scr_reset(r, page);
#line 747
  rxvt_scr_clear(r, page);
#line 748
  rxvt_scr_refresh(r, page, (unsigned char )(1 << 1));
  }
#line 749
  return;
}
}
#line 761 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_cursor(rxvt_t *r , int page , int mode ) 
{ 
  screen_t *s ;

  {
#line 769
  if ((int )(r->vts[page])->current_screen == 1) {
#line 770
    s = & (r->vts[page])->swap;
  } else {
#line 773
    s = & (r->vts[page])->screen;
  }
  {
#line 776
  if (mode == 115) {
#line 776
    goto case_115;
  }
#line 783
  if (mode == 114) {
#line 783
    goto case_114;
  }
#line 774
  goto switch_break;
  case_115: /* CIL Label */ 
#line 777
  s->s_cur.row = s->cur.row;
#line 778
  s->s_cur.col = s->cur.col;
#line 779
  s->s_rstyle = (r->vts[page])->rstyle;
#line 780
  s->s_charset = s->charset;
#line 781
  s->s_charset_char = (r->vts[page])->charsets[s->charset];
#line 782
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 784
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 785
  s->cur.row = s->s_cur.row;
#line 786
  s->cur.col = s->s_cur.col;
#line 787
  s->flags &= (unsigned int )(~ (1 << 4));
#line 788
  (r->vts[page])->rstyle = s->s_rstyle;
#line 789
  s->charset = s->s_charset;
#line 790
  (r->vts[page])->charsets[s->charset] = s->s_charset_char;
#line 791
  rxvt_set_font_style(r, page);
  }
#line 792
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 795
  if ((int )r->TermWin.nrow - 1 < s->cur.row) {
#line 795
    s->cur.row = (int )r->TermWin.nrow - 1;
  }
#line 796
  if ((int )r->TermWin.ncol - 1 < s->cur.col) {
#line 796
    s->cur.col = (int )r->TermWin.ncol - 1;
  }
#line 799
  if (0 > s->cur.row) {
#line 799
    s->cur.row = 0;
  }
#line 800
  if (0 > s->cur.col) {
#line 800
    s->cur.col = 0;
  }
#line 801
  return;
}
}
#line 810 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_scr_change_screen(rxvt_t *r , int page , int scrn ) 
{ 
  unsigned int i ;
  unsigned int offset ;
  int swapittmp ;
  text_t *swapittmp___0 ;
  int16_t swapittmp___1 ;
  uint32_t *swapittmp___2 ;
  unsigned int tmp ;
  int16_t swapittmp___3 ;
  int16_t swapittmp___4 ;
  int16_t swapittmp___5 ;
  int swapittmp___6 ;

  {
#line 817
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 821
  (r->vts[page])->view_start = (uint16_t )0;
#line 824
  if ((int )(r->vts[page])->current_screen == scrn) {
#line 825
    return ((int )(r->vts[page])->current_screen);
  }
  {
#line 827
  rxvt_selection_check(r, page, 2);
#line 829
  swapittmp = (int )(r->vts[page])->current_screen;
#line 829
  (r->vts[page])->current_screen = (unsigned char )scrn;
#line 829
  scrn = swapittmp;
#line 832
  (r->vts[page])->num_scr = (uint16_t )0;
#line 833
  offset = (unsigned int )(r->vts[page])->saveLines;
#line 835
  i = (unsigned int )(r->vts[page])->prev_nrow;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    tmp = i;
#line 835
    i --;
#line 835
    if (! tmp) {
#line 835
      goto while_break;
    }
#line 837
    swapittmp___0 = *((r->vts[page])->screen.text + (i + offset));
#line 837
    *((r->vts[page])->screen.text + (i + offset)) = *((r->vts[page])->swap.text + i);
#line 837
    *((r->vts[page])->swap.text + i) = swapittmp___0;
#line 839
    swapittmp___1 = *((r->vts[page])->screen.tlen + (i + offset));
#line 839
    *((r->vts[page])->screen.tlen + (i + offset)) = *((r->vts[page])->swap.tlen + i);
#line 839
    *((r->vts[page])->swap.tlen + i) = swapittmp___1;
#line 841
    swapittmp___2 = *((r->vts[page])->screen.rend + (i + offset));
#line 841
    *((r->vts[page])->screen.rend + (i + offset)) = *((r->vts[page])->swap.rend + i);
#line 841
    *((r->vts[page])->swap.rend + i) = swapittmp___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 844
  swapittmp___3 = (int16_t )(r->vts[page])->screen.cur.row;
#line 844
  (r->vts[page])->screen.cur.row = (r->vts[page])->swap.cur.row;
#line 844
  (r->vts[page])->swap.cur.row = (int32_t )swapittmp___3;
#line 845
  swapittmp___4 = (int16_t )(r->vts[page])->screen.cur.col;
#line 845
  (r->vts[page])->screen.cur.col = (r->vts[page])->swap.cur.col;
#line 845
  (r->vts[page])->swap.cur.col = (int32_t )swapittmp___4;
#line 850
  if (0 > (r->vts[page])->screen.cur.row) {
#line 850
    (r->vts[page])->screen.cur.row = 0;
  }
#line 851
  if ((int32_t )(r->vts[page])->prev_nrow - 1 < (r->vts[page])->screen.cur.row) {
#line 851
    (r->vts[page])->screen.cur.row = (int32_t )(r->vts[page])->prev_nrow - 1;
  }
#line 852
  if (0 > (r->vts[page])->screen.cur.col) {
#line 852
    (r->vts[page])->screen.cur.col = 0;
  }
#line 853
  if ((int32_t )(r->vts[page])->prev_ncol - 1 < (r->vts[page])->screen.cur.col) {
#line 853
    (r->vts[page])->screen.cur.col = (int32_t )(r->vts[page])->prev_ncol - 1;
  }
#line 855
  swapittmp___5 = (int16_t )(r->vts[page])->screen.charset;
#line 855
  (r->vts[page])->screen.charset = (r->vts[page])->swap.charset;
#line 855
  (r->vts[page])->swap.charset = (uint16_t )swapittmp___5;
#line 857
  swapittmp___6 = (int )(r->vts[page])->screen.flags;
#line 857
  (r->vts[page])->screen.flags = (r->vts[page])->swap.flags;
#line 857
  (r->vts[page])->swap.flags = (unsigned int )swapittmp___6;
#line 858
  (r->vts[page])->screen.flags |= (unsigned int )(1 << 1);
#line 859
  (r->vts[page])->swap.flags |= (unsigned int )(1 << 1);
#line 870
  if ((unsigned long )r->Options[((1UL << 2) | 1UL) & 3UL] & (((1UL << 2) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 871
    rxvt_tabbar_draw_buttons(r);
    }
  }
#line 873
  return (scrn);
}
}
#line 881 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_color(rxvt_t *r , int page , unsigned int color , int fgbg ) 
{ 


  {
#line 884
  color &= 511U;
#line 885
  if (0 == fgbg) {
#line 886
    (r->vts[page])->rstyle = ((r->vts[page])->rstyle & 4294966784U) | color;
  } else {
#line 888
    (r->vts[page])->rstyle = ((r->vts[page])->rstyle & 4294705663U) | (color << 9);
  }
#line 889
  return;
}
}
#line 897 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_rendition(rxvt_t *r , int page , int set , int style ) 
{ 


  {
#line 900
  if (set) {
#line 901
    (r->vts[page])->rstyle |= (unsigned int )style;
  } else
#line 902
  if (style == -1) {
#line 903
    (r->vts[page])->rstyle = (unsigned int )(1 << 9) | ((r->vts[page])->rstyle & 12582912U);
  } else {
#line 905
    (r->vts[page])->rstyle &= (unsigned int )(~ style);
  }
#line 906
  return;
}
}
#line 916 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_scroll_text(rxvt_t *r , int page , int row1 , int row2 , int count , int spec ) 
{ 
  int i ;
  int j ;
  int ret ;
  unsigned int nscrolled ;
  size_t size ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int tmp___4 ;

  {
#line 923
  if (count == 0) {
#line 924
    return (0);
  } else
#line 923
  if (row1 > row2) {
#line 924
    return (0);
  }
#line 926
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 932
  if (count > 0) {
#line 932
    if (row1 == 0) {
#line 932
      if ((int )(r->vts[page])->current_screen == 0) {
#line 938
        nscrolled = (unsigned int )(r->vts[page])->nscrolled + (unsigned int )count;
#line 941
        if (nscrolled > (unsigned int )(r->vts[page])->saveLines) {
#line 942
          (r->vts[page])->nscrolled = (r->vts[page])->saveLines;
        } else {
#line 944
          (r->vts[page])->nscrolled = (uint16_t )nscrolled;
        }
      } else {
#line 932
        goto _L___0;
      }
    } else {
#line 932
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 946
  if (! spec) {
#line 947
    row1 += (int )(r->vts[page])->saveLines;
  }
#line 948
  row2 += (int )(r->vts[page])->saveLines;
#line 950
  if (r->selection.op) {
#line 950
    if ((int )r->selection.vt == page) {
#line 950
      if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 956
        i = r->selection.beg.row + (int32_t )(r->vts[page])->saveLines;
#line 957
        j = r->selection.end.row + (int32_t )(r->vts[page])->saveLines;
#line 958
        if (i < row1) {
#line 958
          if (j > row1) {
#line 958
            goto _L___1;
          } else {
#line 958
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 958
        if (i < row2) {
#line 958
          if (j > row2) {
#line 958
            goto _L___1;
          } else {
#line 958
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 958
        if (i - count < row1) {
#line 958
          if (i >= row1) {
#line 958
            goto _L___1;
          } else {
#line 958
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 958
        if (i - count > row2) {
#line 958
          if (i <= row2) {
#line 958
            goto _L___1;
          } else {
#line 958
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 958
        if (j - count < row1) {
#line 958
          if (j >= row1) {
#line 958
            goto _L___1;
          } else {
#line 958
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 958
        if (j - count > row2) {
#line 958
          if (j <= row2) {
            _L___1: /* CIL Label */ 
#line 967
            tmp___3 = 0;
#line 967
            r->selection.end.col = tmp___3;
#line 967
            tmp___2 = tmp___3;
#line 967
            r->selection.end.row = tmp___2;
#line 967
            tmp___1 = tmp___2;
#line 967
            r->selection.mark.col = tmp___1;
#line 967
            tmp___0 = tmp___1;
#line 967
            r->selection.mark.row = tmp___0;
#line 967
            tmp = tmp___0;
#line 967
            r->selection.beg.col = tmp;
#line 967
            r->selection.beg.row = tmp;
#line 969
            r->selection.op = (enum __anonenum_op_361 )0;
          } else {
#line 958
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 971
        if (j >= row1) {
#line 971
          if (j <= row2) {
#line 974
            r->selection.beg.row -= count;
#line 975
            r->selection.end.row -= count;
#line 976
            r->selection.mark.row -= count;
          }
        }
      }
    }
  }
  {
#line 981
  rxvt_selection_check(r, page, 0);
#line 983
  (r->vts[page])->num_scr = (uint16_t )((int )(r->vts[page])->num_scr + count);
#line 984
  j = count;
  }
#line 985
  if (count < 0) {
#line 986
    count = - count;
  }
#line 987
  i = (row2 - row1) + 1;
#line 988
  if (i < count) {
#line 988
    count = i;
  }
#line 990
  if (j > 0) {
#line 995
    i = count - 1;
#line 995
    j = row1;
    {
#line 995
    while (1) {
      while_continue: /* CIL Label */ ;
#line 995
      if (! (i >= 0)) {
#line 995
        goto while_break;
      }
#line 997
      *((r->vts[page])->buf_text + i) = *((r->vts[page])->screen.text + j);
#line 998
      *((r->vts[page])->buf_rend + i) = *((r->vts[page])->screen.rend + j);
#line 995
      i --;
#line 995
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1002
    size = sizeof(*((r->vts[page])->screen.tlen));
#line 1003
    memmove((void *)((r->vts[page])->screen.tlen + row1), (void const   *)((r->vts[page])->screen.tlen + (row1 + count)),
            (size_t )(((row2 - row1) - count) + 1) * size);
#line 1005
    size = sizeof(*((r->vts[page])->screen.text));
#line 1006
    memmove((void *)((r->vts[page])->screen.text + row1), (void const   *)((r->vts[page])->screen.text + (row1 + count)),
            (size_t )(((row2 - row1) - count) + 1) * size);
#line 1008
    size = sizeof(*((r->vts[page])->screen.rend));
#line 1009
    memmove((void *)((r->vts[page])->screen.rend + row1), (void const   *)((r->vts[page])->screen.rend + (row1 + count)),
            (size_t )(((row2 - row1) - count) + 1) * size);
#line 1012
    j = (row2 - count) + 1;
#line 1013
    i = count;
#line 1013
    ret = i;
    }
  } else {
    {
#line 1020
    size = sizeof(*((r->vts[page])->screen.text));
#line 1021
    memcpy((void */* __restrict  */)((void *)(r->vts[page])->buf_text), (void const   */* __restrict  */)((void const   *)((r->vts[page])->screen.text + ((row2 - count) + 1))),
           (size_t )count * size);
#line 1022
    size = sizeof(*((r->vts[page])->screen.rend));
#line 1023
    memcpy((void */* __restrict  */)((void *)(r->vts[page])->buf_rend), (void const   */* __restrict  */)((void const   *)((r->vts[page])->screen.rend + ((row2 - count) + 1))),
           (size_t )count * size);
#line 1026
    size = sizeof(*((r->vts[page])->screen.tlen));
#line 1027
    memmove((void *)((r->vts[page])->screen.tlen + (row1 + count)), (void const   *)((r->vts[page])->screen.tlen + row1),
            (size_t )(((row2 - row1) - count) + 1) * size);
#line 1029
    size = sizeof(*((r->vts[page])->screen.text));
#line 1030
    memmove((void *)((r->vts[page])->screen.text + (row1 + count)), (void const   *)((r->vts[page])->screen.text + row1),
            (size_t )(((row2 - row1) - count) + 1) * size);
#line 1032
    size = sizeof(*((r->vts[page])->screen.rend));
#line 1033
    memmove((void *)((r->vts[page])->screen.rend + (row1 + count)), (void const   *)((r->vts[page])->screen.rend + row1),
            (size_t )(((row2 - row1) - count) + 1) * size);
#line 1036
    j = row1;
#line 1036
    i = count;
#line 1037
    ret = - count;
    }
  }
  {
#line 1041
  size = sizeof(*((r->vts[page])->screen.tlen));
#line 1042
  memset((void *)((r->vts[page])->screen.tlen + j), 0, (size_t )count * size);
#line 1043
  size = sizeof(*((r->vts[page])->screen.text));
#line 1044
  memcpy((void */* __restrict  */)((void *)((r->vts[page])->screen.text + j)), (void const   */* __restrict  */)((void const   *)(r->vts[page])->buf_text),
         (size_t )count * size);
#line 1045
  size = sizeof(*((r->vts[page])->screen.rend));
#line 1046
  memcpy((void */* __restrict  */)((void *)((r->vts[page])->screen.rend + j)), (void const   */* __restrict  */)((void const   *)(r->vts[page])->buf_rend),
         (size_t )count * size);
  }
  {
#line 1048
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1048
    tmp___4 = i;
#line 1048
    i --;
#line 1048
    if (! tmp___4) {
#line 1048
      goto while_break___0;
    }
#line 1050
    if (! spec) {
      {
#line 1051
      rxvt_blank_screen_mem(r, page, (r->vts[page])->screen.text, (r->vts[page])->screen.rend,
                            (unsigned int )j, (r->vts[page])->rstyle);
      }
    }
#line 1048
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1056
  return (ret);
}
}
#line 1064 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
__inline static void adjust_view_start(rxvt_t *r , int page , int nlines ) 
{ 


  {
#line 1067
  if ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL)) {
#line 1067
    if ((int )(r->vts[page])->view_start != 0) {
#line 1067
      if ((int )(r->vts[page])->view_start + nlines <= (int )(r->vts[page])->nscrolled) {
#line 1071
        (r->vts[page])->view_start = (uint16_t )((int )(r->vts[page])->view_start + nlines);
      }
    }
  }
#line 1072
  return;
}
}
#line 1078 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_add_lines(rxvt_t *r , int page , unsigned char const   *str , int nlines ,
                        int len ) 
{ 
  unsigned char checksel ;
  unsigned char clearsel ;
  char c ;
  int i ;
  int row ;
  int last_col ;
  text_t *stp ;
  uint32_t *srp ;
  int tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;

  {
#line 1090
  if (len <= 0) {
#line 1091
    return;
  }
#line 1093
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1094
  last_col = (int )r->TermWin.ncol;
#line 1096
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1096
    (r->vts[page])->view_start = (uint16_t )0;
  }
#line 1097
  if (nlines > 0) {
#line 1105
    nlines += (r->vts[page])->screen.cur.row - (int32_t )(r->vts[page])->screen.bscroll;
#line 1106
    if (nlines > 0) {
#line 1106
      if ((int )(r->vts[page])->screen.tscroll == 0) {
#line 1106
        if ((int )(r->vts[page])->screen.bscroll == (int )r->TermWin.nrow - 1) {
          {
#line 1113
          rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                           nlines, 0);
#line 1115
          adjust_view_start(r, page, nlines);
#line 1117
          (r->vts[page])->screen.cur.row -= nlines;
          }
        }
      }
    }
  }
#line 1134
  if (last_col - 1 < (r->vts[page])->screen.cur.col) {
#line 1134
    (r->vts[page])->screen.cur.col = last_col - 1;
  }
#line 1135
  if ((int32_t )r->TermWin.nrow - 1 < (r->vts[page])->screen.cur.row) {
#line 1135
    (r->vts[page])->screen.cur.row = (int32_t )r->TermWin.nrow - 1;
  }
#line 1136
  if (- ((int32_t )(r->vts[page])->nscrolled) > (r->vts[page])->screen.cur.row) {
#line 1136
    (r->vts[page])->screen.cur.row = - ((int32_t )(r->vts[page])->nscrolled);
  }
#line 1138
  row = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
#line 1140
  if (r->selection.op) {
#line 1140
    if ((int )r->selection.vt == page) {
#line 1140
      if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 1140
        checksel = (unsigned char)1;
      } else {
#line 1140
        checksel = (unsigned char)0;
      }
    } else {
#line 1140
      checksel = (unsigned char)0;
    }
  } else {
#line 1140
    checksel = (unsigned char)0;
  }
#line 1142
  clearsel = (unsigned char)0;
#line 1144
  stp = *((r->vts[page])->screen.text + row);
#line 1145
  srp = *((r->vts[page])->screen.rend + row);
#line 1158
  i = 0;
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1158
    if (! (i < len)) {
#line 1158
      goto while_break;
    }
#line 1160
    tmp = i;
#line 1160
    i ++;
#line 1160
    c = (char )*(str + tmp);
    {
#line 1163
    if ((int )c == 9) {
#line 1163
      goto case_9;
    }
#line 1167
    if ((int )c == 10) {
#line 1167
      goto case_10;
    }
#line 1189
    if ((int )c == 13) {
#line 1189
      goto case_13;
    }
#line 1198
    goto switch_default;
    case_9: /* CIL Label */ 
    {
#line 1164
    rxvt_scr_tab(r, page, 1);
    }
#line 1165
    goto __Cont;
    case_10: /* CIL Label */ 
#line 1169
    if ((int )*((r->vts[page])->screen.tlen + row) != -1) {
#line 1170
      if ((r->vts[page])->screen.cur.col > (int32_t )*((r->vts[page])->screen.tlen + row)) {
#line 1170
        *((r->vts[page])->screen.tlen + row) = (int16_t )(r->vts[page])->screen.cur.col;
      }
    }
#line 1172
    (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1173
    if ((r->vts[page])->screen.cur.row == (int32_t )(r->vts[page])->screen.bscroll) {
      {
#line 1177
      rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                       1, 0);
#line 1179
      adjust_view_start(r, page, 1);
      }
    } else
#line 1181
    if ((r->vts[page])->screen.cur.row < (int )r->TermWin.nrow - 1) {
#line 1182
      ((r->vts[page])->screen.cur.row) ++;
#line 1182
      row = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
    }
#line 1184
    stp = *((r->vts[page])->screen.text + row);
#line 1185
    srp = *((r->vts[page])->screen.rend + row);
#line 1187
    goto __Cont;
    case_13: /* CIL Label */ 
#line 1191
    if ((int )*((r->vts[page])->screen.tlen + row) != -1) {
#line 1192
      if ((r->vts[page])->screen.cur.col > (int32_t )*((r->vts[page])->screen.tlen + row)) {
#line 1192
        *((r->vts[page])->screen.tlen + row) = (int16_t )(r->vts[page])->screen.cur.col;
      }
    }
#line 1193
    (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1194
    (r->vts[page])->screen.cur.col = 0;
#line 1196
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 1271
    if ((int )c == 127) {
#line 1272
      goto __Cont;
    }
#line 1273
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1276
    if (checksel) {
#line 1276
      if (! ((r->vts[page])->screen.cur.row < r->selection.beg.row)) {
#line 1276
        if ((r->vts[page])->screen.cur.row == r->selection.beg.row) {
#line 1276
          if (! ((r->vts[page])->screen.cur.col < r->selection.beg.col)) {
#line 1276
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1276
        if ((r->vts[page])->screen.cur.row < r->selection.end.row) {
#line 1282
          checksel = (unsigned char)0;
#line 1283
          clearsel = (unsigned char)1;
        } else
#line 1276
        if ((r->vts[page])->screen.cur.row == r->selection.end.row) {
#line 1276
          if ((r->vts[page])->screen.cur.col < r->selection.end.col) {
#line 1282
            checksel = (unsigned char)0;
#line 1283
            clearsel = (unsigned char)1;
          }
        }
      }
    }
#line 1286
    if ((r->vts[page])->screen.flags & (unsigned int )(1 << 4)) {
#line 1288
      *((r->vts[page])->screen.tlen + row) = (int16_t )-1;
#line 1289
      if ((r->vts[page])->screen.cur.row == (int32_t )(r->vts[page])->screen.bscroll) {
        {
#line 1291
        rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                         1, 0);
#line 1293
        adjust_view_start(r, page, 1);
        }
      } else
#line 1295
      if ((r->vts[page])->screen.cur.row < (int )r->TermWin.nrow - 1) {
#line 1296
        ((r->vts[page])->screen.cur.row) ++;
#line 1296
        row = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
      }
#line 1297
      stp = *((r->vts[page])->screen.text + row);
#line 1298
      srp = *((r->vts[page])->screen.rend + row);
#line 1299
      (r->vts[page])->screen.cur.col = 0;
#line 1300
      (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
    }
#line 1303
    if ((r->vts[page])->screen.flags & (unsigned int )(1 << 3)) {
      {
#line 1304
      rxvt_scr_insdel_chars(r, page, 1, -1);
      }
    }
#line 1327
    *(stp + (r->vts[page])->screen.cur.col) = (text_t )c;
#line 1328
    *(srp + (r->vts[page])->screen.cur.col) = (r->vts[page])->rstyle;
#line 1329
    if ((r->vts[page])->screen.cur.col < last_col - 1) {
#line 1330
      ((r->vts[page])->screen.cur.col) ++;
    } else {
#line 1333
      *((r->vts[page])->screen.tlen + row) = (int16_t )last_col;
#line 1334
      if ((r->vts[page])->screen.flags & (unsigned int )(1 << 2)) {
#line 1335
        (r->vts[page])->screen.flags |= (unsigned int )(1 << 4);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1339
  if ((int )*((r->vts[page])->screen.tlen + row) != -1) {
#line 1340
    if ((r->vts[page])->screen.cur.col > (int32_t )*((r->vts[page])->screen.tlen + row)) {
#line 1340
      *((r->vts[page])->screen.tlen + row) = (int16_t )(r->vts[page])->screen.cur.col;
    }
  }
#line 1347
  if (clearsel) {
#line 1348
    tmp___2 = 0;
#line 1348
    r->selection.end.col = tmp___2;
#line 1348
    tmp___1 = tmp___2;
#line 1348
    r->selection.end.row = tmp___1;
#line 1348
    tmp___0 = tmp___1;
#line 1348
    r->selection.beg.col = tmp___0;
#line 1348
    r->selection.beg.row = tmp___0;
  }
#line 1351
  if (0 > (r->vts[page])->screen.cur.row) {
#line 1351
    (r->vts[page])->screen.cur.row = 0;
  }
#line 1352
  return;
}
}
#line 1360 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_backspace(rxvt_t *r , int page ) 
{ 


  {
#line 1364
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1365
  if (! ((r->vts[page])->screen.cur.col == 0)) {
#line 1375
    if (((r->vts[page])->screen.flags & (unsigned int )(1 << 4)) == 0U) {
      {
#line 1376
      rxvt_scr_gotorc(r, page, 0, -1, 3);
      }
    }
  }
#line 1377
  (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1378
  return;
}
}
#line 1387 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_tab(rxvt_t *r , int page , int count ) 
{ 
  int i ;
  int x ;

  {
#line 1393
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1395
  x = (r->vts[page])->screen.cur.col;
#line 1395
  i = x;
#line 1396
  if (count == 0) {
#line 1397
    return;
  } else
#line 1398
  if (count > 0) {
    {
#line 1400
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1400
      i ++;
#line 1400
      if (! (i < (int )r->TermWin.ncol)) {
#line 1400
        goto while_break;
      }
#line 1401
      if (*(r->tabstop + i)) {
#line 1403
        x = i;
#line 1404
        count --;
#line 1404
        if (! count) {
#line 1405
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1408
    if (count) {
#line 1409
      x = (int )r->TermWin.ncol - 1;
    }
  } else {
    {
#line 1413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1413
      i --;
#line 1413
      if (! (i >= 0)) {
#line 1413
        goto while_break___0;
      }
#line 1414
      if (*(r->tabstop + i)) {
#line 1416
        x = i;
#line 1417
        count ++;
#line 1417
        if (! count) {
#line 1418
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1421
    if (count) {
#line 1422
      x = 0;
    }
  }
#line 1434
  (r->vts[page])->screen.cur.col = x;
#line 1436
  return;
}
}
#line 1447 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_backindex(rxvt_t *r , int page ) 
{ 


  {
#line 1450
  if ((r->vts[page])->screen.cur.col > 0) {
    {
#line 1451
    rxvt_scr_gotorc(r, page, 0, -1, 3);
    }
  } else {
#line 1454
    if ((int )*((r->vts[page])->screen.tlen + ((r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines)) == 0) {
#line 1455
      return;
    }
    {
#line 1456
    rxvt_scr_insdel_chars(r, page, 1, -1);
    }
  }
#line 1458
  return;
}
}
#line 1469 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_forwardindex(rxvt_t *r , int page ) 
{ 
  int row ;

  {
#line 1474
  if ((r->vts[page])->screen.cur.col < (int )r->TermWin.ncol - 1) {
    {
#line 1475
    rxvt_scr_gotorc(r, page, 0, 1, 3);
    }
  } else {
#line 1478
    row = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
#line 1479
    if ((int )*((r->vts[page])->screen.tlen + row) == 0) {
#line 1480
      return;
    } else
#line 1481
    if ((int )*((r->vts[page])->screen.tlen + row) == -1) {
#line 1482
      *((r->vts[page])->screen.tlen + row) = (int16_t )r->TermWin.ncol;
    }
    {
#line 1483
    rxvt_scr_gotorc(r, page, 0, 0, 2);
#line 1484
    rxvt_scr_insdel_chars(r, page, 1, 1);
#line 1485
    rxvt_scr_gotorc(r, 0, page, (int )r->TermWin.ncol - 1, 2);
    }
  }
#line 1487
  return;
}
}
#line 1495 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_gotorc(rxvt_t *r , int page , int row , int col , int relative ) 
{ 


  {
#line 1498
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1499
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1499
    (r->vts[page])->view_start = (uint16_t )0;
  }
#line 1504
  if (relative & 1) {
#line 1504
    (r->vts[page])->screen.cur.col += col;
  } else {
#line 1504
    (r->vts[page])->screen.cur.col = col;
  }
#line 1506
  if (0 > (r->vts[page])->screen.cur.col) {
#line 1506
    (r->vts[page])->screen.cur.col = 0;
  }
#line 1507
  if ((int32_t )r->TermWin.ncol - 1 < (r->vts[page])->screen.cur.col) {
#line 1507
    (r->vts[page])->screen.cur.col = (int32_t )r->TermWin.ncol - 1;
  }
#line 1509
  (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1510
  if (relative & 2) {
#line 1512
    if (row > 0) {
#line 1514
      if ((r->vts[page])->screen.cur.row <= (int32_t )(r->vts[page])->screen.bscroll) {
#line 1514
        if ((r->vts[page])->screen.cur.row + row > (int32_t )(r->vts[page])->screen.bscroll) {
#line 1516
          (r->vts[page])->screen.cur.row = (int32_t )(r->vts[page])->screen.bscroll;
        } else {
#line 1518
          (r->vts[page])->screen.cur.row += row;
        }
      } else {
#line 1518
        (r->vts[page])->screen.cur.row += row;
      }
    } else
#line 1521
    if (row < 0) {
#line 1523
      if ((r->vts[page])->screen.cur.row >= (int32_t )(r->vts[page])->screen.tscroll) {
#line 1523
        if ((r->vts[page])->screen.cur.row + row < (int32_t )(r->vts[page])->screen.tscroll) {
#line 1525
          (r->vts[page])->screen.cur.row = (int32_t )(r->vts[page])->screen.tscroll;
        } else {
#line 1527
          (r->vts[page])->screen.cur.row += row;
        }
      } else {
#line 1527
        (r->vts[page])->screen.cur.row += row;
      }
    }
  } else
#line 1532
  if ((r->vts[page])->screen.flags & 1U) {
#line 1535
    (r->vts[page])->screen.cur.row = row + (int )(r->vts[page])->screen.tscroll;
#line 1536
    if ((int )(r->vts[page])->screen.bscroll < (r->vts[page])->screen.cur.row) {
#line 1536
      (r->vts[page])->screen.cur.row = (int32_t )(r->vts[page])->screen.bscroll;
    }
  } else {
#line 1539
    (r->vts[page])->screen.cur.row = row;
  }
#line 1541
  if (0 > (r->vts[page])->screen.cur.row) {
#line 1541
    (r->vts[page])->screen.cur.row = 0;
  }
#line 1542
  if ((int32_t )r->TermWin.nrow - 1 < (r->vts[page])->screen.cur.row) {
#line 1542
    (r->vts[page])->screen.cur.row = (int32_t )r->TermWin.nrow - 1;
  }
#line 1543
  return;
}
}
#line 1550 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_index(rxvt_t *r , int page , enum page_dirn direction ) 
{ 
  int dirn ;

  {
#line 1555
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1556
  if ((unsigned int )direction == 0U) {
#line 1556
    dirn = 1;
  } else {
#line 1556
    dirn = -1;
  }
#line 1559
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1559
    (r->vts[page])->view_start = (uint16_t )0;
  }
#line 1562
  (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1563
  if ((r->vts[page])->screen.cur.row == (int32_t )(r->vts[page])->screen.bscroll) {
#line 1563
    if ((unsigned int )direction == 0U) {
      {
#line 1565
      rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                       dirn, 0);
      }
    } else {
#line 1563
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1563
  if ((r->vts[page])->screen.cur.row == (int32_t )(r->vts[page])->screen.tscroll) {
#line 1563
    if ((unsigned int )direction == 1U) {
      {
#line 1565
      rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                       dirn, 0);
      }
    } else {
#line 1568
      (r->vts[page])->screen.cur.row += dirn;
    }
  } else {
#line 1568
    (r->vts[page])->screen.cur.row += dirn;
  }
#line 1569
  if (0 > (r->vts[page])->screen.cur.row) {
#line 1569
    (r->vts[page])->screen.cur.row = 0;
  }
#line 1570
  if ((int32_t )r->TermWin.nrow - 1 < (r->vts[page])->screen.cur.row) {
#line 1570
    (r->vts[page])->screen.cur.row = (int32_t )r->TermWin.nrow - 1;
  }
  {
#line 1571
  rxvt_selection_check(r, page, 0);
  }
#line 1572
  return;
}
}
#line 1582 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_erase_line(rxvt_t *r , int page , int mode ) 
{ 
  unsigned int row ;
  unsigned int col ;
  unsigned int num ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t tmp___5 ;
  int32_t tmp___6 ;
  int32_t tmp___7 ;

  {
#line 1587
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1589
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1589
    (r->vts[page])->view_start = (uint16_t )0;
  }
  {
#line 1591
  rxvt_selection_check(r, page, 1);
#line 1593
  (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1595
  row = (unsigned int )((int )(r->vts[page])->saveLines + (r->vts[page])->screen.cur.row);
  }
  {
#line 1598
  if (mode == 0) {
#line 1598
    goto case_0;
  }
#line 1608
  if (mode == 1) {
#line 1608
    goto case_1;
  }
#line 1617
  if (mode == 2) {
#line 1617
    goto case_2;
  }
#line 1624
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1599
  col = (unsigned int )(r->vts[page])->screen.cur.col;
#line 1600
  num = (unsigned int )r->TermWin.ncol - col;
#line 1601
  if ((int )((int16_t )col) < (int )*((r->vts[page])->screen.tlen + row)) {
#line 1601
    *((r->vts[page])->screen.tlen + row) = (int16_t )col;
  }
#line 1602
  if (r->selection.beg.row == (r->vts[page])->screen.cur.row) {
#line 1602
    if (r->selection.beg.col >= (r->vts[page])->screen.cur.col) {
#line 1602
      goto _L;
    } else {
#line 1602
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1602
  if (r->selection.end.row == (r->vts[page])->screen.cur.row) {
#line 1602
    if (r->selection.end.col >= (r->vts[page])->screen.cur.col) {
      _L: /* CIL Label */ 
#line 1606
      tmp___1 = 0;
#line 1606
      r->selection.end.col = tmp___1;
#line 1606
      tmp___0 = tmp___1;
#line 1606
      r->selection.end.row = tmp___0;
#line 1606
      tmp = tmp___0;
#line 1606
      r->selection.beg.col = tmp;
#line 1606
      r->selection.beg.row = tmp;
    }
  }
#line 1607
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1609
  col = 0U;
#line 1610
  num = (unsigned int )((r->vts[page])->screen.cur.col + 1);
#line 1611
  if (r->selection.beg.row == (r->vts[page])->screen.cur.row) {
#line 1611
    if (r->selection.beg.col <= (r->vts[page])->screen.cur.col) {
#line 1611
      goto _L___1;
    } else {
#line 1611
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1611
  if (r->selection.end.row == (r->vts[page])->screen.cur.row) {
#line 1611
    if (r->selection.end.col <= (r->vts[page])->screen.cur.col) {
      _L___1: /* CIL Label */ 
#line 1615
      tmp___4 = 0;
#line 1615
      r->selection.end.col = tmp___4;
#line 1615
      tmp___3 = tmp___4;
#line 1615
      r->selection.end.row = tmp___3;
#line 1615
      tmp___2 = tmp___3;
#line 1615
      r->selection.beg.col = tmp___2;
#line 1615
      r->selection.beg.row = tmp___2;
    }
  }
#line 1616
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1618
  col = 0U;
#line 1619
  num = (unsigned int )r->TermWin.ncol;
#line 1620
  *((r->vts[page])->screen.tlen + row) = (int16_t )0;
#line 1621
  if (r->selection.beg.row <= (r->vts[page])->screen.cur.row) {
#line 1621
    if (r->selection.end.row >= (r->vts[page])->screen.cur.row) {
#line 1622
      tmp___7 = 0;
#line 1622
      r->selection.end.col = tmp___7;
#line 1622
      tmp___6 = tmp___7;
#line 1622
      r->selection.end.row = tmp___6;
#line 1622
      tmp___5 = tmp___6;
#line 1622
      r->selection.beg.col = tmp___5;
#line 1622
      r->selection.beg.row = tmp___5;
    }
  }
#line 1623
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1625
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1628
  if (*((r->vts[page])->screen.text + row)) {
    {
#line 1629
    rxvt_blank_line(*((r->vts[page])->screen.text + row) + col, *((r->vts[page])->screen.rend + row) + col,
                    num, (r->vts[page])->rstyle);
    }
  } else {
    {
#line 1632
    rxvt_blank_screen_mem(r, page, (r->vts[page])->screen.text, (r->vts[page])->screen.rend,
                          row, (r->vts[page])->rstyle);
    }
  }
#line 1634
  return;
}
}
#line 1644 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_erase_screen(rxvt_t *r , int page , int mode ) 
{ 
  int num ;
  int32_t row ;
  int32_t row_offset ;
  uint32_t ren ;
  XGCValues gcvalue ;
  int sr ;
  int non_empty ;
  int sc ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int tmp___2 ;

  {
#line 1652
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1654
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1654
    (r->vts[page])->view_start = (uint16_t )0;
  }
#line 1656
  row_offset = (int32_t )(r->vts[page])->saveLines;
  {
#line 1660
  if (mode == 0) {
#line 1660
    goto case_0;
  }
#line 1666
  if (mode == 1) {
#line 1666
    goto case_1;
  }
#line 1672
  if (mode == 2) {
#line 1672
    goto case_2;
  }
#line 1718
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1661
  rxvt_selection_check(r, page, 1);
#line 1662
  rxvt_scr_erase_line(r, page, 0);
#line 1663
  row = (r->vts[page])->screen.cur.row + 1;
#line 1664
  num = (int )r->TermWin.nrow - row;
  }
#line 1665
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1667
  rxvt_selection_check(r, page, 3);
#line 1668
  rxvt_scr_erase_line(r, page, 1);
#line 1669
  row = 0;
#line 1670
  num = (r->vts[page])->screen.cur.row;
  }
#line 1671
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1678
  if ((int )(r->vts[page])->current_screen == 0) {
#line 1688
    sr = ((int )(r->vts[page])->saveLines + (int )r->TermWin.nrow) - 1;
    {
#line 1688
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1688
      if (! (sr >= (int )(r->vts[page])->saveLines)) {
#line 1688
        goto while_break;
      }
#line 1690
      non_empty = 0;
#line 1692
      sc = 0;
      {
#line 1692
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1692
        if (! (sc < (int )*((r->vts[page])->screen.tlen + sr))) {
#line 1692
          goto while_break___0;
        }
#line 1693
        if ((int )*(*((r->vts[page])->screen.text + sr) + sc) != 0) {
#line 1693
          if ((int )*(*((r->vts[page])->screen.text + sr) + sc) != 32) {
#line 1698
            non_empty = 1;
#line 1699
            goto while_break___0;
          }
        }
#line 1692
        sc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1702
      if (non_empty) {
#line 1702
        goto while_break;
      }
#line 1688
      sr --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1705
    sr -= (int )(r->vts[page])->saveLines;
#line 1708
    if (sr > 0) {
      {
#line 1709
      rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                       sr, 0);
      }
    }
  } else {
    {
#line 1713
    rxvt_selection_check(r, page, 3);
    }
  }
#line 1715
  row = 0;
#line 1716
  num = (int )r->TermWin.nrow;
#line 1717
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1719
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1722
  (r->h)->refresh_type = (unsigned char )((int )(r->h)->refresh_type | (1 << 3));
#line 1723
  if (r->selection.op) {
#line 1723
    if ((int )r->selection.vt == page) {
#line 1723
      if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 1723
        if (r->selection.beg.row >= row) {
#line 1723
          if (r->selection.beg.row <= row + num) {
#line 1723
            goto _L;
          } else {
#line 1723
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1723
        if (r->selection.end.row >= row) {
#line 1723
          if (r->selection.end.row <= row + num) {
            _L: /* CIL Label */ 
#line 1732
            tmp___1 = 0;
#line 1732
            r->selection.end.col = tmp___1;
#line 1732
            tmp___0 = tmp___1;
#line 1732
            r->selection.end.row = tmp___0;
#line 1732
            tmp = tmp___0;
#line 1732
            r->selection.beg.col = tmp;
#line 1732
            r->selection.beg.row = tmp;
          }
        }
      }
    }
  }
#line 1735
  if (row >= (int32_t )r->TermWin.nrow) {
#line 1736
    return;
  }
#line 1738
  if ((int )r->TermWin.nrow - row < num) {
#line 1738
    num = (int )r->TermWin.nrow - row;
  }
#line 1739
  if ((r->vts[page])->rstyle & 3145728U) {
#line 1740
    ren = (uint32_t )(~ 0);
  } else
#line 1742
  if (((r->vts[page])->rstyle & 261632U) >> 9 == 1U) {
#line 1744
    ren = (uint32_t )(1 << 9);
#line 1745
    if (r->TermWin.mapped) {
      {
#line 1745
      rxvt_clear_area(r, page, (int )r->TermWin.int_bwidth, row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                      (unsigned int )((r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth),
                      (unsigned int )(num * (int32_t )r->TermWin.fheight));
      }
    }
  } else {
    {
#line 1750
    ren = (r->vts[page])->rstyle & 262143U;
#line 1752
    gcvalue.foreground = *(r->pixColors + (((r->vts[page])->rstyle & 261632U) >> 9));
#line 1753
    XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
#line 1754
    rxvt_fill_rectangle(r, page, (int )r->TermWin.int_bwidth, row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                        (unsigned int )((r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth),
                        (unsigned int )(num * (int32_t )r->TermWin.fheight));
#line 1756
    gcvalue.foreground = *(r->pixColors + 0);
#line 1757
    XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
    }
  }
  {
#line 1760
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1760
    tmp___2 = num;
#line 1760
    num --;
#line 1760
    if (! tmp___2) {
#line 1760
      goto while_break___1;
    }
    {
#line 1762
    rxvt_blank_screen_mem(r, page, (r->vts[page])->screen.text, (r->vts[page])->screen.rend,
                          (unsigned int )(row + row_offset), (r->vts[page])->rstyle);
#line 1765
    *((r->vts[page])->screen.tlen + (row + row_offset)) = (int16_t )0;
#line 1766
    rxvt_blank_line(*((r->vts[page])->drawn_text + row), *((r->vts[page])->drawn_rend + row),
                    (unsigned int )r->TermWin.ncol, ren);
#line 1760
    row ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1770
  return;
}
}
#line 1778 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_E(rxvt_t *r , int page ) 
{ 
  int i ;
  int j ;
  int k ;
  uint32_t *r1 ;
  uint32_t fs ;
  uint32_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1784
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1785
  (r->h)->num_scr_allow = (unsigned char)0;
#line 1786
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1786
    (r->vts[page])->view_start = (uint16_t )0;
  }
  {
#line 1788
  rxvt_selection_check(r, page, 3);
#line 1790
  fs = (r->vts[page])->rstyle;
#line 1791
  k = (int )(r->vts[page])->saveLines;
#line 1791
  i = (int )r->TermWin.nrow;
  }
  {
#line 1791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1791
    tmp___1 = i;
#line 1791
    i --;
#line 1791
    if (! tmp___1) {
#line 1791
      goto while_break;
    }
    {
#line 1794
    *((r->vts[page])->screen.tlen + k) = (int16_t )r->TermWin.ncol;
#line 1795
    memset((void *)*((r->vts[page])->screen.text + k), 'E', (size_t )r->TermWin.ncol);
#line 1796
    r1 = *((r->vts[page])->screen.rend + k);
#line 1796
    j = (int )r->TermWin.ncol;
    }
    {
#line 1796
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1796
      tmp___0 = j;
#line 1796
      j --;
#line 1796
      if (! tmp___0) {
#line 1796
        goto while_break___0;
      }
#line 1797
      tmp = r1;
#line 1797
      r1 ++;
#line 1797
      *tmp = fs;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1791
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1799
  return;
}
}
#line 1806 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_insdel_lines(rxvt_t *r , int page , int count , int insdel ) 
{ 
  int end ;

  {
#line 1811
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1811
    (r->vts[page])->view_start = (uint16_t )0;
  }
  {
#line 1813
  rxvt_selection_check(r, page, 1);
  }
#line 1815
  if ((r->vts[page])->screen.cur.row > (int32_t )(r->vts[page])->screen.bscroll) {
#line 1816
    return;
  }
#line 1818
  end = ((int )(r->vts[page])->screen.bscroll - (r->vts[page])->screen.cur.row) + 1;
#line 1819
  if (count > end) {
#line 1821
    if (insdel == 1) {
#line 1822
      return;
    } else
#line 1823
    if (insdel == -1) {
#line 1824
      count = end;
    }
  }
  {
#line 1826
  (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1828
  rxvt_scroll_text(r, page, (r->vts[page])->screen.cur.row, (int )(r->vts[page])->screen.bscroll,
                   insdel * count, 0);
  }
#line 1830
  return;
}
}
#line 1837 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_insdel_chars(rxvt_t *r , int page , int count , int insdel ) 
{ 
  int col ;
  int row ;
  uint32_t tr ;
  text_t *stp ;
  uint32_t *srp ;
  int16_t *slp ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;

  {
#line 1846
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1847
  if (! ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL))) {
#line 1847
    (r->vts[page])->view_start = (uint16_t )0;
  }
#line 1851
  if (count <= 0) {
#line 1852
    return;
  }
  {
#line 1854
  rxvt_selection_check(r, page, 1);
  }
#line 1855
  if ((int )r->TermWin.ncol - (r->vts[page])->screen.cur.col < count) {
#line 1855
    count = (int )r->TermWin.ncol - (r->vts[page])->screen.cur.col;
  }
#line 1857
  row = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
#line 1858
  (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 4));
#line 1860
  stp = *((r->vts[page])->screen.text + row);
#line 1861
  srp = *((r->vts[page])->screen.rend + row);
#line 1862
  slp = (r->vts[page])->screen.tlen + row;
  {
#line 1865
  if (insdel == -1) {
#line 1865
    goto case_neg_1;
  }
#line 1899
  if (insdel == 2) {
#line 1899
    goto case_2;
  }
#line 1908
  if (insdel == 1) {
#line 1908
    goto case_1;
  }
#line 1863
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 1866
  col = (int )r->TermWin.ncol - 1;
  {
#line 1866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if (! (col - count >= (r->vts[page])->screen.cur.col)) {
#line 1866
      goto while_break;
    }
#line 1868
    *(stp + col) = *(stp + (col - count));
#line 1869
    *(srp + col) = *(srp + (col - count));
#line 1866
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1871
  if ((int )*slp != -1) {
#line 1873
    *slp = (int16_t )((int )*slp + count);
#line 1874
    if ((int )r->TermWin.ncol < (int )*slp) {
#line 1874
      *slp = (int16_t )r->TermWin.ncol;
    }
  }
#line 1876
  if (r->selection.op) {
#line 1876
    if ((int )r->selection.vt == page) {
#line 1876
      if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 1876
        if (r->selection.beg.row == (r->vts[page])->screen.cur.row) {
#line 1876
          if (r->selection.beg.col >= (r->vts[page])->screen.cur.col) {
#line 1882
            if (r->selection.end.row != (r->vts[page])->screen.cur.row) {
#line 1882
              goto _L;
            } else
#line 1882
            if (r->selection.end.col + count >= (int32_t )r->TermWin.ncol) {
              _L: /* CIL Label */ 
#line 1886
              tmp___1 = 0;
#line 1886
              r->selection.end.col = tmp___1;
#line 1886
              tmp___0 = tmp___1;
#line 1886
              r->selection.end.row = tmp___0;
#line 1886
              tmp = tmp___0;
#line 1886
              r->selection.beg.col = tmp;
#line 1886
              r->selection.beg.row = tmp;
            } else {
#line 1889
              r->selection.beg.col += count;
#line 1890
              r->selection.mark.col += count;
#line 1891
              r->selection.end.col += count;
            }
          }
        }
      }
    }
  }
  {
#line 1894
  rxvt_blank_line(stp + (r->vts[page])->screen.cur.col, srp + (r->vts[page])->screen.cur.col,
                  (unsigned int )count, (r->vts[page])->rstyle);
  }
#line 1897
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1900
  (r->vts[page])->screen.cur.col += count;
#line 1901
  rxvt_selection_check(r, page, 1);
#line 1902
  (r->vts[page])->screen.cur.col -= count;
#line 1903
  rxvt_blank_line(stp + (r->vts[page])->screen.cur.col, srp + (r->vts[page])->screen.cur.col,
                  (unsigned int )count, (r->vts[page])->rstyle);
  }
#line 1906
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1909
  tr = *(srp + ((int )r->TermWin.ncol - 1)) & 4194303U;
#line 1911
  col = (r->vts[page])->screen.cur.col;
  {
#line 1911
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1911
    if (! (col + count < (int )r->TermWin.ncol)) {
#line 1911
      goto while_break___0;
    }
#line 1913
    *(stp + col) = *(stp + (col + count));
#line 1914
    *(srp + col) = *(srp + (col + count));
#line 1911
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1916
  rxvt_blank_line(stp + ((int )r->TermWin.ncol - count), srp + ((int )r->TermWin.ncol - count),
                  (unsigned int )count, tr);
  }
#line 1919
  if ((int )*slp == -1) {
#line 1920
    *slp = (int16_t )r->TermWin.ncol;
  }
#line 1921
  *slp = (int16_t )((int )*slp - count);
#line 1922
  if (0 > (int )*slp) {
#line 1922
    *slp = (int16_t )0;
  }
#line 1923
  if (r->selection.op) {
#line 1923
    if ((int )r->selection.vt == page) {
#line 1923
      if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 1923
        if (r->selection.beg.row == (r->vts[page])->screen.cur.row) {
#line 1923
          if (r->selection.beg.col >= (r->vts[page])->screen.cur.col) {
#line 1929
            if (r->selection.end.row != (r->vts[page])->screen.cur.row) {
#line 1929
              goto _L___0;
            } else
#line 1929
            if ((r->vts[page])->screen.cur.col >= r->selection.beg.col - count) {
#line 1929
              goto _L___0;
            } else
#line 1929
            if (r->selection.end.col >= (int32_t )r->TermWin.ncol) {
              _L___0: /* CIL Label */ 
#line 1934
              tmp___4 = 0;
#line 1934
              r->selection.end.col = tmp___4;
#line 1934
              tmp___3 = tmp___4;
#line 1934
              r->selection.end.row = tmp___3;
#line 1934
              tmp___2 = tmp___3;
#line 1934
              r->selection.beg.col = tmp___2;
#line 1934
              r->selection.beg.row = tmp___2;
            } else {
#line 1938
              r->selection.beg.col -= count;
#line 1939
              r->selection.mark.col -= count;
#line 1940
              r->selection.end.col -= count;
            }
          }
        }
      }
    }
  }
#line 1943
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1957
  return;
}
}
#line 1965 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_scroll_region(rxvt_t *r , int page , int top , int bot ) 
{ 


  {
#line 1971
  if (0 > top) {
#line 1971
    top = 0;
  }
#line 1972
  if ((int )r->TermWin.nrow - 1 < bot) {
#line 1972
    bot = (int )r->TermWin.nrow - 1;
  }
#line 1973
  if (top > bot) {
#line 1974
    return;
  }
  {
#line 1975
  (r->vts[page])->screen.tscroll = (uint16_t )top;
#line 1976
  (r->vts[page])->screen.bscroll = (uint16_t )bot;
#line 1977
  rxvt_scr_gotorc(r, page, 0, 0, 0);
  }
#line 1978
  return;
}
}
#line 1987 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_cursor_visible(rxvt_t *r , int page , int mode ) 
{ 


  {
#line 1990
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 1991
  if (mode) {
#line 1992
    (r->vts[page])->screen.flags |= (unsigned int )(1 << 1);
  } else {
#line 1994
    (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 1));
  }
#line 1995
  return;
}
}
#line 2004 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_autowrap(rxvt_t *r , int page , int mode ) 
{ 


  {
#line 2007
  if (mode) {
#line 2008
    (r->vts[page])->screen.flags |= (unsigned int )(1 << 2);
  } else {
#line 2010
    (r->vts[page])->screen.flags &= (unsigned int )(~ ((1 << 2) | (1 << 4)));
  }
#line 2011
  return;
}
}
#line 2024 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_relative_origin(rxvt_t *r , int page , int mode ) 
{ 


  {
#line 2027
  if (mode) {
#line 2028
    (r->vts[page])->screen.flags |= 1U;
  } else {
#line 2030
    (r->vts[page])->screen.flags &= 4294967294U;
  }
  {
#line 2031
  rxvt_scr_gotorc(r, page, 0, 0, 0);
  }
#line 2032
  return;
}
}
#line 2041 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_insert_mode(rxvt_t *r , int page , int mode ) 
{ 


  {
#line 2044
  if (mode) {
#line 2045
    (r->vts[page])->screen.flags |= (unsigned int )(1 << 3);
  } else {
#line 2047
    (r->vts[page])->screen.flags &= (unsigned int )(~ (1 << 3));
  }
#line 2048
  return;
}
}
#line 2058 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_set_tab(rxvt_t *r , int page , int mode ) 
{ 


  {
#line 2061
  if (mode < 0) {
    {
#line 2062
    memset((void *)r->tabstop, 0, (unsigned long )r->TermWin.ncol * sizeof(char ));
    }
  } else
#line 2063
  if ((r->vts[page])->screen.cur.col < (int32_t )r->TermWin.ncol) {
#line 2064
    if (mode) {
#line 2064
      *(r->tabstop + (r->vts[page])->screen.cur.col) = (char)1;
    } else {
#line 2064
      *(r->tabstop + (r->vts[page])->screen.cur.col) = (char)0;
    }
  }
#line 2065
  return;
}
}
#line 2074 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_rvideo_mode(rxvt_t *r , int page , int mode ) 
{ 
  unsigned long swapittmp ;
  unsigned long swapittmp___0 ;

  {
#line 2079
  if ((int )(r->vts[page])->rvideo != mode) {
#line 2081
    (r->vts[page])->rvideo = (char )mode;
#line 2083
    swapittmp = (r->vts[page])->p_fg;
#line 2083
    (r->vts[page])->p_fg = (r->vts[page])->p_bg;
#line 2083
    (r->vts[page])->p_bg = swapittmp;
#line 2088
    if (r->TermWin.fade) {
#line 2090
      swapittmp___0 = (r->vts[page])->p_fgfade;
#line 2090
      (r->vts[page])->p_fgfade = (r->vts[page])->p_bgfade;
#line 2090
      (r->vts[page])->p_bgfade = swapittmp___0;
    }
#line 2099
    if (page == (int )r->tabBar.atab) {
      {
#line 2102
      r->fgbg_tabnum = -1;
#line 2103
      rxvt_set_vt_colors(r, (int )r->tabBar.atab);
      }
    }
    {
#line 2106
    rxvt_scr_clear(r, page);
#line 2107
    rxvt_scr_touch(r, page, 1);
    }
  }
#line 2109
  return;
}
}
#line 2117 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_report_position(rxvt_t *r , int page ) 
{ 


  {
  {
#line 2120
  rxvt_tt_printf(r, page, "\033[%d;%dR", (r->vts[page])->screen.cur.row + 1, (r->vts[page])->screen.cur.col + 1);
  }
#line 2121
  return;
}
}
#line 2131 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_set_font_style(rxvt_t *r , int page ) 
{ 


  {
#line 2134
  (r->vts[page])->rstyle &= 4282384383U;
  {
#line 2137
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 48) {
#line 2137
    goto case_48;
  }
#line 2140
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 65) {
#line 2140
    goto case_65;
  }
#line 2143
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 66) {
#line 2143
    goto case_66;
  }
#line 2145
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 60) {
#line 2145
    goto case_60;
  }
#line 2147
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 53) {
#line 2147
    goto case_53;
  }
#line 2149
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 67) {
#line 2149
    goto case_67;
  }
#line 2151
  if ((int )(r->vts[page])->charsets[(r->vts[page])->screen.charset] == 75) {
#line 2151
    goto case_75;
  }
#line 2135
  goto switch_break;
  case_48: /* CIL Label */ 
#line 2138
  (r->vts[page])->rstyle |= 4194304U;
#line 2139
  goto switch_break;
  case_65: /* CIL Label */ 
#line 2141
  (r->vts[page])->rstyle |= 8388608U;
#line 2142
  goto switch_break;
  case_66: /* CIL Label */ 
#line 2144
  goto switch_break;
  case_60: /* CIL Label */ 
#line 2146
  goto switch_break;
  case_53: /* CIL Label */ 
#line 2148
  goto switch_break;
  case_67: /* CIL Label */ 
#line 2150
  goto switch_break;
  case_75: /* CIL Label */ 
#line 2152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2154
  return;
}
}
#line 2165 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_charset_choose(rxvt_t *r , int page , int set ) 
{ 


  {
  {
#line 2168
  (r->vts[page])->screen.charset = (uint16_t )set;
#line 2169
  rxvt_set_font_style(r, page);
  }
#line 2170
  return;
}
}
#line 2182 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_charset_set(rxvt_t *r , int page , int set , unsigned int ch ) 
{ 


  {
  {
#line 2189
  (r->vts[page])->charsets[set] = (char )((unsigned char )ch);
#line 2190
  rxvt_set_font_style(r, page);
  }
#line 2191
  return;
}
}
#line 2209 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_expose(rxvt_t *r , int page , int x , int y , int width , int height ,
                     int refresh ) 
{ 
  int i ;
  row_col_t rc[2] ;
  register int j ;
  register int k ;

  {
#line 2217
  if ((unsigned long )(r->vts[page])->drawn_text == (unsigned long )((void *)0)) {
#line 2218
    return;
  }
#line 2220
  if (x > (int )r->TermWin.int_bwidth) {
#line 2220
    x = x;
  } else {
#line 2220
    x = (int )r->TermWin.int_bwidth;
  }
#line 2221
  if (x < r->szHint.width) {
#line 2221
    x = x;
  } else {
#line 2221
    x = r->szHint.width;
  }
#line 2222
  if (y > (int )r->TermWin.int_bwidth) {
#line 2222
    y = y;
  } else {
#line 2222
    y = (int )r->TermWin.int_bwidth;
  }
#line 2223
  if (y < r->szHint.height) {
#line 2223
    y = y;
  } else {
#line 2223
    y = r->szHint.height;
  }
#line 2226
  rc[0].col = (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth;
#line 2227
  rc[0].row = (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 2229
  rc[1].col = (((x + width) + (int )r->TermWin.fwidth) - 1) / (int32_t )r->TermWin.fwidth;
#line 2230
  rc[1].row = ((((y + height) + (int )r->TermWin.fheight) - 1) - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 2233
  i = 0;
  {
#line 2233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2233
    if (! (i < 2)) {
#line 2233
      goto while_break;
    }
#line 2235
    if ((int )r->TermWin.ncol - 1 < rc[i].col) {
#line 2235
      rc[i].col = (int )r->TermWin.ncol - 1;
    }
#line 2236
    if ((int )r->TermWin.nrow - 1 < rc[i].row) {
#line 2236
      rc[i].row = (int )r->TermWin.nrow - 1;
    }
#line 2233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2242
  j = rc[0].col;
#line 2243
  k = (rc[1].col - rc[0].col) + 1;
#line 2245
  i = rc[0].row;
  {
#line 2245
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2245
    if (! (i <= rc[1].row)) {
#line 2245
      goto while_break___0;
    }
    {
#line 2248
    memset((void *)(*((r->vts[page])->drawn_text + i) + j), 0, (size_t )k);
#line 2245
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2252
  if (refresh) {
    {
#line 2255
    rxvt_scr_refresh(r, page, (unsigned char )((1 << 1) | (1 << 3)));
    }
  }
#line 2257
  return;
}
}
#line 2265 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_touch(rxvt_t *r , int page , int refresh ) 
{ 


  {
  {
#line 2269
  rxvt_scr_expose(r, page, 0, 0, (r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth,
                  (r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth,
                  refresh);
  }
#line 2270
  return;
}
}
#line 2278 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_scr_move_to(rxvt_t *r , int page , int y , int len ) 
{ 
  long p ;
  uint16_t oldviewstart ;
  long tmp ;
  int tmp___0 ;

  {
#line 2281
  p = 0L;
#line 2284
  oldviewstart = (r->vts[page])->view_start;
#line 2285
  if (y < len) {
#line 2287
    p = (long )((((int )r->TermWin.nrow + (int )(r->vts[page])->nscrolled) * (len - y)) / len);
#line 2288
    p -= (long )((int )r->TermWin.nrow - 1);
#line 2289
    if (p > 0L) {
#line 2289
      p = p;
    } else {
#line 2289
      p = 0L;
    }
  }
#line 2291
  if (p < (long )(r->vts[page])->nscrolled) {
#line 2291
    tmp = p;
  } else {
#line 2291
    tmp = (long )(r->vts[page])->nscrolled;
  }
  {
#line 2291
  (r->vts[page])->view_start = (uint16_t )tmp;
#line 2294
  tmp___0 = rxvt_scr_change_view(r, page, oldviewstart);
  }
#line 2294
  return (tmp___0);
}
}
#line 2303 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_scr_page(rxvt_t *r , int page , enum page_dirn direction , int nlines ) 
{ 
  int n ;
  uint16_t oldviewstart ;
  int tmp ;

  {
#line 2311
  oldviewstart = (r->vts[page])->view_start;
#line 2312
  if ((unsigned int )direction == 0U) {
#line 2314
    n = (int )(r->vts[page])->view_start + nlines;
#line 2315
    if (n < (int )(r->vts[page])->nscrolled) {
#line 2315
      (r->vts[page])->view_start = (uint16_t )n;
    } else {
#line 2315
      (r->vts[page])->view_start = (r->vts[page])->nscrolled;
    }
  } else {
#line 2319
    n = (int )(r->vts[page])->view_start - nlines;
#line 2320
    if (n > 0) {
#line 2320
      (r->vts[page])->view_start = (uint16_t )n;
    } else {
#line 2320
      (r->vts[page])->view_start = (uint16_t )0;
    }
  }
  {
#line 2322
  tmp = rxvt_scr_change_view(r, page, oldviewstart);
  }
#line 2322
  return (tmp);
}
}
#line 2327 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_scr_change_view(rxvt_t *r , int page , uint16_t oldviewstart ) 
{ 


  {
#line 2330
  if ((int )(r->vts[page])->view_start != (int )oldviewstart) {
#line 2332
    (r->vts[page])->want_refresh = (unsigned char)1;
#line 2333
    (r->vts[page])->num_scr = (uint16_t )((int )(r->vts[page])->num_scr - ((int )(r->vts[page])->view_start - (int )oldviewstart));
  }
#line 2335
  return ((int )(r->vts[page])->view_start - (int )oldviewstart);
}
}
#line 2348 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
static int bellcount  =    0;
#line 2349 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
static struct timeval lastBell  =    {(__time_t )0, (__suseconds_t )0};
#line 2341 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_bell(rxvt_t *r , int page ) 
{ 
  struct timeval tvnow ;
  long tminterval ;
  struct timespec rqt ;
  int tmp ;
  int tmp___0 ;
  XGCValues values ;

  {
  {
#line 2350
  tvnow.tv_sec = (__time_t )0;
#line 2350
  tvnow.tv_usec = (__suseconds_t )0;
#line 2356
  rqt.tv_sec = (__time_t )(r->TermWin.vBellDuration / 1000000000UL);
#line 2357
  rqt.tv_nsec = (__syscall_slong_t )(r->TermWin.vBellDuration % 1000000000UL);
#line 2360
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& tvnow), (__timezone_ptr_t )((void *)0));
  }
#line 2360
  if (tmp___0 >= 0) {
#line 2362
    if (0L == lastBell.tv_sec) {
#line 2362
      if (0L == lastBell.tv_usec) {
#line 2364
        tminterval = 0L;
      } else {
#line 2367
        tminterval = (tvnow.tv_sec - lastBell.tv_sec) * 1000L + (tvnow.tv_usec - lastBell.tv_usec) / 1000L;
      }
    } else {
#line 2367
      tminterval = (tvnow.tv_sec - lastBell.tv_sec) * 1000L + (tvnow.tv_usec - lastBell.tv_usec) / 1000L;
    }
#line 2370
    lastBell = tvnow;
#line 2371
    if (tminterval > 500L) {
#line 2372
      bellcount = 1;
    } else {
#line 2374
      tmp = bellcount;
#line 2374
      bellcount ++;
#line 2374
      if (tmp >= 3) {
#line 2375
        return;
      }
    }
  }
#line 2381
  if ((unsigned long )r->Options[(1UL << 7) & 3UL] & ((1UL << 7) & 0xfffffffffffffffcUL)) {
    {
#line 2383
    XMapWindow(r->Xdisplay, r->TermWin.parent);
    }
  }
#line 2385
  if ((unsigned long )r->Options[(1UL << 5) & 3UL] & ((1UL << 5) & 0xfffffffffffffffcUL)) {
#line 2385
    goto _L___0;
  } else
#line 2385
  if ((unsigned long )r->Options[(1UL << 6) & 3UL] & ((1UL << 6) & 0xfffffffffffffffcUL)) {
#line 2385
    if ((int )r->tabBar.atab == page) {
#line 2385
      if (r->TermWin.focus) {
        _L___0: /* CIL Label */ 
#line 2396
        if ((int )r->tabBar.atab != page) {
#line 2397
          return;
        } else
#line 2396
        if ((int )(r->h)->refresh_type == 0) {
#line 2397
          return;
        }
#line 2404
        if ((r->h)->am_transparent) {
#line 2404
          goto _L;
        } else
#line 2404
        if ((r->h)->am_pixmap_trans) {
          _L: /* CIL Label */ 
          {
#line 2418
          XGetGCValues(r->Xdisplay, r->TermWin.gc, (unsigned long )((1L << 2) | (1L << 8)),
                       & values);
#line 2421
          XSetForeground(r->Xdisplay, r->TermWin.gc, *(r->pixColors + 0));
#line 2423
          XSetFillStyle(r->Xdisplay, r->TermWin.gc, 0);
#line 2425
          XFillRectangle(r->Xdisplay, (r->vts[page])->vt, r->TermWin.gc, (int32_t )r->TermWin.int_bwidth,
                         (int32_t )r->TermWin.int_bwidth, (unsigned int )((int32_t )r->TermWin.ncol * (int32_t )r->TermWin.fwidth),
                         (unsigned int )((int32_t )r->TermWin.nrow * (int32_t )r->TermWin.fheight));
#line 2430
          XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )((1L << 2) | (1L << 8)),
                    & values);
#line 2433
          XSync(r->Xdisplay, 0);
          }
#line 2436
          if (r->TermWin.vBellDuration) {
            {
#line 2437
            nanosleep((struct timespec  const  *)(& rqt), (struct timespec *)((void *)0));
            }
          }
          {
#line 2440
          XClearArea(r->Xdisplay, (r->vts[page])->vt, 0, 0, 0U, 0U, 1);
          }
        } else {
          {
#line 2446
          rxvt_scr_rvideo_mode(r, page, ! (r->vts[page])->rvideo);
#line 2449
          rxvt_scr_refresh(r, page, (r->h)->refresh_type);
#line 2450
          XSync(r->Xdisplay, 0);
          }
#line 2451
          if (r->TermWin.vBellDuration) {
            {
#line 2452
            nanosleep((struct timespec  const  *)(& rqt), (struct timespec *)((void *)0));
            }
          }
          {
#line 2454
          rxvt_scr_rvideo_mode(r, page, ! (r->vts[page])->rvideo);
          }
        }
      } else {
#line 2385
        goto _L___2;
      }
    } else {
#line 2385
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2458
  if ((r->h)->rs[309]) {
#line 2458
    if (*((r->h)->rs[309])) {
      {
#line 2459
      rxvt_async_exec(r, (r->h)->rs[309]);
      }
    } else {
      {
#line 2462
      XBell(r->Xdisplay, 0);
      }
    }
  } else {
    {
#line 2462
    XBell(r->Xdisplay, 0);
    }
  }
#line 2464
  return;
}
}
#line 2479 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
char *escSetColor(char *s , int color , int fg ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2482
  if (color >= 2) {
#line 2482
    if (color < 10) {
#line 2483
      if (fg) {
#line 2483
        tmp = '3';
      } else {
#line 2483
        tmp = '4';
      }
      {
#line 2483
      tmp___0 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%c%d;",
                        tmp, color - 2);
#line 2483
      s += tmp___0;
      }
    } else {
#line 2482
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2485
  if (color >= 10) {
#line 2485
    if (color <= 17) {
#line 2486
      if (fg) {
#line 2486
        tmp___1 = "9";
      } else {
#line 2486
        tmp___1 = "10";
      }
      {
#line 2486
      tmp___2 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s%d;",
                        tmp___1, color - 10);
#line 2486
      s += tmp___2;
      }
    } else {
#line 2485
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2489
  if (color >= 18) {
#line 2489
    if (color <= 257) {
#line 2490
      if (fg) {
#line 2490
        tmp___3 = '3';
      } else {
#line 2490
        tmp___3 = '4';
      }
      {
#line 2490
      tmp___4 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%c8;5;%d;",
                        tmp___3, (color - 18) + 16);
#line 2490
      s += tmp___4;
      }
    }
  }
#line 2496
  return (s);
}
}
#line 2505 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_printscreen(rxvt_t *r , int page , int fullhist , int pretty , int linecont ,
                          char const   *pipeName ) 
{ 
  int row ;
  int col ;
  int nrows ;
  int row_offset ;
  text_t *txt ;
  uint32_t *rnd ;
  FILE *fd ;
  int lineEnd ;
  unsigned short const   **tmp ;
  char escsq[32] ;
  char *s ;
  char *t ;
  int start ;
  int color ;
  uint32_t rend ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 2519
  fd = rxvt_popen_printer(r, pipeName);
  }
#line 2519
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 2520
    return;
  }
#line 2522
  nrows = (int )r->TermWin.nrow;
#line 2523
  row_offset = (int )(r->vts[page])->saveLines;
#line 2524
  if (! fullhist) {
#line 2525
    row_offset -= (int )(r->vts[page])->view_start;
  } else {
#line 2528
    nrows += (int )(r->vts[page])->nscrolled;
#line 2529
    row_offset -= (int )(r->vts[page])->nscrolled;
  }
#line 2532
  row = 0;
  {
#line 2532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2532
    if (row < nrows) {
      {
#line 2532
      tmp___6 = ferror(fd);
      }
#line 2532
      if (tmp___6) {
#line 2532
        goto while_break;
      }
    } else {
#line 2532
      goto while_break;
    }
#line 2536
    txt = *((r->vts[page])->screen.text + (row + row_offset));
#line 2537
    rnd = *((r->vts[page])->screen.rend + (row + row_offset));
#line 2539
    if (linecont) {
#line 2539
      if ((int )*((r->vts[page])->screen.tlen + (row + row_offset)) == -1) {
#line 2541
        lineEnd = (int )r->TermWin.ncol - 1;
      } else {
#line 2539
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2545
      lineEnd = (int )r->TermWin.ncol - 1;
      {
#line 2545
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2545
        if (lineEnd >= 0) {
          {
#line 2545
          tmp = __ctype_b_loc();
          }
#line 2545
          if (! ((int const   )*(*tmp + (int )*(txt + lineEnd)) & 8192)) {
#line 2545
            goto while_break___0;
          }
        } else {
#line 2545
          goto while_break___0;
        }
#line 2545
        lineEnd --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2553
    if (pretty) {
#line 2557
      col = 0;
      {
#line 2557
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2557
        if (! (col <= lineEnd)) {
#line 2557
          goto while_break___1;
        }
#line 2562
        start = col;
#line 2565
        rend = *(rnd + start);
        {
#line 2569
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2571
          col ++;
#line 2569
          if (col <= lineEnd) {
#line 2569
            if (! (*(rnd + col) == rend)) {
#line 2569
              goto while_break___2;
            }
          } else {
#line 2569
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2576
        tmp___0 = sprintf((char */* __restrict  */)(escsq), (char const   */* __restrict  */)"\033[");
#line 2576
        s = escsq + tmp___0;
#line 2576
        t = s;
        }
#line 2578
        if (rend & 262144U) {
          {
#line 2578
          tmp___1 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"1;");
#line 2578
          s += tmp___1;
          }
        }
#line 2579
        if (rend & 2097152U) {
          {
#line 2579
          tmp___2 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"4;");
#line 2579
          s += tmp___2;
          }
        }
#line 2580
        if (rend & 524288U) {
          {
#line 2580
          tmp___3 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"5;");
#line 2580
          s += tmp___3;
          }
        }
#line 2581
        if (rend & 1048576U) {
          {
#line 2581
          tmp___4 = sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"7;");
#line 2581
          s += tmp___4;
          }
        }
#line 2583
        color = (int )(rend & 511U);
#line 2584
        if (color != 0) {
          {
#line 2585
          s = escSetColor(s, color, 1);
          }
        }
#line 2587
        color = (int )((rend & 261632U) >> 9);
#line 2588
        if (color != 1) {
          {
#line 2589
          s = escSetColor(s, color, 0);
          }
        }
#line 2591
        if ((unsigned long )s != (unsigned long )t) {
          {
#line 2597
          tmp___5 = s;
#line 2597
          s --;
#line 2597
          *tmp___5 = (char )'\000';
#line 2598
          *s = (char )'m';
#line 2600
          fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s%.*s\033[0m",
                  escsq, col - start, txt + start);
          }
        } else {
          {
#line 2604
          fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%.*s",
                  col - start, txt + start);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 2611
      fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%.*s",
              lineEnd + 1, txt);
      }
    }
#line 2613
    if (! linecont) {
      {
#line 2614
      fputc('\n', fd);
      }
    } else
#line 2613
    if ((int )*((r->vts[page])->screen.tlen + (row + row_offset)) != -1) {
      {
#line 2614
      fputc('\n', fd);
      }
    }
#line 2532
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2618
  rxvt_pclose_printer(fd);
  }
#line 2620
  return;
}
}
#line 2761 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
__inline static void rxvt_clear_area(rxvt_t *r , int page , int x , int y , unsigned int w ,
                                     unsigned int h ) 
{ 


  {
  {
#line 2766
  XClearArea(r->Xdisplay, (r->vts[page])->vt, x, y, w, h, 0);
  }
#line 2767
  return;
}
}
#line 2770 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
__inline static void rxvt_fill_rectangle(rxvt_t *r , int page , int x , int y , unsigned int w ,
                                         unsigned int h ) 
{ 


  {
  {
#line 2774
  XFillRectangle(r->Xdisplay, (r->vts[page])->vt, r->TermWin.gc, x, y, w, h);
  }
#line 2775
  return;
}
}
#line 2904 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_draw_string_x11(rxvt_t *r , Window win , GC gc , Region refreshRegion ,
                          int x , int y , char *str , int len , int (*draw_string___0)() ) 
{ 


  {
  {
#line 2995
  (*draw_string___0)(r->Xdisplay, win, gc, x, y, str, len);
  }
#line 2996
  return;
}
}
#line 3012 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_draw_string(rxvt_t *r , int page , int x , int y , char *str , int len ,
                          int drawfunc , uint16_t fore , uint16_t back , uint32_t rend ,
                          Region refreshRegion ) 
{ 
  int (*draw_string___0)() ;

  {
  {
#line 3237
  if (drawfunc == 1) {
#line 3237
    goto case_1;
  }
#line 3239
  if (drawfunc == 2) {
#line 3239
    goto case_2;
  }
#line 3241
  if (drawfunc == 3) {
#line 3241
    goto case_3;
  }
#line 3243
  if (drawfunc == 4) {
#line 3243
    goto case_4;
  }
#line 3246
  if (drawfunc == 5) {
#line 3246
    goto case_5;
  }
#line 3250
  if (drawfunc == 8) {
#line 3250
    goto case_8;
  }
#line 3250
  if (drawfunc == 7) {
#line 3250
    goto case_8;
  }
#line 3250
  if (drawfunc == 6) {
#line 3250
    goto case_8;
  }
#line 3253
  if (drawfunc == 9) {
#line 3253
    goto case_9;
  }
#line 3257
  if (drawfunc == 12) {
#line 3257
    goto case_12;
  }
#line 3257
  if (drawfunc == 11) {
#line 3257
    goto case_12;
  }
#line 3257
  if (drawfunc == 10) {
#line 3257
    goto case_12;
  }
#line 3260
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3238
  draw_string___0 = (int (*)())(& XDrawString);
#line 3238
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3240
  draw_string___0 = (int (*)())(& XDrawString16);
#line 3240
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3242
  draw_string___0 = (int (*)())(& XDrawImageString);
#line 3242
  goto switch_break;
  case_4: /* CIL Label */ 
#line 3244
  draw_string___0 = (int (*)())(& XDrawImageString16);
#line 3244
  goto switch_break;
  case_5: /* CIL Label */ 
#line 3247
  draw_string___0 = (int (*)())(& XDrawString);
#line 3247
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 3251
  draw_string___0 = (int (*)())(& XDrawString16);
#line 3251
  goto switch_break;
  case_9: /* CIL Label */ 
#line 3254
  draw_string___0 = (int (*)())(& XDrawImageString);
#line 3254
  goto switch_break;
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 3258
  draw_string___0 = (int (*)())(& XDrawImageString16);
#line 3258
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3261
  draw_string___0 = (int (*)())((void *)0);
#line 3261
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3265
  y += (r->TermWin.font)->ascent;
#line 3268
  if (draw_string___0) {
    {
#line 3269
    rxvt_draw_string_x11(r, (r->vts[page])->vt, r->TermWin.gc, refreshRegion, x, y,
                         str, len, draw_string___0);
    }
  }
#line 3272
  return;
}
}
#line 3310 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_refresh(rxvt_t *r , int page , unsigned char refresh_type ) 
{ 
  unsigned char clearfirst ;
  unsigned char clearlast ;
  unsigned char must_clear ;
  unsigned char already_cleared ;
  unsigned char usingBoldFt ;
  unsigned char loadedBoldFt ;
  unsigned char rvid ;
  unsigned char wbyte ;
  unsigned char showcursor ;
  signed char morecur ;
  uint16_t fore ;
  uint16_t back ;
  int16_t col ;
  int16_t row ;
  int16_t ocrow ;
  int16_t len ;
  int16_t wlen ;
  int i ;
  int row_offset ;
  uint32_t cc1 ;
  XGCValues gcvalue ;
  XFontStruct *wf ;
  uint32_t *drp ;
  uint32_t *srp ;
  text_t *dtp ;
  text_t *stp ;
  char *buffer ;
  int drawfunc ;
  int image_drawfunc ;
  struct rxvt_hidden *h ;
  void *tmp ;
  int tmp___0 ;
  unsigned char setoldcursor ;
  uint32_t ccol1 ;
  uint32_t ccol2 ;
  int currow ;
  int16_t nits ;
  int j ;
  uint32_t *drp2 ;
  text_t *dtp2 ;
  int tmp___1 ;
  int16_t tmp___2 ;
  text_t *tmp___3 ;
  text_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  int16_t tmp___7 ;
  int swapittmp ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char clear_next ;
  int j___0 ;
  int xpixel ;
  int ypixelc ;
  unsigned long gcmask ;
  unsigned char is_font_char ;
  unsigned char is_same_char ;
  text_t t ;
  int tmp___10 ;
  unsigned int tmp___12 ;
  unsigned char fontdiff ;
  unsigned char fprop ;
  uint32_t rend ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  int16_t tmp___15 ;
  text_t tmp___16 ;
  unsigned int tmp___17 ;
  int echars ;
  int16_t tmp___18 ;
  uint16_t swapittmp___0 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  unsigned int tmp___22 ;
  Region tmp___23 ;
  unsigned long pixel ;
  Region tmp___24 ;
  Region tmp___25 ;
  Region tmp___26 ;
  int tmp___27 ;
  unsigned int tmp___28 ;
  int currow___0 ;
  unsigned long gcmask___0 ;
  int tmp___29 ;

  {
#line 3313
  already_cleared = (unsigned char)0;
#line 3327
  morecur = (signed char)0;
#line 3340
  cc1 = (uint32_t )0;
#line 3359
  h = r->h;
#line 3361
  if (! ((int )refresh_type & (1 << 4))) {
#line 3362
    (r->vts[page])->scrolled_lines = 0;
  }
#line 3364
  if ((int )refresh_type == 0) {
#line 3368
    return;
  } else
#line 3364
  if (! (r->vts[page])->mapped) {
#line 3368
    return;
  }
#line 3385
  drawfunc = 1;
#line 3386
  image_drawfunc = 3;
#line 3389
  wbyte = (unsigned char)0;
#line 3389
  must_clear = wbyte;
#line 3389
  clearlast = must_clear;
#line 3389
  clearfirst = clearlast;
#line 3391
  usingBoldFt = (unsigned char)0;
#line 3394
  if ((unsigned long )((void *)0) != (unsigned long )r->TermWin.bfont) {
#line 3403
    loadedBoldFt = (unsigned char)1;
  } else {
#line 3405
    loadedBoldFt = (unsigned char)0;
  }
#line 3408
  if (h->currmaxcol < (int )r->TermWin.ncol) {
    {
#line 3410
    h->currmaxcol = (int )r->TermWin.ncol;
#line 3411
    tmp = rxvt_realloc((void *)h->buffer, sizeof(char ) * (unsigned long )(h->currmaxcol + 1));
#line 3411
    h->buffer = (char *)tmp;
    }
  }
  {
#line 3413
  buffer = h->buffer;
#line 3415
  row_offset = (int )(r->vts[page])->saveLines - (int )(r->vts[page])->view_start;
#line 3421
  XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.font)->fid);
#line 3422
  wf = r->TermWin.font;
  }
#line 3425
  if ((int )refresh_type & (1 << 3)) {
#line 3427
    clearlast = (unsigned char)1;
#line 3427
    clearfirst = clearlast;
#line 3428
    h->refresh_type = (unsigned char )((int )h->refresh_type & ~ (1 << 3));
  }
#line 3434
  if (h->am_transparent) {
#line 3434
    tmp___0 = 1;
  } else
#line 3434
  if (h->am_pixmap_trans) {
#line 3434
    tmp___0 = 1;
  } else {
#line 3434
    tmp___0 = 0;
  }
#line 3434
  must_clear = (unsigned char )((int )must_clear | tmp___0);
#line 3437
  ocrow = (int16_t )h->oldcursor.row;
#line 3442
  gcvalue.foreground = *(r->pixColors + 0);
#line 3443
  gcvalue.background = *(r->pixColors + 1);
#line 3450
  if ((int )refresh_type & (1 << 4)) {
#line 3450
    if ((unsigned long )((Region )0) != (unsigned long )h->refreshRegion) {
      {
#line 3458
      XSetRegion(r->Xdisplay, r->TermWin.gc, h->refreshRegion);
      }
#line 3464
      if (must_clear) {
#line 3464
        already_cleared = (unsigned char)1;
      }
    }
  }
  {
#line 3470
  rxvt_scr_reverse_selection(r, page);
#line 3481
  showcursor = (unsigned char )((r->vts[page])->screen.flags & (unsigned int )(1 << 1));
  }
#line 3483
  if (h->hidden_cursor) {
#line 3484
    showcursor = (unsigned char)0;
  }
#line 3486
  if (showcursor) {
#line 3486
    if (r->TermWin.focus) {
#line 3488
      currow = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
#line 3489
      srp = *((r->vts[page])->screen.rend + currow) + (r->vts[page])->screen.cur.col;
#line 3493
      *srp ^= 1048576U;
#line 3496
      cc1 = *srp & 262143U;
#line 3497
      if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 3497
        if (h->pixcolor_set[8] & (unsigned int )(1 << 2)) {
#line 3498
          ccol1 = (uint32_t )258;
        } else {
#line 3501
          ccol1 = *(*((r->vts[page])->drawn_rend + (r->vts[page])->screen.cur.row) + (r->vts[page])->screen.cur.col) & 511U;
        }
      } else {
#line 3501
        ccol1 = *(*((r->vts[page])->drawn_rend + (r->vts[page])->screen.cur.row) + (r->vts[page])->screen.cur.col) & 511U;
      }
#line 3509
      if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 3509
        if (h->pixcolor_set[8] & (unsigned int )(1 << 2)) {
#line 3509
          if (h->pixcolor_set[8] & (unsigned int )(1 << 3)) {
#line 3514
            ccol2 = (uint32_t )259;
          } else {
#line 3521
            ccol2 = (*(*((r->vts[page])->drawn_rend + (r->vts[page])->screen.cur.row) + (r->vts[page])->screen.cur.col) & 261632U) >> 9;
          }
        } else {
#line 3521
          ccol2 = (*(*((r->vts[page])->drawn_rend + (r->vts[page])->screen.cur.row) + (r->vts[page])->screen.cur.col) & 261632U) >> 9;
        }
      } else {
#line 3521
        ccol2 = (*(*((r->vts[page])->drawn_rend + (r->vts[page])->screen.cur.row) + (r->vts[page])->screen.cur.col) & 261632U) >> 9;
      }
#line 3531
      *srp = (*srp & 4294966784U) | ccol1;
#line 3532
      *srp = (*srp & 4294705663U) | (ccol2 << 9);
    }
  }
#line 3559
  setoldcursor = (unsigned char)0;
#line 3560
  if ((int )ocrow != -1) {
#line 3562
    if ((r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->view_start != (int32_t )ocrow) {
#line 3562
      goto _L;
    } else
#line 3562
    if ((r->vts[page])->screen.cur.col != h->oldcursor.col) {
      _L: /* CIL Label */ 
#line 3564
      if ((int )ocrow < (int )r->TermWin.nrow) {
#line 3564
        if (h->oldcursor.col < (int32_t )r->TermWin.ncol) {
#line 3569
          *(*((r->vts[page])->drawn_rend + ocrow) + h->oldcursor.col) ^= 3145728U;
        }
      }
#line 3581
      if (r->TermWin.focus) {
#line 3582
        h->oldcursor.row = -1;
      } else
#line 3581
      if (! showcursor) {
#line 3582
        h->oldcursor.row = -1;
      } else {
#line 3584
        setoldcursor = (unsigned char)1;
      }
    }
  } else
#line 3587
  if (! r->TermWin.focus) {
#line 3588
    setoldcursor = (unsigned char)1;
  }
#line 3590
  if (setoldcursor) {
#line 3592
    if ((r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->view_start >= (int32_t )r->TermWin.nrow) {
#line 3593
      h->oldcursor.row = -1;
    } else {
#line 3596
      h->oldcursor.row = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->view_start;
#line 3597
      h->oldcursor.col = (r->vts[page])->screen.cur.col;
    }
  }
#line 3612
  i = (int )(r->vts[page])->num_scr;
#line 3613
  if ((int )refresh_type == 1) {
#line 3613
    if (h->num_scr_allow) {
#line 3613
      if (i) {
        {
#line 3613
        tmp___9 = abs(i);
        }
#line 3613
        if (tmp___9 < (int )r->TermWin.nrow) {
#line 3613
          if (! must_clear) {
#line 3626
            j = (int )r->TermWin.nrow;
#line 3627
            len = (int16_t )-1;
#line 3627
            wlen = len;
#line 3628
            if (i > 0) {
#line 3628
              row = (int16_t )0;
            } else {
#line 3628
              row = (int16_t )(j - 1);
            }
            {
#line 3629
            while (1) {
              while_continue: /* CIL Label */ ;
#line 3629
              tmp___8 = j;
#line 3629
              j --;
#line 3629
              if (! (tmp___8 >= 0)) {
#line 3629
                goto while_break;
              }
#line 3631
              if ((int )row + i >= 0) {
#line 3631
                if ((int )row + i < (int )r->TermWin.nrow) {
#line 3631
                  if ((int )row + i != (int )ocrow) {
#line 3633
                    stp = *((r->vts[page])->screen.text + ((int )row + row_offset));
#line 3634
                    srp = *((r->vts[page])->screen.rend + ((int )row + row_offset));
#line 3635
                    dtp = *((r->vts[page])->drawn_text + row);
#line 3636
                    dtp2 = *((r->vts[page])->drawn_text + ((int )row + i));
#line 3637
                    drp = *((r->vts[page])->drawn_rend + row);
#line 3638
                    drp2 = *((r->vts[page])->drawn_rend + ((int )row + i));
#line 3639
                    nits = (int16_t )0;
#line 3639
                    col = (int16_t )r->TermWin.ncol;
                    {
#line 3639
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 3639
                      tmp___2 = col;
#line 3639
                      col = (int16_t )((int )col - 1);
#line 3639
                      if (! tmp___2) {
#line 3639
                        goto while_break___0;
                      }
#line 3640
                      if ((int )*(stp + col) != (int )*(dtp2 + col)) {
#line 3642
                        nits = (int16_t )((int )nits - 1);
                      } else
#line 3640
                      if (*(srp + col) != *(drp2 + col)) {
#line 3642
                        nits = (int16_t )((int )nits - 1);
                      } else
#line 3643
                      if ((int )*(stp + col) != (int )*(dtp + col)) {
#line 3645
                        nits = (int16_t )((int )nits + 1);
                      } else
#line 3643
                      if (*(srp + col) != *(drp + col)) {
#line 3645
                        nits = (int16_t )((int )nits + 1);
                      }
                    }
                    while_break___0: /* CIL Label */ ;
                    }
#line 3646
                    if ((int )nits > 8) {
#line 3648
                      col = (int16_t )r->TermWin.ncol;
                      {
#line 3648
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 3648
                        tmp___7 = col;
#line 3648
                        col = (int16_t )((int )col - 1);
#line 3648
                        if (! tmp___7) {
#line 3648
                          goto while_break___1;
                        }
#line 3650
                        tmp___3 = dtp;
#line 3650
                        dtp ++;
#line 3650
                        tmp___4 = dtp2;
#line 3650
                        dtp2 ++;
#line 3650
                        *tmp___3 = *tmp___4;
#line 3651
                        tmp___5 = drp;
#line 3651
                        drp ++;
#line 3651
                        tmp___6 = drp2;
#line 3651
                        drp2 ++;
#line 3651
                        *tmp___5 = *tmp___6;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
#line 3653
                      if ((int )len == -1) {
#line 3654
                        len = row;
                      }
#line 3655
                      wlen = row;
#line 3656
                      goto __Cont;
                    }
                  }
                }
              }
#line 3660
              if ((int )len != -1) {
#line 3663
                if ((int )wlen < (int )len) {
#line 3664
                  swapittmp = (int )wlen;
#line 3664
                  wlen = len;
#line 3664
                  len = (int16_t )swapittmp;
                }
                {
#line 3667
                XCopyArea(r->Xdisplay, (r->vts[page])->vt, (r->vts[page])->vt, r->TermWin.gc,
                          0, ((int )len + i) * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                          (unsigned int )r->szHint.width, (unsigned int )((((int )wlen - (int )len) + 1) * (int32_t )r->TermWin.fheight),
                          0, (int32_t )len * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth);
#line 3673
                len = (int16_t )-1;
                }
              }
              __Cont: /* CIL Label */ 
#line 3629
              if (i > 0) {
#line 3629
                tmp___1 = 1;
              } else {
#line 3629
                tmp___1 = -1;
              }
#line 3629
              row = (int16_t )((int )row + tmp___1);
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 3683
  row = (int16_t )0;
  {
#line 3683
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3683
    if (! ((int )row < (int )r->TermWin.nrow)) {
#line 3683
      goto while_break___2;
    }
#line 3685
    clear_next = (unsigned char)0;
#line 3694
    stp = *((r->vts[page])->screen.text + ((int )row + row_offset));
#line 3695
    srp = *((r->vts[page])->screen.rend + ((int )row + row_offset));
#line 3696
    dtp = *((r->vts[page])->drawn_text + row);
#line 3697
    drp = *((r->vts[page])->drawn_rend + row);
#line 3708
    col = (int16_t )0;
    {
#line 3708
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3708
      if (! ((int )col < (int )r->TermWin.ncol)) {
#line 3708
        goto while_break___3;
      }
#line 3713
      t = *(dtp + col);
#line 3714
      if ((int )t == (int )*(stp + col)) {
#line 3714
        if (*(drp + col) == *(srp + col)) {
#line 3714
          tmp___10 = 1;
        } else {
#line 3714
          tmp___10 = 0;
        }
      } else {
#line 3714
        tmp___10 = 0;
      }
#line 3714
      is_same_char = (unsigned char )tmp___10;
#line 3715
      if (! clear_next) {
#line 3715
        if (is_same_char) {
#line 3718
          goto __Cont___0;
        } else
#line 3715
        if ((int )t == 0) {
#line 3718
          goto __Cont___0;
        } else
#line 3715
        if ((int )t == 32) {
#line 3718
          goto __Cont___0;
        }
      }
#line 3720
      if (clear_next) {
#line 3723
        clear_next = (unsigned char)0;
#line 3724
        *(dtp + col) = (text_t )0;
#line 3727
        if (is_same_char) {
#line 3728
          goto __Cont___0;
        }
      }
#line 3782
      if ((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] & (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL)) {
#line 3782
        tmp___12 = *(drp + col) & 262144U;
      } else {
#line 3782
        tmp___12 = (unsigned int )((*(drp + col) & 262655U) == 262144U);
      }
#line 3782
      if (tmp___12) {
#line 3782
        j___0 = 1;
      } else {
#line 3782
        j___0 = 0;
      }
#line 3784
      if (j___0) {
#line 3784
        if (r->TermWin.bfont) {
#line 3784
          wf = r->TermWin.bfont;
        } else {
#line 3784
          wf = r->TermWin.font;
        }
      } else {
#line 3784
        wf = r->TermWin.font;
      }
#line 3794
      if (wf->per_char) {
#line 3794
        if ((unsigned int )t >= wf->min_char_or_byte2) {
#line 3794
          if ((unsigned int )t <= wf->max_char_or_byte2) {
#line 3794
            is_font_char = (unsigned char)1;
          } else {
#line 3794
            is_font_char = (unsigned char)0;
          }
        } else {
#line 3794
          is_font_char = (unsigned char)0;
        }
      } else {
#line 3794
        is_font_char = (unsigned char)0;
      }
#line 3795
      if (! is_font_char) {
#line 3795
        goto _L___0;
      } else
#line 3795
      if ((int )(wf->per_char + ((unsigned int )t - wf->min_char_or_byte2))->lbearing < 0) {
        _L___0: /* CIL Label */ 
#line 3797
        if ((int )col == 0) {
#line 3798
          clearfirst = (unsigned char)1;
        } else {
#line 3800
          *(dtp + ((int )col - 1)) = (text_t )0;
        }
      }
#line 3802
      if (! is_font_char) {
#line 3802
        goto _L___1;
      } else
#line 3802
      if ((int )(wf->per_char + ((unsigned int )t - wf->min_char_or_byte2))->width < (int )(wf->per_char + ((unsigned int )t - wf->min_char_or_byte2))->rbearing + j___0) {
        _L___1: /* CIL Label */ 
#line 3805
        if ((int )col == (int )r->TermWin.ncol - 1) {
#line 3806
          clearlast = (unsigned char)1;
        } else {
#line 3808
          clear_next = (unsigned char)1;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 3708
      col = (int16_t )((int )col + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3819
    ypixelc = (int32_t )row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth;
#line 3821
    col = (int16_t )0;
    {
#line 3821
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3821
      if (! ((int )col < (int )r->TermWin.ncol)) {
#line 3821
        goto while_break___4;
      }
#line 3831
      rend = *(srp + col);
#line 3836
      if ((int )*(stp + col) == (int )*(dtp + col)) {
#line 3836
        if (rend == *(drp + col)) {
#line 3851
          goto __Cont___1;
        } else
#line 3836
        if ((int )*(stp + col) == 32) {
#line 3836
          if (rend & 1048576U) {
#line 3836
            tmp___13 = (rend & 15466496U) | ((rend & 511U) << 9);
          } else {
#line 3836
            tmp___13 = rend & 16776704U;
          }
#line 3836
          if (*(drp + col) & 1048576U) {
#line 3836
            tmp___14 = (*(drp + col) & 15466496U) | ((*(drp + col) & 511U) << 9);
          } else {
#line 3836
            tmp___14 = *(drp + col) & 16776704U;
          }
#line 3836
          if (tmp___13 == tmp___14) {
#line 3851
            goto __Cont___1;
          }
        }
      }
#line 3867
      fontdiff = (unsigned char)0;
#line 3868
      len = (int16_t )0;
#line 3869
      tmp___15 = len;
#line 3869
      len = (int16_t )((int )len + 1);
#line 3869
      tmp___16 = *(stp + col);
#line 3869
      *(dtp + col) = tmp___16;
#line 3869
      *(buffer + tmp___15) = (char )tmp___16;
#line 3870
      *(drp + col) = rend;
#line 3871
      xpixel = (int32_t )col * (int32_t )r->TermWin.fwidth + (int32_t )r->TermWin.int_bwidth;
#line 3877
      if ((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] & (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL)) {
#line 3877
        tmp___17 = rend & 262144U;
      } else {
#line 3877
        tmp___17 = (unsigned int )((rend & 262655U) == 262144U);
      }
#line 3877
      if (tmp___17) {
#line 3877
        if ((unsigned long )r->TermWin.bfont != (unsigned long )((void *)0)) {
#line 3878
          fprop = (unsigned char )((int )r->TermWin.propfont & (1 << 1));
        } else {
#line 3881
          fprop = (unsigned char )((int )r->TermWin.propfont & 1);
        }
      } else {
#line 3881
        fprop = (unsigned char )((int )r->TermWin.propfont & 1);
      }
#line 3982
      if (! fprop) {
#line 3987
        i = 0;
#line 3987
        echars = 0;
        {
#line 3987
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3987
          col = (int16_t )((int )col + 1);
#line 3987
          if (! ((int )col < (int )r->TermWin.ncol - 1)) {
#line 3987
            goto while_break___5;
          }
#line 4001
          if (rend != *(srp + col)) {
#line 4003
            goto while_break___5;
          }
#line 4004
          tmp___18 = len;
#line 4004
          len = (int16_t )((int )len + 1);
#line 4004
          *(buffer + tmp___18) = (char )*(stp + col);
#line 4006
          if ((int )*(stp + col) != (int )*(dtp + col)) {
#line 4011
            *(dtp + col) = *(stp + col);
#line 4012
            *(drp + col) = *(srp + col);
#line 4013
            i = 0;
          } else
#line 4006
          if (*(srp + col) != *(drp + col)) {
#line 4011
            *(dtp + col) = *(stp + col);
#line 4012
            *(drp + col) = *(srp + col);
#line 4013
            i = 0;
          } else {
#line 4022
            i ++;
#line 4027
            echars ++;
#line 4027
            if (echars > (int )len >> 2) {
#line 4027
              goto while_break___5;
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 4031
        col = (int16_t )((int )col - 1);
#line 4032
        len = (int16_t )((int )len - i);
      }
#line 4036
      wlen = len;
#line 4038
      *(buffer + len) = (char )'\000';
#line 4043
      fore = (uint16_t )(rend & 511U);
#line 4044
      back = (uint16_t )((rend & 261632U) >> 9);
#line 4045
      rend &= 16515072U;
      {
#line 4049
      if ((rend & 12582912U) == 4194304U) {
#line 4049
        goto case_4194304;
      }
#line 4057
      if ((rend & 12582912U) == 8388608U) {
#line 4057
        goto case_8388608;
      }
#line 4047
      goto switch_break;
      case_4194304: /* CIL Label */ 
#line 4050
      i = 0;
      {
#line 4050
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 4050
        if (! (i < (int )len)) {
#line 4050
          goto while_break___6;
        }
#line 4054
        if ((int )*(buffer + i) > 95) {
#line 4054
          if ((int )*(buffer + i) < 127) {
#line 4055
            *(buffer + i) = (char )((int )*(buffer + i) - 95);
          }
        }
#line 4050
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 4056
      goto switch_break;
      case_8388608: /* CIL Label */ 
#line 4058
      i = 0;
      {
#line 4058
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 4058
        if (! (i < (int )len)) {
#line 4058
          goto while_break___7;
        }
#line 4059
        if ((int )*(buffer + i) == 35) {
#line 4060
          *(buffer + i) = (char)30;
        }
#line 4058
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 4061
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 4069
      if ((int )fore == 0) {
#line 4069
        if ((int )back == 1) {
#line 4074
          if (rend & 262144U) {
#line 4076
            if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 4076
              if (h->pixcolor_set[8] & (unsigned int )(1 << 7)) {
#line 4076
                if (*(r->pixColors + fore) != *(r->pixColors + 263)) {
#line 4076
                  if (*(r->pixColors + back) != *(r->pixColors + 263)) {
#line 4083
                    fore = (uint16_t )263;
#line 4092
                    rend &= 4294705151U;
                  }
                }
              }
            }
          } else
#line 4095
          if (rend & 2097152U) {
#line 4097
            if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 4097
              if (h->pixcolor_set[8] & (unsigned int )(1 << 8)) {
#line 4097
                if (*(r->pixColors + fore) != *(r->pixColors + 264)) {
#line 4097
                  if (*(r->pixColors + back) != *(r->pixColors + 264)) {
#line 4103
                    fore = (uint16_t )264;
#line 4104
                    rend &= 4292870143U;
                  }
                }
              }
            }
          }
        }
      }
#line 4109
      if (rend & 1048576U) {
#line 4109
        rvid = (unsigned char)1;
      } else {
#line 4109
        rvid = (unsigned char)0;
      }
#line 4116
      if (rend & 524288U) {
#line 4118
        if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 4118
          if (h->pixcolor_set[8] & (unsigned int )(1 << 10)) {
#line 4118
            if (*(r->pixColors + fore) != *(r->pixColors + 266)) {
#line 4118
              if (*(r->pixColors + back) != *(r->pixColors + 266)) {
#line 4118
                if (! (h->pixcolor_set[8] & (unsigned int )(1 << 2))) {
#line 4118
                  goto _L___2;
                } else
#line 4118
                if (! r->TermWin.focus) {
#line 4118
                  goto _L___2;
                } else
#line 4118
                if (! showcursor) {
#line 4118
                  goto _L___2;
                } else
#line 4118
                if ((r->vts[page])->screen.cur.row != (int32_t )row) {
#line 4118
                  goto _L___2;
                } else
#line 4118
                if ((r->vts[page])->screen.cur.col != (int32_t )col) {
                  _L___2: /* CIL Label */ 
#line 4132
                  if (rvid) {
#line 4132
                    rvid = (unsigned char)0;
                  }
#line 4133
                  back = (uint16_t )266;
                } else {
#line 4136
                  rvid = (unsigned char)1;
                }
              } else {
#line 4136
                rvid = (unsigned char)1;
              }
            } else {
#line 4136
              rvid = (unsigned char)1;
            }
          } else {
#line 4136
            rvid = (unsigned char)1;
          }
        } else {
#line 4136
          rvid = (unsigned char)1;
        }
      }
#line 4145
      if (rvid) {
#line 4148
        if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 4148
          if (h->pixcolor_set[8] & (unsigned int )(1 << 9)) {
#line 4148
            if (*(r->pixColors + fore) != *(r->pixColors + 265)) {
#line 4148
              if (*(r->pixColors + back) != *(r->pixColors + 265)) {
#line 4148
                if (! (h->pixcolor_set[8] & (unsigned int )(1 << 2))) {
#line 4161
                  back = (uint16_t )265;
                } else
#line 4148
                if (! r->TermWin.focus) {
#line 4161
                  back = (uint16_t )265;
                } else
#line 4148
                if (! showcursor) {
#line 4161
                  back = (uint16_t )265;
                } else
#line 4148
                if ((r->vts[page])->screen.cur.row != (int32_t )row) {
#line 4161
                  back = (uint16_t )265;
                } else
#line 4148
                if ((r->vts[page])->screen.cur.col != (int32_t )col) {
#line 4161
                  back = (uint16_t )265;
                } else {
#line 4166
                  swapittmp___0 = fore;
#line 4166
                  fore = back;
#line 4166
                  back = swapittmp___0;
                }
              } else {
#line 4166
                swapittmp___0 = fore;
#line 4166
                fore = back;
#line 4166
                back = swapittmp___0;
              }
            } else {
#line 4166
              swapittmp___0 = fore;
#line 4166
              fore = back;
#line 4166
              back = swapittmp___0;
            }
          } else {
#line 4166
            swapittmp___0 = fore;
#line 4166
            fore = back;
#line 4166
            back = swapittmp___0;
          }
        } else {
#line 4166
          swapittmp___0 = fore;
#line 4166
          fore = back;
#line 4166
          back = swapittmp___0;
        }
      }
#line 4175
      if (rend & 262144U) {
#line 4175
        if (! ((unsigned long )r->Options[((1UL << 19) | 1UL) & 3UL] & (((1UL << 19) | 1UL) & 0xfffffffffffffffcUL))) {
#line 4177
          if ((int )fore >= 2) {
#line 4177
            if ((int )fore < 10) {
#line 4179
              fore = (uint16_t )((int )fore + 8);
#line 4180
              if (! ((unsigned long )r->Options[((1UL << 20) | 1UL) & 3UL] & (((1UL << 20) | 1UL) & 0xfffffffffffffffcUL))) {
#line 4181
                rend &= 4294705151U;
              }
            }
          }
        }
      }
#line 4220
      gcmask = 0UL;
#line 4221
      if ((int )back != 1) {
#line 4223
        gcvalue.background = *(r->pixColors + back);
#line 4224
        gcmask = (unsigned long )(1L << 3);
      }
#line 4226
      if ((int )fore != 0) {
#line 4228
        gcvalue.foreground = *(r->pixColors + fore);
#line 4229
        gcmask |= (unsigned long )(1L << 2);
      } else
#line 4232
      if (rend & 262144U) {
#line 4232
        if (h->pixcolor_set[8] & (unsigned int )(1 << 7)) {
#line 4244
          gcvalue.foreground = *(r->pixColors + 263);
#line 4245
          gcmask |= (unsigned long )(1L << 2);
#line 4252
          if (! ((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] & (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL))) {
#line 4253
            rend &= 4294705151U;
          }
        } else {
#line 4232
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 4255
      if (rend & 2097152U) {
#line 4255
        if (h->pixcolor_set[8] & (unsigned int )(1 << 8)) {
#line 4263
          gcvalue.foreground = *(r->pixColors + 264);
#line 4264
          gcmask |= (unsigned long )(1L << 2);
#line 4266
          rend &= 4292870143U;
        }
      }
#line 4271
      if (gcmask) {
        {
#line 4272
        XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask, & gcvalue);
        }
      }
#line 4281
      if ((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] & (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL)) {
#line 4281
        tmp___22 = rend & 262144U;
      } else {
#line 4281
        if (rend & 262144U) {
#line 4281
          if ((int )fore == 0) {
#line 4281
            tmp___21 = 1;
          } else {
#line 4281
            tmp___21 = 0;
          }
        } else {
#line 4281
          tmp___21 = 0;
        }
#line 4281
        tmp___22 = (unsigned int )tmp___21;
      }
#line 4281
      if (tmp___22) {
#line 4281
        if (! wbyte) {
#line 4283
          if (usingBoldFt) {
#line 4284
            rend &= 4294705151U;
          } else
#line 4286
          if (loadedBoldFt) {
            {
#line 4288
            usingBoldFt = (unsigned char)1;
#line 4299
            XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.bfont)->fid);
#line 4303
            fontdiff = (unsigned char )((int )r->TermWin.propfont & (1 << 1));
#line 4304
            rend &= 4294705151U;
            }
          }
        } else {
#line 4281
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 4312
      if (usingBoldFt) {
#line 4312
        if ((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] & (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL)) {
#line 4312
          tmp___20 = rend & 262144U;
        } else {
#line 4312
          if (rend & 262144U) {
#line 4312
            if ((int )fore == 0) {
#line 4312
              tmp___19 = 1;
            } else {
#line 4312
              tmp___19 = 0;
            }
          } else {
#line 4312
            tmp___19 = 0;
          }
#line 4312
          tmp___20 = (unsigned int )tmp___19;
        }
#line 4312
        if (! tmp___20) {
#line 4314
          usingBoldFt = (unsigned char)0;
#line 4322
          if (! wbyte) {
#line 4323
            fontdiff = (unsigned char)0;
          }
          {
#line 4333
          XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.font)->fid);
          }
        }
      }
#line 4341
      if ((int )back == 1) {
#line 4341
        if (must_clear) {
#line 4343
          if (! already_cleared) {
            {
#line 4343
            rxvt_clear_area(r, page, xpixel, ypixelc, (unsigned int )((int32_t )len * (int32_t )r->TermWin.fwidth),
                            (unsigned int )((int32_t )r->TermWin.fheight));
            }
          }
#line 4345
          i = 0;
          {
#line 4345
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 4345
            if (! (i < (int )len)) {
#line 4345
              goto while_break___8;
            }
#line 4347
            if ((int )*(buffer + i) != 32) {
#line 4351
              if ((int )refresh_type & (1 << 4)) {
#line 4351
                tmp___23 = (r->h)->refreshRegion;
              } else {
#line 4351
                tmp___23 = (Region )0L;
              }
              {
#line 4351
              rxvt_scr_draw_string(r, page, xpixel, ypixelc, buffer, (int )wlen, drawfunc,
                                   fore, back, rend, tmp___23);
              }
#line 4356
              goto while_break___8;
            }
#line 4345
            i ++;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
#line 4341
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 4359
      if (fprop) {
#line 4359
        goto _L___5;
      } else
#line 4359
      if (fontdiff) {
        _L___5: /* CIL Label */ 
        {
#line 4364
        pixel = gcvalue.foreground;
#line 4365
        gcvalue.foreground = gcvalue.background;
#line 4366
        XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
#line 4367
        rxvt_fill_rectangle(r, page, xpixel, ypixelc, (unsigned int )((int32_t )len * (int32_t )r->TermWin.fwidth),
                            (unsigned int )((int32_t )r->TermWin.fheight));
#line 4371
        gcvalue.foreground = pixel;
#line 4372
        XChangeGC(r->Xdisplay, r->TermWin.gc, (unsigned long )(1L << 2), & gcvalue);
        }
#line 4375
        if ((int )refresh_type & (1 << 4)) {
#line 4375
          tmp___24 = (r->h)->refreshRegion;
        } else {
#line 4375
          tmp___24 = (Region )0L;
        }
        {
#line 4375
        rxvt_scr_draw_string(r, page, xpixel, ypixelc, buffer, (int )wlen, drawfunc,
                             fore, back, rend, tmp___24);
        }
      } else {
#line 4384
        if ((int )refresh_type & (1 << 4)) {
#line 4384
          tmp___25 = (r->h)->refreshRegion;
        } else {
#line 4384
          tmp___25 = (Region )0L;
        }
        {
#line 4384
        rxvt_scr_draw_string(r, page, xpixel, ypixelc, buffer, (int )wlen, image_drawfunc,
                             fore, back, rend, tmp___25);
        }
      }
#line 4395
      if ((unsigned long )r->Options[((1UL << 18) | 1UL) & 3UL] & (((1UL << 18) | 1UL) & 0xfffffffffffffffcUL)) {
#line 4395
        tmp___28 = rend & 262144U;
      } else {
#line 4395
        if (rend & 262144U) {
#line 4395
          if ((int )fore == 0) {
#line 4395
            tmp___27 = 1;
          } else {
#line 4395
            tmp___27 = 0;
          }
        } else {
#line 4395
          tmp___27 = 0;
        }
#line 4395
        tmp___28 = (unsigned int )tmp___27;
      }
#line 4395
      if (tmp___28) {
#line 4402
        if ((int )refresh_type & (1 << 4)) {
#line 4402
          tmp___26 = (r->h)->refreshRegion;
        } else {
#line 4402
          tmp___26 = (Region )0L;
        }
        {
#line 4402
        rxvt_scr_draw_string(r, page, xpixel + 1, ypixelc, buffer, (int )wlen, drawfunc,
                             fore, back, rend, tmp___26);
        }
      }
#line 4409
      if (rend & 2097152U) {
#line 4424
        if ((r->TermWin.font)->descent > 1) {
          {
#line 4425
          XDrawLine(r->Xdisplay, (r->vts[page])->vt, r->TermWin.gc, xpixel, (ypixelc + (r->TermWin.font)->ascent) + 1,
                    (xpixel + (int32_t )len * (int32_t )r->TermWin.fwidth) - 1, (ypixelc + (r->TermWin.font)->ascent) + 1);
          }
        }
      }
#line 4432
      if (gcmask) {
        {
#line 4434
        gcvalue.foreground = *(r->pixColors + 0);
#line 4435
        gcvalue.background = *(r->pixColors + 1);
#line 4436
        XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask, & gcvalue);
        }
      }
      __Cont___1: /* CIL Label */ 
#line 3821
      col = (int16_t )((int )col + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3683
    row = (int16_t )((int )row + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4447
  if (usingBoldFt) {
    {
#line 4449
    usingBoldFt = (unsigned char)0;
#line 4459
    XSetFont(r->Xdisplay, r->TermWin.gc, (r->TermWin.font)->fid);
    }
  }
#line 4468
  if (showcursor) {
#line 4470
    if (r->TermWin.focus) {
#line 4472
      currow___0 = (r->vts[page])->screen.cur.row + (int32_t )(r->vts[page])->saveLines;
#line 4473
      srp = *((r->vts[page])->screen.rend + currow___0) + (r->vts[page])->screen.cur.col;
#line 4474
      *srp ^= 1048576U;
#line 4477
      *srp = (*srp & 4294705152U) | cc1;
    } else
#line 4491
    if (h->oldcursor.row >= 0) {
#line 4496
      gcmask___0 = 0UL;
#line 4497
      if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth > 2) {
#line 4497
        if (h->pixcolor_set[8] & (unsigned int )(1 << 2)) {
          {
#line 4499
          gcvalue.foreground = *(r->pixColors + 258);
#line 4500
          gcmask___0 = (unsigned long )(1L << 2);
#line 4501
          XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask___0, & gcvalue);
#line 4502
          gcvalue.foreground = *(r->pixColors + 0);
          }
        }
      }
#line 4506
      if (morecur) {
#line 4506
        tmp___29 = 1;
      } else {
#line 4506
        tmp___29 = 0;
      }
      {
#line 4506
      XDrawRectangle(r->Xdisplay, (r->vts[page])->vt, r->TermWin.gc, (h->oldcursor.col + (int32_t )morecur) * (int32_t )r->TermWin.fwidth + (int32_t )r->TermWin.int_bwidth,
                     h->oldcursor.row * (int32_t )r->TermWin.fheight + (int32_t )r->TermWin.int_bwidth,
                     (unsigned int )((1 + tmp___29) * (int32_t )r->TermWin.fwidth - 1),
                     (unsigned int )((int32_t )r->TermWin.fheight - 1));
      }
#line 4514
      if (gcmask___0) {
        {
#line 4515
        XChangeGC(r->Xdisplay, r->TermWin.gc, gcmask___0, & gcvalue);
        }
      }
    }
  }
  {
#line 4525
  rxvt_scr_reverse_selection(r, page);
  }
#line 4535
  if (clearfirst) {
#line 4535
    if (r->TermWin.int_bwidth) {
      {
#line 4536
      rxvt_clear_area(r, page, 0, 0, (unsigned int )r->TermWin.int_bwidth, (unsigned int )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth));
      }
    }
  }
#line 4542
  if (clearlast) {
#line 4542
    if (r->TermWin.int_bwidth) {
      {
#line 4543
      rxvt_clear_area(r, page, r->szHint.width + (int )r->TermWin.int_bwidth, 0, (unsigned int )r->TermWin.int_bwidth,
                      (unsigned int )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth));
      }
    }
  }
#line 4547
  if ((int )refresh_type & (1 << 2)) {
    {
#line 4548
    XSync(r->Xdisplay, 0);
    }
  }
#line 4550
  if ((int )refresh_type & (1 << 4)) {
#line 4550
    if ((unsigned long )((Region )0) != (unsigned long )h->refreshRegion) {
      {
#line 4561
      XSetClipMask(r->Xdisplay, r->TermWin.gc, (Pixmap )0L);
      }
    } else {
#line 4569
      (r->vts[page])->want_refresh = (unsigned char)0;
    }
  } else {
#line 4569
    (r->vts[page])->want_refresh = (unsigned char)0;
  }
#line 4571
  h->refresh_type = (unsigned char )((int )h->refresh_type & ~ (1 << 4));
#line 4572
  h->want_clip_refresh = (unsigned char)0;
#line 4576
  if ((unsigned long )((Region )0) != (unsigned long )h->refreshRegion) {
    {
#line 4578
    XDestroyRegion(h->refreshRegion);
#line 4579
    h->refreshRegion = (Region )0L;
    }
  }
#line 4582
  (r->vts[page])->num_scr = (uint16_t )0;
#line 4583
  h->num_scr_allow = (unsigned char)1;
#line 4584
  return;
}
}
#line 4600 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_clear(rxvt_t *r , int page ) 
{ 


  {
#line 4603
  if (! (r->vts[page])->mapped) {
#line 4604
    return;
  }
#line 4608
  (r->h)->num_scr_allow = (unsigned char)0;
#line 4609
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 4611
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 4613
    if (0UL != r->TermWin.parent) {
      {
#line 4614
      XClearWindow(r->Xdisplay, r->TermWin.parent);
      }
    }
  }
  {
#line 4617
  XClearWindow(r->Xdisplay, (r->vts[page])->vt);
  }
#line 4618
  return;
}
}
#line 4622 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_scr_reverse_selection(rxvt_t *r , int page ) 
{ 
  int i ;
  int col ;
  int row ;
  int end_row ;
  uint32_t *srp ;

  {
#line 4628
  if (r->selection.op) {
#line 4628
    if ((int )r->selection.vt == page) {
#line 4628
      if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 4633
        end_row = (int )(r->vts[page])->saveLines - (int )(r->vts[page])->view_start;
#line 4635
        i = r->selection.beg.row + (int32_t )(r->vts[page])->saveLines;
#line 4636
        row = r->selection.end.row + (int32_t )(r->vts[page])->saveLines;
#line 4638
        if (i >= end_row) {
#line 4639
          col = r->selection.beg.col;
        } else {
#line 4642
          col = 0;
#line 4643
          i = end_row;
        }
#line 4646
        end_row += (int )r->TermWin.nrow;
        {
#line 4647
        while (1) {
          while_continue: /* CIL Label */ ;
#line 4647
          if (i < row) {
#line 4647
            if (! (i < end_row)) {
#line 4647
              goto while_break;
            }
          } else {
#line 4647
            goto while_break;
          }
#line 4648
          srp = *((r->vts[page])->screen.rend + i);
          {
#line 4648
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 4648
            if (! (col < (int )r->TermWin.ncol)) {
#line 4648
              goto while_break___0;
            }
#line 4652
            *(srp + col) ^= 524288U;
#line 4648
            col ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 4647
          i ++;
#line 4647
          col = 0;
        }
        while_break: /* CIL Label */ ;
        }
#line 4654
        if (i == row) {
#line 4654
          if (i < end_row) {
#line 4655
            srp = *((r->vts[page])->screen.rend + i);
            {
#line 4655
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4655
              if (! (col < r->selection.end.col)) {
#line 4655
                goto while_break___1;
              }
#line 4659
              *(srp + col) ^= 524288U;
#line 4655
              col ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 4662
  return;
}
}
#line 4708 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_check(rxvt_t *r , int page , int check_more ) 
{ 
  row_col_t pos ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;

  {
#line 4713
  if (! r->selection.op) {
#line 4716
    return;
  } else
#line 4713
  if ((int )r->selection.vt != page) {
#line 4716
    return;
  } else
#line 4713
  if ((int )r->selection.screen != (int )(r->vts[page])->current_screen) {
#line 4716
    return;
  }
#line 4718
  pos.col = 0;
#line 4718
  pos.row = pos.col;
#line 4719
  if (r->selection.beg.row < - ((int32_t )(r->vts[page])->nscrolled)) {
#line 4719
    goto _L___0;
  } else
#line 4719
  if (r->selection.beg.row >= (int32_t )r->TermWin.nrow) {
#line 4719
    goto _L___0;
  } else
#line 4719
  if (r->selection.mark.row < - ((int32_t )(r->vts[page])->nscrolled)) {
#line 4719
    goto _L___0;
  } else
#line 4719
  if (r->selection.mark.row >= (int32_t )r->TermWin.nrow) {
#line 4719
    goto _L___0;
  } else
#line 4719
  if (r->selection.end.row < - ((int32_t )(r->vts[page])->nscrolled)) {
#line 4719
    goto _L___0;
  } else
#line 4719
  if (r->selection.end.row >= (int32_t )r->TermWin.nrow) {
#line 4719
    goto _L___0;
  } else
#line 4719
  if (check_more == 1) {
#line 4719
    if ((int )(r->vts[page])->current_screen == (int )r->selection.screen) {
#line 4719
      if ((r->vts[page])->screen.cur.row < r->selection.beg.row) {
#line 4719
        goto _L___8;
      } else
#line 4719
      if ((r->vts[page])->screen.cur.row == r->selection.beg.row) {
#line 4719
        if ((r->vts[page])->screen.cur.col < r->selection.beg.col) {
#line 4719
          goto _L___8;
        } else {
#line 4719
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 4719
      if ((r->vts[page])->screen.cur.row < r->selection.end.row) {
#line 4719
        goto _L___0;
      } else
#line 4719
      if ((r->vts[page])->screen.cur.row == r->selection.end.row) {
#line 4719
        if ((r->vts[page])->screen.cur.col < r->selection.end.col) {
#line 4719
          goto _L___0;
        } else {
#line 4719
          goto _L___8;
        }
      } else {
#line 4719
        goto _L___8;
      }
    } else {
#line 4719
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 4719
  if (check_more == 2) {
#line 4719
    if (r->selection.beg.row < pos.row) {
#line 4719
      goto _L___4;
    } else
#line 4719
    if (r->selection.beg.row == pos.row) {
#line 4719
      if (r->selection.beg.col < pos.col) {
        _L___4: /* CIL Label */ 
#line 4719
        if (r->selection.end.row > pos.row) {
#line 4719
          goto _L___0;
        } else
#line 4719
        if (r->selection.end.row == pos.row) {
#line 4719
          if (r->selection.end.col > pos.col) {
#line 4719
            goto _L___0;
          } else {
#line 4719
            goto _L___3;
          }
        } else {
#line 4719
          goto _L___3;
        }
      } else {
#line 4719
        goto _L___3;
      }
    } else {
#line 4719
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 4719
  if (check_more == 3) {
#line 4719
    if (r->selection.end.row > pos.row) {
#line 4719
      goto _L___0;
    } else
#line 4719
    if (r->selection.end.row == pos.row) {
#line 4719
      if (r->selection.end.col > pos.col) {
#line 4719
        goto _L___0;
      } else {
#line 4719
        goto _L___1;
      }
    } else {
#line 4719
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4719
  if (check_more == 4) {
#line 4719
    if (r->selection.beg.row != r->selection.end.row) {
#line 4719
      goto _L___0;
    } else
#line 4719
    if (r->selection.end.col > (int32_t )r->TermWin.ncol) {
      _L___0: /* CIL Label */ 
#line 4740
      tmp___1 = 0;
#line 4740
      r->selection.end.col = tmp___1;
#line 4740
      tmp___0 = tmp___1;
#line 4740
      r->selection.end.row = tmp___0;
#line 4740
      tmp = tmp___0;
#line 4740
      r->selection.beg.col = tmp;
#line 4740
      r->selection.beg.row = tmp;
    }
  }
#line 4742
  return;
}
}
#line 4749 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_paste_str(rxvt_t *r , int page , unsigned char const   *data , unsigned int nitems ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int n ;
  unsigned char *ds ;
  void *tmp ;

  {
  {
#line 4754
  tmp = rxvt_malloc((size_t )16384);
#line 4754
  ds = (unsigned char *)tmp;
#line 4759
  i = 0U;
  }
  {
#line 4759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4759
    if (! (i < nitems)) {
#line 4759
      goto while_break;
    }
#line 4761
    if (nitems - i < 16384U) {
#line 4761
      n = nitems - i;
    } else {
#line 4761
      n = 16384U;
    }
    {
#line 4762
    memcpy((void */* __restrict  */)((void *)ds), (void const   */* __restrict  */)((void const   *)(data + i)),
           (size_t )n);
#line 4763
    j = 0U;
    }
    {
#line 4763
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4763
      if (! (j < n)) {
#line 4763
        goto while_break___0;
      }
#line 4764
      if ((int )*(ds + j) == 10) {
#line 4765
        *(ds + j) = (unsigned char )'\r';
      }
#line 4763
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4766
    rxvt_tt_write(r, page, (unsigned char const   *)ds, (int )n);
#line 4759
    i += 16384U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4768
  rxvt_free((void *)ds);
  }
#line 4769
  return;
}
}
#line 4778 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_selection_paste(rxvt_t *r , Window win , Atom prop , int delete_prop ) 
{ 
  long nread ;
  unsigned long bytes_after ;
  XTextProperty ct ;
  int tmp ;

  {
#line 4781
  nread = 0L;
#line 4791
  if (0UL == prop) {
#line 4803
    return (0);
  }
  {
#line 4806
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4808
    tmp = XGetWindowProperty(r->Xdisplay, win, prop, nread / 4L, 4096L, delete_prop,
                             (Atom )0L, & ct.encoding, & ct.format, & ct.nitems, & bytes_after,
                             & ct.value);
    }
#line 4808
    if (tmp != 0) {
#line 4815
      goto while_break;
    }
#line 4816
    if (ct.encoding == 0UL) {
#line 4819
      goto while_break;
    }
#line 4822
    if ((unsigned long )ct.value == (unsigned long )((void *)0)) {
#line 4825
      goto __Cont;
    }
#line 4828
    if (ct.nitems == 0UL) {
#line 4832
      if ((int )(r->h)->selection_wait == 1) {
#line 4832
        if (nread == 0L) {
          {
#line 4839
          rxvt_selection_paste(r, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                               (Atom )9, 0);
          }
        }
      }
#line 4841
      nread = -1L;
#line 4842
      goto while_break;
    }
    {
#line 4845
    nread = (long )((unsigned long )nread + ct.nitems);
#line 4859
    rxvt_paste_str(r, (int )r->tabBar.atab, (unsigned char const   *)ct.value, (unsigned int )ct.nitems);
    }
#line 4861
    if (bytes_after == 0UL) {
#line 4862
      goto while_break;
    }
    {
#line 4864
    XFree((void *)ct.value);
#line 4865
    ct.value = (unsigned char *)0;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 4868
  if (ct.value) {
    {
#line 4869
    XFree((void *)ct.value);
    }
  }
#line 4871
  if ((int )(r->h)->selection_wait == 1) {
#line 4872
    (r->h)->selection_wait = (unsigned char)0;
  }
#line 4875
  return ((int )nread);
}
}
#line 4883 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_property(rxvt_t *r , Window win , Atom prop ) 
{ 
  int reget_time ;
  int a ;
  int afmt ;
  Atom atype ;
  unsigned long bytes_after ;
  unsigned long nitems ;
  unsigned char *s ;
  int tmp ;

  {
#line 4886
  reget_time = 0;
#line 4888
  if (0UL == prop) {
#line 4889
    return;
  }
#line 4892
  if ((int )(r->h)->selection_wait == 1) {
    {
#line 4897
    s = (unsigned char *)((void *)0);
#line 4899
    a = XGetWindowProperty(r->Xdisplay, win, prop, 0L, 1L, 0, (r->h)->xa[7], & atype,
                           & afmt, & nitems, & bytes_after, & s);
    }
#line 4902
    if (s) {
      {
#line 4903
      XFree((void *)s);
      }
    }
#line 4904
    if (a != 0) {
#line 4905
      return;
    }
#line 4907
    if (atype == (r->h)->xa[7]) {
      {
#line 4910
      XDeleteProperty(r->Xdisplay, win, prop);
#line 4911
      XFlush(r->Xdisplay);
#line 4912
      reget_time = 1;
#line 4913
      (r->h)->selection_wait = (unsigned char)2;
      }
    }
  } else
#line 4917
  if ((int )(r->h)->selection_wait == 2) {
    {
#line 4919
    reget_time = 1;
#line 4920
    tmp = rxvt_selection_paste(r, win, prop, 1);
    }
#line 4920
    if (tmp == -1) {
#line 4923
      (r->h)->selection_wait = (unsigned char)0;
#line 4924
      (r->h)->timeout[0].tv_sec = (__time_t )0;
    }
  }
#line 4927
  if (reget_time) {
    {
#line 4929
    gettimeofday((struct timeval */* __restrict  */)(& (r->h)->timeout[0]), (__timezone_ptr_t )((void *)0));
#line 4931
    (r->h)->timeout[0].tv_sec += 10L;
    }
  }
#line 4933
  return;
}
}
#line 4943 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_request_by_sel(rxvt_t *r , int page , Time tm , int x , int y ,
                                   int sel ) 
{ 


  {
#line 4948
  if (x < 0) {
#line 4949
    return;
  } else
#line 4948
  if (x >= (r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth) {
#line 4949
    return;
  } else
#line 4948
  if (y < 0) {
#line 4949
    return;
  } else
#line 4948
  if (y >= (r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) {
#line 4949
    return;
  }
  {
#line 4951
  (r->h)->selection_request_time = tm;
#line 4952
  (r->h)->selection_wait = (unsigned char)1;
#line 4957
  (r->h)->selection_type = (unsigned char)0;
#line 4959
  rxvt_selection_request_other(r, page, (Atom )31, sel);
  }
#line 4966
  return;
}
}
#line 4980 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_request(rxvt_t *r , int page , Time tm , int x , int y ) 
{ 
  int i ;
  int tmp ;

  {
#line 4985
  if (x < 0) {
#line 4986
    return;
  } else
#line 4985
  if (x >= (r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth) {
#line 4986
    return;
  } else
#line 4985
  if (y < 0) {
#line 4986
    return;
  } else
#line 4985
  if (y >= (r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) {
#line 4986
    return;
  }
#line 4988
  if ((unsigned long )r->selection.text != (unsigned long )((void *)0)) {
    {
#line 4991
    rxvt_paste_str(r, page, (unsigned char const   *)r->selection.text, r->selection.len);
    }
#line 4992
    return;
  } else {
#line 4998
    (r->h)->selection_request_time = tm;
#line 4999
    (r->h)->selection_wait = (unsigned char)1;
#line 5001
    i = 1;
    {
#line 5001
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5001
      if (! (i <= 3)) {
#line 5001
        goto while_break;
      }
      {
#line 5006
      (r->h)->selection_type = (unsigned char)0;
#line 5008
      tmp = rxvt_selection_request_other(r, page, (Atom )31, i);
      }
#line 5008
      if (tmp) {
#line 5015
        return;
      }
#line 5001
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 5020
  (r->h)->selection_wait = (unsigned char)0;
#line 5022
  rxvt_selection_paste(r, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                       (Atom )9, 0);
  }
#line 5023
  return;
}
}
#line 5027 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
int rxvt_selection_request_other(rxvt_t *r , int page , Atom target , int selnum ) 
{ 
  Atom sel ;
  Window tmp ;

  {
#line 5035
  (r->h)->selection_type = (unsigned char )((int )(r->h)->selection_type | selnum);
#line 5036
  if (selnum == 1) {
#line 5037
    sel = (Atom )1;
  } else
#line 5038
  if (selnum == 2) {
#line 5039
    sel = (Atom )2;
  } else {
#line 5041
    sel = (r->h)->xa[19];
  }
  {
#line 5042
  tmp = XGetSelectionOwner(r->Xdisplay, sel);
  }
#line 5042
  if (tmp != 0UL) {
    {
#line 5047
    XConvertSelection(r->Xdisplay, sel, target, (r->h)->xa[6], (r->vts[page])->vt,
                      (r->h)->selection_request_time);
    }
#line 5050
    return (1);
  }
#line 5052
  return (0);
}
}
#line 5063 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_paste_file(rxvt_t *r , int page , Time tm , int x , int y , char *filename ) 
{ 
  char buffer[8192] ;
  char *str ;
  FILE *fdpaste ;
  wordexp_t p ;
  int wordexp_result ;
  size_t tmp ;

  {
#line 5070
  if (x < 0) {
#line 5071
    return;
  } else
#line 5070
  if (x >= (r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth) {
#line 5071
    return;
  } else
#line 5070
  if (y < 0) {
#line 5071
    return;
  } else
#line 5070
  if (y >= (r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) {
#line 5071
    return;
  }
  {
#line 5082
  wordexp_result = wordexp((char const   */* __restrict  */)filename, (wordexp_t */* __restrict  */)(& p),
                           0);
  }
#line 5083
  if (wordexp_result == 0) {
#line 5083
    if (p.we_wordc == 1UL) {
#line 5084
      filename = *(p.we_wordv);
    } else {
      {
#line 5087
      rxvt_msg((uint32_t )1, (uint32_t )2, "Error expanding %s, or possibly ambiguous expansion\n",
               filename);
#line 5090
      rxvt_msg((uint32_t )3, (uint32_t )2, "wordexp_result=%i\n", wordexp_result);
      }
    }
  } else {
    {
#line 5087
    rxvt_msg((uint32_t )1, (uint32_t )2, "Error expanding %s, or possibly ambiguous expansion\n",
             filename);
#line 5090
    rxvt_msg((uint32_t )3, (uint32_t )2, "wordexp_result=%i\n", wordexp_result);
    }
  }
  {
#line 5094
  fdpaste = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 5094
  if ((unsigned long )((void *)0) != (unsigned long )fdpaste) {
    {
#line 5096
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 5096
      str = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)fdpaste);
      }
#line 5096
      if (! ((unsigned long )((void *)0) != (unsigned long )str)) {
#line 5096
        goto while_break;
      }
      {
#line 5097
      tmp = strlen((char const   *)str);
#line 5097
      rxvt_paste_str(r, page, (unsigned char const   *)str, (unsigned int )tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5099
    fclose(fdpaste);
    }
  }
  {
#line 5108
  wordfree(& p);
  }
#line 5110
  return;
}
}
#line 5121 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_process_selectionclear(rxvt_t *r , int page ) 
{ 
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;

  {
#line 5126
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 5127
  if (r->selection.text) {
    {
#line 5128
    rxvt_free((void *)r->selection.text);
    }
  }
#line 5129
  r->selection.text = (unsigned char *)((void *)0);
#line 5130
  r->selection.len = (uint32_t )0;
#line 5131
  tmp___1 = 0;
#line 5131
  r->selection.end.col = tmp___1;
#line 5131
  tmp___0 = tmp___1;
#line 5131
  r->selection.end.row = tmp___0;
#line 5131
  tmp = tmp___0;
#line 5131
  r->selection.beg.col = tmp;
#line 5131
  r->selection.beg.row = tmp;
#line 5132
  r->selection.vt = (short)-1;
#line 5134
  r->selection.op = (enum __anonenum_op_361 )0;
#line 5135
  r->selection.screen = (short)0;
#line 5136
  r->selection.clicks = (short)0;
#line 5137
  return;
}
}
#line 5146 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_make(rxvt_t *r , int page , Time tm ) 
{ 
  int i ;
  int col ;
  int end_col ;
  int row ;
  int end_row ;
  unsigned char *new_selection_text ;
  unsigned char *str ;
  text_t *t ;
  uint32_t *re ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  void *tmp___2 ;
  uint32_t *tmp___3 ;
  unsigned char *tmp___4 ;
  uint32_t *tmp___5 ;
  unsigned char *tmp___6 ;
  size_t tmp___7 ;
  Window tmp___8 ;

  {
  {
#line 5163
  if ((unsigned int )r->selection.op == 3U) {
#line 5163
    goto case_3;
  }
#line 5165
  if ((unsigned int )r->selection.op == 1U) {
#line 5165
    goto case_1;
  }
#line 5168
  if ((unsigned int )r->selection.op == 2U) {
#line 5168
    goto case_2;
  }
#line 5171
  goto switch_default;
  case_3: /* CIL Label */ 
#line 5164
  goto switch_break;
  case_1: /* CIL Label */ 
#line 5166
  tmp___1 = 0;
#line 5166
  r->selection.end.col = tmp___1;
#line 5166
  tmp___0 = tmp___1;
#line 5166
  r->selection.end.row = tmp___0;
#line 5166
  tmp = tmp___0;
#line 5166
  r->selection.beg.col = tmp;
#line 5166
  r->selection.beg.row = tmp;
  case_2: /* CIL Label */ 
#line 5169
  r->selection.op = (enum __anonenum_op_361 )4;
  switch_default: /* CIL Label */ 
#line 5172
  return;
  switch_break: /* CIL Label */ ;
  }
#line 5174
  r->selection.op = (enum __anonenum_op_361 )4;
#line 5175
  r->selection.vt = (short )page;
#line 5177
  if ((int )r->selection.clicks == 4) {
#line 5178
    return;
  }
  {
#line 5182
  i = ((r->selection.end.row - r->selection.beg.row) + 1) * ((int )r->TermWin.ncol + 1) + 1;
#line 5186
  tmp___2 = rxvt_malloc((unsigned long )i * sizeof(char ));
#line 5186
  str = (unsigned char *)tmp___2;
#line 5188
  new_selection_text = str;
#line 5190
  col = r->selection.beg.col;
  }
#line 5191
  if (0 > col) {
#line 5191
    col = 0;
  }
#line 5192
  row = r->selection.beg.row + (int32_t )(r->vts[page])->saveLines;
#line 5193
  end_row = r->selection.end.row + (int32_t )(r->vts[page])->saveLines;
  {
#line 5198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5198
    if (! (row < end_row)) {
#line 5198
      goto while_break;
    }
#line 5200
    t = *((r->vts[page])->screen.text + row) + col;
#line 5205
    re = *((r->vts[page])->screen.rend + row) + col;
#line 5207
    end_col = (int )*((r->vts[page])->screen.tlen + row);
#line 5207
    if (end_col == -1) {
#line 5208
      end_col = (int )r->TermWin.ncol;
    }
    {
#line 5217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5217
      if (! (col < end_col)) {
#line 5217
        goto while_break___0;
      }
#line 5230
      tmp___3 = re;
#line 5230
      re ++;
#line 5230
      if (*tmp___3 & 4194304U) {
#line 5230
        if ((int )*t >= 96) {
#line 5230
          if ((int )*t < 128) {
#line 5231
            *str = (unsigned char )*((r->h)->rs[325] + ((int )*t - 96));
          } else {
#line 5234
            *str = *t;
          }
        } else {
#line 5234
          *str = *t;
        }
      } else {
#line 5234
        *str = *t;
      }
#line 5217
      col ++;
#line 5217
      str ++;
#line 5217
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5238
    if ((int )*((r->vts[page])->screen.tlen + row) != -1) {
      {
#line 5241
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5241
        if ((unsigned long )str > (unsigned long )new_selection_text) {
#line 5241
          if (! (32 == (int )*(str + -1))) {
#line 5241
            goto while_break___1;
          }
        } else {
#line 5241
          goto while_break___1;
        }
#line 5241
        str --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5243
      tmp___4 = str;
#line 5243
      str ++;
#line 5243
      *tmp___4 = (unsigned char )'\n';
    }
#line 5198
    row ++;
#line 5198
    col = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 5250
  t = *((r->vts[page])->screen.text + row) + col;
#line 5255
  re = *((r->vts[page])->screen.rend + row) + col;
#line 5257
  end_col = (int )*((r->vts[page])->screen.tlen + row);
#line 5258
  if (end_col == -1) {
#line 5259
    end_col = r->selection.end.col;
  } else
#line 5258
  if (r->selection.end.col <= end_col) {
#line 5259
    end_col = r->selection.end.col;
  }
#line 5260
  if ((int )r->TermWin.ncol < end_col) {
#line 5260
    end_col = (int )r->TermWin.ncol;
  }
  {
#line 5269
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5269
    if (! (col < end_col)) {
#line 5269
      goto while_break___2;
    }
#line 5282
    tmp___5 = re;
#line 5282
    re ++;
#line 5282
    if (*tmp___5 & 4194304U) {
#line 5282
      if ((int )*t >= 96) {
#line 5282
        if ((int )*t < 128) {
#line 5283
          *str = (unsigned char )*((r->h)->rs[325] + ((int )*t - 96));
        } else {
#line 5286
          *str = *t;
        }
      } else {
#line 5286
        *str = *t;
      }
    } else {
#line 5286
      *str = *t;
    }
#line 5269
    col ++;
#line 5269
    str ++;
#line 5269
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 5290
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5290
    if ((unsigned long )str > (unsigned long )new_selection_text) {
#line 5290
      if (! (32 == (int )*(str + -1))) {
#line 5290
        goto while_break___3;
      }
    } else {
#line 5290
      goto while_break___3;
    }
#line 5290
    str --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5302
  if ((unsigned int )r->selection_style != 0U) {
#line 5303
    if (end_col != r->selection.end.col) {
#line 5305
      tmp___6 = str;
#line 5305
      str ++;
#line 5305
      *tmp___6 = (unsigned char )'\n';
    }
  }
  {
#line 5308
  *str = (unsigned char )'\000';
#line 5309
  tmp___7 = strlen((char const   *)((char *)new_selection_text));
#line 5309
  i = (int )tmp___7;
  }
#line 5309
  if (i == 0) {
    {
#line 5311
    rxvt_free((void *)new_selection_text);
    }
#line 5312
    return;
  }
#line 5314
  r->selection.len = (uint32_t )i;
#line 5315
  if (r->selection.text) {
    {
#line 5316
    rxvt_free((void *)r->selection.text);
    }
  }
  {
#line 5317
  r->selection.text = new_selection_text;
#line 5319
  XSetSelectionOwner(r->Xdisplay, (Atom )1, (r->vts[page])->vt, tm);
#line 5320
  tmp___8 = XGetSelectionOwner(r->Xdisplay, (Atom )1);
  }
#line 5320
  if (tmp___8 != (r->vts[page])->vt) {
    {
#line 5321
    rxvt_msg((uint32_t )1, (uint32_t )2, "can\'t get primary selection");
    }
  }
  {
#line 5322
  XChangeProperty(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                  (Atom )9, (Atom )31, 8, 0, (unsigned char const   *)r->selection.text,
                  (int )r->selection.len);
#line 5324
  (r->h)->selection_time = tm;
  }
#line 5327
  return;
}
}
#line 5336 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_click(rxvt_t *r , int page , int clicks , int x , int y ) 
{ 


  {
  {
#line 5341
  r->selection.vt = (short )page;
#line 5342
  clicks = (clicks - 1) % 3 + 1;
#line 5343
  r->selection.clicks = (short )clicks;
#line 5345
  rxvt_selection_start_colrow(r, page, (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth,
                              (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight);
  }
#line 5347
  if (clicks == 2) {
    {
#line 5348
    rxvt_selection_extend_colrow(r, page, r->selection.mark.col, r->selection.mark.row + (int32_t )(r->vts[page])->view_start,
                                 0, 1, 0);
    }
  } else
#line 5347
  if (clicks == 3) {
    {
#line 5348
    rxvt_selection_extend_colrow(r, page, r->selection.mark.col, r->selection.mark.row + (int32_t )(r->vts[page])->view_start,
                                 0, 1, 0);
    }
  }
#line 5353
  return;
}
}
#line 5361 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_start_colrow(rxvt_t *r , int page , int col , int row ) 
{ 
  int32_t tmp ;
  int32_t tmp___0 ;

  {
#line 5364
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 5365
  r->selection.mark.col = col;
#line 5366
  r->selection.mark.row = row - (int )(r->vts[page])->view_start;
#line 5367
  if (- ((int32_t )(r->vts[page])->nscrolled) > r->selection.mark.row) {
#line 5367
    r->selection.mark.row = - ((int32_t )(r->vts[page])->nscrolled);
  }
#line 5368
  if ((int32_t )r->TermWin.nrow - 1 < r->selection.mark.row) {
#line 5368
    r->selection.mark.row = (int32_t )r->TermWin.nrow - 1;
  }
#line 5369
  if (0 > r->selection.mark.col) {
#line 5369
    r->selection.mark.col = 0;
  }
#line 5370
  if ((int32_t )r->TermWin.ncol - 1 < r->selection.mark.col) {
#line 5370
    r->selection.mark.col = (int32_t )r->TermWin.ncol - 1;
  }
#line 5372
  if (r->selection.op) {
#line 5375
    tmp = r->selection.mark.row;
#line 5375
    r->selection.end.row = tmp;
#line 5375
    r->selection.beg.row = tmp;
#line 5376
    tmp___0 = r->selection.mark.col;
#line 5376
    r->selection.end.col = tmp___0;
#line 5376
    r->selection.beg.col = tmp___0;
  }
#line 5378
  r->selection.op = (enum __anonenum_op_361 )1;
#line 5379
  r->selection.screen = (short )(r->vts[page])->current_screen;
#line 5380
  r->selection.vt = (short )page;
#line 5381
  return;
}
}
#line 5400 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_delimit_word(rxvt_t *r , int page , enum page_dirn dirn , row_col_t const   *mark ,
                                 row_col_t *ret ) 
{ 
  int col ;
  int row ;
  int dirnadd ;
  int tcol ;
  int trow ;
  int w1 ;
  int w2 ;
  row_col_t bound ;
  text_t *stp ;
  uint32_t *srp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 5409
  r->selection.vt = (short )page;
#line 5411
  if ((unsigned int )dirn == 0U) {
#line 5413
    bound.row = ((int )(r->vts[page])->saveLines - (int )(r->vts[page])->nscrolled) - 1;
#line 5414
    bound.col = 0;
#line 5415
    dirnadd = -1;
  } else {
#line 5419
    bound.row = (int )(r->vts[page])->saveLines + (int )r->TermWin.nrow;
#line 5420
    bound.col = (int )r->TermWin.ncol - 1;
#line 5421
    dirnadd = 1;
  }
#line 5423
  row = (int )(mark->row + (int32_t const   )(r->vts[page])->saveLines);
#line 5424
  col = (int )mark->col;
#line 5425
  if (0 > col) {
#line 5425
    col = 0;
  }
#line 5427
  stp = *((r->vts[page])->screen.text + row) + col;
#line 5428
  if ((int )*stp == 32) {
#line 5428
    w1 = 2;
  } else
#line 5428
  if ((int )*stp == 9) {
#line 5428
    w1 = 2;
  } else {
    {
#line 5428
    tmp = strchr((r->h)->rs[324], (int )*stp);
#line 5428
    w1 = (unsigned long )tmp != (unsigned long )((void *)0);
    }
  }
#line 5430
  if ((unsigned int )r->selection_style != 2U) {
#line 5432
    if (w1 == 1) {
#line 5434
      stp += dirnadd;
#line 5435
      if ((int )*stp == 32) {
#line 5435
        tmp___1 = 2;
      } else
#line 5435
      if ((int )*stp == 9) {
#line 5435
        tmp___1 = 2;
      } else {
        {
#line 5435
        tmp___0 = strchr((r->h)->rs[324], (int )*stp);
#line 5435
        tmp___1 = (unsigned long )tmp___0 != (unsigned long )((void *)0);
        }
      }
#line 5435
      if (tmp___1 == 1) {
#line 5436
        goto Old_Word_Selection_You_Die;
      }
#line 5437
      col += dirnadd;
    }
#line 5439
    w1 = 0;
  }
#line 5441
  srp = *((r->vts[page])->screen.rend + row) + col;
#line 5442
  w2 = 1;
  {
#line 5444
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5446
      if (! (col != bound.col)) {
#line 5446
        goto while_break___0;
      }
#line 5448
      stp += dirnadd;
#line 5449
      if ((int )*stp == 32) {
#line 5449
        tmp___3 = 2;
      } else
#line 5449
      if ((int )*stp == 9) {
#line 5449
        tmp___3 = 2;
      } else {
        {
#line 5449
        tmp___2 = strchr((r->h)->rs[324], (int )*stp);
#line 5449
        tmp___3 = (unsigned long )tmp___2 != (unsigned long )((void *)0);
        }
      }
#line 5449
      if (tmp___3 != w1) {
#line 5450
        goto while_break___0;
      }
#line 5451
      srp += dirnadd;
#line 5452
      if (1 != w2) {
#line 5453
        goto while_break___0;
      }
#line 5446
      col += dirnadd;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5455
    if (col == bound.col) {
#line 5455
      if (row != bound.row) {
#line 5457
        if ((unsigned int )dirn == 0U) {
#line 5457
          tmp___6 = 1;
        } else {
#line 5457
          tmp___6 = 0;
        }
#line 5457
        if ((int )*((r->vts[page])->screen.tlen + (row - tmp___6)) == -1) {
#line 5459
          trow = row + dirnadd;
#line 5460
          if ((unsigned int )dirn == 0U) {
#line 5460
            tcol = (int )r->TermWin.ncol - 1;
          } else {
#line 5460
            tcol = 0;
          }
#line 5461
          if ((unsigned long )*((r->vts[page])->screen.text + trow) == (unsigned long )((void *)0)) {
#line 5462
            goto while_break;
          }
#line 5463
          stp = *((r->vts[page])->screen.text + trow) + tcol;
#line 5464
          srp = *((r->vts[page])->screen.rend + trow) + tcol;
#line 5465
          if ((int )*stp == 32) {
#line 5465
            tmp___5 = 2;
          } else
#line 5465
          if ((int )*stp == 9) {
#line 5465
            tmp___5 = 2;
          } else {
            {
#line 5465
            tmp___4 = strchr((r->h)->rs[324], (int )*stp);
#line 5465
            tmp___5 = (unsigned long )tmp___4 != (unsigned long )((void *)0);
            }
          }
#line 5465
          if (tmp___5 != w1) {
#line 5467
            goto while_break;
          } else
#line 5465
          if (1 != w2) {
#line 5467
            goto while_break;
          }
#line 5468
          row = trow;
#line 5469
          col = tcol;
#line 5470
          goto __Cont;
        }
      }
    }
#line 5473
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  Old_Word_Selection_You_Die: ;
#line 5479
  if ((unsigned int )dirn == 1U) {
#line 5480
    col ++;
  }
#line 5483
  ret->row = row - (int )(r->vts[page])->saveLines;
#line 5484
  ret->col = col;
#line 5485
  return;
}
}
#line 5497 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_extend(rxvt_t *r , int page , int x , int y , int flag ) 
{ 
  int col ;
  int row ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int tmp___1 ;

  {
#line 5502
  col = (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth;
#line 5503
  row = (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 5504
  if (0 > row) {
#line 5504
    row = 0;
  }
#line 5505
  if ((int )r->TermWin.nrow - 1 < row) {
#line 5505
    row = (int )r->TermWin.nrow - 1;
  }
#line 5506
  if (0 > col) {
#line 5506
    col = 0;
  }
#line 5507
  if ((int )r->TermWin.ncol < col) {
#line 5507
    col = (int )r->TermWin.ncol;
  }
#line 5516
  if ((unsigned int )r->selection_style != 0U) {
#line 5518
    if ((int )r->selection.clicks % 3 == 1) {
#line 5518
      if (! flag) {
#line 5518
        if (col == r->selection.mark.col) {
#line 5518
          if (row == r->selection.mark.row + (int32_t )(r->vts[page])->view_start) {
#line 5527
            tmp = 0;
#line 5527
            r->selection.end.row = tmp;
#line 5527
            r->selection.beg.row = tmp;
#line 5528
            tmp___0 = 0;
#line 5528
            r->selection.end.col = tmp___0;
#line 5528
            r->selection.beg.col = tmp___0;
#line 5529
            r->selection.clicks = (short)4;
#line 5530
            (r->vts[page])->want_refresh = (unsigned char)1;
#line 5532
            return;
          }
        }
      }
    }
  }
#line 5536
  if ((int )r->selection.clicks == 4) {
#line 5537
    r->selection.clicks = (short)1;
  }
#line 5538
  if (flag == 1) {
#line 5538
    tmp___1 = 1;
  } else {
#line 5538
    tmp___1 = 0;
  }
  {
#line 5538
  rxvt_selection_extend_colrow(r, page, col, row, ! (! flag), tmp___1, 0);
  }
#line 5542
  return;
}
}
#line 5577 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_extend_colrow(rxvt_t *r , int page , int32_t col , int32_t row ,
                                  int button3 , int buttonpress , int clickchange ) 
{ 
  unsigned int ncol ;
  row_col_t pos ;
  int end_col ;
  enum __anonenum_closeto_380 closeto ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t tmp___3 ;
  int end_row ;

  {
#line 5580
  ncol = (unsigned int )r->TermWin.ncol;
#line 5584
  closeto = (enum __anonenum_closeto_380 )1;
#line 5593
  (r->vts[page])->want_refresh = (unsigned char)1;
  {
#line 5596
  if ((unsigned int )r->selection.op == 1U) {
#line 5596
    goto case_1;
  }
#line 5600
  if ((unsigned int )r->selection.op == 2U) {
#line 5600
    goto case_2;
  }
#line 5606
  if ((unsigned int )r->selection.op == 4U) {
#line 5606
    goto case_4;
  }
#line 5609
  if ((unsigned int )r->selection.op == 3U) {
#line 5609
    goto case_3;
  }
#line 5611
  if ((unsigned int )r->selection.op == 0U) {
#line 5611
    goto case_0;
  }
#line 5614
  goto switch_default;
  case_1: /* CIL Label */ 
#line 5597
  tmp___1 = 0;
#line 5597
  r->selection.end.col = tmp___1;
#line 5597
  tmp___0 = tmp___1;
#line 5597
  r->selection.end.row = tmp___0;
#line 5597
  tmp = tmp___0;
#line 5597
  r->selection.beg.col = tmp;
#line 5597
  r->selection.beg.row = tmp;
#line 5598
  r->selection.op = (enum __anonenum_op_361 )2;
  case_2: /* CIL Label */ 
#line 5601
  if (row != r->selection.mark.row) {
#line 5604
    r->selection.op = (enum __anonenum_op_361 )3;
  } else
#line 5601
  if (col != r->selection.mark.col) {
#line 5604
    r->selection.op = (enum __anonenum_op_361 )3;
  } else
#line 5601
  if (! button3) {
#line 5601
    if (buttonpress) {
#line 5604
      r->selection.op = (enum __anonenum_op_361 )3;
    }
  }
#line 5605
  goto switch_break;
  case_4: /* CIL Label */ 
#line 5607
  r->selection.op = (enum __anonenum_op_361 )3;
  case_3: /* CIL Label */ 
#line 5610
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 5612
  rxvt_selection_start_colrow(r, page, col, row);
  }
  switch_default: /* CIL Label */ 
#line 5615
  return;
  switch_break: /* CIL Label */ ;
  }
#line 5618
  if (r->selection.beg.col == r->selection.end.col) {
#line 5618
    if (r->selection.beg.col != r->selection.mark.col) {
#line 5618
      if (r->selection.beg.row == r->selection.end.row) {
#line 5618
        if (r->selection.beg.row != r->selection.mark.row) {
#line 5625
          tmp___2 = r->selection.mark.col;
#line 5625
          r->selection.end.col = tmp___2;
#line 5625
          r->selection.beg.col = tmp___2;
#line 5626
          tmp___3 = r->selection.mark.row;
#line 5626
          r->selection.end.row = tmp___3;
#line 5626
          r->selection.beg.row = tmp___3;
        }
      }
    }
  }
#line 5634
  pos.col = col;
#line 5635
  pos.row = row;
#line 5637
  pos.row -= (int32_t )(r->vts[page])->view_start;
#line 5728
  if (button3) {
#line 5728
    if (buttonpress) {
#line 5733
      if (pos.row < r->selection.beg.row) {
#line 5739
        closeto = (enum __anonenum_closeto_380 )0;
      } else
#line 5733
      if (pos.row == r->selection.beg.row) {
#line 5733
        if (pos.col < r->selection.beg.col) {
#line 5739
          closeto = (enum __anonenum_closeto_380 )0;
        } else {
#line 5733
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 5733
      if (! (pos.row > r->selection.end.row)) {
#line 5733
        if (pos.row == r->selection.end.row) {
#line 5733
          if (! (pos.col > r->selection.end.col)) {
#line 5733
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 5733
        if ((unsigned int )(pos.col - r->selection.beg.col) + (unsigned int )(pos.row - r->selection.beg.row) * ncol < (unsigned int )(r->selection.end.col - pos.col) + (unsigned int )(r->selection.end.row - pos.row) * ncol) {
#line 5739
          closeto = (enum __anonenum_closeto_380 )0;
        }
      }
#line 5741
      if ((unsigned int )closeto == 0U) {
#line 5743
        r->selection.beg.row = pos.row;
#line 5744
        r->selection.beg.col = pos.col;
#line 5745
        r->selection.mark.row = r->selection.end.row;
#line 5746
        r->selection.mark.col = r->selection.end.col - ((int )r->selection.clicks == 2);
      } else {
#line 5751
        r->selection.end.row = pos.row;
#line 5752
        r->selection.end.col = pos.col;
#line 5753
        r->selection.mark.row = r->selection.beg.row;
#line 5754
        r->selection.mark.col = r->selection.beg.col;
      }
    } else {
#line 5728
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 5759
  if (r->selection.mark.row > pos.row) {
#line 5759
    goto _L___1;
  } else
#line 5759
  if (r->selection.mark.row == pos.row) {
#line 5759
    if (r->selection.mark.col > pos.col) {
      _L___1: /* CIL Label */ 
#line 5761
      if (r->selection.mark.row == r->selection.end.row) {
#line 5761
        if (r->selection.mark.col == r->selection.end.col) {
#line 5761
          if (clickchange) {
#line 5761
            if ((int )r->selection.clicks == 2) {
#line 5764
              (r->selection.mark.col) --;
            }
          }
        }
      }
#line 5765
      r->selection.beg.row = pos.row;
#line 5766
      r->selection.beg.col = pos.col;
#line 5767
      r->selection.end.row = r->selection.mark.row;
#line 5768
      r->selection.end.col = r->selection.mark.col + ((int )r->selection.clicks == 2);
    } else {
#line 5773
      r->selection.beg.row = r->selection.mark.row;
#line 5774
      r->selection.beg.col = r->selection.mark.col;
#line 5775
      r->selection.end.row = pos.row;
#line 5776
      r->selection.end.col = pos.col;
    }
  } else {
#line 5773
    r->selection.beg.row = r->selection.mark.row;
#line 5774
    r->selection.beg.col = r->selection.mark.col;
#line 5775
    r->selection.end.row = pos.row;
#line 5776
    r->selection.end.col = pos.col;
  }
#line 5781
  if ((int )r->selection.clicks == 1) {
#line 5783
    end_col = (int )*((r->vts[page])->screen.tlen + (r->selection.beg.row + (int32_t )(r->vts[page])->saveLines));
#line 5784
    if (end_col != -1) {
#line 5784
      if (r->selection.beg.col > end_col) {
#line 5787
        r->selection.beg.col = (int32_t )ncol;
      }
    }
#line 5795
    end_col = (int )*((r->vts[page])->screen.tlen + (r->selection.end.row + (int32_t )(r->vts[page])->saveLines));
#line 5797
    if (end_col != -1) {
#line 5797
      if (r->selection.end.col > end_col) {
#line 5798
        r->selection.end.col = (int32_t )ncol;
      }
    }
  } else
#line 5804
  if ((int )r->selection.clicks == 2) {
#line 5806
    if (r->selection.end.row > r->selection.beg.row) {
#line 5807
      (r->selection.end.col) --;
    } else
#line 5806
    if (r->selection.end.row == r->selection.beg.row) {
#line 5806
      if (r->selection.end.col > r->selection.beg.col) {
#line 5807
        (r->selection.end.col) --;
      }
    }
    {
#line 5808
    rxvt_selection_delimit_word(r, page, (enum page_dirn )0, (row_col_t const   *)(& r->selection.beg),
                                & r->selection.beg);
#line 5810
    rxvt_selection_delimit_word(r, page, (enum page_dirn )1, (row_col_t const   *)(& r->selection.end),
                                & r->selection.end);
    }
  } else
#line 5813
  if ((int )r->selection.clicks == 3) {
#line 5816
    if ((unsigned long )r->Options[(1UL << 19) & 3UL] & ((1UL << 19) & 0xfffffffffffffffcUL)) {
      {
#line 5820
      rxvt_selection_delimit_word(r, page, (enum page_dirn )0, (row_col_t const   *)(& r->selection.beg),
                                  & r->selection.beg);
#line 5822
      end_row = (int )*((r->vts[page])->screen.tlen + (r->selection.mark.row + (int32_t )(r->vts[page])->saveLines));
#line 5824
      end_row = r->selection.mark.row;
      }
      {
#line 5824
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5824
        if (! (end_row < (int )r->TermWin.nrow)) {
#line 5824
          goto while_break;
        }
#line 5830
        end_col = (int )*((r->vts[page])->screen.tlen + (end_row + (int )(r->vts[page])->saveLines));
#line 5831
        if (end_col != -1) {
          {
#line 5833
          r->selection.end.row = end_row;
#line 5834
          r->selection.end.col = end_col;
#line 5835
          rxvt_selection_trim(r, page);
          }
#line 5836
          goto while_break;
        }
#line 5824
        end_row ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 5843
      if (r->selection.mark.row > r->selection.beg.row) {
#line 5844
        (r->selection.mark.col) ++;
      } else
#line 5843
      if (r->selection.mark.row == r->selection.beg.row) {
#line 5843
        if (r->selection.mark.col > r->selection.beg.col) {
#line 5844
          (r->selection.mark.col) ++;
        }
      }
#line 5845
      r->selection.beg.col = 0;
#line 5846
      r->selection.end.col = (int32_t )ncol;
    }
  }
#line 5850
  if (button3) {
#line 5850
    if (buttonpress) {
#line 5853
      if ((unsigned int )closeto == 0U) {
#line 5855
        r->selection.mark.row = r->selection.end.row;
#line 5856
        r->selection.mark.col = r->selection.end.col - ((int )r->selection.clicks == 2);
      } else {
#line 5860
        r->selection.mark.row = r->selection.beg.row;
#line 5861
        r->selection.mark.col = r->selection.beg.col;
      }
    }
  }
#line 5868
  return;
}
}
#line 5873 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_trim(rxvt_t *r , int page ) 
{ 
  int32_t end_col ;
  int32_t end_row ;
  text_t *stp ;

  {
#line 5879
  end_col = r->selection.end.col;
#line 5880
  end_row = r->selection.end.row;
  {
#line 5881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5881
    if (! (end_row >= r->selection.beg.row)) {
#line 5881
      goto while_break;
    }
#line 5883
    stp = *((r->vts[page])->screen.text + (end_row + (int32_t )(r->vts[page])->saveLines));
    {
#line 5884
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5884
      end_col --;
#line 5884
      if (! (end_col >= 0)) {
#line 5884
        goto while_break___0;
      }
#line 5886
      if ((int )*(stp + end_col) != 32) {
#line 5886
        if ((int )*(stp + end_col) != 9) {
#line 5887
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5889
    if (end_col >= 0) {
#line 5891
      r->selection.end.col = end_col + 1;
#line 5892
      r->selection.end.row = end_row;
#line 5893
      goto while_break;
    } else
#line 5889
    if ((int )*((r->vts[page])->screen.tlen + ((end_row - 1) + (int32_t )(r->vts[page])->saveLines)) != -1) {
#line 5891
      r->selection.end.col = end_col + 1;
#line 5892
      r->selection.end.row = end_row;
#line 5893
      goto while_break;
    }
#line 5895
    end_row --;
#line 5896
    end_col = (int32_t )r->TermWin.ncol;
  }
  while_break: /* CIL Label */ ;
  }
#line 5899
  if (r->selection.mark.row > r->selection.end.row) {
#line 5901
    r->selection.mark.row = r->selection.end.row;
#line 5902
    r->selection.mark.col = r->selection.end.col;
  } else
#line 5904
  if (r->selection.mark.row == r->selection.end.row) {
#line 5904
    if (r->selection.mark.col > r->selection.end.col) {
#line 5906
      r->selection.mark.col = r->selection.end.col;
    }
  }
#line 5907
  return;
}
}
#line 5917 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_selection_rotate(rxvt_t *r , int page , int x , int y ) 
{ 


  {
  {
#line 5920
  r->selection.clicks = (short )((int )r->selection.clicks % 3 + 1);
#line 5922
  rxvt_selection_extend_colrow(r, page, (x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth,
                               (y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight,
                               1, 0, 1);
  }
#line 5924
  return;
}
}
#line 5934 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_process_selectionrequest(rxvt_t *r , int page , XSelectionRequestEvent const   *rq ) 
{ 
  XSelectionEvent ev ;
  Atom target_list[3] ;
  Atom target ;
  XTextProperty ct ;
  XICCEncodingStyle style ;
  char *cl[2] ;
  char dummy[1] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int selectlen ;

  {
#line 5948
  ev.type = 31;
#line 5949
  ev.property = (Atom )0L;
#line 5950
  ev.display = (Display *)rq->display;
#line 5951
  ev.requestor = (Window )rq->requestor;
#line 5952
  ev.selection = (Atom )rq->selection;
#line 5953
  ev.target = (Atom )rq->target;
#line 5954
  ev.time = (Time )rq->time;
#line 5956
  if (rq->target == (Atom const   )(r->h)->xa[4]) {
    {
#line 5958
    target_list[0] = (r->h)->xa[4];
#line 5959
    target_list[1] = (Atom )31;
#line 5960
    target_list[2] = (r->h)->xa[2];
#line 5964
    XChangeProperty(r->Xdisplay, (Window )rq->requestor, (Atom )rq->property, (Atom )4,
                    32, 0, (unsigned char const   *)((unsigned char *)(target_list)),
                    (int )(sizeof(target_list) / sizeof(target_list[0])));
#line 5968
    ev.property = (Atom )rq->property;
    }
  } else
#line 5970
  if (! (rq->target == (Atom const   )(r->h)->xa[3])) {
#line 5974
    if (rq->target == (Atom const   )(r->h)->xa[5]) {
#line 5974
      if (r->selection.text) {
#line 5976
        if (sizeof(Time ) > 4UL) {
#line 5976
          tmp = sizeof(Time ) / 4UL;
        } else {
#line 5976
          tmp = 1UL;
        }
#line 5976
        if (sizeof(Time ) > 4UL) {
#line 5976
          tmp___0 = 32UL;
        } else {
#line 5976
          tmp___0 = 8UL * sizeof(Time );
        }
        {
#line 5976
        XChangeProperty(r->Xdisplay, (Window )rq->requestor, (Atom )rq->property,
                        (Atom )19, (int )tmp___0, 0, (unsigned char const   *)((unsigned char *)(& (r->h)->selection_time)),
                        (int )tmp);
#line 5981
        ev.property = (Atom )rq->property;
        }
      } else {
#line 5974
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 5983
    if (rq->target == 31UL) {
#line 5983
      goto _L;
    } else
#line 5983
    if (rq->target == (Atom const   )(r->h)->xa[0]) {
#line 5983
      goto _L;
    } else
#line 5983
    if (rq->target == (Atom const   )(r->h)->xa[2]) {
      _L: /* CIL Label */ 
#line 6003
      target = (Atom )31;
#line 6004
      style = (XICCEncodingStyle )0;
#line 6006
      if (r->selection.text) {
#line 6008
        cl[0] = (char *)r->selection.text;
#line 6009
        selectlen = (int )r->selection.len;
      } else {
#line 6013
        cl[0] = dummy;
#line 6014
        dummy[0] = (char )'\000';
#line 6015
        selectlen = 0;
      }
      {
#line 6023
      ct.value = (unsigned char *)cl[0];
#line 6024
      ct.nitems = (unsigned long )selectlen;
#line 6026
      XChangeProperty(r->Xdisplay, (Window )rq->requestor, (Atom )rq->property, target,
                      8, 0, (unsigned char const   *)ct.value, (int )ct.nitems);
#line 6029
      ev.property = (Atom )rq->property;
      }
    }
  }
  {
#line 6035
  XSendEvent(r->Xdisplay, (Window )rq->requestor, 0, 0L, (XEvent *)(& ev));
  }
#line 6036
  return;
}
}
#line 6046 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/screen.c"
void rxvt_pixel_position(rxvt_t *r , int *x , int *y ) 
{ 


  {
#line 6049
  *x = (*x - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fwidth;
#line 6051
  *y = (*y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight;
#line 6053
  return;
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 1596 "/usr/include/X11/Xlib.h"
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1623
extern Pixmap XCreatePixmapFromBitmapData(Display * , Drawable  , char * , unsigned int  ,
                                          unsigned int  , unsigned long  , unsigned long  ,
                                          unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 2127
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2326
extern int XDrawArcs(Display * , Drawable  , GC  , XArc * , int  ) ;
#line 2364
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2483
extern int XFillArcs(Display * , Drawable  , GC  , XArc * , int  ) ;
#line 2491
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2808
extern int XMapRaised(Display * , Window  ) ;
#line 2837
extern int XMoveResizeWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ) ;
#line 2969
extern int XQueryColor(Display * , Colormap  , XColor * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3270
extern int XSetLineAttributes(Display * , GC  , unsigned int  , int  , int  , int  ) ;
#line 3345
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 3351
extern int XSetWindowBackgroundPixmap(Display * , Window  , Pixmap  ) ;
#line 3446
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 3517
extern int XUnmapWindow(Display * , Window  ) ;
#line 391 "/usr/include/X11/Xutil.h"
extern Region XCreateRegion(void) ;
#line 800
extern int XUnionRectWithRegion(XRectangle * , Region  , Region  ) ;
#line 104 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_destroy_termwin(rxvt_t *r , int page ) ;
#line 105
void rxvt_create_termwin(rxvt_t *r , int page , int profile , char const   *title ) ;
#line 106
char const   *getProfileOption(rxvt_t *r , int profile , int resource ) ;
#line 109
int rxvt_run_command(rxvt_t *r , int page , char const   **argv ) ;
#line 112
char **rxvt_string_to_argv(char const   *string , int *argc ) ;
#line 119
void rxvt_cleanutent(rxvt_t *r , int page ) ;
#line 137
void rxvt_privileges(int mode ) ;
#line 141
void rxvt_clean_exit(rxvt_t *r ) ;
#line 153
void rxvt_set_term_title(rxvt_t *r , unsigned char const   *str ) ;
#line 154
void rxvt_set_icon_name(rxvt_t *r , unsigned char const   *str ) ;
#line 160
int rxvt_parse_alloc_color(rxvt_t *r , XColor *screen_in_out , char const   *colour ) ;
#line 161
int rxvt_alloc_color(rxvt_t *r , XColor *screen_in_out , char const   *colour ) ;
#line 440
void refresh_tabbar_tab(rxvt_t *r , int page ) ;
#line 442
void rxvt_tabbar_resize(rxvt_t *r ) ;
#line 443
void rxvt_tabbar_dispatcher(rxvt_t *r , XButtonEvent *ev ) ;
#line 444
void rxvt_tabbar_button_release(rxvt_t *r , XButtonEvent *ev ) ;
#line 446
void rxvt_tabbar_expose(rxvt_t *r , XEvent *ev ) ;
#line 449
void rxvt_tabbar_create(rxvt_t *r ) ;
#line 450
void rxvt_tabbar_clean_exit(rxvt_t *r ) ;
#line 451
unsigned short rxvt_tabbar_height(rxvt_t *r ) ;
#line 452
unsigned short rxvt_tabbar_rheight(rxvt_t *r ) ;
#line 453
unsigned int rxvt_tab_width(rxvt_t *r , char const   *str ) ;
#line 454
int rxvt_is_tabbar_win(rxvt_t *r , Window w ) ;
#line 457
void rxvt_tabbar_change_color(rxvt_t *r , int item , char const   *str ) ;
#line 458
void rxvt_tabbar_highlight_tab(rxvt_t *r , short page , int force ) ;
#line 460
void sync_tab_title(rxvt_t *r , int page ) ;
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/close_term.xbm"
static unsigned char close_term_bits[54]  = 
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/close_term.xbm"
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)32,      (unsigned char)12,      (unsigned char)0,      (unsigned char)96, 
        (unsigned char)30,      (unsigned char)0,      (unsigned char)192,      (unsigned char)14, 
        (unsigned char)0,      (unsigned char)192,      (unsigned char)7,      (unsigned char)0, 
        (unsigned char)128,      (unsigned char)3,      (unsigned char)0,      (unsigned char)128, 
        (unsigned char)7,      (unsigned char)0,      (unsigned char)192,      (unsigned char)15, 
        (unsigned char)0,      (unsigned char)192,      (unsigned char)30,      (unsigned char)0, 
        (unsigned char)96,      (unsigned char)60,      (unsigned char)0,      (unsigned char)32, 
        (unsigned char)24,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/term.xbm"
static unsigned char term_bits[54]  = 
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/term.xbm"
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)254, 
        (unsigned char)255,      (unsigned char)1,      (unsigned char)254,      (unsigned char)255, 
        (unsigned char)1,      (unsigned char)254,      (unsigned char)255,      (unsigned char)1, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)10,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)18,      (unsigned char)0,      (unsigned char)1, 
        (unsigned char)18,      (unsigned char)0,      (unsigned char)1,      (unsigned char)10, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)0,      (unsigned char)1, 
        (unsigned char)2,      (unsigned char)0,      (unsigned char)1,      (unsigned char)2, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)0,      (unsigned char)1, 
        (unsigned char)254,      (unsigned char)255,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/right.xbm"
static unsigned char right_bits[54]  = 
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/right.xbm"
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)64,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)192,      (unsigned char)0,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)192,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)192,      (unsigned char)7,      (unsigned char)0, 
        (unsigned char)192,      (unsigned char)15,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)31,      (unsigned char)0,      (unsigned char)192,      (unsigned char)15, 
        (unsigned char)0,      (unsigned char)192,      (unsigned char)7,      (unsigned char)0, 
        (unsigned char)192,      (unsigned char)3,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)192,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)64,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/left.xbm"
static unsigned char left_bits[54]  = 
#line 3 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/left.xbm"
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)8,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)12,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)15, 
        (unsigned char)0,      (unsigned char)128,      (unsigned char)15,      (unsigned char)0, 
        (unsigned char)192,      (unsigned char)15,      (unsigned char)0,      (unsigned char)224, 
        (unsigned char)15,      (unsigned char)0,      (unsigned char)192,      (unsigned char)15, 
        (unsigned char)0,      (unsigned char)128,      (unsigned char)15,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)15,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)12, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)8,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 128 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static unsigned char *xbm_name[4]  = {      term_bits,      close_term_bits,      left_bits,      right_bits};
#line 135 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static Pixmap img[4]  ;
#line 143
char const   **cmd_argv ;
#line 151 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static int width_between(rxvt_t *r , int start , int end ) 
{ 
  register int i ;
  register int w ;

  {
#line 154
  w = 0;
#line 156
  i = start;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i <= end)) {
#line 156
      goto while_break;
    }
#line 157
    w += 1 + (int )(r->vts[i])->tab_width;
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (w);
}
}
#line 169 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static int find_left_tab(rxvt_t *r , int start , int distance ) 
{ 
  register int i ;
  register int left ;

  {
#line 175
  if (0 == start) {
#line 176
    return (0);
  }
#line 179
  if (distance < 0) {
#line 180
    return (start);
  }
#line 182
  left = distance;
#line 183
  i = start - 1;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i >= 0)) {
#line 183
      goto while_break;
    }
#line 185
    if (left < 1 + (int )(r->vts[i])->tab_width) {
#line 186
      goto while_break;
    }
#line 187
    left -= 1 + (int )(r->vts[i])->tab_width;
#line 183
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (i + 1);
}
}
#line 200 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static int find_right_tab(rxvt_t *r , int start , int distance ) 
{ 
  register int i ;
  register int left ;

  {
#line 206
  if ((int )r->tabBar.ltab == start) {
#line 207
    return (start);
  }
#line 210
  if (distance < 0) {
#line 211
    return (start);
  }
#line 213
  left = distance;
#line 214
  i = start + 1;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i <= (int )r->tabBar.ltab)) {
#line 214
      goto while_break;
    }
#line 216
    if (left < 1 + (int )(r->vts[i])->tab_width) {
#line 217
      goto while_break;
    }
#line 218
    left -= 1 + (int )(r->vts[i])->tab_width;
#line 214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (i - 1);
}
}
#line 231 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_set_visible_tabs(rxvt_t *r , int refresh ) 
{ 
  int tmp ;
  int tmp___0 ;
  register int size ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 307
  r->tabBar.fvtab = r->tabBar.atab;
#line 310
  if ((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL)) {
#line 310
    tmp = 0;
  } else {
#line 310
    tmp = 1;
  }
  {
#line 310
  tmp___0 = find_right_tab(r, (int )r->tabBar.fvtab, (r->szHint.width - tmp * 93) - (1 + (int )(r->vts[r->tabBar.fvtab])->tab_width));
#line 310
  r->tabBar.lvtab = (short )tmp___0;
  }
#line 313
  if ((int )r->tabBar.lvtab == (int )r->tabBar.ltab) {
#line 313
    if (0 != (int )r->tabBar.fvtab) {
#line 316
      if ((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL)) {
#line 316
        tmp___1 = 0;
      } else {
#line 316
        tmp___1 = 1;
      }
      {
#line 316
      tmp___2 = width_between(r, (int )r->tabBar.fvtab, (int )r->tabBar.lvtab);
#line 316
      size = (r->szHint.width - tmp___1 * 93) - tmp___2;
#line 319
      tmp___3 = find_left_tab(r, (int )r->tabBar.fvtab, size);
#line 319
      r->tabBar.fvtab = (short )tmp___3;
      }
    }
  }
#line 321
  if (refresh) {
#line 321
    if (0UL != r->tabBar.win) {
#line 322
      if ((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL)) {
#line 322
        tmp___4 = 0;
      } else {
#line 322
        tmp___4 = 1;
      }
      {
#line 322
      XClearArea(r->Xdisplay, r->tabBar.win, 0, 0, (unsigned int )(r->szHint.width - tmp___4 * 93),
                 0U, 1);
      }
    }
  }
#line 324
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static int draw_string(rxvt_t *r , Region clipRegion , int x , int y , char *str ,
                       int len , int multichar , int active ) 
{ 


  {
  {
#line 454
  XSetFont(r->Xdisplay, r->tabBar.gc, (r->TermWin.font)->fid);
#line 455
  rxvt_draw_string_x11(r, r->tabBar.win, r->tabBar.gc, clipRegion, x, y, str, len,
                       (int (*)())(& XDrawString));
  }
#line 457
  return (len * (int32_t )r->TermWin.fwidth);
}
}
#line 470 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static void draw_title(rxvt_t *r , int x , int y , int tnum , Region region ) 
{ 
  Region clipRegion ;
  char str[41] ;
  size_t tmp ;

  {
  {
#line 484
  clipRegion = (Region )0L;
#line 521
  y -= (r->TermWin.font)->descent;
#line 543
  strncpy((char */* __restrict  */)(str), (char const   */* __restrict  */)((char const   *)(r->vts[tnum])->tab_title),
          (size_t )r->TermWin.maxTabWidth);
#line 544
  str[r->TermWin.maxTabWidth] = (char )'\000';
#line 615
  tmp = strlen((char const   *)(str));
#line 615
  draw_string(r, clipRegion, x, y, str, (int )tmp, 0, tnum == (int )r->tabBar.atab);
  }
#line 622
  if ((unsigned long )((Region )0) != (unsigned long )clipRegion) {
    {
#line 624
    XDestroyRegion(clipRegion);
    }
#line 626
    if ((unsigned long )((Region )0) == (unsigned long )region) {
      {
#line 627
      XSetClipMask(r->Xdisplay, r->tabBar.gc, (Pixmap )0L);
      }
    } else {
      {
#line 629
      XSetRegion(r->Xdisplay, r->tabBar.gc, region);
      }
    }
  }
#line 635
  return;
}
}
#line 654 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void refresh_tabbar_tab(rxvt_t *r , int page ) 
{ 
  int i ;
  XRectangle rect ;

  {
#line 662
  if (page < (int )r->tabBar.fvtab) {
#line 662
    return;
  } else
#line 662
  if (page > (int )r->tabBar.lvtab) {
#line 662
    return;
  }
#line 664
  i = (int )r->tabBar.fvtab;
#line 664
  rect.x = (short)1;
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (i < page)) {
#line 664
      goto while_break;
    }
#line 665
    rect.x = (short )((int )rect.x + (1 + (int )(r->vts[i])->tab_width));
#line 664
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 667
  rect.y = (short)0;
#line 668
  rect.width = (unsigned short )(1 + (int )(r->vts[page])->tab_width);
#line 669
  rect.height = (unsigned short)0;
#line 672
  XClearArea(r->Xdisplay, r->tabBar.win, (int )rect.x, (int )rect.y, (unsigned int )rect.width,
             (unsigned int )rect.height, 1);
  }
#line 674
  return;
}
}
#line 681 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_draw_tabs(rxvt_t *r , Region region ) 
{ 
  int page ;
  int x ;
  XArc arcs[2] ;
  XPoint points[8] ;
  int clear ;
  int tmp ;

  {
#line 685
  if ((int )r->tabBar.ltab < 0) {
#line 689
    return;
  } else
#line 685
  if (0UL == r->tabBar.win) {
#line 689
    return;
  } else
#line 685
  if (! r->tabBar.state) {
#line 689
    return;
  }
#line 701
  if ((unsigned long )((Region )0) != (unsigned long )region) {
    {
#line 702
    XSetRegion(r->Xdisplay, r->tabBar.gc, region);
    }
  }
#line 704
  page = (int )r->tabBar.fvtab;
#line 704
  x = 1;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (page <= (int )r->tabBar.lvtab)) {
#line 704
      goto while_break;
    }
#line 718
    if (page == (int )r->tabBar.atab) {
#line 718
      goto _L___0;
    } else
#line 718
    if ((unsigned long )((void *)0) != (unsigned long )(& (r->vts[page])->monitor_tab)) {
#line 718
      if ((int )(r->vts[page])->monitor_tab == 4) {
        _L___0: /* CIL Label */ 
#line 727
        if (page == (int )r->tabBar.atab) {
#line 727
          if ((int )(r->vts[page])->monitor_tab == 4) {
            {
#line 730
            rxvt_msg((uint32_t )3, (uint32_t )64, "Macro MonitorTab: monitored tab %i is now the active tab",
                     page);
#line 732
            (r->vts[page])->monitor_tab = (short)0;
            }
          }
        }
#line 738
        clear = 0;
#line 740
        if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
#line 743
          points[0].x = (short)0;
#line 743
          points[0].y = (short)0;
#line 744
          points[1].x = (short )x;
#line 744
          points[1].y = (short)0;
#line 745
          points[2].x = (short )x;
#line 745
          points[2].y = (short )((int )((short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100)) - (100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 748
          arcs[0].x = (short )x;
#line 748
          arcs[0].y = (short )((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 748
          arcs[0].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 748
          arcs[0].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 748
          arcs[0].angle1 = (short)11520;
#line 748
          arcs[0].angle2 = (short)5760;
#line 750
          arcs[1].x = (short )((x + (int )(r->vts[r->tabBar.atab])->tab_width) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 750
          arcs[1].y = (short )((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 750
          arcs[1].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 750
          arcs[1].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 750
          arcs[1].angle1 = (short)17280;
#line 750
          arcs[1].angle2 = (short)5760;
#line 756
          points[3].x = (short )((int )((short )x) + (100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 756
          points[3].y = (short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100);
#line 757
          points[4].x = (short )(((int )((short )x) + (int )(r->vts[r->tabBar.atab])->tab_width) - (100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 757
          points[4].y = (short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100);
#line 761
          points[5].x = (short )((int )((short )x) + (int )(r->vts[r->tabBar.atab])->tab_width);
#line 761
          points[5].y = (short )((int )((short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100)) - (100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 763
          points[6].x = (short )((int )((short )x) + (int )(r->vts[r->tabBar.atab])->tab_width);
#line 763
          points[6].y = (short)0;
#line 764
          points[7].x = (short )r->szHint.width;
#line 764
          points[7].y = (short)0;
        } else {
#line 773
          points[0].x = (short)0;
#line 773
          points[0].y = (short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100);
#line 774
          points[1].x = (short )x;
#line 774
          points[1].y = (short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100);
#line 775
          points[2].x = (short )x;
#line 775
          points[2].y = (short )((100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 778
          arcs[0].x = (short )x;
#line 778
          arcs[0].y = (short)0;
#line 778
          arcs[0].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 778
          arcs[0].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 778
          arcs[0].angle1 = (short)11520;
#line 778
          arcs[0].angle2 = (short)-5760;
#line 780
          arcs[1].x = (short )((x + (int )(r->vts[r->tabBar.atab])->tab_width) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 780
          arcs[1].y = (short)0;
#line 780
          arcs[1].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 780
          arcs[1].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 780
          arcs[1].angle1 = (short)5760;
#line 780
          arcs[1].angle2 = (short)-5760;
#line 785
          points[3].x = (short )((int )((short )x) + (100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 785
          points[3].y = (short)0;
#line 786
          points[4].x = (short )(((int )((short )x) + (int )(r->vts[r->tabBar.atab])->tab_width) - (100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 786
          points[4].y = (short)0;
#line 793
          points[5].x = (short )((int )((short )x) + (int )(r->vts[r->tabBar.atab])->tab_width);
#line 793
          points[5].y = (short )((100 * ((int )r->TermWin.fwidth - 1)) / 100);
#line 795
          points[6].x = (short )((int )((short )x) + (int )(r->vts[r->tabBar.atab])->tab_width);
#line 795
          points[6].y = (short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100);
#line 796
          points[7].x = (short )r->szHint.width;
#line 796
          points[7].y = (short )(((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100);
        }
#line 804
        if ((r->h)->am_transparent) {
#line 804
          goto _L;
        } else
#line 804
        if ((r->h)->am_pixmap_trans) {
          _L: /* CIL Label */ 
#line 804
          if ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL)) {
#line 806
            clear = 1;
          }
        }
#line 809
        if (! clear) {
          {
#line 814
          XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.bg);
#line 816
          XFillArcs(r->Xdisplay, r->tabBar.win, r->tabBar.gc, arcs, 2);
#line 818
          XFillPolygon(r->Xdisplay, r->tabBar.win, r->tabBar.gc, points + 1, 6, 2,
                       0);
          }
        }
        {
#line 846
        XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.frame);
#line 849
        XDrawLines(r->Xdisplay, r->tabBar.win, r->tabBar.gc, points, 3, 0);
#line 852
        XDrawArcs(r->Xdisplay, r->tabBar.win, r->tabBar.gc, arcs, 2);
#line 854
        XDrawLines(r->Xdisplay, r->tabBar.win, r->tabBar.gc, points + 3, 2, 0);
#line 857
        XDrawLines(r->Xdisplay, r->tabBar.win, r->tabBar.gc, points + 5, 3, 0);
#line 861
        XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.fg);
#line 862
        draw_title(r, x + ((int )r->TermWin.fwidth - 1), ((20 * (int )r->TermWin.fheight) / 100) / 2 + (((int )r->TermWin.fheight + 3) + 1),
                   page, region);
        }
      } else {
#line 718
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 871
      XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.delimit);
      }
#line 873
      if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
        {
#line 876
        XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, x, 1, x, ((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (100 * ((int )r->TermWin.fwidth - 1)) / 100) - (20 * (int )r->TermWin.fheight) / 100);
#line 881
        arcs[0].x = (short )x;
#line 881
        arcs[0].y = (short )(((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (20 * (int )r->TermWin.fheight) / 100) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 881
        arcs[0].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 881
        arcs[0].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 881
        arcs[0].angle1 = (short)11520;
#line 881
        arcs[0].angle2 = (short)5760;
#line 883
        arcs[1].x = (short )((x + (int )(r->vts[page])->tab_width) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 883
        arcs[1].y = (short )(((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (20 * (int )r->TermWin.fheight) / 100) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 883
        arcs[1].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 883
        arcs[1].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 883
        arcs[1].angle1 = (short)17280;
#line 883
        arcs[1].angle2 = (short)5760;
#line 887
        XDrawArcs(r->Xdisplay, r->tabBar.win, r->tabBar.gc, arcs, 2);
#line 890
        XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, x + (100 * ((int )r->TermWin.fwidth - 1)) / 100,
                  (((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (20 * (int )r->TermWin.fheight) / 100,
                  (x + (int )(r->vts[page])->tab_width) - (100 * ((int )r->TermWin.fwidth - 1)) / 100,
                  (((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (20 * (int )r->TermWin.fheight) / 100);
#line 896
        XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, x + (int )(r->vts[page])->tab_width,
                  ((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (100 * ((int )r->TermWin.fwidth - 1)) / 100) - (20 * (int )r->TermWin.fheight) / 100,
                  x + (int )(r->vts[page])->tab_width, 1);
        }
      } else {
        {
#line 905
        XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, x, (((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - 1,
                  x, (100 * ((int )r->TermWin.fwidth - 1)) / 100 + (20 * (int )r->TermWin.fheight) / 100);
#line 910
        arcs[0].x = (short )x;
#line 910
        arcs[0].y = (short )((20 * (int )r->TermWin.fheight) / 100);
#line 910
        arcs[0].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 910
        arcs[0].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 910
        arcs[0].angle1 = (short)11520;
#line 910
        arcs[0].angle2 = (short)-5760;
#line 912
        arcs[1].x = (short )((x + (int )(r->vts[page])->tab_width) - 2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 912
        arcs[1].y = (short )((20 * (int )r->TermWin.fheight) / 100);
#line 912
        arcs[1].width = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 912
        arcs[1].height = (unsigned short )(2 * ((100 * ((int )r->TermWin.fwidth - 1)) / 100));
#line 912
        arcs[1].angle1 = (short)5760;
#line 912
        arcs[1].angle2 = (short)-5760;
#line 916
        XDrawArcs(r->Xdisplay, r->tabBar.win, r->tabBar.gc, arcs, 2);
#line 919
        XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, x + (100 * ((int )r->TermWin.fwidth - 1)) / 100,
                  (20 * (int )r->TermWin.fheight) / 100, (x + (int )(r->vts[page])->tab_width) - (100 * ((int )r->TermWin.fwidth - 1)) / 100,
                  (20 * (int )r->TermWin.fheight) / 100);
#line 925
        XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, x + (int )(r->vts[page])->tab_width,
                  (100 * ((int )r->TermWin.fwidth - 1)) / 100 + (20 * (int )r->TermWin.fheight) / 100,
                  x + (int )(r->vts[page])->tab_width, (((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - 1);
        }
      }
      {
#line 932
      XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.ifg);
      }
#line 933
      if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
#line 933
        tmp = ((int )r->TermWin.fheight + 3) + 1;
      } else {
#line 933
        tmp = (20 * (int )r->TermWin.fheight) / 100 + (((int )r->TermWin.fheight + 3) + 1);
      }
      {
#line 933
      draw_title(r, x + ((int )r->TermWin.fwidth - 1), tmp, page, region);
      }
#line 939
      if ((r->vts[page])->highlight) {
        {
#line 940
        rxvt_tabbar_highlight_tab(r, (short )page, 1);
        }
      }
    }
#line 944
    x += 1 + (int )(r->vts[page])->tab_width;
#line 704
    page ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  if ((unsigned long )((Region )0) != (unsigned long )region) {
    {
#line 948
    XSetClipMask(r->Xdisplay, r->tabBar.gc, (Pixmap )0L);
    }
  }
#line 949
  return;
}
}
#line 953 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_highlight_tab(rxvt_t *r , short page , int force ) 
{ 
  register int i ;
  register int x ;
  int sx ;
  int sy ;
  unsigned int rw ;
  unsigned int rh ;
  XGCValues gcvalues ;

  {
#line 974
  if (! force) {
#line 974
    if ((r->vts[page])->highlight) {
#line 975
      return;
    }
  }
#line 978
  (r->vts[page])->highlight = (unsigned char)1;
#line 980
  if ((int )r->tabBar.ltab < 0) {
#line 981
    return;
  } else
#line 980
  if (0UL == r->tabBar.win) {
#line 981
    return;
  } else
#line 980
  if (! r->tabBar.state) {
#line 981
    return;
  }
#line 984
  if ((int )page < (int )r->tabBar.fvtab) {
#line 985
    return;
  } else
#line 984
  if ((int )page > (int )r->tabBar.lvtab) {
#line 985
    return;
  } else
#line 984
  if ((int )page == (int )r->tabBar.atab) {
#line 985
    return;
  }
#line 987
  i = (int )r->tabBar.fvtab;
#line 987
  x = 1;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! (i < (int )page)) {
#line 987
      goto while_break;
    }
#line 987
    x += 1 + (int )(r->vts[i])->tab_width;
#line 987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 990
  XGetGCValues(r->Xdisplay, r->tabBar.gc, (unsigned long )((((1L << 4) | (1L << 5)) | (1L << 6)) | (1L << 7)),
               & gcvalues);
#line 993
  XSetLineAttributes(r->Xdisplay, r->tabBar.gc, 1U, 1, 1, 0);
#line 996
  XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.ifg);
#line 999
  sx = x + ((int )r->TermWin.fwidth - 1) / 2;
  }
#line 1000
  if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1000
    sy = 1;
  } else {
#line 1000
    sy = (20 * (int )r->TermWin.fheight) / 100 + 1;
  }
  {
#line 1003
  rw = (unsigned int )((int )(r->vts[page])->tab_width - ((int )r->TermWin.fwidth - 1));
#line 1004
  rh = (unsigned int )(((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - (20 * (int )r->TermWin.fheight) / 100) - 3);
#line 1006
  XDrawRectangle(r->Xdisplay, r->tabBar.win, r->tabBar.gc, sx, sy, rw, rh);
#line 1010
  XChangeGC(r->Xdisplay, r->tabBar.gc, (unsigned long )((((1L << 4) | (1L << 5)) | (1L << 6)) | (1L << 7)),
            & gcvalues);
  }
#line 1013
  return;
}
}
#line 1019 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_draw_buttons(rxvt_t *r ) 
{ 
  register int i ;
  int topoff ;
  unsigned long frame ;
  int sx ;
  int sx___0 ;

  {
#line 1027
  if ((int )r->tabBar.ltab < 0) {
#line 1028
    return;
  }
#line 1029
  if (0UL == r->tabBar.win) {
#line 1030
    return;
  }
#line 1031
  if (! r->tabBar.state) {
#line 1032
    return;
  }
#line 1035
  if ((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1036
    return;
  }
#line 1038
  if (0 > ((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - 18) / 2) {
#line 1038
    topoff = 0;
  } else {
#line 1038
    topoff = ((((int )r->TermWin.fheight + 6) + (20 * (int )r->TermWin.fheight) / 100) - 18) / 2;
  }
  {
#line 1043
  frame = r->tabBar.frame;
#line 1045
  XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.fg);
#line 1046
  i = 4;
  }
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! (i >= 1)) {
#line 1046
      goto while_break;
    }
#line 1072
    if (0UL != img[4 - i]) {
      {
#line 1074
      XCopyArea(r->Xdisplay, img[4 - i], r->tabBar.win, r->tabBar.gc, 0, 0, 18U, 18U,
                r->szHint.width - i * 23, topoff);
      }
    }
#line 1046
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1082
  XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.frame);
#line 1083
  i = 4;
  }
  {
#line 1083
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1083
    if (! (i >= 1)) {
#line 1083
      goto while_break___0;
    }
    {
#line 1091
    sx = r->szHint.width - i * 23;
#line 1093
    XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, sx, topoff, sx + 18, topoff);
#line 1096
    XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, sx, topoff, sx, topoff + 18);
#line 1083
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1099
  XSetForeground(r->Xdisplay, r->tabBar.gc, r->tabBar.delimit);
#line 1100
  i = 4;
  }
  {
#line 1100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1100
    if (! (i >= 1)) {
#line 1100
      goto while_break___1;
    }
    {
#line 1102
    sx___0 = r->szHint.width - i * 23;
#line 1104
    XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, sx___0, topoff + 18, sx___0 + 18,
              topoff + 18);
#line 1107
    XDrawLine(r->Xdisplay, r->tabBar.win, r->tabBar.gc, sx___0 + 18, topoff, sx___0 + 18,
              topoff + 18);
#line 1100
    i --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1110
  return;
}
}
#line 1117 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
static void init_tabbar(rxvt_t *r ) 
{ 
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 1120
  r->tabBar.state = (char)0;
#line 1122
  r->tabBar.ltab = (short)-1;
#line 1123
  r->tabBar.atab = (short)0;
#line 1124
  r->tabBar.fvtab = (short)0;
#line 1125
  r->tabBar.lvtab = (short)0;
#line 1126
  r->tabBar.ptab = (short)0;
#line 1138
  tmp___1 = (char)0;
#line 1138
  r->tabBar.rsibg = tmp___1;
#line 1138
  tmp___0 = tmp___1;
#line 1138
  r->tabBar.rsifg = tmp___0;
#line 1138
  tmp = tmp___0;
#line 1138
  r->tabBar.rsbg = tmp;
#line 1138
  r->tabBar.rsfg = tmp;
#line 1142
  return;
}
}
#line 1146 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_kill_page(rxvt_t *r , short page ) 
{ 


  {
  {
#line 1149
  kill((r->vts[page])->cmd_pid, 1);
  }
#line 1150
  return;
}
}
#line 1157 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_adjust_fd_number(rxvt_t *r ) 
{ 
  int num_fds ;
  int i ;

  {
#line 1160
  num_fds = 2;
#line 1163
  i = 0;
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (! (i <= (int )r->tabBar.ltab)) {
#line 1163
      goto while_break;
    }
#line 1164
    if ((r->vts[i])->cmd_fd > num_fds) {
#line 1164
      num_fds = (r->vts[i])->cmd_fd;
    }
#line 1163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1167
  if (r->Xfd > num_fds) {
#line 1167
    num_fds = r->Xfd;
  }
#line 1169
  if (r->fifo_fd > num_fds) {
#line 1169
    num_fds = r->fifo_fd;
  }
#line 1172
  if (r->TermWin.ice_fd > num_fds) {
#line 1172
    num_fds = r->TermWin.ice_fd;
  }
#line 1182
  r->num_fds = num_fds + 1;
#line 1184
  return;
}
}
#line 1192 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_append_page(rxvt_t *r , int profile , char const   *title , char const   *command ) 
{ 
  int num_cmd_args ;
  char **argv ;
  char const   *cmd ;
  char const   *cwdOption ;
  char const   *tmp ;
  char cwd[4096] ;
  unsigned int tmp___0 ;
  char child_cwd[4096] ;
  unsigned int tmp___1 ;
  int len ;
  char proc_cwd[32] ;
  ssize_t tmp___2 ;
  wordexp_t p ;
  int wordexp_result ;
  int tmp___3 ;
  char *filename ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char **s ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
#line 1196
  num_cmd_args = 0;
#line 1205
  if ((int )r->tabBar.ltab == 14) {
    {
#line 1207
    rxvt_msg((uint32_t )1, (uint32_t )256, "Too many tabs");
    }
#line 1208
    return;
  }
#line 1211
  if (profile < 0) {
    {
#line 1213
    rxvt_msg((uint32_t )2, (uint32_t )256, "Warning: Profile %d out of range", profile);
#line 1214
    profile = 0;
    }
  } else
#line 1211
  if (profile >= 5) {
    {
#line 1213
    rxvt_msg((uint32_t )2, (uint32_t )256, "Warning: Profile %d out of range", profile);
#line 1214
    profile = 0;
    }
  }
#line 1218
  r->tabBar.ltab = (short )((int )r->tabBar.ltab + 1);
#line 1226
  if (cmd_argv) {
#line 1226
    if ((unsigned long )command == (unsigned long )((void *)0)) {
#line 1226
      if ((int )r->tabBar.ltab == 0) {
#line 1234
        argv = cmd_argv;
      } else
#line 1226
      if ((unsigned long )r->Options[((1UL << 3) | 1UL) & 3UL] & (((1UL << 3) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1234
        argv = cmd_argv;
      } else {
#line 1226
        goto _L___0;
      }
    } else {
#line 1226
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1239
    if ((unsigned long )command == (unsigned long )((void *)0)) {
      {
#line 1240
      command = getProfileOption(r, profile, 339);
      }
    }
#line 1242
    if ((unsigned long )command != (unsigned long )((void *)0)) {
#line 1242
      if ((int const   )*command != 33) {
#line 1244
        cmd = command;
#line 1247
        if ((int const   )*(cmd + 0) == 92) {
#line 1247
          if ((int const   )*(cmd + 1) == 33) {
#line 1248
            cmd ++;
          }
        }
        {
#line 1250
        argv = rxvt_string_to_argv(cmd, & num_cmd_args);
        }
      } else {
#line 1253
        argv = (char **)((void *)0);
      }
    } else {
#line 1253
      argv = (char **)((void *)0);
    }
  }
#line 1260
  if ((unsigned long )title == (unsigned long )((void *)0)) {
#line 1260
    goto _L___3;
  } else
#line 1260
  if ((int const   )*title == 0) {
    _L___3: /* CIL Label */ 
    {
#line 1262
    title = getProfileOption(r, profile, 334);
    }
#line 1263
    if ((unsigned long )title == (unsigned long )((void *)0)) {
#line 1263
      goto _L___2;
    } else
#line 1263
    if ((int const   )*title == 0) {
      _L___2: /* CIL Label */ 
#line 1265
      if (command) {
#line 1265
        if ((int const   )*command != 0) {
#line 1266
          title = command;
        } else {
#line 1265
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1267
      if (argv) {
#line 1267
        if (*(argv + 0)) {
#line 1267
          if ((int )*(*(argv + 0)) != 0) {
#line 1268
            title = (char const   *)*(argv + 0);
          }
        }
      }
    }
  }
  {
#line 1271
  rxvt_create_termwin(r, (int )r->tabBar.ltab, profile, title);
#line 1279
  tmp___7 = getProfileOption(r, profile, 359);
  }
#line 1279
  if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
    {
#line 1281
    tmp = getProfileOption(r, profile, 359);
#line 1281
    cwdOption = tmp;
#line 1282
    cwd[0] = (char )'\000';
#line 1282
    tmp___0 = 1U;
    }
    {
#line 1282
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1282
      if (tmp___0 >= 4096U) {
#line 1282
        goto while_break;
      }
#line 1282
      cwd[tmp___0] = (char)0;
#line 1282
      tmp___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1282
    child_cwd[0] = (char )'\000';
#line 1282
    tmp___1 = 1U;
    {
#line 1282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1282
      if (tmp___1 >= 4096U) {
#line 1282
        goto while_break___0;
      }
#line 1282
      child_cwd[tmp___1] = (char)0;
#line 1282
      tmp___1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1284
    len = 0;
#line 1287
    getcwd(cwd, (size_t )4096);
#line 1289
    tmp___5 = strcmp(cwdOption, ".");
    }
#line 1289
    if (tmp___5) {
      {
#line 1309
      tmp___3 = wordexp((char const   */* __restrict  */)cwdOption, (wordexp_t */* __restrict  */)(& p),
                        0);
#line 1309
      wordexp_result = tmp___3;
      }
#line 1312
      if (wordexp_result == 0) {
#line 1314
        if (p.we_wordc > 1UL) {
          {
#line 1315
          rxvt_msg((uint32_t )1, (uint32_t )256, "Too many words when expanding %s\n",
                   cwdOption);
          }
        } else {
          {
#line 1319
          filename = *(p.we_wordv);
#line 1321
          tmp___4 = strlen((char const   *)filename);
#line 1321
          len = (int )tmp___4;
          }
#line 1322
          if (4095 < len) {
#line 1322
            len = 4095;
          }
          {
#line 1323
          strncpy((char */* __restrict  */)(child_cwd), (char const   */* __restrict  */)((char const   *)filename),
                  (size_t )len);
#line 1324
          child_cwd[len] = (char)0;
          }
        }
        {
#line 1327
        wordfree(& p);
        }
      }
    } else
#line 1291
    if ((int )r->tabBar.atab != (int )r->tabBar.ltab) {
      {
#line 1298
      sprintf((char */* __restrict  */)(proc_cwd), (char const   */* __restrict  */)"/proc/%d/cwd",
              (r->vts[r->tabBar.atab])->cmd_pid);
#line 1299
      tmp___2 = readlink((char const   */* __restrict  */)(proc_cwd), (char */* __restrict  */)(child_cwd),
                         (size_t )4095);
#line 1299
      len = (int )tmp___2;
      }
#line 1299
      if (len > 0) {
#line 1301
        child_cwd[len] = (char)0;
      }
    }
#line 1339
    if (len > 0) {
      {
#line 1339
      tmp___6 = chdir((char const   *)(child_cwd));
      }
#line 1339
      if (tmp___6 == 0) {
        {
#line 1346
        (r->vts[r->tabBar.ltab])->cmd_fd = rxvt_run_command(r, (int )r->tabBar.ltab,
                                                            (char const   **)argv);
#line 1350
        chdir((char const   *)(cwd));
        }
      } else {
        {
#line 1359
        (r->vts[r->tabBar.ltab])->cmd_fd = rxvt_run_command(r, (int )r->tabBar.ltab,
                                                            (char const   **)argv);
        }
      }
    } else {
      {
#line 1359
      (r->vts[r->tabBar.ltab])->cmd_fd = rxvt_run_command(r, (int )r->tabBar.ltab,
                                                          (char const   **)argv);
      }
    }
  } else {
    {
#line 1364
    (r->vts[r->tabBar.ltab])->cmd_fd = rxvt_run_command(r, (int )r->tabBar.ltab, (char const   **)argv);
    }
  }
#line 1371
  if (num_cmd_args > 0) {
#line 1375
    s = argv;
    {
#line 1375
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1375
      if (! ((unsigned long )*s != (unsigned long )((void *)0))) {
#line 1375
        goto while_break___1;
      }
      {
#line 1375
      rxvt_free((void *)*s);
#line 1375
      s ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1376
    rxvt_free((void *)argv);
    }
  }
#line 1383
  if (-1 == (r->vts[r->tabBar.ltab])->cmd_fd) {
    {
#line 1385
    rxvt_destroy_termwin(r, (int )r->tabBar.ltab);
#line 1386
    r->tabBar.ltab = (short )((int )r->tabBar.ltab - 1);
    }
#line 1387
    return;
  }
  {
#line 1393
  rxvt_adjust_fd_number(r);
#line 1398
  rxvt_scr_reset(r, (int )r->tabBar.ltab);
#line 1399
  rxvt_scr_refresh(r, (int )r->tabBar.ltab, (unsigned char)1);
  }
#line 1405
  if ((unsigned long )command != (unsigned long )((void *)0)) {
#line 1405
    if ((int const   )*command == 33) {
      {
#line 1407
      command ++;
#line 1408
      tmp___8 = strlen(command);
#line 1408
      rxvt_tt_write(r, (int )r->tabBar.ltab, (unsigned char const   *)command, (int )tmp___8);
#line 1410
      rxvt_tt_write(r, (int )r->tabBar.ltab, (unsigned char const   *)"\n", 1);
      }
    }
  }
#line 1416
  r->tabBar.ptab = r->tabBar.atab;
#line 1417
  r->tabBar.atab = r->tabBar.ltab;
#line 1420
  (r->vts[r->tabBar.atab])->mapped = (uint16_t )1;
#line 1423
  if ((int )r->tabBar.ptab != (int )r->tabBar.atab) {
#line 1424
    (r->vts[r->tabBar.ptab])->mapped = (uint16_t )0;
  }
  {
#line 1427
  rxvt_tabbar_set_visible_tabs(r, 1);
#line 1428
  refresh_tabbar_tab(r, (int )r->tabBar.ptab);
  }
#line 1434
  if (! r->tabBar.state) {
#line 1434
    if ((int )r->tabBar.ltab == 1) {
#line 1434
      if ((unsigned long )r->Options[((1UL << 28) | 1UL) & 3UL] & (((1UL << 28) | 1UL) & 0xfffffffffffffffcUL)) {
        {
#line 1434
        tmp___9 = rxvt_tabbar_show(r);
        }
#line 1434
        if (tmp___9) {
          {
#line 1439
          rxvt_resize_on_subwin(r, (resize_reason_t )3);
          }
        }
      }
    }
  }
#line 1442
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 1443
    sync_tab_title(r, (int )r->tabBar.atab);
    }
  }
#line 1446
  if ((unsigned long )r->Options[((1UL << 11) | 1UL) & 3UL] & (((1UL << 11) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 1447
    rxvt_set_icon_name(r, (unsigned char const   *)(r->vts[r->tabBar.atab])->tab_title);
    }
  }
#line 1449
  return;
}
}
#line 1456 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_remove_page(rxvt_t *r , short page ) 
{ 
  register int i ;
  int tmp ;

  {
  {
#line 1467
  rxvt_privileges('r');
#line 1468
  rxvt_cleanutent(r, (int )page);
#line 1469
  rxvt_privileges(0);
#line 1474
  rxvt_free((void *)(r->vts[page])->ttydev);
#line 1476
  close((r->vts[page])->cmd_fd);
  }
#line 1478
  if ((r->vts[page])->v_buffer) {
    {
#line 1480
    rxvt_free((void *)(r->vts[page])->v_buffer);
#line 1481
    (r->vts[page])->v_buffer = (unsigned char *)((void *)0);
    }
  }
  {
#line 1485
  rxvt_scr_release(r, (int )page);
#line 1488
  rxvt_destroy_termwin(r, (int )page);
#line 1491
  r->tabBar.ltab = (short )((int )r->tabBar.ltab - 1);
  }
#line 1494
  if ((int )r->tabBar.ltab < 0) {
    {
#line 1495
    rxvt_clean_exit(r);
    }
  }
#line 1498
  i = (int )page;
  {
#line 1498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1498
    if (! (i <= (int )r->tabBar.ltab)) {
#line 1498
      goto while_break;
    }
    {
#line 1500
    r->vts[i] = r->vts[i + 1];
#line 1501
    refresh_tabbar_tab(r, i);
#line 1498
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1505
  if ((int )page == (int )r->selection.vt) {
    {
#line 1506
    rxvt_process_selectionclear(r, (int )page);
    }
  } else
#line 1507
  if ((int )r->selection.vt > (int )page) {
#line 1508
    r->selection.vt = (short )((int )r->selection.vt - 1);
  }
#line 1515
  if ((int )r->tabBar.ptab > (int )page) {
#line 1515
    r->tabBar.ptab = (short )((int )r->tabBar.ptab - 1);
  }
#line 1517
  if ((int )r->tabBar.ptab > (int )r->tabBar.ltab) {
#line 1517
    r->tabBar.ptab = r->tabBar.ltab;
  }
#line 1520
  if ((int )r->tabBar.atab == (int )page) {
#line 1523
    r->tabBar.atab = r->tabBar.ptab;
#line 1526
    if ((int )r->tabBar.ptab > 0) {
#line 1526
      r->tabBar.ptab = (short )((int )r->tabBar.ptab - 1);
    } else
#line 1527
    if ((int )r->tabBar.ptab < (int )r->tabBar.ltab) {
#line 1527
      r->tabBar.ptab = (short )((int )r->tabBar.ptab + 1);
    }
  } else
#line 1529
  if ((int )r->tabBar.atab > (int )page) {
#line 1529
    r->tabBar.atab = (short )((int )r->tabBar.atab - 1);
  }
  {
#line 1532
  (r->vts[r->tabBar.atab])->mapped = (uint16_t )1;
#line 1535
  rxvt_adjust_fd_number(r);
#line 1539
  rxvt_tabbar_set_visible_tabs(r, 1);
#line 1540
  refresh_tabbar_tab(r, (int )r->tabBar.atab);
  }
#line 1543
  if (r->tabBar.state) {
#line 1545
    if ((int )r->tabBar.ltab == 0) {
#line 1545
      if ((unsigned long )r->Options[((1UL << 28) | 1UL) & 3UL] & (((1UL << 28) | 1UL) & 0xfffffffffffffffcUL)) {
        {
#line 1545
        tmp = rxvt_tabbar_hide(r);
        }
#line 1545
        if (tmp) {
          {
#line 1550
          rxvt_resize_on_subwin(r, (resize_reason_t )2);
          }
        }
      }
    }
  }
  {
#line 1554
  rxvt_set_vt_colors(r, (int )r->tabBar.atab);
#line 1555
  XMapRaised(r->Xdisplay, (r->vts[r->tabBar.atab])->vt);
  }
#line 1566
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 1567
    sync_tab_title(r, (int )r->tabBar.atab);
    }
  }
#line 1570
  if ((unsigned long )r->Options[((1UL << 11) | 1UL) & 3UL] & (((1UL << 11) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 1571
    rxvt_set_icon_name(r, (unsigned char const   *)(r->vts[r->tabBar.atab])->tab_title);
    }
  }
#line 1573
  return;
}
}
#line 1580 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_set_title(rxvt_t *r , short page , unsigned char const   *str ) 
{ 
  char *n_title ;
  unsigned int tmp ;

  {
  {
#line 1589
  n_title = strndup((char const   *)str, (size_t )507);
  }
#line 1593
  if ((unsigned long )((void *)0) != (unsigned long )n_title) {
    {
#line 1595
    rxvt_free((void *)(r->vts[page])->tab_title);
#line 1596
    (r->vts[page])->tab_title = n_title;
#line 1599
    tmp = rxvt_tab_width(r, (char const   *)n_title);
#line 1599
    (r->vts[page])->tab_width = (short )tmp;
    }
  }
#line 1605
  if ((int )page >= (int )r->tabBar.fvtab) {
#line 1605
    if ((int )page <= (int )r->tabBar.lvtab) {
      {
#line 1608
      rxvt_tabbar_set_visible_tabs(r, 1);
#line 1609
      refresh_tabbar_tab(r, (int )page);
      }
    }
  }
#line 1613
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1613
    if ((int )page == (int )r->tabBar.atab) {
      {
#line 1615
      sync_tab_title(r, (int )r->tabBar.atab);
      }
    }
  }
#line 1618
  if ((unsigned long )r->Options[((1UL << 11) | 1UL) & 3UL] & (((1UL << 11) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1618
    if ((int )page == (int )r->tabBar.atab) {
      {
#line 1620
      rxvt_set_icon_name(r, (unsigned char const   *)(r->vts[r->tabBar.atab])->tab_title);
      }
    }
  }
#line 1622
  return;
}
}
#line 1629 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_activate_page(rxvt_t *r , short index___0 ) 
{ 


  {
#line 1633
  if ((int )index___0 == (int )r->tabBar.atab) {
#line 1636
    return;
  }
#line 1638
  (r->vts[r->tabBar.atab])->mapped = (uint16_t )0;
#line 1639
  r->tabBar.ptab = r->tabBar.atab;
#line 1640
  r->tabBar.atab = index___0;
#line 1641
  (r->vts[r->tabBar.atab])->mapped = (uint16_t )1;
#line 1642
  (r->vts[r->tabBar.atab])->highlight = (unsigned char)0;
#line 1648
  if ((int )index___0 < (int )r->tabBar.fvtab) {
    {
#line 1651
    rxvt_tabbar_set_visible_tabs(r, 1);
    }
  } else
#line 1648
  if ((int )index___0 > (int )r->tabBar.lvtab) {
    {
#line 1651
    rxvt_tabbar_set_visible_tabs(r, 1);
    }
  }
  {
#line 1653
  refresh_tabbar_tab(r, (int )r->tabBar.atab);
#line 1654
  refresh_tabbar_tab(r, (int )r->tabBar.ptab);
#line 1657
  rxvt_set_vt_colors(r, (int )r->tabBar.atab);
#line 1658
  XMapRaised(r->Xdisplay, (r->vts[r->tabBar.atab])->vt);
  }
#line 1669
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 1670
    sync_tab_title(r, (int )r->tabBar.atab);
    }
  }
#line 1673
  if ((unsigned long )r->Options[((1UL << 11) | 1UL) & 3UL] & (((1UL << 11) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 1674
    rxvt_set_icon_name(r, (unsigned char const   *)(r->vts[r->tabBar.atab])->tab_title);
    }
  }
#line 1676
  return;
}
}
#line 1683 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_resize(rxvt_t *r ) 
{ 
  register int i ;
  int sx ;
  int sy ;
  unsigned short tmp ;
  unsigned int tmp___0 ;

  {
#line 1690
  sx = 0;
#line 1691
  sy = 0;
#line 1695
  if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1696
    sy += (r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth;
  }
  {
#line 1697
  tmp = rxvt_tabbar_rheight(r);
#line 1697
  XMoveResizeWindow(r->Xdisplay, r->tabBar.win, sx, sy, (unsigned int )r->szHint.width,
                    (unsigned int )tmp);
#line 1701
  i = 0;
  }
  {
#line 1701
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1701
    if (! (i <= (int )r->tabBar.ltab)) {
#line 1701
      goto while_break;
    }
    {
#line 1702
    tmp___0 = rxvt_tab_width(r, (char const   *)(r->vts[i])->tab_title);
#line 1702
    (r->vts[i])->tab_width = (short )tmp___0;
#line 1701
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1705
  rxvt_tabbar_set_visible_tabs(r, 0);
#line 1707
  XClearArea(r->Xdisplay, r->tabBar.win, 0, 0, 0U, 0U, 1);
  }
#line 1709
  return;
}
}
#line 1716 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_dispatcher(rxvt_t *r , XButtonEvent *ev ) 
{ 
  register int x ;
  register int y ;
  register int z ;
  register int but ;
  register int w ;
  register int i ;
  int tmp ;

  {
#line 1721
  x = ev->x;
#line 1722
  y = ev->y;
#line 1723
  but = -1;
  {
#line 1753
  if (ev->button == 4U) {
#line 1753
    goto case_4;
  }
#line 1760
  if (ev->button == 5U) {
#line 1760
    goto case_5;
  }
#line 1767
  goto switch_default;
  case_4: /* CIL Label */ 
#line 1754
  if (0 != (int )r->tabBar.atab) {
    {
#line 1755
    rxvt_activate_page(r, (short )((int )r->tabBar.atab - 1));
    }
  } else
#line 1756
  if (0 != (int )r->tabBar.ltab) {
    {
#line 1757
    rxvt_activate_page(r, r->tabBar.ltab);
    }
  }
#line 1758
  return;
  case_5: /* CIL Label */ 
#line 1761
  if ((int )r->tabBar.atab != (int )r->tabBar.ltab) {
    {
#line 1762
    rxvt_activate_page(r, (short )((int )r->tabBar.atab + 1));
    }
  } else
#line 1763
  if (0 != (int )r->tabBar.ltab) {
    {
#line 1764
    rxvt_activate_page(r, (short)0);
    }
  }
#line 1765
  return;
  switch_default: /* CIL Label */ 
#line 1768
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1773
  z = r->szHint.width - x;
#line 1774
  if (! ((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL))) {
#line 1774
    if (z < 92) {
#line 1774
      if (z % 23 > 5) {
#line 1780
        but = z / 23;
#line 1783
        if (ev->button != 1U) {
#line 1786
          return;
        }
        {
#line 1792
        if (but == 0) {
#line 1792
          goto case_0;
        }
#line 1797
        if (but == 1) {
#line 1797
          goto case_1;
        }
#line 1802
        if (but == 2) {
#line 1802
          goto case_2;
        }
#line 1820
        if (but == 3) {
#line 1820
          goto case_3;
        }
#line 1824
        goto switch_default___0;
        case_0: /* CIL Label */ 
#line 1793
        if ((int )r->tabBar.atab < (int )r->tabBar.ltab) {
          {
#line 1794
          rxvt_activate_page(r, (short )((int )r->tabBar.atab + 1));
          }
        }
#line 1795
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 1798
        if ((int )r->tabBar.atab > 0) {
          {
#line 1799
          rxvt_activate_page(r, (short )((int )r->tabBar.atab - 1));
          }
        }
#line 1800
        goto switch_break___0;
        case_2: /* CIL Label */ 
#line 1803
        if (! ((unsigned long )r->Options[((1UL << 2) | 1UL) & 3UL] & (((1UL << 2) | 1UL) & 0xfffffffffffffffcUL))) {
          {
#line 1815
          (r->vts[r->tabBar.atab])->holdOption = (unsigned char )((unsigned int )(r->vts[r->tabBar.atab])->holdOption & ~ ((1U << 1) | (1U << 2)));
#line 1816
          rxvt_kill_page(r, r->tabBar.atab);
          }
        } else
#line 1803
        if ((unsigned long )r->Options[((1UL << 2) | 1UL) & 3UL] & (((1UL << 2) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1803
          if (0 == (int )(r->vts[r->tabBar.atab])->current_screen) {
            {
#line 1815
            (r->vts[r->tabBar.atab])->holdOption = (unsigned char )((unsigned int )(r->vts[r->tabBar.atab])->holdOption & ~ ((1U << 1) | (1U << 2)));
#line 1816
            rxvt_kill_page(r, r->tabBar.atab);
            }
          }
        }
#line 1818
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
#line 1821
        rxvt_append_page(r, 0, (char const   *)((void *)0), (char const   *)((void *)0));
        }
#line 1822
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 1825
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 1774
        goto _L___0;
      }
    } else {
#line 1774
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1828
    if ((unsigned long )r->Options[((1UL << 17) | 1UL) & 3UL] & (((1UL << 17) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1828
      tmp = 0;
    } else {
#line 1828
      tmp = 1;
    }
#line 1828
    if (x < r->szHint.width - tmp * 93) {
#line 1828
      if ((int )r->tabBar.ltab >= 0) {
#line 1830
        w = 0;
#line 1832
        i = (int )r->tabBar.fvtab;
        {
#line 1832
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1832
          if (w < x) {
#line 1832
            if (! (i <= (int )r->tabBar.lvtab)) {
#line 1832
              goto while_break;
            }
          } else {
#line 1832
            goto while_break;
          }
#line 1833
          w += 1 + (int )(r->vts[i])->tab_width;
#line 1832
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1835
        if (w - 1 >= x) {
#line 1837
          but = i - 1;
          {
#line 1842
          if (ev->button == 1U) {
#line 1842
            goto case_1___0;
          }
#line 1848
          if (ev->button == 2U) {
#line 1848
            goto case_2___0;
          }
#line 1840
          goto switch_break___1;
          case_1___0: /* CIL Label */ 
          {
#line 1844
          rxvt_activate_page(r, (short )but);
#line 1845
          r->tabClicked = (short )but;
          }
#line 1846
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 1850
          if ((unsigned long )((void *)0) != (unsigned long )r->selection.text) {
            {
#line 1851
            rxvt_tabbar_set_title(r, (short )but, (unsigned char const   *)r->selection.text);
            }
          }
#line 1852
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
        } else
#line 1858
        if (2U == ev->button) {
#line 1858
          if ((unsigned long )((void *)0) != (unsigned long )r->selection.text) {
            {
#line 1859
            rxvt_tabbar_set_title(r, r->tabBar.atab, (unsigned char const   *)r->selection.text);
            }
          }
        }
      }
    }
  }
#line 1862
  return;
}
}
#line 1871 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_button_release(rxvt_t *r , XButtonEvent *ev ) 
{ 
  int w ;
  int droppedTab ;
  unsigned short tmp ;

  {
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1878
    if (ev->button != 1U) {
#line 1889
      goto while_break;
    } else
#line 1878
    if ((int )r->tabClicked == -1) {
#line 1889
      goto while_break;
    } else
#line 1878
    if (ev->y < 0) {
#line 1889
      goto while_break;
    } else {
      {
#line 1878
      tmp = rxvt_tabbar_rheight(r);
      }
#line 1878
      if (ev->y > (int )tmp) {
#line 1889
        goto while_break;
      }
    }
#line 1892
    droppedTab = (int )r->tabBar.fvtab;
#line 1892
    w = 0;
    {
#line 1892
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1892
      if (w < ev->x) {
#line 1892
        if (! (droppedTab <= (int )r->tabBar.lvtab)) {
#line 1892
          goto while_break___0;
        }
      } else {
#line 1892
        goto while_break___0;
      }
#line 1897
      w += 1 + (int )(r->vts[droppedTab])->tab_width;
#line 1892
      droppedTab ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1902
    rxvt_tabbar_move_tab(r, (short )(droppedTab - 1));
    }
#line 1876
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1905
  r->tabClicked = (short)-1;
#line 1906
  return;
}
}
#line 1913 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
int rxvt_tabbar_visible(rxvt_t *r ) 
{ 
  int tmp ;

  {
#line 1916
  if (0UL != r->tabBar.win) {
#line 1916
    if (r->tabBar.state) {
#line 1916
      tmp = 1;
    } else {
#line 1916
      tmp = 0;
    }
  } else {
#line 1916
    tmp = 0;
  }
#line 1916
  return (tmp);
}
}
#line 1924 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_expose(rxvt_t *r , XEvent *ev ) 
{ 
  Region region ;
  XRectangle rect ;
  int tmp ;

  {
#line 1929
  region = (Region )0L;
#line 1931
  if (ev) {
#line 1931
    if (ev->type == 12) {
      {
#line 1933
      region = XCreateRegion();
      }
      {
#line 1935
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1939
        rect.x = (short )ev->xexpose.x;
#line 1940
        rect.y = (short )ev->xexpose.y;
#line 1941
        rect.width = (unsigned short )ev->xexpose.width;
#line 1942
        rect.height = (unsigned short )ev->xexpose.height;
#line 1944
        XUnionRectWithRegion(& rect, region, region);
#line 1935
        tmp = XCheckTypedWindowEvent(r->Xdisplay, r->tabBar.win, 12, ev);
        }
#line 1935
        if (! tmp) {
#line 1935
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1948
      XClearWindow(r->Xdisplay, r->tabBar.win);
      }
    }
  } else {
    {
#line 1948
    XClearWindow(r->Xdisplay, r->tabBar.win);
    }
  }
  {
#line 1951
  rxvt_draw_tabs(r, region);
#line 1954
  rxvt_tabbar_draw_buttons(r);
  }
#line 1956
  if ((unsigned long )((Region )0) != (unsigned long )region) {
    {
#line 1957
    XDestroyRegion(region);
    }
  }
#line 1958
  return;
}
}
#line 1965 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
int rxvt_tabbar_hide(rxvt_t *r ) 
{ 
  int changed ;

  {
  {
#line 1968
  changed = 0;
#line 1971
  changed = (int )r->tabBar.state;
#line 1972
  XUnmapWindow(r->Xdisplay, r->tabBar.win);
#line 1973
  r->tabBar.state = (char)0;
  }
#line 1975
  return (changed);
}
}
#line 1983 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
int rxvt_tabbar_show(rxvt_t *r ) 
{ 
  int changed ;

  {
  {
#line 1986
  changed = 0;
#line 1989
  changed = ! r->tabBar.state;
#line 1990
  XMapWindow(r->Xdisplay, r->tabBar.win);
#line 1991
  r->tabBar.state = (char)1;
  }
#line 1993
  return (changed);
}
}
#line 2001 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_create(rxvt_t *r ) 
{ 
  XColor color ;
  XColor bgcolor ;
  XGCValues gcvalue ;
  unsigned long gcmask ;
  register int i ;
  int sx ;
  int sy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short tmp___6 ;

  {
  {
#line 2019
  init_tabbar(r);
  }
#line 2024
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
#line 2026
    r->tabBar.fg = *(r->pixColorsFocus + 0);
#line 2027
    r->tabBar.bg = *(r->pixColorsFocus + 1);
#line 2028
    r->tabBar.ifg = *(r->pixColorsFocus + 0);
#line 2029
    r->tabBar.ibg = *(r->pixColorsFocus + 1);
#line 2030
    r->tabBar.frame = *(r->pixColorsFocus + 1);
#line 2031
    r->tabBar.delimit = *(r->pixColorsFocus + 0);
  } else {
#line 2036
    if ((r->h)->rs[298]) {
      {
#line 2036
      tmp = rxvt_parse_alloc_color(r, & color, (r->h)->rs[298]);
      }
#line 2036
      if (tmp) {
#line 2041
        r->tabBar.fg = color.pixel;
      } else {
#line 2050
        r->tabBar.fg = *(r->pixColorsFocus + 2);
      }
    } else {
#line 2050
      r->tabBar.fg = *(r->pixColorsFocus + 2);
    }
#line 2060
    if ((r->h)->rs[299]) {
      {
#line 2060
      tmp___1 = rxvt_parse_alloc_color(r, & color, (r->h)->rs[299]);
      }
#line 2060
      if (tmp___1) {
#line 2065
        r->tabBar.bg = color.pixel;
      } else {
#line 2060
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2070
      color.red = (unsigned short)54016;
#line 2071
      color.green = (unsigned short)54016;
#line 2072
      color.blue = (unsigned short)56576;
#line 2073
      tmp___0 = rxvt_alloc_color(r, & color, "Active_Tab");
      }
#line 2073
      if (tmp___0) {
#line 2074
        r->tabBar.bg = color.pixel;
      } else {
#line 2076
        r->tabBar.bg = r->profile[0].bg;
      }
    }
#line 2080
    r->tabBar.frame = *(r->pixColorsFocus + 0);
#line 2083
    if ((r->h)->rs[300]) {
      {
#line 2083
      tmp___2 = rxvt_parse_alloc_color(r, & color, (r->h)->rs[300]);
      }
#line 2083
      if (tmp___2) {
#line 2088
        r->tabBar.ifg = color.pixel;
      } else {
#line 2096
        r->tabBar.ifg = *(r->pixColorsFocus + 2);
      }
    } else {
#line 2096
      r->tabBar.ifg = *(r->pixColorsFocus + 2);
    }
#line 2104
    if ((r->h)->rs[301]) {
      {
#line 2104
      tmp___4 = rxvt_parse_alloc_color(r, & color, (r->h)->rs[301]);
      }
#line 2104
      if (tmp___4) {
#line 2108
        r->tabBar.ibg = color.pixel;
      } else {
#line 2104
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 2112
      color.red = (unsigned short)41216;
#line 2113
      color.green = (unsigned short)41216;
#line 2114
      color.blue = (unsigned short)44032;
#line 2115
      tmp___3 = rxvt_alloc_color(r, & color, "Inactive_Tab_Bg");
      }
#line 2115
      if (tmp___3) {
#line 2116
        r->tabBar.ibg = color.pixel;
      } else {
#line 2118
        r->tabBar.ibg = r->profile[0].bg;
      }
    }
    {
#line 2122
    color.pixel = *(r->pixColorsFocus + 0);
#line 2123
    XQueryColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                & color);
#line 2125
    bgcolor.pixel = *(r->pixColorsFocus + 1);
#line 2126
    XQueryColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                & bgcolor);
#line 2128
    color.red = (unsigned short )(((int )bgcolor.red + 3 * (int )color.red) / 4);
#line 2129
    color.green = (unsigned short )(((int )bgcolor.green + 3 * (int )color.green) / 4);
#line 2130
    color.blue = (unsigned short )(((int )bgcolor.blue + 3 * (int )color.blue) / 4);
#line 2132
    tmp___5 = rxvt_alloc_color(r, & color, "Tab_Delimit");
    }
#line 2132
    if (tmp___5) {
#line 2133
      r->tabBar.delimit = color.pixel;
    } else {
#line 2135
      r->tabBar.delimit = r->profile[0].fg;
    }
  }
#line 2141
  sx = 0;
#line 2142
  sy = 0;
#line 2146
  if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
#line 2147
    sy += (r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth;
  }
  {
#line 2152
  tmp___6 = rxvt_tabbar_rheight(r);
#line 2152
  r->tabBar.win = XCreateSimpleWindow(r->Xdisplay, r->TermWin.parent, sx, sy, (unsigned int )r->szHint.width,
                                      (unsigned int )tmp___6, 0U, r->tabBar.ifg, r->tabBar.ibg);
  }
#line 2200
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 2200
    if ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL)) {
      {
#line 2204
      XSetWindowBackgroundPixmap(r->Xdisplay, r->tabBar.win, (Pixmap )1L);
      }
    }
  }
#line 2209
  gcvalue.foreground = r->tabBar.fg;
#line 2210
  gcvalue.line_width = 0;
#line 2211
  gcvalue.line_style = 0;
#line 2212
  gcvalue.cap_style = 1;
#line 2213
  gcvalue.join_style = 0;
#line 2214
  gcvalue.arc_mode = 0;
#line 2215
  gcvalue.fill_style = 0;
#line 2217
  gcmask = (unsigned long )(((((((1L << 2) | (1L << 4)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 22)) | (1L << 8));
#line 2223
  if ((r->h)->am_transparent) {
#line 2223
    goto _L___1;
  } else
#line 2223
  if ((r->h)->am_pixmap_trans) {
    _L___1: /* CIL Label */ 
#line 2223
    if (! ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL))) {
#line 2231
      gcvalue.background = r->tabBar.bg;
#line 2232
      gcmask |= (unsigned long )(1L << 3);
    }
  } else {
#line 2231
    gcvalue.background = r->tabBar.bg;
#line 2232
    gcmask |= (unsigned long )(1L << 3);
  }
  {
#line 2235
  r->tabBar.gc = XCreateGC(r->Xdisplay, r->tabBar.win, gcmask, & gcvalue);
#line 2240
  XDefineCursor(r->Xdisplay, r->tabBar.win, (r->h)->bar_pointer);
#line 2241
  XSelectInput(r->Xdisplay, r->tabBar.win, ((1L << 15) | (1L << 2)) | (1L << 3));
#line 2251
  XSetFont(r->Xdisplay, r->tabBar.gc, (r->TermWin.font)->fid);
#line 2267
  i = 0;
  }
  {
#line 2267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2267
    if (! (i < 4)) {
#line 2267
      goto while_break;
    }
    {
#line 2277
    img[i] = XCreatePixmapFromBitmapData(r->Xdisplay, r->tabBar.win, (char *)xbm_name[i],
                                         18U, 18U, r->tabBar.fg, r->tabBar.bg, (unsigned int )(((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth);
#line 2267
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2285
  return;
}
}
#line 2292 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_clean_exit(rxvt_t *r ) 
{ 
  register int i ;

  {
#line 2298
  r->tabBar.win = (Window )0L;
#line 2301
  if (r->tabBar.rsfg) {
    {
#line 2302
    rxvt_free((void *)(r->h)->rs[298]);
    }
  }
#line 2303
  if (r->tabBar.rsbg) {
    {
#line 2304
    rxvt_free((void *)(r->h)->rs[299]);
    }
  }
#line 2305
  if (r->tabBar.rsifg) {
    {
#line 2306
    rxvt_free((void *)(r->h)->rs[300]);
    }
  }
#line 2307
  if (r->tabBar.rsibg) {
    {
#line 2308
    rxvt_free((void *)(r->h)->rs[301]);
    }
  }
#line 2310
  if ((unsigned long )((GC )0) != (unsigned long )r->tabBar.gc) {
    {
#line 2312
    XFreeGC(r->Xdisplay, r->tabBar.gc);
#line 2313
    r->tabBar.gc = (GC )0L;
    }
  }
#line 2316
  i = 0;
  {
#line 2316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2316
    if (! (i < 4)) {
#line 2316
      goto while_break;
    }
#line 2340
    if (0UL != img[i]) {
      {
#line 2341
      XFreePixmap(r->Xdisplay, img[i]);
      }
    }
#line 2343
    img[i] = (Pixmap )0L;
#line 2316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2345
  return;
}
}
#line 2349 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
unsigned short rxvt_tabbar_height(rxvt_t *r ) 
{ 
  unsigned short tmp ;

  {
#line 2352
  if (0UL == r->tabBar.win) {
#line 2353
    return ((unsigned short)0);
  } else
#line 2352
  if (! r->tabBar.state) {
#line 2353
    return ((unsigned short)0);
  }
  {
#line 2354
  tmp = rxvt_tabbar_rheight(r);
  }
#line 2354
  return (tmp);
}
}
#line 2359 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
unsigned short rxvt_tabbar_rheight(rxvt_t *r ) 
{ 


  {
#line 2362
  return ((unsigned short )((((int )r->TermWin.fheight + 6) + 2) + (20 * (int )r->TermWin.fheight) / 100));
}
}
#line 2367 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
unsigned int rxvt_tab_width(rxvt_t *r , char const   *str ) 
{ 
  int len ;
  uint16_t maxw ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 2392
  maxw = r->TermWin.maxTabWidth;
#line 2395
  tmp = strlen(str);
#line 2395
  len = (int )tmp;
  }
#line 2396
  if (len > (int )maxw) {
#line 2397
    len = (int )maxw;
  }
  {
#line 2405
  tmp___0 = XTextWidth(r->TermWin.font, str, len);
  }
#line 2405
  return ((unsigned int )(2 * ((int )r->TermWin.fwidth - 1) + tmp___0));
}
}
#line 2411 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
int rxvt_is_tabbar_win(rxvt_t *r , Window w ) 
{ 


  {
#line 2414
  return (w == r->tabBar.win);
}
}
#line 2419 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_change_color(rxvt_t *r , int item , char const   *str ) 
{ 
  XColor xcol ;
  int changed ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 2423
  changed = 0;
  {
#line 2428
  if (item == 72) {
#line 2428
    goto case_72;
  }
#line 2447
  if (item == 73) {
#line 2447
    goto case_73;
  }
#line 2463
  if (item == 74) {
#line 2463
    goto case_74;
  }
#line 2482
  if (item == 75) {
#line 2482
    goto case_75;
  }
#line 2497
  goto switch_default;
  case_72: /* CIL Label */ 
#line 2429
  if ((r->h)->rs[298]) {
    {
#line 2429
    tmp = strcasecmp(str, (r->h)->rs[298]);
    }
#line 2429
    if (! tmp) {
#line 2431
      goto switch_break;
    }
  }
  {
#line 2433
  tmp___1 = rxvt_parse_alloc_color(r, & xcol, str);
  }
#line 2433
  if (tmp___1) {
#line 2435
    r->tabBar.fg = xcol.pixel;
#line 2439
    if (r->tabBar.rsfg) {
      {
#line 2440
      rxvt_free((void *)(r->h)->rs[298]);
      }
    }
    {
#line 2441
    tmp___0 = strdup(str);
#line 2441
    (r->h)->rs[298] = (char const   *)tmp___0;
#line 2442
    r->tabBar.rsfg = (char)1;
#line 2443
    changed = 1;
    }
  }
#line 2445
  goto switch_break;
  case_73: /* CIL Label */ 
#line 2448
  if ((r->h)->rs[299]) {
    {
#line 2448
    tmp___2 = strcasecmp(str, (r->h)->rs[299]);
    }
#line 2448
    if (! tmp___2) {
#line 2450
      goto switch_break;
    }
  }
  {
#line 2452
  tmp___4 = rxvt_parse_alloc_color(r, & xcol, str);
  }
#line 2452
  if (tmp___4) {
#line 2454
    r->tabBar.bg = xcol.pixel;
#line 2455
    if (r->tabBar.rsbg) {
      {
#line 2456
      rxvt_free((void *)(r->h)->rs[299]);
      }
    }
    {
#line 2457
    tmp___3 = strdup(str);
#line 2457
    (r->h)->rs[299] = (char const   *)tmp___3;
#line 2458
    r->tabBar.rsbg = (char)1;
#line 2459
    changed = 1;
    }
  }
#line 2461
  goto switch_break;
  case_74: /* CIL Label */ 
#line 2464
  if ((r->h)->rs[300]) {
    {
#line 2464
    tmp___5 = strcasecmp(str, (r->h)->rs[300]);
    }
#line 2464
    if (! tmp___5) {
#line 2466
      goto switch_break;
    }
  }
  {
#line 2468
  tmp___7 = rxvt_parse_alloc_color(r, & xcol, str);
  }
#line 2468
  if (tmp___7) {
#line 2470
    r->tabBar.ifg = xcol.pixel;
#line 2474
    if (r->tabBar.rsifg) {
      {
#line 2475
      rxvt_free((void *)(r->h)->rs[300]);
      }
    }
    {
#line 2476
    tmp___6 = strdup(str);
#line 2476
    (r->h)->rs[300] = (char const   *)tmp___6;
#line 2477
    r->tabBar.rsifg = (char)1;
#line 2478
    changed = 1;
    }
  }
#line 2480
  goto switch_break;
  case_75: /* CIL Label */ 
#line 2483
  if ((r->h)->rs[301]) {
    {
#line 2483
    tmp___8 = strcasecmp(str, (r->h)->rs[301]);
    }
#line 2483
    if (! tmp___8) {
#line 2484
      goto switch_break;
    }
  }
  {
#line 2486
  tmp___10 = rxvt_parse_alloc_color(r, & xcol, str);
  }
#line 2486
  if (tmp___10) {
#line 2488
    r->tabBar.ibg = xcol.pixel;
#line 2489
    if (r->tabBar.rsibg) {
      {
#line 2490
      rxvt_free((void *)(r->h)->rs[301]);
      }
    }
    {
#line 2491
    tmp___9 = strdup(str);
#line 2491
    (r->h)->rs[301] = (char const   *)tmp___9;
#line 2492
    r->tabBar.rsibg = (char)1;
#line 2493
    changed = 1;
    }
  }
#line 2495
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2498
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2501
  if (changed) {
#line 2503
    if (75 == item) {
#line 2506
      if ((r->h)->am_transparent) {
#line 2506
        goto _L;
      } else
#line 2506
      if ((r->h)->am_pixmap_trans) {
        _L: /* CIL Label */ 
#line 2506
        if (! ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL))) {
          {
#line 2529
          XSetWindowBackground(r->Xdisplay, r->tabBar.win, r->tabBar.ibg);
          }
        }
      } else {
        {
#line 2529
        XSetWindowBackground(r->Xdisplay, r->tabBar.win, r->tabBar.ibg);
        }
      }
    }
    {
#line 2538
    XClearArea(r->Xdisplay, r->tabBar.win, 0, 0, 0U, 0U, 1);
    }
  }
#line 2540
  return;
}
}
#line 2546 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void rxvt_tabbar_move_tab(rxvt_t *r , short newPage ) 
{ 
  short curPage ;
  short i ;
  term_t *temp_vt ;
  term_t *temp_vt___0 ;
  int tmp ;

  {
#line 2549
  curPage = r->tabBar.atab;
#line 2553
  if (0 == (int )r->tabBar.ltab) {
#line 2559
    return;
  } else
#line 2553
  if ((int )newPage == (int )curPage) {
#line 2559
    return;
  } else
#line 2553
  if ((int )newPage < 0) {
#line 2559
    return;
  } else
#line 2553
  if ((int )newPage > (int )r->tabBar.ltab) {
#line 2559
    return;
  }
#line 2561
  if ((int )newPage < (int )curPage) {
#line 2563
    temp_vt = r->vts[curPage];
#line 2566
    i = curPage;
    {
#line 2566
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2566
      if (! ((int )i > (int )newPage)) {
#line 2566
        goto while_break;
      }
#line 2567
      r->vts[i] = r->vts[(int )i - 1];
#line 2566
      i = (short )((int )i - 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 2569
    r->vts[newPage] = temp_vt;
#line 2572
    if ((int )r->selection.vt >= (int )newPage) {
#line 2572
      if ((int )r->selection.vt < (int )curPage) {
#line 2573
        r->selection.vt = (short )((int )r->selection.vt + 1);
      } else {
#line 2572
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2574
    if ((int )r->selection.vt == (int )curPage) {
#line 2575
      r->selection.vt = newPage;
    }
  } else {
#line 2579
    temp_vt___0 = r->vts[curPage];
#line 2582
    i = curPage;
    {
#line 2582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2582
      if (! ((int )i < (int )newPage)) {
#line 2582
        goto while_break___0;
      }
#line 2583
      r->vts[i] = r->vts[(int )i + 1];
#line 2582
      i = (short )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2585
    r->vts[newPage] = temp_vt___0;
#line 2588
    if ((int )r->selection.vt > (int )curPage) {
#line 2588
      if ((int )r->selection.vt <= (int )newPage) {
#line 2589
        r->selection.vt = (short )((int )r->selection.vt - 1);
      } else {
#line 2588
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2590
    if ((int )r->selection.vt == (int )curPage) {
#line 2591
      r->selection.vt = newPage;
    }
  }
#line 2595
  r->tabBar.atab = newPage;
#line 2597
  if ((int )r->tabBar.ptab == (int )newPage) {
#line 2597
    r->tabBar.ptab = curPage;
  }
#line 2600
  if ((int )newPage < (int )r->tabBar.fvtab) {
    {
#line 2601
    rxvt_tabbar_set_visible_tabs(r, 1);
    }
  } else
#line 2600
  if ((int )newPage > (int )r->tabBar.lvtab) {
    {
#line 2601
    rxvt_tabbar_set_visible_tabs(r, 1);
    }
  } else {
#line 2608
    if ((int )newPage < (int )curPage) {
#line 2608
      i = newPage;
    } else {
#line 2608
      i = curPage;
    }
    {
#line 2608
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2608
      if ((int )newPage > (int )curPage) {
#line 2608
        tmp = (int )newPage;
      } else {
#line 2608
        tmp = (int )curPage;
      }
#line 2608
      if (! ((int )i <= tmp)) {
#line 2608
        goto while_break___1;
      }
      {
#line 2609
      refresh_tabbar_tab(r, (int )i);
#line 2608
      i = (short )((int )i + 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2612
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 2613
    sync_tab_title(r, (int )r->tabBar.atab);
    }
  }
#line 2614
  return;
}
}
#line 2619 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/tabbar.c"
void sync_tab_title(rxvt_t *r , int page ) 
{ 
  char wintitle[507] ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 2624
  if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->winTitleFormat) {
    {
#line 2632
    rxvt_set_term_title(r, (unsigned char const   *)((unsigned char *)(r->vts[page])->tab_title));
    }
  } else {
    {
#line 2624
    tmp = strlen((char const   *)(r->vts[page])->winTitleFormat);
#line 2624
    tmp___0 = rxvt_percent_interpolate(r, page, (char const   *)(r->vts[page])->winTitleFormat,
                                       (int )tmp, wintitle, 507);
    }
#line 2624
    if (tmp___0 <= 1) {
      {
#line 2632
      rxvt_set_term_title(r, (unsigned char const   *)((unsigned char *)(r->vts[page])->tab_title));
      }
    } else {
      {
#line 2635
      rxvt_set_term_title(r, (unsigned char const   *)((unsigned char *)(wintitle)));
      }
    }
  }
#line 2636
  return;
}
}
#line 1616 "/usr/include/X11/Xlib.h"
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 309 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_scrollbar_init_xterm(rxvt_t *r ) ;
#line 310
void rxvt_scrollbar_exit_xterm(rxvt_t *r ) ;
#line 311
int rxvt_scrollbar_show_xterm(rxvt_t *r , int update , int last_top , int last_bot ,
                              int scroller_len ) ;
#line 40 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-xterm.c"
unsigned char const   x_stp_bits[2]  = {      (unsigned char const   )85,      (unsigned char const   )170};
#line 44 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-xterm.c"
void rxvt_scrollbar_init_xterm(rxvt_t *r ) 
{ 
  XGCValues gcvalue ;
  unsigned long gcmask ;

  {
  {
#line 51
  r->scrollBar.gc = (GC )0L;
#line 54
  r->scrollBar.xterm_fg = *(r->pixColorsFocus + 0);
#line 55
  r->scrollBar.xterm_bg = *(r->pixColorsFocus + 1);
#line 56
  r->scrollBar.xterm_shadow = *(r->pixColorsFocus + 261);
#line 59
  gcvalue.stipple = XCreateBitmapFromData(r->Xdisplay, r->scrollBar.win, (char const   *)((char *)(x_stp_bits)),
                                          8U, 2U);
#line 64
  gcvalue.fill_style = 3;
#line 65
  gcvalue.foreground = r->scrollBar.xterm_fg;
  }
#line 68
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 68
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 76
      gcvalue.background = r->scrollBar.xterm_bg;
    }
  } else {
#line 76
    gcvalue.background = r->scrollBar.xterm_bg;
  }
#line 77
  gcmask = (unsigned long )(((1L << 2) | (1L << 8)) | (1L << 11));
#line 80
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 80
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 88
      gcmask |= (unsigned long )(1L << 3);
    }
  } else {
#line 88
    gcmask |= (unsigned long )(1L << 3);
  }
  {
#line 90
  r->scrollBar.gc = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask, & gcvalue);
  }
#line 96
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 96
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
      {
#line 104
      XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.xterm_bg);
      }
    }
  } else {
    {
#line 104
    XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.xterm_bg);
    }
  }
#line 106
  return;
}
}
#line 109 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-xterm.c"
void rxvt_scrollbar_exit_xterm(rxvt_t *r ) 
{ 


  {
#line 113
  return;
}
}
#line 117 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-xterm.c"
int rxvt_scrollbar_show_xterm(rxvt_t *r , int update , int last_top , int last_bot ,
                              int scroller_len ) 
{ 
  int xsb ;
  int sbwidth ;
  int clear ;
  int tmp ;
  int tmp___0 ;

  {
#line 120
  xsb = 0;
#line 121
  sbwidth = (int )r->scrollBar.width - 1;
#line 122
  clear = 0;
#line 127
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 127
    if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
#line 129
      clear = 1;
    } else {
#line 137
      clear = 0;
    }
  } else {
#line 137
    clear = 0;
  }
#line 140
  if ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL)) {
#line 140
    xsb = 1;
  } else {
#line 140
    xsb = 0;
  }
#line 141
  if (last_top < (int )r->scrollBar.top) {
    {
#line 142
    XClearArea(r->Xdisplay, r->scrollBar.win, r->sb_shadow + xsb, last_top, (unsigned int )sbwidth,
               (unsigned int )((int )r->scrollBar.top - last_top), 0);
    }
  }
#line 146
  if ((int )r->scrollBar.bot < last_bot) {
    {
#line 147
    XClearArea(r->Xdisplay, r->scrollBar.win, r->sb_shadow + xsb, (int )r->scrollBar.bot,
               (unsigned int )sbwidth, (unsigned int )((last_bot - (int )r->scrollBar.bot) + clear),
               0);
    }
  }
  {
#line 152
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.xterm_fg);
#line 153
  XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, (r->sb_shadow + xsb) + 1,
                 (int )r->scrollBar.top, (unsigned int )(sbwidth - 2), (unsigned int )scroller_len);
#line 157
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.xterm_shadow);
  }
#line 158
  if (xsb) {
#line 158
    tmp = r->sb_shadow;
  } else {
#line 158
    tmp = r->sb_shadow + sbwidth;
  }
#line 158
  if (xsb) {
#line 158
    tmp___0 = r->sb_shadow;
  } else {
#line 158
    tmp___0 = r->sb_shadow + sbwidth;
  }
  {
#line 158
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, tmp___0, (int )r->scrollBar.beg,
            tmp, (int )r->scrollBar.end);
  }
#line 162
  return (1);
}
}
#line 1609 "/usr/include/X11/Xlib.h"
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 2373
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 291 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_scrollbar_init_next(rxvt_t *r ) ;
#line 292
void rxvt_scrollbar_exit_next(rxvt_t *r ) ;
#line 293
int rxvt_scrollbar_show_next(rxvt_t *r , int update , int last_top , int last_bot ,
                             int scroller_len ) ;
#line 50 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
unsigned char const   n_stp_bits[2]  = {      (unsigned char const   )85,      (unsigned char const   )170};
#line 60 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
char const   * const  SCROLLER_DIMPLE[6]  = {      (char const   */* const  */)".%###.",      (char const   */* const  */)"%#%%%%",      (char const   */* const  */)"#%%...",      (char const   */* const  */)"#%..  ", 
        (char const   */* const  */)"#%.   ",      (char const   */* const  */)".%.  ."};
#line 68 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
char const   * const  SCROLLER_ARROW_UP[13]  = 
#line 68
  {      (char const   */* const  */)"...........",      (char const   */* const  */)"...........",      (char const   */* const  */)".....%.....",      (char const   */* const  */)".....#.....", 
        (char const   */* const  */)"....%#%....",      (char const   */* const  */)"....###....",      (char const   */* const  */)"...%###%...",      (char const   */* const  */)"...#####...", 
        (char const   */* const  */)"..%#####%..",      (char const   */* const  */)"..#######..",      (char const   */* const  */)".%#######%.",      (char const   */* const  */)"...........", 
        (char const   */* const  */)"..........."};
#line 83 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
char const   * const  SCROLLER_ARROW_DOWN[13]  = 
#line 83
  {      (char const   */* const  */)"...........",      (char const   */* const  */)"...........",      (char const   */* const  */)".%#######%.",      (char const   */* const  */)"..#######..", 
        (char const   */* const  */)"..%#####%..",      (char const   */* const  */)"...#####...",      (char const   */* const  */)"...%###%...",      (char const   */* const  */)"....###....", 
        (char const   */* const  */)"....%#%....",      (char const   */* const  */)".....#.....",      (char const   */* const  */)".....%.....",      (char const   */* const  */)"...........", 
        (char const   */* const  */)"..........."};
#line 98 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
char const   * const  HI_SCROLLER_ARROW_UP[13]  = 
#line 98
  {      (char const   */* const  */)"           ",      (char const   */* const  */)"           ",      (char const   */* const  */)"     %     ",      (char const   */* const  */)"     %     ", 
        (char const   */* const  */)"    %%%    ",      (char const   */* const  */)"    %%%    ",      (char const   */* const  */)"   %%%%%   ",      (char const   */* const  */)"   %%%%%   ", 
        (char const   */* const  */)"  %%%%%%%  ",      (char const   */* const  */)"  %%%%%%%  ",      (char const   */* const  */)" %%%%%%%%% ",      (char const   */* const  */)"           ", 
        (char const   */* const  */)"           "};
#line 113 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
char const   * const  HI_SCROLLER_ARROW_DOWN[13]  = 
#line 113
  {      (char const   */* const  */)"           ",      (char const   */* const  */)"           ",      (char const   */* const  */)" %%%%%%%%% ",      (char const   */* const  */)"  %%%%%%%  ", 
        (char const   */* const  */)"  %%%%%%%  ",      (char const   */* const  */)"   %%%%%   ",      (char const   */* const  */)"   %%%%%   ",      (char const   */* const  */)"    %%%    ", 
        (char const   */* const  */)"    %%%    ",      (char const   */* const  */)"     %     ",      (char const   */* const  */)"     %     ",      (char const   */* const  */)"           ", 
        (char const   */* const  */)"           "};
#line 131 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
static Pixmap rxvt_render_pixmap(rxvt_t *r , char const   * const  *data , int width ,
                                 int height ) 
{ 
  char a ;
  int x ;
  int y ;
  Pixmap d ;
  unsigned long pointcolour ;

  {
  {
#line 139
  d = XCreatePixmap(r->Xdisplay, r->scrollBar.win, (unsigned int )width, (unsigned int )height,
                    (unsigned int )(((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth);
  }
#line 141
  if (0UL == d) {
#line 142
    return ((Pixmap )0L);
  }
#line 144
  y = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (y < height)) {
#line 144
      goto while_break;
    }
#line 145
    x = 0;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 145
      if (! (x < width)) {
#line 145
        goto while_break___0;
      }
#line 146
      a = (char )*(*(data + y) + x);
#line 146
      if ((int )a == 32) {
#line 147
        pointcolour = r->scrollBar.next_white;
      } else
#line 146
      if ((int )a == 119) {
#line 147
        pointcolour = r->scrollBar.next_white;
      } else
#line 148
      if ((int )a == 46) {
#line 149
        pointcolour = r->scrollBar.next_bg;
      } else
#line 148
      if ((int )a == 108) {
#line 149
        pointcolour = r->scrollBar.next_bg;
      } else
#line 150
      if ((int )a == 37) {
#line 151
        pointcolour = r->scrollBar.next_dark;
      } else
#line 150
      if ((int )a == 100) {
#line 151
        pointcolour = r->scrollBar.next_dark;
      } else {
#line 153
        pointcolour = r->scrollBar.next_fg;
      }
      {
#line 154
      XSetForeground(r->Xdisplay, r->scrollBar.gc, pointcolour);
#line 155
      XDrawPoint(r->Xdisplay, d, r->scrollBar.gc, x, y);
#line 145
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (d);
}
}
#line 164 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
void rxvt_scrollbar_init_next(rxvt_t *r ) 
{ 
  XGCValues gcvalue ;
  unsigned long gcmask ;
  XColor xcol ;
  Pixmap stipple ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 173
  r->scrollBar.next_stippleGC = (GC )0L;
#line 174
  r->scrollBar.next_dimple = (Pixmap )0L;
#line 177
  gcvalue.graphics_exposures = 0;
#line 181
  r->scrollBar.next_fg = *(r->pixColorsFocus + 2);
#line 182
  xcol.red = (unsigned short)44730;
#line 183
  xcol.green = (unsigned short)43690;
#line 184
  xcol.blue = (unsigned short)44730;
#line 185
  tmp = rxvt_alloc_color(r, & xcol, "light gray");
  }
#line 185
  if (! tmp) {
#line 186
    xcol.pixel = *(r->pixColorsFocus + 9);
  }
  {
#line 187
  r->scrollBar.next_bg = xcol.pixel;
#line 188
  r->scrollBar.next_white = *(r->pixColorsFocus + 17);
#line 189
  xcol.red = (unsigned short)20906;
#line 190
  xcol.green = (unsigned short)21845;
#line 191
  xcol.blue = (unsigned short)20804;
#line 192
  tmp___0 = rxvt_alloc_color(r, & xcol, "dark gray");
  }
#line 192
  if (! tmp___0) {
#line 193
    xcol.pixel = *(r->pixColorsFocus + 10);
  }
#line 194
  r->scrollBar.next_dark = xcol.pixel;
#line 198
  gcvalue.foreground = r->scrollBar.next_fg;
#line 201
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 201
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 209
      gcvalue.background = r->scrollBar.next_bg;
    }
  } else {
#line 209
    gcvalue.background = r->scrollBar.next_bg;
  }
#line 210
  gcmask = (unsigned long )(1L << 2);
#line 213
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 213
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 221
      gcmask |= (unsigned long )(1L << 3);
    }
  } else {
#line 221
    gcmask |= (unsigned long )(1L << 3);
  }
  {
#line 222
  r->scrollBar.gc = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask, & gcvalue);
#line 228
  stipple = XCreateBitmapFromData(r->Xdisplay, r->scrollBar.win, (char const   *)((char *)(n_stp_bits)),
                                  8U, 2U);
  }
#line 230
  if (0UL != stipple) {
#line 231
    gcvalue.foreground = r->scrollBar.next_dark;
#line 234
    if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 234
      if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 242
        gcvalue.background = r->scrollBar.next_bg;
      }
    } else {
#line 242
      gcvalue.background = r->scrollBar.next_bg;
    }
#line 243
    gcvalue.fill_style = 3;
#line 244
    gcvalue.stipple = stipple;
#line 245
    gcmask = (unsigned long )(((1L << 2) | (1L << 11)) | (1L << 8));
#line 248
    if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 248
      if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 256
        gcmask |= (unsigned long )(1L << 3);
      }
    } else {
#line 256
      gcmask |= (unsigned long )(1L << 3);
    }
    {
#line 258
    r->scrollBar.next_stippleGC = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask,
                                            & gcvalue);
    }
  }
  {
#line 265
  r->scrollBar.next_dimple = rxvt_render_pixmap(r, SCROLLER_DIMPLE, 6, 6);
#line 268
  r->scrollBar.next_upArrow = rxvt_render_pixmap(r, SCROLLER_ARROW_UP, 11, 13);
#line 271
  r->scrollBar.next_upArrowHi = rxvt_render_pixmap(r, HI_SCROLLER_ARROW_UP, 11, 13);
#line 274
  r->scrollBar.next_downArrow = rxvt_render_pixmap(r, SCROLLER_ARROW_DOWN, 11, 13);
#line 277
  r->scrollBar.next_downArrowHi = rxvt_render_pixmap(r, HI_SCROLLER_ARROW_DOWN, 11,
                                                     13);
  }
#line 283
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 283
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
      {
#line 291
      XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_bg);
      }
    }
  } else {
    {
#line 291
    XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_bg);
    }
  }
#line 293
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
void rxvt_scrollbar_exit_next(rxvt_t *r ) 
{ 


  {
#line 300
  if ((unsigned long )((GC )0) != (unsigned long )r->scrollBar.next_stippleGC) {
    {
#line 301
    XFreeGC(r->Xdisplay, r->scrollBar.next_stippleGC);
#line 302
    r->scrollBar.next_stippleGC = (GC )0L;
    }
  }
#line 304
  if (0UL != r->scrollBar.next_dimple) {
    {
#line 305
    XFreePixmap(r->Xdisplay, r->scrollBar.next_dimple);
#line 306
    r->scrollBar.next_dimple = (Pixmap )0L;
    }
  }
#line 308
  if (0UL != r->scrollBar.next_upArrow) {
    {
#line 309
    XFreePixmap(r->Xdisplay, r->scrollBar.next_upArrow);
#line 310
    r->scrollBar.next_upArrow = (Pixmap )0L;
    }
  }
#line 312
  if (0UL != r->scrollBar.next_upArrowHi) {
    {
#line 313
    XFreePixmap(r->Xdisplay, r->scrollBar.next_upArrowHi);
#line 314
    r->scrollBar.next_upArrowHi = (Pixmap )0L;
    }
  }
#line 316
  if (0UL != r->scrollBar.next_downArrow) {
    {
#line 317
    XFreePixmap(r->Xdisplay, r->scrollBar.next_downArrow);
#line 318
    r->scrollBar.next_downArrow = (Pixmap )0L;
    }
  }
#line 320
  if (0UL != r->scrollBar.next_downArrowHi) {
    {
#line 321
    XFreePixmap(r->Xdisplay, r->scrollBar.next_downArrowHi);
#line 322
    r->scrollBar.next_downArrowHi = (Pixmap )0L;
    }
  }
#line 324
  return;
}
}
#line 329 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
static void next_draw_bevel(rxvt_t *r , Drawable d , int x1 , int y1 , int w , int h ) 
{ 
  int x2 ;
  int y2 ;

  {
  {
#line 334
  x2 = (x1 + w) - 1;
#line 335
  y2 = (y1 + h) - 1;
#line 338
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_white);
#line 339
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x1, y1, x2, y1);
#line 340
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x1, y1, x1, y2);
#line 343
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_fg);
#line 344
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x1, y2, x2, y2);
#line 345
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x2, y1, x2, y2);
#line 348
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_dark);
#line 349
  x1 ++;
#line 349
  y1 ++;
#line 349
  x2 --;
#line 349
  y2 --;
#line 350
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x1, y2, x2, y2);
#line 351
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x2, y1, x2, y2);
  }
#line 352
  return;
}
}
#line 356 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-next.c"
int rxvt_scrollbar_show_next(rxvt_t *r , int update , int last_top , int last_bot ,
                             int scroller_len ) 
{ 
  int height ;
  Drawable s ;
  int page ;

  {
#line 361
  page = (int )r->tabBar.atab;
#line 364
  height = ((int )r->scrollBar.end + (((((17 - (1 << 1)) - 1) + 1) << 1) + 1)) + 1;
#line 366
  if ((int )(r->vts[page])->nscrolled == 0) {
#line 366
    goto _L;
  } else
#line 366
  if (! update) {
    _L: /* CIL Label */ 
    {
#line 367
    XClearArea(r->Xdisplay, r->scrollBar.win, 0, 0, 18U, (unsigned int )height, 0);
#line 370
    XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_fg);
#line 371
    XDrawRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 0, 1, 17U, (unsigned int )(height + 1));
    }
#line 377
    if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 377
      if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
        {
#line 385
        XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_stippleGC,
                       2, 0, (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )height);
        }
      }
    } else {
      {
#line 385
      XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_stippleGC, 2,
                     0, (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )height);
      }
    }
  }
#line 389
  if ((r->vts[page])->nscrolled) {
#line 390
    if (last_top < (int )r->scrollBar.top) {
#line 390
      goto _L___0;
    } else
#line 390
    if (! update) {
      _L___0: /* CIL Label */ 
#line 396
      if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 396
        if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
          {
#line 398
          XClearArea(r->Xdisplay, r->scrollBar.win, 2, 1 + last_top, (unsigned int )((17 - (1 << 1)) - 1),
                     (unsigned int )((int )r->scrollBar.top - last_top), 0);
          }
        } else {
          {
#line 413
          XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_stippleGC,
                         2, 1 + last_top, (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )((int )r->scrollBar.top - last_top));
          }
        }
      } else {
        {
#line 413
        XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_stippleGC,
                       2, 1 + last_top, (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )((int )r->scrollBar.top - last_top));
        }
      }
    }
#line 418
    if ((int )r->scrollBar.bot < last_bot) {
#line 418
      goto _L___1;
    } else
#line 418
    if (! update) {
      _L___1: /* CIL Label */ 
#line 424
      if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 424
        if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
          {
#line 426
          XClearArea(r->Xdisplay, r->scrollBar.win, 2, (int )r->scrollBar.bot + 1,
                     (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )(last_bot - (int )r->scrollBar.bot),
                     0);
          }
        } else {
          {
#line 441
          XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_stippleGC,
                         2, (int )r->scrollBar.bot + 1, (unsigned int )((17 - (1 << 1)) - 1),
                         (unsigned int )(last_bot - (int )r->scrollBar.bot));
          }
        }
      } else {
        {
#line 441
        XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.next_stippleGC,
                       2, (int )r->scrollBar.bot + 1, (unsigned int )((17 - (1 << 1)) - 1),
                       (unsigned int )(last_bot - (int )r->scrollBar.bot));
        }
      }
    }
#line 452
    if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 452
      if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
        {
#line 454
        XClearArea(r->Xdisplay, r->scrollBar.win, 2, (int )r->scrollBar.top + 1, (unsigned int )((17 - (1 << 1)) - 1),
                   (unsigned int )scroller_len, 0);
        }
      } else {
        {
#line 470
        XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_bg);
#line 471
        XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 2, (int )r->scrollBar.top + 1,
                       (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )scroller_len);
        }
      }
    } else {
      {
#line 470
      XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_bg);
#line 471
      XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 2, (int )r->scrollBar.top + 1,
                     (unsigned int )((17 - (1 << 1)) - 1), (unsigned int )scroller_len);
      }
    }
    {
#line 481
    XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_white);
#line 482
    XCopyArea(r->Xdisplay, r->scrollBar.next_dimple, r->scrollBar.win, r->scrollBar.gc,
              0, 0, 6U, 6U, 5, ((int )r->scrollBar.top + 1) + (scroller_len - 6) / 2);
#line 492
    next_draw_bevel(r, r->scrollBar.win, 2, (int )r->scrollBar.top + 1, (17 - (1 << 1)) - 1,
                    scroller_len);
#line 498
    next_draw_bevel(r, r->scrollBar.win, 2, height - ((((17 - (1 << 1)) - 1) + 1) << 1),
                    (17 - (1 << 1)) - 1, (17 - (1 << 1)) - 1);
#line 501
    next_draw_bevel(r, r->scrollBar.win, 2, height - (((17 - (1 << 1)) - 1) + 1),
                    (17 - (1 << 1)) - 1, (17 - (1 << 1)) - 1);
#line 508
    XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.next_white);
    }
#line 509
    if ((int )r->scrollBar.state == 85) {
#line 509
      s = r->scrollBar.next_upArrowHi;
    } else {
#line 509
      s = r->scrollBar.next_upArrow;
    }
    {
#line 510
    XCopyArea(r->Xdisplay, s, r->scrollBar.win, r->scrollBar.gc, 0, 0, 11U, 13U, 3,
              (height - ((((17 - (1 << 1)) - 1) + 1) << 1)) + 1);
    }
#line 518
    if ((int )r->scrollBar.state == 68) {
#line 518
      s = r->scrollBar.next_downArrowHi;
    } else {
#line 518
      s = r->scrollBar.next_downArrow;
    }
    {
#line 519
    XCopyArea(r->Xdisplay, s, r->scrollBar.win, r->scrollBar.gc, 0, 0, 11U, 13U, 3,
              (height - (((17 - (1 << 1)) - 1) + 1)) + 1);
    }
  }
#line 525
  return (1);
}
}
#line 300 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_scrollbar_init_rxvt(rxvt_t *r ) ;
#line 301
void rxvt_scrollbar_exit_rxvt(rxvt_t *r ) ;
#line 302
int rxvt_scrollbar_show_rxvt(rxvt_t *r , int update , int last_top , int last_bot ,
                             int scroller_len ) ;
#line 41 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-rxvt.c"
void rxvt_draw_button(rxvt_t *r , int x , int y , int state , int dirn ) 
{ 
  unsigned int sz ;
  unsigned int sz2 ;
  XPoint pt[3] ;
  unsigned long top ;
  unsigned long bot ;
  unsigned long tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 48
  sz = (unsigned int )r->scrollBar.width;
#line 49
  sz2 = sz / 2U;
  {
#line 51
  if (state == 1) {
#line 51
    goto case_1;
  }
#line 55
  if (state == -1) {
#line 55
    goto case_neg_1;
  }
#line 59
  goto switch_default;
  case_1: /* CIL Label */ 
#line 52
  top = r->scrollBar.rxvt_topshadow;
#line 53
  bot = r->scrollBar.rxvt_botshadow;
#line 54
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 56
  top = r->scrollBar.rxvt_botshadow;
#line 57
  bot = r->scrollBar.rxvt_topshadow;
#line 58
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 60
  bot = r->scrollBar.rxvt_fg;
#line 60
  top = bot;
#line 61
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 65
  pt[0].x = (short )x;
#line 66
  pt[1].x = (short )(((unsigned int )x + sz) - 1U);
#line 67
  pt[2].x = (short )((unsigned int )x + sz2);
#line 68
  if (dirn == 0) {
#line 69
    pt[1].y = (short )(((unsigned int )y + sz) - 1U);
#line 69
    pt[0].y = pt[1].y;
#line 70
    pt[2].y = (short )y;
  } else {
#line 72
    pt[1].y = (short )y;
#line 72
    pt[0].y = pt[1].y;
#line 73
    pt[2].y = (short )(((unsigned int )y + sz) - 1U);
  }
  {
#line 76
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.rxvt_fg);
#line 77
  XFillPolygon(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, pt, 3, 2, 0);
  }
#line 81
  if (dirn == 0) {
#line 81
    tmp = bot;
  } else {
#line 81
    tmp = top;
  }
  {
#line 81
  XSetForeground(r->Xdisplay, r->scrollBar.gc, tmp);
#line 82
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, (int )pt[0].x, (int )pt[0].y,
            (int )pt[1].x, (int )pt[1].y);
#line 86
  pt[1].x = (short )(((unsigned int )x + sz2) - 1U);
  }
#line 87
  if (dirn == 0) {
#line 87
    tmp___0 = 0U;
  } else {
#line 87
    tmp___0 = sz - 1U;
  }
  {
#line 87
  pt[1].y = (short )((unsigned int )y + tmp___0);
#line 88
  XSetForeground(r->Xdisplay, r->scrollBar.gc, top);
#line 89
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, (int )pt[0].x, (int )pt[0].y,
            (int )pt[1].x, (int )pt[1].y);
#line 107
  pt[1].x = (short )(((unsigned int )x + sz) - 1U);
  }
#line 109
  if (dirn == 0) {
#line 109
    tmp___1 = sz - 1U;
  } else {
#line 109
    tmp___1 = 0U;
  }
#line 109
  pt[1].y = (short )((unsigned int )y + tmp___1);
#line 110
  if (dirn == 0) {
#line 110
    tmp___2 = 0U;
  } else {
#line 110
    tmp___2 = sz - 1U;
  }
  {
#line 110
  pt[2].y = (short )((unsigned int )y + tmp___2);
#line 111
  XSetForeground(r->Xdisplay, r->scrollBar.gc, bot);
#line 112
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, (int )pt[2].x, (int )pt[2].y,
            (int )pt[1].x, (int )pt[1].y);
  }
#line 128
  return;
}
}
#line 133 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-rxvt.c"
void rxvt_scrollbar_init_rxvt(rxvt_t *r ) 
{ 
  XGCValues gcvalue ;
  unsigned long gcmask ;

  {
#line 141
  r->scrollBar.rxvt_fg = *(r->pixColorsFocus + 268);
#line 142
  r->scrollBar.rxvt_bg = *(r->pixColorsFocus + 271);
#line 143
  r->scrollBar.rxvt_topshadow = *(r->pixColorsFocus + 270);
#line 144
  r->scrollBar.rxvt_botshadow = *(r->pixColorsFocus + 271);
#line 147
  gcvalue.foreground = r->scrollBar.rxvt_fg;
#line 150
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 150
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 158
      gcvalue.background = r->scrollBar.rxvt_bg;
    }
  } else {
#line 158
    gcvalue.background = r->scrollBar.rxvt_bg;
  }
#line 159
  gcmask = (unsigned long )(1L << 2);
#line 162
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 162
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
#line 170
      gcmask |= (unsigned long )(1L << 3);
    }
  } else {
#line 170
    gcmask |= (unsigned long )(1L << 3);
  }
  {
#line 171
  r->scrollBar.gc = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask, & gcvalue);
  }
#line 177
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 177
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
      {
#line 185
      XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.rxvt_bg);
      }
    }
  } else {
    {
#line 185
    XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.rxvt_bg);
    }
  }
#line 187
  return;
}
}
#line 191 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-rxvt.c"
void rxvt_scrollbar_exit_rxvt(rxvt_t *r ) 
{ 


  {
#line 195
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-rxvt.c"
int rxvt_scrollbar_show_rxvt(rxvt_t *r , int update , int last_top , int last_bot ,
                             int scroller_len ) 
{ 
  int sbshadow ;
  int sbwidth ;
  int tmp ;
  int tmp___0 ;

  {
#line 202
  sbshadow = r->sb_shadow;
#line 203
  sbwidth = (int )r->scrollBar.width;
#line 206
  if (last_top < (int )r->scrollBar.top) {
    {
#line 207
    XClearArea(r->Xdisplay, r->scrollBar.win, sbshadow, last_top, (unsigned int )sbwidth,
               (unsigned int )((int )r->scrollBar.top - last_top), 0);
    }
  }
#line 212
  if ((int )r->scrollBar.bot < last_bot) {
    {
#line 213
    XClearArea(r->Xdisplay, r->scrollBar.win, sbshadow, (int )r->scrollBar.bot, (unsigned int )sbwidth,
               (unsigned int )(last_bot - (int )r->scrollBar.bot), 0);
    }
  }
#line 221
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 221
    if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
      {
#line 225
      XClearArea(r->Xdisplay, r->scrollBar.win, sbshadow, (int )r->scrollBar.top,
                 (unsigned int )sbwidth, (unsigned int )scroller_len, 0);
      }
    } else {
      {
#line 242
      XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.rxvt_fg);
#line 243
      XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, sbshadow, (int )r->scrollBar.top,
                     (unsigned int )sbwidth, (unsigned int )scroller_len);
      }
    }
  } else {
    {
#line 242
    XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.rxvt_fg);
#line 243
    XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, sbshadow, (int )r->scrollBar.top,
                   (unsigned int )sbwidth, (unsigned int )scroller_len);
    }
  }
#line 247
  if (sbshadow) {
    {
#line 249
    rxvt_draw_shadow(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, r->scrollBar.rxvt_botshadow,
                     r->scrollBar.rxvt_topshadow, 0, 0, sbwidth + 2 * sbshadow, ((int )r->scrollBar.end + (sbwidth + 1)) + sbshadow);
    }
  }
  {
#line 256
  rxvt_draw_shadow(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, r->scrollBar.rxvt_topshadow,
                   r->scrollBar.rxvt_botshadow, sbshadow, (int )r->scrollBar.top,
                   sbwidth, scroller_len);
  }
#line 262
  if ((int )r->scrollBar.state == 85) {
#line 262
    tmp = -1;
  } else {
#line 262
    tmp = 1;
  }
  {
#line 262
  rxvt_draw_button(r, sbshadow, sbshadow, tmp, 0);
  }
#line 264
  if ((int )r->scrollBar.state == 68) {
#line 264
    tmp___0 = -1;
  } else {
#line 264
    tmp___0 = 1;
  }
  {
#line 264
  rxvt_draw_button(r, sbshadow, (int )r->scrollBar.end + 1, tmp___0, 1);
  }
#line 266
  return (1);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 55 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) updwtmp)(char const   *__wtmp_file ,
                                                                               struct utmp  const  *__utmp ) ;
#line 65
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setutent)(void) ;
#line 68
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endutent)(void) ;
#line 72
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) getutid)(struct utmp  const  *__id ) ;
#line 79
extern  __attribute__((__nothrow__)) struct utmp *( __attribute__((__leaf__)) pututline)(struct utmp  const  *__utmp_ptr ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 118 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_makeutent(rxvt_t *r , int page , char const   *pty , char const   *hostname ) ;
#line 50 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/logging.c"
int rxvt_write_bsd_utmp(int utmp_pos , struct utmp *wu ) ;
#line 59
void rxvt_update_lastlog(char const   *fname , char const   *pty , char const   *host ) ;
#line 79 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/logging.c"
void rxvt_makeutent(rxvt_t *r , int page , char const   *pty , char const   *hostname ) 
{ 
  struct utmp *ut ;
  int i ;
  char ut_id[5] ;
  struct passwd *pwent ;
  __uid_t tmp ;
  struct passwd *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  time_t tmp___7 ;
  char const   *tmp___8 ;
  time_t tmp___9 ;

  {
  {
#line 87
  ut = & (r->vts[page])->ut;
#line 96
  tmp = getuid();
#line 96
  tmp___0 = getpwuid(tmp);
#line 96
  pwent = tmp___0;
#line 98
  tmp___1 = strncmp(pty, "/dev/", (size_t )5);
  }
#line 98
  if (! tmp___1) {
#line 99
    pty += 5;
  }
  {
#line 101
  tmp___5 = strncmp(pty, "pty", (size_t )3);
  }
#line 101
  if (tmp___5) {
    {
#line 101
    tmp___6 = strncmp(pty, "tty", (size_t )3);
    }
#line 101
    if (tmp___6) {
      {
#line 105
      tmp___4 = sscanf((char const   */* __restrict  */)pty, (char const   */* __restrict  */)"pts/%d",
                       & i);
      }
#line 105
      if (tmp___4 == 1) {
        {
#line 106
        sprintf((char */* __restrict  */)(ut_id), (char const   */* __restrict  */)"vt%02x",
                i & 255);
        }
      } else {
        {
#line 108
        tmp___2 = strncmp(pty, "pty", (size_t )3);
        }
#line 108
        if (tmp___2) {
          {
#line 108
          tmp___3 = strncmp(pty, "tty", (size_t )3);
          }
#line 108
          if (tmp___3) {
            {
#line 109
            rxvt_msg((uint32_t )1, (uint32_t )32, "can\'t parse tty name \"%s\"",
                     pty);
            }
#line 110
            return;
          }
        }
      }
    } else {
      {
#line 102
      strncpy((char */* __restrict  */)(ut_id), (char const   */* __restrict  */)(pty + 3),
              sizeof(ut_id));
      }
    }
  } else {
    {
#line 102
    strncpy((char */* __restrict  */)(ut_id), (char const   */* __restrict  */)(pty + 3),
            sizeof(ut_id));
    }
  }
  {
#line 114
  memset((void *)ut, 0, sizeof(struct utmp ));
#line 116
  setutent();
#line 117
  strncpy((char */* __restrict  */)(ut->ut_id), (char const   */* __restrict  */)((char const   *)(ut_id)),
          sizeof(ut->ut_id));
#line 118
  ut->ut_type = (short)8;
#line 119
  getutid((struct utmp  const  *)ut);
#line 120
  strncpy((char */* __restrict  */)((r->vts[page])->ut_id), (char const   */* __restrict  */)((char const   *)(ut_id)),
          sizeof((r->vts[page])->ut_id));
#line 134
  strncpy((char */* __restrict  */)(ut->ut_line), (char const   */* __restrict  */)pty,
          sizeof(ut->ut_line));
#line 135
  tmp___7 = time((time_t *)((void *)0));
#line 135
  ut->ut_tv.tv_sec = (int32_t )tmp___7;
  }
#line 137
  if (pwent) {
#line 137
    if (pwent->pw_name) {
#line 137
      tmp___8 = (char const   *)pwent->pw_name;
    } else {
#line 137
      tmp___8 = "?";
    }
  } else {
#line 137
    tmp___8 = "?";
  }
  {
#line 137
  strncpy((char */* __restrict  */)(ut->ut_user), (char const   */* __restrict  */)tmp___8,
          sizeof(ut->ut_user));
#line 139
  strncpy((char */* __restrict  */)(ut->ut_id), (char const   */* __restrict  */)((char const   *)(ut_id)),
          sizeof(ut->ut_id));
#line 140
  tmp___9 = time((time_t *)((void *)0));
#line 140
  ut->ut_tv.tv_sec = (int32_t )tmp___9;
#line 141
  ut->ut_pid = (r->vts[page])->cmd_pid;
#line 143
  strncpy((char */* __restrict  */)(ut->ut_host), (char const   */* __restrict  */)hostname,
          sizeof(ut->ut_host));
#line 145
  ut->ut_type = (short)7;
#line 146
  pututline((struct utmp  const  *)ut);
#line 147
  endutent();
#line 148
  (r->vts[page])->utmp_pos = 0;
  }
#line 212
  if ((unsigned long )r->Options[(1UL << 3) & 3UL] & ((1UL << 3) & 0xfffffffffffffffcUL)) {
    {
#line 217
    updwtmp("/var/log/wtmp", (struct utmp  const  *)ut);
    }
  }
#line 235
  if ((unsigned long )r->Options[(1UL << 3) & 3UL] & ((1UL << 3) & 0xfffffffffffffffcUL)) {
    {
#line 236
    rxvt_update_lastlog("/var/log/lastlog", pty, hostname);
    }
  }
#line 239
  return;
}
}
#line 246 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/logging.c"
void rxvt_cleanutent(rxvt_t *r , int page ) 
{ 
  struct utmp *ut ;
  struct utmp *tmput ;
  struct utmp *tmp ;
  time_t tmp___0 ;

  {
  {
#line 254
  ut = & (r->vts[page])->ut;
#line 262
  memset((void *)ut, 0, sizeof(struct utmp ));
#line 263
  setutent();
#line 264
  strncpy((char */* __restrict  */)(ut->ut_id), (char const   */* __restrict  */)((char const   *)((r->vts[page])->ut_id)),
          sizeof(ut->ut_id));
#line 265
  ut->ut_type = (short)7;
#line 267
  tmp = getutid((struct utmp  const  *)ut);
#line 267
  tmput = tmp;
  }
#line 269
  if (tmput) {
#line 270
    ut = tmput;
  }
  {
#line 272
  ut->ut_type = (short)8;
#line 279
  tmp___0 = time((time_t *)((void *)0));
#line 279
  ut->ut_tv.tv_sec = (int32_t )tmp___0;
  }
#line 302
  if ((unsigned long )r->Options[(1UL << 3) & 3UL] & ((1UL << 3) & 0xfffffffffffffffcUL)) {
    {
#line 307
    updwtmp("/var/log/wtmp", (struct utmp  const  *)ut);
    }
  }
#line 327
  if (ut->ut_pid == (r->vts[page])->cmd_pid) {
    {
#line 328
    pututline((struct utmp  const  *)ut);
    }
  }
  {
#line 329
  endutent();
  }
#line 342
  return;
}
}
#line 351 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/logging.c"
int rxvt_write_bsd_utmp(int utmp_pos , struct utmp *wu ) 
{ 
  int fd ;
  __off_t tmp ;

  {
#line 356
  if (utmp_pos <= 0) {
#line 357
    return (0);
  } else {
    {
#line 356
    fd = open("/var/run/utmp", 1);
    }
#line 356
    if (fd == -1) {
#line 357
      return (0);
    }
  }
  {
#line 359
  tmp = lseek(fd, (off_t )((unsigned long )utmp_pos * sizeof(struct utmp )), 0);
  }
#line 359
  if (tmp != -1L) {
    {
#line 360
    write(fd, (void const   *)wu, sizeof(struct utmp ));
    }
  }
  {
#line 361
  close(fd);
  }
#line 362
  return (1);
}
}
#line 418 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/logging.c"
void rxvt_update_lastlog(char const   *fname , char const   *pty , char const   *host ) 
{ 
  int fd ;
  struct lastlog ll ;
  struct passwd *pwent ;
  __uid_t tmp ;
  time_t tmp___0 ;
  __off_t tmp___1 ;

  {
  {
#line 443
  tmp = getuid();
#line 443
  pwent = getpwuid(tmp);
  }
#line 444
  if (! pwent) {
    {
#line 445
    rxvt_msg((uint32_t )1, (uint32_t )32, "no entry in password file");
    }
#line 446
    return;
  }
  {
#line 448
  memset((void *)(& ll), 0, sizeof(ll));
#line 449
  tmp___0 = time((time_t *)((void *)0));
#line 449
  ll.ll_time = (int32_t )tmp___0;
#line 450
  strncpy((char */* __restrict  */)(ll.ll_line), (char const   */* __restrict  */)pty,
          sizeof(ll.ll_line));
#line 451
  strncpy((char */* __restrict  */)(ll.ll_host), (char const   */* __restrict  */)host,
          sizeof(ll.ll_host));
#line 463
  fd = open(fname, 2);
  }
#line 463
  if (fd != -1) {
    {
#line 464
    tmp___1 = lseek(fd, (off_t )((unsigned long )((long )pwent->pw_uid) * sizeof(ll)),
                    0);
    }
#line 464
    if (tmp___1 != -1L) {
      {
#line 466
      write(fd, (void const   *)(& ll), sizeof(ll));
      }
    }
    {
#line 467
    close(fd);
    }
  }
#line 471
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 403 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_usage(int type ) ;
#line 405
void rxvt_get_options(rxvt_t *r , int argc , char const   * const  *argv ) ;
#line 406
void rxvt_extract_resources(rxvt_t *r , Display *display , char const   *name ) ;
#line 36 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
void rxvt_get_xdefaults(rxvt_t *r , FILE *stream , char const   *name , macro_priority_t priority ) ;
#line 42 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static char const   *emptyResource  =    "";
#line 44 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static char const   * const  xnames[3]  = {      (char const   */* const  */)".mrxvtrc",      (char const   */* const  */)".Xdefaults",      (char const   */* const  */)".Xresources"};
#line 90 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static struct __anonstruct_optList_376  const  optList[152]  = 
#line 90
  {      {(uint32_t const   )0, (int const   )334, "tabTitle", "tt", "string", "title name for tab",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )344, "saveLines", "sl", "number", "number of scrolled lines to save for tab",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )339, "command", "e", "string", "command to execute for a tab",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )349, "foreground", "fg", "color", "foreground color for a tab",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )354, "background", "bg", "color", "background color for a tab",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )359, "workingDirectory", "wd", "dir", "Working directory to open new tabs in",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )364, "holdExit", "hold", "number", "Keep tab open after child exits, based on childs exit status",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )369, "holdExitText", "het", "string", "text to show while holding the terminal",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )374, "holdExitTitle", "heT", "string", "Tab title of exited tabs",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )379, "titleFormat", "tf", "string", "Displayed tab title format",
      (char const   )1}, 
        {(uint32_t const   )0, (int const   )384, "winTitleFormat", "wtf", "string",
      "format of window title (when syncing to tab title)", (char const   )1}, 
        {(uint32_t const   )0, (int const   )288, "maxTabWidth", "mtw", "number", "maximum (char) title width of all tabs",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )289, "minVisibleTabs", "mvt", "number",
      "minimum # of tabs to keep visible (requires xftpfn)", (char const   )0}, 
        {(uint32_t const   )((1UL << 25) | 1UL), (int const   )-1, "highlightTabOnBell",
      "htb", (char const   *)((void *)0), "highlighting inactive tabs only when bell sounds",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 10) | 1UL), (int const   )-1, "syncTabTitle", "stt",
      (char const   *)((void *)0), "synchronizing terminal title with tab title",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 12) | 1UL), (int const   )-1, "hideTabbar", "ht",
      (char const   *)((void *)0), "hiding tabbar on initialization", (char const   )0}, 
        {(uint32_t const   )((1UL << 28) | 1UL),
      (int const   )-1, "autohideTabbar", "aht", (char const   *)((void *)0), "auto hide/show the tabbar depending on number of open tabs",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 13) | 1UL), (int const   )-1, "bottomTabbar", "bt",
      (char const   *)((void *)0), "showing tabbar at bottom", (char const   )0}, 
        {(uint32_t const   )((1UL << 17) | 1UL), (int const   )-1, "hideButtons", "hb",
      (char const   *)((void *)0), "hide buttons on tabbar", (char const   )0}, 
        {(uint32_t const   )((1UL << 11) | 1UL), (int const   )-1, "syncTabIcon", "sti",
      (char const   *)((void *)0), "synchronizing icon name with tab title", (char const   )0}, 
        {(uint32_t const   )((1UL << 18) | 1UL),
      (int const   )-1, "veryBoldFont", "vbf", (char const   *)((void *)0), "showing color text with bold font",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 19) | 1UL), (int const   )-1, "boldColors", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )((1UL << 20) | 1UL),
      (int const   )-1, "veryBright", (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )3, (char const   *)((void *)0), "into",
      "WinID", "Parent window id", (char const   )0}, 
        {(uint32_t const   )0, (int const   )0, (char const   *)((void *)0), "d", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )0, (char const   *)((void *)0), "display",
      "string", "X server to contact", (char const   )0}, 
        {(uint32_t const   )0, (int const   )4, "termName", "tn", "string", "the TERM environment variable",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )287, "title", "title", "string", "title name for window",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )6, (char const   *)((void *)0), "g", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )6, "geometry", "geometry", "geometry", "size (in characters) and position",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 2), (int const   )-1, "interceptConsole", "C", (char const   *)((void *)0),
      "intercept console messages", (char const   )0}, 
        {(uint32_t const   )(1UL << 4), (int const   )-1, "startIconic", "iconic", (char const   *)((void *)0),
      "start iconic", (char const   )0}, 
        {(uint32_t const   )((1UL << 29) | 1UL), (int const   )-1, "maximized", "m",
      (char const   *)((void *)0), "Start maximized", (char const   )0}, 
        {(uint32_t const   )((1UL << 30) | 1UL), (int const   )-1, "fullscreen", "fs",
      (char const   *)((void *)0), "Start fullscreen", (char const   )0}, 
        {(uint32_t const   )(1UL << 8), (int const   )-1, "reverseVideo", "rv", (char const   *)((void *)0),
      "reverse video", (char const   )0}, 
        {(uint32_t const   )(1UL << 3), (int const   )-1, "loginShell", "ls", (char const   *)((void *)0),
      "login shell", (char const   )0}, 
        {(uint32_t const   )0, (int const   )304, "refreshLimit", (char const   *)((void *)0),
      "nchars", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )303, "skipPages", (char const   *)((void *)0),
      "%d", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )276, "tintColor", "tint", "color", "tint color",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )305, "shading", "shade", "%", "shade background by %x when tinting",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )305, "backgroundFade", "bgfade", "%", "fade background image or transparent background by %x (obsolete)",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )307, "bgRefreshInterval", (char const   *)((void *)0),
      "ms", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )302, "fading", "fade", "%", "make colors x% darker when losing focus",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 10), (int const   )-1, "scrollBar", "sb", (char const   *)((void *)0),
      "scrollbar", (char const   )0}, 
        {(uint32_t const   )(1UL << 11), (int const   )-1, "scrollbarRight", "sr", (char const   *)((void *)0),
      "scrollbar right", (char const   )0}, 
        {(uint32_t const   )(1UL << 12), (int const   )-1, "scrollbarFloating", "st",
      (char const   *)((void *)0), "scrollbar without a trough", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )322, "scrollbarThickness", "sbt", "number", "scrollbar thickness/width in pixels",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )297, "scrollbarStyle", "ss", "mode", "scrollbar style = plain|xterm|rxvt|next|sgi",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )296, "scrollbarAlign", "sa", "mode", "scrollbar alignment = top|bottom",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 14), (int const   )-1, "scrollTtyOutputInhibit",
      "si", (char const   *)((void *)0), "scroll-on-tty-output inhibit", (char const   )0}, 
        {(uint32_t const   )(1UL << 15),
      (int const   )-1, "scrollTtyKeypress", "sk", (char const   *)((void *)0), "scroll-on-keypress",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )318, "opacity", "o", "%", "transluscent window (true transparent) opaque degree",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )319, "opacityDegree", "od", "%", "transluscent window opaque degree interval",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 16), (int const   )-1, "transparent", "tr", (char const   *)((void *)0),
      "transparent", (char const   )0}, 
        {(uint32_t const   )(1UL << 17), (int const   )-1, "transparentForce", "trf",
      (char const   *)((void *)0), "forcefully transparent", (char const   )0}, 
        {(uint32_t const   )(1UL << 23), (int const   )-1, "transparentScrollbar", "trs",
      (char const   *)((void *)0), "transparent scrollbar", (char const   )0}, 
        {(uint32_t const   )(1UL << 26), (int const   )-1, "transparentTabbar", "trt",
      (char const   *)((void *)0), "transparent tabbar", (char const   )0}, 
        {(uint32_t const   )(1UL << 9), (int const   )-1, "utmpInhibit", "ut", (char const   *)((void *)0),
      "utmp inhibit - do not log to utmp", (char const   )0}, 
        {(uint32_t const   )0, (int const   )327, (char const   *)((void *)0), "cf",
      "file", "Configuration file instead of ~/.mrxvtrc", (char const   )0}, 
        {(uint32_t const   )(1UL << 5), (int const   )-1, "visualBell", "vb", (char const   *)((void *)0),
      "visual bell", (char const   )0}, 
        {(uint32_t const   )(1UL << 6), (int const   )-1, "currentTabVBell", "ctvb",
      (char const   *)((void *)0), "visual bell only for active tab in focused window",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )310, "vBellDuration", (char const   *)((void *)0),
      "Duration (ms) of the visual bell", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )309, "bellCommand", "blc", "string", "command to execute instead of beeping",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )311, "monitorCommand", "mcmd", "string",
      "command to execute if activity/inactivity was detected while monitoring", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )312, "monitorTimeout", "mto", "number", "timeout in milliseconds for tab-monitoring",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 7), (int const   )-1, "mapAlert", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )(1UL << 13),
      (int const   )-1, "meta8", "m8", (char const   *)((void *)0), "meta8", (char const   )0}, 
        {(uint32_t const   )(1UL << 20),
      (int const   )-1, "mouseWheelScrollPage", "mp", (char const   *)((void *)0),
      "mouse wheel scrolling a page", (char const   )0}, 
        {(uint32_t const   )(1UL << 19), (int const   )-1, "tripleclickwords", "tcw",
      (char const   *)((void *)0), "triple click word selection", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )269, "ufBackground", "ufbg", "color", "unfocused background color",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )298, "tabForeground", "tabfg", "color",
      "tabbar active tab foreground color", (char const   )0}, 
        {(uint32_t const   )0, (int const   )299, "tabBackground", "tabbg", "color",
      "tabbar and active tab background color", (char const   )0}, 
        {(uint32_t const   )0, (int const   )300, "itabForeground", "itabfg", "color",
      "tabbar inactive tab foreground color", (char const   )0}, 
        {(uint32_t const   )0, (int const   )301, "itabBackground", "itabbg", "color",
      "tabbar inactive tab background color", (char const   )0}, 
        {(uint32_t const   )0, (int const   )9, "color0", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )10, "color1", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )11, "color2", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )12, "color3", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )13, "color4", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )14, "color5", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )15, "color6", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )16, "color7", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )17, "color8", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )18, "color9", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )19, "color10", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )20, "color11", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )21, "color12", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )22, "color13", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )23, "color14", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )24, "color15", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )270, "colorBD", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )271, "colorUL", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )272, "colorRV", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )274, "scrollColor", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )275, "troughColor", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )273, "highlightColor", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )265, "cursorColor", "cr", "color", "cursor color",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )266, "cursorColor2", (char const   *)((void *)0),
      "color", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )267, "pointerColor", "pr", "color", "pointer color",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )268, "borderColor", "bd", "color", "border color",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )290, "boldFont", "fb", "fontname", "bold text font",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )291, "boldFont1", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )292, "boldFont2", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )293, "boldFont3", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )294, "boldFont4", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )295, "boldFont5", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )280, "font", "fn", "fontname", "normal text font",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )281, "font1", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )282, "font2", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )283, "font3", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )284, "font4", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )285, "font5", (char const   *)((void *)0),
      "fontname", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )((1UL << 3) | 1UL), (int const   )-1, "cmdAllTabs", "at",
      (char const   *)((void *)0), "running -e command for all tabs", (char const   )0}, 
        {(uint32_t const   )((1UL << 2) | 1UL),
      (int const   )-1, "protectSecondary", "ps", (char const   *)((void *)0), "protecting tab that uses the secondary screen from being closed",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )286, "clientName", "name", "string", "client instance, icon, and title strings",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )287, (char const   *)((void *)0), "T", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )5, "iconName", "in", "string", "icon name for window",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 14) | 1UL), (int const   )-1, "borderLess", "bl",
      (char const   *)((void *)0), "borderless window", (char const   )0}, 
        {(uint32_t const   )((1UL << 15) | 1UL), (int const   )-1, "overrideRedirect",
      "or", (char const   *)((void *)0), "override_redirect flag", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )313, "desktop", "desktop", "number", "desktop to place the program",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 16) | 1UL), (int const   )-1, "broadcast", "bcst",
      (char const   *)((void *)0), "broadcast input to all terminals", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )320, "externalBorder", "w", "number", "external border in pixels",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )320, (char const   *)((void *)0), "bw",
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )320, (char const   *)((void *)0), "borderwidth", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )321, "internalBorder", "b", "number", "internal border in pixels",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 27) | 1UL), (int const   )-1, "smartResize", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )((1UL << 26) | 1UL),
      (int const   )-1, "smoothResize", (char const   *)((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )323, "lineSpace", "lsp", "number", "number of extra pixels between rows",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 21), (int const   )-1, "pointerBlank", "pb", (char const   *)((void *)0),
      "blank pointer", (char const   )0}, 
        {(uint32_t const   )0, (int const   )330, "pointerBlankDelay", (char const   *)((void *)0),
      "number", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )(1UL << 22), (int const   )-1, "cursorBlink", "bc", (char const   *)((void *)0),
      "blinking cursor", (char const   )0}, 
        {(uint32_t const   )0, (int const   )329, "cursorBlinkInterval", "bci", "number",
      "cursor blinking interval (ms)", (char const   )0}, 
        {(uint32_t const   )0, (int const   )314, "backspaceKey", (char const   *)((void *)0),
      "string", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )315, "deleteKey", (char const   *)((void *)0),
      "string", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )316, "selectStyle", (char const   *)((void *)0),
      "select style mode = old|oldword", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )317, "printPipe", (char const   *)((void *)0), "string", (char const   *)((void *)0),
      (char const   )0}, 
        {(uint32_t const   )((1UL << 21) | 1UL), (int const   )-1, "noSysConfig", "nsc",
      (char const   *)((void *)0), "reading /etc/mrxvt/mrxvtrc.", (char const   )0}, 
        {(uint32_t const   )((1UL << 22) | 1UL),
      (int const   )-1, "disableMacros", "dm", (char const   *)((void *)0), "all keyboard shortcuts (macros)",
      (char const   )0}, 
        {(uint32_t const   )((1UL << 24) | 1UL), (int const   )-1, "linuxHomeEndKey",
      "lk", (char const   *)((void *)0), "enable Linux console Home/End keys", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )326, "modifier", "mod", "modifier", "meta modifier = alt|meta|hyper|super|mod1|...|mod5",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )-1, (char const   *)((void *)0), "xrm",
      "string", "X resource", (char const   )0}, 
        {(uint32_t const   )0, (int const   )324, "cutChars", (char const   *)((void *)0),
      "string", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )325, "acsChars", (char const   *)((void *)0),
      "string", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0, (int const   )328, "answerbackString", (char const   *)((void *)0),
      "string", (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )((1UL << 23) | 1UL), (int const   )-1, "sessionMgt", "sm",
      (char const   *)((void *)0), "enabling X session management", (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )331, "smClientID", "sid", "string", "client id of mrxvt for X session management",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )333, "initTermNumber", "tnum", "number",
      "Initial number of tabs/terminals", (char const   )0}, 
        {(uint32_t const   )0, (int const   )332, "initProfileList", "ip", "profile list",
      "List of profiles to load on startup", (char const   )0}, 
        {(uint32_t const   )0, (int const   )1, "dbgMasks", "dmask", "string", "List of debug masks separated by coma",
      (char const   )0}, 
        {(uint32_t const   )0, (int const   )2, "dbgLevel", "dlevel", "string", "Name of number of the debug level",
      (char const   )0}, 
        {(uint32_t const   )(1UL << 29), (int const   )-1, "useFifo", (char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0), (char const   )0}, 
        {(uint32_t const   )0,
      (int const   )-1, (char const   *)((void *)0), "e", "command arg ...", "command to execute",
      (char const   )0}};
#line 570 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static uint32_t pSetOpts[4]  = {      0U,      0U,      0U,      0U};
#line 579 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static char const   releasestring[14]  = 
#line 579
  {      (char const   )'M',      (char const   )'r',      (char const   )'x',      (char const   )'v', 
        (char const   )'t',      (char const   )' ',      (char const   )'v',      (char const   )'0', 
        (char const   )'.',      (char const   )'5',      (char const   )'.',      (char const   )'4', 
        (char const   )'\n',      (char const   )'\000'};
#line 580 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static char const   optionsstring[181]  = 
#line 580
  {      (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )':', 
        (char const   )' ',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'p',      (char const   )'a', 
        (char const   )'r',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )',',      (char const   )'f',      (char const   )'a',      (char const   )'d', 
        (char const   )'e',      (char const   )',',      (char const   )'t',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )',',      (char const   )'u', 
        (char const   )'t',      (char const   )'m',      (char const   )'p',      (char const   )',', 
        (char const   )'s',      (char const   )'c',      (char const   )'r',      (char const   )'o', 
        (char const   )'l',      (char const   )'l',      (char const   )'b',      (char const   )'a', 
        (char const   )'r',      (char const   )'s',      (char const   )'=',      (char const   )'r', 
        (char const   )'x',      (char const   )'v',      (char const   )'t',      (char const   )'+', 
        (char const   )'N',      (char const   )'e',      (char const   )'X',      (char const   )'T', 
        (char const   )'+',      (char const   )'x',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'m',      (char const   )'+',      (char const   )'s', 
        (char const   )'g',      (char const   )'i',      (char const   )'+',      (char const   )'p', 
        (char const   )'l',      (char const   )'a',      (char const   )'i',      (char const   )'n', 
        (char const   )',',      (char const   )'f',      (char const   )'r',      (char const   )'i', 
        (char const   )'l',      (char const   )'l',      (char const   )'s',      (char const   )',', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'e', 
        (char const   )'s',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )',',      (char const   )'s',      (char const   )'e', 
        (char const   )'l',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )'c',      (char const   )'r',      (char const   )'o',      (char const   )'l', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )',',      (char const   )'2',      (char const   )'5',      (char const   )'6', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'o', 
        (char const   )'u',      (char const   )'r',      (char const   )',',      (char const   )'c', 
        (char const   )'u',      (char const   )'r',      (char const   )'s',      (char const   )'o', 
        (char const   )'r',      (char const   )'B',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )',',      (char const   )'p', 
        (char const   )'o',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'B',      (char const   )'l', 
        (char const   )'a',      (char const   )'n',      (char const   )'k',      (char const   )',', 
        (char const   )'s',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )',',      (char const   )'R', 
        (char const   )'e',      (char const   )'s',      (char const   )'o',      (char const   )'u', 
        (char const   )'r',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'\n',      (char const   )'U',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )'\000'};
#line 706 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
void rxvt_usage(int type ) 
{ 
  unsigned int i ;
  unsigned int col ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 711
  write(1, (void const   *)(releasestring), sizeof(releasestring) - 1UL);
#line 712
  write(1, (void const   *)(optionsstring), sizeof(optionsstring) - 1UL);
#line 713
  write(1, (void const   *)"mrxvt", sizeof("mrxvt") - 1UL);
  }
  {
#line 717
  if (type == 0) {
#line 717
    goto case_0;
  }
#line 749
  if (type == 1) {
#line 749
    goto case_1;
  }
#line 768
  if (type == 2) {
#line 768
    goto case_2;
  }
#line 715
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 718
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" [-help] [--help]\n");
#line 719
  col = 1U;
#line 719
  i = 0U;
  }
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 719
      goto while_break;
    }
#line 720
    if ((unsigned long )((void *)0) != (unsigned long )optList[i].desc) {
#line 722
      len = 0;
#line 724
      if (! optList[i].flag) {
#line 726
        if (optList[i].flag) {
#line 726
          len = 0;
        } else {
#line 726
          if (optList[i].arg) {
            {
#line 726
            tmp = strlen((char const   *)optList[i].arg);
#line 726
            tmp___0 = tmp;
            }
          } else {
#line 726
            tmp___0 = (size_t )1;
          }
#line 726
          len = (int )tmp___0;
        }
#line 727
        if (len > 0) {
#line 728
          len ++;
        }
      }
      {
#line 732
      tmp___1 = strlen((char const   *)optList[i].opt);
      }
#line 732
      if (optList[i].flag) {
#line 732
        tmp___2 = 2;
      } else {
#line 732
        tmp___2 = 0;
      }
#line 732
      len = (int )((size_t )len + ((4UL + tmp___1) + (size_t )tmp___2));
#line 734
      col += (unsigned int )len;
#line 735
      if (col > 79U) {
        {
#line 737
        _IO_putc('\n', stdout);
#line 738
        col = (unsigned int )(1 + len);
        }
      }
#line 740
      if (optList[i].flag) {
#line 740
        tmp___3 = "/+";
      } else {
#line 740
        tmp___3 = "";
      }
      {
#line 740
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" [-%s%s",
              tmp___3, optList[i].opt);
      }
#line 742
      if (optList[i].flag) {
#line 742
        tmp___6 = (size_t )0;
      } else {
#line 742
        if (optList[i].arg) {
          {
#line 742
          tmp___4 = strlen((char const   *)optList[i].arg);
#line 742
          tmp___5 = tmp___4;
          }
        } else {
#line 742
          tmp___5 = (size_t )1;
        }
#line 742
        tmp___6 = tmp___5;
      }
#line 742
      if (tmp___6) {
        {
#line 743
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" %s]",
                optList[i].arg);
        }
      } else {
        {
#line 745
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"]");
        }
      }
    }
#line 719
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 750
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere options include:\n");
#line 752
  i = 0U;
  }
  {
#line 752
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 752
      goto while_break___0;
    }
#line 753
    if ((unsigned long )((void *)0) != (unsigned long )optList[i].desc) {
#line 757
      if (optList[i].flag) {
#line 757
        tmp___7 = "turn on/off ";
      } else {
#line 757
        tmp___7 = "";
      }
#line 757
      if (optList[i].arg) {
#line 757
        tmp___8 = optList[i].arg;
      } else {
#line 757
        tmp___8 = (char const   */* const  */)"";
      }
      {
#line 757
      tmp___9 = strlen((char const   *)optList[i].opt);
      }
#line 757
      if (optList[i].flag) {
#line 757
        tmp___10 = 0;
      } else {
#line 757
        tmp___10 = 2;
      }
#line 757
      if (optList[i].flag) {
#line 757
        tmp___11 = "-/+";
      } else {
#line 757
        tmp___11 = "-";
      }
      {
#line 757
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  %s%s %-*s%s%s\n",
              tmp___11, optList[i].opt, (24UL - tmp___9) + (size_t )tmp___10, tmp___8,
              tmp___7, optList[i].desc);
      }
    }
#line 752
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 765
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n  --help to list long-options");
  }
#line 766
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 769
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" [options] [-e command args]\n\nwhere resources (long-options) include:\n");
#line 787
  i = 0U;
  }
  {
#line 787
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 787
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 787
      goto while_break___1;
    }
#line 788
    if ((unsigned long )((void *)0) != (unsigned long )optList[i].kw) {
#line 789
      if (optList[i].flag) {
#line 789
        tmp___12 = (char const   */* const  */)"boolean";
      } else {
#line 789
        tmp___12 = optList[i].arg;
      }
      {
#line 789
      tmp___13 = strlen((char const   *)optList[i].kw);
#line 789
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"  %s: %*s%s\n",
              optList[i].kw, 24UL - tmp___13, "", tmp___12);
      }
    }
#line 787
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 794
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n  -help to list options");
  }
#line 795
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 798
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n\n");
#line 799
  exit(1);
  }
}
}
#line 805 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
int num_tabs(int len ) 
{ 
  int tmp ;

  {
#line 808
  if (len >= 0) {
#line 808
    if (len < 40) {
#line 808
      tmp = (40 - (len - len % 8)) / 8;
    } else {
#line 808
      tmp = 0;
    }
  } else {
#line 808
    tmp = 0;
  }
#line 808
  return (tmp);
}
}
#line 812 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
int rxvt_save_options(rxvt_t *r , char const   *filename ) 
{ 
  int i ;
  FILE *pf ;
  FILE *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  char *tabs ;
  register int j ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int bval ;
  char *OnOff[2] ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
  {
#line 816
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
#line 816
  pf = tmp;
  }
#line 818
  if ((r->h)->rs[286]) {
#line 818
    tmp___0 = (r->h)->rs[286];
  } else {
#line 818
    tmp___0 = "mrxvt";
  }
#line 818
  name = tmp___0;
#line 820
  tabs = (char *)"\t\t\t\t\t";
#line 822
  if ((unsigned long )((void *)0) == (unsigned long )pf) {
#line 823
    return (0);
  }
#line 825
  i = 0;
  {
#line 825
  while (1) {
    while_continue: /* CIL Label */ ;
#line 825
    if (! ((unsigned long )i < sizeof(optList) / sizeof(optList[0]))) {
#line 825
      goto while_break;
    }
#line 827
    if ((unsigned long )((void *)0) == (unsigned long )optList[i].kw) {
#line 834
      goto __Cont;
    } else
#line 827
    if (optList[i].doff == -1) {
#line 827
      if (! optList[i].flag) {
#line 834
        goto __Cont;
      }
    }
#line 836
    if (optList[i].multiple) {
#line 840
      j = 0;
      {
#line 840
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 840
        if (! (j < 5)) {
#line 840
          goto while_break___0;
        }
#line 842
        if ((r->h)->rs[optList[i].doff + (int const   )j]) {
          {
#line 843
          tmp___1 = strlen(name);
#line 843
          tmp___2 = strlen((char const   *)optList[i].kw);
#line 843
          tmp___3 = num_tabs((int )(((tmp___1 + sizeof(".profile")) + 2UL) + tmp___2));
#line 843
          fprintf((FILE */* __restrict  */)pf, (char const   */* __restrict  */)"%s.profile%d.%s:%.*s%s\n",
                  name, j, optList[i].kw, tmp___3, tabs, (r->h)->rs[optList[i].doff + (int const   )j]);
          }
        }
#line 840
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 850
    if (optList[i].flag) {
#line 853
      OnOff[0] = (char *)"False";
#line 853
      OnOff[1] = (char *)"True";
#line 855
      if (r->Options[optList[i].flag & 3U] & (unsigned int )(optList[i].flag & 4294967292U)) {
#line 855
        bval = 1;
      } else {
#line 855
        bval = 0;
      }
#line 857
      if ((unsigned long )optList[i].flag & (1UL << 31)) {
#line 858
        bval = ! bval;
      }
      {
#line 859
      tmp___4 = strlen(name);
#line 859
      tmp___5 = strlen((char const   *)optList[i].kw);
#line 859
      tmp___6 = num_tabs((int )(((tmp___4 + 1UL) + tmp___5) + 1UL));
#line 859
      fprintf((FILE */* __restrict  */)pf, (char const   */* __restrict  */)"%s.%s:%.*s%s\n",
              name, optList[i].kw, tmp___6, tabs, OnOff[bval]);
      }
    } else
#line 864
    if ((r->h)->rs[optList[i].doff]) {
      {
#line 866
      tmp___7 = strlen(name);
#line 866
      tmp___8 = strlen((char const   *)optList[i].kw);
#line 866
      tmp___9 = num_tabs((int )(((tmp___7 + 1UL) + tmp___8) + 1UL));
#line 866
      fprintf((FILE */* __restrict  */)pf, (char const   */* __restrict  */)"%s.%s:%.*s%s\n",
              name, optList[i].kw, tmp___9, tabs, (r->h)->rs[optList[i].doff]);
      }
    }
    __Cont: /* CIL Label */ 
#line 825
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  fputs((char const   */* __restrict  */)"\n\n# vim: set ft=mrxvtrc :\n", (FILE */* __restrict  */)pf);
#line 875
  fclose(pf);
  }
#line 876
  return (1);
}
}
#line 888 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static char const   On[3]  = {      (char const   )'O',      (char const   )'N',      (char const   )'\000'};
#line 888 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
static char const   Off[4]  = {      (char const   )'O',      (char const   )'F',      (char const   )'F',      (char const   )'\000'};
#line 884 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
void rxvt_get_options(rxvt_t *r , int argc , char const   * const  *argv ) 
{ 
  int i ;
  int bad_option ;
  unsigned int entry ;
  unsigned int longopt ;
  char const   *flag ;
  char const   *opt ;
  int profileNum ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char buflong[256] ;
  char bufshort[128] ;
  int offset ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *str ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char const   *str___0 ;
  char const   *msg ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 887
  bad_option = 0;
#line 893
  i = 1;
  {
#line 893
  while (1) {
    while_continue: /* CIL Label */ ;
#line 893
    if (! (i < argc)) {
#line 893
      goto while_break;
    }
    {
#line 895
    longopt = 0U;
#line 899
    opt = (char const   *)*(argv + i);
#line 900
    profileNum = 0;
#line 902
    rxvt_msg((uint32_t )3, (uint32_t )262144, "argv[%d] = %s: \n", i, opt);
    }
#line 903
    if ((int const   )*opt == 45) {
#line 905
      flag = On;
#line 906
      opt ++;
#line 906
      if ((int const   )*opt == 45) {
#line 907
        tmp = opt;
#line 907
        opt ++;
#line 907
        longopt = (unsigned int )*tmp;
      }
    } else
#line 909
    if ((int const   )*opt == 43) {
#line 911
      flag = Off;
#line 912
      opt ++;
#line 912
      if ((int const   )*opt == 43) {
#line 913
        tmp___0 = opt;
#line 913
        opt ++;
#line 913
        longopt = (unsigned int )*tmp___0;
      }
    } else {
      {
#line 917
      bad_option = 1;
#line 918
      rxvt_msg((uint32_t )1, (uint32_t )262144, "bad option \"%s\"\n", opt);
      }
#line 919
      goto __Cont;
    }
    {
#line 922
    tmp___2 = strcmp(opt, "help");
    }
#line 922
    if (! tmp___2) {
#line 923
      if (longopt) {
#line 923
        tmp___1 = 2;
      } else {
#line 923
        tmp___1 = 1;
      }
      {
#line 923
      rxvt_usage(tmp___1);
      }
    }
    {
#line 924
    tmp___3 = strcmp(opt, "h");
    }
#line 924
    if (! tmp___3) {
      {
#line 925
      rxvt_usage(0);
      }
    }
#line 928
    entry = 0U;
    {
#line 928
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 928
      if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 928
        goto while_break___0;
      }
#line 934
      buflong[0] = (char )'\000';
#line 935
      bufshort[0] = (char )'\000';
#line 941
      if (optList[entry].multiple) {
        {
#line 943
        offset = 0;
#line 948
        offset = rxvt_str_match(opt, "vt");
        }
#line 949
        if (offset == 0) {
          {
#line 950
          offset = rxvt_str_match(opt, "profile");
          }
        }
#line 956
        if (offset) {
          {
#line 958
          profileNum = atoi(opt + offset);
          }
#line 959
          if (profileNum < 0) {
#line 961
            entry = (unsigned int )(sizeof(optList) / sizeof(optList[0]));
#line 962
            goto while_break___0;
          } else
#line 959
          if (profileNum >= 5) {
#line 961
            entry = (unsigned int )(sizeof(optList) / sizeof(optList[0]));
#line 962
            goto while_break___0;
          }
          {
#line 965
          snprintf((char */* __restrict  */)(buflong), sizeof(buflong) - 1UL, (char const   */* __restrict  */)"%.*s%d.%s",
                   offset, opt, profileNum, optList[entry].kw);
#line 967
          buflong[sizeof(buflong) - 1UL] = (char )'\000';
#line 969
          snprintf((char */* __restrict  */)(bufshort), sizeof(bufshort) - 1UL, (char const   */* __restrict  */)"%.*s%d.%s",
                   offset, opt, profileNum, optList[entry].opt);
#line 971
          bufshort[sizeof(bufshort) - 1UL] = (char )'\000';
          }
        } else {
          {
#line 979
          strncpy((char */* __restrict  */)(buflong), (char const   */* __restrict  */)((char const   *)optList[entry].kw),
                  sizeof(buflong) - 1UL);
#line 980
          buflong[sizeof(buflong) - 1UL] = (char )'\000';
#line 982
          strncpy((char */* __restrict  */)(bufshort), (char const   */* __restrict  */)((char const   *)optList[entry].opt),
                  sizeof(bufshort) - 1UL);
#line 983
          bufshort[sizeof(bufshort) - 1UL] = (char )'\000';
#line 985
          profileNum = 0;
          }
        }
      } else
#line 990
      if (optList[entry].kw) {
        {
#line 992
        strncpy((char */* __restrict  */)(buflong), (char const   */* __restrict  */)((char const   *)optList[entry].kw),
                sizeof(buflong) - 1UL);
#line 993
        buflong[sizeof(buflong) - 1UL] = (char )'\000';
        }
#line 994
        if (optList[entry].opt) {
          {
#line 996
          strncpy((char */* __restrict  */)(bufshort), (char const   */* __restrict  */)((char const   *)optList[entry].opt),
                  sizeof(bufshort) - 1UL);
#line 998
          bufshort[sizeof(bufshort) - 1UL] = (char )'\000';
          }
        }
      } else
#line 1001
      if (optList[entry].opt) {
        {
#line 1004
        strncpy((char */* __restrict  */)(bufshort), (char const   */* __restrict  */)((char const   *)optList[entry].opt),
                sizeof(bufshort) - 1UL);
#line 1006
        bufshort[sizeof(bufshort) - 1UL] = (char )'\000';
        }
      }
#line 1011
      if (optList[entry].kw) {
        {
#line 1011
        tmp___4 = strcmp(opt, (char const   *)(buflong));
        }
#line 1011
        if (tmp___4) {
#line 1011
          goto _L;
        } else {
#line 1018
          goto while_break___0;
        }
      } else
      _L: /* CIL Label */ 
#line 1011
      if (! longopt) {
#line 1011
        if (optList[entry].opt) {
          {
#line 1011
          tmp___5 = strcasecmp(opt, (char const   *)(bufshort));
          }
#line 1011
          if (! tmp___5) {
#line 1018
            goto while_break___0;
          }
        }
      }
#line 928
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1022
    if ((unsigned long )entry < sizeof(optList) / sizeof(optList[0])) {
#line 1024
      if ((unsigned long )optList[entry].flag & (1UL << 31)) {
#line 1025
        if ((unsigned long )flag == (unsigned long )(On)) {
#line 1025
          flag = Off;
        } else {
#line 1025
          flag = On;
        }
      }
#line 1028
      if (optList[entry].flag) {
#line 1028
        tmp___8 = (size_t )0;
      } else {
#line 1028
        if (optList[entry].arg) {
          {
#line 1028
          tmp___6 = strlen((char const   *)optList[entry].arg);
#line 1028
          tmp___7 = tmp___6;
          }
        } else {
#line 1028
          tmp___7 = (size_t )1;
        }
#line 1028
        tmp___8 = tmp___7;
      }
#line 1028
      if (tmp___8) {
#line 1030
        i ++;
#line 1030
        str = (char const   *)*(argv + i);
#line 1034
        if ((unsigned long )flag == (unsigned long )(On)) {
#line 1034
          if (str) {
#line 1034
            if (optList[entry].doff != -1) {
#line 1037
              (r->h)->rs[optList[entry].doff + (int const   )profileNum] = str;
            }
          }
        }
      } else {
#line 1053
        if ((unsigned long )flag == (unsigned long )(On)) {
#line 1054
          r->Options[optList[entry].flag & 3U] |= (unsigned int )(optList[entry].flag & 4294967292U);
        } else {
#line 1056
          r->Options[optList[entry].flag & 3U] &= (unsigned int )(~ (optList[entry].flag & 4294967292U));
        }
#line 1062
        pSetOpts[optList[entry].flag & 3U] |= (unsigned int )(optList[entry].flag & 4294967292U);
      }
    } else {
      {
#line 1069
      tmp___11 = rxvt_str_match(opt, "macro.");
      }
#line 1069
      if (tmp___11) {
#line 1071
        i ++;
#line 1071
        str___0 = (char const   *)*(argv + i);
#line 1073
        if ((unsigned long )((void *)0) != (unsigned long )str___0) {
          {
#line 1074
          rxvt_parse_macros(r, (opt + sizeof("macro.")) - 1, str___0, (macro_priority_t )0);
          }
        }
      } else {
#line 1085
        msg = "bad";
#line 1087
        if (longopt) {
#line 1089
          opt --;
#line 1090
          bad_option = 1;
        } else {
          {
#line 1092
          tmp___9 = strcmp(opt, "7");
          }
#line 1092
          if (tmp___9) {
            {
#line 1092
            tmp___10 = strcmp(opt, "8");
            }
#line 1092
            if (tmp___10) {
#line 1100
              bad_option = 1;
            } else {
#line 1098
              msg = "obsolete";
            }
          } else {
#line 1098
            msg = "obsolete";
          }
        }
        {
#line 1102
        opt --;
#line 1102
        rxvt_msg((uint32_t )1, (uint32_t )262144, "%s option \"%s\"", msg, opt);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 893
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1107
  if (bad_option) {
    {
#line 1114
    rxvt_msg((uint32_t )1, (uint32_t )262144, "Use -h, -help or --help to get help\n");
#line 1116
    exit(1);
    }
  }
#line 1120
  return;
}
}
#line 1128 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
void rxvt_get_xdefaults(rxvt_t *r , FILE *stream , char const   *name , macro_priority_t priority ) 
{ 
  unsigned int len ;
  unsigned int lenstr ;
  char *str ;
  char buffer[256] ;
  size_t tmp ;
  unsigned int entry ;
  unsigned int n ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *ptr ;
  char kw[256] ;
  int profileNum ;
  int offset ;
  char buf[256] ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int s ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1136
  rxvt_msg((uint32_t )3, (uint32_t )262144, "rxvt_get_xdefaults (%s)\n", name);
  }
#line 1138
  if ((unsigned long )((void *)0) == (unsigned long )stream) {
#line 1139
    return;
  }
  {
#line 1140
  tmp = strlen(name);
#line 1140
  len = (unsigned int )tmp;
  }
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1142
    str = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)stream);
    }
#line 1142
    if (! ((unsigned long )((void *)0) != (unsigned long )str)) {
#line 1142
      goto while_break;
    }
    {
#line 1146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1146
      if (*str) {
        {
#line 1146
        tmp___0 = __ctype_b_loc();
        }
#line 1146
        if (! ((int const   )*(*tmp___0 + (int )*str) & 8192)) {
#line 1146
          goto while_break___0;
        }
      } else {
#line 1146
        goto while_break___0;
      }
#line 1147
      str ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1149
    if ((int )*(str + len) != 42) {
#line 1149
      if ((int )*(str + len) != 46) {
#line 1153
        goto while_continue;
      } else {
#line 1149
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1149
    if (len) {
      {
#line 1149
      tmp___1 = strncmp((char const   *)str, name, (size_t )len);
      }
#line 1149
      if (tmp___1) {
#line 1153
        goto while_continue;
      }
    }
    {
#line 1154
    str += len + 1U;
#line 1155
    tmp___2 = strlen((char const   *)str);
#line 1155
    lenstr = (unsigned int )tmp___2;
#line 1162
    ptr = str;
    }
    {
#line 1163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1163
      if (*ptr) {
#line 1163
        if (! ((int )*ptr != 58)) {
#line 1163
          goto while_break___1;
        }
      } else {
#line 1163
        goto while_break___1;
      }
#line 1165
      if (42 == (int )*ptr) {
#line 1166
        *ptr = (char )'.';
      }
#line 1167
      ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1171
    tmp___12 = rxvt_parse_macros(r, (char const   *)str, (char const   *)((void *)0),
                                 priority);
    }
#line 1171
    if (! tmp___12) {
#line 1173
      entry = 0U;
      {
#line 1173
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1173
        if (! ((unsigned long )entry < sizeof(optList) / sizeof(optList[0]))) {
#line 1173
          goto while_break___2;
        }
#line 1177
        profileNum = 0;
#line 1179
        if ((unsigned long )((void *)0) == (unsigned long )optList[entry].kw) {
#line 1180
          goto __Cont;
        }
        {
#line 1181
        strncpy((char */* __restrict  */)(kw), (char const   */* __restrict  */)((char const   *)optList[entry].kw),
                sizeof(kw) - 1UL);
#line 1182
        kw[sizeof(kw) - 1UL] = (char)0;
        }
#line 1184
        if (optList[entry].multiple) {
          {
#line 1186
          offset = 0;
#line 1191
          offset = rxvt_str_match((char const   *)str, "vt");
          }
#line 1192
          if (offset == 0) {
            {
#line 1193
            offset = rxvt_str_match((char const   *)str, "profile");
            }
          }
#line 1198
          if (offset) {
            {
#line 1202
            profileNum = atoi((char const   *)(str + offset));
            }
#line 1203
            if (profileNum < 0) {
#line 1204
              goto __Cont;
            } else
#line 1203
            if (profileNum >= 5) {
#line 1204
              goto __Cont;
            }
            {
#line 1206
            snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%.*s%d.%s",
                     offset, str, profileNum, kw);
#line 1208
            buf[sizeof(buf) - 1UL] = (char )'\000';
#line 1210
            strncpy((char */* __restrict  */)(kw), (char const   */* __restrict  */)((char const   *)(buf)),
                    sizeof(kw) - 1UL);
#line 1211
            kw[sizeof(kw) - 1UL] = (char )'\000';
            }
          } else {
#line 1222
            profileNum = 0;
          }
        }
        {
#line 1228
        tmp___3 = strlen((char const   *)(kw));
#line 1228
        n = (unsigned int )tmp___3;
        }
#line 1229
        if (n < lenstr) {
#line 1229
          if ((int )*(str + n) == 58) {
            {
#line 1229
            tmp___11 = rxvt_str_match((char const   *)str, (char const   *)(kw));
            }
#line 1229
            if (tmp___11) {
              {
#line 1232
              str += n + 1U;
#line 1233
              rxvt_str_trim(str);
#line 1234
              tmp___4 = strlen((char const   *)str);
#line 1234
              n = (unsigned int )tmp___4;
              }
#line 1242
              if (optList[entry].flag) {
#line 1249
                if (! (pSetOpts[optList[entry].flag & 3U] & (unsigned int )(optList[entry].flag & 4294967292U))) {
                  {
#line 1256
                  tmp___5 = strcasecmp((char const   *)str, "true");
                  }
#line 1256
                  if (tmp___5 == 0) {
#line 1256
                    tmp___9 = 1;
                  } else {
                    {
#line 1256
                    tmp___6 = strcasecmp((char const   *)str, "yes");
                    }
#line 1256
                    if (tmp___6 == 0) {
#line 1256
                      tmp___9 = 1;
                    } else {
                      {
#line 1256
                      tmp___7 = strcasecmp((char const   *)str, "on");
                      }
#line 1256
                      if (tmp___7 == 0) {
#line 1256
                        tmp___9 = 1;
                      } else {
                        {
#line 1256
                        tmp___8 = strcasecmp((char const   *)str, "1");
                        }
#line 1256
                        if (tmp___8 == 0) {
#line 1256
                          tmp___9 = 1;
                        } else {
#line 1256
                          tmp___9 = 0;
                        }
                      }
                    }
                  }
#line 1256
                  s = tmp___9;
#line 1260
                  if ((unsigned long )optList[entry].flag & (1UL << 31)) {
#line 1261
                    s = ! s;
                  }
#line 1263
                  if (s) {
#line 1264
                    r->Options[optList[entry].flag & 3U] |= (unsigned int )(optList[entry].flag & 4294967292U);
                  } else {
#line 1266
                    r->Options[optList[entry].flag & 3U] &= (unsigned int )(~ (optList[entry].flag & 4294967292U));
                  }
#line 1269
                  pSetOpts[optList[entry].flag & 3U] |= (unsigned int )(optList[entry].flag & 4294967292U);
                }
              } else
#line 1273
              if ((unsigned long )((void *)0) == (unsigned long )(r->h)->rs[optList[entry].doff + (int const   )profileNum]) {
#line 1280
                if (n) {
#line 1280
                  if (! optList[entry].flag) {
                    {
#line 1280
                    tmp___10 = strdup((char const   *)str);
#line 1280
                    (r->h)->rs[optList[entry].doff + (int const   )profileNum] = (char const   *)tmp___10;
                    }
                  } else {
#line 1280
                    (r->h)->rs[optList[entry].doff + (int const   )profileNum] = emptyResource;
                  }
                } else {
#line 1280
                  (r->h)->rs[optList[entry].doff + (int const   )profileNum] = emptyResource;
                }
              }
#line 1285
              goto while_break___2;
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 1173
        entry ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1292
  rewind(stream);
  }
#line 1293
  return;
}
}
#line 1302 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/xdefaults.c"
void rxvt_extract_resources(rxvt_t *r , Display *display , char const   *name ) 
{ 
  FILE *fd ;
  char *home ;
  macro_priority_t priority ;
  char *localepath ;
  void *tmp ;
  int i ;
  int len ;
  size_t tmp___0 ;
  char *f ;
  size_t tmp___1 ;
  void *tmp___2 ;
  macro_priority_t tmp___3 ;
  macro_priority_t tmp___4 ;
  macro_priority_t tmp___5 ;
  macro_priority_t tmp___6 ;

  {
#line 1310
  fd = (FILE *)((void *)0);
#line 1313
  priority = (macro_priority_t )1;
#line 1321
  localepath = (char *)((void *)0);
#line 1323
  if ((unsigned long )((void *)0) != (unsigned long )(r->h)->locale) {
    {
#line 1327
    tmp = rxvt_malloc((size_t )256);
#line 1327
    localepath = (char *)tmp;
#line 1328
    sprintf((char */* __restrict  */)localepath, (char const   */* __restrict  */)"/usr/X11R6/lib/X11/%-.*s/app-defaults/Mrxvt",
            (int )((258UL - sizeof("/usr/X11R6/lib/X11/%-.*s/app-defaults")) - sizeof("Mrxvt")),
            (r->h)->locale);
    }
  }
#line 1337
  if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[327]) {
    {
#line 1338
    fd = fopen((char const   */* __restrict  */)(r->h)->rs[327], (char const   */* __restrict  */)"r");
    }
  }
#line 1340
  if ((unsigned long )((void *)0) == (unsigned long )fd) {
    {
#line 1340
    home = getenv("HOME");
    }
#line 1340
    if ((unsigned long )((void *)0) != (unsigned long )home) {
      {
#line 1342
      tmp___0 = strlen((char const   *)home);
#line 1342
      len = (int )(tmp___0 + 2UL);
#line 1343
      f = (char *)((void *)0);
#line 1347
      i = 0;
      }
      {
#line 1347
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1347
        if (! ((unsigned long )i < sizeof(xnames) / sizeof(xnames[0]))) {
#line 1347
          goto while_break;
        }
        {
#line 1351
        tmp___1 = strlen((char const   *)xnames[i]);
#line 1351
        tmp___2 = rxvt_realloc((void *)f, ((size_t )len + tmp___1) * sizeof(char ));
#line 1351
        f = (char *)tmp___2;
#line 1353
        sprintf((char */* __restrict  */)f, (char const   */* __restrict  */)"%s/%s",
                home, xnames[i]);
#line 1355
        fd = fopen((char const   */* __restrict  */)f, (char const   */* __restrict  */)"r");
        }
#line 1355
        if ((unsigned long )((void *)0) != (unsigned long )fd) {
#line 1356
          goto while_break;
        }
#line 1347
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1358
      rxvt_free((void *)f);
      }
    }
  }
  {
#line 1383
  tmp___3 = priority;
#line 1383
  priority = (macro_priority_t )((int )priority + 1);
#line 1383
  rxvt_get_xdefaults(r, fd, name, tmp___3);
#line 1384
  tmp___4 = priority;
#line 1384
  priority = (macro_priority_t )((int )priority + 1);
#line 1384
  rxvt_get_xdefaults(r, fd, "Mrxvt", tmp___4);
#line 1385
  tmp___5 = priority;
#line 1385
  priority = (macro_priority_t )((int )priority + 1);
#line 1385
  rxvt_get_xdefaults(r, fd, "XTerm", tmp___5);
  }
#line 1389
  if ((unsigned long )((void *)0) != (unsigned long )fd) {
    {
#line 1390
    fclose(fd);
    }
  }
#line 1419
  if (! ((unsigned long )r->Options[((1UL << 21) | 1UL) & 3UL] & (((1UL << 21) | 1UL) & 0xfffffffffffffffcUL))) {
    {
#line 1419
    fd = fopen((char const   */* __restrict  */)"/usr/local/etc/mrxvt/mrxvtrc", (char const   */* __restrict  */)"r");
    }
#line 1419
    if ((unsigned long )((void *)0) != (unsigned long )fd) {
      {
#line 1422
      tmp___6 = priority;
#line 1422
      priority = (macro_priority_t )((int )priority + 1);
#line 1422
      rxvt_get_xdefaults(r, fd, "Mrxvt", tmp___6);
#line 1423
      fclose(fd);
      }
    }
  }
  {
#line 1451
  rxvt_free((void *)localepath);
#line 1464
  r->Options[(1UL << 31) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 31) & 3UL] & ~ ((1UL << 31) & 0xfffffffffffffffcUL));
#line 1465
  r->Options[((1UL << 31) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 31) | 1UL) & 3UL] & ~ (((1UL << 31) | 1UL) & 0xfffffffffffffffcUL));
#line 1466
  r->Options[((1UL << 31) | 2UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 31) | 2UL) & 3UL] & ~ (((1UL << 31) | 2UL) & 0xfffffffffffffffcUL));
#line 1467
  r->Options[((1UL << 31) | 3UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 31) | 3UL) & 3UL] & ~ (((1UL << 31) | 3UL) & 0xfffffffffffffffcUL));
  }
#line 1506
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 1906 "/usr/include/X11/Xlib.h"
extern int XIconifyWindow(Display * , Window  , int  ) ;
#line 2121
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2803
extern int XLowerWindow(Display * , Window  ) ;
#line 2846
extern int XMoveWindow(Display * , Window  , int  , int  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3038
extern int XRaiseWindow(Display * , Window  ) ;
#line 3079
extern int XRefreshKeyboardMapping(XMappingEvent * ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3458
extern int XTranslateCoordinates(Display * , Window  , Window  , int  , int  , int * ,
                                 int * , Window * ) ;
#line 534 "/usr/include/X11/Xutil.h"
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 659
extern void XSetWMNormalHints(Display * , Window  , XSizeHints * ) ;
#line 1108 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
void rxvt_main_loop(rxvt_t *r ) ;
#line 33 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_xterm_seq(rxvt_t *r , int page , int op , char const   *str , unsigned char resp ) ;
#line 36
void rxvt_pointer_unblank(rxvt_t *r , int page ) ;
#line 87
void rxvt_set_jumpscroll(rxvt_t *r ) ;
#line 111
termenv_t rxvt_get_termenv(char const   *env ) ;
#line 147
int rxvt_change_font_x11(rxvt_t *r , char const   *fontname ) ;
#line 155
void rxvt_set_window_color(rxvt_t *r , int page , int idx , char const   *color ) ;
#line 156
void rxvt_recolour_cursor(rxvt_t *r ) ;
#line 340
void rxvt_scrollbar_resize(rxvt_t *r ) ;
#line 344
unsigned short rxvt_scrollbar_width(rxvt_t *r ) ;
#line 345
unsigned short rxvt_scrollbar_rwidth(rxvt_t *r ) ;
#line 346
int rxvt_is_scrollbar_win(rxvt_t *r , Window w ) ;
#line 383
int rxvt_set_opacity(rxvt_t *r ) ;
#line 384
void rxvt_process_reparentnotify(rxvt_t *r , XEvent *ev ) ;
#line 387
void refreshRootBGVars(rxvt_t *r ) ;
#line 388
int rxvt_check_our_parents(rxvt_t *r ) ;
#line 391
void rxvt_refresh_bg_image(rxvt_t *r , int page , int imediate ) ;
#line 465
void rxvt_process_ice_msgs(rxvt_t *r ) ;
#line 53 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static DeadKeyChar dkc_tab[66]  = 
#line 53 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
  {      {(KeySym )65, (KeySym )96, (KeySym )192}, 
        {(KeySym )65, (KeySym )180, (KeySym )193}, 
        {(KeySym )65, (KeySym )39, (KeySym )193}, 
        {(KeySym )65, (KeySym )94, (KeySym )194}, 
        {(KeySym )65, (KeySym )126, (KeySym )195}, 
        {(KeySym )65, (KeySym )34, (KeySym )196}, 
        {(KeySym )97, (KeySym )96, (KeySym )224}, 
        {(KeySym )97, (KeySym )180, (KeySym )225}, 
        {(KeySym )97, (KeySym )39, (KeySym )225}, 
        {(KeySym )97, (KeySym )94, (KeySym )226}, 
        {(KeySym )97, (KeySym )126, (KeySym )227}, 
        {(KeySym )97, (KeySym )34, (KeySym )228}, 
        {(KeySym )67, (KeySym )96, (KeySym )199}, 
        {(KeySym )67, (KeySym )180, (KeySym )199}, 
        {(KeySym )99, (KeySym )96, (KeySym )231}, 
        {(KeySym )99, (KeySym )180, (KeySym )231}, 
        {(KeySym )69, (KeySym )96, (KeySym )200}, 
        {(KeySym )69, (KeySym )180, (KeySym )201}, 
        {(KeySym )69, (KeySym )39, (KeySym )201}, 
        {(KeySym )69, (KeySym )94, (KeySym )202}, 
        {(KeySym )69, (KeySym )34, (KeySym )203}, 
        {(KeySym )101, (KeySym )96, (KeySym )232}, 
        {(KeySym )101, (KeySym )180, (KeySym )233}, 
        {(KeySym )101, (KeySym )39, (KeySym )233}, 
        {(KeySym )101, (KeySym )94, (KeySym )234}, 
        {(KeySym )101, (KeySym )34, (KeySym )235}, 
        {(KeySym )73, (KeySym )96, (KeySym )204}, 
        {(KeySym )73, (KeySym )180, (KeySym )205}, 
        {(KeySym )73, (KeySym )39, (KeySym )205}, 
        {(KeySym )73, (KeySym )94, (KeySym )206}, 
        {(KeySym )73, (KeySym )34, (KeySym )207}, 
        {(KeySym )105, (KeySym )96, (KeySym )236}, 
        {(KeySym )105, (KeySym )180, (KeySym )237}, 
        {(KeySym )105, (KeySym )39, (KeySym )237}, 
        {(KeySym )105, (KeySym )94, (KeySym )238}, 
        {(KeySym )105, (KeySym )34, (KeySym )239}, 
        {(KeySym )78, (KeySym )126, (KeySym )209}, 
        {(KeySym )110, (KeySym )126, (KeySym )241}, 
        {(KeySym )79, (KeySym )96, (KeySym )210}, 
        {(KeySym )79, (KeySym )180, (KeySym )211}, 
        {(KeySym )79, (KeySym )39, (KeySym )211}, 
        {(KeySym )79, (KeySym )94, (KeySym )212}, 
        {(KeySym )79, (KeySym )126, (KeySym )213}, 
        {(KeySym )79, (KeySym )34, (KeySym )214}, 
        {(KeySym )111, (KeySym )96, (KeySym )242}, 
        {(KeySym )111, (KeySym )180, (KeySym )243}, 
        {(KeySym )111, (KeySym )39, (KeySym )243}, 
        {(KeySym )111, (KeySym )94, (KeySym )244}, 
        {(KeySym )111, (KeySym )126, (KeySym )245}, 
        {(KeySym )111, (KeySym )34, (KeySym )246}, 
        {(KeySym )85, (KeySym )96, (KeySym )217}, 
        {(KeySym )85, (KeySym )180, (KeySym )218}, 
        {(KeySym )85, (KeySym )39, (KeySym )218}, 
        {(KeySym )85, (KeySym )94, (KeySym )219}, 
        {(KeySym )85, (KeySym )34, (KeySym )220}, 
        {(KeySym )117, (KeySym )96, (KeySym )249}, 
        {(KeySym )117, (KeySym )180, (KeySym )250}, 
        {(KeySym )117, (KeySym )39, (KeySym )250}, 
        {(KeySym )117, (KeySym )94, (KeySym )251}, 
        {(KeySym )117, (KeySym )34, (KeySym )252}, 
        {(KeySym )89, (KeySym )180, (KeySym )221}, 
        {(KeySym )89, (KeySym )39, (KeySym )221}, 
        {(KeySym )121, (KeySym )180, (KeySym )253}, 
        {(KeySym )121, (KeySym )39, (KeySym )253}, 
        {(KeySym )121, (KeySym )34, (KeySym )255}, 
        {(KeySym )0, (KeySym )0, (KeySym )0}};
#line 146
void rxvt_process_keypress(rxvt_t *r , XKeyEvent *ev ) ;
#line 147
void rxvt_clean_cmd_page(rxvt_t *r ) ;
#line 148
__inline static int rxvt_cmdbuf_has_input(rxvt_t *r , int page ) ;
#line 149
int rxvt_find_cmd_child(rxvt_t *r ) ;
#line 150
void rxvt_check_cmdbuf(rxvt_t *r , int page ) ;
#line 151
int rxvt_read_child_cmdfd(rxvt_t *r , int page , unsigned int count ) ;
#line 152
void rxvt_process_children_cmdfd(rxvt_t *r , fd_set *p_readfds ) ;
#line 153
int rxvt_check_quick_timeout(rxvt_t *r ) ;
#line 154
int rxvt_adjust_quick_timeout(rxvt_t *r , int quick_timeout , struct timeval *value ) ;
#line 155
void rxvt_refresh_vtscr_if_needed(rxvt_t *r ) ;
#line 156
unsigned char rxvt_cmd_getc(rxvt_t *r , int *p_page ) ;
#line 158
void rxvt_pointer_blank(rxvt_t *r , int page ) ;
#line 160
void rxvt_mouse_report(rxvt_t *r , XButtonEvent const   *ev ) ;
#line 165
void rxvt_scrollbar_dispatcher(rxvt_t *r , int page , XButtonEvent *ev ) ;
#line 166
void rxvt_process_buttonpress(rxvt_t *r , int page , XButtonEvent *ev ) ;
#line 168
void rxvt_process_wheel_button(rxvt_t *r , int page , XButtonEvent *ev ) ;
#line 170
void rxvt_process_buttonrelease(rxvt_t *r , int page , XButtonEvent *ev ) ;
#line 171
void rxvt_process_clientmessage(rxvt_t *r , XClientMessageEvent *ev ) ;
#line 172
void rxvt_process_visibilitynotify(rxvt_t *r , XVisibilityEvent *ev ) ;
#line 177
void rxvt_change_colors_on_focus(rxvt_t *r ) ;
#line 178
void rxvt_process_focusin(rxvt_t *r , XFocusChangeEvent *ev ) ;
#line 179
void rxvt_process_focusout(rxvt_t *r , XFocusChangeEvent *ev ) ;
#line 180
int rxvt_calc_colrow(rxvt_t *r , unsigned int width , unsigned int height ) ;
#line 181
void rxvt_resize_sub_windows(rxvt_t *r ) ;
#line 182
void rxvt_resize_on_configure(rxvt_t *r , unsigned int width , unsigned int height ) ;
#line 184
int getWMStruts(Display *dpy , Window w , CARD32 *left , CARD32 *right , CARD32 *top ,
                CARD32 *bottom ) ;
#line 186
void rxvt_process_configurenotify(rxvt_t *r , XConfigureEvent *ev ) ;
#line 187
void rxvt_process_selectionnotify(rxvt_t *r , XSelectionEvent *ev ) ;
#line 188
void rxvt_process_propertynotify(rxvt_t *r , XEvent *ev ) ;
#line 189
void rxvt_process_expose(rxvt_t *r , XEvent *ev ) ;
#line 190
void rxvt_process_motionnotify(rxvt_t *r , XEvent *ev ) ;
#line 191
void rxvt_process_x_event(rxvt_t *r , XEvent *ev ) ;
#line 193
void rxvt_process_print_pipe(rxvt_t *r , int page ) ;
#line 195
void rxvt_process_nonprinting(rxvt_t *r , int page , unsigned char ch ) ;
#line 196
void rxvt_process_escape_vt52(rxvt_t *r , int page , unsigned char ch ) ;
#line 197
void rxvt_process_escape_seq(rxvt_t *r , int page ) ;
#line 198
void rxvt_process_csi_seq(rxvt_t *r , int page ) ;
#line 200
void rxvt_process_window_ops(rxvt_t *r , int page , int const   *args , unsigned int nargs ) ;
#line 202
unsigned char *rxvt_get_to_st(rxvt_t *r , int page , unsigned char *ends_how ) ;
#line 203
void rxvt_process_dcs_seq(rxvt_t *r , int page ) ;
#line 204
void rxvt_process_osc_seq(rxvt_t *r , int page ) ;
#line 205
void rxvt_xwsh_seq(rxvt_t *r , int op , char const   *str ) ;
#line 206
void rxvt_process_xwsh_seq(rxvt_t *r , int page ) ;
#line 207
int rxvt_privcases(rxvt_t *r , int page , int mode , uint32_t bit ) ;
#line 208
void rxvt_process_terminal_mode(rxvt_t *r , int page , int mode , int priv , unsigned int nargs ,
                                int const   *arg ) ;
#line 209
void rxvt_process_sgr_mode(rxvt_t *r , int page , unsigned int nargs , int const   *arg ) ;
#line 210
void rxvt_process_graphics(rxvt_t *r , int page ) ;
#line 211
void rxvt_process_getc(rxvt_t *r , int page , unsigned char ch ) ;
#line 269 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void set_xterm_key_seq(unsigned char *kbuf___0 , char const   *umod_prefix , char const   *mod_prefix_format ,
                       char suffix , int ctrl , int meta , int shft ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 274
  if (ctrl) {
#line 274
    goto _L;
  } else
#line 274
  if (meta) {
#line 274
    goto _L;
  } else
#line 274
  if (shft) {
    _L: /* CIL Label */ 
#line 275
    if (shft) {
#line 275
      tmp = 1;
    } else {
#line 275
      tmp = 0;
    }
#line 275
    if (meta) {
#line 275
      tmp___0 = 2;
    } else {
#line 275
      tmp___0 = 0;
    }
#line 275
    if (ctrl) {
#line 275
      tmp___1 = 4;
    } else {
#line 275
      tmp___1 = 0;
    }
    {
#line 275
    sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)mod_prefix_format,
            ((1 + tmp) + tmp___0) + tmp___1, (int )suffix);
    }
  } else {
    {
#line 279
    sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"%s%c",
            umod_prefix, (int )suffix);
    }
  }
#line 280
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_0xffxx_keypress(rxvt_t *r , KeySym keysym , int ctrl , int meta , int shft ,
                         unsigned char *kbuf___0 ) 
{ 
  unsigned int newlen ;
  unsigned char *bsKbuf ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 303
  newlen = 1U;
  {
#line 311
  if (keysym == 65288UL) {
#line 311
    goto case_65288;
  }
#line 367
  if (keysym == 65289UL) {
#line 367
    goto case_65289;
  }
#line 389
  if (keysym == 65293UL) {
#line 389
    goto case_65293;
  }
#line 412
  if (keysym == 65430UL) {
#line 412
    goto case_65430;
  }
#line 412
  if (keysym == 65432UL) {
#line 412
    goto case_65430;
  }
#line 412
  if (keysym == 65433UL) {
#line 412
    goto case_65430;
  }
#line 412
  if (keysym == 65431UL) {
#line 412
    goto case_65430;
  }
#line 435
  if (keysym == 65361UL) {
#line 435
    goto case_65361;
  }
#line 435
  if (keysym == 65363UL) {
#line 435
    goto case_65361;
  }
#line 435
  if (keysym == 65364UL) {
#line 435
    goto case_65361;
  }
#line 435
  if (keysym == 65362UL) {
#line 435
    goto case_65361;
  }
#line 516
  if (keysym == 65434UL) {
#line 516
    goto case_65434;
  }
#line 527
  if (keysym == 65365UL) {
#line 527
    goto case_65365;
  }
#line 533
  if (keysym == 65435UL) {
#line 533
    goto case_65435;
  }
#line 545
  if (keysym == 65366UL) {
#line 545
    goto case_65366;
  }
#line 550
  if (keysym == 65421UL) {
#line 550
    goto case_65421;
  }
#line 569
  if (keysym == 65437UL) {
#line 569
    goto case_65437;
  }
#line 588
  if (keysym == 65438UL) {
#line 588
    goto case_65438;
  }
#line 600
  if (keysym == 65379UL) {
#line 600
    goto case_65379;
  }
#line 606
  if (keysym == 65439UL) {
#line 606
    goto case_65439;
  }
#line 618
  if (keysym == 65535UL) {
#line 618
    goto case_65535;
  }
#line 657
  if (keysym == 65465UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65464UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65463UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65462UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65461UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65460UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65459UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65458UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65457UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65456UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65454UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65455UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65453UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65452UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65451UL) {
#line 657
    goto case_65465;
  }
#line 657
  if (keysym == 65450UL) {
#line 657
    goto case_65465;
  }
#line 693
  if (keysym == 65384UL) {
#line 693
    goto case_65384;
  }
#line 701
  if (keysym == 65378UL) {
#line 701
    goto case_65378;
  }
#line 705
  if (keysym == 65376UL) {
#line 705
    goto case_65376;
  }
#line 710
  if (keysym == 65436UL) {
#line 710
    goto case_65436;
  }
#line 723
  if (keysym == 65367UL) {
#line 723
    goto case_65367;
  }
#line 731
  if (keysym == 65429UL) {
#line 731
    goto case_65429;
  }
#line 743
  if (keysym == 65360UL) {
#line 743
    goto case_65360;
  }
#line 757
  if (keysym == 65428UL) {
#line 757
    goto case_65428;
  }
#line 757
  if (keysym == 65427UL) {
#line 757
    goto case_65428;
  }
#line 757
  if (keysym == 65426UL) {
#line 757
    goto case_65428;
  }
#line 757
  if (keysym == 65425UL) {
#line 757
    goto case_65428;
  }
#line 773
  if (keysym == 65473UL) {
#line 773
    goto case_65473;
  }
#line 773
  if (keysym == 65472UL) {
#line 773
    goto case_65473;
  }
#line 773
  if (keysym == 65471UL) {
#line 773
    goto case_65473;
  }
#line 773
  if (keysym == 65470UL) {
#line 773
    goto case_65473;
  }
#line 782
  if (keysym == 65474UL) {
#line 782
    goto case_65474;
  }
#line 791
  if (keysym == 65479UL) {
#line 791
    goto case_65479;
  }
#line 791
  if (keysym == 65478UL) {
#line 791
    goto case_65479;
  }
#line 791
  if (keysym == 65477UL) {
#line 791
    goto case_65479;
  }
#line 791
  if (keysym == 65476UL) {
#line 791
    goto case_65479;
  }
#line 791
  if (keysym == 65475UL) {
#line 791
    goto case_65479;
  }
#line 799
  if (keysym == 65483UL) {
#line 799
    goto case_65483;
  }
#line 799
  if (keysym == 65482UL) {
#line 799
    goto case_65483;
  }
#line 799
  if (keysym == 65481UL) {
#line 799
    goto case_65483;
  }
#line 799
  if (keysym == 65480UL) {
#line 799
    goto case_65483;
  }
#line 805
  if (keysym == 65485UL) {
#line 805
    goto case_65485;
  }
#line 805
  if (keysym == 65484UL) {
#line 805
    goto case_65485;
  }
#line 810
  if (keysym == 65386UL) {
#line 810
    goto case_65386;
  }
#line 815
  if (keysym == 65383UL) {
#line 815
    goto case_65383;
  }
#line 838
  if (keysym == 65504UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65503UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65502UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65501UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65500UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65499UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65498UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65497UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65496UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65495UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65494UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65493UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65492UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65491UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65490UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65489UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65488UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65487UL) {
#line 838
    goto case_65504;
  }
#line 838
  if (keysym == 65486UL) {
#line 838
    goto case_65504;
  }
#line 844
  goto switch_default;
  case_65288: /* CIL Label */ 
#line 313
  bsKbuf = kbuf___0;
#line 315
  if (meta) {
#line 315
    if ((int )(r->h)->meta_char == 27) {
#line 323
      tmp = bsKbuf;
#line 323
      bsKbuf ++;
#line 323
      *tmp = (unsigned char)27;
#line 324
      newlen ++;
#line 326
      meta = 0;
    }
  }
#line 329
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 8)) {
#line 331
    if (! (! ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 9))) ^ ! (! ctrl)) {
#line 331
      *(bsKbuf + 0) = (unsigned char )'\b';
    } else {
#line 331
      *(bsKbuf + 0) = (unsigned char )'\177';
    }
#line 334
    *(bsKbuf + 1) = (unsigned char )'\000';
  } else {
    {
#line 341
    strcpy((char */* __restrict  */)((char *)bsKbuf), (char const   */* __restrict  */)(r->h)->key_backspace);
    }
  }
#line 344
  if (meta) {
#line 345
    *bsKbuf = (unsigned char )((int )*bsKbuf | (int )(r->h)->meta_char);
  }
#line 361
  goto switch_break;
  case_65289: /* CIL Label */ 
#line 373
  if (shft) {
    {
#line 374
    strcpy((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[Z");
    }
  } else {
#line 385
    newlen = 0U;
  }
#line 387
  goto switch_break;
  case_65293: /* CIL Label */ 
#line 390
  newlen = 0U;
#line 392
  if ((int )(r->h)->meta_char == 128) {
#line 397
    tmp___0 = newlen;
#line 397
    newlen ++;
#line 397
    if (meta) {
#line 397
      *(kbuf___0 + tmp___0) = (unsigned char )((int )(r->h)->meta_char | 13);
    } else {
#line 397
      *(kbuf___0 + tmp___0) = (unsigned char)13;
    }
  } else {
#line 401
    if (meta) {
#line 402
      tmp___1 = newlen;
#line 402
      newlen ++;
#line 402
      *(kbuf___0 + tmp___1) = (unsigned char)27;
    }
#line 403
    tmp___2 = newlen;
#line 403
    newlen ++;
#line 403
    *(kbuf___0 + tmp___2) = (unsigned char)13;
  }
#line 405
  *(kbuf___0 + newlen) = (unsigned char )'\000';
#line 406
  goto switch_break;
  case_65430: /* CIL Label */ 
  case_65432: /* CIL Label */ 
  case_65433: /* CIL Label */ 
  case_65431: /* CIL Label */ 
#line 417
  if (r->numlock_state) {
#line 417
    shft = 0;
  }
#line 419
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 421
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )*("txvr" + (keysym - 65430UL)),
                      ctrl, meta, shft);
    }
#line 423
    goto switch_break;
  }
#line 427
  keysym = 65361UL + (keysym - 65430UL);
  case_65361: /* CIL Label */ 
  case_65363: /* CIL Label */ 
  case_65364: /* CIL Label */ 
  case_65362: /* CIL Label */ 
  {
#line 442
  set_xterm_key_seq(kbuf___0, "\033[", "\033[1;%d%c", (char )*("DACB" + (keysym - 65361UL)),
                    ctrl, meta, shft);
  }
#line 445
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 6)) {
#line 445
    if (! ctrl) {
#line 445
      if (! meta) {
#line 445
        if (! shft) {
#line 451
          *(kbuf___0 + 1) = (unsigned char )'O';
        }
      }
    }
  }
#line 512
  goto switch_break;
  case_65434: /* CIL Label */ 
#line 517
  if (r->numlock_state) {
#line 517
    shft = 0;
  }
#line 519
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 521
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'y', ctrl, meta, shft);
    }
#line 523
    goto switch_break;
  }
  case_65365: /* CIL Label */ 
  {
#line 528
  set_xterm_key_seq(kbuf___0, "\033[5", "\033[5;%d%c", (char )'~', ctrl, meta, shft);
  }
#line 529
  goto switch_break;
  case_65435: /* CIL Label */ 
#line 534
  if (r->numlock_state) {
#line 534
    shft = 0;
  }
#line 536
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 538
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'s', ctrl, meta, shft);
    }
#line 540
    goto switch_break;
  }
  case_65366: /* CIL Label */ 
  {
#line 546
  set_xterm_key_seq(kbuf___0, "\033[6", "\033[6;%d%c", (char )'~', ctrl, meta, shft);
  }
#line 547
  goto switch_break;
  case_65421: /* CIL Label */ 
#line 552
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
#line 552
    if (! r->numlock_state) {
#line 552
      goto _L;
    } else
#line 552
    if (ctrl) {
#line 552
      goto _L;
    } else
#line 552
    if (meta) {
#line 552
      goto _L;
    } else
#line 552
    if (shft) {
      _L: /* CIL Label */ 
#line 556
      if (r->numlock_state) {
#line 556
        shft = 0;
      }
      {
#line 558
      set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'M', ctrl, meta, shft);
      }
    } else {
#line 563
      *(kbuf___0 + 0) = (unsigned char )'\r';
#line 564
      *(kbuf___0 + 1) = (unsigned char )'\000';
    }
  } else {
#line 563
    *(kbuf___0 + 0) = (unsigned char )'\r';
#line 564
    *(kbuf___0 + 1) = (unsigned char )'\000';
  }
#line 566
  goto switch_break;
  case_65437: /* CIL Label */ 
#line 570
  if (r->numlock_state) {
#line 570
    shft = 0;
  }
#line 572
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 574
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'u', ctrl, meta, shft);
    }
  } else {
#line 579
    *(kbuf___0 + 0) = (unsigned char )'5';
#line 580
    *(kbuf___0 + 1) = (unsigned char )'\000';
  }
#line 583
  goto switch_break;
  case_65438: /* CIL Label */ 
#line 589
  if (r->numlock_state) {
#line 589
    shft = 0;
  }
#line 591
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 593
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'p', ctrl, meta, shft);
    }
#line 595
    goto switch_break;
  }
  case_65379: /* CIL Label */ 
  {
#line 601
  set_xterm_key_seq(kbuf___0, "\033[2", "\033[2;%d%c", (char )'~', ctrl, meta, shft);
  }
#line 602
  goto switch_break;
  case_65439: /* CIL Label */ 
#line 607
  if (r->numlock_state) {
#line 607
    shft = 0;
  }
#line 609
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 611
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'n', ctrl, meta, shft);
    }
#line 613
    goto switch_break;
  }
  case_65535: /* CIL Label */ 
  {
#line 620
  strcpy((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)(r->h)->key_delete);
  }
#line 638
  goto switch_break;
  case_65465: /* CIL Label */ 
  case_65464: /* CIL Label */ 
  case_65463: /* CIL Label */ 
  case_65462: /* CIL Label */ 
  case_65461: /* CIL Label */ 
  case_65460: /* CIL Label */ 
  case_65459: /* CIL Label */ 
  case_65458: /* CIL Label */ 
  case_65457: /* CIL Label */ 
  case_65456: /* CIL Label */ 
  case_65454: /* CIL Label */ 
  case_65455: /* CIL Label */ 
  case_65453: /* CIL Label */ 
  case_65452: /* CIL Label */ 
  case_65451: /* CIL Label */ 
  case_65450: /* CIL Label */ 
#line 666
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
#line 666
    if (! r->numlock_state) {
#line 666
      goto _L___0;
    } else
#line 666
    if (ctrl) {
#line 666
      goto _L___0;
    } else
#line 666
    if (meta) {
#line 666
      goto _L___0;
    } else
#line 666
    if (shft) {
      _L___0: /* CIL Label */ 
#line 669
      if (r->numlock_state) {
#line 681
        shft = 0;
      }
      {
#line 683
      set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )(106UL + (keysym - 65450UL)),
                        ctrl, meta, shft);
      }
    } else {
#line 688
      *(kbuf___0 + 0) = (unsigned char )(42UL + (keysym - 65450UL));
#line 689
      *(kbuf___0 + 1) = (unsigned char )'\000';
    }
  } else {
#line 688
    *(kbuf___0 + 0) = (unsigned char )(42UL + (keysym - 65450UL));
#line 689
    *(kbuf___0 + 1) = (unsigned char )'\000';
  }
#line 691
  goto switch_break;
  case_65384: /* CIL Label */ 
  {
#line 694
  set_xterm_key_seq(kbuf___0, "\033[1", "\033[1;%d%c", (char )'~', ctrl, meta, shft);
  }
#line 695
  goto switch_break;
  case_65378: /* CIL Label */ 
  {
#line 702
  set_xterm_key_seq(kbuf___0, "\033[3", "\033[3;%d%c", (char )'~', ctrl, meta, shft);
  }
#line 703
  goto switch_break;
  case_65376: /* CIL Label */ 
  {
#line 706
  set_xterm_key_seq(kbuf___0, "\033[4", "\033[4;%d%c", (char )'~', ctrl, meta, shft);
  }
#line 707
  goto switch_break;
  case_65436: /* CIL Label */ 
#line 711
  if (r->numlock_state) {
#line 711
    shft = 0;
  }
#line 713
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 715
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'q', ctrl, meta, shft);
    }
#line 717
    goto switch_break;
  }
  case_65367: /* CIL Label */ 
#line 724
  if ((unsigned long )r->Options[((1UL << 24) | 1UL) & 3UL] & (((1UL << 24) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 725
    set_xterm_key_seq(kbuf___0, "\033[4", "\033[4;%d%c", (char )'~', ctrl, meta, shft);
    }
  } else {
    {
#line 727
    set_xterm_key_seq(kbuf___0, "\033[8", "\033[8;%d%c", (char )'~', ctrl, meta, shft);
    }
  }
#line 728
  goto switch_break;
  case_65429: /* CIL Label */ 
#line 732
  if (r->numlock_state) {
#line 732
    shft = 0;
  }
#line 734
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 736
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )'w', ctrl, meta, shft);
    }
#line 738
    goto switch_break;
  }
  case_65360: /* CIL Label */ 
#line 744
  if ((unsigned long )r->Options[((1UL << 24) | 1UL) & 3UL] & (((1UL << 24) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 745
    set_xterm_key_seq(kbuf___0, "\033[1", "\033[1;%d%c", (char )'~', ctrl, meta, shft);
    }
  } else {
    {
#line 747
    set_xterm_key_seq(kbuf___0, "\033[7", "\033[7;%d%c", (char )'~', ctrl, meta, shft);
    }
  }
#line 748
  goto switch_break;
  case_65428: /* CIL Label */ 
  case_65427: /* CIL Label */ 
  case_65426: /* CIL Label */ 
  case_65425: /* CIL Label */ 
#line 760
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 7)) {
    {
#line 762
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )(80UL + (keysym - 65425UL)),
                      ctrl, meta, shft);
    }
#line 764
    goto switch_break;
  } else {
#line 767
    keysym = 65470UL + (keysym - 65425UL);
  }
  case_65473: /* CIL Label */ 
  case_65472: /* CIL Label */ 
  case_65471: /* CIL Label */ 
  case_65470: /* CIL Label */ 
#line 774
  if (0U == (unsigned int )(r->vts[r->tabBar.atab])->termenv) {
    {
#line 777
    set_xterm_key_seq(kbuf___0, "\033O", "\033O%d%c", (char )(80UL + (keysym - 65470UL)),
                      ctrl, meta, shft);
    }
#line 779
    goto switch_break;
  }
  case_65474: /* CIL Label */ 
  {
#line 783
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          11 + (int )(keysym - 65470UL));
#line 784
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 785
  goto switch_break;
  case_65479: /* CIL Label */ 
  case_65478: /* CIL Label */ 
  case_65477: /* CIL Label */ 
  case_65476: /* CIL Label */ 
  case_65475: /* CIL Label */ 
  {
#line 792
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          17 + (int )(keysym - 65475UL));
#line 793
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 794
  goto switch_break;
  case_65483: /* CIL Label */ 
  case_65482: /* CIL Label */ 
  case_65481: /* CIL Label */ 
  case_65480: /* CIL Label */ 
  {
#line 800
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          23 + (int )(keysym - 65480UL));
#line 801
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 802
  goto switch_break;
  case_65485: /* CIL Label */ 
  case_65484: /* CIL Label */ 
  {
#line 806
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          28 + (int )(keysym - 65484UL));
#line 807
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 808
  goto switch_break;
  case_65386: /* CIL Label */ 
  {
#line 811
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          28 + (int )(keysym - 65386UL));
#line 812
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 813
  goto switch_break;
  case_65383: /* CIL Label */ 
  {
#line 816
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          29 + (int )(keysym - 65383UL));
#line 817
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 818
  goto switch_break;
  case_65504: /* CIL Label */ 
  case_65503: /* CIL Label */ 
  case_65502: /* CIL Label */ 
  case_65501: /* CIL Label */ 
  case_65500: /* CIL Label */ 
  case_65499: /* CIL Label */ 
  case_65498: /* CIL Label */ 
  case_65497: /* CIL Label */ 
  case_65496: /* CIL Label */ 
  case_65495: /* CIL Label */ 
  case_65494: /* CIL Label */ 
  case_65493: /* CIL Label */ 
  case_65492: /* CIL Label */ 
  case_65491: /* CIL Label */ 
  case_65490: /* CIL Label */ 
  case_65489: /* CIL Label */ 
  case_65488: /* CIL Label */ 
  case_65487: /* CIL Label */ 
  case_65486: /* CIL Label */ 
  {
#line 839
  sprintf((char */* __restrict  */)((char *)kbuf___0), (char const   */* __restrict  */)"\033[%2d",
          31 + (int )(keysym - 65486UL));
#line 840
  set_xterm_key_seq(kbuf___0 + 4, "", ";%d%c", (char )'~', ctrl, meta, shft);
  }
#line 841
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 845
  newlen = 0U;
#line 846
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 853
  if (newlen) {
    {
#line 853
    tmp___3 = strlen((char const   *)kbuf___0);
#line 853
    tmp___4 = tmp___3;
    }
  } else {
#line 853
    tmp___4 = (size_t )-1;
  }
#line 853
  return ((int )tmp___4);
}
}
#line 869 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static KeySym accent  =    (KeySym )0;
#line 883 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static unsigned char kbuf[512]  ;
#line 863 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_keypress(rxvt_t *r , XKeyEvent *ev ) 
{ 
  int ctrl ;
  int meta ;
  int shft ;
  int len ;
  KeySym keysym ;
  register int idx ;
  KeySym dk ;
  KeySym dk___0 ;
  int tmp ;
  int newlen ;
  int tmp___0 ;
  unsigned char *ch ;
  unsigned char ch___0 ;
  int tmp___1 ;

  {
  {
#line 887
  shft = (int )(ev->state & 1U);
#line 888
  ctrl = (int )(ev->state & (unsigned int )(1 << 2));
#line 889
  meta = (int )(ev->state & (r->h)->ModMetaMask);
#line 909
  r->numlock_state = (int )(ev->state & (r->h)->ModNumLockMask);
#line 931
  len = XLookupString(ev, (char *)(kbuf), 512, & keysym, (XComposeStatus *)((void *)0));
  }
#line 937
  if (! len) {
#line 939
    if (keysym >= 256UL) {
#line 939
      if (keysym < 2048UL) {
#line 941
        kbuf[0] = (unsigned char )(keysym & 255UL);
#line 942
        kbuf[1] = (unsigned char )'\000';
#line 943
        len = 1;
      } else {
#line 946
        kbuf[0] = (unsigned char )'\000';
      }
    } else {
#line 946
      kbuf[0] = (unsigned char )'\000';
    }
  }
#line 959
  if (0UL != accent) {
#line 961
    if (! ctrl) {
#line 961
      if (! meta) {
#line 961
        if (65UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (97UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (67UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (99UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (69UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (101UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (73UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (105UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (78UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (110UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (79UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (111UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (85UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (117UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (89UL == keysym) {
#line 961
          goto _L___3;
        } else
#line 961
        if (121UL == keysym) {
          _L___3: /* CIL Label */ 
#line 976
          dk = (KeySym )0;
          {
#line 981
          if (accent == 65104UL) {
#line 981
            goto case_65104;
          }
#line 985
          if (accent == 65105UL) {
#line 985
            goto case_65105;
          }
#line 989
          if (accent == 65106UL) {
#line 989
            goto case_65106;
          }
#line 993
          if (accent == 65111UL) {
#line 993
            goto case_65111;
          }
#line 997
          if (accent == 65107UL) {
#line 997
            goto case_65107;
          }
#line 1001
          goto switch_default;
          case_65104: /* CIL Label */ 
#line 982
          dk = (KeySym )96;
#line 983
          goto switch_break;
          case_65105: /* CIL Label */ 
#line 986
          dk = (KeySym )180;
#line 987
          goto switch_break;
          case_65106: /* CIL Label */ 
#line 990
          dk = (KeySym )94;
#line 991
          goto switch_break;
          case_65111: /* CIL Label */ 
#line 994
          dk = (KeySym )34;
#line 995
          goto switch_break;
          case_65107: /* CIL Label */ 
#line 998
          dk = (KeySym )126;
#line 999
          goto switch_break;
          switch_default: /* CIL Label */ ;
          switch_break: /* CIL Label */ ;
          }
#line 1005
          idx = 0;
          {
#line 1005
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1005
            if (! (idx < (int )(sizeof(dkc_tab) / sizeof(DeadKeyChar )))) {
#line 1005
              goto while_break;
            }
#line 1007
            if (keysym == dkc_tab[idx].ks) {
#line 1007
              if (dk == dkc_tab[idx].dk) {
#line 1009
                kbuf[0] = (unsigned char )dkc_tab[idx].ach;
#line 1010
                goto while_break;
              }
            }
#line 1005
            idx ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 1015
          len = 1;
#line 1016
          accent = (KeySym )0;
        } else {
#line 961
          goto _L___4;
        }
      } else {
#line 961
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1018
    if (! ctrl) {
#line 1018
      if (! meta) {
#line 1018
        if (32UL == keysym) {
#line 1018
          goto _L___0;
        } else
#line 1018
        if (accent == keysym) {
          _L___0: /* CIL Label */ 
#line 1023
          dk___0 = (KeySym )0;
          {
#line 1032
          if (accent == 65104UL) {
#line 1032
            goto case_65104___0;
          }
#line 1036
          if (accent == 65105UL) {
#line 1036
            goto case_65105___0;
          }
#line 1040
          if (accent == 65106UL) {
#line 1040
            goto case_65106___0;
          }
#line 1044
          if (accent == 65111UL) {
#line 1044
            goto case_65111___0;
          }
#line 1048
          if (accent == 65107UL) {
#line 1048
            goto case_65107___0;
          }
#line 1052
          goto switch_default___0;
          case_65104___0: /* CIL Label */ 
#line 1033
          dk___0 = (KeySym )96;
#line 1033
          keysym = dk___0;
#line 1034
          goto switch_break___0;
          case_65105___0: /* CIL Label */ 
#line 1037
          dk___0 = (KeySym )39;
#line 1037
          keysym = dk___0;
#line 1038
          goto switch_break___0;
          case_65106___0: /* CIL Label */ 
#line 1041
          dk___0 = (KeySym )94;
#line 1041
          keysym = dk___0;
#line 1042
          goto switch_break___0;
          case_65111___0: /* CIL Label */ 
#line 1045
          dk___0 = (KeySym )34;
#line 1045
          keysym = dk___0;
#line 1046
          goto switch_break___0;
          case_65107___0: /* CIL Label */ 
#line 1049
          dk___0 = (KeySym )126;
#line 1049
          keysym = dk___0;
#line 1050
          goto switch_break___0;
          switch_default___0: /* CIL Label */ ;
          switch_break___0: /* CIL Label */ ;
          }
#line 1056
          kbuf[0] = (unsigned char )dk___0;
#line 1058
          len = 1;
#line 1059
          accent = (KeySym )0;
        } else {
#line 1018
          goto _L___1;
        }
      } else {
#line 1018
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1061
    if (! ctrl) {
#line 1061
      if (! meta) {
#line 1061
        if (0 == len) {
#line 1061
          if (! (65505UL == keysym)) {
#line 1061
            if (! (65506UL == keysym)) {
#line 1070
              accent = (KeySym )0;
            }
          }
        } else {
#line 1070
          accent = (KeySym )0;
        }
      } else {
#line 1070
        accent = (KeySym )0;
      }
    } else {
#line 1070
      accent = (KeySym )0;
    }
  }
  {
#line 1097
  tmp = rxvt_process_macros(r, keysym, ev);
  }
#line 1097
  if (tmp) {
#line 1098
    return;
  }
#line 1135
  if ((int )(r->vts[r->tabBar.atab])->hold > 1) {
#line 1138
    if (keysym) {
#line 1138
      if (len) {
        {
#line 1139
        rxvt_remove_page(r, r->tabBar.atab);
        }
      }
    }
#line 1140
    return;
  }
#line 1147
  if (keysym >= 65280UL) {
#line 1147
    if (keysym <= 65535UL) {
      {
#line 1149
      tmp___0 = rxvt_0xffxx_keypress(r, keysym, ctrl, meta, shft, kbuf);
#line 1149
      newlen = tmp___0;
      }
#line 1151
      if (-1 != newlen) {
#line 1152
        len = newlen;
      }
    } else {
#line 1147
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 1169
  if (ctrl) {
#line 1169
    if (keysym == 45UL) {
#line 1171
      len = 1;
#line 1172
      kbuf[0] = (unsigned char )'\037';
    } else {
#line 1169
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 1175
  if (shft) {
#line 1175
    if (keysym == 65056UL) {
      {
#line 1178
      strcpy((char */* __restrict  */)((char *)(kbuf)), (char const   */* __restrict  */)"\033[Z");
#line 1179
      len = 3;
      }
    } else {
#line 1175
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 1188
  if (! ctrl) {
#line 1188
    if (! meta) {
#line 1188
      if (keysym >= 65104UL) {
#line 1188
        if (keysym <= 65122UL) {
#line 1192
          if (65104UL == keysym) {
#line 1200
            len = 0;
#line 1201
            accent = keysym;
          } else
#line 1192
          if (65105UL == keysym) {
#line 1200
            len = 0;
#line 1201
            accent = keysym;
          } else
#line 1192
          if (65106UL == keysym) {
#line 1200
            len = 0;
#line 1201
            accent = keysym;
          } else
#line 1192
          if (65111UL == keysym) {
#line 1200
            len = 0;
#line 1201
            accent = keysym;
          } else
#line 1192
          if (65107UL == keysym) {
#line 1200
            len = 0;
#line 1201
            accent = keysym;
          }
        } else {
#line 1188
          goto _L___7;
        }
      } else {
#line 1188
        goto _L___7;
      }
    } else {
#line 1188
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 1214
  if (meta) {
#line 1225
    if ((int )(r->h)->meta_char == 128) {
#line 1229
      ch = kbuf;
      {
#line 1229
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1229
        if (! ((unsigned long )ch < (unsigned long )(kbuf + len))) {
#line 1229
          goto while_break___0;
        }
#line 1230
        *ch = (unsigned char )((int )*ch | 128);
#line 1229
        ch ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1232
      meta = 0;
    } else {
      {
#line 1237
      ch___0 = (unsigned char)27;
#line 1240
      rxvt_tt_write(r, (int )r->tabBar.atab, (unsigned char const   *)(& ch___0),
                    1);
      }
    }
  }
#line 1258
  if (len <= 0) {
#line 1261
    return;
  }
#line 1264
  if ((unsigned long )r->Options[(1UL << 15) & 3UL] & ((1UL << 15) & 0xfffffffffffffffcUL)) {
#line 1266
    if ((r->vts[r->tabBar.atab])->view_start) {
#line 1268
      (r->vts[r->tabBar.atab])->view_start = (uint16_t )0;
#line 1269
      (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
    }
  }
  {
#line 1286
  tmp___1 = strcmp("UTF-8", (char const   *)(r->h)->locale);
  }
#line 1286
  if (0 == tmp___1) {
    {
#line 1288
    rxvt_msg((uint32_t )3, (uint32_t )1, "UTF-8 string?");
    }
  }
  {
#line 1291
  rxvt_tt_write(r, (int )r->tabBar.atab, (unsigned char const   *)(kbuf), (int )((unsigned int )len));
  }
#line 1292
  return;
}
}
#line 1299 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_cmd_write(rxvt_t *r , int page , unsigned char const   *str , unsigned int count ) 
{ 
  unsigned int n ;
  unsigned int s ;
  unsigned char *cmdbuf_base ;
  unsigned char *cmdbuf_endp ;
  unsigned char *cmdbuf_ptr ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1304
  cmdbuf_base = (r->vts[page])->cmdbuf_base;
#line 1304
  cmdbuf_endp = (r->vts[page])->cmdbuf_endp;
#line 1304
  if ((r->vts[page])->cmdbuf_escstart) {
#line 1304
    tmp = (r->vts[page])->cmdbuf_escstart;
  } else {
#line 1304
    tmp = (r->vts[page])->cmdbuf_ptr;
  }
#line 1304
  cmdbuf_ptr = tmp;
#line 1310
  n = (unsigned int )(cmdbuf_ptr - cmdbuf_base);
#line 1311
  s = (unsigned int )((cmdbuf_base + 8191) - cmdbuf_endp);
#line 1317
  if (n > 0U) {
#line 1317
    if (s < count) {
      {
#line 1319
      memmove((void *)cmdbuf_base, (void const   *)cmdbuf_ptr, (size_t )((unsigned int )(cmdbuf_endp - cmdbuf_ptr)));
#line 1322
      cmdbuf_ptr -= n;
#line 1323
      cmdbuf_endp -= n;
#line 1324
      s += n;
      }
#line 1326
      if ((r->vts[page])->cmdbuf_escstart) {
#line 1327
        (r->vts[page])->cmdbuf_escstart -= n;
      }
#line 1328
      if ((r->vts[page])->cmdbuf_escfail) {
#line 1329
        (r->vts[page])->cmdbuf_escfail -= n;
      }
#line 1331
      (r->vts[page])->cmdbuf_ptr = cmdbuf_ptr;
    }
  }
#line 1334
  if (count > s) {
    {
#line 1336
    rxvt_msg((uint32_t )1, (uint32_t )1, "data loss: cmd_write too large");
#line 1337
    count = s;
    }
  }
  {
#line 1340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1340
    tmp___2 = count;
#line 1340
    count --;
#line 1340
    if (! tmp___2) {
#line 1340
      goto while_break;
    }
#line 1341
    tmp___0 = cmdbuf_endp;
#line 1341
    cmdbuf_endp ++;
#line 1341
    tmp___1 = str;
#line 1341
    str ++;
#line 1341
    *tmp___0 = (unsigned char )*tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  (r->vts[page])->cmdbuf_endp = cmdbuf_endp;
#line 1346
  return;
}
}
#line 1353 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_mark_dead_childs(rxvt_t *r ) 
{ 
  int i ;
  int j ;
  short ndead_childs ;
  int status ;
  int pid ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __pid_t tmp___3 ;

  {
#line 1357
  ndead_childs = r->ndead_childs;
#line 1365
  i = (int )r->tabBar.ltab;
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1365
    if (! (i >= 0)) {
#line 1365
      goto while_break;
    }
    {
#line 1369
    tmp = __errno_location();
#line 1369
    *tmp = 0;
    }
#line 1370
    if (! (r->vts[i])->dead) {
      {
#line 1370
      pid = waitpid((r->vts[i])->cmd_pid, & status, 1);
      }
#line 1370
      if (pid != 0) {
#line 1375
        if (pid == -1) {
          {
#line 1375
          tmp___0 = __errno_location();
          }
#line 1375
          if (*tmp___0 == 10) {
#line 1385
            (r->vts[i])->status = 0;
          } else {
#line 1390
            r->ndead_childs = (short )((int )r->ndead_childs - 1);
#line 1393
            ndead_childs = (short )((int )ndead_childs - 1);
#line 1396
            (r->vts[i])->status = status;
          }
        } else {
#line 1390
          r->ndead_childs = (short )((int )r->ndead_childs - 1);
#line 1393
          ndead_childs = (short )((int )ndead_childs - 1);
#line 1396
          (r->vts[i])->status = status;
        }
#line 1402
        (r->vts[i])->dead = (unsigned char)1;
#line 1403
        (r->vts[i])->hold = (unsigned char)1;
#line 1405
        r->cleanDeadChilds = (unsigned char)1;
      }
    }
#line 1365
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1414
  i = 0;
#line 1414
  j = 0;
  {
#line 1414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1414
    if (! (i < (int )r->nAsyncChilds)) {
#line 1414
      goto while_break___0;
    }
    {
#line 1416
    tmp___3 = waitpid((__pid_t )r->asyncChilds[i], (int *)((void *)0), 1);
    }
#line 1416
    if (tmp___3 != 0) {
#line 1418
      r->ndead_childs = (short )((int )r->ndead_childs - 1);
#line 1419
      ndead_childs = (short )((int )ndead_childs - 1);
#line 1421
      i ++;
    } else {
#line 1425
      tmp___1 = j;
#line 1425
      j ++;
#line 1425
      tmp___2 = i;
#line 1425
      i ++;
#line 1425
      r->asyncChilds[tmp___1] = r->asyncChilds[tmp___2];
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1427
  r->nAsyncChilds = (short )((int )r->nAsyncChilds - (i - j));
#line 1430
  if ((int )r->ndead_childs < 0) {
#line 1440
    r->ndead_childs = (short)0;
  } else
#line 1443
  if ((int )ndead_childs > 0) {
#line 1470
    r->ndead_childs = (short )((int )r->ndead_childs - (int )ndead_childs);
  }
#line 1474
  return;
}
}
#line 1485 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_clean_cmd_page(rxvt_t *r ) 
{ 
  int i ;
  int maxLen ;
  char const   *msg ;
  unsigned char *last_escfail ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *buffer ;
  unsigned long __lengthofbuffer ;
  void *tmp___1 ;
  int len ;
  size_t tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tabTitle ;
  unsigned long __lengthoftabTitle ;
  void *tmp___4 ;
  size_t tmp___5 ;
  union __anonunion_376___1 __constr_expr_5 ;
  union __anonunion_377___1 __constr_expr_6 ;

  {
#line 1491
  if (r->ndead_childs) {
    {
#line 1492
    rxvt_mark_dead_childs(r);
    }
  }
#line 1499
  if (! r->cleanDeadChilds) {
#line 1500
    return;
  }
#line 1511
  i = (int )r->tabBar.ltab;
  {
#line 1511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1511
    if (! (i >= 0)) {
#line 1511
      goto while_break;
    }
#line 1513
    if ((r->vts[i])->dead) {
#line 1513
      if ((int )(r->vts[i])->hold == 1) {
#line 1523
        if (1U & (unsigned int )(r->vts[i])->holdOption) {
#line 1523
          goto _L;
        } else
#line 1523
        if ((1U << 1) & (unsigned int )(r->vts[i])->holdOption) {
#line 1523
          __constr_expr_5.__in = (r->vts[i])->status;
#line 1523
          if ((__constr_expr_5.__i & 127) == 0) {
#line 1523
            goto _L___0;
          } else {
#line 1523
            goto _L;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1523
        if ((1U << 2) & (unsigned int )(r->vts[i])->holdOption) {
#line 1523
          __constr_expr_6.__in = (r->vts[i])->status;
#line 1523
          if ((__constr_expr_6.__i & 65280) >> 8 != 0) {
            _L: /* CIL Label */ 
#line 1525
            maxLen = 1024;
#line 1532
            (r->vts[i])->hold = (unsigned char )((int )(r->vts[i])->hold + 1);
            {
#line 1537
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1539
              last_escfail = (unsigned char *)((void *)0);
              {
#line 1544
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1544
                if (! ((unsigned long )(r->vts[i])->cmdbuf_ptr < (unsigned long )(r->vts[i])->cmdbuf_endp)) {
#line 1544
                  goto while_break___1;
                }
                {
#line 1546
                tmp = (r->vts[i])->cmdbuf_ptr;
#line 1546
                ((r->vts[i])->cmdbuf_ptr) ++;
#line 1546
                rxvt_process_getc(r, i, *tmp);
                }
#line 1549
                if ((r->vts[i])->cmdbuf_escfail) {
#line 1555
                  if ((unsigned long )((void *)0) == (unsigned long )last_escfail) {
#line 1556
                    last_escfail = (r->vts[i])->cmdbuf_escfail;
                  } else {
#line 1565
                    last_escfail = (unsigned char *)((void *)0);
#line 1566
                    (r->vts[i])->cmdbuf_escstart = (unsigned char *)((void *)0);
#line 1567
                    (r->vts[i])->cmdbuf_escfail = (unsigned char *)((void *)0);
#line 1570
                    ((r->vts[i])->cmdbuf_ptr) ++;
                  }
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 1578
              if ((unsigned long )(r->vts[i])->v_bufstr < (unsigned long )(r->vts[i])->v_bufptr) {
                {
#line 1579
                rxvt_cmd_write(r, i, (unsigned char const   *)((void *)0), 0U);
                }
              }
              {
#line 1582
              rxvt_check_cmdbuf(r, i);
#line 1585
              rxvt_read_child_cmdfd(r, i, (unsigned int )(8191L - ((r->vts[i])->cmdbuf_endp - (r->vts[i])->cmdbuf_base)));
#line 1537
              tmp___0 = rxvt_cmdbuf_has_input(r, i);
              }
#line 1537
              if (! tmp___0) {
#line 1537
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 1595
            msg = getProfileOption(r, (int )(r->vts[i])->profileNum, 369);
            }
#line 1597
            if ((unsigned long )((void *)0) != (unsigned long )msg) {
#line 1597
              if (*msg) {
                {
#line 1599
                __lengthofbuffer = (unsigned long )maxLen;
#line 1599
                tmp___1 = __builtin_alloca(sizeof(*buffer) * __lengthofbuffer);
#line 1599
                buffer = (unsigned char *)tmp___1;
#line 1602
                tmp___2 = strlen(msg);
#line 1602
                rxvt_percent_interpolate(r, i, msg, (int )tmp___2, (char *)buffer,
                                         maxLen);
#line 1605
                len = rxvt_str_escaped((char *)buffer);
#line 1607
                rxvt_cmd_write(r, i, (unsigned char const   *)buffer, (unsigned int )len);
                }
#line 1609
                if ((unsigned long )(r->vts[i])->cmdbuf_ptr < (unsigned long )(r->vts[i])->cmdbuf_endp) {
                  {
#line 1610
                  tmp___3 = (r->vts[i])->cmdbuf_ptr;
#line 1610
                  ((r->vts[i])->cmdbuf_ptr) ++;
#line 1610
                  rxvt_process_getc(r, i, *tmp___3);
                  }
                }
              }
            }
            {
#line 1616
            msg = getProfileOption(r, (int )(r->vts[i])->profileNum, 374);
            }
#line 1618
            if ((unsigned long )((void *)0) != (unsigned long )msg) {
#line 1618
              if (*msg) {
                {
#line 1620
                __lengthoftabTitle = (unsigned long )maxLen;
#line 1620
                tmp___4 = __builtin_alloca(sizeof(*tabTitle) * __lengthoftabTitle);
#line 1620
                tabTitle = (unsigned char *)tmp___4;
#line 1622
                tmp___5 = strlen(msg);
#line 1622
                rxvt_percent_interpolate(r, i, msg, (int )tmp___5, (char *)tabTitle,
                                         maxLen);
#line 1624
                rxvt_str_escaped((char *)tabTitle);
#line 1626
                rxvt_tabbar_set_title(r, (short )i, (unsigned char const   *)tabTitle);
                }
              }
            }
          } else {
            {
#line 1630
            rxvt_remove_page(r, (short )i);
            }
          }
        } else {
          {
#line 1630
          rxvt_remove_page(r, (short )i);
          }
        }
      }
    }
#line 1511
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1634
  r->cleanDeadChilds = (unsigned char)0;
#line 1635
  return;
}
}
#line 1640 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
__inline static int rxvt_cmdbuf_has_input(rxvt_t *r , int page ) 
{ 
  int tmp ;

  {
#line 1643
  if ((r->vts[page])->cmdbuf_escfail) {
#line 1643
    tmp = (unsigned long )(r->vts[page])->cmdbuf_escfail < (unsigned long )(r->vts[page])->cmdbuf_endp;
  } else {
#line 1643
    tmp = (unsigned long )(r->vts[page])->cmdbuf_ptr < (unsigned long )(r->vts[page])->cmdbuf_endp;
  }
#line 1643
  return (tmp);
}
}
#line 1659 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static int lastProcessed  =    0;
#line 1655 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_find_cmd_child(rxvt_t *r ) 
{ 
  register int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1666
  tmp = rxvt_cmdbuf_has_input(r, (int )r->tabBar.atab);
  }
#line 1666
  if (tmp) {
#line 1667
    return ((int )r->tabBar.atab);
  }
#line 1673
  if (lastProcessed > (int )r->tabBar.ltab) {
#line 1674
    lastProcessed = (int )r->tabBar.ltab;
  }
#line 1677
  k = lastProcessed + 1;
  {
#line 1679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1681
    if (k > (int )r->tabBar.ltab) {
#line 1682
      k = 0;
    }
    {
#line 1687
    tmp___0 = rxvt_cmdbuf_has_input(r, k);
    }
#line 1687
    if (tmp___0) {
#line 1689
      lastProcessed = k;
#line 1690
      return (k);
    }
#line 1679
    tmp___1 = k;
#line 1679
    k ++;
#line 1679
    if (! (tmp___1 != lastProcessed)) {
#line 1679
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1696
  return (-1);
}
}
#line 1701 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_check_cmdbuf(rxvt_t *r , int page ) 
{ 
  unsigned char *tmp ;
  unsigned char *start ;
  unsigned int n ;
  unsigned int len ;
  int tmp___0 ;

  {
#line 1706
  if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->cmdbuf_escstart) {
#line 1706
    if ((unsigned long )(r->vts[page])->cmdbuf_ptr == (unsigned long )(r->vts[page])->cmdbuf_endp) {
#line 1715
      tmp = (r->vts[page])->cmdbuf_base;
#line 1715
      (r->vts[page])->cmdbuf_endp = tmp;
#line 1715
      (r->vts[page])->cmdbuf_ptr = tmp;
    } else {
#line 1706
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1720
  if ((r->vts[page])->cmdbuf_endp - (r->vts[page])->cmdbuf_base == 8191L) {
#line 1720
    if ((r->vts[page])->cmdbuf_escstart) {
#line 1720
      tmp___0 = (unsigned long )(r->vts[page])->cmdbuf_escstart > (unsigned long )((r->vts[page])->cmdbuf_base);
    } else {
#line 1720
      tmp___0 = (unsigned long )(r->vts[page])->cmdbuf_ptr > (unsigned long )((r->vts[page])->cmdbuf_base);
    }
#line 1720
    if (tmp___0) {
#line 1737
      if ((r->vts[page])->cmdbuf_escstart) {
#line 1737
        start = (r->vts[page])->cmdbuf_escstart;
      } else {
#line 1737
        start = (r->vts[page])->cmdbuf_ptr;
      }
      {
#line 1741
      n = (unsigned int )(start - (r->vts[page])->cmdbuf_base);
#line 1742
      len = (unsigned int )((r->vts[page])->cmdbuf_endp - start);
#line 1747
      memmove((void *)((r->vts[page])->cmdbuf_base), (void const   *)start, (size_t )len);
#line 1749
      (r->vts[page])->cmdbuf_ptr -= n;
#line 1750
      (r->vts[page])->cmdbuf_endp -= n;
      }
#line 1751
      if ((r->vts[page])->cmdbuf_escstart) {
#line 1752
        (r->vts[page])->cmdbuf_escstart -= n;
      }
#line 1753
      if ((r->vts[page])->cmdbuf_escfail) {
#line 1754
        (r->vts[page])->cmdbuf_escfail -= n;
      }
    }
  }
#line 1756
  return;
}
}
#line 1763 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_read_child_cmdfd(rxvt_t *r , int page , unsigned int count ) 
{ 
  int n ;
  int bread ;
  struct timeval tp ;
  int readErrno ;
  int *tmp ;
  unsigned char tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  unsigned char tmp___3 ;

  {
#line 1766
  n = 0;
#line 1766
  bread = 0;
  {
#line 1769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1769
    if (! count) {
#line 1769
      goto while_break;
    }
    {
#line 1779
    tmp = __errno_location();
#line 1779
    tmp___0 = (unsigned char)0;
#line 1779
    (r->vts[page])->gotEIO = tmp___0;
#line 1779
    *tmp = (int )tmp___0;
#line 1780
    tmp___1 = read((r->vts[page])->cmd_fd, (void *)(r->vts[page])->cmdbuf_endp, (size_t )count);
#line 1780
    n = (int )tmp___1;
#line 1781
    tmp___2 = __errno_location();
#line 1781
    readErrno = *tmp___2;
    }
#line 1785
    if (n > 0) {
#line 1788
      count -= (unsigned int )n;
#line 1789
      bread += n;
#line 1790
      (r->vts[page])->cmdbuf_endp += n;
    } else
#line 1793
    if (0 == n) {
#line 1797
      goto while_break;
    } else {
      {
#line 1814
      if (readErrno == 5) {
#line 1814
        goto case_5;
      }
#line 1816
      if (readErrno == 4) {
#line 1816
        goto case_4;
      }
#line 1812
      goto switch_break;
      case_5: /* CIL Label */ 
#line 1815
      tmp___3 = (unsigned char)1;
#line 1815
      (r->vts[page])->gotEIO = tmp___3;
#line 1815
      r->gotEIO = tmp___3;
      case_4: /* CIL Label */ 
      {
#line 1817
      rxvt_mark_dead_childs(r);
      }
#line 1818
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1825
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1830
  if (bread != 0) {
    {
#line 1832
    gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
    }
  }
#line 1836
  (r->vts[page])->monitor_nbytes_read += bread;
#line 1837
  (r->vts[page])->nbytes_last_read = bread;
#line 1838
  return (bread);
}
}
#line 1842 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_monitor_tab(rxvt_t *r , int i ) 
{ 
  struct timeval tp ;
  struct timeval monitor_timeout_time ;
  short execute_action ;
  int monitor_timeout ;
  int tmp ;
  int tmp___0 ;
  int maxLen ;
  char *expstr ;
  unsigned long __lengthofexpstr ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1848
  execute_action = (short)0;
#line 1849
  monitor_timeout = 2000;
#line 1852
  if ((unsigned long )((void *)0) == (unsigned long )(& (r->vts[i])->monitor_tab)) {
#line 1855
    return;
  } else
#line 1852
  if ((int )(r->vts[i])->monitor_tab == 0) {
#line 1855
    return;
  } else
#line 1852
  if ((int )(r->vts[i])->monitor_tab == 4) {
#line 1855
    return;
  }
#line 1857
  monitor_timeout_time = (r->vts[i])->monitor_start;
#line 1859
  if ((r->h)->rs[312]) {
    {
#line 1860
    monitor_timeout = atoi((r->h)->rs[312]);
    }
  }
  {
#line 1862
  monitor_timeout_time.tv_sec += (__time_t )(monitor_timeout / 1000);
#line 1863
  monitor_timeout_time.tv_usec += (__suseconds_t )((monitor_timeout - (monitor_timeout / 1000) * 1000) * 1000);
#line 1867
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
  }
#line 1870
  if ((int )(r->vts[i])->monitor_tab == 3) {
#line 1870
    if (monitor_timeout_time.tv_sec == tp.tv_sec) {
#line 1870
      tmp___0 = monitor_timeout_time.tv_usec < tp.tv_usec;
    } else {
#line 1870
      tmp___0 = monitor_timeout_time.tv_sec < tp.tv_sec;
    }
#line 1870
    if (tmp___0) {
#line 1873
      if ((r->vts[i])->monitor_nbytes_read > 0) {
        {
#line 1875
        (r->vts[i])->monitor_tab = (short)2;
#line 1876
        rxvt_msg((uint32_t )3, (uint32_t )64, "Macro MonitorTab: decided to monitor inactivity on tab %i",
                 i);
        }
      } else {
        {
#line 1882
        (r->vts[i])->monitor_tab = (short)1;
#line 1883
        rxvt_msg((uint32_t )3, (uint32_t )64, "Macro MonitorTab: decided to monitor activity on tab %i",
                 i);
        }
      }
#line 1886
      (r->vts[i])->monitor_nbytes_read = 0;
#line 1887
      (r->vts[i])->monitor_start = tp;
    } else {
#line 1870
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1890
  if ((int )(r->vts[i])->monitor_tab == 2) {
#line 1890
    if (monitor_timeout_time.tv_sec == tp.tv_sec) {
#line 1890
      tmp = monitor_timeout_time.tv_usec < tp.tv_usec;
    } else {
#line 1890
      tmp = monitor_timeout_time.tv_sec < tp.tv_sec;
    }
#line 1890
    if (tmp) {
#line 1894
      if ((r->vts[i])->monitor_nbytes_read == 0) {
        {
#line 1896
        rxvt_msg((uint32_t )3, (uint32_t )64, "Macro MonitorTab: detected inactivity on tab %i",
                 i);
#line 1898
        execute_action = (short)1;
        }
      } else {
        {
#line 1903
        rxvt_msg((uint32_t )5, (uint32_t )64, "Macro MonitorTab: NOT detected inactivity on tab %i / %i ",
                 i, (r->vts[i])->monitor_nbytes_read);
#line 1906
        (r->vts[i])->monitor_start = tp;
#line 1907
        (r->vts[i])->monitor_nbytes_read = 0;
        }
      }
    } else {
#line 1890
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1911
  if ((int )(r->vts[i])->monitor_tab == 1) {
#line 1911
    if ((r->vts[i])->monitor_nbytes_read != 0) {
      {
#line 1914
      rxvt_msg((uint32_t )3, (uint32_t )64, "Macro MonitorTab: detected activity on tab %i",
               i);
#line 1916
      execute_action = (short)1;
      }
    }
  }
#line 1922
  if ((int )execute_action == 0) {
#line 1923
    return;
  }
  {
#line 1925
  maxLen = 1024;
#line 1926
  __lengthofexpstr = (unsigned long )maxLen;
#line 1926
  tmp___1 = __builtin_alloca(sizeof(*expstr) * __lengthofexpstr);
#line 1926
  expstr = (char *)tmp___1;
  }
#line 1929
  if ((r->h)->rs[311]) {
#line 1929
    if (*((r->h)->rs[311])) {
      {
#line 1932
      tmp___2 = strlen((r->h)->rs[311]);
#line 1932
      rxvt_percent_interpolate(r, i, (char const   *)((char *)(r->h)->rs[311]), (int )tmp___2,
                               expstr, maxLen);
#line 1935
      rxvt_async_exec(r, (char const   *)expstr);
      }
    }
  }
  {
#line 1939
  rxvt_scr_bell(r, i);
#line 1942
  rxvt_tabbar_highlight_tab(r, (short )i, 0);
  }
#line 1945
  if ((int )r->tabBar.atab != i) {
#line 1947
    (r->vts[i])->monitor_tab = (short)4;
  } else {
#line 1951
    (r->vts[i])->monitor_tab = (short)0;
  }
#line 1964
  if ((r->h)->am_transparent) {
#line 1964
    goto _L___1;
  } else
#line 1964
  if ((r->h)->am_pixmap_trans) {
    _L___1: /* CIL Label */ 
#line 1964
    if ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL)) {
#line 1967
      (r->vts[i])->monitor_tab = (short)0;
    }
  }
  {
#line 1973
  rxvt_tabbar_expose(r, (XEvent *)((void *)0));
  }
#line 1974
  return;
}
}
#line 1978 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_children_cmdfd(rxvt_t *r , fd_set *p_readfds ) 
{ 
  register int i ;
  unsigned int count ;
  unsigned int bufsiz ;
  int tmp ;

  {
#line 1987
  i = 0;
  {
#line 1987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1987
    if (! (i <= (int )r->tabBar.ltab)) {
#line 1987
      goto while_break;
    }
    {
#line 1992
    rxvt_monitor_tab(r, i);
    }
#line 1995
    if (! ((p_readfds->fds_bits[(r->vts[i])->cmd_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << (r->vts[i])->cmd_fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 1997
      (r->vts[i])->nbytes_last_read = 0;
#line 1998
      (r->vts[i])->scrolled_lines = 0;
#line 1999
      goto __Cont;
    }
    {
#line 2005
    rxvt_check_cmdbuf(r, i);
#line 2008
    bufsiz = (unsigned int )(8191L - ((r->vts[i])->cmdbuf_endp - (r->vts[i])->cmdbuf_base));
#line 2008
    count = bufsiz;
#line 2012
    tmp = rxvt_read_child_cmdfd(r, i, count);
#line 2012
    count -= (unsigned int )tmp;
    }
#line 2021
    if (! ((unsigned long )r->Options[((1UL << 25) | 1UL) & 3UL] & (((1UL << 25) | 1UL) & 0xfffffffffffffffcUL))) {
#line 2021
      if (bufsiz != count) {
#line 2021
        if (i != (int )r->tabBar.atab) {
          {
#line 2027
          rxvt_tabbar_highlight_tab(r, (short )i, 0);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2030
  return;
}
}
#line 2035 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_check_quick_timeout(rxvt_t *r ) 
{ 
  struct rxvt_hidden *h ;
  int quick_timeout ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2038
  h = r->h;
#line 2039
  quick_timeout = 0;
#line 2060
  if (h->pending_scroll_selection) {
#line 2062
    quick_timeout = 1;
#line 2064
    tmp = h->scroll_selection_delay;
#line 2064
    (h->scroll_selection_delay) --;
#line 2064
    if (! tmp) {
      {
#line 2064
      tmp___0 = rxvt_scr_page(r, (int )r->tabBar.atab, h->scroll_selection_dir, h->scroll_selection_lines);
      }
#line 2064
      if (tmp___0) {
        {
#line 2068
        rxvt_selection_extend(r, (int )r->tabBar.atab, h->selection_save_x, h->selection_save_y,
                              h->selection_save_state);
#line 2070
        h->scroll_selection_delay = 2;
#line 2071
        h->refresh_type = (unsigned char )((int )h->refresh_type | (1 << 2));
#line 2072
        (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
        }
      }
    }
  }
#line 2079
  if ((int )r->scrollBar.state == 85) {
#line 2079
    goto _L;
  } else
#line 2079
  if ((int )r->scrollBar.state == 68) {
    _L: /* CIL Label */ 
#line 2081
    quick_timeout = 1;
#line 2083
    tmp___1 = h->scroll_arrow_delay;
#line 2083
    (h->scroll_arrow_delay) --;
#line 2083
    if (! tmp___1) {
#line 2083
      if ((int )r->scrollBar.state == 85) {
#line 2083
        tmp___2 = 0;
      } else {
#line 2083
        tmp___2 = 1;
      }
      {
#line 2083
      tmp___3 = rxvt_scr_page(r, (int )r->tabBar.atab, (enum page_dirn )tmp___2, 1);
      }
#line 2083
      if (tmp___3) {
#line 2086
        h->scroll_arrow_delay = 2;
#line 2087
        h->refresh_type = (unsigned char )((int )h->refresh_type | (1 << 2));
#line 2088
        (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
      }
    }
  }
#line 2094
  return (quick_timeout);
}
}
#line 2099 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_adjust_quick_timeout(rxvt_t *r , int quick_timeout , struct timeval *value ) 
{ 
  struct rxvt_hidden *h ;
  struct timeval tp ;
  int set_quick_timeout ;
  int32_t fsdiff ;
  int tmp ;
  int32_t csdiff ;
  int32_t psdiff ;
  int32_t bsdiff ;
  int tmp___0 ;
  int32_t pdelay ;

  {
#line 2102
  h = r->h;
#line 2104
  set_quick_timeout = 0;
#line 2105
  fsdiff = (int32_t )60000000L;
#line 2109
  value->tv_usec = (__suseconds_t )10000;
#line 2110
  value->tv_sec = (__time_t )0;
#line 2113
  if (! r->TermWin.mapped) {
#line 2114
    quick_timeout = 0;
  } else
#line 2113
  if ((int )(r->h)->refresh_type == 0) {
#line 2114
    quick_timeout = 0;
  } else {
#line 2117
    if ((r->vts[r->tabBar.atab])->want_refresh) {
#line 2117
      tmp = 1;
    } else
#line 2117
    if (h->want_clip_refresh) {
#line 2117
      tmp = 1;
    } else {
#line 2117
      tmp = 0;
    }
#line 2117
    quick_timeout |= tmp;
#line 2119
    quick_timeout |= (int )h->want_full_refresh;
  }
#line 2127
  bsdiff = (int32_t )60000000L;
#line 2127
  psdiff = bsdiff;
#line 2127
  csdiff = psdiff;
#line 2131
  if (h->lastCNotify.tv_sec) {
    {
#line 2133
    gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 2134
    bsdiff = (int32_t )(((tp.tv_sec - h->lastCNotify.tv_sec) * 1000000L + tp.tv_usec) - h->lastCNotify.tv_usec);
    }
#line 2137
    if ((unsigned long )bsdiff > h->bgRefreshInterval) {
#line 2139
      bsdiff = 0;
#line 2140
      h->lastCNotify.tv_sec = (__time_t )0;
#line 2143
      if (! (r->h)->bgGrabbed) {
#line 2143
        goto _L;
      } else
#line 2143
      if ((int )(r->h)->prevPos.x != r->szHint.x) {
#line 2143
        goto _L;
      } else
#line 2143
      if ((int )(r->h)->prevPos.y != r->szHint.y) {
#line 2143
        goto _L;
      } else
#line 2143
      if ((int )(r->h)->prevPos.width != r->szHint.width) {
#line 2143
        goto _L;
      } else
#line 2143
      if ((int )(r->h)->prevPos.height != r->szHint.height) {
        _L: /* CIL Label */ 
        {
#line 2143
        tmp___0 = rxvt_check_our_parents(r);
        }
#line 2143
        if (tmp___0) {
#line 2150
          h->want_full_refresh = (unsigned char)1;
        }
      }
    } else {
#line 2154
      bsdiff = (int32_t )(h->bgRefreshInterval - (unsigned long )bsdiff);
    }
#line 2158
    set_quick_timeout = 1;
  }
#line 2166
  if ((unsigned long )r->Options[(1UL << 22) & 3UL] & ((1UL << 22) & 0xfffffffffffffffcUL)) {
#line 2166
    if (r->TermWin.focus) {
      {
#line 2169
      gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 2171
      csdiff = (int32_t )(((tp.tv_sec - h->lastcursorchange.tv_sec) * 1000000L + tp.tv_usec) - h->lastcursorchange.tv_usec);
      }
#line 2173
      if ((long )csdiff > h->blinkInterval) {
#line 2176
        h->lastcursorchange.tv_sec = tp.tv_sec;
#line 2177
        h->lastcursorchange.tv_usec = tp.tv_usec;
#line 2178
        h->hidden_cursor = (unsigned char )(! h->hidden_cursor);
#line 2181
        (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
#line 2182
        csdiff = 0;
      } else {
#line 2185
        csdiff = (int32_t )(h->blinkInterval - (long )csdiff);
      }
#line 2186
      set_quick_timeout = 1;
    }
  }
#line 2194
  if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 2194
    if (h->pointerBlankDelay > 0) {
#line 2194
      if (0 == (int )(r->vts[r->tabBar.atab])->hidden_pointer) {
        {
#line 2201
        gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 2202
        psdiff = (int32_t )(((tp.tv_sec - h->lastmotion.tv_sec) * 1000000L + tp.tv_usec) - h->lastmotion.tv_usec);
#line 2204
        pdelay = (int32_t )((long )h->pointerBlankDelay * 1000000L);
        }
#line 2206
        if (psdiff >= pdelay) {
          {
#line 2207
          rxvt_pointer_blank(r, (int )r->tabBar.atab);
          }
        } else {
#line 2210
          set_quick_timeout = 1;
#line 2211
          psdiff = pdelay - psdiff;
        }
      }
    }
  }
#line 2215
  if (! quick_timeout) {
#line 2215
    if (set_quick_timeout) {
#line 2217
      if (fsdiff < csdiff) {
#line 2217
        csdiff = fsdiff;
      }
#line 2218
      if (bsdiff < csdiff) {
#line 2218
        csdiff = bsdiff;
      }
#line 2219
      if (psdiff < csdiff) {
#line 2219
        csdiff = psdiff;
      }
#line 2220
      value->tv_sec = (long )csdiff / 1000000L;
#line 2221
      value->tv_usec = (long )csdiff % 1000000L;
#line 2222
      quick_timeout = 1;
    }
  }
#line 2227
  quick_timeout |= (int )r->gotEIO;
#line 2228
  r->gotEIO = (unsigned char)0;
#line 2230
  return (quick_timeout);
}
}
#line 2236 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_refresh_vtscr_if_needed(rxvt_t *r ) 
{ 


  {
#line 2240
  if ((r->h)->want_full_refresh) {
    {
#line 2243
    (r->h)->want_full_refresh = (unsigned char)0;
#line 2246
    rxvt_scr_clear(r, (int )r->tabBar.atab);
#line 2247
    rxvt_scr_touch(r, (int )r->tabBar.atab, 0);
#line 2248
    (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
    }
  }
#line 2255
  if ((r->vts[r->tabBar.atab])->want_refresh) {
#line 2256
    (r->h)->refresh_type = (unsigned char )((int )(r->h)->refresh_type & ~ (1 << 4));
  }
#line 2258
  if ((r->vts[r->tabBar.atab])->want_refresh) {
#line 2258
    goto _L;
  } else
#line 2258
  if ((r->h)->want_clip_refresh) {
    _L: /* CIL Label */ 
#line 2258
    if ((r->vts[r->tabBar.atab])->mapped) {
#line 2258
      if ((int )(r->h)->refresh_type != 0) {
        {
#line 2265
        rxvt_scr_refresh(r, (int )r->tabBar.atab, (r->h)->refresh_type);
#line 2268
        rxvt_scrollbar_update(r, 1);
        }
      }
    }
  }
#line 2276
  return;
}
}
#line 2294 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
unsigned char rxvt_cmd_getc(rxvt_t *r , int *p_page ) 
{ 
  int selpage ;
  int retpage ;
  fd_set readfds ;
  int quick_timeout ;
  int select_res ;
  int want_motion_time ;
  int want_keypress_time ;
  struct timeval tp ;
  struct timeval value ;
  struct rxvt_hidden *h ;
  register int i ;
  XEvent xev ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int __d0 ;
  int __d1 ;
  struct timeval *tmp___4 ;
  ssize_t len ;
  int nbytes ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char astr[512] ;
  char *fptr ;
  char *aptr ;
  action_t action ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;

  {
#line 2297
  selpage = *p_page;
#line 2301
  want_motion_time = 0;
#line 2304
  want_keypress_time = 0;
#line 2310
  h = r->h;
  {
#line 2318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2321
    i = 0;
    {
#line 2321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2321
      if (! (i <= (int )r->tabBar.ltab)) {
#line 2321
        goto while_break___0;
      }
      {
#line 2322
      rxvt_monitor_tab(r, i);
#line 2321
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2326
    tp.tv_usec = (__suseconds_t )0;
#line 2326
    tp.tv_sec = tp.tv_usec;
#line 2329
    want_keypress_time = 0;
#line 2332
    if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 2333
      want_motion_time = 0;
    }
#line 2337
    if (selpage == -1) {
      {
#line 2340
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 2340
        tmp = XPending(r->Xdisplay);
        }
#line 2340
        if (! tmp) {
#line 2340
          goto while_break___1;
        }
        {
#line 2344
        XNextEvent(r->Xdisplay, & xev);
        }
#line 2348
        if ((unsigned long )r->Options[(1UL << 22) & 3UL] & ((1UL << 22) & 0xfffffffffffffffcUL)) {
#line 2348
          if (2 == xev.type) {
#line 2351
            if (h->hidden_cursor) {
#line 2354
              h->hidden_cursor = (unsigned char)0;
#line 2355
              (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
            }
#line 2357
            want_keypress_time = 1;
          }
        }
#line 2362
        if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 2362
          if (h->pointerBlankDelay > 0) {
#line 2365
            if (6 == xev.type) {
#line 2365
              goto _L;
            } else
#line 2365
            if (4 == xev.type) {
#line 2365
              goto _L;
            } else
#line 2365
            if (5 == xev.type) {
              _L: /* CIL Label */ 
#line 2370
              if ((r->vts[r->tabBar.atab])->hidden_pointer) {
                {
#line 2371
                rxvt_pointer_unblank(r, (int )r->tabBar.atab);
                }
              }
#line 2372
              want_motion_time = 1;
            }
#line 2375
            if (2 == xev.type) {
#line 2375
              if (! (r->vts[r->tabBar.atab])->hidden_pointer) {
                {
#line 2376
                rxvt_pointer_blank(r, (int )r->tabBar.atab);
                }
              }
            }
          }
        }
        {
#line 2390
        rxvt_process_x_event(r, & xev);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 2395
    if (! (r->vts[selpage])->dead) {
      {
#line 2395
      tmp___0 = XPending(r->Xdisplay);
      }
#line 2395
      if (tmp___0) {
#line 2404
        *p_page = -1;
#line 2405
        return ((unsigned char)0);
      }
    }
#line 2414
    if (selpage != -1) {
      {
#line 2414
      tmp___2 = rxvt_cmdbuf_has_input(r, selpage);
      }
#line 2414
      if (tmp___2) {
#line 2415
        tmp___1 = (r->vts[selpage])->cmdbuf_ptr;
#line 2415
        ((r->vts[selpage])->cmdbuf_ptr) ++;
#line 2415
        return (*tmp___1);
      }
    }
#line 2417
    if (selpage == -1) {
      {
#line 2417
      retpage = rxvt_find_cmd_child(r);
      }
#line 2417
      if (-1 != retpage) {
#line 2426
        *p_page = retpage;
#line 2427
        tmp___3 = (r->vts[*p_page])->cmdbuf_ptr;
#line 2427
        ((r->vts[*p_page])->cmdbuf_ptr) ++;
#line 2427
        return (*tmp___3);
      }
    }
#line 2436
    if (want_keypress_time) {
      {
#line 2439
      gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 2441
      h->lastcursorchange.tv_sec = tp.tv_sec;
#line 2442
      h->lastcursorchange.tv_usec = tp.tv_usec;
      }
    }
#line 2447
    if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 2447
      if (want_motion_time) {
        {
#line 2449
        gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 2450
        h->lastmotion.tv_sec = tp.tv_sec;
#line 2451
        h->lastmotion.tv_usec = tp.tv_usec;
        }
      }
    }
    {
#line 2455
    quick_timeout = rxvt_check_quick_timeout(r);
#line 2456
    quick_timeout = rxvt_adjust_quick_timeout(r, quick_timeout, & value);
    }
    {
#line 2464
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2464
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.fds_bits[0]): "memory");
#line 2464
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2465
    readfds.fds_bits[r->Xfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << r->Xfd % (8 * (int )sizeof(__fd_mask ));
#line 2467
    i = 0;
    {
#line 2467
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2467
      if (! (i <= (int )r->tabBar.ltab)) {
#line 2467
        goto while_break___3;
      }
#line 2470
      if ((int )(r->vts[i])->hold > 1) {
#line 2474
        goto __Cont;
      } else
#line 2476
      if ((r->vts[i])->gotEIO) {
#line 2480
        (r->vts[i])->gotEIO = (unsigned char)0;
#line 2481
        goto __Cont;
      }
#line 2487
      readfds.fds_bits[(r->vts[i])->cmd_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << (r->vts[i])->cmd_fd % (8 * (int )sizeof(__fd_mask ));
#line 2490
      if ((unsigned long )(r->vts[i])->v_bufstr < (unsigned long )(r->vts[i])->v_bufptr) {
        {
#line 2491
        rxvt_tt_write(r, i, (unsigned char const   *)((void *)0), 0);
        }
      }
      __Cont: /* CIL Label */ 
#line 2467
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2495
    if (-1 != r->TermWin.ice_fd) {
#line 2496
      readfds.fds_bits[r->TermWin.ice_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << r->TermWin.ice_fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 2500
    if (r->fifo_fd != -1) {
#line 2501
      readfds.fds_bits[r->fifo_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << r->fifo_fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 2509
    if (quick_timeout) {
#line 2509
      tmp___4 = & value;
    } else {
#line 2509
      tmp___4 = (struct timeval *)((void *)0);
    }
    {
#line 2509
    select_res = select(r->num_fds, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp___4);
    }
#line 2516
    if (select_res > 0) {
      {
#line 2528
      rxvt_process_children_cmdfd(r, & readfds);
      }
#line 2537
      if (-1 != r->TermWin.ice_fd) {
#line 2537
        if ((readfds.fds_bits[r->TermWin.ice_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << r->TermWin.ice_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 2541
          rxvt_process_ice_msgs(r);
          }
        }
      }
#line 2545
      if (-1 != r->fifo_fd) {
#line 2545
        if ((readfds.fds_bits[r->fifo_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << r->fifo_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 2550
          nbytes = (int )((sizeof(r->fifo_buf) - (unsigned long )(r->fbuf_ptr - r->fifo_buf)) - 1UL);
#line 2553
          tmp___6 = __errno_location();
#line 2553
          *tmp___6 = 0;
#line 2554
          len = read(r->fifo_fd, (void *)r->fbuf_ptr, (size_t )nbytes);
#line 2556
          tmp___9 = __errno_location();
          }
#line 2556
          if (*tmp___9) {
            {
#line 2558
            tmp___7 = __errno_location();
#line 2558
            tmp___8 = strerror(*tmp___7);
#line 2558
            rxvt_msg((uint32_t )1, (uint32_t )1, "Error: reading fifo %s", tmp___8);
            }
          }
#line 2561
          if (len == 0L) {
            {
#line 2564
            close(r->fifo_fd);
#line 2565
            r->fifo_fd = open((char const   *)r->fifo_name, 2048);
#line 2566
            rxvt_adjust_fd_number(r);
#line 2569
            r->fbuf_ptr = r->fifo_buf;
            }
          } else
#line 2572
          if (len > 0L) {
#line 2575
            fptr = r->fifo_buf;
#line 2579
            action.str = (unsigned char *)((void *)0);
#line 2581
            r->fbuf_ptr += len;
            {
#line 2583
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2585
              aptr = astr;
              {
#line 2586
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 2586
                if ((unsigned long )fptr < (unsigned long )r->fbuf_ptr) {
#line 2586
                  if (*fptr) {
#line 2586
                    if (! ((int )*fptr != 10)) {
#line 2586
                      goto while_break___5;
                    }
                  } else {
#line 2586
                    goto while_break___5;
                  }
                } else {
#line 2586
                  goto while_break___5;
                }
#line 2587
                tmp___10 = aptr;
#line 2587
                aptr ++;
#line 2587
                tmp___11 = fptr;
#line 2587
                fptr ++;
#line 2587
                *tmp___10 = *tmp___11;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 2589
              if ((unsigned long )fptr < (unsigned long )r->fbuf_ptr) {
#line 2589
                if ((int )*fptr == 10) {
                  {
#line 2592
                  *aptr = (char)0;
#line 2593
                  tmp___12 = rxvt_set_action(& action, astr);
                  }
#line 2593
                  if (tmp___12) {
                    {
#line 2594
                    rxvt_dispatch_action(r, & action, (XEvent *)((void *)0));
                    }
                  }
#line 2596
                  fptr ++;
                } else {
                  {
#line 2605
                  memcpy((void */* __restrict  */)((void *)(r->fifo_buf)), (void const   */* __restrict  */)((void const   *)(astr)),
                         (size_t )(aptr - astr));
#line 2606
                  r->fbuf_ptr = r->fifo_buf + (aptr - astr);
                  }
#line 2607
                  goto while_break___4;
                }
              } else {
                {
#line 2605
                memcpy((void */* __restrict  */)((void *)(r->fifo_buf)), (void const   */* __restrict  */)((void const   *)(astr)),
                       (size_t )(aptr - astr));
#line 2606
                r->fbuf_ptr = r->fifo_buf + (aptr - astr);
                }
#line 2607
                goto while_break___4;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 2612
            rxvt_free((void *)action.str);
            }
          }
        }
      }
#line 2620
      if (selpage != -1) {
        {
#line 2620
        tmp___15 = rxvt_cmdbuf_has_input(r, selpage);
        }
#line 2620
        if (tmp___15) {
#line 2621
          tmp___13 = (r->vts[selpage])->cmdbuf_ptr;
#line 2621
          ((r->vts[selpage])->cmdbuf_ptr) ++;
#line 2621
          return (*tmp___13);
        } else {
#line 2620
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 2624
        retpage = rxvt_find_cmd_child(r);
        }
#line 2624
        if (retpage != -1) {
#line 2626
          if (selpage != -1) {
#line 2626
            if (selpage != retpage) {
#line 2633
              *p_page = -1;
#line 2634
              return ((unsigned char )'\000');
            } else {
#line 2640
              *p_page = retpage;
#line 2641
              tmp___14 = (r->vts[retpage])->cmdbuf_ptr;
#line 2641
              ((r->vts[retpage])->cmdbuf_ptr) ++;
#line 2641
              return (*tmp___14);
            }
          } else {
#line 2640
            *p_page = retpage;
#line 2641
            tmp___14 = (r->vts[retpage])->cmdbuf_ptr;
#line 2641
            ((r->vts[retpage])->cmdbuf_ptr) ++;
#line 2641
            return (*tmp___14);
          }
        }
      }
    }
#line 2650
    if (r->ndead_childs) {
      {
#line 2651
      rxvt_mark_dead_childs(r);
      }
    } else
#line 2650
    if (select_res == -1) {
      {
#line 2651
      rxvt_mark_dead_childs(r);
      }
    }
#line 2653
    if (r->cleanDeadChilds) {
#line 2656
      *p_page = -1;
#line 2657
      return ((unsigned char )'\000');
    }
    {
#line 2664
    rxvt_refresh_vtscr_if_needed(r);
    }

  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2674 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_pointer_unblank(rxvt_t *r , int page ) 
{ 
  struct timeval tp ;

  {
  {
#line 2678
  XDefineCursor(r->Xdisplay, (r->vts[page])->vt, r->term_pointer);
#line 2679
  rxvt_recolour_cursor(r);
  }
#line 2681
  if (! ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL))) {
#line 2682
    return;
  }
#line 2684
  (r->vts[page])->hidden_pointer = (unsigned char)0;
#line 2686
  if ((r->h)->pointerBlankDelay > 0) {
    {
#line 2690
    gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 2691
    (r->h)->lastmotion.tv_sec = tp.tv_sec;
#line 2692
    (r->h)->lastmotion.tv_usec = tp.tv_usec;
    }
  }
#line 2695
  return;
}
}
#line 2700 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_pointer_blank(rxvt_t *r , int page ) 
{ 


  {
#line 2704
  if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 2704
    if (0UL != (r->h)->blank_pointer) {
      {
#line 2707
      XDefineCursor(r->Xdisplay, (r->vts[page])->vt, (r->h)->blank_pointer);
#line 2709
      XFlush(r->Xdisplay);
#line 2710
      (r->vts[page])->hidden_pointer = (unsigned char)1;
      }
    }
  }
#line 2712
  return;
}
}
#line 2717 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_mouse_report(rxvt_t *r , XButtonEvent const   *ev ) 
{ 
  int button_number ;
  int key_state ;
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2720
  key_state = 0;
#line 2723
  x = (int )ev->x;
#line 2724
  y = (int )ev->y;
#line 2725
  rxvt_pixel_position(r, & x, & y);
  }
#line 2727
  if ((long )(r->h)->MEvent.button == 0L) {
#line 2729
    button_number = 3;
  } else {
#line 2733
    button_number = (int )((r->h)->MEvent.button - 1U);
#line 2735
    if (button_number >= 3) {
#line 2736
      button_number += 61;
    }
  }
#line 2739
  if ((unsigned long )(r->vts[r->tabBar.atab])->PrivateModes & (1UL << 12)) {
#line 2745
    key_state = 0;
#line 2746
    if (button_number == 3) {
#line 2747
      return;
    }
  } else {
#line 2758
    if ((r->h)->MEvent.state & 1U) {
#line 2758
      tmp = 4;
    } else {
#line 2758
      tmp = 0;
    }
#line 2758
    if ((r->h)->MEvent.state & (r->h)->ModMetaMask) {
#line 2758
      tmp___0 = 8;
    } else {
#line 2758
      tmp___0 = 0;
    }
#line 2758
    if ((r->h)->MEvent.state & (unsigned int )(1 << 2)) {
#line 2758
      tmp___1 = 16;
    } else {
#line 2758
      tmp___1 = 0;
    }
#line 2758
    key_state = (tmp + tmp___0) + tmp___1;
  }
  {
#line 2778
  rxvt_tt_printf(r, (int )r->tabBar.atab, "\033[M%c%c%c", (32 + button_number) + key_state,
                 (32 + x) + 1, (32 + y) + 1);
  }
#line 2783
  return;
}
}
#line 2812 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_scrollbar_dispatcher(rxvt_t *r , int page , XButtonEvent *ev ) 
{ 
  int reportmode ;
  struct rxvt_hidden *h ;
  int upordown ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2815
  reportmode = 0;
#line 2816
  h = r->h;
#line 2819
  if (! h->bypass_keystate) {
#line 2820
    reportmode = ! (! ((unsigned long )(r->vts[page])->PrivateModes & ((1UL << 12) | (1UL << 13))));
  }
#line 2822
  r->scrollBar.state = (char)1;
#line 2834
  if (reportmode) {
#line 2841
    if ((int )r->scrollBar.style == 1) {
#line 2841
      if (ev->y > (int )r->scrollBar.end) {
#line 2841
        if (ev->y <= (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
          {
#line 2853
          rxvt_tt_printf(r, page, "\033[A");
          }
        } else {
#line 2841
          goto _L___4;
        }
      } else {
#line 2841
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 2841
    if ((int )r->scrollBar.style == 0) {
#line 2841
      if (ev->y < (int )r->scrollBar.beg) {
        {
#line 2853
        rxvt_tt_printf(r, page, "\033[A");
        }
      } else {
#line 2841
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 2841
    if ((int )r->scrollBar.style == 3) {
#line 2841
      if (ev->y < (int )r->scrollBar.beg) {
        {
#line 2853
        rxvt_tt_printf(r, page, "\033[A");
        }
      } else {
#line 2841
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2855
    if ((int )r->scrollBar.style == 1) {
#line 2855
      if (ev->y > (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
        {
#line 2863
        rxvt_tt_printf(r, page, "\033[B");
        }
      } else {
#line 2855
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2855
    if ((int )r->scrollBar.style == 0) {
#line 2855
      if (ev->y > (int )r->scrollBar.end) {
        {
#line 2863
        rxvt_tt_printf(r, page, "\033[B");
        }
      } else {
#line 2855
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2855
    if ((int )r->scrollBar.style == 3) {
#line 2855
      if (ev->y > (int )r->scrollBar.end) {
        {
#line 2863
        rxvt_tt_printf(r, page, "\033[B");
        }
      } else {
#line 2855
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2869
      if (ev->button == 2U) {
#line 2869
        goto case_2;
      }
#line 2872
      if (ev->button == 1U) {
#line 2872
        goto case_1;
      }
#line 2875
      if (ev->button == 3U) {
#line 2875
        goto case_3;
      }
#line 2867
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2870
      rxvt_tt_printf(r, page, "\f");
      }
#line 2871
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2873
      rxvt_tt_printf(r, page, "\033[6~");
      }
#line 2874
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 2876
      rxvt_tt_printf(r, page, "\033[5~");
      }
#line 2877
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
#line 2884
    upordown = 0;
#line 2886
    if ((int )r->scrollBar.style == 1) {
#line 2888
      if (ev->y > (int )r->scrollBar.end) {
#line 2888
        if (ev->y <= (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
#line 2889
          upordown = -1;
        } else {
#line 2888
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 2890
      if (ev->y > (int )r->scrollBar.end + ((int )r->scrollBar.width + 1)) {
#line 2891
        upordown = 1;
      }
    } else
#line 2893
    if ((int )r->scrollBar.style == 0) {
#line 2895
      if (ev->y < (int )r->scrollBar.beg) {
#line 2896
        upordown = -1;
      } else
#line 2897
      if (ev->y > (int )r->scrollBar.end) {
#line 2898
        upordown = 1;
      }
    } else
#line 2900
    if ((int )r->scrollBar.style == 3) {
#line 2902
      if (ev->y < (int )r->scrollBar.beg) {
#line 2903
        upordown = -1;
      } else
#line 2904
      if (ev->y > (int )r->scrollBar.end) {
#line 2905
        upordown = 1;
      }
    }
#line 2908
    if (upordown) {
#line 2911
      h->scroll_arrow_delay = 40;
#line 2913
      if (upordown < 0) {
#line 2913
        tmp = 0;
      } else {
#line 2913
        tmp = 1;
      }
      {
#line 2913
      tmp___0 = rxvt_scr_page(r, (int )r->tabBar.atab, (enum page_dirn )tmp, 1);
      }
#line 2913
      if (tmp___0) {
#line 2915
        if (upordown < 0) {
#line 2916
          r->scrollBar.state = (char )'U';
        } else {
#line 2918
          r->scrollBar.state = (char )'D';
        }
      }
    } else {
      {
#line 2925
      if (ev->button == 2U) {
#line 2925
        goto case_2___0;
      }
#line 2952
      if (ev->button == 1U) {
#line 2952
        goto case_1___1;
      }
#line 2957
      if (ev->button == 3U) {
#line 2957
        goto case_3___0;
      }
#line 2923
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 2928
      if ((int )h->scrollbar_align == 1) {
#line 2928
        goto case_1___0;
      }
#line 2931
      if ((int )h->scrollbar_align == 0) {
#line 2931
        goto case_0;
      }
#line 2934
      if ((int )h->scrollbar_align == 2) {
#line 2934
        goto case_2___1;
      }
#line 2926
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
#line 2929
      h->csrO = 0;
#line 2930
      goto switch_break___1;
      case_0: /* CIL Label */ 
#line 2932
      h->csrO = ((int )r->scrollBar.bot - (int )r->scrollBar.top) / 2;
#line 2933
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 2935
      h->csrO = (int )r->scrollBar.bot - (int )r->scrollBar.top;
#line 2936
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 2939
      if ((int )r->scrollBar.style == 2) {
#line 2939
        goto _L___6;
      } else
#line 2939
      if (ev->y < (int )r->scrollBar.top) {
#line 2939
        goto _L___6;
      } else
#line 2939
      if (ev->y > (int )r->scrollBar.bot) {
        _L___6: /* CIL Label */ 
#line 2945
        if ((int )r->scrollBar.style == 1) {
#line 2945
          tmp___2 = ((17 - (1 << 1)) - 1) - (1 << 1);
        } else {
#line 2945
          if ((int )r->scrollBar.style == 3) {
#line 2945
            tmp___1 = 10;
          } else {
#line 2945
            tmp___1 = 10;
          }
#line 2945
          tmp___2 = tmp___1;
        }
        {
#line 2945
        rxvt_scr_move_to(r, page, (ev->y - (int )r->scrollBar.beg) - h->csrO, ((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___2);
        }
      }
#line 2949
      r->scrollBar.state = (char )'m';
#line 2950
      goto switch_break___0;
      case_1___1: /* CIL Label */ 
#line 2953
      if ((int )h->scrollbar_align == 0) {
#line 2954
        h->csrO = ev->y - (int )r->scrollBar.top;
      }
      case_3___0: /* CIL Label */ 
#line 2958
      if ((int )r->scrollBar.style != 2) {
#line 2960
        if (ev->y < (int )r->scrollBar.top) {
          {
#line 2962
          rxvt_scr_page(r, (int )r->tabBar.atab, (enum page_dirn )0, (int )r->TermWin.nrow - 1);
          }
        } else
#line 2966
        if (ev->y > (int )r->scrollBar.bot) {
          {
#line 2968
          rxvt_scr_page(r, (int )r->tabBar.atab, (enum page_dirn )1, (int )r->TermWin.nrow - 1);
          }
        } else {
#line 2973
          r->scrollBar.state = (char )'m';
        }
      } else {
#line 2977
        if ((int )r->scrollBar.style == 1) {
#line 2977
          tmp___4 = ((17 - (1 << 1)) - 1) - (1 << 1);
        } else {
#line 2977
          if ((int )r->scrollBar.style == 3) {
#line 2977
            tmp___3 = 10;
          } else {
#line 2977
            tmp___3 = 10;
          }
#line 2977
          tmp___4 = tmp___3;
        }
#line 2977
        if (ev->button == 1U) {
#line 2977
          tmp___5 = 1;
        } else {
#line 2977
          tmp___5 = 0;
        }
        {
#line 2977
        rxvt_scr_page(r, (int )r->tabBar.atab, (enum page_dirn )tmp___5, ((int )r->TermWin.nrow * (ev->y - (int )r->scrollBar.beg)) / (((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___4));
        }
      }
#line 2982
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 2986
  return;
}
}
#line 2992 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_buttonpress(rxvt_t *r , int page , XButtonEvent *ev ) 
{ 
  int reportmode ;
  int clickintime ;
  struct rxvt_hidden *h ;
  int tmp ;
  int tmp___0 ;

  {
#line 2995
  reportmode = 0;
#line 2996
  h = r->h;
#line 3000
  h->bypass_keystate = (unsigned char )(ev->state & (h->ModMetaMask | 1U));
#line 3001
  if (! h->bypass_keystate) {
#line 3002
    reportmode = ! (! ((unsigned long )(r->vts[page])->PrivateModes & ((1UL << 12) | (1UL << 13))));
  }
#line 3007
  if (ev->window == (r->vts[page])->vt) {
#line 3053
    clickintime = ev->time - h->MEvent.time < 500UL;
#line 3054
    if (reportmode) {
      {
#line 3058
      h->MEvent.state = ev->state;
#line 3083
      h->MEvent.button = ev->button;
#line 3084
      rxvt_mouse_report(r, (XButtonEvent const   *)ev);
      }
    } else {
#line 3089
      if (ev->button != h->MEvent.button) {
#line 3090
        h->MEvent.clicks = 0;
      }
      {
#line 3093
      if (ev->button == 1U) {
#line 3093
        goto case_1;
      }
#line 3103
      if (ev->button == 3U) {
#line 3103
        goto case_3;
      }
#line 3091
      goto switch_break;
      case_1: /* CIL Label */ 
#line 3094
      if (h->MEvent.button == 1U) {
#line 3094
        if (clickintime) {
#line 3095
          (h->MEvent.clicks) ++;
        } else {
#line 3097
          h->MEvent.clicks = 1;
        }
      } else {
#line 3097
        h->MEvent.clicks = 1;
      }
      {
#line 3098
      rxvt_selection_click(r, page, h->MEvent.clicks, ev->x, ev->y);
#line 3100
      h->MEvent.button = 1U;
      }
#line 3101
      goto switch_break;
      case_3: /* CIL Label */ 
#line 3104
      if (h->MEvent.button == 3U) {
#line 3104
        if (clickintime) {
          {
#line 3105
          rxvt_selection_rotate(r, page, ev->x, ev->y);
          }
        } else {
          {
#line 3107
          rxvt_selection_extend(r, page, ev->x, ev->y, 1);
          }
        }
      } else {
        {
#line 3107
        rxvt_selection_extend(r, page, ev->x, ev->y, 1);
        }
      }
#line 3108
      h->MEvent.button = 3U;
#line 3109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 3112
    h->MEvent.time = ev->time;
#line 3113
    return;
  }
  {
#line 3120
  tmp = rxvt_is_tabbar_win(r, ev->window);
  }
#line 3120
  if (tmp) {
    {
#line 3121
    rxvt_tabbar_dispatcher(r, ev);
    }
  }
  {
#line 3128
  tmp___0 = rxvt_is_scrollbar_win(r, ev->window);
  }
#line 3128
  if (tmp___0) {
    {
#line 3129
    rxvt_scrollbar_dispatcher(r, page, ev);
    }
  }
#line 3140
  return;
}
}
#line 3146 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_wheel_button(rxvt_t *r , int page , XButtonEvent *ev ) 
{ 
  int i ;
  int v ;

  {
#line 3151
  if (ev->button == 4U) {
#line 3151
    v = 0;
  } else {
#line 3151
    v = 1;
  }
#line 3152
  if (ev->state & 1U) {
#line 3153
    i = 1;
  } else
#line 3154
  if ((unsigned long )r->Options[(1UL << 20) & 3UL] & ((1UL << 20) & 0xfffffffffffffffcUL)) {
#line 3155
    i = (int )r->TermWin.nrow - 1;
  } else {
#line 3157
    i = 5;
  }
  {
#line 3168
  rxvt_scr_page(r, (int )r->tabBar.atab, (enum page_dirn )v, i);
#line 3171
  rxvt_scrollbar_update(r, 1);
  }
#line 3191
  return;
}
}
#line 3196 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_buttonrelease(rxvt_t *r , int page , XButtonEvent *ev ) 
{ 
  int reportmode ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 3199
  reportmode = 0;
#line 3201
  if ((int )r->tabClicked != -1) {
    {
#line 3203
    tmp = rxvt_is_tabbar_win(r, ev->window);
    }
#line 3203
    if (tmp) {
      {
#line 3205
      rxvt_tabbar_button_release(r, ev);
      }
#line 3206
      return;
    } else {
#line 3210
      r->tabClicked = (short)-1;
    }
  }
#line 3214
  (r->h)->csrO = 0;
#line 3215
  if (! (r->h)->bypass_keystate) {
#line 3216
    reportmode = ! (! ((unsigned long )(r->vts[page])->PrivateModes & ((1UL << 12) | (1UL << 13))));
  }
  {
#line 3219
  tmp___0 = __ctype_b_loc();
  }
#line 3219
  if ((int const   )*(*tmp___0 + (int )r->scrollBar.state) & 256) {
    {
#line 3221
    r->scrollBar.state = (char)1;
#line 3222
    rxvt_scrollbar_update(r, 0);
#line 3224
    (r->h)->refresh_type = (unsigned char )((int )(r->h)->refresh_type & ~ (1 << 2));
    }
  }
#line 3241
  (r->h)->pending_scroll_selection = 0;
#line 3244
  if (ev->window == (r->vts[page])->vt) {
#line 3246
    if (0UL == ev->subwindow) {
#line 3248
      if (reportmode) {
#line 3252
        if (ev->button >= 4U) {
#line 3253
          return;
        }
        {
#line 3269
        (r->h)->MEvent.button = 0U;
#line 3270
        rxvt_mouse_report(r, (XButtonEvent const   *)ev);
        }
#line 3272
        return;
      }
#line 3278
      if ((unsigned long )(r->vts[page])->PrivateModes & ((1UL << 12) | (1UL << 13))) {
#line 3278
        if ((r->h)->bypass_keystate) {
#line 3278
          if (1U == ev->button) {
#line 3278
            if ((r->h)->MEvent.clicks <= 1) {
              {
#line 3282
              rxvt_selection_extend(r, page, ev->x, ev->y, 0);
              }
            }
          }
        }
      }
      {
#line 3287
      if (ev->button == 3U) {
#line 3287
        goto case_3;
      }
#line 3287
      if (ev->button == 1U) {
#line 3287
        goto case_3;
      }
#line 3290
      if (ev->button == 2U) {
#line 3290
        goto case_2;
      }
#line 3295
      if (ev->button == 5U) {
#line 3295
        goto case_5;
      }
#line 3295
      if (ev->button == 4U) {
#line 3295
        goto case_5;
      }
#line 3284
      goto switch_break;
      case_3: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 3288
      rxvt_selection_make(r, page, ev->time);
      }
#line 3289
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3291
      rxvt_selection_request(r, page, ev->time, ev->x, ev->y);
      }
#line 3292
      goto switch_break;
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 3296
      rxvt_process_wheel_button(r, page, ev);
      }
#line 3297
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 3306
  return;
}
}
#line 3311 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_clientmessage(rxvt_t *r , XClientMessageEvent *ev ) 
{ 


  {
#line 3315
  if (ev->format == 32) {
#line 3315
    if ((Atom )ev->data.l[0] == (r->h)->xa[8]) {
      {
#line 3319
      rxvt_exit_request(r);
      }
    }
  }
#line 3349
  return;
}
}
#line 3354 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_visibilitynotify(rxvt_t *r , XVisibilityEvent *ev ) 
{ 


  {
  {
#line 3360
  if (ev->state == 0) {
#line 3360
    goto case_0;
  }
#line 3363
  if (ev->state == 1) {
#line 3363
    goto case_1;
  }
#line 3366
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3361
  (r->h)->refresh_type = (unsigned char)1;
#line 3362
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3364
  (r->h)->refresh_type = (unsigned char )(1 << 1);
#line 3365
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3367
  (r->h)->refresh_type = (unsigned char)0;
#line 3368
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3370
  return;
}
}
#line 3404 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_change_colors_on_focus(rxvt_t *r ) 
{ 
  int tmp ;

  {
  {
#line 3408
  tmp = rxvt_set_vt_colors(r, (int )r->tabBar.atab);
  }
#line 3408
  if (tmp) {
    {
#line 3410
    rxvt_scr_clear(r, (int )r->tabBar.atab);
#line 3411
    rxvt_scr_touch(r, (int )r->tabBar.atab, 1);
    }
  }
#line 3413
  return;
}
}
#line 3417 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_focusin(rxvt_t *r , XFocusChangeEvent *ev ) 
{ 


  {
#line 3420
  if (ev->mode == 1) {
#line 3421
    return;
  } else
#line 3420
  if (ev->mode == 2) {
#line 3421
    return;
  }
#line 3423
  if (ev->window == r->TermWin.parent) {
    {
#line 3428
    r->TermWin.focus = (char)1;
#line 3429
    (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
#line 3436
    rxvt_change_colors_on_focus(r);
    }
  }
#line 3438
  return;
}
}
#line 3442 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_focusout(rxvt_t *r , XFocusChangeEvent *ev ) 
{ 


  {
#line 3445
  if (ev->mode == 1) {
#line 3446
    return;
  } else
#line 3445
  if (ev->mode == 2) {
#line 3446
    return;
  }
#line 3448
  if (ev->window == r->TermWin.parent) {
    {
#line 3453
    r->TermWin.focus = (char)0;
#line 3454
    (r->vts[r->tabBar.atab])->want_refresh = (unsigned char)1;
#line 3457
    (r->h)->hidden_cursor = (unsigned char)0;
#line 3465
    rxvt_change_colors_on_focus(r);
    }
  }
#line 3467
  return;
}
}
#line 3479 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_resize_on_subwin(rxvt_t *r , resize_reason_t reason ) 
{ 
  unsigned int oldWidth ;
  unsigned int oldHeight ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned short tmp___4 ;
  unsigned short tmp___5 ;
  unsigned short tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;
  int tmp___12 ;
  unsigned short tmp___13 ;
  int tmp___14 ;
  unsigned short tmp___15 ;
  CARD32 left ;
  CARD32 right ;
  CARD32 top ;
  CARD32 bottom ;
  int wx ;
  int wy ;
  unsigned int wwidth ;
  unsigned int wheight ;
  int newx ;
  int newy ;
  unsigned int dspw ;
  unsigned int dsph ;
  int dx ;
  int dy ;
  int tmp___16 ;

  {
#line 3485
  oldWidth = (unsigned int )r->szHint.width;
#line 3486
  oldHeight = (unsigned int )r->szHint.height;
  {
#line 3503
  if ((unsigned int )reason == 2U) {
#line 3503
    goto case_2;
  }
#line 3508
  if ((unsigned int )reason == 3U) {
#line 3508
    goto case_3;
  }
#line 3515
  if ((unsigned int )reason == 4U) {
#line 3515
    goto case_4;
  }
#line 3520
  if ((unsigned int )reason == 5U) {
#line 3520
    goto case_5;
  }
#line 3527
  if ((unsigned int )reason == 6U) {
#line 3527
    goto case_6;
  }
#line 3573
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 3504
  tmp = rxvt_tabbar_rheight(r);
#line 3504
  r->szHint.base_height -= (int )tmp;
#line 3505
  tmp___0 = rxvt_tabbar_rheight(r);
#line 3505
  r->szHint.min_height -= (int )tmp___0;
#line 3506
  tmp___1 = rxvt_tabbar_rheight(r);
#line 3506
  r->szHint.height -= (int )tmp___1;
  }
#line 3507
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3509
  tmp___2 = rxvt_tabbar_rheight(r);
#line 3509
  r->szHint.base_height += (int )tmp___2;
#line 3510
  tmp___3 = rxvt_tabbar_rheight(r);
#line 3510
  r->szHint.min_height += (int )tmp___3;
#line 3511
  tmp___4 = rxvt_tabbar_rheight(r);
#line 3511
  r->szHint.height += (int )tmp___4;
  }
#line 3512
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3516
  tmp___5 = rxvt_scrollbar_rwidth(r);
#line 3516
  r->szHint.base_width -= (int )tmp___5;
#line 3517
  tmp___6 = rxvt_scrollbar_rwidth(r);
#line 3517
  r->szHint.min_width -= (int )tmp___6;
#line 3518
  tmp___7 = rxvt_scrollbar_rwidth(r);
#line 3518
  r->szHint.width -= (int )tmp___7;
  }
#line 3519
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 3521
  tmp___8 = rxvt_scrollbar_rwidth(r);
#line 3521
  r->szHint.base_width += (int )tmp___8;
#line 3522
  tmp___9 = rxvt_scrollbar_rwidth(r);
#line 3522
  r->szHint.min_width += (int )tmp___9;
#line 3523
  tmp___10 = rxvt_scrollbar_rwidth(r);
#line 3523
  r->szHint.width += (int )tmp___10;
  }
#line 3524
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 3529
  r->szHint.base_width = 2 * (int )r->TermWin.int_bwidth;
#line 3530
  r->szHint.base_height = 2 * (int )r->TermWin.int_bwidth;
#line 3532
  tmp___12 = rxvt_scrollbar_visible(r);
  }
#line 3532
  if (tmp___12) {
    {
#line 3533
    tmp___11 = rxvt_scrollbar_width(r);
#line 3533
    r->szHint.base_width += (int )tmp___11;
    }
  }
  {
#line 3539
  tmp___14 = rxvt_tabbar_visible(r);
  }
#line 3539
  if (tmp___14) {
    {
#line 3540
    tmp___13 = rxvt_tabbar_height(r);
#line 3540
    r->szHint.base_height += (int )tmp___13;
    }
  }
#line 3544
  if ((unsigned long )r->Options[((1UL << 26) | 1UL) & 3UL] & (((1UL << 26) | 1UL) & 0xfffffffffffffffcUL)) {
#line 3546
    r->szHint.width_inc = 1;
#line 3547
    r->szHint.height_inc = 1;
  } else {
#line 3552
    r->szHint.width_inc = (int )r->TermWin.fwidth;
#line 3553
    r->szHint.height_inc = (int )r->TermWin.fheight;
  }
#line 3557
  r->szHint.min_width = r->szHint.base_width + (int )r->TermWin.fwidth;
#line 3558
  r->szHint.min_height = r->szHint.base_height + (int )r->TermWin.fheight;
#line 3561
  r->szHint.width = r->szHint.base_width + (int32_t )r->TermWin.ncol * (int32_t )r->TermWin.fwidth;
#line 3563
  r->szHint.height = r->szHint.base_height + (int32_t )r->TermWin.nrow * (int32_t )r->TermWin.fheight;
#line 3570
  (r->h)->want_resize = (unsigned char )((unsigned int )(r->h)->want_resize | (1U << 1));
#line 3571
  goto switch_break;
  switch_default: /* CIL Label */ ;
#line 3575
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3579
  XSetWMNormalHints(r->Xdisplay, r->TermWin.parent, & r->szHint);
  }
#line 3582
  if (! ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL))) {
#line 3583
    if ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL)) {
#line 3583
      (r->h)->window_vt_x = 0;
    } else {
#line 3583
      (r->h)->window_vt_x = r->szHint.base_width - 2 * (int )r->TermWin.int_bwidth;
    }
  }
#line 3586
  (r->h)->window_vt_y = r->szHint.base_height - 2 * (int )r->TermWin.int_bwidth;
#line 3587
  if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 3588
    tmp___15 = rxvt_tabbar_height(r);
#line 3588
    (r->h)->window_vt_y -= (int )tmp___15;
    }
  }
  {
#line 3597
  XResizeWindow(r->Xdisplay, r->TermWin.parent, (unsigned int )r->szHint.width, (unsigned int )r->szHint.height);
#line 3605
  (r->h)->want_resize = (unsigned char )((unsigned int )(r->h)->want_resize | 1U);
  }
  {
#line 3608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3608
    if (! ((unsigned long )r->Options[((1UL << 27) | 1UL) & 3UL] & (((1UL << 27) | 1UL) & 0xfffffffffffffffcUL))) {
#line 3608
      goto while_break;
    }
    {
#line 3619
    newx = r->szHint.x;
#line 3619
    newy = r->szHint.y;
#line 3622
    dspw = (unsigned int )(((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->width;
#line 3622
    dsph = (unsigned int )(((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->height;
#line 3625
    dx = r->szHint.width - (int )oldWidth;
#line 3625
    dy = r->szHint.height - (int )oldHeight;
#line 3629
    tmp___16 = getWMStruts(r->Xdisplay, r->TermWin.parent, & left, & right, & top,
                           & bottom);
    }
#line 3629
    if (! tmp___16) {
#line 3630
      goto while_break;
    }
#line 3632
    wx = (int )((CARD32 )r->szHint.x - left);
#line 3633
    wy = (int )((CARD32 )r->szHint.y - top);
#line 3634
    wwidth = ((CARD32 )r->szHint.width + left) + right;
#line 3635
    wheight = ((CARD32 )r->szHint.height + top) + bottom;
#line 3646
    if (wwidth >= dspw) {
#line 3646
      goto while_break;
    } else
#line 3646
    if (wheight >= dsph) {
#line 3646
      goto while_break;
    }
#line 3648
    if (wx < 0) {
#line 3648
      if (wx + dx >= 0) {
#line 3648
        newx = (int )left;
      } else {
#line 3648
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3649
    if (wx + (int )wwidth > (int )dspw) {
#line 3649
      if ((wx + (int )wwidth) - dx <= (int )dspw) {
#line 3651
        newx = (int )((dspw - wwidth) + left);
      }
    }
#line 3653
    if (wy < 0) {
#line 3653
      if (wy + dy >= 0) {
#line 3653
        newy = (int )top;
      } else {
#line 3653
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3654
    if (wy + (int )wheight > (int )dsph) {
#line 3654
      if ((wy + (int )wheight) - dy <= (int )dsph) {
#line 3656
        newy = (int )((dsph - wheight) + top);
      }
    }
#line 3658
    if (newx != r->szHint.x) {
#line 3658
      goto _L___1;
    } else
#line 3658
    if (newy != r->szHint.y) {
      _L___1: /* CIL Label */ 
#line 3658
      if (newx - (int )left >= 0) {
#line 3658
        if ((unsigned int )((newx - (int )left) + (int )wwidth) <= dspw) {
#line 3658
          if (newy - (int )top >= 0) {
#line 3658
            if ((unsigned int )((newy - (int )top) + (int )wheight) <= dsph) {
              {
#line 3667
              XMoveWindow(r->Xdisplay, r->TermWin.parent, newx, newy);
              }
            }
          }
        }
      }
    }
#line 3670
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3679
  r->szHint.width = (int )oldWidth;
#line 3680
  r->szHint.height = (int )oldHeight;
#line 3681
  return;
}
}
#line 3686 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_resize_on_font(rxvt_t *r , char *fontname ) 
{ 
  int tmp ;

  {
  {
#line 3699
  tmp = rxvt_change_font_x11(r, (char const   *)fontname);
  }
#line 3699
  if (! tmp) {
#line 3700
    return;
  }
  {
#line 3702
  rxvt_resize_on_subwin(r, (resize_reason_t )6);
  }
#line 3703
  return;
}
}
#line 3711 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_calc_colrow(rxvt_t *r , unsigned int width , unsigned int height ) 
{ 
  unsigned int ncol ;
  unsigned int nrow ;
  int tmp ;

  {
#line 3721
  if (! (r->h)->want_resize) {
#line 3721
    if ((unsigned int )r->szHint.width == width) {
#line 3721
      if ((unsigned int )r->szHint.height == height) {
#line 3723
        return (0);
      }
    }
  }
#line 3726
  ncol = (unsigned int )((int32_t )(width - (unsigned int )r->szHint.base_width) / (int32_t )r->TermWin.fwidth);
#line 3727
  nrow = (unsigned int )((int32_t )(height - (unsigned int )r->szHint.base_height) / (int32_t )r->TermWin.fheight);
#line 3728
  if (1U > ncol) {
#line 3728
    ncol = 1U;
  }
#line 3729
  if (1U > nrow) {
#line 3729
    nrow = 1U;
  }
#line 3731
  (r->h)->prev_ncol = r->TermWin.ncol;
#line 3732
  (r->h)->prev_nrow = r->TermWin.nrow;
#line 3733
  r->TermWin.ncol = (uint16_t )ncol;
#line 3734
  r->TermWin.nrow = (uint16_t )nrow;
#line 3741
  r->szHint.width = (int )width;
#line 3742
  r->szHint.height = (int )height;
#line 3744
  if ((int )(r->h)->prev_ncol != (int )r->TermWin.ncol) {
#line 3744
    tmp = 1;
  } else
#line 3744
  if ((int )(r->h)->prev_nrow != (int )r->TermWin.nrow) {
#line 3744
    tmp = 1;
  } else {
#line 3744
    tmp = 0;
  }
#line 3744
  return (tmp);
}
}
#line 3750 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_resize_sub_windows(rxvt_t *r ) 
{ 
  register int i ;

  {
  {
#line 3759
  rxvt_scrollbar_resize(r);
#line 3764
  rxvt_tabbar_resize(r);
#line 3766
  i = 0;
  }
  {
#line 3766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3766
    if (! (i <= (int )r->tabBar.ltab)) {
#line 3766
      goto while_break;
    }
    {
#line 3768
    XMoveResizeWindow(r->Xdisplay, (r->vts[i])->vt, (r->h)->window_vt_x, (r->h)->window_vt_y,
                      (unsigned int )((r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth),
                      (unsigned int )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth));
#line 3766
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3772
  return;
}
}
#line 3777 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_resize_on_configure(rxvt_t *r , unsigned int width , unsigned int height ) 
{ 
  register int i ;
  unsigned int old_width ;
  unsigned int old_height ;
  int fix_screen ;
  int curr_screen ;
  uint16_t old_ncol ;
  int tmp ;

  {
  {
#line 3780
  i = 0;
#line 3781
  old_width = (unsigned int )r->szHint.width;
#line 3781
  old_height = (unsigned int )r->szHint.height;
#line 3788
  fix_screen = rxvt_calc_colrow(r, width, height);
  }
#line 3794
  if ((r->h)->want_resize) {
    {
#line 3796
    rxvt_resize_sub_windows(r);
    }
  } else
#line 3794
  if (old_width != (unsigned int )r->szHint.width) {
    {
#line 3796
    rxvt_resize_sub_windows(r);
    }
  } else
#line 3794
  if (old_height != (unsigned int )r->szHint.height) {
    {
#line 3796
    rxvt_resize_sub_windows(r);
    }
  }
#line 3798
  if (fix_screen) {
#line 3800
    i = 0;
    {
#line 3800
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3800
      if (! (i <= (int )r->tabBar.ltab)) {
#line 3800
        goto while_break;
      }
      {
#line 3802
      curr_screen = -1;
#line 3812
      (r->vts[i])->prev_nrow = (r->h)->prev_nrow;
#line 3813
      (r->vts[i])->prev_ncol = (r->h)->prev_ncol;
#line 3814
      old_ncol = (r->vts[i])->prev_ncol;
#line 3816
      rxvt_scr_clear(r, i);
#line 3821
      curr_screen = rxvt_scr_change_screen(r, i, 0);
#line 3823
      rxvt_scr_reset(r, i);
      }
#line 3824
      if (curr_screen >= 0) {
        {
#line 3827
        rxvt_scr_change_screen(r, i, curr_screen);
        }
#line 3828
        if ((int )old_ncol != (int )r->TermWin.ncol) {
#line 3828
          tmp = 4;
        } else {
#line 3828
          tmp = 0;
        }
        {
#line 3828
        rxvt_selection_check(r, i, tmp);
        }
      }
#line 3800
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3836
  return;
}
}
#line 3850 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static int const   natoms  =    (int const   )2;
#line 3851 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static char const   *atomName[2]  = {      "_KDE_NET_WM_FRAME_STRUT",      "_NET_FRAME_EXTENTS"};
#line 3845 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int getWMStruts(Display *dpy , Window w , CARD32 *left , CARD32 *right , CARD32 *top ,
                CARD32 *bottom ) 
{ 
  Atom atom ;
  int i ;
  Atom type ;
  int format ;
  unsigned long nitems ;
  unsigned long bytes_after ;
  unsigned char *prop ;
  CARD32 tmp ;
  CARD32 tmp___0 ;
  CARD32 tmp___1 ;
  int tmp___2 ;
  CARD32 *struts ;

  {
#line 3866
  tmp___1 = (CARD32 )0;
#line 3866
  *bottom = tmp___1;
#line 3866
  tmp___0 = tmp___1;
#line 3866
  *top = tmp___0;
#line 3866
  tmp = tmp___0;
#line 3866
  *right = tmp;
#line 3866
  *left = tmp;
#line 3869
  i = 0;
  {
#line 3869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3869
    if (! (i < (int )natoms)) {
#line 3869
      goto while_break;
    }
    {
#line 3871
    atom = XInternAtom(dpy, atomName[i], 0);
    }
#line 3872
    if (0UL == atom) {
#line 3873
      goto __Cont;
    }
    {
#line 3875
    tmp___2 = XGetWindowProperty(dpy, w, atom, 0L, 4L, 0, (Atom )6, & type, & format,
                                 & nitems, & bytes_after, & prop);
    }
#line 3875
    if (tmp___2 != 0) {
#line 3882
      goto __Cont;
    }
#line 3884
    if (type == 6UL) {
#line 3884
      if (bytes_after == 0UL) {
#line 3884
        if (format == 32) {
#line 3884
          if (nitems == 4UL) {
#line 3889
            struts = (CARD32 *)prop;
#line 3891
            *left = *(struts + 0);
#line 3892
            *right = *(struts + 1);
#line 3893
            *top = *(struts + 2);
#line 3894
            *bottom = *(struts + 3);
#line 3903
            i = (int )natoms;
          }
        }
      }
    }
    {
#line 3906
    XFree((void *)prop);
    }
    __Cont: /* CIL Label */ 
#line 3869
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3908
  return (i == (int )(natoms + 1));
}
}
#line 3913 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_configurenotify(rxvt_t *r , XConfigureEvent *ev ) 
{ 
  unsigned int height ;
  unsigned int width ;
  int tmp ;
  int tmp___0 ;

  {
#line 3918
  if (ev->window != r->TermWin.parent) {
#line 3919
    return;
  }
  {
#line 3922
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3924
    width = (unsigned int )ev->width;
#line 3925
    height = (unsigned int )ev->height;
#line 3922
    tmp = XCheckTypedWindowEvent(r->Xdisplay, ev->window, 22, (XEvent *)ev);
    }
#line 3922
    if (! tmp) {
#line 3922
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3935
  XTranslateCoordinates(r->Xdisplay, r->TermWin.parent, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                        0, 0, & r->szHint.x, & r->szHint.y, & ev->window);
  }
#line 3940
  if ((r->h)->want_resize) {
    {
#line 3946
    rxvt_resize_on_configure(r, width, height);
    }
  } else
#line 3940
  if ((unsigned int )r->szHint.width != width) {
    {
#line 3946
    rxvt_resize_on_configure(r, width, height);
    }
  } else
#line 3940
  if ((unsigned int )r->szHint.height != height) {
    {
#line 3946
    rxvt_resize_on_configure(r, width, height);
    }
  }
#line 3955
  if ((unsigned int )(r->h)->want_resize & ~ (1U << 1)) {
    {
#line 3957
    (r->h)->want_resize = (unsigned char)0;
#line 3973
    rxvt_scr_touch(r, (int )r->tabBar.atab, 0);
    }
  }
#line 3983
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 3985
    if (! (r->h)->bgGrabbed) {
#line 3985
      goto _L;
    } else
#line 3985
    if ((int )(r->h)->prevPos.x != r->szHint.x) {
#line 3985
      goto _L;
    } else
#line 3985
    if ((int )(r->h)->prevPos.y != r->szHint.y) {
#line 3985
      goto _L;
    } else
#line 3985
    if ((unsigned int )(r->h)->prevPos.width != width) {
#line 3985
      goto _L;
    } else
#line 3985
    if ((unsigned int )(r->h)->prevPos.height != height) {
      _L: /* CIL Label */ 
#line 3999
      if (! (r->h)->bgRefreshInterval) {
        {
#line 4002
        tmp___0 = rxvt_check_our_parents(r);
        }
#line 4002
        if (tmp___0) {
#line 4004
          (r->h)->want_resize = (unsigned char)0;
#line 4005
          (r->h)->want_full_refresh = (unsigned char)1;
        }
      } else {
        {
#line 4011
        gettimeofday((struct timeval */* __restrict  */)(& (r->h)->lastCNotify), (__timezone_ptr_t )((void *)0));
        }
      }
    }
  }
#line 4016
  return;
}
}
#line 4020 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_selectionnotify(rxvt_t *r , XSelectionEvent *ev ) 
{ 


  {
#line 4024
  if ((int )(r->h)->selection_wait == 1) {
    {
#line 4025
    rxvt_selection_paste(r, ev->requestor, ev->property, 1);
    }
  }
#line 4026
  return;
}
}
#line 4030 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_propertynotify(rxvt_t *r , XEvent *ev ) 
{ 
  int wantRefresh ;
  struct timespec rqt ;
  int tmp ;

  {
#line 4034
  wantRefresh = 0;
  {
#line 4048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4056
    if (ev->xproperty.atom == (r->h)->xa[6]) {
#line 4056
      if (ev->xproperty.state == 0) {
        {
#line 4061
        rxvt_selection_property(r, ev->xproperty.window, ev->xproperty.atom);
        }
      } else {
#line 4056
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4065
    if (0UL != (r->h)->xa[17]) {
#line 4065
      if (0UL != (r->h)->xa[18]) {
#line 4065
        if (ev->xproperty.atom == (r->h)->xa[17]) {
#line 4065
          goto _L;
        } else
#line 4065
        if (ev->xproperty.atom == (r->h)->xa[18]) {
          _L: /* CIL Label */ 
#line 4076
          if (! wantRefresh) {
            {
#line 4094
            rqt.tv_sec = (__time_t )0;
#line 4095
            rqt.tv_nsec = (__syscall_slong_t )10000000;
#line 4096
            nanosleep((struct timespec  const  *)(& rqt), (struct timespec *)((void *)0));
            }
          }
#line 4102
          wantRefresh = 1;
        }
      }
    }
    {
#line 4048
    tmp = XCheckTypedEvent(r->Xdisplay, 28, ev);
    }
#line 4048
    if (! tmp) {
#line 4048
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4113
  if (wantRefresh) {
    {
#line 4119
    refreshRootBGVars(r);
    }
#line 4120
    if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
      {
#line 4125
      rxvt_check_our_parents(r);
#line 4126
      (r->h)->want_full_refresh = (unsigned char)1;
      }
    }
  }
#line 4130
  return;
}
}
#line 4137 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_expose(rxvt_t *r , XEvent *ev ) 
{ 
  int page ;
  Window win ;
  Window tmp ;
  XRectangle rect ;
  int tmp___0 ;
  int tmp___1 ;
  XEvent unused_xevent ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4140
  page = (int )r->tabBar.atab;
#line 4141
  if (ev->type == 12) {
#line 4141
    tmp = ev->xexpose.window;
  } else {
#line 4141
    tmp = ev->xgraphicsexpose.drawable;
  }
#line 4141
  win = tmp;
#line 4145
  if (win == (r->vts[page])->vt) {
#line 4152
    if ((unsigned long )((Region )0) == (unsigned long )(r->h)->refreshRegion) {
      {
#line 4154
      (r->h)->refreshRegion = XCreateRegion();
      }
    }
    {
#line 4159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4163
      if (ev->type == 12) {
#line 4165
        rect.x = (short )ev->xexpose.x;
#line 4166
        rect.y = (short )ev->xexpose.y;
#line 4167
        rect.width = (unsigned short )ev->xexpose.width;
#line 4168
        rect.height = (unsigned short )ev->xexpose.height;
      } else {
#line 4172
        rect.x = (short )ev->xgraphicsexpose.x;
#line 4173
        rect.y = (short )ev->xgraphicsexpose.y;
#line 4174
        rect.width = (unsigned short )ev->xgraphicsexpose.width;
#line 4175
        rect.height = (unsigned short )ev->xgraphicsexpose.height;
      }
      {
#line 4192
      XClearArea(r->Xdisplay, win, (int )rect.x, (int )rect.y, (unsigned int )rect.width,
                 (unsigned int )rect.height, 0);
#line 4195
      XUnionRectWithRegion(& rect, (r->h)->refreshRegion, (r->h)->refreshRegion);
#line 4197
      rxvt_scr_expose(r, page, (int )rect.x, (int )rect.y, (int )rect.width, (int )rect.height,
                      0);
#line 4159
      tmp___0 = XCheckTypedWindowEvent(r->Xdisplay, win, 12, ev);
      }
#line 4159
      if (! tmp___0) {
        {
#line 4159
        tmp___1 = XCheckTypedWindowEvent(r->Xdisplay, win, 13, ev);
        }
#line 4159
        if (! tmp___1) {
#line 4159
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4209
    (r->h)->refresh_type = (unsigned char )((int )(r->h)->refresh_type | (1 << 4));
#line 4210
    (r->h)->want_clip_refresh = (unsigned char)1;
  } else {
    {
#line 4236
    tmp___2 = rxvt_is_tabbar_win(r, win);
    }
#line 4236
    if (tmp___2) {
      {
#line 4236
      tmp___3 = rxvt_tabbar_visible(r);
      }
#line 4236
      if (tmp___3) {
        {
#line 4238
        rxvt_tabbar_expose(r, ev);
        }
#line 4239
        return;
      }
    }
    {
#line 4243
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4243
      tmp___4 = XCheckTypedWindowEvent(r->Xdisplay, win, 12, & unused_xevent);
      }
#line 4243
      if (! tmp___4) {
        {
#line 4243
        tmp___5 = XCheckTypedWindowEvent(r->Xdisplay, win, 13, & unused_xevent);
        }
#line 4243
        if (! tmp___5) {
#line 4243
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4250
    tmp___6 = rxvt_is_scrollbar_win(r, win);
    }
#line 4250
    if (tmp___6) {
      {
#line 4250
      tmp___7 = rxvt_scrollbar_visible(r);
      }
#line 4250
      if (tmp___7) {
        {
#line 4252
        r->scrollBar.state = (char)1;
#line 4253
        rxvt_scrollbar_update(r, 0);
        }
#line 4254
        return;
      }
    }
  }
#line 4266
  return;
}
}
#line 4270 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_motionnotify(rxvt_t *r , XEvent *ev ) 
{ 
  int page ;
  Window unused_root ;
  Window unused_child ;
  int unused_root_x ;
  int unused_root_y ;
  unsigned int unused_mask ;
  int tmp ;
  int tmp___0 ;
  int dist ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4273
  page = (int )r->tabBar.atab;
#line 4281
  if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 4281
    if ((r->vts[page])->hidden_pointer) {
      {
#line 4282
      rxvt_pointer_unblank(r, page);
      }
    }
  }
#line 4298
  if ((unsigned long )(r->vts[page])->PrivateModes & ((1UL << 12) | (1UL << 13))) {
#line 4298
    if (! (r->h)->bypass_keystate) {
#line 4300
      return;
    }
  }
#line 4302
  if (ev->xany.window == (r->vts[page])->vt) {
#line 4304
    if (ev->xbutton.state & (unsigned int )((1 << 8) | (1 << 10))) {
      {
#line 4306
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 4306
        tmp = XCheckTypedWindowEvent(r->Xdisplay, (r->vts[page])->vt, 6, ev);
        }
#line 4306
        if (! tmp) {
#line 4306
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 4309
      XQueryPointer(r->Xdisplay, (r->vts[page])->vt, & unused_root, & unused_child,
                    & unused_root_x, & unused_root_y, & ev->xbutton.x, & ev->xbutton.y,
                    & unused_mask);
      }
#line 4316
      if (ev->xmotion.time - (r->h)->MEvent.time > 50UL) {
#line 4319
        if (ev->xbutton.state & (unsigned int )(1 << 10)) {
#line 4319
          tmp___0 = 2;
        } else {
#line 4319
          tmp___0 = 0;
        }
        {
#line 4319
        rxvt_selection_extend(r, page, ev->xbutton.x, ev->xbutton.y, tmp___0);
        }
#line 4323
        if (ev->xbutton.y < (int )r->TermWin.int_bwidth) {
#line 4323
          goto _L;
        } else
#line 4323
        if ((ev->xbutton.y - (int32_t )r->TermWin.int_bwidth) / (int32_t )r->TermWin.fheight > (int )r->TermWin.nrow - 1) {
          _L: /* CIL Label */ 
#line 4330
          (r->h)->pending_scroll_selection = 1;
#line 4336
          if ((r->h)->scroll_selection_delay <= 0) {
#line 4337
            (r->h)->scroll_selection_delay = 2;
          }
#line 4343
          (r->h)->selection_save_x = ev->xbutton.x;
#line 4344
          (r->h)->selection_save_y = ev->xbutton.y;
#line 4345
          if (ev->xbutton.state & (unsigned int )(1 << 10)) {
#line 4345
            (r->h)->selection_save_state = 2;
          } else {
#line 4345
            (r->h)->selection_save_state = 0;
          }
#line 4348
          if (ev->xbutton.y < (int )r->TermWin.int_bwidth) {
#line 4350
            (r->h)->scroll_selection_dir = (enum page_dirn )0;
#line 4351
            dist = (int )r->TermWin.int_bwidth - ev->xbutton.y;
          } else {
#line 4355
            (r->h)->scroll_selection_dir = (enum page_dirn )1;
#line 4356
            dist = ev->xbutton.y - ((int )r->TermWin.int_bwidth + ((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth));
          }
#line 4359
          (r->h)->scroll_selection_lines = (dist / (int32_t )r->TermWin.fheight) / 4 + 1;
#line 4361
          if (2 < (r->h)->scroll_selection_lines) {
#line 4361
            (r->h)->scroll_selection_lines = 2;
          }
        } else {
#line 4370
          (r->h)->pending_scroll_selection = 0;
        }
      }
    }
  } else {
    {
#line 4379
    tmp___4 = rxvt_is_scrollbar_win(r, ev->xany.window);
    }
#line 4379
    if (tmp___4) {
#line 4379
      if ((int )r->scrollBar.state == 109) {
        {
#line 4384
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 4384
          tmp___1 = XCheckTypedWindowEvent(r->Xdisplay, r->scrollBar.win, 6, ev);
          }
#line 4384
          if (! tmp___1) {
#line 4384
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 4390
        XQueryPointer(r->Xdisplay, r->scrollBar.win, & unused_root, & unused_child,
                      & unused_root_x, & unused_root_y, & ev->xbutton.x, & ev->xbutton.y,
                      & unused_mask);
        }
#line 4395
        if ((int )r->scrollBar.style == 1) {
#line 4395
          tmp___3 = ((17 - (1 << 1)) - 1) - (1 << 1);
        } else {
#line 4395
          if ((int )r->scrollBar.style == 3) {
#line 4395
            tmp___2 = 10;
          } else {
#line 4395
            tmp___2 = 10;
          }
#line 4395
          tmp___3 = tmp___2;
        }
        {
#line 4395
        rxvt_scr_move_to(r, page, (ev->xbutton.y - (int )r->scrollBar.beg) - (r->h)->csrO,
                         ((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___3);
#line 4399
        rxvt_scr_refresh(r, page, (unsigned char )((int )(r->h)->refresh_type & ~ (1 << 4)));
#line 4400
        rxvt_scrollbar_update(r, 1);
        }
      }
    }
  }
#line 4403
  return;
}
}
#line 4407 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_x_event(rxvt_t *r , XEvent *ev ) 
{ 
  int page ;
  int i ;
  int want_timeout ;
  struct timeval tp ;
  struct rxvt_hidden *h ;
  int tmp ;
  int tmp___0 ;

  {
#line 4410
  page = (int )r->tabBar.atab;
#line 4411
  want_timeout = 0;
#line 4413
  h = r->h;
#line 4460
  i = 1;
  {
#line 4460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4460
    tmp = i;
#line 4460
    i --;
#line 4460
    if (! tmp) {
#line 4460
      goto while_break;
    }
#line 4461
    if (h->timeout[i].tv_sec) {
#line 4463
      want_timeout = 1;
#line 4464
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4468
  if (want_timeout) {
    {
#line 4470
    gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
    }
  }
#line 4478
  if (want_timeout) {
#line 4480
    i = 1;
    {
#line 4480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4480
      tmp___0 = i;
#line 4480
      i --;
#line 4480
      if (! tmp___0) {
#line 4480
        goto while_break___0;
      }
#line 4482
      if (h->timeout[i].tv_sec == 0L) {
#line 4490
        goto __Cont;
      } else
#line 4482
      if (tp.tv_sec < h->timeout[i].tv_sec) {
#line 4490
        goto __Cont;
      } else
#line 4482
      if (tp.tv_sec == h->timeout[i].tv_sec) {
#line 4482
        if (tp.tv_usec < h->timeout[i].tv_usec) {
#line 4490
          goto __Cont;
        }
      }
#line 4493
      h->timeout[i].tv_sec = (__time_t )0;
      {
#line 4496
      if (i == 0) {
#line 4496
        goto case_0;
      }
#line 4502
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 4497
      rxvt_msg((uint32_t )1, (uint32_t )1, "data loss: timeout on INCR selection paste");
#line 4499
      h->selection_wait = (unsigned char)0;
      }
#line 4500
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4503
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 4511
  if (ev->type == 2) {
#line 4511
    goto case_2;
  }
#line 4521
  if (ev->type == 4) {
#line 4521
    goto case_4;
  }
#line 4525
  if (ev->type == 5) {
#line 4525
    goto case_5;
  }
#line 4529
  if (ev->type == 33) {
#line 4529
    goto case_33;
  }
#line 4533
  if (ev->type == 34) {
#line 4533
    goto case_34;
  }
#line 4547
  if (ev->type == 15) {
#line 4547
    goto case_15;
  }
#line 4561
  if (ev->type == 9) {
#line 4561
    goto case_9;
  }
#line 4565
  if (ev->type == 10) {
#line 4565
    goto case_10;
  }
#line 4569
  if (ev->type == 22) {
#line 4569
    goto case_22;
  }
#line 4573
  if (ev->type == 29) {
#line 4573
    goto case_29;
  }
#line 4577
  if (ev->type == 31) {
#line 4577
    goto case_31;
  }
#line 4581
  if (ev->type == 30) {
#line 4581
    goto case_30;
  }
#line 4585
  if (ev->type == 18) {
#line 4585
    goto case_18;
  }
#line 4589
  if (ev->type == 19) {
#line 4589
    goto case_19;
  }
#line 4593
  if (ev->type == 28) {
#line 4593
    goto case_28;
  }
#line 4597
  if (ev->type == 21) {
#line 4597
    goto case_21;
  }
#line 4602
  if (ev->type == 12) {
#line 4602
    goto case_12;
  }
#line 4602
  if (ev->type == 13) {
#line 4602
    goto case_12;
  }
#line 4606
  if (ev->type == 6) {
#line 4606
    goto case_6;
  }
#line 4509
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 4512
  rxvt_process_keypress(r, (XKeyEvent *)ev);
  }
#line 4513
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 4522
  rxvt_process_buttonpress(r, page, (XButtonEvent *)ev);
  }
#line 4523
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 4526
  rxvt_process_buttonrelease(r, page, (XButtonEvent *)ev);
  }
#line 4527
  goto switch_break___0;
  case_33: /* CIL Label */ 
  {
#line 4530
  rxvt_process_clientmessage(r, (XClientMessageEvent *)ev);
  }
#line 4531
  goto switch_break___0;
  case_34: /* CIL Label */ 
  {
#line 4534
  XRefreshKeyboardMapping(& ev->xmapping);
  }
#line 4535
  goto switch_break___0;
  case_15: /* CIL Label */ 
  {
#line 4548
  rxvt_process_visibilitynotify(r, (XVisibilityEvent *)ev);
  }
#line 4549
  goto switch_break___0;
  case_9: /* CIL Label */ 
  {
#line 4562
  rxvt_process_focusin(r, (XFocusChangeEvent *)ev);
  }
#line 4563
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 4566
  rxvt_process_focusout(r, (XFocusChangeEvent *)ev);
  }
#line 4567
  goto switch_break___0;
  case_22: /* CIL Label */ 
  {
#line 4570
  rxvt_process_configurenotify(r, (XConfigureEvent *)ev);
  }
#line 4571
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 4574
  rxvt_process_selectionclear(r, page);
  }
#line 4575
  goto switch_break___0;
  case_31: /* CIL Label */ 
  {
#line 4578
  rxvt_process_selectionnotify(r, (XSelectionEvent *)ev);
  }
#line 4579
  goto switch_break___0;
  case_30: /* CIL Label */ 
  {
#line 4582
  rxvt_process_selectionrequest(r, page, (XSelectionRequestEvent const   *)((XSelectionRequestEvent *)ev));
  }
#line 4583
  goto switch_break___0;
  case_18: /* CIL Label */ 
#line 4586
  r->TermWin.mapped = (uint16_t )0;
#line 4587
  goto switch_break___0;
  case_19: /* CIL Label */ 
#line 4590
  r->TermWin.mapped = (uint16_t )1;
#line 4591
  goto switch_break___0;
  case_28: /* CIL Label */ 
  {
#line 4594
  rxvt_process_propertynotify(r, ev);
  }
#line 4595
  goto switch_break___0;
  case_21: /* CIL Label */ 
  {
#line 4598
  rxvt_process_reparentnotify(r, ev);
  }
#line 4599
  goto switch_break___0;
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 4603
  rxvt_process_expose(r, ev);
  }
#line 4604
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 4607
  rxvt_process_motionnotify(r, ev);
  }
#line 4608
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 4610
  return;
}
}
#line 4618 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
FILE *rxvt_popen_printer(rxvt_t *r , char const   *pipeName ) 
{ 
  FILE *stream ;
  char const   *tmp ;
  FILE *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 4621
  if (pipeName) {
#line 4621
    tmp = pipeName;
  } else {
#line 4621
    tmp = (r->h)->rs[317];
  }
  {
#line 4621
  tmp___0 = popen(tmp, "w");
#line 4621
  stream = tmp___0;
  }
#line 4626
  if ((unsigned long )((void *)0) == (unsigned long )stream) {
#line 4627
    if ((r->h)->rs[317]) {
#line 4627
      tmp___1 = (r->h)->rs[317];
    } else {
#line 4627
      tmp___1 = pipeName;
    }
    {
#line 4627
    rxvt_msg((uint32_t )1, (uint32_t )1, "Can\'t open printer pipe %s", tmp___1);
    }
  }
#line 4630
  return (stream);
}
}
#line 4635 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_pclose_printer(FILE *stream ) 
{ 
  int tmp ;

  {
  {
#line 4638
  fflush(stream);
#line 4642
  tmp = pclose(stream);
  }
#line 4642
  return (tmp);
}
}
#line 4650 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_print_pipe(rxvt_t *r , int page ) 
{ 


  {
  {
#line 4653
  rxvt_msg((uint32_t )1, (uint32_t )1, "Print pipe not implemented in this version");
  }
#line 4722
  return;
}
}
#line 4742 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_set_escfail(rxvt_t *r , int page , int nchars ) 
{ 


  {
  {
#line 4747
  rxvt_check_cmdbuf(r, page);
#line 4748
  (r->vts[page])->cmdbuf_escfail = ((r->vts[page])->cmdbuf_ptr + nchars) - 1;
  }
#line 4750
  if ((unsigned long )(r->vts[page])->cmdbuf_escfail > (unsigned long )(((r->vts[page])->cmdbuf_base + 8192) - 3)) {
#line 4756
    (r->vts[page])->cmdbuf_ptr = (r->vts[page])->cmdbuf_escstart + 1;
#line 4757
    (r->vts[page])->cmdbuf_escstart = (unsigned char *)((void *)0);
#line 4758
    (r->vts[page])->cmdbuf_escfail = (unsigned char *)((void *)0);
  } else {
#line 4763
    (r->vts[page])->cmdbuf_ptr = (r->vts[page])->cmdbuf_escstart;
  }
#line 4764
  return;
}
}
#line 4768 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_nonprinting(rxvt_t *r , int page , unsigned char ch ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 4773
  if ((int )ch == 5) {
#line 4773
    goto case_5;
  }
#line 4783
  if ((int )ch == 7) {
#line 4783
    goto case_7;
  }
#line 4789
  if ((int )ch == 8) {
#line 4789
    goto case_8;
  }
#line 4793
  if ((int )ch == 9) {
#line 4793
    goto case_9;
  }
#line 4797
  if ((int )ch == 13) {
#line 4797
    goto case_13;
  }
#line 4803
  if ((int )ch == 10) {
#line 4803
    goto case_10;
  }
#line 4803
  if ((int )ch == 12) {
#line 4803
    goto case_10;
  }
#line 4803
  if ((int )ch == 11) {
#line 4803
    goto case_10;
  }
#line 4807
  if ((int )ch == 14) {
#line 4807
    goto case_14;
  }
#line 4811
  if ((int )ch == 15) {
#line 4811
    goto case_15;
  }
#line 4771
  goto switch_break;
  case_5: /* CIL Label */ 
#line 4774
  if ((r->h)->rs[328]) {
    {
#line 4775
    tmp = strlen((r->h)->rs[328]);
#line 4775
    rxvt_tt_write(r, page, (unsigned char const   *)(r->h)->rs[328], (int )((unsigned int )tmp));
    }
  } else {
    {
#line 4779
    tmp___0 = strlen("\033[?1;2c");
#line 4779
    rxvt_tt_write(r, page, (unsigned char const   *)((unsigned char *)"\033[?1;2c"),
                  (int )((unsigned int )tmp___0));
    }
  }
#line 4781
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 4784
  rxvt_scr_bell(r, page);
  }
#line 4785
  if (page != (int )r->tabBar.atab) {
    {
#line 4786
    rxvt_tabbar_highlight_tab(r, (short )page, 0);
    }
  }
#line 4787
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 4790
  rxvt_scr_backspace(r, page);
  }
#line 4791
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 4794
  rxvt_scr_tab(r, page, 1);
  }
#line 4795
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 4798
  rxvt_scr_gotorc(r, page, 0, 0, 2);
  }
#line 4799
  goto switch_break;
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  {
#line 4804
  rxvt_scr_index(r, page, (enum page_dirn )0);
  }
#line 4805
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 4808
  rxvt_scr_charset_choose(r, page, 1);
  }
#line 4809
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 4812
  rxvt_scr_charset_choose(r, page, 0);
  }
#line 4813
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4815
  return;
}
}
#line 4821 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_escape_vt52(rxvt_t *r , int page , unsigned char ch ) 
{ 
  int row ;
  int col ;
  int readpage ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 4825
  readpage = page;
  {
#line 4829
  if ((int )ch == 65) {
#line 4829
    goto case_65;
  }
#line 4833
  if ((int )ch == 66) {
#line 4833
    goto case_66;
  }
#line 4837
  if ((int )ch == 67) {
#line 4837
    goto case_67;
  }
#line 4841
  if ((int )ch == 68) {
#line 4841
    goto case_68;
  }
#line 4845
  if ((int )ch == 72) {
#line 4845
    goto case_72;
  }
#line 4849
  if ((int )ch == 73) {
#line 4849
    goto case_73;
  }
#line 4853
  if ((int )ch == 74) {
#line 4853
    goto case_74;
  }
#line 4857
  if ((int )ch == 75) {
#line 4857
    goto case_75;
  }
#line 4861
  if ((int )ch == 89) {
#line 4861
    goto case_89;
  }
#line 4884
  if ((int )ch == 90) {
#line 4884
    goto case_90;
  }
#line 4889
  if ((int )ch == 60) {
#line 4889
    goto case_60;
  }
#line 4894
  if ((int )ch == 71) {
#line 4894
    goto case_71;
  }
#line 4894
  if ((int )ch == 70) {
#line 4894
    goto case_71;
  }
#line 4899
  if ((int )ch == 62) {
#line 4899
    goto case_62;
  }
#line 4899
  if ((int )ch == 61) {
#line 4899
    goto case_62;
  }
#line 4827
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 4830
  rxvt_scr_gotorc(r, page, -1, 0, 3);
  }
#line 4831
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 4834
  rxvt_scr_gotorc(r, page, 1, 0, 3);
  }
#line 4835
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 4838
  rxvt_scr_gotorc(r, page, 0, 1, 3);
  }
#line 4839
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 4842
  rxvt_scr_gotorc(r, page, 0, -1, 3);
  }
#line 4843
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 4846
  rxvt_scr_gotorc(r, page, 0, 0, 0);
  }
#line 4847
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 4850
  rxvt_scr_index(r, page, (enum page_dirn )1);
  }
#line 4851
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 4854
  rxvt_scr_erase_screen(r, page, 0);
  }
#line 4855
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 4858
  rxvt_scr_erase_line(r, page, 0);
  }
#line 4859
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 4867
  tmp = rxvt_cmd_getc(r, & readpage);
#line 4867
  row = (int )tmp - 32;
  }
#line 4868
  if (readpage == -1) {
    {
#line 4870
    rxvt_set_escfail(r, page, 2);
    }
#line 4871
    goto switch_break;
  }
  {
#line 4874
  tmp___0 = rxvt_cmd_getc(r, & readpage);
#line 4874
  col = (int )tmp___0 - 32;
  }
#line 4875
  if (readpage == -1) {
    {
#line 4877
    rxvt_set_escfail(r, page, 1);
    }
#line 4878
    goto switch_break;
  }
  {
#line 4881
  rxvt_scr_gotorc(r, page, row, col, 0);
  }
#line 4882
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 4886
  rxvt_tt_printf(r, page, "\033/Z");
  }
#line 4887
  goto switch_break;
  case_60: /* CIL Label */ 
#line 4890
  (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes & ~ (1UL << 19));
#line 4891
  goto switch_break;
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
#line 4896
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 4901
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4903
  return;
}
}
#line 4909 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_escape_seq(rxvt_t *r , int page ) 
{ 
  int readpage ;
  unsigned char c ;
  unsigned char ch ;
  unsigned char tmp ;

  {
  {
#line 4912
  readpage = page;
#line 4913
  tmp = rxvt_cmd_getc(r, & readpage);
#line 4913
  ch = tmp;
  }
#line 4916
  if (readpage == -1) {
    {
#line 4918
    rxvt_set_escfail(r, page, 1);
    }
#line 4919
    return;
  }
#line 4922
  if ((unsigned long )(r->vts[page])->PrivateModes & (1UL << 19)) {
    {
#line 4924
    rxvt_process_escape_vt52(r, page, ch);
    }
#line 4925
    return;
  }
  {
#line 4931
  if ((int )ch == 35) {
#line 4931
    goto case_35;
  }
#line 4941
  if ((int )ch == 40) {
#line 4941
    goto case_40;
  }
#line 4950
  if ((int )ch == 41) {
#line 4950
    goto case_41;
  }
#line 4960
  if ((int )ch == 42) {
#line 4960
    goto case_42;
  }
#line 4970
  if ((int )ch == 43) {
#line 4970
    goto case_43;
  }
#line 4993
  if ((int )ch == 54) {
#line 4993
    goto case_54;
  }
#line 4997
  if ((int )ch == 55) {
#line 4997
    goto case_55;
  }
#line 5000
  if ((int )ch == 56) {
#line 5000
    goto case_56;
  }
#line 5004
  if ((int )ch == 57) {
#line 5004
    goto case_57;
  }
#line 5009
  if ((int )ch == 62) {
#line 5009
    goto case_62;
  }
#line 5009
  if ((int )ch == 61) {
#line 5009
    goto case_62;
  }
#line 5013
  if ((int )ch == 64) {
#line 5013
    goto case_64;
  }
#line 5023
  if ((int )ch == 68) {
#line 5023
    goto case_68;
  }
#line 5028
  if ((int )ch == 69) {
#line 5028
    goto case_69;
  }
#line 5033
  if ((int )ch == 71) {
#line 5033
    goto case_71;
  }
#line 5038
  if ((int )ch == 72) {
#line 5038
    goto case_72;
  }
#line 5043
  if ((int )ch == 77) {
#line 5043
    goto case_77;
  }
#line 5054
  if ((int )ch == 80) {
#line 5054
    goto case_80;
  }
#line 5060
  if ((int )ch == 90) {
#line 5060
    goto case_90;
  }
#line 5066
  if ((int )ch == 91) {
#line 5066
    goto case_91;
  }
#line 5071
  if ((int )ch == 93) {
#line 5071
    goto case_93;
  }
#line 5076
  if ((int )ch == 99) {
#line 5076
    goto case_99;
  }
#line 5084
  if ((int )ch == 110) {
#line 5084
    goto case_110;
  }
#line 5089
  if ((int )ch == 111) {
#line 5089
    goto case_111;
  }
#line 4928
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 4932
  c = rxvt_cmd_getc(r, & readpage);
  }
#line 4934
  if (readpage == -1) {
    {
#line 4935
    rxvt_set_escfail(r, page, 1);
    }
  } else
#line 4936
  if ((int )c == 8) {
    {
#line 4937
    rxvt_scr_E(r, readpage);
    }
  }
#line 4939
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 4942
  c = rxvt_cmd_getc(r, & readpage);
  }
#line 4944
  if (readpage == -1) {
    {
#line 4945
    rxvt_set_escfail(r, page, 1);
    }
  } else {
    {
#line 4947
    rxvt_scr_charset_set(r, page, 0, (unsigned int )c);
    }
  }
#line 4948
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 4951
  c = rxvt_cmd_getc(r, & readpage);
  }
#line 4953
  if (readpage == -1) {
    {
#line 4954
    rxvt_set_escfail(r, page, 1);
    }
  } else {
    {
#line 4956
    rxvt_scr_charset_set(r, page, 1, (unsigned int )c);
    }
  }
#line 4958
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 4961
  c = rxvt_cmd_getc(r, & readpage);
  }
#line 4963
  if (readpage == -1) {
    {
#line 4964
    rxvt_set_escfail(r, page, 1);
    }
  } else {
    {
#line 4966
    rxvt_scr_charset_set(r, page, 2, (unsigned int )c);
    }
  }
#line 4968
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 4971
  c = rxvt_cmd_getc(r, & readpage);
  }
#line 4973
  if (readpage == -1) {
    {
#line 4974
    rxvt_set_escfail(r, page, 1);
    }
  } else {
    {
#line 4976
    rxvt_scr_charset_set(r, page, 3, (unsigned int )c);
    }
  }
#line 4978
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 4994
  rxvt_scr_backindex(r, page);
  }
#line 4995
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 4998
  rxvt_scr_cursor(r, page, 's');
  }
#line 4999
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 5001
  rxvt_scr_cursor(r, page, 'r');
  }
#line 5002
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 5005
  rxvt_scr_forwardindex(r, page);
  }
#line 5006
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 5010
  if ((int )ch == 61) {
#line 5010
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 7));
  } else {
#line 5010
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes & ~ (1UL << 7));
  }
#line 5011
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 5014
  c = rxvt_cmd_getc(r, & readpage);
  }
#line 5016
  if (readpage == -1) {
    {
#line 5017
    rxvt_set_escfail(r, page, 1);
    }
  }
#line 5021
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 5024
  rxvt_scr_index(r, page, (enum page_dirn )0);
  }
#line 5025
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 5029
  rxvt_scr_add_lines(r, page, (unsigned char const   *)"\n\r", 1, 2);
  }
#line 5030
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 5034
  rxvt_process_graphics(r, page);
  }
#line 5035
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 5039
  rxvt_scr_set_tab(r, page, 1);
  }
#line 5040
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 5044
  rxvt_scr_index(r, page, (enum page_dirn )1);
  }
#line 5045
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 5056
  rxvt_process_xwsh_seq(r, page);
  }
#line 5057
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 5061
  rxvt_tt_write(r, page, (unsigned char const   *)"\033[?1;2c", (int )((unsigned int )(sizeof("\033[?1;2c") - 1UL)));
  }
#line 5063
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 5067
  rxvt_process_csi_seq(r, page);
  }
#line 5068
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 5072
  rxvt_process_osc_seq(r, page);
  }
#line 5073
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 5077
  rxvt_scr_poweron(r, page);
#line 5079
  rxvt_scrollbar_update(r, 1);
  }
#line 5081
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 5085
  rxvt_scr_charset_choose(r, page, 2);
  }
#line 5086
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 5090
  rxvt_scr_charset_choose(r, page, 3);
  }
#line 5091
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5093
  return;
}
}
#line 5117 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
unsigned char const   csi_defaults[8]  = 
#line 5117
  {      (unsigned char const   )((((((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 4)) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1),      (unsigned char const   )((((1 << 7) | (1 << 6)) | (1 << 3)) | (1 << 2)),      (unsigned char const   )((((((1 << 7) | (1 << 5)) | (1 << 4)) | (1 << 3)) | (1 << 2)) | (1 << 1)),      (unsigned char const   )((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 1)), 
        (unsigned char const   )((((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 3)) | (1 << 2)) | (1 << 1)),      (unsigned char const   )((1 << 5) | (1 << 4)),      (unsigned char const   )0,      (unsigned char const   )0};
#line 5131 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_csi_seq(rxvt_t *r , int page ) 
{ 
  int readpage ;
  unsigned char ch ;
  unsigned char priv ;
  unsigned char i ;
  unsigned int nargs ;
  unsigned int p ;
  int n ;
  int ndef ;
  int arg[32] ;
  unsigned int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 5134
  readpage = page;
#line 5141
  nargs = 32U;
  {
#line 5141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5141
    if (! (nargs > 0U)) {
#line 5141
      goto while_break;
    }
#line 5142
    nargs --;
#line 5142
    arg[nargs] = 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5144
  priv = (unsigned char)0;
#line 5145
  ch = rxvt_cmd_getc(r, & readpage);
  }
#line 5146
  if (readpage == -1) {
    {
#line 5148
    rxvt_set_escfail(r, page, 1);
    }
#line 5149
    return;
  }
#line 5152
  if ((int )ch >= 60) {
#line 5152
    if ((int )ch <= 63) {
      {
#line 5154
      priv = ch;
#line 5155
      ch = rxvt_cmd_getc(r, & readpage);
      }
#line 5156
      if (readpage == -1) {
        {
#line 5158
        rxvt_set_escfail(r, page, 1);
        }
#line 5159
        return;
      }
    }
  }
#line 5164
  n = -1;
  {
#line 5164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5164
    if (! ((int )ch < 64)) {
#line 5164
      goto while_break___0;
    }
    {
#line 5166
    tmp___0 = __ctype_b_loc();
    }
#line 5166
    if ((int const   )*(*tmp___0 + (int )ch) & 2048) {
#line 5168
      if (n < 0) {
#line 5169
        n = (int )ch - 48;
      } else {
#line 5171
        n = (n * 10 + (int )ch) - 48;
      }
    } else
#line 5173
    if ((int )ch == 59) {
#line 5175
      if (nargs < 32U) {
#line 5176
        tmp = nargs;
#line 5176
        nargs ++;
#line 5176
        arg[tmp] = n;
      }
#line 5177
      n = -1;
    } else
#line 5179
    if ((int )ch == 8) {
      {
#line 5181
      rxvt_scr_backspace(r, page);
      }
    } else
#line 5183
    if ((int )ch == 27) {
      {
#line 5185
      rxvt_process_escape_seq(r, page);
      }
#line 5186
      return;
    } else
#line 5188
    if ((int )ch < 32) {
      {
#line 5190
      rxvt_process_nonprinting(r, page, ch);
      }
    }
    {
#line 5193
    ch = rxvt_cmd_getc(r, & readpage);
    }
#line 5194
    if (readpage == -1) {
      {
#line 5196
      rxvt_set_escfail(r, page, 1);
      }
#line 5197
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5201
  if ((int )ch > 127) {
#line 5202
    return;
  }
#line 5204
  if (nargs < 32U) {
#line 5205
    tmp___1 = nargs;
#line 5205
    nargs ++;
#line 5205
    arg[tmp___1] = n;
  }
#line 5207
  i = (unsigned char )((int )ch - 64);
#line 5208
  ndef = ! (! ((int const   )csi_defaults[(int )i / 8] & (int const   )(128 >> ((int )i & 7))));
#line 5209
  p = 0U;
  {
#line 5209
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5209
    if (! (p < nargs)) {
#line 5209
      goto while_break___1;
    }
#line 5210
    if (arg[p] == -1) {
#line 5211
      arg[p] = ndef;
    }
#line 5209
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5222
  if (priv) {
    {
#line 5226
    if ((int )priv == 62) {
#line 5226
      goto case_62;
    }
#line 5230
    if ((int )priv == 63) {
#line 5230
      goto case_63;
    }
#line 5224
    goto switch_break;
    case_62: /* CIL Label */ 
#line 5227
    if ((int )ch == 99) {
      {
#line 5228
      rxvt_tt_printf(r, page, "\033[>%d;%-.8s;0c", 'R', "0.5.4");
      }
    }
#line 5229
    goto switch_break;
    case_63: /* CIL Label */ 
#line 5231
    if ((int )ch == 104) {
      {
#line 5233
      rxvt_process_terminal_mode(r, page, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 5231
    if ((int )ch == 108) {
      {
#line 5233
      rxvt_process_terminal_mode(r, page, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 5231
    if ((int )ch == 114) {
      {
#line 5233
      rxvt_process_terminal_mode(r, page, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 5231
    if ((int )ch == 115) {
      {
#line 5233
      rxvt_process_terminal_mode(r, page, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    } else
#line 5231
    if ((int )ch == 116) {
      {
#line 5233
      rxvt_process_terminal_mode(r, page, (int )ch, (int )priv, nargs, (int const   *)(arg));
      }
    }
#line 5235
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5237
    return;
  }
  {
#line 5245
  if ((int )ch == 105) {
#line 5245
    goto case_105;
  }
#line 5259
  if ((int )ch == 101) {
#line 5259
    goto case_101;
  }
#line 5259
  if ((int )ch == 65) {
#line 5259
    goto case_101;
  }
#line 5263
  if ((int )ch == 107) {
#line 5263
    goto case_107;
  }
#line 5263
  if ((int )ch == 66) {
#line 5263
    goto case_107;
  }
#line 5268
  if ((int )ch == 106) {
#line 5268
    goto case_106;
  }
#line 5268
  if ((int )ch == 68) {
#line 5268
    goto case_106;
  }
#line 5276
  if ((int )ch == 97) {
#line 5276
    goto case_97;
  }
#line 5276
  if ((int )ch == 67) {
#line 5276
    goto case_97;
  }
#line 5284
  if ((int )ch == 70) {
#line 5284
    goto case_70;
  }
#line 5287
  if ((int )ch == 69) {
#line 5287
    goto case_69;
  }
#line 5292
  if ((int )ch == 96) {
#line 5292
    goto case_96;
  }
#line 5292
  if ((int )ch == 71) {
#line 5292
    goto case_96;
  }
#line 5296
  if ((int )ch == 100) {
#line 5296
    goto case_100;
  }
#line 5301
  if ((int )ch == 102) {
#line 5301
    goto case_102;
  }
#line 5301
  if ((int )ch == 72) {
#line 5301
    goto case_102;
  }
#line 5305
  if ((int )ch == 90) {
#line 5305
    goto case_90;
  }
#line 5308
  if ((int )ch == 73) {
#line 5308
    goto case_73;
  }
#line 5312
  if ((int )ch == 74) {
#line 5312
    goto case_74;
  }
#line 5316
  if ((int )ch == 75) {
#line 5316
    goto case_75;
  }
#line 5320
  if ((int )ch == 64) {
#line 5320
    goto case_64;
  }
#line 5324
  if ((int )ch == 76) {
#line 5324
    goto case_76;
  }
#line 5328
  if ((int )ch == 77) {
#line 5328
    goto case_77;
  }
#line 5332
  if ((int )ch == 88) {
#line 5332
    goto case_88;
  }
#line 5336
  if ((int )ch == 80) {
#line 5336
    goto case_80;
  }
#line 5340
  if ((int )ch == 84) {
#line 5340
    goto case_84;
  }
#line 5343
  if ((int )ch == 83) {
#line 5343
    goto case_83;
  }
#line 5348
  if ((int )ch == 99) {
#line 5348
    goto case_99;
  }
#line 5353
  if ((int )ch == 109) {
#line 5353
    goto case_109;
  }
#line 5357
  if ((int )ch == 110) {
#line 5357
    goto case_110;
  }
#line 5379
  if ((int )ch == 103) {
#line 5379
    goto case_103;
  }
#line 5395
  if ((int )ch == 87) {
#line 5395
    goto case_87;
  }
#line 5414
  if ((int )ch == 108) {
#line 5414
    goto case_108;
  }
#line 5419
  if ((int )ch == 104) {
#line 5419
    goto case_104;
  }
#line 5425
  if ((int )ch == 114) {
#line 5425
    goto case_114;
  }
#line 5434
  if ((int )ch == 115) {
#line 5434
    goto case_115;
  }
#line 5437
  if ((int )ch == 117) {
#line 5437
    goto case_117;
  }
#line 5442
  if ((int )ch == 116) {
#line 5442
    goto case_116;
  }
#line 5447
  if ((int )ch == 120) {
#line 5447
    goto case_120;
  }
#line 5452
  goto switch_default;
  case_105: /* CIL Label */ 
  {
#line 5248
  if (arg[0] == 0) {
#line 5248
    goto case_0;
  }
#line 5251
  if (arg[0] == 5) {
#line 5251
    goto case_5;
  }
#line 5246
  goto switch_break___1;
  case_0: /* CIL Label */ 
  {
#line 5249
  rxvt_scr_printscreen(r, page, 0, 0, 0, (char const   *)((void *)0));
  }
#line 5250
  goto switch_break___1;
  case_5: /* CIL Label */ 
  {
#line 5252
  rxvt_process_print_pipe(r, page);
  }
#line 5253
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 5255
  goto switch_break___0;
  case_101: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 5260
  arg[0] = - arg[0];
  case_107: /* CIL Label */ 
  case_66: /* CIL Label */ 
  {
#line 5264
  rxvt_scr_gotorc(r, page, arg[0], 0, 3);
  }
#line 5265
  goto switch_break___0;
  case_106: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 5272
  if (arg[0]) {
#line 5272
    arg[0] = - arg[0];
  } else {
#line 5272
    arg[0] = -1;
  }
  case_97: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 5280
  if (arg[0]) {
#line 5280
    tmp___2 = arg[0];
  } else {
#line 5280
    tmp___2 = 1;
  }
  {
#line 5280
  rxvt_scr_gotorc(r, page, 0, tmp___2, 3);
  }
#line 5282
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 5285
  arg[0] = - arg[0];
  case_69: /* CIL Label */ 
  {
#line 5288
  rxvt_scr_gotorc(r, page, arg[0], 0, 2);
  }
#line 5289
  goto switch_break___0;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
  {
#line 5293
  rxvt_scr_gotorc(r, page, 0, arg[0] - 1, 2);
  }
#line 5294
  goto switch_break___0;
  case_100: /* CIL Label */ 
  {
#line 5297
  rxvt_scr_gotorc(r, page, arg[0] - 1, 0, 1);
  }
#line 5298
  goto switch_break___0;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 5302
  if (nargs < 2U) {
#line 5302
    tmp___3 = 0;
  } else {
#line 5302
    tmp___3 = arg[1] - 1;
  }
  {
#line 5302
  rxvt_scr_gotorc(r, page, arg[0] - 1, tmp___3, 0);
  }
#line 5303
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 5306
  arg[0] = - arg[0];
  case_73: /* CIL Label */ 
  {
#line 5309
  rxvt_scr_tab(r, page, arg[0]);
  }
#line 5310
  goto switch_break___0;
  case_74: /* CIL Label */ 
  {
#line 5313
  rxvt_scr_erase_screen(r, page, arg[0]);
  }
#line 5314
  goto switch_break___0;
  case_75: /* CIL Label */ 
  {
#line 5317
  rxvt_scr_erase_line(r, page, arg[0]);
  }
#line 5318
  goto switch_break___0;
  case_64: /* CIL Label */ 
  {
#line 5321
  rxvt_scr_insdel_chars(r, page, arg[0], -1);
  }
#line 5322
  goto switch_break___0;
  case_76: /* CIL Label */ 
  {
#line 5325
  rxvt_scr_insdel_lines(r, page, arg[0], -1);
  }
#line 5326
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
#line 5329
  rxvt_scr_insdel_lines(r, page, arg[0], 1);
  }
#line 5330
  goto switch_break___0;
  case_88: /* CIL Label */ 
  {
#line 5333
  rxvt_scr_insdel_chars(r, page, arg[0], 2);
  }
#line 5334
  goto switch_break___0;
  case_80: /* CIL Label */ 
  {
#line 5337
  rxvt_scr_insdel_chars(r, page, arg[0], 1);
  }
#line 5338
  goto switch_break___0;
  case_84: /* CIL Label */ 
#line 5341
  arg[0] = - arg[0];
  case_83: /* CIL Label */ 
  {
#line 5344
  rxvt_scroll_text(r, page, (int )(r->vts[page])->screen.tscroll, (int )(r->vts[page])->screen.bscroll,
                   arg[0], 0);
  }
#line 5346
  goto switch_break___0;
  case_99: /* CIL Label */ 
  {
#line 5349
  rxvt_tt_write(r, page, (unsigned char const   *)"\033[?1;2c", (int )((unsigned int )(sizeof("\033[?1;2c") - 1UL)));
  }
#line 5351
  goto switch_break___0;
  case_109: /* CIL Label */ 
  {
#line 5354
  rxvt_process_sgr_mode(r, page, nargs, (int const   *)(arg));
  }
#line 5355
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 5360
  if (arg[0] == 5) {
#line 5360
    goto case_5___0;
  }
#line 5363
  if (arg[0] == 6) {
#line 5363
    goto case_6;
  }
#line 5372
  if (arg[0] == 8) {
#line 5372
    goto case_8;
  }
#line 5358
  goto switch_break___2;
  case_5___0: /* CIL Label */ 
  {
#line 5361
  rxvt_tt_printf(r, page, "\033[0n");
  }
#line 5362
  goto switch_break___2;
  case_6: /* CIL Label */ 
  {
#line 5364
  rxvt_scr_report_position(r, page);
  }
#line 5365
  goto switch_break___2;
  case_8: /* CIL Label */ 
  {
#line 5373
  rxvt_xterm_seq(r, page, 2, "mrxvt-0.5.4", (unsigned char)156);
  }
#line 5375
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 5377
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
#line 5382
  if (arg[0] == 0) {
#line 5382
    goto case_0___0;
  }
#line 5389
  if (arg[0] == 5) {
#line 5389
    goto case_5___1;
  }
#line 5389
  if (arg[0] == 3) {
#line 5389
    goto case_5___1;
  }
#line 5380
  goto switch_break___3;
  case_0___0: /* CIL Label */ 
  {
#line 5383
  rxvt_scr_set_tab(r, page, 0);
  }
#line 5384
  goto switch_break___3;
  case_5___1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 5390
  rxvt_scr_set_tab(r, page, -1);
  }
#line 5391
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 5393
  goto switch_break___0;
  case_87: /* CIL Label */ 
  {
#line 5398
  if (arg[0] == 0) {
#line 5398
    goto case_0___1;
  }
#line 5402
  if (arg[0] == 2) {
#line 5402
    goto case_2;
  }
#line 5407
  if (arg[0] == 5) {
#line 5407
    goto case_5___2;
  }
#line 5396
  goto switch_break___4;
  case_0___1: /* CIL Label */ 
  {
#line 5399
  rxvt_scr_set_tab(r, page, 1);
  }
#line 5400
  goto switch_break___4;
  case_2: /* CIL Label */ 
  {
#line 5403
  rxvt_scr_set_tab(r, page, 0);
  }
#line 5404
  goto switch_break___4;
  case_5___2: /* CIL Label */ 
  {
#line 5408
  rxvt_scr_set_tab(r, page, -1);
  }
#line 5409
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 5412
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 5415
  if (arg[0] == 4) {
    {
#line 5416
    rxvt_scr_insert_mode(r, page, 0);
    }
  }
#line 5417
  goto switch_break___0;
  case_104: /* CIL Label */ 
#line 5420
  if (arg[0] == 4) {
    {
#line 5421
    rxvt_scr_insert_mode(r, page, 1);
    }
  }
#line 5422
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 5426
  if (nargs == 1U) {
    {
#line 5427
    rxvt_scr_scroll_region(r, page, arg[0] - 1, 999);
    }
  } else
#line 5428
  if (nargs == 0U) {
    {
#line 5429
    rxvt_scr_scroll_region(r, page, 0, 999);
    }
  } else
#line 5428
  if (arg[0] >= arg[1]) {
    {
#line 5429
    rxvt_scr_scroll_region(r, page, 0, 999);
    }
  } else {
    {
#line 5431
    rxvt_scr_scroll_region(r, page, arg[0] - 1, arg[1] - 1);
    }
  }
#line 5432
  goto switch_break___0;
  case_115: /* CIL Label */ 
  {
#line 5435
  rxvt_scr_cursor(r, page, 's');
  }
#line 5436
  goto switch_break___0;
  case_117: /* CIL Label */ 
  {
#line 5438
  rxvt_scr_cursor(r, page, 'r');
  }
#line 5439
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
#line 5443
  rxvt_process_window_ops(r, page, (int const   *)(arg), nargs);
  }
#line 5444
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 5448
  if (arg[0] == 0) {
    {
#line 5449
    rxvt_tt_printf(r, page, "\033[%d;1;1;112;112;1;0x", arg[0] + 2);
    }
  } else
#line 5448
  if (arg[0] == 1) {
    {
#line 5449
    rxvt_tt_printf(r, page, "\033[%d;1;1;112;112;1;0x", arg[0] + 2);
    }
  }
  switch_default: /* CIL Label */ 
#line 5453
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 5455
  return;
}
}
#line 5462 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_window_ops(rxvt_t *r , int page , int const   *args , unsigned int nargs ) 
{ 
  int x ;
  int y ;
  unsigned int w ;
  unsigned int h ;
  XWindowAttributes wattr ;
  Window wdummy ;
  int tmp ;

  {
#line 5471
  if (nargs == 0U) {
#line 5472
    return;
  }
  {
#line 5476
  if (*(args + 0) == 1) {
#line 5476
    goto case_1;
  }
#line 5479
  if (*(args + 0) == 2) {
#line 5479
    goto case_2;
  }
#line 5483
  if (*(args + 0) == 3) {
#line 5483
    goto case_3;
  }
#line 5486
  if (*(args + 0) == 4) {
#line 5486
    goto case_4;
  }
#line 5492
  if (*(args + 0) == 5) {
#line 5492
    goto case_5;
  }
#line 5495
  if (*(args + 0) == 6) {
#line 5495
    goto case_6;
  }
#line 5498
  if (*(args + 0) == 7) {
#line 5498
    goto case_7;
  }
#line 5501
  if (*(args + 0) == 8) {
#line 5501
    goto case_8;
  }
#line 5519
  if (*(args + 0) == 11) {
#line 5519
    goto case_11;
  }
#line 5524
  if (*(args + 0) == 13) {
#line 5524
    goto case_13;
  }
#line 5531
  if (*(args + 0) == 14) {
#line 5531
    goto case_14;
  }
#line 5536
  if (*(args + 0) == 18) {
#line 5536
    goto case_18;
  }
#line 5507
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 5477
  XMapWindow(r->Xdisplay, r->TermWin.parent);
  }
#line 5478
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 5480
  XIconifyWindow(r->Xdisplay, r->TermWin.parent, ((_XPrivDisplay )r->Xdisplay)->default_screen);
  }
#line 5482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 5484
  XMoveWindow(r->Xdisplay, r->TermWin.parent, (int )*(args + 1), (int )*(args + 2));
  }
#line 5485
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 5487
  w = (unsigned int )*(args + 2);
#line 5488
  h = (unsigned int )*(args + 1);
#line 5489
  XResizeWindow(r->Xdisplay, r->TermWin.parent, w, h);
#line 5490
  (r->h)->want_resize = (unsigned char)1;
  }
#line 5491
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 5493
  XRaiseWindow(r->Xdisplay, r->TermWin.parent);
  }
#line 5494
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 5496
  XLowerWindow(r->Xdisplay, r->TermWin.parent);
  }
#line 5497
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 5499
  rxvt_scr_touch(r, page, 1);
  }
#line 5500
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 5502
  w = (unsigned int )((int32_t )*(args + 2) * (int32_t )r->TermWin.fwidth + r->szHint.base_width);
#line 5503
  h = (unsigned int )((int32_t )*(args + 1) * (int32_t )r->TermWin.fheight + r->szHint.base_height);
#line 5504
  XResizeWindow(r->Xdisplay, r->TermWin.parent, w, h);
#line 5505
  (r->h)->want_resize = (unsigned char)1;
  }
#line 5506
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 5508
  if (*(args + 0) >= 24) {
    {
#line 5511
    w = (unsigned int )r->szHint.width;
#line 5512
    h = (unsigned int )(*(args + 1) * (int const   )r->TermWin.fheight + (int const   )r->szHint.base_height);
#line 5513
    XResizeWindow(r->Xdisplay, r->TermWin.parent, w, h);
#line 5514
    (r->h)->want_resize = (unsigned char)1;
    }
  }
#line 5516
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 5520
  XGetWindowAttributes(r->Xdisplay, r->TermWin.parent, & wattr);
  }
#line 5521
  if (wattr.map_state == 2) {
#line 5521
    tmp = 1;
  } else {
#line 5521
    tmp = 2;
  }
  {
#line 5521
  rxvt_tt_printf(r, page, "\033[%dt", tmp);
  }
#line 5523
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 5525
  XGetWindowAttributes(r->Xdisplay, r->TermWin.parent, & wattr);
#line 5526
  XTranslateCoordinates(r->Xdisplay, r->TermWin.parent, wattr.root, - wattr.border_width,
                        - wattr.border_width, & x, & y, & wdummy);
#line 5529
  rxvt_tt_printf(r, page, "\033[3;%d;%dt", x, y);
  }
#line 5530
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 5532
  XGetWindowAttributes(r->Xdisplay, r->TermWin.parent, & wattr);
#line 5533
  rxvt_tt_printf(r, page, "\033[4;%d;%dt", wattr.height, wattr.width);
  }
#line 5535
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 5537
  rxvt_tt_printf(r, page, "\033[8;%d;%dt", (int )r->TermWin.nrow, (int )r->TermWin.ncol);
  }
#line 5539
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5541
  return;
}
}
#line 5551 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
unsigned char *rxvt_get_to_st(rxvt_t *r , int page , unsigned char *ends_how ) 
{ 
  int readpage ;
  int seen_esc ;
  unsigned int n ;
  unsigned char *s ;
  unsigned char ch ;
  unsigned char string[512] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  char *tmp___1 ;

  {
#line 5554
  readpage = page;
#line 5555
  seen_esc = 0;
#line 5556
  n = 0U;
  {
#line 5561
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5563
    ch = rxvt_cmd_getc(r, & readpage);
    }
#line 5564
    if (readpage == -1) {
      {
#line 5566
      rxvt_set_escfail(r, page, 1);
      }
#line 5567
      return ((unsigned char *)((void *)0));
    }
#line 5570
    if (! ch) {
#line 5571
      goto while_break;
    }
#line 5573
    if ((int )ch == 7) {
#line 5577
      goto while_break;
    } else
#line 5573
    if ((int )ch == 156) {
#line 5577
      goto while_break;
    } else
#line 5573
    if ((int )ch == 92) {
#line 5573
      if (seen_esc) {
#line 5577
        goto while_break;
      }
    }
#line 5579
    if ((int )ch == 27) {
#line 5581
      seen_esc = 1;
#line 5582
      goto __Cont;
    } else
#line 5584
    if ((int )ch == 9) {
#line 5585
      ch = (unsigned char )' ';
    } else
#line 5586
    if ((int )ch < 8) {
#line 5598
      goto __Cont;
    } else
#line 5586
    if ((int )ch > 13) {
#line 5586
      if ((int )ch < 32) {
#line 5598
        goto __Cont;
      }
    }
#line 5601
    if ((unsigned long )n < sizeof(string) - 1UL) {
#line 5602
      tmp = n;
#line 5602
      n ++;
#line 5602
      string[tmp] = ch;
    }
#line 5604
    seen_esc = 0;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5607
  tmp___0 = n;
#line 5607
  n ++;
#line 5607
  string[tmp___0] = (unsigned char )'\000';
#line 5608
  tmp___1 = strndup((char const   *)(string), (size_t )n);
#line 5608
  s = (unsigned char *)tmp___1;
  }
#line 5608
  if ((unsigned long )((void *)0) == (unsigned long )s) {
#line 5609
    return ((unsigned char *)((void *)0));
  }
#line 5611
  if ((int )ch == 92) {
#line 5611
    *ends_how = (unsigned char)27;
  } else {
#line 5611
    *ends_how = ch;
  }
#line 5613
  return (s);
}
}
#line 5622 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_dcs_seq(rxvt_t *r , int page ) 
{ 
  unsigned char eh ;
  unsigned char *s ;

  {
  {
#line 5628
  s = rxvt_get_to_st(r, page, & eh);
  }
#line 5629
  if (s) {
    {
#line 5630
    rxvt_free((void *)s);
    }
  }
#line 5631
  return;
}
}
#line 5639 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_osc_seq(rxvt_t *r , int page ) 
{ 
  int readpage ;
  unsigned char ch ;
  unsigned char eh ;
  unsigned char *s ;
  int arg ;
  unsigned short const   **tmp ;

  {
#line 5642
  readpage = page;
#line 5649
  arg = 0;
  {
#line 5650
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5652
    ch = rxvt_cmd_getc(r, & readpage);
    }
#line 5653
    if (readpage == -1) {
      {
#line 5655
      rxvt_set_escfail(r, page, 1);
      }
#line 5656
      return;
    }
    {
#line 5659
    tmp = __ctype_b_loc();
    }
#line 5659
    if ((int const   )*(*tmp + (int )ch) & 2048) {
#line 5660
      arg = arg * 10 + ((int )ch - 48);
    } else {
#line 5662
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5666
  if ((int )ch == 59) {
    {
#line 5668
    s = rxvt_get_to_st(r, page, & eh);
    }
#line 5669
    if (s) {
#line 5675
      if (! (arg == 10)) {
        {
#line 5683
        rxvt_xterm_seq(r, page, arg, (char const   *)((char *)s), eh);
        }
      }
      {
#line 5685
      rxvt_free((void *)s);
      }
    }
  }
#line 5688
  return;
}
}
#line 5707 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_xwsh_seq(rxvt_t *r , int op , char const   *str ) 
{ 


  {
  {
#line 5713
  if (op == 1) {
#line 5713
    goto case_1;
  }
#line 5716
  if (op == 3) {
#line 5716
    goto case_3;
  }
#line 5719
  if (op == 4) {
#line 5719
    goto case_4;
  }
#line 5721
  if (op == 5) {
#line 5721
    goto case_5;
  }
#line 5723
  if (op == 6) {
#line 5723
    goto case_6;
  }
#line 5725
  if (op == 7) {
#line 5725
    goto case_7;
  }
#line 5727
  if (op == 8) {
#line 5727
    goto case_8;
  }
#line 5729
  if (op == 9) {
#line 5729
    goto case_9;
  }
#line 5731
  if (op == 10) {
#line 5731
    goto case_10;
  }
#line 5733
  if (op == 11) {
#line 5733
    goto case_11;
  }
#line 5735
  if (op == 101) {
#line 5735
    goto case_101;
  }
#line 5737
  if (op == 103) {
#line 5737
    goto case_103;
  }
#line 5711
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 5714
  rxvt_set_term_title(r, (unsigned char const   *)str);
  }
#line 5715
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 5717
  rxvt_set_icon_name(r, (unsigned char const   *)str);
  }
#line 5718
  goto switch_break;
  case_4: /* CIL Label */ 
#line 5720
  goto switch_break;
  case_5: /* CIL Label */ 
#line 5722
  goto switch_break;
  case_6: /* CIL Label */ 
#line 5724
  goto switch_break;
  case_7: /* CIL Label */ 
#line 5726
  goto switch_break;
  case_8: /* CIL Label */ 
#line 5728
  goto switch_break;
  case_9: /* CIL Label */ 
#line 5730
  goto switch_break;
  case_10: /* CIL Label */ 
#line 5732
  goto switch_break;
  case_11: /* CIL Label */ 
#line 5734
  goto switch_break;
  case_101: /* CIL Label */ 
#line 5736
  goto switch_break;
  case_103: /* CIL Label */ 
#line 5738
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5740
  return;
}
}
#line 5744 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_xwsh_seq(rxvt_t *r , int page ) 
{ 
  int readpage ;
  unsigned char ch ;
  unsigned char string[512] ;
  int arg ;
  unsigned short const   **tmp ;
  int n ;
  int tmp___0 ;

  {
#line 5747
  readpage = page;
#line 5752
  arg = 0;
  {
#line 5753
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5755
    ch = rxvt_cmd_getc(r, & readpage);
    }
#line 5756
    if (readpage == -1) {
      {
#line 5758
      rxvt_set_escfail(r, page, 1);
      }
#line 5759
      return;
    }
    {
#line 5762
    tmp = __ctype_b_loc();
    }
#line 5762
    if ((int const   )*(*tmp + (int )ch) & 2048) {
#line 5763
      arg = arg * 10 + ((int )ch - 48);
    } else {
#line 5765
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5768
  if ((int )ch == 46) {
    {
#line 5770
    ch = rxvt_cmd_getc(r, & readpage);
    }
#line 5771
    if (readpage == -1) {
      {
#line 5773
      rxvt_set_escfail(r, page, 1);
      }
#line 5774
      return;
    }
#line 5777
    if ((int )ch == 121) {
#line 5779
      n = 0;
      {
#line 5781
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 5783
        ch = rxvt_cmd_getc(r, & readpage);
        }
#line 5784
        if (readpage == -1) {
          {
#line 5786
          rxvt_set_escfail(r, page, 1);
          }
#line 5787
          return;
        }
#line 5790
        if ((int )ch == 27) {
#line 5791
          goto while_break___0;
        }
#line 5793
        if (ch) {
#line 5795
          if ((int )ch == 9) {
#line 5796
            ch = (unsigned char )' ';
          } else
#line 5797
          if ((int )ch < 32) {
#line 5798
            return;
          }
#line 5800
          if ((unsigned long )n < sizeof(string) - 1UL) {
#line 5801
            tmp___0 = n;
#line 5801
            n ++;
#line 5801
            string[tmp___0] = ch;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 5805
      ch = rxvt_cmd_getc(r, & readpage);
      }
#line 5806
      if (readpage == -1) {
        {
#line 5808
        rxvt_set_escfail(r, page, 1);
        }
#line 5809
        return;
      }
#line 5812
      if ((int )ch == 92) {
        {
#line 5814
        string[n] = (unsigned char )'\000';
#line 5815
        rxvt_xwsh_seq(r, arg, (char const   *)((char *)(string)));
        }
      }
    }
  }
#line 5819
  return;
}
}
#line 5844 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_xterm_seq(rxvt_t *r , int page , int op , char const   *str , unsigned char resp ) 
{ 
  int color ;
  char *buf ;
  char *name ;
  int changed ;
  int shade ;
  char *tmp ;
  char *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int len___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int oldopacity ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 5850
  changed = 0;
  {
#line 5861
  if (op == 0) {
#line 5861
    goto case_0;
  }
#line 5861
  if (op == 2) {
#line 5861
    goto case_0;
  }
#line 5880
  if (op == 1) {
#line 5880
    goto case_1;
  }
#line 5893
  if (op == 4) {
#line 5893
    goto case_4;
  }
#line 5908
  if (op == 12) {
#line 5908
    goto case_12;
  }
#line 5912
  if (op == 13) {
#line 5912
    goto case_13;
  }
#line 5916
  if (op == 18) {
#line 5916
    goto case_18;
  }
#line 5919
  if (op == 19) {
#line 5919
    goto case_19;
  }
#line 5922
  if (op == 17) {
#line 5922
    goto case_17;
  }
#line 5927
  if (op == 10) {
#line 5927
    goto case_10;
  }
#line 5960
  if (op == 39) {
#line 5960
    goto case_39;
  }
#line 5963
  if (op == 49) {
#line 5963
    goto case_49;
  }
#line 5966
  if (op == 46) {
#line 5966
    goto case_46;
  }
#line 5969
  if (op == 50) {
#line 5969
    goto case_50;
  }
#line 5987
  if (op == 62) {
#line 5987
    goto case_62;
  }
#line 5997
  if (op == 60) {
#line 5997
    goto case_60;
  }
#line 6002
  if (op == 61) {
#line 6002
    goto case_61;
  }
#line 6006
  if (op == 64) {
#line 6006
    goto case_64;
  }
#line 6027
  if (op == 63) {
#line 6027
    goto case_63;
  }
#line 6178
  if (op == 70) {
#line 6178
    goto case_70;
  }
#line 6223
  if (op == 75) {
#line 6223
    goto case_75;
  }
#line 6223
  if (op == 74) {
#line 6223
    goto case_75;
  }
#line 6223
  if (op == 73) {
#line 6223
    goto case_75;
  }
#line 6223
  if (op == 72) {
#line 6223
    goto case_75;
  }
#line 6229
  if (op == 66) {
#line 6229
    goto case_66;
  }
#line 6236
  if (op == 67) {
#line 6236
    goto case_67;
  }
#line 6236
  if (op == 82) {
#line 6236
    goto case_67;
  }
#line 6266
  if (op == 83) {
#line 6266
    goto case_83;
  }
#line 6270
  goto switch_default;
  case_0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 5863
  rxvt_tabbar_set_title(r, (short )page, (unsigned char const   *)str);
  }
#line 5876
  if (op == 2) {
#line 5877
    goto switch_break;
  }
  case_1: /* CIL Label */ 
  {
#line 5881
  rxvt_set_icon_name(r, (unsigned char const   *)str);
  }
#line 5891
  goto switch_break;
  case_4: /* CIL Label */ 
#line 5894
  buf = (char *)str;
  {
#line 5894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5894
    if (buf) {
#line 5894
      if (! *buf) {
#line 5894
        goto while_break;
      }
    } else {
#line 5894
      goto while_break;
    }
    {
#line 5896
    name = strchr((char const   *)buf, ';');
    }
#line 5896
    if ((unsigned long )((void *)0) == (unsigned long )name) {
#line 5897
      goto while_break;
    }
    {
#line 5898
    tmp = name;
#line 5898
    name ++;
#line 5898
    *tmp = (char )'\000';
#line 5899
    color = atoi((char const   *)buf);
    }
#line 5900
    if (color < 0) {
#line 5901
      goto while_break;
    } else
#line 5900
    if (color >= 272) {
#line 5901
      goto while_break;
    }
    {
#line 5902
    buf = strchr((char const   *)name, ';');
    }
#line 5902
    if ((unsigned long )((void *)0) != (unsigned long )buf) {
#line 5903
      tmp___0 = buf;
#line 5903
      buf ++;
#line 5903
      *tmp___0 = (char )'\000';
    }
    {
#line 5904
    rxvt_set_window_color(r, page, color + 2, (char const   *)name);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5906
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 5909
  rxvt_set_window_color(r, page, 258, str);
  }
#line 5910
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 5913
  rxvt_set_window_color(r, page, 260, str);
  }
#line 5914
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 5917
  rxvt_set_window_color(r, page, 263, str);
  }
#line 5918
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 5920
  rxvt_set_window_color(r, page, 264, str);
  }
#line 5921
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 5923
  rxvt_set_window_color(r, page, 265, str);
  }
#line 5924
  goto switch_break;
  case_10: /* CIL Label */ 
#line 5935
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 5961
  rxvt_set_window_color(r, page, 0, str);
  }
#line 5962
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 5964
  rxvt_set_window_color(r, page, 1, str);
  }
#line 5965
  goto switch_break;
  case_46: /* CIL Label */ 
#line 5968
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 5970
  rxvt_resize_on_font(r, (char *)str);
  }
#line 5971
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 5988
  rxvt_tabbar_set_title(r, (short )page, (unsigned char const   *)str);
  }
#line 5989
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
#line 5994
    goto switch_break;
  }
  case_60: /* CIL Label */ 
  {
#line 5998
  rxvt_set_term_title(r, (unsigned char const   *)str);
  }
#line 5999
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 6003
  rxvt_tabbar_set_title(r, (short )page, (unsigned char const   *)str);
  }
#line 6004
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 6008
  tmp___1 = strlen(str);
#line 6008
  len = (int )tmp___1;
  }
#line 6010
  if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->title_format) {
    {
#line 6015
    rxvt_free((void *)(r->vts[page])->title_format);
#line 6016
    (r->vts[page])->title_format = strdup(str);
    }
  } else {
    {
#line 6010
    tmp___2 = strlen((char const   *)(r->vts[page])->title_format);
    }
#line 6010
    if ((size_t )len != tmp___2) {
      {
#line 6015
      rxvt_free((void *)(r->vts[page])->title_format);
#line 6016
      (r->vts[page])->title_format = strdup(str);
      }
    } else {
      {
#line 6019
      strcpy((char */* __restrict  */)(r->vts[page])->title_format, (char const   */* __restrict  */)str);
      }
    }
  }
  {
#line 6022
  refresh_tabbar_tab(r, page);
  }
#line 6024
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 6029
  tmp___3 = strlen(str);
#line 6029
  len___0 = (int )tmp___3;
  }
#line 6031
  if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->winTitleFormat) {
    {
#line 6036
    rxvt_free((void *)(r->vts[page])->winTitleFormat);
#line 6037
    (r->vts[page])->winTitleFormat = strdup(str);
    }
  } else {
    {
#line 6031
    tmp___4 = strlen((char const   *)(r->vts[page])->winTitleFormat);
    }
#line 6031
    if ((size_t )len___0 != tmp___4) {
      {
#line 6036
      rxvt_free((void *)(r->vts[page])->winTitleFormat);
#line 6037
      (r->vts[page])->winTitleFormat = strdup(str);
      }
    } else {
      {
#line 6040
      strcpy((char */* __restrict  */)(r->vts[page])->winTitleFormat, (char const   */* __restrict  */)str);
      }
    }
  }
#line 6042
  if ((unsigned long )r->Options[((1UL << 10) | 1UL) & 3UL] & (((1UL << 10) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 6043
    sync_tab_title(r, (int )r->tabBar.atab);
    }
  }
#line 6045
  goto switch_break;
  case_70: /* CIL Label */ 
#line 6179
  if (0UL != (r->h)->xa[14]) {
#line 6181
    oldopacity = r->TermWin.opacity;
#line 6184
    if (45 == (int )*str) {
#line 6184
      if (0 == (int )*(str + 1)) {
#line 6187
        if ((r->h)->rs[319]) {
#line 6187
          tmp___5 = r->TermWin.opacity_degree;
        } else {
#line 6187
          tmp___5 = 1;
        }
      } else {
#line 6184
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 6190
    if (43 == (int )*str) {
#line 6190
      if (0 == (int )*(str + 1)) {
#line 6193
        if ((r->h)->rs[319]) {
#line 6193
          tmp___5 = - r->TermWin.opacity_degree;
        } else {
#line 6193
          tmp___5 = -1;
        }
      } else {
#line 6190
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 6199
      tmp___6 = atoi(str);
#line 6199
      tmp___5 = 100 - tmp___6;
      }
#line 6201
      if (tmp___5 < 0) {
#line 6202
        tmp___5 = oldopacity;
      } else
#line 6201
      if (tmp___5 > 100) {
#line 6202
        tmp___5 = oldopacity;
      }
    }
#line 6204
    if (45 == (int )*str) {
#line 6206
      r->TermWin.opacity += tmp___5;
    } else
#line 6204
    if (43 == (int )*str) {
#line 6206
      r->TermWin.opacity += tmp___5;
    } else {
#line 6209
      r->TermWin.opacity = tmp___5;
    }
#line 6210
    if (r->TermWin.opacity < 0) {
#line 6211
      r->TermWin.opacity = 0;
    }
#line 6212
    if (r->TermWin.opacity > 100) {
#line 6213
      r->TermWin.opacity = 100;
    }
#line 6215
    if (r->TermWin.opacity != oldopacity) {
      {
#line 6216
      rxvt_set_opacity(r);
      }
    }
  }
#line 6218
  goto switch_break;
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  {
#line 6224
  rxvt_tabbar_change_color(r, op, str);
  }
#line 6225
  goto switch_break;
  case_66: /* CIL Label */ 
#line 6230
  if ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 13)) {
#line 6230
    if ((r->h)->rs[305]) {
      {
#line 6232
      rxvt_set_window_color(r, page, 269, str);
      }
    }
  }
#line 6233
  goto switch_break;
  case_67: /* CIL Label */ 
  case_82: /* CIL Label */ 
#line 6237
  if (! ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 13))) {
#line 6239
    goto switch_break;
  } else
#line 6237
  if (! (r->h)->rs[305]) {
#line 6239
    goto switch_break;
  }
#line 6241
  if ((int const   )*str == 43) {
    {
#line 6244
    tmp___7 = atoi(str);
#line 6244
    shade = (100 - r->TermWin.shade) + tmp___7;
    }
  } else
#line 6241
  if ((int const   )*str == 45) {
    {
#line 6244
    tmp___7 = atoi(str);
#line 6244
    shade = (100 - r->TermWin.shade) + tmp___7;
    }
  } else {
    {
#line 6248
    shade = atoi(str);
    }
  }
#line 6250
  if (shade >= 0) {
#line 6250
    if (shade <= 100) {
#line 6252
      shade = 100 - shade;
#line 6253
      changed = r->TermWin.shade != shade;
#line 6254
      r->TermWin.shade = shade;
    }
  }
#line 6257
  if (changed) {
    {
#line 6260
    rxvt_refresh_bg_image(r, page, 0);
    }
  }
#line 6262
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 6267
  (r->vts[page])->termenv = rxvt_get_termenv(str);
  }
#line 6268
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 6271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6273
  return;
}
}
#line 6288 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
int rxvt_privcases(rxvt_t *r , int page , int mode , uint32_t bit ) 
{ 
  int state ;

  {
#line 6293
  if (mode == 115) {
#line 6295
    (r->vts[page])->PrivateModes |= (r->vts[page])->PrivateModes & bit;
#line 6296
    return (-1);
  } else {
#line 6300
    if (mode == 114) {
#line 6302
      if ((r->vts[page])->SavedModes & bit) {
#line 6302
        state = 1;
      } else {
#line 6302
        state = 0;
      }
    } else
#line 6304
    if (mode == 116) {
#line 6304
      state = ! ((r->vts[page])->PrivateModes & bit);
    } else {
#line 6304
      state = mode;
    }
#line 6305
    if (state) {
#line 6305
      (r->vts[page])->PrivateModes |= bit;
    } else {
#line 6305
      (r->vts[page])->PrivateModes &= ~ bit;
    }
  }
#line 6307
  return (state);
}
}
#line 6318 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
static struct __anonstruct_argtopriv_380  const  argtopriv[20]  = 
#line 6318
  {      {(int const   )1, (uint32_t const   )(1UL << 6)}, 
        {(int const   )2, (uint32_t const   )(1UL << 19)}, 
        {(int const   )3, (uint32_t const   )1UL}, 
        {(int const   )4, (uint32_t const   )(1UL << 18)}, 
        {(int const   )5, (uint32_t const   )(1UL << 2)}, 
        {(int const   )6, (uint32_t const   )(1UL << 3)}, 
        {(int const   )7, (uint32_t const   )(1UL << 5)}, 
        {(int const   )9, (uint32_t const   )(1UL << 12)}, 
        {(int const   )10, (uint32_t const   )(1UL << 15)}, 
        {(int const   )30, (uint32_t const   )(1UL << 14)}, 
        {(int const   )25, (uint32_t const   )(1UL << 11)}, 
        {(int const   )35, (uint32_t const   )(1UL << 10)}, 
        {(int const   )40, (uint32_t const   )(1UL << 1)}, 
        {(int const   )47, (uint32_t const   )(1UL << 4)}, 
        {(int const   )66, (uint32_t const   )(1UL << 7)}, 
        {(int const   )67, (uint32_t const   )(1UL << 9)}, 
        {(int const   )1000, (uint32_t const   )(1UL << 13)}, 
        {(int const   )1010, (uint32_t const   )(1UL << 16)}, 
        {(int const   )1011, (uint32_t const   )(1UL << 17)}, 
        {(int const   )1047, (uint32_t const   )(1UL << 4)}};
#line 6313 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_terminal_mode(rxvt_t *r , int page , int mode , int priv , unsigned int nargs ,
                                int const   *arg ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int state ;
  int tmp ;
  unsigned int w ;
  int tmp___0 ;
  unsigned int h ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 6358
  if (nargs == 0U) {
#line 6359
    return;
  }
#line 6362
  if (mode == 108) {
#line 6363
    mode = 0;
  } else
#line 6364
  if (mode == 104) {
#line 6365
    mode = 1;
  }
#line 6367
  i = 0U;
  {
#line 6367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6367
    if (! (i < nargs)) {
#line 6367
      goto while_break;
    }
#line 6369
    state = -1;
#line 6372
    j = 0U;
    {
#line 6372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6372
      if (! ((unsigned long )j < sizeof(argtopriv) / sizeof(argtopriv[0]))) {
#line 6372
        goto while_break___0;
      }
#line 6374
      if (argtopriv[j].argval == *(arg + i)) {
        {
#line 6376
        state = rxvt_privcases(r, page, mode, (uint32_t )argtopriv[j].bit);
        }
#line 6377
        goto while_break___0;
      }
#line 6372
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6382
    if (state == -1) {
#line 6382
      if (mode == 0) {
#line 6382
        goto _L;
      } else
#line 6382
      if (mode == 1) {
        _L: /* CIL Label */ 
        {
#line 6386
        if (*(arg + i) == 1048) {
#line 6386
          goto case_1048;
        }
#line 6390
        if (*(arg + i) == 1049) {
#line 6390
          goto case_1049;
        }
#line 6405
        goto switch_default;
        case_1048: /* CIL Label */ 
#line 6387
        if (mode == 0) {
#line 6387
          tmp = 'r';
        } else {
#line 6387
          tmp = 's';
        }
        {
#line 6387
        rxvt_scr_cursor(r, page, tmp);
        }
#line 6388
        goto switch_break;
        case_1049: /* CIL Label */ 
#line 6393
        if (mode == 0) {
          {
#line 6395
          rxvt_scr_change_screen(r, page, 0);
#line 6396
          rxvt_scr_cursor(r, page, 'r');
          }
        } else {
          {
#line 6400
          rxvt_scr_cursor(r, page, 's');
#line 6401
          rxvt_scr_change_screen(r, page, 1);
#line 6402
          rxvt_scr_erase_screen(r, page, 2);
          }
        }
        switch_default: /* CIL Label */ 
#line 6406
        goto __Cont;
        switch_break: /* CIL Label */ ;
        }
#line 6408
        goto __Cont;
      }
    }
    {
#line 6415
    if (*(arg + i) == 2) {
#line 6415
      goto case_2;
    }
#line 6422
    if (*(arg + i) == 3) {
#line 6422
      goto case_3;
    }
#line 6432
    if (*(arg + i) == 4) {
#line 6432
      goto case_4;
    }
#line 6445
    if (*(arg + i) == 5) {
#line 6445
      goto case_5;
    }
#line 6448
    if (*(arg + i) == 6) {
#line 6448
      goto case_6;
    }
#line 6451
    if (*(arg + i) == 7) {
#line 6451
      goto case_7;
    }
#line 6455
    if (*(arg + i) == 9) {
#line 6455
      goto case_9;
    }
#line 6477
    if (*(arg + i) == 30) {
#line 6477
      goto case_30;
    }
#line 6491
    if (*(arg + i) == 25) {
#line 6491
      goto case_25;
    }
#line 6496
    if (*(arg + i) == 47) {
#line 6496
      goto case_47;
    }
#line 6501
    if (*(arg + i) == 1000) {
#line 6501
      goto case_1000;
    }
#line 6509
    if (*(arg + i) == 1010) {
#line 6509
      goto case_1010;
    }
#line 6516
    if (*(arg + i) == 1011) {
#line 6516
      goto case_1011;
    }
#line 6523
    if (*(arg + i) == 1047) {
#line 6523
      goto case_1047;
    }
#line 6533
    goto switch_default___0;
    case_2: /* CIL Label */ 
#line 6420
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 19));
#line 6421
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 6423
    if ((unsigned long )(r->vts[page])->PrivateModes & (1UL << 1)) {
#line 6425
      if (state) {
#line 6425
        tmp___0 = 132;
      } else {
#line 6425
        tmp___0 = 80;
      }
      {
#line 6425
      w = (unsigned int )(tmp___0 * (int32_t )r->TermWin.fwidth + r->szHint.base_width);
#line 6427
      h = (unsigned int )r->szHint.base_height;
#line 6428
      XResizeWindow(r->Xdisplay, r->TermWin.parent, w, h);
#line 6429
      (r->h)->want_resize = (unsigned char)1;
      }
    }
#line 6431
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 6433
    if (state) {
#line 6436
      (r->h)->refresh_limit = 8191;
#line 6437
      (r->h)->skip_pages = 1;
    } else {
      {
#line 6442
      rxvt_set_jumpscroll(r);
      }
    }
#line 6444
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
#line 6446
    rxvt_scr_rvideo_mode(r, page, state);
    }
#line 6447
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 6449
    rxvt_scr_relative_origin(r, page, state);
    }
#line 6450
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 6452
    rxvt_scr_autowrap(r, page, state);
    }
#line 6453
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 6456
    if (state) {
#line 6457
      (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes & ~ (1UL << 13));
    }
#line 6458
    goto switch_break___0;
    case_30: /* CIL Label */ 
#line 6478
    if (state) {
      {
#line 6480
      tmp___1 = rxvt_scrollbar_show(r);
      }
#line 6480
      if (tmp___1) {
        {
#line 6481
        rxvt_resize_on_subwin(r, (resize_reason_t )5);
        }
      }
    } else {
      {
#line 6485
      tmp___2 = rxvt_scrollbar_hide(r);
      }
#line 6485
      if (tmp___2) {
        {
#line 6486
        rxvt_resize_on_subwin(r, (resize_reason_t )4);
        }
      }
    }
#line 6488
    goto switch_break___0;
    case_25: /* CIL Label */ 
    {
#line 6492
    rxvt_scr_cursor_visible(r, page, state);
    }
#line 6493
    goto switch_break___0;
    case_47: /* CIL Label */ 
    {
#line 6497
    rxvt_scr_change_screen(r, page, state);
    }
#line 6498
    goto switch_break___0;
    case_1000: /* CIL Label */ 
#line 6502
    if (state) {
#line 6503
      (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes & ~ (1UL << 12));
    }
#line 6504
    goto switch_break___0;
    case_1010: /* CIL Label */ 
#line 6510
    if (state) {
#line 6511
      r->Options[(1UL << 14) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 14) & 3UL] | ((1UL << 14) & 0xfffffffffffffffcUL));
    } else {
#line 6513
      r->Options[(1UL << 14) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 14) & 3UL] & ~ ((1UL << 14) & 0xfffffffffffffffcUL));
    }
#line 6514
    goto switch_break___0;
    case_1011: /* CIL Label */ 
#line 6517
    if (state) {
#line 6518
      r->Options[(1UL << 15) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 15) & 3UL] | ((1UL << 15) & 0xfffffffffffffffcUL));
    } else {
#line 6520
      r->Options[(1UL << 15) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 15) & 3UL] & ~ ((1UL << 15) & 0xfffffffffffffffcUL));
    }
#line 6521
    goto switch_break___0;
    case_1047: /* CIL Label */ 
#line 6529
    if ((int )(r->vts[page])->current_screen != 0) {
      {
#line 6530
      rxvt_scr_erase_screen(r, page, 2);
      }
    }
    {
#line 6531
    rxvt_scr_change_screen(r, page, state);
    }
    switch_default___0: /* CIL Label */ 
#line 6534
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 6367
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6537
  return;
}
}
#line 6542 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_sgr_mode(rxvt_t *r , int page , unsigned int nargs , int const   *arg ) 
{ 
  unsigned int i ;
  short rendset ;
  int rendstyle ;

  {
#line 6547
  rendstyle = 0;
#line 6549
  if (nargs == 0U) {
    {
#line 6551
    rxvt_scr_rendition(r, page, 0, ~ 0);
    }
#line 6552
    return;
  }
#line 6554
  i = 0U;
  {
#line 6554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6554
    if (! (i < nargs)) {
#line 6554
      goto while_break;
    }
#line 6556
    rendset = (short)-1;
    {
#line 6559
    if (*(arg + i) == 0) {
#line 6559
      goto case_0;
    }
#line 6562
    if (*(arg + i) == 1) {
#line 6562
      goto case_1;
    }
#line 6565
    if (*(arg + i) == 4) {
#line 6565
      goto case_4;
    }
#line 6568
    if (*(arg + i) == 5) {
#line 6568
      goto case_5;
    }
#line 6571
    if (*(arg + i) == 7) {
#line 6571
      goto case_7;
    }
#line 6574
    if (*(arg + i) == 22) {
#line 6574
      goto case_22;
    }
#line 6577
    if (*(arg + i) == 24) {
#line 6577
      goto case_24;
    }
#line 6580
    if (*(arg + i) == 25) {
#line 6580
      goto case_25;
    }
#line 6583
    if (*(arg + i) == 27) {
#line 6583
      goto case_27;
    }
#line 6557
    goto switch_break;
    case_0: /* CIL Label */ 
#line 6560
    rendset = (short)0;
#line 6560
    rendstyle = ~ 0;
#line 6561
    goto switch_break;
    case_1: /* CIL Label */ 
#line 6563
    rendset = (short)1;
#line 6563
    rendstyle = 262144;
#line 6564
    goto switch_break;
    case_4: /* CIL Label */ 
#line 6566
    rendset = (short)1;
#line 6566
    rendstyle = 2097152;
#line 6567
    goto switch_break;
    case_5: /* CIL Label */ 
#line 6569
    rendset = (short)1;
#line 6569
    rendstyle = 524288;
#line 6570
    goto switch_break;
    case_7: /* CIL Label */ 
#line 6572
    rendset = (short)1;
#line 6572
    rendstyle = 1048576;
#line 6573
    goto switch_break;
    case_22: /* CIL Label */ 
#line 6575
    rendset = (short)0;
#line 6575
    rendstyle = 262144;
#line 6576
    goto switch_break;
    case_24: /* CIL Label */ 
#line 6578
    rendset = (short)0;
#line 6578
    rendstyle = 2097152;
#line 6579
    goto switch_break;
    case_25: /* CIL Label */ 
#line 6581
    rendset = (short)0;
#line 6581
    rendstyle = 524288;
#line 6582
    goto switch_break;
    case_27: /* CIL Label */ 
#line 6584
    rendset = (short)0;
#line 6584
    rendstyle = 1048576;
#line 6585
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 6587
    if ((int )rendset != -1) {
      {
#line 6589
      rxvt_scr_rendition(r, page, (int )rendset, rendstyle);
      }
#line 6590
      goto __Cont;
    }
    {
#line 6602
    if (*(arg + i) == 37) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 36) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 35) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 34) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 33) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 32) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 31) {
#line 6602
      goto case_37;
    }
#line 6602
    if (*(arg + i) == 30) {
#line 6602
      goto case_37;
    }
#line 6607
    if (*(arg + i) == 38) {
#line 6607
      goto case_38;
    }
#line 6616
    if (*(arg + i) == 39) {
#line 6616
      goto case_39;
    }
#line 6627
    if (*(arg + i) == 47) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 46) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 45) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 44) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 43) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 42) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 41) {
#line 6627
      goto case_47;
    }
#line 6627
    if (*(arg + i) == 40) {
#line 6627
      goto case_47;
    }
#line 6632
    if (*(arg + i) == 48) {
#line 6632
      goto case_48;
    }
#line 6641
    if (*(arg + i) == 49) {
#line 6641
      goto case_49;
    }
#line 6653
    if (*(arg + i) == 97) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 96) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 95) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 94) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 93) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 92) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 91) {
#line 6653
      goto case_97;
    }
#line 6653
    if (*(arg + i) == 90) {
#line 6653
      goto case_97;
    }
#line 6664
    if (*(arg + i) == 107) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 106) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 105) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 104) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 103) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 102) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 101) {
#line 6664
      goto case_107;
    }
#line 6664
    if (*(arg + i) == 100) {
#line 6664
      goto case_107;
    }
#line 6593
    goto switch_break___0;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
    {
#line 6603
    rxvt_scr_color(r, page, (unsigned int )(2 + (int )(*(arg + i) - 30)), 0);
    }
#line 6605
    goto switch_break___0;
    case_38: /* CIL Label */ 
#line 6608
    if (nargs > i + 2U) {
#line 6608
      if (*(arg + (i + 1U)) == 5) {
        {
#line 6610
        rxvt_scr_color(r, page, (unsigned int )(2 + (int )*(arg + (i + 2U))), 0);
#line 6612
        i += 2U;
        }
      }
    }
#line 6614
    goto switch_break___0;
    case_39: /* CIL Label */ 
    {
#line 6617
    rxvt_scr_color(r, page, 0U, 0);
    }
#line 6618
    goto switch_break___0;
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 6628
    rxvt_scr_color(r, page, (unsigned int )(2 + (int )(*(arg + i) - 40)), 1);
    }
#line 6630
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 6633
    if (nargs > i + 2U) {
#line 6633
      if (*(arg + (i + 1U)) == 5) {
        {
#line 6635
        rxvt_scr_color(r, page, (unsigned int )(2 + (int )*(arg + (i + 2U))), 1);
#line 6637
        i += 2U;
        }
      }
    }
#line 6639
    goto switch_break___0;
    case_49: /* CIL Label */ 
    {
#line 6642
    rxvt_scr_color(r, page, 1U, 1);
    }
#line 6643
    goto switch_break___0;
    case_97: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_90: /* CIL Label */ 
    {
#line 6654
    rxvt_scr_color(r, page, (unsigned int )(10 + (int )(*(arg + i) - 90)), 0);
    }
#line 6656
    goto switch_break___0;
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 6665
    rxvt_scr_color(r, page, (unsigned int )(10 + (int )(*(arg + i) - 100)), 1);
    }
#line 6667
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 6554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6671
  return;
}
}
#line 6676 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_graphics(rxvt_t *r , int page ) 
{ 
  int readpage ;
  unsigned char ch ;
  unsigned char cmd ;
  unsigned char tmp ;

  {
  {
#line 6679
  readpage = page;
#line 6680
  tmp = rxvt_cmd_getc(r, & readpage);
#line 6680
  cmd = tmp;
  }
#line 6682
  if (readpage == -1) {
    {
#line 6684
    rxvt_set_escfail(r, page, 1);
    }
#line 6685
    return;
  }
#line 6688
  if ((int )cmd == 81) {
    {
#line 6690
    rxvt_tt_printf(r, page, "\033G0\n");
    }
#line 6691
    return;
  }
  {
#line 6695
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6697
    ch = rxvt_cmd_getc(r, & readpage);
    }
#line 6698
    if (readpage == -1) {
      {
#line 6700
      rxvt_set_escfail(r, page, 1);
      }
#line 6701
      return;
    }
#line 6695
    if ((int )ch != 58) {
#line 6695
      if ((int )ch >= 32) {
#line 6695
        if (! ((int )ch <= 126)) {
#line 6695
          goto while_break;
        }
      } else {
#line 6695
        goto while_break;
      }
    } else {
#line 6695
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6708
  return;
}
}
#line 6718 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_process_getc(rxvt_t *r , int page , unsigned char ch ) 
{ 
  int limit ;
  int nlines ;
  int nchars ;
  int refreshnow ;
  unsigned char *str ;
  unsigned char *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;

  {
#line 6724
  limit = (r->h)->skip_pages * (int )r->TermWin.nrow;
#line 6725
  if (limit < 0) {
#line 6727
    limit = 2147483647;
  }
  {
#line 6735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6737
    if ((int )ch >= 32) {
#line 6737
      goto _L___1;
    } else
#line 6737
    if ((int )ch == 9) {
#line 6737
      goto _L___1;
    } else
#line 6737
    if ((int )ch == 10) {
#line 6737
      goto _L___1;
    } else
#line 6737
    if ((int )ch == 13) {
      _L___1: /* CIL Label */ 
#line 6743
      nlines = 0;
#line 6743
      refreshnow = 0;
#line 6750
      nchars = (r->vts[page])->screen.cur.col;
#line 6756
      ((r->vts[page])->cmdbuf_ptr) --;
#line 6756
      str = (r->vts[page])->cmdbuf_ptr;
      {
#line 6757
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6757
        if (! ((unsigned long )(r->vts[page])->cmdbuf_ptr < (unsigned long )(r->vts[page])->cmdbuf_endp)) {
#line 6757
          goto while_break___0;
        }
#line 6759
        tmp = (r->vts[page])->cmdbuf_ptr;
#line 6759
        ((r->vts[page])->cmdbuf_ptr) ++;
#line 6759
        ch = *tmp;
#line 6761
        if ((int )ch == 10) {
#line 6763
          nchars = 0;
#line 6764
          nlines ++;
#line 6765
          ((r->vts[page])->scrolled_lines) ++;
        } else
#line 6768
        if ((int )ch < 32) {
#line 6768
          if ((int )ch != 9) {
#line 6768
            if ((int )ch != 13) {
#line 6774
              ((r->vts[page])->cmdbuf_ptr) --;
#line 6775
              goto while_break___0;
            } else {
#line 6768
              goto _L___0;
            }
          } else {
#line 6768
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 6778
          nchars ++;
#line 6778
          if (nchars > (int )r->TermWin.ncol) {
#line 6780
            ((r->vts[page])->scrolled_lines) ++;
#line 6781
            nchars = 0;
          }
        }
#line 6784
        if ((r->vts[page])->mapped) {
#line 6784
          if ((r->vts[page])->scrolled_lines >= limit) {
#line 6789
            refreshnow = 1;
#line 6790
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 6800
      rxvt_scr_add_lines(r, page, (unsigned char const   *)str, nlines, (int )((r->vts[page])->cmdbuf_ptr - str));
      }
#line 6810
      if (refreshnow) {
        {
#line 6812
        refreshnow = 0;
#line 6820
        rxvt_scr_refresh(r, page, (unsigned char )((int )(r->h)->refresh_type & ~ (1 << 4)));
#line 6824
        tmp___0 = XPending(r->Xdisplay);
        }
#line 6824
        if (tmp___0) {
#line 6825
          goto while_break;
        }
      }
    } else
#line 6832
    if ((int )ch == 27) {
#line 6835
      if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->cmdbuf_escstart) {
#line 6836
        (r->vts[page])->cmdbuf_escstart = (r->vts[page])->cmdbuf_ptr - 1;
      }
      {
#line 6840
      (r->vts[page])->cmdbuf_escfail = (unsigned char *)((void *)0);
#line 6843
      rxvt_process_escape_seq(r, page);
      }
#line 6846
      if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->cmdbuf_escfail) {
#line 6847
        (r->vts[page])->cmdbuf_escstart = (unsigned char *)((void *)0);
      } else {
#line 6850
        goto while_break;
      }
    } else {
      {
#line 6858
      rxvt_process_nonprinting(r, page, ch);
      }
    }
    {
#line 6870
    tmp___2 = rxvt_cmdbuf_has_input(r, page);
    }
#line 6870
    if (tmp___2) {
#line 6871
      tmp___1 = (r->vts[page])->cmdbuf_ptr;
#line 6871
      ((r->vts[page])->cmdbuf_ptr) ++;
#line 6871
      ch = *tmp___1;
    } else {
#line 6873
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6875
  return;
}
}
#line 6880 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_main_loop(rxvt_t *r ) 
{ 
  register int i ;
  unsigned char ch ;
  int page ;

  {
#line 6891
  i = 0;
  {
#line 6891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6891
    if (! (i <= (int )r->tabBar.ltab)) {
#line 6891
      goto while_break;
    }
    {
#line 6893
    rxvt_tt_winsize((r->vts[i])->cmd_fd, r->TermWin.ncol, r->TermWin.nrow, (r->vts[i])->cmd_pid);
#line 6891
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6897
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6900
    page = -1;
#line 6902
    ch = (unsigned char)0;
    {
#line 6904
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6904
      if ((int )r->ndead_childs == 0) {
#line 6904
        if ((int )r->cleanDeadChilds == 0) {
          {
#line 6904
          ch = rxvt_cmd_getc(r, & page);
          }
#line 6904
          if (! ((int )ch == 0)) {
#line 6904
            goto while_break___1;
          }
        } else {
#line 6904
          goto while_break___1;
        }
      } else {
#line 6904
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 6917
    if (page != -1) {
#line 6917
      if ((int )ch != 0) {
        {
#line 6919
        rxvt_process_getc(r, page, ch);
        }
      }
    }
#line 6935
    if ((r->vts[r->tabBar.atab])->nbytes_last_read <= (r->h)->refresh_limit) {
      {
#line 6936
      rxvt_refresh_vtscr_if_needed(r);
      }
    }
#line 6942
    if ((int )r->ndead_childs > 0) {
      {
#line 6943
      rxvt_clean_cmd_page(r);
      }
    } else
#line 6942
    if (r->cleanDeadChilds) {
      {
#line 6943
      rxvt_clean_cmd_page(r);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 6956 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_tt_printf(rxvt_t *r , int page , char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  unsigned char buf[256] ;
  size_t tmp ;

  {
  {
#line 6962
  __builtin_va_start(arg_ptr, fmt);
#line 6963
  vsnprintf((char */* __restrict  */)((char *)(buf)), sizeof(buf) - 1UL, (char const   */* __restrict  */)fmt,
            arg_ptr);
#line 6964
  buf[sizeof(buf) - 1UL] = (unsigned char)0;
#line 6965
  __builtin_va_end(arg_ptr);
#line 6966
  tmp = strlen((char const   *)(buf));
#line 6966
  rxvt_tt_write(r, page, (unsigned char const   *)(buf), (int )((unsigned int )tmp));
  }
#line 6967
  return;
}
}
#line 6978 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/command.c"
void rxvt_tt_write(rxvt_t *r , int page , unsigned char const   *d , int len ) 
{ 
  register int k ;
  register int beg ;
  register int end ;
  int riten ;
  int p ;
  unsigned char *v_buffer ;
  unsigned char *v_bufstr ;
  unsigned char *v_bufptr ;
  unsigned char *v_bufend ;
  void *tmp ;
  unsigned int size ;
  unsigned int reallocto ;
  void *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  unsigned int start ;
  unsigned int size___0 ;
  unsigned int reallocto___0 ;
  void *tmp___3 ;

  {
#line 6984
  if ((unsigned long )r->Options[((1UL << 16) | 1UL) & 3UL] & (((1UL << 16) | 1UL) & 0xfffffffffffffffcUL)) {
#line 6986
    beg = 0;
#line 6986
    end = (int )r->tabBar.ltab;
  } else {
#line 6990
    end = page;
#line 6990
    beg = end;
  }
#line 6993
  k = beg;
  {
#line 6993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6993
    if (! (k <= end)) {
#line 6993
      goto while_break;
    }
#line 7008
    if ((unsigned long )((void *)0) == (unsigned long )(r->vts[k])->v_bufstr) {
#line 7008
      if (len > 0) {
#line 7010
        p = (len / 128 + 1) * 128;
#line 7011
        if (p <= 0) {
#line 7012
          return;
        }
        {
#line 7013
        tmp = rxvt_malloc((size_t )p);
#line 7013
        v_bufptr = (unsigned char *)tmp;
#line 7013
        v_bufstr = v_bufptr;
#line 7013
        v_buffer = v_bufstr;
#line 7014
        v_bufend = v_buffer + p;
        }
      } else {
#line 7018
        v_buffer = (r->vts[k])->v_buffer;
#line 7019
        v_bufstr = (r->vts[k])->v_bufstr;
#line 7020
        v_bufptr = (r->vts[k])->v_bufptr;
#line 7021
        v_bufend = (r->vts[k])->v_bufend;
      }
    } else {
#line 7018
      v_buffer = (r->vts[k])->v_buffer;
#line 7019
      v_bufstr = (r->vts[k])->v_bufstr;
#line 7020
      v_bufptr = (r->vts[k])->v_bufptr;
#line 7021
      v_bufend = (r->vts[k])->v_bufend;
    }
#line 7030
    if (len > 0) {
#line 7032
      if ((unsigned long )v_bufend < (unsigned long )(v_bufptr + len)) {
#line 7035
        if ((unsigned long )v_bufstr != (unsigned long )v_buffer) {
          {
#line 7038
          memmove((void *)v_buffer, (void const   *)v_bufstr, (size_t )((unsigned int )(v_bufptr - v_bufstr)));
#line 7040
          v_bufptr -= v_bufstr - v_buffer;
#line 7041
          v_bufstr = v_buffer;
          }
        }
#line 7043
        if ((unsigned long )v_bufend < (unsigned long )(v_bufptr + len)) {
          {
#line 7047
          size = (unsigned int )(v_bufptr - v_buffer);
#line 7050
          reallocto = ((size + (unsigned int )len) / 128U + 1U) * 128U;
#line 7051
          tmp___0 = rxvt_realloc((void *)v_buffer, (size_t )reallocto);
#line 7051
          v_buffer = (unsigned char *)tmp___0;
          }
#line 7053
          if (v_buffer) {
#line 7055
            v_bufstr = v_buffer;
#line 7056
            v_bufptr = v_buffer + size;
#line 7057
            v_bufend = v_buffer + reallocto;
          } else {
            {
#line 7062
            rxvt_msg((uint32_t )1, (uint32_t )1, "data loss: cannot allocate buffer space");
#line 7065
            v_buffer = v_bufstr;
            }
          }
        }
      }
#line 7069
      if ((unsigned long )v_bufend >= (unsigned long )(v_bufptr + len)) {
        {
#line 7072
        memcpy((void */* __restrict  */)((void *)v_bufptr), (void const   */* __restrict  */)((void const   *)d),
               (size_t )len);
#line 7073
        v_bufptr += len;
        }
      }
    }
#line 7091
    p = (int )(v_bufptr - v_bufstr);
#line 7091
    if (p > 0) {
#line 7093
      if (p < 128) {
#line 7093
        tmp___1 = p;
      } else {
#line 7093
        tmp___1 = 128;
      }
      {
#line 7093
      tmp___2 = write((r->vts[k])->cmd_fd, (void const   *)v_bufstr, (size_t )tmp___1);
#line 7093
      riten = (int )tmp___2;
      }
#line 7095
      if (riten < 0) {
#line 7096
        riten = 0;
      }
#line 7097
      v_bufstr += riten;
#line 7098
      if ((unsigned long )v_bufstr >= (unsigned long )v_bufptr) {
#line 7099
        v_bufptr = v_buffer;
#line 7099
        v_bufstr = v_bufptr;
      }
    }
#line 7105
    if (v_bufend - v_bufptr > 1024L) {
      {
#line 7108
      start = (unsigned int )(v_bufstr - v_buffer);
#line 7109
      size___0 = (unsigned int )(v_bufptr - v_buffer);
#line 7112
      reallocto___0 = (size___0 / 128U + 1U) * 128U;
#line 7113
      tmp___3 = rxvt_realloc((void *)v_buffer, (size_t )reallocto___0);
#line 7113
      v_buffer = (unsigned char *)tmp___3;
      }
#line 7114
      if (v_buffer) {
#line 7116
        v_bufstr = v_buffer + start;
#line 7117
        v_bufptr = v_buffer + size___0;
#line 7118
        v_bufend = v_buffer + reallocto___0;
      } else {
#line 7124
        v_buffer = v_bufstr - start;
      }
    }
#line 7127
    (r->vts[k])->v_buffer = v_buffer;
#line 7128
    (r->vts[k])->v_bufstr = v_bufstr;
#line 7129
    (r->vts[k])->v_bufptr = v_bufptr;
#line 7130
    (r->vts[k])->v_bufend = v_bufend;
#line 6993
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7132
  return;
}
}
#line 327 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_scrollbar_init_sgi(rxvt_t *r ) ;
#line 328
void rxvt_scrollbar_exit_sgi(rxvt_t *r ) ;
#line 329
int rxvt_scrollbar_show_sgi(rxvt_t *r , int update , int last_top , int last_bot ,
                            int scroller_len ) ;
#line 39 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *SCROLLER_DIMPLE___0[10]  = 
#line 39 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
  {      (char *)"            ",      (char *)"############",      (char *)".==========%",      (char *)".==========%", 
        (char *)"            ",      (char *)"############",      (char *)".==========%",      (char *)".==========%", 
        (char *)"            ",      (char *)"############"};
#line 57 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *SCROLLER_ARROW_UP___0[14]  = 
#line 57
  {      (char *)"============",      (char *)"============",      (char *)"=====*======",      (char *)"=====**=====", 
        (char *)"=====**=====",      (char *)"====****====",      (char *)"====****====",      (char *)"===******===", 
        (char *)"===******===",      (char *)"==********==",      (char *)"==********==",      (char *)"============", 
        (char *)"============",      (char *)"============"};
#line 74 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *SCROLLER_ARROW_DOWN___0[14]  = 
#line 74
  {      (char *)"============",      (char *)"============",      (char *)"=*********==",      (char *)"==********==", 
        (char *)"==********==",      (char *)"===******===",      (char *)"===******===",      (char *)"====****====", 
        (char *)"====****====",      (char *)"=====**=====",      (char *)"=====**=====",      (char *)"============", 
        (char *)"============",      (char *)"============"};
#line 93 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *LO_SCROLLER_ARROW_UP[14]  = 
#line 93
  {      (char *)"============",      (char *)"============",      (char *)"=====-======",      (char *)"=====--=====", 
        (char *)"=====--=====",      (char *)"====----====",      (char *)"====----====",      (char *)"===------===", 
        (char *)"===------===",      (char *)"==--------==",      (char *)"==--------==",      (char *)"============", 
        (char *)"============",      (char *)"============"};
#line 110 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *LO_SCROLLER_ARROW_DOWN[14]  = 
#line 110
  {      (char *)"============",      (char *)"============",      (char *)"=---------==",      (char *)"==--------==", 
        (char *)"==--------==",      (char *)"===------===",      (char *)"===------===",      (char *)"====----====", 
        (char *)"====----====",      (char *)"=====--=====",      (char *)"=====--=====",      (char *)"============", 
        (char *)"============",      (char *)"============"};
#line 129 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *HI_SCROLLER_ARROW_UP___0[14]  = 
#line 129
  {      (char *)"            ",      (char *)"            ",      (char *)"     %      ",      (char *)"     %%     ", 
        (char *)"     %%     ",      (char *)"    %%%%    ",      (char *)"    %%%%    ",      (char *)"   %%%%%%   ", 
        (char *)"   %%%%%%   ",      (char *)"  %%%%%%%%  ",      (char *)"  %%%%%%%%  ",      (char *)"            ", 
        (char *)"            ",      (char *)"            "};
#line 146 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static char *HI_SCROLLER_ARROW_DOWN___0[14]  = 
#line 146
  {      (char *)"            ",      (char *)"            ",      (char *)" %%%%%%%%%  ",      (char *)"  %%%%%%%%  ", 
        (char *)"  %%%%%%%%  ",      (char *)"   %%%%%%   ",      (char *)"   %%%%%%   ",      (char *)"    %%%%    ", 
        (char *)"    %%%%    ",      (char *)"     %%     ",      (char *)"     %%     ",      (char *)"            ", 
        (char *)"            ",      (char *)"            "};
#line 174 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static unsigned char stp_bits[8]  = 
#line 174
  {      (unsigned char)85,      (unsigned char)170,      (unsigned char)85,      (unsigned char)170, 
        (unsigned char)85,      (unsigned char)170,      (unsigned char)85,      (unsigned char)170};
#line 179 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static Pixmap create_icon(rxvt_t *r , char **data , int sx , int sy , unsigned int width ,
                          unsigned int height ) 
{ 
  register int i ;
  register int k ;
  register int x ;
  register int y ;
  unsigned long pixel ;
  Pixmap pixmap ;

  {
  {
#line 188
  pixmap = XCreatePixmap(r->Xdisplay, r->scrollBar.win, width, height, (unsigned int )(((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth);
  }
#line 190
  if (0UL == pixmap) {
#line 191
    return ((Pixmap )0L);
  }
#line 193
  y = sy;
#line 194
  i = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! ((unsigned int )i < height)) {
#line 194
      goto while_break;
    }
#line 195
    x = sx;
#line 196
    k = 0;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 196
      if (! ((unsigned int )k < width)) {
#line 196
        goto while_break___0;
      }
      {
#line 199
      if ((int )*(*(data + y) + x) == 119) {
#line 199
        goto case_119;
      }
#line 199
      if ((int )*(*(data + y) + x) == 32) {
#line 199
        goto case_119;
      }
#line 202
      if ((int )*(*(data + y) + x) == 108) {
#line 202
        goto case_108;
      }
#line 202
      if ((int )*(*(data + y) + x) == 46) {
#line 202
        goto case_108;
      }
#line 205
      if ((int )*(*(data + y) + x) == 103) {
#line 205
        goto case_103;
      }
#line 205
      if ((int )*(*(data + y) + x) == 45) {
#line 205
        goto case_103;
      }
#line 208
      if ((int )*(*(data + y) + x) == 100) {
#line 208
        goto case_100;
      }
#line 208
      if ((int )*(*(data + y) + x) == 37) {
#line 208
        goto case_100;
      }
#line 211
      if ((int )*(*(data + y) + x) == 118) {
#line 211
        goto case_118;
      }
#line 211
      if ((int )*(*(data + y) + x) == 42) {
#line 211
        goto case_118;
      }
#line 214
      if ((int )*(*(data + y) + x) == 98) {
#line 214
        goto case_98;
      }
#line 214
      if ((int )*(*(data + y) + x) == 35) {
#line 214
        goto case_98;
      }
#line 218
      goto switch_default;
      case_119: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 200
      pixel = r->scrollBar.sgi_white;
#line 200
      goto switch_break;
      case_108: /* CIL Label */ 
      case_46: /* CIL Label */ 
#line 203
      pixel = r->scrollBar.sgi_fg;
#line 203
      goto switch_break;
      case_103: /* CIL Label */ 
      case_45: /* CIL Label */ 
#line 206
      pixel = r->scrollBar.sgi_lmedium;
#line 206
      goto switch_break;
      case_100: /* CIL Label */ 
      case_37: /* CIL Label */ 
#line 209
      pixel = r->scrollBar.sgi_dark;
#line 209
      goto switch_break;
      case_118: /* CIL Label */ 
      case_42: /* CIL Label */ 
#line 212
      pixel = r->scrollBar.sgi_vdark;
#line 212
      goto switch_break;
      case_98: /* CIL Label */ 
      case_35: /* CIL Label */ 
#line 215
      pixel = r->scrollBar.sgi_black;
#line 215
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 219
      pixel = r->scrollBar.sgi_bg;
#line 220
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 222
      XSetForeground(r->Xdisplay, r->scrollBar.gc, pixel);
#line 223
      XDrawPoint(r->Xdisplay, pixmap, r->scrollBar.gc, k, i);
#line 196
      k ++;
#line 196
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 194
    y ++;
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (pixmap);
}
}
#line 234 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static void sgi_draw_bevel(rxvt_t *r , Drawable d , int x , int y , int w , int h ) 
{ 


  {
  {
#line 237
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.sgi_fg);
#line 238
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x, y, x + w, y);
#line 239
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x, y, x, y + h);
#line 241
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x + 1, y + 1, (x + w) - 1, y + 1);
#line 242
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x + 1, y + 1, x + 1, (y + h) - 1);
#line 244
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.sgi_dark);
#line 245
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x + w, y + 1, x + w, y + h);
#line 246
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x + 1, y + h, x + w, y + h);
#line 248
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, (x + w) - 1, y + 2, (x + w) - 1, (y + h) - 1);
#line 249
  XDrawLine(r->Xdisplay, d, r->scrollBar.gc, x + 2, (y + h) - 1, (x + w) - 1, (y + h) - 1);
  }
#line 250
  return;
}
}
#line 254 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
static void scrollbar_fill_back(rxvt_t *r , unsigned int height ) 
{ 


  {
  {
#line 258
  XClearArea(r->Xdisplay, r->scrollBar.win, 0, (2 << 1) + (16 - (2 << 1)), 16U, height,
             0);
#line 263
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.sgi_fg);
#line 264
  XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 0, 0, 16U, (unsigned int )((2 << 1) + (16 - (2 << 1))));
#line 268
  XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 0, (int )(height + (unsigned int )((2 << 1) + (16 - (2 << 1)))),
                 16U, (unsigned int )((2 << 1) + (16 - (2 << 1))));
#line 272
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.sgi_dark);
#line 274
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 15, 0, 15, (int )(height + (unsigned int )(((2 << 1) + (16 - (2 << 1))) << 1)));
#line 278
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 2, (int )((height + (unsigned int )(((2 << 1) + (16 - (2 << 1))) << 1)) - 1U),
            16, (int )((height + (unsigned int )(((2 << 1) + (16 - (2 << 1))) << 1)) - 1U));
  }
#line 281
  return;
}
}
#line 285 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
void rxvt_scrollbar_init_sgi(rxvt_t *r ) 
{ 
  XGCValues gcvalue ;
  unsigned long gcmask ;
  Pixmap stipple ;
  XColor xcol ;
  unsigned int x_offset ;
  unsigned int y_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 296
  r->scrollBar.sgi_black = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->black_pixel;
#line 298
  r->scrollBar.sgi_white = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->white_pixel;
#line 301
  xcol.red = (unsigned short)56832;
#line 302
  xcol.green = (unsigned short)56832;
#line 303
  xcol.blue = (unsigned short)56832;
#line 304
  tmp = rxvt_alloc_color(r, & xcol, "light gray");
  }
#line 304
  if (tmp) {
#line 312
    r->scrollBar.sgi_fg = xcol.pixel;
  } else {
#line 306
    r->scrollBar.sgi_fg = *(r->pixColorsFocus + 9);
  }
  {
#line 314
  xcol.red = (unsigned short)43520;
#line 315
  xcol.green = (unsigned short)43520;
#line 316
  xcol.blue = (unsigned short)43520;
#line 317
  tmp___0 = rxvt_alloc_color(r, & xcol, "light medium gray");
  }
#line 317
  if (tmp___0) {
#line 325
    r->scrollBar.sgi_lmedium = xcol.pixel;
  } else {
#line 319
    r->scrollBar.sgi_lmedium = *(r->pixColorsFocus + 9);
  }
  {
#line 327
  xcol.red = (unsigned short)48384;
#line 328
  xcol.green = (unsigned short)48384;
#line 329
  xcol.blue = (unsigned short)48384;
#line 330
  tmp___1 = rxvt_alloc_color(r, & xcol, "medium gray");
  }
#line 330
  if (tmp___1) {
#line 338
    r->scrollBar.sgi_bg = xcol.pixel;
  } else {
#line 332
    r->scrollBar.sgi_bg = *(r->pixColorsFocus + 2);
  }
  {
#line 340
  xcol.red = (unsigned short)36352;
#line 341
  xcol.green = (unsigned short)36352;
#line 342
  xcol.blue = (unsigned short)36352;
#line 343
  tmp___2 = rxvt_alloc_color(r, & xcol, "dark gray");
  }
#line 343
  if (! tmp___2) {
#line 345
    r->scrollBar.sgi_dark = *(r->pixColorsFocus + 10);
  }
  {
#line 350
  r->scrollBar.sgi_dark = xcol.pixel;
#line 352
  xcol.red = (unsigned short)24064;
#line 353
  xcol.green = (unsigned short)24064;
#line 354
  xcol.blue = (unsigned short)24064;
#line 355
  tmp___3 = rxvt_alloc_color(r, & xcol, "very dark gray");
  }
#line 355
  if (! tmp___3) {
#line 357
    r->scrollBar.sgi_vdark = *(r->pixColorsFocus + 10);
  }
  {
#line 362
  r->scrollBar.sgi_vdark = xcol.pixel;
#line 365
  gcvalue.foreground = r->scrollBar.sgi_white;
#line 366
  gcmask = (unsigned long )(1L << 2);
#line 367
  r->scrollBar.gc = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask, & gcvalue);
#line 370
  stipple = XCreateBitmapFromData(r->Xdisplay, r->scrollBar.win, (char const   *)(stp_bits),
                                  8U, 8U);
#line 373
  gcvalue.foreground = r->scrollBar.sgi_dark;
#line 374
  gcvalue.background = r->scrollBar.sgi_bg;
#line 375
  gcvalue.fill_style = 2;
#line 376
  gcvalue.stipple = stipple;
#line 377
  gcmask = (unsigned long )((((1L << 2) | (1L << 3)) | (1L << 11)) | (1L << 8));
#line 378
  r->scrollBar.sgi_stippleGC = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask, & gcvalue);
#line 383
  r->scrollBar.sgi_dimple = create_icon(r, SCROLLER_DIMPLE___0, 0, 0, 12U, 10U);
#line 388
  y_offset = (unsigned int )((12 - (16 - (2 << 1))) >> 1);
#line 388
  x_offset = y_offset;
#line 389
  r->scrollBar.sgi_upArrow = create_icon(r, SCROLLER_ARROW_UP___0, (int )x_offset,
                                         (int )y_offset, 12U, 14U);
#line 392
  r->scrollBar.sgi_upArrowHi = create_icon(r, HI_SCROLLER_ARROW_UP___0, (int )x_offset,
                                           (int )y_offset, 12U, 14U);
#line 395
  r->scrollBar.sgi_upArrowLow = create_icon(r, LO_SCROLLER_ARROW_UP, (int )x_offset,
                                            (int )y_offset, 12U, 14U);
#line 398
  r->scrollBar.sgi_downArrow = create_icon(r, SCROLLER_ARROW_DOWN___0, (int )x_offset,
                                           (int )y_offset, 12U, 14U);
#line 401
  r->scrollBar.sgi_downArrowHi = create_icon(r, HI_SCROLLER_ARROW_DOWN___0, (int )x_offset,
                                             (int )y_offset, 12U, 14U);
#line 405
  r->scrollBar.sgi_downArrowLow = create_icon(r, LO_SCROLLER_ARROW_DOWN, (int )x_offset,
                                              (int )y_offset, 12U, 14U);
  }
#line 413
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 413
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
      {
#line 421
      XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.sgi_bg);
      }
    }
  } else {
    {
#line 421
    XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.sgi_bg);
    }
  }
#line 423
  return;
}
}
#line 427 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
void rxvt_scrollbar_exit_sgi(rxvt_t *r ) 
{ 


  {
#line 430
  if ((unsigned long )((GC )0) != (unsigned long )r->scrollBar.sgi_stippleGC) {
    {
#line 431
    XFreeGC(r->Xdisplay, r->scrollBar.sgi_stippleGC);
#line 432
    r->scrollBar.sgi_stippleGC = (GC )0L;
    }
  }
#line 434
  if (0UL != r->scrollBar.sgi_dimple) {
    {
#line 435
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_dimple);
#line 436
    r->scrollBar.sgi_dimple = (Pixmap )0L;
    }
  }
#line 438
  if (0UL != r->scrollBar.sgi_upArrow) {
    {
#line 439
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_upArrow);
#line 440
    r->scrollBar.sgi_upArrow = (Pixmap )0L;
    }
  }
#line 442
  if (0UL != r->scrollBar.sgi_upArrowHi) {
    {
#line 443
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_upArrowHi);
#line 444
    r->scrollBar.sgi_upArrowHi = (Pixmap )0L;
    }
  }
#line 446
  if (0UL != r->scrollBar.sgi_upArrowLow) {
    {
#line 447
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_upArrowLow);
#line 448
    r->scrollBar.sgi_upArrowLow = (Pixmap )0L;
    }
  }
#line 450
  if (0UL != r->scrollBar.sgi_downArrow) {
    {
#line 451
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_downArrow);
#line 452
    r->scrollBar.sgi_downArrow = (Pixmap )0L;
    }
  }
#line 454
  if (0UL != r->scrollBar.sgi_downArrowHi) {
    {
#line 455
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_downArrowHi);
#line 456
    r->scrollBar.sgi_downArrowHi = (Pixmap )0L;
    }
  }
#line 458
  if (0UL != r->scrollBar.sgi_downArrowLow) {
    {
#line 459
    XFreePixmap(r->Xdisplay, r->scrollBar.sgi_downArrowLow);
#line 460
    r->scrollBar.sgi_downArrowLow = (Pixmap )0L;
    }
  }
#line 462
  return;
}
}
#line 466 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-sgi.c"
int rxvt_scrollbar_show_sgi(rxvt_t *r , int update , int last_top , int last_bot ,
                            int scroller_len ) 
{ 
  register int new_height ;
  Pixmap tmp ;
  Pixmap tmp___0 ;

  {
#line 469
  new_height = ((int )r->scrollBar.end + ((2 << 1) + (16 - (2 << 1)))) + (r->sb_shadow << 1);
#line 474
  if (! update) {
    {
#line 475
    scrollbar_fill_back(r, (unsigned int )r->scrollBar.end);
    }
  }
#line 477
  if (0 == (int )(r->vts[r->tabBar.atab])->nscrolled) {
    {
#line 479
    XCopyArea(r->Xdisplay, r->scrollBar.sgi_upArrowLow, r->scrollBar.win, r->scrollBar.gc,
              0, 0, (unsigned int )(16 - (2 << 1)), 14U, ((16 >> 1) - ((16 - (2 << 1)) >> 1)) + 1,
              2);
#line 487
    XCopyArea(r->Xdisplay, r->scrollBar.sgi_downArrowLow, r->scrollBar.win, r->scrollBar.gc,
              0, 0, (unsigned int )(16 - (2 << 1)), 14U, ((16 >> 1) - ((16 - (2 << 1)) >> 1)) + 1,
              (new_height - 14) - 2);
    }
  } else {
#line 498
    if (last_top < (int )r->scrollBar.top) {
      {
#line 499
      XClearArea(r->Xdisplay, r->scrollBar.win, 0, last_top, 15U, (unsigned int )(last_top - (int )r->scrollBar.top),
                 0);
      }
    }
#line 503
    if ((int )r->scrollBar.bot < last_bot) {
      {
#line 504
      XClearArea(r->Xdisplay, r->scrollBar.win, 0, (int )r->scrollBar.bot, 15U, (unsigned int )((last_bot - (int )r->scrollBar.bot) + 1),
                 0);
      }
    }
    {
#line 508
    XClearArea(r->Xdisplay, r->scrollBar.win, 0, (int )r->scrollBar.top, 15U, (unsigned int )scroller_len,
               0);
#line 513
    XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.sgi_vdark);
#line 514
    XDrawRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 0, (int )r->scrollBar.top,
                   15U, (unsigned int )scroller_len);
#line 519
    sgi_draw_bevel(r, r->scrollBar.win, 1, (int )r->scrollBar.top + 1, 13, scroller_len - 2);
#line 532
    XCopyArea(r->Xdisplay, r->scrollBar.sgi_dimple, r->scrollBar.win, r->scrollBar.gc,
              0, 0, 12U, 10U, ((16 >> 1) - (12 >> 1)) + 1, (int )r->scrollBar.top + ((scroller_len - 10) >> 1));
    }
#line 540
    if ((int )r->scrollBar.state == 85) {
#line 540
      tmp = r->scrollBar.sgi_upArrowHi;
    } else {
#line 540
      tmp = r->scrollBar.sgi_upArrow;
    }
    {
#line 540
    XCopyArea(r->Xdisplay, tmp, r->scrollBar.win, r->scrollBar.gc, 0, 0, (unsigned int )(16 - (2 << 1)),
              14U, ((16 >> 1) - ((16 - (2 << 1)) >> 1)) + 1, 2);
    }
#line 550
    if ((int )r->scrollBar.state == 68) {
#line 550
      tmp___0 = r->scrollBar.sgi_downArrowHi;
    } else {
#line 550
      tmp___0 = r->scrollBar.sgi_downArrow;
    }
    {
#line 550
    XCopyArea(r->Xdisplay, tmp___0, r->scrollBar.win, r->scrollBar.gc, 0, 0, (unsigned int )(16 - (2 << 1)),
              14U, ((16 >> 1) - ((16 - (2 << 1)) >> 1)) + 1, (new_height - 14) - 2);
    }
  }
  {
#line 561
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.sgi_fg);
#line 562
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 0, ((2 << 1) + (16 - (2 << 1))) - 1,
            15, ((2 << 1) + (16 - (2 << 1))) - 1);
#line 566
  XDrawLine(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, 0, new_height - ((2 << 1) + (16 - (2 << 1))),
            15, new_height - ((2 << 1) + (16 - (2 << 1))));
  }
#line 570
  return (1);
}
}
#line 139 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 874
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 287 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcslen)(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 370
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 354 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
char *rxvt_wcstombs(wchar_t const   *str , int len ) ;
#line 355
wchar_t *rxvt_mbstowcs(char const   *str ) ;
#line 356
char *rxvt_wcstoutf8(wchar_t const   *str ) ;
#line 357
wchar_t *rxvt_utf8towcs(char const   *str ) ;
#line 359
int ma_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 360
int ma_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 361
char *ma_strcpy(char *d , char const   *s ) ;
#line 362
char *ma_strncpy(char *d , char const   *s , size_t len ) ;
#line 363
int ma_strcmp(char const   *s1 , char const   *s2 ) ;
#line 364
int ma_strncmp(char const   *s1 , char const   *s2 , size_t len ) ;
#line 365
char *ma_strcat(char *s1 , char const   *s2 ) ;
#line 366
char *ma_strncat(char *s1 , char const   *s2 , size_t len ) ;
#line 367
size_t ma_strlen(char const   *s ) ;
#line 368
char *ma_strdup(char const   *s ) ;
#line 369
char *ma_strndup(char const   *s , size_t sz ) ;
#line 370
char *ma_index(char const   *s , int c ) ;
#line 371
char *ma_strchr(char const   *s , int c ) ;
#line 372
char *ma_rindex(char const   *s , int c ) ;
#line 373
char *ma_strrchr(char const   *s , int c ) ;
#line 374
void *ma_memcpy(void *s1 , void const   *s2 , size_t len ) ;
#line 375
void *ma_memmove(void *d , void const   *s , size_t len ) ;
#line 376
void ma_bzero(void *buf , size_t len ) ;
#line 377
void *ma_memset(void *p , int c1 , size_t len ) ;
#line 378
char *ma_strcasestr(char const   *phaystack , char const   *pneedle ) ;
#line 33 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *rxvt_wcstombs(wchar_t const   *str , int len ) 
{ 
  mbstate_t mbs ;
  char *r ;
  char *dst ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int l ;
  wchar_t const   *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 40
  if (len < 0) {
    {
#line 41
    tmp = wcslen(str);
#line 41
    len = (int )tmp;
    }
  }
  {
#line 43
  memset((void *)(& mbs), 0, sizeof(mbs));
#line 44
  tmp___0 = __ctype_get_mb_cur_max();
#line 44
  tmp___1 = rxvt_malloc((size_t )len * tmp___0 + 1UL);
#line 44
  r = (char *)tmp___1;
#line 45
  dst = r;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    tmp___5 = len;
#line 47
    len --;
#line 47
    if (! tmp___5) {
#line 47
      goto while_break;
    }
    {
#line 48
    tmp___2 = str;
#line 48
    str ++;
#line 48
    tmp___3 = wcrtomb((char */* __restrict  */)dst, (wchar_t )*tmp___2, (mbstate_t */* __restrict  */)(& mbs));
#line 48
    l = (int )tmp___3;
    }
#line 49
    if (l < 0) {
#line 50
      tmp___4 = dst;
#line 50
      dst ++;
#line 50
      *tmp___4 = (char )'?';
    } else {
#line 52
      dst += l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  tmp___6 = dst;
#line 55
  dst ++;
#line 55
  *tmp___6 = (char)0;
#line 57
  return (r);
}
}
#line 62 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
wchar_t *rxvt_mbstowcs(char const   *str ) 
{ 
  wchar_t *r ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 66
  tmp = strlen(str);
#line 66
  len = (int )tmp;
#line 68
  tmp___0 = rxvt_malloc((unsigned long )(len + 1) * sizeof(wchar_t ));
#line 68
  r = (wchar_t *)tmp___0;
#line 70
  tmp___1 = mbstowcs((wchar_t */* __restrict  */)r, (char const   */* __restrict  */)str,
                     (size_t )(len + 1));
  }
#line 70
  if (tmp___1 < 0UL) {
#line 71
    *r = 0;
  }
#line 73
  return (r);
}
}
#line 78 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *rxvt_wcstoutf8(wchar_t const   *str ) 
{ 
  char *r ;
  char *p ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  unicode_t w ;
  wchar_t const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 85
  tmp = wcslen(str);
#line 85
  len = (int )tmp;
#line 87
  tmp___0 = rxvt_malloc((size_t )(len * 4 + 1));
#line 87
  r = (char *)tmp___0;
#line 88
  p = r;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    tmp___13 = len;
#line 90
    len --;
#line 90
    if (! tmp___13) {
#line 90
      goto while_break;
    }
#line 91
    tmp___1 = str;
#line 91
    str ++;
#line 91
    w = (unicode_t )((unsigned long )*tmp___1 & 2097151UL);
#line 93
    if (w < 128U) {
#line 94
      tmp___2 = p;
#line 94
      p ++;
#line 94
      *tmp___2 = (char )w;
    } else
#line 95
    if (w < 2048U) {
#line 96
      tmp___3 = p;
#line 96
      p ++;
#line 96
      *tmp___3 = (char )(192U | (w >> 6));
#line 97
      tmp___4 = p;
#line 97
      p ++;
#line 97
      *tmp___4 = (char )(128U | (w & 63U));
    } else
#line 99
    if (w < 65536U) {
#line 100
      tmp___5 = p;
#line 100
      p ++;
#line 100
      *tmp___5 = (char )(224U | (w >> 12));
#line 101
      tmp___6 = p;
#line 101
      p ++;
#line 101
      *tmp___6 = (char )(128U | ((w >> 6) & 63U));
#line 102
      tmp___7 = p;
#line 102
      p ++;
#line 102
      *tmp___7 = (char )(128U | (w & 63U));
    } else
#line 104
    if (w < 1114112U) {
#line 105
      tmp___8 = p;
#line 105
      p ++;
#line 105
      *tmp___8 = (char )(240U | (w >> 18));
#line 106
      tmp___9 = p;
#line 106
      p ++;
#line 106
      *tmp___9 = (char )(128U | ((w >> 12) & 63U));
#line 107
      tmp___10 = p;
#line 107
      p ++;
#line 107
      *tmp___10 = (char )(128U | ((w >> 6) & 63U));
#line 108
      tmp___11 = p;
#line 108
      p ++;
#line 108
      *tmp___11 = (char )(128U | (w & 63U));
    } else {
#line 111
      tmp___12 = p;
#line 111
      p ++;
#line 111
      *tmp___12 = (char )'?';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  *p = (char)0;
#line 116
  return (r);
}
}
#line 121 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
wchar_t *rxvt_utf8towcs(char const   *str ) 
{ 
  wchar_t *r ;
  wchar_t *p ;
  unsigned char *s ;
  unsigned char *e ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  wchar_t *tmp___1 ;
  unsigned char *tmp___2 ;
  wchar_t *tmp___3 ;
  wchar_t *tmp___4 ;
  wchar_t *tmp___5 ;
  wchar_t *tmp___6 ;

  {
  {
#line 128
  tmp = strlen(str);
#line 128
  len = (int )tmp;
#line 131
  tmp___0 = rxvt_malloc((unsigned long )(len + 1) * sizeof(wchar_t ));
#line 131
  r = (wchar_t *)tmp___0;
#line 131
  p = r;
#line 134
  s = (unsigned char *)str;
#line 134
  e = s + len;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    len = (int )(e - s);
#line 140
    if (len == 0) {
#line 141
      goto while_break;
    } else
#line 142
    if ((int )*(s + 0) < 128) {
#line 143
      tmp___1 = p;
#line 143
      p ++;
#line 143
      tmp___2 = s;
#line 143
      s ++;
#line 143
      *tmp___1 = (wchar_t )*tmp___2;
    } else
#line 144
    if (len >= 2) {
#line 144
      if ((int )*(s + 0) >= 194) {
#line 144
        if ((int )*(s + 0) <= 223) {
#line 144
          if (((int )*(s + 1) & 192) == 128) {
#line 147
            tmp___3 = p;
#line 147
            p ++;
#line 147
            *tmp___3 = (((int )*(s + 0) & 31) << 6) | ((int )*(s + 1) & 63);
#line 148
            s += 2;
          } else {
#line 144
            goto _L___16;
          }
        } else {
#line 144
          goto _L___16;
        }
      } else {
#line 144
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 150
    if (len >= 3) {
#line 150
      if ((int )*(s + 0) == 224) {
#line 150
        if ((int )*(s + 1) >= 160) {
#line 150
          if ((int )*(s + 1) <= 191) {
#line 150
            goto _L___7;
          } else {
#line 150
            goto _L___14;
          }
        } else {
#line 150
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 150
      if ((int )*(s + 0) >= 225) {
#line 150
        if ((int )*(s + 0) <= 236) {
#line 150
          if ((int )*(s + 1) >= 128) {
#line 150
            if ((int )*(s + 1) <= 191) {
#line 150
              goto _L___7;
            } else {
#line 150
              goto _L___12;
            }
          } else {
#line 150
            goto _L___12;
          }
        } else {
#line 150
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 150
      if ((int )*(s + 0) == 237) {
#line 150
        if ((int )*(s + 1) >= 128) {
#line 150
          if ((int )*(s + 1) <= 159) {
#line 150
            goto _L___7;
          } else {
#line 150
            goto _L___9;
          }
        } else {
#line 150
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 150
      if ((int )*(s + 0) >= 238) {
#line 150
        if ((int )*(s + 0) <= 239) {
#line 150
          if ((int )*(s + 1) >= 128) {
#line 150
            if ((int )*(s + 1) <= 191) {
              _L___7: /* CIL Label */ 
#line 150
              if (((int )*(s + 2) & 192) == 128) {
#line 156
                tmp___4 = p;
#line 156
                p ++;
#line 156
                *tmp___4 = ((((int )*(s + 0) & 15) << 12) | (((int )*(s + 1) & 63) << 6)) | ((int )*(s + 2) & 63);
#line 159
                s += 3;
              } else {
#line 150
                goto _L___6;
              }
            } else {
#line 150
              goto _L___6;
            }
          } else {
#line 150
            goto _L___6;
          }
        } else {
#line 150
          goto _L___6;
        }
      } else {
#line 150
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 161
    if (len >= 4) {
#line 161
      if ((int )*(s + 0) == 240) {
#line 161
        if ((int )*(s + 1) >= 144) {
#line 161
          if ((int )*(s + 1) <= 191) {
#line 161
            goto _L;
          } else {
#line 161
            goto _L___4;
          }
        } else {
#line 161
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 161
      if ((int )*(s + 0) >= 241) {
#line 161
        if ((int )*(s + 0) <= 243) {
#line 161
          if ((int )*(s + 1) >= 128) {
#line 161
            if ((int )*(s + 1) <= 191) {
#line 161
              goto _L;
            } else {
#line 161
              goto _L___2;
            }
          } else {
#line 161
            goto _L___2;
          }
        } else {
#line 161
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 161
      if ((int )*(s + 0) == 244) {
#line 161
        if ((int )*(s + 1) >= 128) {
#line 161
          if ((int )*(s + 1) <= 143) {
            _L: /* CIL Label */ 
#line 161
            if (((int )*(s + 2) & 192) == 128) {
#line 161
              if (((int )*(s + 3) & 192) == 128) {
#line 166
                tmp___5 = p;
#line 166
                p ++;
#line 166
                *tmp___5 = (((((int )*(s + 0) & 7) << 18) | (((int )*(s + 1) & 63) << 12)) | (((int )*(s + 2) & 63) << 6)) | ((int )*(s + 3) & 63);
#line 170
                s += 4;
              } else {
#line 173
                tmp___6 = p;
#line 173
                p ++;
#line 173
                *tmp___6 = 65533;
#line 174
                s ++;
              }
            } else {
#line 173
              tmp___6 = p;
#line 173
              p ++;
#line 173
              *tmp___6 = 65533;
#line 174
              s ++;
            }
          } else {
#line 173
            tmp___6 = p;
#line 173
            p ++;
#line 173
            *tmp___6 = 65533;
#line 174
            s ++;
          }
        } else {
#line 173
          tmp___6 = p;
#line 173
          p ++;
#line 173
          *tmp___6 = 65533;
#line 174
          s ++;
        }
      } else {
#line 173
        tmp___6 = p;
#line 173
        p ++;
#line 173
        *tmp___6 = 65533;
#line 174
        s ++;
      }
    } else {
#line 173
      tmp___6 = p;
#line 173
      p ++;
#line 173
      *tmp___6 = 65533;
#line 174
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  *p = 0;
#line 180
  return (r);
}
}
#line 192 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
int ma_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp = tolower((int )*s1);
#line 195
    tmp___0 = tolower((int )*s2);
    }
#line 195
    if (! (tmp == tmp___0)) {
#line 195
      goto while_break;
    }
#line 196
    if (! *s1) {
#line 197
      return (0);
    }
#line 195
    s1 ++;
#line 195
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  tmp___1 = tolower((int )*s1);
#line 198
  tmp___2 = tolower((int )*s2);
  }
#line 198
  return (tmp___1 - tmp___2);
}
}
#line 202 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
int ma_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    tmp = n;
#line 205
    n --;
#line 205
    if (tmp) {
      {
#line 205
      tmp___0 = tolower((int )*s1);
#line 205
      tmp___1 = tolower((int )*s2);
      }
#line 205
      if (! (tmp___0 == tmp___1)) {
#line 205
        goto while_break;
      }
    } else {
#line 205
      goto while_break;
    }
#line 206
    if (! *s1) {
#line 207
      return (0);
    }
#line 205
    s1 ++;
#line 205
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (n == 0UL) {
#line 209
    return (0);
  }
  {
#line 210
  tmp___2 = tolower((int )*s1);
#line 210
  tmp___3 = tolower((int )*s2);
  }
#line 210
  return (tmp___2 - tmp___3);
}
}
#line 214 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strcpy(char *d , char const   *s ) 
{ 
  char *r ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 217
  r = d;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    tmp = r;
#line 219
    r ++;
#line 219
    tmp___1 = s;
#line 219
    s ++;
#line 219
    tmp___0 = (char )*tmp___1;
#line 219
    *tmp = tmp___0;
#line 219
    if (! ((int )tmp___0 != 0)) {
#line 219
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (d);
}
}
#line 225 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strncpy(char *d , char const   *s , size_t len ) 
{ 
  char *r ;
  char *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 228
  r = d;
#line 230
  if (len) {
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! len) {
#line 231
        goto while_break;
      }
#line 232
      tmp___0 = r;
#line 232
      r ++;
#line 232
      tmp___2 = s;
#line 232
      s ++;
#line 232
      tmp___1 = (char )*tmp___2;
#line 232
      *tmp___0 = tmp___1;
#line 232
      if ((int )tmp___1 == 0) {
        {
#line 233
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 233
          len --;
#line 233
          if (! len) {
#line 233
            goto while_break___0;
          }
#line 234
          tmp = r;
#line 234
          r ++;
#line 234
          *tmp = (char )'\000';
        }
        while_break___0: /* CIL Label */ ;
        }
#line 235
        goto while_break;
      }
#line 231
      len --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 237
  return (d);
}
}
#line 241 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
int ma_strcmp(char const   *s1 , char const   *s2 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    tmp___0 = s2;
#line 244
    s2 ++;
#line 244
    if (! ((int const   )*s1 == (int const   )*tmp___0)) {
#line 244
      goto while_break;
    }
#line 245
    tmp = s1;
#line 245
    s1 ++;
#line 245
    if ((int const   )*tmp == 0) {
#line 246
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  s2 --;
#line 247
  return ((int )((unsigned char )*s1) - (int )((unsigned char )*s2));
}
}
#line 251 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
int ma_strncmp(char const   *s1 , char const   *s2 , size_t len ) 
{ 
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 254
  if (len) {
    {
#line 255
    while (1) {
      while_continue: /* CIL Label */ ;
#line 255
      tmp = len;
#line 255
      len --;
#line 255
      if (tmp) {
#line 255
        tmp___0 = s1;
#line 255
        s1 ++;
#line 255
        tmp___1 = s2;
#line 255
        s2 ++;
#line 255
        if (! ((int const   )*tmp___0 == (int const   )*tmp___1)) {
#line 255
          goto while_break;
        }
      } else {
#line 255
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 257
    len ++;
#line 257
    if (len) {
#line 258
      s1 --;
#line 258
      s2 --;
#line 258
      return ((int )((unsigned char )*s1) - (int )((unsigned char )*s2));
    }
  }
#line 260
  return (0);
}
}
#line 264 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strcat(char *s1 , char const   *s2 ) 
{ 
  char *r ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 267
  r = s1;
#line 269
  if ((int )*r != 0) {
    {
#line 270
    while (1) {
      while_continue: /* CIL Label */ ;
#line 270
      r ++;
#line 270
      if (! ((int )*r != 0)) {
#line 270
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    tmp = r;
#line 272
    r ++;
#line 272
    tmp___1 = s2;
#line 272
    s2 ++;
#line 272
    tmp___0 = (char )*tmp___1;
#line 272
    *tmp = tmp___0;
#line 272
    if (! ((int )tmp___0 != 0)) {
#line 272
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 275
  return (s1);
}
}
#line 279 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strncat(char *s1 , char const   *s2 , size_t len ) 
{ 
  char *r ;
  size_t tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 282
  r = s1;
#line 284
  if ((int )*r != 0) {
    {
#line 285
    while (1) {
      while_continue: /* CIL Label */ ;
#line 285
      r ++;
#line 285
      if (! ((int )*r != 0)) {
#line 285
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    tmp = len;
#line 287
    len --;
#line 287
    if (tmp) {
#line 287
      tmp___0 = r;
#line 287
      r ++;
#line 287
      tmp___2 = s2;
#line 287
      s2 ++;
#line 287
      tmp___1 = (char )*tmp___2;
#line 287
      *tmp___0 = tmp___1;
#line 287
      if (! ((int )tmp___1 != 0)) {
#line 287
        goto while_break___0;
      }
    } else {
#line 287
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 289
  *r = (char )'\000';
#line 291
  return (s1);
}
}
#line 295 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
size_t ma_strlen(char const   *s ) 
{ 
  size_t len ;
  char const   *tmp ;

  {
#line 298
  len = (size_t )0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    tmp = s;
#line 300
    s ++;
#line 300
    if (! ((int const   )*tmp != 0)) {
#line 300
      goto while_break;
    }
#line 300
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return (len);
}
}
#line 307 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strdup(char const   *s ) 
{ 
  int len ;
  size_t tmp ;
  char *c ;
  void *tmp___0 ;

  {
  {
#line 310
  tmp = strlen(s);
#line 310
  len = (int )(tmp + 1UL);
#line 314
  tmp___0 = rxvt_malloc((size_t )len);
#line 314
  c = (char *)tmp___0;
  }
#line 314
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 315
    memcpy((void */* __restrict  */)((void *)c), (void const   */* __restrict  */)((void const   *)s),
           (size_t )len);
    }
  }
#line 316
  return (c);
}
}
#line 321 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strndup(char const   *s , size_t sz ) 
{ 
  char *c ;
  int len ;
  void *tmp ;

  {
  {
#line 325
  len = (int )(sz + 1UL);
#line 328
  tmp = rxvt_malloc((size_t )len);
#line 328
  c = (char *)tmp;
  }
#line 328
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
#line 329
    strncpy((char */* __restrict  */)c, (char const   */* __restrict  */)s, sz);
    }
  }
#line 330
  *(c + sz) = (char )'\000';
#line 331
  return (c);
}
}
#line 336 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_index(char const   *s , int c ) 
{ 
  char *tmp ;

  {
  {
#line 339
  tmp = strchr(s, c);
  }
#line 339
  return (tmp);
}
}
#line 343 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strchr(char const   *s , int c ) 
{ 
  char *p ;
  char const   *tmp ;

  {
#line 346
  p = (char *)((void *)0);
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if ((int const   )*s == (int const   )((char )c)) {
#line 350
      p = (char *)s;
#line 351
      goto while_break;
    }
#line 353
    tmp = s;
#line 353
    s ++;
#line 353
    if ((int const   )*tmp == 0) {
#line 354
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (p);
}
}
#line 361 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_rindex(char const   *s , int c ) 
{ 
  char *tmp ;

  {
  {
#line 364
  tmp = strrchr(s, c);
  }
#line 364
  return (tmp);
}
}
#line 368 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strrchr(char const   *s , int c ) 
{ 
  char *p ;
  char const   *tmp ;

  {
#line 371
  p = (char *)((void *)0);
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if ((int const   )*s == (int const   )((char )c)) {
#line 375
      p = (char *)s;
    }
#line 376
    tmp = s;
#line 376
    s ++;
#line 376
    if ((int const   )*tmp == 0) {
#line 377
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (p);
}
}
#line 383 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
void *ma_memcpy(void *s1 , void const   *s2 , size_t len ) 
{ 
  void *tmp ;

  {
  {
#line 387
  tmp = memmove(s1, s2, len);
  }
#line 387
  return (tmp);
}
}
#line 394 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
void *ma_memmove(void *d , void const   *s , size_t len ) 
{ 
  unsigned int i ;
  unsigned int *pdst ;
  unsigned int *psrc ;
  unsigned char *dst ;
  unsigned char *src ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  size_t tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  size_t tmp___10 ;

  {
#line 400
  dst = (unsigned char *)d;
#line 401
  src = (unsigned char *)s;
#line 403
  if (len) {
#line 403
    if ((unsigned long )d != (unsigned long )s) {
#line 404
      if ((unsigned int )d < (unsigned int )s) {
#line 406
        i = (unsigned int )((unsigned long )(- ((unsigned int )dst)) & (sizeof(unsigned int *) - 1UL));
#line 407
        if (len >= 16UL) {
#line 407
          if (i == (- ((unsigned int )src) & 7U)) {
#line 410
            len -= (size_t )i;
            {
#line 411
            while (1) {
              while_continue: /* CIL Label */ ;
#line 411
              tmp___1 = i;
#line 411
              i --;
#line 411
              if (! tmp___1) {
#line 411
                goto while_break;
              }
#line 412
              tmp = dst;
#line 412
              dst ++;
#line 412
              tmp___0 = src;
#line 412
              src ++;
#line 412
              *tmp = *tmp___0;
            }
            while_break: /* CIL Label */ ;
            }
#line 414
            pdst = (unsigned int *)dst;
#line 415
            psrc = (unsigned int *)src;
#line 416
            i = (unsigned int )(len / sizeof(unsigned int *));
            {
#line 416
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 416
              tmp___4 = i;
#line 416
              i --;
#line 416
              if (! tmp___4) {
#line 416
                goto while_break___0;
              }
#line 417
              tmp___2 = pdst;
#line 417
              pdst ++;
#line 417
              tmp___3 = psrc;
#line 417
              psrc ++;
#line 417
              *tmp___2 = *tmp___3;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 418
            len &= 7UL;
#line 420
            dst = (unsigned char *)pdst;
#line 421
            src = (unsigned char *)psrc;
          }
        }
        {
#line 424
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 424
          tmp___7 = len;
#line 424
          len --;
#line 424
          if (! tmp___7) {
#line 424
            goto while_break___1;
          }
#line 425
          tmp___5 = dst;
#line 425
          dst ++;
#line 425
          tmp___6 = src;
#line 425
          src ++;
#line 425
          *tmp___5 = *tmp___6;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 429
        dst += len;
#line 430
        src += len;
#line 431
        i = (unsigned int )((unsigned long )((unsigned int )dst) & (sizeof(unsigned int *) - 1UL));
#line 432
        if (len >= 16UL) {
#line 432
          if (i == ((unsigned int )src & 7U)) {
#line 435
            len -= (size_t )i;
            {
#line 436
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 436
              tmp___8 = i;
#line 436
              i --;
#line 436
              if (! tmp___8) {
#line 436
                goto while_break___2;
              }
#line 437
              dst --;
#line 437
              src --;
#line 437
              *dst = *src;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 439
            pdst = (unsigned int *)dst;
#line 440
            psrc = (unsigned int *)src;
#line 441
            i = (unsigned int )(len / sizeof(unsigned int *));
            {
#line 441
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 441
              tmp___9 = i;
#line 441
              i --;
#line 441
              if (! tmp___9) {
#line 441
                goto while_break___3;
              }
#line 442
              pdst --;
#line 442
              psrc --;
#line 442
              *pdst = *psrc;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 443
            len &= 7UL;
#line 445
            dst = (unsigned char *)pdst;
#line 446
            src = (unsigned char *)psrc;
          }
        }
        {
#line 449
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 449
          tmp___10 = len;
#line 449
          len --;
#line 449
          if (! tmp___10) {
#line 449
            goto while_break___4;
          }
#line 450
          dst --;
#line 450
          src --;
#line 450
          *dst = *src;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
  }
#line 453
  return (d);
}
}
#line 464 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
void ma_bzero(void *buf , size_t len ) 
{ 


  {
  {
#line 467
  memset(buf, 0, len);
  }
#line 468
  return;
}
}
#line 471 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
void *ma_memset(void *p , int c1 , size_t len ) 
{ 
  unsigned int i ;
  unsigned int val ;
  unsigned int *pdst ;
  unsigned char c ;
  unsigned char *lp ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  unsigned int *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 476
  c = (unsigned char )c1;
#line 477
  lp = (unsigned char *)p;
#line 479
  if (len) {
#line 480
    if (len >= 16UL) {
#line 486
      i = - ((unsigned int )p) & 7U;
#line 486
      if (i) {
#line 487
        len -= (size_t )i;
        {
#line 488
        while (1) {
          while_continue: /* CIL Label */ ;
#line 488
          tmp___0 = i;
#line 488
          i --;
#line 488
          if (! tmp___0) {
#line 488
            goto while_break;
          }
#line 489
          tmp = lp;
#line 489
          lp ++;
#line 489
          *tmp = c;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 493
      val = (unsigned int )(((int )c << 8) + (int )c);
#line 495
      val |= val << 16;
#line 498
      val |= val << 32;
#line 504
      pdst = (unsigned int *)lp;
#line 505
      i = (unsigned int )(len / 8UL);
      {
#line 505
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 505
        tmp___2 = i;
#line 505
        i --;
#line 505
        if (! tmp___2) {
#line 505
          goto while_break___0;
        }
#line 506
        tmp___1 = pdst;
#line 506
        pdst ++;
#line 506
        *tmp___1 = val;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 507
      len &= 7UL;
#line 509
      lp = (unsigned char *)pdst;
    }
    {
#line 512
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 512
      tmp___4 = len;
#line 512
      len --;
#line 512
      if (! tmp___4) {
#line 512
        goto while_break___1;
      }
#line 513
      tmp___3 = lp;
#line 513
      lp ++;
#line 513
      *tmp___3 = c;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 515
  return (p);
}
}
#line 525 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/strings.c"
char *ma_strcasestr(char const   *phaystack , char const   *pneedle ) 
{ 
  register unsigned char const   *haystack ;
  register unsigned char const   *needle ;
  register chartype b ;
  register chartype c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  register chartype a ;
  register unsigned char const   *rhaystack ;
  register unsigned char const   *rneedle ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 533
  haystack = (unsigned char const   *)phaystack;
#line 534
  needle = (unsigned char const   *)pneedle;
#line 536
  tmp = tolower((int )*needle);
#line 536
  b = (chartype )tmp;
  }
#line 537
  if (b != 0U) {
#line 539
    haystack --;
    {
#line 540
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      haystack ++;
#line 542
      c = (chartype )*haystack;
#line 543
      if (c == 0U) {
#line 544
        goto ret0;
      }
      {
#line 540
      tmp___0 = tolower((int )c);
      }
#line 540
      if (! (tmp___0 != (int )b)) {
#line 540
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 548
    needle ++;
#line 548
    tmp___1 = tolower((int )*needle);
#line 548
    c = (chartype )tmp___1;
    }
#line 549
    if (c == 0U) {
#line 550
      goto foundneedle;
    }
#line 551
    needle ++;
#line 552
    goto jin;
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 559
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 561
        haystack ++;
#line 561
        a = (chartype )*haystack;
#line 562
        if (a == 0U) {
#line 563
          goto ret0;
        }
        {
#line 564
        tmp___2 = tolower((int )a);
        }
#line 564
        if (tmp___2 == (int )b) {
#line 565
          goto while_break___1;
        }
#line 566
        haystack ++;
#line 566
        a = (chartype )*haystack;
#line 567
        if (a == 0U) {
#line 568
          goto ret0;
        }
        shloop: 
        {
#line 559
        tmp___3 = tolower((int )a);
        }
#line 559
        if (! (tmp___3 != (int )b)) {
#line 559
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      jin: 
#line 574
      haystack ++;
#line 574
      a = (chartype )*haystack;
#line 575
      if (a == 0U) {
#line 576
        goto ret0;
      }
      {
#line 578
      tmp___4 = tolower((int )a);
      }
#line 578
      if (tmp___4 != (int )c) {
#line 579
        goto shloop;
      }
      {
#line 581
      tmp___5 = haystack;
#line 581
      haystack --;
#line 581
      rhaystack = tmp___5 + 1;
#line 582
      rneedle = needle;
#line 583
      tmp___6 = tolower((int )*rneedle);
#line 583
      a = (chartype )tmp___6;
#line 585
      tmp___11 = tolower((int )*rhaystack);
      }
#line 585
      if (tmp___11 == (int )a) {
        {
#line 586
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 588
          if (a == 0U) {
#line 589
            goto foundneedle;
          }
          {
#line 590
          rhaystack ++;
#line 591
          needle ++;
#line 591
          tmp___7 = tolower((int )*needle);
#line 591
          a = (chartype )tmp___7;
#line 592
          tmp___8 = tolower((int )*rhaystack);
          }
#line 592
          if (tmp___8 != (int )a) {
#line 593
            goto while_break___2;
          }
#line 594
          if (a == 0U) {
#line 595
            goto foundneedle;
          }
          {
#line 596
          rhaystack ++;
#line 597
          needle ++;
#line 597
          tmp___9 = tolower((int )*needle);
#line 597
          a = (chartype )tmp___9;
#line 586
          tmp___10 = tolower((int )*rhaystack);
          }
#line 586
          if (! (tmp___10 == (int )a)) {
#line 586
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 601
      needle = rneedle;
#line 603
      if (a == 0U) {
#line 604
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  foundneedle: 
#line 608
  return ((char *)haystack);
  ret0: 
#line 610
  return ((char *)0);
}
}
#line 1468 "/usr/include/X11/Xlib.h"
extern XImage *XGetImage(Display * , Drawable  , int  , int  , unsigned int  , unsigned int  ,
                         unsigned long  , int  ) ;
#line 2632
extern int XGetGeometry(Display * , Drawable  , Window * , int * , int * , unsigned int * ,
                        unsigned int * , unsigned int * , unsigned int * ) ;
#line 2915
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 3029
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
#line 347 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
unsigned long rxvt_scrollbar_bg(rxvt_t *r ) ;
#line 397
void rxvt_shade_pixmap(rxvt_t *r , Drawable src , int sx , int sy , unsigned int nw ,
                       unsigned int nh ) ;
#line 30 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
int tempDisableTransparent(rxvt_t *r ) ;
#line 31
void expose_transparent_subwin(rxvt_t *r ) ;
#line 32
int resetParentPixmap(rxvt_t *r , unsigned int rootw , unsigned int rooth , unsigned int rootd ) ;
#line 42
static void shade_ximage(rxvt_t *r , XImage *srcImage ) ;
#line 51 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
int rxvt_set_opacity(rxvt_t *r ) 
{ 
  int k ;
  unsigned int n ;
  Window wintree[6] ;
  Window root ;
  Window *list ;
  CARD32 opacity ;
  int tmp ;

  {
#line 63
  if ((unsigned long )((void *)0) == (unsigned long )(r->h)->rs[318]) {
#line 65
    return (0);
  } else
#line 63
  if (0UL == (r->h)->xa[14]) {
#line 65
    return (0);
  }
#line 69
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 70
    r->Options[(1UL << 16) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 16) & 3UL] & ~ ((1UL << 16) & 0xfffffffffffffffcUL));
  }
  {
#line 71
  XSetWindowBackground(r->Xdisplay, r->TermWin.parent, r->profile[0].bg);
#line 74
  opacity = (unsigned int )r->TermWin.opacity * 42949672U;
#line 80
  wintree[0] = r->TermWin.parent;
#line 81
  k = 1;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (k < 6)) {
#line 81
      goto while_break;
    }
    {
#line 83
    XQueryTree(r->Xdisplay, wintree[k - 1], & root, & wintree[k], & list, & n);
#line 85
    XFree((void *)list);
    }
#line 86
    if (wintree[k] == (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root) {
#line 87
      goto while_break;
    }
#line 81
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if (k != 6) {
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      tmp = k;
#line 93
      k --;
#line 93
      if (! (tmp > 0)) {
#line 93
        goto while_break___0;
      }
      {
#line 94
      XChangeProperty(r->Xdisplay, wintree[k], (r->h)->xa[14], (Atom )6, 32, 0, (unsigned char const   *)((unsigned char *)(& opacity)),
                      1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 99
  XSync(r->Xdisplay, 0);
  }
#line 101
  return (1);
}
}
#line 106 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
void rxvt_process_reparentnotify(rxvt_t *r , XEvent *ev ) 
{ 
  int tmp ;

  {
  {
#line 111
  rxvt_set_opacity(r);
  }
#line 114
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 116
    if ((r->h)->bgRefreshInterval) {
      {
#line 117
      gettimeofday((struct timeval */* __restrict  */)(& (r->h)->lastCNotify), (__timezone_ptr_t )((void *)0));
      }
    } else {
      {
#line 118
      tmp = rxvt_check_our_parents(r);
      }
#line 118
      if (tmp) {
#line 119
        (r->h)->want_full_refresh = (unsigned char)1;
      }
    }
  }
#line 122
  return;
}
}
#line 131 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
int tempDisableTransparent(rxvt_t *r ) 
{ 


  {
#line 135
  if ((r->h)->am_transparent) {
#line 140
    (r->h)->am_transparent = (unsigned char)0;
#line 141
    (r->h)->want_full_refresh = (unsigned char)1;
#line 143
    if (! ((unsigned long )r->Options[(1UL << 17) & 3UL] & ((1UL << 17) & 0xfffffffffffffffcUL))) {
      {
#line 145
      XSetWindowBackground(r->Xdisplay, r->TermWin.parent, r->profile[0].bg);
#line 147
      expose_transparent_subwin(r);
      }
    }
#line 150
    return (1);
  } else {
#line 152
    return (0);
  }
}
}
#line 159 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
void expose_transparent_subwin(rxvt_t *r ) 
{ 


  {
#line 164
  if (-1 == (int )r->tabBar.ltab) {
#line 164
    return;
  }
#line 167
  if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
    {
#line 170
    XClearWindow(r->Xdisplay, r->scrollBar.win);
#line 171
    (*(r->scrollBar.update))(r, 1, (int )r->scrollBar.top, (int )r->scrollBar.bot,
                             (r->h)->scroller_len);
    }
  }
#line 182
  if ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL)) {
    {
#line 185
    rxvt_tabbar_expose(r, (XEvent *)((void *)0));
    }
  }
#line 187
  return;
}
}
#line 200 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
int resetParentPixmap(rxvt_t *r , unsigned int rootw , unsigned int rooth , unsigned int rootd ) 
{ 
  Pixmap pmap ;
  GC gc ;
  int sx ;
  int sy ;
  int nx ;
  int ny ;
  unsigned int nw ;
  unsigned int nh ;
  XImage *image ;
  XGCValues values ;
  int i ;

  {
  {
#line 207
  sx = r->szHint.x;
#line 207
  sy = r->szHint.y;
#line 207
  nx = 0;
#line 207
  ny = 0;
#line 211
  nw = (unsigned int )r->szHint.width;
#line 211
  nh = (unsigned int )r->szHint.height;
#line 221
  pmap = XCreatePixmap(r->Xdisplay, r->TermWin.parent, (unsigned int )r->szHint.width,
                       (unsigned int )r->szHint.height, rootd);
  }
#line 223
  if (0UL == pmap) {
#line 224
    return (0);
  }
  {
#line 226
  gc = XCreateGC(r->Xdisplay, r->TermWin.parent, 0UL, (XGCValues *)((void *)0));
  }
#line 228
  if (sx < 0) {
#line 230
    nw += (unsigned int )sx;
#line 231
    nx = - sx;
#line 232
    sx = 0;
  }
#line 234
  if (sy < 0) {
#line 236
    nh += (unsigned int )sy;
#line 237
    ny = - sy;
#line 238
    sy = 0;
  }
#line 240
  if (rootw - (unsigned int )sx < nw) {
#line 240
    nw = rootw - (unsigned int )sx;
  }
#line 241
  if (rooth - (unsigned int )sy < nh) {
#line 241
    nh = rooth - (unsigned int )sy;
  }
#line 280
  if ((r->h)->rpWidth < rootw) {
#line 280
    goto _L;
  } else
#line 280
  if ((r->h)->rpHeight < rooth) {
    _L: /* CIL Label */ 
    {
#line 288
    values.ts_x_origin = - sx;
#line 289
    values.ts_y_origin = - sy;
#line 290
    values.fill_style = 1;
#line 291
    values.tile = (r->h)->rootPixmap;
#line 293
    XChangeGC(r->Xdisplay, gc, (unsigned long )((((1L << 8) | (1L << 12)) | (1L << 13)) | (1L << 10)),
              & values);
#line 297
    XFillRectangle(r->Xdisplay, pmap, gc, 0, 0, nw, nh);
#line 299
    image = XGetImage(r->Xdisplay, pmap, 0, 0, nw, nh, (unsigned long )(~ 0L), 2);
    }
  } else {
    {
#line 303
    image = XGetImage(r->Xdisplay, (r->h)->rootPixmap, sx, sy, nw, nh, (unsigned long )(~ 0L),
                      2);
    }
  }
#line 306
  if ((unsigned long )image != (unsigned long )((void *)0)) {
    {
#line 312
    shade_ximage(r, image);
#line 313
    XPutImage(r->Xdisplay, pmap, gc, image, 0, 0, nx, ny, nw, nh);
#line 317
    (*(image->f.destroy_image))(image);
    }
  } else
#line 319
  if ((r->h)->xerror_return == 0) {
#line 326
    (r->h)->xerror_return = 255;
  }
#line 336
  if ((r->h)->xerror_return == 0) {
    {
#line 338
    XSetWindowBackgroundPixmap(r->Xdisplay, r->TermWin.parent, pmap);
    }
#line 344
    if (! (r->h)->am_transparent) {
#line 344
      if (! (r->h)->am_pixmap_trans) {
#line 347
        i = 0;
        {
#line 347
        while (1) {
          while_continue: /* CIL Label */ ;
#line 347
          if (! (i <= (int )r->tabBar.ltab)) {
#line 347
            goto while_break;
          }
          {
#line 349
          XSetWindowBackgroundPixmap(r->Xdisplay, (r->vts[i])->vt, (Pixmap )1L);
#line 347
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 356
  XFreeGC(r->Xdisplay, gc);
#line 357
  XFreePixmap(r->Xdisplay, pmap);
  }
#line 359
  return ((r->h)->xerror_return == 0);
}
}
#line 364 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
void rxvt_toggle_transparency(rxvt_t *r ) 
{ 
  register int i ;
  unsigned long tmp ;

  {
#line 370
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
    {
#line 373
    r->Options[(1UL << 16) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 16) & 3UL] & ~ ((1UL << 16) & 0xfffffffffffffffcUL));
#line 374
    (r->h)->am_transparent = (unsigned char)0;
#line 375
    (r->h)->am_pixmap_trans = (unsigned char)0;
#line 376
    (r->h)->bgGrabbed = 0;
#line 378
    XSetWindowBackground(r->Xdisplay, r->TermWin.parent, r->profile[0].bg);
#line 380
    i = 0;
    }
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (i <= (int )r->tabBar.ltab)) {
#line 380
        goto while_break;
      }
#line 388
      if (i == (int )r->tabBar.atab) {
        {
#line 391
        r->fgbg_tabnum = -1;
#line 392
        rxvt_set_vt_colors(r, (int )r->tabBar.atab);
        }
      }
#line 380
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 397
    if (0UL != r->scrollBar.win) {
#line 397
      if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
        {
#line 407
        tmp = rxvt_scrollbar_bg(r);
#line 407
        XSetWindowBackground(r->Xdisplay, r->scrollBar.win, tmp);
#line 411
        XClearWindow(r->Xdisplay, r->scrollBar.win);
        }
      }
    }
#line 429
    if ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL)) {
      {
#line 448
      XSetWindowBackground(r->Xdisplay, r->tabBar.win, r->tabBar.ibg);
      }
    }
  } else {
    {
#line 454
    r->Options[(1UL << 16) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 16) & 3UL] | ((1UL << 16) & 0xfffffffffffffffcUL));
#line 455
    XSetWindowBackgroundPixmap(r->Xdisplay, r->TermWin.parent, (Pixmap )1L);
#line 457
    i = 0;
    }
    {
#line 457
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 457
      if (! (i <= (int )r->tabBar.ltab)) {
#line 457
        goto while_break___0;
      }
      {
#line 459
      XSetWindowBackgroundPixmap(r->Xdisplay, (r->vts[i])->vt, (Pixmap )1L);
#line 457
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 463
    if (0UL != r->scrollBar.win) {
#line 463
      if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
        {
#line 465
        XSetWindowBackgroundPixmap(r->Xdisplay, r->scrollBar.win, (Pixmap )1L);
        }
      }
    }
#line 474
    if ((unsigned long )r->Options[(1UL << 26) & 3UL] & ((1UL << 26) & 0xfffffffffffffffcUL)) {
      {
#line 475
      XSetWindowBackgroundPixmap(r->Xdisplay, r->tabBar.win, (Pixmap )1L);
      }
    }
    {
#line 478
    XSelectInput(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                 1L << 22);
#line 479
    rxvt_check_our_parents(r);
    }
  }
  {
#line 483
  XClearWindow(r->Xdisplay, r->TermWin.parent);
#line 485
  rxvt_scrollbar_update(r, 0);
#line 490
  rxvt_tabbar_expose(r, (XEvent *)((void *)0));
#line 492
  rxvt_scr_clear(r, (int )r->tabBar.atab);
#line 493
  rxvt_scr_touch(r, (int )r->tabBar.atab, 1);
  }
#line 494
  return;
}
}
#line 503 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
void refreshRootBGVars(rxvt_t *r ) 
{ 
  unsigned long nitems ;
  unsigned long bytes_after ;
  Atom atype ;
  int aformat ;
  unsigned char *prop ;
  int u_rootx ;
  int u_rooty ;
  unsigned int u_bw ;
  unsigned int u_depth ;
  Window u_cr ;
  int tmp ;

  {
#line 509
  prop = (unsigned char *)((void *)0);
#line 511
  (r->h)->allowedxerror = (unsigned char)1;
#line 512
  (r->h)->xerror_return = 0;
#line 515
  if (0UL != (r->h)->xa[17]) {
    {
#line 515
    tmp = XGetWindowProperty(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                             (r->h)->xa[17], 0L, 1L, 0, (Atom )20, & atype, & aformat,
                             & nitems, & bytes_after, & prop);
    }
#line 515
    if (tmp == 0) {
#line 515
      if ((unsigned long )prop != (unsigned long )((void *)0)) {
        {
#line 527
        (r->h)->rootPixmap = *((Pixmap *)prop);
#line 528
        (r->h)->bgGrabbed = 0;
#line 530
        XFree((void *)prop);
#line 533
        XGetGeometry(r->Xdisplay, (r->h)->rootPixmap, & u_cr, & u_rootx, & u_rooty,
                     & (r->h)->rpWidth, & (r->h)->rpHeight, & u_bw, & u_depth);
        }
      } else {
#line 539
        (r->h)->rootPixmap = (Pixmap )0L;
      }
    } else {
#line 539
      (r->h)->rootPixmap = (Pixmap )0L;
    }
  } else {
#line 539
    (r->h)->rootPixmap = (Pixmap )0L;
  }
#line 541
  (r->h)->allowedxerror = (unsigned char)0;
#line 542
  if ((r->h)->xerror_return != 0) {
#line 543
    (r->h)->rootPixmap = (Pixmap )0L;
  }
#line 546
  return;
}
}
#line 554 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
int rxvt_check_our_parents(rxvt_t *r ) 
{ 
  int have_changed ;
  int rootdepth ;
  XWindowAttributes wattr ;
  XWindowAttributes wrootattr ;
  Window u_cr ;
  int tmp ;
  int retvt ;
  Window root ;
  Window oldp ;
  Window *list ;
  unsigned int i ;
  unsigned int n ;

  {
#line 557
  have_changed = 0;
#line 566
  if (! ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL))) {
#line 567
    return (have_changed);
  }
  {
#line 574
  XGetWindowAttributes(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                       & wrootattr);
#line 575
  rootdepth = wrootattr.depth;
#line 576
  XGetWindowAttributes(r->Xdisplay, r->TermWin.parent, & wattr);
  }
#line 578
  if (rootdepth != wattr.depth) {
    {
#line 586
    rxvt_msg((uint32_t )1, (uint32_t )4096, "Root window has different depth. Disabling transparency");
#line 589
    (r->h)->am_pixmap_trans = (unsigned char)0;
#line 590
    r->Options[((1UL << 17) | (1UL << 16)) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 17) | (1UL << 16)) & 3UL] & ~ (((1UL << 17) | (1UL << 16)) & 0xfffffffffffffffcUL));
#line 591
    tmp = tempDisableTransparent(r);
    }
#line 591
    return (tmp);
  }
  {
#line 599
  XTranslateCoordinates(r->Xdisplay, r->TermWin.parent, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                        0, 0, & r->szHint.x, & r->szHint.y, & u_cr);
  }
#line 605
  if (r->szHint.x + r->szHint.width <= 0) {
#line 610
    return (0);
  } else
#line 605
  if (r->szHint.x >= wrootattr.width) {
#line 610
    return (0);
  } else
#line 605
  if (r->szHint.y + r->szHint.height <= 0) {
#line 610
    return (0);
  } else
#line 605
  if (r->szHint.y >= wrootattr.height) {
#line 610
    return (0);
  }
  {
#line 612
  XSync(r->Xdisplay, 0);
#line 614
  (r->h)->allowedxerror = (unsigned char)1;
#line 615
  (r->h)->xerror_return = 0;
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 626
    retvt = 0;
#line 628
    if (0UL == (r->h)->rootPixmap) {
      {
#line 630
      have_changed = tempDisableTransparent(r);
      }
#line 631
      goto while_break;
    }
    {
#line 634
    retvt = resetParentPixmap(r, (unsigned int )wrootattr.width, (unsigned int )wrootattr.height,
                              (unsigned int )wrootattr.depth);
    }
#line 637
    if (retvt) {
      {
#line 640
      (r->h)->bgGrabbed = 1;
#line 641
      (r->h)->prevPos.x = (short )r->szHint.x;
#line 642
      (r->h)->prevPos.y = (short )r->szHint.y;
#line 643
      (r->h)->prevPos.width = (unsigned short )r->szHint.width;
#line 644
      (r->h)->prevPos.height = (unsigned short )r->szHint.height;
#line 646
      have_changed = 1;
#line 647
      (r->h)->am_transparent = (unsigned char)1;
#line 648
      (r->h)->am_pixmap_trans = (unsigned char)0;
#line 650
      expose_transparent_subwin(r);
      }
    } else {
      {
#line 653
      have_changed = tempDisableTransparent(r);
      }
    }
#line 621
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  (r->h)->allowedxerror = (unsigned char)0;
#line 660
  if ((r->h)->xerror_return != 0) {
#line 660
    if ((r->h)->am_transparent) {
      {
#line 664
      have_changed = tempDisableTransparent(r);
      }
    }
  }
#line 672
  if (! (r->h)->am_transparent) {
#line 672
    if ((unsigned long )r->Options[(1UL << 17) & 3UL] & ((1UL << 17) & 0xfffffffffffffffcUL)) {
#line 686
      i = 1U;
      {
#line 686
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 686
        if (! (i < 6U)) {
#line 686
          goto while_break___0;
        }
        {
#line 691
        oldp = r->TermWin.parenttree[i];
#line 692
        XQueryTree(r->Xdisplay, r->TermWin.parenttree[i - 1U], & root, & r->TermWin.parenttree[i],
                   & list, & n);
#line 694
        XFree((void *)list);
        }
#line 698
        if (r->TermWin.parenttree[i] == (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root) {
#line 700
          if (0UL != oldp) {
#line 701
            have_changed = 1;
          }
#line 702
          goto while_break___0;
        }
#line 704
        if (oldp != r->TermWin.parenttree[i]) {
#line 705
          have_changed = 1;
        }
#line 686
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 708
      n = 0U;
      {
#line 712
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 712
        if (! (n < i)) {
#line 712
          goto while_break___1;
        }
        {
#line 718
        XGetWindowAttributes(r->Xdisplay, r->TermWin.parenttree[n], & wattr);
        }
#line 721
        if (wattr.depth != rootdepth) {
#line 724
          n = 7U;
#line 725
          goto while_break___1;
        } else
#line 721
        if (wattr.class == 2) {
#line 724
          n = 7U;
#line 725
          goto while_break___1;
        }
#line 712
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 729
      if (n > 6U) {
#line 735
        if ((r->h)->am_pixmap_trans) {
          {
#line 737
          (r->h)->am_pixmap_trans = (unsigned char)0;
#line 738
          (r->h)->want_full_refresh = (unsigned char)1;
#line 739
          have_changed = 1;
#line 741
          XSetWindowBackground(r->Xdisplay, r->TermWin.parent, r->profile[0].bg);
#line 744
          expose_transparent_subwin(r);
          }
        }
      } else {
#line 750
        n = 0U;
        {
#line 750
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 750
          if (! (n < i)) {
#line 750
            goto while_break___2;
          }
          {
#line 751
          XSetWindowBackgroundPixmap(r->Xdisplay, r->TermWin.parenttree[n], (Pixmap )1L);
#line 750
          n ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 754
        (r->h)->am_pixmap_trans = (unsigned char)1;
#line 755
        have_changed = 1;
#line 756
        expose_transparent_subwin(r);
        }
      }
      {
#line 762
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 762
        if (! (i < 6U)) {
#line 762
          goto while_break___3;
        }
#line 763
        r->TermWin.parenttree[i] = (Window )0L;
#line 762
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 768
  return (have_changed);
}
}
#line 777 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
void rxvt_refresh_bg_image(rxvt_t *r , int page , int imediate ) 
{ 


  {
#line 783
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 785
    if (imediate) {
      {
#line 788
      rxvt_check_our_parents(r);
#line 790
      rxvt_scr_clear(r, page);
#line 791
      rxvt_scr_touch(r, page, imediate);
      }
    } else
#line 785
    if (! (r->h)->bgRefreshInterval) {
      {
#line 788
      rxvt_check_our_parents(r);
#line 790
      rxvt_scr_clear(r, page);
#line 791
      rxvt_scr_touch(r, page, imediate);
      }
    } else {
      {
#line 797
      gettimeofday((struct timeval */* __restrict  */)(& (r->h)->lastCNotify), (__timezone_ptr_t )((void *)0));
#line 798
      (r->h)->bgGrabbed = 0;
      }
    }
  } else {
    {
#line 811
    rxvt_scr_clear(r, page);
#line 812
    rxvt_scr_touch(r, page, imediate);
    }
  }
#line 814
  return;
}
}
#line 979 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
void rxvt_shade_pixmap(rxvt_t *r , Drawable src , int sx , int sy , unsigned int nw ,
                       unsigned int nh ) 
{ 
  XImage *ximage ;
  GC gc ;
  GC tmp ;

  {
  {
#line 985
  tmp = XCreateGC(r->Xdisplay, src, 0UL, (XGCValues *)0);
#line 985
  gc = tmp;
#line 987
  ximage = XGetImage(r->Xdisplay, src, sx, sy, nw, nh, (unsigned long )(~ 0L), 2);
  }
#line 989
  if ((unsigned long )((void *)0) != (unsigned long )ximage) {
    {
#line 991
    shade_ximage(r, ximage);
#line 993
    XPutImage(r->Xdisplay, src, gc, ximage, 0, 0, sx, sy, nw, nh);
#line 994
    (*(ximage->f.destroy_image))(ximage);
    }
  }
  {
#line 997
  XFreeGC(r->Xdisplay, gc);
  }
#line 998
  return;
}
}
#line 1006 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/transparent.c"
static void shade_ximage(rxvt_t *r , XImage *srcImage ) 
{ 
  int sh_r ;
  int sh_g ;
  int sh_b ;
  uint32_t mask_r ;
  uint32_t mask_g ;
  uint32_t mask_b ;
  uint32_t *lookup ;
  uint32_t *lookup_r ;
  uint32_t *lookup_g ;
  uint32_t *lookup_b ;
  unsigned int lower_lim_r ;
  unsigned int lower_lim_g ;
  unsigned int lower_lim_b ;
  unsigned int upper_lim_r ;
  unsigned int upper_lim_g ;
  unsigned int upper_lim_b ;
  int i ;
  Visual *visual ;
  XColor color ;
  int shade ;
  int rm ;
  int gm ;
  int bm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  unsigned short *p1 ;
  unsigned short *pf ;
  unsigned short *p ;
  unsigned short *pl ;
  unsigned short *p1___0 ;
  unsigned short *pf___0 ;
  unsigned short *p___0 ;
  unsigned short *pl___0 ;
  unsigned char *p1___1 ;
  unsigned char *pf___1 ;
  unsigned char *p___1 ;
  unsigned char *pl___1 ;
  uint32_t *p1___2 ;
  uint32_t *pf___2 ;
  uint32_t *p___2 ;
  uint32_t *pl___2 ;

  {
#line 1015
  visual = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_visual;
#line 1023
  if ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 13)) {
#line 1023
    if ((r->h)->rs[305]) {
      {
#line 1025
      color.pixel = *(r->pixColorsFocus + 269);
#line 1026
      XQueryColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                  & color);
#line 1028
      shade = r->TermWin.shade;
      }
    } else {
#line 1030
      return;
    }
  } else {
#line 1030
    return;
  }
#line 1032
  rm = (int )color.red;
#line 1033
  gm = (int )color.green;
#line 1034
  bm = (int )color.blue;
#line 1037
  if (100 == shade) {
#line 1038
    return;
  }
#line 1040
  if (visual->class != 4) {
#line 1041
    return;
  } else
#line 1040
  if (srcImage->format != 2) {
#line 1041
    return;
  }
#line 1046
  mask_r = (uint32_t )visual->red_mask;
#line 1047
  mask_g = (uint32_t )visual->green_mask;
#line 1048
  mask_b = (uint32_t )visual->blue_mask;
  {
#line 1053
  if (srcImage->bits_per_pixel == 15) {
#line 1053
    goto case_15;
  }
#line 1067
  if (srcImage->bits_per_pixel == 16) {
#line 1067
    goto case_16;
  }
#line 1081
  if (srcImage->bits_per_pixel == 24) {
#line 1081
    goto case_24;
  }
#line 1095
  if (srcImage->bits_per_pixel == 32) {
#line 1095
    goto case_32;
  }
#line 1109
  goto switch_default;
  case_15: /* CIL Label */ 
#line 1054
  if (mask_r != 31744U) {
#line 1057
    return;
  } else
#line 1054
  if (mask_g != 992U) {
#line 1057
    return;
  } else
#line 1054
  if (mask_b != 31U) {
#line 1057
    return;
  }
  {
#line 1058
  tmp = rxvt_malloc(sizeof(uint32_t ) * 96UL);
#line 1058
  lookup = (uint32_t *)tmp;
#line 1059
  lookup_r = lookup;
#line 1060
  lookup_g = lookup + 32;
#line 1061
  lookup_b = (lookup + 32) + 32;
#line 1062
  sh_r = 10;
#line 1063
  sh_g = 5;
#line 1064
  sh_b = 0;
  }
#line 1065
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1068
  if (mask_r != 63488U) {
#line 1071
    return;
  } else
#line 1068
  if (mask_g != 2016U) {
#line 1071
    return;
  } else
#line 1068
  if (mask_b != 31U) {
#line 1071
    return;
  }
  {
#line 1072
  tmp___0 = rxvt_malloc(sizeof(uint32_t ) * 128UL);
#line 1072
  lookup = (uint32_t *)tmp___0;
#line 1073
  lookup_r = lookup;
#line 1074
  lookup_g = lookup + 32;
#line 1075
  lookup_b = (lookup + 32) + 64;
#line 1076
  sh_r = 11;
#line 1077
  sh_g = 5;
#line 1078
  sh_b = 0;
  }
#line 1079
  goto switch_break;
  case_24: /* CIL Label */ 
#line 1082
  if (mask_r != 16711680U) {
#line 1085
    return;
  } else
#line 1082
  if (mask_g != 65280U) {
#line 1085
    return;
  } else
#line 1082
  if (mask_b != 255U) {
#line 1085
    return;
  }
  {
#line 1086
  tmp___1 = rxvt_malloc(sizeof(uint32_t ) * 768UL);
#line 1086
  lookup = (uint32_t *)tmp___1;
#line 1087
  lookup_r = lookup;
#line 1088
  lookup_g = lookup + 256;
#line 1089
  lookup_b = (lookup + 256) + 256;
#line 1090
  sh_r = 16;
#line 1091
  sh_g = 8;
#line 1092
  sh_b = 0;
  }
#line 1093
  goto switch_break;
  case_32: /* CIL Label */ 
#line 1096
  if (mask_r != 16711680U) {
#line 1099
    return;
  } else
#line 1096
  if (mask_g != 65280U) {
#line 1099
    return;
  } else
#line 1096
  if (mask_b != 255U) {
#line 1099
    return;
  }
  {
#line 1100
  tmp___2 = rxvt_malloc(sizeof(uint32_t ) * 768UL);
#line 1100
  lookup = (uint32_t *)tmp___2;
#line 1101
  lookup_r = lookup;
#line 1102
  lookup_g = lookup + 256;
#line 1103
  lookup_b = (lookup + 256) + 256;
#line 1104
  sh_r = 16;
#line 1105
  sh_g = 8;
#line 1106
  sh_b = 0;
  }
#line 1107
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1110
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1115
  if (shade < 0) {
#line 1117
    shade = - shade;
#line 1118
    if (shade < 0) {
#line 1119
      shade = 0;
    }
#line 1120
    if (shade > 100) {
#line 1121
      shade = 100;
    }
#line 1123
    lower_lim_r = (unsigned int )(65535 - rm);
#line 1124
    lower_lim_g = (unsigned int )(65535 - gm);
#line 1125
    lower_lim_b = (unsigned int )(65535 - bm);
#line 1127
    lower_lim_r = 65535U - (lower_lim_r * (uint32_t )shade) / 100U;
#line 1128
    lower_lim_g = 65535U - (lower_lim_g * (uint32_t )shade) / 100U;
#line 1129
    lower_lim_b = 65535U - (lower_lim_b * (uint32_t )shade) / 100U;
#line 1131
    upper_lim_b = 65535U;
#line 1131
    upper_lim_g = upper_lim_b;
#line 1131
    upper_lim_r = upper_lim_g;
  } else {
#line 1135
    if (shade < 0) {
#line 1136
      shade = 0;
    }
#line 1137
    if (shade > 100) {
#line 1138
      shade = 100;
    }
#line 1140
    lower_lim_b = 0U;
#line 1140
    lower_lim_g = lower_lim_b;
#line 1140
    lower_lim_r = lower_lim_g;
#line 1142
    upper_lim_r = ((uint32_t )rm * (uint32_t )shade) / 100U;
#line 1143
    upper_lim_g = ((uint32_t )gm * (uint32_t )shade) / 100U;
#line 1144
    upper_lim_b = ((uint32_t )bm * (uint32_t )shade) / 100U;
  }
#line 1149
  if (srcImage->bits_per_pixel == 24) {
#line 1149
    if (mask_r >= 16711680U) {
#line 1153
      tmp___3 = lower_lim_r;
#line 1154
      lower_lim_r = lower_lim_b;
#line 1155
      lower_lim_b = tmp___3;
#line 1157
      tmp___3 = upper_lim_r;
#line 1158
      upper_lim_r = upper_lim_b;
#line 1159
      upper_lim_b = tmp___3;
    }
  }
#line 1163
  i = 0;
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (! ((uint32_t )i <= mask_r >> sh_r)) {
#line 1163
      goto while_break;
    }
#line 1166
    tmp___4 = (uint32_t )i * (upper_lim_r - lower_lim_r);
#line 1167
    tmp___4 += (mask_r >> sh_r) * lower_lim_r;
#line 1168
    *(lookup_r + i) = tmp___4 / 65535U << sh_r;
#line 1163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1170
  i = 0;
  {
#line 1170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1170
    if (! ((uint32_t )i <= mask_g >> sh_g)) {
#line 1170
      goto while_break___0;
    }
#line 1173
    tmp___5 = (uint32_t )i * (upper_lim_g - lower_lim_g);
#line 1174
    tmp___5 += (mask_g >> sh_g) * lower_lim_g;
#line 1175
    *(lookup_g + i) = tmp___5 / 65535U << sh_g;
#line 1170
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1177
  i = 0;
  {
#line 1177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1177
    if (! ((uint32_t )i <= mask_b >> sh_b)) {
#line 1177
      goto while_break___1;
    }
#line 1180
    tmp___6 = (uint32_t )i * (upper_lim_b - lower_lim_b);
#line 1181
    tmp___6 += (mask_b >> sh_b) * lower_lim_b;
#line 1182
    *(lookup_b + i) = tmp___6 / 65535U << sh_b;
#line 1177
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1189
  if (srcImage->bits_per_pixel == 15) {
#line 1189
    goto case_15___0;
  }
#line 1208
  if (srcImage->bits_per_pixel == 16) {
#line 1208
    goto case_16___0;
  }
#line 1227
  if (srcImage->bits_per_pixel == 24) {
#line 1227
    goto case_24___0;
  }
#line 1246
  if (srcImage->bits_per_pixel == 32) {
#line 1246
    goto case_32___0;
  }
#line 1187
  goto switch_break___0;
  case_15___0: /* CIL Label */ 
#line 1192
  p1 = (unsigned short *)srcImage->data;
#line 1193
  pf = (unsigned short *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 1194
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1194
    if (! ((unsigned long )p1 < (unsigned long )pf)) {
#line 1194
      goto while_break___2;
    }
#line 1196
    p = p1;
#line 1197
    pl = p1 + srcImage->width;
    {
#line 1198
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1198
      if (! ((unsigned long )p < (unsigned long )pl)) {
#line 1198
        goto while_break___3;
      }
#line 1200
      *p = (unsigned short )((*(lookup_r + (((int )*p & 31744) >> 10)) | *(lookup_g + (((int )*p & 992) >> 5))) | *(lookup_b + ((int )*p & 31)));
#line 1198
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1204
    p1 = (unsigned short *)((char *)p1 + srcImage->bytes_per_line);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1206
  goto switch_break___0;
  case_16___0: /* CIL Label */ 
#line 1211
  p1___0 = (unsigned short *)srcImage->data;
#line 1212
  pf___0 = (unsigned short *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 1213
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1213
    if (! ((unsigned long )p1___0 < (unsigned long )pf___0)) {
#line 1213
      goto while_break___4;
    }
#line 1215
    p___0 = p1___0;
#line 1216
    pl___0 = p1___0 + srcImage->width;
    {
#line 1217
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1217
      if (! ((unsigned long )p___0 < (unsigned long )pl___0)) {
#line 1217
        goto while_break___5;
      }
#line 1219
      *p___0 = (unsigned short )((*(lookup_r + (((int )*p___0 & 63488) >> 11)) | *(lookup_g + (((int )*p___0 & 2016) >> 5))) | *(lookup_b + ((int )*p___0 & 31)));
#line 1217
      p___0 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1223
    p1___0 = (unsigned short *)((char *)p1___0 + srcImage->bytes_per_line);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1225
  goto switch_break___0;
  case_24___0: /* CIL Label */ 
#line 1230
  p1___1 = (unsigned char *)srcImage->data;
#line 1231
  pf___1 = (unsigned char *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 1232
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1232
    if (! ((unsigned long )p1___1 < (unsigned long )pf___1)) {
#line 1232
      goto while_break___6;
    }
#line 1234
    p___1 = p1___1;
#line 1235
    pl___1 = p1___1 + srcImage->width * 3;
    {
#line 1236
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1236
      if (! ((unsigned long )p___1 < (unsigned long )pl___1)) {
#line 1236
        goto while_break___7;
      }
#line 1238
      *(p___1 + 0) = (unsigned char )*(lookup_r + (((int )*(p___1 + 0) & 16711680) >> 16));
#line 1239
      *(p___1 + 1) = (unsigned char )*(lookup_r + (((int )*(p___1 + 1) & 65280) >> 8));
#line 1240
      *(p___1 + 2) = (unsigned char )*(lookup_r + ((int )*(p___1 + 2) & 255));
#line 1236
      p___1 += 3;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1242
    p1___1 = (unsigned char *)((char *)p1___1 + srcImage->bytes_per_line);
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1244
  goto switch_break___0;
  case_32___0: /* CIL Label */ 
#line 1249
  p1___2 = (uint32_t *)srcImage->data;
#line 1250
  pf___2 = (uint32_t *)(srcImage->data + srcImage->height * srcImage->bytes_per_line);
  {
#line 1252
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1252
    if (! ((unsigned long )p1___2 < (unsigned long )pf___2)) {
#line 1252
      goto while_break___8;
    }
#line 1254
    p___2 = p1___2;
#line 1255
    pl___2 = p1___2 + srcImage->width;
    {
#line 1256
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1256
      if (! ((unsigned long )p___2 < (unsigned long )pl___2)) {
#line 1256
        goto while_break___9;
      }
#line 1258
      *p___2 = ((*(lookup_r + ((*p___2 & 16711680U) >> 16)) | *(lookup_g + ((*p___2 & 65280U) >> 8))) | *(lookup_b + (*p___2 & 255U))) | (*p___2 & 4278190080U);
#line 1256
      p___2 ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1263
    p1___2 = (uint32_t *)((char *)p1___2 + srcImage->bytes_per_line);
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1265
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1269
  rxvt_free((void *)lookup);
  }
#line 1270
  return;
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 350 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 1435 "/usr/include/X11/Xlib.h"
extern XModifierKeymap *XGetModifierMapping(Display * ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1579
extern Cursor XCreateGlyphCursor(Display * , Font  , Font  , unsigned int  , unsigned int  ,
                                 XColor const   * , XColor const   * ) ;
#line 1588
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1698
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1827
extern char *XDisplayString(Display * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2097
extern int XChangeWindowAttributes(Display * , Window  , unsigned long  , XSetWindowAttributes * ) ;
#line 2183
extern int XConnectionNumber(Display * ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2578
extern int XFreeModifiermap(XModifierKeymap * ) ;
#line 2612
extern int XGetErrorText(Display * , int  , char * , int  ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2975
extern int XQueryColors(Display * , Colormap  , XColor * , int  ) ;
#line 3166
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 3200
extern int XSetCommand(Display * , Window  , char ** , int  ) ;
#line 665 "/usr/include/X11/Xutil.h"
extern void XSetWMProperties(Display * , Window  , XTextProperty * , XTextProperty * ,
                             char ** , int  , XSizeHints * , XWMHints * , XClassHint * ) ;
#line 85 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
int rxvt_init_vars(rxvt_t *r ) ;
#line 86
void rxvt_init_secondary(rxvt_t *r ) ;
#line 88
char const   **rxvt_init_resources(rxvt_t *r , int argc , char const   * const  *argv ) ;
#line 92
void rxvt_fade_color(rxvt_t *r , XColor const   *xcol , unsigned long *pix_return ,
                     void *xft_return ) ;
#line 94
int rxvt_set_fgbg_colors(rxvt_t *r , int page ) ;
#line 96
void rxvt_copy_color(rxvt_t *r , int dst_index , int src_index ) ;
#line 97
void rxvt_set_color(rxvt_t *r , int cIndex , XColor const   *xcol ) ;
#line 98
void rxvt_init_env(rxvt_t *r ) ;
#line 99
void rxvt_init_xlocale(rxvt_t *r ) ;
#line 101
void rxvt_init_command(rxvt_t *r ) ;
#line 102
CARD32 rxvt_get_desktop(rxvt_t *r ) ;
#line 103
void rxvt_create_show_windows(rxvt_t *r , int argc , char const   * const  *argv ) ;
#line 110
void clean_sigmasks_and_fds(rxvt_t *r , int page ) ;
#line 138
void rxvt_Child_signal(int sig ) ;
#line 139
void rxvt_Exit_signal(int sig ) ;
#line 143
void rxvt_privileged_utmp(rxvt_t *r , int page , char action ) ;
#line 146
void rxvt_init_font_x11(rxvt_t *r ) ;
#line 167
rxvt_t *rxvt_get_r(void) ;
#line 214
int rxvt_get_pty(int *fd_tty , char **ttydev ) ;
#line 215
int rxvt_get_tty(char const   *ttydev ) ;
#line 216
int rxvt_control_tty(int fd_tty , char const   *ttydev ) ;
#line 337
void rxvt_scrollbar_init(rxvt_t *r ) ;
#line 338
void rxvt_scrollbar_create(rxvt_t *r ) ;
#line 466
void rxvt_session_init(rxvt_t *r ) ;
#line 48 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_xerror_handler(Display const   *display , XErrorEvent const   *event ) ;
#line 49
void rxvt_init_colors(rxvt_t *r ) ;
#line 50
void rxvt_init_win_size(rxvt_t *r ) ;
#line 51
void rxvt_color_aliases(rxvt_t *r , int idx ) ;
#line 52
void rxvt_get_ourmods(rxvt_t *r ) ;
#line 53
int rxvt_run_child(rxvt_t *r , int page , char const   **argv ) ;
#line 54
void rxvt_get_ttymode(ttymode_t *tio , int erase ) ;
#line 61 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
char const   * const  def_colorName[270]  = 
#line 61
  {      (char const   */* const  */)"Black",      (char const   */* const  */)"White",      (char const   */* const  */)"black",      (char const   */* const  */)"red3", 
        (char const   */* const  */)"green3",      (char const   */* const  */)"yellow3",      (char const   */* const  */)"blue3",      (char const   */* const  */)"magenta3", 
        (char const   */* const  */)"cyan3",      (char const   */* const  */)"grey90",      (char const   */* const  */)"grey30",      (char const   */* const  */)"red", 
        (char const   */* const  */)"green",      (char const   */* const  */)"yellow",      (char const   */* const  */)"blue",      (char const   */* const  */)"magenta", 
        (char const   */* const  */)"cyan",      (char const   */* const  */)"white",      (char const   */* const  */)"rgb:00/00/00",      (char const   */* const  */)"rgb:00/00/5f", 
        (char const   */* const  */)"rgb:00/00/87",      (char const   */* const  */)"rgb:00/00/af",      (char const   */* const  */)"rgb:00/00/d7",      (char const   */* const  */)"rgb:00/00/ff", 
        (char const   */* const  */)"rgb:00/5f/00",      (char const   */* const  */)"rgb:00/5f/5f",      (char const   */* const  */)"rgb:00/5f/87",      (char const   */* const  */)"rgb:00/5f/af", 
        (char const   */* const  */)"rgb:00/5f/d7",      (char const   */* const  */)"rgb:00/5f/ff",      (char const   */* const  */)"rgb:00/87/00",      (char const   */* const  */)"rgb:00/87/5f", 
        (char const   */* const  */)"rgb:00/87/87",      (char const   */* const  */)"rgb:00/87/af",      (char const   */* const  */)"rgb:00/87/d7",      (char const   */* const  */)"rgb:00/87/ff", 
        (char const   */* const  */)"rgb:00/af/00",      (char const   */* const  */)"rgb:00/af/5f",      (char const   */* const  */)"rgb:00/af/87",      (char const   */* const  */)"rgb:00/af/af", 
        (char const   */* const  */)"rgb:00/af/d7",      (char const   */* const  */)"rgb:00/af/ff",      (char const   */* const  */)"rgb:00/d7/00",      (char const   */* const  */)"rgb:00/d7/5f", 
        (char const   */* const  */)"rgb:00/d7/87",      (char const   */* const  */)"rgb:00/d7/af",      (char const   */* const  */)"rgb:00/d7/d7",      (char const   */* const  */)"rgb:00/d7/ff", 
        (char const   */* const  */)"rgb:00/ff/00",      (char const   */* const  */)"rgb:00/ff/5f",      (char const   */* const  */)"rgb:00/ff/87",      (char const   */* const  */)"rgb:00/ff/af", 
        (char const   */* const  */)"rgb:00/ff/d7",      (char const   */* const  */)"rgb:00/ff/ff",      (char const   */* const  */)"rgb:5f/00/00",      (char const   */* const  */)"rgb:5f/00/5f", 
        (char const   */* const  */)"rgb:5f/00/87",      (char const   */* const  */)"rgb:5f/00/af",      (char const   */* const  */)"rgb:5f/00/d7",      (char const   */* const  */)"rgb:5f/00/ff", 
        (char const   */* const  */)"rgb:5f/5f/00",      (char const   */* const  */)"rgb:5f/5f/5f",      (char const   */* const  */)"rgb:5f/5f/87",      (char const   */* const  */)"rgb:5f/5f/af", 
        (char const   */* const  */)"rgb:5f/5f/d7",      (char const   */* const  */)"rgb:5f/5f/ff",      (char const   */* const  */)"rgb:5f/87/00",      (char const   */* const  */)"rgb:5f/87/5f", 
        (char const   */* const  */)"rgb:5f/87/87",      (char const   */* const  */)"rgb:5f/87/af",      (char const   */* const  */)"rgb:5f/87/d7",      (char const   */* const  */)"rgb:5f/87/ff", 
        (char const   */* const  */)"rgb:5f/af/00",      (char const   */* const  */)"rgb:5f/af/5f",      (char const   */* const  */)"rgb:5f/af/87",      (char const   */* const  */)"rgb:5f/af/af", 
        (char const   */* const  */)"rgb:5f/af/d7",      (char const   */* const  */)"rgb:5f/af/ff",      (char const   */* const  */)"rgb:5f/d7/00",      (char const   */* const  */)"rgb:5f/d7/5f", 
        (char const   */* const  */)"rgb:5f/d7/87",      (char const   */* const  */)"rgb:5f/d7/af",      (char const   */* const  */)"rgb:5f/d7/d7",      (char const   */* const  */)"rgb:5f/d7/ff", 
        (char const   */* const  */)"rgb:5f/ff/00",      (char const   */* const  */)"rgb:5f/ff/5f",      (char const   */* const  */)"rgb:5f/ff/87",      (char const   */* const  */)"rgb:5f/ff/af", 
        (char const   */* const  */)"rgb:5f/ff/d7",      (char const   */* const  */)"rgb:5f/ff/ff",      (char const   */* const  */)"rgb:87/00/00",      (char const   */* const  */)"rgb:87/00/5f", 
        (char const   */* const  */)"rgb:87/00/87",      (char const   */* const  */)"rgb:87/00/af",      (char const   */* const  */)"rgb:87/00/d7",      (char const   */* const  */)"rgb:87/00/ff", 
        (char const   */* const  */)"rgb:87/5f/00",      (char const   */* const  */)"rgb:87/5f/5f",      (char const   */* const  */)"rgb:87/5f/87",      (char const   */* const  */)"rgb:87/5f/af", 
        (char const   */* const  */)"rgb:87/5f/d7",      (char const   */* const  */)"rgb:87/5f/ff",      (char const   */* const  */)"rgb:87/87/00",      (char const   */* const  */)"rgb:87/87/5f", 
        (char const   */* const  */)"rgb:87/87/87",      (char const   */* const  */)"rgb:87/87/af",      (char const   */* const  */)"rgb:87/87/d7",      (char const   */* const  */)"rgb:87/87/ff", 
        (char const   */* const  */)"rgb:87/af/00",      (char const   */* const  */)"rgb:87/af/5f",      (char const   */* const  */)"rgb:87/af/87",      (char const   */* const  */)"rgb:87/af/af", 
        (char const   */* const  */)"rgb:87/af/d7",      (char const   */* const  */)"rgb:87/af/ff",      (char const   */* const  */)"rgb:87/d7/00",      (char const   */* const  */)"rgb:87/d7/5f", 
        (char const   */* const  */)"rgb:87/d7/87",      (char const   */* const  */)"rgb:87/d7/af",      (char const   */* const  */)"rgb:87/d7/d7",      (char const   */* const  */)"rgb:87/d7/ff", 
        (char const   */* const  */)"rgb:87/ff/00",      (char const   */* const  */)"rgb:87/ff/5f",      (char const   */* const  */)"rgb:87/ff/87",      (char const   */* const  */)"rgb:87/ff/af", 
        (char const   */* const  */)"rgb:87/ff/d7",      (char const   */* const  */)"rgb:87/ff/ff",      (char const   */* const  */)"rgb:af/00/00",      (char const   */* const  */)"rgb:af/00/5f", 
        (char const   */* const  */)"rgb:af/00/87",      (char const   */* const  */)"rgb:af/00/af",      (char const   */* const  */)"rgb:af/00/d7",      (char const   */* const  */)"rgb:af/00/ff", 
        (char const   */* const  */)"rgb:af/5f/00",      (char const   */* const  */)"rgb:af/5f/5f",      (char const   */* const  */)"rgb:af/5f/87",      (char const   */* const  */)"rgb:af/5f/af", 
        (char const   */* const  */)"rgb:af/5f/d7",      (char const   */* const  */)"rgb:af/5f/ff",      (char const   */* const  */)"rgb:af/87/00",      (char const   */* const  */)"rgb:af/87/5f", 
        (char const   */* const  */)"rgb:af/87/87",      (char const   */* const  */)"rgb:af/87/af",      (char const   */* const  */)"rgb:af/87/d7",      (char const   */* const  */)"rgb:af/87/ff", 
        (char const   */* const  */)"rgb:af/af/00",      (char const   */* const  */)"rgb:af/af/5f",      (char const   */* const  */)"rgb:af/af/87",      (char const   */* const  */)"rgb:af/af/af", 
        (char const   */* const  */)"rgb:af/af/d7",      (char const   */* const  */)"rgb:af/af/ff",      (char const   */* const  */)"rgb:af/d7/00",      (char const   */* const  */)"rgb:af/d7/5f", 
        (char const   */* const  */)"rgb:af/d7/87",      (char const   */* const  */)"rgb:af/d7/af",      (char const   */* const  */)"rgb:af/d7/d7",      (char const   */* const  */)"rgb:af/d7/ff", 
        (char const   */* const  */)"rgb:af/ff/00",      (char const   */* const  */)"rgb:af/ff/5f",      (char const   */* const  */)"rgb:af/ff/87",      (char const   */* const  */)"rgb:af/ff/af", 
        (char const   */* const  */)"rgb:af/ff/d7",      (char const   */* const  */)"rgb:af/ff/ff",      (char const   */* const  */)"rgb:d7/00/00",      (char const   */* const  */)"rgb:d7/00/5f", 
        (char const   */* const  */)"rgb:d7/00/87",      (char const   */* const  */)"rgb:d7/00/af",      (char const   */* const  */)"rgb:d7/00/d7",      (char const   */* const  */)"rgb:d7/00/ff", 
        (char const   */* const  */)"rgb:d7/5f/00",      (char const   */* const  */)"rgb:d7/5f/5f",      (char const   */* const  */)"rgb:d7/5f/87",      (char const   */* const  */)"rgb:d7/5f/af", 
        (char const   */* const  */)"rgb:d7/5f/d7",      (char const   */* const  */)"rgb:d7/5f/ff",      (char const   */* const  */)"rgb:d7/87/00",      (char const   */* const  */)"rgb:d7/87/5f", 
        (char const   */* const  */)"rgb:d7/87/87",      (char const   */* const  */)"rgb:d7/87/af",      (char const   */* const  */)"rgb:d7/87/d7",      (char const   */* const  */)"rgb:d7/87/ff", 
        (char const   */* const  */)"rgb:d7/af/00",      (char const   */* const  */)"rgb:d7/af/5f",      (char const   */* const  */)"rgb:d7/af/87",      (char const   */* const  */)"rgb:d7/af/af", 
        (char const   */* const  */)"rgb:d7/af/d7",      (char const   */* const  */)"rgb:d7/af/ff",      (char const   */* const  */)"rgb:d7/d7/00",      (char const   */* const  */)"rgb:d7/d7/5f", 
        (char const   */* const  */)"rgb:d7/d7/87",      (char const   */* const  */)"rgb:d7/d7/af",      (char const   */* const  */)"rgb:d7/d7/d7",      (char const   */* const  */)"rgb:d7/d7/ff", 
        (char const   */* const  */)"rgb:d7/ff/00",      (char const   */* const  */)"rgb:d7/ff/5f",      (char const   */* const  */)"rgb:d7/ff/87",      (char const   */* const  */)"rgb:d7/ff/af", 
        (char const   */* const  */)"rgb:d7/ff/d7",      (char const   */* const  */)"rgb:d7/ff/ff",      (char const   */* const  */)"rgb:ff/00/00",      (char const   */* const  */)"rgb:ff/00/5f", 
        (char const   */* const  */)"rgb:ff/00/87",      (char const   */* const  */)"rgb:ff/00/af",      (char const   */* const  */)"rgb:ff/00/d7",      (char const   */* const  */)"rgb:ff/00/ff", 
        (char const   */* const  */)"rgb:ff/5f/00",      (char const   */* const  */)"rgb:ff/5f/5f",      (char const   */* const  */)"rgb:ff/5f/87",      (char const   */* const  */)"rgb:ff/5f/af", 
        (char const   */* const  */)"rgb:ff/5f/d7",      (char const   */* const  */)"rgb:ff/5f/ff",      (char const   */* const  */)"rgb:ff/87/00",      (char const   */* const  */)"rgb:ff/87/5f", 
        (char const   */* const  */)"rgb:ff/87/87",      (char const   */* const  */)"rgb:ff/87/af",      (char const   */* const  */)"rgb:ff/87/d7",      (char const   */* const  */)"rgb:ff/87/ff", 
        (char const   */* const  */)"rgb:ff/af/00",      (char const   */* const  */)"rgb:ff/af/5f",      (char const   */* const  */)"rgb:ff/af/87",      (char const   */* const  */)"rgb:ff/af/af", 
        (char const   */* const  */)"rgb:ff/af/d7",      (char const   */* const  */)"rgb:ff/af/ff",      (char const   */* const  */)"rgb:ff/d7/00",      (char const   */* const  */)"rgb:ff/d7/5f", 
        (char const   */* const  */)"rgb:ff/d7/87",      (char const   */* const  */)"rgb:ff/d7/af",      (char const   */* const  */)"rgb:ff/d7/d7",      (char const   */* const  */)"rgb:ff/d7/ff", 
        (char const   */* const  */)"rgb:ff/ff/00",      (char const   */* const  */)"rgb:ff/ff/5f",      (char const   */* const  */)"rgb:ff/ff/87",      (char const   */* const  */)"rgb:ff/ff/af", 
        (char const   */* const  */)"rgb:ff/ff/d7",      (char const   */* const  */)"rgb:ff/ff/ff",      (char const   */* const  */)"rgb:08/08/08",      (char const   */* const  */)"rgb:12/12/12", 
        (char const   */* const  */)"rgb:1c/1c/1c",      (char const   */* const  */)"rgb:26/26/26",      (char const   */* const  */)"rgb:30/30/30",      (char const   */* const  */)"rgb:3a/3a/3a", 
        (char const   */* const  */)"rgb:44/44/44",      (char const   */* const  */)"rgb:4e/4e/4e",      (char const   */* const  */)"rgb:58/58/58",      (char const   */* const  */)"rgb:62/62/62", 
        (char const   */* const  */)"rgb:6c/6c/6c",      (char const   */* const  */)"rgb:76/76/76",      (char const   */* const  */)"rgb:80/80/80",      (char const   */* const  */)"rgb:8a/8a/8a", 
        (char const   */* const  */)"rgb:94/94/94",      (char const   */* const  */)"rgb:9e/9e/9e",      (char const   */* const  */)"rgb:a8/a8/a8",      (char const   */* const  */)"rgb:b2/b2/b2", 
        (char const   */* const  */)"rgb:bc/bc/bc",      (char const   */* const  */)"rgb:c6/c6/c6",      (char const   */* const  */)"rgb:d0/d0/d0",      (char const   */* const  */)"rgb:da/da/da", 
        (char const   */* const  */)"rgb:e4/e4/e4",      (char const   */* const  */)"rgb:ee/ee/ee",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)"#B2B2B2", 
        (char const   */* const  */)"#969696",      (char const   */* const  */)"rgb:ff/ff/ff"};
#line 587 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
char const   * const  xa_names[20]  = 
#line 587
  {      (char const   */* const  */)"COMPOUND_TEXT",      (char const   */* const  */)"UTF8_STRING",      (char const   */* const  */)"TEXT",      (char const   */* const  */)"MULTIPLE", 
        (char const   */* const  */)"TARGETS",      (char const   */* const  */)"TIMESTAMP",      (char const   */* const  */)"VT_SELECTION",      (char const   */* const  */)"INCR", 
        (char const   */* const  */)"WM_DELETE_WINDOW",      (char const   */* const  */)"_NET_WM_DESKTOP",      (char const   */* const  */)"_WIN_WORKSPACE",      (char const   */* const  */)"_NET_WM_NAME", 
        (char const   */* const  */)"_NET_WM_ICON_NAME",      (char const   */* const  */)"WM_CLIENT_LEADER",      (char const   */* const  */)"_NET_WM_WINDOW_OPACITY",      (char const   */* const  */)"_NET_WM_PID", 
        (char const   */* const  */)"SM_CLIENT_ID",      (char const   */* const  */)"_XROOTPMAP_ID",      (char const   */* const  */)"_XSETROOT_ID",      (char const   */* const  */)"CLIPBOARD"};
#line 638 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_init_vars(rxvt_t *r ) 
{ 
  register int i ;
  struct rxvt_hidden *h ;
  struct rxvt_hidden *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;
  int32_t tmp___3 ;
  int tmp___4 ;
  char fifo_name[4096] ;
  __pid_t tmp___5 ;

  {
  {
#line 645
  memset((void *)r, 0, sizeof(rxvt_t ));
#line 647
  tmp___0 = rxvt_calloc((size_t )1, sizeof(struct rxvt_hidden ));
#line 647
  tmp = (struct rxvt_hidden *)tmp___0;
#line 647
  r->h = tmp;
#line 647
  h = tmp;
#line 649
  i = 0;
  }
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 649
    if (! (i < 15)) {
#line 649
      goto while_break;
    }
#line 652
    r->vterm[i].vts_idx = (short)-1;
#line 654
    r->vts[i] = (term_t *)((void *)0);
#line 649
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  r->Xdisplay = (Display *)((void *)0);
#line 661
  r->TermWin.font = (XFontStruct *)((void *)0);
#line 666
  r->TermWin.bfont = (XFontStruct *)((void *)0);
#line 686
  h->xa[0] = (Atom )0L;
#line 687
  h->xa[3] = (Atom )0L;
#line 688
  h->xa[4] = (Atom )0L;
#line 689
  h->xa[2] = (Atom )0L;
#line 690
  h->xa[5] = (Atom )0L;
#line 691
  h->xa[6] = (Atom )0L;
#line 692
  h->xa[7] = (Atom )0L;
#line 693
  h->locale = (char *)((void *)0);
#line 713
  h->buffer = (char *)((void *)0);
#line 716
  h->am_pixmap_trans = (unsigned char)0;
#line 717
  h->am_transparent = (unsigned char)0;
#line 718
  h->rootPixmap = (Pixmap )0L;
#line 719
  h->bgRefreshInterval = 100000UL;
#line 720
  h->lastCNotify.tv_sec = (__time_t )0;
#line 724
  i = 1;
  {
#line 724
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 724
    tmp___1 = i;
#line 724
    i --;
#line 724
    if (! tmp___1) {
#line 724
      goto while_break___0;
    }
#line 725
    h->timeout[i].tv_sec = (__time_t )0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 729
  h->MEvent.time = (Time )0L;
#line 730
  h->MEvent.button = 0U;
#line 731
  r->Options[0] = (uint32_t )(1UL << 10);
#line 732
  r->Options[1] = (uint32_t )(((1UL << 18) | 1UL) | ((1UL << 27) | 1UL));
#line 733
  r->Options[2] = (uint32_t )2;
#line 734
  r->Options[3] = (uint32_t )3;
#line 735
  h->want_clip_refresh = (unsigned char)0;
#line 741
  h->want_resize = (unsigned char)0;
#line 742
  h->ttygid = (gid_t )-1;
#line 743
  r->Xfd = -1;
#line 745
  r->fifo_fd = -1;
#line 747
  r->ndead_childs = (short)0;
#line 749
  r->nAsyncChilds = (short)0;
#line 756
  r->TermWin.int_bwidth = (uint16_t )0;
#line 757
  r->TermWin.ext_bwidth = (uint16_t )0;
#line 761
  r->TermWin.lineSpace = (uint16_t )0;
#line 765
  (r->h)->blinkInterval = 500L;
#line 768
  (r->h)->pointerBlankDelay = 2;
#line 773
  r->selection_style = (sstyle_t )2;
#line 777
  r->selection.vt = (short)-1;
#line 778
  r->selection.op = (enum __anonenum_op_361 )0;
#line 779
  r->selection.screen = (short)0;
#line 780
  r->selection.clicks = (short)0;
#line 781
  r->selection.text = (unsigned char *)((void *)0);
#line 782
  r->selection.len = (uint32_t )0;
#line 783
  r->selection.beg.row = 0;
#line 784
  r->selection.beg.col = 0;
#line 785
  r->selection.end.row = 0;
#line 786
  r->selection.end.col = 0;
#line 789
  h->colorfgbg = (unsigned long )(1 << 9);
#line 794
  h->refresh_type = (unsigned char )(1 << 1);
#line 795
  h->refreshRegion = (Region )0L;
#line 796
  tmp___2 = (uint16_t )0;
#line 796
  h->prev_ncol = tmp___2;
#line 796
  h->prev_nrow = tmp___2;
#line 798
  r->encoding_method = (enum enc_label )0;
#line 799
  h->multichar_decode = & rxvt_decode_dummy;
#line 801
  tmp___3 = -1;
#line 801
  h->oldcursor.col = tmp___3;
#line 801
  h->oldcursor.row = tmp___3;
#line 802
  tmp___4 = -1;
#line 802
  h->last_state = tmp___4;
#line 802
  h->last_bot = tmp___4;
#line 805
  r->TermWin.sm_conn = (SmcConn )((void *)0);
#line 806
  r->TermWin.ice_conn = (IceConn )((void *)0);
#line 807
  r->TermWin.ice_fd = -1;
#line 808
  r->TermWin.sm_client_id = (char *)((void *)0);
#line 815
  tmp___5 = getpid();
#line 815
  sprintf((char */* __restrict  */)(fifo_name), (char const   */* __restrict  */)"/tmp/.mrxvt-%d",
          tmp___5);
#line 816
  r->fbuf_ptr = r->fifo_buf;
#line 817
  r->fifo_name = strdup((char const   *)(fifo_name));
#line 821
  r->tabClicked = (short)-1;
#line 823
  h->allowedxerror = (unsigned char)0;
#line 824
  h->xerror_return = 0;
  }
#line 825
  return (0);
}
}
#line 830 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_secondary(rxvt_t *r ) 
{ 
  int i ;
  int num_fds ;
  struct group *gr ;
  struct group *tmp ;
  long tmp___0 ;

  {
  {
#line 835
  tmp = getgrnam("tty");
#line 835
  gr = tmp;
  }
#line 837
  if (gr) {
#line 839
    (r->h)->ttygid = gr->gr_gid;
  } else {
    {
#line 844
    (r->h)->ttygid = getgid();
    }
  }
  {
#line 847
  rxvt_set_default_locale(r);
#line 851
  tmp___0 = sysconf(4);
#line 851
  num_fds = (int )tmp___0;
#line 860
  i = open("/dev/null", 0);
  }
#line 860
  if (i < 0) {
    {
#line 863
    dup2(2, 0);
    }
  } else
#line 865
  if (i > 0) {
    {
#line 867
    dup2(i, 0);
#line 868
    close(i);
    }
  }
  {
#line 870
  dup2(2, 1);
#line 871
  i = 3;
  }
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < num_fds)) {
#line 871
      goto while_break;
    }
    {
#line 879
    close(i);
#line 871
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  r->num_fds = 3;
#line 887
  return;
}
}
#line 891 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_xerror_handler(Display const   *display , XErrorEvent const   *event ) 
{ 
  rxvt_t *r ;
  rxvt_t *tmp ;
  char error_msg[1024] ;

  {
  {
#line 894
  tmp = rxvt_get_r();
#line 894
  r = tmp;
#line 897
  XGetErrorText(r->Xdisplay, (int )event->error_code, error_msg, 1023);
#line 898
  (r->h)->xerror_return = (int )event->error_code;
  }
#line 900
  if (! (r->h)->allowedxerror) {
    {
#line 902
    rxvt_msg((uint32_t )1, (uint32_t )8, "%s", error_msg);
    }
  }
#line 909
  return (0);
}
}
#line 966 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_set_jumpscroll(rxvt_t *r ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 969
  if ((r->h)->rs[304]) {
    {
#line 971
    tmp = atol((r->h)->rs[304]);
#line 971
    (r->h)->refresh_limit = (int )tmp;
    }
#line 972
    if ((r->h)->refresh_limit < 0) {
#line 973
      (r->h)->refresh_limit = 0;
    }
  } else {
#line 976
    (r->h)->refresh_limit = 0;
  }
#line 978
  if ((r->h)->rs[303]) {
    {
#line 980
    tmp___0 = atol((r->h)->rs[303]);
#line 980
    (r->h)->skip_pages = (int )tmp___0;
    }
#line 981
    if ((r->h)->skip_pages <= 0) {
#line 982
      (r->h)->skip_pages = 1;
    }
  } else {
#line 985
    (r->h)->skip_pages = 25;
  }
#line 986
  return;
}
}
#line 990 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
char const   **rxvt_init_resources(rxvt_t *r , int argc , char const   * const  *argv ) 
{ 
  register int i ;
  register int r_argc ;
  char const   **cmd_argv___0 ;
  char const   **r_argv ;
  char const   **rs ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  register int tmp___6 ;
  int tmp___7 ;
  register int n ;
  int tmp___8 ;
  register int tmp___9 ;
  int tmp___10 ;
  register int tmp___11 ;
  int tmp___12 ;
  register int tmp___13 ;
  int tmp___14 ;
  register int tmp___15 ;
  int tmp___16 ;
  register int tmp___17 ;
  int tmp___18 ;
  register int tmp___19 ;
  int tmp___20 ;
  register int shade ;
  register unsigned long interval ;
  long tmp___21 ;
  register int fade ;
  register long tmp___22 ;
  long tmp___23 ;
  char *val ;
  void *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  char *val___0 ;
  char *tmp___27 ;
  char *val___1 ;
  char *tmp___28 ;
  int tmp___29 ;
  char const   *swapittmp ;
  int vtfg ;
  int vtbg ;
  char const   *swapittmp___0 ;
  int tmp___30 ;
  int tmp___31 ;
  char const   *s ;
  unsigned long tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  unsigned long tmp___36 ;

  {
#line 1002
  r_argc = 0;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! (r_argc < argc)) {
#line 1002
      goto while_break;
    }
    {
#line 1003
    tmp = strcmp((char const   *)*(argv + r_argc), "-e");
    }
#line 1003
    if (tmp) {
      {
#line 1003
      tmp___0 = strcmp((char const   *)*(argv + r_argc), "-exec");
      }
#line 1003
      if (! tmp___0) {
#line 1004
        goto while_break;
      }
    } else {
#line 1004
      goto while_break;
    }
#line 1002
    r_argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1006
  tmp___1 = rxvt_malloc(sizeof(char *) * (unsigned long )(r_argc + 1));
#line 1006
  r_argv = (char const   **)tmp___1;
#line 1008
  i = 0;
  }
  {
#line 1008
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1008
    if (! (i < r_argc)) {
#line 1008
      goto while_break___0;
    }
#line 1009
    *(r_argv + i) = (char const   *)*(argv + i);
#line 1008
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1010
  *(r_argv + i) = (char const   *)((void *)0);
#line 1012
  if (r_argc == argc) {
#line 1013
    cmd_argv___0 = (char const   **)((void *)0);
  } else {
    {
#line 1016
    tmp___2 = rxvt_malloc(sizeof(char *) * (unsigned long )(argc - r_argc));
#line 1016
    cmd_argv___0 = (char const   **)tmp___2;
#line 1018
    i = 0;
    }
    {
#line 1018
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1018
      if (! (i < (argc - r_argc) - 1)) {
#line 1018
        goto while_break___1;
      }
#line 1019
      *(cmd_argv___0 + i) = (char const   *)*(argv + ((i + r_argc) + 1));
#line 1018
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1020
    *(cmd_argv___0 + i) = (char const   *)((void *)0);
  }
#line 1024
  rs = (r->h)->rs;
#line 1025
  i = 0;
  {
#line 1025
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1025
    if (! (i < 389)) {
#line 1025
      goto while_break___2;
    }
#line 1026
    tmp___3 = i;
#line 1026
    i ++;
#line 1026
    *(rs + tmp___3) = (char const   *)((void *)0);
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1028
  tmp___4 = rxvt_r_basename((char const   *)*(argv + 0));
#line 1028
  *(rs + 286) = (char const   *)tmp___4;
#line 1033
  rxvt_get_options(r, r_argc, (char const   * const  *)r_argv);
#line 1034
  rxvt_free((void *)r_argv);
#line 1058
  rxvt_msg((uint32_t )3, (uint32_t )8, "Open X display %s\n", *(rs + 0));
#line 1059
  r->Xdisplay = XOpenDisplay(*(rs + 0));
  }
#line 1060
  if ((unsigned long )((void *)0) == (unsigned long )r->Xdisplay) {
    {
#line 1062
    rxvt_msg((uint32_t )1, (uint32_t )8, "Error opening display %s\n", *(rs + 0));
#line 1064
    exit(1);
    }
  }
  {
#line 1081
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))(& rxvt_xerror_handler));
#line 1084
  i = 0;
  }
  {
#line 1084
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1084
    if (! (i < 20)) {
#line 1084
      goto while_break___3;
    }
    {
#line 1085
    (r->h)->xa[i] = XInternAtom(r->Xdisplay, (char const   *)xa_names[i], 0);
#line 1084
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1087
  rxvt_extract_resources(r, r->Xdisplay, *(rs + 286));
  }
#line 1092
  if (cmd_argv___0) {
#line 1092
    if (*(cmd_argv___0 + 0)) {
#line 1094
      if (! *(rs + 287)) {
        {
#line 1095
        tmp___5 = rxvt_r_basename(*(cmd_argv___0 + 0));
#line 1095
        *(rs + 287) = (char const   *)tmp___5;
        }
      }
#line 1096
      if (! *(rs + 5)) {
#line 1097
        *(rs + 5) = *(rs + 287);
      }
    } else {
#line 1092
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1101
    if (! *(rs + 287)) {
#line 1102
      *(rs + 287) = *(rs + 286);
    }
#line 1103
    if (! *(rs + 5)) {
#line 1104
      *(rs + 5) = *(rs + 286);
    }
  }
#line 1107
  if (*(rs + 288)) {
    {
#line 1109
    tmp___7 = atoi(*(rs + 288));
#line 1109
    tmp___6 = tmp___7;
    }
#line 1110
    if (tmp___6 >= 1) {
#line 1110
      if (tmp___6 <= 40) {
#line 1110
        r->TermWin.maxTabWidth = (uint16_t )tmp___6;
      } else {
#line 1110
        r->TermWin.maxTabWidth = (uint16_t )40;
      }
    } else {
#line 1110
      r->TermWin.maxTabWidth = (uint16_t )40;
    }
  } else {
#line 1118
    r->TermWin.maxTabWidth = (uint16_t )27;
  }
#line 1125
  if (*(rs + 289)) {
    {
#line 1127
    tmp___8 = atoi(*(rs + 289));
#line 1127
    n = tmp___8;
    }
#line 1128
    if (n >= 2) {
#line 1128
      if (n <= 15) {
#line 1128
        r->TermWin.minVisibleTabs = (uint16_t )n;
      } else {
#line 1128
        r->TermWin.minVisibleTabs = (uint16_t )6;
      }
    } else {
#line 1128
      r->TermWin.minVisibleTabs = (uint16_t )6;
    }
  } else {
#line 1131
    r->TermWin.minVisibleTabs = (uint16_t )6;
  }
#line 1134
  if (*(rs + 321)) {
    {
#line 1136
    tmp___10 = atoi(*(rs + 321));
#line 1136
    tmp___9 = tmp___10;
    }
#line 1137
    if (tmp___9 >= 0) {
#line 1137
      if (tmp___9 <= 20) {
#line 1137
        r->TermWin.int_bwidth = (uint16_t )tmp___9;
      } else {
#line 1137
        r->TermWin.int_bwidth = (uint16_t )0;
      }
    } else {
#line 1137
      r->TermWin.int_bwidth = (uint16_t )0;
    }
  }
#line 1141
  if (*(rs + 320)) {
    {
#line 1143
    tmp___12 = atoi(*(rs + 320));
#line 1143
    tmp___11 = tmp___12;
    }
#line 1144
    if (tmp___11 >= 0) {
#line 1144
      if (tmp___11 <= 20) {
#line 1144
        r->TermWin.ext_bwidth = (uint16_t )tmp___11;
      } else {
#line 1144
        r->TermWin.ext_bwidth = (uint16_t )0;
      }
    } else {
#line 1144
      r->TermWin.ext_bwidth = (uint16_t )0;
    }
  }
#line 1150
  if (*(rs + 323)) {
    {
#line 1152
    tmp___14 = atoi(*(rs + 323));
#line 1152
    tmp___13 = tmp___14;
    }
#line 1153
    if (tmp___13 >= 0) {
#line 1153
      if (tmp___13 <= 20) {
#line 1153
        r->TermWin.lineSpace = (uint16_t )tmp___13;
      } else {
#line 1153
        r->TermWin.lineSpace = (uint16_t )0;
      }
    } else {
#line 1153
      r->TermWin.lineSpace = (uint16_t )0;
    }
  }
#line 1159
  if (*(rs + 330)) {
    {
#line 1161
    tmp___16 = atoi(*(rs + 330));
#line 1161
    tmp___15 = tmp___16;
    }
#line 1162
    if (tmp___15 >= 0) {
#line 1162
      if (tmp___15 <= 20) {
#line 1162
        (r->h)->pointerBlankDelay = tmp___15;
      } else {
#line 1162
        (r->h)->pointerBlankDelay = 2;
      }
    } else {
#line 1162
      (r->h)->pointerBlankDelay = 2;
    }
  }
#line 1168
  if (*(rs + 318)) {
    {
#line 1170
    tmp___18 = atoi(*(rs + 318));
#line 1170
    tmp___17 = tmp___18;
    }
#line 1171
    if (tmp___17 >= 0) {
#line 1171
      if (tmp___17 <= 100) {
#line 1171
        r->TermWin.opacity = 100 - tmp___17;
      } else {
#line 1171
        r->TermWin.opacity = 0;
      }
    } else {
#line 1171
      r->TermWin.opacity = 0;
    }
#line 1174
    if (0UL != (r->h)->xa[14]) {
#line 1174
      if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 1180
        r->Options[(1UL << 16) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 16) & 3UL] & ~ ((1UL << 16) & 0xfffffffffffffffcUL));
      }
    }
  }
#line 1184
  if (*(rs + 319)) {
    {
#line 1186
    tmp___20 = atoi(*(rs + 319));
#line 1186
    tmp___19 = tmp___20;
    }
#line 1187
    if (tmp___19 > 0) {
#line 1187
      if (tmp___19 <= 100) {
#line 1187
        r->TermWin.opacity_degree = tmp___19;
      } else {
#line 1187
        r->TermWin.opacity_degree = 1;
      }
    } else {
#line 1187
      r->TermWin.opacity_degree = 1;
    }
  }
#line 1191
  if (*(rs + 305)) {
    {
#line 1194
    shade = atoi(*(rs + 305));
    }
#line 1195
    if (shade < 0) {
#line 1196
      shade = 100;
    } else
#line 1195
    if (shade > 100) {
#line 1196
      shade = 100;
    }
#line 1197
    r->TermWin.shade = 100 - shade;
  }
  {
#line 1201
  rxvt_set_jumpscroll(r);
  }
#line 1204
  if (*(rs + 307)) {
    {
#line 1206
    tmp___21 = atol(*(rs + 307));
#line 1206
    interval = (unsigned long )tmp___21;
    }
#line 1208
    if (interval > 1000UL) {
#line 1208
      interval = 1000UL;
    }
#line 1209
    (r->h)->bgRefreshInterval = interval * 1000UL;
  }
#line 1213
  if (*(rs + 302)) {
    {
#line 1216
    fade = atoi(*(rs + 302));
    }
#line 1222
    if (fade <= 0) {
#line 1223
      fade = 100;
    } else
#line 1222
    if (fade > 100) {
#line 1223
      fade = 100;
    }
#line 1224
    r->TermWin.fade = 100 - fade;
  }
#line 1229
  if (*(rs + 329)) {
    {
#line 1231
    tmp___23 = atol(*(rs + 329));
#line 1231
    tmp___22 = tmp___23;
    }
#line 1232
    if (tmp___22 >= 100L) {
#line 1232
      if (tmp___22 <= 5000L) {
#line 1232
        (r->h)->blinkInterval = tmp___22;
      } else {
#line 1232
        (r->h)->blinkInterval = 500L;
      }
    } else {
#line 1232
      (r->h)->blinkInterval = 500L;
    }
  }
#line 1235
  (r->h)->blinkInterval *= 1000L;
#line 1239
  if (! *(rs + 317)) {
#line 1240
    *(rs + 317) = "lpr";
  }
#line 1242
  if (! *(rs + 324)) {
#line 1243
    *(rs + 324) = "\"&\'()*,;<=>?@[\\]^`{|}~";
  }
#line 1246
  if (! *(rs + 325)) {
#line 1247
    *(rs + 325) = ".#    o+  ----+---__++--|<> =#. ";
  }
  {
#line 1248
  tmp___26 = strlen(*(rs + 325));
#line 1248
  i = (int )tmp___26;
  }
#line 1248
  if (i < 32) {
    {
#line 1250
    tmp___24 = rxvt_realloc((void *)*(rs + 325), (size_t )32);
#line 1250
    val = (char *)tmp___24;
    }
    {
#line 1251
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1251
      if (! (i < 32)) {
#line 1251
        goto while_break___4;
      }
#line 1252
      tmp___25 = i;
#line 1252
      i ++;
#line 1252
      *(val + tmp___25) = (char )' ';
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1253
    *(rs + 325) = (char const   *)val;
  }
#line 1258
  if (! *(rs + 314)) {
#line 1262
    (r->h)->key_backspace = "DEC";
  } else {
    {
#line 1266
    tmp___27 = strdup(*(rs + 314));
#line 1266
    val___0 = tmp___27;
#line 1267
    rxvt_str_trim(val___0);
#line 1268
    rxvt_str_escaped(val___0);
#line 1269
    (r->h)->key_backspace = (char const   *)val___0;
    }
  }
#line 1273
  if (! *(rs + 315)) {
#line 1277
    (r->h)->key_delete = "\033[3~";
  } else {
    {
#line 1281
    tmp___28 = strdup(*(rs + 315));
#line 1281
    val___1 = tmp___28;
#line 1282
    rxvt_str_trim(val___1);
#line 1283
    rxvt_str_escaped(val___1);
#line 1284
    (r->h)->key_delete = (char const   *)val___1;
    }
  }
#line 1287
  if (*(rs + 328)) {
    {
#line 1289
    rxvt_str_trim((char *)*(rs + 328));
#line 1290
    rxvt_str_escaped((char *)*(rs + 328));
    }
  }
#line 1293
  if (*(rs + 316)) {
    {
#line 1295
    tmp___29 = strncasecmp(*(rs + 316), "oldword", (size_t )7);
    }
#line 1295
    if (tmp___29 == 0) {
#line 1296
      r->selection_style = (sstyle_t )1;
    }
  }
  {
#line 1305
  rxvt_set_default_font_x11(r);
#line 1373
  i = 0;
  }
  {
#line 1373
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1373
    if (! (i < 270)) {
#line 1373
      goto while_break___5;
    }
#line 1374
    if (! *(rs + (7 + i))) {
#line 1375
      *(rs + (7 + i)) = (char const   *)def_colorName[i];
    }
#line 1373
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1379
  if ((unsigned long )r->Options[(1UL << 8) & 3UL] & ((1UL << 8) & 0xfffffffffffffffcUL)) {
#line 1381
    if (! *(rs + 7)) {
#line 1382
      *(rs + 7) = (char const   *)def_colorName[0];
    }
#line 1383
    if (! *(rs + 8)) {
#line 1384
      *(rs + 8) = (char const   *)def_colorName[1];
    }
#line 1386
    swapittmp = *(rs + 7);
#line 1386
    *(rs + 7) = *(rs + 8);
#line 1386
    *(rs + 8) = swapittmp;
#line 1388
    i = 0;
    {
#line 1388
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1388
      if (! (i < 5)) {
#line 1388
        goto while_break___6;
      }
#line 1390
      vtfg = 349 + i;
#line 1391
      vtbg = 354 + i;
#line 1392
      if (! *(rs + vtfg)) {
#line 1393
        *(rs + vtfg) = (char const   *)def_colorName[0];
      }
#line 1394
      if (! *(rs + vtbg)) {
#line 1395
        *(rs + vtbg) = (char const   *)def_colorName[1];
      }
#line 1397
      swapittmp___0 = *(rs + vtfg);
#line 1397
      *(rs + vtfg) = *(rs + vtbg);
#line 1397
      *(rs + vtbg) = swapittmp___0;
#line 1388
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1403
  rxvt_color_aliases(r, 0);
#line 1404
  rxvt_color_aliases(r, 1);
#line 1406
  rxvt_color_aliases(r, 258);
#line 1407
  rxvt_color_aliases(r, 259);
#line 1409
  rxvt_color_aliases(r, 260);
#line 1410
  rxvt_color_aliases(r, 261);
#line 1412
  rxvt_color_aliases(r, 263);
#line 1413
  rxvt_color_aliases(r, 264);
#line 1414
  rxvt_color_aliases(r, 265);
  }
#line 1422
  if ((unsigned long )r->Options[((1UL << 28) | 1UL) & 3UL] & (((1UL << 28) | 1UL) & 0xfffffffffffffffcUL)) {
#line 1423
    r->Options[((1UL << 12) | 1UL) & 3UL] = (uint32_t )((unsigned long )r->Options[((1UL << 12) | 1UL) & 3UL] | (((1UL << 12) | 1UL) & 0xfffffffffffffffcUL));
  }
  {
#line 1426
  rxvt_cleanup_macros(r);
#line 1432
  i = 0;
  }
  {
#line 1432
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1432
    if (! (i < 5)) {
#line 1432
      goto while_break___7;
    }
#line 1435
    if ((r->h)->rs[344 + i]) {
      {
#line 1437
      tmp___31 = atoi((r->h)->rs[344 + i]);
#line 1437
      tmp___30 = tmp___31;
      }
#line 1439
      if (tmp___30 >= 0) {
#line 1439
        if (tmp___30 <= 65535) {
#line 1439
          r->profile[i].saveLines = tmp___30;
        } else {
#line 1439
          r->profile[i].saveLines = 100;
        }
      } else {
#line 1439
        r->profile[i].saveLines = 100;
      }
    } else
#line 1443
    if (i > 0) {
#line 1443
      r->profile[i].saveLines = r->profile[0].saveLines;
    } else {
#line 1443
      r->profile[i].saveLines = 100;
    }
#line 1447
    if ((r->h)->rs[364 + i]) {
      {
#line 1449
      s = (r->h)->rs[364 + i];
#line 1452
      tmp___33 = strcasecmp(s, "true");
      }
#line 1452
      if (tmp___33) {
        {
#line 1452
        tmp___34 = strcasecmp(s, "yes");
        }
#line 1452
        if (tmp___34) {
          {
#line 1452
          tmp___35 = strcasecmp(s, "on");
          }
#line 1452
          if (tmp___35) {
            {
#line 1459
            tmp___32 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)((void *)0),
                               0);
#line 1459
            r->profile[i].holdOption = (unsigned char )tmp___32;
            }
          } else {
#line 1457
            r->profile[i].holdOption = (unsigned char)1;
          }
        } else {
#line 1457
          r->profile[i].holdOption = (unsigned char)1;
        }
      } else {
#line 1457
        r->profile[i].holdOption = (unsigned char)1;
      }
    } else
#line 1462
    if (i > 0) {
#line 1462
      r->profile[i].holdOption = r->profile[0].holdOption;
    } else {
#line 1462
      r->profile[i].holdOption = (unsigned char )((1U << 2) | (1U << 1));
    }
#line 1432
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1466
  if (! (r->h)->rs[374]) {
#line 1467
    (r->h)->rs[374] = "(Done) %t";
  }
#line 1469
  if (! (r->h)->rs[369]) {
#line 1470
    (r->h)->rs[369] = "\n\n\r\033[31mProcess exited %N with status %S. Press any key to close tab.\033[0m";
  }
#line 1475
  if (! (r->h)->rs[359]) {
#line 1476
    (r->h)->rs[359] = ".";
  }
#line 1480
  if ((r->h)->rs[310]) {
    {
#line 1481
    tmp___36 = strtoul((char const   */* __restrict  */)(r->h)->rs[310], (char **/* __restrict  */)((void *)0),
                       0);
#line 1481
    r->TermWin.vBellDuration = 1000000UL * tmp___36;
    }
  } else {
#line 1484
    r->TermWin.vBellDuration = 0UL;
  }
#line 1488
  return (cmd_argv___0);
}
}
#line 1493 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_env(rxvt_t *r ) 
{ 
  int i ;
  unsigned int u ;
  char *val ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int l ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 1518
  val = XDisplayString(r->Xdisplay);
  }
#line 1519
  if ((unsigned long )((void *)0) == (unsigned long )(r->h)->rs[0]) {
#line 1520
    (r->h)->rs[0] = (char const   *)val;
  }
  {
#line 1522
  tmp = strlen((char const   *)val);
#line 1522
  i = (int )(tmp + 9UL);
  }
#line 1523
  if (i <= 0) {
#line 1524
    i = 1024;
  } else
#line 1523
  if (i > 1024) {
#line 1524
    i = 1024;
  }
  {
#line 1525
  tmp___0 = rxvt_malloc((unsigned long )i * sizeof(char ));
#line 1525
  (r->h)->env_display = (char *)tmp___0;
#line 1526
  strcpy((char */* __restrict  */)(r->h)->env_display, (char const   */* __restrict  */)"DISPLAY=");
#line 1527
  strncat((char */* __restrict  */)(r->h)->env_display, (char const   */* __restrict  */)((char const   *)val),
          (size_t )(i - 9));
#line 1528
  *((r->h)->env_display + (i - 1)) = (char)0;
#line 1532
  i = 0;
#line 1532
  u = (unsigned int )r->TermWin.parent;
  }
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (! u) {
#line 1532
      goto while_break;
    }
#line 1532
    u /= 10U;
#line 1532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1534
  if (1 > i) {
#line 1534
    i = 1;
  }
  {
#line 1535
  tmp___1 = rxvt_malloc((unsigned long )(i + 10) * sizeof(char ));
#line 1535
  (r->h)->env_windowid = (char *)tmp___1;
#line 1537
  sprintf((char */* __restrict  */)(r->h)->env_windowid, (char const   */* __restrict  */)"WINDOWID=%u",
          (unsigned int )r->TermWin.parent);
#line 1549
  putenv((r->h)->env_display);
#line 1550
  putenv((r->h)->env_windowid);
  }
#line 1555
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 1556
    putenv((char *)"COLORTERM=rxvt-mono");
    }
  } else {
    {
#line 1558
    putenv((char *)"COLORTERM=rxvt");
    }
  }
#line 1559
  if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[4]) {
    {
#line 1561
    tmp___2 = strlen((r->h)->rs[4]);
#line 1561
    l = (int )(6UL + tmp___2);
    }
#line 1562
    if (l <= 0) {
#line 1563
      l = 1024;
    } else
#line 1562
    if (l > 1024) {
#line 1563
      l = 1024;
    }
    {
#line 1564
    tmp___3 = rxvt_malloc((unsigned long )l * sizeof(char ));
#line 1564
    (r->h)->env_term = (char *)tmp___3;
#line 1565
    strcpy((char */* __restrict  */)(r->h)->env_term, (char const   */* __restrict  */)"TERM=");
#line 1566
    strncat((char */* __restrict  */)(r->h)->env_term, (char const   */* __restrict  */)(r->h)->rs[4],
            (size_t )(l - 6));
#line 1567
    *((r->h)->env_term + (l - 1)) = (char)0;
#line 1568
    putenv((r->h)->env_term);
    }
  } else {
    {
#line 1571
    putenv((char *)"TERM=rxvt");
    }
  }
  {
#line 1576
  unsetenv("LINES");
#line 1577
  unsetenv("COLUMNS");
#line 1578
  unsetenv("TERMCAP");
#line 1585
  tmp___4 = rxvt_malloc((sizeof("MRXVT_TABTITLE=") + 507UL) + 1UL);
#line 1585
  (r->h)->env_tabtitle = (char *)tmp___4;
  }
#line 1586
  return;
}
}
#line 1594 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_xlocale(rxvt_t *r ) 
{ 


  {
#line 1622
  return;
}
}
#line 1628 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_fifo(rxvt_t *r ) 
{ 


  {
  {
#line 1631
  unlink((char const   *)r->fifo_name);
#line 1632
  mkfifo((char const   *)r->fifo_name, (__mode_t )384);
#line 1638
  r->fifo_fd = open((char const   *)r->fifo_name, 2048);
  }
#line 1639
  if (r->fifo_fd == -1) {
#line 1640
    r->Options[(1UL << 29) & 3UL] = (uint32_t )((unsigned long )r->Options[(1UL << 29) & 3UL] & ~ ((1UL << 29) & 0xfffffffffffffffcUL));
  } else
#line 1642
  if (r->fifo_fd + 1 > r->num_fds) {
#line 1642
    r->num_fds = r->fifo_fd + 1;
  }
#line 1645
  r->fbuf_ptr = r->fifo_buf;
#line 1646
  return;
}
}
#line 1650 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_command(rxvt_t *r ) 
{ 
  struct sigaction act ;

  {
  {
#line 1667
  XSetWMProtocols(r->Xdisplay, r->TermWin.parent, & (r->h)->xa[8], 1);
  }
#line 1671
  if ((unsigned long )r->Options[(1UL << 13) & 3UL] & ((1UL << 13) & 0xfffffffffffffffcUL)) {
#line 1671
    (r->h)->meta_char = (unsigned char)128;
  } else {
#line 1671
    (r->h)->meta_char = (unsigned char)27;
  }
  {
#line 1673
  rxvt_get_ourmods(r);
#line 1679
  r->Xfd = XConnectionNumber(r->Xdisplay);
  }
#line 1681
  if ((unsigned long )r->Options[(1UL << 29) & 3UL] & ((1UL << 29) & 0xfffffffffffffffcUL)) {
    {
#line 1682
    rxvt_init_fifo(r);
    }
  } else {
#line 1684
    r->fifo_fd = -1;
  }
#line 1688
  if ((unsigned long )r->Options[(1UL << 22) & 3UL] & ((1UL << 22) & 0xfffffffffffffffcUL)) {
    {
#line 1689
    gettimeofday((struct timeval */* __restrict  */)(& (r->h)->lastcursorchange),
                 (__timezone_ptr_t )((void *)0));
    }
  }
  {
#line 1695
  act.__sigaction_handler.sa_handler = & rxvt_Exit_signal;
#line 1696
  act.sa_flags = 0;
#line 1697
  sigemptyset(& act.sa_mask);
#line 1700
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 1702
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 1703
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 1709
  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 1710
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 1720
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 1723
  act.__sigaction_handler.sa_handler = & rxvt_Child_signal;
#line 1724
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 1725
  return;
}
}
#line 1729 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_fade_color(rxvt_t *r , XColor const   *xcol , unsigned long *pix_return ,
                     void *xft_return ) 
{ 
  XColor faded_xcol ;

  {
#line 1739
  if (r->TermWin.fade) {
    {
#line 1743
    faded_xcol.red = (unsigned short )(((int const   )xcol->red / 100) * (int const   )r->TermWin.fade);
#line 1744
    faded_xcol.green = (unsigned short )(((int const   )xcol->green / 100) * (int const   )r->TermWin.fade);
#line 1745
    faded_xcol.blue = (unsigned short )(((int const   )xcol->blue / 100) * (int const   )r->TermWin.fade);
#line 1747
    rxvt_alloc_color(r, & faded_xcol, "Faded");
#line 1749
    *pix_return = faded_xcol.pixel;
    }
  }
#line 1756
  return;
}
}
#line 1768 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_set_fgbg_colors(rxvt_t *r , int page ) 
{ 
  int changed ;
  int tmp ;

  {
#line 1771
  changed = 0;
#line 1777
  if (r->fgbg_tabnum == (r->vts[page])->globalTabNum) {
#line 1777
    if (r->TermWin.fade) {
#line 1793
      return (0);
    } else
#line 1777
    if (! ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 6))) {
#line 1793
      return (0);
    } else {
#line 1777
      if (r->TermWin.focus) {
#line 1777
        tmp = *(r->pixColors + 1) == (r->vts[page])->p_bg;
      } else {
#line 1777
        tmp = *(r->pixColors + 1) == *(r->pixColors + 262);
      }
#line 1777
      if (tmp) {
#line 1793
        return (0);
      }
    }
  }
#line 1795
  if (*(r->pixColorsFocus + 0) != (r->vts[page])->p_fg) {
#line 1795
    *(r->pixColorsFocus + 0) = (r->vts[page])->p_fg;
#line 1795
    changed = 1;
  }
#line 1801
  if (r->TermWin.fade) {
#line 1804
    if (*(r->pixColorsFocus + 1) != (r->vts[page])->p_bg) {
#line 1804
      *(r->pixColorsFocus + 1) = (r->vts[page])->p_bg;
#line 1804
      changed = 1;
    }
#line 1806
    if (*(r->pixColorsUnfocus + 0) != (r->vts[page])->p_fgfade) {
#line 1806
      *(r->pixColorsUnfocus + 0) = (r->vts[page])->p_fgfade;
#line 1806
      changed = 1;
    }
#line 1807
    if (*(r->pixColorsUnfocus + 1) != (r->vts[page])->p_bgfade) {
#line 1807
      *(r->pixColorsUnfocus + 1) = (r->vts[page])->p_bgfade;
#line 1807
      changed = 1;
    }
  } else
#line 1823
  if ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 6)) {
#line 1823
    if (! r->TermWin.focus) {
#line 1826
      if (*(r->pixColorsFocus + 1) != *(r->pixColorsFocus + 262)) {
#line 1826
        *(r->pixColorsFocus + 1) = *(r->pixColorsFocus + 262);
#line 1826
        changed = 1;
      }
    } else {
#line 1823
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1838
  if (*(r->pixColorsFocus + 1) != (r->vts[page])->p_bg) {
#line 1838
    *(r->pixColorsFocus + 1) = (r->vts[page])->p_bg;
#line 1838
    changed = 1;
  }
#line 1847
  r->fgbg_tabnum = (r->vts[page])->globalTabNum;
#line 1851
  return (changed);
}
}
#line 1857 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_copy_color(rxvt_t *r , int dst_index , int src_index ) 
{ 


  {
#line 1860
  *(r->pixColorsFocus + dst_index) = *(r->pixColorsFocus + src_index);
#line 1862
  if (r->TermWin.fade) {
#line 1863
    *(r->pixColorsUnfocus + dst_index) = *(r->pixColorsUnfocus + src_index);
  }
#line 1875
  (r->h)->pixcolor_set[dst_index / 32] |= (unsigned int )(1 << dst_index % 32);
#line 1876
  return;
}
}
#line 1879 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_set_color(rxvt_t *r , int cIndex , XColor const   *xcol ) 
{ 


  {
#line 1883
  *(r->pixColorsFocus + cIndex) = (unsigned long )xcol->pixel;
#line 1889
  if (r->TermWin.fade) {
#line 1891
    if (cIndex == 260) {
#line 1894
      *(r->pixColorsUnfocus + cIndex) = *(r->pixColorsFocus + cIndex);
    } else {
      {
#line 1902
      rxvt_fade_color(r, xcol, r->pixColorsUnfocus + cIndex, (void *)0);
      }
    }
  }
#line 1911
  (r->h)->pixcolor_set[cIndex / 32] |= (unsigned int )(1 << cIndex % 32);
#line 1912
  return;
}
}
#line 1921 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_colors(rxvt_t *r ) 
{ 
  register int i ;
  XColor xcol ;
  int vtfg ;
  int vtbg ;
  int tmp ;
  int tmp___0 ;
  XColor xcol___0 ;
  int tmp___1 ;
  int tmp___2 ;
  XColor xcol___1[3] ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1929
  i = 0;
  {
#line 1929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1929
    if (! (i < 5)) {
#line 1929
      goto while_break;
    }
#line 1932
    vtfg = 349 + i;
#line 1933
    vtbg = 354 + i;
#line 1935
    if (! ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[349 + i])) {
#line 1936
      if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[349]) {
#line 1936
        (r->h)->rs[vtfg] = (r->h)->rs[349];
      } else {
#line 1936
        (r->h)->rs[vtfg] = (char const   *)def_colorName[0];
      }
    }
#line 1938
    if (! ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[354 + i])) {
#line 1939
      if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[354]) {
#line 1939
        (r->h)->rs[vtbg] = (r->h)->rs[354];
      } else {
#line 1939
        (r->h)->rs[vtbg] = (char const   *)def_colorName[1];
      }
    }
    {
#line 1943
    tmp = rxvt_parse_alloc_color(r, & xcol, (r->h)->rs[vtfg]);
    }
#line 1943
    if (tmp) {
      {
#line 1945
      r->profile[i].fg = xcol.pixel;
#line 1951
      rxvt_fade_color(r, (XColor const   *)(& xcol), & r->profile[i].fg_fade, (void *)0);
      }
    } else {
      {
#line 1957
      rxvt_msg((uint32_t )1, (uint32_t )8, "Could not alloc foreground color of profile %d",
               i);
      }
#line 1959
      if (i == 0) {
        {
#line 1961
        exit(1);
        }
      }
#line 1964
      r->profile[i].fg = r->profile[0].fg;
#line 1965
      r->profile[i].fg_fade = r->profile[0].fg_fade;
    }
    {
#line 1974
    tmp___0 = rxvt_parse_alloc_color(r, & xcol, (r->h)->rs[vtbg]);
    }
#line 1974
    if (tmp___0) {
      {
#line 1976
      r->profile[i].bg = xcol.pixel;
#line 1982
      rxvt_fade_color(r, (XColor const   *)(& xcol), & r->profile[i].bg_fade, (void *)0);
      }
    } else {
      {
#line 1988
      rxvt_msg((uint32_t )1, (uint32_t )8, "Could not alloc background color of profile %d",
               i);
      }
#line 1990
      if (i == 0) {
        {
#line 1992
        exit(1);
        }
      }
#line 1995
      r->profile[i].bg = r->profile[0].bg;
#line 1996
      r->profile[i].bg_fade = r->profile[0].bg_fade;
    }
#line 1929
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2006
  *(r->pixColorsFocus + 0) = r->profile[0].fg;
#line 2007
  *(r->pixColorsFocus + 1) = r->profile[0].bg;
#line 2009
  if (r->TermWin.fade) {
#line 2011
    *(r->pixColorsUnfocus + 0) = r->profile[0].fg_fade;
#line 2012
    *(r->pixColorsUnfocus + 1) = r->profile[0].bg_fade;
  }
#line 2029
  r->fgbg_tabnum = -1;
#line 2036
  i = 2;
  {
#line 2036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2036
    if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
#line 2036
      tmp___2 = 2;
    } else {
#line 2036
      tmp___2 = 270;
    }
#line 2036
    if (! (i < tmp___2)) {
#line 2036
      goto while_break___0;
    }
#line 2040
    if ((unsigned long )((void *)0) == (unsigned long )(r->h)->rs[7 + i]) {
#line 2041
      goto __Cont;
    }
    {
#line 2043
    tmp___1 = rxvt_parse_alloc_color(r, & xcol___0, (r->h)->rs[7 + i]);
    }
#line 2043
    if (tmp___1) {
      {
#line 2079
      rxvt_set_color(r, i, (XColor const   *)(& xcol___0));
      }
    } else {
#line 2045
      if ((unsigned long )(r->h)->rs[7 + i] != (unsigned long )def_colorName[i]) {
        {
#line 2047
        rxvt_msg((uint32_t )1, (uint32_t )8, "Could not allocate color \'%s\'\n",
                 (r->h)->rs[7 + i]);
#line 2051
        (r->h)->rs[7 + i] = (char const   *)def_colorName[i];
#line 2052
        i --;
        }
#line 2053
        goto __Cont;
      }
      {
#line 2064
      if (i == 260) {
#line 2064
        goto case_260;
      }
#line 2064
      if (i == 259) {
#line 2064
        goto case_260;
      }
#line 2068
      goto switch_default;
      case_260: /* CIL Label */ 
      case_259: /* CIL Label */ 
      {
#line 2065
      rxvt_copy_color(r, i, 0);
      }
#line 2066
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2069
      rxvt_copy_color(r, i, 1);
      }
#line 2070
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2036
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2087
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
#line 2087
    goto _L;
  } else
#line 2087
  if (! ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 4))) {
    _L: /* CIL Label */ 
#line 2093
    *(r->pixColorsFocus + 260) = r->profile[0].fg;
#line 2094
    if (r->TermWin.fade) {
#line 2095
      *(r->pixColorsUnfocus + 260) = r->profile[0].fg;
    }
#line 2104
    (r->h)->pixcolor_set[8] |= (unsigned int )(1 << 4);
  }
#line 2107
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 2108
    rxvt_copy_color(r, 261, 0);
    }
  } else
#line 2107
  if (! ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 5))) {
    {
#line 2108
    rxvt_copy_color(r, 261, 0);
    }
  }
#line 2118
  if ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root_depth <= 2) {
    {
#line 2120
    rxvt_copy_color(r, 267, 0);
#line 2121
    rxvt_copy_color(r, 270, 1);
#line 2122
    rxvt_copy_color(r, 271, 1);
    }
  } else {
    {
#line 2134
    xcol___1[1].pixel = *(r->pixColorsFocus + 267);
#line 2140
    xcol___1[0].pixel = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->white_pixel;
#line 2141
    XQueryColors(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                 xcol___1, 2);
#line 2145
    xcol___1[2].red = (unsigned short )((int )xcol___1[1].red / 2);
#line 2146
    xcol___1[2].green = (unsigned short )((int )xcol___1[1].green / 2);
#line 2147
    xcol___1[2].blue = (unsigned short )((int )xcol___1[1].blue / 2);
#line 2148
    tmp___3 = rxvt_alloc_color(r, & xcol___1[2], "Color_bottomShadow");
    }
#line 2148
    if (tmp___3) {
      {
#line 2152
      rxvt_set_color(r, 271, (XColor const   *)(& xcol___1[2]));
      }
    } else {
      {
#line 2149
      rxvt_copy_color(r, 271, 2);
      }
    }
#line 2156
    if ((int )xcol___1[0].red / 5 > (int )xcol___1[1].red) {
#line 2156
      xcol___1[1].red = (unsigned short )((int )xcol___1[0].red / 5);
    } else {
#line 2156
      xcol___1[1].red = xcol___1[1].red;
    }
#line 2157
    if ((int )xcol___1[0].green / 5 > (int )xcol___1[1].green) {
#line 2157
      xcol___1[1].green = (unsigned short )((int )xcol___1[0].green / 5);
    } else {
#line 2157
      xcol___1[1].green = xcol___1[1].green;
    }
#line 2158
    if ((int )xcol___1[0].blue / 5 > (int )xcol___1[1].blue) {
#line 2158
      xcol___1[1].blue = (unsigned short )((int )xcol___1[0].blue / 5);
    } else {
#line 2158
      xcol___1[1].blue = xcol___1[1].blue;
    }
#line 2159
    if ((int )xcol___1[0].red < ((int )xcol___1[1].red * 7) / 5) {
#line 2159
      xcol___1[1].red = xcol___1[0].red;
    } else {
#line 2159
      xcol___1[1].red = (unsigned short )(((int )xcol___1[1].red * 7) / 5);
    }
#line 2160
    if ((int )xcol___1[0].green < ((int )xcol___1[1].green * 7) / 5) {
#line 2160
      xcol___1[1].green = xcol___1[0].green;
    } else {
#line 2160
      xcol___1[1].green = (unsigned short )(((int )xcol___1[1].green * 7) / 5);
    }
#line 2161
    if ((int )xcol___1[0].blue < ((int )xcol___1[1].blue * 7) / 5) {
#line 2161
      xcol___1[1].blue = xcol___1[0].blue;
    } else {
#line 2161
      xcol___1[1].blue = (unsigned short )(((int )xcol___1[1].blue * 7) / 5);
    }
    {
#line 2163
    tmp___4 = rxvt_alloc_color(r, & xcol___1[1], "Color_topShadow");
    }
#line 2163
    if (tmp___4) {
      {
#line 2166
      rxvt_set_color(r, 270, (XColor const   *)(& xcol___1[1]));
      }
    } else {
      {
#line 2164
      rxvt_copy_color(r, 270, 17);
      }
    }
  }
#line 2192
  return;
}
}
#line 2198 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_color_aliases(rxvt_t *r , int idx ) 
{ 
  int i ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 2201
  if ((r->h)->rs[7 + idx]) {
    {
#line 2201
    tmp___0 = __ctype_b_loc();
    }
#line 2201
    if ((int const   )*(*tmp___0 + (int )*((r->h)->rs[7 + idx])) & 2048) {
      {
#line 2203
      tmp = atoi((r->h)->rs[7 + idx]);
#line 2203
      i = tmp;
      }
#line 2205
      if (i >= 8) {
#line 2205
        if (i <= 15) {
#line 2207
          i -= 8;
#line 2209
          (r->h)->rs[7 + idx] = (r->h)->rs[17 + i];
#line 2210
          return;
        }
      }
#line 2213
      if (i >= 0) {
#line 2213
        if (i <= 7) {
#line 2214
          (r->h)->rs[7 + idx] = (r->h)->rs[9 + i];
        }
      }
    }
  }
#line 2216
  return;
}
}
#line 2220 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_win_size(rxvt_t *r ) 
{ 
  int flags ;
  short recalc_x ;
  short recalc_y ;
  short recalc_width ;
  short recalc_height ;
  int x ;
  int y ;
  unsigned int w ;
  unsigned int h ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned short tmp___5 ;

  {
  {
#line 2223
  flags = 0;
#line 2224
  recalc_x = (short)0;
#line 2224
  recalc_y = (short)0;
#line 2224
  recalc_width = (short)1;
#line 2224
  recalc_height = (short)1;
#line 2230
  r->szHint.flags = (((1L << 4) | (1L << 6)) | (1L << 8)) | (1L << 9);
#line 2231
  r->szHint.win_gravity = 1;
#line 2234
  r->TermWin.ncol = (uint16_t )80;
#line 2235
  r->TermWin.nrow = (uint16_t )24;
#line 2236
  r->szHint.x = 0;
#line 2237
  r->szHint.y = 0;
#line 2240
  refreshRootBGVars(r);
  }
#line 2244
  if ((r->h)->rs[6]) {
    {
#line 2245
    flags = XParseGeometry((r->h)->rs[6], & x, & y, & w, & h);
    }
  }
#line 2249
  if ((unsigned long )r->Options[((1UL << 26) | 1UL) & 3UL] & (((1UL << 26) | 1UL) & 0xfffffffffffffffcUL)) {
#line 2251
    r->szHint.width_inc = 1;
#line 2252
    r->szHint.height_inc = 1;
  } else {
#line 2257
    r->szHint.width_inc = (int )r->TermWin.fwidth;
#line 2258
    r->szHint.height_inc = (int )r->TermWin.fheight;
  }
#line 2262
  r->szHint.base_width = 2 * (int )r->TermWin.int_bwidth;
#line 2263
  r->szHint.base_height = 2 * (int )r->TermWin.int_bwidth;
#line 2265
  if ((unsigned long )r->Options[(1UL << 10) & 3UL] & ((1UL << 10) & 0xfffffffffffffffcUL)) {
    {
#line 2266
    tmp = rxvt_scrollbar_rwidth(r);
#line 2266
    r->szHint.base_width += (int )tmp;
    }
  }
#line 2272
  if (! ((unsigned long )r->Options[((1UL << 12) | 1UL) & 3UL] & (((1UL << 12) | 1UL) & 0xfffffffffffffffcUL))) {
    {
#line 2273
    tmp___0 = rxvt_tabbar_rheight(r);
#line 2273
    r->szHint.base_height += (int )tmp___0;
    }
  }
#line 2276
  r->szHint.min_width = r->szHint.base_width + (int )r->TermWin.fwidth;
#line 2277
  r->szHint.min_height = r->szHint.base_height + (int )r->TermWin.fheight;
#line 2280
  if (flags & 4) {
#line 2282
    if (w <= 0U) {
#line 2282
      tmp___2 = 0U;
    } else {
#line 2282
      if (w < (unsigned int )(65535 >> 1)) {
#line 2282
        tmp___1 = w;
      } else {
#line 2282
        tmp___1 = (unsigned int )(65535 >> 1);
      }
#line 2282
      tmp___2 = tmp___1;
    }
#line 2282
    r->TermWin.ncol = (uint16_t )((int16_t )tmp___2);
#line 2284
    if ((unsigned long )r->Options[((1UL << 26) | 1UL) & 3UL] & (((1UL << 26) | 1UL) & 0xfffffffffffffffcUL)) {
#line 2287
      if ((int )r->TermWin.ncol > r->szHint.base_width + (int )r->TermWin.fwidth) {
#line 2289
        r->szHint.width = (int )r->TermWin.ncol;
#line 2290
        r->TermWin.ncol = (uint16_t )(((int )r->TermWin.ncol - r->szHint.base_width) / (int )r->TermWin.fwidth);
#line 2292
        recalc_width = (short)0;
      } else {
#line 2294
        r->TermWin.ncol = (uint16_t )1;
      }
    }
#line 2297
    r->szHint.flags |= 1L << 1;
  }
#line 2299
  if (flags & 8) {
#line 2301
    if (h <= 0U) {
#line 2301
      tmp___4 = 0U;
    } else {
#line 2301
      if (h < (unsigned int )(65535 >> 1)) {
#line 2301
        tmp___3 = h;
      } else {
#line 2301
        tmp___3 = (unsigned int )(65535 >> 1);
      }
#line 2301
      tmp___4 = tmp___3;
    }
#line 2301
    r->TermWin.nrow = (uint16_t )((int16_t )tmp___4);
#line 2303
    if ((unsigned long )r->Options[((1UL << 26) | 1UL) & 3UL] & (((1UL << 26) | 1UL) & 0xfffffffffffffffcUL)) {
#line 2306
      if ((int )r->TermWin.nrow > r->szHint.base_height + (int )r->TermWin.fheight) {
#line 2308
        r->szHint.height = (int )r->TermWin.nrow;
#line 2309
        r->TermWin.nrow = (uint16_t )(((int )r->TermWin.nrow - r->szHint.base_height) / (int )r->TermWin.fheight);
#line 2311
        recalc_height = (short)0;
      } else {
#line 2313
        r->TermWin.nrow = (uint16_t )1;
      }
    }
#line 2316
    r->szHint.flags |= 1L << 1;
  }
#line 2318
  if (flags & 1) {
#line 2320
    r->szHint.x = x;
#line 2321
    r->szHint.flags |= 1L;
#line 2322
    if (flags & 16) {
#line 2324
      recalc_x = (short)1;
#line 2325
      r->szHint.win_gravity = 3;
    }
  }
#line 2328
  if (flags & 2) {
#line 2330
    r->szHint.y = y;
#line 2331
    r->szHint.flags |= 1L;
#line 2332
    if (flags & 32) {
#line 2334
      recalc_y = (short)1;
#line 2335
      if (r->szHint.win_gravity == 3) {
#line 2336
        r->szHint.win_gravity = 9;
      } else {
#line 2338
        r->szHint.win_gravity = 7;
      }
    }
  }
#line 2343
  if (recalc_width) {
#line 2344
    r->szHint.width = r->szHint.base_width + (int32_t )r->TermWin.ncol * (int32_t )r->TermWin.fwidth;
  }
#line 2345
  if (recalc_height) {
#line 2346
    r->szHint.height = r->szHint.base_height + (int32_t )r->TermWin.nrow * (int32_t )r->TermWin.fheight;
  }
#line 2349
  if (recalc_x) {
#line 2350
    r->szHint.x += ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->width - r->szHint.width) - 2 * (int )r->TermWin.ext_bwidth;
  }
#line 2352
  if (recalc_y) {
#line 2353
    r->szHint.y += ((((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->height - r->szHint.height) - 2 * (int )r->TermWin.ext_bwidth;
  }
#line 2357
  if ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL)) {
#line 2357
    (r->h)->window_vt_x = 0;
  } else {
#line 2357
    (r->h)->window_vt_x = r->szHint.base_width - 2 * (int )r->TermWin.int_bwidth;
  }
#line 2359
  (r->h)->window_vt_y = r->szHint.base_height - 2 * (int )r->TermWin.int_bwidth;
#line 2360
  if ((unsigned long )r->Options[((1UL << 13) | 1UL) & 3UL] & (((1UL << 13) | 1UL) & 0xfffffffffffffffcUL)) {
#line 2360
    if (! ((unsigned long )r->Options[((1UL << 12) | 1UL) & 3UL] & (((1UL << 12) | 1UL) & 0xfffffffffffffffcUL))) {
      {
#line 2361
      tmp___5 = rxvt_tabbar_rheight(r);
#line 2361
      (r->h)->window_vt_y -= (int )tmp___5;
      }
    }
  }
#line 2362
  return;
}
}
#line 2371 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_get_ourmods(rxvt_t *r ) 
{ 
  int i ;
  int j ;
  int k ;
  int requestedmeta ;
  int realmeta ;
  int realalt ;
  char const   *cm ;
  char const   *rsmod ;
  XModifierKeymap *map ;
  KeyCode *kc ;
  unsigned int modmasks[5] ;
  int tmp ;
  int tmp___0 ;
  KeySym __attribute__((__deprecated__))  tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2380
  modmasks[0] = (unsigned int )(1 << 3);
#line 2380
  modmasks[1] = (unsigned int )(1 << 4);
#line 2380
  modmasks[2] = (unsigned int )(1 << 5);
#line 2380
  modmasks[3] = (unsigned int )(1 << 6);
#line 2380
  modmasks[4] = (unsigned int )(1 << 7);
#line 2386
  realalt = 0;
#line 2386
  realmeta = realalt;
#line 2386
  requestedmeta = realmeta;
#line 2388
  rsmod = (r->h)->rs[326];
#line 2389
  if (rsmod) {
    {
#line 2389
    tmp = strcasecmp(rsmod, "mod1");
    }
#line 2389
    if (tmp >= 0) {
      {
#line 2389
      tmp___0 = strcasecmp(rsmod, "mod5");
      }
#line 2389
      if (tmp___0 <= 0) {
#line 2392
        requestedmeta = (int )((int const   )*(rsmod + 3) - 48);
      }
    }
  }
  {
#line 2394
  map = XGetModifierMapping(r->Xdisplay);
#line 2395
  kc = map->modifiermap;
#line 2396
  i = 1;
  }
  {
#line 2396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2396
    if (! (i < 6)) {
#line 2396
      goto while_break;
    }
#line 2398
    k = (i + 2) * map->max_keypermod;
#line 2399
    j = map->max_keypermod;
    {
#line 2399
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2399
      tmp___4 = j;
#line 2399
      j --;
#line 2399
      if (! tmp___4) {
#line 2399
        goto while_break___0;
      }
#line 2401
      if ((int )*(kc + k) == 0) {
#line 2402
        goto while_break___0;
      }
      {
#line 2404
      tmp___1 = XKeycodeToKeysym(r->Xdisplay, *(kc + k), 0);
      }
      {
#line 2406
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65407) {
#line 2406
        goto case_65407;
      }
#line 2412
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65512) {
#line 2412
        goto case_65512;
      }
#line 2412
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65511) {
#line 2412
        goto case_65512;
      }
#line 2417
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65514) {
#line 2417
        goto case_65514;
      }
#line 2417
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65513) {
#line 2417
        goto case_65514;
      }
#line 2422
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65516) {
#line 2422
        goto case_65516;
      }
#line 2422
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65515) {
#line 2422
        goto case_65516;
      }
#line 2426
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65518) {
#line 2426
        goto case_65518;
      }
#line 2426
      if (tmp___1 == (KeySym __attribute__((__deprecated__))  )65517) {
#line 2426
        goto case_65518;
      }
#line 2409
      goto switch_default;
      case_65407: /* CIL Label */ 
#line 2407
      (r->h)->ModNumLockMask = modmasks[i - 1];
      switch_default: /* CIL Label */ 
#line 2410
      goto __Cont;
      case_65512: /* CIL Label */ 
      case_65511: /* CIL Label */ 
#line 2413
      cm = "meta";
#line 2414
      realmeta = i;
#line 2415
      goto switch_break;
      case_65514: /* CIL Label */ 
      case_65513: /* CIL Label */ 
#line 2418
      cm = "alt";
#line 2419
      realalt = i;
#line 2420
      goto switch_break;
      case_65516: /* CIL Label */ 
      case_65515: /* CIL Label */ 
#line 2423
      cm = "super";
#line 2424
      goto switch_break;
      case_65518: /* CIL Label */ 
      case_65517: /* CIL Label */ 
#line 2427
      cm = "hyper";
#line 2428
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2431
      if (rsmod) {
        {
#line 2431
        tmp___2 = strlen(cm);
#line 2431
        tmp___3 = strncasecmp(rsmod, cm, tmp___2);
        }
#line 2431
        if (tmp___3 == 0) {
#line 2432
          requestedmeta = i;
        }
      }
      __Cont: /* CIL Label */ 
#line 2399
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2435
  XFreeModifiermap(map);
  }
#line 2437
  if (requestedmeta) {
#line 2437
    i = requestedmeta;
  } else {
#line 2437
    if (realmeta) {
#line 2437
      tmp___6 = realmeta;
    } else {
#line 2437
      if (realalt) {
#line 2437
        tmp___5 = realalt;
      } else {
#line 2437
        tmp___5 = 0;
      }
#line 2437
      tmp___6 = tmp___5;
    }
#line 2437
    i = tmp___6;
  }
#line 2441
  if (i) {
#line 2442
    (r->h)->ModMetaMask = modmasks[i - 1];
  }
#line 2443
  return;
}
}
#line 2448 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
char **rxvt_string_to_argv(char const   *string , int *argc ) 
{ 
  int i ;
  char **pret ;
  char const   *pcur ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int max_argv_len ;
  char *argval ;
  unsigned long __lengthofargval ;
  void *tmp___3 ;
  int j ;
  char const   *s ;
  int nbslashs ;
  int nbytes ;
  int tmp___4 ;
  int nbytes___0 ;
  long tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  void *tmp___8 ;
  char **s___0 ;

  {
#line 2451
  i = 0;
#line 2458
  *argc = 0;
#line 2459
  if ((unsigned long )((void *)0) == (unsigned long )string) {
#line 2461
    *argc = 0;
#line 2462
    return ((char **)((void *)0));
  } else
#line 2459
  if ((int const   )*string == 0) {
#line 2461
    *argc = 0;
#line 2462
    return ((char **)((void *)0));
  }
  {
#line 2471
  tmp = rxvt_calloc((size_t )1024, sizeof(char *));
#line 2471
  pret = (char **)tmp;
  }
#line 2574
  if ((int const   )*string == 33) {
#line 2574
    string ++;
#line 2574
    if ((int const   )*string != 33) {
      {
#line 2577
      tmp___0 = i;
#line 2577
      i ++;
#line 2577
      *(pret + tmp___0) = strdup("/bin/sh");
#line 2578
      tmp___1 = i;
#line 2578
      i ++;
#line 2578
      *(pret + tmp___1) = strdup("-c");
#line 2579
      tmp___2 = i;
#line 2579
      i ++;
#line 2579
      *(pret + tmp___2) = strdup(string);
      }
    } else {
#line 2574
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 2591
    pcur = string;
    {
#line 2592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2592
      if (i < 1024) {
#line 2592
        if (! *pcur) {
#line 2592
          goto while_break;
        }
      } else {
#line 2592
        goto while_break;
      }
      {
#line 2594
      max_argv_len = 1024;
#line 2595
      __lengthofargval = (unsigned long )max_argv_len;
#line 2595
      tmp___3 = __builtin_alloca(sizeof(*argval) * __lengthofargval);
#line 2595
      argval = (char *)tmp___3;
#line 2596
      j = 0;
      }
      {
#line 2599
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2599
        if (! ((int const   )*pcur == 32)) {
#line 2599
          if (! ((int const   )*pcur == 9)) {
#line 2599
            goto while_break___0;
          }
        }
#line 2599
        pcur ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2601
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2601
        if (*pcur) {
#line 2601
          if ((int const   )*pcur != 32) {
#line 2601
            if ((int const   )*pcur != 9) {
#line 2601
              if (! (j < max_argv_len - 1)) {
#line 2601
                goto while_break___1;
              }
            } else {
#line 2601
              goto while_break___1;
            }
          } else {
#line 2601
            goto while_break___1;
          }
        } else {
#line 2601
          goto while_break___1;
        }
#line 2606
        if ((int const   )*pcur == 92) {
#line 2608
          s = pcur + 1;
          {
#line 2611
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2611
            if (! ((int const   )*s == 92)) {
#line 2611
              goto while_break___2;
            }
#line 2612
            s ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2614
          if ((int const   )*s == 32) {
#line 2614
            goto _L;
          } else
#line 2614
          if ((int const   )*s == 9) {
            _L: /* CIL Label */ 
#line 2616
            nbslashs = (int )(s - pcur);
#line 2617
            if (nbslashs / 2 < (max_argv_len - j) - 1) {
#line 2617
              tmp___4 = nbslashs / 2;
            } else {
#line 2617
              tmp___4 = (max_argv_len - j) - 1;
            }
            {
#line 2617
            nbytes = tmp___4;
#line 2620
            memset((void *)(argval + j), '\\', (size_t )nbytes);
#line 2621
            pcur = s;
#line 2622
            j += nbytes;
            }
#line 2624
            if (nbslashs % 2 == 0) {
#line 2625
              goto while_break___1;
            }
          } else {
#line 2631
            if (s - pcur < (long )((max_argv_len - j) - 1)) {
#line 2631
              tmp___5 = s - pcur;
            } else {
#line 2631
              tmp___5 = (long )((max_argv_len - j) - 1);
            }
            {
#line 2631
            nbytes___0 = (int )tmp___5;
#line 2633
            memcpy((void */* __restrict  */)((void *)(argval + j)), (void const   */* __restrict  */)((void const   *)pcur),
                   (size_t )nbytes___0);
#line 2634
            j += nbytes___0;
#line 2635
            pcur = s;
            }
          }
        }
#line 2639
        tmp___6 = j;
#line 2639
        j ++;
#line 2639
        tmp___7 = pcur;
#line 2639
        pcur ++;
#line 2639
        *(argval + tmp___6) = (char )*tmp___7;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2642
      if (j) {
        {
#line 2644
        *(argval + j) = (char )'\000';
#line 2645
        *(pret + i) = strdup((char const   *)argval);
        }
      } else {
#line 2648
        goto while_break;
      }
#line 2592
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2655
  if (*(pret + i)) {
#line 2657
    *argc = i + 1;
#line 2658
    *(pret + (i + 1)) = (char *)((void *)0);
  } else
#line 2660
  if (i) {
#line 2662
    *argc = i;
  } else {
#line 2671
    goto NotMatch;
  }
  {
#line 2675
  tmp___8 = rxvt_realloc((void *)pret, (unsigned long )(*argc + 1) * sizeof(char *));
#line 2675
  pret = (char **)tmp___8;
  }
#line 2676
  return (pret);
  NotMatch: 
#line 2679
  *argc = 0;
#line 2682
  s___0 = pret;
  {
#line 2682
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2682
    if (! ((unsigned long )((void *)0) != (unsigned long )*s___0)) {
#line 2682
      goto while_break___3;
    }
    {
#line 2682
    rxvt_free((void *)*s___0);
#line 2682
    s___0 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2685
  rxvt_free((void *)pret);
  }
#line 2686
  return ((char **)((void *)0));
}
}
#line 2695 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_set_vt_colors(rxvt_t *r , int page ) 
{ 
  int changed ;
  int useFocusColors ;
  unsigned long *pix_colors ;
  int tmp ;
  int tmp___0 ;

  {
#line 2698
  changed = 0;
#line 2704
  if (r->TermWin.focus) {
#line 2704
    tmp = 1;
  } else
#line 2704
  if (! r->TermWin.fade) {
#line 2704
    tmp = 1;
  } else {
#line 2704
    tmp = 0;
  }
#line 2704
  useFocusColors = tmp;
#line 2705
  if (useFocusColors) {
#line 2705
    pix_colors = r->pixColorsFocus;
  } else {
#line 2705
    pix_colors = r->pixColorsUnfocus;
  }
#line 2706
  if ((unsigned long )r->pixColors != (unsigned long )pix_colors) {
#line 2708
    changed = 1;
#line 2709
    r->pixColors = pix_colors;
  }
  {
#line 2717
  tmp___0 = rxvt_set_fgbg_colors(r, page);
  }
#line 2717
  if (tmp___0) {
#line 2718
    changed = 1;
  }
#line 2720
  if (changed) {
    {
#line 2728
    XSetForeground(r->Xdisplay, r->TermWin.gc, *(r->pixColors + 0));
#line 2729
    XSetBackground(r->Xdisplay, r->TermWin.gc, *(r->pixColors + 1));
    }
#line 2731
    if (0UL != (r->vts[page])->vt) {
#line 2733
      if (! ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL))) {
        {
#line 2738
        XSetWindowBackground(r->Xdisplay, (r->vts[page])->vt, *(r->pixColors + 1));
        }
      }
    }
  }
#line 2743
  return (changed);
}
}
#line 2748 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
termenv_t rxvt_get_termenv(char const   *env ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2751
  if ((unsigned long )((void *)0) == (unsigned long )env) {
#line 2752
    return ((termenv_t )0);
  } else {
    {
#line 2753
    tmp___4 = strcasecmp(env, "xterm");
    }
#line 2753
    if (0 == tmp___4) {
#line 2754
      return ((termenv_t )0);
    } else {
      {
#line 2755
      tmp___3 = strcasecmp(env, "rxvt");
      }
#line 2755
      if (0 == tmp___3) {
#line 2756
        return ((termenv_t )1);
      } else {
        {
#line 2757
        tmp___2 = strcasecmp(env, "vt102");
        }
#line 2757
        if (0 == tmp___2) {
#line 2758
          return ((termenv_t )2);
        } else {
          {
#line 2759
          tmp___1 = strcasecmp(env, "vt100");
          }
#line 2759
          if (0 == tmp___1) {
#line 2760
            return ((termenv_t )3);
          } else {
            {
#line 2761
            tmp___0 = strcasecmp(env, "ansi");
            }
#line 2761
            if (0 == tmp___0) {
#line 2762
              return ((termenv_t )4);
            } else {
              {
#line 2763
              tmp = strcasecmp(env, "dumb");
              }
#line 2763
              if (0 == tmp) {
#line 2764
                return ((termenv_t )5);
              } else {
#line 2766
                return ((termenv_t )0);
              }
            }
          }
        }
      }
    }
  }
}
}
#line 2771 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_init_vts(rxvt_t *r , int page , int profile ) 
{ 
  struct group *gr ;
  struct group *tmp ;
  register int i ;
  int tmp___0 ;
  char const   *stf ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *wtf ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned char *tmp___10 ;

  {
  {
#line 2775
  tmp = getgrnam("tty");
#line 2775
  gr = tmp;
#line 2783
  i = 0;
  }
  {
#line 2783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2783
    if (! (i < 15)) {
#line 2783
      goto while_break;
    }
#line 2784
    if (-1 == (int )r->vterm[i].vts_idx) {
#line 2785
      goto while_break;
    }
#line 2783
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2790
  r->vts[page] = & r->vterm[i];
#line 2791
  memset((void *)r->vts[page], 0, sizeof(r->vterm[0]));
#line 2794
  (r->vts[page])->vts_idx = (short )i;
#line 2797
  (r->vts[page])->profileNum = (unsigned char )profile;
#line 2800
  tmp___0 = r->ntabs;
#line 2800
  (r->ntabs) ++;
#line 2800
  (r->vts[page])->globalTabNum = tmp___0;
  }
#line 2804
  if (gr) {
#line 2806
    (r->vts[page])->ttymode = (unsigned int )(384 | (128 >> 3));
  } else {
#line 2811
    (r->vts[page])->ttymode = (unsigned int )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
  {
#line 2815
  (r->vts[page])->saveLines = (uint16_t )r->profile[profile].saveLines;
#line 2818
  (r->vts[page])->vt = (Window )0L;
#line 2823
  (r->vts[page])->tab_title = (char *)((void *)0);
#line 2830
  tmp___1 = getProfileOption(r, profile, 379);
#line 2830
  stf = tmp___1;
  }
#line 2831
  if ((unsigned long )((void *)0) != (unsigned long )stf) {
    {
#line 2831
    tmp___2 = strdup(stf);
#line 2831
    (r->vts[page])->title_format = tmp___2;
    }
  } else {
#line 2831
    (r->vts[page])->title_format = (char *)((void *)0);
  }
  {
#line 2835
  tmp___3 = getProfileOption(r, profile, 384);
#line 2835
  wtf = tmp___3;
  }
#line 2836
  if ((unsigned long )((void *)0) != (unsigned long )wtf) {
    {
#line 2836
    tmp___4 = strdup(wtf);
#line 2836
    (r->vts[page])->winTitleFormat = tmp___4;
    }
  } else {
#line 2836
    (r->vts[page])->winTitleFormat = (char *)((void *)0);
  }
#line 2844
  (r->vts[page])->cmd_pid = -1;
#line 2845
  tmp___5 = -1;
#line 2845
  (r->vts[page])->tty_fd = tmp___5;
#line 2845
  (r->vts[page])->cmd_fd = tmp___5;
#line 2847
  (r->vts[page])->next_utmp_action = (unsigned char )'s';
#line 2853
  (r->vts[page])->holdOption = r->profile[profile].holdOption;
#line 2855
  (r->vts[page])->status = 0;
#line 2856
  (r->vts[page])->hold = (unsigned char)0;
#line 2857
  (r->vts[page])->dead = (unsigned char)0;
#line 2858
  (r->vts[page])->highlight = (unsigned char)0;
#line 2861
  if ((r->h)->rs[4]) {
#line 2861
    tmp___6 = (r->h)->rs[4];
  } else {
#line 2861
    tmp___6 = "rxvt";
  }
  {
#line 2861
  (r->vts[page])->termenv = rxvt_get_termenv(tmp___6);
#line 2865
  tmp___7 = (uint32_t )(((1UL << 5) | (1UL << 10)) | (1UL << 11));
#line 2865
  (r->vts[page])->SavedModes = tmp___7;
#line 2865
  (r->vts[page])->PrivateModes = tmp___7;
  }
#line 2867
  if ((unsigned long )r->Options[(1UL << 14) & 3UL] & ((1UL << 14) & 0xfffffffffffffffcUL)) {
#line 2868
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 16));
  }
#line 2869
  if ((unsigned long )r->Options[(1UL << 15) & 3UL] & ((1UL << 15) & 0xfffffffffffffffcUL)) {
#line 2870
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 17));
  }
#line 2871
  if ((r->h)->skip_pages > 1) {
#line 2872
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 18));
  }
  {
#line 2874
  tmp___8 = strcmp((r->h)->key_backspace, "DEC");
  }
#line 2874
  if (tmp___8 == 0) {
#line 2875
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 8));
  }
  {
#line 2878
  tmp___9 = rxvt_scrollbar_visible(r);
  }
#line 2878
  if (tmp___9) {
#line 2880
    (r->vts[page])->PrivateModes = (uint32_t )((unsigned long )(r->vts[page])->PrivateModes | (1UL << 14));
#line 2881
    (r->vts[page])->SavedModes = (uint32_t )((unsigned long )(r->vts[page])->SavedModes | (1UL << 14));
  }
#line 2893
  (r->vts[page])->p_fg = r->profile[profile].fg;
#line 2894
  (r->vts[page])->p_bg = r->profile[profile].bg;
#line 2896
  if (r->TermWin.fade) {
#line 2898
    (r->vts[page])->p_fgfade = r->profile[profile].fg_fade;
#line 2899
    (r->vts[page])->p_bgfade = r->profile[profile].bg_fade;
  }
#line 2917
  tmp___10 = (r->vts[page])->cmdbuf_base;
#line 2917
  (r->vts[page])->cmdbuf_endp = tmp___10;
#line 2917
  (r->vts[page])->cmdbuf_ptr = tmp___10;
#line 2921
  (r->vts[page])->v_buffer = (unsigned char *)((void *)0);
#line 2922
  (r->vts[page])->v_bufstr = (unsigned char *)((void *)0);
#line 2923
  (r->vts[page])->v_bufptr = (unsigned char *)((void *)0);
#line 2924
  (r->vts[page])->v_bufend = (unsigned char *)((void *)0);
#line 2927
  (r->vts[page])->init_screen = (unsigned char)0;
#line 2930
  (r->vts[page])->want_refresh = (unsigned char)1;
#line 2931
  return;
}
}
#line 2937 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_destroy_termwin(rxvt_t *r , int page ) 
{ 


  {
  {
#line 2943
  rxvt_free((void *)(r->vts[page])->tab_title);
#line 2944
  (r->vts[page])->tab_title = (char *)((void *)0);
#line 2946
  rxvt_free((void *)(r->vts[page])->title_format);
#line 2947
  (r->vts[page])->title_format = (char *)((void *)0);
#line 2958
  XDestroyWindow(r->Xdisplay, (r->vts[page])->vt);
#line 2959
  (r->vts[page])->vt = (Window )0L;
#line 2975
  (r->vts[page])->vts_idx = (short)-1;
  }
#line 2976
  return;
}
}
#line 2982 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_create_termwin(rxvt_t *r , int page , int profile , char const   *title ) 
{ 
  long vt_emask ;
  char *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 2991
  rxvt_init_vts(r, page, profile);
  }
#line 2996
  if ((unsigned long )((void *)0) == (unsigned long )title) {
#line 2997
    title = "Terminal";
  }
  {
#line 2998
  tmp = strndup(title, (size_t )507);
#line 2998
  (r->vts[page])->tab_title = tmp;
#line 3002
  sprintf((char */* __restrict  */)(r->h)->env_tabtitle, (char const   */* __restrict  */)"MRXVT_TABTITLE=%s",
          (r->vts[page])->tab_title);
#line 3003
  putenv((r->h)->env_tabtitle);
#line 3006
  tmp___0 = rxvt_tab_width(r, (char const   *)(r->vts[page])->tab_title);
#line 3006
  (r->vts[page])->tab_width = (short )tmp___0;
#line 3012
  rxvt_set_vt_colors(r, page);
#line 3017
  (r->vts[page])->vt = XCreateSimpleWindow(r->Xdisplay, r->TermWin.parent, (r->h)->window_vt_x,
                                           (r->h)->window_vt_y, (unsigned int )((r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth),
                                           (unsigned int )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth),
                                           0U, *(r->pixColors + 0), *(r->pixColors + 1));
#line 3035
  rxvt_pointer_unblank(r, page);
#line 3038
  vt_emask = (((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 22);
  }
#line 3041
  if ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL)) {
#line 3042
    vt_emask |= 1L << 6;
  } else {
#line 3045
    vt_emask |= (1L << 8) | (1L << 10);
  }
  {
#line 3046
  XSelectInput(r->Xdisplay, (r->vts[page])->vt, vt_emask);
  }
#line 3050
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
    {
#line 3052
    XSetWindowBackgroundPixmap(r->Xdisplay, (r->vts[page])->vt, (Pixmap )1L);
    }
  }
  {
#line 3082
  XMapWindow(r->Xdisplay, (r->vts[page])->vt);
  }
#line 3083
  return;
}
}
#line 3093 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
char const   *getProfileOption(rxvt_t *r , int profile , int resource ) 
{ 
  char const   *tmp ;

  {
#line 3102
  if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[resource + profile]) {
#line 3102
    tmp = (r->h)->rs[resource + profile];
  } else {
#line 3102
    tmp = (r->h)->rs[resource];
  }
#line 3102
  return (tmp);
}
}
#line 3107 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_set_borderless(rxvt_t *r ) 
{ 
  Atom prop ;
  CARD32 hints ;
  MWMHints mwmhints ;

  {
  {
#line 3114
  hints = (CARD32 )0;
#line 3115
  mwmhints.flags = (int )(1L << 1);
#line 3116
  mwmhints.decorations = 0;
#line 3119
  prop = XInternAtom(r->Xdisplay, "_MOTIF_WM_HINTS", 1);
  }
#line 3120
  if (0UL != prop) {
    {
#line 3121
    XChangeProperty(r->Xdisplay, r->TermWin.parent, prop, prop, 32, 0, (unsigned char const   *)((unsigned char *)(& mwmhints)),
                    5);
    }
  }
  {
#line 3126
  prop = XInternAtom(r->Xdisplay, "_WIN_HINTS", 1);
  }
#line 3127
  if (0UL != prop) {
    {
#line 3128
    XChangeProperty(r->Xdisplay, r->TermWin.parent, prop, prop, 32, 0, (unsigned char const   *)((unsigned char *)(& hints)),
                    1);
    }
  }
  {
#line 3132
  prop = XInternAtom(r->Xdisplay, "KWM_WIN_DECORATION", 1);
  }
#line 3133
  if (0UL != prop) {
    {
#line 3134
    XChangeProperty(r->Xdisplay, r->TermWin.parent, prop, prop, 32, 0, (unsigned char const   *)((unsigned char *)(& hints)),
                    1);
    }
  }
#line 3136
  return;
}
}
#line 3142 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int ewmh_message(Display *dpy , Window root_win , Window client_win , Atom msgAtom ,
                 long d0 , long d1 , long d2 , long d3 , long d4 ) 
{ 
  XEvent event ;
  int tmp ;

  {
#line 3149
  if (0UL == msgAtom) {
#line 3150
    return (1);
  }
  {
#line 3152
  event.xclient.type = 33;
#line 3153
  event.xclient.serial = 0UL;
#line 3154
  event.xclient.send_event = 1;
#line 3155
  event.xclient.message_type = msgAtom;
#line 3156
  event.xclient.window = client_win;
#line 3157
  event.xclient.format = 32;
#line 3159
  event.xclient.data.l[0] = d0;
#line 3160
  event.xclient.data.l[1] = d1;
#line 3161
  event.xclient.data.l[2] = d2;
#line 3162
  event.xclient.data.l[3] = d3;
#line 3163
  event.xclient.data.l[4] = d4;
#line 3165
  tmp = XSendEvent(dpy, root_win, 0, (1L << 20) | (1L << 19), & event);
  }
#line 3165
  return (tmp);
}
}
#line 3172 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_set_desktop(rxvt_t *r , CARD32 desktop ) 
{ 


  {
#line 3176
  if (desktop >= 0U) {
#line 3176
    if (desktop <= 64U) {
#line 3176
      if (0UL != (r->h)->xa[10]) {
        {
#line 3178
        XChangeProperty(r->Xdisplay, r->TermWin.parent, (r->h)->xa[10], (Atom )6,
                        32, 0, (unsigned char const   *)((unsigned char *)(& desktop)),
                        1);
        }
      }
    }
  }
#line 3183
  if (desktop >= 0U) {
#line 3183
    if (desktop <= 64U) {
#line 3183
      if (0UL != (r->h)->xa[9]) {
        {
#line 3185
        XChangeProperty(r->Xdisplay, r->TermWin.parent, (r->h)->xa[9], (Atom )6, 32,
                        0, (unsigned char const   *)((unsigned char *)(& desktop)),
                        1);
        }
      }
    }
  }
#line 3188
  return;
}
}
#line 3192 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
CARD32 rxvt_get_desktop(rxvt_t *r ) 
{ 
  Atom ret_type ;
  int format ;
  unsigned long nitems ;
  unsigned long bytes_after ;
  unsigned char *prop ;
  CARD32 desktop ;
  int tmp ;

  {
#line 3202
  if (0UL == (r->h)->xa[9]) {
#line 3203
    return ((CARD32 )0);
  }
  {
#line 3205
  tmp = XGetWindowProperty(r->Xdisplay, r->TermWin.parent, (r->h)->xa[9], 0L, 9223372036854775807L,
                           0, (Atom )6, & ret_type, & format, & nitems, & bytes_after,
                           & prop);
  }
#line 3205
  if (tmp != 0) {
#line 3211
    return ((CARD32 )0);
  }
#line 3213
  if (ret_type == 6UL) {
#line 3213
    if (format == 32) {
#line 3215
      desktop = *((CARD32 *)prop + 0);
#line 3216
      if (desktop < 0U) {
#line 3217
        desktop = (CARD32 )0;
      } else
#line 3216
      if (desktop > 64U) {
#line 3217
        desktop = (CARD32 )0;
      }
    } else {
#line 3220
      desktop = (CARD32 )0;
    }
  } else {
#line 3220
    desktop = (CARD32 )0;
  }
  {
#line 3222
  XFree((void *)prop);
  }
#line 3225
  return (desktop);
}
}
#line 3248 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
static struct __anonstruct_XColor_81  const  blackcolour  =    {0UL, (unsigned short)0, (unsigned short)0, (unsigned short)0, (char)0, (char)0};
#line 3232 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_create_show_windows(rxvt_t *r , int argc , char const   * const  *argv ) 
{ 
  XClassHint class_hint ;
  XWMHints wm_hint ;
  XTextProperty win_prop ;
  XTextProperty icon_prop ;
  XGCValues gcvalue ;
  unsigned long gcmask ;
  CARD32 pid ;
  __pid_t tmp ;
  register int i ;
  Window parent ;
  XWindowAttributes attrs ;
  XSetWindowAttributes attrib ;
  CARD32 desktop ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  Atom tmp___3 ;
  Atom tmp___4 ;
  Atom tmp___5 ;
  Atom tmp___6 ;
  Atom tmp___7 ;

  {
  {
#line 3242
  tmp = getpid();
#line 3242
  pid = (CARD32 )tmp;
#line 3291
  rxvt_init_colors(r);
#line 3318
  rxvt_init_font_x11(r);
#line 3326
  rxvt_scrollbar_init(r);
#line 3328
  rxvt_init_win_size(r);
  }
#line 3333
  if ((r->h)->rs[3]) {
    {
#line 3337
    (r->h)->allowedxerror = (unsigned char)1;
#line 3338
    (r->h)->xerror_return = 0;
#line 3340
    parent = strtoul((char const   */* __restrict  */)(r->h)->rs[3], (char **/* __restrict  */)((void *)0),
                     0);
#line 3342
    XGetWindowAttributes(r->Xdisplay, parent, & attrs);
    }
#line 3345
    if ((r->h)->xerror_return != 0) {
      {
#line 3347
      rxvt_msg((uint32_t )1, (uint32_t )8, "Unable to embed into Win 0x%lx", parent);
#line 3348
      parent = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root;
      }
    } else
#line 3345
    if (attrs.class == 2) {
      {
#line 3347
      rxvt_msg((uint32_t )1, (uint32_t )8, "Unable to embed into Win 0x%lx", parent);
#line 3348
      parent = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root;
      }
    }
#line 3351
    (r->h)->allowedxerror = (unsigned char)0;
  } else {
#line 3354
    parent = (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root;
  }
  {
#line 3374
  r->TermWin.parent = XCreateSimpleWindow(r->Xdisplay, parent, r->szHint.x, r->szHint.y,
                                          (unsigned int )r->szHint.width, (unsigned int )r->szHint.height,
                                          (unsigned int )r->TermWin.ext_bwidth, *(r->pixColorsFocus + 261),
                                          *(r->pixColorsFocus + 1));
  }
#line 3410
  if ((unsigned long )r->Options[((1UL << 23) | 1UL) & 3UL] & (((1UL << 23) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 3411
    rxvt_session_init(r);
    }
  }
  {
#line 3419
  win_prop.value = (unsigned char *)(r->h)->rs[287];
#line 3420
  win_prop.nitems = strlen((char const   *)win_prop.value);
#line 3421
  win_prop.encoding = (Atom )31;
#line 3422
  win_prop.format = 8;
#line 3424
  icon_prop.value = (unsigned char *)(r->h)->rs[5];
#line 3425
  icon_prop.nitems = strlen((char const   *)icon_prop.value);
#line 3426
  icon_prop.encoding = (Atom )31;
#line 3427
  icon_prop.format = 8;
#line 3429
  wm_hint.flags = (1L | (1L << 1)) | (1L << 6);
#line 3430
  wm_hint.input = 1;
  }
#line 3431
  if ((unsigned long )r->Options[(1UL << 4) & 3UL] & ((1UL << 4) & 0xfffffffffffffffcUL)) {
#line 3431
    wm_hint.initial_state = 3;
  } else {
#line 3431
    wm_hint.initial_state = 1;
  }
  {
#line 3433
  wm_hint.window_group = r->TermWin.parent;
#line 3451
  class_hint.res_name = (char *)(r->h)->rs[286];
#line 3452
  class_hint.res_class = (char *)"XTerm";
#line 3453
  XSetWMProperties(r->Xdisplay, r->TermWin.parent, & win_prop, & icon_prop, (char **)argv,
                   argc, & r->szHint, & wm_hint, & class_hint);
#line 3466
  rxvt_set_term_title(r, (unsigned char const   *)win_prop.value);
#line 3468
  rxvt_set_icon_name(r, (unsigned char const   *)icon_prop.value);
#line 3470
  XSetCommand(r->Xdisplay, r->TermWin.parent, (char **)argv, argc);
  }
#line 3473
  if ((unsigned long )r->Options[((1UL << 15) | 1UL) & 3UL] & (((1UL << 15) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 3476
    attrib.override_redirect = 1;
#line 3477
    XChangeWindowAttributes(r->Xdisplay, r->TermWin.parent, (unsigned long )(1L << 9),
                            & attrib);
    }
  }
  {
#line 3482
  XChangeProperty(r->Xdisplay, r->TermWin.parent, (r->h)->xa[15], (Atom )6, 32, 0,
                  (unsigned char const   *)((unsigned char *)(& pid)), 1);
  }
#line 3487
  if ((unsigned long )r->Options[((1UL << 14) | 1UL) & 3UL] & (((1UL << 14) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 3489
    rxvt_set_borderless(r);
    }
  }
#line 3491
  if ((r->h)->rs[313]) {
    {
#line 3493
    tmp___0 = atoi((r->h)->rs[313]);
#line 3493
    desktop = (CARD32 )tmp___0;
#line 3494
    rxvt_set_desktop(r, desktop);
    }
  }
#line 3501
  if (0UL != (r->h)->xa[13]) {
    {
#line 3502
    XChangeProperty(r->Xdisplay, r->TermWin.parent, (r->h)->xa[13], (Atom )33, 32,
                    0, (unsigned char const   *)((unsigned char *)(& r->TermWin.parent)),
                    1);
    }
  }
#line 3507
  if ((unsigned long )((void *)0) != (unsigned long )r->TermWin.sm_conn) {
#line 3507
    if ((unsigned long )((void *)0) != (unsigned long )r->TermWin.sm_client_id) {
      {
#line 3507
      tmp___2 = strcmp((char const   *)r->TermWin.sm_client_id, "");
      }
#line 3507
      if (tmp___2) {
#line 3512
        if (0UL != (r->h)->xa[16]) {
          {
#line 3513
          tmp___1 = strlen((char const   *)r->TermWin.sm_client_id);
#line 3513
          XChangeProperty(r->Xdisplay, r->TermWin.parent, (r->h)->xa[16], (Atom )31,
                          8, 0, (unsigned char const   *)((unsigned char *)r->TermWin.sm_client_id),
                          (int )tmp___1);
          }
        }
      }
    }
  }
#line 3523
  r->TermWin.parenttree[0] = r->TermWin.parent;
#line 3524
  i = 1;
  {
#line 3524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3524
    if (! (i < 6)) {
#line 3524
      goto while_break;
    }
#line 3525
    r->TermWin.parenttree[i] = (Window )0L;
#line 3524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3542
  XSelectInput(r->Xdisplay, r->TermWin.parent, ((1L | (1L << 21)) | (1L << 16)) | (1L << 17));
#line 3559
  r->term_pointer = XCreateFontCursor(r->Xdisplay, 152U);
#line 3561
  (r->h)->bar_pointer = XCreateFontCursor(r->Xdisplay, 68U);
  }
#line 3564
  if (! ((unsigned long )r->Options[(1UL << 21) & 3UL] & ((1UL << 21) & 0xfffffffffffffffcUL))) {
#line 3565
    (r->h)->blank_pointer = (Cursor )0L;
  } else {
    {
#line 3567
    (r->h)->blank_pointer = XCreateGlyphCursor(r->Xdisplay, (r->TermWin.font)->fid,
                                               (r->TermWin.font)->fid, (unsigned int )' ',
                                               (unsigned int )' ', (XColor const   *)((XColor *)(& blackcolour)),
                                               (XColor const   *)((XColor *)(& blackcolour)));
    }
  }
  {
#line 3577
  gcvalue.font = (r->TermWin.font)->fid;
#line 3578
  gcvalue.foreground = *(r->pixColorsFocus + 0);
#line 3579
  gcvalue.background = *(r->pixColorsFocus + 1);
#line 3580
  gcvalue.graphics_exposures = 1;
#line 3581
  gcmask = (unsigned long )(((1L << 2) | (1L << 3)) | (1L << 16));
#line 3585
  gcmask |= (unsigned long )(1L << 14);
#line 3586
  r->TermWin.gc = XCreateGC(r->Xdisplay, r->TermWin.parent, gcmask, & gcvalue);
#line 3590
  rxvt_scrollbar_create(r);
  }
#line 3591
  if ((unsigned long )r->Options[(1UL << 10) & 3UL] & ((1UL << 10) & 0xfffffffffffffffcUL)) {
    {
#line 3593
    rxvt_scrollbar_show(r);
    }
  }
  {
#line 3625
  rxvt_tabbar_create(r);
  }
#line 3626
  if (! ((unsigned long )r->Options[((1UL << 12) | 1UL) & 3UL] & (((1UL << 12) | 1UL) & 0xfffffffffffffffcUL))) {
    {
#line 3627
    rxvt_tabbar_show(r);
    }
  }
  {
#line 3629
  XMapWindow(r->Xdisplay, r->TermWin.parent);
  }
#line 3635
  if ((unsigned long )r->Options[((1UL << 29) | 1UL) & 3UL] & (((1UL << 29) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 3636
    tmp___3 = XInternAtom(r->Xdisplay, "_NET_WM_STATE_MAXIMIZED_VERT", 1);
#line 3636
    tmp___4 = XInternAtom(r->Xdisplay, "_NET_WM_STATE_MAXIMIZED_HORZ", 1);
#line 3636
    tmp___5 = XInternAtom(r->Xdisplay, "_NET_WM_STATE", 1);
#line 3636
    ewmh_message(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                 r->TermWin.parent, tmp___5, 1L, (long )tmp___4, (long )tmp___3, 0L,
                 0L);
    }
  } else
#line 3642
  if ((unsigned long )r->Options[((1UL << 30) | 1UL) & 3UL] & (((1UL << 30) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 3643
    tmp___6 = XInternAtom(r->Xdisplay, "_NET_WM_STATE_FULLSCREEN", 1);
#line 3643
    tmp___7 = XInternAtom(r->Xdisplay, "_NET_WM_STATE", 1);
#line 3643
    ewmh_message(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                 r->TermWin.parent, tmp___7, 1L, (long )tmp___6, 0L, 0L, 0L);
    }
  }
#line 3648
  return;
}
}
#line 3655 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_async_exec(rxvt_t *r , char const   *cmd ) 
{ 
  int pid ;
  int argc ;
  char **argv ;
  short tmp ;

  {
#line 3662
  if ((int )r->nAsyncChilds >= 16) {
    {
#line 3664
    rxvt_msg((uint32_t )1, (uint32_t )8, "Too many childs. Increase MAX_CHILDS in src/feature.h");
    }
#line 3666
    return (0);
  }
  {
#line 3669
  pid = fork();
  }
  {
#line 3672
  if (pid == -1) {
#line 3672
    goto case_neg_1;
  }
#line 3677
  if (pid == 0) {
#line 3677
    goto case_0;
  }
#line 3692
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 3673
  rxvt_msg((uint32_t )1, (uint32_t )8, "Unable to fork");
  }
#line 3674
  return (0);
  case_0: /* CIL Label */ 
  {
#line 3682
  clean_sigmasks_and_fds(r, (int )r->tabBar.atab);
#line 3684
  argv = rxvt_string_to_argv(cmd, & argc);
#line 3686
  execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 3688
  rxvt_msg((uint32_t )1, (uint32_t )8, "Failed to exec %s", *(argv + 0));
#line 3689
  exit(1);
  }
  switch_default: /* CIL Label */ 
#line 3694
  tmp = r->nAsyncChilds;
#line 3694
  r->nAsyncChilds = (short )((int )r->nAsyncChilds + 1);
#line 3694
  r->asyncChilds[tmp] = (short )pid;
#line 3695
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3706 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_run_command(rxvt_t *r , int page , char const   **argv ) 
{ 
  int cfd ;
  int er ;
  int tmp ;
  int tmp___0 ;
  pid_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int fdstdin ;

  {
  {
#line 3714
  cfd = rxvt_get_pty(& (r->vts[page])->tty_fd, & (r->vts[page])->ttydev);
  }
#line 3714
  if (cfd < 0) {
    {
#line 3717
    rxvt_msg((uint32_t )1, (uint32_t )8, "can\'t open pseudo-tty");
    }
#line 3718
    return (-1);
  }
#line 3721
  if (r->Xfd > 1024) {
    {
#line 3723
    rxvt_msg((uint32_t )1, (uint32_t )8, "fd too high: %d max", 1024);
    }
#line 3724
    return (-1);
  } else
#line 3721
  if (cfd > 1024) {
    {
#line 3723
    rxvt_msg((uint32_t )1, (uint32_t )8, "fd too high: %d max", 1024);
    }
#line 3724
    return (-1);
  }
  {
#line 3727
  fcntl(cfd, 4, 2048);
  }
#line 3730
  if ((r->vts[page])->tty_fd < 0) {
    {
#line 3735
    tmp = rxvt_get_tty((char const   *)(r->vts[page])->ttydev);
#line 3735
    (r->vts[page])->tty_fd = tmp;
    }
#line 3735
    if (tmp < 0) {
      {
#line 3737
      close(cfd);
#line 3738
      rxvt_msg((uint32_t )1, (uint32_t )8, "can\'t open slave tty %s", (r->vts[page])->ttydev);
      }
#line 3739
      return (-1);
    }
  }
#line 3745
  if (*((r->h)->key_backspace + 0)) {
#line 3745
    if (! *((r->h)->key_backspace + 1)) {
#line 3746
      er = (int )*((r->h)->key_backspace + 0);
    } else {
#line 3745
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 3747
    tmp___0 = strcmp((r->h)->key_backspace, "DEC");
    }
#line 3747
    if (tmp___0 == 0) {
#line 3748
      er = '\177';
    } else {
#line 3751
      er = -1;
    }
  }
  {
#line 3752
  rxvt_get_ttymode(& (r->vts[page])->tio, er);
#line 3760
  tmp___1 = fork();
#line 3760
  (r->vts[page])->cmd_pid = tmp___1;
  }
  {
#line 3762
  if (tmp___1 == -1) {
#line 3762
    goto case_neg_1;
  }
#line 3767
  if (tmp___1 == 0) {
#line 3767
    goto case_0;
  }
#line 3824
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 3763
  rxvt_msg((uint32_t )1, (uint32_t )8, "can\'t fork");
#line 3764
  close(cfd);
  }
#line 3765
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 3783
  tmp___3 = rxvt_control_tty((r->vts[page])->tty_fd, (char const   *)(r->vts[page])->ttydev);
  }
#line 3783
  if (tmp___3 < 0) {
    {
#line 3788
    rxvt_msg((uint32_t )1, (uint32_t )8, "Could not obtain control of tty");
    }
  } else {
    {
#line 3796
    dup2((r->vts[page])->tty_fd, 0);
#line 3797
    dup2((r->vts[page])->tty_fd, 1);
#line 3798
    dup2((r->vts[page])->tty_fd, 2);
#line 3800
    clean_sigmasks_and_fds(r, page);
#line 3805
    rxvt_run_child(r, page, argv);
    }
#line 3810
    if (argv) {
#line 3810
      if (*(argv + 0)) {
#line 3810
        tmp___2 = *(argv + 0);
      } else {
#line 3810
        tmp___2 = "shell";
      }
    } else {
#line 3810
      tmp___2 = "shell";
    }
    {
#line 3810
    rxvt_msg((uint32_t )1, (uint32_t )8, "Could not execute %s.\n", tmp___2);
    }
  }
#line 3814
  if (! ((unsigned int )(r->vts[page])->holdOption & (1U << 2))) {
#line 3814
    if (! ((unsigned int )(r->vts[page])->holdOption & 1U)) {
      {
#line 3819
      sleep(5U);
      }
    }
  }
  {
#line 3820
  exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 3829
  fdstdin = dup(0);
#line 3830
  dup2((r->vts[page])->tty_fd, 0);
#line 3837
  rxvt_privileged_utmp(r, page, (char )'s');
#line 3844
  dup2(fdstdin, 0);
#line 3845
  close(fdstdin);
#line 3852
  close((r->vts[page])->tty_fd);
#line 3853
  (r->vts[page])->tty_fd = -1;
  }
#line 3854
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3867
  return (cfd);
}
}
#line 3880 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void clean_sigmasks_and_fds(rxvt_t *r , int page ) 
{ 
  struct sigaction ignore ;
  struct sigaction deflt ;
  register int i ;

  {
#line 3890
  i = 3;
  {
#line 3890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3890
    if (! (i < r->num_fds)) {
#line 3890
      goto while_break;
    }
    {
#line 3891
    close(i);
#line 3890
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3892
  if ((r->vts[page])->tty_fd > 2) {
    {
#line 3894
    close((r->vts[page])->tty_fd);
#line 3895
    (r->vts[page])->tty_fd = -1;
    }
  }
  {
#line 3899
  deflt.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 3900
  deflt.sa_flags = 0;
#line 3901
  sigemptyset(& deflt.sa_mask);
#line 3903
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& deflt), (struct sigaction */* __restrict  */)((void *)0));
#line 3904
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& deflt), (struct sigaction */* __restrict  */)((void *)0));
#line 3905
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& deflt), (struct sigaction */* __restrict  */)((void *)0));
#line 3906
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& deflt), (struct sigaction */* __restrict  */)((void *)0));
#line 3907
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& deflt), (struct sigaction */* __restrict  */)((void *)0));
#line 3908
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& deflt), (struct sigaction */* __restrict  */)((void *)0));
#line 3915
  ignore.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 3916
  ignore.sa_flags = 0;
#line 3917
  sigemptyset(& ignore.sa_mask);
#line 3919
  sigaction(20, (struct sigaction  const  */* __restrict  */)(& ignore), (struct sigaction */* __restrict  */)((void *)0));
#line 3920
  sigaction(21, (struct sigaction  const  */* __restrict  */)(& ignore), (struct sigaction */* __restrict  */)((void *)0));
#line 3921
  sigaction(22, (struct sigaction  const  */* __restrict  */)(& ignore), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 3923
  return;
}
}
#line 3931 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
int rxvt_run_child(rxvt_t *r , int page , char const   **argv ) 
{ 
  char *login___0 ;
  unsigned int on ;
  int i ;
  char const   *argv0 ;
  char const   *shell ;
  struct passwd *pwent ;
  __uid_t tmp ;
  struct passwd *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int l ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 3940
  cfsetospeed(& (r->vts[page])->tio, (speed_t )15);
#line 3940
  cfsetispeed(& (r->vts[page])->tio, (speed_t )15);
#line 3940
  tcsetattr(0, 0, (struct termios  const  *)(& (r->vts[page])->tio));
  }
#line 3942
  if ((unsigned long )r->Options[(1UL << 2) & 3UL] & ((1UL << 2) & 0xfffffffffffffffcUL)) {
    {
#line 3946
    on = 1U;
#line 3947
    ioctl(0, 21533UL, & on);
    }
  }
  {
#line 3960
  rxvt_tt_winsize(0, r->TermWin.ncol, r->TermWin.nrow, 0);
  }
#line 3964
  if ((unsigned long )((void *)0) != (unsigned long )argv) {
#line 3967
    i = 0;
    {
#line 3967
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3967
      if (! *(argv + i)) {
#line 3967
        goto while_break;
      }
#line 3967
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3969
    execvp(*(argv + 0), (char * const  *)argv);
    }
  } else {
    {
#line 3976
    tmp___1 = getenv("SHELL");
#line 3976
    shell = (char const   *)tmp___1;
    }
#line 3976
    if ((unsigned long )((void *)0) == (unsigned long )shell) {
#line 3976
      goto _L;
    } else
#line 3976
    if (0 == (int )*shell) {
      _L: /* CIL Label */ 
      {
#line 3979
      tmp = getuid();
#line 3979
      tmp___0 = getpwuid(tmp);
#line 3979
      pwent = tmp___0;
      }
#line 3981
      if ((unsigned long )((void *)0) == (unsigned long )pwent) {
#line 3986
        shell = "/bin/sh";
      } else {
#line 3981
        shell = (char const   *)pwent->pw_shell;
#line 3981
        if ((unsigned long )((void *)0) == (unsigned long )shell) {
#line 3986
          shell = "/bin/sh";
        } else
#line 3981
        if (0 == (int )*shell) {
#line 3986
          shell = "/bin/sh";
        }
      }
    }
    {
#line 3989
    tmp___2 = rxvt_r_basename(shell);
#line 3989
    argv0 = (char const   *)tmp___2;
    }
#line 3990
    if ((unsigned long )r->Options[(1UL << 3) & 3UL] & ((1UL << 3) & 0xfffffffffffffffcUL)) {
      {
#line 3992
      tmp___3 = strlen(argv0);
#line 3992
      l = (int )(tmp___3 + 2UL);
      }
#line 3993
      if (l <= 0) {
#line 3994
        l = 4096;
      } else
#line 3993
      if (l > 4096) {
#line 3994
        l = 4096;
      }
      {
#line 3995
      tmp___4 = rxvt_malloc((unsigned long )l * sizeof(char ));
#line 3995
      login___0 = (char *)tmp___4;
#line 3997
      *(login___0 + 0) = (char )'-';
#line 3998
      strncpy((char */* __restrict  */)(login___0 + 1), (char const   */* __restrict  */)argv0,
              (size_t )(l - 2));
#line 3999
      *(login___0 + (l - 1)) = (char)0;
#line 4000
      argv0 = (char const   *)login___0;
      }
    }
    {
#line 4002
    execlp(shell, argv0, (void *)0);
    }
  }
#line 4060
  return (-1);
}
}
#line 4068 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/init.c"
void rxvt_get_ttymode(ttymode_t *tio , int erase ) 
{ 
  int tmp ;

  {
  {
#line 4075
  tmp = tcgetattr(0, tio);
  }
#line 4075
  if (tmp < 0) {
#line 4078
    tio->c_cc[0] = (cc_t )3;
#line 4079
    tio->c_cc[1] = (cc_t )28;
#line 4080
    tio->c_cc[2] = (cc_t )127;
#line 4081
    tio->c_cc[3] = (cc_t )21;
#line 4082
    tio->c_cc[8] = (cc_t )17;
#line 4083
    tio->c_cc[9] = (cc_t )19;
#line 4084
    tio->c_cc[10] = (cc_t )26;
#line 4089
    tio->c_cc[12] = (cc_t )18;
#line 4092
    tio->c_cc[13] = (cc_t )15;
#line 4095
    tio->c_cc[14] = (cc_t )23;
#line 4098
    tio->c_cc[15] = (cc_t )22;
  }
#line 4101
  tio->c_cc[4] = (cc_t )4;
#line 4102
  tio->c_cc[11] = (cc_t )'\000';
#line 4104
  tio->c_cc[16] = (cc_t )'\000';
#line 4107
  tio->c_cc[7] = (cc_t )'\000';
#line 4113
  tio->c_cc[6] = (cc_t )1;
#line 4116
  tio->c_cc[5] = (cc_t )0;
#line 4118
  if (erase != -1) {
#line 4119
    tio->c_cc[2] = (cc_t )((char )erase);
  }
#line 4122
  tio->c_iflag = (tcflag_t )9478;
#line 4129
  tio->c_oflag = (tcflag_t )5;
#line 4132
  tio->c_cflag = (tcflag_t )176;
#line 4135
  tio->c_lflag = (tcflag_t )35387;
#line 4264
  return;
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 291 "/usr/include/X11/ICE/ICElib.h"
extern void IceSetShutdownNegotiation(IceConn  , int  ) ;
#line 300
extern IceCloseStatus IceCloseConnection(IceConn  ) ;
#line 304
extern int IceAddConnectionWatch(void (*)(IceConn  , IcePointer  , int  , IcePointer * ) ,
                                 IcePointer  ) ;
#line 332
extern IceProcessMessagesStatus IceProcessMessages(IceConn  , IceReplyWaitInfo * ,
                                                   int * ) ;
#line 381
extern int IceConnectionNumber(IceConn  ) ;
#line 405
extern IceIOErrorHandler IceSetIOErrorHandler(void (*)(IceConn  ) ) ;
#line 348 "/usr/include/X11/SM/SMlib.h"
extern SmcConn SmcOpenConnection(char * , SmPointer  , int  , int  , unsigned long  ,
                                 SmcCallbacks * , char * , char ** , int  , char * ) ;
#line 361
extern SmcCloseStatus SmcCloseConnection(SmcConn  , int  , char ** ) ;
#line 373
extern void SmcSetProperties(SmcConn  , int  , SmProp ** ) ;
#line 418
extern void SmcSaveYourselfDone(SmcConn  , int  ) ;
#line 467 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_session_exit(rxvt_t *r ) ;
#line 36 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void callback_die(SmcConn smc_conn , SmPointer client_data ) ;
#line 37
static void fetch_window_position(rxvt_t *r , int *px , int *py ) ;
#line 38
static void callback_save_yourself(SmcConn smc_conn , SmPointer client_data , int save_style ,
                                   int shutdown___0 , int interact_style , int fast ) ;
#line 39
static void callback_shutdown_cancelled(SmcConn smc_conn , SmPointer client_data ) ;
#line 40
static void callback_save_complete(SmcConn smc_conn , SmPointer client_data ) ;
#line 41
static void ice_io_error_handler(IceConn connection ) ;
#line 42
static void ice_connection_watch(IceConn connection , IcePointer client_data , int opening ,
                                 IcePointer *watch_data ) ;
#line 48 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void callback_die(SmcConn smc_conn , SmPointer client_data ) 
{ 
  rxvt_t *r ;
  rxvt_t *tmp ;

  {
  {
#line 51
  tmp = rxvt_get_r();
#line 51
  r = tmp;
  }
#line 55
  if ((unsigned long )((void *)0) != (unsigned long )smc_conn) {
    {
#line 56
    SmcCloseConnection(smc_conn, 0, (char **)((void *)0));
#line 57
    r->TermWin.sm_conn = (SmcConn )((void *)0);
    }
  }
#line 59
  return;
}
}
#line 63 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void fetch_window_position(rxvt_t *r , int *px , int *py ) 
{ 
  int k ;
  unsigned int n ;
  Window wintree[6] ;
  Window root ;
  Window *list ;
  XWindowAttributes attr ;

  {
#line 76
  *px = r->szHint.x;
#line 77
  *py = r->szHint.y;
#line 83
  wintree[0] = r->TermWin.parent;
#line 84
  k = 1;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (k < 6)) {
#line 84
      goto while_break;
    }
    {
#line 85
    XQueryTree(r->Xdisplay, wintree[k - 1], & root, & wintree[k], & list, & n);
#line 87
    XFree((void *)list);
    }
#line 88
    if (wintree[k] == (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root) {
#line 89
      goto while_break;
    }
#line 84
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  if (6 == k) {
#line 93
    return;
  } else
#line 92
  if (1 == k) {
#line 93
    return;
  }
  {
#line 94
  k --;
#line 95
  XGetWindowAttributes(r->Xdisplay, wintree[k], & attr);
#line 96
  *px = attr.x;
#line 97
  *py = attr.y;
  }
#line 98
  return;
}
}
#line 102 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void callback_save_yourself(SmcConn smc_conn , SmPointer client_data , int save_style ,
                                   int shutdown___0 , int interact_style , int fast ) 
{ 
  rxvt_t *r ;
  rxvt_t *tmp ;
  struct __anonstruct_vals_376 vals ;
  SmProp prop[6] ;
  SmProp *props[6] ;
  char priority ;
  char restart_style ;
  struct passwd *pw ;
  int n ;
  int i ;
  char initprof[495] ;
  char desktop[33] ;
  char geometry[132] ;
  int x ;
  int y ;
  char posx[33] ;
  char posy[33] ;
  size_t tmp___0 ;
  __uid_t tmp___1 ;
  size_t tmp___2 ;
  char tmpbuf[64] ;
  CARD32 tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;

  {
  {
#line 105
  tmp = rxvt_get_r();
#line 105
  r = tmp;
  }
#line 109
  if ((unsigned long )((void *)0) != (unsigned long )smc_conn) {
    {
#line 118
    prop[0].name = (char *)"Program";
#line 118
    prop[0].type = (char *)"ARRAY8";
#line 118
    prop[0].num_vals = 1;
#line 118
    prop[0].vals = vals.program;
#line 118
    prop[1].name = (char *)"UserID";
#line 118
    prop[1].type = (char *)"ARRAY8";
#line 118
    prop[1].num_vals = 1;
#line 118
    prop[1].vals = vals.user;
#line 118
    prop[2].name = (char *)"RestartStyleHint";
#line 118
    prop[2].type = (char *)"CARD8";
#line 118
    prop[2].num_vals = 1;
#line 118
    prop[2].vals = vals.hint;
#line 118
    prop[3].name = (char *)"_GSM_Priority";
#line 118
    prop[3].type = (char *)"CARD8";
#line 118
    prop[3].num_vals = 1;
#line 118
    prop[3].vals = vals.priority;
#line 118
    prop[4].name = (char *)"CloneCommand";
#line 118
    prop[4].type = (char *)"LISTofARRAY8";
#line 118
    prop[4].num_vals = 0;
#line 118
    prop[4].vals = vals.restart;
#line 118
    prop[5].name = (char *)"RestartCommand";
#line 118
    prop[5].type = (char *)"LISTofARRAY8";
#line 118
    prop[5].num_vals = 0;
#line 118
    prop[5].vals = vals.restart;
#line 127
    props[0] = & prop[0];
#line 127
    props[1] = & prop[1];
#line 127
    props[2] = & prop[2];
#line 127
    props[3] = & prop[3];
#line 127
    props[4] = & prop[4];
#line 127
    props[5] = & prop[5];
#line 136
    priority = (char)5;
#line 137
    restart_style = (char)0;
#line 138
    pw = (struct passwd *)((void *)0);
#line 139
    n = 0;
#line 147
    vals.program[0].value = (SmPointer )*(r->global_argv + 0);
#line 148
    tmp___0 = strlen((char const   *)vals.program[0].value);
#line 148
    vals.program[0].length = (int )tmp___0;
#line 151
    tmp___1 = getuid();
#line 151
    pw = getpwuid(tmp___1);
    }
#line 153
    if (pw) {
#line 153
      vals.user[0].value = (SmPointer )pw->pw_name;
    } else {
#line 153
      vals.user[0].value = (SmPointer )"";
    }
    {
#line 154
    tmp___2 = strlen((char const   *)vals.user[0].value);
#line 154
    vals.user[0].length = (int )tmp___2;
#line 156
    vals.hint[0].value = (SmPointer )(& restart_style);
#line 157
    vals.hint[0].length = 1;
#line 159
    vals.priority[0].value = (SmPointer )(& priority);
#line 160
    vals.priority[0].length = 1;
#line 163
    sprintf((char */* __restrict  */)(initprof), (char const   */* __restrict  */)"%d",
            (int )(r->vts[0])->profileNum);
#line 164
    i = 1;
    }
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;
#line 164
      if (! (i <= (int )r->tabBar.ltab)) {
#line 164
        goto while_break;
      }
      {
#line 166
      sprintf((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)",%d",
              (int )(r->vts[i])->profileNum);
#line 167
      strcat((char */* __restrict  */)(initprof), (char const   */* __restrict  */)((char const   *)(tmpbuf)));
#line 164
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 170
    tmp___3 = rxvt_get_desktop(r);
#line 170
    sprintf((char */* __restrict  */)(desktop), (char const   */* __restrict  */)"%d",
            (int )tmp___3);
#line 172
    sprintf((char */* __restrict  */)(geometry), (char const   */* __restrict  */)"%dx%d",
            (int )r->TermWin.ncol, (int )r->TermWin.nrow);
#line 174
    fetch_window_position(r, & x, & y);
    }
#line 175
    if (x >= 0) {
#line 175
      tmp___4 = "+%d";
    } else {
#line 175
      tmp___4 = "%d";
    }
    {
#line 175
    sprintf((char */* __restrict  */)(posx), (char const   */* __restrict  */)tmp___4,
            x);
    }
#line 176
    if (y >= 0) {
#line 176
      tmp___5 = "+%d";
    } else {
#line 176
      tmp___5 = "%d";
    }
    {
#line 176
    sprintf((char */* __restrict  */)(posy), (char const   */* __restrict  */)tmp___5,
            y);
#line 177
    strcat((char */* __restrict  */)(geometry), (char const   */* __restrict  */)((char const   *)(posx)));
#line 178
    strcat((char */* __restrict  */)(geometry), (char const   */* __restrict  */)((char const   *)(posy)));
#line 180
    tmp___6 = n;
#line 180
    n ++;
#line 180
    vals.restart[tmp___6].value = (SmPointer )*(r->global_argv + 0);
#line 181
    tmp___7 = n;
#line 181
    n ++;
#line 181
    vals.restart[tmp___7].value = (SmPointer )"-ip";
#line 182
    tmp___8 = n;
#line 182
    n ++;
#line 182
    vals.restart[tmp___8].value = (SmPointer )(initprof);
#line 183
    tmp___9 = n;
#line 183
    n ++;
#line 183
    vals.restart[tmp___9].value = (SmPointer )"-desktop";
#line 184
    tmp___10 = n;
#line 184
    n ++;
#line 184
    vals.restart[tmp___10].value = (SmPointer )(desktop);
#line 185
    tmp___11 = n;
#line 185
    n ++;
#line 185
    vals.restart[tmp___11].value = (SmPointer )"-geometry";
#line 186
    tmp___12 = n;
#line 186
    n ++;
#line 186
    vals.restart[tmp___12].value = (SmPointer )(geometry);
#line 192
    prop[4].num_vals = n;
#line 194
    tmp___13 = n;
#line 194
    n ++;
#line 194
    vals.restart[tmp___13].value = (SmPointer )"-sm";
#line 195
    tmp___14 = n;
#line 195
    n ++;
#line 195
    vals.restart[tmp___14].value = (SmPointer )"-sid";
#line 196
    tmp___15 = n;
#line 196
    n ++;
#line 196
    vals.restart[tmp___15].value = (SmPointer )r->TermWin.sm_client_id;
#line 198
    prop[5].num_vals = n;
#line 200
    i = 0;
    }
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (! (i < n)) {
#line 200
        goto while_break___0;
      }
      {
#line 201
      tmp___16 = strlen((char const   *)vals.restart[i].value);
#line 201
      vals.restart[i].length = (int )tmp___16;
#line 200
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 203
    SmcSetProperties(smc_conn, (int )(sizeof(props) / sizeof(SmProp *)), props);
#line 204
    SmcSaveYourselfDone(smc_conn, 1);
    }
  }
#line 206
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void callback_shutdown_cancelled(SmcConn smc_conn , SmPointer client_data ) 
{ 


  {
#line 215
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void callback_save_complete(SmcConn smc_conn , SmPointer client_data ) 
{ 


  {
#line 224
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void ice_io_error_handler(IceConn connection ) 
{ 


  {
#line 234
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
static void ice_connection_watch(IceConn connection , IcePointer client_data , int opening ,
                                 IcePointer *watch_data ) 
{ 
  rxvt_t *r ;
  rxvt_t *tmp ;

  {
  {
#line 241
  tmp = rxvt_get_r();
#line 241
  r = tmp;
  }
#line 243
  if (opening) {
    {
#line 245
    r->TermWin.ice_conn = connection;
#line 246
    r->TermWin.ice_fd = IceConnectionNumber(connection);
    }
#line 249
    if (-1 != r->TermWin.ice_fd) {
      {
#line 250
      fcntl(r->TermWin.ice_fd, 2, 1);
      }
    }
  } else {
#line 254
    r->TermWin.ice_conn = (IceConn )((void *)0);
#line 255
    r->TermWin.ice_fd = -1;
  }
#line 257
  return;
}
}
#line 261 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
void rxvt_process_ice_msgs(rxvt_t *r ) 
{ 
  IceProcessMessagesStatus status ;

  {
  {
#line 269
  status = IceProcessMessages(r->TermWin.ice_conn, (IceReplyWaitInfo *)((void *)0),
                              (int *)((void *)0));
  }
#line 271
  if ((unsigned int )status == 1U) {
    {
#line 274
    IceSetShutdownNegotiation(r->TermWin.ice_conn, 0);
#line 275
    IceCloseConnection(r->TermWin.ice_conn);
    }
  }
#line 277
  return;
}
}
#line 281 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
void rxvt_session_init(rxvt_t *r ) 
{ 
  SmcCallbacks callbacks ;
  char error_string_ret[4096] ;
  unsigned int tmp ;
  char *client_id ;
  char *prev_client_id ;
  char *tmp___0 ;

  {
#line 285
  error_string_ret[0] = (char )'\000';
#line 285
  tmp = 1U;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (tmp >= 4096U) {
#line 285
      goto while_break;
    }
#line 285
    error_string_ret[tmp] = (char)0;
#line 285
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  client_id = (char *)((void *)0);
#line 290
  rxvt_msg((uint32_t )3, (uint32_t )65536, "SessionMgr: init\n");
  }
#line 292
  if ((unsigned long )((void *)0) != (unsigned long )r->TermWin.sm_conn) {
    {
#line 293
    rxvt_msg((uint32_t )3, (uint32_t )65536, "SessionMgr: duplicate session init\n");
    }
#line 294
    return;
  }
  {
#line 297
  tmp___0 = getenv("SESSION_MANAGER");
  }
#line 297
  if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
    {
#line 298
    rxvt_msg((uint32_t )3, (uint32_t )65536, "SessionMgr: session manager is not running\n");
    }
#line 299
    return;
  }
  {
#line 303
  IceSetIOErrorHandler(& ice_io_error_handler);
#line 304
  IceAddConnectionWatch(& ice_connection_watch, (void *)0);
#line 307
  callbacks.save_yourself.callback = & callback_save_yourself;
#line 308
  callbacks.die.callback = & callback_die;
#line 309
  callbacks.save_complete.callback = & callback_save_complete;
#line 310
  callbacks.shutdown_cancelled.callback = & callback_shutdown_cancelled;
#line 311
  callbacks.shutdown_cancelled.client_data = (void *)0;
#line 311
  callbacks.save_complete.client_data = callbacks.shutdown_cancelled.client_data;
#line 311
  callbacks.die.client_data = callbacks.save_complete.client_data;
#line 311
  callbacks.save_yourself.client_data = callbacks.die.client_data;
#line 317
  prev_client_id = (char *)(r->h)->rs[331];
#line 319
  r->TermWin.sm_conn = SmcOpenConnection((char *)((void *)0), (void *)0, 1, 0, (unsigned long )(((1L | (1L << 2)) | (1L << 1)) | (1L << 3)),
                                         & callbacks, prev_client_id, & client_id,
                                         (int )sizeof(error_string_ret), error_string_ret);
  }
#line 326
  if ((unsigned long )((void *)0) == (unsigned long )r->TermWin.sm_conn) {
#line 328
    return;
  }
#line 331
  if ((unsigned long )((void *)0) == (unsigned long )client_id) {
    {
#line 333
    r->TermWin.sm_client_id = strdup((char const   *)prev_client_id);
    }
  } else {
    {
#line 336
    r->TermWin.sm_client_id = strdup((char const   *)client_id);
#line 337
    rxvt_free((void *)client_id);
    }
  }
#line 339
  return;
}
}
#line 343 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/session.c"
void rxvt_session_exit(rxvt_t *r ) 
{ 


  {
  {
#line 346
  rxvt_msg((uint32_t )3, (uint32_t )65536, "SessionMgr: exit\n");
  }
#line 348
  if ((unsigned long )((void *)0) == (unsigned long )r->TermWin.sm_conn) {
#line 349
    return;
  }
  {
#line 351
  SmcCloseConnection(r->TermWin.sm_conn, 0, (char **)((void *)0));
#line 352
  r->TermWin.sm_conn = (SmcConn )((void *)0);
  }
#line 353
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 473 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_parse_dbg_arguments(int argc , char const   * const  *argv ) ;
#line 27 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
uint32_t g_dbg_mask  =    (uint32_t )0L;
#line 28 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
uint32_t g_dbg_level  =    (uint32_t )1;
#line 31 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
static char const   *dbg_level_name[6]  = {      "FATAL",      "ERROR",      "WARN",      "INFO", 
        "VERBOSE",      "DEBUG"};
#line 41 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
static char const   *dbg_mask_name[21]  = 
#line 41
  {      "COMMAND",      "SCREEN",      "PTYTTY",      "INIT", 
        "MAIN",      "LOGGING",      "MACROS",      "MENUBAR", 
        "TABBAR",      "SCROLLBAR",      "IMAGES",      "PIXMAP", 
        "TRANSPARENT",      "ENCODING",      "GKRELOT",      "MEMORY", 
        "SESSION",      "STRING",      "RESOURCE",      "XFTACS", 
        "MISC"};
#line 66 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
static dbgmask_t dbg_mask_map[21]  = 
#line 66
  {      (dbgmask_t )1,      (dbgmask_t )2,      (dbgmask_t )4,      (dbgmask_t )8, 
        (dbgmask_t )16,      (dbgmask_t )32,      (dbgmask_t )64,      (dbgmask_t )128, 
        (dbgmask_t )256,      (dbgmask_t )512,      (dbgmask_t )1024,      (dbgmask_t )2048, 
        (dbgmask_t )4096,      (dbgmask_t )8192,      (dbgmask_t )16384,      (dbgmask_t )32768, 
        (dbgmask_t )65536,      (dbgmask_t )131072,      (dbgmask_t )262144,      (dbgmask_t )524288, 
        (dbgmask_t )1048576};
#line 94 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
int rxvt_msg(uint32_t level , uint32_t mask , char const   *fmt  , ...) 
{ 
  int len ;
  va_list ap ;
  size_t tmp ;

  {
#line 99
  if (level <= 1U) {
#line 99
    goto _L;
  } else
#line 99
  if (g_dbg_level >= level) {
#line 99
    if (mask & g_dbg_mask) {
      _L: /* CIL Label */ 
      {
#line 106
      __builtin_va_start(ap, fmt);
#line 107
      len = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
                     ap);
#line 108
      __builtin_va_end(ap);
#line 111
      tmp = strlen(fmt);
      }
#line 111
      if ((int const   )*(fmt + (tmp - 1UL)) != 10) {
        {
#line 113
        fputc('\n', stderr);
#line 114
        len ++;
        }
      }
#line 116
      return (len);
    }
  }
#line 118
  return (0);
}
}
#line 123 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
static int rxvt_dbg_parse_masks(char const   *maskstring ) 
{ 
  int mask ;
  char const   *ptr ;
  char const   *pcoma ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 126
  mask = 0;
#line 129
  if (48 == (int )*(maskstring + 0)) {
#line 129
    if (120 == (int )*(maskstring + 1)) {
#line 129
      goto _L___21;
    } else
#line 129
    if (88 == (int )*(maskstring + 1)) {
      _L___21: /* CIL Label */ 
#line 132
      ptr = maskstring + 2;
      {
#line 132
      while (1) {
        while_continue: /* CIL Label */ ;
#line 132
        if (! *ptr) {
#line 132
          goto while_break;
        }
#line 134
        if ((int const   )*ptr < 48) {
#line 135
          return (0);
        } else
#line 134
        if ((int const   )*ptr > 57) {
#line 135
          return (0);
        }
#line 136
        mask = (mask << 4) + (int )((int const   )*ptr - 48);
#line 132
        ptr ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 138
      if (ptr - maskstring > 32L) {
#line 139
        return (0);
      }
    } else {
#line 129
      goto _L___20;
    }
  } else {
    _L___20: /* CIL Label */ 
#line 146
    pcoma = maskstring;
#line 146
    ptr = pcoma;
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 150
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 150
        if (*pcoma) {
#line 150
          if (! (44 != (int )*pcoma)) {
#line 150
            goto while_break___1;
          }
        } else {
#line 150
          goto while_break___1;
        }
#line 151
        pcoma ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 153
      len = (int )(pcoma - ptr);
#line 154
      if (0 == len) {
#line 155
        return (0);
      }
#line 157
      if ((unsigned long )len == sizeof("COMMAND") - 1UL) {
        {
#line 157
        tmp___20 = strncasecmp(dbg_mask_name[0], ptr, (size_t )len);
        }
#line 157
        if (0 == tmp___20) {
#line 159
          mask |= 1;
        } else {
#line 157
          goto _L___19;
        }
      } else
      _L___19: /* CIL Label */ 
#line 160
      if ((unsigned long )len == sizeof("SCREEN") - 1UL) {
        {
#line 160
        tmp___19 = strncasecmp(dbg_mask_name[1], ptr, (size_t )len);
        }
#line 160
        if (0 == tmp___19) {
#line 162
          mask |= 2;
        } else {
#line 160
          goto _L___18;
        }
      } else
      _L___18: /* CIL Label */ 
#line 163
      if ((unsigned long )len == sizeof("PTYTTY") - 1UL) {
        {
#line 163
        tmp___18 = strncasecmp(dbg_mask_name[2], ptr, (size_t )len);
        }
#line 163
        if (0 == tmp___18) {
#line 165
          mask |= 4;
        } else {
#line 163
          goto _L___17;
        }
      } else
      _L___17: /* CIL Label */ 
#line 166
      if ((unsigned long )len == sizeof("INIT") - 1UL) {
        {
#line 166
        tmp___17 = strncasecmp(dbg_mask_name[3], ptr, (size_t )len);
        }
#line 166
        if (0 == tmp___17) {
#line 168
          mask |= 8;
        } else {
#line 166
          goto _L___16;
        }
      } else
      _L___16: /* CIL Label */ 
#line 169
      if ((unsigned long )len == sizeof("MAIN") - 1UL) {
        {
#line 169
        tmp___16 = strncasecmp(dbg_mask_name[4], ptr, (size_t )len);
        }
#line 169
        if (0 == tmp___16) {
#line 171
          mask |= 16;
        } else {
#line 169
          goto _L___15;
        }
      } else
      _L___15: /* CIL Label */ 
#line 172
      if ((unsigned long )len == sizeof("LOGGING") - 1UL) {
        {
#line 172
        tmp___15 = strncasecmp(dbg_mask_name[5], ptr, (size_t )len);
        }
#line 172
        if (0 == tmp___15) {
#line 174
          mask |= 32;
        } else {
#line 172
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 175
      if ((unsigned long )len == sizeof("MACROS") - 1UL) {
        {
#line 175
        tmp___14 = strncasecmp(dbg_mask_name[6], ptr, (size_t )len);
        }
#line 175
        if (0 == tmp___14) {
#line 177
          mask |= 64;
        } else {
#line 175
          goto _L___13;
        }
      } else
      _L___13: /* CIL Label */ 
#line 178
      if ((unsigned long )len == sizeof("MENUBAR") - 1UL) {
        {
#line 178
        tmp___13 = strncasecmp(dbg_mask_name[7], ptr, (size_t )len);
        }
#line 178
        if (0 == tmp___13) {
#line 180
          mask |= 128;
        } else {
#line 178
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 181
      if ((unsigned long )len == sizeof("TABBAR") - 1UL) {
        {
#line 181
        tmp___12 = strncasecmp(dbg_mask_name[8], ptr, (size_t )len);
        }
#line 181
        if (0 == tmp___12) {
#line 183
          mask |= 256;
        } else {
#line 181
          goto _L___11;
        }
      } else
      _L___11: /* CIL Label */ 
#line 184
      if ((unsigned long )len == sizeof("SCROLLBAR") - 1UL) {
        {
#line 184
        tmp___11 = strncasecmp(dbg_mask_name[9], ptr, (size_t )len);
        }
#line 184
        if (0 == tmp___11) {
#line 186
          mask |= 512;
        } else {
#line 184
          goto _L___10;
        }
      } else
      _L___10: /* CIL Label */ 
#line 187
      if ((unsigned long )len == sizeof("IMAGES") - 1UL) {
        {
#line 187
        tmp___10 = strncasecmp(dbg_mask_name[10], ptr, (size_t )len);
        }
#line 187
        if (0 == tmp___10) {
#line 189
          mask |= 1024;
        } else {
#line 187
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 190
      if ((unsigned long )len == sizeof("PIXMAP") - 1UL) {
        {
#line 190
        tmp___9 = strncasecmp(dbg_mask_name[11], ptr, (size_t )len);
        }
#line 190
        if (0 == tmp___9) {
#line 192
          mask |= 2048;
        } else {
#line 190
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 193
      if ((unsigned long )len == sizeof("TRANSPARENT") - 1UL) {
        {
#line 193
        tmp___8 = strncasecmp(dbg_mask_name[12], ptr, (size_t )len);
        }
#line 193
        if (0 == tmp___8) {
#line 195
          mask |= 4096;
        } else {
#line 193
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 196
      if ((unsigned long )len == sizeof("ENCODING") - 1UL) {
        {
#line 196
        tmp___7 = strncasecmp(dbg_mask_name[13], ptr, (size_t )len);
        }
#line 196
        if (0 == tmp___7) {
#line 198
          mask |= 8192;
        } else {
#line 196
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 199
      if ((unsigned long )len == sizeof("GKRELOT") - 1UL) {
        {
#line 199
        tmp___6 = strncasecmp(dbg_mask_name[14], ptr, (size_t )len);
        }
#line 199
        if (0 == tmp___6) {
#line 201
          mask |= 16384;
        } else {
#line 199
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 202
      if ((unsigned long )len == sizeof("MEMORY") - 1UL) {
        {
#line 202
        tmp___5 = strncasecmp(dbg_mask_name[15], ptr, (size_t )len);
        }
#line 202
        if (0 == tmp___5) {
#line 204
          mask |= 32768;
        } else {
#line 202
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 205
      if ((unsigned long )len == sizeof("SESSION") - 1UL) {
        {
#line 205
        tmp___4 = strncasecmp(dbg_mask_name[16], ptr, (size_t )len);
        }
#line 205
        if (0 == tmp___4) {
#line 207
          mask |= 65536;
        } else {
#line 205
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 208
      if ((unsigned long )len == sizeof("STRING") - 1UL) {
        {
#line 208
        tmp___3 = strncasecmp(dbg_mask_name[17], ptr, (size_t )len);
        }
#line 208
        if (0 == tmp___3) {
#line 210
          mask |= 131072;
        } else {
#line 208
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 211
      if ((unsigned long )len == sizeof("RESOURCE") - 1UL) {
        {
#line 211
        tmp___2 = strncasecmp(dbg_mask_name[18], ptr, (size_t )len);
        }
#line 211
        if (0 == tmp___2) {
#line 213
          mask |= 262144;
        } else {
#line 211
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 214
      if ((unsigned long )len == sizeof("XFTACS") - 1UL) {
        {
#line 214
        tmp___1 = strncasecmp(dbg_mask_name[19], ptr, (size_t )len);
        }
#line 214
        if (0 == tmp___1) {
#line 216
          mask |= 524288;
        } else {
#line 214
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 217
      if ((unsigned long )len == sizeof("MISC") - 1UL) {
        {
#line 217
        tmp___0 = strncasecmp(dbg_mask_name[20], ptr, (size_t )len);
        }
#line 217
        if (0 == tmp___0) {
#line 219
          mask |= 1048576;
        } else {
#line 217
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 220
      if ((unsigned long )len == sizeof("ALL") - 1UL) {
        {
#line 220
        tmp = strncasecmp("ALL", ptr, (size_t )len);
        }
#line 220
        if (0 == tmp) {
#line 222
          mask = (int )((unsigned int )mask | 4294967295U);
        } else {
          {
#line 225
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: unknown debug mask name %s\n",
                  ptr);
          }
#line 226
          return (0);
        }
      } else {
        {
#line 225
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: unknown debug mask name %s\n",
                ptr);
        }
#line 226
        return (0);
      }
#line 229
      if (! *pcoma) {
#line 230
        goto while_break___0;
      }
#line 232
      pcoma ++;
#line 233
      ptr = pcoma;
#line 148
      if (! *ptr) {
#line 148
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 238
  g_dbg_mask = (uint32_t )mask;
#line 239
  return (1);
}
}
#line 244 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
static int rxvt_dbg_parse_level(char const   *levelstring ) 
{ 
  int level ;
  int tmp ;

  {
#line 249
  if (0 == (int )*levelstring) {
#line 250
    return (0);
  }
#line 252
  if (48 <= (int )*levelstring) {
#line 252
    if ((int const   )*levelstring <= 57) {
      {
#line 253
      level = atoi(levelstring);
      }
    } else {
#line 252
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 256
    level = 0;
    {
#line 256
    while (1) {
      while_continue: /* CIL Label */ ;
#line 256
      if (! (level < 6)) {
#line 256
        goto while_break;
      }
      {
#line 257
      tmp = strcasecmp(dbg_level_name[level], levelstring);
      }
#line 257
      if (0 == tmp) {
#line 258
        goto while_break;
      }
#line 256
      level ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 260
  if (level < 0) {
#line 261
    return (0);
  } else
#line 260
  if (level >= 6) {
#line 261
    return (0);
  }
#line 263
  g_dbg_level = (uint32_t )level;
#line 265
  return (1);
}
}
#line 271 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
static void rxvt_dbg_usage(char const   *argv ) 
{ 
  int i ;

  {
  {
#line 276
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s -dm dbg_masks -dl dbg_level\n",
          argv);
#line 278
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Available debug masks values and their names are:\n");
#line 279
  i = 0;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < 21)) {
#line 279
      goto while_break;
    }
    {
#line 280
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        0x%08x : %s\n",
            (unsigned int )dbg_mask_map[i], dbg_mask_name[i]);
#line 279
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        0xffffffff : ALL\n");
#line 283
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    Available debug levels and their names are:\n");
#line 284
  i = 0;
  }
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 284
    if (! (i < 6)) {
#line 284
      goto while_break___0;
    }
    {
#line 285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %d : %s\n",
            i, dbg_level_name[i]);
#line 284
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 290 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/debug.c"
void rxvt_parse_dbg_arguments(int argc , char const   * const  *argv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 295
  i = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < argc - 1)) {
#line 295
      goto while_break;
    }
    {
#line 297
    tmp___0 = strcasecmp("-dmask", (char const   *)*(argv + i));
    }
#line 297
    if (0 == tmp___0) {
      {
#line 299
      tmp = rxvt_dbg_parse_masks((char const   *)*(argv + (i + 1)));
      }
#line 299
      if (! tmp) {
        {
#line 301
        rxvt_dbg_usage((char const   *)*(argv + 0));
#line 302
        exit(1);
        }
      }
#line 304
      i ++;
    }
    {
#line 307
    tmp___2 = strcasecmp("-dlevel", (char const   *)*(argv + i));
    }
#line 307
    if (0 == tmp___2) {
      {
#line 309
      tmp___1 = rxvt_dbg_parse_level((char const   *)*(argv + (i + 1)));
      }
#line 309
      if (! tmp___1) {
        {
#line 311
        rxvt_dbg_usage((char const   *)*(argv + 0));
#line 312
        exit(1);
        }
      }
#line 314
      i ++;
    }
#line 295
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return;
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 924 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) grantpt)(int __fd ) ;
#line 928
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 944
extern int getpt(void) ;
#line 38 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/ptytty.c"
int rxvt_get_pty(int *fd_tty , char **ttydev ) 
{ 
  int pfd ;
  char *ptr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *c1 ;
  char const   *c2 ;
  char pty_name[11] ;
  char tty_name[11] ;
  int tmp___2 ;

  {
  {
#line 43
  *ttydev = (char *)((void *)0);
#line 85
  pfd = getpt();
  }
#line 89
  if (pfd >= 0) {
    {
#line 92
    tmp___0 = grantpt(pfd);
    }
#line 92
    if (tmp___0 == 0) {
      {
#line 92
      tmp___1 = unlockpt(pfd);
      }
#line 92
      if (tmp___1 == 0) {
        {
#line 94
        tmp = ptsname(pfd);
#line 94
        ptr = tmp;
        }
#line 95
        if (ptr) {
          {
#line 96
          *ttydev = strdup((char const   *)ptr);
          }
        }
#line 97
        return (pfd);
      }
    }
    {
#line 99
    close(pfd);
    }
  }
#line 154
  pty_name[0] = (char )'/';
#line 154
  pty_name[1] = (char )'d';
#line 154
  pty_name[2] = (char )'e';
#line 154
  pty_name[3] = (char )'v';
#line 154
  pty_name[4] = (char )'/';
#line 154
  pty_name[5] = (char )'p';
#line 154
  pty_name[6] = (char )'t';
#line 154
  pty_name[7] = (char )'y';
#line 154
  pty_name[8] = (char )'?';
#line 154
  pty_name[9] = (char )'?';
#line 154
  pty_name[10] = (char )'\000';
#line 155
  tty_name[0] = (char )'/';
#line 155
  tty_name[1] = (char )'d';
#line 155
  tty_name[2] = (char )'e';
#line 155
  tty_name[3] = (char )'v';
#line 155
  tty_name[4] = (char )'/';
#line 155
  tty_name[5] = (char )'t';
#line 155
  tty_name[6] = (char )'t';
#line 155
  tty_name[7] = (char )'y';
#line 155
  tty_name[8] = (char )'?';
#line 155
  tty_name[9] = (char )'?';
#line 155
  tty_name[10] = (char )'\000';
#line 163
  c1 = "?";
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! *c1) {
#line 163
      goto while_break;
    }
#line 164
    tty_name[sizeof(pty_name) - 3UL] = (char )*c1;
#line 164
    pty_name[sizeof(pty_name) - 3UL] = tty_name[sizeof(pty_name) - 3UL];
#line 166
    c2 = "?";
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! *c2) {
#line 166
        goto while_break___0;
      }
      {
#line 167
      tty_name[sizeof(pty_name) - 2UL] = (char )*c2;
#line 167
      pty_name[sizeof(pty_name) - 2UL] = tty_name[sizeof(pty_name) - 2UL];
#line 169
      pfd = open((char const   *)(pty_name), 258, 0);
      }
#line 169
      if (pfd >= 0) {
        {
#line 170
        tmp___2 = access((char const   *)(tty_name), 6);
        }
#line 170
        if (tmp___2 == 0) {
          {
#line 171
          *ttydev = strdup((char const   *)(tty_name));
          }
#line 172
          return (pfd);
        }
        {
#line 174
        close(pfd);
        }
      }
#line 166
      c2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 163
    c1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (-1);
}
}
#line 188 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/ptytty.c"
int rxvt_get_tty(char const   *ttydev ) 
{ 
  int tmp ;

  {
  {
#line 191
  tmp = open(ttydev, 258, 0);
  }
#line 191
  return (tmp);
}
}
#line 199 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/ptytty.c"
int rxvt_control_tty(int fd_tty , char const   *ttydev ) 
{ 
  int fd ;

  {
  {
#line 208
  setsid();
#line 211
  setpgid(0, 0);
#line 217
  fd = open("/dev/tty", 258);
  }
#line 219
  if (fd >= 0) {
    {
#line 220
    ioctl(fd, 21538UL, (void *)0);
#line 221
    close(fd);
    }
  }
  {
#line 225
  fd = open("/dev/tty", 258);
  }
#line 227
  if (fd >= 0) {
    {
#line 228
    close(fd);
    }
  }
  {
#line 260
  fd = ioctl(fd_tty, 21518UL, (void *)0);
#line 272
  fd = open("/dev/tty", 1);
  }
#line 274
  if (fd < 0) {
#line 275
    return (-1);
  }
  {
#line 276
  close(fd);
  }
#line 281
  return (0);
}
}
#line 1109 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvtlib.h"
rxvt_t *rxvt_init(int argc , char const   * const  *argv ) ;
#line 32 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/rxvt.c"
int main(int argc , char const   * const  *argv ) 
{ 
  rxvt_t *rxvt_vars ;

  {
  {
#line 47
  rxvt_privileges('s');
#line 48
  rxvt_privileges(0);
#line 54
  rxvt_parse_dbg_arguments(argc, argv);
#line 61
  rxvt_vars = rxvt_init(argc, argv);
  }
#line 61
  if ((unsigned long )rxvt_vars == (unsigned long )((void *)0)) {
#line 62
    return (1);
  }
  {
#line 64
  rxvt_main_loop(rxvt_vars);
  }
#line 70
  return (0);
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 710
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) seteuid)(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2260
extern int XDestroySubwindows(Display * , Window  ) ;
#line 2545
extern int XFreeCursor(Display * , Cursor  ) ;
#line 2554
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 3072
extern int XRecolorCursor(Display * , Cursor  , XColor * , XColor * ) ;
#line 489 "/usr/include/X11/Xutil.h"
extern int XGetWMIconName(Display * , Window  , XTextProperty * ) ;
#line 495
extern int XGetWMName(Display * , Window  , XTextProperty * ) ;
#line 142 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_close_all_tabs(rxvt_t *r ) ;
#line 152
void rxvt_set_win_title(rxvt_t *r , Window win , char const   *str ) ;
#line 339
void rxvt_scrollbar_clean_exit(rxvt_t *r ) ;
#line 45 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_alarm_signal(int sig ) ;
#line 46
void rxvt_pre_show_init(rxvt_t *r ) ;
#line 48
void rxvt_free_hidden(rxvt_t *r ) ;
#line 49
void rxvt_font_up_down(rxvt_t *r , int n , int direction ) ;
#line 50
int rxvt_get_font_widest(XFontStruct *f ) ;
#line 51
void rxvt_set_colorfgbg(rxvt_t *r ) ;
#line 65
void rxvt_set_r(rxvt_t *r ) ;
#line 85 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
char const   **cmd_argv  ;
#line 93 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_pre_show_init(rxvt_t *r ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 100
  tmp = rxvt_malloc(sizeof(unsigned long ) * 272UL);
#line 100
  r->pixColorsFocus = (unsigned long *)tmp;
#line 101
  r->pixColors = r->pixColorsFocus;
  }
#line 117
  if (r->TermWin.fade) {
    {
#line 120
    tmp___0 = rxvt_malloc(sizeof(unsigned long ) * 272UL);
#line 120
    r->pixColorsUnfocus = (unsigned long *)tmp___0;
    }
  } else {
#line 134
    r->pixColorsUnfocus = (unsigned long *)((void *)0);
  }
#line 139
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
rxvt_t *rxvt_init(int argc , char const   * const  *argv ) 
{ 
  register int i ;
  register int itnum ;
  rxvt_t *r ;
  void *tmp ;
  int tmp___0 ;
  char *s ;
  int profile ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 151
  tmp = rxvt_calloc((size_t )1, sizeof(rxvt_t ));
#line 151
  r = (rxvt_t *)tmp;
#line 154
  rxvt_set_r(r);
#line 157
  tmp___0 = rxvt_init_vars(r);
  }
#line 157
  if (tmp___0 < 0) {
    {
#line 159
    rxvt_msg((uint32_t )1, (uint32_t )16, "Could not initialize.");
#line 160
    rxvt_free((void *)r);
    }
#line 161
    return ((rxvt_t *)((void *)0));
  }
  {
#line 165
  r->global_argc = argc;
#line 166
  r->global_argv = (char **)argv;
#line 168
  rxvt_init_secondary(r);
#line 169
  cmd_argv = rxvt_init_resources(r, argc, argv);
#line 171
  rxvt_pre_show_init(r);
#line 173
  rxvt_create_show_windows(r, argc, argv);
  }
#line 176
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
    {
#line 178
    XSelectInput(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->root,
                 1L << 22);
    }
  }
  {
#line 190
  rxvt_init_env(r);
#line 191
  rxvt_init_command(r);
#line 192
  rxvt_init_screen(r);
  }
#line 197
  if ((r->h)->rs[332]) {
#line 200
    s = (char *)(r->h)->rs[332];
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 204
      tmp___1 = atoi((char const   *)s);
#line 204
      profile = tmp___1;
#line 206
      rxvt_append_page(r, profile, (char const   *)((void *)0), (char const   *)((void *)0));
#line 208
      s = strchr((char const   *)s, ',');
#line 202
      tmp___2 = s;
#line 202
      s ++;
      }
#line 202
      if (! ((unsigned long )((void *)0) != (unsigned long )tmp___2)) {
#line 202
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 215
  if ((r->h)->rs[333]) {
    {
#line 217
    rxvt_msg((uint32_t )1, (uint32_t )16, "Option tnum is obsolete. Use --initProfileList instead");
#line 220
    itnum = atoi((r->h)->rs[333]);
    }
#line 221
    if (1 > itnum) {
#line 221
      itnum = 1;
    } else {
#line 221
      itnum = itnum;
    }
#line 222
    if (itnum < 15) {
#line 222
      itnum = itnum;
    } else {
#line 222
      itnum = 15;
    }
#line 224
    i = 0;
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 224
      if (! (i < itnum)) {
#line 224
        goto while_break___0;
      }
#line 225
      if (i < 5) {
#line 225
        tmp___3 = i;
      } else {
#line 225
        tmp___3 = 0;
      }
      {
#line 225
      rxvt_append_page(r, tmp___3, (char const   *)((void *)0), (char const   *)((void *)0));
#line 224
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 230
    rxvt_append_page(r, 0, (char const   *)((void *)0), (char const   *)((void *)0));
    }
  }
  {
#line 233
  rxvt_activate_page(r, (short)0);
#line 236
  rxvt_init_xlocale(r);
  }
#line 238
  return (r);
}
}
#line 249 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_Child_signal(int sig ) 
{ 
  rxvt_t *r ;

  {
  {
#line 261
  r = rxvt_get_r();
#line 262
  r->ndead_childs = (short )((int )r->ndead_childs + 1);
  }
#line 265
  return;
}
}
#line 272 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_Exit_signal(int sig ) 
{ 
  register int i ;
  rxvt_t *r ;

  {
  {
#line 280
  rxvt_msg((uint32_t )3, (uint32_t )16, "Received signal %d\n", sig);
#line 282
  r = rxvt_get_r();
#line 285
  i = 0;
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i <= (int )r->tabBar.ltab)) {
#line 285
      goto while_break;
    }
    {
#line 287
    rxvt_privileges('r');
#line 288
    rxvt_cleanutent(r, i);
#line 289
    rxvt_privileges(0);
#line 285
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  rxvt_close_all_tabs(r);
  }
#line 296
  return;
}
}
#line 299 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_alarm_signal(int sig ) 
{ 
  int i ;
  rxvt_t *r ;
  rxvt_t *tmp ;
  int tmp___0 ;

  {
  {
#line 303
  tmp = rxvt_get_r();
#line 303
  r = tmp;
  }
#line 305
  if ((int )r->tabBar.ltab >= 0) {
    {
#line 307
    rxvt_msg((uint32_t )2, (uint32_t )16, "mrxvt: WARNING Processes ");
#line 308
    i = 0;
    }
    {
#line 308
    while (1) {
      while_continue: /* CIL Label */ ;
#line 308
      if (! (i <= (int )r->tabBar.ltab)) {
#line 308
        goto while_break;
      }
#line 309
      if (i == (int )r->tabBar.ltab) {
#line 309
        tmp___0 = ' ';
      } else {
#line 309
        tmp___0 = ',';
      }
      {
#line 309
      rxvt_msg((uint32_t )2, (uint32_t )16, "%d%c", (r->vts[i])->cmd_pid, tmp___0);
#line 308
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 311
    rxvt_msg((uint32_t )2, (uint32_t )16, " have not responded to SIGHUP, and are still running. Either \'kill -9\' these processes or close the mrxvt window again within 3 seconds.\n");
    }
  }
#line 316
  return;
}
}
#line 320 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_free_hidden(rxvt_t *r ) 
{ 


  {
#line 345
  return;
}
}
#line 353 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_exit_request(rxvt_t *r ) 
{ 
  int tmp ;
  int tmp___0 ;
  int i ;
  int dontExit ;

  {
#line 357
  if ((int )r->tabBar.ltab > 0) {
    {
#line 357
    tmp___0 = rxvt_tabbar_visible(r);
    }
#line 357
    if (! tmp___0) {
      {
#line 359
      XBell(r->Xdisplay, 0);
#line 360
      tmp = rxvt_tabbar_show(r);
      }
#line 360
      if (tmp) {
        {
#line 360
        rxvt_resize_on_subwin(r, (resize_reason_t )3);
        }
      }
#line 361
      return;
    }
  }
#line 365
  if ((unsigned long )r->Options[((1UL << 2) | 1UL) & 3UL] & (((1UL << 2) | 1UL) & 0xfffffffffffffffcUL)) {
#line 367
    dontExit = 0;
#line 369
    i = 0;
    {
#line 369
    while (1) {
      while_continue: /* CIL Label */ ;
#line 369
      if (! (i <= (int )r->tabBar.ltab)) {
#line 369
        goto while_break;
      }
#line 371
      if ((int )(r->vts[i])->current_screen == 1) {
#line 373
        dontExit = 1;
#line 374
        if (i != (int )r->tabBar.atab) {
          {
#line 375
          rxvt_tabbar_highlight_tab(r, (short )i, 0);
          }
        }
      }
#line 369
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 379
    if (dontExit) {
      {
#line 381
      XBell(r->Xdisplay, 0);
      }
#line 382
      return;
    }
  }
  {
#line 386
  rxvt_close_all_tabs(r);
  }
#line 387
  return;
}
}
#line 409 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
static struct timeval lastRequest  =    {(__time_t )0, (__suseconds_t )0};
#line 406 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_close_all_tabs(rxvt_t *r ) 
{ 
  struct timeval now ;
  int i ;

  {
#line 413
  i = (int )r->tabBar.ltab;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (i >= 0)) {
#line 413
      goto while_break;
    }
#line 415
    if ((r->vts[i])->dead) {
      {
#line 416
      rxvt_remove_page(r, (short )i);
      }
    } else {
      {
#line 420
      (r->vts[i])->holdOption = (unsigned char)0;
#line 421
      kill((r->vts[i])->cmd_pid, 1);
      }
    }
#line 413
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
#line 426
  if (lastRequest.tv_sec != 0L) {
#line 426
    if (now.tv_sec - lastRequest.tv_sec < 5L) {
      {
#line 428
      rxvt_clean_exit(r);
      }
    } else {
      {
#line 432
      lastRequest = now;
#line 435
      signal(14, & rxvt_alarm_signal);
#line 436
      alarm(2U);
      }
    }
  } else {
    {
#line 432
    lastRequest = now;
#line 435
    signal(14, & rxvt_alarm_signal);
#line 436
    alarm(2U);
    }
  }
#line 438
  return;
}
}
#line 441 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_clean_exit(rxvt_t *r ) 
{ 


  {
#line 445
  if ((unsigned long )r->Options[((1UL << 23) | 1UL) & 3UL] & (((1UL << 23) | 1UL) & 0xfffffffffffffffcUL)) {
    {
#line 446
    rxvt_session_exit(r);
    }
  }
  {
#line 466
  rxvt_free_hidden(r);
  }
#line 469
  if (0UL != r->TermWin.parent) {
    {
#line 471
    XDestroySubwindows(r->Xdisplay, r->TermWin.parent);
#line 472
    XDestroyWindow(r->Xdisplay, r->TermWin.parent);
#line 473
    r->TermWin.parent = (Window )0L;
    }
  }
  {
#line 477
  rxvt_scrollbar_clean_exit(r);
#line 484
  rxvt_tabbar_clean_exit(r);
  }
#line 486
  if ((unsigned long )((void *)0) != (unsigned long )r->TermWin.font) {
    {
#line 487
    XFreeFont(r->Xdisplay, r->TermWin.font);
    }
  }
#line 489
  if ((unsigned long )((void *)0) != (unsigned long )r->TermWin.bfont) {
#line 489
    if ((unsigned long )r->TermWin.font != (unsigned long )r->TermWin.bfont) {
      {
#line 491
      XFreeFont(r->Xdisplay, r->TermWin.bfont);
#line 492
      r->TermWin.bfont = (XFontStruct *)((void *)0);
      }
    }
  }
#line 502
  r->TermWin.font = (XFontStruct *)((void *)0);
#line 552
  if (0UL != r->term_pointer) {
    {
#line 554
    XFreeCursor(r->Xdisplay, r->term_pointer);
#line 555
    r->term_pointer = (Cursor )0L;
    }
  }
#line 557
  if ((unsigned long )((GC )0) != (unsigned long )r->TermWin.gc) {
    {
#line 559
    XFreeGC(r->Xdisplay, r->TermWin.gc);
#line 560
    r->TermWin.gc = (GC )0L;
    }
  }
  {
#line 562
  XCloseDisplay(r->Xdisplay);
#line 563
  r->Xdisplay = (Display *)((void *)0);
  }
#line 566
  if (r->fifo_fd != -1) {
    {
#line 568
    close(r->fifo_fd);
#line 569
    r->fifo_fd = -1;
#line 571
    unlink((char const   *)r->fifo_name);
#line 572
    rxvt_free((void *)r->fifo_name);
#line 572
    r->fifo_name = (char *)((void *)0);
    }
  }
  {
#line 576
  rxvt_free((void *)r->tabstop);
#line 576
  r->tabstop = (char *)((void *)0);
#line 577
  rxvt_free((void *)r->pixColorsFocus);
#line 577
  r->pixColorsFocus = (unsigned long *)((void *)0);
  }
#line 579
  if ((unsigned long )((void *)0) != (unsigned long )r->pixColorsUnfocus) {
    {
#line 581
    rxvt_free((void *)r->pixColorsUnfocus);
#line 582
    r->pixColorsUnfocus = (unsigned long *)((void *)0);
    }
  }
  {
#line 600
  rxvt_free((void *)r->h);
#line 600
  r->h = (struct rxvt_hidden *)((void *)0);
#line 601
  rxvt_free((void *)r);
#line 601
  r = (rxvt_t *)((void *)0);
#line 605
  exit(0);
  }
}
}
#line 614 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
static uid_t g_euid  ;
#line 615 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
static gid_t g_egid  ;
#line 620 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_privileges(int mode ) 
{ 
  __uid_t tmp ;
  __gid_t tmp___0 ;

  {
  {
#line 633
  if (mode == 0) {
#line 633
    goto case_0;
  }
#line 641
  if (mode == 115) {
#line 641
    goto case_115;
  }
#line 645
  if (mode == 114) {
#line 645
    goto case_114;
  }
#line 631
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 638
  tmp = getuid();
#line 638
  seteuid(tmp);
#line 639
  tmp___0 = getgid();
#line 639
  setegid(tmp___0);
  }
#line 640
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 642
  g_euid = geteuid();
#line 643
  g_egid = getegid();
  }
#line 644
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 646
  seteuid(g_euid);
#line 647
  setegid(g_egid);
  }
#line 648
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 666
  return;
}
}
#line 671 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_privileged_utmp(rxvt_t *r , int page , char action ) 
{ 
  __pid_t tmp ;

  {
  {
#line 674
  tmp = getpid();
#line 674
  rxvt_msg((uint32_t )3, (uint32_t )16, "rxvt_privileged_utmp %d (%c); waiting for: %c (pid: %d)\n",
           page, (int )action, (int )(r->vts[page])->next_utmp_action, tmp);
  }
#line 676
  if ((int )(r->vts[page])->next_utmp_action != (int )action) {
#line 681
    return;
  } else
#line 676
  if ((int )action != 115) {
#line 676
    if ((int )action != 114) {
#line 681
      return;
    } else {
#line 676
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 676
  if ((unsigned long )r->Options[(1UL << 9) & 3UL] & ((1UL << 9) & 0xfffffffffffffffcUL)) {
#line 681
    return;
  } else
#line 676
  if ((unsigned long )((void *)0) == (unsigned long )(r->vts[page])->ttydev) {
#line 681
    return;
  } else
#line 676
  if (0 == (int )*((r->vts[page])->ttydev)) {
#line 681
    return;
  }
  {
#line 683
  rxvt_privileges('r');
  }
#line 684
  if ((int )action == 115) {
    {
#line 686
    (r->vts[page])->next_utmp_action = (unsigned char )'r';
#line 687
    rxvt_makeutent(r, page, (char const   *)(r->vts[page])->ttydev, (r->h)->rs[0]);
    }
  } else {
    {
#line 692
    (r->vts[page])->next_utmp_action = (unsigned char)0;
#line 693
    rxvt_cleanutent(r, page);
    }
  }
  {
#line 695
  rxvt_privileges(0);
  }
#line 696
  return;
}
}
#line 763 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_tt_winsize(int fd , unsigned short col , unsigned short row , pid_t pid ) 
{ 
  struct winsize ws ;
  int tmp ;

  {
#line 775
  if (fd < 0) {
#line 776
    return;
  }
  {
#line 778
  ws.ws_col = col;
#line 779
  ws.ws_row = row;
#line 780
  ws.ws_ypixel = (unsigned short)0;
#line 780
  ws.ws_xpixel = ws.ws_ypixel;
#line 782
  tmp = ioctl(fd, 21524UL, & ws);
  }
#line 782
  if (! (tmp < 0)) {
#line 792
    if (pid) {
      {
#line 793
      kill(pid, 28);
      }
    }
  }
#line 795
  return;
}
}
#line 1474 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_init_font_x11(rxvt_t *r ) 
{ 
  char *msg ;
  XFontStruct *xfont ;
  XFontStruct *bfont ;
  int ckfont ;
  int fh ;
  int fw ;
  int idx ;
  int tmp ;

  {
  {
#line 1477
  msg = (char *)"can\'t load font \"%s\"\n";
#line 1483
  fh = 0;
#line 1483
  fw = 0;
#line 1484
  idx = 0;
#line 1500
  (r->h)->fnum = 0;
#line 1501
  idx = (r->h)->fnum % 6;
#line 1505
  xfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[280 + idx]);
  }
#line 1506
  if ((unsigned long )((void *)0) == (unsigned long )xfont) {
    {
#line 1509
    rxvt_msg((uint32_t )1, (uint32_t )16, (char const   *)msg, (r->h)->rs[280 + idx]);
#line 1512
    (r->h)->rs[280 + idx] = "fixed";
#line 1514
    xfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[280 + idx]);
    }
#line 1515
    if ((unsigned long )((void *)0) == (unsigned long )xfont) {
      {
#line 1518
      rxvt_msg((uint32_t )1, (uint32_t )16, (char const   *)msg, (r->h)->rs[280 + idx]);
      }
#line 1521
      goto Abort;
    }
  }
#line 1525
  if ((unsigned long )((void *)0) != (unsigned long )xfont) {
#line 1527
    r->TermWin.font = xfont;
  }
  {
#line 1532
  fw = rxvt_get_font_widest(r->TermWin.font);
#line 1533
  fh = (r->TermWin.font)->ascent + (r->TermWin.font)->descent;
#line 1535
  fh += (int )r->TermWin.lineSpace;
  }
#line 1538
  if (fw == (int )(r->TermWin.font)->min_bounds.width) {
#line 1540
    r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont & -2);
  } else {
#line 1543
    r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont | 1);
  }
#line 1546
  if (fw == (int )r->TermWin.fwidth) {
#line 1546
    if (fh == (int )r->TermWin.fheight) {
#line 1546
      tmp = 0;
    } else {
#line 1546
      tmp = 1;
    }
  } else {
#line 1546
    tmp = 1;
  }
#line 1546
  ckfont = tmp;
#line 1549
  r->TermWin.fwidth = (uint16_t )fw;
#line 1550
  r->TermWin.fheight = (uint16_t )fh;
#line 1558
  bfont = (XFontStruct *)((void *)0);
#line 1559
  if (ckfont) {
#line 1562
    if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[290 + idx]) {
      {
#line 1565
      bfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[290 + idx]);
      }
    }
#line 1568
    if ((unsigned long )((void *)0) != (unsigned long )bfont) {
      {
#line 1571
      fw = rxvt_get_font_widest(bfont);
#line 1572
      fh = bfont->ascent + bfont->descent;
#line 1574
      fh += (int )r->TermWin.lineSpace;
      }
#line 1576
      if (fw <= (int )r->TermWin.fwidth) {
#line 1576
        if (fh <= (int )r->TermWin.fheight) {
#line 1578
          r->TermWin.bfont = bfont;
#line 1579
          if (fw == (int )r->TermWin.fwidth) {
#line 1580
            r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont & ~ (1 << 1));
          } else {
#line 1582
            r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont | (1 << 1));
          }
        } else {
          {
#line 1586
          XFreeFont(r->Xdisplay, bfont);
          }
        }
      } else {
        {
#line 1586
        XFreeFont(r->Xdisplay, bfont);
        }
      }
    }
  }
#line 1623
  return;
  Abort: 
  {
#line 1626
  rxvt_msg((uint32_t )1, (uint32_t )16, "fatal error, aborting...");
#line 1627
  exit(1);
  }
}
}
#line 1858 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
int rxvt_change_font_x11(rxvt_t *r , char const   *fontname ) 
{ 
  char *msg ;
  XFontStruct *xfont ;
  XFontStruct *bfont ;
  int ckfont ;
  int fh ;
  int fw ;
  int idx ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *ptr ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1861
  msg = (char *)"can\'t load font \"%s\"";
#line 1867
  fh = 0;
#line 1867
  fw = 0;
#line 1868
  idx = 0;
  {
#line 1878
  if ((int const   )*(fontname + 0) == 35) {
#line 1878
    goto case_35;
  }
#line 1908
  goto switch_default___0;
  case_35: /* CIL Label */ 
  {
#line 1879
  idx = atoi(fontname + 1);
  }
  {
#line 1883
  if ((int const   )*(fontname + 1) == 43) {
#line 1883
    goto case_43;
  }
#line 1888
  if ((int const   )*(fontname + 1) == 45) {
#line 1888
    goto case_45;
  }
#line 1893
  goto switch_default;
  case_43: /* CIL Label */ 
#line 1884
  if (idx) {
#line 1884
    tmp = idx;
  } else {
#line 1884
    tmp = 1;
  }
#line 1884
  (r->h)->fnum += tmp;
#line 1885
  (r->h)->fnum %= 6;
#line 1886
  goto switch_break___0;
  case_45: /* CIL Label */ 
#line 1889
  if (idx) {
#line 1889
    tmp___0 = idx;
  } else {
#line 1889
    tmp___0 = -1;
  }
#line 1889
  (r->h)->fnum += tmp___0;
#line 1890
  (r->h)->fnum %= 6;
#line 1891
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1895
  if ((int const   )*(fontname + 1) != 0) {
    {
#line 1895
    tmp___1 = __ctype_b_loc();
    }
#line 1895
    if (! ((int const   )*(*tmp___1 + (int )*(fontname + 1)) & 2048)) {
#line 1897
      return (0);
    }
  }
#line 1902
  (r->h)->fnum = idx % 6;
#line 1903
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1905
  fontname = (char const   *)((void *)0);
#line 1906
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 1910
  idx = 0;
  {
#line 1910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1910
    if (! (idx < 6)) {
#line 1910
      goto while_break;
    }
    {
#line 1912
    tmp___2 = strcmp((r->h)->rs[280 + idx], fontname);
    }
#line 1912
    if (! tmp___2) {
#line 1914
      (r->h)->fnum = idx % 6;
#line 1915
      fontname = (char const   *)((void *)0);
#line 1916
      goto while_break;
    }
#line 1910
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1919
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1922
  if ((r->h)->fnum < 0) {
#line 1923
    (r->h)->fnum += - ((r->h)->fnum / 6 - 1) * 6;
  }
#line 1924
  idx = (r->h)->fnum % 6;
#line 1931
  if ((unsigned long )((void *)0) != (unsigned long )fontname) {
    {
#line 1933
    xfont = XLoadQueryFont(r->Xdisplay, fontname);
    }
#line 1934
    if (xfont) {
      {
#line 1937
      tmp___3 = strdup(fontname);
#line 1937
      ptr = tmp___3;
      }
#line 1938
      if (ptr) {
#line 1940
        if ((unsigned long )((void *)0) != (unsigned long )(r->h)->newfont[idx]) {
          {
#line 1941
          rxvt_free((void *)(r->h)->newfont[idx]);
          }
        }
#line 1942
        (r->h)->newfont[idx] = ptr;
#line 1943
        (r->h)->rs[280 + idx] = (char const   *)(r->h)->newfont[idx];
      }
      {
#line 1950
      XFreeFont(r->Xdisplay, xfont);
      }
    }
  }
  {
#line 1959
  xfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[280 + idx]);
  }
#line 1960
  if (! xfont) {
    {
#line 1963
    rxvt_msg((uint32_t )1, (uint32_t )16, (char const   *)msg, (r->h)->rs[280 + idx]);
#line 1966
    (r->h)->rs[280 + idx] = "fixed";
#line 1968
    xfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[280 + idx]);
    }
#line 1969
    if (! xfont) {
      {
#line 1972
      rxvt_msg((uint32_t )1, (uint32_t )16, (char const   *)msg, (r->h)->rs[280 + idx]);
      }
#line 1973
      return (0);
    }
  }
#line 1977
  if (xfont) {
#line 1983
    if (r->TermWin.font) {
      {
#line 1984
      XFreeFont(r->Xdisplay, r->TermWin.font);
      }
    }
#line 1985
    r->TermWin.font = xfont;
  }
  {
#line 1990
  fw = rxvt_get_font_widest(r->TermWin.font);
#line 1991
  fh = (r->TermWin.font)->ascent + (r->TermWin.font)->descent;
#line 1993
  fh += (int )r->TermWin.lineSpace;
  }
#line 1996
  if (fw == (int )(r->TermWin.font)->min_bounds.width) {
#line 1998
    r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont & -2);
  } else {
#line 2001
    r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont | 1);
  }
#line 2004
  if (fw == (int )r->TermWin.fwidth) {
#line 2004
    if (fh == (int )r->TermWin.fheight) {
#line 2004
      tmp___4 = 0;
    } else {
#line 2004
      tmp___4 = 1;
    }
  } else {
#line 2004
    tmp___4 = 1;
  }
#line 2004
  ckfont = tmp___4;
#line 2016
  r->TermWin.fwidth = (uint16_t )fw;
#line 2017
  r->TermWin.fheight = (uint16_t )fh;
#line 2022
  bfont = (XFontStruct *)((void *)0);
#line 2023
  if (ckfont) {
#line 2025
    if (r->TermWin.bfont) {
      {
#line 2026
      XFreeFont(r->Xdisplay, r->TermWin.bfont);
#line 2027
      r->TermWin.bfont = (XFontStruct *)((void *)0);
      }
    }
#line 2031
    if ((unsigned long )((void *)0) == (unsigned long )r->TermWin.bfont) {
#line 2031
      if ((unsigned long )((void *)0) != (unsigned long )(r->h)->rs[290 + idx]) {
        {
#line 2035
        bfont = XLoadQueryFont(r->Xdisplay, (r->h)->rs[290 + idx]);
        }
      }
    }
#line 2038
    if (bfont) {
      {
#line 2041
      fw = rxvt_get_font_widest(bfont);
#line 2042
      fh = bfont->ascent + bfont->descent;
#line 2044
      fh += (int )r->TermWin.lineSpace;
      }
#line 2046
      if (fw <= (int )r->TermWin.fwidth) {
#line 2046
        if (fh <= (int )r->TermWin.fheight) {
#line 2048
          r->TermWin.bfont = bfont;
#line 2049
          if (fw == (int )r->TermWin.fwidth) {
#line 2050
            r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont & -2);
          } else {
#line 2052
            r->TermWin.propfont = (uint16_t )((int )r->TermWin.propfont | 1);
          }
        } else {
          {
#line 2056
          XFreeFont(r->Xdisplay, bfont);
          }
        }
      } else {
        {
#line 2056
        XFreeFont(r->Xdisplay, bfont);
        }
      }
    }
  }
#line 2119
  return (1);
}
}
#line 2124 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_font_up_down(rxvt_t *r , int n , int direction ) 
{ 
  char const   *p ;
  int initial ;
  int j ;
  size_t tmp ;

  {
#line 2130
  j = 0;
  {
#line 2130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2130
    if (! (j < n)) {
#line 2130
      goto while_break;
    }
#line 2132
    initial = (r->h)->fnum;
    {
#line 2133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2135
      (r->h)->fnum += direction;
#line 2136
      if ((r->h)->fnum == 6) {
#line 2138
        (r->h)->fnum = initial;
#line 2139
        return;
      } else
#line 2136
      if ((r->h)->fnum == -1) {
#line 2138
        (r->h)->fnum = initial;
#line 2139
        return;
      }
#line 2141
      p = (r->h)->rs[280 + (r->h)->fnum % 6];
#line 2143
      if ((unsigned long )((void *)0) != (unsigned long )p) {
        {
#line 2143
        tmp = strlen(p);
        }
#line 2143
        if (tmp > 1UL) {
#line 2144
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2130
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2147
  return;
}
}
#line 2153 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
int rxvt_get_font_widest(XFontStruct *f ) 
{ 
  int i ;
  int cw ;
  int fw ;

  {
#line 2156
  fw = 0;
#line 2158
  if ((int )f->min_bounds.width == (int )f->max_bounds.width) {
#line 2159
    return ((int )f->min_bounds.width);
  }
#line 2160
  if ((unsigned long )((void *)0) == (unsigned long )f->per_char) {
#line 2161
    return ((int )f->max_bounds.width);
  }
#line 2162
  i = (int )(f->max_char_or_byte2 - f->min_char_or_byte2);
  {
#line 2162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2162
    i --;
#line 2162
    if (! (i >= 0)) {
#line 2162
      goto while_break;
    }
#line 2164
    cw = (int )(f->per_char + i)->width;
#line 2165
    if (cw > fw) {
#line 2165
      fw = cw;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2167
  return (fw);
}
}
#line 2174 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_utf8_property(rxvt_t *r , Atom prop , Window win , char const   *str ) 
{ 
  wchar_t *ws ;
  wchar_t *tmp ;
  char *s ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 2179
  tmp = rxvt_mbstowcs(str);
#line 2179
  ws = tmp;
#line 2180
  tmp___0 = rxvt_wcstoutf8((wchar_t const   *)ws);
#line 2180
  s = tmp___0;
#line 2182
  tmp___1 = strlen((char const   *)s);
#line 2182
  XChangeProperty(r->Xdisplay, win, prop, (r->h)->xa[1], 8, 0, (unsigned char const   *)((unsigned char *)s),
                  (int )tmp___1);
#line 2186
  rxvt_free((void *)s);
#line 2187
  rxvt_free((void *)ws);
  }
#line 2190
  return;
}
}
#line 2196 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_win_title(rxvt_t *r , Window win , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 2199
  tmp = strlen(str);
#line 2199
  XChangeProperty(r->Xdisplay, win, (Atom )39, (Atom )31, 8, 0, (unsigned char const   *)((unsigned char *)str),
                  (int )tmp);
#line 2203
  rxvt_set_utf8_property(r, (r->h)->xa[11], r->TermWin.parent, str);
  }
#line 2206
  return;
}
}
#line 2210 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_term_title(rxvt_t *r , unsigned char const   *str ) 
{ 
  XTextProperty prop ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2216
  tmp = XGetWMName(r->Xdisplay, r->TermWin.parent, & prop);
  }
#line 2216
  if (tmp == 0) {
#line 2217
    prop.value = (unsigned char *)((void *)0);
  }
#line 2218
  if ((unsigned long )((void *)0) == (unsigned long )prop.value) {
    {
#line 2221
    rxvt_set_win_title(r, r->TermWin.parent, (char const   *)((char *)str));
    }
  } else {
    {
#line 2218
    tmp___0 = strcmp((char const   *)prop.value, (char const   *)str);
    }
#line 2218
    if (tmp___0) {
      {
#line 2221
      rxvt_set_win_title(r, r->TermWin.parent, (char const   *)((char *)str));
      }
    }
  }
#line 2223
  return;
}
}
#line 2227 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_icon_name(rxvt_t *r , unsigned char const   *str ) 
{ 
  XTextProperty prop ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2233
  tmp = XGetWMIconName(r->Xdisplay, r->TermWin.parent, & prop);
  }
#line 2233
  if (tmp == 0) {
#line 2234
    prop.value = (unsigned char *)((void *)0);
  }
#line 2235
  if ((unsigned long )((void *)0) == (unsigned long )prop.value) {
    {
#line 2238
    tmp___0 = strlen((char const   *)str);
#line 2238
    XChangeProperty(r->Xdisplay, r->TermWin.parent, (Atom )37, (Atom )31, 8, 0, (unsigned char const   *)((unsigned char *)str),
                    (int )tmp___0);
#line 2242
    rxvt_set_utf8_property(r, (r->h)->xa[12], r->TermWin.parent, (char const   *)((char *)str));
    }
  } else {
    {
#line 2235
    tmp___1 = strcmp((char const   *)prop.value, (char const   *)str);
    }
#line 2235
    if (tmp___1) {
      {
#line 2238
      tmp___0 = strlen((char const   *)str);
#line 2238
      XChangeProperty(r->Xdisplay, r->TermWin.parent, (Atom )37, (Atom )31, 8, 0,
                      (unsigned char const   *)((unsigned char *)str), (int )tmp___0);
#line 2242
      rxvt_set_utf8_property(r, (r->h)->xa[12], r->TermWin.parent, (char const   *)((char *)str));
      }
    }
  }
#line 2246
  return;
}
}
#line 2251 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_window_color(rxvt_t *r , int page , int idx , char const   *color ) 
{ 
  XColor xcol ;
  int color_set ;
  register int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 2261
  if ((unsigned long )((void *)0) == (unsigned long )color) {
#line 2262
    return;
  } else
#line 2261
  if (0 == (int )*color) {
#line 2262
    return;
  }
  {
#line 2268
  rxvt_set_fgbg_colors(r, page);
#line 2270
  color_set = (int )((r->h)->pixcolor_set[idx / 32] & (unsigned int )(1 << idx % 32));
#line 2273
  tmp = __ctype_b_loc();
  }
#line 2273
  if ((int const   )*(*tmp + (int )*color) & 2048) {
    {
#line 2275
    i = atoi(color);
    }
#line 2276
    if (i >= 8) {
#line 2276
      if (i <= 15) {
        {
#line 2278
        i -= 8;
#line 2280
        rxvt_copy_color(r, idx, 10 + i);
        }
#line 2281
        goto Done;
      }
    }
#line 2284
    if (i >= 0) {
#line 2284
      if (i <= 7) {
        {
#line 2286
        rxvt_copy_color(r, idx, 2 + i);
        }
#line 2287
        goto Done;
      }
    }
  }
  {
#line 2291
  tmp___0 = rxvt_parse_alloc_color(r, & xcol, color);
  }
#line 2291
  if (! tmp___0) {
#line 2293
    return;
  }
  {
#line 2315
  rxvt_set_color(r, idx, (XColor const   *)(& xcol));
  }
  Done: 
#line 2318
  if (idx == 1) {
#line 2320
    (r->vts[page])->p_bg = *(r->pixColorsFocus + idx);
#line 2326
    if (r->TermWin.fade) {
#line 2328
      (r->vts[page])->p_bgfade = *(r->pixColorsUnfocus + idx);
    }
#line 2338
    if (page == (int )r->tabBar.atab) {
#line 2339
      r->fgbg_tabnum = -1;
    }
  } else
#line 2342
  if (idx == 0) {
#line 2344
    (r->vts[page])->p_fg = *(r->pixColorsFocus + idx);
#line 2350
    if (r->TermWin.fade) {
#line 2352
      (r->vts[page])->p_fgfade = *(r->pixColorsUnfocus + idx);
    }
#line 2359
    if (page == (int )r->tabBar.atab) {
#line 2361
      r->fgbg_tabnum = -1;
    }
  }
#line 2372
  if (idx == 260) {
    {
#line 2373
    rxvt_recolour_cursor(r);
    }
  }
#line 2377
  if (idx == 269) {
#line 2380
    if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
      {
#line 2382
      rxvt_check_our_parents(r);
      }
    }
  }
  {
#line 2401
  rxvt_set_vt_colors(r, (int )r->tabBar.atab);
#line 2406
  XClearArea(r->Xdisplay, (r->vts[r->tabBar.atab])->vt, 0, 0, 0U, 0U, 1);
  }
#line 2407
  return;
}
}
#line 2415 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_recolour_cursor(rxvt_t *r ) 
{ 
  XColor xcol[2] ;

  {
  {
#line 2420
  xcol[0].pixel = *(r->pixColorsFocus + 260);
#line 2421
  xcol[1].pixel = r->profile[0].bg;
#line 2422
  XQueryColors(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
               xcol, 2);
#line 2423
  XRecolorCursor(r->Xdisplay, r->term_pointer, & xcol[0], & xcol[1]);
  }
#line 2426
  return;
}
}
#line 2434 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_colorfgbg(rxvt_t *r ) 
{ 
  unsigned int i ;
  char const   *xpmb ;
  char fstr[sizeof("default") + 1UL] ;
  char bstr[sizeof("default") + 1UL] ;
  void *tmp ;

  {
  {
#line 2438
  xpmb = "\000";
#line 2441
  tmp = rxvt_malloc(sizeof("COLORFGBG=default;default;bg") + 1UL);
#line 2441
  (r->h)->env_colorfgbg = (char *)tmp;
#line 2443
  strcpy((char */* __restrict  */)(fstr), (char const   */* __restrict  */)"default");
#line 2444
  strcpy((char */* __restrict  */)(bstr), (char const   */* __restrict  */)"default");
#line 2445
  i = 2U;
  }
  {
#line 2445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2445
    if (! (i <= 17U)) {
#line 2445
      goto while_break;
    }
#line 2446
    if (*(r->pixColorsFocus + 0) == *(r->pixColorsFocus + i)) {
      {
#line 2448
      sprintf((char */* __restrict  */)(fstr), (char const   */* __restrict  */)"%d",
              i - 2U);
      }
#line 2449
      goto while_break;
    }
#line 2445
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2451
  i = 2U;
  {
#line 2451
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2451
    if (! (i <= 17U)) {
#line 2451
      goto while_break___0;
    }
#line 2452
    if (*(r->pixColorsFocus + 1) == *(r->pixColorsFocus + i)) {
      {
#line 2454
      sprintf((char */* __restrict  */)(bstr), (char const   */* __restrict  */)"%d",
              i - 2U);
      }
#line 2458
      goto while_break___0;
    }
#line 2451
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2460
  sprintf((char */* __restrict  */)(r->h)->env_colorfgbg, (char const   */* __restrict  */)"COLORFGBG=%s;%s%s",
          fstr, xpmb, bstr);
#line 2461
  putenv((r->h)->env_colorfgbg);
#line 2464
  (r->h)->colorfgbg = (unsigned long )(1 << 9);
#line 2465
  i = 2U;
  }
  {
#line 2465
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2465
    if (! (i <= 9U)) {
#line 2465
      goto while_break___1;
    }
#line 2467
    if (*(r->pixColorsFocus + 0) == *(r->pixColorsFocus + i)) {
#line 2467
      if (*(r->pixColorsFocus + 0) == *(r->pixColorsFocus + 263)) {
#line 2477
        (r->h)->colorfgbg = ((r->h)->colorfgbg & 4294966784UL) | (unsigned long )i;
      }
    }
#line 2478
    if (*(r->pixColorsFocus + 1) == *(r->pixColorsFocus + i)) {
#line 2479
      (r->h)->colorfgbg = ((r->h)->colorfgbg & 4294705663UL) | (unsigned long )(i << 9);
    }
#line 2465
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2482
  return;
}
}
#line 2526 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
int rxvt_parse_alloc_color(rxvt_t *r , XColor *screen_in_out , char const   *colour ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 2529
  res = 0;
#line 2531
  tmp = XParseColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                    colour, screen_in_out);
  }
#line 2531
  if (tmp) {
    {
#line 2534
    res = rxvt_alloc_color(r, screen_in_out, colour);
    }
  } else {
    {
#line 2532
    rxvt_msg((uint32_t )1, (uint32_t )16, "can\'t determine colour: %s", colour);
    }
  }
#line 2535
  return (res);
}
}
#line 2540 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
int rxvt_alloc_color(rxvt_t *r , XColor *screen_in_out , char const   *colour ) 
{ 
  int tmp ;

  {
  {
#line 2543
  tmp = XAllocColor(r->Xdisplay, (((_XPrivDisplay )r->Xdisplay)->screens + ((_XPrivDisplay )r->Xdisplay)->default_screen)->cmap,
                    screen_in_out);
  }
#line 2543
  return (tmp);
}
}
#line 3081 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
static rxvt_t *_rxvt_vars  =    (rxvt_t *)((void *)0);
#line 3084 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
rxvt_t *rxvt_get_r(void) 
{ 


  {
#line 3087
  return (_rxvt_vars);
}
}
#line 3090 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/main.c"
void rxvt_set_r(rxvt_t *r ) 
{ 


  {
#line 3093
  _rxvt_vars = r;
#line 3094
  return;
}
}
#line 318 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/protos.h"
void rxvt_scrollbar_init_plain(rxvt_t *r ) ;
#line 319
void rxvt_scrollbar_exit_plain(rxvt_t *r ) ;
#line 320
int rxvt_scrollbar_show_plain(rxvt_t *r , int update , int last_top , int last_bot ,
                              int scroller_len ) ;
#line 57 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
void rxvt_scrollbar_init(rxvt_t *r ) 
{ 
  char *scrollalign ;
  char *scrollstyle ;
  char *thickness ;
  int i ;
  short style ;
  short width ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 60
  scrollalign = (char *)(r->h)->rs[296];
#line 61
  scrollstyle = (char *)(r->h)->rs[297];
#line 62
  thickness = (char *)(r->h)->rs[322];
#line 64
  style = (short)-1;
#line 64
  width = (short)0;
#line 67
  if (scrollstyle) {
    {
#line 70
    tmp = strncasecmp((char const   *)scrollstyle, "plain", (size_t )5);
    }
#line 70
    if (0 == tmp) {
#line 71
      style = (short)4;
    }
    {
#line 74
    tmp___0 = strncasecmp((char const   *)scrollstyle, "xterm", (size_t )5);
    }
#line 74
    if (0 == tmp___0) {
#line 75
      style = (short)2;
    }
    {
#line 78
    tmp___1 = strncasecmp((char const   *)scrollstyle, "rxvt", (size_t )4);
    }
#line 78
    if (0 == tmp___1) {
#line 79
      style = (short)0;
    }
    {
#line 82
    tmp___2 = strncasecmp((char const   *)scrollstyle, "next", (size_t )4);
    }
#line 82
    if (0 == tmp___2) {
#line 83
      style = (short)1;
    }
    {
#line 86
    tmp___3 = strncasecmp((char const   *)scrollstyle, "sgi", (size_t )3);
    }
#line 86
    if (0 == tmp___3) {
#line 87
      style = (short)3;
    }
  }
#line 95
  if (-1 == (int )style) {
#line 95
    goto _L;
  } else
#line 95
  if (! scrollstyle) {
    _L: /* CIL Label */ 
#line 97
    style = (short)4;
#line 100
    style = (short)2;
#line 103
    style = (short)0;
#line 106
    style = (short)1;
#line 109
    if (-1 == (int )style) {
#line 110
      style = (short)3;
    }
  }
  {
#line 116
  if ((int )style == 4) {
#line 116
    goto case_4;
  }
#line 119
  if ((int )style == 2) {
#line 119
    goto case_2;
  }
#line 122
  if ((int )style == 0) {
#line 122
    goto case_0;
  }
#line 125
  if ((int )style == 1) {
#line 125
    goto case_1;
  }
#line 128
  if ((int )style == 3) {
#line 128
    goto case_3;
  }
#line 131
  goto switch_default;
  case_4: /* CIL Label */ 
#line 117
  width = (short)15;
#line 118
  goto switch_break;
  case_2: /* CIL Label */ 
#line 120
  width = (short)15;
#line 121
  goto switch_break;
  case_0: /* CIL Label */ 
#line 123
  width = (short)10;
#line 124
  goto switch_break;
  case_1: /* CIL Label */ 
#line 126
  width = (short)17;
#line 127
  goto switch_break;
  case_3: /* CIL Label */ 
#line 129
  width = (short)16;
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 136
  if ((int )style != 1) {
#line 137
    if (thickness) {
      {
#line 137
      i = atoi((char const   *)thickness);
      }
#line 137
      if (i >= 5) {
#line 138
        if (i < 100) {
#line 138
          width = (short )i;
        } else {
#line 138
          width = (short)100;
        }
      }
    }
  }
#line 141
  if (! ((unsigned long )r->Options[(1UL << 12) & 3UL] & ((1UL << 12) & 0xfffffffffffffffcUL))) {
#line 141
    if ((int )style == 0) {
#line 142
      r->sb_shadow = 1;
    }
  }
#line 147
  r->scrollBar.style = style;
#line 148
  r->scrollBar.width = width;
#line 151
  if (scrollalign) {
    {
#line 152
    tmp___5 = strncasecmp((char const   *)scrollalign, "top", (size_t )3);
    }
#line 152
    if (tmp___5 == 0) {
#line 153
      (r->h)->scrollbar_align = (unsigned char)1;
    } else {
      {
#line 154
      tmp___4 = strncasecmp((char const   *)scrollalign, "bottom", (size_t )6);
      }
#line 154
      if (tmp___4 == 0) {
#line 155
        (r->h)->scrollbar_align = (unsigned char)2;
      }
    }
  }
#line 158
  if ((int )r->scrollBar.style == 4) {
#line 159
    r->scrollBar.update = & rxvt_scrollbar_show_plain;
  }
#line 162
  if ((int )r->scrollBar.style == 2) {
#line 163
    r->scrollBar.update = & rxvt_scrollbar_show_xterm;
  }
#line 166
  if ((int )r->scrollBar.style == 1) {
#line 167
    r->scrollBar.update = & rxvt_scrollbar_show_next;
  }
#line 170
  if ((int )r->scrollBar.style == 0) {
#line 171
    r->scrollBar.update = & rxvt_scrollbar_show_rxvt;
  }
#line 174
  if ((int )r->scrollBar.style == 3) {
#line 175
    r->scrollBar.update = & rxvt_scrollbar_show_sgi;
  }
#line 179
  r->scrollBar.win = (Window )0L;
#line 180
  r->scrollBar.state = (char)0;
#line 181
  return;
}
}
#line 188 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
int rxvt_scrollbar_hide(rxvt_t *r ) 
{ 
  int changed ;

  {
  {
#line 191
  changed = 0;
#line 193
  changed = (int )r->scrollBar.state;
#line 194
  XUnmapWindow(r->Xdisplay, r->scrollBar.win);
#line 195
  r->scrollBar.state = (char)0;
  }
#line 198
  return (changed);
}
}
#line 206 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
int rxvt_scrollbar_show(rxvt_t *r ) 
{ 
  int changed ;

  {
  {
#line 209
  changed = 0;
#line 211
  changed = ! r->scrollBar.state;
#line 212
  XMapWindow(r->Xdisplay, r->scrollBar.win);
#line 213
  r->scrollBar.state = (char)1;
  }
#line 214
  return (changed);
}
}
#line 219 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
void rxvt_scrollbar_create(rxvt_t *r ) 
{ 
  int sb_x ;
  int sb_y ;
  unsigned int sb_w ;
  unsigned int sb_h ;
  unsigned short tmp ;

  {
#line 229
  if ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL)) {
#line 229
    sb_x = (r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth;
  } else {
#line 229
    sb_x = 0;
  }
  {
#line 230
  sb_y = (r->h)->window_vt_y;
#line 231
  tmp = rxvt_scrollbar_rwidth(r);
#line 231
  sb_w = (unsigned int )tmp;
#line 232
  sb_h = (unsigned int )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth);
  }
#line 236
  if ((int )r->scrollBar.style == 4) {
#line 237
    r->scrollBar.beg = (short)0;
#line 238
    r->scrollBar.end = (short )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth);
  }
#line 242
  if ((int )r->scrollBar.style == 2) {
#line 243
    r->scrollBar.beg = (short)0;
#line 244
    r->scrollBar.end = (short )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth);
  }
#line 248
  if ((int )r->scrollBar.style == 1) {
#line 249
    r->scrollBar.beg = (short)0;
#line 250
    r->scrollBar.end = (short )(((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) - ((((((17 - (1 << 1)) - 1) + 1) << 1) + 1) + 1));
  }
#line 254
  if ((int )r->scrollBar.style == 0) {
#line 255
    r->scrollBar.beg = (short )(((int )r->scrollBar.width + 1) + r->sb_shadow);
#line 256
    r->scrollBar.end = (short )(((((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) - ((int )r->scrollBar.width + 1)) + r->sb_shadow) - (r->sb_shadow << 1));
  }
#line 260
  if ((int )r->scrollBar.style == 3) {
#line 261
    r->scrollBar.beg = (short )((2 << 1) + (16 - (2 << 1)));
#line 262
    r->scrollBar.end = (short )((((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) - ((2 << 1) + (16 - (2 << 1)))) - (r->sb_shadow << 1));
  }
  {
#line 267
  r->scrollBar.win = XCreateSimpleWindow(r->Xdisplay, r->TermWin.parent, sb_x, sb_y,
                                         sb_w, sb_h, 0U, *(r->pixColorsFocus + 0),
                                         *(r->pixColorsFocus + 1));
#line 279
  XDefineCursor(r->Xdisplay, r->scrollBar.win, (r->h)->bar_pointer);
#line 280
  XSelectInput(r->Xdisplay, r->scrollBar.win, (((((1L << 15) | (1L << 2)) | (1L << 3)) | (1L << 8)) | (1L << 9)) | (1L << 10));
  }
#line 303
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 303
    if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
      {
#line 305
      XSetWindowBackgroundPixmap(r->Xdisplay, r->scrollBar.win, (Pixmap )1L);
      }
    }
  }
#line 309
  r->scrollBar.state = (char)0;
#line 314
  if ((int )r->scrollBar.style == 4) {
    {
#line 315
    rxvt_scrollbar_init_plain(r);
    }
  }
#line 318
  if ((int )r->scrollBar.style == 2) {
    {
#line 319
    rxvt_scrollbar_init_xterm(r);
    }
  }
#line 322
  if ((int )r->scrollBar.style == 0) {
    {
#line 323
    rxvt_scrollbar_init_rxvt(r);
    }
  }
#line 326
  if ((int )r->scrollBar.style == 1) {
    {
#line 327
    rxvt_scrollbar_init_next(r);
    }
  }
#line 330
  if ((int )r->scrollBar.style == 3) {
    {
#line 331
    rxvt_scrollbar_init_sgi(r);
    }
  }
#line 333
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
void rxvt_scrollbar_clean_exit(rxvt_t *r ) 
{ 


  {
#line 340
  r->scrollBar.win = (Window )0L;
#line 342
  if ((unsigned long )((GC )0) != (unsigned long )r->scrollBar.gc) {
    {
#line 343
    XFreeGC(r->Xdisplay, r->scrollBar.gc);
#line 344
    r->scrollBar.gc = (GC )0L;
    }
  }
#line 355
  if ((int )r->scrollBar.style == 4) {
    {
#line 356
    rxvt_scrollbar_exit_plain(r);
    }
  }
#line 359
  if ((int )r->scrollBar.style == 2) {
    {
#line 360
    rxvt_scrollbar_exit_xterm(r);
    }
  }
#line 363
  if ((int )r->scrollBar.style == 0) {
    {
#line 364
    rxvt_scrollbar_exit_rxvt(r);
    }
  }
#line 367
  if ((int )r->scrollBar.style == 1) {
    {
#line 368
    rxvt_scrollbar_exit_next(r);
    }
  }
#line 371
  if ((int )r->scrollBar.style == 3) {
    {
#line 372
    rxvt_scrollbar_exit_sgi(r);
    }
  }
#line 374
  return;
}
}
#line 378 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
void rxvt_scrollbar_resize(rxvt_t *r ) 
{ 
  int sb_x ;
  int sb_y ;
  unsigned int sb_w ;
  unsigned int sb_h ;
  unsigned short tmp ;

  {
#line 385
  if ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL)) {
#line 385
    sb_x = (r->szHint.width - r->szHint.base_width) + 2 * (int )r->TermWin.int_bwidth;
  } else {
#line 385
    sb_x = 0;
  }
  {
#line 386
  sb_y = (r->h)->window_vt_y;
#line 387
  tmp = rxvt_scrollbar_rwidth(r);
#line 387
  sb_w = (unsigned int )tmp;
#line 388
  sb_h = (unsigned int )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth);
#line 389
  XMoveResizeWindow(r->Xdisplay, r->scrollBar.win, sb_x, sb_y, sb_w, sb_h);
  }
#line 394
  if ((int )r->scrollBar.style == 4) {
#line 395
    r->scrollBar.beg = (short)0;
#line 396
    r->scrollBar.end = (short )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth);
  }
#line 400
  if ((int )r->scrollBar.style == 2) {
#line 401
    r->scrollBar.beg = (short)0;
#line 402
    r->scrollBar.end = (short )((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth);
  }
#line 406
  if ((int )r->scrollBar.style == 1) {
#line 407
    r->scrollBar.beg = (short)0;
#line 408
    r->scrollBar.end = (short )(((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) - ((((((17 - (1 << 1)) - 1) + 1) << 1) + 1) + 1));
  }
#line 412
  if ((int )r->scrollBar.style == 0) {
#line 413
    r->scrollBar.beg = (short )(((int )r->scrollBar.width + 1) + r->sb_shadow);
#line 414
    r->scrollBar.end = (short )(((((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) - ((int )r->scrollBar.width + 1)) + r->sb_shadow) - (r->sb_shadow << 1));
  }
#line 418
  if ((int )r->scrollBar.style == 3) {
#line 419
    r->scrollBar.beg = (short )((2 << 1) + (16 - (2 << 1)));
#line 420
    r->scrollBar.end = (short )((((r->szHint.height - r->szHint.base_height) + 2 * (int )r->TermWin.int_bwidth) - ((2 << 1) + (16 - (2 << 1)))) - (r->sb_shadow << 1));
  }
  {
#line 424
  rxvt_scrollbar_update(r, 0);
  }
#line 425
  return;
}
}
#line 429 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
int rxvt_scrollbar_visible(rxvt_t *r ) 
{ 
  int tmp ;

  {
#line 432
  if (0UL != r->scrollBar.win) {
#line 432
    if (r->scrollBar.state) {
#line 432
      tmp = 1;
    } else {
#line 432
      tmp = 0;
    }
  } else {
#line 432
    tmp = 0;
  }
#line 432
  return (tmp);
}
}
#line 440 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
int rxvt_scrollbar_update(rxvt_t *r , int update ) 
{ 
  int ret ;
  int top ;
  int bot ;
  int len ;
  int adj ;
  int tmp ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  {
#line 443
  ret = 0;
#line 446
  tmp = rxvt_scrollbar_visible(r);
  }
#line 446
  if (! tmp) {
#line 447
    return (0);
  }
#line 449
  if (update) {
#line 451
    top = (int )(r->vts[r->tabBar.atab])->nscrolled - (int )(r->vts[r->tabBar.atab])->view_start;
#line 453
    bot = top + ((int )r->TermWin.nrow - 1);
#line 455
    if ((int )(r->vts[r->tabBar.atab])->nscrolled + ((int )r->TermWin.nrow - 1) > 1) {
#line 455
      len = (int )(r->vts[r->tabBar.atab])->nscrolled + ((int )r->TermWin.nrow - 1);
    } else {
#line 455
      len = 1;
    }
#line 456
    if ((int )r->scrollBar.style == 1) {
#line 456
      tmp___3 = ((17 - (1 << 1)) - 1) - (1 << 1);
    } else {
#line 456
      if ((int )r->scrollBar.style == 3) {
#line 456
        tmp___2 = 10;
      } else {
#line 456
        tmp___2 = 10;
      }
#line 456
      tmp___3 = tmp___2;
    }
#line 456
    if (((bot - top) * (((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___3)) % len > 0) {
#line 456
      adj = 1;
    } else {
#line 456
      adj = 0;
    }
#line 467
    if ((int )r->scrollBar.style == 1) {
#line 467
      tmp___5 = ((17 - (1 << 1)) - 1) - (1 << 1);
    } else {
#line 467
      if ((int )r->scrollBar.style == 3) {
#line 467
        tmp___4 = 10;
      } else {
#line 467
        tmp___4 = 10;
      }
#line 467
      tmp___5 = tmp___4;
    }
#line 467
    r->scrollBar.top = (short )((int )r->scrollBar.beg + (top * (((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___5)) / len);
#line 468
    if ((int )r->scrollBar.style == 1) {
#line 468
      tmp___7 = ((17 - (1 << 1)) - 1) - (1 << 1);
    } else {
#line 468
      if ((int )r->scrollBar.style == 3) {
#line 468
        tmp___6 = 10;
      } else {
#line 468
        tmp___6 = 10;
      }
#line 468
      tmp___7 = tmp___6;
    }
#line 468
    if ((int )r->scrollBar.style == 1) {
#line 468
      tmp___9 = ((17 - (1 << 1)) - 1) - (1 << 1);
    } else {
#line 468
      if ((int )r->scrollBar.style == 3) {
#line 468
        tmp___8 = 10;
      } else {
#line 468
        tmp___8 = 10;
      }
#line 468
      tmp___9 = tmp___8;
    }
#line 468
    (r->h)->scroller_len = (((bot - top) * (((int )r->scrollBar.end - (int )r->scrollBar.beg) - tmp___7)) / len + tmp___9) + adj;
#line 470
    r->scrollBar.bot = (short )((int )r->scrollBar.top + (r->h)->scroller_len);
#line 473
    if ((int )r->scrollBar.top == (r->h)->last_top) {
#line 473
      if ((int )r->scrollBar.bot == (r->h)->last_bot) {
#line 473
        if ((int )r->scrollBar.state == (r->h)->last_state) {
#line 477
          return (0);
        } else {
          {
#line 473
          tmp___10 = __ctype_b_loc();
          }
#line 473
          if (! ((int const   )*(*tmp___10 + (int )r->scrollBar.state) & 256)) {
#line 477
            return (0);
          }
        }
      }
    }
  }
  {
#line 480
  ret = (*(r->scrollBar.update))(r, update, (r->h)->last_top, (r->h)->last_bot, (r->h)->scroller_len);
#line 483
  (r->h)->last_top = (int )r->scrollBar.top;
#line 484
  (r->h)->last_bot = (int )r->scrollBar.bot;
#line 485
  (r->h)->last_state = (int )r->scrollBar.state;
  }
#line 487
  return (ret);
}
}
#line 492 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
unsigned short rxvt_scrollbar_width(rxvt_t *r ) 
{ 


  {
#line 495
  if (0UL == r->scrollBar.win) {
#line 496
    return ((unsigned short)0);
  } else
#line 495
  if (! r->scrollBar.state) {
#line 496
    return ((unsigned short)0);
  }
#line 497
  return ((unsigned short )((int )r->scrollBar.width + r->sb_shadow * 2));
}
}
#line 502 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
unsigned short rxvt_scrollbar_rwidth(rxvt_t *r ) 
{ 


  {
#line 505
  return ((unsigned short )((int )r->scrollBar.width + r->sb_shadow * 2));
}
}
#line 510 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
int rxvt_is_scrollbar_win(rxvt_t *r , Window w ) 
{ 


  {
#line 513
  return (w == r->scrollBar.win);
}
}
#line 520 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar.c"
unsigned long rxvt_scrollbar_bg(rxvt_t *r ) 
{ 


  {
  {
#line 526
  if ((int )r->scrollBar.style == 4) {
#line 526
    goto case_4;
  }
#line 529
  if ((int )r->scrollBar.style == 2) {
#line 529
    goto case_2;
  }
#line 532
  if ((int )r->scrollBar.style == 0) {
#line 532
    goto case_0;
  }
#line 535
  if ((int )r->scrollBar.style == 1) {
#line 535
    goto case_1;
  }
#line 538
  if ((int )r->scrollBar.style == 3) {
#line 538
    goto case_3;
  }
#line 540
  goto switch_default;
  case_4: /* CIL Label */ 
#line 526
  return (r->scrollBar.plain_bg);
  case_2: /* CIL Label */ 
#line 529
  return (r->scrollBar.xterm_bg);
  case_0: /* CIL Label */ 
#line 532
  return (r->scrollBar.rxvt_bg);
  case_1: /* CIL Label */ 
#line 535
  return (r->scrollBar.next_bg);
  case_3: /* CIL Label */ 
#line 538
  return (r->scrollBar.sgi_bg);
  switch_default: /* CIL Label */ ;
#line 540
  return (r->profile[0].bg);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 41 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-plain.c"
void rxvt_scrollbar_init_plain(rxvt_t *r ) 
{ 
  XGCValues gcvalue ;
  unsigned long gcmask ;

  {
#line 48
  r->scrollBar.gc = (GC )0L;
#line 52
  if ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 11)) {
#line 52
    r->scrollBar.plain_fg = *(r->pixColorsFocus + 267);
  } else {
#line 52
    r->scrollBar.plain_fg = *(r->pixColorsFocus + 1);
  }
#line 55
  if ((r->h)->pixcolor_set[8] & (unsigned int )(1 << 11)) {
#line 55
    r->scrollBar.plain_bg = *(r->pixColorsFocus + 268);
  } else {
#line 55
    r->scrollBar.plain_bg = *(r->pixColorsFocus + 1);
  }
#line 66
  gcmask = (unsigned long )(1L << 2);
#line 67
  gcvalue.foreground = r->scrollBar.plain_fg;
#line 71
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 71
    if (! ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL))) {
      {
#line 80
      gcmask |= (unsigned long )(1L << 3);
#line 81
      gcvalue.background = r->scrollBar.plain_bg;
#line 82
      XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.plain_bg);
      }
    }
  } else {
    {
#line 80
    gcmask |= (unsigned long )(1L << 3);
#line 81
    gcvalue.background = r->scrollBar.plain_bg;
#line 82
    XSetWindowBackground(r->Xdisplay, r->scrollBar.win, r->scrollBar.plain_bg);
    }
  }
  {
#line 86
  r->scrollBar.gc = XCreateGC(r->Xdisplay, r->scrollBar.win, gcmask, & gcvalue);
  }
#line 89
  return;
}
}
#line 92 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-plain.c"
void rxvt_scrollbar_exit_plain(rxvt_t *r ) 
{ 


  {
#line 96
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/mrxvt-0.5.4/src/scrollbar-plain.c"
int rxvt_scrollbar_show_plain(rxvt_t *r , int update , int last_top , int last_bot ,
                              int scroller_len ) 
{ 
  int xsb ;
  int sbwidth ;
  int clear ;

  {
#line 103
  xsb = 0;
#line 104
  sbwidth = (int )r->scrollBar.width - 1;
#line 105
  clear = 0;
#line 110
  if ((unsigned long )r->Options[(1UL << 16) & 3UL] & ((1UL << 16) & 0xfffffffffffffffcUL)) {
#line 110
    if ((unsigned long )r->Options[(1UL << 23) & 3UL] & ((1UL << 23) & 0xfffffffffffffffcUL)) {
#line 112
      clear = 1;
    } else {
#line 120
      clear = 0;
    }
  } else {
#line 120
    clear = 0;
  }
#line 122
  scroller_len --;
#line 124
  if ((unsigned long )r->Options[(1UL << 11) & 3UL] & ((1UL << 11) & 0xfffffffffffffffcUL)) {
#line 124
    xsb = 1;
  } else {
#line 124
    xsb = 0;
  }
#line 125
  if (last_top < (int )r->scrollBar.top) {
    {
#line 126
    XClearArea(r->Xdisplay, r->scrollBar.win, r->sb_shadow + xsb, last_top, (unsigned int )((sbwidth + 1) - xsb),
               (unsigned int )((int )r->scrollBar.top - last_top), 0);
    }
  }
#line 130
  if ((int )r->scrollBar.bot < last_bot) {
    {
#line 131
    XClearArea(r->Xdisplay, r->scrollBar.win, r->sb_shadow + xsb, (int )r->scrollBar.bot,
               (unsigned int )((sbwidth + 1) - xsb), (unsigned int )((last_bot - (int )r->scrollBar.bot) + clear),
               0);
    }
  }
  {
#line 136
  XSetForeground(r->Xdisplay, r->scrollBar.gc, r->scrollBar.plain_fg);
  }
#line 137
  if (clear) {
    {
#line 139
    XClearArea(r->Xdisplay, r->scrollBar.win, r->sb_shadow + xsb, (int )r->scrollBar.top,
               (unsigned int )sbwidth, (unsigned int )scroller_len, 0);
#line 143
    XDrawRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, r->sb_shadow + xsb,
                   (int )r->scrollBar.top, (unsigned int )(sbwidth - xsb), (unsigned int )scroller_len);
    }
  } else {
    {
#line 148
    XFillRectangle(r->Xdisplay, r->scrollBar.win, r->scrollBar.gc, r->sb_shadow + xsb,
                   (int )r->scrollBar.top, (unsigned int )sbwidth, (unsigned int )scroller_len);
    }
  }
#line 153
  return (1);
}
}
