/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 81 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct ata_lba_regs {
   __u8 feat ;
   __u8 nsect ;
   __u8 lbal ;
   __u8 lbam ;
   __u8 lbah ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct ata_tf {
   __u8 dev ;
   __u8 command ;
   __u8 error ;
   __u8 status ;
   __u8 is_lba48 ;
   struct ata_lba_regs lob ;
   struct ata_lba_regs hob ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct __anonstruct_lob_35 {
   unsigned int data : 1 ;
   unsigned int feat : 1 ;
   unsigned int lbal : 1 ;
   unsigned int nsect : 1 ;
   unsigned int lbam : 1 ;
   unsigned int lbah : 1 ;
   unsigned int dev : 1 ;
   unsigned int command : 1 ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
union __anonunion____missing_field_name_34 {
   unsigned int lob_all : 8 ;
   struct __anonstruct_lob_35 lob ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct __anonstruct_hob_37 {
   unsigned int data : 1 ;
   unsigned int feat : 1 ;
   unsigned int lbal : 1 ;
   unsigned int nsect : 1 ;
   unsigned int lbam : 1 ;
   unsigned int lbah : 1 ;
   unsigned int dev : 1 ;
   unsigned int command : 1 ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
union __anonunion____missing_field_name_36 {
   unsigned int hob_all : 8 ;
   struct __anonstruct_hob_37 hob ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
union reg_flags {
   unsigned int all : 16 ;
   union __anonunion____missing_field_name_34 __annonCompField1 ;
   union __anonunion____missing_field_name_36 __annonCompField2 ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct taskfile_regs {
   __u8 data ;
   __u8 feat ;
   __u8 nsect ;
   __u8 lbal ;
   __u8 lbam ;
   __u8 lbah ;
   __u8 dev ;
   __u8 command ;
};
#line 159 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct hdio_taskfile {
   struct taskfile_regs lob ;
   struct taskfile_regs hob ;
   union reg_flags oflags ;
   union reg_flags iflags ;
   int dphase ;
   int cmd_req ;
   unsigned long obytes ;
   unsigned long ibytes ;
   __u16 data[0] ;
};
#line 171 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
struct scsi_sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   void *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 228 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.h"
void tf_init(struct ata_tf *tf , __u8 ata_op , __u64 lba , unsigned int nsect ) ;
#line 229
__u64 tf_to_lba(struct ata_tf *tf ) ;
#line 230
int sg16(int fd___0 , int rw , int dma , struct ata_tf *tf , void *data , unsigned int data_bytes ,
         unsigned int timeout_secs ) ;
#line 231
int do_drive_cmd(int fd___0 , unsigned char *args ) ;
#line 232
int do_taskfile_cmd(int fd___0 , struct hdio_taskfile *r , unsigned int timeout_secs ) ;
#line 234
void init_hdio_taskfile(struct hdio_taskfile *r , __u8 ata_op , int rw , int force_lba48 ,
                        __u64 lba , unsigned int nsect , int data_bytes ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
int verbose ;
#line 20
int prefer_ata12 ;
#line 55 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
__inline static int needs_lba48(__u8 ata_op , __u64 lba , unsigned int nsect ) 
{ 


  {
  {
#line 67
  if ((int )ata_op == 234) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 55) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 39) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 69) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 66) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 53) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 52) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 37) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 36) {
#line 67
    goto case_234;
  }
#line 67
  if ((int )ata_op == 6) {
#line 67
    goto case_234;
  }
#line 57
  goto switch_break;
  case_234: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 68
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 70
  if (lba >= (__u64 )(1 << 28) - 1ULL) {
#line 71
    return (1);
  }
#line 72
  if (nsect) {
#line 73
    if (nsect > 255U) {
#line 74
      return (1);
    }
#line 75
    if ((lba + (__u64 )nsect) - 1ULL >= (__u64 )(1 << 28) - 1ULL) {
#line 76
      return (1);
    }
  }
#line 78
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
__inline static int is_dma(__u8 ata_op ) 
{ 


  {
  {
#line 90
  if ((int )ata_op == 202) {
#line 90
    goto case_202;
  }
#line 90
  if ((int )ata_op == 200) {
#line 90
    goto case_202;
  }
#line 90
  if ((int )ata_op == 97) {
#line 90
    goto case_202;
  }
#line 90
  if ((int )ata_op == 53) {
#line 90
    goto case_202;
  }
#line 90
  if ((int )ata_op == 96) {
#line 90
    goto case_202;
  }
#line 90
  if ((int )ata_op == 37) {
#line 90
    goto case_202;
  }
#line 90
  if ((int )ata_op == 6) {
#line 90
    goto case_202;
  }
#line 92
  goto switch_default;
  case_202: /* CIL Label */ 
  case_200: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 91
  return (1);
  switch_default: /* CIL Label */ 
#line 93
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
void tf_init(struct ata_tf *tf , __u8 ata_op , __u64 lba , unsigned int nsect ) 
{ 
  int tmp ;

  {
  {
#line 99
  memset((void *)tf, 0, sizeof(*tf));
#line 100
  tf->command = ata_op;
#line 101
  tf->dev = (__u8 )64;
#line 102
  tf->lob.lbal = (__u8 )lba;
#line 103
  tf->lob.lbam = (__u8 )(lba >> 8);
#line 104
  tf->lob.lbah = (__u8 )(lba >> 16);
#line 105
  tf->lob.nsect = (__u8 )nsect;
#line 106
  tmp = needs_lba48(ata_op, lba, nsect);
  }
#line 106
  if (tmp) {
#line 107
    tf->is_lba48 = (__u8 )1;
#line 108
    tf->hob.nsect = (__u8 )(nsect >> 8);
#line 109
    tf->hob.lbal = (__u8 )(lba >> 24);
#line 110
    tf->hob.lbam = (__u8 )(lba >> 32);
#line 111
    tf->hob.lbah = (__u8 )(lba >> 40);
  } else {
#line 113
    tf->dev = (__u8 )((unsigned long long )tf->dev | ((lba >> 24) & 15ULL));
  }
#line 115
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
__u64 tf_to_lba(struct ata_tf *tf ) 
{ 
  __u32 lba24 ;
  __u32 lbah ;
  __u64 lba64 ;

  {
#line 124
  lba24 = (__u32 )((((int )tf->lob.lbah << 16) | ((int )tf->lob.lbam << 8)) | (int )tf->lob.lbal);
#line 125
  if (tf->is_lba48) {
#line 126
    lbah = (__u32 )((((int )tf->hob.lbah << 16) | ((int )tf->hob.lbam << 8)) | (int )tf->hob.lbal);
  } else {
#line 128
    lbah = (__u32 )((int )tf->dev & 15);
  }
#line 129
  lba64 = ((__u64 )lbah << 24) | (__u64 )lba24;
#line 130
  return (lba64);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
static void dump_bytes(char const   *prefix , unsigned char *p , int len ) 
{ 
  int i ;

  {
#line 151
  if (prefix) {
    {
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            prefix);
    }
  }
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < len)) {
#line 153
      goto while_break;
    }
    {
#line 154
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %02x",
            (int )*(p + i));
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 156
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
int sg16(int fd___0 , int rw , int dma , struct ata_tf *tf , void *data , unsigned int data_bytes ,
         unsigned int timeout_secs ) 
{ 
  unsigned char cdb[16] ;
  unsigned char sb[32] ;
  unsigned char *desc ;
  struct scsi_sg_io_hdr io_hdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __u64 tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int len ;
  int maxlen ;
  int *tmp___7 ;

  {
  {
#line 165
  memset((void *)(& cdb), 0, sizeof(cdb));
#line 166
  memset((void *)(& sb), 0, sizeof(sb));
#line 167
  memset((void *)(& io_hdr), 0, sizeof(struct scsi_sg_io_hdr ));
  }
#line 169
  if (dma) {
#line 171
    if (data) {
#line 171
      cdb[1] = (unsigned char )(6 << 1);
    } else {
#line 171
      cdb[1] = (unsigned char )(3 << 1);
    }
  } else
#line 173
  if (data) {
#line 173
    if (rw) {
#line 173
      tmp = 5 << 1;
    } else {
#line 173
      tmp = 4 << 1;
    }
#line 173
    cdb[1] = (unsigned char )tmp;
  } else {
#line 173
    cdb[1] = (unsigned char )(3 << 1);
  }
#line 175
  cdb[2] = (unsigned char)32;
#line 176
  if (data) {
#line 177
    cdb[2] = (unsigned char )((int )cdb[2] | 6);
#line 178
    if (rw) {
#line 178
      tmp___0 = 0;
    } else {
#line 178
      tmp___0 = 8;
    }
#line 178
    cdb[2] = (unsigned char )((int )cdb[2] | tmp___0);
  }
#line 181
  if (! prefer_ata12) {
#line 181
    goto _L;
  } else
#line 181
  if (tf->is_lba48) {
    _L: /* CIL Label */ 
#line 182
    cdb[0] = (unsigned char)133;
#line 183
    cdb[4] = tf->lob.feat;
#line 184
    cdb[6] = tf->lob.nsect;
#line 185
    cdb[8] = tf->lob.lbal;
#line 186
    cdb[10] = tf->lob.lbam;
#line 187
    cdb[12] = tf->lob.lbah;
#line 188
    cdb[13] = tf->dev;
#line 189
    cdb[14] = tf->command;
#line 190
    if (tf->is_lba48) {
#line 191
      cdb[1] = (unsigned char )((int )cdb[1] | 1);
#line 192
      cdb[3] = tf->hob.feat;
#line 193
      cdb[5] = tf->hob.nsect;
#line 194
      cdb[7] = tf->hob.lbal;
#line 195
      cdb[9] = tf->hob.lbam;
#line 196
      cdb[11] = tf->hob.lbah;
    }
#line 198
    io_hdr.cmd_len = (unsigned char)16;
  } else {
#line 200
    cdb[0] = (unsigned char)161;
#line 201
    cdb[3] = tf->lob.feat;
#line 202
    cdb[4] = tf->lob.nsect;
#line 203
    cdb[5] = tf->lob.lbal;
#line 204
    cdb[6] = tf->lob.lbam;
#line 205
    cdb[7] = tf->lob.lbah;
#line 206
    cdb[8] = tf->dev;
#line 207
    cdb[9] = tf->command;
#line 208
    io_hdr.cmd_len = (unsigned char)12;
  }
#line 211
  io_hdr.interface_id = 'S';
#line 212
  io_hdr.mx_sb_len = (unsigned char )sizeof(sb);
#line 213
  if (data) {
#line 213
    if (rw) {
#line 213
      tmp___1 = -2;
    } else {
#line 213
      tmp___1 = -3;
    }
#line 213
    io_hdr.dxfer_direction = tmp___1;
  } else {
#line 213
    io_hdr.dxfer_direction = -1;
  }
#line 214
  if (data) {
#line 214
    io_hdr.dxfer_len = data_bytes;
  } else {
#line 214
    io_hdr.dxfer_len = 0U;
  }
  {
#line 215
  io_hdr.dxferp = data;
#line 216
  io_hdr.cmdp = cdb;
#line 217
  io_hdr.sbp = (void *)(sb);
#line 218
  tmp___2 = tf_to_lba(tf);
#line 218
  io_hdr.pack_id = (int )tmp___2;
  }
#line 219
  if (timeout_secs) {
#line 219
    tmp___3 = timeout_secs;
  } else {
#line 219
    tmp___3 = 5U;
  }
#line 219
  io_hdr.timeout = tmp___3 * 1000U;
#line 221
  if (verbose) {
    {
#line 222
    dump_bytes("outgoing cdb", cdb, (int )sizeof(cdb));
    }
#line 223
    if (data) {
      {
#line 224
      dump_bytes("data", (unsigned char *)data, 16);
      }
    }
  }
  {
#line 227
  tmp___4 = ioctl(fd___0, 8837UL, & io_hdr);
  }
#line 227
  if (tmp___4 == -1) {
#line 228
    if (verbose) {
      {
#line 229
      perror("ioctl(fd,SG_IO)");
      }
    }
#line 230
    return (-1);
  }
#line 233
  if (verbose) {
    {
#line 234
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: ATA_%u status=0x%x, host_status=0x%x, driver_status=0x%x\n",
            (int )io_hdr.cmd_len, (int )io_hdr.status, (int )io_hdr.host_status, (int )io_hdr.driver_status);
    }
  }
#line 237
  if (io_hdr.host_status) {
#line 237
    goto _L___0;
  } else
#line 237
  if ((int )io_hdr.driver_status != 8) {
#line 237
    goto _L___0;
  } else
#line 237
  if (io_hdr.status) {
#line 237
    if ((int )io_hdr.status != 2) {
      _L___0: /* CIL Label */ 
#line 240
      if (verbose) {
        {
#line 241
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: bad response (not CHECK_CONDITION)\n");
        }
      }
      {
#line 242
      tmp___5 = __errno_location();
#line 242
      *tmp___5 = 52;
      }
#line 243
      return (-1);
    }
  }
#line 246
  desc = sb + 8;
#line 247
  if ((int )sb[0] != 114) {
#line 247
    goto _L___1;
  } else
#line 247
  if ((int )sb[7] < 14) {
#line 247
    goto _L___1;
  } else
#line 247
  if ((int )*(desc + 0) != 9) {
#line 247
    goto _L___1;
  } else
#line 247
  if ((int )*(desc + 1) < 12) {
    _L___1: /* CIL Label */ 
#line 248
    if (verbose) {
      {
#line 249
      dump_bytes("SG_IO: bad/missing sense data, sb[]", sb, (int )sizeof(sb));
      }
    }
    {
#line 250
    tmp___6 = __errno_location();
#line 250
    *tmp___6 = 52;
    }
#line 251
    return (-1);
  }
#line 254
  if (verbose) {
    {
#line 255
    dump_bytes("SG_IO: sb[]", sb, (int )sizeof(sb));
    }
  }
#line 257
  if (verbose) {
#line 258
    len = (int )*(desc + 1);
#line 258
    maxlen = (int )((sizeof(sb) - 8UL) - 2UL);
#line 259
    if (len > maxlen) {
#line 260
      len = maxlen;
    }
    {
#line 261
    dump_bytes("SG_IO: desc[]", desc, len);
    }
  }
#line 264
  tf->is_lba48 = (__u8 )((int )*(desc + 2) & 1);
#line 265
  tf->error = *(desc + 3);
#line 266
  tf->lob.nsect = *(desc + 5);
#line 267
  tf->lob.lbal = *(desc + 7);
#line 268
  tf->lob.lbam = *(desc + 9);
#line 269
  tf->lob.lbah = *(desc + 11);
#line 270
  tf->dev = *(desc + 12);
#line 271
  tf->status = *(desc + 13);
#line 272
  tf->hob.feat = (__u8 )0;
#line 273
  if (tf->is_lba48) {
#line 274
    tf->hob.nsect = *(desc + 4);
#line 275
    tf->hob.lbal = *(desc + 6);
#line 276
    tf->hob.lbam = *(desc + 8);
#line 277
    tf->hob.lbah = *(desc + 10);
  } else {
#line 279
    tf->hob.nsect = (__u8 )0;
#line 280
    tf->hob.lbal = (__u8 )0;
#line 281
    tf->hob.lbam = (__u8 )0;
#line 282
    tf->hob.lbah = (__u8 )0;
  }
#line 285
  if (verbose) {
    {
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ATA_%u stat=%02x err=%02x nsect=%02x lbal=%02x lbam=%02x lbah=%02x dev=%02x\n",
            (int )io_hdr.cmd_len, (int )tf->status, (int )tf->error, (int )tf->lob.nsect,
            (int )tf->lob.lbal, (int )tf->lob.lbam, (int )tf->lob.lbah, (int )tf->dev);
    }
  }
#line 289
  if ((int )tf->status & 9) {
#line 290
    if (verbose) {
      {
#line 291
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I/O error, ata_op=0x%02x ata_status=0x%02x ata_error=0x%02x\n",
              (int )tf->command, (int )tf->status, (int )tf->error);
      }
    }
    {
#line 294
    tmp___7 = __errno_location();
#line 294
    *tmp___7 = 5;
    }
#line 295
    return (-1);
  }
#line 297
  return (0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
int do_drive_cmd(int fd___0 , unsigned char *args ) 
{ 
  struct ata_tf tf ;
  void *data ;
  unsigned int data_bytes ;
  int rc ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 307
  data = (void *)0;
#line 308
  data_bytes = 0U;
#line 311
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 312
    goto use_legacy_ioctl;
  }
#line 316
  if (*(args + 3)) {
#line 317
    data_bytes = (unsigned int )((int )*(args + 3) * 512);
#line 318
    data = (void *)(args + 4);
  }
  {
#line 320
  tf_init(& tf, *(args + 0), (__u64 )0, (unsigned int )*(args + 1));
#line 321
  tf.lob.feat = *(args + 2);
  }
#line 322
  if ((int )tf.command == 176) {
#line 323
    tf.lob.nsect = *(args + 3);
#line 324
    tf.lob.lbal = *(args + 1);
#line 325
    tf.lob.lbam = (__u8 )79;
#line 326
    tf.lob.lbah = (__u8 )194;
  }
  {
#line 329
  tmp = is_dma(tf.command);
#line 329
  rc = sg16(fd___0, 0, tmp, & tf, data, data_bytes, 0U);
  }
#line 330
  if (rc == -1) {
    {
#line 331
    tmp___0 = __errno_location();
    }
#line 331
    if (*tmp___0 == 22) {
#line 332
      goto use_legacy_ioctl;
    } else {
      {
#line 331
      tmp___1 = __errno_location();
      }
#line 331
      if (*tmp___1 == 19) {
#line 332
        goto use_legacy_ioctl;
      } else {
        {
#line 331
        tmp___2 = __errno_location();
        }
#line 331
        if (*tmp___2 == 52) {
#line 332
          goto use_legacy_ioctl;
        }
      }
    }
  }
#line 335
  if (rc == 0) {
#line 336
    *(args + 0) = tf.status;
#line 337
    *(args + 1) = tf.error;
#line 338
    *(args + 2) = tf.lob.nsect;
  } else {
    {
#line 335
    tmp___3 = __errno_location();
    }
#line 335
    if (*tmp___3 == 5) {
#line 336
      *(args + 0) = tf.status;
#line 337
      *(args + 1) = tf.error;
#line 338
      *(args + 2) = tf.lob.nsect;
    }
  }
#line 340
  return (rc);
  use_legacy_ioctl: 
#line 344
  if (verbose) {
#line 345
    if (args) {
      {
#line 346
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying legacy HDIO_DRIVE_CMD\n");
      }
    }
  }
  {
#line 348
  tmp___4 = ioctl(fd___0, 799UL, args);
  }
#line 348
  return (tmp___4);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
int do_taskfile_cmd(int fd___0 , struct hdio_taskfile *r , unsigned int timeout_secs ) 
{ 
  int rc ;
  struct ata_tf tf ;
  void *data ;
  unsigned int data_bytes ;
  int rw ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int err ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 356
  data = (void *)0;
#line 357
  data_bytes = 0U;
#line 358
  rw = 0;
#line 362
  tf_init(& tf, (__u8 )0, (__u64 )0, 0U);
  }
#line 364
  if (verbose) {
    {
#line 365
    printf((char const   */* __restrict  */)"oflags.lob_all=0x%02x, flags={", r->oflags.__annonCompField1.lob_all);
    }
#line 366
    if (r->oflags.__annonCompField1.lob.feat) {
      {
#line 366
      printf((char const   */* __restrict  */)" feat");
      }
    }
#line 367
    if (r->oflags.__annonCompField1.lob.nsect) {
      {
#line 367
      printf((char const   */* __restrict  */)" nsect");
      }
    }
#line 368
    if (r->oflags.__annonCompField1.lob.lbal) {
      {
#line 368
      printf((char const   */* __restrict  */)" lbal");
      }
    }
#line 369
    if (r->oflags.__annonCompField1.lob.lbam) {
      {
#line 369
      printf((char const   */* __restrict  */)" lbam");
      }
    }
#line 370
    if (r->oflags.__annonCompField1.lob.lbah) {
      {
#line 370
      printf((char const   */* __restrict  */)" lbah");
      }
    }
#line 371
    if (r->oflags.__annonCompField1.lob.dev) {
      {
#line 371
      printf((char const   */* __restrict  */)" dev");
      }
    }
#line 372
    if (r->oflags.__annonCompField1.lob.command) {
      {
#line 372
      printf((char const   */* __restrict  */)" command");
      }
    }
    {
#line 373
    printf((char const   */* __restrict  */)" }\n");
#line 374
    printf((char const   */* __restrict  */)"oflags.hob_all=0x%02x, flags={", r->oflags.__annonCompField2.hob_all);
    }
#line 375
    if (r->oflags.__annonCompField2.hob.feat) {
      {
#line 375
      printf((char const   */* __restrict  */)" feat");
      }
    }
#line 376
    if (r->oflags.__annonCompField2.hob.nsect) {
      {
#line 376
      printf((char const   */* __restrict  */)" nsect");
      }
    }
#line 377
    if (r->oflags.__annonCompField2.hob.lbal) {
      {
#line 377
      printf((char const   */* __restrict  */)" lbal");
      }
    }
#line 378
    if (r->oflags.__annonCompField2.hob.lbam) {
      {
#line 378
      printf((char const   */* __restrict  */)" lbam");
      }
    }
#line 379
    if (r->oflags.__annonCompField2.hob.lbah) {
      {
#line 379
      printf((char const   */* __restrict  */)" lbah");
      }
    }
    {
#line 380
    printf((char const   */* __restrict  */)" }\n");
    }
  }
#line 383
  if (r->oflags.__annonCompField1.lob.feat) {
#line 383
    tf.lob.feat = r->lob.feat;
  }
#line 384
  if (r->oflags.__annonCompField1.lob.lbal) {
#line 384
    tf.lob.lbal = r->lob.lbal;
  }
#line 385
  if (r->oflags.__annonCompField1.lob.nsect) {
#line 385
    tf.lob.nsect = r->lob.nsect;
  }
#line 386
  if (r->oflags.__annonCompField1.lob.lbam) {
#line 386
    tf.lob.lbam = r->lob.lbam;
  }
#line 387
  if (r->oflags.__annonCompField1.lob.lbah) {
#line 387
    tf.lob.lbah = r->lob.lbah;
  }
#line 388
  if (r->oflags.__annonCompField1.lob.dev) {
#line 388
    tf.dev = r->lob.dev;
  }
#line 389
  if (r->oflags.__annonCompField1.lob.command) {
#line 389
    tf.command = r->lob.command;
  }
  {
#line 390
  tmp = needs_lba48(tf.command, (__u64 )0, 0U);
  }
#line 390
  if (tmp) {
#line 390
    goto _L;
  } else
#line 390
  if (r->oflags.__annonCompField2.hob_all) {
#line 390
    goto _L;
  } else
#line 390
  if (r->iflags.__annonCompField2.hob_all) {
    _L: /* CIL Label */ 
#line 391
    tf.is_lba48 = (__u8 )1;
#line 392
    if (r->oflags.__annonCompField2.hob.feat) {
#line 392
      tf.hob.feat = r->hob.feat;
    }
#line 393
    if (r->oflags.__annonCompField2.hob.lbal) {
#line 393
      tf.hob.lbal = r->hob.lbal;
    }
#line 394
    if (r->oflags.__annonCompField2.hob.nsect) {
#line 394
      tf.hob.nsect = r->hob.nsect;
    }
#line 395
    if (r->oflags.__annonCompField2.hob.lbam) {
#line 395
      tf.hob.lbam = r->hob.lbam;
    }
#line 396
    if (r->oflags.__annonCompField2.hob.lbah) {
#line 396
      tf.hob.lbah = r->hob.lbah;
    }
#line 397
    if (verbose) {
      {
#line 398
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"using LBA48 taskfile\n");
      }
    }
  }
  {
#line 402
  if (r->cmd_req == 4) {
#line 402
    goto case_4;
  }
#line 402
  if (r->cmd_req == 3) {
#line 402
    goto case_4;
  }
#line 407
  if (r->cmd_req == 2) {
#line 407
    goto case_2;
  }
#line 400
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 403
  data_bytes = (unsigned int )r->obytes;
#line 404
  data = (void *)(r->data);
#line 405
  rw = 1;
#line 406
  goto switch_break;
  case_2: /* CIL Label */ 
#line 408
  data_bytes = (unsigned int )r->ibytes;
#line 409
  data = (void *)(r->data);
#line 410
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 413
  tmp___0 = is_dma(tf.command);
#line 413
  rc = sg16(fd___0, rw, tmp___0, & tf, data, data_bytes, timeout_secs);
  }
#line 414
  if (rc == -1) {
    {
#line 415
    tmp___1 = __errno_location();
    }
#line 415
    if (*tmp___1 == 22) {
#line 416
      goto use_legacy_ioctl;
    } else {
      {
#line 415
      tmp___2 = __errno_location();
      }
#line 415
      if (*tmp___2 == 19) {
#line 416
        goto use_legacy_ioctl;
      } else {
        {
#line 415
        tmp___3 = __errno_location();
        }
#line 415
        if (*tmp___3 == 52) {
#line 416
          goto use_legacy_ioctl;
        }
      }
    }
  }
#line 419
  if (rc == 0) {
#line 419
    goto _L___0;
  } else {
    {
#line 419
    tmp___4 = __errno_location();
    }
#line 419
    if (*tmp___4 == 5) {
      _L___0: /* CIL Label */ 
#line 420
      if (r->iflags.__annonCompField1.lob.feat) {
#line 420
        r->lob.feat = tf.error;
      }
#line 421
      if (r->iflags.__annonCompField1.lob.lbal) {
#line 421
        r->lob.lbal = tf.lob.lbal;
      }
#line 422
      if (r->iflags.__annonCompField1.lob.nsect) {
#line 422
        r->lob.nsect = tf.lob.nsect;
      }
#line 423
      if (r->iflags.__annonCompField1.lob.lbam) {
#line 423
        r->lob.lbam = tf.lob.lbam;
      }
#line 424
      if (r->iflags.__annonCompField1.lob.lbah) {
#line 424
        r->lob.lbah = tf.lob.lbah;
      }
#line 425
      if (r->iflags.__annonCompField1.lob.dev) {
#line 425
        r->lob.dev = tf.dev;
      }
#line 426
      if (r->iflags.__annonCompField1.lob.command) {
#line 426
        r->lob.command = tf.status;
      }
#line 427
      if (r->iflags.__annonCompField2.hob.feat) {
#line 427
        r->hob.feat = tf.hob.feat;
      }
#line 428
      if (r->iflags.__annonCompField2.hob.lbal) {
#line 428
        r->hob.lbal = tf.hob.lbal;
      }
#line 429
      if (r->iflags.__annonCompField2.hob.nsect) {
#line 429
        r->hob.nsect = tf.hob.nsect;
      }
#line 430
      if (r->iflags.__annonCompField2.hob.lbam) {
#line 430
        r->hob.lbam = tf.hob.lbam;
      }
#line 431
      if (r->iflags.__annonCompField2.hob.lbah) {
#line 431
        r->hob.lbah = tf.hob.lbah;
      }
    }
  }
#line 433
  return (rc);
  use_legacy_ioctl: 
#line 439
  if (verbose) {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying legacy HDIO_DRIVE_TASKFILE\n");
    }
  }
  {
#line 441
  tmp___5 = __errno_location();
#line 441
  *tmp___5 = 0;
#line 443
  rc = ioctl(fd___0, 797UL, r);
  }
#line 444
  if (verbose) {
    {
#line 445
    tmp___6 = __errno_location();
#line 445
    err = *tmp___6;
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rc=%d, errno=%d, returned ATA registers: ",
            rc, err);
    }
#line 447
    if (r->iflags.__annonCompField1.lob.feat) {
      {
#line 447
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" er=%02x",
              (int )r->lob.feat);
      }
    }
#line 448
    if (r->iflags.__annonCompField1.lob.nsect) {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ns=%02x",
              (int )r->lob.nsect);
      }
    }
#line 449
    if (r->iflags.__annonCompField1.lob.lbal) {
      {
#line 449
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ll=%02x",
              (int )r->lob.lbal);
      }
    }
#line 450
    if (r->iflags.__annonCompField1.lob.lbam) {
      {
#line 450
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" lm=%02x",
              (int )r->lob.lbam);
      }
    }
#line 451
    if (r->iflags.__annonCompField1.lob.lbah) {
      {
#line 451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" lh=%02x",
              (int )r->lob.lbah);
      }
    }
#line 452
    if (r->iflags.__annonCompField1.lob.dev) {
      {
#line 452
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" dh=%02x",
              (int )r->lob.dev);
      }
    }
#line 453
    if (r->iflags.__annonCompField1.lob.command) {
      {
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" st=%02x",
              (int )r->lob.command);
      }
    }
#line 454
    if (r->iflags.__annonCompField2.hob.feat) {
      {
#line 454
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.feat);
      }
    }
#line 455
    if (r->iflags.__annonCompField2.hob.nsect) {
      {
#line 455
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.nsect);
      }
    }
#line 456
    if (r->iflags.__annonCompField2.hob.lbal) {
      {
#line 456
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.lbal);
      }
    }
#line 457
    if (r->iflags.__annonCompField2.hob.lbam) {
      {
#line 457
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.lbam);
      }
    }
#line 458
    if (r->iflags.__annonCompField2.hob.lbah) {
      {
#line 458
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.lbah);
      }
    }
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 460
    tmp___7 = __errno_location();
#line 460
    *tmp___7 = err;
    }
  }
#line 462
  if (rc == -1) {
    {
#line 462
    tmp___9 = __errno_location();
    }
#line 462
    if (*tmp___9 == 22) {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The running kernel lacks CONFIG_IDE_TASK_IOCTL support for this device.\n");
#line 464
      tmp___8 = __errno_location();
#line 464
      *tmp___8 = 22;
      }
    }
  }
#line 466
  return (rc);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/sgio.c"
void init_hdio_taskfile(struct hdio_taskfile *r , __u8 ata_op , int rw , int force_lba48 ,
                        __u64 lba , unsigned int nsect , int data_bytes ) 
{ 
  int tmp ;

  {
  {
#line 472
  memset((void *)r, 0, sizeof(struct hdio_taskfile ) + (unsigned long )data_bytes);
  }
#line 473
  if (! data_bytes) {
#line 474
    r->dphase = 0;
#line 475
    r->cmd_req = 0;
  } else
#line 476
  if (rw == 1) {
#line 477
    r->dphase = 4;
#line 478
    r->cmd_req = 4;
#line 479
    r->obytes = (unsigned long )data_bytes;
  } else {
#line 481
    r->dphase = 1;
#line 482
    r->cmd_req = 2;
#line 483
    r->ibytes = (unsigned long )data_bytes;
  }
  {
#line 485
  r->lob.command = ata_op;
#line 486
  r->oflags.__annonCompField1.lob.command = 1U;
#line 487
  r->oflags.__annonCompField1.lob.dev = 1U;
#line 488
  r->oflags.__annonCompField1.lob.lbal = 1U;
#line 489
  r->oflags.__annonCompField1.lob.lbam = 1U;
#line 490
  r->oflags.__annonCompField1.lob.lbah = 1U;
#line 491
  r->oflags.__annonCompField1.lob.nsect = 1U;
#line 493
  r->iflags.__annonCompField1.lob.command = 1U;
#line 494
  r->iflags.__annonCompField1.lob.feat = 1U;
#line 496
  r->lob.nsect = (__u8 )nsect;
#line 497
  r->lob.lbal = (__u8 )lba;
#line 498
  r->lob.lbam = (__u8 )(lba >> 8);
#line 499
  r->lob.lbah = (__u8 )(lba >> 16);
#line 500
  r->lob.dev = (__u8 )224;
#line 502
  tmp = needs_lba48(ata_op, lba, nsect);
  }
#line 502
  if (tmp) {
#line 502
    goto _L;
  } else
#line 502
  if (force_lba48) {
    _L: /* CIL Label */ 
#line 503
    r->hob.nsect = (__u8 )(nsect >> 8);
#line 504
    r->hob.lbal = (__u8 )(lba >> 24);
#line 505
    r->hob.lbam = (__u8 )(lba >> 32);
#line 506
    r->hob.lbah = (__u8 )(lba >> 40);
#line 507
    r->oflags.__annonCompField2.hob.nsect = 1U;
#line 508
    r->oflags.__annonCompField2.hob.lbal = 1U;
#line 509
    r->oflags.__annonCompField2.hob.lbam = 1U;
#line 510
    r->oflags.__annonCompField2.hob.lbah = 1U;
  } else {
#line 512
    r->lob.dev = (__u8 )((unsigned long long )r->lob.dev | ((lba >> 24) & 15ULL));
  }
#line 514
  return;
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int prefer_ata12  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int verbose  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int vscenabled  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int force  =    0;
#line 38 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
char *device  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
char *progname  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int fd  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
static __u8 atabuffer[516]  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int check_WDC_drive(void) 
{ 
  int i ;
  int *tmp ;
  int tmp___0 ;

  {
#line 52
  if (verbose) {
    {
#line 53
    printf((char const   */* __restrict  */)"Checking if Drive is a Western Digital Drive\n");
    }
  }
  {
#line 56
  memset((void *)(atabuffer), 0, sizeof(atabuffer));
#line 57
  atabuffer[0] = (__u8 )236;
#line 58
  atabuffer[3] = (__u8 )1;
#line 59
  tmp___0 = do_drive_cmd(fd, atabuffer);
  }
#line 59
  if (tmp___0) {
    {
#line 60
    perror(" HDIO_DRIVE_CMD(identify) failed");
#line 61
    tmp = __errno_location();
    }
#line 61
    return (*tmp);
  }
#line 64
  if (! force) {
#line 66
    if ((int )atabuffer[59] != 87) {
#line 66
      goto _L;
    } else
#line 66
    if ((int )atabuffer[58] != 68) {
#line 66
      goto _L;
    } else
#line 66
    if ((int )atabuffer[61] != 67) {
      _L: /* CIL Label */ 
      {
#line 69
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The drive %s does not seem to be a Western Digital Drive ",
              device);
#line 70
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"but a ");
#line 71
      i = 27;
      }
      {
#line 71
      while (1) {
        while_continue: /* CIL Label */ ;
#line 71
        if (! (i < 47)) {
#line 71
          goto while_break;
        }
#line 72
        if ((int )atabuffer[(4 + i * 2) + 1] == 0) {
#line 72
          goto while_break;
        }
        {
#line 73
        putchar((int )atabuffer[(4 + i * 2) + 1]);
        }
#line 74
        if ((int )atabuffer[4 + i * 2] == 0) {
#line 74
          goto while_break;
        }
        {
#line 75
        putchar((int )atabuffer[4 + i * 2]);
#line 71
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 77
      printf((char const   */* __restrict  */)"\n");
#line 79
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use the --force option if you know what you\'re doing\n");
      }
#line 80
      return (1);
    }
  }
#line 84
  return (0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_enable(void) 
{ 
  int err ;
  struct ata_tf tf ;
  int *tmp ;
  int tmp___0 ;

  {
#line 90
  if (verbose) {
    {
#line 91
    printf((char const   */* __restrict  */)"Enabling Vendor Specific ATA commands\n");
    }
  }
  {
#line 94
  err = 0;
#line 96
  tf_init(& tf, (__u8 )128, (__u64 )0, 0U);
#line 97
  tf.lob.feat = (__u8 )69;
#line 98
  tf.lob.lbam = (__u8 )68;
#line 99
  tf.lob.lbah = (__u8 )87;
#line 100
  tf.dev = (__u8 )160;
#line 102
  tmp___0 = sg16(fd, 1, 0, & tf, (void *)0, 0U, 5U);
  }
#line 102
  if (tmp___0) {
    {
#line 103
    tmp = __errno_location();
#line 103
    err = *tmp;
#line 104
    perror("sg16(VSC_ENABLE) failed");
    }
#line 105
    return (err);
  }
#line 107
  vscenabled = 1;
#line 108
  return (0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_disable(void) 
{ 
  int err ;
  struct ata_tf tf ;
  int *tmp ;
  int tmp___0 ;

  {
#line 114
  if (verbose) {
    {
#line 115
    printf((char const   */* __restrict  */)"Disabling Vendor Specific ATA commands\n");
    }
  }
  {
#line 118
  err = 0;
#line 120
  tf_init(& tf, (__u8 )128, (__u64 )0, 0U);
#line 121
  tf.lob.feat = (__u8 )68;
#line 122
  tf.lob.lbam = (__u8 )68;
#line 123
  tf.lob.lbah = (__u8 )87;
#line 124
  tf.dev = (__u8 )160;
#line 126
  tmp___0 = sg16(fd, 1, 0, & tf, (void *)0, 0U, 5U);
  }
#line 126
  if (tmp___0) {
    {
#line 127
    tmp = __errno_location();
#line 127
    err = *tmp;
#line 128
    perror("sg16(VSC_DISABLE) failed");
    }
#line 129
    return (err);
  }
#line 131
  vscenabled = 0;
#line 132
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_send_key(char rw ) 
{ 
  int err ;
  char buffer[512] ;
  struct ata_tf tf ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 138
  err = 0;
#line 142
  tf_init(& tf, (__u8 )176, (__u64 )0, 0U);
#line 143
  tf.lob.feat = (__u8 )214;
#line 144
  tf.lob.nsect = (__u8 )1;
#line 145
  tf.lob.lbal = (__u8 )190;
#line 146
  tf.lob.lbam = (__u8 )79;
#line 147
  tf.lob.lbah = (__u8 )194;
#line 148
  tf.dev = (__u8 )160;
#line 150
  memset((void *)(buffer), 0, sizeof(buffer));
#line 151
  buffer[0] = (char)42;
#line 152
  buffer[2] = rw;
#line 153
  buffer[4] = (char)2;
#line 154
  buffer[6] = (char)13;
#line 155
  buffer[8] = (char)22;
#line 156
  buffer[10] = (char)1;
#line 158
  tmp___0 = sg16(fd, 1, 0, & tf, (void *)(buffer), 512U, 5U);
  }
#line 158
  if (tmp___0) {
    {
#line 159
    tmp = __errno_location();
#line 159
    err = *tmp;
#line 160
    perror("sg16(VSC_SENDKEY) failed");
    }
#line 161
    return (err);
  }
#line 163
  vscenabled = 0;
#line 164
  return (0);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_send_write_key(void) 
{ 
  int tmp ;

  {
#line 168
  if (verbose) {
    {
#line 169
    printf((char const   */* __restrict  */)"Sending WRITE key\n");
    }
  }
  {
#line 171
  tmp = VSC_send_key((char)2);
  }
#line 171
  return (tmp);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_send_read_key(void) 
{ 
  int tmp ;

  {
#line 175
  if (verbose) {
    {
#line 176
    printf((char const   */* __restrict  */)"Sending READ key\n");
    }
  }
  {
#line 178
  tmp = VSC_send_key((char)1);
  }
#line 178
  return (tmp);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_get_timer(unsigned char *timer ) 
{ 
  int err ;
  char buffer[512] ;
  struct ata_tf tf ;
  int *tmp ;
  int tmp___0 ;

  {
#line 184
  if (verbose) {
    {
#line 185
    printf((char const   */* __restrict  */)"Getting Idle3 timer value\n");
    }
  }
  {
#line 188
  err = 0;
#line 192
  tf_init(& tf, (__u8 )176, (__u64 )0, 0U);
#line 193
  tf.lob.feat = (__u8 )213;
#line 194
  tf.lob.nsect = (__u8 )1;
#line 195
  tf.lob.lbal = (__u8 )191;
#line 196
  tf.lob.lbam = (__u8 )79;
#line 197
  tf.lob.lbah = (__u8 )194;
#line 198
  tf.dev = (__u8 )160;
#line 200
  memset((void *)(buffer), 0, sizeof(buffer));
#line 202
  tmp___0 = sg16(fd, 0, 0, & tf, (void *)(buffer), 512U, 5U);
  }
#line 202
  if (tmp___0) {
    {
#line 203
    tmp = __errno_location();
#line 203
    err = *tmp;
#line 204
    perror("sg16(VSC_GET_TIMER) failed");
    }
#line 205
    return (err);
  }
#line 208
  *timer = (unsigned char )buffer[0];
#line 209
  return (0);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int VSC_set_timer(unsigned char timer ) 
{ 
  int err ;
  char buffer[512] ;
  struct ata_tf tf ;
  int *tmp ;
  int tmp___0 ;

  {
#line 215
  if (verbose) {
    {
#line 216
    printf((char const   */* __restrict  */)"Setting Idle3 timer value to %02x\n",
           (int )timer);
    }
  }
  {
#line 219
  err = 0;
#line 223
  tf_init(& tf, (__u8 )176, (__u64 )0, 0U);
#line 224
  tf.lob.feat = (__u8 )214;
#line 225
  tf.lob.nsect = (__u8 )1;
#line 226
  tf.lob.lbal = (__u8 )191;
#line 227
  tf.lob.lbam = (__u8 )79;
#line 228
  tf.lob.lbah = (__u8 )194;
#line 229
  tf.dev = (__u8 )160;
#line 231
  memset((void *)(buffer), 0, sizeof(buffer));
#line 232
  buffer[0] = (char )timer;
#line 234
  tmp___0 = sg16(fd, 1, 0, & tf, (void *)(buffer), 512U, 5U);
  }
#line 234
  if (tmp___0) {
    {
#line 235
    tmp = __errno_location();
#line 235
    err = *tmp;
#line 236
    perror("sg16(VSC_SET_TIMER) failed");
    }
#line 237
    return (err);
  }
#line 240
  return (0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
void cleanup(void) 
{ 


  {
#line 246
  if (fd == 0) {
#line 246
    return;
  }
#line 247
  if (vscenabled != 0) {
    {
#line 247
    VSC_disable();
    }
  }
  {
#line 248
  close(fd);
  }
#line 249
  return;
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
void show_version(void) 
{ 


  {
  {
#line 254
  printf((char const   */* __restrict  */)"%s v%s\n", progname, "0.9.1");
  }
#line 255
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
void show_usage(void) 
{ 


  {
  {
#line 260
  printf((char const   */* __restrict  */)"%s v%s - Read, Set or disable the idle3 timer of Western Digital drives\n",
         progname, "0.9.1");
#line 261
  printf((char const   */* __restrict  */)"Copyright (C) 2011  Christophe Bothamy\n");
#line 262
  printf((char const   */* __restrict  */)"\n");
#line 263
  printf((char const   */* __restrict  */)"Usage: %s [options] device\n", progname);
#line 264
  printf((char const   */* __restrict  */)"Options: \n");
#line 265
  printf((char const   */* __restrict  */)" -h : displat help\n");
#line 266
  printf((char const   */* __restrict  */)" -V : show version and exit immediately\n");
#line 267
  printf((char const   */* __restrict  */)" -v : verbose output\n");
#line 268
  printf((char const   */* __restrict  */)" --force : force even if no Western Digital HDD are detected\n");
#line 269
  printf((char const   */* __restrict  */)" -g : get raw idle3 timer value\n");
#line 270
  printf((char const   */* __restrict  */)" -g100 : get idle3 timer value as wdidle3 v1.00 value\n");
#line 271
  printf((char const   */* __restrict  */)" -g103 : get idle3 timer value as wdidle3 v1.03 value\n");
#line 272
  printf((char const   */* __restrict  */)" -g105 : get idle3 timer value as wdidle3 v1.05 value\n");
#line 273
  printf((char const   */* __restrict  */)" -d : disable idle3 timer\n");
#line 274
  printf((char const   */* __restrict  */)" -s<value> : set idle3 timer raw value\n");
  }
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/idle3-tools-0.9.1/idle3ctl.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int action ;
  unsigned char timer ;
  int display_usage ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 280
  action = 1;
#line 282
  display_usage = 1;
#line 284
  tmp = strrchr((char const   *)*argv, '/');
#line 284
  progname = tmp;
  }
#line 284
  if ((unsigned long )progname == (unsigned long )((void *)0)) {
#line 284
    progname = *argv;
  } else {
#line 285
    progname ++;
  }
  {
#line 288
  atexit(& cleanup);
#line 291
  i = 1;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! (i < argc)) {
#line 291
      goto while_break;
    }
    {
#line 292
    tmp___20 = strcmp((char const   *)*(argv + i), "-h");
    }
#line 292
    if (tmp___20 == 0) {
      {
#line 293
      show_usage();
#line 294
      exit(1);
      }
    } else {
      {
#line 296
      tmp___19 = strcmp((char const   *)*(argv + i), "-V");
      }
#line 296
      if (tmp___19 == 0) {
        {
#line 297
        show_version();
#line 298
        exit(1);
        }
      } else {
        {
#line 300
        tmp___18 = strcmp((char const   *)*(argv + i), "--force");
        }
#line 300
        if (tmp___18 == 0) {
#line 300
          force = 1;
        } else {
          {
#line 301
          tmp___17 = strcmp((char const   *)*(argv + i), "-v");
          }
#line 301
          if (tmp___17 == 0) {
#line 301
            verbose = 1;
          } else {
            {
#line 302
            tmp___16 = strcmp((char const   *)*(argv + i), "-g");
            }
#line 302
            if (tmp___16 == 0) {
#line 302
              action = 1;
            } else {
              {
#line 303
              tmp___15 = strcmp((char const   *)*(argv + i), "-g100");
              }
#line 303
              if (tmp___15 == 0) {
#line 303
                action = 2;
              } else {
                {
#line 304
                tmp___14 = strcmp((char const   *)*(argv + i), "-g103");
                }
#line 304
                if (tmp___14 == 0) {
#line 304
                  action = 3;
                } else {
                  {
#line 305
                  tmp___13 = strcmp((char const   *)*(argv + i), "-g105");
                  }
#line 305
                  if (tmp___13 == 0) {
#line 305
                    action = 3;
                  } else {
                    {
#line 306
                    tmp___12 = strcmp((char const   *)*(argv + i), "-d");
                    }
#line 306
                    if (tmp___12 == 0) {
#line 307
                      action = 0;
#line 308
                      timer = (unsigned char)0;
                    } else {
                      {
#line 310
                      tmp___11 = strncmp((char const   *)*(argv + i), "-s", (size_t )2);
                      }
#line 310
                      if (tmp___11 == 0) {
                        {
#line 311
                        action = 0;
#line 312
                        timer = (unsigned char)0;
#line 313
                        tmp___2 = strlen((char const   *)*(argv + i));
                        }
#line 313
                        if (tmp___2 > 2UL) {
                          {
#line 313
                          tmp___0 = atoi((char const   *)(*(argv + i) + 2));
#line 313
                          timer = (unsigned char )tmp___0;
                          }
                        } else {
#line 315
                          i ++;
#line 315
                          if (i < argc) {
                            {
#line 315
                            tmp___1 = atoi((char const   *)*(argv + i));
#line 315
                            timer = (unsigned char )tmp___1;
                            }
                          }
                        }
#line 317
                        if ((int )timer <= 0) {
                          {
#line 318
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to parse a positive value to set timer\n");
#line 319
                          exit(1);
                          }
                        }
                      } else {
                        {
#line 322
                        tmp___10 = strncmp((char const   *)*(argv + i), "-", (size_t )1);
                        }
#line 322
                        if (tmp___10 == 0) {
                          {
#line 323
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option \'%s\'\n\n",
                                  *(argv + i));
#line 324
                          show_usage();
#line 325
                          exit(1);
                          }
                        } else {
                          {
#line 328
                          display_usage = 0;
#line 331
                          device = *(argv + i);
#line 332
                          fd = open((char const   *)device, 2048);
                          }
#line 333
                          if (fd < 0) {
                            {
#line 334
                            perror("open failed");
#line 335
                            exit(1);
                            }
                          }
                          {
#line 339
                          tmp___3 = check_WDC_drive();
                          }
#line 339
                          if (tmp___3 != 0) {
                            {
#line 340
                            exit(1);
                            }
                          }
                          {
#line 343
                          tmp___4 = VSC_enable();
                          }
#line 343
                          if (tmp___4 != 0) {
                            {
#line 343
                            exit(1);
                            }
                          }
#line 345
                          if (action == 0) {
                            {
#line 346
                            tmp___5 = VSC_send_write_key();
                            }
#line 346
                            if (tmp___5 != 0) {
                              {
#line 346
                              exit(1);
                              }
                            }
                            {
#line 347
                            tmp___6 = VSC_set_timer(timer);
                            }
#line 347
                            if (tmp___6 != 0) {
                              {
#line 347
                              exit(1);
                              }
                            }
#line 349
                            if ((int )timer == 0) {
                              {
#line 349
                              printf((char const   */* __restrict  */)"Idle3 timer disabled\n");
                              }
                            } else {
                              {
#line 350
                              printf((char const   */* __restrict  */)"Idle3 timer set to %d (0x%02x)\n",
                                     (int )timer, (int )timer);
                              }
                            }
                            {
#line 352
                            printf((char const   */* __restrict  */)"Please power cycle your drive off and on for the new setting to be taken into account. A reboot will not be enough!\n");
                            }
                          } else
#line 355
                          if (action >= 1) {
                            {
#line 356
                            tmp___7 = VSC_send_read_key();
                            }
#line 356
                            if (tmp___7 != 0) {
                              {
#line 356
                              exit(1);
                              }
                            }
                            {
#line 357
                            tmp___8 = VSC_get_timer(& timer);
                            }
#line 357
                            if (tmp___8 != 0) {
                              {
#line 357
                              exit(1);
                              }
                            }
#line 359
                            if ((int )timer == 0) {
                              {
#line 360
                              printf((char const   */* __restrict  */)"Idle3 timer is disabled\n");
                              }
                            } else {
                              {
#line 363
                              if (action == 1) {
#line 363
                                goto case_1;
                              }
#line 366
                              if (action == 2) {
#line 366
                                goto case_2;
                              }
#line 369
                              if (action == 3) {
#line 369
                                goto case_3;
                              }
#line 362
                              goto switch_break;
                              case_1: /* CIL Label */ 
                              {
#line 364
                              printf((char const   */* __restrict  */)"Idle3 timer set to %d (0x%02x)\n",
                                     (int )timer, (int )timer);
                              }
#line 365
                              goto switch_break;
                              case_2: /* CIL Label */ 
                              {
#line 367
                              printf((char const   */* __restrict  */)"Idle3 timer set to %.1fs (0x%02x)\n",
                                     (double )timer / 10.0, (int )timer);
                              }
#line 368
                              goto switch_break;
                              case_3: /* CIL Label */ 
#line 370
                              if ((int )timer < 129) {
#line 370
                                tmp___9 = (double )timer / 10.0;
                              } else {
#line 370
                                tmp___9 = (double )((int )timer - 128) * 30.0;
                              }
                              {
#line 370
                              printf((char const   */* __restrict  */)"Idle3 timer set to %.1fs (0x%02x)\n",
                                     tmp___9, (int )timer);
                              }
#line 371
                              goto switch_break;
                              switch_break: /* CIL Label */ ;
                              }
                            }
                          }
                          {
#line 375
                          VSC_disable();
#line 377
                          close(fd);
#line 378
                          fd = 0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  if (display_usage) {
    {
#line 383
    show_usage();
    }
  }
  {
#line 386
  exit(0);
  }
}
}
