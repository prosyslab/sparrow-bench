/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct SgrepStruct;
#line 112 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct SgrepStringStruct {
   struct SgrepStruct *sgrep ;
   size_t size ;
   size_t length ;
   char *s ;
   struct SgrepStringStruct *escaped ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct SgrepStringStruct SgrepString;
#line 126 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct RegionStruct {
   int start ;
   int end ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct RegionStruct Region;
#line 135 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct ListNodeStruct {
   Region list[1 << 7] ;
   struct ListNodeStruct *next ;
   struct ListNodeStruct *prev ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct ListNodeStruct ListNode;
#line 144
struct RegionListStruct;
#line 154
enum RegionListSorted {
    NOT_SORTED = 0,
    START_SORTED = 1,
    END_SORTED = 2
} ;
#line 155 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct RegionListStruct {
   struct SgrepStruct *sgrep ;
   int nodes ;
   int length ;
   int chars ;
   int refcount ;
   int nested ;
   enum RegionListSorted sorted ;
   int complete ;
   ListNode *first ;
   ListNode *last ;
   ListNode *end_sorted ;
   struct RegionListStruct *next ;
   ListNode **start_sorted_array ;
};
#line 155 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct RegionListStruct RegionList;
#line 222
struct TempFileStruct;
#line 222 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct TempFileStruct TempFile;
#line 227 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct Statistics {
   int phrases ;
   int operators_evaluated ;
   int order ;
   int or_oper ;
   int in ;
   int not_in ;
   int equal ;
   int not_equal ;
   int containing ;
   int not_containing ;
   int extracting ;
   int quote ;
   int inner ;
   int outer ;
   int concat ;
   int join ;
   int parenting ;
   int childrening ;
   int region_lists ;
   int constant_lists ;
   int region_lists_now ;
   int gc_nodes ;
   int gc_nodes_allocated ;
   int longest_list ;
   int output ;
   int scans ;
   int scanned_files ;
   int scanned_bytes ;
   int sorts_by_start ;
   int sorts_by_end ;
   int sorts_optimized ;
   int remove_duplicates ;
   int parse_tree_size ;
   int optimized_phrases ;
   int optimized_nodes ;
   int input_size ;
   int memory_blocks ;
   size_t memory_allocated ;
   size_t peak_memory_usage ;
   int reallocs ;
};
#line 397
enum __anonenum_ScannerType_26 {
    SGML_SCANNER = 0,
    XML_SCANNER = 1,
    TEXT_SCANNER = 2
} ;
#line 397 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef enum __anonenum_ScannerType_26 ScannerType;
#line 403
enum Encoding {
    ENCODING_GUESS = 0,
    ENCODING_8BIT = 1,
    ENCODING_UTF8 = 2,
    ENCODING_UTF16 = 3
} ;
#line 410
struct MemoryBlockStruct;
#line 411
struct IndexReaderStruct;
#line 411 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct SgrepStruct {
   char *index_file ;
   int recurse_dirs ;
   struct Statistics statistics ;
   int do_concat ;
   struct IndexReaderStruct *index_reader ;
   void (*progress_callback)(void *data , int files_processed , int total_files ,
                             int bytes_processed , int total_bytes ) ;
   void *progress_data ;
   FILE *progress_stream ;
   int progress_output ;
   SgrepString *error ;
   FILE *error_stream ;
   char *word_chars ;
   char *output_style ;
   int open_failure ;
   int print_newline ;
   int print_all ;
   int stream_mode ;
   ScannerType scanner_type ;
   int ignore_case ;
   enum Encoding default_encoding ;
   int sgml_debug ;
   int include_system_entities ;
   RegionList *chars_list ;
   TempFile *first_temp_file ;
   TempFile *stdin_temp_file ;
   struct MemoryBlockStruct *m_blocks ;
};
#line 411 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct SgrepStruct SgrepData;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 146 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
struct TempFileStruct {
   SgrepData *sgrep ;
   char *file_name ;
   FILE *stream ;
   TempFile *next ;
   TempFile *prev ;
};
#line 328 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
typedef struct MemoryBlockStruct MemoryBlock;
#line 329 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
struct MemoryBlockStruct {
   int magic ;
   char const   *file ;
   int line ;
   size_t size ;
   struct MemoryBlockStruct *prev ;
   struct MemoryBlockStruct *next ;
};
#line 94 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
enum Oper {
    IN = 0,
    NOT_IN = 1,
    CONTAINING = 2,
    NOT_CONTAINING = 3,
    EQUAL = 4,
    NOT_EQUAL = 5,
    ORDERED = 6,
    L_ORDERED = 7,
    R_ORDERED = 8,
    LR_ORDERED = 9,
    QUOTE = 10,
    L_QUOTE = 11,
    R_QUOTE = 12,
    LR_QUOTE = 13,
    EXTRACTING = 14,
    OR = 15,
    PARENTING = 16,
    CHILDRENING = 17,
    NEAR = 18,
    NEAR_BEFORE = 19,
    OUTER = 20,
    INNER = 21,
    CONCAT = 22,
    JOIN = 23,
    FIRST = 24,
    LAST = 25,
    FIRST_BYTES = 26,
    LAST_BYTES = 27,
    PHRASE = 28,
    INVALID = 29
} ;
#line 185
struct ParseTreeNodeStruct;
#line 185 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct PHRASE_NODE {
   struct PHRASE_NODE *next ;
   SgrepString *phrase ;
   RegionList *regions ;
   struct ParseTreeNodeStruct *parent ;
};
#line 185 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct PHRASE_NODE ParseTreeLeaf;
#line 197 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct ParseTreeNodeStruct {
   enum Oper oper ;
   struct ParseTreeNodeStruct *parent ;
   struct ParseTreeNodeStruct *left ;
   struct ParseTreeNodeStruct *right ;
   int label_left ;
   int label_right ;
   int refcount ;
   RegionList *result ;
   int number ;
   ParseTreeLeaf *leaf ;
};
#line 197 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct ParseTreeNodeStruct ParseTreeNode;
#line 20 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
struct __anonstruct_Optimizer_28 {
   SgrepData *sgrep ;
   int label_c ;
   ParseTreeNode **root ;
   ParseTreeLeaf **phrase_list ;
   int tree_size ;
   int optimized_nodes ;
   int optimized_phrases ;
};
#line 20 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
typedef struct __anonstruct_Optimizer_28 Optimizer;
#line 144 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct __anonstruct_ListIterator_25 {
   struct RegionListStruct  const  *list ;
   ListNode *node ;
   int ind ;
};
#line 144 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct __anonstruct_ListIterator_25 ListIterator;
#line 218
struct FileListStruct;
#line 219 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct FileListStruct FileList;
#line 579 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct IndexReaderStruct IndexReader;
#line 33 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
struct __anonstruct_Evaluator_28 {
   struct SgrepStruct *sgrep ;
   FileList const   *files ;
   Region *tmp_stack ;
   int tmp_stack_size ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
typedef struct __anonstruct_Evaluator_28 Evaluator;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 111 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef int SgrepChar;
#line 284 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
struct __anonstruct_OneFile_29 {
   int start ;
   int length ;
   char *name ;
};
#line 284 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
typedef struct __anonstruct_OneFile_29 OneFile;
#line 289 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
struct FileListStruct {
   SgrepData *sgrep ;
   int total_size ;
   int num_files ;
   int allocated ;
   OneFile *files ;
   int last_errno ;
   int progress_limit ;
};
#line 1031
enum SortTypes {
    SORT_BY_START = 0,
    SORT_BY_END = 1
} ;
#line 580 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct IndexWriterStruct;
#line 581
struct IndexEntryListStruct;
#line 582 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct IndexEntryListStruct IndexEntryList;
#line 583
struct IndexEntryStruct;
#line 584 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct IndexEntryStruct IndexEntry;
#line 601
enum IndexModes {
    IM_NONE = 0,
    IM_CREATE = 1,
    IM_TERMS = 2,
    IM_DONE = 3
} ;
#line 602 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct __anonstruct_IndexOptions_27 {
   struct SgrepStruct *sgrep ;
   enum IndexModes index_mode ;
   int index_stats ;
   int stop_word_limit ;
   char const   *input_stop_word_file ;
   char const   *output_stop_word_file ;
   int hash_table_size ;
   int available_memory ;
   FileList *file_list_files ;
   FileList *file_list ;
   char const   *file_name ;
};
#line 602 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct __anonstruct_IndexOptions_27 IndexOptions;
#line 64 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexBlock {
   int next ;
   unsigned char buf[32] ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct ExternalIndexBuffer {
   int first ;
   int current ;
   int bytes ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct __anonstruct_internal_29 {
   unsigned char ibuf[12] ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct __anonstruct_map_30 {
   unsigned char const   *buf ;
   int ind ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
union __anonunion_list_28 {
   struct __anonstruct_internal_29 internal ;
   struct ExternalIndexBuffer external ;
   struct __anonstruct_map_30 map ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexBufferStruct {
   char *str ;
   struct IndexBufferStruct *next ;
   union __anonunion_list_28 list ;
   int last_index ;
   int saved_bytes ;
   short block_used ;
   short last_len ;
   unsigned char lcp ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
typedef struct IndexBufferStruct IndexBuffer;
#line 111 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexReaderStruct {
   SgrepData *sgrep ;
   char const   *filename ;
   void *map ;
   size_t size ;
   int len ;
   unsigned char const   *array ;
   void const   *entries ;
};
#line 121 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexBufferArray {
   IndexBuffer bufs[1024] ;
   struct IndexBufferArray *next ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexWriterStruct {
   struct SgrepStruct *sgrep ;
   IndexOptions const   *options ;
   FileList *file_list ;
   struct IndexBufferArray *free_index_buffers ;
   int first_free_index_buffer ;
   int hash_size ;
   IndexBuffer **htable ;
   IndexBuffer *sorted_buffers ;
   int spool_size ;
   int spool_used ;
   struct IndexBlock *spool ;
   TempFile *memory_load_files[256] ;
   int memory_loads ;
   FILE *stream ;
   int terms ;
   int postings ;
   int total_postings_bytes ;
   int total_string_bytes ;
   int strings_lcps_compressed ;
   int entry_lengths[8] ;
   int flist_start ;
   int flist_size ;
   int total_index_file_size ;
   int failed ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
typedef struct IndexWriterStruct IndexWriter;
#line 176 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexEntryListStruct {
   int hits ;
   IndexReader *reader ;
   IndexEntry *first ;
   IndexEntry *last ;
};
#line 183 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct IndexEntryStruct {
   char *term ;
   unsigned char const   *postings ;
   struct IndexEntryStruct *next ;
};
#line 192 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct SortingReaderStruct {
   Region *regions[32] ;
   int sizes[32] ;
   int lists_merged ;
   int regions_merged ;
   int max ;
   Region one ;
   Region *saved_array ;
   int saved_size ;
   int dots ;
};
#line 209 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
union __anonunion_data_31 {
   struct IndexEntryListStruct *entry_list ;
   RegionList *reader ;
   struct SortingReaderStruct sorting_reader ;
   FILE *stream ;
};
#line 209 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
struct LookupStruct {
   SgrepData *sgrep ;
   char const   *begin ;
   char const   *end ;
   IndexReader *map ;
   void (*callback)(char const   *str , unsigned char const   *regions , struct LookupStruct *data ) ;
   int stop_words ;
   union __anonunion_data_31 data ;
};
#line 631 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct SGMLScannerStruct;
#line 632 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct SGMLScannerStruct SGMLScanner;
#line 29 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
struct CharacterListStruct {
   unsigned long bitmap[65536UL / sizeof(unsigned long )] ;
   SgrepData *sgrep ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
typedef struct CharacterListStruct CharacterList;
#line 49
enum SGMLState {
    SGML_PCDATA = 0,
    SGML_WORD = 1,
    SGML_ENTITY_OPEN = 2,
    SGML_ENTITY = 3,
    SGML_PCDATA_ENTITY = 4,
    SGML_WORD_ENTITY = 5,
    SGML_CHARACTER_REFERENCE_OPEN = 6,
    SGML_DECIMAL_CHARACTER_REFERENCE = 7,
    SGML_HEX_CHARACTER_REFERENCE = 8,
    SGML_CHARACTER_REFERENCE_CLOSE = 9,
    SGML_STAGO = 10,
    SGML_GI = 11,
    SGML_W_ATTNAME = 12,
    SGML_ATTNAME = 13,
    SGML_W_ATTEQUAL = 14,
    SGML_W_ATTVALUE = 15,
    SGML_ATTVALUE = 16,
    SGML_ATTVALUE_DQUOTED = 17,
    SGML_ATTVALUE_SQUOTED = 18,
    SGML_ATTRIBUTE_END = 19,
    SGML_STAGC = 20,
    SGML_END_TAG = 21,
    SGML_W_ETAGC = 22,
    SGML_DECLARATION_START = 23,
    SGML_DOCTYPE_DECLARATION = 24,
    SGML_COMMENT_START = 25,
    SGML_COMMENT = 26,
    SGML_COMMENT_WORD = 27,
    SGML_COMMENT_END1 = 28,
    SGML_COMMENT_END2 = 29,
    SGML_PI = 30,
    SGML_PI_END = 31,
    SGML_MARKED_SECTION_START = 32,
    SGML_MARKED_SECTION_START2 = 33,
    SGML_CDATA_MARKED_SECTION = 34,
    SGML_CDATA_MARKED_SECTION_WORD = 35,
    SGML_CDATA_MARKED_SECTION_END1 = 36,
    SGML_CDATA_MARKED_SECTION_END2 = 37,
    SGML_DOCTYPE = 38,
    SGML_DOCTYPE_EXTERNAL = 39,
    SGML_DOCTYPE_PUBLIC = 40,
    SGML_DOCTYPE_SYSTEM = 41,
    SGML_WAITING_LITERAL = 42,
    SGML_LITERAL_START = 43,
    SGML_LITERAL_SQUOTED = 44,
    SGML_LITERAL_DQUOTED = 45,
    SGML_DOCTYPE_PUBLIC_ID_START = 46,
    SGML_DOCTYPE_PUBLIC_ID = 47,
    SGML_DOCTYPE_SYSTEM_ID_START = 48,
    SGML_DOCTYPE_SYSTEM_ID = 49,
    SGML_DOCTYPE_INTERNAL_START = 50,
    SGML_DOCTYPE_INTERNAL = 51,
    SGML_INTERNAL_DECLARATION_START1 = 52,
    SGML_INTERNAL_DECLARATION_START2 = 53,
    SGML_PEREFERENCE = 54,
    SGML_INTERNAL_DECLARATION_NAME = 55,
    SGML_ENTITY_DECLARATION = 56,
    SGML_ENTITY_DECLARATION_NAME = 57,
    SGML_ENTITY_DEFINITION = 58,
    SGML_ENTITY_DEFINITION_TYPE = 59,
    SGML_LITERAL_ENTITY = 60,
    SGML_GENERAL_ENTITY_DEFINITION_DQUOTED = 61,
    SGML_GENERAL_ENTITY_DEFINITION_SQUOTED = 62,
    SGML_ENTITY_DEFINITION_PUBLIC_ID = 63,
    SGML_WAITING_ENTITY_DEFINITION_SYSTEM_ID = 64,
    SGML_ENTITY_DEFINITION_SYSTEM_ID = 65,
    SGML_ENTITY_DEFINITION_NDATA = 66,
    SGML_ENTITY_DEFINITION_NDATA2 = 67,
    SGML_ENTITY_DEFINITION_NDATA_NAME = 68,
    SGML_ENTITY_DEFINITION_END = 69,
    SGML_ELEMENT_TYPE_DECLARATION = 70,
    SGML_ATTLIST_DECLARATION = 71,
    SGML_NOTATION_DECLARATION = 72,
    SGML_DOCTYPE_END = 73,
    SGML_RESERVED_WORD = 74
} ;
#line 103 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
struct ElementStackStruct {
   char *gi ;
   int start ;
   int end ;
   struct ElementStackStruct *prev ;
};
#line 103 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
typedef struct ElementStackStruct ElementStack;
#line 110
enum EncoderState {
    EIGHT_BIT = 0,
    UTF8_1 = 1,
    UTF8_2 = 2,
    UTF8_3_1 = 3,
    UTF8_3_2 = 4,
    UTF16_1 = 5,
    UTF16_BIG_START = 6,
    UTF16_BIG = 7,
    UTF16_SMALL_START = 8,
    UTF16_SMALL = 9
} ;
#line 118 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
struct EncoderStruct {
   enum EncoderState estate ;
   int char1 ;
   int char2 ;
   int prev ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
typedef struct EncoderStruct Encoder;
#line 126 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
struct SGMLScannerStruct {
   SgrepData *sgrep ;
   FileList *file_list ;
   int file_num ;
   Encoder encoder ;
   ScannerType type ;
   CharacterList *name_start_chars ;
   CharacterList *name_chars ;
   CharacterList *word_chars ;
   CharacterList *indexed_chars ;
   int ignore_case ;
   int include_system_entities ;
   int maintain_element_stack ;
   ElementStack *top ;
   RegionList *element_list ;
   int parse_errors ;
   struct PHRASE_NODE *phrase_list ;
   int words ;
   int word_end ;
   SgrepString *word ;
   int tags ;
   SgrepString *gi ;
   int anames ;
   SgrepString *aname ;
   int avals ;
   SgrepString *aval ;
   int comments ;
   int comment_words ;
   SgrepString *comment_word ;
   int markeds ;
   int doctypes ;
   int doctype_declarations ;
   int internal_declarations ;
   int entity_has_systemid ;
   int entity_is_ndata ;
   int entitys ;
   int character_reference ;
   SgrepString *name ;
   int name2s ;
   SgrepString *name2 ;
   int literals ;
   SgrepString *literal ;
   int publici ;
   int systemi ;
   SgrepString *pi ;
   enum SGMLState state ;
   enum SGMLState state_stack[10] ;
   int state_stack_ptr ;
   void (*entry)(struct SGMLScannerStruct *state , char const   *str , int start ,
                 int end ) ;
   void *data ;
   int failed ;
};
#line 707 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
struct DisplayerStruct;
#line 707 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
typedef struct DisplayerStruct Displayer;
#line 19 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
struct DisplayerStruct {
   struct SgrepStruct *sgrep ;
   FileList const   *files ;
   int region ;
   int current_file ;
   int last ;
   int first_ind ;
   int last_char ;
   int start_warned ;
   int end_warned ;
   FILE *stream ;
   char *map ;
   size_t map_size ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
enum Token {
    W_IN = 0,
    W_NOT = 1,
    W_CONTAINING = 2,
    W_OR = 3,
    W_ORDERED = 4,
    W_L_ORDERED = 5,
    W_R_ORDERED = 6,
    W_LR_ORDERED = 7,
    W_EXTRACTING = 8,
    W_QUOTE = 9,
    W_L_QUOTE = 10,
    W_R_QUOTE = 11,
    W_LR_QUOTE = 12,
    W_EQUAL = 13,
    W_PARENTING = 14,
    W_CHILDRENING = 15,
    W_NEAR = 16,
    W_NEAR_BEFORE = 17,
    W_OUTER = 18,
    W_INNER = 19,
    W_CONCAT = 20,
    W_JOIN = 21,
    W_FIRST = 22,
    W_LAST = 23,
    W_FIRST_BYTES = 24,
    W_LAST_BYTES = 25,
    W_CHARS = 26,
    W_START = 27,
    W_END = 28,
    W_PROLOG = 29,
    W_ELEMENTS = 30,
    W_FILE = 31,
    W_STRING = 32,
    W_REGEX = 33,
    W_DOCTYPE = 34,
    W_DOCTYPE_PID = 35,
    W_DOCTYPE_SID = 36,
    W_PI = 37,
    W_ATTRIBUTE = 38,
    W_ATTVALUE = 39,
    W_STAG = 40,
    W_ETAG = 41,
    W_COMMENT = 42,
    W_COMMENT_WORD = 43,
    W_WORD = 44,
    W_CDATA = 45,
    W_ENTITY = 46,
    W_ENTITY_DECLARATION = 47,
    W_ENTITY_LITERAL = 48,
    W_ENTITY_PID = 49,
    W_ENTITY_SID = 50,
    W_ENTITY_NDATA = 51,
    W_RAW = 52,
    R_WORDS = 53,
    W_LPAREN = 54,
    W_RPAREN = 55,
    W_LBRACK = 56,
    W_RBRACK = 57,
    W_COMMA = 58,
    W_PHRASE = 59,
    W_NUMBER = 60,
    W_EOF = 61,
    W_PARSE_ERROR = 62,
    W_END_TOKENS = 63
} ;
#line 69
enum ScannerState {
    SCANNER_START = 0,
    SCANNER_STRING = 1,
    SCANNER_NAME = 2,
    SCANNER_NUMBER = 3,
    SCANNER_COMMENT = 4,
    SCANNER_LINE_START_COMMENT = 5,
    SCANNER_LINE_NUMBER_COMMENT = 6,
    SCANNER_FILE_NAME_COMMENT_START = 7,
    SCANNER_FILE_NAME_COMMENT = 8
} ;
#line 84 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
struct __anonstruct_Parser_29 {
   SgrepData *sgrep ;
   char const   *expr_str ;
   int expr_ind ;
   int ch ;
   enum Token token ;
   SgrepString *unexpanded_string_token ;
   SgrepString *string_token ;
   struct PHRASE_NODE *first_phrase ;
   int line ;
   int column ;
   SgrepString *file ;
   int errline ;
   int errcol ;
   int errind ;
   enum ScannerState scanner_state ;
   int nodes ;
   ParseTreeNode *node_array[5000] ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
typedef struct __anonstruct_Parser_29 Parser;
#line 140 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
struct __anonstruct_reserved_words_30 {
   char const   *word ;
   enum Token t ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
struct index_opt_data {
   char opt ;
   char *have_param ;
   char *what_does ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ScanBuffer {
   SgrepData *sgrep ;
   FileList *file_list ;
   int len ;
   int file_num ;
   int old_file_num ;
   int last_file ;
   int region_start ;
   unsigned char const   *map ;
   int map_size ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct OutputList {
   struct PHRASE_NODE *phrase ;
   struct OutputList *next ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ACState {
   struct ACState *gotos[256] ;
   struct ACState *fail ;
   struct ACState *next ;
   struct OutputList *output_list ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ACScanner {
   SgrepData *sgrep ;
   struct PHRASE_NODE *phrase_list ;
   struct ACState *root_state ;
   struct ACState *s ;
   int ignore_case ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
enum ExpressionType {
    E_FILE = 0,
    E_TEXT = 1
} ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
struct Expression {
   enum ExpressionType type ;
   char *expr ;
   struct Expression *next ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
struct time_points {
   struct tms start ;
   struct tms parsing ;
   struct tms acsearch ;
   struct tms eval ;
   struct tms output ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
struct OptionData {
   char opt ;
   char *have_param ;
   char *what_does ;
};
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 539 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
TempFile *create_temp_file(SgrepData *sgrep___0 ) ;
#line 540
int delete_temp_file(TempFile *temp_file ) ;
#line 542
FILE *temp_file_stream(TempFile *temp_file ) ;
#line 548
int ( /* format attribute */  sgrep_error)(SgrepData *sgrep___0 , char *format  , ...) ;
#line 561
int preprocess(SgrepData *sgrep___0 , char *input_str , char *output_str , char *processor ,
               int maxsize ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 229 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/preproc.c"
int preprocess(SgrepData *sgrep___0 , char *input_str , char *output_str , char *processor ,
               int maxsize ) 
{ 
  TempFile *temp_file1 ;
  TempFile *temp_file2 ;
  FILE *tmpf1 ;
  FILE *tmpf2 ;
  int tmp_stdinfd ;
  int tmp_stdoutfd ;
  int out_bytes ;
  int e ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;

  {
  {
#line 234
  out_bytes = 0;
#line 237
  tmp___0 = strcmp((char const   *)processor, "-");
  }
#line 237
  if (tmp___0 == 0) {
    {
#line 238
    strncpy((char */* __restrict  */)output_str, (char const   */* __restrict  */)input_str,
            (size_t )maxsize);
#line 239
    tmp = strlen((char const   *)output_str);
    }
#line 239
    return ((int )tmp);
  }
  {
#line 241
  temp_file2 = (TempFile *)((void *)0);
#line 241
  temp_file1 = temp_file2;
#line 242
  tmpf2 = (FILE *)((void *)0);
#line 242
  tmpf1 = tmpf2;
#line 243
  tmp_stdoutfd = -1;
#line 243
  tmp_stdinfd = tmp_stdoutfd;
#line 247
  temp_file1 = create_temp_file(sgrep___0);
  }
#line 247
  if ((unsigned long )temp_file1 == (unsigned long )((void *)0)) {
    {
#line 249
    sgrep_error(sgrep___0, (char *)"Failed to create tmpfile for preprocessing\n");
    }
#line 250
    goto error;
  } else {
    {
#line 247
    temp_file2 = create_temp_file(sgrep___0);
    }
#line 247
    if ((unsigned long )temp_file2 == (unsigned long )((void *)0)) {
      {
#line 249
      sgrep_error(sgrep___0, (char *)"Failed to create tmpfile for preprocessing\n");
      }
#line 250
      goto error;
    }
  }
  {
#line 252
  tmpf1 = temp_file_stream(temp_file1);
#line 253
  tmpf2 = temp_file_stream(temp_file2);
#line 254
  tmp___3 = fputs((char const   */* __restrict  */)input_str, (FILE */* __restrict  */)tmpf1);
  }
#line 254
  if (tmp___3 == -1) {
    {
#line 258
    tmp___1 = __errno_location();
#line 258
    tmp___2 = strerror(*tmp___1);
#line 258
    sgrep_error(sgrep___0, (char *)"Failed to write preprocessor tmpfile: %s\n", tmp___2);
    }
#line 260
    goto error;
  } else {
    {
#line 254
    tmp___4 = fseek(tmpf1, 0L, 0);
    }
#line 254
    if (tmp___4 != 0) {
      {
#line 258
      tmp___1 = __errno_location();
#line 258
      tmp___2 = strerror(*tmp___1);
#line 258
      sgrep_error(sgrep___0, (char *)"Failed to write preprocessor tmpfile: %s\n",
                  tmp___2);
      }
#line 260
      goto error;
    } else {
      {
#line 254
      tmp___5 = fflush(tmpf1);
      }
#line 254
      if (tmp___5 == -1) {
        {
#line 258
        tmp___1 = __errno_location();
#line 258
        tmp___2 = strerror(*tmp___1);
#line 258
        sgrep_error(sgrep___0, (char *)"Failed to write preprocessor tmpfile: %s\n",
                    tmp___2);
        }
#line 260
        goto error;
      } else {
        {
#line 254
        tmp___6 = ferror(tmpf1);
        }
#line 254
        if (tmp___6) {
          {
#line 258
          tmp___1 = __errno_location();
#line 258
          tmp___2 = strerror(*tmp___1);
#line 258
          sgrep_error(sgrep___0, (char *)"Failed to write preprocessor tmpfile: %s\n",
                      tmp___2);
          }
#line 260
          goto error;
        }
      }
    }
  }
  {
#line 264
  tmp_stdinfd = dup(0);
  }
#line 264
  if (tmp_stdinfd == -1) {
    {
#line 266
    tmp___7 = __errno_location();
#line 266
    tmp___8 = strerror(*tmp___7);
#line 266
    sgrep_error(sgrep___0, (char *)"dup: %s\n", tmp___8);
    }
#line 267
    goto error;
  } else {
    {
#line 264
    tmp_stdoutfd = dup(1);
    }
#line 264
    if (tmp_stdoutfd == -1) {
      {
#line 266
      tmp___7 = __errno_location();
#line 266
      tmp___8 = strerror(*tmp___7);
#line 266
      sgrep_error(sgrep___0, (char *)"dup: %s\n", tmp___8);
      }
#line 267
      goto error;
    }
  }
#line 271
  if (tmp_stdinfd >= 2) {
#line 271
    if (! (tmp_stdoutfd >= 2)) {
      {
#line 271
      __assert_fail("tmp_stdinfd>=2 && tmp_stdoutfd>=2", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/preproc.c",
                    271U, "preprocess");
      }
    }
  } else {
    {
#line 271
    __assert_fail("tmp_stdinfd>=2 && tmp_stdoutfd>=2", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/preproc.c",
                  271U, "preprocess");
    }
  }
  {
#line 272
  tmp___11 = fileno(tmpf1);
#line 272
  tmp___12 = dup2(tmp___11, 0);
  }
#line 272
  if (tmp___12 < 0) {
    {
#line 273
    tmp___9 = __errno_location();
#line 273
    tmp___10 = strerror(*tmp___9);
#line 273
    sgrep_error(sgrep___0, (char *)"dup2:%s", tmp___10);
    }
#line 274
    goto error;
  } else {
    {
#line 272
    tmp___13 = fileno(tmpf2);
#line 272
    tmp___14 = dup2(tmp___13, 1);
    }
#line 272
    if (tmp___14 < 0) {
      {
#line 273
      tmp___9 = __errno_location();
#line 273
      tmp___10 = strerror(*tmp___9);
#line 273
      sgrep_error(sgrep___0, (char *)"dup2:%s", tmp___10);
      }
#line 274
      goto error;
    }
  }
  {
#line 277
  e = system((char const   *)processor);
  }
#line 277
  if (e < 0) {
    {
#line 278
    tmp___15 = __errno_location();
#line 278
    tmp___16 = strerror(*tmp___15);
#line 278
    sgrep_error(sgrep___0, (char *)"system(\"%s\"):%s\n", processor, tmp___16);
    }
#line 280
    goto error;
  }
#line 282
  if (e != 0) {
    {
#line 283
    sgrep_error(sgrep___0, (char *)"system(\"%s\") returned non zero exit status (%d).\n",
                processor, e);
    }
  }
  {
#line 286
  tmp___19 = dup2(tmp_stdinfd, 0);
  }
#line 286
  if (tmp___19 < 0) {
    {
#line 287
    tmp___17 = __errno_location();
#line 287
    tmp___18 = strerror(*tmp___17);
#line 287
    sgrep_error(sgrep___0, (char *)"dup2(stdin,0):%s", tmp___18);
    }
#line 288
    goto error;
  }
  {
#line 290
  close(tmp_stdinfd);
#line 291
  tmp_stdinfd = -1;
#line 292
  tmp___22 = dup2(tmp_stdoutfd, 1);
  }
#line 292
  if (tmp___22 < 0) {
    {
#line 293
    tmp___20 = __errno_location();
#line 293
    tmp___21 = strerror(*tmp___20);
#line 293
    sgrep_error(sgrep___0, (char *)"dup2(stdout,1):%s", tmp___21);
    }
#line 294
    goto error;
  }
  {
#line 296
  close(tmp_stdoutfd);
#line 297
  tmp_stdoutfd = -1;
#line 299
  delete_temp_file(temp_file1);
#line 300
  tmpf1 = (FILE *)((void *)0);
#line 303
  tmp___25 = fseek(tmpf2, 0L, 2);
  }
#line 303
  if (tmp___25 != 0) {
    {
#line 308
    tmp___23 = __errno_location();
#line 308
    tmp___24 = strerror(*tmp___23);
#line 308
    sgrep_error(sgrep___0, (char *)"Error reading preprocessor output:%s", tmp___24);
    }
#line 309
    goto error;
  } else {
    {
#line 303
    tmp___26 = fseek(tmpf2, 0L, 0);
    }
#line 303
    if (tmp___26 != 0) {
      {
#line 308
      tmp___23 = __errno_location();
#line 308
      tmp___24 = strerror(*tmp___23);
#line 308
      sgrep_error(sgrep___0, (char *)"Error reading preprocessor output:%s", tmp___24);
      }
#line 309
      goto error;
    } else {
      {
#line 303
      tmp___27 = fread((void */* __restrict  */)output_str, (size_t )1, (size_t )maxsize,
                       (FILE */* __restrict  */)tmpf2);
#line 303
      out_bytes = (int )tmp___27;
      }
#line 303
      if (out_bytes < 0) {
        {
#line 308
        tmp___23 = __errno_location();
#line 308
        tmp___24 = strerror(*tmp___23);
#line 308
        sgrep_error(sgrep___0, (char *)"Error reading preprocessor output:%s", tmp___24);
        }
#line 309
        goto error;
      } else {
        {
#line 303
        tmp___28 = ferror(tmpf2);
        }
#line 303
        if (tmp___28) {
          {
#line 308
          tmp___23 = __errno_location();
#line 308
          tmp___24 = strerror(*tmp___23);
#line 308
          sgrep_error(sgrep___0, (char *)"Error reading preprocessor output:%s", tmp___24);
          }
#line 309
          goto error;
        }
      }
    }
  }
#line 311
  if (out_bytes >= maxsize) {
    {
#line 312
    sgrep_error(sgrep___0, (char *)"Preprocessor output too long (>%d bytes)\n", maxsize);
#line 314
    out_bytes = maxsize - 1;
    }
  }
  {
#line 316
  delete_temp_file(temp_file2);
#line 317
  tmpf2 = (FILE *)((void *)0);
#line 318
  *(output_str + out_bytes) = (char)0;
  }
#line 319
  if (out_bytes == 0) {
    {
#line 320
    sgrep_error(sgrep___0, (char *)"Preprocessor returned empty file\n");
    }
#line 321
    return (-1);
  }
#line 323
  return (out_bytes);
  error: 
#line 326
  if ((unsigned long )temp_file1 != (unsigned long )((void *)0)) {
    {
#line 326
    delete_temp_file(temp_file1);
    }
  }
#line 327
  if ((unsigned long )temp_file2 != (unsigned long )((void *)0)) {
    {
#line 327
    delete_temp_file(temp_file2);
    }
  }
#line 328
  if (tmp_stdinfd > 0) {
    {
#line 329
    dup2(tmp_stdinfd, 0);
#line 330
    close(tmp_stdinfd);
    }
  }
#line 332
  if (tmp_stdoutfd > 0) {
    {
#line 333
    dup2(tmp_stdoutfd, 0);
#line 334
    close(tmp_stdoutfd);
    }
  }
#line 336
  *(output_str + 0) = (char)0;
#line 337
  return (-1);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 487 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
void *sgrep_debug_malloc(SgrepData *sgrep___0 , size_t size , char const   *file ,
                         int line ) ;
#line 488
void *sgrep_debug_calloc(SgrepData *sgrep___0 , size_t nmemb , size_t size ) ;
#line 489
void *sgrep_debug_realloc(SgrepData *sgrep___0 , void *ptr , size_t size ) ;
#line 490
char *sgrep_debug_strdup(SgrepData *sgrep___0 , char const   *str , char const   *file ,
                         int line ) ;
#line 491
void sgrep_debug_free(SgrepData *sgrep___0 , void *ptr ) ;
#line 492
void sgrep_free_all(SgrepData *sgrep___0 ) ;
#line 493
void check_memory_leaks(SgrepData *sgrep___0 ) ;
#line 538
TempFile *create_named_temp_file(SgrepData *sgrep___0 ) ;
#line 541
char const   *temp_file_name(TempFile *temp_file ) ;
#line 543
TempFile *temp_file_read_stdin(SgrepData *sgrep___0 ) ;
#line 648
SgrepString *new_string(SgrepData *sgrep___0 , size_t size ) ;
#line 651
void delete_string(SgrepString *s ) ;
#line 652
void string_cat(SgrepString *s , char const   *str ) ;
#line 717
size_t map_file(SgrepData *sgrep___0 , char const   *filename , void **map ) ;
#line 718
int unmap_file(SgrepData *sgrep___0 , void *map , size_t size ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
size_t map_file(SgrepData *sgrep___0 , char const   *filename , void **map ) 
{ 
  int fd ;
  int len ;
  int *tmp ;
  char *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 45
  fd = open(filename, 0);
  }
#line 46
  if (fd < 0) {
    {
#line 47
    tmp = __errno_location();
#line 47
    tmp___0 = strerror(*tmp);
#line 47
    sgrep_error(sgrep___0, (char *)"Failed to open file \'%s\':%s\n", filename, tmp___0);
#line 49
    *map = (void *)0;
    }
#line 50
    return ((size_t )0);
  }
  {
#line 52
  tmp___1 = lseek(fd, (__off_t )0, 2);
#line 52
  len = (int )tmp___1;
  }
#line 53
  if (len < 0) {
    {
#line 54
    tmp___2 = __errno_location();
#line 54
    tmp___3 = strerror(*tmp___2);
#line 54
    sgrep_error(sgrep___0, (char *)"lseek \'%s\':%s", filename, tmp___3);
#line 55
    close(fd);
#line 56
    *map = (void *)0;
    }
#line 57
    return ((size_t )0);
  }
  {
#line 64
  *map = mmap((void *)0, (size_t )len, 1, 1, fd, (__off_t )0);
#line 65
  close(fd);
  }
#line 66
  if ((unsigned long )*map == (unsigned long )((void *)0)) {
    {
#line 67
    tmp___4 = __errno_location();
#line 67
    tmp___5 = strerror(*tmp___4);
#line 67
    sgrep_error(sgrep___0, (char *)"mmap \'%s\':%s\n", filename, tmp___5);
#line 69
    *map = (void *)0;
    }
#line 70
    return ((size_t )0);
  } else
#line 66
  if ((unsigned long )*map == (unsigned long )((void *)-1)) {
    {
#line 67
    tmp___4 = __errno_location();
#line 67
    tmp___5 = strerror(*tmp___4);
#line 67
    sgrep_error(sgrep___0, (char *)"mmap \'%s\':%s\n", filename, tmp___5);
#line 69
    *map = (void *)0;
    }
#line 70
    return ((size_t )0);
  }
#line 72
  return ((size_t )len);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
int unmap_file(SgrepData *sgrep___0 , void *map , size_t size ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = munmap(map, size);
  }
#line 128
  if (tmp < 0) {
#line 128
    return (-1);
  }
#line 129
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
static int i  =    0;
#line 154 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
TempFile *create_named_temp_file(SgrepData *sgrep___0 ) 
{ 
  char const   *prefix ;
  SgrepString *file_name ;
  char tmp[50] ;
  int fd ;
  int j ;
  TempFile *temp_file ;
  void *tmp___0 ;
  char *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 167
  tmp___0 = sgrep_debug_malloc(sgrep___0, sizeof(TempFile ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                               167);
#line 167
  temp_file = (TempFile *)tmp___0;
#line 168
  temp_file->sgrep = sgrep___0;
#line 169
  temp_file->stream = (FILE *)((void *)0);
#line 170
  temp_file->prev = (TempFile *)((void *)0);
#line 173
  file_name = new_string(sgrep___0, (size_t )1024);
#line 174
  tmp___1 = getenv("TEMP");
#line 174
  prefix = (char const   *)tmp___1;
  }
#line 175
  if (! prefix) {
#line 176
    prefix = "/tmp";
  }
#line 178
  j = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if ((unsigned long )temp_file->stream == (unsigned long )((void *)0)) {
#line 178
      if (! (j < 1000)) {
#line 178
        goto while_break;
      }
    } else {
#line 178
      goto while_break;
    }
    {
#line 179
    i ++;
#line 180
    file_name->length = (size_t )0;
#line 181
    string_cat(file_name, prefix);
#line 182
    string_cat(file_name, "/");
#line 183
    string_cat(file_name, "sg");
#line 184
    tmp___2 = getpid();
#line 184
    sprintf((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"%d-%d",
            tmp___2, i);
#line 185
    string_cat(file_name, (char const   *)(tmp));
#line 186
    string_cat(file_name, ".tmp");
#line 187
    *(file_name->s + file_name->length) = (char)0;
#line 187
    fd = open((char const   *)file_name->s, 194, 384);
    }
#line 188
    if (fd >= 0) {
      {
#line 189
      temp_file->stream = fdopen(fd, "wb+");
      }
    }
#line 178
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if ((unsigned long )temp_file->stream == (unsigned long )((void *)0)) {
    {
#line 193
    tmp___3 = __errno_location();
#line 193
    tmp___4 = strerror(*tmp___3);
#line 193
    *(file_name->s + file_name->length) = (char)0;
#line 193
    sgrep_error(sgrep___0, (char *)"Failed to create temp file \'%s\': %s\n", (char const   *)file_name->s,
                tmp___4);
#line 195
    sgrep_debug_free(sgrep___0, (void *)temp_file);
#line 196
    delete_string(file_name);
    }
#line 197
    return ((TempFile *)((void *)0));
  }
  {
#line 199
  *(file_name->s + file_name->length) = (char)0;
#line 199
  temp_file->file_name = sgrep_debug_strdup(sgrep___0, (char const   *)file_name->s,
                                            "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                                            199);
#line 200
  delete_string(file_name);
#line 218
  temp_file->next = sgrep___0->first_temp_file;
  }
#line 219
  if (temp_file->next) {
#line 219
    (temp_file->next)->prev = temp_file;
  }
#line 220
  sgrep___0->first_temp_file = temp_file;
#line 221
  return (temp_file);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
TempFile *create_temp_file(SgrepData *sgrep___0 ) 
{ 
  TempFile *temp_file ;
  TempFile *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 226
  tmp = create_named_temp_file(sgrep___0);
#line 226
  temp_file = tmp;
  }
#line 227
  if (! temp_file) {
#line 227
    return ((TempFile *)((void *)0));
  }
  {
#line 228
  tmp___2 = remove((char const   *)temp_file->file_name);
  }
#line 228
  if (tmp___2 == 0) {
    {
#line 229
    sgrep_debug_free(sgrep___0, (void *)temp_file->file_name);
#line 230
    temp_file->file_name = (char *)((void *)0);
    }
  } else {
    {
#line 232
    tmp___0 = __errno_location();
#line 232
    tmp___1 = strerror(*tmp___0);
#line 232
    sgrep_error(sgrep___0, (char *)"Failed to unlink tempfile \'%s\':%s\n", temp_file->file_name,
                tmp___1);
    }
  }
#line 235
  return (temp_file);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
FILE *temp_file_stream(TempFile *temp_file ) 
{ 


  {
#line 242
  if (! temp_file) {
    {
#line 242
    __assert_fail("temp_file", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  242U, "temp_file_stream");
    }
  }
#line 243
  return (temp_file->stream);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
char const   *temp_file_name(TempFile *temp_file ) 
{ 


  {
#line 247
  if (! temp_file) {
    {
#line 247
    __assert_fail("temp_file", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  247U, "temp_file_name");
    }
  }
#line 248
  return ((char const   *)temp_file->file_name);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
int delete_temp_file(TempFile *temp_file ) 
{ 
  SgrepData *sgrep___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 252
  sgrep___0 = temp_file->sgrep;
#line 253
  fclose(temp_file->stream);
  }
#line 254
  if (temp_file->file_name) {
    {
#line 255
    tmp___1 = remove((char const   *)temp_file->file_name);
    }
#line 255
    if (tmp___1) {
      {
#line 256
      tmp = __errno_location();
#line 256
      tmp___0 = strerror(*tmp);
#line 256
      sgrep_error(sgrep___0, (char *)"Failed to remove temp file \'%s\':%s\n", temp_file->file_name,
                  tmp___0);
      }
    }
    {
#line 259
    sgrep_debug_free(sgrep___0, (void *)temp_file->file_name);
#line 260
    temp_file->file_name = (char *)((void *)0);
    }
  }
#line 262
  if ((unsigned long )sgrep___0->first_temp_file == (unsigned long )temp_file) {
#line 263
    sgrep___0->first_temp_file = temp_file->next;
  }
#line 265
  if (temp_file->next) {
#line 266
    (temp_file->next)->prev = temp_file->prev;
  }
#line 268
  if (temp_file->prev) {
#line 269
    (temp_file->prev)->next = temp_file->next;
  }
  {
#line 271
  sgrep_debug_free(sgrep___0, (void *)temp_file);
  }
#line 272
  return (0);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
TempFile *temp_file_read_stdin(SgrepData *sgrep___0 ) 
{ 
  char buf[8192] ;
  int r ;
  int w ;
  TempFile *temp ;
  FILE *temp_stream ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 287
  if (sgrep___0->stdin_temp_file) {
    {
#line 289
    sgrep_error(sgrep___0, (char *)"stdin already used\n");
    }
#line 290
    return ((TempFile *)((void *)0));
  }
  {
#line 293
  temp = create_named_temp_file(sgrep___0);
  }
#line 294
  if (! temp) {
#line 294
    return ((TempFile *)((void *)0));
  }
  {
#line 296
  temp_stream = temp_file_stream(temp);
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 299
    tmp = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )8192, (FILE */* __restrict  */)stdin);
#line 299
    r = (int )tmp;
    }
#line 300
    if (r > 0) {
      {
#line 301
      tmp___0 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )r,
                       (FILE */* __restrict  */)temp_stream);
#line 301
      w = (int )tmp___0;
      }
    }
#line 298
    if (r > 0) {
#line 298
      if (w == r) {
        {
#line 298
        tmp___1 = feof(stdin);
        }
#line 298
        if (tmp___1) {
#line 298
          goto while_break;
        }
      } else {
#line 298
        goto while_break;
      }
    } else {
#line 298
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  tmp___4 = ferror(stdin);
  }
#line 304
  if (tmp___4) {
    {
#line 305
    tmp___2 = __errno_location();
#line 305
    tmp___3 = strerror(*tmp___2);
#line 305
    sgrep_error(sgrep___0, (char *)"Failed to read stdin: %s\n", tmp___3);
#line 306
    delete_temp_file(temp);
    }
#line 307
    return ((TempFile *)((void *)0));
  }
  {
#line 309
  tmp___7 = ferror(temp_stream);
  }
#line 309
  if (tmp___7) {
    {
#line 311
    tmp___5 = __errno_location();
#line 311
    tmp___6 = strerror(*tmp___5);
#line 311
    sgrep_error(sgrep___0, (char *)"Failed to write stdin to temp file: %s\n", tmp___6);
#line 313
    delete_temp_file(temp);
    }
#line 314
    return ((TempFile *)((void *)0));
  } else {
    {
#line 309
    tmp___8 = fflush(temp_stream);
    }
#line 309
    if (tmp___8) {
      {
#line 311
      tmp___5 = __errno_location();
#line 311
      tmp___6 = strerror(*tmp___5);
#line 311
      sgrep_error(sgrep___0, (char *)"Failed to write stdin to temp file: %s\n", tmp___6);
#line 313
      delete_temp_file(temp);
      }
#line 314
      return ((TempFile *)((void *)0));
    } else {
      {
#line 309
      tmp___9 = ferror(temp_stream);
      }
#line 309
      if (tmp___9) {
        {
#line 311
        tmp___5 = __errno_location();
#line 311
        tmp___6 = strerror(*tmp___5);
#line 311
        sgrep_error(sgrep___0, (char *)"Failed to write stdin to temp file: %s\n",
                    tmp___6);
#line 313
        delete_temp_file(temp);
        }
#line 314
        return ((TempFile *)((void *)0));
      } else {
        {
#line 309
        tmp___10 = fseek(temp_stream, 0L, 0);
        }
#line 309
        if (tmp___10 != 0) {
          {
#line 311
          tmp___5 = __errno_location();
#line 311
          tmp___6 = strerror(*tmp___5);
#line 311
          sgrep_error(sgrep___0, (char *)"Failed to write stdin to temp file: %s\n",
                      tmp___6);
#line 313
          delete_temp_file(temp);
          }
#line 314
          return ((TempFile *)((void *)0));
        }
      }
    }
  }
#line 316
  sgrep___0->stdin_temp_file = temp;
#line 317
  return (temp);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
void *sgrep_debug_malloc(SgrepData *sgrep___0 , size_t size , char const   *file ,
                         int line ) 
{ 
  MemoryBlock *block ;
  void *ptr ;
  void *tmp ;

  {
#line 347
  if (size == 0UL) {
#line 347
    return ((void *)0);
  }
#line 348
  if (! sgrep___0) {
    {
#line 350
    ptr = malloc(size);
    }
#line 351
    if (! ptr) {
      {
#line 352
      perror("malloc");
#line 353
      abort();
      }
    }
#line 355
    return (ptr);
  }
  {
#line 357
  tmp = malloc(sizeof(MemoryBlock ) + size);
#line 357
  block = (MemoryBlock *)tmp;
  }
#line 358
  if ((unsigned long )block == (unsigned long )((void *)0)) {
    {
#line 359
    perror("malloc");
#line 360
    abort();
    }
  }
#line 363
  block->magic = 91172;
#line 364
  block->file = file;
#line 365
  block->line = line;
#line 367
  block->size = sizeof(MemoryBlock ) + size;
#line 369
  block->next = sgrep___0->m_blocks;
#line 370
  block->prev = (struct MemoryBlockStruct *)((void *)0);
#line 371
  if (sgrep___0->m_blocks) {
#line 371
    (sgrep___0->m_blocks)->prev = block;
  }
#line 372
  sgrep___0->m_blocks = block;
#line 374
  (sgrep___0->statistics.memory_blocks) ++;
#line 375
  sgrep___0->statistics.memory_allocated += block->size;
#line 376
  if (sgrep___0->statistics.memory_allocated > sgrep___0->statistics.peak_memory_usage) {
#line 377
    sgrep___0->statistics.peak_memory_usage = sgrep___0->statistics.memory_allocated;
  }
#line 379
  return ((void *)(block + 1));
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
void *sgrep_debug_calloc(SgrepData *sgrep___0 , size_t nmemb , size_t size ) 
{ 
  void *mem ;

  {
  {
#line 384
  mem = sgrep_debug_malloc(sgrep___0, nmemb * size, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                           384);
#line 385
  memset(mem, 0, nmemb * size);
  }
#line 386
  return (mem);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
void sgrep_debug_free(SgrepData *sgrep___0 , void *ptr ) 
{ 
  MemoryBlock *block ;

  {
#line 391
  if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
    {
#line 391
    __assert_fail("ptr!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  391U, "sgrep_debug_free");
    }
  }
#line 392
  if (! sgrep___0) {
    {
#line 393
    free(ptr);
    }
#line 394
    return;
  }
#line 396
  block = (MemoryBlock *)ptr - 1;
#line 397
  if (! (block->magic == 91172)) {
    {
#line 397
    __assert_fail("block->magic==91172", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  397U, "sgrep_debug_free");
    }
  }
#line 398
  if (block->next) {
#line 399
    (block->next)->prev = block->prev;
  }
#line 401
  if (block->prev) {
#line 402
    (block->prev)->next = block->next;
  } else {
#line 405
    if (! ((unsigned long )sgrep___0->m_blocks == (unsigned long )block)) {
      {
#line 405
      __assert_fail("sgrep->m_blocks==block", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                    405U, "sgrep_debug_free");
      }
    }
#line 406
    sgrep___0->m_blocks = block->next;
#line 407
    if (sgrep___0->m_blocks) {
#line 407
      (sgrep___0->m_blocks)->prev = (struct MemoryBlockStruct *)((void *)0);
    }
  }
  {
#line 409
  (sgrep___0->statistics.memory_blocks) --;
#line 410
  sgrep___0->statistics.memory_allocated -= block->size;
#line 411
  block->magic = 0;
#line 412
  block->file = (char const   *)((void *)0);
#line 413
  block->line = 0;
#line 414
  free((void *)block);
  }
#line 415
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
void sgrep_free_all(SgrepData *sgrep___0 ) 
{ 


  {
#line 418
  if (! sgrep___0) {
    {
#line 418
    __assert_fail("sgrep", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  418U, "sgrep_free_all");
    }
  }
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! ((unsigned long )sgrep___0->m_blocks != (unsigned long )((void *)0))) {
#line 419
      goto while_break;
    }
    {
#line 420
    sgrep_debug_free(sgrep___0, (void *)(sgrep___0->m_blocks + 1));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  if (sgrep___0->statistics.memory_blocks == 0) {
#line 422
    if (! (sgrep___0->statistics.memory_allocated == 0UL)) {
      {
#line 422
      __assert_fail("(sgrep->statistics).memory_blocks==0 && (sgrep->statistics).memory_allocated==0",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                    422U, "sgrep_free_all");
      }
    }
  } else {
    {
#line 422
    __assert_fail("(sgrep->statistics).memory_blocks==0 && (sgrep->statistics).memory_allocated==0",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  422U, "sgrep_free_all");
    }
  }
#line 423
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
void *sgrep_debug_realloc(SgrepData *sgrep___0 , void *ptr , size_t size ) 
{ 
  MemoryBlock *old_block ;
  MemoryBlock *new_block___0 ;
  void *tmp ;
  void *r ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 433
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 433
    tmp = sgrep_debug_malloc(sgrep___0, size, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                             433);
    }
#line 433
    return (tmp);
  }
#line 434
  if (size == 0UL) {
    {
#line 435
    sgrep_debug_free(sgrep___0, ptr);
    }
#line 436
    return ((void *)0);
  }
#line 438
  if (! sgrep___0) {
    {
#line 439
    tmp___0 = realloc(ptr, size);
#line 439
    r = tmp___0;
    }
#line 440
    if (! r) {
      {
#line 441
      perror("realloc");
#line 442
      abort();
      }
    }
#line 444
    return (r);
  }
#line 446
  old_block = (MemoryBlock *)ptr - 1;
#line 447
  if (! (old_block->magic == 91172)) {
    {
#line 447
    __assert_fail("old_block->magic==91172", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  447U, "sgrep_debug_realloc");
    }
  }
  {
#line 448
  old_block->magic = 0;
#line 449
  tmp___1 = realloc((void *)old_block, size + sizeof(MemoryBlock ));
#line 449
  new_block___0 = (MemoryBlock *)tmp___1;
#line 450
  new_block___0->magic = 91172;
  }
#line 452
  if ((unsigned long )new_block___0 == (unsigned long )((void *)0)) {
    {
#line 454
    perror("realloc");
#line 455
    abort();
    }
  }
#line 457
  if ((unsigned long )new_block___0 != (unsigned long )old_block) {
#line 458
    if (new_block___0->next) {
#line 458
      (new_block___0->next)->prev = new_block___0;
    }
#line 459
    if (new_block___0->prev) {
#line 459
      (new_block___0->prev)->next = new_block___0;
    }
#line 460
    if ((unsigned long )sgrep___0->m_blocks == (unsigned long )old_block) {
#line 461
      sgrep___0->m_blocks = new_block___0;
    }
  }
#line 464
  (sgrep___0->statistics.reallocs) ++;
#line 465
  sgrep___0->statistics.memory_allocated += (size + sizeof(MemoryBlock )) - new_block___0->size;
#line 466
  new_block___0->size = size + sizeof(MemoryBlock );
#line 467
  if (sgrep___0->statistics.memory_allocated > sgrep___0->statistics.peak_memory_usage) {
#line 468
    sgrep___0->statistics.peak_memory_usage = sgrep___0->statistics.memory_allocated;
  }
#line 470
  return ((void *)(new_block___0 + 1));
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
char *sgrep_debug_strdup(SgrepData *sgrep___0 , char const   *str , char const   *file ,
                         int line ) 
{ 
  int l ;
  char *new_str ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 477
  tmp = strlen(str);
#line 477
  l = (int )tmp;
#line 478
  tmp___0 = sgrep_debug_malloc(sgrep___0, (size_t )(l + 1), file, line);
#line 478
  new_str = (char *)tmp___0;
#line 479
  memcpy((void */* __restrict  */)new_str, (void const   */* __restrict  */)str, (size_t )(l + 1));
  }
#line 480
  return (new_str);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c"
void check_memory_leaks(SgrepData *sgrep___0 ) 
{ 
  int leaks ;
  MemoryBlock *block ;

  {
#line 484
  leaks = 0;
#line 486
  if (! sgrep___0) {
    {
#line 486
    __assert_fail("sgrep", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sysdeps.c",
                  486U, "check_memory_leaks");
    }
  }
#line 487
  if (sgrep___0->statistics.memory_blocks > 0) {
    {
#line 488
    fprintf((FILE */* __restrict  */)sgrep___0->progress_stream, (char const   */* __restrict  */)"Memory leak: %d blocks having %d bytes total size\n",
            sgrep___0->statistics.memory_blocks, sgrep___0->statistics.memory_allocated);
#line 492
    fprintf((FILE */* __restrict  */)sgrep___0->progress_stream, (char const   */* __restrict  */)"<LEAK_SPOTS>\n");
#line 493
    block = sgrep___0->m_blocks;
    }
    {
#line 493
    while (1) {
      while_continue: /* CIL Label */ ;
#line 493
      if (block) {
#line 493
        if (! (leaks < 15)) {
#line 493
          goto while_break;
        }
      } else {
#line 493
        goto while_break;
      }
      {
#line 494
      leaks ++;
#line 495
      fprintf((FILE */* __restrict  */)sgrep___0->progress_stream, (char const   */* __restrict  */)"\t%s:%d: %d bytes\n",
              block->file, block->line, block->size);
#line 493
      block = block->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 498
    fprintf((FILE */* __restrict  */)sgrep___0->progress_stream, (char const   */* __restrict  */)"</LEAK_SPOTS>\n");
    }
  }
#line 500
  return;
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 570 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
void optimize_tree(struct SgrepStruct *sgrep___0 , ParseTreeNode **root , struct PHRASE_NODE **phrase_list ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
struct PHRASE_NODE *qsort_phrases(struct PHRASE_NODE **phrase_list ) 
{ 
  struct PHRASE_NODE *list1 ;
  struct PHRASE_NODE *list2 ;
  struct PHRASE_NODE *comp ;
  struct PHRASE_NODE *next ;
  struct PHRASE_NODE *p_list ;
  int tmp ;
  struct PHRASE_NODE *tmp___0 ;

  {
#line 37
  p_list = *phrase_list;
#line 41
  if ((unsigned long )p_list == (unsigned long )((void *)0)) {
#line 43
    return ((struct PHRASE_NODE *)((void *)0));
  }
#line 45
  comp = p_list;
#line 49
  p_list = p_list->next;
#line 50
  if ((unsigned long )p_list == (unsigned long )((void *)0)) {
#line 53
    return (*phrase_list);
  }
#line 56
  list1 = (struct PHRASE_NODE *)((void *)0);
#line 57
  list2 = comp;
#line 58
  comp->next = (struct PHRASE_NODE *)((void *)0);
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )p_list != (unsigned long )((void *)0))) {
#line 59
      goto while_break;
    }
    {
#line 61
    next = p_list->next;
#line 62
    tmp = strcmp((char const   *)(comp->phrase)->s, (char const   *)(p_list->phrase)->s);
    }
#line 62
    if (tmp < 0) {
#line 68
      p_list->next = list2;
#line 69
      list2 = p_list;
    } else {
#line 75
      p_list->next = list1;
#line 76
      list1 = p_list;
    }
#line 78
    p_list = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  comp = qsort_phrases(& list2);
  }
#line 85
  if ((unsigned long )list1 == (unsigned long )((void *)0)) {
#line 87
    *phrase_list = list2;
#line 88
    return (comp);
  }
  {
#line 90
  tmp___0 = qsort_phrases(& list1);
#line 90
  tmp___0->next = list2;
#line 91
  *phrase_list = list1;
  }
#line 92
  return (comp);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
void remove_duplicate_phrases(Optimizer *o ) 
{ 
  struct PHRASE_NODE *pn ;
  struct PHRASE_NODE *lpn ;
  struct PHRASE_NODE *tmp ;
  SgrepData *sgrep___0 ;
  char *last___0 ;
  int tmp___0 ;

  {
  {
#line 101
  lpn = (struct PHRASE_NODE *)((void *)0);
#line 103
  sgrep___0 = o->sgrep;
#line 107
  qsort_phrases(o->phrase_list);
#line 108
  pn = *(o->phrase_list);
#line 110
  last___0 = (char *)"";
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
#line 113
      goto while_break;
    }
    {
#line 115
    tmp___0 = strcmp((char const   *)last___0, (char const   *)(pn->phrase)->s);
    }
#line 115
    if (tmp___0 == 0) {
#line 123
      (pn->parent)->label_left = o->label_c;
#line 125
      lpn->next = pn->next;
#line 126
      (pn->parent)->leaf = lpn;
#line 128
      tmp = pn;
#line 129
      pn = pn->next;
#line 130
      if (! ((unsigned long )pn == (unsigned long )((void *)0))) {
#line 130
        if ((unsigned long )pn->parent != (unsigned long )((void *)0)) {
#line 130
          if (! ((pn->parent)->label_left == 2)) {
            {
#line 130
            __assert_fail("pn==((void *)0) || ( pn->parent!=((void *)0) && pn->parent->label_left==2 )",
                          "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                          133U, "remove_duplicate_phrases");
            }
          }
        } else {
          {
#line 130
          __assert_fail("pn==((void *)0) || ( pn->parent!=((void *)0) && pn->parent->label_left==2 )",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                        133U, "remove_duplicate_phrases");
          }
        }
      }
      {
#line 134
      delete_string(tmp->phrase);
#line 135
      tmp->phrase = (SgrepString *)((void *)0);
#line 136
      sgrep_debug_free(sgrep___0, (void *)tmp);
#line 139
      (o->optimized_phrases) ++;
      }
    } else {
#line 143
      last___0 = (pn->phrase)->s;
#line 144
      (o->label_c) ++;
#line 145
      (pn->parent)->label_left = o->label_c;
#line 146
      lpn = pn;
#line 147
      pn = pn->next;
#line 149
      if (! ((unsigned long )pn == (unsigned long )((void *)0))) {
#line 149
        if (! ((unsigned long )pn->parent != (unsigned long )((void *)0))) {
          {
#line 149
          __assert_fail("pn==((void *)0) || pn->parent!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                        149U, "remove_duplicate_phrases");
          }
        }
      }
#line 150
      if (! ((unsigned long )pn == (unsigned long )((void *)0))) {
#line 150
        if (! ((pn->parent)->label_left == 2)) {
          {
#line 150
          __assert_fail("pn==((void *)0) || pn->parent->label_left==2", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                        150U, "remove_duplicate_phrases");
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
int add_parents(ParseTreeNode *node , ParseTreeNode *parent ) 
{ 
  int nodes ;
  int tmp ;
  int tmp___0 ;

  {
#line 166
  nodes = 1;
#line 167
  node->parent = parent;
#line 169
  if (! (node->label_right == -1)) {
    {
#line 169
    __assert_fail("node->label_right==-1", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                  169U, "add_parents");
    }
  }
#line 171
  node->refcount = 0;
#line 172
  if ((unsigned int )node->oper == 28U) {
#line 174
    (node->leaf)->parent = node;
  } else {
#line 177
    if (! ((unsigned long )node->left != (unsigned long )((void *)0))) {
      {
#line 177
      __assert_fail("node->left!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                    177U, "add_parents");
      }
    }
    {
#line 178
    tmp = add_parents(node->left, node);
#line 178
    nodes += tmp;
    }
#line 179
    if ((unsigned long )node->right != (unsigned long )((void *)0)) {
      {
#line 181
      tmp___0 = add_parents(node->right, node);
#line 181
      nodes += tmp___0;
      }
    }
  }
#line 184
  return (nodes);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
int create_leaf_list(ParseTreeNode *root , ParseTreeNode **list , int ind ) 
{ 


  {
#line 192
  if ((unsigned int )root->oper == 28U) {
#line 194
    *(list + ind) = root;
#line 195
    return (ind + 1);
  }
  {
#line 197
  ind = create_leaf_list(root->left, list, ind);
  }
#line 198
  if ((unsigned long )root->right != (unsigned long )((void *)0)) {
    {
#line 200
    ind = create_leaf_list(root->right, list, ind);
    }
  }
#line 202
  return (ind);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
int comp_tree_nodes(ParseTreeNode **n1 , ParseTreeNode **n2 ) 
{ 
  int x ;

  {
#line 224
  if ((unsigned int )(*n1)->oper == 23U) {
#line 224
    goto _L;
  } else
#line 224
  if ((unsigned int )(*n1)->oper == 24U) {
#line 224
    goto _L;
  } else
#line 224
  if ((unsigned int )(*n1)->oper == 25U) {
    _L: /* CIL Label */ 
#line 224
    if ((unsigned int )(*n2)->oper == (unsigned int )(*n1)->oper) {
#line 227
      x = (*n1)->number - (*n2)->number;
    } else {
#line 229
      x = (int )((unsigned int )(*n1)->oper - (unsigned int )(*n2)->oper);
    }
  } else {
#line 229
    x = (int )((unsigned int )(*n1)->oper - (unsigned int )(*n2)->oper);
  }
#line 231
  if (x != 0) {
#line 231
    return (x);
  }
#line 234
  if (! ((*n1)->label_left != 0)) {
#line 234
    if (! ((unsigned long )(*n1)->right == (unsigned long )((void *)0))) {
      {
#line 234
      __assert_fail("(*n1)->label_left!=0 || (*n1)->right==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                    234U, "comp_tree_nodes");
      }
    }
  }
#line 235
  if (! ((*n2)->label_left != 0)) {
#line 235
    if (! ((unsigned long )(*n2)->right == (unsigned long )((void *)0))) {
      {
#line 235
      __assert_fail("(*n2)->label_left!=0 || (*n2)->right==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                    235U, "comp_tree_nodes");
      }
    }
  }
#line 237
  if ((*n1)->label_left == 0) {
#line 237
    if ((*n2)->label_left == 0) {
#line 238
      return ((unsigned long )*n1 != (unsigned long )*n2);
    }
  }
#line 239
  x = (*n1)->label_left - (*n2)->label_left;
#line 240
  if (x != 0) {
#line 240
    return (x);
  }
#line 241
  x = (*n1)->label_right - (*n2)->label_right;
#line 242
  return (x);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
void sort_leaf_list(ParseTreeNode **leaf_list , int nmemb ) 
{ 


  {
  {
#line 253
  qsort((void *)leaf_list, (size_t )nmemb, sizeof(ParseTreeNode **), (int (*)(void const   * ,
                                                                              void const   * ))(& comp_tree_nodes));
  }
#line 255
  return;
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
void shrink_tree(Optimizer *o ) 
{ 
  int leaf_list_size ;
  int i___0 ;
  ParseTreeNode *dad ;
  ParseTreeNode *me ;
  ParseTreeNode *big_brother ;
  int imleft ;
  ParseTreeNode **list0 ;
  int list0_size ;
  ParseTreeNode **list1 ;
  int list1_size ;
  ParseTreeNode **tmp ;
  ParseTreeNode *root ;
  SgrepData *sgrep___0 ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  ParseTreeNode *tree_tmp ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 273
  root = *(o->root);
#line 274
  sgrep___0 = o->sgrep;
#line 276
  leaf_list_size = (int )((unsigned long )o->tree_size * sizeof(ParseTreeNode *));
#line 277
  tmp___0 = sgrep_debug_malloc(sgrep___0, (size_t )leaf_list_size, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                               277);
#line 277
  list0 = (ParseTreeNode **)tmp___0;
#line 278
  tmp___1 = sgrep_debug_malloc(sgrep___0, (size_t )leaf_list_size, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                               278);
#line 278
  list1 = (ParseTreeNode **)tmp___1;
#line 279
  list0_size = create_leaf_list(root, list0, 0);
#line 280
  list1_size = 0;
  }
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (list0_size > 1)) {
#line 282
      goto while_break;
    }
#line 284
    i___0 = 0;
    {
#line 284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 284
      if (! (i___0 < list0_size)) {
#line 284
        goto while_break___0;
      }
#line 286
      if ((unsigned int )(*(list0 + i___0))->oper == 15U) {
#line 286
        goto _L;
      } else
#line 286
      if ((unsigned int )(*(list0 + i___0))->oper == 4U) {
#line 286
        goto _L;
      } else
#line 286
      if ((unsigned int )(*(list0 + i___0))->oper == 18U) {
        _L: /* CIL Label */ 
#line 286
        if ((*(list0 + i___0))->label_left < (*(list0 + i___0))->label_right) {
#line 296
          tmp___2 = (*(list0 + i___0))->label_left;
#line 297
          (*(list0 + i___0))->label_left = (*(list0 + i___0))->label_right;
#line 298
          (*(list0 + i___0))->label_right = tmp___2;
#line 299
          tree_tmp = (*(list0 + i___0))->left;
#line 300
          (*(list0 + i___0))->left = (*(list0 + i___0))->right;
#line 301
          (*(list0 + i___0))->right = tree_tmp;
        }
      }
#line 284
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 305
    sort_leaf_list(list0, list0_size);
#line 309
    big_brother = (ParseTreeNode *)((void *)0);
#line 310
    i___0 = 0;
    }
    {
#line 310
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 310
      if (! (i___0 < list0_size)) {
#line 310
        goto while_break___1;
      }
#line 312
      me = *(list0 + i___0);
#line 313
      dad = me->parent;
#line 314
      imleft = (unsigned long )dad->left == (unsigned long )me;
#line 316
      if ((unsigned long )big_brother == (unsigned long )((void *)0)) {
#line 318
        (o->label_c) ++;
#line 319
        big_brother = me;
      } else {
        {
#line 316
        tmp___3 = comp_tree_nodes(& big_brother, & me);
        }
#line 316
        if (tmp___3 != 0) {
#line 318
          (o->label_c) ++;
#line 319
          big_brother = me;
        } else {
          {
#line 322
          (o->optimized_nodes) ++;
#line 325
          me->left = (struct ParseTreeNodeStruct *)((void *)0);
#line 326
          me->right = (struct ParseTreeNodeStruct *)((void *)0);
#line 327
          me->oper = (enum Oper )29;
#line 328
          sgrep_debug_free(sgrep___0, (void *)me);
          }
        }
      }
#line 331
      if (imleft) {
#line 333
        dad->label_left = o->label_c;
#line 334
        dad->left = big_brother;
      } else {
#line 337
        dad->label_right = o->label_c;
#line 338
        dad->right = big_brother;
      }
#line 340
      if (! ((unsigned long )dad->left != (unsigned long )((void *)0))) {
        {
#line 340
        __assert_fail("dad->left!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c",
                      340U, "shrink_tree");
        }
      }
#line 342
      if (dad->label_left != -1) {
#line 342
        if (dad->label_right != -1) {
#line 342
          goto _L___0;
        } else
#line 342
        if ((unsigned long )dad->right == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 346
          if ((unsigned long )dad->right == (unsigned long )((void *)0)) {
#line 346
            dad->label_right = -1;
          }
#line 347
          tmp___4 = list1_size;
#line 347
          list1_size ++;
#line 347
          *(list1 + tmp___4) = dad;
        }
      }
#line 310
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 357
    tmp = list0;
#line 358
    list0 = list1;
#line 359
    list1 = tmp;
#line 360
    list0_size = list1_size;
#line 361
    list1_size = 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  sgrep_debug_free(sgrep___0, (void *)list0);
#line 364
  sgrep_debug_free(sgrep___0, (void *)list1);
  }
#line 365
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
void create_reference_counters(ParseTreeNode *root ) 
{ 


  {
#line 371
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 371
    return;
  }
#line 373
  if (root->label_left == 0) {
#line 377
    root->refcount = -1;
  } else
#line 373
  if (root->label_left == 1) {
#line 377
    root->refcount = -1;
  } else {
#line 379
    if (root->refcount == 0) {
      {
#line 381
      create_reference_counters(root->left);
#line 382
      create_reference_counters(root->right);
      }
    }
#line 384
    (root->refcount) ++;
  }
#line 386
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/optimize.c"
void optimize_tree(struct SgrepStruct *sgrep___0 , ParseTreeNode **root , struct PHRASE_NODE **phrase_list ) 
{ 
  Optimizer optimizer ;

  {
  {
#line 486
  optimizer.sgrep = sgrep___0;
#line 487
  optimizer.label_c = 3;
#line 488
  optimizer.root = root;
#line 489
  optimizer.phrase_list = phrase_list;
#line 490
  optimizer.tree_size = 0;
#line 491
  optimizer.optimized_nodes = 0;
#line 492
  optimizer.optimized_phrases = 0;
#line 495
  optimizer.tree_size = add_parents(*root, (ParseTreeNode *)((void *)0));
#line 501
  remove_duplicate_phrases(& optimizer);
#line 504
  shrink_tree(& optimizer);
#line 506
  create_reference_counters(*root);
#line 510
  sgrep___0->statistics.parse_tree_size += optimizer.tree_size;
#line 511
  sgrep___0->statistics.optimized_phrases += optimizer.optimized_phrases;
#line 512
  sgrep___0->statistics.optimized_nodes += optimizer.optimized_nodes;
  }
#line 513
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
int flist_start(FileList const   *list , int n ) ;
#line 524
int flist_total(FileList const   *list ) ;
#line 588
RegionList *index_lookup(IndexReader *map , char const   *term ) ;
#line 677
RegionList *new_region_list(SgrepData *sgrep___0 ) ;
#line 678
void delete_region_list(RegionList *l ) ;
#line 680
void list_require_start_sorted_array(RegionList *l ) ;
#line 685
void insert_list_node(RegionList *l ) ;
#line 686
void start_region_search(RegionList *l , ListIterator *handle ) ;
#line 687
void start_region_search_from(RegionList *l , int index___0 , ListIterator *handle ) ;
#line 688
void start_end_sorted_search(RegionList *l , ListIterator *handle ) ;
#line 689
void list_set_sorted(RegionList *l , enum RegionListSorted sorted ) ;
#line 690
enum RegionListSorted list_get_sorted(RegionList const   *l ) ;
#line 691
void remove_duplicates(RegionList *s ) ;
#line 692
void to_chars(RegionList *c , int chars , int end ) ;
#line 697
void check_add_region(RegionList const   *l , int s , int e ) ;
#line 698
void check_get_region(ListIterator const   *handle , Region const   *reg ) ;
#line 699
void check_prev_region(ListIterator const   *handle , Region const   *reg ) ;
#line 700
int check_region_at(RegionList const   *l , int ind ) ;
#line 704
RegionList *eval(struct SgrepStruct *sgrep___0 , FileList const   *file_list , ParseTreeNode *root ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *recursive_eval(Evaluator *evaluator , ParseTreeNode *root ) ;
#line 41
RegionList *eval_operator(Evaluator *evaluator , ParseTreeNode *root ) ;
#line 42
RegionList *or(RegionList *l , RegionList *r ) ;
#line 43
RegionList *nest_order(Evaluator *evaluator , RegionList *l , RegionList *r , int type ) ;
#line 44
RegionList *quote(RegionList *l , RegionList *r , int type ) ;
#line 45
RegionList *in(RegionList *l , RegionList *r , int not ) ;
#line 46
RegionList *containing(Evaluator *evaluator , RegionList *l , RegionList *r , int not ) ;
#line 47
RegionList *extracting(RegionList *l , RegionList *r ) ;
#line 48
RegionList *outer(RegionList *gcl ) ;
#line 49
RegionList *inner(Evaluator *evaluator , RegionList *gcl ) ;
#line 50
RegionList *concat(RegionList *l ) ;
#line 51
RegionList *join(Evaluator *evaluator , RegionList *l , int number ) ;
#line 52
RegionList *first(RegionList *input , int num ) ;
#line 53
RegionList *last(RegionList *input , int num ) ;
#line 54
RegionList *first_bytes(RegionList *input , int num ) ;
#line 55
RegionList *last_bytes(RegionList *input , int num ) ;
#line 56
RegionList *equal(RegionList *l , RegionList *r , int not ) ;
#line 57
RegionList *parenting(Evaluator *evaluator , RegionList *l , RegionList *r ) ;
#line 58
RegionList *childrening(RegionList *children , RegionList *parents ) ;
#line 59
RegionList *eval_near(RegionList *l , RegionList *r , int how_near ) ;
#line 60
RegionList *near_before(RegionList *l , RegionList *r , int how_near ) ;
#line 62
int free_tree_node(ParseTreeNode *node ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *eval(struct SgrepStruct *sgrep___0 , FileList const   *file_list , ParseTreeNode *root ) 
{ 
  RegionList *r ;
  Evaluator evaluator ;
  void *tmp ;

  {
  {
#line 70
  evaluator.sgrep = sgrep___0;
#line 71
  evaluator.files = file_list;
#line 72
  evaluator.tmp_stack_size = 1024;
#line 73
  tmp = sgrep_debug_malloc(sgrep___0, 1024UL * sizeof(Region ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                           74);
#line 73
  evaluator.tmp_stack = (Region *)tmp;
#line 75
  r = recursive_eval(& evaluator, root);
  }
#line 76
  if (evaluator.tmp_stack) {
    {
#line 76
    sgrep_debug_free(sgrep___0, (void *)evaluator.tmp_stack);
    }
  }
#line 77
  return (r);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *recursive_eval(Evaluator *evaluator , ParseTreeNode *root ) 
{ 
  RegionList *a ;
  SgrepData *sgrep___0 ;
  char const   *s ;
  RegionList *list ;
  RegionList *tmp ;
  int start ;
  int tmp___0 ;
  int end ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Region reg1 ;
  Region reg2 ;
  ListIterator p ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 91
  sgrep___0 = evaluator->sgrep;
#line 92
  a = root->result;
#line 100
  if (! ((unsigned int )root->oper != 29U)) {
    {
#line 100
    __assert_fail("root->oper!=INVALID", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  100U, "recursive_eval");
    }
  }
#line 103
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 103
    if ((unsigned int )root->oper == 28U) {
#line 106
      if (sgrep___0->index_file) {
#line 106
        if ((unsigned long )(root->leaf)->regions == (unsigned long )((void *)0)) {
#line 107
          if (! ((unsigned long )(root->leaf)->phrase != (unsigned long )((void *)0))) {
            {
#line 107
            __assert_fail("root->leaf->phrase!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                          107U, "recursive_eval");
            }
          }
#line 108
          if (! sgrep___0->index_reader) {
            {
#line 108
            __assert_fail("sgrep->index_reader", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                          108U, "recursive_eval");
            }
          }
#line 110
          if ((int )*(((root->leaf)->phrase)->s + 0) == 35) {
            {
#line 112
            *(((root->leaf)->phrase)->s + ((root->leaf)->phrase)->length) = (char)0;
#line 112
            s = (char const   *)((root->leaf)->phrase)->s;
#line 113
            tmp = new_region_list(sgrep___0);
#line 113
            list = tmp;
#line 114
            (root->leaf)->regions = list;
#line 115
            tmp___3 = strcmp(s, "#start");
            }
#line 115
            if (tmp___3 == 0) {
              {
#line 116
              tmp___0 = flist_start(evaluator->files, 0);
#line 116
              start = tmp___0;
              }
              {
#line 117
              while (1) {
                while_continue: /* CIL Label */ ;
                {
#line 117
                check_add_region((RegionList const   *)list, start, start);
                }
                {
#line 117
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 117
                  if (list->length == 1 << 7) {
                    {
#line 117
                    insert_list_node(list);
                    }
                  }
#line 117
                  (list->last)->list[list->length].start = start;
#line 117
                  (list->last)->list[list->length].end = start;
#line 117
                  (list->length) ++;
#line 117
                  goto while_break___0;
                }
                while_break___0: /* CIL Label */ ;
                }
#line 117
                goto while_break;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
              {
#line 118
              tmp___2 = strcmp(s, "#end");
              }
#line 118
              if (tmp___2 == 0) {
                {
#line 119
                tmp___1 = flist_total(evaluator->files);
#line 119
                end = tmp___1 - 1;
                }
                {
#line 120
                while (1) {
                  while_continue___1: /* CIL Label */ ;
                  {
#line 120
                  check_add_region((RegionList const   *)list, end, end);
                  }
                  {
#line 120
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 120
                    if (list->length == 1 << 7) {
                      {
#line 120
                      insert_list_node(list);
                      }
                    }
#line 120
                    (list->last)->list[list->length].start = end;
#line 120
                    (list->last)->list[list->length].end = end;
#line 120
                    (list->length) ++;
#line 120
                    goto while_break___2;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 120
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 122
                sgrep_error(sgrep___0, (char *)"Don\'t know how to handle phrase %s\n",
                            s);
                }
              }
            }
          } else {
            {
#line 127
            (root->leaf)->regions = index_lookup(sgrep___0->index_reader, (char const   *)((root->leaf)->phrase)->s);
            }
          }
        }
      }
#line 132
      if (! ((unsigned long )(root->leaf)->regions != (unsigned long )((void *)0))) {
        {
#line 132
        __assert_fail("root->leaf->regions!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      132U, "recursive_eval");
        }
      }
#line 134
      a = (root->leaf)->regions;
#line 135
      (root->leaf)->regions = (RegionList *)((void *)0);
#line 136
      a->refcount = root->refcount;
    }
  }
#line 145
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 149
    a = eval_operator(evaluator, root);
#line 150
    a->refcount = root->refcount;
#line 152
    free_tree_node(root->left);
#line 159
    free_tree_node(root->right);
    }
  }
#line 176
  if ((a->nodes - 1) * (1 << 7) + a->length > sgrep___0->statistics.longest_list) {
#line 177
    sgrep___0->statistics.longest_list = (a->nodes - 1) * (1 << 7) + a->length;
  }
#line 180
  if (! a->nested) {
    {
#line 185
    start_region_search(a, & p);
    }
    {
#line 186
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 186
      check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg1));
      }
      {
#line 186
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 186
        if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 186
          goto _L;
        } else
#line 186
        if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 186
          if (p.ind == (int )(p.list)->length) {
#line 186
            reg1.start = -1;
#line 186
            reg1.end = -1;
#line 186
            goto while_break___4;
          }
#line 186
          if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 186
            reg1.start = p.ind;
#line 186
            reg1.end = p.ind + (int )(p.list)->chars;
#line 186
            (p.ind) ++;
#line 186
            goto while_break___4;
          }
        }
#line 186
        if (p.ind == 1 << 7) {
#line 186
          p.node = (p.node)->next;
#line 186
          p.ind = 0;
        }
#line 186
        tmp___4 = p.ind;
#line 186
        (p.ind) ++;
#line 186
        reg1 = (p.node)->list[tmp___4];
#line 186
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 186
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 187
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 187
      check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg2));
      }
      {
#line 187
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 187
        if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 187
          goto _L___0;
        } else
#line 187
        if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 187
          if (p.ind == (int )(p.list)->length) {
#line 187
            reg2.start = -1;
#line 187
            reg2.end = -1;
#line 187
            goto while_break___6;
          }
#line 187
          if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 187
            reg2.start = p.ind;
#line 187
            reg2.end = p.ind + (int )(p.list)->chars;
#line 187
            (p.ind) ++;
#line 187
            goto while_break___6;
          }
        }
#line 187
        if (p.ind == 1 << 7) {
#line 187
          p.node = (p.node)->next;
#line 187
          p.ind = 0;
        }
#line 187
        tmp___5 = p.ind;
#line 187
        (p.ind) ++;
#line 187
        reg2 = (p.node)->list[tmp___5];
#line 187
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 187
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 188
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 188
      if (! (reg2.start != -1)) {
#line 188
        goto while_break___7;
      }
#line 190
      if (! (reg1.end < reg2.end)) {
        {
#line 190
        __assert_fail("reg1.end<reg2.end", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      190U, "recursive_eval");
        }
      }
#line 191
      reg1 = reg2;
      {
#line 192
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 192
        check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg2));
        }
        {
#line 192
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 192
          if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 192
            goto _L___1;
          } else
#line 192
          if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
#line 192
            if (p.ind == (int )(p.list)->length) {
#line 192
              reg2.start = -1;
#line 192
              reg2.end = -1;
#line 192
              goto while_break___9;
            }
#line 192
            if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 192
              reg2.start = p.ind;
#line 192
              reg2.end = p.ind + (int )(p.list)->chars;
#line 192
              (p.ind) ++;
#line 192
              goto while_break___9;
            }
          }
#line 192
          if (p.ind == 1 << 7) {
#line 192
            p.node = (p.node)->next;
#line 192
            p.ind = 0;
          }
#line 192
          tmp___6 = p.ind;
#line 192
          (p.ind) ++;
#line 192
          reg2 = (p.node)->list[tmp___6];
#line 192
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 192
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 197
  root->result = a;
#line 204
  return (a);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *eval_operator(Evaluator *evaluator , ParseTreeNode *root ) 
{ 
  RegionList *a ;
  RegionList *l ;
  RegionList *r ;

  {
#line 214
  a = (RegionList *)((void *)0);
#line 215
  if (! ((unsigned long )root->left != (unsigned long )((void *)0))) {
    {
#line 215
    __assert_fail("root->left!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  215U, "eval_operator");
    }
  }
  {
#line 219
  l = recursive_eval(evaluator, root->left);
  }
#line 221
  if ((unsigned long )root->right == (unsigned long )((void *)0)) {
#line 221
    r = (RegionList *)((void *)0);
  } else {
    {
#line 222
    r = recursive_eval(evaluator, root->right);
    }
  }
#line 225
  ((evaluator->sgrep)->statistics.operators_evaluated) ++;
  {
#line 229
  if ((unsigned int )root->oper == 15U) {
#line 229
    goto case_15;
  }
#line 235
  if ((unsigned int )root->oper == 9U) {
#line 235
    goto case_9;
  }
#line 235
  if ((unsigned int )root->oper == 8U) {
#line 235
    goto case_9;
  }
#line 235
  if ((unsigned int )root->oper == 7U) {
#line 235
    goto case_9;
  }
#line 235
  if ((unsigned int )root->oper == 6U) {
#line 235
    goto case_9;
  }
#line 241
  if ((unsigned int )root->oper == 13U) {
#line 241
    goto case_13;
  }
#line 241
  if ((unsigned int )root->oper == 12U) {
#line 241
    goto case_13;
  }
#line 241
  if ((unsigned int )root->oper == 11U) {
#line 241
    goto case_13;
  }
#line 241
  if ((unsigned int )root->oper == 10U) {
#line 241
    goto case_13;
  }
#line 244
  if ((unsigned int )root->oper == 0U) {
#line 244
    goto case_0;
  }
#line 247
  if ((unsigned int )root->oper == 1U) {
#line 247
    goto case_1;
  }
#line 250
  if ((unsigned int )root->oper == 2U) {
#line 250
    goto case_2;
  }
#line 253
  if ((unsigned int )root->oper == 3U) {
#line 253
    goto case_3;
  }
#line 257
  if ((unsigned int )root->oper == 4U) {
#line 257
    goto case_4;
  }
#line 260
  if ((unsigned int )root->oper == 5U) {
#line 260
    goto case_5;
  }
#line 264
  if ((unsigned int )root->oper == 16U) {
#line 264
    goto case_16;
  }
#line 267
  if ((unsigned int )root->oper == 17U) {
#line 267
    goto case_17;
  }
#line 270
  if ((unsigned int )root->oper == 20U) {
#line 270
    goto case_20;
  }
#line 273
  if ((unsigned int )root->oper == 21U) {
#line 273
    goto case_21;
  }
#line 276
  if ((unsigned int )root->oper == 14U) {
#line 276
    goto case_14;
  }
#line 279
  if ((unsigned int )root->oper == 22U) {
#line 279
    goto case_22;
  }
#line 282
  if ((unsigned int )root->oper == 23U) {
#line 282
    goto case_23;
  }
#line 285
  if ((unsigned int )root->oper == 24U) {
#line 285
    goto case_24;
  }
#line 288
  if ((unsigned int )root->oper == 25U) {
#line 288
    goto case_25;
  }
#line 291
  if ((unsigned int )root->oper == 26U) {
#line 291
    goto case_26;
  }
#line 294
  if ((unsigned int )root->oper == 27U) {
#line 294
    goto case_27;
  }
#line 297
  if ((unsigned int )root->oper == 18U) {
#line 297
    goto case_18;
  }
#line 300
  if ((unsigned int )root->oper == 19U) {
#line 300
    goto case_19;
  }
#line 303
  goto switch_default;
  case_15: /* CIL Label */ 
  {
#line 230
  a = or(l, r);
  }
#line 231
  goto switch_break;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 236
  a = nest_order(evaluator, l, r, (int )root->oper);
  }
#line 237
  goto switch_break;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 242
  a = quote(l, r, (int )root->oper);
  }
#line 243
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 245
  a = in(l, r, 0);
  }
#line 246
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 248
  a = in(l, r, 1);
  }
#line 249
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 251
  a = containing(evaluator, l, r, 0);
  }
#line 252
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 254
  a = containing(evaluator, l, r, 1);
  }
#line 255
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 258
  a = equal(l, r, 0);
  }
#line 259
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 261
  a = equal(l, r, 1);
  }
#line 262
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 265
  a = parenting(evaluator, l, r);
  }
#line 266
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 268
  a = childrening(l, r);
  }
#line 269
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 271
  a = outer(l);
  }
#line 272
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 274
  a = inner(evaluator, l);
  }
#line 275
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 277
  a = extracting(l, r);
  }
#line 278
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 280
  a = concat(l);
  }
#line 281
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 283
  a = join(evaluator, l, root->number);
  }
#line 284
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 286
  a = first(l, root->number);
  }
#line 287
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 289
  a = last(l, root->number);
  }
#line 290
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 292
  a = first_bytes(l, root->number);
  }
#line 293
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 295
  a = last_bytes(l, root->number);
  }
#line 296
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 298
  a = eval_near(l, r, root->number);
  }
#line 299
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 301
  a = near_before(l, r, root->number);
  }
#line 302
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 304
  sgrep_error(evaluator->sgrep, (char *)"Unknown operator in parse tree (%d)\n", (unsigned int )root->oper);
#line 307
  __assert_fail("0 && \"Unknown operator in parse tree\"", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                307U, "eval_operator");
  }
#line 308
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 311
  return (a);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
int free_tree_node(ParseTreeNode *node ) 
{ 


  {
#line 321
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 321
    return (0);
  }
#line 323
  if ((unsigned long )node->result != (unsigned long )((void *)0)) {
#line 323
    if ((node->result)->refcount != -1) {
#line 324
      ((node->result)->refcount) --;
#line 325
      if (! ((node->result)->refcount >= 0)) {
        {
#line 325
        __assert_fail("node->result->refcount>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      325U, "free_tree_node");
        }
      }
#line 326
      if ((node->result)->refcount == 0) {
        {
#line 327
        delete_region_list(node->result);
#line 328
        node->result = (RegionList *)((void *)0);
        }
#line 329
        return (1);
      }
    }
  }
#line 332
  return (0);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
Region first_of(ListIterator *lp , ListIterator *rp ) 
{ 
  Region l_reg ;
  Region r_reg ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 356
    check_get_region((ListIterator const   *)lp, (Region const   *)(& l_reg));
    }
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 356
      if ((unsigned long )lp->node == (unsigned long )((void *)0)) {
#line 356
        goto _L;
      } else
#line 356
      if ((unsigned long )(lp->node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 356
        if (lp->ind == (int )(lp->list)->length) {
#line 356
          l_reg.start = -1;
#line 356
          l_reg.end = -1;
#line 356
          goto while_break___0;
        }
#line 356
        if ((unsigned long )(lp->list)->last == (unsigned long )((void *)0)) {
#line 356
          l_reg.start = lp->ind;
#line 356
          l_reg.end = lp->ind + (int )(lp->list)->chars;
#line 356
          (lp->ind) ++;
#line 356
          goto while_break___0;
        }
      }
#line 356
      if (lp->ind == 1 << 7) {
#line 356
        lp->node = (lp->node)->next;
#line 356
        lp->ind = 0;
      }
#line 356
      tmp = lp->ind;
#line 356
      (lp->ind) ++;
#line 356
      l_reg = (lp->node)->list[tmp];
#line 356
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 356
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 357
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 357
    check_get_region((ListIterator const   *)rp, (Region const   *)(& r_reg));
    }
    {
#line 357
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 357
      if ((unsigned long )rp->node == (unsigned long )((void *)0)) {
#line 357
        goto _L___0;
      } else
#line 357
      if ((unsigned long )(rp->node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 357
        if (rp->ind == (int )(rp->list)->length) {
#line 357
          r_reg.start = -1;
#line 357
          r_reg.end = -1;
#line 357
          goto while_break___2;
        }
#line 357
        if ((unsigned long )(rp->list)->last == (unsigned long )((void *)0)) {
#line 357
          r_reg.start = rp->ind;
#line 357
          r_reg.end = rp->ind + (int )(rp->list)->chars;
#line 357
          (rp->ind) ++;
#line 357
          goto while_break___2;
        }
      }
#line 357
      if (rp->ind == 1 << 7) {
#line 357
        rp->node = (rp->node)->next;
#line 357
        rp->ind = 0;
      }
#line 357
      tmp___0 = rp->ind;
#line 357
      (rp->ind) ++;
#line 357
      r_reg = (rp->node)->list[tmp___0];
#line 357
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 357
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 358
  if (r_reg.start != -1) {
#line 358
    if (l_reg.start != -1) {
#line 360
      if (l_reg.start < r_reg.start) {
        {
#line 362
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 362
          check_prev_region((ListIterator const   *)rp, (Region const   *)(& r_reg));
          }
          {
#line 362
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 362
            if ((unsigned long )rp->node == (unsigned long )((void *)0)) {
#line 362
              goto _L___1;
            } else
#line 362
            if ((unsigned long )(rp->node)->prev == (unsigned long )((void *)0)) {
              _L___1: /* CIL Label */ 
#line 362
              if (rp->ind == 0) {
#line 362
                r_reg.start = -1;
#line 362
                r_reg.end = -1;
#line 362
                goto while_break___4;
              }
#line 362
              if ((unsigned long )(rp->list)->first == (unsigned long )((void *)0)) {
#line 362
                (rp->ind) --;
#line 362
                r_reg.start = rp->ind;
#line 362
                r_reg.end = r_reg.start + (int )(rp->list)->chars;
#line 362
                goto while_break___4;
              }
            }
#line 362
            if (rp->ind == 0) {
#line 362
              rp->node = (rp->node)->prev;
#line 362
              rp->ind = 1 << 7;
            }
#line 362
            (rp->ind) --;
#line 362
            r_reg = (rp->node)->list[rp->ind];
#line 362
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 362
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 363
        return (l_reg);
      } else
#line 364
      if (l_reg.start > r_reg.start) {
        {
#line 366
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 366
          check_prev_region((ListIterator const   *)lp, (Region const   *)(& l_reg));
          }
          {
#line 366
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 366
            if ((unsigned long )lp->node == (unsigned long )((void *)0)) {
#line 366
              goto _L___2;
            } else
#line 366
            if ((unsigned long )(lp->node)->prev == (unsigned long )((void *)0)) {
              _L___2: /* CIL Label */ 
#line 366
              if (lp->ind == 0) {
#line 366
                l_reg.start = -1;
#line 366
                l_reg.end = -1;
#line 366
                goto while_break___6;
              }
#line 366
              if ((unsigned long )(lp->list)->first == (unsigned long )((void *)0)) {
#line 366
                (lp->ind) --;
#line 366
                l_reg.start = lp->ind;
#line 366
                l_reg.end = l_reg.start + (int )(lp->list)->chars;
#line 366
                goto while_break___6;
              }
            }
#line 366
            if (lp->ind == 0) {
#line 366
              lp->node = (lp->node)->prev;
#line 366
              lp->ind = 1 << 7;
            }
#line 366
            (lp->ind) --;
#line 366
            l_reg = (lp->node)->list[lp->ind];
#line 366
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 366
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 367
        return (r_reg);
      } else
#line 368
      if (l_reg.end < r_reg.end) {
        {
#line 370
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 370
          check_prev_region((ListIterator const   *)rp, (Region const   *)(& r_reg));
          }
          {
#line 370
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 370
            if ((unsigned long )rp->node == (unsigned long )((void *)0)) {
#line 370
              goto _L___3;
            } else
#line 370
            if ((unsigned long )(rp->node)->prev == (unsigned long )((void *)0)) {
              _L___3: /* CIL Label */ 
#line 370
              if (rp->ind == 0) {
#line 370
                r_reg.start = -1;
#line 370
                r_reg.end = -1;
#line 370
                goto while_break___8;
              }
#line 370
              if ((unsigned long )(rp->list)->first == (unsigned long )((void *)0)) {
#line 370
                (rp->ind) --;
#line 370
                r_reg.start = rp->ind;
#line 370
                r_reg.end = r_reg.start + (int )(rp->list)->chars;
#line 370
                goto while_break___8;
              }
            }
#line 370
            if (rp->ind == 0) {
#line 370
              rp->node = (rp->node)->prev;
#line 370
              rp->ind = 1 << 7;
            }
#line 370
            (rp->ind) --;
#line 370
            r_reg = (rp->node)->list[rp->ind];
#line 370
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 370
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 371
        return (l_reg);
      } else
#line 372
      if (l_reg.end > r_reg.end) {
        {
#line 374
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 374
          check_prev_region((ListIterator const   *)lp, (Region const   *)(& l_reg));
          }
          {
#line 374
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 374
            if ((unsigned long )lp->node == (unsigned long )((void *)0)) {
#line 374
              goto _L___4;
            } else
#line 374
            if ((unsigned long )(lp->node)->prev == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 374
              if (lp->ind == 0) {
#line 374
                l_reg.start = -1;
#line 374
                l_reg.end = -1;
#line 374
                goto while_break___10;
              }
#line 374
              if ((unsigned long )(lp->list)->first == (unsigned long )((void *)0)) {
#line 374
                (lp->ind) --;
#line 374
                l_reg.start = lp->ind;
#line 374
                l_reg.end = l_reg.start + (int )(lp->list)->chars;
#line 374
                goto while_break___10;
              }
            }
#line 374
            if (lp->ind == 0) {
#line 374
              lp->node = (lp->node)->prev;
#line 374
              lp->ind = 1 << 7;
            }
#line 374
            (lp->ind) --;
#line 374
            l_reg = (lp->node)->list[lp->ind];
#line 374
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 374
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 375
        return (r_reg);
      } else {
#line 378
        return (r_reg);
      }
    }
  }
#line 381
  if (r_reg.start != -1) {
#line 381
    return (r_reg);
  }
#line 382
  if (l_reg.start != -1) {
#line 382
    return (l_reg);
  }
#line 384
  return (r_reg);
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *or(RegionList *l , RegionList *r ) 
{ 
  ListIterator lp ;
  ListIterator rp ;
  RegionList *a ;
  Region tmp ;
  Region prev ;
  SgrepData *sgrep___0 ;

  {
  {
#line 402
  sgrep___0 = l->sgrep;
#line 407
  (sgrep___0->statistics.or_oper) ++;
#line 408
  a = new_region_list(sgrep___0);
#line 410
  prev.start = -1;
#line 411
  prev.end = -1;
#line 413
  start_region_search(l, & lp);
#line 414
  start_region_search(r, & rp);
#line 422
  tmp = first_of(& lp, & rp);
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (tmp.start != -1)) {
#line 422
      goto while_break;
    }
#line 425
    if (tmp.end <= prev.end) {
#line 428
      a->nested = 1;
    }
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 431
      check_add_region((RegionList const   *)a, tmp.start, tmp.end);
      }
      {
#line 431
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 431
        if (a->length == 1 << 7) {
          {
#line 431
          insert_list_node(a);
          }
        }
#line 431
        (a->last)->list[a->length].start = tmp.start;
#line 431
        (a->last)->list[a->length].end = tmp.end;
#line 431
        (a->length) ++;
#line 431
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 431
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 433
    prev = tmp;
#line 422
    tmp = first_of(& lp, & rp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return (a);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *nest_order(Evaluator *evaluator , RegionList *l , RegionList *r , int type ) 
{ 
  ListIterator lp ;
  ListIterator rp ;
  RegionList *a ;
  Region r_reg ;
  Region l_reg ;
  int nest_depth ;
  int nestings ;
  int s ;
  int e ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 448
  nest_depth = 0;
#line 451
  sgrep___0 = evaluator->sgrep;
#line 460
  start_region_search(r, & rp);
#line 462
  (sgrep___0->statistics.order) ++;
#line 463
  a = new_region_list(sgrep___0);
  }
#line 464
  if (l->nested) {
#line 464
    tmp = 1;
  } else
#line 464
  if (r->nested) {
#line 464
    tmp = 1;
  } else {
#line 464
    tmp = 0;
  }
  {
#line 464
  a->nested = tmp;
#line 486
  nestings = 0;
#line 487
  start_end_sorted_search(l, & lp);
  }
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 488
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
    }
    {
#line 488
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 488
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 488
        goto _L;
      } else
#line 488
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 488
        if (lp.ind == (int )(lp.list)->length) {
#line 488
          l_reg.start = -1;
#line 488
          l_reg.end = -1;
#line 488
          goto while_break___0;
        }
#line 488
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 488
          l_reg.start = lp.ind;
#line 488
          l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 488
          (lp.ind) ++;
#line 488
          goto while_break___0;
        }
      }
#line 488
      if (lp.ind == 1 << 7) {
#line 488
        lp.node = (lp.node)->next;
#line 488
        lp.ind = 0;
      }
#line 488
      tmp___0 = lp.ind;
#line 488
      (lp.ind) ++;
#line 488
      l_reg = (lp.node)->list[tmp___0];
#line 488
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 488
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 489
    check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
    }
    {
#line 489
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 489
      if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 489
        goto _L___0;
      } else
#line 489
      if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 489
        if (rp.ind == (int )(rp.list)->length) {
#line 489
          r_reg.start = -1;
#line 489
          r_reg.end = -1;
#line 489
          goto while_break___2;
        }
#line 489
        if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 489
          r_reg.start = rp.ind;
#line 489
          r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 489
          (rp.ind) ++;
#line 489
          goto while_break___2;
        }
      }
#line 489
      if (rp.ind == 1 << 7) {
#line 489
        rp.node = (rp.node)->next;
#line 489
        rp.ind = 0;
      }
#line 489
      tmp___1 = rp.ind;
#line 489
      (rp.ind) ++;
#line 489
      r_reg = (rp.node)->list[tmp___1];
#line 489
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 489
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 491
  if (l_reg.start == -1) {
#line 491
    return (a);
  } else
#line 491
  if (r_reg.start == -1) {
#line 491
    return (a);
  }
  {
#line 493
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 495
    if (l_reg.end < r_reg.start) {
#line 495
      if (l_reg.start != -1) {
#line 499
        if (nest_depth == evaluator->tmp_stack_size) {
          {
#line 501
          evaluator->tmp_stack_size += evaluator->tmp_stack_size / 2;
#line 502
          tmp___2 = sgrep_debug_realloc(sgrep___0, (void *)evaluator->tmp_stack, (unsigned long )evaluator->tmp_stack_size * sizeof(Region ));
#line 502
          evaluator->tmp_stack = (Region *)tmp___2;
          }
        }
#line 506
        tmp___3 = nest_depth;
#line 506
        nest_depth ++;
#line 506
        *(evaluator->tmp_stack + tmp___3) = l_reg;
#line 507
        nestings = 0;
        {
#line 514
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 514
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 514
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 514
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 514
              goto _L___1;
            } else
#line 514
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___1: /* CIL Label */ 
#line 514
              if (lp.ind == (int )(lp.list)->length) {
#line 514
                l_reg.start = -1;
#line 514
                l_reg.end = -1;
#line 514
                goto while_break___5;
              }
#line 514
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 514
                l_reg.start = lp.ind;
#line 514
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 514
                (lp.ind) ++;
#line 514
                goto while_break___5;
              }
            }
#line 514
            if (lp.ind == 1 << 7) {
#line 514
              lp.node = (lp.node)->next;
#line 514
              lp.ind = 0;
            }
#line 514
            tmp___4 = lp.ind;
#line 514
            (lp.ind) ++;
#line 514
            l_reg = (lp.node)->list[tmp___4];
#line 514
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 514
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 495
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 516
    if (nest_depth > 0) {
#line 521
      if (type == 7) {
#line 522
        nest_depth --;
#line 522
        s = (evaluator->tmp_stack + nest_depth)->end + 1;
      } else
#line 521
      if (type == 9) {
#line 522
        nest_depth --;
#line 522
        s = (evaluator->tmp_stack + nest_depth)->end + 1;
      } else {
#line 523
        nest_depth --;
#line 523
        s = (evaluator->tmp_stack + nest_depth)->start;
      }
#line 524
      if (type == 8) {
#line 525
        e = r_reg.start - 1;
      } else
#line 524
      if (type == 9) {
#line 525
        e = r_reg.start - 1;
      } else {
#line 526
        e = r_reg.end;
      }
#line 528
      if (e >= s) {
#line 533
        nestings ++;
#line 534
        if (nestings == 2) {
          {
#line 540
          a->nested = 1;
#line 541
          list_set_sorted(a, (enum RegionListSorted )0);
          }
        }
        {
#line 543
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 543
          check_add_region((RegionList const   *)a, s, e);
          }
          {
#line 543
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 543
            if (a->length == 1 << 7) {
              {
#line 543
              insert_list_node(a);
              }
            }
#line 543
            (a->last)->list[a->length].start = s;
#line 543
            (a->last)->list[a->length].end = e;
#line 543
            (a->length) ++;
#line 543
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 543
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 545
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 545
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 545
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 545
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 545
            goto _L___2;
          } else
#line 545
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___2: /* CIL Label */ 
#line 545
            if (rp.ind == (int )(rp.list)->length) {
#line 545
              r_reg.start = -1;
#line 545
              r_reg.end = -1;
#line 545
              goto while_break___9;
            }
#line 545
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 545
              r_reg.start = rp.ind;
#line 545
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 545
              (rp.ind) ++;
#line 545
              goto while_break___9;
            }
          }
#line 545
          if (rp.ind == 1 << 7) {
#line 545
            rp.node = (rp.node)->next;
#line 545
            rp.ind = 0;
          }
#line 545
          tmp___5 = rp.ind;
#line 545
          (rp.ind) ++;
#line 545
          r_reg = (rp.node)->list[tmp___5];
#line 545
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 545
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
      {
#line 548
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 548
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 548
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 548
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 548
            goto _L___3;
          } else
#line 548
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 548
            if (rp.ind == (int )(rp.list)->length) {
#line 548
              r_reg.start = -1;
#line 548
              r_reg.end = -1;
#line 548
              goto while_break___11;
            }
#line 548
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 548
              r_reg.start = rp.ind;
#line 548
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 548
              (rp.ind) ++;
#line 548
              goto while_break___11;
            }
          }
#line 548
          if (rp.ind == 1 << 7) {
#line 548
            rp.node = (rp.node)->next;
#line 548
            rp.ind = 0;
          }
#line 548
          tmp___6 = rp.ind;
#line 548
          (rp.ind) ++;
#line 548
          r_reg = (rp.node)->list[tmp___6];
#line 548
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 548
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 493
    if (! (r_reg.start != -1)) {
#line 493
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 551
  return (a);
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *in(RegionList *l , RegionList *r , int not ) 
{ 
  ListIterator lp ;
  ListIterator rp ;
  RegionList *a ;
  RegionList *r2 ;
  Region r_reg ;
  Region l_reg ;
  Region r_reg2 ;
  char *oper_name ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 568
  sgrep___0 = l->sgrep;
#line 573
  if (not) {
#line 575
    (sgrep___0->statistics.not_in) ++;
#line 576
    oper_name = (char *)"not in";
  } else {
#line 579
    (sgrep___0->statistics.in) ++;
#line 580
    oper_name = (char *)"in";
  }
  {
#line 582
  a = new_region_list(sgrep___0);
#line 585
  a->nested = l->nested;
#line 588
  start_region_search(l, & lp);
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 589
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
    }
    {
#line 589
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 589
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 589
        goto _L;
      } else
#line 589
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 589
        if (lp.ind == (int )(lp.list)->length) {
#line 589
          l_reg.start = -1;
#line 589
          l_reg.end = -1;
#line 589
          goto while_break___0;
        }
#line 589
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 589
          l_reg.start = lp.ind;
#line 589
          l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 589
          (lp.ind) ++;
#line 589
          goto while_break___0;
        }
      }
#line 589
      if (lp.ind == 1 << 7) {
#line 589
        lp.node = (lp.node)->next;
#line 589
        lp.ind = 0;
      }
#line 589
      tmp = lp.ind;
#line 589
      (lp.ind) ++;
#line 589
      l_reg = (lp.node)->list[tmp];
#line 589
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 589
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  if (r->nested) {
    {
#line 599
    r2 = outer(r);
#line 600
    r = r2;
    }
  } else {
#line 602
    r2 = (RegionList *)((void *)0);
  }
  {
#line 604
  start_region_search(r, & rp);
  }
  {
#line 611
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 611
    check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
    }
    {
#line 611
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 611
      if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 611
        goto _L___0;
      } else
#line 611
      if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 611
        if (rp.ind == (int )(rp.list)->length) {
#line 611
          r_reg.start = -1;
#line 611
          r_reg.end = -1;
#line 611
          goto while_break___2;
        }
#line 611
        if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 611
          r_reg.start = rp.ind;
#line 611
          r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 611
          (rp.ind) ++;
#line 611
          goto while_break___2;
        }
      }
#line 611
      if (rp.ind == 1 << 7) {
#line 611
        rp.node = (rp.node)->next;
#line 611
        rp.ind = 0;
      }
#line 611
      tmp___0 = rp.ind;
#line 611
      (rp.ind) ++;
#line 611
      r_reg = (rp.node)->list[tmp___0];
#line 611
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 611
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 612
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 612
    if (r_reg.start != -1) {
#line 612
      if (! (l_reg.start != -1)) {
#line 612
        goto while_break___3;
      }
    } else {
#line 612
      goto while_break___3;
    }
#line 619
    if (l_reg.start < r_reg.start) {
#line 624
      if (not) {
        {
#line 624
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 624
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 624
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 624
            if (a->length == 1 << 7) {
              {
#line 624
              insert_list_node(a);
              }
            }
#line 624
            (a->last)->list[a->length].start = l_reg.start;
#line 624
            (a->last)->list[a->length].end = l_reg.end;
#line 624
            (a->length) ++;
#line 624
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 624
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 625
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 625
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 625
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 625
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 625
            goto _L___1;
          } else
#line 625
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
#line 625
            if (lp.ind == (int )(lp.list)->length) {
#line 625
              l_reg.start = -1;
#line 625
              l_reg.end = -1;
#line 625
              goto while_break___7;
            }
#line 625
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 625
              l_reg.start = lp.ind;
#line 625
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 625
              (lp.ind) ++;
#line 625
              goto while_break___7;
            }
          }
#line 625
          if (lp.ind == 1 << 7) {
#line 625
            lp.node = (lp.node)->next;
#line 625
            lp.ind = 0;
          }
#line 625
          tmp___1 = lp.ind;
#line 625
          (lp.ind) ++;
#line 625
          l_reg = (lp.node)->list[tmp___1];
#line 625
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 625
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 628
    if (l_reg.end <= r_reg.end) {
#line 632
      if (l_reg.start > r_reg.start) {
#line 632
        goto _L___4;
      } else
#line 632
      if (l_reg.end < r_reg.end) {
        _L___4: /* CIL Label */ 
#line 635
        if (! not) {
          {
#line 635
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 635
            check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
            }
            {
#line 635
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 635
              if (a->length == 1 << 7) {
                {
#line 635
                insert_list_node(a);
                }
              }
#line 635
              (a->last)->list[a->length].start = l_reg.start;
#line 635
              (a->last)->list[a->length].end = l_reg.end;
#line 635
              (a->length) ++;
#line 635
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 635
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        {
#line 636
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 636
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 636
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 636
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 636
              goto _L___2;
            } else
#line 636
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___2: /* CIL Label */ 
#line 636
              if (lp.ind == (int )(lp.list)->length) {
#line 636
                l_reg.start = -1;
#line 636
                l_reg.end = -1;
#line 636
                goto while_break___11;
              }
#line 636
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 636
                l_reg.start = lp.ind;
#line 636
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 636
                (lp.ind) ++;
#line 636
                goto while_break___11;
              }
            }
#line 636
            if (lp.ind == 1 << 7) {
#line 636
              lp.node = (lp.node)->next;
#line 636
              lp.ind = 0;
            }
#line 636
            tmp___2 = lp.ind;
#line 636
            (lp.ind) ++;
#line 636
            l_reg = (lp.node)->list[tmp___2];
#line 636
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 636
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      } else {
#line 638
        if (not) {
          {
#line 638
          while (1) {
            while_continue___12: /* CIL Label */ ;
            {
#line 638
            check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
            }
            {
#line 638
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 638
              if (a->length == 1 << 7) {
                {
#line 638
                insert_list_node(a);
                }
              }
#line 638
              (a->last)->list[a->length].start = l_reg.start;
#line 638
              (a->last)->list[a->length].end = l_reg.end;
#line 638
              (a->length) ++;
#line 638
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 638
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
        {
#line 639
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 639
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 639
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 639
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 639
              goto _L___3;
            } else
#line 639
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___3: /* CIL Label */ 
#line 639
              if (lp.ind == (int )(lp.list)->length) {
#line 639
                l_reg.start = -1;
#line 639
                l_reg.end = -1;
#line 639
                goto while_break___15;
              }
#line 639
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 639
                l_reg.start = lp.ind;
#line 639
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 639
                (lp.ind) ++;
#line 639
                goto while_break___15;
              }
            }
#line 639
            if (lp.ind == 1 << 7) {
#line 639
              lp.node = (lp.node)->next;
#line 639
              lp.ind = 0;
            }
#line 639
            tmp___3 = lp.ind;
#line 639
            (lp.ind) ++;
#line 639
            l_reg = (lp.node)->list[tmp___3];
#line 639
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 639
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    } else
#line 642
    if (l_reg.start == r_reg.start) {
#line 647
      if (not) {
        {
#line 647
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 647
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 647
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 647
            if (a->length == 1 << 7) {
              {
#line 647
              insert_list_node(a);
              }
            }
#line 647
            (a->last)->list[a->length].start = l_reg.start;
#line 647
            (a->last)->list[a->length].end = l_reg.end;
#line 647
            (a->length) ++;
#line 647
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 647
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
      {
#line 648
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 648
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 648
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 648
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 648
            goto _L___5;
          } else
#line 648
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___5: /* CIL Label */ 
#line 648
            if (lp.ind == (int )(lp.list)->length) {
#line 648
              l_reg.start = -1;
#line 648
              l_reg.end = -1;
#line 648
              goto while_break___19;
            }
#line 648
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 648
              l_reg.start = lp.ind;
#line 648
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 648
              (lp.ind) ++;
#line 648
              goto while_break___19;
            }
          }
#line 648
          if (lp.ind == 1 << 7) {
#line 648
            lp.node = (lp.node)->next;
#line 648
            lp.ind = 0;
          }
#line 648
          tmp___4 = lp.ind;
#line 648
          (lp.ind) ++;
#line 648
          l_reg = (lp.node)->list[tmp___4];
#line 648
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 648
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
    } else {
      {
#line 655
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 655
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg2));
        }
        {
#line 655
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 655
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 655
            goto _L___6;
          } else
#line 655
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___6: /* CIL Label */ 
#line 655
            if (rp.ind == (int )(rp.list)->length) {
#line 655
              r_reg2.start = -1;
#line 655
              r_reg2.end = -1;
#line 655
              goto while_break___21;
            }
#line 655
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 655
              r_reg2.start = rp.ind;
#line 655
              r_reg2.end = rp.ind + (int )(rp.list)->chars;
#line 655
              (rp.ind) ++;
#line 655
              goto while_break___21;
            }
          }
#line 655
          if (rp.ind == 1 << 7) {
#line 655
            rp.node = (rp.node)->next;
#line 655
            rp.ind = 0;
          }
#line 655
          tmp___5 = rp.ind;
#line 655
          (rp.ind) ++;
#line 655
          r_reg2 = (rp.node)->list[tmp___5];
#line 655
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 655
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 656
      if (r_reg2.start == -1) {
#line 659
        if (l_reg.start > r_reg.end) {
#line 663
          r_reg = r_reg2;
        } else {
#line 668
          if (not) {
            {
#line 668
            while (1) {
              while_continue___22: /* CIL Label */ ;
              {
#line 668
              check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
              }
              {
#line 668
              while (1) {
                while_continue___23: /* CIL Label */ ;
#line 668
                if (a->length == 1 << 7) {
                  {
#line 668
                  insert_list_node(a);
                  }
                }
#line 668
                (a->last)->list[a->length].start = l_reg.start;
#line 668
                (a->last)->list[a->length].end = l_reg.end;
#line 668
                (a->length) ++;
#line 668
                goto while_break___23;
              }
              while_break___23: /* CIL Label */ ;
              }
#line 668
              goto while_break___22;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
          {
#line 669
          while (1) {
            while_continue___24: /* CIL Label */ ;
            {
#line 669
            check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
            }
            {
#line 669
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 669
              if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 669
                goto _L___7;
              } else
#line 669
              if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
                _L___7: /* CIL Label */ 
#line 669
                if (lp.ind == (int )(lp.list)->length) {
#line 669
                  l_reg.start = -1;
#line 669
                  l_reg.end = -1;
#line 669
                  goto while_break___25;
                }
#line 669
                if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 669
                  l_reg.start = lp.ind;
#line 669
                  l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 669
                  (lp.ind) ++;
#line 669
                  goto while_break___25;
                }
              }
#line 669
              if (lp.ind == 1 << 7) {
#line 669
                lp.node = (lp.node)->next;
#line 669
                lp.ind = 0;
              }
#line 669
              tmp___6 = lp.ind;
#line 669
              (lp.ind) ++;
#line 669
              l_reg = (lp.node)->list[tmp___6];
#line 669
              goto while_break___25;
            }
            while_break___25: /* CIL Label */ ;
            }
#line 669
            goto while_break___24;
          }
          while_break___24: /* CIL Label */ ;
          }
        }
      } else
#line 674
      if (l_reg.start >= r_reg2.start) {
#line 678
        r_reg = r_reg2;
      } else {
        {
#line 683
        while (1) {
          while_continue___26: /* CIL Label */ ;
          {
#line 683
          check_prev_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg2));
          }
          {
#line 683
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 683
            if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 683
              goto _L___8;
            } else
#line 683
            if ((unsigned long )(rp.node)->prev == (unsigned long )((void *)0)) {
              _L___8: /* CIL Label */ 
#line 683
              if (rp.ind == 0) {
#line 683
                r_reg2.start = -1;
#line 683
                r_reg2.end = -1;
#line 683
                goto while_break___27;
              }
#line 683
              if ((unsigned long )(rp.list)->first == (unsigned long )((void *)0)) {
#line 683
                (rp.ind) --;
#line 683
                r_reg2.start = rp.ind;
#line 683
                r_reg2.end = r_reg2.start + (int )(rp.list)->chars;
#line 683
                goto while_break___27;
              }
            }
#line 683
            if (rp.ind == 0) {
#line 683
              rp.node = (rp.node)->prev;
#line 683
              rp.ind = 1 << 7;
            }
#line 683
            (rp.ind) --;
#line 683
            r_reg2 = (rp.node)->list[rp.ind];
#line 683
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
#line 683
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 684
        if (not) {
          {
#line 684
          while (1) {
            while_continue___28: /* CIL Label */ ;
            {
#line 684
            check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
            }
            {
#line 684
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 684
              if (a->length == 1 << 7) {
                {
#line 684
                insert_list_node(a);
                }
              }
#line 684
              (a->last)->list[a->length].start = l_reg.start;
#line 684
              (a->last)->list[a->length].end = l_reg.end;
#line 684
              (a->length) ++;
#line 684
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 684
            goto while_break___28;
          }
          while_break___28: /* CIL Label */ ;
          }
        }
        {
#line 685
        while (1) {
          while_continue___30: /* CIL Label */ ;
          {
#line 685
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 685
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 685
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 685
              goto _L___9;
            } else
#line 685
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___9: /* CIL Label */ 
#line 685
              if (lp.ind == (int )(lp.list)->length) {
#line 685
                l_reg.start = -1;
#line 685
                l_reg.end = -1;
#line 685
                goto while_break___31;
              }
#line 685
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 685
                l_reg.start = lp.ind;
#line 685
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 685
                (lp.ind) ++;
#line 685
                goto while_break___31;
              }
            }
#line 685
            if (lp.ind == 1 << 7) {
#line 685
              lp.node = (lp.node)->next;
#line 685
              lp.ind = 0;
            }
#line 685
            tmp___7 = lp.ind;
#line 685
            (lp.ind) ++;
#line 685
            l_reg = (lp.node)->list[tmp___7];
#line 685
            goto while_break___31;
          }
          while_break___31: /* CIL Label */ ;
          }
#line 685
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 697
  if (not) {
    {
#line 699
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 699
      if (! (l_reg.start != -1)) {
#line 699
        goto while_break___32;
      }
      {
#line 701
      while (1) {
        while_continue___33: /* CIL Label */ ;
        {
#line 701
        check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
        }
        {
#line 701
        while (1) {
          while_continue___34: /* CIL Label */ ;
#line 701
          if (a->length == 1 << 7) {
            {
#line 701
            insert_list_node(a);
            }
          }
#line 701
          (a->last)->list[a->length].start = l_reg.start;
#line 701
          (a->last)->list[a->length].end = l_reg.end;
#line 701
          (a->length) ++;
#line 701
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 701
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
      {
#line 702
      while (1) {
        while_continue___35: /* CIL Label */ ;
        {
#line 702
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 702
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 702
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 702
            goto _L___10;
          } else
#line 702
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___10: /* CIL Label */ 
#line 702
            if (lp.ind == (int )(lp.list)->length) {
#line 702
              l_reg.start = -1;
#line 702
              l_reg.end = -1;
#line 702
              goto while_break___36;
            }
#line 702
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 702
              l_reg.start = lp.ind;
#line 702
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 702
              (lp.ind) ++;
#line 702
              goto while_break___36;
            }
          }
#line 702
          if (lp.ind == 1 << 7) {
#line 702
            lp.node = (lp.node)->next;
#line 702
            lp.ind = 0;
          }
#line 702
          tmp___8 = lp.ind;
#line 702
          (lp.ind) ++;
#line 702
          l_reg = (lp.node)->list[tmp___8];
#line 702
          goto while_break___36;
        }
        while_break___36: /* CIL Label */ ;
        }
#line 702
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
  }
#line 707
  if ((unsigned long )r2 != (unsigned long )((void *)0)) {
    {
#line 707
    delete_region_list(r2);
    }
  }
#line 708
  return (a);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *outer(RegionList *gcl ) 
{ 
  ListIterator p ;
  Region reg1 ;
  Region reg2 ;
  RegionList *a ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 723
  sgrep___0 = gcl->sgrep;
#line 730
  (sgrep___0->statistics.outer) ++;
#line 731
  reg2.start = 0;
#line 732
  a = new_region_list(sgrep___0);
#line 733
  start_region_search(gcl, & p);
  }
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 734
    check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg1));
    }
    {
#line 734
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 734
      if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 734
        goto _L;
      } else
#line 734
      if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 734
        if (p.ind == (int )(p.list)->length) {
#line 734
          reg1.start = -1;
#line 734
          reg1.end = -1;
#line 734
          goto while_break___0;
        }
#line 734
        if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 734
          reg1.start = p.ind;
#line 734
          reg1.end = p.ind + (int )(p.list)->chars;
#line 734
          (p.ind) ++;
#line 734
          goto while_break___0;
        }
      }
#line 734
      if (p.ind == 1 << 7) {
#line 734
        p.node = (p.node)->next;
#line 734
        p.ind = 0;
      }
#line 734
      tmp = p.ind;
#line 734
      (p.ind) ++;
#line 734
      reg1 = (p.node)->list[tmp];
#line 734
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 734
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  if (reg1.start == -1) {
#line 737
    return (a);
  }
  {
#line 741
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 741
    check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg2));
    }
    {
#line 741
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 741
      if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 741
        goto _L___0;
      } else
#line 741
      if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 741
        if (p.ind == (int )(p.list)->length) {
#line 741
          reg2.start = -1;
#line 741
          reg2.end = -1;
#line 741
          goto while_break___2;
        }
#line 741
        if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 741
          reg2.start = p.ind;
#line 741
          reg2.end = p.ind + (int )(p.list)->chars;
#line 741
          (p.ind) ++;
#line 741
          goto while_break___2;
        }
      }
#line 741
      if (p.ind == 1 << 7) {
#line 741
        p.node = (p.node)->next;
#line 741
        p.ind = 0;
      }
#line 741
      tmp___0 = p.ind;
#line 741
      (p.ind) ++;
#line 741
      reg2 = (p.node)->list[tmp___0];
#line 741
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 741
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 742
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 742
    if (reg2.start == reg1.start) {
#line 742
      if (! (reg2.end > reg1.end)) {
#line 742
        goto while_break___3;
      }
    } else {
#line 742
      goto while_break___3;
    }
#line 744
    reg1 = reg2;
    {
#line 745
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 745
      check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg2));
      }
      {
#line 745
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 745
        if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 745
          goto _L___1;
        } else
#line 745
        if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 745
          if (p.ind == (int )(p.list)->length) {
#line 745
            reg2.start = -1;
#line 745
            reg2.end = -1;
#line 745
            goto while_break___5;
          }
#line 745
          if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 745
            reg2.start = p.ind;
#line 745
            reg2.end = p.ind + (int )(p.list)->chars;
#line 745
            (p.ind) ++;
#line 745
            goto while_break___5;
          }
        }
#line 745
        if (p.ind == 1 << 7) {
#line 745
          p.node = (p.node)->next;
#line 745
          p.ind = 0;
        }
#line 745
        tmp___1 = p.ind;
#line 745
        (p.ind) ++;
#line 745
        reg2 = (p.node)->list[tmp___1];
#line 745
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 745
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 748
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 748
    if (reg1.start != -1) {
#line 748
      if (! (reg2.start != -1)) {
#line 748
        goto while_break___6;
      }
    } else {
#line 748
      goto while_break___6;
    }
#line 750
    if (reg2.end > reg1.end) {
#line 750
      if (reg2.start != reg1.start) {
        {
#line 753
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 753
          check_add_region((RegionList const   *)a, reg1.start, reg1.end);
          }
          {
#line 753
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 753
            if (a->length == 1 << 7) {
              {
#line 753
              insert_list_node(a);
              }
            }
#line 753
            (a->last)->list[a->length].start = reg1.start;
#line 753
            (a->last)->list[a->length].end = reg1.end;
#line 753
            (a->length) ++;
#line 753
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 753
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 754
        reg1 = reg2;
      }
    }
    {
#line 756
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 756
      check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg2));
      }
      {
#line 756
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 756
        if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 756
          goto _L___2;
        } else
#line 756
        if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
          _L___2: /* CIL Label */ 
#line 756
          if (p.ind == (int )(p.list)->length) {
#line 756
            reg2.start = -1;
#line 756
            reg2.end = -1;
#line 756
            goto while_break___10;
          }
#line 756
          if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 756
            reg2.start = p.ind;
#line 756
            reg2.end = p.ind + (int )(p.list)->chars;
#line 756
            (p.ind) ++;
#line 756
            goto while_break___10;
          }
        }
#line 756
        if (p.ind == 1 << 7) {
#line 756
          p.node = (p.node)->next;
#line 756
          p.ind = 0;
        }
#line 756
        tmp___2 = p.ind;
#line 756
        (p.ind) ++;
#line 756
        reg2 = (p.node)->list[tmp___2];
#line 756
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 756
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 758
    if (reg2.start == reg1.start) {
#line 760
      reg1 = reg2;
      {
#line 761
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 761
        check_get_region((ListIterator const   *)(& p), (Region const   *)(& reg2));
        }
        {
#line 761
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 761
          if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 761
            goto _L___3;
          } else
#line 761
          if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 761
            if (p.ind == (int )(p.list)->length) {
#line 761
              reg2.start = -1;
#line 761
              reg2.end = -1;
#line 761
              goto while_break___12;
            }
#line 761
            if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 761
              reg2.start = p.ind;
#line 761
              reg2.end = p.ind + (int )(p.list)->chars;
#line 761
              (p.ind) ++;
#line 761
              goto while_break___12;
            }
          }
#line 761
          if (p.ind == 1 << 7) {
#line 761
            p.node = (p.node)->next;
#line 761
            p.ind = 0;
          }
#line 761
          tmp___3 = p.ind;
#line 761
          (p.ind) ++;
#line 761
          reg2 = (p.node)->list[tmp___3];
#line 761
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 761
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 764
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 764
    check_add_region((RegionList const   *)a, reg1.start, reg1.end);
    }
    {
#line 764
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 764
      if (a->length == 1 << 7) {
        {
#line 764
        insert_list_node(a);
        }
      }
#line 764
      (a->last)->list[a->length].start = reg1.start;
#line 764
      (a->last)->list[a->length].end = reg1.end;
#line 764
      (a->length) ++;
#line 764
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 764
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 765
  return (a);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *inner(Evaluator *evaluator , RegionList *gcl ) 
{ 
  ListIterator p ;
  int inq_ind ;
  RegionList *a ;
  Region n_reg ;
  Region c_reg ;
  int i___0 ;
  Region *inner_stack ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 774
  inq_ind = 0;
#line 775
  a = (RegionList *)((void *)0);
#line 779
  sgrep___0 = evaluator->sgrep;
#line 788
  (sgrep___0->statistics.inner) ++;
#line 789
  a = new_region_list(sgrep___0);
#line 790
  inner_stack = evaluator->tmp_stack;
#line 798
  start_region_search(gcl, & p);
  }
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 799
    check_get_region((ListIterator const   *)(& p), (Region const   *)(& c_reg));
    }
    {
#line 799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 799
      if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 799
        goto _L;
      } else
#line 799
      if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 799
        if (p.ind == (int )(p.list)->length) {
#line 799
          c_reg.start = -1;
#line 799
          c_reg.end = -1;
#line 799
          goto while_break___0;
        }
#line 799
        if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 799
          c_reg.start = p.ind;
#line 799
          c_reg.end = p.ind + (int )(p.list)->chars;
#line 799
          (p.ind) ++;
#line 799
          goto while_break___0;
        }
      }
#line 799
      if (p.ind == 1 << 7) {
#line 799
        p.node = (p.node)->next;
#line 799
        p.ind = 0;
      }
#line 799
      tmp = p.ind;
#line 799
      (p.ind) ++;
#line 799
      c_reg = (p.node)->list[tmp];
#line 799
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 799
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 800
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 800
    if (! (c_reg.start != -1)) {
#line 800
      goto while_break___1;
    }
    {
#line 801
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 801
      check_get_region((ListIterator const   *)(& p), (Region const   *)(& n_reg));
      }
      {
#line 801
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 801
        if ((unsigned long )p.node == (unsigned long )((void *)0)) {
#line 801
          goto _L___0;
        } else
#line 801
        if ((unsigned long )(p.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 801
          if (p.ind == (int )(p.list)->length) {
#line 801
            n_reg.start = -1;
#line 801
            n_reg.end = -1;
#line 801
            goto while_break___3;
          }
#line 801
          if ((unsigned long )(p.list)->last == (unsigned long )((void *)0)) {
#line 801
            n_reg.start = p.ind;
#line 801
            n_reg.end = p.ind + (int )(p.list)->chars;
#line 801
            (p.ind) ++;
#line 801
            goto while_break___3;
          }
        }
#line 801
        if (p.ind == 1 << 7) {
#line 801
          p.node = (p.node)->next;
#line 801
          p.ind = 0;
        }
#line 801
        tmp___0 = p.ind;
#line 801
        (p.ind) ++;
#line 801
        n_reg = (p.node)->list[tmp___0];
#line 801
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 801
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 802
    if (! (n_reg.start >= c_reg.start)) {
#line 802
      if (! (n_reg.start == -1)) {
        {
#line 802
        __assert_fail("n_reg.start>=c_reg.start || n_reg.start==-1", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      802U, "inner");
        }
      }
    }
#line 803
    if (n_reg.start > c_reg.end) {
#line 803
      goto _L___1;
    } else
#line 803
    if (n_reg.start == -1) {
      _L___1: /* CIL Label */ 
#line 811
      i___0 = 0;
      {
#line 811
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 811
        if (! (i___0 < inq_ind)) {
#line 811
          goto while_break___4;
        }
#line 813
        if (! ((inner_stack + i___0)->start <= c_reg.start)) {
          {
#line 813
          __assert_fail("inner_stack[i].start<=c_reg.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        813U, "inner");
          }
        }
#line 815
        if ((inner_stack + i___0)->end < c_reg.end) {
          {
#line 817
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 817
            check_add_region((RegionList const   *)a, (inner_stack + i___0)->start,
                             (inner_stack + i___0)->end);
            }
            {
#line 817
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 817
              if (a->length == 1 << 7) {
                {
#line 817
                insert_list_node(a);
                }
              }
#line 817
              (a->last)->list[a->length].start = (inner_stack + i___0)->start;
#line 817
              (a->last)->list[a->length].end = (inner_stack + i___0)->end;
#line 817
              (a->length) ++;
#line 817
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 817
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 811
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 820
      inq_ind = 0;
      {
#line 821
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 821
        check_add_region((RegionList const   *)a, c_reg.start, c_reg.end);
        }
        {
#line 821
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 821
          if (a->length == 1 << 7) {
            {
#line 821
            insert_list_node(a);
            }
          }
#line 821
          (a->last)->list[a->length].start = c_reg.start;
#line 821
          (a->last)->list[a->length].end = c_reg.end;
#line 821
          (a->length) ++;
#line 821
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 821
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    } else
#line 822
    if (n_reg.end > c_reg.end) {
#line 826
      if (evaluator->tmp_stack_size == inq_ind) {
        {
#line 828
        evaluator->tmp_stack_size += evaluator->tmp_stack_size / 2;
#line 829
        tmp___1 = sgrep_debug_realloc(sgrep___0, (void *)inner_stack, (unsigned long )evaluator->tmp_stack_size * sizeof(Region ));
#line 829
        inner_stack = (Region *)tmp___1;
#line 833
        evaluator->tmp_stack = inner_stack;
        }
      }
#line 835
      tmp___2 = inq_ind;
#line 835
      inq_ind ++;
#line 835
      *(inner_stack + tmp___2) = c_reg;
    } else {
      {
#line 840
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 840
        if (inq_ind) {
#line 840
          if (n_reg.start >= (inner_stack + (inq_ind - 1))->start) {
#line 840
            if (! (n_reg.end <= (inner_stack + (inq_ind - 1))->end)) {
#line 840
              goto while_break___9;
            }
          } else {
#line 840
            goto while_break___9;
          }
        } else {
#line 840
          goto while_break___9;
        }
#line 844
        inq_ind --;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 847
    c_reg = n_reg;
#line 848
    if (inq_ind) {
#line 849
      if (! (c_reg.start < (inner_stack + (inq_ind - 1))->start)) {
#line 849
        if (! (c_reg.end > (inner_stack + (inq_ind - 1))->end)) {
          {
#line 849
          __assert_fail("c_reg.start<inner_stack[inq_ind-1].start || c_reg.end>inner_stack[inq_ind-1].end",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        850U, "inner");
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 852
  return (a);
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *containing(Evaluator *evaluator , RegionList *l , RegionList *r , int not ) 
{ 
  ListIterator lp ;
  ListIterator rp ;
  RegionList *a ;
  RegionList *r2 ;
  Region r_reg ;
  Region l_reg ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 863
  sgrep___0 = evaluator->sgrep;
#line 872
  if (not) {
#line 872
    (sgrep___0->statistics.not_containing) ++;
  } else {
#line 872
    (sgrep___0->statistics.containing) ++;
  }
  {
#line 873
  a = new_region_list(sgrep___0);
#line 875
  a->nested = l->nested;
#line 877
  start_region_search(l, & lp);
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 878
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
    }
    {
#line 878
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 878
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 878
        goto _L;
      } else
#line 878
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 878
        if (lp.ind == (int )(lp.list)->length) {
#line 878
          l_reg.start = -1;
#line 878
          l_reg.end = -1;
#line 878
          goto while_break___0;
        }
#line 878
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 878
          l_reg.start = lp.ind;
#line 878
          l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 878
          (lp.ind) ++;
#line 878
          goto while_break___0;
        }
      }
#line 878
      if (lp.ind == 1 << 7) {
#line 878
        lp.node = (lp.node)->next;
#line 878
        lp.ind = 0;
      }
#line 878
      tmp = lp.ind;
#line 878
      (lp.ind) ++;
#line 878
      l_reg = (lp.node)->list[tmp];
#line 878
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 878
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 882
  if (r->nested) {
    {
#line 885
    r2 = inner(evaluator, r);
#line 886
    r = r2;
    }
  } else {
#line 888
    r2 = (RegionList *)((void *)0);
  }
  {
#line 896
  start_region_search(r, & rp);
  }
  {
#line 898
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 898
    check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
    }
    {
#line 898
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 898
      if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 898
        goto _L___0;
      } else
#line 898
      if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 898
        if (rp.ind == (int )(rp.list)->length) {
#line 898
          r_reg.start = -1;
#line 898
          r_reg.end = -1;
#line 898
          goto while_break___2;
        }
#line 898
        if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 898
          r_reg.start = rp.ind;
#line 898
          r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 898
          (rp.ind) ++;
#line 898
          goto while_break___2;
        }
      }
#line 898
      if (rp.ind == 1 << 7) {
#line 898
        rp.node = (rp.node)->next;
#line 898
        rp.ind = 0;
      }
#line 898
      tmp___0 = rp.ind;
#line 898
      (rp.ind) ++;
#line 898
      r_reg = (rp.node)->list[tmp___0];
#line 898
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 898
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 899
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 899
    if (r_reg.start != -1) {
#line 899
      if (! (l_reg.start != -1)) {
#line 899
        goto while_break___3;
      }
    } else {
#line 899
      goto while_break___3;
    }
#line 901
    if (l_reg.start > r_reg.start) {
      {
#line 904
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 904
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 904
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 904
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 904
            goto _L___1;
          } else
#line 904
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
#line 904
            if (rp.ind == (int )(rp.list)->length) {
#line 904
              r_reg.start = -1;
#line 904
              r_reg.end = -1;
#line 904
              goto while_break___5;
            }
#line 904
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 904
              r_reg.start = rp.ind;
#line 904
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 904
              (rp.ind) ++;
#line 904
              goto while_break___5;
            }
          }
#line 904
          if (rp.ind == 1 << 7) {
#line 904
            rp.node = (rp.node)->next;
#line 904
            rp.ind = 0;
          }
#line 904
          tmp___1 = rp.ind;
#line 904
          (rp.ind) ++;
#line 904
          r_reg = (rp.node)->list[tmp___1];
#line 904
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 904
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 905
    if (l_reg.end >= r_reg.end) {
#line 909
      if (l_reg.start < r_reg.start) {
#line 909
        goto _L___4;
      } else
#line 909
      if (l_reg.end > r_reg.end) {
        _L___4: /* CIL Label */ 
#line 912
        if (! not) {
          {
#line 912
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 912
            check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
            }
            {
#line 912
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 912
              if (a->length == 1 << 7) {
                {
#line 912
                insert_list_node(a);
                }
              }
#line 912
              (a->last)->list[a->length].start = l_reg.start;
#line 912
              (a->last)->list[a->length].end = l_reg.end;
#line 912
              (a->length) ++;
#line 912
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 912
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
        {
#line 913
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 913
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 913
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 913
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 913
              goto _L___2;
            } else
#line 913
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___2: /* CIL Label */ 
#line 913
              if (lp.ind == (int )(lp.list)->length) {
#line 913
                l_reg.start = -1;
#line 913
                l_reg.end = -1;
#line 913
                goto while_break___9;
              }
#line 913
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 913
                l_reg.start = lp.ind;
#line 913
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 913
                (lp.ind) ++;
#line 913
                goto while_break___9;
              }
            }
#line 913
            if (lp.ind == 1 << 7) {
#line 913
              lp.node = (lp.node)->next;
#line 913
              lp.ind = 0;
            }
#line 913
            tmp___2 = lp.ind;
#line 913
            (lp.ind) ++;
#line 913
            l_reg = (lp.node)->list[tmp___2];
#line 913
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 913
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else {
#line 915
        if (not) {
          {
#line 915
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 915
            check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
            }
            {
#line 915
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 915
              if (a->length == 1 << 7) {
                {
#line 915
                insert_list_node(a);
                }
              }
#line 915
              (a->last)->list[a->length].start = l_reg.start;
#line 915
              (a->last)->list[a->length].end = l_reg.end;
#line 915
              (a->length) ++;
#line 915
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 915
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
        {
#line 916
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 916
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 916
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 916
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 916
              goto _L___3;
            } else
#line 916
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___3: /* CIL Label */ 
#line 916
              if (lp.ind == (int )(lp.list)->length) {
#line 916
                l_reg.start = -1;
#line 916
                l_reg.end = -1;
#line 916
                goto while_break___13;
              }
#line 916
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 916
                l_reg.start = lp.ind;
#line 916
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 916
                (lp.ind) ++;
#line 916
                goto while_break___13;
              }
            }
#line 916
            if (lp.ind == 1 << 7) {
#line 916
              lp.node = (lp.node)->next;
#line 916
              lp.ind = 0;
            }
#line 916
            tmp___3 = lp.ind;
#line 916
            (lp.ind) ++;
#line 916
            l_reg = (lp.node)->list[tmp___3];
#line 916
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 916
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    } else {
#line 921
      if (not) {
        {
#line 921
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 921
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 921
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 921
            if (a->length == 1 << 7) {
              {
#line 921
              insert_list_node(a);
              }
            }
#line 921
            (a->last)->list[a->length].start = l_reg.start;
#line 921
            (a->last)->list[a->length].end = l_reg.end;
#line 921
            (a->length) ++;
#line 921
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 921
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      {
#line 922
      while (1) {
        while_continue___16: /* CIL Label */ ;
        {
#line 922
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 922
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 922
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 922
            goto _L___5;
          } else
#line 922
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___5: /* CIL Label */ 
#line 922
            if (lp.ind == (int )(lp.list)->length) {
#line 922
              l_reg.start = -1;
#line 922
              l_reg.end = -1;
#line 922
              goto while_break___17;
            }
#line 922
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 922
              l_reg.start = lp.ind;
#line 922
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 922
              (lp.ind) ++;
#line 922
              goto while_break___17;
            }
          }
#line 922
          if (lp.ind == 1 << 7) {
#line 922
            lp.node = (lp.node)->next;
#line 922
            lp.ind = 0;
          }
#line 922
          tmp___4 = lp.ind;
#line 922
          (lp.ind) ++;
#line 922
          l_reg = (lp.node)->list[tmp___4];
#line 922
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 922
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 926
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 926
    if (not) {
#line 926
      if (! (l_reg.start != -1)) {
#line 926
        goto while_break___18;
      }
    } else {
#line 926
      goto while_break___18;
    }
    {
#line 928
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 928
      check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
      }
      {
#line 928
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 928
        if (a->length == 1 << 7) {
          {
#line 928
          insert_list_node(a);
          }
        }
#line 928
        (a->last)->list[a->length].start = l_reg.start;
#line 928
        (a->last)->list[a->length].end = l_reg.end;
#line 928
        (a->length) ++;
#line 928
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 928
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 929
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 929
      check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
      }
      {
#line 929
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 929
        if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 929
          goto _L___6;
        } else
#line 929
        if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
          _L___6: /* CIL Label */ 
#line 929
          if (lp.ind == (int )(lp.list)->length) {
#line 929
            l_reg.start = -1;
#line 929
            l_reg.end = -1;
#line 929
            goto while_break___22;
          }
#line 929
          if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 929
            l_reg.start = lp.ind;
#line 929
            l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 929
            (lp.ind) ++;
#line 929
            goto while_break___22;
          }
        }
#line 929
        if (lp.ind == 1 << 7) {
#line 929
          lp.node = (lp.node)->next;
#line 929
          lp.ind = 0;
        }
#line 929
        tmp___5 = lp.ind;
#line 929
        (lp.ind) ++;
#line 929
        l_reg = (lp.node)->list[tmp___5];
#line 929
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 929
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 932
  if ((unsigned long )r2 != (unsigned long )((void *)0)) {
    {
#line 932
    delete_region_list(r2);
    }
  }
#line 933
  return (a);
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *equal(RegionList *l , RegionList *r , int not ) 
{ 
  ListIterator lp ;
  ListIterator rp ;
  RegionList *a ;
  Region r_reg ;
  Region l_reg ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 943
  sgrep___0 = l->sgrep;
#line 952
  if (not) {
#line 952
    (sgrep___0->statistics.not_equal) ++;
  } else {
#line 952
    (sgrep___0->statistics.equal) ++;
  }
  {
#line 953
  a = new_region_list(sgrep___0);
#line 955
  a->nested = l->nested;
#line 957
  start_region_search(l, & lp);
  }
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 958
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
    }
    {
#line 958
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 958
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 958
        goto _L;
      } else
#line 958
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 958
        if (lp.ind == (int )(lp.list)->length) {
#line 958
          l_reg.start = -1;
#line 958
          l_reg.end = -1;
#line 958
          goto while_break___0;
        }
#line 958
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 958
          l_reg.start = lp.ind;
#line 958
          l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 958
          (lp.ind) ++;
#line 958
          goto while_break___0;
        }
      }
#line 958
      if (lp.ind == 1 << 7) {
#line 958
        lp.node = (lp.node)->next;
#line 958
        lp.ind = 0;
      }
#line 958
      tmp = lp.ind;
#line 958
      (lp.ind) ++;
#line 958
      l_reg = (lp.node)->list[tmp];
#line 958
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 958
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 966
  start_region_search(r, & rp);
  }
  {
#line 967
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 967
    check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
    }
    {
#line 967
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 967
      if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 967
        goto _L___0;
      } else
#line 967
      if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 967
        if (rp.ind == (int )(rp.list)->length) {
#line 967
          r_reg.start = -1;
#line 967
          r_reg.end = -1;
#line 967
          goto while_break___2;
        }
#line 967
        if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 967
          r_reg.start = rp.ind;
#line 967
          r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 967
          (rp.ind) ++;
#line 967
          goto while_break___2;
        }
      }
#line 967
      if (rp.ind == 1 << 7) {
#line 967
        rp.node = (rp.node)->next;
#line 967
        rp.ind = 0;
      }
#line 967
      tmp___0 = rp.ind;
#line 967
      (rp.ind) ++;
#line 967
      r_reg = (rp.node)->list[tmp___0];
#line 967
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 967
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 970
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 970
    if (r_reg.start != -1) {
#line 970
      if (! (l_reg.start != -1)) {
#line 970
        goto while_break___3;
      }
    } else {
#line 970
      goto while_break___3;
    }
#line 972
    if (l_reg.start < r_reg.start) {
#line 974
      if (not) {
        {
#line 974
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 974
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 974
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 974
            if (a->length == 1 << 7) {
              {
#line 974
              insert_list_node(a);
              }
            }
#line 974
            (a->last)->list[a->length].start = l_reg.start;
#line 974
            (a->last)->list[a->length].end = l_reg.end;
#line 974
            (a->length) ++;
#line 974
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 974
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 975
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 975
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 975
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 975
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 975
            goto _L___1;
          } else
#line 975
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
#line 975
            if (lp.ind == (int )(lp.list)->length) {
#line 975
              l_reg.start = -1;
#line 975
              l_reg.end = -1;
#line 975
              goto while_break___7;
            }
#line 975
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 975
              l_reg.start = lp.ind;
#line 975
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 975
              (lp.ind) ++;
#line 975
              goto while_break___7;
            }
          }
#line 975
          if (lp.ind == 1 << 7) {
#line 975
            lp.node = (lp.node)->next;
#line 975
            lp.ind = 0;
          }
#line 975
          tmp___1 = lp.ind;
#line 975
          (lp.ind) ++;
#line 975
          l_reg = (lp.node)->list[tmp___1];
#line 975
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 975
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 976
    if (r_reg.start < l_reg.start) {
      {
#line 978
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 978
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 978
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 978
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 978
            goto _L___2;
          } else
#line 978
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___2: /* CIL Label */ 
#line 978
            if (rp.ind == (int )(rp.list)->length) {
#line 978
              r_reg.start = -1;
#line 978
              r_reg.end = -1;
#line 978
              goto while_break___9;
            }
#line 978
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 978
              r_reg.start = rp.ind;
#line 978
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 978
              (rp.ind) ++;
#line 978
              goto while_break___9;
            }
          }
#line 978
          if (rp.ind == 1 << 7) {
#line 978
            rp.node = (rp.node)->next;
#line 978
            rp.ind = 0;
          }
#line 978
          tmp___2 = rp.ind;
#line 978
          (rp.ind) ++;
#line 978
          r_reg = (rp.node)->list[tmp___2];
#line 978
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 978
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 980
    if (l_reg.end < r_reg.end) {
#line 982
      if (not) {
        {
#line 982
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 982
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 982
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 982
            if (a->length == 1 << 7) {
              {
#line 982
              insert_list_node(a);
              }
            }
#line 982
            (a->last)->list[a->length].start = l_reg.start;
#line 982
            (a->last)->list[a->length].end = l_reg.end;
#line 982
            (a->length) ++;
#line 982
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 982
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      {
#line 983
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 983
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 983
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 983
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 983
            goto _L___3;
          } else
#line 983
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 983
            if (lp.ind == (int )(lp.list)->length) {
#line 983
              l_reg.start = -1;
#line 983
              l_reg.end = -1;
#line 983
              goto while_break___13;
            }
#line 983
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 983
              l_reg.start = lp.ind;
#line 983
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 983
              (lp.ind) ++;
#line 983
              goto while_break___13;
            }
          }
#line 983
          if (lp.ind == 1 << 7) {
#line 983
            lp.node = (lp.node)->next;
#line 983
            lp.ind = 0;
          }
#line 983
          tmp___3 = lp.ind;
#line 983
          (lp.ind) ++;
#line 983
          l_reg = (lp.node)->list[tmp___3];
#line 983
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 983
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 984
    if (r_reg.end < l_reg.end) {
      {
#line 986
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 986
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 986
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 986
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 986
            goto _L___4;
          } else
#line 986
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___4: /* CIL Label */ 
#line 986
            if (rp.ind == (int )(rp.list)->length) {
#line 986
              r_reg.start = -1;
#line 986
              r_reg.end = -1;
#line 986
              goto while_break___15;
            }
#line 986
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 986
              r_reg.start = rp.ind;
#line 986
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 986
              (rp.ind) ++;
#line 986
              goto while_break___15;
            }
          }
#line 986
          if (rp.ind == 1 << 7) {
#line 986
            rp.node = (rp.node)->next;
#line 986
            rp.ind = 0;
          }
#line 986
          tmp___4 = rp.ind;
#line 986
          (rp.ind) ++;
#line 986
          r_reg = (rp.node)->list[tmp___4];
#line 986
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 986
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    } else {
#line 989
      if (! not) {
        {
#line 989
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 989
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 989
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 989
            if (a->length == 1 << 7) {
              {
#line 989
              insert_list_node(a);
              }
            }
#line 989
            (a->last)->list[a->length].start = l_reg.start;
#line 989
            (a->last)->list[a->length].end = l_reg.end;
#line 989
            (a->length) ++;
#line 989
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 989
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
      {
#line 990
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 990
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 990
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 990
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 990
            goto _L___5;
          } else
#line 990
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___5: /* CIL Label */ 
#line 990
            if (rp.ind == (int )(rp.list)->length) {
#line 990
              r_reg.start = -1;
#line 990
              r_reg.end = -1;
#line 990
              goto while_break___19;
            }
#line 990
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 990
              r_reg.start = rp.ind;
#line 990
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 990
              (rp.ind) ++;
#line 990
              goto while_break___19;
            }
          }
#line 990
          if (rp.ind == 1 << 7) {
#line 990
            rp.node = (rp.node)->next;
#line 990
            rp.ind = 0;
          }
#line 990
          tmp___5 = rp.ind;
#line 990
          (rp.ind) ++;
#line 990
          r_reg = (rp.node)->list[tmp___5];
#line 990
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 990
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 991
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 991
        check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
        }
        {
#line 991
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 991
          if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 991
            goto _L___6;
          } else
#line 991
          if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
            _L___6: /* CIL Label */ 
#line 991
            if (lp.ind == (int )(lp.list)->length) {
#line 991
              l_reg.start = -1;
#line 991
              l_reg.end = -1;
#line 991
              goto while_break___21;
            }
#line 991
            if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 991
              l_reg.start = lp.ind;
#line 991
              l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 991
              (lp.ind) ++;
#line 991
              goto while_break___21;
            }
          }
#line 991
          if (lp.ind == 1 << 7) {
#line 991
            lp.node = (lp.node)->next;
#line 991
            lp.ind = 0;
          }
#line 991
          tmp___6 = lp.ind;
#line 991
          (lp.ind) ++;
#line 991
          l_reg = (lp.node)->list[tmp___6];
#line 991
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 991
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 995
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 995
    if (not) {
#line 995
      if (! (l_reg.start != -1)) {
#line 995
        goto while_break___22;
      }
    } else {
#line 995
      goto while_break___22;
    }
    {
#line 997
    while (1) {
      while_continue___23: /* CIL Label */ ;
      {
#line 997
      check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
      }
      {
#line 997
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 997
        if (a->length == 1 << 7) {
          {
#line 997
          insert_list_node(a);
          }
        }
#line 997
        (a->last)->list[a->length].start = l_reg.start;
#line 997
        (a->last)->list[a->length].end = l_reg.end;
#line 997
        (a->length) ++;
#line 997
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 997
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 998
    while (1) {
      while_continue___25: /* CIL Label */ ;
      {
#line 998
      check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
      }
      {
#line 998
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 998
        if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 998
          goto _L___7;
        } else
#line 998
        if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
          _L___7: /* CIL Label */ 
#line 998
          if (lp.ind == (int )(lp.list)->length) {
#line 998
            l_reg.start = -1;
#line 998
            l_reg.end = -1;
#line 998
            goto while_break___26;
          }
#line 998
          if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 998
            l_reg.start = lp.ind;
#line 998
            l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 998
            (lp.ind) ++;
#line 998
            goto while_break___26;
          }
        }
#line 998
        if (lp.ind == 1 << 7) {
#line 998
          lp.node = (lp.node)->next;
#line 998
          lp.ind = 0;
        }
#line 998
        tmp___7 = lp.ind;
#line 998
        (lp.ind) ++;
#line 998
        l_reg = (lp.node)->list[tmp___7];
#line 998
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
#line 998
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
  }
  while_break___22: /* CIL Label */ ;
  }
#line 1000
  return (a);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *concat(RegionList *l ) 
{ 
  SgrepData *sgrep___0 ;
  ListIterator lp ;
  RegionList *a ;
  Region reg1 ;
  Region reg2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1010
  sgrep___0 = l->sgrep;
#line 1022
  (sgrep___0->statistics.concat) ++;
#line 1023
  a = new_region_list(sgrep___0);
#line 1024
  start_region_search(l, & lp);
  }
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1025
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& reg1));
    }
    {
#line 1025
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1025
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1025
        goto _L;
      } else
#line 1025
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1025
        if (lp.ind == (int )(lp.list)->length) {
#line 1025
          reg1.start = -1;
#line 1025
          reg1.end = -1;
#line 1025
          goto while_break___0;
        }
#line 1025
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 1025
          reg1.start = lp.ind;
#line 1025
          reg1.end = lp.ind + (int )(lp.list)->chars;
#line 1025
          (lp.ind) ++;
#line 1025
          goto while_break___0;
        }
      }
#line 1025
      if (lp.ind == 1 << 7) {
#line 1025
        lp.node = (lp.node)->next;
#line 1025
        lp.ind = 0;
      }
#line 1025
      tmp = lp.ind;
#line 1025
      (lp.ind) ++;
#line 1025
      reg1 = (lp.node)->list[tmp];
#line 1025
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1025
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1028
  if (reg1.start == -1) {
#line 1028
    return (a);
  }
  {
#line 1035
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1035
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& reg2));
    }
    {
#line 1035
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1035
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1035
        goto _L___0;
      } else
#line 1035
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1035
        if (lp.ind == (int )(lp.list)->length) {
#line 1035
          reg2.start = -1;
#line 1035
          reg2.end = -1;
#line 1035
          goto while_break___2;
        }
#line 1035
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 1035
          reg2.start = lp.ind;
#line 1035
          reg2.end = lp.ind + (int )(lp.list)->chars;
#line 1035
          (lp.ind) ++;
#line 1035
          goto while_break___2;
        }
      }
#line 1035
      if (lp.ind == 1 << 7) {
#line 1035
        lp.node = (lp.node)->next;
#line 1035
        lp.ind = 0;
      }
#line 1035
      tmp___0 = lp.ind;
#line 1035
      (lp.ind) ++;
#line 1035
      reg2 = (lp.node)->list[tmp___0];
#line 1035
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1035
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1037
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1037
    if (! (reg2.start != -1)) {
#line 1037
      goto while_break___3;
    }
#line 1039
    if (reg2.start > reg1.end + 1) {
      {
#line 1042
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1042
        check_add_region((RegionList const   *)a, reg1.start, reg1.end);
        }
        {
#line 1042
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1042
          if (a->length == 1 << 7) {
            {
#line 1042
            insert_list_node(a);
            }
          }
#line 1042
          (a->last)->list[a->length].start = reg1.start;
#line 1042
          (a->last)->list[a->length].end = reg1.end;
#line 1042
          (a->length) ++;
#line 1042
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1042
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1043
      reg1 = reg2;
    } else
#line 1044
    if (reg2.end > reg1.end) {
#line 1047
      reg1.end = reg2.end;
    }
    {
#line 1049
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1049
      check_get_region((ListIterator const   *)(& lp), (Region const   *)(& reg2));
      }
      {
#line 1049
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1049
        if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1049
          goto _L___1;
        } else
#line 1049
        if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 1049
          if (lp.ind == (int )(lp.list)->length) {
#line 1049
            reg2.start = -1;
#line 1049
            reg2.end = -1;
#line 1049
            goto while_break___7;
          }
#line 1049
          if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 1049
            reg2.start = lp.ind;
#line 1049
            reg2.end = lp.ind + (int )(lp.list)->chars;
#line 1049
            (lp.ind) ++;
#line 1049
            goto while_break___7;
          }
        }
#line 1049
        if (lp.ind == 1 << 7) {
#line 1049
          lp.node = (lp.node)->next;
#line 1049
          lp.ind = 0;
        }
#line 1049
        tmp___1 = lp.ind;
#line 1049
        (lp.ind) ++;
#line 1049
        reg2 = (lp.node)->list[tmp___1];
#line 1049
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1049
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1051
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 1051
    check_add_region((RegionList const   *)a, reg1.start, reg1.end);
    }
    {
#line 1051
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1051
      if (a->length == 1 << 7) {
        {
#line 1051
        insert_list_node(a);
        }
      }
#line 1051
      (a->last)->list[a->length].start = reg1.start;
#line 1051
      (a->last)->list[a->length].end = reg1.end;
#line 1051
      (a->length) ++;
#line 1051
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1051
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1052
  return (a);
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *extracting(RegionList *l , RegionList *r ) 
{ 
  SgrepData *sgrep___0 ;
  ListIterator lp ;
  ListIterator rp ;
  ListIterator tmpp ;
  RegionList *a ;
  RegionList *r2 ;
  RegionList *tmp ;
  RegionList *new_tmp ;
  Region l_reg ;
  Region r_reg ;
  int prev_s ;
  int prev_e ;
  int last_tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1060
  sgrep___0 = l->sgrep;
#line 1064
  prev_s = -1;
#line 1065
  prev_e = -1;
#line 1075
  (sgrep___0->statistics.extracting) ++;
#line 1078
  r2 = concat(r);
#line 1079
  r = r2;
#line 1081
  a = new_region_list(sgrep___0);
#line 1083
  a->nested = l->nested;
#line 1085
  tmp = new_region_list(sgrep___0);
#line 1086
  start_region_search(tmp, & tmpp);
#line 1094
  start_region_search(l, & lp);
  }
  {
#line 1095
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1095
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
    }
    {
#line 1095
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1095
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1095
        goto _L;
      } else
#line 1095
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1095
        if (lp.ind == (int )(lp.list)->length) {
#line 1095
          l_reg.start = -1;
#line 1095
          l_reg.end = -1;
#line 1095
          goto while_break___0;
        }
#line 1095
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 1095
          l_reg.start = lp.ind;
#line 1095
          l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 1095
          (lp.ind) ++;
#line 1095
          goto while_break___0;
        }
      }
#line 1095
      if (lp.ind == 1 << 7) {
#line 1095
        lp.node = (lp.node)->next;
#line 1095
        lp.ind = 0;
      }
#line 1095
      tmp___0 = lp.ind;
#line 1095
      (lp.ind) ++;
#line 1095
      l_reg = (lp.node)->list[tmp___0];
#line 1095
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1095
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1096
  start_region_search(r, & rp);
  }
  {
#line 1097
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1097
    check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
    }
    {
#line 1097
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1097
      if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 1097
        goto _L___0;
      } else
#line 1097
      if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1097
        if (rp.ind == (int )(rp.list)->length) {
#line 1097
          r_reg.start = -1;
#line 1097
          r_reg.end = -1;
#line 1097
          goto while_break___2;
        }
#line 1097
        if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 1097
          r_reg.start = rp.ind;
#line 1097
          r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 1097
          (rp.ind) ++;
#line 1097
          goto while_break___2;
        }
      }
#line 1097
      if (rp.ind == 1 << 7) {
#line 1097
        rp.node = (rp.node)->next;
#line 1097
        rp.ind = 0;
      }
#line 1097
      tmp___1 = rp.ind;
#line 1097
      (rp.ind) ++;
#line 1097
      r_reg = (rp.node)->list[tmp___1];
#line 1097
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1097
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1099
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1099
    if (! (l_reg.start != -1)) {
#line 1099
      goto while_break___3;
    }
#line 1101
    if (l_reg.end < r_reg.start) {
#line 1101
      goto _L___5;
    } else
#line 1101
    if (r_reg.start == -1) {
      _L___5: /* CIL Label */ 
#line 1105
      if (prev_s != l_reg.start) {
#line 1105
        goto _L___1;
      } else
#line 1105
      if (prev_e != l_reg.end) {
        _L___1: /* CIL Label */ 
#line 1110
        prev_s = l_reg.start;
#line 1111
        prev_e = l_reg.end;
        {
#line 1112
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1112
          check_add_region((RegionList const   *)a, l_reg.start, l_reg.end);
          }
          {
#line 1112
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1112
            if (a->length == 1 << 7) {
              {
#line 1112
              insert_list_node(a);
              }
            }
#line 1112
            (a->last)->list[a->length].start = l_reg.start;
#line 1112
            (a->last)->list[a->length].end = l_reg.end;
#line 1112
            (a->length) ++;
#line 1112
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1112
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 1114
      l_reg = first_of(& lp, & tmpp);
      }
    } else
#line 1115
    if (r_reg.end < l_reg.start) {
      {
#line 1123
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1123
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 1123
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1123
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 1123
            goto _L___2;
          } else
#line 1123
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___2: /* CIL Label */ 
#line 1123
            if (rp.ind == (int )(rp.list)->length) {
#line 1123
              r_reg.start = -1;
#line 1123
              r_reg.end = -1;
#line 1123
              goto while_break___7;
            }
#line 1123
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 1123
              r_reg.start = rp.ind;
#line 1123
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 1123
              (rp.ind) ++;
#line 1123
              goto while_break___7;
            }
          }
#line 1123
          if (rp.ind == 1 << 7) {
#line 1123
            rp.node = (rp.node)->next;
#line 1123
            rp.ind = 0;
          }
#line 1123
          tmp___2 = rp.ind;
#line 1123
          (rp.ind) ++;
#line 1123
          r_reg = (rp.node)->list[tmp___2];
#line 1123
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1123
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
      {
#line 1127
      new_tmp = new_region_list(sgrep___0);
#line 1130
      last_tmp = -1;
      }
      {
#line 1134
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1134
        if (l_reg.start != -1) {
#line 1134
          if (! (l_reg.start <= r_reg.end)) {
#line 1134
            goto while_break___8;
          }
        } else {
#line 1134
          goto while_break___8;
        }
#line 1136
        if (l_reg.start < r_reg.start) {
#line 1136
          if (prev_s != l_reg.start) {
#line 1136
            goto _L___3;
          } else
#line 1136
          if (prev_e != r_reg.start - 1) {
            _L___3: /* CIL Label */ 
#line 1140
            prev_s = l_reg.start;
#line 1141
            prev_e = r_reg.start - 1;
            {
#line 1146
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 1146
              check_add_region((RegionList const   *)a, l_reg.start, r_reg.start - 1);
              }
              {
#line 1146
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 1146
                if (a->length == 1 << 7) {
                  {
#line 1146
                  insert_list_node(a);
                  }
                }
#line 1146
                (a->last)->list[a->length].start = l_reg.start;
#line 1146
                (a->last)->list[a->length].end = r_reg.start - 1;
#line 1146
                (a->length) ++;
#line 1146
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 1146
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        }
#line 1148
        if (r_reg.end < l_reg.end) {
#line 1153
          if (l_reg.end < last_tmp) {
            {
#line 1154
            list_set_sorted(new_tmp, (enum RegionListSorted )0);
            }
          }
          {
#line 1156
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 1156
            check_add_region((RegionList const   *)new_tmp, r_reg.end + 1, l_reg.end);
            }
            {
#line 1156
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 1156
              if (new_tmp->length == 1 << 7) {
                {
#line 1156
                insert_list_node(new_tmp);
                }
              }
#line 1156
              (new_tmp->last)->list[new_tmp->length].start = r_reg.end + 1;
#line 1156
              (new_tmp->last)->list[new_tmp->length].end = l_reg.end;
#line 1156
              (new_tmp->length) ++;
#line 1156
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 1156
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 1157
          last_tmp = l_reg.end;
        }
        {
#line 1159
        l_reg = first_of(& lp, & tmpp);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1161
      if (l_reg.start != -1) {
        {
#line 1161
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 1161
          check_prev_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 1161
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1161
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1161
              goto _L___4;
            } else
#line 1161
            if ((unsigned long )(lp.node)->prev == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 1161
              if (lp.ind == 0) {
#line 1161
                l_reg.start = -1;
#line 1161
                l_reg.end = -1;
#line 1161
                goto while_break___14;
              }
#line 1161
              if ((unsigned long )(lp.list)->first == (unsigned long )((void *)0)) {
#line 1161
                (lp.ind) --;
#line 1161
                l_reg.start = lp.ind;
#line 1161
                l_reg.end = l_reg.start + (int )(lp.list)->chars;
#line 1161
                goto while_break___14;
              }
            }
#line 1161
            if (lp.ind == 0) {
#line 1161
              lp.node = (lp.node)->prev;
#line 1161
              lp.ind = 1 << 7;
            }
#line 1161
            (lp.ind) --;
#line 1161
            l_reg = (lp.node)->list[lp.ind];
#line 1161
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 1161
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
#line 1163
      if (tmpp.ind == tmp->length) {
#line 1163
        if (! ((unsigned long )(tmpp.node)->next == (unsigned long )((void *)0))) {
          {
#line 1163
          __assert_fail("tmpp.ind==tmp->length && tmpp.node->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        1164U, "extracting");
          }
        }
      } else {
        {
#line 1163
        __assert_fail("tmpp.ind==tmp->length && tmpp.node->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      1164U, "extracting");
        }
      }
      {
#line 1166
      delete_region_list(tmp);
#line 1171
      tmp = new_tmp;
#line 1172
      start_region_search(tmp, & tmpp);
#line 1174
      l_reg = first_of(& lp, & tmpp);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1177
  delete_region_list(r2);
#line 1178
  delete_region_list(tmp);
  }
#line 1179
  return (a);
}
}
#line 1185 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *join(Evaluator *evaluator , RegionList *l , int number ) 
{ 
  RegionList *a ;
  ListIterator p1 ;
  ListIterator p2 ;
  Region r1 ;
  Region r2 ;
  Region prev_r1 ;
  Region prev_r2 ;
  int i___0 ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  enum RegionListSorted tmp___3 ;

  {
#line 1191
  sgrep___0 = l->sgrep;
#line 1200
  if (! (number > 0)) {
    {
#line 1200
    __assert_fail("number>0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  1200U, "join");
    }
  }
  {
#line 1202
  (sgrep___0->statistics.join) ++;
#line 1203
  a = new_region_list(sgrep___0);
#line 1205
  a->nested = l->nested;
  }
#line 1207
  if ((unsigned long )l->first == (unsigned long )((void *)0)) {
    {
#line 1210
    tmp = flist_total(evaluator->files);
#line 1210
    to_chars(a, (l->chars + 1) * number, tmp - 1);
    }
#line 1212
    return (a);
  }
#line 1216
  if ((l->nodes - 1) * (1 << 7) + l->length < number) {
#line 1216
    return (a);
  }
  {
#line 1224
  start_region_search(l, & p1);
#line 1225
  start_region_search(l, & p2);
#line 1227
  prev_r2.start = -1;
#line 1228
  prev_r1.end = -1;
#line 1229
  i___0 = number;
  }
  {
#line 1229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1229
    if (! (i___0 > 0)) {
#line 1229
      goto while_break;
    }
    {
#line 1231
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1231
      check_get_region((ListIterator const   *)(& p1), (Region const   *)(& r1));
      }
      {
#line 1231
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1231
        if ((unsigned long )p1.node == (unsigned long )((void *)0)) {
#line 1231
          goto _L;
        } else
#line 1231
        if ((unsigned long )(p1.node)->next == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 1231
          if (p1.ind == (int )(p1.list)->length) {
#line 1231
            r1.start = -1;
#line 1231
            r1.end = -1;
#line 1231
            goto while_break___1;
          }
#line 1231
          if ((unsigned long )(p1.list)->last == (unsigned long )((void *)0)) {
#line 1231
            r1.start = p1.ind;
#line 1231
            r1.end = p1.ind + (int )(p1.list)->chars;
#line 1231
            (p1.ind) ++;
#line 1231
            goto while_break___1;
          }
        }
#line 1231
        if (p1.ind == 1 << 7) {
#line 1231
          p1.node = (p1.node)->next;
#line 1231
          p1.ind = 0;
        }
#line 1231
        tmp___0 = p1.ind;
#line 1231
        (p1.ind) ++;
#line 1231
        r1 = (p1.node)->list[tmp___0];
#line 1231
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1231
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1232
    if (! (r1.start != -1)) {
      {
#line 1232
      __assert_fail("r1.start!=-1", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                    1232U, "join");
      }
    }
#line 1229
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1234
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1234
    if (! (r1.start != -1)) {
#line 1234
      goto while_break___2;
    }
    {
#line 1236
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1236
      check_get_region((ListIterator const   *)(& p2), (Region const   *)(& r2));
      }
      {
#line 1236
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1236
        if ((unsigned long )p2.node == (unsigned long )((void *)0)) {
#line 1236
          goto _L___0;
        } else
#line 1236
        if ((unsigned long )(p2.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 1236
          if (p2.ind == (int )(p2.list)->length) {
#line 1236
            r2.start = -1;
#line 1236
            r2.end = -1;
#line 1236
            goto while_break___4;
          }
#line 1236
          if ((unsigned long )(p2.list)->last == (unsigned long )((void *)0)) {
#line 1236
            r2.start = p2.ind;
#line 1236
            r2.end = p2.ind + (int )(p2.list)->chars;
#line 1236
            (p2.ind) ++;
#line 1236
            goto while_break___4;
          }
        }
#line 1236
        if (p2.ind == 1 << 7) {
#line 1236
          p2.node = (p2.node)->next;
#line 1236
          p2.ind = 0;
        }
#line 1236
        tmp___1 = p2.ind;
#line 1236
        (p2.ind) ++;
#line 1236
        r2 = (p2.node)->list[tmp___1];
#line 1236
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1236
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1237
    if (r2.start == prev_r2.start) {
#line 1241
      if (r1.end <= prev_r1.end) {
        {
#line 1243
        list_set_sorted(a, (enum RegionListSorted )0);
        }
      }
    }
    {
#line 1246
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1246
      check_add_region((RegionList const   *)a, r2.start, r1.end);
      }
      {
#line 1246
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1246
        if (a->length == 1 << 7) {
          {
#line 1246
          insert_list_node(a);
          }
        }
#line 1246
        (a->last)->list[a->length].start = r2.start;
#line 1246
        (a->last)->list[a->length].end = r1.end;
#line 1246
        (a->length) ++;
#line 1246
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1246
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1247
    prev_r1 = r1;
    {
#line 1248
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1248
      check_get_region((ListIterator const   *)(& p1), (Region const   *)(& r1));
      }
      {
#line 1248
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1248
        if ((unsigned long )p1.node == (unsigned long )((void *)0)) {
#line 1248
          goto _L___1;
        } else
#line 1248
        if ((unsigned long )(p1.node)->next == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 1248
          if (p1.ind == (int )(p1.list)->length) {
#line 1248
            r1.start = -1;
#line 1248
            r1.end = -1;
#line 1248
            goto while_break___8;
          }
#line 1248
          if ((unsigned long )(p1.list)->last == (unsigned long )((void *)0)) {
#line 1248
            r1.start = p1.ind;
#line 1248
            r1.end = p1.ind + (int )(p1.list)->chars;
#line 1248
            (p1.ind) ++;
#line 1248
            goto while_break___8;
          }
        }
#line 1248
        if (p1.ind == 1 << 7) {
#line 1248
          p1.node = (p1.node)->next;
#line 1248
          p1.ind = 0;
        }
#line 1248
        tmp___2 = p1.ind;
#line 1248
        (p1.ind) ++;
#line 1248
        r1 = (p1.node)->list[tmp___2];
#line 1248
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1248
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1249
    prev_r2 = r2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1251
  tmp___3 = list_get_sorted((RegionList const   *)a);
  }
#line 1251
  if ((unsigned int )tmp___3 != 1U) {
    {
#line 1253
    remove_duplicates(a);
    }
  }
#line 1255
  return (a);
}
}
#line 1258 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *first(RegionList *input , int num ) 
{ 
  RegionList *result ;
  ListIterator i___0 ;
  Region r ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1264
  sgrep___0 = input->sgrep;
#line 1266
  result = new_region_list(sgrep___0);
#line 1267
  start_region_search(input, & i___0);
  }
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1268
    check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r));
    }
    {
#line 1268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1268
      if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1268
        goto _L;
      } else
#line 1268
      if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1268
        if (i___0.ind == (int )(i___0.list)->length) {
#line 1268
          r.start = -1;
#line 1268
          r.end = -1;
#line 1268
          goto while_break___0;
        }
#line 1268
        if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1268
          r.start = i___0.ind;
#line 1268
          r.end = i___0.ind + (int )(i___0.list)->chars;
#line 1268
          (i___0.ind) ++;
#line 1268
          goto while_break___0;
        }
      }
#line 1268
      if (i___0.ind == 1 << 7) {
#line 1268
        i___0.node = (i___0.node)->next;
#line 1268
        i___0.ind = 0;
      }
#line 1268
      tmp = i___0.ind;
#line 1268
      (i___0.ind) ++;
#line 1268
      r = (i___0.node)->list[tmp];
#line 1268
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1268
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1269
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1269
    if (num > 0) {
#line 1269
      if (! (r.start != -1)) {
#line 1269
        goto while_break___1;
      }
    } else {
#line 1269
      goto while_break___1;
    }
    {
#line 1270
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1270
      check_add_region((RegionList const   *)result, r.start, r.end);
      }
      {
#line 1270
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1270
        if (result->length == 1 << 7) {
          {
#line 1270
          insert_list_node(result);
          }
        }
#line 1270
        (result->last)->list[result->length].start = r.start;
#line 1270
        (result->last)->list[result->length].end = r.end;
#line 1270
        (result->length) ++;
#line 1270
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1270
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1271
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1271
      check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r));
      }
      {
#line 1271
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1271
        if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1271
          goto _L___0;
        } else
#line 1271
        if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 1271
          if (i___0.ind == (int )(i___0.list)->length) {
#line 1271
            r.start = -1;
#line 1271
            r.end = -1;
#line 1271
            goto while_break___5;
          }
#line 1271
          if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1271
            r.start = i___0.ind;
#line 1271
            r.end = i___0.ind + (int )(i___0.list)->chars;
#line 1271
            (i___0.ind) ++;
#line 1271
            goto while_break___5;
          }
        }
#line 1271
        if (i___0.ind == 1 << 7) {
#line 1271
          i___0.node = (i___0.node)->next;
#line 1271
          i___0.ind = 0;
        }
#line 1271
        tmp___0 = i___0.ind;
#line 1271
        (i___0.ind) ++;
#line 1271
        r = (i___0.node)->list[tmp___0];
#line 1271
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1271
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1272
    num --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1274
  return (result);
}
}
#line 1277 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *last(RegionList *input , int num ) 
{ 
  RegionList *result ;
  ListIterator i___0 ;
  Region r ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1281
  sgrep___0 = input->sgrep;
#line 1283
  num = ((input->nodes - 1) * (1 << 7) + input->length) - num;
#line 1284
  if (num < 0) {
#line 1284
    num = 0;
  }
  {
#line 1285
  result = new_region_list(sgrep___0);
#line 1286
  start_region_search_from(input, num, & i___0);
  }
  {
#line 1287
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1287
    check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r));
    }
    {
#line 1287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1287
      if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1287
        goto _L;
      } else
#line 1287
      if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1287
        if (i___0.ind == (int )(i___0.list)->length) {
#line 1287
          r.start = -1;
#line 1287
          r.end = -1;
#line 1287
          goto while_break___0;
        }
#line 1287
        if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1287
          r.start = i___0.ind;
#line 1287
          r.end = i___0.ind + (int )(i___0.list)->chars;
#line 1287
          (i___0.ind) ++;
#line 1287
          goto while_break___0;
        }
      }
#line 1287
      if (i___0.ind == 1 << 7) {
#line 1287
        i___0.node = (i___0.node)->next;
#line 1287
        i___0.ind = 0;
      }
#line 1287
      tmp = i___0.ind;
#line 1287
      (i___0.ind) ++;
#line 1287
      r = (i___0.node)->list[tmp];
#line 1287
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1287
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1288
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1288
    if (! (r.start != -1)) {
#line 1288
      goto while_break___1;
    }
    {
#line 1289
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1289
      check_add_region((RegionList const   *)result, r.start, r.end);
      }
      {
#line 1289
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1289
        if (result->length == 1 << 7) {
          {
#line 1289
          insert_list_node(result);
          }
        }
#line 1289
        (result->last)->list[result->length].start = r.start;
#line 1289
        (result->last)->list[result->length].end = r.end;
#line 1289
        (result->length) ++;
#line 1289
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1289
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1290
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1290
      check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r));
      }
      {
#line 1290
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1290
        if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1290
          goto _L___0;
        } else
#line 1290
        if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 1290
          if (i___0.ind == (int )(i___0.list)->length) {
#line 1290
            r.start = -1;
#line 1290
            r.end = -1;
#line 1290
            goto while_break___5;
          }
#line 1290
          if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1290
            r.start = i___0.ind;
#line 1290
            r.end = i___0.ind + (int )(i___0.list)->chars;
#line 1290
            (i___0.ind) ++;
#line 1290
            goto while_break___5;
          }
        }
#line 1290
        if (i___0.ind == 1 << 7) {
#line 1290
          i___0.node = (i___0.node)->next;
#line 1290
          i___0.ind = 0;
        }
#line 1290
        tmp___0 = i___0.ind;
#line 1290
        (i___0.ind) ++;
#line 1290
        r = (i___0.node)->list[tmp___0];
#line 1290
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1290
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1292
  return (result);
}
}
#line 1295 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *first_bytes(RegionList *input , int num ) 
{ 
  ListIterator i___0 ;
  Region r1 ;
  Region r2 ;
  RegionList *result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1301
  if (! (num >= 0)) {
    {
#line 1301
    __assert_fail("num>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  1301U, "first_bytes");
    }
  }
  {
#line 1302
  result = new_region_list(input->sgrep);
  }
#line 1303
  if (num == 0) {
#line 1303
    return (result);
  }
  {
#line 1305
  result->nested = input->nested;
#line 1306
  start_region_search(input, & i___0);
#line 1307
  r2.start = -1;
  }
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1308
    check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r1));
    }
    {
#line 1308
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1308
      if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1308
        goto _L;
      } else
#line 1308
      if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1308
        if (i___0.ind == (int )(i___0.list)->length) {
#line 1308
          r1.start = -1;
#line 1308
          r1.end = -1;
#line 1308
          goto while_break___0;
        }
#line 1308
        if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1308
          r1.start = i___0.ind;
#line 1308
          r1.end = i___0.ind + (int )(i___0.list)->chars;
#line 1308
          (i___0.ind) ++;
#line 1308
          goto while_break___0;
        }
      }
#line 1308
      if (i___0.ind == 1 << 7) {
#line 1308
        i___0.node = (i___0.node)->next;
#line 1308
        i___0.ind = 0;
      }
#line 1308
      tmp = i___0.ind;
#line 1308
      (i___0.ind) ++;
#line 1308
      r1 = (i___0.node)->list[tmp];
#line 1308
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1308
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1312
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1312
    if (! (r1.start != -1)) {
#line 1312
      goto while_break___1;
    }
#line 1313
    if ((r1.end - r1.start) + 1 >= num) {
#line 1313
      if (r1.start != r2.start) {
#line 1313
        goto _L___0;
      } else
#line 1313
      if ((r1.start + num) - 1 != r2.end) {
        _L___0: /* CIL Label */ 
#line 1315
        r1.end = (r1.start + num) - 1;
        {
#line 1316
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1316
          check_add_region((RegionList const   *)result, r1.start, r1.end);
          }
          {
#line 1316
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1316
            if (result->length == 1 << 7) {
              {
#line 1316
              insert_list_node(result);
              }
            }
#line 1316
            (result->last)->list[result->length].start = r1.start;
#line 1316
            (result->last)->list[result->length].end = r1.end;
#line 1316
            (result->length) ++;
#line 1316
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1316
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 1318
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1318
      check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r2));
      }
      {
#line 1318
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1318
        if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1318
          goto _L___1;
        } else
#line 1318
        if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 1318
          if (i___0.ind == (int )(i___0.list)->length) {
#line 1318
            r2.start = -1;
#line 1318
            r2.end = -1;
#line 1318
            goto while_break___5;
          }
#line 1318
          if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1318
            r2.start = i___0.ind;
#line 1318
            r2.end = i___0.ind + (int )(i___0.list)->chars;
#line 1318
            (i___0.ind) ++;
#line 1318
            goto while_break___5;
          }
        }
#line 1318
        if (i___0.ind == 1 << 7) {
#line 1318
          i___0.node = (i___0.node)->next;
#line 1318
          i___0.ind = 0;
        }
#line 1318
        tmp___0 = i___0.ind;
#line 1318
        (i___0.ind) ++;
#line 1318
        r2 = (i___0.node)->list[tmp___0];
#line 1318
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1318
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1319
    if (r2.start == -1) {
#line 1320
      r1.start = -1;
    } else
#line 1321
    if ((r2.end - r2.start) + 1 >= num) {
#line 1321
      if (r1.start != r2.start) {
#line 1321
        goto _L___5;
      } else
#line 1321
      if ((r2.start + num) - 1 != r1.end) {
        _L___5: /* CIL Label */ 
#line 1323
        r2.end = (r2.start + num) - 1;
        {
#line 1324
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1324
          check_add_region((RegionList const   *)result, r2.start, r2.end);
          }
          {
#line 1324
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1324
            if (result->length == 1 << 7) {
              {
#line 1324
              insert_list_node(result);
              }
            }
#line 1324
            (result->last)->list[result->length].start = r2.start;
#line 1324
            (result->last)->list[result->length].end = r2.end;
#line 1324
            (result->length) ++;
#line 1324
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1324
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1325
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 1325
          check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r1));
          }
          {
#line 1325
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1325
            if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1325
              goto _L___2;
            } else
#line 1325
            if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
              _L___2: /* CIL Label */ 
#line 1325
              if (i___0.ind == (int )(i___0.list)->length) {
#line 1325
                r1.start = -1;
#line 1325
                r1.end = -1;
#line 1325
                goto while_break___9;
              }
#line 1325
              if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1325
                r1.start = i___0.ind;
#line 1325
                r1.end = i___0.ind + (int )(i___0.list)->chars;
#line 1325
                (i___0.ind) ++;
#line 1325
                goto while_break___9;
              }
            }
#line 1325
            if (i___0.ind == 1 << 7) {
#line 1325
              i___0.node = (i___0.node)->next;
#line 1325
              i___0.ind = 0;
            }
#line 1325
            tmp___1 = i___0.ind;
#line 1325
            (i___0.ind) ++;
#line 1325
            r1 = (i___0.node)->list[tmp___1];
#line 1325
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 1325
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else {
#line 1321
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      {
#line 1327
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1327
        check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r1));
        }
        {
#line 1327
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1327
          if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1327
            goto _L___3;
          } else
#line 1327
          if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 1327
            if (i___0.ind == (int )(i___0.list)->length) {
#line 1327
              r1.start = -1;
#line 1327
              r1.end = -1;
#line 1327
              goto while_break___11;
            }
#line 1327
            if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1327
              r1.start = i___0.ind;
#line 1327
              r1.end = i___0.ind + (int )(i___0.list)->chars;
#line 1327
              (i___0.ind) ++;
#line 1327
              goto while_break___11;
            }
          }
#line 1327
          if (i___0.ind == 1 << 7) {
#line 1327
            i___0.node = (i___0.node)->next;
#line 1327
            i___0.ind = 0;
          }
#line 1327
          tmp___2 = i___0.ind;
#line 1327
          (i___0.ind) ++;
#line 1327
          r1 = (i___0.node)->list[tmp___2];
#line 1327
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1327
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1330
  return (result);
}
}
#line 1334 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *last_bytes(RegionList *input , int num ) 
{ 
  ListIterator i___0 ;
  Region r1 ;
  Region r2 ;
  RegionList *result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1341
  if (! (num >= 0)) {
    {
#line 1341
    __assert_fail("num>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  1341U, "last_bytes");
    }
  }
  {
#line 1342
  result = new_region_list(input->sgrep);
  }
#line 1343
  if (num == 0) {
#line 1343
    return (result);
  }
#line 1345
  if (input->nested) {
    {
#line 1346
    list_set_sorted(result, (enum RegionListSorted )0);
#line 1347
    result->nested = 1;
    }
  }
  {
#line 1349
  start_region_search(input, & i___0);
#line 1350
  r2.start = -1;
  }
  {
#line 1351
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1351
    check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r1));
    }
    {
#line 1351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1351
      if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1351
        goto _L;
      } else
#line 1351
      if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1351
        if (i___0.ind == (int )(i___0.list)->length) {
#line 1351
          r1.start = -1;
#line 1351
          r1.end = -1;
#line 1351
          goto while_break___0;
        }
#line 1351
        if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1351
          r1.start = i___0.ind;
#line 1351
          r1.end = i___0.ind + (int )(i___0.list)->chars;
#line 1351
          (i___0.ind) ++;
#line 1351
          goto while_break___0;
        }
      }
#line 1351
      if (i___0.ind == 1 << 7) {
#line 1351
        i___0.node = (i___0.node)->next;
#line 1351
        i___0.ind = 0;
      }
#line 1351
      tmp = i___0.ind;
#line 1351
      (i___0.ind) ++;
#line 1351
      r1 = (i___0.node)->list[tmp];
#line 1351
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1351
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1352
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1352
    if (! (r1.start != -1)) {
#line 1352
      goto while_break___1;
    }
#line 1353
    if ((r1.end - r1.start) + 1 >= num) {
#line 1353
      if (r1.end != r2.end) {
#line 1353
        goto _L___0;
      } else
#line 1353
      if ((r1.end + 1) - num != r2.start) {
        _L___0: /* CIL Label */ 
#line 1355
        r1.start = (r1.end + 1) - num;
        {
#line 1356
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1356
          check_add_region((RegionList const   *)result, r1.start, r1.end);
          }
          {
#line 1356
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1356
            if (result->length == 1 << 7) {
              {
#line 1356
              insert_list_node(result);
              }
            }
#line 1356
            (result->last)->list[result->length].start = r1.start;
#line 1356
            (result->last)->list[result->length].end = r1.end;
#line 1356
            (result->length) ++;
#line 1356
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1356
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 1358
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1358
      check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r2));
      }
      {
#line 1358
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1358
        if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1358
          goto _L___1;
        } else
#line 1358
        if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 1358
          if (i___0.ind == (int )(i___0.list)->length) {
#line 1358
            r2.start = -1;
#line 1358
            r2.end = -1;
#line 1358
            goto while_break___5;
          }
#line 1358
          if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1358
            r2.start = i___0.ind;
#line 1358
            r2.end = i___0.ind + (int )(i___0.list)->chars;
#line 1358
            (i___0.ind) ++;
#line 1358
            goto while_break___5;
          }
        }
#line 1358
        if (i___0.ind == 1 << 7) {
#line 1358
          i___0.node = (i___0.node)->next;
#line 1358
          i___0.ind = 0;
        }
#line 1358
        tmp___0 = i___0.ind;
#line 1358
        (i___0.ind) ++;
#line 1358
        r2 = (i___0.node)->list[tmp___0];
#line 1358
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1358
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1359
    if (r2.start == -1) {
#line 1360
      r1.start = -1;
    } else
#line 1361
    if ((r2.end - r2.start) + 1 >= num) {
#line 1361
      if (r2.end != r1.end) {
#line 1361
        goto _L___5;
      } else
#line 1361
      if ((r2.end + 1) - num != r1.start) {
        _L___5: /* CIL Label */ 
#line 1363
        r2.start = (r2.end + 1) - num;
        {
#line 1364
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1364
          check_add_region((RegionList const   *)result, r2.start, r2.end);
          }
          {
#line 1364
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1364
            if (result->length == 1 << 7) {
              {
#line 1364
              insert_list_node(result);
              }
            }
#line 1364
            (result->last)->list[result->length].start = r2.start;
#line 1364
            (result->last)->list[result->length].end = r2.end;
#line 1364
            (result->length) ++;
#line 1364
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1364
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1365
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 1365
          check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r1));
          }
          {
#line 1365
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1365
            if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1365
              goto _L___2;
            } else
#line 1365
            if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
              _L___2: /* CIL Label */ 
#line 1365
              if (i___0.ind == (int )(i___0.list)->length) {
#line 1365
                r1.start = -1;
#line 1365
                r1.end = -1;
#line 1365
                goto while_break___9;
              }
#line 1365
              if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1365
                r1.start = i___0.ind;
#line 1365
                r1.end = i___0.ind + (int )(i___0.list)->chars;
#line 1365
                (i___0.ind) ++;
#line 1365
                goto while_break___9;
              }
            }
#line 1365
            if (i___0.ind == 1 << 7) {
#line 1365
              i___0.node = (i___0.node)->next;
#line 1365
              i___0.ind = 0;
            }
#line 1365
            tmp___1 = i___0.ind;
#line 1365
            (i___0.ind) ++;
#line 1365
            r1 = (i___0.node)->list[tmp___1];
#line 1365
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 1365
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      } else {
#line 1361
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      {
#line 1367
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1367
        check_get_region((ListIterator const   *)(& i___0), (Region const   *)(& r1));
        }
        {
#line 1367
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1367
          if ((unsigned long )i___0.node == (unsigned long )((void *)0)) {
#line 1367
            goto _L___3;
          } else
#line 1367
          if ((unsigned long )(i___0.node)->next == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 1367
            if (i___0.ind == (int )(i___0.list)->length) {
#line 1367
              r1.start = -1;
#line 1367
              r1.end = -1;
#line 1367
              goto while_break___11;
            }
#line 1367
            if ((unsigned long )(i___0.list)->last == (unsigned long )((void *)0)) {
#line 1367
              r1.start = i___0.ind;
#line 1367
              r1.end = i___0.ind + (int )(i___0.list)->chars;
#line 1367
              (i___0.ind) ++;
#line 1367
              goto while_break___11;
            }
          }
#line 1367
          if (i___0.ind == 1 << 7) {
#line 1367
            i___0.node = (i___0.node)->next;
#line 1367
            i___0.ind = 0;
          }
#line 1367
          tmp___2 = i___0.ind;
#line 1367
          (i___0.ind) ++;
#line 1367
          r1 = (i___0.node)->list[tmp___2];
#line 1367
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1367
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1370
  if (result->nested) {
    {
#line 1371
    remove_duplicates(result);
    }
  }
#line 1374
  return (result);
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *quote(RegionList *l , RegionList *r , int type ) 
{ 
  ListIterator lp ;
  ListIterator rp ;
  RegionList *a ;
  Region r_reg ;
  Region l_reg ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1386
  sgrep___0 = l->sgrep;
#line 1395
  (sgrep___0->statistics.quote) ++;
#line 1396
  a = new_region_list(sgrep___0);
#line 1415
  start_region_search(r, & rp);
#line 1416
  start_region_search(l, & lp);
  }
  {
#line 1417
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1417
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
    }
    {
#line 1417
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1417
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1417
        goto _L;
      } else
#line 1417
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1417
        if (lp.ind == (int )(lp.list)->length) {
#line 1417
          l_reg.start = -1;
#line 1417
          l_reg.end = -1;
#line 1417
          goto while_break___0;
        }
#line 1417
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 1417
          l_reg.start = lp.ind;
#line 1417
          l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 1417
          (lp.ind) ++;
#line 1417
          goto while_break___0;
        }
      }
#line 1417
      if (lp.ind == 1 << 7) {
#line 1417
        lp.node = (lp.node)->next;
#line 1417
        lp.ind = 0;
      }
#line 1417
      tmp = lp.ind;
#line 1417
      (lp.ind) ++;
#line 1417
      l_reg = (lp.node)->list[tmp];
#line 1417
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1417
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1418
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1418
    check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
    }
    {
#line 1418
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1418
      if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 1418
        goto _L___0;
      } else
#line 1418
      if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1418
        if (rp.ind == (int )(rp.list)->length) {
#line 1418
          r_reg.start = -1;
#line 1418
          r_reg.end = -1;
#line 1418
          goto while_break___2;
        }
#line 1418
        if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 1418
          r_reg.start = rp.ind;
#line 1418
          r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 1418
          (rp.ind) ++;
#line 1418
          goto while_break___2;
        }
      }
#line 1418
      if (rp.ind == 1 << 7) {
#line 1418
        rp.node = (rp.node)->next;
#line 1418
        rp.ind = 0;
      }
#line 1418
      tmp___0 = rp.ind;
#line 1418
      (rp.ind) ++;
#line 1418
      r_reg = (rp.node)->list[tmp___0];
#line 1418
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1418
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1421
  if (l_reg.start == -1) {
#line 1421
    return (a);
  } else
#line 1421
  if (r_reg.start == -1) {
#line 1421
    return (a);
  }
  {
#line 1422
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1424
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1424
      if (l_reg.end >= r_reg.start) {
#line 1424
        if (! (r_reg.start != -1)) {
#line 1424
          goto while_break___4;
        }
      } else {
#line 1424
        goto while_break___4;
      }
      {
#line 1425
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 1425
        check_get_region((ListIterator const   *)(& rp), (Region const   *)(& r_reg));
        }
        {
#line 1425
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1425
          if ((unsigned long )rp.node == (unsigned long )((void *)0)) {
#line 1425
            goto _L___1;
          } else
#line 1425
          if ((unsigned long )(rp.node)->next == (unsigned long )((void *)0)) {
            _L___1: /* CIL Label */ 
#line 1425
            if (rp.ind == (int )(rp.list)->length) {
#line 1425
              r_reg.start = -1;
#line 1425
              r_reg.end = -1;
#line 1425
              goto while_break___6;
            }
#line 1425
            if ((unsigned long )(rp.list)->last == (unsigned long )((void *)0)) {
#line 1425
              r_reg.start = rp.ind;
#line 1425
              r_reg.end = rp.ind + (int )(rp.list)->chars;
#line 1425
              (rp.ind) ++;
#line 1425
              goto while_break___6;
            }
          }
#line 1425
          if (rp.ind == 1 << 7) {
#line 1425
            rp.node = (rp.node)->next;
#line 1425
            rp.ind = 0;
          }
#line 1425
          tmp___1 = rp.ind;
#line 1425
          (rp.ind) ++;
#line 1425
          r_reg = (rp.node)->list[tmp___1];
#line 1425
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1425
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1427
    if (r_reg.start >= 0) {
      {
#line 1430
      if (type == 10) {
#line 1430
        goto case_10;
      }
#line 1433
      if (type == 11) {
#line 1433
        goto case_11;
      }
#line 1436
      if (type == 12) {
#line 1436
        goto case_12;
      }
#line 1439
      if (type == 13) {
#line 1439
        goto case_13;
      }
#line 1445
      goto switch_default;
      case_10: /* CIL Label */ 
      {
#line 1431
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1431
        check_add_region((RegionList const   *)a, l_reg.start, r_reg.end);
        }
        {
#line 1431
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1431
          if (a->length == 1 << 7) {
            {
#line 1431
            insert_list_node(a);
            }
          }
#line 1431
          (a->last)->list[a->length].start = l_reg.start;
#line 1431
          (a->last)->list[a->length].end = r_reg.end;
#line 1431
          (a->length) ++;
#line 1431
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1431
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1432
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 1434
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 1434
        check_add_region((RegionList const   *)a, l_reg.end + 1, r_reg.end);
        }
        {
#line 1434
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1434
          if (a->length == 1 << 7) {
            {
#line 1434
            insert_list_node(a);
            }
          }
#line 1434
          (a->last)->list[a->length].start = l_reg.end + 1;
#line 1434
          (a->last)->list[a->length].end = r_reg.end;
#line 1434
          (a->length) ++;
#line 1434
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1434
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1435
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 1437
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 1437
        check_add_region((RegionList const   *)a, l_reg.start, r_reg.start - 1);
        }
        {
#line 1437
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1437
          if (a->length == 1 << 7) {
            {
#line 1437
            insert_list_node(a);
            }
          }
#line 1437
          (a->last)->list[a->length].start = l_reg.start;
#line 1437
          (a->last)->list[a->length].end = r_reg.start - 1;
#line 1437
          (a->length) ++;
#line 1437
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1437
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1438
      goto switch_break;
      case_13: /* CIL Label */ 
#line 1441
      if (l_reg.end + 1 < r_reg.start) {
        {
#line 1442
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 1442
          check_add_region((RegionList const   *)a, l_reg.end + 1, r_reg.start - 1);
          }
          {
#line 1442
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 1442
            if (a->length == 1 << 7) {
              {
#line 1442
              insert_list_node(a);
              }
            }
#line 1442
            (a->last)->list[a->length].start = l_reg.end + 1;
#line 1442
            (a->last)->list[a->length].end = r_reg.start - 1;
#line 1442
            (a->length) ++;
#line 1442
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 1442
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
#line 1444
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1446
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 1450
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1450
        if (l_reg.start <= r_reg.end) {
#line 1450
          if (! (l_reg.start != -1)) {
#line 1450
            goto while_break___15;
          }
        } else {
#line 1450
          goto while_break___15;
        }
        {
#line 1451
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 1451
          check_get_region((ListIterator const   *)(& lp), (Region const   *)(& l_reg));
          }
          {
#line 1451
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1451
            if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 1451
              goto _L___2;
            } else
#line 1451
            if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
              _L___2: /* CIL Label */ 
#line 1451
              if (lp.ind == (int )(lp.list)->length) {
#line 1451
                l_reg.start = -1;
#line 1451
                l_reg.end = -1;
#line 1451
                goto while_break___17;
              }
#line 1451
              if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 1451
                l_reg.start = lp.ind;
#line 1451
                l_reg.end = lp.ind + (int )(lp.list)->chars;
#line 1451
                (lp.ind) ++;
#line 1451
                goto while_break___17;
              }
            }
#line 1451
            if (lp.ind == 1 << 7) {
#line 1451
              lp.node = (lp.node)->next;
#line 1451
              lp.ind = 0;
            }
#line 1451
            tmp___2 = lp.ind;
#line 1451
            (lp.ind) ++;
#line 1451
            l_reg = (lp.node)->list[tmp___2];
#line 1451
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 1451
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 1422
    if (l_reg.start != -1) {
#line 1422
      if (! (r_reg.start != -1)) {
#line 1422
        goto while_break___3;
      }
    } else {
#line 1422
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1455
  return (a);
}
}
#line 1462 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
int list_find_first_start(RegionList *list , int start , int index___0 ) 
{ 
  int end ;
  int middle ;
  Region region ;

  {
#line 1467
  if (! list->start_sorted_array) {
    {
#line 1467
    __assert_fail("list->start_sorted_array", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  1467U, "list_find_first_start");
    }
  }
#line 1468
  end = (list->nodes - 1) * (1 << 7) + list->length;
#line 1469
  if (! (start <= end)) {
    {
#line 1469
    __assert_fail("start<=end", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                  1469U, "list_find_first_start");
    }
  }
#line 1471
  middle = 1;
  {
#line 1472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1472
    if (! (start + middle < end)) {
#line 1472
      goto while_break;
    }
    {
#line 1473
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1473
      check_region_at((RegionList const   *)list, start + middle);
      }
#line 1473
      if (! ((unsigned long )(& region) != (unsigned long )((void *)0))) {
        {
#line 1473
        __assert_fail("(&region)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      1473U, "list_find_first_start");
        }
      }
      {
#line 1473
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1473
        region = (*(list->start_sorted_array + ((start + middle) >> 7)))->list[(start + middle) & ((1 << 7) - 1)];
#line 1473
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1473
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1476
    if (region.start < index___0) {
#line 1477
      start += middle + 1;
#line 1478
      middle += middle;
    } else {
#line 1480
      end = start + middle;
#line 1481
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1485
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1485
    if (! (start != end)) {
#line 1485
      goto while_break___2;
    }
#line 1486
    middle = (end + start) / 2;
    {
#line 1487
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1487
      check_region_at((RegionList const   *)list, middle);
      }
#line 1487
      if (! ((unsigned long )(& region) != (unsigned long )((void *)0))) {
        {
#line 1487
        __assert_fail("(&region)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      1487U, "list_find_first_start");
        }
      }
      {
#line 1487
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1487
        region = (*(list->start_sorted_array + (middle >> 7)))->list[middle & ((1 << 7) - 1)];
#line 1487
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1487
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1490
    if (region.start < index___0) {
#line 1491
      start = middle + 1;
    } else {
#line 1493
      end = middle;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1496
  return (start);
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *parenting(Evaluator *evaluator , RegionList *l , RegionList *r ) 
{ 
  RegionList *result ;
  Region parent ;
  Region child ;
  ListIterator child_i ;
  int parent_i ;
  int parent_size ;
  Region *stack ;
  int sp ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1504
  stack = evaluator->tmp_stack;
#line 1505
  sp = 0;
#line 1506
  sgrep___0 = l->sgrep;
#line 1508
  (sgrep___0->statistics.parenting) ++;
#line 1511
  result = new_region_list(sgrep___0);
  }
#line 1512
  if ((r->nodes - 1) * (1 << 7) + r->length > 1) {
#line 1512
    result->nested = 1;
  }
  {
#line 1514
  list_require_start_sorted_array(l);
#line 1515
  parent_size = (l->nodes - 1) * (1 << 7) + l->length;
  }
#line 1516
  if (parent_size == 0) {
#line 1516
    return (result);
  }
#line 1517
  parent_i = 0;
  {
#line 1518
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1518
    check_region_at((RegionList const   *)l, parent_i);
    }
#line 1518
    if (! ((unsigned long )(& parent) != (unsigned long )((void *)0))) {
      {
#line 1518
      __assert_fail("(&parent)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                    1518U, "parenting");
      }
    }
    {
#line 1518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1518
      parent = (*(l->start_sorted_array + (parent_i >> 7)))->list[parent_i & ((1 << 7) - 1)];
#line 1518
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1518
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1520
  start_region_search(r, & child_i);
  }
  {
#line 1521
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1521
    check_get_region((ListIterator const   *)(& child_i), (Region const   *)(& child));
    }
    {
#line 1521
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1521
      if ((unsigned long )child_i.node == (unsigned long )((void *)0)) {
#line 1521
        goto _L;
      } else
#line 1521
      if ((unsigned long )(child_i.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1521
        if (child_i.ind == (int )(child_i.list)->length) {
#line 1521
          child.start = -1;
#line 1521
          child.end = -1;
#line 1521
          goto while_break___2;
        }
#line 1521
        if ((unsigned long )(child_i.list)->last == (unsigned long )((void *)0)) {
#line 1521
          child.start = child_i.ind;
#line 1521
          child.end = child_i.ind + (int )(child_i.list)->chars;
#line 1521
          (child_i.ind) ++;
#line 1521
          goto while_break___2;
        }
      }
#line 1521
      if (child_i.ind == 1 << 7) {
#line 1521
        child_i.node = (child_i.node)->next;
#line 1521
        child_i.ind = 0;
      }
#line 1521
      tmp = child_i.ind;
#line 1521
      (child_i.ind) ++;
#line 1521
      child = (child_i.node)->list[tmp];
#line 1521
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1521
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1523
  list_set_sorted(result, (enum RegionListSorted )0);
  }
  {
#line 1525
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1525
    if (child.start != -1) {
#line 1525
      if (! (sp > 0)) {
#line 1525
        if (! (parent_i < parent_size)) {
#line 1525
          goto while_break___3;
        }
      }
    } else {
#line 1525
      goto while_break___3;
    }
    {
#line 1530
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1530
      if (parent.end < child.start) {
#line 1530
        if (! (parent_i < parent_size)) {
#line 1530
          goto while_break___4;
        }
      } else {
#line 1530
        goto while_break___4;
      }
      {
#line 1531
      parent_i = list_find_first_start(l, parent_i, parent.end + 1);
      }
#line 1532
      if (parent_i < parent_size) {
        {
#line 1533
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1533
          check_region_at((RegionList const   *)l, parent_i);
          }
#line 1533
          if (! ((unsigned long )(& parent) != (unsigned long )((void *)0))) {
            {
#line 1533
            __assert_fail("(&parent)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                          1533U, "parenting");
            }
          }
          {
#line 1533
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1533
            parent = (*(l->start_sorted_array + (parent_i >> 7)))->list[parent_i & ((1 << 7) - 1)];
#line 1533
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1533
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1543
    if (sp == 0) {
      {
#line 1544
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1544
        if (child.start != -1) {
#line 1544
          if (parent.start < child.start) {
#line 1544
            if (parent.end >= child.end) {
#line 1544
              goto while_break___7;
            } else {
#line 1544
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 1544
          if (parent.start <= child.start) {
#line 1544
            if (parent.end > child.end) {
#line 1544
              goto while_break___7;
            } else {
#line 1544
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1544
          if (! (parent.end > child.start)) {
#line 1544
            goto while_break___7;
          }
        } else {
#line 1544
          goto while_break___7;
        }
        {
#line 1547
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 1547
          check_get_region((ListIterator const   *)(& child_i), (Region const   *)(& child));
          }
          {
#line 1547
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1547
            if ((unsigned long )child_i.node == (unsigned long )((void *)0)) {
#line 1547
              goto _L___0;
            } else
#line 1547
            if ((unsigned long )(child_i.node)->next == (unsigned long )((void *)0)) {
              _L___0: /* CIL Label */ 
#line 1547
              if (child_i.ind == (int )(child_i.list)->length) {
#line 1547
                child.start = -1;
#line 1547
                child.end = -1;
#line 1547
                goto while_break___9;
              }
#line 1547
              if ((unsigned long )(child_i.list)->last == (unsigned long )((void *)0)) {
#line 1547
                child.start = child_i.ind;
#line 1547
                child.end = child_i.ind + (int )(child_i.list)->chars;
#line 1547
                (child_i.ind) ++;
#line 1547
                goto while_break___9;
              }
            }
#line 1547
            if (child_i.ind == 1 << 7) {
#line 1547
              child_i.node = (child_i.node)->next;
#line 1547
              child_i.ind = 0;
            }
#line 1547
            tmp___0 = child_i.ind;
#line 1547
            (child_i.ind) ++;
#line 1547
            child = (child_i.node)->list[tmp___0];
#line 1547
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 1547
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 1552
    if (child.start == -1) {
#line 1552
      goto while_break___3;
    }
#line 1554
    if (parent_i < parent_size) {
#line 1554
      if (parent.start < child.start) {
#line 1554
        if (parent.end >= child.end) {
#line 1554
          goto _L___6;
        } else {
#line 1554
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 1554
      if (parent.start <= child.start) {
#line 1554
        if (parent.end > child.end) {
          _L___6: /* CIL Label */ 
#line 1558
          if (evaluator->tmp_stack_size == sp) {
            {
#line 1560
            evaluator->tmp_stack_size += evaluator->tmp_stack_size / 2;
#line 1561
            tmp___1 = sgrep_debug_realloc(sgrep___0, (void *)stack, (unsigned long )evaluator->tmp_stack_size * sizeof(Region ));
#line 1561
            stack = (Region *)tmp___1;
#line 1564
            evaluator->tmp_stack = stack;
            }
          }
#line 1566
          tmp___2 = sp;
#line 1566
          sp ++;
#line 1566
          *(stack + tmp___2) = parent;
#line 1567
          parent_i ++;
#line 1568
          if (parent_i < parent_size) {
            {
#line 1569
            while (1) {
              while_continue___10: /* CIL Label */ ;
              {
#line 1569
              check_region_at((RegionList const   *)l, parent_i);
              }
#line 1569
              if (! ((unsigned long )(& parent) != (unsigned long )((void *)0))) {
                {
#line 1569
                __assert_fail("(&parent)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                              1569U, "parenting");
                }
              }
              {
#line 1569
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 1569
                parent = (*(l->start_sorted_array + (parent_i >> 7)))->list[parent_i & ((1 << 7) - 1)];
#line 1569
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 1569
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
          }
        } else {
#line 1554
          goto _L___5;
        }
      } else {
#line 1554
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1575
    if (sp > 0) {
#line 1576
      if ((stack + (sp - 1))->start < child.start) {
#line 1576
        if (! ((stack + (sp - 1))->end >= child.end)) {
#line 1576
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1576
      if ((stack + (sp - 1))->start <= child.start) {
#line 1576
        if (! ((stack + (sp - 1))->end > child.end)) {
          {
#line 1576
          __assert_fail("(((stack[sp-1]).start<(child).start && (stack[sp-1]).end>=(child).end) || ((stack[sp-1]).start<=(child).start && (stack[sp-1]).end>(child).end))",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        1576U, "parenting");
          }
        }
      } else {
        {
#line 1576
        __assert_fail("(((stack[sp-1]).start<(child).start && (stack[sp-1]).end>=(child).end) || ((stack[sp-1]).start<=(child).start && (stack[sp-1]).end>(child).end))",
                      "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      1576U, "parenting");
        }
      }
      {
#line 1577
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1577
        check_add_region((RegionList const   *)result, (stack + (sp - 1))->start,
                         (stack + (sp - 1))->end);
        }
        {
#line 1577
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1577
          if (result->length == 1 << 7) {
            {
#line 1577
            insert_list_node(result);
            }
          }
#line 1577
          (result->last)->list[result->length].start = (stack + (sp - 1))->start;
#line 1577
          (result->last)->list[result->length].end = (stack + (sp - 1))->end;
#line 1577
          (result->length) ++;
#line 1577
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 1577
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1579
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 1579
        check_get_region((ListIterator const   *)(& child_i), (Region const   *)(& child));
        }
        {
#line 1579
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1579
          if ((unsigned long )child_i.node == (unsigned long )((void *)0)) {
#line 1579
            goto _L___4;
          } else
#line 1579
          if ((unsigned long )(child_i.node)->next == (unsigned long )((void *)0)) {
            _L___4: /* CIL Label */ 
#line 1579
            if (child_i.ind == (int )(child_i.list)->length) {
#line 1579
              child.start = -1;
#line 1579
              child.end = -1;
#line 1579
              goto while_break___15;
            }
#line 1579
            if ((unsigned long )(child_i.list)->last == (unsigned long )((void *)0)) {
#line 1579
              child.start = child_i.ind;
#line 1579
              child.end = child_i.ind + (int )(child_i.list)->chars;
#line 1579
              (child_i.ind) ++;
#line 1579
              goto while_break___15;
            }
          }
#line 1579
          if (child_i.ind == 1 << 7) {
#line 1579
            child_i.node = (child_i.node)->next;
#line 1579
            child_i.ind = 0;
          }
#line 1579
          tmp___3 = child_i.ind;
#line 1579
          (child_i.ind) ++;
#line 1579
          child = (child_i.node)->list[tmp___3];
#line 1579
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 1579
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1583
      if (child.start != -1) {
        {
#line 1584
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1584
          if (sp > 0) {
#line 1584
            if (! ((stack + (sp - 1))->end < child.end)) {
#line 1584
              goto while_break___16;
            }
          } else {
#line 1584
            goto while_break___16;
          }
#line 1585
          if (! ((stack + (sp - 1))->start <= child.start)) {
            {
#line 1585
            __assert_fail("stack[sp-1].start<=child.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                          1585U, "parenting");
            }
          }
#line 1586
          sp --;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1593
  remove_duplicates(result);
  }
#line 1594
  return (result);
}
}
#line 1598 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *childrening(RegionList *children , RegionList *parents ) 
{ 
  RegionList *result ;
  ListIterator parent_i ;
  int child_number ;
  Region parent ;
  Region child ;
  Region next_child ;
  int childrens ;
  RegionList *saved_parents ;
  int last_parent_end ;
  int loops ;
  int first___0 ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1607
  loops = 0;
#line 1609
  sgrep___0 = children->sgrep;
#line 1611
  (sgrep___0->statistics.childrening) ++;
#line 1614
  start_region_search(parents, & parent_i);
#line 1615
  list_require_start_sorted_array(children);
  }
  {
#line 1616
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1616
    check_get_region((ListIterator const   *)(& parent_i), (Region const   *)(& parent));
    }
    {
#line 1616
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1616
      if ((unsigned long )parent_i.node == (unsigned long )((void *)0)) {
#line 1616
        goto _L;
      } else
#line 1616
      if ((unsigned long )(parent_i.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1616
        if (parent_i.ind == (int )(parent_i.list)->length) {
#line 1616
          parent.start = -1;
#line 1616
          parent.end = -1;
#line 1616
          goto while_break___0;
        }
#line 1616
        if ((unsigned long )(parent_i.list)->last == (unsigned long )((void *)0)) {
#line 1616
          parent.start = parent_i.ind;
#line 1616
          parent.end = parent_i.ind + (int )(parent_i.list)->chars;
#line 1616
          (parent_i.ind) ++;
#line 1616
          goto while_break___0;
        }
      }
#line 1616
      if (parent_i.ind == 1 << 7) {
#line 1616
        parent_i.node = (parent_i.node)->next;
#line 1616
        parent_i.ind = 0;
      }
#line 1616
      tmp = parent_i.ind;
#line 1616
      (parent_i.ind) ++;
#line 1616
      parent = (parent_i.node)->list[tmp];
#line 1616
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1616
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1617
  saved_parents = new_region_list(sgrep___0);
#line 1618
  saved_parents->nested = 1;
#line 1619
  child_number = 0;
#line 1620
  childrens = (children->nodes - 1) * (1 << 7) + children->length;
#line 1621
  result = new_region_list(sgrep___0);
#line 1622
  first___0 = parent.start;
  }
  {
#line 1625
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1625
    if (! (first___0 != -1)) {
#line 1625
      goto while_break___1;
    }
    {
#line 1628
    child_number = list_find_first_start(children, child_number, first___0);
    }
#line 1630
    if (child_number < childrens) {
      {
#line 1631
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1631
        check_region_at((RegionList const   *)children, child_number);
        }
#line 1631
        if (! ((unsigned long )(& child) != (unsigned long )((void *)0))) {
          {
#line 1631
          __assert_fail("(&child)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        1631U, "childrening");
          }
        }
        {
#line 1631
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1631
          child = (*(children->start_sorted_array + (child_number >> 7)))->list[child_number & ((1 << 7) - 1)];
#line 1631
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1631
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1637
      if (child.start == parent.start) {
#line 1637
        if (child.end == parent.end) {
#line 1638
          first___0 ++;
#line 1639
          goto while_continue___1;
        }
      }
      {
#line 1645
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1645
        if (parent.start < child.start) {
#line 1645
          if (parent.end >= child.end) {
#line 1645
            goto _L___2;
          } else {
#line 1645
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 1645
        if (parent.start <= child.start) {
#line 1645
          if (parent.end > child.end) {
            _L___2: /* CIL Label */ 
#line 1645
            if (! (child_number + 1 < childrens)) {
#line 1645
              goto while_break___4;
            }
          } else {
#line 1645
            goto while_break___4;
          }
        } else {
#line 1645
          goto while_break___4;
        }
        {
#line 1648
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1648
          check_region_at((RegionList const   *)children, child_number + 1);
          }
#line 1648
          if (! ((unsigned long )(& next_child) != (unsigned long )((void *)0))) {
            {
#line 1648
            __assert_fail("(&next_child)!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                          1648U, "childrening");
            }
          }
          {
#line 1648
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1648
            next_child = (*(children->start_sorted_array + ((child_number + 1) >> 7)))->list[(child_number + 1) & ((1 << 7) - 1)];
#line 1648
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1648
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1649
        if (next_child.start == child.start) {
#line 1649
          if (parent.start < next_child.start) {
#line 1649
            if (parent.end >= next_child.end) {
#line 1649
              goto _L___0;
            } else {
#line 1649
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1649
          if (parent.start <= next_child.start) {
#line 1649
            if (parent.end > next_child.end) {
              _L___0: /* CIL Label */ 
#line 1652
              if (! (next_child.end > child.end)) {
                {
#line 1652
                __assert_fail("next_child.end>child.end", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                              1652U, "childrening");
                }
              }
#line 1653
              child_number ++;
#line 1654
              child = next_child;
            } else {
#line 1656
              goto while_break___4;
            }
          } else {
#line 1656
            goto while_break___4;
          }
        } else {
#line 1656
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1660
      if (child_number < childrens) {
#line 1660
        if (! (parent.start <= child.start)) {
          {
#line 1660
          __assert_fail("child_number<childrens && parent.start<=child.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        1660U, "childrening");
          }
        }
      } else {
        {
#line 1660
        __assert_fail("child_number<childrens && parent.start<=child.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                      1660U, "childrening");
        }
      }
#line 1663
      if (parent.start < child.start) {
#line 1663
        if (parent.end >= child.end) {
#line 1663
          goto _L___6;
        } else {
#line 1663
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 1663
      if (parent.start <= child.start) {
#line 1663
        if (parent.end > child.end) {
          _L___6: /* CIL Label */ 
          {
#line 1665
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 1665
            check_add_region((RegionList const   *)result, child.start, child.end);
            }
            {
#line 1665
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1665
              if (result->length == 1 << 7) {
                {
#line 1665
                insert_list_node(result);
                }
              }
#line 1665
              (result->last)->list[result->length].start = child.start;
#line 1665
              (result->last)->list[result->length].end = child.end;
#line 1665
              (result->length) ++;
#line 1665
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 1665
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1666
          first___0 = child.end + 1;
        } else {
#line 1663
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
#line 1669
        last_parent_end = parent.end;
        {
#line 1670
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 1670
          check_get_region((ListIterator const   *)(& parent_i), (Region const   *)(& parent));
          }
          {
#line 1670
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 1670
            if ((unsigned long )parent_i.node == (unsigned long )((void *)0)) {
#line 1670
              goto _L___4;
            } else
#line 1670
            if ((unsigned long )(parent_i.node)->next == (unsigned long )((void *)0)) {
              _L___4: /* CIL Label */ 
#line 1670
              if (parent_i.ind == (int )(parent_i.list)->length) {
#line 1670
                parent.start = -1;
#line 1670
                parent.end = -1;
#line 1670
                goto while_break___10;
              }
#line 1670
              if ((unsigned long )(parent_i.list)->last == (unsigned long )((void *)0)) {
#line 1670
                parent.start = parent_i.ind;
#line 1670
                parent.end = parent_i.ind + (int )(parent_i.list)->chars;
#line 1670
                (parent_i.ind) ++;
#line 1670
                goto while_break___10;
              }
            }
#line 1670
            if (parent_i.ind == 1 << 7) {
#line 1670
              parent_i.node = (parent_i.node)->next;
#line 1670
              parent_i.ind = 0;
            }
#line 1670
            tmp___0 = parent_i.ind;
#line 1670
            (parent_i.ind) ++;
#line 1670
            parent = (parent_i.node)->list[tmp___0];
#line 1670
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 1670
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 1671
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1671
          if (parent.start != -1) {
#line 1671
            if (! (parent.start <= last_parent_end)) {
#line 1671
              goto while_break___11;
            }
          } else {
#line 1671
            goto while_break___11;
          }
          {
#line 1674
          while (1) {
            while_continue___12: /* CIL Label */ ;
            {
#line 1674
            check_add_region((RegionList const   *)saved_parents, parent.start, parent.end);
            }
            {
#line 1674
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1674
              if (saved_parents->length == 1 << 7) {
                {
#line 1674
                insert_list_node(saved_parents);
                }
              }
#line 1674
              (saved_parents->last)->list[saved_parents->length].start = parent.start;
#line 1674
              (saved_parents->last)->list[saved_parents->length].end = parent.end;
#line 1674
              (saved_parents->length) ++;
#line 1674
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 1674
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 1675
          while (1) {
            while_continue___14: /* CIL Label */ ;
            {
#line 1675
            check_get_region((ListIterator const   *)(& parent_i), (Region const   *)(& parent));
            }
            {
#line 1675
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 1675
              if ((unsigned long )parent_i.node == (unsigned long )((void *)0)) {
#line 1675
                goto _L___5;
              } else
#line 1675
              if ((unsigned long )(parent_i.node)->next == (unsigned long )((void *)0)) {
                _L___5: /* CIL Label */ 
#line 1675
                if (parent_i.ind == (int )(parent_i.list)->length) {
#line 1675
                  parent.start = -1;
#line 1675
                  parent.end = -1;
#line 1675
                  goto while_break___15;
                }
#line 1675
                if ((unsigned long )(parent_i.list)->last == (unsigned long )((void *)0)) {
#line 1675
                  parent.start = parent_i.ind;
#line 1675
                  parent.end = parent_i.ind + (int )(parent_i.list)->chars;
#line 1675
                  (parent_i.ind) ++;
#line 1675
                  goto while_break___15;
                }
              }
#line 1675
              if (parent_i.ind == 1 << 7) {
#line 1675
                parent_i.node = (parent_i.node)->next;
#line 1675
                parent_i.ind = 0;
              }
#line 1675
              tmp___1 = parent_i.ind;
#line 1675
              (parent_i.ind) ++;
#line 1675
              parent = (parent_i.node)->list[tmp___1];
#line 1675
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 1675
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1677
        first___0 = parent.start;
      }
    } else {
#line 1680
      first___0 = -1;
    }
#line 1684
    if (first___0 == -1) {
#line 1684
      if ((saved_parents->nodes - 1) * (1 << 7) + saved_parents->length > 0) {
#line 1686
        if (loops > 0) {
          {
#line 1688
          delete_region_list(parents);
          }
        }
        {
#line 1690
        loops ++;
#line 1692
        parents = saved_parents;
#line 1693
        start_region_search(parents, & parent_i);
        }
        {
#line 1694
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 1694
          check_get_region((ListIterator const   *)(& parent_i), (Region const   *)(& parent));
          }
          {
#line 1694
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1694
            if ((unsigned long )parent_i.node == (unsigned long )((void *)0)) {
#line 1694
              goto _L___9;
            } else
#line 1694
            if ((unsigned long )(parent_i.node)->next == (unsigned long )((void *)0)) {
              _L___9: /* CIL Label */ 
#line 1694
              if (parent_i.ind == (int )(parent_i.list)->length) {
#line 1694
                parent.start = -1;
#line 1694
                parent.end = -1;
#line 1694
                goto while_break___17;
              }
#line 1694
              if ((unsigned long )(parent_i.list)->last == (unsigned long )((void *)0)) {
#line 1694
                parent.start = parent_i.ind;
#line 1694
                parent.end = parent_i.ind + (int )(parent_i.list)->chars;
#line 1694
                (parent_i.ind) ++;
#line 1694
                goto while_break___17;
              }
            }
#line 1694
            if (parent_i.ind == 1 << 7) {
#line 1694
              parent_i.node = (parent_i.node)->next;
#line 1694
              parent_i.ind = 0;
            }
#line 1694
            tmp___2 = parent_i.ind;
#line 1694
            (parent_i.ind) ++;
#line 1694
            parent = (parent_i.node)->list[tmp___2];
#line 1694
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 1694
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
        {
#line 1695
        saved_parents = new_region_list(sgrep___0);
#line 1696
        saved_parents->nested = 1;
#line 1697
        child_number = 0;
#line 1700
        list_set_sorted(result, (enum RegionListSorted )0);
#line 1701
        result->nested = 1;
#line 1702
        first___0 = parent.start;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1707
  delete_region_list(saved_parents);
  }
#line 1708
  if (loops > 0) {
    {
#line 1708
    delete_region_list(parents);
    }
  }
#line 1710
  if (loops > 0) {
    {
#line 1713
    remove_duplicates(result);
    }
  }
#line 1716
  return (result);
}
}
#line 1719 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *eval_near(RegionList *l , RegionList *r , int how_near ) 
{ 
  RegionList *first_list ;
  RegionList *second_list ;
  ListIterator first_i ;
  ListIterator second_i ;
  Region result ;
  Region first___0 ;
  Region second ;
  RegionList *result_list ;
  SgrepData *sgrep___0 ;
  RegionList *tmp ;
  RegionList *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1725
  sgrep___0 = l->sgrep;
#line 1728
  if (l->nested) {
    {
#line 1728
    tmp = outer(l);
#line 1728
    first_list = tmp;
    }
  } else {
#line 1728
    first_list = l;
  }
#line 1729
  if (r->nested) {
    {
#line 1729
    tmp___0 = outer(r);
#line 1729
    second_list = tmp___0;
    }
  } else {
#line 1729
    second_list = r;
  }
  {
#line 1732
  start_region_search(first_list, & first_i);
  }
  {
#line 1733
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1733
    check_get_region((ListIterator const   *)(& first_i), (Region const   *)(& first___0));
    }
    {
#line 1733
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1733
      if ((unsigned long )first_i.node == (unsigned long )((void *)0)) {
#line 1733
        goto _L;
      } else
#line 1733
      if ((unsigned long )(first_i.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1733
        if (first_i.ind == (int )(first_i.list)->length) {
#line 1733
          first___0.start = -1;
#line 1733
          first___0.end = -1;
#line 1733
          goto while_break___0;
        }
#line 1733
        if ((unsigned long )(first_i.list)->last == (unsigned long )((void *)0)) {
#line 1733
          first___0.start = first_i.ind;
#line 1733
          first___0.end = first_i.ind + (int )(first_i.list)->chars;
#line 1733
          (first_i.ind) ++;
#line 1733
          goto while_break___0;
        }
      }
#line 1733
      if (first_i.ind == 1 << 7) {
#line 1733
        first_i.node = (first_i.node)->next;
#line 1733
        first_i.ind = 0;
      }
#line 1733
      tmp___1 = first_i.ind;
#line 1733
      (first_i.ind) ++;
#line 1733
      first___0 = (first_i.node)->list[tmp___1];
#line 1733
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1733
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1734
  start_region_search(second_list, & second_i);
  }
  {
#line 1735
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1735
    check_get_region((ListIterator const   *)(& second_i), (Region const   *)(& second));
    }
    {
#line 1735
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1735
      if ((unsigned long )second_i.node == (unsigned long )((void *)0)) {
#line 1735
        goto _L___0;
      } else
#line 1735
      if ((unsigned long )(second_i.node)->next == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1735
        if (second_i.ind == (int )(second_i.list)->length) {
#line 1735
          second.start = -1;
#line 1735
          second.end = -1;
#line 1735
          goto while_break___2;
        }
#line 1735
        if ((unsigned long )(second_i.list)->last == (unsigned long )((void *)0)) {
#line 1735
          second.start = second_i.ind;
#line 1735
          second.end = second_i.ind + (int )(second_i.list)->chars;
#line 1735
          (second_i.ind) ++;
#line 1735
          goto while_break___2;
        }
      }
#line 1735
      if (second_i.ind == 1 << 7) {
#line 1735
        second_i.node = (second_i.node)->next;
#line 1735
        second_i.ind = 0;
      }
#line 1735
      tmp___2 = second_i.ind;
#line 1735
      (second_i.ind) ++;
#line 1735
      second = (second_i.node)->list[tmp___2];
#line 1735
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1735
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1736
  result_list = new_region_list(sgrep___0);
#line 1737
  result.end = -1;
#line 1737
  result.start = result.end;
  }
  {
#line 1740
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1740
    if (first___0.start != -1) {
#line 1740
      if (! (second.start != -1)) {
#line 1740
        goto while_break___3;
      }
    } else {
#line 1740
      goto while_break___3;
    }
#line 1742
    if (first___0.start < second.start) {
#line 1742
      goto _L___3;
    } else
#line 1742
    if (first___0.start == second.start) {
#line 1742
      if (first___0.end < second.end) {
        _L___3: /* CIL Label */ 
#line 1746
        if ((second.start - 1) - first___0.end <= how_near) {
#line 1750
          if (! (first___0.start >= result.start)) {
            {
#line 1750
            __assert_fail("first.start>=result.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                          1750U, "eval_near");
            }
          }
#line 1751
          if (second.end > result.end) {
#line 1754
            if (result.start > 0) {
              {
#line 1755
              while (1) {
                while_continue___4: /* CIL Label */ ;
                {
#line 1755
                check_add_region((RegionList const   *)result_list, result.start,
                                 result.end);
                }
                {
#line 1755
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1755
                  if (result_list->length == 1 << 7) {
                    {
#line 1755
                    insert_list_node(result_list);
                    }
                  }
#line 1755
                  (result_list->last)->list[result_list->length].start = result.start;
#line 1755
                  (result_list->last)->list[result_list->length].end = result.end;
#line 1755
                  (result_list->length) ++;
#line 1755
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1755
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
            }
#line 1758
            result.start = first___0.start;
#line 1759
            result.end = second.end;
          }
        }
        {
#line 1762
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1762
          check_get_region((ListIterator const   *)(& first_i), (Region const   *)(& first___0));
          }
          {
#line 1762
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1762
            if ((unsigned long )first_i.node == (unsigned long )((void *)0)) {
#line 1762
              goto _L___1;
            } else
#line 1762
            if ((unsigned long )(first_i.node)->next == (unsigned long )((void *)0)) {
              _L___1: /* CIL Label */ 
#line 1762
              if (first_i.ind == (int )(first_i.list)->length) {
#line 1762
                first___0.start = -1;
#line 1762
                first___0.end = -1;
#line 1762
                goto while_break___7;
              }
#line 1762
              if ((unsigned long )(first_i.list)->last == (unsigned long )((void *)0)) {
#line 1762
                first___0.start = first_i.ind;
#line 1762
                first___0.end = first_i.ind + (int )(first_i.list)->chars;
#line 1762
                (first_i.ind) ++;
#line 1762
                goto while_break___7;
              }
            }
#line 1762
            if (first_i.ind == 1 << 7) {
#line 1762
              first_i.node = (first_i.node)->next;
#line 1762
              first_i.ind = 0;
            }
#line 1762
            tmp___3 = first_i.ind;
#line 1762
            (first_i.ind) ++;
#line 1762
            first___0 = (first_i.node)->list[tmp___3];
#line 1762
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1762
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 1742
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 1768
      if ((first___0.start - 1) - second.end <= how_near) {
#line 1772
        if (! (second.start >= result.start)) {
          {
#line 1772
          __assert_fail("second.start>=result.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c",
                        1772U, "eval_near");
          }
        }
#line 1773
        if (first___0.end > result.end) {
#line 1776
          if (result.start >= 0) {
            {
#line 1777
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 1777
              check_add_region((RegionList const   *)result_list, result.start, result.end);
              }
              {
#line 1777
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 1777
                if (result_list->length == 1 << 7) {
                  {
#line 1777
                  insert_list_node(result_list);
                  }
                }
#line 1777
                (result_list->last)->list[result_list->length].start = result.start;
#line 1777
                (result_list->last)->list[result_list->length].end = result.end;
#line 1777
                (result_list->length) ++;
#line 1777
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 1777
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
#line 1780
          result.start = second.start;
#line 1781
          result.end = first___0.end;
        }
      }
      {
#line 1784
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1784
        check_get_region((ListIterator const   *)(& second_i), (Region const   *)(& second));
        }
        {
#line 1784
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1784
          if ((unsigned long )second_i.node == (unsigned long )((void *)0)) {
#line 1784
            goto _L___2;
          } else
#line 1784
          if ((unsigned long )(second_i.node)->next == (unsigned long )((void *)0)) {
            _L___2: /* CIL Label */ 
#line 1784
            if (second_i.ind == (int )(second_i.list)->length) {
#line 1784
              second.start = -1;
#line 1784
              second.end = -1;
#line 1784
              goto while_break___11;
            }
#line 1784
            if ((unsigned long )(second_i.list)->last == (unsigned long )((void *)0)) {
#line 1784
              second.start = second_i.ind;
#line 1784
              second.end = second_i.ind + (int )(second_i.list)->chars;
#line 1784
              (second_i.ind) ++;
#line 1784
              goto while_break___11;
            }
          }
#line 1784
          if (second_i.ind == 1 << 7) {
#line 1784
            second_i.node = (second_i.node)->next;
#line 1784
            second_i.ind = 0;
          }
#line 1784
          tmp___4 = second_i.ind;
#line 1784
          (second_i.ind) ++;
#line 1784
          second = (second_i.node)->list[tmp___4];
#line 1784
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1784
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1789
  if ((unsigned long )first_list != (unsigned long )l) {
    {
#line 1790
    delete_region_list(first_list);
    }
  }
#line 1792
  if ((unsigned long )second_list != (unsigned long )r) {
    {
#line 1793
    delete_region_list(second_list);
    }
  }
#line 1797
  if (result.start > 0) {
    {
#line 1798
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 1798
      check_add_region((RegionList const   *)result_list, result.start, result.end);
      }
      {
#line 1798
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1798
        if (result_list->length == 1 << 7) {
          {
#line 1798
          insert_list_node(result_list);
          }
        }
#line 1798
        (result_list->last)->list[result_list->length].start = result.start;
#line 1798
        (result_list->last)->list[result_list->length].end = result.end;
#line 1798
        (result_list->length) ++;
#line 1798
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1798
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 1801
  return (result_list);
}
}
#line 1804 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/eval.c"
RegionList *near_before(RegionList *l , RegionList *r , int how_near ) 
{ 
  RegionList *first_list ;
  RegionList *second_list ;
  ListIterator first_i ;
  int second_size ;
  int second_i ;
  Region first___0 ;
  RegionList *result_list ;
  SgrepData *sgrep___0 ;
  RegionList *tmp ;
  RegionList *tmp___0 ;
  int tmp___1 ;
  RegionList *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1812
  sgrep___0 = l->sgrep;
#line 1815
  if (l->nested) {
    {
#line 1815
    tmp = outer(l);
#line 1815
    first_list = tmp;
    }
  } else {
#line 1815
    first_list = l;
  }
#line 1816
  if (r->nested) {
    {
#line 1816
    tmp___0 = outer(r);
#line 1816
    second_list = tmp___0;
    }
  } else {
#line 1816
    second_list = r;
  }
  {
#line 1819
  start_region_search(first_list, & first_i);
  }
  {
#line 1820
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1820
    check_get_region((ListIterator const   *)(& first_i), (Region const   *)(& first___0));
    }
    {
#line 1820
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1820
      if ((unsigned long )first_i.node == (unsigned long )((void *)0)) {
#line 1820
        goto _L;
      } else
#line 1820
      if ((unsigned long )(first_i.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1820
        if (first_i.ind == (int )(first_i.list)->length) {
#line 1820
          first___0.start = -1;
#line 1820
          first___0.end = -1;
#line 1820
          goto while_break___0;
        }
#line 1820
        if ((unsigned long )(first_i.list)->last == (unsigned long )((void *)0)) {
#line 1820
          first___0.start = first_i.ind;
#line 1820
          first___0.end = first_i.ind + (int )(first_i.list)->chars;
#line 1820
          (first_i.ind) ++;
#line 1820
          goto while_break___0;
        }
      }
#line 1820
      if (first_i.ind == 1 << 7) {
#line 1820
        first_i.node = (first_i.node)->next;
#line 1820
        first_i.ind = 0;
      }
#line 1820
      tmp___1 = first_i.ind;
#line 1820
      (first_i.ind) ++;
#line 1820
      first___0 = (first_i.node)->list[tmp___1];
#line 1820
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1820
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1821
  if (first___0.start == -1) {
    {
#line 1822
    tmp___2 = new_region_list(sgrep___0);
    }
#line 1822
    return (tmp___2);
  }
  {
#line 1824
  list_require_start_sorted_array(second_list);
#line 1825
  second_size = (second_list->nodes - 1) * (1 << 7) + second_list->length;
#line 1826
  second_i = list_find_first_start(second_list, 0, first___0.end + 1);
#line 1827
  result_list = new_region_list(sgrep___0);
  }
  {
#line 1830
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1830
    if (first___0.start != -1) {
#line 1830
      if (! (second_i < second_size)) {
#line 1830
        goto while_break___1;
      }
    } else {
#line 1830
      goto while_break___1;
    }
    {
#line 1832
    tmp___5 = check_region_at((RegionList const   *)second_list, second_i);
    }
#line 1832
    if (((*(second_list->start_sorted_array + (tmp___5 >> 7)))->list[second_i & ((1 << 7) - 1)].start - 1) - first___0.end <= how_near) {
      {
#line 1835
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1835
        tmp___3 = check_region_at((RegionList const   *)second_list, second_i);
#line 1835
        check_add_region((RegionList const   *)result_list, first___0.start, (*(second_list->start_sorted_array + (tmp___3 >> 7)))->list[second_i & ((1 << 7) - 1)].end);
        }
        {
#line 1835
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1835
          if (result_list->length == 1 << 7) {
            {
#line 1835
            insert_list_node(result_list);
            }
          }
          {
#line 1835
          (result_list->last)->list[result_list->length].start = first___0.start;
#line 1835
          tmp___4 = check_region_at((RegionList const   *)second_list, second_i);
#line 1835
          (result_list->last)->list[result_list->length].end = (*(second_list->start_sorted_array + (tmp___4 >> 7)))->list[second_i & ((1 << 7) - 1)].end;
#line 1835
          (result_list->length) ++;
          }
#line 1835
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1835
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 1840
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1840
      check_get_region((ListIterator const   *)(& first_i), (Region const   *)(& first___0));
      }
      {
#line 1840
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1840
        if ((unsigned long )first_i.node == (unsigned long )((void *)0)) {
#line 1840
          goto _L___0;
        } else
#line 1840
        if ((unsigned long )(first_i.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 1840
          if (first_i.ind == (int )(first_i.list)->length) {
#line 1840
            first___0.start = -1;
#line 1840
            first___0.end = -1;
#line 1840
            goto while_break___5;
          }
#line 1840
          if ((unsigned long )(first_i.list)->last == (unsigned long )((void *)0)) {
#line 1840
            first___0.start = first_i.ind;
#line 1840
            first___0.end = first_i.ind + (int )(first_i.list)->chars;
#line 1840
            (first_i.ind) ++;
#line 1840
            goto while_break___5;
          }
        }
#line 1840
        if (first_i.ind == 1 << 7) {
#line 1840
          first_i.node = (first_i.node)->next;
#line 1840
          first_i.ind = 0;
        }
#line 1840
        tmp___6 = first_i.ind;
#line 1840
        (first_i.ind) ++;
#line 1840
        first___0 = (first_i.node)->list[tmp___6];
#line 1840
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1840
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1841
    if (first___0.start != -1) {
      {
#line 1842
      second_i = list_find_first_start(second_list, second_i, first___0.end + 1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1848
  if ((unsigned long )first_list != (unsigned long )l) {
    {
#line 1849
    delete_region_list(first_list);
    }
  }
#line 1851
  if ((unsigned long )second_list != (unsigned long )r) {
    {
#line 1852
    delete_region_list(second_list);
    }
  }
#line 1855
  return (result_list);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 512 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
FileList *new_flist(SgrepData *sgrep___0 ) ;
#line 513
int flist_add(FileList *ifs , char const   *name ) ;
#line 514
int flist_add_relative(FileList *list , int relative_to , char const   *name ) ;
#line 515
int flist_exists(FileList *list , char const   *name ) ;
#line 516
void flist_add_known(FileList *ifs , char const   *name , int length ) ;
#line 517
FileList *flist_duplicate(FileList *list ) ;
#line 518
void flist_cat(FileList *to , FileList *from ) ;
#line 519
void delete_flist(FileList *list ) ;
#line 520
void flist_ready(FileList *ifs ) ;
#line 521
char const   *flist_name(FileList const   *list , int n ) ;
#line 522
int flist_length(FileList const   *list , int n ) ;
#line 525
int flist_files(FileList const   *list ) ;
#line 526
int flist_search(FileList const   *output_files , int s ) ;
#line 527
int flist_add_one_file_list_file(FileList *ifs , char const   *filename ) ;
#line 528
int flist_add_file_list_files(FileList *ifs , FileList *file_lists ) ;
#line 529
int flist_last_errno(FileList const   *list ) ;
#line 535
char *get_arg(SgrepData *sgrep___0 , char ***argv , int *i___0 , int *j ) ;
#line 537
FileList *check_files(SgrepData *sgrep___0 , int argc , char **argv , int num_file_list_files___0 ,
                      char **file_list_files___0 ) ;
#line 544
SgrepString *expand_backslashes(SgrepData *sgrep___0 , char const   *s ) ;
#line 545
int expand_backslash_escape(SgrepData *sgrep___0 , unsigned char const   *list , int *i___0 ) ;
#line 554
int ( /* format attribute */  sgrep_progress)(SgrepData *sgrep___0 , char *format 
                                              , ...) ;
#line 564
ParseTreeNode *parse_string(SgrepData *sgrep___0 , char const   *str , struct PHRASE_NODE **phrase_list ) ;
#line 574
ParseTreeNode *parse_and_optimize(SgrepData *sgrep___0 , char const   *query , struct PHRASE_NODE **phrases ) ;
#line 649
SgrepString *init_string(SgrepData *sgrep___0 , size_t size , char const   *src ) ;
#line 650
void push_front(SgrepString *s , char const   *str ) ;
#line 654
void real_string_push(SgrepString *s , SgrepChar ch ) ;
#line 656
void string_tolower(SgrepString *s , int from ) ;
#line 657
void string_toupper(SgrepString *s , int from ) ;
#line 662
char const   *string_escaped(SgrepString *str ) ;
#line 663
void string_cat_escaped(SgrepString *escaped , char const   *str ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ListNode *get_start_sorted_list(RegionList *s ) ;
#line 20
ListNode *get_end_sorted_list(RegionList *s ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ParseTreeNode *parse_and_optimize(SgrepData *sgrep___0 , char const   *query , struct PHRASE_NODE **phrases ) 
{ 
  ParseTreeNode *root ;
  ParseTreeNode *concat___0 ;
  void *tmp ;

  {
  {
#line 33
  root = parse_string(sgrep___0, query, phrases);
  }
#line 34
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 36
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 42
  optimize_tree(sgrep___0, & root, phrases);
  }
#line 44
  if (sgrep___0->do_concat) {
    {
#line 48
    tmp = sgrep_debug_malloc(sgrep___0, sizeof(ParseTreeNode ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                             48);
#line 48
    concat___0 = (ParseTreeNode *)tmp;
#line 49
    concat___0->oper = (enum Oper )22;
#line 50
    concat___0->left = root;
#line 51
    concat___0->right = (struct ParseTreeNodeStruct *)((void *)0);
#line 52
    concat___0->leaf = (ParseTreeLeaf *)((void *)0);
#line 53
    concat___0->parent = (struct ParseTreeNodeStruct *)((void *)0);
#line 54
    concat___0->refcount = 1;
#line 55
    concat___0->result = (RegionList *)((void *)0);
#line 56
    root = concat___0;
    }
  }
#line 58
  return (root);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
SgrepString *new_string(SgrepData *sgrep___0 , size_t size ) 
{ 
  SgrepString *s ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 70
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(SgrepString ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                           70);
#line 70
  s = (SgrepString *)tmp;
#line 71
  s->sgrep = sgrep___0;
#line 72
  tmp___0 = sgrep_debug_malloc(sgrep___0, size + 1UL, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                               72);
#line 72
  s->s = (char *)tmp___0;
#line 73
  s->size = size;
#line 74
  s->length = (size_t )0;
#line 75
  *(s->s + 0) = (char)0;
#line 76
  s->escaped = (struct SgrepStringStruct *)((void *)0);
  }
#line 77
  return (s);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void delete_string(SgrepString *s ) 
{ 
  SgrepData *sgrep___0 ;

  {
  {
#line 81
  sgrep___0 = s->sgrep;
#line 82
  sgrep_debug_free(sgrep___0, (void *)s->s);
  }
#line 83
  if (s->escaped) {
    {
#line 84
    delete_string(s->escaped);
    }
  }
  {
#line 86
  sgrep_debug_free(sgrep___0, (void *)s);
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
SgrepString *init_string(SgrepData *sgrep___0 , size_t size , char const   *src ) 
{ 
  SgrepString *s ;

  {
  {
#line 93
  s = new_string(sgrep___0, size);
#line 94
  memcpy((void */* __restrict  */)s->s, (void const   */* __restrict  */)src, size);
#line 95
  *(s->s + size) = (char)0;
#line 96
  s->length = size;
  }
#line 97
  return (s);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void string_cat_escaped(SgrepString *escaped , char const   *str ) 
{ 
  int i___0 ;
  int c ;
  int ch ;
  char buf[40] ;
  int x ;
  char buf___0[30] ;

  {
#line 104
  i___0 = 0;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! *(str + i___0)) {
#line 104
      goto while_break;
    }
#line 105
    c = (int )((unsigned char )*(str + i___0));
    {
#line 107
    if (c == 10) {
#line 107
      goto case_10;
    }
#line 110
    if (c == 13) {
#line 110
      goto case_13;
    }
#line 113
    if (c == 8) {
#line 113
      goto case_8;
    }
#line 116
    if (c == 34) {
#line 116
      goto case_34;
    }
#line 119
    if (c == 255) {
#line 119
      goto case_255;
    }
#line 141
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 108
    string_cat(escaped, "\\n");
    }
#line 109
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 111
    string_cat(escaped, "\\r");
    }
#line 112
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 114
    string_cat(escaped, "\\b");
    }
#line 115
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 117
    string_cat(escaped, "\\\"");
    }
#line 118
    goto switch_break;
    case_255: /* CIL Label */ 
#line 121
    ch = 0;
#line 123
    x = 0;
#line 124
    i___0 ++;
#line 125
    c = (int )((unsigned char )*(str + i___0));
    {
#line 126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 126
      if (c) {
#line 126
        if (! (c != 32)) {
#line 126
          goto while_break___0;
        }
      } else {
#line 126
        goto while_break___0;
      }
#line 127
      ch |= (c - 33) << x;
#line 128
      x += 6;
#line 129
      i___0 ++;
#line 130
      c = (int )((unsigned char )*(str + i___0));
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    if (c == 0) {
      {
#line 133
      sgrep_error(escaped->sgrep, (char *)"Could not decode internal encoded character!\n");
      }
    } else {
      {
#line 136
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\\#x%x;",
              ch);
#line 137
      string_cat(escaped, (char const   *)(buf));
      }
    }
#line 139
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 142
    if (c < 32) {
      {
#line 144
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"\\#x%x;",
              c);
#line 145
      string_cat(escaped, (char const   *)(buf___0));
      }
    } else {
      {
#line 147
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 147
        if (escaped->length < escaped->size) {
#line 147
          if (c < 255) {
#line 147
            *(escaped->s + escaped->length) = (char )c;
#line 147
            (escaped->length) ++;
          } else {
            {
#line 147
            real_string_push(escaped, c);
            }
          }
        } else {
          {
#line 147
          real_string_push(escaped, c);
          }
        }
#line 147
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 149
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 104
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
char const   *string_escaped(SgrepString *str ) 
{ 


  {
#line 155
  if (! str->escaped) {
    {
#line 156
    str->escaped = new_string(str->sgrep, str->length + 8UL);
    }
  } else {
#line 158
    (str->escaped)->length = (size_t )0;
  }
  {
#line 160
  *(str->s + str->length) = (char)0;
#line 160
  string_cat_escaped(str->escaped, (char const   *)str->s);
#line 161
  *((str->escaped)->s + (str->escaped)->length) = (char)0;
  }
#line 161
  return ((char const   *)(str->escaped)->s);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void push_front(SgrepString *s , char const   *str ) 
{ 
  char *tmp ;
  int l ;
  SgrepData *sgrep___0 ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 167
  sgrep___0 = s->sgrep;
#line 169
  tmp___0 = strlen(str);
#line 169
  l = (int )tmp___0;
#line 170
  tmp___1 = sgrep_debug_malloc(sgrep___0, (s->length + (size_t )l) + 1UL, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                               170);
#line 170
  tmp = (char *)tmp___1;
#line 171
  memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)str, (size_t )l);
#line 172
  memcpy((void */* __restrict  */)(tmp + l), (void const   */* __restrict  */)s->s,
         s->length);
#line 173
  sgrep_debug_free(sgrep___0, (void *)s->s);
#line 174
  s->s = tmp;
#line 175
  s->length += (size_t )l;
#line 176
  *(s->s + s->length) = (char)0;
#line 177
  s->size = s->length + 1UL;
  }
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void string_cat(SgrepString *s , char const   *str ) 
{ 
  int l ;
  SgrepData *sgrep___0 ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 182
  sgrep___0 = s->sgrep;
#line 184
  tmp = strlen(str);
#line 184
  l = (int )tmp;
  }
#line 185
  if ((s->length + (size_t )l) + 1UL >= s->size) {
    {
#line 186
    s->size = (s->length + (size_t )l) + 1UL;
#line 187
    tmp___0 = sgrep_debug_realloc(sgrep___0, (void *)s->s, s->size);
#line 187
    s->s = (char *)tmp___0;
    }
  }
  {
#line 189
  memcpy((void */* __restrict  */)(s->s + s->length), (void const   */* __restrict  */)str,
         (size_t )l);
#line 190
  s->length += (size_t )l;
#line 191
  *(s->s + s->length) = (char)0;
  }
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void real_string_push(SgrepString *s , SgrepChar ch ) 
{ 
  SgrepData *sgrep___0 ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 195
  sgrep___0 = s->sgrep;
#line 197
  if (s->length + 1UL >= s->size) {
#line 198
    if (s->size < 16UL) {
#line 198
      s->size = (size_t )32;
    } else {
#line 198
      s->size += s->size / 2UL;
    }
    {
#line 199
    tmp = sgrep_debug_realloc(sgrep___0, (void *)s->s, s->size);
#line 199
    s->s = (char *)tmp;
    }
  }
#line 201
  if (ch > 254) {
#line 202
    tmp___0 = s->length;
#line 202
    (s->length) ++;
#line 202
    *((unsigned char *)s->s + tmp___0) = (unsigned char)255;
    {
#line 203
    while (1) {
      while_continue: /* CIL Label */ ;
#line 203
      if (! (ch > 0)) {
#line 203
        goto while_break;
      }
      {
#line 204
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 204
        if (s->length < s->size) {
#line 204
          if (ch % 64 + 33 < 255) {
#line 204
            *(s->s + s->length) = (char )(ch % 64 + 33);
#line 204
            (s->length) ++;
          } else {
            {
#line 204
            real_string_push(s, ch % 64 + 33);
            }
          }
        } else {
          {
#line 204
          real_string_push(s, ch % 64 + 33);
          }
        }
#line 204
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 205
      ch /= 64;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 207
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 207
      if (s->length < s->size) {
#line 207
        *(s->s + s->length) = (char)32;
#line 207
        (s->length) ++;
      } else {
        {
#line 207
        real_string_push(s, 32);
        }
      }
#line 207
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 209
    tmp___1 = s->length;
#line 209
    (s->length) ++;
#line 209
    *(s->s + tmp___1) = (char )ch;
  }
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void string_tolower(SgrepString *s , int from ) 
{ 
  unsigned int i___0 ;
  int tmp ;

  {
#line 214
  i___0 = (unsigned int )from;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((size_t )i___0 < s->length)) {
#line 215
      goto while_break;
    }
#line 216
    if ((int )((unsigned char )*(s->s + i___0)) == 255) {
#line 218
      i___0 ++;
      {
#line 219
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 219
        if ((size_t )i___0 < s->length) {
#line 219
          if (! ((int )*(s->s + i___0) != 32)) {
#line 219
            goto while_break___0;
          }
        } else {
#line 219
          goto while_break___0;
        }
#line 219
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 221
      tmp = tolower((int )*(s->s + i___0));
#line 221
      *(s->s + i___0) = (char )tmp;
      }
    }
#line 223
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void string_toupper(SgrepString *s , int from ) 
{ 
  unsigned int i___0 ;
  int tmp ;

  {
#line 228
  i___0 = (unsigned int )from;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! ((size_t )i___0 < s->length)) {
#line 229
      goto while_break;
    }
#line 230
    if ((int )((unsigned char )*(s->s + i___0)) == 255) {
#line 232
      i___0 ++;
      {
#line 233
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 233
        if ((size_t )i___0 < s->length) {
#line 233
          if (! ((int )*(s->s + i___0) != 32)) {
#line 233
            goto while_break___0;
          }
        } else {
#line 233
          goto while_break___0;
        }
#line 233
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 235
      tmp = toupper((int )*(s->s + i___0));
#line 235
      *(s->s + i___0) = (char )tmp;
      }
    }
#line 237
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int ( /* format attribute */  sgrep_error)(SgrepData *sgrep___0 , char *format  , ...) 
{ 
  char tmpstr[2048] ;
  int l ;
  va_list ap ;

  {
#line 246
  if (! sgrep___0) {
#line 246
    return (0);
  }
  {
#line 247
  __builtin_va_start(ap, format);
#line 249
  l = vsnprintf((char */* __restrict  */)(tmpstr), sizeof(tmpstr), (char const   */* __restrict  */)format,
                ap);
#line 253
  __builtin_va_end(ap);
  }
#line 254
  if (sgrep___0->error_stream) {
    {
#line 255
    fputs((char const   */* __restrict  */)(tmpstr), (FILE */* __restrict  */)sgrep___0->error_stream);
    }
  } else
#line 257
  if (sgrep___0->error) {
    {
#line 258
    string_cat(sgrep___0->error, (char const   *)(tmpstr));
    }
  } else {
    {
#line 260
    sgrep___0->error = init_string(sgrep___0, (size_t )l, (char const   *)(tmpstr));
    }
  }
#line 263
  return (l);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int ( /* format attribute */  sgrep_progress)(SgrepData *sgrep___0 , char *format 
                                              , ...) 
{ 
  va_list ap ;
  int l ;

  {
#line 268
  l = 0;
#line 270
  if (! sgrep___0) {
#line 270
    return (0);
  }
  {
#line 271
  __builtin_va_start(ap, format);
  }
#line 272
  if (sgrep___0->progress_output) {
    {
#line 273
    l = vfprintf((FILE */* __restrict  */)sgrep___0->progress_stream, (char const   */* __restrict  */)format,
                 ap);
#line 274
    fflush(sgrep___0->progress_stream);
    }
  }
  {
#line 276
  __builtin_va_end(ap);
  }
#line 277
  return (l);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_last_errno(FileList const   *list ) 
{ 


  {
#line 301
  return ((int )list->last_errno);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
FileList *new_flist(SgrepData *sgrep___0 ) 
{ 
  FileList *ifs ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 310
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(FileList ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                           310);
#line 310
  ifs = (FileList *)tmp;
#line 311
  ifs->progress_limit = 100;
#line 312
  ifs->sgrep = sgrep___0;
#line 313
  ifs->allocated = 256;
#line 314
  tmp___0 = sgrep_debug_malloc(sgrep___0, sizeof(OneFile ) * (unsigned long )ifs->allocated,
                               "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                               315);
#line 314
  ifs->files = (OneFile *)tmp___0;
#line 316
  ifs->num_files = 0;
#line 317
  ifs->total_size = 0;
#line 318
  ifs->last_errno = 0;
  }
#line 319
  return (ifs);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void flist_add_known(FileList *ifs , char const   *name , int length ) 
{ 
  SgrepData *sgrep___0 ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 327
  sgrep___0 = ifs->sgrep;
#line 328
  if (ifs->num_files >= ifs->allocated) {
    {
#line 329
    tmp = sgrep_debug_realloc(sgrep___0, (void *)ifs->files, (sizeof(OneFile ) * (unsigned long )ifs->allocated) * 2UL);
#line 329
    ifs->files = (OneFile *)tmp;
#line 331
    ifs->allocated *= 2;
    }
  }
#line 333
  (ifs->files + ifs->num_files)->start = ifs->total_size;
#line 334
  (ifs->files + ifs->num_files)->length = length;
#line 335
  if (name) {
    {
#line 335
    tmp___0 = sgrep_debug_strdup(sgrep___0, name, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                                 335);
#line 335
    (ifs->files + ifs->num_files)->name = tmp___0;
    }
  } else {
#line 335
    (ifs->files + ifs->num_files)->name = (char *)((void *)0);
  }
#line 336
  ifs->total_size += length;
#line 337
  (ifs->num_files) ++;
#line 338
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
FileList *flist_duplicate(FileList *list ) 
{ 
  FileList *copy ;
  FileList *tmp ;

  {
  {
#line 341
  tmp = new_flist(list->sgrep);
#line 341
  copy = tmp;
#line 342
  flist_cat(copy, list);
  }
#line 343
  return (copy);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void flist_cat(FileList *to , FileList *from ) 
{ 
  int i___0 ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 348
  i___0 = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 348
    tmp___1 = flist_files((FileList const   *)from);
    }
#line 348
    if (! (i___0 < tmp___1)) {
#line 348
      goto while_break;
    }
    {
#line 349
    tmp = flist_length((FileList const   *)from, i___0);
#line 349
    tmp___0 = flist_name((FileList const   *)from, i___0);
#line 349
    flist_add_known(to, tmp___0, tmp);
#line 348
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_exists(FileList *list , char const   *name ) 
{ 
  int i___0 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 355
  i___0 = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 355
    tmp___1 = flist_files((FileList const   *)list);
    }
#line 355
    if (! (i___0 < tmp___1)) {
#line 355
      goto while_break;
    }
    {
#line 356
    tmp = flist_name((FileList const   *)list, i___0);
#line 356
    tmp___0 = strcmp(name, tmp);
    }
#line 356
    if (tmp___0 == 0) {
#line 356
      return (1);
    }
#line 355
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_add(FileList *ifs , char const   *name ) 
{ 
  FILE *fd ;
  int ls ;
  SgrepData *sgrep___0 ;
  TempFile *temp ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;

  {
#line 367
  fd = (FILE *)((void *)0);
#line 368
  ls = 0;
#line 369
  sgrep___0 = ifs->sgrep;
#line 370
  temp = (TempFile *)((void *)0);
#line 373
  if (ifs->progress_limit) {
    {
#line 374
    tmp___0 = flist_files((FileList const   *)ifs);
    }
#line 374
    if (tmp___0 + 1 == ifs->progress_limit) {
      {
#line 375
      sgrep_progress(sgrep___0, (char *)"Checking files.");
      }
    } else {
      {
#line 376
      tmp = flist_files((FileList const   *)ifs);
      }
#line 376
      if ((tmp + 1) % ifs->progress_limit == 0) {
        {
#line 377
        sgrep_progress(sgrep___0, (char *)".");
        }
      }
    }
  }
  {
#line 381
  tmp___3 = strcmp(name, "-");
  }
#line 381
  if (tmp___3 == 0) {
    {
#line 385
    temp = temp_file_read_stdin(sgrep___0);
    }
#line 386
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 386
      return (-1);
    }
    {
#line 387
    fd = temp_file_stream(temp);
    }
  } else {
    {
#line 389
    fd = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
    }
#line 390
    if (! fd) {
      {
#line 391
      tmp___1 = __errno_location();
#line 391
      tmp___2 = strerror(*tmp___1);
#line 391
      sgrep_error(sgrep___0, (char *)"open \'%s\': %s\n", name, tmp___2);
      }
#line 392
      return (-1);
    }
  }
  {
#line 397
  tmp___7 = fseek(fd, 0L, 2);
  }
#line 397
  if (tmp___7 < 0) {
#line 397
    goto _L;
  } else {
    {
#line 397
    tmp___8 = ftell(fd);
#line 397
    ls = (int )tmp___8;
    }
#line 397
    if (ls < 0) {
#line 397
      goto _L;
    } else {
      {
#line 397
      tmp___9 = fgetc(fd);
      }
#line 397
      if (tmp___9) {
#line 397
        goto _L___0;
      } else {
        _L___0: /* CIL Label */ 
        {
#line 397
        tmp___10 = ferror(fd);
        }
#line 397
        if (tmp___10) {
          _L: /* CIL Label */ 
          {
#line 403
          tmp___4 = __errno_location();
#line 403
          tmp___5 = strerror(*tmp___4);
#line 403
          sgrep_error(sgrep___0, (char *)"File \'%s\': %s\n", name, tmp___5);
#line 404
          tmp___6 = __errno_location();
#line 404
          ifs->last_errno = *tmp___6;
          }
#line 405
          if (fd) {
#line 405
            if (! temp) {
              {
#line 405
              fclose(fd);
              }
            }
          }
#line 406
          return (-1);
        }
      }
    }
  }
#line 408
  if (fd) {
#line 408
    if (! temp) {
      {
#line 408
      fclose(fd);
      }
    }
  }
#line 409
  if (ls == 0) {
    {
#line 410
    sgrep_error(sgrep___0, (char *)"Ignoring zero sized file \'%s\'\n", name);
    }
#line 411
    return (-1);
  }
#line 417
  if (temp) {
    {
#line 418
    tmp___11 = temp_file_name(temp);
#line 418
    flist_add_known(ifs, tmp___11, ls);
    }
  } else {
    {
#line 420
    flist_add_known(ifs, name, ls);
    }
  }
#line 422
  return (0);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_path_is_absolute(FileList *list , char const   *name ) 
{ 


  {
#line 427
  return ((int const   )*(name + 0) == 47);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
SgrepString *flist_get_path(FileList *list , char const   *name ) 
{ 
  SgrepData *sgrep___0 ;
  int len ;
  int i___0 ;
  size_t tmp ;
  SgrepString *tmp___0 ;
  SgrepString *tmp___1 ;

  {
  {
#line 438
  sgrep___0 = list->sgrep;
#line 442
  tmp = strlen(name);
#line 442
  len = (int )tmp;
#line 443
  i___0 = len - 1;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (i___0 >= 0)) {
#line 443
      goto while_break;
    }
#line 444
    if ((int const   )*(name + i___0) == 47) {
      {
#line 445
      tmp___0 = init_string(sgrep___0, (size_t )(i___0 + 1), name);
      }
#line 445
      return (tmp___0);
    }
#line 443
    i___0 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  tmp___1 = new_string(sgrep___0, (size_t )30);
  }
#line 448
  return (tmp___1);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_add_relative(FileList *list , int relative_to , char const   *name ) 
{ 
  SgrepString *path ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 468
  if (relative_to >= 0) {
    {
#line 468
    tmp = flist_files((FileList const   *)list);
    }
#line 468
    if (! (relative_to < tmp)) {
      {
#line 468
      __assert_fail("relative_to>=0 && relative_to<flist_files(list)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    468U, "flist_add_relative");
      }
    }
  } else {
    {
#line 468
    __assert_fail("relative_to>=0 && relative_to<flist_files(list)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  468U, "flist_add_relative");
    }
  }
  {
#line 469
  tmp___1 = flist_path_is_absolute(list, name);
  }
#line 469
  if (tmp___1) {
    {
#line 470
    tmp___0 = flist_add(list, name);
    }
#line 470
    return (tmp___0);
  }
  {
#line 472
  tmp___2 = flist_name((FileList const   *)list, relative_to);
#line 472
  path = flist_get_path(list, tmp___2);
#line 473
  string_cat(path, name);
#line 474
  r = flist_add(list, (char const   *)path->s);
#line 475
  delete_string(path);
  }
#line 476
  return (r);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void delete_flist(FileList *list ) 
{ 
  int i___0 ;
  SgrepData *sgrep___0 ;
  int tmp ;

  {
#line 481
  sgrep___0 = list->sgrep;
#line 483
  i___0 = 0;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 483
    tmp = flist_files((FileList const   *)list);
    }
#line 483
    if (! (i___0 < tmp)) {
#line 483
      goto while_break;
    }
#line 484
    if ((unsigned long )(list->files + i___0)->name != (unsigned long )((void *)0)) {
      {
#line 485
      sgrep_debug_free(sgrep___0, (void *)(list->files + i___0)->name);
#line 486
      (list->files + i___0)->name = (char *)((void *)0);
      }
    }
#line 483
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  sgrep_debug_free(sgrep___0, (void *)list->files);
#line 490
  list->files = (OneFile *)((void *)0);
#line 491
  sgrep_debug_free(sgrep___0, (void *)list);
  }
#line 492
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void flist_ready(FileList *ifs ) 
{ 
  SgrepData *sgrep___0 ;
  void *tmp ;

  {
#line 495
  sgrep___0 = ifs->sgrep;
#line 497
  if (ifs->num_files == 0) {
#line 498
    ifs->allocated = 1;
  } else {
#line 500
    ifs->allocated = ifs->num_files;
  }
  {
#line 502
  tmp = sgrep_debug_realloc(sgrep___0, (void *)ifs->files, (unsigned long )ifs->allocated * sizeof(OneFile ));
#line 502
  ifs->files = (OneFile *)tmp;
  }
#line 503
  if (ifs->progress_limit) {
#line 503
    if (ifs->num_files >= ifs->progress_limit) {
      {
#line 504
      sgrep_progress(sgrep___0, (char *)" done.\n");
      }
    }
  }
#line 506
  ifs->progress_limit = 0;
#line 507
  return;
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
char const   *flist_name(FileList const   *list , int n ) 
{ 


  {
#line 510
  if (n < 0) {
#line 510
    return ((char const   *)((void *)0));
  } else
#line 510
  if (n >= (int )list->num_files) {
#line 510
    return ((char const   *)((void *)0));
  }
#line 511
  return ((char const   *)(list->files + n)->name);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_length(FileList const   *list , int n ) 
{ 


  {
#line 515
  if (n < 0) {
#line 515
    return (-1);
  } else
#line 515
  if (n >= (int )list->num_files) {
#line 515
    return (-1);
  }
#line 516
  return ((list->files + n)->length);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_start(FileList const   *list , int n ) 
{ 


  {
#line 519
  if (n < 0) {
#line 519
    return (-1);
  } else
#line 519
  if (n >= (int )list->num_files) {
#line 519
    return (-1);
  }
#line 520
  return ((list->files + n)->start);
}
}
#line 523 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_total(FileList const   *list ) 
{ 


  {
#line 524
  return ((int )list->total_size);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_files(FileList const   *list ) 
{ 


  {
#line 527
  return ((int )list->num_files);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_search(FileList const   *output_files , int s ) 
{ 
  int bs ;
  int be ;
  int bm ;
  int rounds ;
  int tmp ;

  {
#line 539
  rounds = 0;
#line 540
  if (output_files) {
#line 540
    if (! (output_files->num_files > 0)) {
      {
#line 540
      __assert_fail("output_files && output_files->num_files>0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    540U, "flist_search");
      }
    }
  } else {
    {
#line 540
    __assert_fail("output_files && output_files->num_files>0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  540U, "flist_search");
    }
  }
  {
#line 541
  tmp = flist_total(output_files);
  }
#line 541
  if (s > tmp - 1) {
#line 541
    return (-1);
  }
#line 542
  if (output_files->num_files == 1) {
#line 542
    return (0);
  }
#line 544
  bs = 0;
#line 544
  be = (int )output_files->num_files;
#line 545
  bm = (bs + be) / 2;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! ((output_files->files + bm)->start > s)) {
#line 546
      if (! ((output_files->files + bm)->start + (output_files->files + bm)->length <= s)) {
#line 546
        goto while_break;
      }
    }
#line 549
    if ((output_files->files + bm)->start > s) {
#line 549
      be = bm;
    } else {
#line 550
      bs = bm + 1;
    }
#line 551
    bm = (bs + be) / 2;
#line 553
    rounds ++;
#line 553
    if (! (rounds < 1000)) {
      {
#line 553
      __assert_fail("++rounds<1000", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    553U, "flist_search");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (bm);
}
}
#line 558 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_add_one_file_list_file(FileList *ifs , char const   *filename ) 
{ 
  FILE *file_list_stream ;
  char name_buf[1024] ;
  int c ;
  SgrepData *sgrep___0 ;
  int line ;
  int *tmp ;
  char *tmp___0 ;
  size_t i___0 ;
  size_t tmp___1 ;

  {
  {
#line 562
  sgrep___0 = ifs->sgrep;
#line 565
  file_list_stream = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 566
  if ((unsigned long )file_list_stream == (unsigned long )((void *)0)) {
    {
#line 567
    tmp = __errno_location();
#line 567
    tmp___0 = strerror(*tmp);
#line 567
    sgrep_error(sgrep___0, (char *)"open \'%s\':%s\n", filename, tmp___0);
    }
#line 569
    return (-1);
  }
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    i___0 = (size_t )0;
#line 575
    line = 1;
    {
#line 577
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 577
      c = _IO_getc(file_list_stream);
      }
#line 577
      if (c != 10) {
#line 577
        if (c != -1) {
#line 577
          if (! (i___0 < sizeof(name_buf) - 1UL)) {
#line 577
            goto while_break___0;
          }
        } else {
#line 577
          goto while_break___0;
        }
      } else {
#line 577
        goto while_break___0;
      }
#line 579
      tmp___1 = i___0;
#line 579
      i___0 ++;
#line 579
      name_buf[tmp___1] = (char )c;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 581
    if (i___0 == sizeof(name_buf) - 1UL) {
      {
#line 582
      sgrep_error(sgrep___0, (char *)"File name too long in %s:%d\n", filename, line);
      }
      {
#line 584
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 584
        if (c != 10) {
#line 584
          if (! (c != -1)) {
#line 584
            goto while_break___1;
          }
        } else {
#line 584
          goto while_break___1;
        }
        {
#line 584
        c = _IO_getc(file_list_stream);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 586
    if (i___0 > 0UL) {
      {
#line 587
      name_buf[i___0] = (char)0;
#line 588
      flist_add(ifs, (char const   *)(name_buf));
      }
    }
#line 590
    line ++;
#line 573
    if (! (c != -1)) {
#line 573
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 593
  fclose(file_list_stream);
#line 594
  file_list_stream = (FILE *)((void *)0);
  }
#line 595
  return (0);
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int flist_add_file_list_files(FileList *ifs , FileList *file_lists ) 
{ 
  int i___0 ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 600
  i___0 = 0;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 600
    tmp___0 = flist_files((FileList const   *)file_lists);
    }
#line 600
    if (! (i___0 < tmp___0)) {
#line 600
      goto while_break;
    }
    {
#line 601
    tmp = flist_name((FileList const   *)file_lists, i___0);
#line 601
    flist_add_one_file_list_file(ifs, tmp);
#line 600
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return (0);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
FileList *check_files(SgrepData *sgrep___0 , int argc , char **argv , int num_file_list_files___0 ,
                      char **file_list_files___0 ) 
{ 
  FileList *ifs ;
  int fnum ;
  int anum ;
  char *tmparg[2] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 613
  tmparg[0] = (char *)"-";
#line 613
  tmparg[1] = (char *)((void *)0);
#line 615
  ifs = new_flist(sgrep___0);
  }
#line 617
  if (argc == 0) {
#line 617
    if (num_file_list_files___0 == 0) {
#line 619
      argc = 1;
#line 620
      argv = tmparg;
    }
  }
#line 624
  fnum = 0;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (fnum < num_file_list_files___0)) {
#line 624
      goto while_break;
    }
    {
#line 625
    flist_add_one_file_list_file(ifs, (char const   *)*(file_list_files___0 + fnum));
#line 624
    fnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  anum = 0;
  {
#line 629
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 629
    if (! (anum < argc)) {
#line 629
      goto while_break___0;
    }
    {
#line 631
    flist_add(ifs, (char const   *)*(argv + anum));
#line 629
    anum ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 650
  flist_ready(ifs);
#line 651
  tmp = flist_files((FileList const   *)ifs);
  }
#line 651
  if (tmp >= ifs->progress_limit) {
    {
#line 652
    sgrep_progress(sgrep___0, (char *)" done.\n");
    }
  }
  {
#line 654
  ifs->progress_limit = 0;
#line 659
  tmp___0 = flist_total((FileList const   *)ifs);
#line 659
  sgrep___0->statistics.input_size += tmp___0;
  }
#line 660
  return (ifs);
}
}
#line 667 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ListNode *new_list_node(SgrepData *sgrep___0 ) 
{ 
  ListNode *n ;
  void *tmp ;

  {
  {
#line 670
  (sgrep___0->statistics.gc_nodes) ++;
#line 671
  (sgrep___0->statistics.gc_nodes_allocated) ++;
#line 672
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(ListNode ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                           672);
#line 672
  n = (ListNode *)tmp;
#line 673
  n->prev = (struct ListNodeStruct *)((void *)0);
#line 674
  n->next = (struct ListNodeStruct *)((void *)0);
  }
#line 675
  return (n);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void insert_list_node(RegionList *l ) 
{ 
  ListNode *new_node ;

  {
#line 683
  if (! (l->length == 1 << 7)) {
    {
#line 683
    __assert_fail("l->length==( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  683U, "insert_list_node");
    }
  }
  {
#line 684
  new_node = new_list_node(l->sgrep);
#line 685
  (l->last)->next = new_node;
#line 686
  new_node->prev = l->last;
#line 687
  l->last = new_node;
#line 688
  l->length = 0;
#line 689
  (l->nodes) ++;
  }
#line 690
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void init_region_list(RegionList *l ) 
{ 


  {
  {
#line 700
  l->first = new_list_node(l->sgrep);
#line 701
  l->last = l->first;
#line 702
  (l->last)->next = (struct ListNodeStruct *)((void *)0);
#line 703
  (l->last)->prev = (struct ListNodeStruct *)((void *)0);
#line 704
  l->length = 0;
#line 705
  l->nodes = 1;
#line 706
  l->chars = 0;
#line 707
  l->complete = 0;
#line 708
  l->end_sorted = (ListNode *)((void *)0);
#line 709
  l->nested = 0;
#line 710
  l->sorted = (enum RegionListSorted )1;
#line 711
  l->start_sorted_array = (ListNode **)((void *)0);
  }
#line 712
  return;
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
RegionList *new_region_list(SgrepData *sgrep___0 ) 
{ 
  RegionList *l ;
  void *tmp ;

  {
  {
#line 723
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(RegionList ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                           723);
#line 723
  l = (RegionList *)tmp;
#line 724
  l->sgrep = sgrep___0;
#line 725
  init_region_list(l);
#line 726
  (sgrep___0->statistics.region_lists) ++;
#line 727
  (sgrep___0->statistics.region_lists_now) ++;
  }
#line 728
  return (l);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ListNode *copy_list_nodes(SgrepData *sgrep___0 , ListNode const   *n , ListNode **return_last ) 
{ 
  ListNode *first___0 ;
  ListNode *last___0 ;

  {
  {
#line 737
  first___0 = (ListNode *)((void *)0);
#line 738
  last___0 = (ListNode *)((void *)0);
#line 740
  last___0 = new_list_node(sgrep___0);
#line 741
  memcpy((void */* __restrict  */)last___0, (void const   */* __restrict  */)n, sizeof(ListNode ));
#line 742
  first___0 = last___0;
#line 743
  first___0->prev = (struct ListNodeStruct *)((void *)0);
#line 744
  n = (ListNode const   *)n->next;
  }
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! n) {
#line 745
      goto while_break;
    }
    {
#line 746
    last___0->next = new_list_node(sgrep___0);
#line 747
    memcpy((void */* __restrict  */)last___0->next, (void const   */* __restrict  */)n,
           sizeof(ListNode ));
#line 748
    (last___0->next)->prev = last___0;
#line 749
    last___0 = last___0->next;
#line 750
    n = (ListNode const   *)n->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  last___0->next = (struct ListNodeStruct *)((void *)0);
#line 753
  if (return_last) {
#line 754
    *return_last = last___0;
  }
#line 756
  return (first___0);
}
}
#line 765 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void to_chars(RegionList *c , int chars , int end ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 767
  sgrep___0 = c->sgrep;
#line 768
  if (c->length == 0) {
#line 768
    if (! ((unsigned long )c->last == (unsigned long )c->first)) {
      {
#line 768
      __assert_fail("c->length==0 && c->last==c->first", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    768U, "to_chars");
      }
    }
  } else {
    {
#line 768
    __assert_fail("c->length==0 && c->last==c->first", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  768U, "to_chars");
    }
  }
#line 770
  c->chars = chars - 1;
#line 771
  if ((unsigned long )c->first != (unsigned long )((void *)0)) {
    {
#line 773
    sgrep_debug_free(sgrep___0, (void *)c->first);
#line 774
    c->first = (ListNode *)((void *)0);
#line 775
    c->last = (ListNode *)((void *)0);
    }
  }
#line 777
  if (end == 0) {
#line 777
    end = (c->length + chars) - 2;
  }
#line 778
  c->length = (end - chars) + 2;
#line 779
  if (c->length <= 0) {
    {
#line 783
    init_region_list(c);
    }
  }
#line 785
  return;
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void check_add_region(RegionList const   *l , int s , int e ) 
{ 


  {
#line 794
  if (l) {
#line 794
    if (! ((unsigned long )l->first != (unsigned long )((void *)0))) {
      {
#line 794
      __assert_fail("l && l->first!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    794U, "check_add_region");
      }
    }
  } else {
    {
#line 794
    __assert_fail("l && l->first!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  794U, "check_add_region");
    }
  }
#line 795
  if (! (! l->complete)) {
    {
#line 795
    __assert_fail("!l->complete", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  795U, "check_add_region");
    }
  }
#line 796
  if (! (s <= e)) {
    {
#line 796
    __assert_fail("s<=e", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  796U, "check_add_region");
    }
  }
#line 797
  if (! ((unsigned long )(l->last)->next == (unsigned long )((void *)0))) {
    {
#line 797
    __assert_fail("l->last->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  797U, "check_add_region");
    }
  }
#line 798
  if (! (l->length >= 0)) {
#line 798
    if (! (l->length <= (int const   )(1 << 7))) {
      {
#line 798
      __assert_fail("l->length>=0 || l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    798U, "check_add_region");
      }
    }
  }
#line 801
  if (! (l->length == 0)) {
#line 801
    if (! ((unsigned int const   )l->sorted != 1U)) {
#line 801
      if (! ((l->last)->list[l->length - 1].start < s)) {
#line 801
        if ((l->last)->list[l->length - 1].start == s) {
#line 801
          if (! ((l->last)->list[l->length - 1].end < e)) {
            {
#line 801
            __assert_fail("l->length==0 || l->sorted!=START_SORTED || ((l)->last->list[(l)->length-1]).start<s || (((l)->last->list[(l)->length-1]).start==s && ((l)->last->list[(l)->length-1]).end<e)",
                          "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                          804U, "check_add_region");
            }
          }
        } else {
          {
#line 801
          __assert_fail("l->length==0 || l->sorted!=START_SORTED || ((l)->last->list[(l)->length-1]).start<s || (((l)->last->list[(l)->length-1]).start==s && ((l)->last->list[(l)->length-1]).end<e)",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                        804U, "check_add_region");
          }
        }
      }
    }
  }
#line 808
  if (! l->nested) {
#line 808
    if (! (l->length == 0)) {
#line 808
      if (! ((unsigned int const   )l->sorted != 1U)) {
#line 808
        if (! (e > (l->last)->list[l->length - 1].end)) {
          {
#line 808
          __assert_fail("l->nested || l->length==0 || l->sorted!=START_SORTED || e>((l)->last->list[(l)->length-1]).end",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                        809U, "check_add_region");
          }
        }
      }
    }
  }
#line 810
  return;
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void start_region_search(RegionList *l , ListIterator *handle ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 818
  sgrep___0 = l->sgrep;
#line 819
  if (! ((unsigned long )l->last == (unsigned long )((void *)0))) {
#line 819
    if (! ((unsigned long )(l->last)->next == (unsigned long )((void *)0))) {
      {
#line 819
      __assert_fail("l->last==((void *)0) || l->last->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    819U, "start_region_search");
      }
    }
  }
#line 820
  if ((unsigned long )l->last != (unsigned long )((void *)0)) {
#line 820
    if (! (l->length <= 1 << 7)) {
      {
#line 820
      __assert_fail("l->last!=((void *)0) && l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    820U, "start_region_search");
      }
    }
  } else {
    {
#line 820
    __assert_fail("l->last!=((void *)0) && l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  820U, "start_region_search");
    }
  }
#line 821
  if (! (l->length >= 0)) {
    {
#line 821
    __assert_fail("l->length>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  821U, "start_region_search");
    }
  }
#line 823
  l->complete = 1;
#line 824
  if ((unsigned int )l->sorted != 1U) {
    {
#line 825
    get_start_sorted_list(l);
    }
  }
#line 827
  handle->list = (struct RegionListStruct  const  *)l;
#line 828
  handle->ind = 0;
#line 829
  handle->node = l->first;
#line 830
  (sgrep___0->statistics.scans) ++;
#line 831
  return;
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void start_region_search_from(RegionList *l , int index___0 , ListIterator *handle ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 840
  sgrep___0 = l->sgrep;
#line 841
  if (! ((unsigned long )l->last == (unsigned long )((void *)0))) {
#line 841
    if (! ((unsigned long )(l->last)->next == (unsigned long )((void *)0))) {
      {
#line 841
      __assert_fail("l->last==((void *)0) || l->last->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    841U, "start_region_search_from");
      }
    }
  }
#line 842
  if ((unsigned long )l->last != (unsigned long )((void *)0)) {
#line 842
    if (! (l->length <= 1 << 7)) {
      {
#line 842
      __assert_fail("l->last!=((void *)0) && l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    842U, "start_region_search_from");
      }
    }
  } else {
    {
#line 842
    __assert_fail("l->last!=((void *)0) && l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  842U, "start_region_search_from");
    }
  }
#line 843
  if (! (l->length >= 0)) {
    {
#line 843
    __assert_fail("l->length>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  843U, "start_region_search_from");
    }
  }
#line 845
  l->complete = 1;
#line 846
  if ((unsigned int )l->sorted != 1U) {
    {
#line 847
    get_start_sorted_list(l);
    }
  }
#line 849
  handle->list = (struct RegionListStruct  const  *)l;
#line 850
  handle->ind = 0;
#line 851
  handle->node = l->first;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (index___0 >= 1 << 7) {
#line 852
      if (! (handle->node)->next) {
#line 852
        goto while_break;
      }
    } else {
#line 852
      goto while_break;
    }
#line 853
    handle->node = (handle->node)->next;
#line 854
    index___0 -= 1 << 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 856
  if (index___0 < l->length) {
#line 856
    handle->ind = index___0;
  } else {
#line 856
    handle->ind = l->length;
  }
#line 857
  (sgrep___0->statistics.scans) ++;
#line 858
  return;
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void start_end_sorted_search(RegionList *l , ListIterator *handle ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 861
  sgrep___0 = l->sgrep;
#line 862
  if (! ((unsigned long )l->last == (unsigned long )((void *)0))) {
#line 862
    if (! ((unsigned long )(l->last)->next == (unsigned long )((void *)0))) {
      {
#line 862
      __assert_fail("l->last==((void *)0) || l->last->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    862U, "start_end_sorted_search");
      }
    }
  }
#line 863
  if ((unsigned long )l->last != (unsigned long )((void *)0)) {
#line 863
    if (! (l->length <= 1 << 7)) {
      {
#line 863
      __assert_fail("l->last!=((void *)0) && l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    863U, "start_end_sorted_search");
      }
    }
  } else {
    {
#line 863
    __assert_fail("l->last!=((void *)0) && l->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  863U, "start_end_sorted_search");
    }
  }
#line 864
  if (! (l->length >= 0)) {
    {
#line 864
    __assert_fail("l->length>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  864U, "start_end_sorted_search");
    }
  }
#line 866
  l->complete = 1;
#line 867
  if ((unsigned int )l->sorted == 1U) {
#line 867
    if (! l->nested) {
      {
#line 868
      start_region_search(l, handle);
      }
#line 869
      return;
    }
  }
  {
#line 871
  handle->list = (struct RegionListStruct  const  *)l;
#line 872
  handle->ind = 0;
#line 873
  handle->node = get_end_sorted_list(l);
#line 874
  (sgrep___0->statistics.scans) ++;
  }
#line 875
  return;
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void list_set_sorted(RegionList *l , enum RegionListSorted sorted ) 
{ 


  {
#line 878
  if (! (! l->complete)) {
    {
#line 878
    __assert_fail("!l->complete", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  878U, "list_set_sorted");
    }
  }
#line 879
  l->sorted = sorted;
#line 880
  return;
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
enum RegionListSorted list_get_sorted(RegionList const   *l ) 
{ 


  {
#line 883
  return ((enum RegionListSorted )l->sorted);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void check_get_region(ListIterator const   *handle , Region const   *reg ) 
{ 


  {
#line 910
  if ((unsigned long )(handle->list)->last != (unsigned long )((void *)0)) {
#line 912
    if (! ((unsigned long )((handle->list)->last)->next == (unsigned long )((void *)0))) {
      {
#line 912
      __assert_fail("handle->list->last->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    912U, "check_get_region");
      }
    }
#line 913
    if (! ((handle->list)->length <= (int const   )(1 << 7))) {
      {
#line 913
      __assert_fail("handle->list->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    913U, "check_get_region");
      }
    }
#line 914
    if (! ((unsigned long )handle->node != (unsigned long )((void *)0))) {
      {
#line 914
      __assert_fail("handle->node!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    914U, "check_get_region");
      }
    }
#line 915
    if (! (handle->ind <= (int const   )(1 << 7))) {
      {
#line 915
      __assert_fail("handle->ind<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    915U, "check_get_region");
      }
    }
  }
#line 917
  return;
}
}
#line 924 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int check_region_at(RegionList const   *l , int ind ) 
{ 


  {
#line 925
  if (! l) {
    {
#line 925
    __assert_fail("l", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  925U, "check_region_at");
    }
  }
#line 926
  if (! (! l->chars)) {
    {
#line 926
    __assert_fail("!l->chars", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  926U, "check_region_at");
    }
  }
#line 927
  if (ind >= 0) {
#line 927
    if (! (ind < (int )((l->nodes - 1) * (int const   )(1 << 7) + l->length))) {
      {
#line 927
      __assert_fail("ind>=0 && ind<(((l)->nodes-1)*( 1 << 7 )+(l)->length)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    927U, "check_region_at");
      }
    }
  } else {
    {
#line 927
    __assert_fail("ind>=0 && ind<(((l)->nodes-1)*( 1 << 7 )+(l)->length)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  927U, "check_region_at");
    }
  }
#line 928
  if (l->start_sorted_array) {
#line 928
    if (! *(l->start_sorted_array + ind / (1 << 7))) {
      {
#line 928
      __assert_fail("l->start_sorted_array && l->start_sorted_array[ind/( 1 << 7 )]",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    928U, "check_region_at");
      }
    }
  } else {
    {
#line 928
    __assert_fail("l->start_sorted_array && l->start_sorted_array[ind/( 1 << 7 )]",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  928U, "check_region_at");
    }
  }
#line 929
  return (ind);
}
}
#line 941 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void check_prev_region(ListIterator const   *handle , Region const   *reg ) 
{ 


  {
#line 943
  if ((unsigned long )(handle->list)->last != (unsigned long )((void *)0)) {
#line 945
    if (! ((unsigned long )((handle->list)->last)->next == (unsigned long )((void *)0))) {
      {
#line 945
      __assert_fail("handle->list->last->next==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    945U, "check_prev_region");
      }
    }
#line 946
    if (! ((handle->list)->length <= (int const   )(1 << 7))) {
      {
#line 946
      __assert_fail("handle->list->length<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    946U, "check_prev_region");
      }
    }
#line 947
    if (! ((unsigned long )handle->node != (unsigned long )((void *)0))) {
      {
#line 947
      __assert_fail("handle->node!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    947U, "check_prev_region");
      }
    }
#line 948
    if (! (handle->ind <= (int const   )(1 << 7))) {
      {
#line 948
      __assert_fail("handle->ind<=( 1 << 7 )", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    948U, "check_prev_region");
      }
    }
  }
#line 950
  if (! ((handle->list)->length >= 0)) {
    {
#line 950
    __assert_fail("handle->list->length>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  950U, "check_prev_region");
    }
  }
#line 951
  if (! (handle->ind >= 0)) {
    {
#line 951
    __assert_fail("handle->ind>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  951U, "check_prev_region");
    }
  }
#line 952
  return;
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void delete_region_list(RegionList *l ) 
{ 
  SgrepData *sgrep___0 ;
  ListNode *next ;
  ListNode *next___0 ;

  {
#line 961
  sgrep___0 = l->sgrep;
#line 969
  if (l->start_sorted_array) {
    {
#line 970
    sgrep_debug_free(sgrep___0, (void *)l->start_sorted_array);
    }
  }
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! ((unsigned long )l->first != (unsigned long )((void *)0))) {
#line 972
      goto while_break;
    }
    {
#line 973
    next = (l->first)->next;
#line 974
    sgrep_debug_free(sgrep___0, (void *)l->first);
#line 975
    l->first = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 977
  if ((unsigned long )l->end_sorted != (unsigned long )l->first) {
    {
#line 977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 977
      if (! l->end_sorted) {
#line 977
        goto while_break___0;
      }
      {
#line 978
      next___0 = (l->end_sorted)->next;
#line 979
      sgrep_debug_free(sgrep___0, (void *)l->end_sorted);
#line 980
      l->end_sorted = next___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 982
  sgrep_debug_free(sgrep___0, (void *)l);
#line 983
  (sgrep___0->statistics.region_lists_now) --;
  }
#line 988
  return;
}
}
#line 994 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ListNode **create_node_array(RegionList const   *s , ListNode *n ) 
{ 
  int i___0 ;
  ListNode **inds ;
  SgrepData *sgrep___0 ;
  void *tmp ;

  {
  {
#line 998
  sgrep___0 = (SgrepData *)s->sgrep;
#line 1004
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(ListNode *) * (unsigned long )s->nodes,
                           "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                           1004);
#line 1004
  inds = (ListNode **)tmp;
#line 1005
  *(inds + 0) = n;
#line 1006
  i___0 = 1;
  }
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (! (i___0 < (int )s->nodes)) {
#line 1006
      goto while_break;
    }
#line 1007
    *(inds + i___0) = (*(inds + (i___0 - 1)))->next;
#line 1006
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1011
  return (inds);
}
}
#line 1014 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void list_require_start_sorted_array(RegionList *l ) 
{ 


  {
#line 1015
  l->complete = 1;
#line 1016
  if (! (! l->chars)) {
    {
#line 1016
    __assert_fail("!l->chars", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  1016U, "list_require_start_sorted_array");
    }
  }
#line 1017
  if (l->start_sorted_array) {
#line 1017
    return;
  }
#line 1018
  if ((unsigned int )l->sorted != 1U) {
    {
#line 1019
    get_start_sorted_list(l);
    }
  }
#line 1021
  if ((unsigned int )l->sorted == 1U) {
#line 1021
    if (! l->first) {
      {
#line 1021
      __assert_fail("l->sorted==START_SORTED && l->first", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    1021U, "list_require_start_sorted_array");
      }
    }
  } else {
    {
#line 1021
    __assert_fail("l->sorted==START_SORTED && l->first", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  1021U, "list_require_start_sorted_array");
    }
  }
  {
#line 1022
  l->start_sorted_array = create_node_array((RegionList const   *)l, l->first);
  }
#line 1023
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void gc_qsort(ListNode **inds , int s , int e , enum SortTypes st ) 
{ 
  Region creg ;
  Region sreg ;
  int i___0 ;
  int m ;
  int last___0 ;
  int r ;
  int tmp ;
  int tmp___0 ;

  {
#line 1038
  if (s >= e) {
#line 1038
    return;
  }
#line 1040
  m = (s + e) / 2;
#line 1041
  creg = (*(inds + (m >> 7)))->list[m & ((1 << 7) - 1)];
#line 1042
  (*(inds + (m >> 7)))->list[m & ((1 << 7) - 1)] = (*(inds + (s >> 7)))->list[s & ((1 << 7) - 1)];
#line 1043
  (*(inds + (s >> 7)))->list[s & ((1 << 7) - 1)] = creg;
#line 1045
  last___0 = s;
#line 1046
  i___0 = s + 1;
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! (i___0 <= e)) {
#line 1046
      goto while_break;
    }
#line 1048
    if ((unsigned int )st == 0U) {
#line 1049
      if ((*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)].start < creg.start) {
#line 1049
        tmp = 1;
      } else
#line 1049
      if ((*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)].start == creg.start) {
#line 1049
        if ((*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)].end < creg.end) {
#line 1049
          tmp = 1;
        } else {
#line 1049
          tmp = 0;
        }
      } else {
#line 1049
        tmp = 0;
      }
#line 1049
      r = tmp;
    } else {
#line 1053
      if ((*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)].end < creg.end) {
#line 1053
        tmp___0 = 1;
      } else
#line 1053
      if ((*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)].end == creg.end) {
#line 1053
        if ((*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)].start < creg.start) {
#line 1053
          tmp___0 = 1;
        } else {
#line 1053
          tmp___0 = 0;
        }
      } else {
#line 1053
        tmp___0 = 0;
      }
#line 1053
      r = tmp___0;
    }
#line 1056
    if (r) {
#line 1058
      last___0 ++;
#line 1059
      sreg = (*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)];
#line 1060
      (*(inds + (i___0 >> 7)))->list[i___0 & ((1 << 7) - 1)] = (*(inds + (last___0 >> 7)))->list[last___0 & ((1 << 7) - 1)];
#line 1061
      (*(inds + (last___0 >> 7)))->list[last___0 & ((1 << 7) - 1)] = sreg;
    }
#line 1046
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1064
  sreg = (*(inds + (s >> 7)))->list[s & ((1 << 7) - 1)];
#line 1065
  (*(inds + (s >> 7)))->list[s & ((1 << 7) - 1)] = (*(inds + (last___0 >> 7)))->list[last___0 & ((1 << 7) - 1)];
#line 1066
  (*(inds + (last___0 >> 7)))->list[last___0 & ((1 << 7) - 1)] = sreg;
#line 1067
  gc_qsort(inds, s, last___0 - 1, st);
#line 1068
  gc_qsort(inds, last___0 + 1, e, st);
  }
#line 1069
  return;
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ListNode *get_end_sorted_list(RegionList *s ) 
{ 
  int size ;
  ListNode **inds ;
  SgrepData *sgrep___0 ;

  {
#line 1076
  sgrep___0 = s->sgrep;
#line 1078
  if (! s) {
    {
#line 1078
    __assert_fail("s", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  1078U, "get_end_sorted_list");
    }
  }
#line 1079
  s->complete = 1;
#line 1080
  if ((unsigned int )s->sorted == 2U) {
#line 1081
    return (s->first);
  }
#line 1083
  if ((unsigned int )s->sorted == 1U) {
#line 1083
    if (! s->nested) {
#line 1085
      return (s->first);
    }
  }
#line 1087
  size = (s->nodes - 1) * (1 << 7) + s->length;
#line 1088
  if (size < 2) {
#line 1090
    return (s->first);
  }
#line 1092
  if (s->end_sorted) {
#line 1094
    return (s->end_sorted);
  }
#line 1097
  if ((unsigned int )s->sorted == 0U) {
#line 1098
    s->sorted = (enum RegionListSorted )2;
#line 1099
    s->end_sorted = s->first;
  } else {
    {
#line 1101
    s->end_sorted = copy_list_nodes(sgrep___0, (ListNode const   *)s->first, (ListNode **)((void *)0));
    }
  }
  {
#line 1104
  inds = create_node_array((RegionList const   *)s, s->end_sorted);
#line 1105
  gc_qsort(inds, 0, size - 1, (enum SortTypes )1);
#line 1106
  sgrep_debug_free(sgrep___0, (void *)inds);
#line 1108
  (sgrep___0->statistics.sorts_by_end) ++;
  }
#line 1109
  return (s->end_sorted);
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
ListNode *get_start_sorted_list(RegionList *s ) 
{ 
  int size ;
  ListNode **inds ;
  SgrepData *sgrep___0 ;

  {
#line 1123
  sgrep___0 = s->sgrep;
#line 1125
  if (! s) {
    {
#line 1125
    __assert_fail("s", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  1125U, "get_start_sorted_list");
    }
  }
#line 1126
  s->complete = 1;
#line 1127
  if ((unsigned int )s->sorted == 1U) {
#line 1128
    return (s->first);
  }
#line 1130
  size = (s->nodes - 1) * (1 << 7) + s->length;
#line 1131
  if (size < 2) {
#line 1133
    s->sorted = (enum RegionListSorted )1;
#line 1134
    return (s->first);
  }
#line 1137
  if ((unsigned int )s->sorted == 2U) {
#line 1138
    if (! ((unsigned long )s->first == (unsigned long )s->end_sorted)) {
      {
#line 1138
      __assert_fail("s->first==s->end_sorted", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                    1138U, "get_start_sorted_list");
      }
    }
    {
#line 1139
    s->first = copy_list_nodes(sgrep___0, (ListNode const   *)s->first, (ListNode **)((void *)0));
    }
  }
  {
#line 1141
  s->sorted = (enum RegionListSorted )1;
#line 1144
  inds = create_node_array((RegionList const   *)s, s->first);
#line 1145
  gc_qsort(inds, 0, size - 1, (enum SortTypes )0);
#line 1146
  sgrep_debug_free(sgrep___0, (void *)inds);
#line 1148
  (sgrep___0->statistics.sorts_by_start) ++;
  }
#line 1149
  return (s->first);
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
void remove_duplicates(RegionList *s ) 
{ 
  ListIterator r ;
  ListIterator s_handle ;
  ListNode *t ;
  Region p1 ;
  Region p2 ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1160
  sgrep___0 = s->sgrep;
#line 1164
  if (! s) {
    {
#line 1164
    __assert_fail("s", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  1164U, "remove_duplicates");
    }
  }
  {
#line 1165
  start_region_search(s, & r);
  }
#line 1166
  if (! ((unsigned int )s->sorted == 1U)) {
    {
#line 1166
    __assert_fail("s->sorted==START_SORTED", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                  1166U, "remove_duplicates");
    }
  }
  {
#line 1167
  (sgrep___0->statistics.remove_duplicates) ++;
#line 1169
  start_region_search(s, & s_handle);
  }
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1170
    check_get_region((ListIterator const   *)(& s_handle), (Region const   *)(& p1));
    }
    {
#line 1170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1170
      if ((unsigned long )s_handle.node == (unsigned long )((void *)0)) {
#line 1170
        goto _L;
      } else
#line 1170
      if ((unsigned long )(s_handle.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 1170
        if (s_handle.ind == (int )(s_handle.list)->length) {
#line 1170
          p1.start = -1;
#line 1170
          p1.end = -1;
#line 1170
          goto while_break___0;
        }
#line 1170
        if ((unsigned long )(s_handle.list)->last == (unsigned long )((void *)0)) {
#line 1170
          p1.start = s_handle.ind;
#line 1170
          p1.end = s_handle.ind + (int )(s_handle.list)->chars;
#line 1170
          (s_handle.ind) ++;
#line 1170
          goto while_break___0;
        }
      }
#line 1170
      if (s_handle.ind == 1 << 7) {
#line 1170
        s_handle.node = (s_handle.node)->next;
#line 1170
        s_handle.ind = 0;
      }
#line 1170
      tmp = s_handle.ind;
#line 1170
      (s_handle.ind) ++;
#line 1170
      p1 = (s_handle.node)->list[tmp];
#line 1170
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1170
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1171
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1171
    if (! (p1.start != -1)) {
#line 1171
      goto while_break___1;
    }
    {
#line 1173
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1173
      check_get_region((ListIterator const   *)(& s_handle), (Region const   *)(& p2));
      }
      {
#line 1173
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1173
        if ((unsigned long )s_handle.node == (unsigned long )((void *)0)) {
#line 1173
          goto _L___0;
        } else
#line 1173
        if ((unsigned long )(s_handle.node)->next == (unsigned long )((void *)0)) {
          _L___0: /* CIL Label */ 
#line 1173
          if (s_handle.ind == (int )(s_handle.list)->length) {
#line 1173
            p2.start = -1;
#line 1173
            p2.end = -1;
#line 1173
            goto while_break___3;
          }
#line 1173
          if ((unsigned long )(s_handle.list)->last == (unsigned long )((void *)0)) {
#line 1173
            p2.start = s_handle.ind;
#line 1173
            p2.end = s_handle.ind + (int )(s_handle.list)->chars;
#line 1173
            (s_handle.ind) ++;
#line 1173
            goto while_break___3;
          }
        }
#line 1173
        if (s_handle.ind == 1 << 7) {
#line 1173
          s_handle.node = (s_handle.node)->next;
#line 1173
          s_handle.ind = 0;
        }
#line 1173
        tmp___0 = s_handle.ind;
#line 1173
        (s_handle.ind) ++;
#line 1173
        p2 = (s_handle.node)->list[tmp___0];
#line 1173
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1173
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1174
    if (p1.start != p2.start) {
#line 1174
      goto _L___1;
    } else
#line 1174
    if (p1.end != p2.end) {
      _L___1: /* CIL Label */ 
#line 1177
      if (r.ind == 1 << 7) {
#line 1179
        r.node = (r.node)->next;
#line 1180
        if (! ((unsigned long )r.node != (unsigned long )((void *)0))) {
          {
#line 1180
          __assert_fail("r.node!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c",
                        1180U, "remove_duplicates");
          }
        }
#line 1181
        r.ind = 0;
      }
#line 1186
      tmp___1 = r.ind;
#line 1186
      (r.ind) ++;
#line 1186
      (r.node)->list[tmp___1] = p1;
#line 1187
      p1 = p2;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1190
  s->length = r.ind;
#line 1191
  s->last = r.node;
#line 1193
  r.node = (r.node)->next;
  {
#line 1194
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1194
    if (! ((unsigned long )r.node != (unsigned long )((void *)0))) {
#line 1194
      goto while_break___4;
    }
    {
#line 1196
    t = r.node;
#line 1197
    r.node = (r.node)->next;
#line 1198
    sgrep_debug_free(sgrep___0, (void *)t);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1200
  (s->last)->next = (struct ListNodeStruct *)((void *)0);
#line 1201
  return;
}
}
#line 1206 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
char *get_arg(SgrepData *sgrep___0 , char ***argv , int *i___0 , int *j ) 
{ 
  char *r ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 1210
  if ((int )*(*(*argv) + (*j + 1)) == 0) {
#line 1212
    if ((unsigned long )*(*argv + 1) == (unsigned long )((void *)0)) {
      {
#line 1214
      sgrep_error(sgrep___0, (char *)"Option -%c requires an argument\n", (int )*(*(*argv) + *j));
      }
#line 1216
      return ((char *)((void *)0));
    }
    {
#line 1218
    (*argv) ++;
#line 1218
    r = *(*argv);
#line 1219
    (*i___0) ++;
#line 1220
    tmp = strlen((char const   *)r);
#line 1220
    *j = (int )(tmp - 1UL);
    }
  } else {
    {
#line 1223
    r = *(*argv) + (*j + 1);
#line 1224
    tmp___0 = strlen((char const   *)*(*argv));
#line 1224
    *j = (int )(tmp___0 - 1UL);
    }
  }
#line 1229
  return (r);
}
}
#line 1235 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
int expand_backslash_escape(SgrepData *sgrep___0 , unsigned char const   *list , int *i___0 ) 
{ 
  int reference ;
  int ch ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1237
  reference = -1;
#line 1240
  if ((int const   )*(list + *i___0) == 0) {
    {
#line 1241
    sgrep_error(sgrep___0, (char *)"Backslash at end of string\n");
    }
#line 1242
    return (-1);
  }
#line 1245
  ch = (int )*(list + *i___0);
#line 1246
  (*i___0) ++;
  {
#line 1248
  if (ch == 116) {
#line 1248
    goto case_116;
  }
#line 1249
  if (ch == 110) {
#line 1249
    goto case_110;
  }
#line 1250
  if (ch == 114) {
#line 1250
    goto case_114;
  }
#line 1251
  if (ch == 102) {
#line 1251
    goto case_102;
  }
#line 1252
  if (ch == 98) {
#line 1252
    goto case_98;
  }
#line 1253
  if (ch == 92) {
#line 1253
    goto case_92;
  }
#line 1254
  if (ch == 34) {
#line 1254
    goto case_34;
  }
#line 1255
  if (ch == 10) {
#line 1255
    goto case_10;
  }
#line 1256
  if (ch == 35) {
#line 1256
    goto case_35;
  }
#line 1257
  goto switch_default;
  case_116: /* CIL Label */ 
#line 1248
  return ('\t');
  case_110: /* CIL Label */ 
#line 1249
  return ('\n');
  case_114: /* CIL Label */ 
#line 1250
  return ('\r');
  case_102: /* CIL Label */ 
#line 1251
  return ('\f');
  case_98: /* CIL Label */ 
#line 1252
  return ('\b');
  case_92: /* CIL Label */ 
#line 1253
  return ('\\');
  case_34: /* CIL Label */ 
#line 1254
  ch = '\"';
#line 1254
  return (ch);
  case_10: /* CIL Label */ 
#line 1255
  return ('\n');
  case_35: /* CIL Label */ 
#line 1256
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1258
  tmp = __ctype_b_loc();
  }
#line 1258
  if ((int const   )*(*tmp + ch) & 16384) {
    {
#line 1259
    sgrep_error(sgrep___0, (char *)"Unknown backslash escape \'%c\'\n", ch);
    }
  } else {
    {
#line 1261
    sgrep_error(sgrep___0, (char *)"Unknown blackslash escape #%d\n", ch);
    }
  }
#line 1263
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 1266
  if ((int const   )*(list + *i___0) == 0) {
    {
#line 1267
    sgrep_error(sgrep___0, (char *)"Character reference at end of string\n");
    }
#line 1268
    return (-1);
  }
#line 1271
  if ((int const   )*(list + *i___0) == 120) {
#line 1273
    reference = 0;
#line 1274
    (*i___0) ++;
    {
#line 1275
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1275
      if ((int const   )*(list + *i___0) >= 48) {
#line 1275
        if (! ((int const   )*(list + *i___0) <= 57)) {
#line 1275
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1275
        tmp___1 = toupper((int )*(list + *i___0));
        }
#line 1275
        if (tmp___1 >= 65) {
          {
#line 1275
          tmp___2 = toupper((int )*(list + *i___0));
          }
#line 1275
          if (! (tmp___2 <= 70)) {
#line 1275
            goto while_break;
          }
        } else {
#line 1275
          goto while_break;
        }
      }
#line 1277
      if ((int const   )*(list + *i___0) >= 48) {
#line 1277
        if ((int const   )*(list + *i___0) <= 57) {
#line 1278
          reference = (reference * 16 + (int )*(list + *i___0)) - 48;
        } else {
          {
#line 1280
          tmp___0 = toupper((int )*(list + *i___0));
#line 1280
          reference = ((reference * 16 + tmp___0) - 65) + 10;
          }
        }
      } else {
        {
#line 1280
        tmp___0 = toupper((int )*(list + *i___0));
#line 1280
        reference = ((reference * 16 + tmp___0) - 65) + 10;
        }
      }
#line 1282
      (*i___0) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1285
    if ((int const   )*(list + *i___0) == 59) {
#line 1285
      (*i___0) ++;
    }
  } else
#line 1286
  if ((int const   )*(list + *i___0) >= 48) {
#line 1286
    if ((int const   )*(list + *i___0) <= 57) {
#line 1288
      reference = (int )((int const   )*(list + *i___0) - 48);
#line 1289
      (*i___0) ++;
      {
#line 1290
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1290
        if ((int const   )*(list + *i___0) >= 48) {
#line 1290
          if (! ((int const   )*(list + *i___0) <= 57)) {
#line 1290
            goto while_break___0;
          }
        } else {
#line 1290
          goto while_break___0;
        }
#line 1291
        reference = reference * 10 + (int )((int const   )*(list + *i___0) - 48);
#line 1292
        (*i___0) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1295
      if ((int const   )*(list + *i___0) == 59) {
#line 1295
        (*i___0) ++;
      }
    } else {
#line 1286
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1296
  if ((int const   )*(list + *i___0) < 32) {
    {
#line 1297
    sgrep_error(sgrep___0, (char *)"Invalid character #%d in character list character reference\n",
                (int const   )*(list + *i___0));
    }
#line 1299
    return (-1);
  } else {
    {
#line 1301
    sgrep_error(sgrep___0, (char *)"Invalid character \'%c\' in character list character reference\n",
                (int const   )*(list + *i___0));
    }
#line 1303
    return (-1);
  }
#line 1306
  if (reference >= 65534) {
    {
#line 1307
    sgrep_error(sgrep___0, (char *)"Character #%d in character list is not an unicode character\n",
                reference);
#line 1309
    reference = -1;
    }
  } else
#line 1306
  if (reference == 0) {
    {
#line 1307
    sgrep_error(sgrep___0, (char *)"Character #%d in character list is not an unicode character\n",
                reference);
#line 1309
    reference = -1;
    }
  }
#line 1312
  return (reference);
}
}
#line 1318 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/common.c"
SgrepString *expand_backslashes(SgrepData *sgrep___0 , char const   *s ) 
{ 
  int i___0 ;
  SgrepString *r ;
  unsigned char const   *str ;
  size_t tmp ;
  int ch ;

  {
  {
#line 1319
  i___0 = 0;
#line 1321
  str = (unsigned char const   *)s;
#line 1323
  tmp = strlen(s);
#line 1323
  r = new_string(sgrep___0, tmp);
  }
  {
#line 1324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1324
    if (! *(str + i___0)) {
#line 1324
      goto while_break;
    }
#line 1325
    if ((int const   )*(str + i___0) == 92) {
      {
#line 1327
      i___0 ++;
#line 1328
      ch = expand_backslash_escape(sgrep___0, str, & i___0);
      }
#line 1329
      if (ch >= 0) {
        {
#line 1329
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1329
          if (r->length < r->size) {
#line 1329
            if (ch < 255) {
#line 1329
              *(r->s + r->length) = (char )ch;
#line 1329
              (r->length) ++;
            } else {
              {
#line 1329
              real_string_push(r, ch);
              }
            }
          } else {
            {
#line 1329
            real_string_push(r, ch);
            }
          }
#line 1329
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 1331
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1331
        if (r->length < r->size) {
#line 1331
          if ((int const   )*(str + i___0) < 255) {
#line 1331
            *(r->s + r->length) = (char )*(str + i___0);
#line 1331
            (r->length) ++;
          } else {
            {
#line 1331
            real_string_push(r, (SgrepChar )*(str + i___0));
            }
          }
        } else {
          {
#line 1331
          real_string_push(r, (SgrepChar )*(str + i___0));
          }
        }
#line 1331
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1332
      i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1335
  return (r);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 586 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
IndexReader *new_index_reader(SgrepData *sgrep___0 , char const   *filename ) ;
#line 587
void delete_index_reader(IndexReader *reader ) ;
#line 589
IndexEntryList *index_term_lookup(IndexReader *reader , char const   *first_prefix ,
                                  char const   *last_prefix ) ;
#line 592
FileList *index_file_list(IndexReader *imap ) ;
#line 593
int index_list_size(IndexEntryList *l ) ;
#line 594
IndexEntry *index_first_entry(IndexEntryList *l ) ;
#line 595
IndexEntry *index_next_entry(IndexEntry *e ) ;
#line 596
char const   *index_entry_term(IndexEntry *e ) ;
#line 597
void delete_index_entry_list(IndexEntryList *l ) ;
#line 615
void set_default_index_options(SgrepData *sgrep___0 , IndexOptions *o ) ;
#line 616
int create_index(IndexOptions const   *options ) ;
#line 617
int add_region_to_index(struct IndexWriterStruct *writer , char const   *str , int start ,
                        int end ) ;
#line 627
int index_search(SgrepData *sgrep___0 , struct IndexWriterStruct *writer , FileList *files ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
static struct __anonstruct_IndexOptions_27  const  default_index_options  = 
#line 58 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
     {(struct SgrepStruct *)((void *)0), (enum IndexModes )0, 0, 0, (char const   *)((void *)0),
    (char const   *)((void *)0), 1000003, 20971520, (FileList *)((void *)0), (FileList *)0,
    (char const   *)0};
#line 235 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
static int put_int(int i___0 , FILE *stream ) 
{ 


  {
  {
#line 236
  _IO_putc(i___0 >> 24, stream);
#line 237
  _IO_putc(i___0 >> 16, stream);
#line 238
  _IO_putc(i___0 >> 8, stream);
#line 239
  _IO_putc(i___0 & 255, stream);
  }
#line 240
  return (4);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
static int get_int(unsigned char const   *ptr , int ind ) 
{ 


  {
#line 244
  ptr += ind * 4;
#line 245
  return ((int )(((((int const   )*(ptr + 0) << 24) | ((int const   )*(ptr + 1) << 16)) | ((int const   )*(ptr + 2) << 8)) | (int const   )*(ptr + 3)));
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
static int fwrite_postings(IndexWriter *writer , IndexBuffer *tmp , FILE *stream ) 
{ 
  int bytes ;
  int esize ;
  struct IndexBlock *ind ;

  {
#line 254
  bytes = 0;
#line 256
  if ((int )tmp->block_used == 0) {
#line 261
    return (0);
  } else
#line 262
  if ((int )tmp->block_used > 0) {
    {
#line 263
    bytes += (int )tmp->block_used;
#line 264
    fwrite((void const   */* __restrict  */)(tmp->list.internal.ibuf), (size_t )tmp->block_used,
           (size_t )1, (FILE */* __restrict  */)stream);
    }
  } else {
#line 267
    ind = writer->spool + tmp->list.external.first;
#line 268
    esize = tmp->list.external.bytes;
#line 269
    bytes = esize;
    {
#line 270
    while (1) {
      while_continue: /* CIL Label */ ;
#line 270
      if (! (ind->next != (-0x7FFFFFFF-1))) {
#line 270
        goto while_break;
      }
      {
#line 271
      esize -= 32;
#line 272
      fwrite((void const   */* __restrict  */)(ind->buf), (size_t )32, (size_t )1,
             (FILE */* __restrict  */)stream);
#line 273
      ind = writer->spool + ind->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 275
    if (! (esize <= 32)) {
      {
#line 275
      __assert_fail("esize<=32", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    275U, "fwrite_postings");
      }
    }
    {
#line 276
    fwrite((void const   */* __restrict  */)(ind->buf), (size_t )esize, (size_t )1,
           (FILE */* __restrict  */)stream);
    }
  }
#line 278
  return (bytes);
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
unsigned int hash_function(int size , char const   *str ) 
{ 
  int i___0 ;
  unsigned int r ;

  {
#line 284
  r = 0U;
#line 286
  i___0 = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! *(str + i___0)) {
#line 286
      goto while_break;
    }
#line 287
    r = (unsigned int )((unsigned char )*(str + i___0)) + 61U * r;
#line 286
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (r % (unsigned int )size);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void display_index_statistics(IndexWriter *writer ) 
{ 
  int i___0 ;
  int size ;
  FILE *f ;

  {
  {
#line 297
  f = (writer->sgrep)->progress_stream;
#line 298
  size = (int )((unsigned long )writer->spool_size * sizeof(struct IndexBlock ));
#line 299
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Indexer memory usage:\n");
#line 300
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%dK bytes postings, %dK postings spool size, %dK used\n",
          writer->total_postings_bytes / 1024, size / 1024, writer->spool_used / 1024);
#line 304
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d individual terms of %d term postings (%d%%)\n",
          writer->terms, writer->postings, (writer->terms * 100) / writer->postings);
#line 307
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Postings lengths:\n");
#line 308
  i___0 = 0;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i___0 < 8)) {
#line 308
      goto while_break;
    }
#line 309
    if (writer->entry_lengths[i___0] > 0) {
      {
#line 310
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%8d:%8d, %8dK (%d%%)\n",
              i___0 + 1, writer->entry_lengths[i___0], ((i___0 + 1) * writer->entry_lengths[i___0]) / 1024,
              (((i___0 + 1) * writer->entry_lengths[i___0]) * 100) / writer->total_postings_bytes);
      }
    }
#line 308
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Hash array size %dK\n",
          ((unsigned long )writer->hash_size * sizeof(IndexBuffer *)) / 1024UL);
#line 318
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Term entries total size %dK\n",
          ((unsigned long )writer->terms * sizeof(IndexBuffer )) / 1024UL);
#line 320
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Strings total size %dK\n",
          writer->total_string_bytes / 1024);
  }
#line 321
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int index_buffer_compare(void const   *first___0 , void const   *next ) 
{ 
  int tmp ;

  {
  {
#line 326
  tmp = strcmp((char const   *)(*((IndexBuffer const   **)first___0))->str, (char const   *)(*((IndexBuffer const   **)next))->str);
  }
#line 326
  return (tmp);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void index_spool_overflow(IndexWriter *writer ) 
{ 
  int i___0 ;
  int j ;
  IndexBuffer *l ;
  IndexBuffer **term_array ;
  int esize ;
  TempFile *temp_file ;
  FILE *load_file ;
  SgrepData *sgrep___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 339
  sgrep___0 = writer->sgrep;
#line 341
  sgrep_progress(sgrep___0, (char *)"Postings spool overflow. Sorting terms..\n");
#line 343
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(IndexBuffer *) * (unsigned long )writer->terms,
                           "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                           343);
#line 343
  term_array = (IndexBuffer **)tmp;
  }
#line 344
  if (writer->htable) {
#line 346
    j = 0;
#line 347
    i___0 = 0;
    {
#line 347
    while (1) {
      while_continue: /* CIL Label */ ;
#line 347
      if (! (i___0 < writer->hash_size)) {
#line 347
        goto while_break;
      }
#line 348
      l = *(writer->htable + i___0);
      {
#line 348
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 348
        if (! l) {
#line 348
          goto while_break___0;
        }
#line 349
        tmp___0 = j;
#line 349
        j ++;
#line 349
        *(term_array + tmp___0) = l;
#line 348
        l = l->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 347
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 352
    qsort((void *)term_array, (size_t )writer->terms, sizeof(IndexBuffer *), & index_buffer_compare);
    }
  } else {
#line 356
    j = 0;
#line 357
    l = writer->sorted_buffers;
    {
#line 357
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 357
      if (! l) {
#line 357
        goto while_break___1;
      }
#line 358
      if (! (j < writer->terms)) {
        {
#line 358
        __assert_fail("j<writer->terms", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                      358U, "index_spool_overflow");
        }
      }
#line 359
      tmp___1 = j;
#line 359
      j ++;
#line 359
      *(term_array + tmp___1) = l;
#line 357
      l = l->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 361
    if (! (j == writer->terms)) {
      {
#line 361
      __assert_fail("j==writer->terms", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    361U, "index_spool_overflow");
      }
    }
  }
  {
#line 363
  temp_file = create_temp_file(sgrep___0);
  }
#line 364
  if (! temp_file) {
    {
#line 365
    sgrep_error(sgrep___0, (char *)"Can\'t write memory load\n");
#line 366
    writer->failed = 1;
#line 367
    writer->spool_used = 0;
#line 368
    sgrep_debug_free(sgrep___0, (void *)term_array);
    }
#line 369
    return;
  }
  {
#line 371
  load_file = temp_file_stream(temp_file);
#line 372
  i___0 = 0;
  }
  {
#line 372
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 372
    if (! (i___0 < writer->terms)) {
#line 372
      goto while_break___2;
    }
#line 373
    if ((i___0 & 1023) == 0) {
      {
#line 374
      sgrep_progress(sgrep___0, (char *)"saving memory load: %d/%d entries (%d%%)\r",
                     i___0, writer->terms, (i___0 * 100) / writer->terms);
      }
    }
#line 377
    if ((int )(*(term_array + i___0))->block_used < 0) {
      {
#line 379
      fputs((char const   */* __restrict  */)(*(term_array + i___0))->str, (FILE */* __restrict  */)load_file);
#line 380
      fputc(0, load_file);
#line 381
      put_int((*(term_array + i___0))->list.external.bytes, load_file);
#line 383
      esize = fwrite_postings(writer, *(term_array + i___0), load_file);
#line 384
      (*(term_array + i___0))->saved_bytes += esize;
      }
#line 385
      if (! (esize == (*(term_array + i___0))->list.external.bytes)) {
        {
#line 385
        __assert_fail("esize==term_array[i]->list.external.bytes", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                      385U, "index_spool_overflow");
        }
      }
#line 387
      (*(term_array + i___0))->block_used = (short)0;
    }
#line 372
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 390
  sgrep_debug_free(sgrep___0, (void *)term_array);
#line 391
  sgrep_progress(sgrep___0, (char *)"\n");
#line 392
  fflush(load_file);
#line 393
  tmp___5 = ferror(load_file);
  }
#line 393
  if (tmp___5) {
    {
#line 394
    tmp___2 = __errno_location();
#line 394
    tmp___3 = strerror(*tmp___2);
#line 394
    sgrep_error(sgrep___0, (char *)"Failed to write memory load: %s\n", tmp___3);
#line 395
    delete_temp_file(temp_file);
#line 396
    writer->failed = 1;
    }
  } else {
#line 398
    tmp___4 = writer->memory_loads;
#line 398
    (writer->memory_loads) ++;
#line 398
    writer->memory_load_files[tmp___4] = temp_file;
  }
#line 400
  writer->spool_used = 0;
#line 401
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void new_block(IndexWriter *writer , IndexBuffer *buf , unsigned char byte ) 
{ 


  {
#line 405
  if (! (writer->spool_used < writer->spool_size)) {
    {
#line 405
    __assert_fail("writer->spool_used<writer->spool_size", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  405U, "new_block");
    }
  }
#line 406
  if (! ((writer->spool + buf->list.external.current)->next == (-0x7FFFFFFF-1))) {
    {
#line 406
    __assert_fail("writer->spool[buf->list.external.current].next==(-2147483647 - 1)",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  406U, "new_block");
    }
  }
#line 408
  (writer->spool + buf->list.external.current)->next = writer->spool_used;
#line 409
  buf->list.external.current = writer->spool_used;
#line 410
  (writer->spool + writer->spool_used)->buf[0] = byte;
#line 411
  (writer->spool + writer->spool_used)->next = (-0x7FFFFFFF-1);
#line 412
  (buf->list.external.bytes) ++;
#line 413
  buf->block_used = (short)-1;
#line 414
  (writer->spool_used) ++;
#line 415
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void add_byte(IndexWriter *writer , IndexBuffer *buf , unsigned char byte ) 
{ 
  int used ;
  short tmp ;

  {
#line 419
  (writer->total_postings_bytes) ++;
#line 420
  if ((int )buf->block_used >= 0) {
#line 422
    if ((int )buf->block_used < 12) {
#line 423
      tmp = buf->block_used;
#line 423
      buf->block_used = (short )((int )buf->block_used + 1);
#line 423
      buf->list.internal.ibuf[tmp] = byte;
#line 424
      return;
    }
#line 427
    if (! (writer->spool_used < writer->spool_size)) {
      {
#line 427
      __assert_fail("writer->spool_used<writer->spool_size", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    427U, "add_byte");
      }
    }
    {
#line 428
    (writer->spool + writer->spool_used)->next = (-0x7FFFFFFF-1);
#line 429
    memcpy((void */* __restrict  */)((writer->spool + writer->spool_used)->buf), (void const   */* __restrict  */)(buf->list.internal.ibuf),
           (size_t )12);
#line 431
    buf->list.external.first = writer->spool_used;
#line 432
    buf->list.external.current = writer->spool_used;
#line 433
    buf->list.external.bytes = (int )buf->block_used;
#line 434
    buf->block_used = (short)-12;
#line 435
    (writer->spool_used) ++;
    }
  }
#line 438
  used = - ((int )buf->block_used);
#line 439
  if (used == 32) {
    {
#line 440
    new_block(writer, buf, byte);
    }
  } else {
#line 442
    (writer->spool + buf->list.external.current)->buf[used] = byte;
#line 443
    buf->block_used = (short )((int )buf->block_used - 1);
#line 444
    (buf->list.external.bytes) ++;
  }
#line 446
  if (! (writer->spool_used <= writer->spool_size)) {
    {
#line 446
    __assert_fail("writer->spool_used<=writer->spool_size", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  446U, "add_byte");
    }
  }
#line 447
  if (writer->spool_used == writer->spool_size) {
    {
#line 447
    index_spool_overflow(writer);
    }
  }
#line 448
  return;
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void add_integer(IndexWriter *writer , IndexBuffer *buf , int num ) 
{ 


  {
#line 459
  if (num < 0) {
    {
#line 461
    add_byte(writer, buf, (unsigned char)255);
#line 463
    num = - num;
    }
  }
#line 465
  if (num < 127) {
    {
#line 468
    add_byte(writer, buf, (unsigned char )num);
#line 469
    (writer->entry_lengths[0]) ++;
    }
  } else
#line 470
  if (num < 1 << 14) {
    {
#line 472
    add_byte(writer, buf, (unsigned char )((num >> 8) | 128));
#line 473
    add_byte(writer, buf, (unsigned char )(num & 255));
#line 474
    (writer->entry_lengths[1]) ++;
    }
  } else
#line 475
  if (num < 1 << 21) {
    {
#line 477
    add_byte(writer, buf, (unsigned char )((num >> 16) | 192));
#line 478
    add_byte(writer, buf, (unsigned char )((num >> 8) & 255));
#line 479
    add_byte(writer, buf, (unsigned char )(num & 255));
#line 480
    (writer->entry_lengths[2]) ++;
    }
  } else
#line 481
  if (num < 1 << 28) {
    {
#line 483
    add_byte(writer, buf, (unsigned char )((num >> 24) | 224));
#line 484
    add_byte(writer, buf, (unsigned char )((num >> 16) & 255));
#line 485
    add_byte(writer, buf, (unsigned char )((num >> 8) & 255));
#line 486
    add_byte(writer, buf, (unsigned char )(num & 255));
#line 487
    (writer->entry_lengths[3]) ++;
    }
  } else
#line 488
  if (num <= 2147483647) {
    {
#line 490
    add_byte(writer, buf, (unsigned char)240);
#line 491
    add_byte(writer, buf, (unsigned char )((num >> 24) & 255));
#line 492
    add_byte(writer, buf, (unsigned char )((num >> 16) & 255));
#line 493
    add_byte(writer, buf, (unsigned char )((num >> 8) & 255));
#line 494
    add_byte(writer, buf, (unsigned char )(num & 255));
    }
  } else {
    {
#line 497
    sgrep_error(writer->sgrep, (char *)"Index value %u is too big!\n", num);
    }
  }
#line 499
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void add_entry(IndexWriter *writer , IndexBuffer *buf , int index___0 ) 
{ 


  {
#line 502
  if (! (index___0 >= 0)) {
    {
#line 502
    __assert_fail("index>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  502U, "add_entry");
    }
  }
  {
#line 503
  index___0 -= buf->last_index;
#line 504
  buf->last_index += index___0;
#line 505
  add_integer(writer, buf, index___0);
  }
#line 506
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
unsigned char get_next_block(IndexWriter *writer , IndexBuffer *buf ) 
{ 


  {
#line 509
  if (! ((int )buf->block_used < 0)) {
    {
#line 509
    __assert_fail("buf->block_used<0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  509U, "get_next_block");
    }
  }
#line 510
  if ((int )buf->block_used == -33) {
#line 512
    buf->list.external.current = buf->list.external.first;
  } else {
#line 515
    if (! (- ((int )buf->block_used) == 32)) {
      {
#line 515
      __assert_fail("-buf->block_used==32", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    515U, "get_next_block");
      }
    }
#line 516
    if (! ((writer->spool + buf->list.external.current)->next > 0)) {
      {
#line 516
      __assert_fail("writer->spool[buf->list.external.current].next>0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    516U, "get_next_block");
      }
    }
#line 517
    buf->list.external.current = (writer->spool + buf->list.external.current)->next;
  }
#line 519
  buf->block_used = (short)-1;
#line 520
  return ((writer->spool + buf->list.external.current)->buf[0]);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
unsigned char get_byte(IndexBuffer *buf ) 
{ 
  int tmp ;

  {
#line 525
  if (! ((int )buf->block_used == -32768)) {
    {
#line 525
    __assert_fail("buf->block_used==(-32767 - 1)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  525U, "get_byte");
    }
  }
#line 526
  tmp = buf->list.map.ind;
#line 526
  (buf->list.map.ind) ++;
#line 526
  return ((unsigned char )*(buf->list.map.buf + tmp));
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int get_integer(IndexBuffer *buf ) 
{ 
  unsigned char i___0 ;
  int r ;
  int negative ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  int tmp___9 ;

  {
  {
#line 544
  negative = 0;
#line 546
  i___0 = get_byte(buf);
  }
#line 547
  if ((int )i___0 == 255) {
    {
#line 548
    negative = 1;
#line 549
    i___0 = get_byte(buf);
    }
  }
#line 551
  if ((int )i___0 == 127) {
#line 553
    return (2147483647);
  } else
#line 555
  if ((int )i___0 < 127) {
#line 555
    r = (int )i___0;
  } else
#line 556
  if (((int )i___0 & 192) == 128) {
    {
#line 558
    tmp = get_byte(buf);
#line 558
    r = (((int )i___0 & 63) << 8) | (int )tmp;
    }
  } else
#line 560
  if (((int )i___0 & 224) == 192) {
    {
#line 562
    tmp___0 = get_byte(buf);
#line 562
    r = (((int )i___0 & 31) << 16) | ((int )tmp___0 << 8);
#line 563
    tmp___1 = get_byte(buf);
#line 563
    r |= (int )tmp___1;
    }
  } else
#line 565
  if (((int )i___0 & 240) == 224) {
    {
#line 567
    tmp___2 = get_byte(buf);
#line 567
    r = (((int )i___0 & 15) << 24) | ((int )tmp___2 << 16);
#line 568
    tmp___3 = get_byte(buf);
#line 568
    r |= (int )tmp___3 << 8;
#line 569
    tmp___4 = get_byte(buf);
#line 569
    r |= (int )tmp___4;
    }
  } else
#line 570
  if ((int )i___0 == 240) {
    {
#line 572
    tmp___5 = get_byte(buf);
#line 572
    r = (int )tmp___5 << 24;
#line 573
    tmp___6 = get_byte(buf);
#line 573
    r |= (int )tmp___6 << 16;
#line 574
    tmp___7 = get_byte(buf);
#line 574
    r |= (int )tmp___7 << 8;
#line 575
    tmp___8 = get_byte(buf);
#line 575
    r |= (int )tmp___8;
    }
  } else {
    {
#line 577
    __assert_fail("0 && \"Corrupted index file\"", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  577U, "get_integer");
#line 578
    abort();
    }
  }
#line 580
  if (negative) {
#line 580
    tmp___9 = - r;
  } else {
#line 580
    tmp___9 = r;
  }
#line 580
  return (tmp___9);
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
unsigned int get_entry(IndexBuffer *buf ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 584
  tmp = get_integer(buf);
#line 584
  r = tmp;
  }
#line 585
  if (r == 2147483647) {
#line 585
    return ((unsigned int )r);
  }
#line 586
  buf->last_index += r;
#line 587
  if (! (buf->last_index >= 0)) {
    {
#line 587
    __assert_fail("buf->last_index>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  587U, "get_entry");
    }
  }
#line 589
  return ((unsigned int )buf->last_index);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
static IndexBuffer *new_writer_index_buffer(IndexWriter *writer ) 
{ 
  struct SgrepStruct *sgrep___0 ;
  struct IndexBufferArray *b ;
  void *tmp ;
  int tmp___0 ;

  {
#line 593
  sgrep___0 = writer->sgrep;
#line 594
  if ((unsigned long )writer->free_index_buffers == (unsigned long )((void *)0)) {
    {
#line 597
    tmp = sgrep_debug_calloc(sgrep___0, (size_t )1, sizeof(struct IndexBufferArray ));
#line 597
    b = (struct IndexBufferArray *)tmp;
#line 599
    b->next = writer->free_index_buffers;
#line 600
    writer->first_free_index_buffer = 0;
#line 601
    writer->free_index_buffers = b;
    }
  } else
#line 594
  if (writer->first_free_index_buffer == 1024) {
    {
#line 597
    tmp = sgrep_debug_calloc(sgrep___0, (size_t )1, sizeof(struct IndexBufferArray ));
#line 597
    b = (struct IndexBufferArray *)tmp;
#line 599
    b->next = writer->free_index_buffers;
#line 600
    writer->first_free_index_buffer = 0;
#line 601
    writer->free_index_buffers = b;
    }
  }
#line 603
  tmp___0 = writer->first_free_index_buffer;
#line 603
  (writer->first_free_index_buffer) ++;
#line 603
  return (& (writer->free_index_buffers)->bufs[tmp___0]);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexBuffer *find_index_buffer(IndexWriter *writer , char const   *str ) 
{ 
  IndexBuffer **n ;
  int h ;
  SgrepData *sgrep___0 ;
  unsigned int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 609
  sgrep___0 = writer->sgrep;
#line 611
  tmp = hash_function(writer->hash_size, str);
#line 611
  h = (int )tmp;
#line 613
  n = writer->htable + h;
  }
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 614
    if (! ((unsigned long )*n != (unsigned long )((void *)0))) {
#line 614
      goto while_break;
    }
    {
#line 616
    tmp___0 = strcmp(str, (char const   *)(*n)->str);
    }
#line 616
    if (tmp___0 != 0) {
#line 618
      n = & (*n)->next;
    } else {
#line 621
      return (*n);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 624
  (writer->terms) ++;
#line 625
  if (writer->terms == writer->hash_size * 2) {
    {
#line 626
    sgrep_error(sgrep___0, (char *)"Warning: There is more than 2*%d (hash table size) unique index terms.\n",
                writer->hash_size);
#line 627
    sgrep_error(sgrep___0, (char *)"Warning: Suggest using larger hash table (-H option).\n");
    }
  }
  {
#line 629
  *n = new_writer_index_buffer(writer);
#line 630
  (*n)->str = sgrep_debug_strdup(sgrep___0, str, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                                 630);
#line 631
  tmp___1 = strlen(str);
#line 631
  (*n)->last_len = (short )(tmp___1 - 1UL);
#line 632
  tmp___2 = strlen(str);
#line 632
  writer->total_string_bytes = (int )((size_t )writer->total_string_bytes + (tmp___2 + 1UL));
  }
#line 633
  return (*n);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int read_stop_word_file(IndexWriter *writer , char const   *filename ) 
{ 
  char entry[256] ;
  int term_len ;
  int ch ;
  FILE *stop_file ;
  IndexBuffer *ib ;
  SgrepData *sgrep___0 ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 643
  sgrep___0 = writer->sgrep;
#line 645
  stop_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 646
  if ((unsigned long )stop_file == (unsigned long )((void *)0)) {
    {
#line 647
    tmp = __errno_location();
#line 647
    tmp___0 = strerror(*tmp);
#line 647
    sgrep_error(sgrep___0, (char *)"Failed to read stop word file \'%s\':%s\n", filename,
                tmp___0);
    }
#line 649
    return (-1);
  }
  {
#line 652
  ch = _IO_getc(stop_file);
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 653
    if (! (ch != -1)) {
#line 653
      goto while_break;
    }
#line 655
    if (ch >= 48) {
#line 655
      if (ch <= 57) {
        {
#line 656
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 656
          if (ch >= 48) {
#line 656
            if (! (ch <= 57)) {
#line 656
              goto while_break___0;
            }
          } else {
#line 656
            goto while_break___0;
          }
          {
#line 656
          ch = _IO_getc(stop_file);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 658
        if (ch == 32) {
          {
#line 658
          ch = _IO_getc(stop_file);
          }
        }
      }
    }
#line 661
    term_len = 0;
    {
#line 661
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 661
      if (term_len < 255) {
#line 661
        if (ch != -1) {
#line 661
          if (! (ch != 10)) {
#line 661
            goto while_break___1;
          }
        } else {
#line 661
          goto while_break___1;
        }
      } else {
#line 661
        goto while_break___1;
      }
      {
#line 663
      tmp___1 = term_len;
#line 663
      term_len ++;
#line 663
      entry[tmp___1] = (char )ch;
#line 661
      ch = _IO_getc(stop_file);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 664
    entry[term_len] = (char)0;
#line 665
    if (term_len > 0) {
      {
#line 667
      ib = find_index_buffer(writer, (char const   *)(entry));
      }
#line 670
      if (! (ib->last_index == 0)) {
#line 670
        if (! (ib->last_index == -1)) {
          {
#line 670
          __assert_fail("ib->last_index==0 || ib->last_index==-1", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                        670U, "read_stop_word_file");
          }
        }
      }
#line 671
      ib->last_index = -1;
    }
#line 674
    if (ch == 10) {
      {
#line 674
      ch = _IO_getc(stop_file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  fclose(stop_file);
  }
#line 678
  return (0);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int add_region_to_index(struct IndexWriterStruct *writer , char const   *str , int start ,
                        int end ) 
{ 
  IndexBuffer *ib ;
  int len ;
  SgrepData *sgrep___0 ;

  {
#line 685
  sgrep___0 = writer->sgrep;
#line 688
  if (end < start) {
    {
#line 689
    sgrep_error(sgrep___0, (char *)"BUG: ignoring zero sized region\n");
    }
#line 690
    return (0);
  }
  {
#line 692
  ib = find_index_buffer(writer, str);
#line 694
  (writer->postings) ++;
  }
#line 697
  if (ib->last_index == -1) {
#line 697
    return (0);
  }
#line 699
  len = (end - start) + 1;
#line 703
  if ((int )ib->last_len == len) {
#line 703
    if (start != 0) {
#line 706
      if (start == ib->last_index) {
        {
#line 709
        add_entry(writer, ib, start);
#line 710
        add_entry(writer, ib, start);
        }
      } else {
        {
#line 712
        add_entry(writer, ib, start);
        }
      }
    } else {
#line 703
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 714
  if (len == - ((int )ib->last_len)) {
    {
#line 717
    ib->last_len = (short )len;
#line 718
    add_entry(writer, ib, start);
#line 719
    add_entry(writer, ib, end);
    }
  } else {
#line 723
    if ((int )ib->last_len > 0) {
      {
#line 725
      add_entry(writer, ib, ib->last_index);
      }
    }
    {
#line 728
    ib->last_len = (short )(- len);
#line 729
    add_entry(writer, ib, start);
#line 730
    add_entry(writer, ib, end);
    }
  }
#line 732
  if (writer->failed) {
#line 733
    return (-1);
  } else {
#line 735
    return (0);
  }
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int get_region_index(IndexBuffer *buf , Region *region ) 
{ 
  int saved_index ;
  int s ;
  int e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 743
  saved_index = buf->last_index;
#line 744
  if (! (saved_index != 2147483647)) {
    {
#line 744
    __assert_fail("saved_index!=2147483647", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  744U, "get_region_index");
    }
  }
  {
#line 745
  tmp = get_entry(buf);
#line 745
  s = (int )tmp;
  }
#line 746
  if (s == 2147483647) {
#line 747
    buf->last_index = 2147483647;
#line 748
    return (0);
  }
#line 751
  if ((int )buf->last_len > 0) {
#line 753
    if (s == saved_index) {
      {
#line 756
      tmp___0 = get_entry(buf);
#line 756
      s = (int )tmp___0;
      }
#line 757
      if (s == saved_index) {
#line 757
        if (s != 0) {
#line 759
          region->start = s;
#line 760
          region->end = (s + (int )buf->last_len) - 1;
#line 761
          return (1);
        }
      }
      {
#line 764
      tmp___1 = get_entry(buf);
#line 764
      e = (int )tmp___1;
      }
#line 765
      if (! (e != 2147483647)) {
        {
#line 765
        __assert_fail("e!=2147483647", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                      765U, "get_region_index");
        }
      }
#line 766
      buf->last_len = (short )(0 - ((e - s) + 1));
#line 767
      region->start = s;
#line 768
      region->end = e;
#line 769
      return (1);
    }
#line 772
    region->start = s;
#line 773
    region->end = (s + (int )buf->last_len) - 1;
#line 774
    return (1);
  }
  {
#line 777
  tmp___2 = get_entry(buf);
#line 777
  e = (int )tmp___2;
  }
#line 778
  if (! (e != 2147483647)) {
    {
#line 778
    __assert_fail("e!=2147483647", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  778U, "get_region_index");
    }
  }
#line 779
  if ((e - s) + 1 == - ((int )buf->last_len)) {
#line 781
    buf->last_len = (short )((e - s) + 1);
  } else {
#line 784
    buf->last_len = (short )(0 - ((e - s) + 1));
  }
#line 786
  region->start = s;
#line 787
  region->end = e;
#line 788
  return (1);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void rewind_index_buffer(IndexBuffer *buf ) 
{ 


  {
#line 792
  if ((int )buf->block_used < 0) {
#line 793
    buf->block_used = (short)-33;
  } else {
#line 795
    buf->block_used = (short)0;
  }
#line 797
  buf->last_index = 0;
#line 798
  return;
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexWriter *new_index_writer(IndexOptions const   *options ) 
{ 
  int i___0 ;
  IndexWriter *writer ;
  SgrepData *sgrep___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 803
  sgrep___0 = (SgrepData *)options->sgrep;
#line 805
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(IndexWriter ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                           805);
#line 805
  writer = (IndexWriter *)tmp;
#line 806
  writer->sgrep = (struct SgrepStruct *)options->sgrep;
#line 807
  writer->options = options;
#line 808
  writer->file_list = (FileList *)((void *)0);
#line 810
  writer->free_index_buffers = (struct IndexBufferArray *)((void *)0);
#line 811
  writer->first_free_index_buffer = 0;
#line 812
  writer->total_postings_bytes = 0;
#line 813
  writer->terms = 0;
#line 814
  writer->postings = 0;
#line 815
  writer->total_string_bytes = 0;
#line 816
  i___0 = 0;
  }
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    if (! (i___0 < 8)) {
#line 816
      goto while_break;
    }
#line 816
    writer->entry_lengths[i___0] = 0;
#line 816
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 818
  tmp___0 = sgrep_debug_malloc(sgrep___0, (unsigned long )options->hash_table_size * sizeof(IndexBuffer *),
                               "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                               819);
#line 818
  writer->htable = (IndexBuffer **)tmp___0;
#line 821
  writer->hash_size = (int )options->hash_table_size;
#line 822
  i___0 = 0;
  }
  {
#line 822
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 822
    if (! (i___0 < writer->hash_size)) {
#line 822
      goto while_break___0;
    }
#line 822
    *(writer->htable + i___0) = (IndexBuffer *)((void *)0);
#line 822
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 823
  writer->spool_size = (int )((unsigned long )options->available_memory / sizeof(struct IndexBlock ));
#line 825
  writer->spool_used = 0;
#line 826
  tmp___1 = sgrep_debug_calloc(sgrep___0, (size_t )1, (unsigned long )writer->spool_size * sizeof(struct IndexBlock ));
#line 826
  writer->spool = (struct IndexBlock *)tmp___1;
  }
#line 827
  if ((unsigned long )writer->spool == (unsigned long )((void *)0)) {
    {
#line 828
    sgrep_error(sgrep___0, (char *)"Could not allocate %dK memory for postings spool\n",
                ((unsigned long )writer->spool_size * sizeof(struct IndexBlock )) / 1024UL);
#line 830
    sgrep_debug_free(sgrep___0, (void *)writer->htable);
#line 831
    sgrep_debug_free(sgrep___0, (void *)writer);
    }
#line 832
    return ((IndexWriter *)((void *)0));
  }
#line 834
  writer->memory_loads = 0;
#line 835
  writer->stream = (FILE *)((void *)0);
#line 836
  writer->failed = 0;
#line 837
  return (writer);
}
}
#line 845 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void delete_index_writer(IndexWriter *writer ) 
{ 
  struct IndexBufferArray *b ;
  int i___0 ;
  SgrepData *sgrep___0 ;

  {
#line 848
  sgrep___0 = writer->sgrep;
#line 851
  if (writer->stream) {
    {
#line 852
    fclose(writer->stream);
#line 853
    writer->stream = (FILE *)((void *)0);
    }
  }
#line 856
  i___0 = 0;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i___0 < writer->memory_loads)) {
#line 856
      goto while_break;
    }
#line 857
    if ((unsigned long )writer->memory_load_files[i___0] != (unsigned long )((void *)0)) {
      {
#line 858
      delete_temp_file(writer->memory_load_files[i___0]);
#line 859
      writer->memory_load_files[i___0] = (TempFile *)((void *)0);
      }
    }
#line 856
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 863
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 863
    if (! writer->free_index_buffers) {
#line 863
      goto while_break___0;
    }
    {
#line 864
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 864
      (writer->first_free_index_buffer) --;
#line 864
      if (! (writer->first_free_index_buffer >= 0)) {
#line 864
        goto while_break___1;
      }
      {
#line 865
      sgrep_debug_free(sgrep___0, (void *)(writer->free_index_buffers)->bufs[writer->first_free_index_buffer].str);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 867
    b = writer->free_index_buffers;
#line 868
    writer->free_index_buffers = (writer->free_index_buffers)->next;
#line 869
    writer->first_free_index_buffer = 1024;
#line 870
    sgrep_debug_free(sgrep___0, (void *)b);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 873
  if (writer->spool) {
    {
#line 874
    sgrep_debug_free(sgrep___0, (void *)writer->spool);
    }
  }
#line 877
  if (writer->htable) {
    {
#line 878
    sgrep_debug_free(sgrep___0, (void *)writer->htable);
    }
  }
  {
#line 881
  sgrep_debug_free(sgrep___0, (void *)writer);
  }
#line 882
  return;
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexBuffer *merge_sort_index_buffer(IndexBuffer *list ) 
{ 
  IndexBuffer *l ;
  IndexBuffer *next ;
  IndexBuffer *first___0 ;
  IndexBuffer *second ;
  IndexBuffer *sorted ;
  struct IndexBufferStruct *tmp ;
  struct IndexBufferStruct *tmp___0 ;
  int tmp___1 ;

  {
#line 888
  sorted = (IndexBuffer *)((void *)0);
#line 890
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 890
    return (list);
  }
#line 893
  first___0 = (IndexBuffer *)((void *)0);
#line 894
  second = (IndexBuffer *)((void *)0);
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    if (! list) {
#line 895
      goto while_break;
    }
#line 896
    next = list->next;
#line 897
    list->next = first___0;
#line 898
    first___0 = list;
#line 899
    list = next;
#line 900
    if (list) {
#line 901
      next = list->next;
#line 902
      list->next = second;
#line 903
      second = list;
#line 904
      list = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 907
  if ((unsigned long )second == (unsigned long )((void *)0)) {
#line 907
    return (first___0);
  }
  {
#line 910
  first___0 = merge_sort_index_buffer(first___0);
#line 911
  second = merge_sort_index_buffer(second);
#line 914
  l = (IndexBuffer *)((void *)0);
  }
  {
#line 915
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 915
    if (first___0) {
#line 915
      if (! second) {
#line 915
        goto while_break___0;
      }
    } else {
#line 915
      goto while_break___0;
    }
#line 916
    if (first___0) {
#line 916
      if (! second) {
#line 916
        goto _L___0;
      } else {
        {
#line 916
        tmp___1 = strcmp((char const   *)first___0->str, (char const   *)second->str);
        }
#line 916
        if (tmp___1 <= 0) {
          _L___0: /* CIL Label */ 
#line 917
          if (l) {
#line 917
            tmp = first___0;
#line 917
            l->next = tmp;
#line 917
            l = tmp;
          } else {
#line 918
            sorted = first___0;
#line 918
            l = sorted;
          }
#line 919
          first___0 = first___0->next;
        } else {
#line 916
          goto _L;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 921
      if (l) {
#line 921
        tmp___0 = second;
#line 921
        l->next = tmp___0;
#line 921
        l = tmp___0;
      } else {
#line 922
        sorted = second;
#line 922
        l = sorted;
      }
#line 923
      second = second->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 926
  if (! first___0) {
#line 926
    if (! second) {
      {
#line 926
      __assert_fail("first||second", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    926U, "merge_sort_index_buffer");
      }
    }
  }
#line 927
  if (first___0) {
#line 927
    l->next = first___0;
  } else {
#line 928
    l->next = second;
  }
#line 930
  return (sorted);
}
}
#line 933 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void sort_index_buffers(IndexWriter *writer ) 
{ 
  IndexBuffer *list ;
  IndexBuffer *l ;
  IndexBuffer *next ;
  IndexBuffer *sorted_buffer ;
  int i___0 ;
  int state ;
  SgrepData *sgrep___0 ;

  {
#line 939
  sgrep___0 = writer->sgrep;
#line 942
  list = (IndexBuffer *)((void *)0);
#line 943
  state = 0;
#line 944
  i___0 = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i___0 < writer->hash_size)) {
#line 944
      goto while_break;
    }
#line 945
    l = *(writer->htable + i___0);
    {
#line 945
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 945
      if (! l) {
#line 945
        goto while_break___0;
      }
#line 946
      next = l->next;
#line 947
      l->next = list;
#line 948
      list = l;
#line 945
      l = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 944
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 953
  sgrep_debug_free(sgrep___0, (void *)writer->htable);
#line 956
  sorted_buffer = merge_sort_index_buffer(list);
#line 957
  writer->htable = (IndexBuffer **)((void *)0);
#line 958
  writer->sorted_buffers = sorted_buffer;
  }
#line 959
  return;
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void count_lcps_recursion(IndexBuffer **array , int len , char const   *str ) 
{ 
  char const   *middle_str ;
  int middle_ind ;
  unsigned int i___0 ;

  {
#line 969
  if (! (len != 0)) {
    {
#line 969
    __assert_fail("len!=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  969U, "count_lcps_recursion");
    }
  }
#line 971
  middle_ind = len / 2;
#line 972
  middle_str = (char const   *)(*(array + middle_ind))->str;
#line 973
  i___0 = 0U;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if ((int const   )*(str + i___0) == (int const   )*(middle_str + i___0)) {
#line 973
      if (*(middle_str + i___0)) {
#line 973
        if (! *(str + i___0)) {
#line 973
          goto while_break;
        }
      } else {
#line 973
        goto while_break;
      }
    } else {
#line 973
      goto while_break;
    }
#line 973
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 974
  if (i___0 < 256U) {
#line 974
    (*(array + middle_ind))->lcp = (unsigned char )i___0;
  } else {
#line 974
    (*(array + middle_ind))->lcp = (unsigned char)255;
  }
#line 975
  *(array + middle_ind) = (IndexBuffer *)((void *)0);
#line 977
  if (len == 1) {
#line 977
    return;
  }
#line 978
  if (len == 2) {
    {
#line 979
    count_lcps_recursion(array, 1, middle_str);
    }
#line 980
    return;
  }
  {
#line 982
  count_lcps_recursion(array, middle_ind, middle_str);
#line 983
  count_lcps_recursion((array + middle_ind) + 1, (len - middle_ind) - 1, middle_str);
  }
#line 984
  return;
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void count_common_prefixes(IndexWriter *writer ) 
{ 
  int i___0 ;
  IndexBuffer *tmp ;
  IndexBuffer **sorted_array ;
  SgrepData *sgrep___0 ;
  void *tmp___0 ;

  {
  {
#line 990
  sgrep___0 = writer->sgrep;
#line 992
  tmp___0 = sgrep_debug_malloc(sgrep___0, (unsigned long )writer->terms * sizeof(IndexBuffer *),
                               "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                               993);
#line 992
  sorted_array = (IndexBuffer **)tmp___0;
#line 994
  tmp = writer->sorted_buffers;
#line 994
  i___0 = 0;
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! tmp) {
#line 994
      goto while_break;
    }
#line 995
    if (! (i___0 < writer->terms)) {
      {
#line 995
      __assert_fail("i<writer->terms", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    995U, "count_common_prefixes");
      }
    }
#line 996
    *(sorted_array + i___0) = tmp;
#line 994
    tmp = tmp->next;
#line 994
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 998
  count_lcps_recursion(sorted_array, i___0, "");
#line 999
  sgrep_debug_free(sgrep___0, (void *)sorted_array);
  }
#line 1000
  return;
}
}
#line 1003 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void count_statistics(IndexWriter *writer ) 
{ 
  IndexBuffer *tmp ;
  int i___0 ;
  char const   *name ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 1007
  writer->strings_lcps_compressed = 0;
#line 1008
  tmp = writer->sorted_buffers;
  {
#line 1008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1008
    if (! tmp) {
#line 1008
      goto while_break;
    }
#line 1009
    writer->strings_lcps_compressed += (int )tmp->lcp;
#line 1008
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  if (writer->file_list) {
#line 1016
    writer->flist_size = 4;
#line 1017
    i___0 = 0;
    {
#line 1017
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1017
      tmp___1 = flist_files((FileList const   *)writer->file_list);
      }
#line 1017
      if (! (i___0 < tmp___1)) {
#line 1017
        goto while_break___0;
      }
      {
#line 1018
      name = flist_name((FileList const   *)writer->file_list, i___0);
#line 1019
      writer->flist_size += 4;
      }
#line 1020
      if ((unsigned long )name != (unsigned long )((void *)0)) {
        {
#line 1021
        tmp___0 = strlen(name);
#line 1021
        writer->flist_size = (int )((size_t )writer->flist_size + (tmp___0 + 1UL));
        }
      }
#line 1023
      writer->flist_size += 4;
#line 1017
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1026
    writer->flist_size = 0;
  }
#line 1032
  writer->total_index_file_size = ((((1024 + writer->terms * 4) + writer->total_string_bytes) - writer->strings_lcps_compressed) + writer->terms) + (writer->total_postings_bytes + writer->terms);
#line 1037
  writer->flist_start = writer->total_index_file_size;
#line 1038
  writer->total_index_file_size += writer->flist_size;
#line 1039
  return;
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int write_index_term_array(IndexWriter *writer , FILE *stream ) 
{ 
  int i___0 ;
  int possible_stop_word_size ;
  IndexBuffer *tmp ;
  FILE *stop_stream ;
  SgrepData *sgrep___0 ;
  int wbytes ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1042
  i___0 = 0;
#line 1043
  possible_stop_word_size = 0;
#line 1044
  tmp = (IndexBuffer *)((void *)0);
#line 1045
  stop_stream = (FILE *)((void *)0);
#line 1046
  sgrep___0 = writer->sgrep;
#line 1048
  tmp = writer->sorted_buffers;
  {
#line 1048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    if (! tmp) {
#line 1048
      goto while_break;
    }
    {
#line 1051
    put_int(i___0, stream);
    }
#line 1053
    if (tmp->last_index == -1) {
#line 1056
      tmp->last_index = 0;
    }
    {
#line 1059
    add_byte(writer, tmp, (unsigned char)127);
#line 1061
    tmp___0 = strlen((char const   *)tmp->str);
    }
#line 1061
    if ((int )tmp->block_used >= 0) {
#line 1061
      tmp___1 = (int )tmp->block_used;
    } else {
#line 1061
      tmp___1 = tmp->list.external.bytes;
    }
#line 1061
    wbytes = (int )((((tmp___0 - (size_t )tmp->lcp) + 2UL) + (size_t )tmp->saved_bytes) + (size_t )tmp___1);
#line 1065
    i___0 += wbytes;
#line 1066
    wbytes += 4;
#line 1069
    if ((writer->options)->stop_word_limit) {
#line 1069
      if (writer->total_index_file_size / wbytes < (int )(writer->options)->stop_word_limit) {
#line 1071
        if (possible_stop_word_size == 0) {
          {
#line 1072
          sgrep_error(sgrep___0, (char *)"Possible stop words:\n");
          }
        }
        {
#line 1074
        sgrep_error(sgrep___0, (char *)"%5dK (%2.2f%%) \'%s\'\n", wbytes / 1024, ((double )wbytes * 100.0) / (double )writer->total_index_file_size,
                    tmp->str);
#line 1076
        possible_stop_word_size += wbytes;
        }
      }
    }
#line 1080
    if ((writer->options)->output_stop_word_file) {
#line 1081
      if ((unsigned long )stop_stream == (unsigned long )((void *)0)) {
        {
#line 1082
        stop_stream = fopen((char const   */* __restrict  */)(writer->options)->output_stop_word_file,
                            (char const   */* __restrict  */)"w+");
        }
#line 1083
        if ((unsigned long )stop_stream == (unsigned long )((void *)0)) {
          {
#line 1084
          tmp___2 = __errno_location();
#line 1084
          tmp___3 = strerror(*tmp___2);
#line 1084
          sgrep_error(sgrep___0, (char *)"Failed to open stop word file \'%s\':%s\n",
                      (writer->options)->output_stop_word_file, tmp___3);
          }
#line 1087
          return (-1);
        }
      }
      {
#line 1090
      fprintf((FILE */* __restrict  */)stop_stream, (char const   */* __restrict  */)"%d %s\n",
              wbytes, tmp->str);
      }
    }
#line 1048
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1094
  if (stop_stream) {
    {
#line 1095
    tmp___6 = ferror(stop_stream);
    }
#line 1095
    if (tmp___6) {
      {
#line 1096
      tmp___4 = __errno_location();
#line 1096
      tmp___5 = strerror(*tmp___4);
#line 1096
      sgrep_error(sgrep___0, (char *)"Failed to write stop word file \'%s\':%s", (writer->options)->output_stop_word_file,
                  tmp___5);
#line 1099
      fclose(stop_stream);
      }
#line 1100
      return (-1);
    }
    {
#line 1102
    fclose(stop_stream);
    }
  }
#line 1106
  if (possible_stop_word_size > 0) {
    {
#line 1107
    sgrep_error(sgrep___0, (char *)"-------------\n%5dK (%2.2f%%) total\n", possible_stop_word_size / 1024,
                ((double )possible_stop_word_size * 100.0) / (double )writer->total_index_file_size);
    }
  }
#line 1111
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void write_index_header(IndexWriter *writer ) 
{ 
  FILE *stream ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1119
  l = 0;
#line 1120
  stream = writer->stream;
#line 1122
  l = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n\n%d terms\n%d entries\n",
              "sgrep-index v0", writer->terms, writer->postings);
#line 1125
  tmp = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"1024 bytes header (%d%%)\n",
                102400 / writer->total_index_file_size);
#line 1125
  l += tmp;
#line 1127
  tmp___0 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d bytes term index (%d%%)\n",
                    writer->terms * 4, ((writer->terms * 4) * 100) / writer->total_index_file_size);
#line 1127
  l += tmp___0;
#line 1130
  tmp___1 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d bytes strings (%d%%)\n  %d total strings\n  %d compressed with lcps (-%d%%)\n",
                    (writer->total_string_bytes - writer->strings_lcps_compressed) + writer->terms,
                    (((writer->total_string_bytes - writer->strings_lcps_compressed) + writer->terms) * 100) / writer->total_index_file_size,
                    writer->total_string_bytes, writer->strings_lcps_compressed - writer->terms,
                    ((writer->strings_lcps_compressed - writer->terms) * 100) / writer->total_string_bytes);
#line 1130
  l += tmp___1;
#line 1139
  tmp___2 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d bytes postings (%d%%)\n",
                    writer->total_postings_bytes + writer->terms, ((writer->total_postings_bytes + writer->terms) * 100) / writer->total_index_file_size);
#line 1139
  l += tmp___2;
#line 1143
  tmp___3 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d bytes file list (%d%%)\n",
                    writer->flist_size, (writer->flist_size * 100) / writer->total_index_file_size);
#line 1143
  l += tmp___3;
#line 1146
  tmp___4 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d total index size\n--\n",
                    writer->total_index_file_size);
#line 1146
  l += tmp___4;
  }
  {
#line 1148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1148
    if (! (l < 512)) {
#line 1148
      goto while_break;
    }
    {
#line 1149
    _IO_putc(0, stream);
#line 1150
    l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1153
  tmp___5 = put_int(writer->terms, stream);
#line 1153
  l += tmp___5;
#line 1154
  tmp___6 = put_int(1024, stream);
#line 1154
  l += tmp___6;
#line 1155
  tmp___7 = put_int(1024 + writer->terms * 4, stream);
#line 1155
  l += tmp___7;
#line 1156
  tmp___8 = put_int(writer->flist_start, stream);
#line 1156
  l += tmp___8;
  }
  {
#line 1158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1158
    if (! (l < 1024)) {
#line 1158
      goto while_break___0;
    }
    {
#line 1159
    _IO_putc(0, stream);
#line 1160
    l ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1162
  return;
}
}
#line 1164 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int write_index_terms(IndexWriter *writer ) 
{ 
  int total_internal_bytes ;
  int total_external_bytes ;
  int total_saved_bytes ;
  int written_terms ;
  IndexBuffer *tmp ;
  FILE *stream ;
  char mlf_string[256][257] ;
  int i___0 ;
  SgrepData *sgrep___0 ;
  FILE *load_stream ;
  int c ;
  int j ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t size ;
  char buf[8192] ;
  int c___0 ;
  int j___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int r ;
  int len ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 1165
  total_internal_bytes = 0;
#line 1166
  total_external_bytes = 0;
#line 1167
  total_saved_bytes = 0;
#line 1168
  written_terms = 0;
#line 1173
  sgrep___0 = writer->sgrep;
#line 1174
  load_stream = (FILE *)((void *)0);
#line 1177
  i___0 = 0;
  {
#line 1177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1177
    if (! (i___0 < writer->memory_loads)) {
#line 1177
      goto while_break;
    }
    {
#line 1179
    load_stream = temp_file_stream(writer->memory_load_files[i___0]);
#line 1181
    tmp___2 = fseek(load_stream, 0L, 0);
    }
#line 1181
    if (tmp___2 == -1) {
      {
#line 1182
      tmp___0 = __errno_location();
#line 1182
      tmp___1 = strerror(*tmp___0);
#line 1182
      sgrep_error(sgrep___0, (char *)"Memory load fseek():%s\n", tmp___1);
#line 1183
      mlf_string[i___0][0] = (char)0;
      }
#line 1184
      return (-1);
    }
#line 1186
    j = 0;
    {
#line 1187
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1187
      c = _IO_getc(load_stream);
      }
#line 1187
      if (c) {
#line 1187
        if (! (c != -1)) {
#line 1187
          goto while_break___0;
        }
      } else {
#line 1187
        goto while_break___0;
      }
#line 1188
      tmp___3 = j;
#line 1188
      j ++;
#line 1188
      mlf_string[i___0][tmp___3] = (char )c;
#line 1189
      if (! (j < 256)) {
        {
#line 1189
        __assert_fail("j<256", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                      1189U, "write_index_terms");
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1191
    if (c == -1) {
      {
#line 1192
      sgrep_error(sgrep___0, (char *)"Memory load file #%d truncated!\n", i___0);
      }
#line 1193
      return (-1);
    }
#line 1195
    mlf_string[i___0][j] = (char)0;
#line 1177
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1199
  stream = writer->stream;
#line 1200
  written_terms = 0;
#line 1202
  tmp = writer->sorted_buffers;
  {
#line 1202
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1202
    if (! tmp) {
#line 1202
      goto while_break___1;
    }
#line 1204
    if ((written_terms & 1023) == 0) {
      {
#line 1205
      sgrep_progress(sgrep___0, (char *)"Writing index %d/%d entries (%d%%)\r", written_terms,
                     writer->terms, (written_terms * 100) / writer->terms);
      }
    }
    {
#line 1209
    written_terms ++;
#line 1211
    _IO_putc((int )tmp->lcp, stream);
#line 1212
    fputs((char const   */* __restrict  */)(tmp->str + (int )tmp->lcp), (FILE */* __restrict  */)stream);
#line 1213
    _IO_putc(0, stream);
#line 1217
    i___0 = 0;
    }
    {
#line 1217
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1217
      if (! (i___0 < writer->memory_loads)) {
#line 1217
        goto while_break___2;
      }
      {
#line 1218
      tmp___14 = strcmp((char const   *)tmp->str, (char const   *)(mlf_string[i___0]));
      }
#line 1218
      if (tmp___14 == 0) {
        {
#line 1224
        load_stream = temp_file_stream(writer->memory_load_files[i___0]);
#line 1225
        tmp___4 = _IO_getc(load_stream);
#line 1225
        size = (size_t )(tmp___4 << 24);
#line 1226
        tmp___5 = _IO_getc(load_stream);
#line 1226
        size |= (unsigned long )(tmp___5 << 16);
#line 1227
        tmp___6 = _IO_getc(load_stream);
#line 1227
        size |= (unsigned long )(tmp___6 << 8);
#line 1228
        tmp___7 = _IO_getc(load_stream);
#line 1228
        size |= (unsigned long )tmp___7;
#line 1229
        tmp___8 = feof(load_stream);
        }
#line 1229
        if (tmp___8) {
          {
#line 1230
          sgrep_error(sgrep___0, (char *)"Memory load file truncated?\n");
          }
#line 1231
          return (-1);
        }
#line 1233
        total_saved_bytes = (int )((size_t )total_saved_bytes + size);
        {
#line 1236
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1236
          if (! (size > 0UL)) {
#line 1236
            goto while_break___3;
          }
#line 1238
          if (size < sizeof(buf)) {
#line 1238
            tmp___9 = size;
          } else {
#line 1238
            tmp___9 = sizeof(buf);
          }
          {
#line 1238
          len = (int )tmp___9;
#line 1239
          tmp___10 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )len,
                           (FILE */* __restrict  */)load_stream);
#line 1239
          r = (int )tmp___10;
          }
#line 1240
          if (r >= 0) {
#line 1240
            if (r < len) {
              {
#line 1241
              sgrep_error(sgrep___0, (char *)"Memory load file truncated?\n");
              }
#line 1242
              return (-1);
            }
          }
#line 1244
          if (r < 0) {
            {
#line 1245
            tmp___11 = __errno_location();
#line 1245
            tmp___12 = strerror(*tmp___11);
#line 1245
            sgrep_error(sgrep___0, (char *)"IO Error when reading memory load:%s\n",
                        tmp___12);
            }
#line 1247
            return (-1);
          }
          {
#line 1249
          fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )r, (FILE */* __restrict  */)stream);
#line 1250
          size -= (size_t )r;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1252
        if (! (size == 0UL)) {
          {
#line 1252
          __assert_fail("size==0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                        1252U, "write_index_terms");
          }
        }
#line 1253
        j___0 = 0;
        {
#line 1255
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1255
          c___0 = _IO_getc(load_stream);
          }
#line 1255
          if (c___0) {
#line 1255
            if (! (c___0 != -1)) {
#line 1255
              goto while_break___4;
            }
          } else {
#line 1255
            goto while_break___4;
          }
#line 1256
          tmp___13 = j___0;
#line 1256
          j___0 ++;
#line 1256
          mlf_string[i___0][tmp___13] = (char )c___0;
#line 1257
          if (! (j___0 <= 256)) {
            {
#line 1257
            __assert_fail("j<=256", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                          1257U, "write_index_terms");
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1259
        mlf_string[i___0][j___0] = (char)0;
#line 1260
        if (c___0 == -1) {
#line 1262
          if (! (j___0 == 0)) {
            {
#line 1262
            __assert_fail("j==0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                          1262U, "write_index_terms");
            }
          }
          {
#line 1263
          delete_temp_file(writer->memory_load_files[i___0]);
#line 1264
          writer->memory_load_files[i___0] = (TempFile *)((void *)0);
          }
        }
      }
#line 1217
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1270
    fwrite_postings(writer, tmp, stream);
    }
#line 1273
    if ((int )tmp->block_used >= 0) {
#line 1273
      total_internal_bytes += (int )tmp->block_used;
    } else {
#line 1274
      total_external_bytes += tmp->list.external.bytes;
    }
    {
#line 1275
    tmp___15 = ferror(stream);
    }
#line 1275
    if (tmp___15) {
      {
#line 1277
      sgrep_progress(sgrep___0, (char *)"\n");
      }
#line 1278
      return (0);
    }
#line 1202
    tmp = tmp->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1281
  sgrep_progress(sgrep___0, (char *)"\n");
  }
#line 1284
  if (! ((total_external_bytes + total_internal_bytes) + total_saved_bytes == writer->total_postings_bytes)) {
    {
#line 1284
    __assert_fail("total_external_bytes+total_internal_bytes+total_saved_bytes== writer->total_postings_bytes",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  1285U, "write_index_terms");
    }
  }
#line 1286
  return (0);
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int write_index_file_list(IndexWriter *writer ) 
{ 
  int i___0 ;
  FILE *stream ;
  char const   *name ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1292
  stream = writer->stream;
#line 1294
  if (writer->file_list) {
    {
#line 1297
    tmp = flist_files((FileList const   *)writer->file_list);
#line 1297
    put_int(tmp, stream);
#line 1299
    i___0 = 0;
    }
    {
#line 1299
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1299
      tmp___2 = flist_files((FileList const   *)writer->file_list);
      }
#line 1299
      if (! (i___0 < tmp___2)) {
#line 1299
        goto while_break;
      }
      {
#line 1300
      name = flist_name((FileList const   *)writer->file_list, i___0);
      }
#line 1301
      if ((unsigned long )name == (unsigned long )((void *)0)) {
        {
#line 1302
        put_int(0, stream);
        }
      } else {
        {
#line 1304
        tmp___0 = strlen(name);
#line 1304
        put_int((int )tmp___0, stream);
#line 1305
        fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)stream);
#line 1307
        _IO_putc(0, stream);
        }
      }
      {
#line 1309
      tmp___1 = flist_length((FileList const   *)writer->file_list, i___0);
#line 1309
      put_int(tmp___1, stream);
#line 1299
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1312
  return (0);
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int write_index(IndexWriter *writer ) 
{ 
  FILE *stream ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1317
  sgrep___0 = writer->sgrep;
#line 1319
  stream = writer->stream;
#line 1320
  sort_index_buffers(writer);
#line 1321
  count_common_prefixes(writer);
#line 1323
  count_statistics(writer);
#line 1324
  sgrep_progress(sgrep___0, (char *)"Writing index file of %dK\n", writer->total_index_file_size / 1024);
#line 1327
  write_index_header(writer);
#line 1328
  fflush(stream);
#line 1329
  tmp = ferror(stream);
  }
#line 1329
  if (tmp) {
#line 1329
    goto io_error;
  }
  {
#line 1332
  tmp___0 = write_index_term_array(writer, stream);
  }
#line 1332
  if (tmp___0 == -1) {
#line 1333
    goto error;
  }
  {
#line 1335
  tmp___1 = ferror(stream);
  }
#line 1335
  if (tmp___1) {
#line 1335
    goto io_error;
  }
  {
#line 1338
  tmp___2 = write_index_terms(writer);
  }
#line 1338
  if (tmp___2 == -1) {
#line 1339
    goto error;
  }
  {
#line 1341
  fflush(stream);
#line 1342
  tmp___3 = ferror(stream);
  }
#line 1342
  if (tmp___3) {
#line 1342
    goto io_error;
  }
  {
#line 1345
  tmp___4 = write_index_file_list(writer);
  }
#line 1345
  if (tmp___4 == -1) {
#line 1346
    goto error;
  }
  {
#line 1348
  fflush(stream);
#line 1349
  tmp___5 = ferror(stream);
  }
#line 1349
  if (tmp___5) {
#line 1349
    goto io_error;
  }
#line 1352
  return (0);
  io_error: 
  {
#line 1355
  tmp___6 = __errno_location();
#line 1355
  tmp___7 = strerror(*tmp___6);
#line 1355
  sgrep_error(sgrep___0, (char *)"IO Error when writing index: %s\n", tmp___7);
  }
  error: 
  {
#line 1357
  sgrep_error(sgrep___0, (char *)"Failed to write index\n");
  }
#line 1358
  return (-1);
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int create_index(IndexOptions const   *options ) 
{ 
  int i___0 ;
  IndexWriter *writer ;
  FileList *file_list ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  SgrepString *s ;
  SgrepString *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 1362
  i___0 = 0;
#line 1363
  writer = (IndexWriter *)((void *)0);
#line 1364
  file_list = (FileList *)((void *)0);
#line 1365
  sgrep___0 = (SgrepData *)options->sgrep;
#line 1367
  file_list = new_flist(sgrep___0);
  }
#line 1368
  if (options->file_list_files) {
    {
#line 1369
    flist_add_file_list_files(file_list, (FileList *)options->file_list_files);
    }
  }
#line 1371
  if (options->file_list) {
    {
#line 1372
    flist_cat(file_list, (FileList *)options->file_list);
    }
  }
  {
#line 1374
  flist_ready(file_list);
#line 1375
  tmp = flist_files((FileList const   *)file_list);
  }
#line 1375
  if (tmp == 0) {
    {
#line 1376
    sgrep_error(sgrep___0, (char *)"No files to index.\n");
    }
#line 1377
    goto error;
  }
  {
#line 1379
  writer = new_index_writer(options);
  }
#line 1380
  if ((unsigned long )writer == (unsigned long )((void *)0)) {
#line 1380
    goto error;
  }
#line 1381
  writer->file_list = file_list;
#line 1384
  if ((writer->options)->input_stop_word_file) {
    {
#line 1385
    tmp___0 = read_stop_word_file(writer, (char const   *)(writer->options)->input_stop_word_file);
    }
#line 1385
    if (tmp___0 == -1) {
#line 1387
      goto error;
    }
  }
  {
#line 1391
  tmp___1 = index_search(writer->sgrep, writer, writer->file_list);
  }
#line 1391
  if (tmp___1 == -1) {
#line 1392
    goto error;
  }
  {
#line 1398
  tmp___2 = new_string(sgrep___0, (size_t )1024);
#line 1398
  s = tmp___2;
#line 1399
  i___0 = 0;
  }
  {
#line 1399
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1399
    tmp___8 = flist_files((FileList const   *)writer->file_list);
    }
#line 1399
    if (! (i___0 < tmp___8)) {
#line 1399
      goto while_break;
    }
    {
#line 1400
    s->length = (size_t )0;
#line 1401
    string_cat(s, "f");
#line 1402
    tmp___3 = flist_name((FileList const   *)writer->file_list, i___0);
#line 1402
    string_cat(s, tmp___3);
#line 1404
    tmp___4 = flist_start((FileList const   *)writer->file_list, i___0);
#line 1404
    tmp___5 = flist_length((FileList const   *)writer->file_list, i___0);
#line 1404
    tmp___6 = flist_start((FileList const   *)writer->file_list, i___0);
#line 1404
    *(s->s + s->length) = (char)0;
#line 1404
    tmp___7 = add_region_to_index(writer, (char const   *)s->s, tmp___6, (tmp___4 + tmp___5) - 1);
    }
#line 1404
    if (tmp___7 == -1) {
#line 1410
      goto error;
    }
#line 1399
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1413
  delete_string(s);
#line 1417
  writer->stream = fopen((char const   */* __restrict  */)(writer->options)->file_name,
                         (char const   */* __restrict  */)"wb");
  }
#line 1418
  if ((unsigned long )writer->stream == (unsigned long )((void *)0)) {
    {
#line 1419
    tmp___9 = __errno_location();
#line 1419
    tmp___10 = strerror(*tmp___9);
#line 1419
    sgrep_error(sgrep___0, (char *)"Can\'t open \'%s\' for writing:%s\n", (writer->options)->file_name,
                tmp___10);
    }
#line 1421
    goto error;
  }
  {
#line 1424
  tmp___11 = write_index(writer);
  }
#line 1424
  if (tmp___11 == -1) {
#line 1425
    goto error;
  }
  {
#line 1428
  fclose(writer->stream);
#line 1429
  writer->stream = (FILE *)((void *)0);
  }
#line 1431
  if ((writer->options)->index_stats) {
    {
#line 1432
    display_index_statistics(writer);
#line 1433
    tmp___12 = flist_total((FileList const   *)writer->file_list);
#line 1433
    tmp___13 = flist_files((FileList const   *)writer->file_list);
#line 1433
    sgrep_error(sgrep___0, (char *)"Indexed %d files having %dK total size\n", tmp___13,
                tmp___12 / 1024);
    }
  }
#line 1438
  if (writer->file_list) {
    {
#line 1439
    delete_flist(writer->file_list);
    }
  }
  {
#line 1441
  delete_index_writer(writer);
  }
#line 1442
  return (0);
  error: 
#line 1445
  if (file_list) {
    {
#line 1446
    delete_flist(file_list);
    }
  }
#line 1448
  if (writer) {
#line 1448
    if (writer->stream) {
      {
#line 1449
      fclose(writer->stream);
#line 1450
      remove((char const   *)(writer->options)->file_name);
      }
    }
  }
#line 1452
  if (writer) {
    {
#line 1452
    delete_index_writer(writer);
    }
  }
#line 1453
  return (-1);
}
}
#line 1467 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int do_recursive_lookup(struct LookupStruct *ls , int s , int e , char const   *pstr ) 
{ 
  char const   *str ;
  char npstr[257] ;
  int middle ;
  int rc ;
  int lc ;
  int tmp ;
  int r ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 1472
  middle = (e - s) / 2;
#line 1476
  tmp = get_int((ls->map)->array, s + middle);
#line 1476
  str = (char const   *)(ls->map)->entries + tmp;
  }
#line 1477
  if ((int const   )*(str + 0) > 0) {
#line 1478
    if (! ((unsigned long )pstr != (unsigned long )((void *)0))) {
      {
#line 1478
      __assert_fail("pstr!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    1478U, "do_recursive_lookup");
      }
    }
    {
#line 1479
    strncpy((char */* __restrict  */)(npstr), (char const   */* __restrict  */)pstr,
            (size_t )*(str + 0));
    }
  }
  {
#line 1481
  strncpy((char */* __restrict  */)(npstr + (int const   )*(str + 0)), (char const   */* __restrict  */)(str + 1),
          (size_t )(256 - (int )*(str + 0)));
  }
#line 1484
  if (ls->end) {
    {
#line 1485
    r = 0;
#line 1487
    tmp___0 = strlen(ls->begin);
#line 1487
    lc = strncmp(ls->begin, (char const   *)(npstr), tmp___0);
#line 1488
    tmp___1 = strlen(ls->end);
#line 1488
    rc = strncmp((char const   *)(npstr), ls->end, tmp___1);
    }
#line 1490
    if (lc <= 0) {
#line 1490
      if (middle > 0) {
        {
#line 1491
        tmp___2 = do_recursive_lookup(ls, s, s + middle, (char const   *)(npstr));
#line 1491
        r += tmp___2;
        }
      }
    }
#line 1494
    if (lc <= 0) {
#line 1494
      if (rc <= 0) {
        {
#line 1496
        r ++;
#line 1497
        tmp___3 = strlen(str + 1);
#line 1497
        (*(ls->callback))((char const   *)(npstr), ((unsigned char const   *)str + 2) + tmp___3,
                          ls);
        }
      }
    }
#line 1501
    if (rc <= 0) {
#line 1501
      if (s + middle < e - 1) {
        {
#line 1502
        tmp___4 = do_recursive_lookup(ls, (s + middle) + 1, e, (char const   *)(npstr));
#line 1502
        r += tmp___4;
        }
      }
    }
#line 1504
    return (r);
  }
  {
#line 1508
  lc = strcmp(ls->begin, (char const   *)(npstr));
  }
#line 1509
  if (lc < 0) {
#line 1509
    if (middle > 0) {
      {
#line 1510
      tmp___5 = do_recursive_lookup(ls, s, s + middle, (char const   *)(npstr));
      }
#line 1510
      return (tmp___5);
    } else {
#line 1509
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1511
  if (lc > 0) {
#line 1511
    if (s + middle < e - 1) {
      {
#line 1512
      tmp___6 = do_recursive_lookup(ls, (s + middle) + 1, e, (char const   *)(npstr));
      }
#line 1512
      return (tmp___6);
    } else {
#line 1511
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1513
  if (lc == 0) {
    {
#line 1515
    tmp___7 = strlen(str + 1);
#line 1515
    (*(ls->callback))((char const   *)(npstr), (unsigned char const   *)((str + 2) + tmp___7),
                      ls);
    }
#line 1517
    return (1);
  }
#line 1520
  return (0);
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexBuffer *new_map_buffer(SgrepData *sgrep___0 , char const   *entry , unsigned char const   *buf ) 
{ 
  IndexBuffer *n ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1527
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(IndexBuffer ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                           1527);
#line 1527
  n = (IndexBuffer *)tmp;
#line 1528
  n->list.map.buf = buf;
#line 1529
  n->list.map.ind = 0;
#line 1530
  n->block_used = (short)-32768;
#line 1531
  n->last_index = 0;
#line 1532
  tmp___0 = strlen(entry);
#line 1532
  n->last_len = (short )(tmp___0 - 1UL);
#line 1533
  n->str = sgrep_debug_strdup(sgrep___0, entry, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                              1533);
#line 1534
  n->saved_bytes = -1;
  }
#line 1535
  return (n);
}
}
#line 1538 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void delete_map_buffer(SgrepData *sgrep___0 , IndexBuffer *map_buffer ) 
{ 


  {
#line 1539
  if (! ((int )map_buffer->block_used == -32768)) {
    {
#line 1539
    __assert_fail("map_buffer->block_used==(-32767 - 1)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  1539U, "delete_map_buffer");
    }
  }
  {
#line 1540
  map_buffer->block_used = (short)0;
#line 1541
  sgrep_debug_free(sgrep___0, (void *)map_buffer->str);
#line 1542
  sgrep_debug_free(sgrep___0, (void *)map_buffer);
  }
#line 1543
  return;
}
}
#line 1545 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void dump_entry(char const   *entry , unsigned char const   *regions , struct LookupStruct *ls ) 
{ 
  Region region ;
  FILE *f ;
  IndexBuffer *map_buffer ;
  SgrepData *sgrep___0 ;
  int tmp ;

  {
  {
#line 1550
  sgrep___0 = ls->sgrep;
#line 1552
  f = ls->data.stream;
#line 1553
  map_buffer = new_map_buffer(sgrep___0, entry, regions);
#line 1554
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s:[", entry);
  }
  {
#line 1555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1555
    tmp = get_region_index(map_buffer, & region);
    }
#line 1555
    if (! tmp) {
#line 1555
      goto while_break;
    }
    {
#line 1556
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(%d,%d)",
            region.start, region.end);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1558
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"]\n");
#line 1559
  delete_map_buffer(sgrep___0, map_buffer);
  }
#line 1560
  return;
}
}
#line 1562 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void read_unsorted_postings(char const   *entry , unsigned char const   *regions ,
                            struct LookupStruct *ls ) 
{ 
  Region r ;
  RegionList *list ;
  IndexBuffer *map_buffer ;
  int size ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1568
  sgrep___0 = ls->sgrep;
#line 1570
  list = ls->data.reader;
#line 1572
  if ((list->nodes - 1) * (1 << 7) + list->length == 0) {
    {
#line 1573
    sgrep_progress(sgrep___0, (char *)" reading..");
    }
  }
  {
#line 1575
  size = (list->nodes - 1) * (1 << 7) + list->length;
#line 1576
  map_buffer = new_map_buffer(sgrep___0, entry, regions);
#line 1578
  tmp___0 = get_region_index(map_buffer, & r);
  }
#line 1578
  if (tmp___0) {
    {
#line 1579
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1579
      check_add_region((RegionList const   *)list, r.start, r.end);
      }
      {
#line 1579
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1579
        if (list->length == 1 << 7) {
          {
#line 1579
          insert_list_node(list);
          }
        }
#line 1579
        (list->last)->list[list->length].start = r.start;
#line 1579
        (list->last)->list[list->length].end = r.end;
#line 1579
        (list->length) ++;
#line 1579
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1579
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1580
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1580
      tmp = get_region_index(map_buffer, & r);
      }
#line 1580
      if (! tmp) {
#line 1580
        goto while_break___1;
      }
      {
#line 1581
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1581
        check_add_region((RegionList const   *)list, r.start, r.end);
        }
        {
#line 1581
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1581
          if (list->length == 1 << 7) {
            {
#line 1581
            insert_list_node(list);
            }
          }
#line 1581
          (list->last)->list[list->length].start = r.start;
#line 1581
          (list->last)->list[list->length].end = r.end;
#line 1581
          (list->length) ++;
#line 1581
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1581
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1584
    (ls->stop_words) ++;
  }
  {
#line 1586
  delete_map_buffer(sgrep___0, map_buffer);
  }
#line 1587
  return;
}
}
#line 1590 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
Region *merge_regions(SgrepData *sgrep___0 , int const   length1 , Region const   *array1 ,
                      int const   length2 , Region const   *array2 , int *return_length ) 
{ 
  Region region1 ;
  Region region2 ;
  Region eor ;
  int ind1 ;
  int ind2 ;
  int m ;
  Region *merged ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1595
  eor.start = 2147483647;
#line 1595
  eor.end = 2147483647;
#line 1596
  ind1 = 0;
#line 1597
  ind2 = 0;
#line 1598
  m = 0;
#line 1602
  tmp = sgrep_debug_malloc(sgrep___0, (unsigned long )(length1 + length2) * sizeof(Region ),
                           "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                           1602);
#line 1602
  merged = (Region *)tmp;
#line 1603
  region1 = (Region )*(array1 + 0);
#line 1604
  region2 = (Region )*(array2 + 0);
  }
  {
#line 1607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1607
    if (! (ind1 < (int )length1)) {
#line 1607
      if (! (ind2 < (int )length2)) {
#line 1607
        goto while_break;
      }
    }
#line 1608
    if (region1.start < region2.start) {
#line 1610
      *(merged + m) = region1;
#line 1611
      ind1 ++;
#line 1611
      if (ind1 < (int )length1) {
#line 1611
        region1 = (Region )*(array1 + ind1);
      } else {
#line 1611
        region1 = eor;
      }
    } else
#line 1612
    if (region1.start > region2.start) {
#line 1614
      *(merged + m) = region2;
#line 1615
      ind2 ++;
#line 1615
      if (ind2 < (int )length2) {
#line 1615
        region2 = (Region )*(array2 + ind2);
      } else {
#line 1615
        region2 = eor;
      }
    } else
#line 1616
    if (region1.end < region2.end) {
#line 1618
      *(merged + m) = region1;
#line 1619
      ind1 ++;
#line 1619
      if (ind1 < (int )length1) {
#line 1619
        region1 = (Region )*(array1 + ind1);
      } else {
#line 1619
        region1 = eor;
      }
    } else
#line 1620
    if (region1.end == region2.end) {
#line 1622
      *(merged + m) = region1;
#line 1623
      ind1 ++;
#line 1623
      if (ind1 < (int )length1) {
#line 1623
        region1 = (Region )*(array1 + ind1);
      } else {
#line 1623
        region1 = eor;
      }
#line 1624
      ind2 ++;
#line 1624
      if (ind2 < (int )length2) {
#line 1624
        region2 = (Region )*(array2 + ind2);
      } else {
#line 1624
        region2 = eor;
      }
    } else {
#line 1627
      *(merged + m) = region2;
#line 1628
      ind2 ++;
#line 1628
      if (ind2 < (int )length2) {
#line 1628
        region2 = (Region )*(array2 + ind2);
      } else {
#line 1628
        region2 = eor;
      }
    }
#line 1630
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1632
  if (length1 > length2) {
#line 1632
    tmp___0 = length1;
  } else {
#line 1632
    tmp___0 = length2;
  }
#line 1632
  if (! (m >= (int )tmp___0)) {
    {
#line 1632
    __assert_fail("m >= ((length1>length2) ? length1:length2)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  1632U, "merge_regions");
    }
  }
#line 1633
  *return_length = m;
#line 1634
  return (merged);
}
}
#line 1637 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void read_and_sort_postings(char const   *entry , unsigned char const   *regions ,
                            struct LookupStruct *ls ) 
{ 
  IndexBuffer *map_buffer ;
  struct SortingReaderStruct *read___0 ;
  int i___0 ;
  Region first___0 ;
  Region tmp ;
  Region *array ;
  int size ;
  int length ;
  SgrepData *sgrep___0 ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  Region *merged ;
  int merged_length ;
  size_t asize ;
  Region *new_array ;
  void *tmp___7 ;

  {
  {
#line 1640
  read___0 = & ls->data.sorting_reader;
#line 1645
  sgrep___0 = ls->sgrep;
#line 1648
  map_buffer = new_map_buffer(sgrep___0, entry, regions);
#line 1649
  array = read___0->saved_array;
#line 1650
  size = read___0->saved_size;
#line 1651
  length = 0;
#line 1652
  first___0 = read___0->one;
  }
  {
#line 1662
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1662
    tmp___4 = get_region_index(map_buffer, & tmp);
    }
#line 1662
    if (! tmp___4) {
#line 1662
      goto while_break;
    }
#line 1663
    if (first___0.start <= tmp.start) {
#line 1664
      if (first___0.start < tmp.start) {
#line 1664
        goto _L;
      } else
#line 1664
      if (first___0.end < tmp.end) {
        _L: /* CIL Label */ 
        {
#line 1666
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1666
          if (length == size) {
            {
#line 1666
            size += size / 2;
#line 1666
            tmp___0 = sgrep_debug_realloc(sgrep___0, (void *)array, sizeof(Region ) * (unsigned long )size);
#line 1666
            array = (Region *)tmp___0;
            }
          }
#line 1666
          tmp___1 = length;
#line 1666
          length ++;
#line 1666
          *(array + tmp___1) = first___0;
#line 1666
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1667
        first___0.start = 2147483647;
#line 1668
        read___0->one.start = 2147483647;
      } else {
#line 1670
        if (! (first___0.start == tmp.start)) {
          {
#line 1670
          __assert_fail("first.start==tmp.start", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                        1670U, "read_and_sort_postings");
          }
        }
#line 1671
        if (first___0.end == tmp.end) {
#line 1673
          first___0.start = 2147483647;
#line 1674
          read___0->one.start = 2147483647;
        }
      }
    }
    {
#line 1678
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1678
      if (length == size) {
        {
#line 1678
        size += size / 2;
#line 1678
        tmp___2 = sgrep_debug_realloc(sgrep___0, (void *)array, sizeof(Region ) * (unsigned long )size);
#line 1678
        array = (Region *)tmp___2;
        }
      }
#line 1678
      tmp___3 = length;
#line 1678
      length ++;
#line 1678
      *(array + tmp___3) = tmp;
#line 1678
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1680
  delete_map_buffer(sgrep___0, map_buffer);
  }
#line 1683
  if (length == 0) {
#line 1684
    (ls->stop_words) ++;
#line 1685
    return;
  }
#line 1688
  if (first___0.start != 2147483647) {
    {
#line 1689
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1689
      if (length == size) {
        {
#line 1689
        size += size / 2;
#line 1689
        tmp___5 = sgrep_debug_realloc(sgrep___0, (void *)array, sizeof(Region ) * (unsigned long )size);
#line 1689
        array = (Region *)tmp___5;
        }
      }
#line 1689
      tmp___6 = length;
#line 1689
      length ++;
#line 1689
      *(array + tmp___6) = first___0;
#line 1689
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1690
    read___0->one.start = 2147483647;
  }
#line 1693
  if (length == 1) {
#line 1694
    read___0->one = tmp;
#line 1695
    return;
  }
#line 1698
  read___0->saved_array = array;
#line 1699
  read___0->saved_size = size;
#line 1714
  i___0 = 0;
  {
#line 1714
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1714
    if (! (1 << i___0 < length)) {
#line 1714
      goto while_break___3;
    }
#line 1714
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1715
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1715
    if (! (read___0->sizes[i___0] > 0)) {
#line 1715
      goto while_break___4;
    }
    {
#line 1717
    merged = (Region *)((void *)0);
#line 1720
    (read___0->lists_merged) ++;
#line 1721
    read___0->regions_merged += length + read___0->sizes[i___0];
#line 1723
    merged = merge_regions(sgrep___0, (int const   )length, (Region const   *)array,
                           (int const   )read___0->sizes[i___0], (Region const   *)read___0->regions[i___0],
                           & merged_length);
    }
#line 1729
    if ((unsigned long )array != (unsigned long )read___0->saved_array) {
      {
#line 1730
      sgrep_debug_free(sgrep___0, (void *)array);
#line 1731
      array = (Region *)((void *)0);
      }
    }
    {
#line 1733
    sgrep_debug_free(sgrep___0, (void *)read___0->regions[i___0]);
#line 1735
    read___0->regions[i___0] = (Region *)((void *)0);
#line 1736
    read___0->sizes[i___0] = 0;
#line 1739
    array = merged;
#line 1740
    length = merged_length;
    }
#line 1741
    if (1 << i___0 < length) {
#line 1741
      i___0 ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1744
  if ((unsigned long )array == (unsigned long )read___0->saved_array) {
    {
#line 1746
    asize = (unsigned long )length * sizeof(Region );
#line 1747
    tmp___7 = sgrep_debug_malloc(sgrep___0, asize, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                                 1747);
#line 1747
    new_array = (Region *)tmp___7;
#line 1748
    memcpy((void */* __restrict  */)new_array, (void const   */* __restrict  */)array,
           asize);
#line 1749
    array = new_array;
    }
  }
#line 1753
  read___0->regions[i___0] = array;
#line 1754
  read___0->sizes[i___0] = length;
#line 1756
  if (i___0 > read___0->max) {
#line 1756
    read___0->max = i___0;
  }
  {
#line 1766
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1766
    if (! (read___0->dots < read___0->regions_merged)) {
#line 1766
      goto while_break___5;
    }
    {
#line 1767
    sgrep_progress(sgrep___0, (char *)".");
#line 1768
    read___0->dots += 1 << 17;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1770
  return;
}
}
#line 1772 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int dump_entries(char const   *begin , char const   *end , IndexReader *map , FILE *stream ) 
{ 
  int hits ;
  struct LookupStruct ls ;
  SgrepData *sgrep___0 ;

  {
  {
#line 1776
  sgrep___0 = map->sgrep;
#line 1778
  ls.sgrep = sgrep___0;
#line 1779
  ls.begin = begin;
#line 1780
  ls.end = end;
#line 1781
  ls.map = map;
#line 1782
  ls.callback = & dump_entry;
#line 1783
  ls.data.stream = stream;
#line 1785
  hits = do_recursive_lookup(& ls, 0, map->len, "");
#line 1786
  sgrep_error(sgrep___0, (char *)"%d entries\n", hits);
  }
#line 1787
  return (hits);
}
}
#line 1790 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexReader *new_index_reader(SgrepData *sgrep___0 , char const   *filename ) 
{ 
  IndexReader *imap ;
  unsigned char const   *ptr ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1794
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(IndexReader ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                           1794);
#line 1794
  imap = (IndexReader *)tmp;
#line 1795
  imap->sgrep = sgrep___0;
#line 1796
  imap->filename = filename;
#line 1797
  imap->size = map_file(sgrep___0, filename, & imap->map);
  }
#line 1798
  if (imap->size == 0UL) {
#line 1798
    goto error;
  }
#line 1799
  if (imap->size <= 1024UL) {
    {
#line 1800
    sgrep_error(sgrep___0, (char *)"Too short index file \'%s\'", filename);
    }
#line 1801
    goto error;
  }
  {
#line 1804
  ptr = (unsigned char const   *)imap->map;
#line 1805
  tmp___0 = strlen("sgrep-index v0");
#line 1805
  tmp___1 = strncmp((char const   *)ptr, "sgrep-index v0", tmp___0);
  }
#line 1805
  if (tmp___1 != 0) {
    {
#line 1807
    sgrep_error(sgrep___0, (char *)"File \'%s\' is not an sgrep index.\n", filename);
    }
#line 1808
    goto error;
  }
  {
#line 1810
  ptr += 512;
#line 1811
  imap->len = get_int(ptr, 0);
#line 1812
  tmp___2 = get_int(ptr, 1);
#line 1812
  imap->array = (unsigned char const   *)imap->map + tmp___2;
#line 1813
  tmp___3 = get_int(ptr, 2);
#line 1813
  imap->entries = (void const   *)((char const   *)imap->map + tmp___3);
#line 1816
  sgrep_progress(sgrep___0, (char *)"Using index \'%s\' of %dK size containing %d terms\n",
                 imap->filename, imap->size / 1024UL, imap->len);
  }
#line 1818
  return (imap);
  error: 
#line 1821
  if (imap->map) {
    {
#line 1821
    unmap_file(sgrep___0, imap->map, imap->size);
    }
  }
  {
#line 1822
  sgrep_debug_free(sgrep___0, (void *)imap);
  }
#line 1823
  return ((IndexReader *)((void *)0));
}
}
#line 1826 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
FileList *index_file_list(IndexReader *imap ) 
{ 
  int file_list_start ;
  SgrepData *sgrep___0 ;
  unsigned char const   *flist_ptr ;
  int files ;
  int i___0 ;
  int l ;
  int size ;
  char const   *name ;
  FileList *file_list ;

  {
  {
#line 1828
  sgrep___0 = imap->sgrep;
#line 1830
  file_list_start = get_int((unsigned char const   *)imap->map + 512, 3);
  }
#line 1832
  if (file_list_start) {
    {
#line 1842
    file_list = new_flist(sgrep___0);
#line 1843
    flist_ptr = (unsigned char const   *)imap->map + file_list_start;
#line 1845
    files = get_int(flist_ptr, 0);
#line 1847
    i___0 = 0;
    }
    {
#line 1847
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1847
      if (! (i___0 < files)) {
#line 1847
        goto while_break;
      }
      {
#line 1848
      flist_ptr += 4;
#line 1849
      l = get_int(flist_ptr, 0);
#line 1850
      flist_ptr += 4;
#line 1851
      name = (char const   *)flist_ptr;
#line 1852
      flist_ptr += l + 1;
#line 1853
      size = get_int(flist_ptr, 0);
#line 1855
      flist_add_known(file_list, name, size);
#line 1847
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1857
    flist_ready(file_list);
    }
#line 1858
    return (file_list);
  } else {
#line 1859
    return ((FileList *)((void *)0));
  }
}
}
#line 1863 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void delete_index_reader(IndexReader *reader ) 
{ 
  SgrepData *sgrep___0 ;

  {
  {
#line 1864
  sgrep___0 = reader->sgrep;
#line 1865
  unmap_file(sgrep___0, reader->map, reader->size);
#line 1866
  sgrep_debug_free(sgrep___0, (void *)reader);
  }
#line 1867
  return;
}
}
#line 1870 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void set_default_index_options(SgrepData *sgrep___0 , IndexOptions *o ) 
{ 


  {
#line 1871
  *o = (IndexOptions )default_index_options;
#line 1872
  o->sgrep = sgrep___0;
#line 1873
  return;
}
}
#line 1879 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
RegionList *index_lookup_sorting(IndexReader *map , char const   *term , struct LookupStruct *ls ,
                                 int *return_hits ) 
{ 
  struct SortingReaderStruct *reader ;
  Region *current ;
  int len ;
  RegionList *result ;
  int i___0 ;
  SgrepData *sgrep___0 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Region *new_current ;

  {
  {
#line 1882
  reader = & ls->data.sorting_reader;
#line 1887
  sgrep___0 = map->sgrep;
#line 1890
  ls->callback = & read_and_sort_postings;
#line 1891
  reader->max = 0;
#line 1892
  reader->regions_merged = 0;
#line 1893
  reader->lists_merged = 0;
#line 1894
  tmp = 2147483647;
#line 1894
  reader->one.end = tmp;
#line 1894
  reader->one.start = tmp;
#line 1896
  memset((void *)(& reader->sizes), 0, sizeof(reader->sizes));
#line 1897
  memset((void *)(& reader->regions), 0, sizeof(reader->regions));
#line 1898
  reader->saved_size = 1 << 7;
#line 1899
  tmp___0 = sgrep_debug_malloc(sgrep___0, sizeof(Region ) * (unsigned long )reader->saved_size,
                               "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                               1900);
#line 1899
  reader->saved_array = (Region *)tmp___0;
#line 1901
  reader->dots = 0;
#line 1904
  *return_hits = do_recursive_lookup(ls, 0, map->len, "");
#line 1906
  sgrep_debug_free(sgrep___0, (void *)reader->saved_array);
  }
#line 1909
  if (reader->one.start != 2147483647) {
    {
#line 1910
    tmp___1 = sgrep_debug_malloc(sgrep___0, sizeof(Region ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                                 1910);
#line 1910
    current = (Region *)tmp___1;
#line 1911
    *(current + 0) = reader->one;
#line 1912
    len = 1;
    }
  } else {
#line 1914
    current = (Region *)((void *)0);
#line 1915
    len = 0;
  }
#line 1921
  i___0 = 0;
  {
#line 1921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1921
    if (! (i___0 <= reader->max)) {
#line 1921
      goto while_break;
    }
#line 1922
    if (reader->sizes[i___0]) {
#line 1923
      if (current) {
        {
#line 1926
        (reader->lists_merged) ++;
#line 1927
        reader->regions_merged += len + reader->sizes[i___0];
#line 1928
        new_current = merge_regions(sgrep___0, (int const   )len, (Region const   *)current,
                                    (int const   )reader->sizes[i___0], (Region const   *)reader->regions[i___0],
                                    & len);
#line 1932
        sgrep_debug_free(sgrep___0, (void *)current);
#line 1933
        sgrep_debug_free(sgrep___0, (void *)reader->regions[i___0]);
#line 1934
        current = new_current;
        }
        {
#line 1935
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1935
          if (! (reader->dots < reader->regions_merged)) {
#line 1935
            goto while_break___0;
          }
          {
#line 1936
          sgrep_progress(sgrep___0, (char *)".");
#line 1937
          reader->dots += 1 << 17;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 1940
        current = reader->regions[i___0];
#line 1941
        len = reader->sizes[i___0];
      }
    }
#line 1921
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1947
  result = new_region_list(sgrep___0);
#line 1948
  result->nested = 1;
#line 1949
  (reader->lists_merged) ++;
#line 1950
  reader->regions_merged += len;
#line 1952
  i___0 = 0;
  }
  {
#line 1952
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1952
    if (! (i___0 < len)) {
#line 1952
      goto while_break___1;
    }
    {
#line 1953
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1953
      check_add_region((RegionList const   *)result, (current + i___0)->start, (current + i___0)->end);
      }
      {
#line 1953
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1953
        if (result->length == 1 << 7) {
          {
#line 1953
          insert_list_node(result);
          }
        }
#line 1953
        (result->last)->list[result->length].start = (current + i___0)->start;
#line 1953
        (result->last)->list[result->length].end = (current + i___0)->end;
#line 1953
        (result->length) ++;
#line 1953
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1953
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1952
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1955
  if (current) {
    {
#line 1955
    sgrep_debug_free(sgrep___0, (void *)current);
    }
  }
#line 1960
  return (result);
}
}
#line 1967 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
RegionList *index_lookup(IndexReader *map , char const   *term ) 
{ 
  int hits ;
  struct LookupStruct ls ;
  RegionList *l ;
  SgrepData *sgrep___0 ;
  SgrepString *s ;
  SgrepString *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1971
  sgrep___0 = map->sgrep;
#line 1974
  ls.sgrep = sgrep___0;
#line 1975
  ls.map = map;
#line 1976
  ls.stop_words = 0;
#line 1978
  if (sgrep___0->progress_output) {
    {
#line 1979
    tmp = new_string(sgrep___0, (size_t )256);
#line 1979
    s = tmp;
#line 1980
    string_cat_escaped(s, term);
#line 1981
    *(s->s + s->length) = (char)0;
#line 1981
    sgrep_progress(sgrep___0, (char *)"Looking up \'%s\'..", (char const   *)s->s);
#line 1982
    delete_string(s);
    }
  }
  {
#line 1985
  tmp___2 = strlen(term);
  }
#line 1985
  if ((int const   )*(term + (tmp___2 - 1UL)) == 42) {
    {
#line 1986
    tmp___0 = (char *)((void *)0);
#line 1987
    tmp___0 = sgrep_debug_strdup(sgrep___0, term, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                                 1987);
#line 1988
    tmp___1 = strlen((char const   *)tmp___0);
#line 1988
    *(tmp___0 + (tmp___1 - 1UL)) = (char)0;
#line 1989
    ls.end = (char const   *)tmp___0;
#line 1989
    ls.begin = ls.end;
#line 1992
    l = index_lookup_sorting(map, term, & ls, & hits);
#line 2005
    sgrep_debug_free(sgrep___0, (void *)tmp___0);
#line 2006
    ls.begin = (char const   *)((void *)0);
#line 2007
    ls.end = (char const   *)((void *)0);
    }
  } else {
    {
#line 2009
    l = new_region_list(sgrep___0);
    }
#line 2010
    if ((int const   )*(term + 0) == 64) {
#line 2011
      l->nested = 1;
    } else {
#line 2013
      l->nested = 0;
    }
    {
#line 2015
    ls.data.reader = l;
#line 2016
    ls.begin = term;
#line 2017
    ls.end = (char const   *)((void *)0);
#line 2018
    ls.callback = & read_unsorted_postings;
#line 2020
    hits = do_recursive_lookup(& ls, 0, map->len, "");
    }
  }
#line 2024
  if ((l->nodes - 1) * (1 << 7) + l->length > 0) {
#line 2025
    if (ls.stop_words == 0) {
      {
#line 2026
      sgrep_progress(sgrep___0, (char *)" %d/%d hits/postings found.", hits, (l->nodes - 1) * (1 << 7) + l->length);
      }
    } else {
      {
#line 2029
      sgrep_progress(sgrep___0, (char *)" %d/%d hits/postings (%d stopwords) found.",
                     hits, (l->nodes - 1) * (1 << 7) + l->length, ls.stop_words);
      }
    }
  } else
#line 2033
  if (ls.stop_words == 0) {
    {
#line 2034
    sgrep_progress(sgrep___0, (char *)" not found.");
    }
  } else {
    {
#line 2036
    sgrep_progress(sgrep___0, (char *)" stopword.");
    }
  }
#line 2041
  if (hits > 1) {
#line 2041
    if ((unsigned int )l->sorted != 1U) {
      {
#line 2042
      sgrep_progress(sgrep___0, (char *)" sorting..");
#line 2043
      remove_duplicates(l);
#line 2044
      sgrep_progress(sgrep___0, (char *)" done.");
      }
    } else {
      {
#line 2046
      list_set_sorted(l, (enum RegionListSorted )1);
      }
    }
  } else {
    {
#line 2046
    list_set_sorted(l, (enum RegionListSorted )1);
    }
  }
  {
#line 2050
  sgrep_progress(sgrep___0, (char *)"\n");
  }
#line 2051
  return (l);
}
}
#line 2054 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void add_to_entry_list(char const   *entry , unsigned char const   *regions , struct LookupStruct *ls ) 
{ 
  struct IndexEntryStruct *n ;
  IndexEntryList *list ;
  SgrepData *sgrep___0 ;
  void *tmp ;

  {
  {
#line 2057
  list = ls->data.entry_list;
#line 2058
  sgrep___0 = ls->sgrep;
#line 2060
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(IndexEntry ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                           2060);
#line 2060
  n = (IndexEntry *)tmp;
#line 2061
  n->term = sgrep_debug_strdup(sgrep___0, entry, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                               2061);
#line 2062
  n->postings = regions;
#line 2063
  n->next = (struct IndexEntryStruct *)((void *)0);
  }
#line 2064
  if (list->last) {
#line 2065
    (list->last)->next = n;
  } else {
#line 2067
    list->first = n;
  }
#line 2069
  list->last = n;
#line 2070
  return;
}
}
#line 2072 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexEntryList *index_term_lookup(IndexReader *reader , char const   *first_prefix ,
                                  char const   *last_prefix ) 
{ 
  IndexEntryList *n ;
  struct LookupStruct ls ;
  SgrepData *sgrep___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 2077
  sgrep___0 = reader->sgrep;
#line 2079
  ls.sgrep = sgrep___0;
#line 2080
  if ((unsigned long )reader != (unsigned long )((void *)0)) {
#line 2080
    if ((unsigned long )first_prefix != (unsigned long )((void *)0)) {
#line 2080
      if (! ((unsigned long )last_prefix == (unsigned long )((void *)0))) {
        {
#line 2080
        tmp = strcmp(first_prefix, last_prefix);
        }
#line 2080
        if (! (tmp <= 0)) {
          {
#line 2080
          __assert_fail("reader!=((void *)0) && first_prefix!=((void *)0) && (last_prefix==((void *)0) || strcmp(first_prefix,last_prefix)<=0)",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                        2081U, "index_term_lookup");
          }
        }
      }
    } else {
      {
#line 2080
      __assert_fail("reader!=((void *)0) && first_prefix!=((void *)0) && (last_prefix==((void *)0) || strcmp(first_prefix,last_prefix)<=0)",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                    2081U, "index_term_lookup");
      }
    }
  } else {
    {
#line 2080
    __assert_fail("reader!=((void *)0) && first_prefix!=((void *)0) && (last_prefix==((void *)0) || strcmp(first_prefix,last_prefix)<=0)",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                  2081U, "index_term_lookup");
    }
  }
  {
#line 2083
  tmp___0 = sgrep_debug_malloc(sgrep___0, sizeof(IndexEntryList ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c",
                               2083);
#line 2083
  n = (IndexEntryList *)tmp___0;
#line 2084
  n->reader = reader;
#line 2085
  n->first = (IndexEntry *)((void *)0);
#line 2086
  n->last = (IndexEntry *)((void *)0);
#line 2088
  ls.begin = first_prefix;
#line 2089
  ls.end = last_prefix;
#line 2090
  ls.map = reader;
#line 2091
  ls.callback = & add_to_entry_list;
#line 2092
  ls.data.entry_list = n;
#line 2094
  n->hits = do_recursive_lookup(& ls, 0, reader->len, "");
  }
#line 2096
  return (n);
}
}
#line 2098 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexEntry *index_first_entry(IndexEntryList *l ) 
{ 


  {
#line 2099
  return (l->first);
}
}
#line 2101 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
IndexEntry *index_next_entry(IndexEntry *e ) 
{ 


  {
#line 2102
  return (e->next);
}
}
#line 2104 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
char const   *index_entry_term(IndexEntry *e ) 
{ 


  {
#line 2105
  return ((char const   *)e->term);
}
}
#line 2108 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int index_list_size(IndexEntryList *l ) 
{ 


  {
#line 2109
  return (l->hits);
}
}
#line 2112 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
void delete_index_entry_list(IndexEntryList *l ) 
{ 
  IndexEntry *e ;
  IndexEntry *t ;
  SgrepData *sgrep___0 ;

  {
#line 2114
  sgrep___0 = (l->reader)->sgrep;
#line 2115
  e = l->first;
  {
#line 2116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2116
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 2116
      goto while_break;
    }
    {
#line 2117
    t = e;
#line 2118
    e = e->next;
#line 2119
    sgrep_debug_free(sgrep___0, (void *)t->term);
#line 2120
    sgrep_debug_free(sgrep___0, (void *)t);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2122
  l->first = (IndexEntry *)((void *)0);
#line 2123
  l->last = (IndexEntry *)((void *)0);
#line 2124
  l->hits = -1;
#line 2125
  sgrep_debug_free(sgrep___0, (void *)l);
  }
#line 2126
  return;
}
}
#line 2128 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index.c"
int index_query(IndexOptions *options , int argc , char **argv ) 
{ 
  IndexReader *reader ;
  SgrepData *sgrep___0 ;
  IndexEntryList *list ;
  IndexEntry *entry ;
  SgrepString *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2130
  sgrep___0 = options->sgrep;
#line 2132
  reader = new_index_reader(sgrep___0, (char const   *)sgrep___0->index_file);
  }
#line 2133
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
    {
#line 2134
    sgrep_error(sgrep___0, (char *)"No index to query. Bailing out\n");
    }
#line 2135
    goto error;
  }
  {
#line 2139
  if ((unsigned int )options->index_mode == 2U) {
#line 2139
    goto case_2;
  }
#line 2163
  goto switch_default;
  case_2: /* CIL Label */ 
#line 2144
  if (argc == 0) {
    {
#line 2145
    sgrep_error(sgrep___0, (char *)"Usage -x index -q terms start_term [end_term]\n");
    }
#line 2146
    goto error;
  } else
#line 2144
  if (argc > 2) {
    {
#line 2145
    sgrep_error(sgrep___0, (char *)"Usage -x index -q terms start_term [end_term]\n");
    }
#line 2146
    goto error;
  }
  {
#line 2148
  list = index_term_lookup(reader, (char const   *)*(argv + 0), (char const   *)*(argv + 1));
  }
#line 2149
  if (! list) {
#line 2149
    goto error;
  }
  {
#line 2151
  tmp = new_string(sgrep___0, (size_t )256);
#line 2152
  entry = index_first_entry(list);
  }
  {
#line 2153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2153
    if (! entry) {
#line 2153
      goto while_break;
    }
    {
#line 2154
    tmp->length = (size_t )0;
#line 2155
    tmp___0 = index_entry_term(entry);
#line 2155
    string_cat_escaped(tmp, tmp___0);
#line 2156
    *(tmp->s + tmp->length) = (char)0;
#line 2156
    printf((char const   */* __restrict  */)"%s\n", (char const   *)tmp->s);
#line 2157
    entry = index_next_entry(entry);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2159
  delete_index_entry_list(list);
#line 2160
  delete_string(tmp);
  }
#line 2161
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2164
  sgrep_error(sgrep___0, (char *)"index_query: got unknown index mode %d\n", (unsigned int )options->index_mode);
  }
#line 2166
  goto error;
  switch_break: /* CIL Label */ ;
  }
#line 2169
  if (reader) {
    {
#line 2169
    delete_index_reader(reader);
    }
  }
#line 2170
  return (0);
  error: 
#line 2173
  if (reader) {
    {
#line 2173
    delete_index_reader(reader);
    }
  }
#line 2174
  return (-1);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
SGMLScanner *new_sgml_phrase_scanner(SgrepData *sgrep___0 , FileList *file_list ,
                                     struct PHRASE_NODE *list ) ;
#line 636
SGMLScanner *new_sgml_index_scanner(SgrepData *sgrep___0 , FileList *file_list , struct IndexWriterStruct *writer ) ;
#line 639
int sgml_scan(SGMLScanner *scanner , unsigned char const   *buf , int len , int start ,
              int file_num ) ;
#line 644
void sgml_flush(SGMLScanner *sgmls ) ;
#line 645
void delete_sgml_scanner(SGMLScanner *s ) ;
#line 214 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
char const   *XML_BaseChar  =    "\\#x0041-\\#x005A\\#x0061-\\#x007A\\#x00C0-\\#x00D6\\#x00D8-\\#x00F6\\#x00F8-\\#x00FF\\#x0100-\\#x0131\\#x0134-\\#x013E\\#x0141-\\#x0148\\#x014A-\\#x017E\\#x0180-\\#x01C3\\#x01CD-\\#x01F0\\#x01F4-\\#x01F5\\#x01FA-\\#x0217\\#x0250-\\#x02A8\\#x02BB-\\#x02C1\\#x0386\\#x0388-\\#x038A\\#x038C\\#x038E-\\#x03A1\\#x03A3-\\#x03CE\\#x03D0-\\#x03D6\\#x03DA\\#x03DC\\#x03DE\\#x03E0\\#x03E2-\\#x03F3\\#x0401-\\#x040C\\#x040E-\\#x044F\\#x0451-\\#x045C\\#x045E-\\#x0481\\#x0490-\\#x04C4\\#x04C7-\\#x04C8\\#x04CB-\\#x04CC\\#x04D0-\\#x04EB\\#x04EE-\\#x04F5\\#x04F8-\\#x04F9\\#x0531-\\#x0556\\#x0559\\#x0561-\\#x0586\\#x05D0-\\#x05EA\\#x05F0-\\#x05F2\\#x0621-\\#x063A\\#x0641-\\#x064A\\#x0671-\\#x06B7\\#x06BA-\\#x06BE\\#x06C0-\\#x06CE\\#x06D0-\\#x06D3\\#x06D5\\#x06E5-\\#x06E6\\#x0905-\\#x0939\\#x093D\\#x0958-\\#x0961\\#x0985-\\#x098C\\#x098F-\\#x0990\\#x0993-\\#x09A8\\#x09AA-\\#x09B0\\#x09B2\\#x09B6-\\#x09B9\\#x09DC-\\#x09DD\\#x09DF-\\#x09E1\\#x09F0-\\#x09F1\\#x0A05-\\#x0A0A\\#x0A0F-\\#x0A10\\#x0A13-\\#x0A28\\#x0A2A-\\#x0A30\\#x0A32-\\#x0A33\\#x0A35-\\#x0A36\\#x0A38-\\#x0A39\\#x0A59-\\#x0A5C\\#x0A5E\\#x0A72-\\#x0A74\\#x0A85-\\#x0A8B\\#x0A8D\\#x0A8F-\\#x0A91\\#x0A93-\\#x0AA8\\#x0AAA-\\#x0AB0\\#x0AB2-\\#x0AB3\\#x0AB5-\\#x0AB9\\#x0ABD\\#x0AE0\\#x0B05-\\#x0B0C\\#x0B0F-\\#x0B10\\#x0B13-\\#x0B28\\#x0B2A-\\#x0B30\\#x0B32-\\#x0B33\\#x0B36-\\#x0B39\\#x0B3D\\#x0B5C-\\#x0B5D\\#x0B5F-\\#x0B61\\#x0B85-\\#x0B8A\\#x0B8E-\\#x0B90\\#x0B92-\\#x0B95\\#x0B99-\\#x0B9A\\#x0B9C\\#x0B9E-\\#x0B9F\\#x0BA3-\\#x0BA4\\#x0BA8-\\#x0BAA\\#x0BAE-\\#x0BB5\\#x0BB7-\\#x0BB9\\#x0C05-\\#x0C0C\\#x0C0E-\\#x0C10\\#x0C12-\\#x0C28\\#x0C2A-\\#x0C33\\#x0C35-\\#x0C39\\#x0C60-\\#x0C61\\#x0C85-\\#x0C8C\\#x0C8E-\\#x0C90\\#x0C92-\\#x0CA8\\#x0CAA-\\#x0CB3\\#x0CB5-\\#x0CB9\\#x0CDE\\#x0CE0-\\#x0CE1\\#x0D05-\\#x0D0C\\#x0D0E-\\#x0D10\\#x0D12-\\#x0D28\\#x0D2A-\\#x0D39\\#x0D60-\\#x0D61\\#x0E01-\\#x0E2E\\#x0E30\\#x0E32-\\#x0E33\\#x0E40-\\#x0E45\\#x0E81-\\#x0E82\\#x0E84\\#x0E87-\\#x0E88\\#x0E8A\\#x0E8D\\#x0E94-\\#x0E97\\#x0E99-\\#x0E9F\\#x0EA1-\\#x0EA3\\#x0EA5\\#x0EA7\\#x0EAA-\\#x0EAB\\#x0EAD-\\#x0EAE\\#x0EB0\\#x0EB2-\\#x0EB3\\#x0EBD\\#x0EC0-\\#x0EC4\\#x0F40-\\#x0F47\\#x0F49-\\#x0F69\\#x10A0-\\#x10C5\\#x10D0-\\#x10F6\\#x1100\\#x1102-\\#x1103\\#x1105-\\#x1107\\#x1109\\#x110B-\\#x110C\\#x110E-\\#x1112\\#x113C\\#x113E\\#x1140\\#x114C\\#x114E\\#x1150\\#x1154-\\#x1155\\#x1159\\#x115F-\\#x1161\\#x1163\\#x1165\\#x1167\\#x1169\\#x116D-\\#x116E\\#x1172-\\#x1173\\#x1175\\#x119E\\#x11A8\\#x11AB\\#x11AE-\\#x11AF\\#x11B7-\\#x11B8\\#x11BA\\#x11BC-\\#x11C2\\#x11EB\\#x11F0\\#x11F9\\#x1E00-\\#x1E9B\\#x1EA0-\\#x1EF9\\#x1F00-\\#x1F15\\#x1F18-\\#x1F1D\\#x1F20-\\#x1F45\\#x1F48-\\#x1F4D\\#x1F50-\\#x1F57\\#x1F59\\#x1F5B\\#x1F5D\\#x1F5F-\\#x1F7D\\#x1F80-\\#x1FB4\\#x1FB6-\\#x1FBC\\#x1FBE\\#x1FC2-\\#x1FC4\\#x1FC6-\\#x1FCC\\#x1FD0-\\#x1FD3\\#x1FD6-\\#x1FDB\\#x1FE0-\\#x1FEC\\#x1FF2-\\#x1FF4\\#x1FF6-\\#x1FFC\\#x2126\\#x212A-\\#x212B\\#x212E\\#x2180-\\#x2182\\#x3041-\\#x3094\\#x30A1-\\#x30FA\\#x3105-\\#x312C\\#xAC00-\\#xD7A3";
#line 272 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
char const   *XML_Ideographic  =    "\\#x4E00-\\#x9FA5\\#x3007\\#x3021-\\#x3029";
#line 276 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
char const   *XML_CombiningChar  =    "\\#x0300-\\#x0345\\#x0360-\\#x0361\\#x0483-\\#x0486\\#x0591-\\#x05A1\\#x05A3-\\#x05B9\\#x05BB-\\#x05BD\\#x05BF\\#x05C1-\\#x05C2\\#x05C4\\#x064B-\\#x0652\\#x0670\\#x06D6-\\#x06DC\\#x06DD-\\#x06DF\\#x06E0-\\#x06E4\\#x06E7-\\#x06E8\\#x06EA-\\#x06ED\\#x0901-\\#x0903\\#x093C\\#x093E-\\#x094C\\#x094D\\#x0951-\\#x0954\\#x0962-\\#x0963\\#x0981-\\#x0983\\#x09BC\\#x09BE\\#x09BF\\#x09C0-\\#x09C4\\#x09C7-\\#x09C8\\#x09CB-\\#x09CD\\#x09D7\\#x09E2-\\#x09E3\\#x0A02\\#x0A3C\\#x0A3E\\#x0A3F\\#x0A40-\\#x0A42\\#x0A47-\\#x0A48\\#x0A4B-\\#x0A4D\\#x0A70-\\#x0A71\\#x0A81-\\#x0A83\\#x0ABC\\#x0ABE-\\#x0AC5\\#x0AC7-\\#x0AC9\\#x0ACB-\\#x0ACD\\#x0B01-\\#x0B03\\#x0B3C\\#x0B3E-\\#x0B43\\#x0B47-\\#x0B48\\#x0B4B-\\#x0B4D\\#x0B56-\\#x0B57\\#x0B82-\\#x0B83\\#x0BBE-\\#x0BC2\\#x0BC6-\\#x0BC8\\#x0BCA-\\#x0BCD\\#x0BD7\\#x0C01-\\#x0C03\\#x0C3E-\\#x0C44\\#x0C46-\\#x0C48\\#x0C4A-\\#x0C4D\\#x0C55-\\#x0C56\\#x0C82-\\#x0C83\\#x0CBE-\\#x0CC4\\#x0CC6-\\#x0CC8\\#x0CCA-\\#x0CCD\\#x0CD5-\\#x0CD6\\#x0D02-\\#x0D03\\#x0D3E-\\#x0D43\\#x0D46-\\#x0D48\\#x0D4A-\\#x0D4D\\#x0D57\\#x0E31\\#x0E34-\\#x0E3A\\#x0E47-\\#x0E4E\\#x0EB1\\#x0EB4-\\#x0EB9\\#x0EBB-\\#x0EBC\\#x0EC8-\\#x0ECD\\#x0F18-\\#x0F19\\#x0F35\\#x0F37\\#x0F39\\#x0F3E\\#x0F3F\\#x0F71-\\#x0F84\\#x0F86-\\#x0F8B\\#x0F90-\\#x0F95\\#x0F97\\#x0F99-\\#x0FAD\\#x0FB1-\\#x0FB7\\#x0FB9\\#x20D0-\\#x20DC\\#x20E1\\#x302A-\\#x302F\\#x3099\\#x309A";
#line 304 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
char const   *XML_Digit  =    "\\#x0030-\\#x0039\\#x0660-\\#x0669\\#x06F0-\\#x06F9\\#x0966-\\#x096F\\#x09E6-\\#x09EF\\#x0A66-\\#x0A6F\\#x0AE6-\\#x0AEF\\#x0B66-\\#x0B6F\\#x0BE7-\\#x0BEF\\#x0C66-\\#x0C6F\\#x0CE6-\\#x0CEF\\#x0D66-\\#x0D6F\\#x0E50-\\#x0E59\\#x0ED0-\\#x0ED9\\#x0F20-\\#x0F29";
#line 312 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
char const   *XML_Extender  =    "\\#x00B7\\#x02D0\\#x02D1\\#x0387\\#x0640\\#x0E46\\#x0EC6\\#x3005\\#x3031-\\#x3035\\#x309D-\\#x309E\\#x30FC-\\#x30FE";
#line 320 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
CharacterList *new_character_list(SgrepData *sgrep___0 ) 
{ 
  CharacterList *a ;
  void *tmp ;

  {
  {
#line 322
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(CharacterList ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                           322);
#line 322
  a = (CharacterList *)tmp;
#line 323
  memset((void *)a, 0, sizeof(CharacterList ));
#line 324
  a->sgrep = sgrep___0;
  }
#line 325
  return (a);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void character_list_add(CharacterList *a , char const   *l ) 
{ 
  int i___0 ;
  unsigned char const   *list ;
  int previous ;
  int expand_from ;
  int current ;
  SgrepData *sgrep___0 ;
  int j ;

  {
#line 333
  list = (unsigned char const   *)l;
#line 337
  sgrep___0 = a->sgrep;
#line 339
  previous = -1;
#line 340
  expand_from = -1;
#line 341
  i___0 = 0;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! *(list + i___0)) {
#line 342
      goto while_break;
    }
#line 343
    current = (int )*(list + i___0);
#line 344
    i___0 ++;
#line 345
    if (current == 92) {
#line 346
      if ((int const   )*(list + i___0) == 45) {
#line 348
        i___0 ++;
#line 349
        current = '-';
      } else {
        {
#line 351
        current = expand_backslash_escape(sgrep___0, list, & i___0);
        }
      }
    } else
#line 353
    if (current == 45) {
#line 353
      if (i___0 > 1) {
#line 353
        if (expand_from == -1) {
#line 355
          expand_from = previous;
#line 356
          goto while_continue;
        }
      }
    }
#line 359
    if (expand_from >= 0) {
#line 359
      if (current >= 0) {
#line 362
        j = expand_from;
        {
#line 362
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 362
          if (! (j <= current)) {
#line 362
            goto while_break___0;
          }
#line 363
          a->bitmap[(unsigned long )j / sizeof(unsigned long )] |= 1UL << (unsigned long )j % sizeof(unsigned long );
#line 362
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 359
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 365
    if (current >= 0) {
#line 366
      a->bitmap[(unsigned long )current / sizeof(unsigned long )] |= 1UL << (unsigned long )current % sizeof(unsigned long );
    }
#line 368
    expand_from = -1;
#line 369
    previous = current;
#line 370
    current = -1;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  if (expand_from >= 0) {
    {
#line 373
    sgrep_error(sgrep___0, (char *)"Character list \'%s\' contains a region with no endpoint\n",
                list);
    }
  }
#line 376
  return;
}
}
#line 378
void pop_elements_to(SGMLScanner *state , struct ElementStackStruct *p ) ;
#line 383 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void sgml_add_entry_to_gclist(SGMLScanner *state , char const   *phrase , int start ,
                              int end ) 
{ 
  struct PHRASE_NODE *n ;
  int tmp ;
  int tmp___0 ;

  {
#line 386
  n = state->phrase_list;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! ((unsigned long )n != (unsigned long )((void *)0))) {
#line 386
      goto while_break;
    }
#line 387
    if ((int )*((n->phrase)->s + ((n->phrase)->length - 1UL)) == 42) {
      {
#line 389
      tmp = strncmp((char const   *)(n->phrase)->s, phrase, (n->phrase)->length - 1UL);
      }
#line 389
      if (tmp == 0) {
        {
#line 390
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 390
          check_add_region((RegionList const   *)n->regions, start, end);
          }
          {
#line 390
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 390
            if ((n->regions)->length == 1 << 7) {
              {
#line 390
              insert_list_node(n->regions);
              }
            }
#line 390
            ((n->regions)->last)->list[(n->regions)->length].start = start;
#line 390
            ((n->regions)->last)->list[(n->regions)->length].end = end;
#line 390
            ((n->regions)->length) ++;
#line 390
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 390
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 393
      tmp___0 = strcmp((char const   *)(n->phrase)->s, phrase);
      }
#line 393
      if (tmp___0 == 0) {
        {
#line 394
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 394
          check_add_region((RegionList const   *)n->regions, start, end);
          }
          {
#line 394
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 394
            if ((n->regions)->length == 1 << 7) {
              {
#line 394
              insert_list_node(n->regions);
              }
            }
#line 394
            ((n->regions)->last)->list[(n->regions)->length].start = start;
#line 394
            ((n->regions)->last)->list[(n->regions)->length].end = end;
#line 394
            ((n->regions)->length) ++;
#line 394
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 394
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 386
    n = n->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return;
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void sgml_add_entry_to_index(SGMLScanner *state , char const   *phrase , int start ,
                             int end ) 
{ 
  int tmp ;

  {
#line 402
  if ((int const   )*(phrase + 0) == 64) {
    {
#line 403
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 403
      check_add_region((RegionList const   *)state->element_list, start, end);
      }
      {
#line 403
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 403
        if ((state->element_list)->length == 1 << 7) {
          {
#line 403
          insert_list_node(state->element_list);
          }
        }
#line 403
        ((state->element_list)->last)->list[(state->element_list)->length].start = start;
#line 403
        ((state->element_list)->last)->list[(state->element_list)->length].end = end;
#line 403
        ((state->element_list)->length) ++;
#line 403
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 403
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 405
    tmp = add_region_to_index((struct IndexWriterStruct *)state->data, phrase, start,
                              end);
    }
#line 405
    if (tmp == -1) {
#line 407
      state->failed = 1;
    }
  }
#line 410
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void reset_encoder(SGMLScanner *sgmls , Encoder *encoder ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 413
  sgrep___0 = sgmls->sgrep;
  {
#line 416
  if ((unsigned int )sgrep___0->default_encoding == 0U) {
#line 416
    goto case_0;
  }
#line 429
  if ((unsigned int )sgrep___0->default_encoding == 1U) {
#line 429
    goto case_1___0;
  }
#line 432
  if ((unsigned int )sgrep___0->default_encoding == 2U) {
#line 432
    goto case_2___0;
  }
#line 435
  if ((unsigned int )sgrep___0->default_encoding == 3U) {
#line 435
    goto case_3;
  }
#line 415
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 418
  if ((unsigned int )sgmls->type == 0U) {
#line 418
    goto case_0___0;
  }
#line 421
  if ((unsigned int )sgmls->type == 1U) {
#line 421
    goto case_1;
  }
#line 424
  if ((unsigned int )sgmls->type == 2U) {
#line 424
    goto case_2;
  }
#line 417
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 419
  encoder->estate = (enum EncoderState )0;
#line 420
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 422
  encoder->estate = (enum EncoderState )1;
#line 423
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 425
  encoder->estate = (enum EncoderState )0;
#line 426
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 428
  goto switch_break;
  case_1___0: /* CIL Label */ 
#line 430
  encoder->estate = (enum EncoderState )0;
#line 431
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 433
  encoder->estate = (enum EncoderState )1;
#line 434
  goto switch_break;
  case_3: /* CIL Label */ 
#line 436
  encoder->estate = (enum EncoderState )1;
#line 437
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 439
  encoder->prev = -1;
#line 440
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
SGMLScanner *new_sgml_scanner_common(SgrepData *sgrep___0 , FileList *file_list ) 
{ 
  SGMLScanner *scanner ;
  void *tmp ;

  {
  {
#line 444
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(SGMLScanner ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                           444);
#line 444
  scanner = (SGMLScanner *)tmp;
#line 445
  scanner->sgrep = sgrep___0;
#line 446
  scanner->file_list = file_list;
#line 447
  scanner->file_num = -1;
#line 448
  scanner->state_stack_ptr = 0;
#line 450
  scanner->maintain_element_stack = 1;
#line 451
  scanner->top = (ElementStack *)((void *)0);
#line 452
  scanner->element_list = (RegionList *)((void *)0);
#line 454
  scanner->word_chars = new_character_list(sgrep___0);
  }
  {
#line 456
  if ((unsigned int )sgrep___0->scanner_type == 0U) {
#line 456
    goto case_0;
  }
#line 462
  if ((unsigned int )sgrep___0->scanner_type == 1U) {
#line 462
    goto case_1;
  }
#line 474
  if ((unsigned int )sgrep___0->scanner_type == 2U) {
#line 474
    goto case_2;
  }
#line 455
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 457
  scanner->name_start_chars = new_character_list(sgrep___0);
#line 458
  character_list_add(scanner->name_start_chars, "a-zA-Z_:");
#line 459
  scanner->name_chars = new_character_list(sgrep___0);
#line 460
  character_list_add(scanner->name_chars, "-a-zA-Z0-9._:");
  }
#line 461
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 464
  scanner->name_start_chars = new_character_list(sgrep___0);
#line 465
  character_list_add(scanner->name_start_chars, XML_BaseChar);
#line 466
  character_list_add(scanner->name_start_chars, XML_Ideographic);
#line 467
  character_list_add(scanner->name_start_chars, "a-zA-Z_:");
#line 469
  scanner->name_chars = new_character_list(sgrep___0);
#line 470
  character_list_add(scanner->name_chars, XML_BaseChar);
#line 471
  character_list_add(scanner->name_chars, XML_Ideographic);
#line 472
  character_list_add(scanner->name_chars, "-a-zA-Z0-9._:");
  }
#line 473
  goto switch_break;
  case_2: /* CIL Label */ 
#line 475
  scanner->name_start_chars = (CharacterList *)((void *)0);
#line 476
  scanner->name_chars = (CharacterList *)((void *)0);
#line 477
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 479
  if (sgrep___0->word_chars) {
    {
#line 480
    character_list_add(scanner->word_chars, (char const   *)sgrep___0->word_chars);
    }
  } else {
    {
#line 482
    character_list_add(scanner->word_chars, XML_BaseChar);
#line 483
    character_list_add(scanner->word_chars, XML_Ideographic);
    }
  }
  {
#line 485
  scanner->parse_errors = 0;
#line 487
  scanner->type = sgrep___0->scanner_type;
#line 488
  scanner->ignore_case = sgrep___0->ignore_case;
#line 489
  scanner->include_system_entities = sgrep___0->include_system_entities;
#line 491
  scanner->state = (enum SGMLState )0;
#line 493
  scanner->gi = new_string(sgrep___0, (size_t )256);
#line 494
  scanner->word = new_string(sgrep___0, (size_t )256);
  }
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if ((scanner->word)->length < 256UL) {
      {
#line 495
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 495
        if ((scanner->word)->length < (scanner->word)->size) {
#line 495
          *((scanner->word)->s + (scanner->word)->length) = (char )'w';
#line 495
          ((scanner->word)->length) ++;
        } else {
          {
#line 495
          real_string_push(scanner->word, 'w');
          }
        }
#line 495
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 495
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 496
  scanner->name2 = new_string(sgrep___0, (size_t )256);
#line 497
  scanner->comment_word = new_string(sgrep___0, (size_t )256);
#line 498
  scanner->name = new_string(sgrep___0, (size_t )256);
#line 499
  scanner->literal = new_string(sgrep___0, (size_t )256);
#line 500
  string_cat(scanner->literal, "xxx");
#line 501
  scanner->aname = new_string(sgrep___0, (size_t )256);
  }
  {
#line 502
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 502
    if ((scanner->aname)->length < 256UL) {
      {
#line 502
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 502
        if ((scanner->aname)->length < (scanner->aname)->size) {
#line 502
          *((scanner->aname)->s + (scanner->aname)->length) = (char )'a';
#line 502
          ((scanner->aname)->length) ++;
        } else {
          {
#line 502
          real_string_push(scanner->aname, 'a');
          }
        }
#line 502
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 502
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 503
  scanner->aval = new_string(sgrep___0, (size_t )256);
  }
  {
#line 504
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 504
    if ((scanner->aval)->length < 256UL) {
      {
#line 504
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 504
        if ((scanner->aval)->length < (scanner->aval)->size) {
#line 504
          *((scanner->aval)->s + (scanner->aval)->length) = (char )'v';
#line 504
          ((scanner->aval)->length) ++;
        } else {
          {
#line 504
          real_string_push(scanner->aval, 'v');
          }
        }
#line 504
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 504
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 505
  scanner->pi = new_string(sgrep___0, (size_t )256);
  }
  {
#line 506
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 506
    if ((scanner->pi)->length < 256UL) {
      {
#line 506
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 506
        if ((scanner->pi)->length < (scanner->pi)->size) {
#line 506
          *((scanner->pi)->s + (scanner->pi)->length) = (char )'?';
#line 506
          ((scanner->pi)->length) ++;
        } else {
          {
#line 506
          real_string_push(scanner->pi, '?');
          }
        }
#line 506
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 506
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 507
  scanner->failed = 0;
#line 509
  reset_encoder(scanner, & scanner->encoder);
  }
#line 510
  return (scanner);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
SGMLScanner *new_sgml_phrase_scanner(SgrepData *sgrep___0 , FileList *file_list ,
                                     struct PHRASE_NODE *list ) 
{ 
  SGMLScanner *scanner ;

  {
  {
#line 517
  scanner = new_sgml_scanner_common(sgrep___0, file_list);
#line 518
  scanner->phrase_list = list;
#line 519
  scanner->entry = & sgml_add_entry_to_gclist;
#line 520
  scanner->data = (void *)0;
  }
#line 521
  return (scanner);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
SGMLScanner *new_sgml_index_scanner(SgrepData *sgrep___0 , FileList *file_list , struct IndexWriterStruct *writer ) 
{ 
  SGMLScanner *scanner ;

  {
  {
#line 529
  scanner = new_sgml_scanner_common(sgrep___0, file_list);
#line 530
  scanner->phrase_list = (struct PHRASE_NODE *)((void *)0);
#line 531
  scanner->element_list = new_region_list(sgrep___0);
#line 532
  list_set_sorted(scanner->element_list, (enum RegionListSorted )0);
#line 533
  (scanner->element_list)->nested = 1;
#line 534
  scanner->entry = & sgml_add_entry_to_index;
#line 535
  scanner->data = (void *)writer;
  }
#line 536
  return (scanner);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void delete_sgml_scanner(SGMLScanner *s ) 
{ 
  SgrepData *sgrep___0 ;

  {
  {
#line 540
  sgrep___0 = s->sgrep;
#line 542
  pop_elements_to(s, (struct ElementStackStruct *)((void *)0));
  }
#line 543
  if (s->element_list) {
    {
#line 544
    delete_region_list(s->element_list);
    }
  }
  {
#line 546
  delete_string(s->word);
#line 547
  delete_string(s->name2);
#line 548
  delete_string(s->comment_word);
#line 549
  delete_string(s->gi);
#line 550
  delete_string(s->aname);
#line 551
  delete_string(s->aval);
#line 552
  delete_string(s->name);
#line 553
  delete_string(s->literal);
#line 554
  delete_string(s->pi);
  }
#line 555
  if (s->name_start_chars) {
    {
#line 555
    sgrep_debug_free(sgrep___0, (void *)s->name_start_chars);
    }
  }
#line 556
  if (s->name_chars) {
    {
#line 556
    sgrep_debug_free(sgrep___0, (void *)s->name_chars);
    }
  }
  {
#line 557
  sgrep_debug_free(sgrep___0, (void *)s->word_chars);
#line 558
  sgrep_debug_free(sgrep___0, (void *)s);
  }
#line 559
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void push_state(SGMLScanner *scanner , enum SGMLState state ) 
{ 
  int tmp ;

  {
#line 563
  if (! (scanner->state_stack_ptr < 10)) {
    {
#line 563
    __assert_fail("scanner->state_stack_ptr<10", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  563U, "push_state");
    }
  }
#line 564
  tmp = scanner->state_stack_ptr;
#line 564
  (scanner->state_stack_ptr) ++;
#line 564
  scanner->state_stack[tmp] = state;
#line 565
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
enum SGMLState pop_state(SGMLScanner *scanner ) 
{ 


  {
#line 568
  if (! (scanner->state_stack_ptr > 0)) {
    {
#line 568
    __assert_fail("scanner->state_stack_ptr>0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  568U, "pop_state");
    }
  }
#line 569
  (scanner->state_stack_ptr) --;
#line 569
  return (scanner->state_stack[scanner->state_stack_ptr]);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void pop_elements_to(SGMLScanner *state , struct ElementStackStruct *p ) 
{ 
  ElementStack *q ;
  SgrepData *sgrep___0 ;

  {
#line 580
  sgrep___0 = state->sgrep;
#line 581
  if (! ((unsigned long )p == (unsigned long )((void *)0))) {
#line 581
    if (! state->top) {
      {
#line 581
      __assert_fail("p==((void *)0) || state->top", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                    581U, "pop_elements_to");
      }
    }
  }
#line 583
  q = state->top;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    if (! ((unsigned long )p != (unsigned long )q)) {
#line 584
      goto while_break;
    }
#line 587
    state->top = q->prev;
    {
#line 588
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 588
      if (sgrep___0->sgml_debug) {
        {
#line 588
        sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "elements", "",
                    "@elements", q->start, q->end);
        }
      }
#line 588
      if (q->start <= q->end) {
        {
#line 588
        (*(state->entry))(state, (char const   *)((char *)"@elements"), q->start,
                          q->end);
        }
      }
#line 588
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 590
    sgrep_debug_free(sgrep___0, (void *)q->gi);
#line 591
    sgrep_debug_free(sgrep___0, (void *)q);
#line 592
    q = state->top;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void parse_xml_declaration(SGMLScanner *scanner ) 
{ 
  SgrepData *sgrep___0 ;
  char const   *version ;
  char const   *encoding ;
  unsigned char const   *ptr ;
  SgrepString *encoding_name ;
  int quote_ch ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;

  {
  {
#line 601
  sgrep___0 = scanner->sgrep;
#line 602
  version = "version";
#line 603
  encoding = "encoding";
#line 604
  *((scanner->pi)->s + (scanner->pi)->length) = (char)0;
#line 604
  ptr = (unsigned char const   *)((char const   *)(scanner->pi)->s + 4);
#line 608
  encoding_name = new_string(sgrep___0, (size_t )256);
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (*ptr) {
      {
#line 610
      tmp = __ctype_b_loc();
      }
#line 610
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
#line 610
        goto while_break;
      }
    } else {
#line 610
      goto while_break;
    }
#line 610
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    if (*ptr) {
#line 613
      if (! ((int const   )*ptr == (int const   )*version)) {
#line 613
        goto while_break___0;
      }
    } else {
#line 613
      goto while_break___0;
    }
#line 614
    ptr ++;
#line 615
    version ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 617
  if (*version) {
#line 617
    goto error;
  }
  {
#line 619
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 619
    if (*ptr) {
      {
#line 619
      tmp___0 = __ctype_b_loc();
      }
#line 619
      if (! ((int const   )*(*tmp___0 + (int )*ptr) & 8192)) {
#line 619
        goto while_break___1;
      }
    } else {
#line 619
      goto while_break___1;
    }
#line 619
    ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 621
  if ((int const   )*ptr != 61) {
#line 621
    goto error;
  }
#line 622
  ptr ++;
  {
#line 624
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 624
    if (*ptr) {
      {
#line 624
      tmp___1 = __ctype_b_loc();
      }
#line 624
      if (! ((int const   )*(*tmp___1 + (int )*ptr) & 8192)) {
#line 624
        goto while_break___2;
      }
    } else {
#line 624
      goto while_break___2;
    }
#line 624
    ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 626
  if ((int const   )*ptr != 39) {
#line 626
    if ((int const   )*ptr != 34) {
#line 626
      goto error;
    }
  }
#line 627
  tmp___2 = ptr;
#line 627
  ptr ++;
#line 627
  quote_ch = (int )*tmp___2;
  {
#line 629
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 629
    if (*ptr) {
#line 629
      if (! ((int const   )*ptr != (int const   )quote_ch)) {
#line 629
        goto while_break___3;
      }
    } else {
#line 629
      goto while_break___3;
    }
#line 629
    ptr ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 630
  if ((int const   )*ptr != (int const   )quote_ch) {
#line 630
    goto error;
  }
#line 631
  ptr ++;
  {
#line 634
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 634
    if (*ptr) {
      {
#line 634
      tmp___3 = __ctype_b_loc();
      }
#line 634
      if (! ((int const   )*(*tmp___3 + (int )*ptr) & 8192)) {
#line 634
        goto while_break___4;
      }
    } else {
#line 634
      goto while_break___4;
    }
#line 634
    ptr ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 635
  if (! *ptr) {
    {
#line 636
    delete_string(encoding_name);
    }
#line 637
    return;
  }
  {
#line 641
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 641
    if (*ptr) {
#line 641
      if (! ((int const   )*ptr == (int const   )*encoding)) {
#line 641
        goto while_break___5;
      }
    } else {
#line 641
      goto while_break___5;
    }
#line 642
    ptr ++;
#line 643
    encoding ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 645
  if (*encoding) {
#line 645
    goto error;
  }
  {
#line 647
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 647
    if (*ptr) {
      {
#line 647
      tmp___4 = __ctype_b_loc();
      }
#line 647
      if (! ((int const   )*(*tmp___4 + (int )*ptr) & 8192)) {
#line 647
        goto while_break___6;
      }
    } else {
#line 647
      goto while_break___6;
    }
#line 647
    ptr ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 649
  if ((int const   )*ptr != 61) {
#line 649
    goto error;
  }
#line 650
  ptr ++;
  {
#line 652
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 652
    if (*ptr) {
      {
#line 652
      tmp___5 = __ctype_b_loc();
      }
#line 652
      if (! ((int const   )*(*tmp___5 + (int )*ptr) & 8192)) {
#line 652
        goto while_break___7;
      }
    } else {
#line 652
      goto while_break___7;
    }
#line 652
    ptr ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 655
  if ((int const   )*ptr != 39) {
#line 655
    if ((int const   )*ptr != 34) {
#line 655
      goto error;
    }
  }
#line 656
  tmp___6 = ptr;
#line 656
  ptr ++;
#line 656
  quote_ch = (int )*tmp___6;
  {
#line 659
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 659
    if (*ptr) {
#line 659
      if (! ((int const   )*ptr != (int const   )quote_ch)) {
#line 659
        goto while_break___8;
      }
    } else {
#line 659
      goto while_break___8;
    }
    {
#line 660
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 660
      if (encoding_name->length < encoding_name->size) {
#line 660
        if ((int const   )*ptr < 255) {
#line 660
          *(encoding_name->s + encoding_name->length) = (char )*ptr;
#line 660
          (encoding_name->length) ++;
        } else {
          {
#line 660
          real_string_push(encoding_name, (SgrepChar )*ptr);
          }
        }
      } else {
        {
#line 660
        real_string_push(encoding_name, (SgrepChar )*ptr);
        }
      }
#line 660
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 661
    ptr ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 663
  if ((int const   )*ptr != (int const   )quote_ch) {
#line 663
    goto error;
  }
#line 664
  ptr ++;
#line 667
  if (sgrep___0->sgml_debug) {
    {
#line 668
    *(encoding_name->s + encoding_name->length) = (char)0;
#line 668
    sgrep_progress(sgrep___0, (char *)"encoding=%s\n", (char const   *)encoding_name->s);
    }
  }
#line 673
  if ((unsigned int )sgrep___0->default_encoding == 0U) {
    {
#line 674
    string_tolower(encoding_name, 0);
#line 675
    *(encoding_name->s + encoding_name->length) = (char)0;
#line 675
    tmp___11 = strcmp((char const   *)encoding_name->s, "iso-8859-1");
    }
#line 675
    if (tmp___11 == 0) {
#line 677
      scanner->encoder.estate = (enum EncoderState )0;
    } else {
      {
#line 675
      *(encoding_name->s + encoding_name->length) = (char)0;
#line 675
      tmp___12 = strcmp((char const   *)encoding_name->s, "us-ascii");
      }
#line 675
      if (tmp___12 == 0) {
#line 677
        scanner->encoder.estate = (enum EncoderState )0;
      } else {
        {
#line 678
        *(encoding_name->s + encoding_name->length) = (char)0;
#line 678
        tmp___10 = strcmp((char const   *)encoding_name->s, "utf-8");
        }
#line 678
        if (tmp___10 == 0) {
#line 679
          scanner->encoder.estate = (enum EncoderState )1;
        } else {
          {
#line 680
          *(encoding_name->s + encoding_name->length) = (char)0;
#line 680
          tmp___9 = strcmp((char const   *)encoding_name->s, "utf-16");
          }
#line 680
          if (tmp___9 == 0) {
#line 681
            if ((unsigned int )scanner->encoder.estate == 1U) {
              {
#line 683
              tmp___7 = flist_name((FileList const   *)scanner->file_list, scanner->file_num);
#line 683
              sgrep_error(sgrep___0, (char *)"File \'%s\': utf-16 encoding given in 8-bit encoding declaration?",
                          tmp___7);
              }
            } else
#line 681
            if ((unsigned int )scanner->encoder.estate == 0U) {
              {
#line 683
              tmp___7 = flist_name((FileList const   *)scanner->file_list, scanner->file_num);
#line 683
              sgrep_error(sgrep___0, (char *)"File \'%s\': utf-16 encoding given in 8-bit encoding declaration?",
                          tmp___7);
              }
            }
          } else {
            {
#line 687
            *(encoding_name->s + encoding_name->length) = (char)0;
#line 687
            tmp___8 = flist_name((FileList const   *)scanner->file_list, scanner->file_num);
#line 687
            sgrep_error(sgrep___0, (char *)"File \'%s\':Unknown encoding \'%s\'. Using default.\n",
                        tmp___8, (char const   *)encoding_name->s);
#line 690
            reset_encoder(scanner, & scanner->encoder);
            }
          }
        }
      }
    }
  }
  {
#line 693
  delete_string(encoding_name);
  }
#line 694
  return;
  error: 
  {
#line 697
  delete_string(encoding_name);
#line 698
  (scanner->parse_errors) ++;
#line 699
  tmp___13 = flist_name((FileList const   *)scanner->file_list, scanner->file_num);
#line 699
  sgrep_error(sgrep___0, (char *)"File \'%s\':Parse error in XML-declaration.\n",
              tmp___13);
  }
#line 701
  return;
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void sgml_found(SGMLScanner *state , enum SGMLState s , int end_index ) 
{ 
  SgrepData *sgrep___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  ElementStack *e ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  ElementStack *p ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *url ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;

  {
#line 704
  sgrep___0 = state->sgrep;
#line 705
  end_index --;
  {
#line 710
  if ((unsigned int )s == 35U) {
#line 710
    goto case_35;
  }
#line 710
  if ((unsigned int )s == 5U) {
#line 710
    goto case_35;
  }
#line 710
  if ((unsigned int )s == 1U) {
#line 710
    goto case_35;
  }
#line 721
  if ((unsigned int )s == 3U) {
#line 721
    goto case_3;
  }
#line 729
  if ((unsigned int )s == 20U) {
#line 729
    goto case_20;
  }
#line 750
  if ((unsigned int )s == 18U) {
#line 750
    goto case_18;
  }
#line 750
  if ((unsigned int )s == 17U) {
#line 750
    goto case_18;
  }
#line 750
  if ((unsigned int )s == 16U) {
#line 750
    goto case_18;
  }
#line 757
  if ((unsigned int )s == 19U) {
#line 757
    goto case_19;
  }
#line 767
  if ((unsigned int )s == 22U) {
#line 767
    goto case_22;
  }
#line 794
  if ((unsigned int )s == 27U) {
#line 794
    goto case_27;
  }
#line 804
  if ((unsigned int )s == 29U) {
#line 804
    goto case_29;
  }
#line 811
  if ((unsigned int )s == 31U) {
#line 811
    goto case_31;
  }
#line 811
  if ((unsigned int )s == 30U) {
#line 811
    goto case_31;
  }
#line 824
  if ((unsigned int )s == 37U) {
#line 824
    goto case_37;
  }
#line 830
  if ((unsigned int )s == 38U) {
#line 830
    goto case_38;
  }
#line 844
  if ((unsigned int )s == 47U) {
#line 844
    goto case_47;
  }
#line 853
  if ((unsigned int )s == 49U) {
#line 853
    goto case_49;
  }
#line 862
  if ((unsigned int )s == 73U) {
#line 862
    goto case_73;
  }
#line 870
  if ((unsigned int )s == 62U) {
#line 870
    goto case_62;
  }
#line 870
  if ((unsigned int )s == 61U) {
#line 870
    goto case_62;
  }
#line 880
  if ((unsigned int )s == 69U) {
#line 880
    goto case_69;
  }
#line 911
  if ((unsigned int )s == 63U) {
#line 911
    goto case_63;
  }
#line 921
  if ((unsigned int )s == 65U) {
#line 921
    goto case_65;
  }
#line 931
  if ((unsigned int )s == 68U) {
#line 931
    goto case_68;
  }
#line 943
  if ((unsigned int )s == 72U) {
#line 943
    goto case_72;
  }
#line 943
  if ((unsigned int )s == 71U) {
#line 943
    goto case_72;
  }
#line 943
  if ((unsigned int )s == 70U) {
#line 943
    goto case_72;
  }
#line 947
  goto switch_default;
  case_35: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 711
  *((state->word)->s + (state->word)->length) = (char)0;
#line 711
  if (! ((int const   )*((char const   *)(state->word)->s + 0) == 119)) {
    {
#line 711
    __assert_fail("((state->word)->s[(state->word)->length]=0,(const char *)(state->word)->s)[0]==\'w\'",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  711U, "sgml_found");
    }
  }
#line 712
  if (state->ignore_case) {
    {
#line 713
    string_tolower(state->word, 1);
    }
  }
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 715
    if (sgrep___0->sgml_debug) {
      {
#line 715
      *((state->word)->s + (state->word)->length) = (char)0;
#line 715
      tmp = string_escaped(state->word);
#line 715
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "word", tmp + 1, (char const   *)(state->word)->s,
                  state->words, end_index);
      }
    }
#line 715
    if (state->words <= end_index) {
      {
#line 715
      *((state->word)->s + (state->word)->length) = (char)0;
#line 715
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->word)->s)),
                        state->words, end_index);
      }
    }
#line 715
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  goto switch_break;
  case_3: /* CIL Label */ 
#line 722
  *((state->name)->s + (state->name)->length) = (char)0;
#line 722
  if (! ((int const   )*((char const   *)(state->name)->s + 0) == 38)) {
    {
#line 722
    __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'&\'",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  722U, "sgml_found");
    }
  }
  {
#line 723
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 723
    if (sgrep___0->sgml_debug) {
      {
#line 723
      *((state->name)->s + (state->name)->length) = (char)0;
#line 723
      tmp___0 = string_escaped(state->name);
#line 723
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "entity", tmp___0 + 1,
                  (char const   *)(state->name)->s, state->entitys, end_index);
      }
    }
#line 723
    if (state->entitys <= end_index) {
      {
#line 723
      *((state->name)->s + (state->name)->length) = (char)0;
#line 723
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->name)->s)),
                        state->entitys, end_index);
      }
    }
#line 723
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 727
  goto switch_break;
  case_20: /* CIL Label */ 
#line 730
  if ((unsigned int )state->type != 1U) {
    {
#line 731
    string_toupper(state->gi, 1);
    }
  }
  {
#line 733
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 733
    if (sgrep___0->sgml_debug) {
      {
#line 733
      *((state->gi)->s + (state->gi)->length) = (char)0;
#line 733
      tmp___1 = string_escaped(state->gi);
#line 733
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "stag", tmp___1 + 1,
                  (char const   *)(state->gi)->s, state->tags, end_index);
      }
    }
#line 733
    if (state->tags <= end_index) {
      {
#line 733
      *((state->gi)->s + (state->gi)->length) = (char)0;
#line 733
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->gi)->s)),
                        state->tags, end_index);
      }
    }
#line 733
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 737
  if (state->maintain_element_stack) {
    {
#line 739
    tmp___2 = sgrep_debug_malloc(sgrep___0, sizeof(ElementStack ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                                 739);
#line 739
    e = (ElementStack *)tmp___2;
#line 740
    *((state->gi)->s + (state->gi)->length) = (char)0;
#line 740
    e->gi = sgrep_debug_strdup(sgrep___0, (char const   *)(state->gi)->s + 1, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                               740);
#line 741
    e->start = state->tags;
#line 742
    e->end = end_index;
#line 743
    e->prev = state->top;
#line 744
    state->top = e;
    }
  }
#line 746
  goto switch_break;
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 751
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 751
    if (sgrep___0->sgml_debug) {
      {
#line 751
      *((state->aval)->s + (state->aval)->length) = (char)0;
#line 751
      tmp___3 = string_escaped(state->aval);
#line 751
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "attvalue", tmp___3 + 1,
                  (char const   *)(state->aval)->s, state->avals, end_index);
      }
    }
#line 751
    if (state->avals <= end_index) {
      {
#line 751
      *((state->aval)->s + (state->aval)->length) = (char)0;
#line 751
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->aval)->s)),
                        state->avals, end_index);
      }
    }
#line 751
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 755
  goto switch_break;
  case_19: /* CIL Label */ 
#line 758
  if ((unsigned int )state->type != 1U) {
    {
#line 759
    string_toupper(state->aname, 1);
    }
  }
  {
#line 761
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 761
    if (sgrep___0->sgml_debug) {
      {
#line 761
      *((state->aname)->s + (state->aname)->length) = (char)0;
#line 761
      tmp___4 = string_escaped(state->aname);
#line 761
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "attribute", tmp___4 + 1,
                  (char const   *)(state->aname)->s, state->anames, end_index);
      }
    }
#line 761
    if (state->anames <= end_index) {
      {
#line 761
      *((state->aname)->s + (state->aname)->length) = (char)0;
#line 761
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->aname)->s)),
                        state->anames, end_index);
      }
    }
#line 761
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 765
  goto switch_break;
  case_22: /* CIL Label */ 
#line 768
  if ((unsigned int )state->type != 1U) {
    {
#line 769
    string_toupper(state->gi, 1);
    }
  }
  {
#line 771
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 771
    if (sgrep___0->sgml_debug) {
      {
#line 771
      *((state->gi)->s + (state->gi)->length) = (char)0;
#line 771
      tmp___5 = string_escaped(state->gi);
#line 771
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "etag", tmp___5 + 1,
                  (char const   *)(state->gi)->s, state->tags, end_index);
      }
    }
#line 771
    if (state->tags <= end_index) {
      {
#line 771
      *((state->gi)->s + (state->gi)->length) = (char)0;
#line 771
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->gi)->s)),
                        state->tags, end_index);
      }
    }
#line 771
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 775
  if (state->maintain_element_stack) {
#line 777
    p = state->top;
    {
#line 778
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 778
      if (p) {
        {
#line 778
        *((state->gi)->s + (state->gi)->length) = (char)0;
#line 778
        tmp___6 = strcmp((char const   *)(state->gi)->s + 1, (char const   *)p->gi);
        }
#line 778
        if (! (tmp___6 != 0)) {
#line 778
          goto while_break___5;
        }
      } else {
#line 778
        goto while_break___5;
      }
#line 779
      p = p->prev;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 781
    if (p) {
      {
#line 783
      pop_elements_to(state, p);
#line 785
      state->top = p->prev;
      }
      {
#line 786
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 786
        if (sgrep___0->sgml_debug) {
          {
#line 786
          sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "elements", "",
                      "@elements", p->start, end_index);
          }
        }
#line 786
        if (p->start <= end_index) {
          {
#line 786
          (*(state->entry))(state, (char const   *)((char *)"@elements"), p->start,
                            end_index);
          }
        }
#line 786
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 788
      sgrep_debug_free(sgrep___0, (void *)p->gi);
#line 789
      sgrep_debug_free(sgrep___0, (void *)p);
      }
    }
  }
#line 792
  goto switch_break;
  case_27: /* CIL Label */ 
#line 795
  if (state->ignore_case) {
    {
#line 796
    string_tolower(state->comment_word, 1);
    }
  }
  {
#line 798
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 798
    if (sgrep___0->sgml_debug) {
      {
#line 798
      *((state->comment_word)->s + (state->comment_word)->length) = (char)0;
#line 798
      tmp___7 = string_escaped(state->comment_word);
#line 798
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "comment_word", tmp___7 + 1,
                  (char const   *)(state->comment_word)->s, state->comment_words,
                  end_index);
      }
    }
#line 798
    if (state->comment_words <= end_index) {
      {
#line 798
      *((state->comment_word)->s + (state->comment_word)->length) = (char)0;
#line 798
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->comment_word)->s)),
                        state->comment_words, end_index);
      }
    }
#line 798
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 802
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 805
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 805
    if (sgrep___0->sgml_debug) {
      {
#line 805
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "comment", (unsigned char const   *)"",
                  (unsigned char const   *)"-", state->comments, end_index);
      }
    }
#line 805
    if (state->comments <= end_index) {
      {
#line 805
      (*(state->entry))(state, (char const   *)((char *)((unsigned char const   *)"-")),
                        state->comments, end_index);
      }
    }
#line 805
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 808
  goto switch_break;
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  {
#line 812
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 812
    if (sgrep___0->sgml_debug) {
      {
#line 812
      *((state->pi)->s + (state->pi)->length) = (char)0;
#line 812
      tmp___8 = string_escaped(state->pi);
#line 812
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "pi", tmp___8 + 1,
                  (char const   *)(state->pi)->s, state->tags, end_index);
      }
    }
#line 812
    if (state->tags <= end_index) {
      {
#line 812
      *((state->pi)->s + (state->pi)->length) = (char)0;
#line 812
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->pi)->s)),
                        state->tags, end_index);
      }
    }
#line 812
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 816
  if ((unsigned int )state->type == 1U) {
    {
#line 816
    *((state->pi)->s + (state->pi)->length) = (char)0;
#line 816
    tmp___9 = toupper((int )*((char const   *)(state->pi)->s + 1));
    }
#line 816
    if (tmp___9 == 88) {
      {
#line 816
      *((state->pi)->s + (state->pi)->length) = (char)0;
#line 816
      tmp___10 = toupper((int )*((char const   *)(state->pi)->s + 2));
      }
#line 816
      if (tmp___10 == 77) {
        {
#line 816
        *((state->pi)->s + (state->pi)->length) = (char)0;
#line 816
        tmp___11 = toupper((int )*((char const   *)(state->pi)->s + 3));
        }
#line 816
        if (tmp___11 == 76) {
          {
#line 820
          parse_xml_declaration(state);
          }
        }
      }
    }
  }
#line 822
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 825
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 825
    if (sgrep___0->sgml_debug) {
      {
#line 825
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "cdata", (unsigned char const   *)"",
                  (unsigned char const   *)"[CDATA", state->markeds, end_index);
      }
    }
#line 825
    if (state->markeds <= end_index) {
      {
#line 825
      (*(state->entry))(state, (char const   *)((char *)((unsigned char const   *)"[CDATA")),
                        state->markeds, end_index);
      }
    }
#line 825
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 828
  goto switch_break;
  case_38: /* CIL Label */ 
#line 831
  *((state->name)->s + (state->name)->length) = (char)0;
#line 831
  if ((int const   )*((char const   *)(state->name)->s + 0) == 100) {
#line 831
    *((state->name)->s + (state->name)->length) = (char)0;
#line 831
    if (! ((int const   )*((char const   *)(state->name)->s + 1) == 110)) {
      {
#line 831
      __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'d\' && ((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[1]==\'n\'",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                    832U, "sgml_found");
      }
    }
  } else {
    {
#line 831
    __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'d\' && ((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[1]==\'n\'",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  832U, "sgml_found");
    }
  }
#line 833
  if ((unsigned int )state->type != 1U) {
    {
#line 834
    string_toupper(state->name, 2);
    }
  }
  {
#line 836
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 836
    if (sgrep___0->sgml_debug) {
      {
#line 836
      *((state->name)->s + (state->name)->length) = (char)0;
#line 836
      tmp___12 = string_escaped(state->name);
#line 836
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "doctype", tmp___12 + 2,
                  (char const   *)(state->name)->s, state->doctypes, end_index);
      }
    }
#line 836
    if (state->doctypes <= end_index) {
      {
#line 836
      *((state->name)->s + (state->name)->length) = (char)0;
#line 836
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->name)->s)),
                        state->doctypes, end_index);
      }
    }
#line 836
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 841
  pop_elements_to(state, (struct ElementStackStruct *)((void *)0));
  }
#line 842
  goto switch_break;
  case_47: /* CIL Label */ 
#line 845
  *((state->literal)->s + 1) = (char )'d';
#line 846
  *((state->literal)->s + 2) = (char )'p';
  {
#line 847
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 847
    if (sgrep___0->sgml_debug) {
      {
#line 847
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 847
      tmp___13 = string_escaped(state->literal);
#line 847
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "doctype_pid", tmp___13 + 3,
                  (char const   *)(state->literal)->s + 1, state->literals, end_index);
      }
    }
#line 847
    if (state->literals <= end_index) {
      {
#line 847
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 847
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->literal)->s + 1)),
                        state->literals, end_index);
      }
    }
#line 847
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 851
  goto switch_break;
  case_49: /* CIL Label */ 
#line 854
  *((state->literal)->s + 1) = (char )'d';
#line 855
  *((state->literal)->s + 2) = (char )'s';
  {
#line 856
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 856
    if (sgrep___0->sgml_debug) {
      {
#line 856
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 856
      tmp___14 = string_escaped(state->literal);
#line 856
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "doctype_sid", tmp___14 + 3,
                  (char const   *)(state->literal)->s + 1, state->literals, end_index);
      }
    }
#line 856
    if (state->literals <= end_index) {
      {
#line 856
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 856
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->literal)->s + 1)),
                        state->literals, end_index);
      }
    }
#line 856
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 860
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 863
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 863
    if (sgrep___0->sgml_debug) {
      {
#line 863
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "prologs", (unsigned char const   *)"d",
                  (unsigned char const   *)"d!", state->doctype_declarations, end_index);
      }
    }
#line 863
    if (state->doctype_declarations <= end_index) {
      {
#line 863
      (*(state->entry))(state, (char const   *)((char *)((unsigned char const   *)"d!")),
                        state->doctype_declarations, end_index);
      }
    }
#line 863
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 866
  goto switch_break;
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
#line 871
  *((state->name)->s + (state->name)->length) = (char)0;
#line 871
  if ((int const   )*((char const   *)(state->name)->s + 0) == 33) {
#line 871
    *((state->name)->s + (state->name)->length) = (char)0;
#line 871
    if (! ((int const   )*((char const   *)(state->name)->s + 1) == 101)) {
      {
#line 871
      __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'!\' && ((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[1]==\'e\'",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                    872U, "sgml_found");
      }
    }
  } else {
    {
#line 871
    __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'!\' && ((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[1]==\'e\'",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  872U, "sgml_found");
    }
  }
#line 873
  *((state->name)->s + 2) = (char )'l';
  {
#line 874
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 874
    if (sgrep___0->sgml_debug) {
      {
#line 874
      *((state->name)->s + (state->name)->length) = (char)0;
#line 874
      tmp___15 = string_escaped(state->name);
#line 874
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "entity_literal",
                  tmp___15 + 3, (char const   *)(state->name)->s, state->literals,
                  end_index);
      }
    }
#line 874
    if (state->literals <= end_index) {
      {
#line 874
      *((state->name)->s + (state->name)->length) = (char)0;
#line 874
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->name)->s)),
                        state->literals, end_index);
      }
    }
#line 874
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 878
  goto switch_break;
  case_69: /* CIL Label */ 
#line 881
  *((state->name)->s + (state->name)->length) = (char)0;
#line 881
  if ((int const   )*((char const   *)(state->name)->s + 0) == 33) {
#line 881
    *((state->name)->s + (state->name)->length) = (char)0;
#line 881
    if (! ((int const   )*((char const   *)(state->name)->s + 1) == 101)) {
      {
#line 881
      __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'!\' && ((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[1]==\'e\'",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                    882U, "sgml_found");
      }
    }
  } else {
    {
#line 881
    __assert_fail("((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[0]==\'!\' && ((state->name)->s[(state->name)->length]=0,(const char *)(state->name)->s)[1]==\'e\'",
                  "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                  882U, "sgml_found");
    }
  }
#line 883
  *((state->name)->s + 2) = (char )'d';
  {
#line 884
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 884
    if (sgrep___0->sgml_debug) {
      {
#line 884
      *((state->name)->s + (state->name)->length) = (char)0;
#line 884
      tmp___16 = string_escaped(state->name);
#line 884
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "entity_declaration",
                  tmp___16 + 3, (char const   *)(state->name)->s, state->internal_declarations,
                  end_index);
      }
    }
#line 884
    if (state->internal_declarations <= end_index) {
      {
#line 884
      *((state->name)->s + (state->name)->length) = (char)0;
#line 884
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->name)->s)),
                        state->internal_declarations, end_index);
      }
    }
#line 884
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 889
  if (state->entity_has_systemid) {
#line 889
    if (! state->entity_is_ndata) {
#line 889
      if (state->include_system_entities) {
        {
#line 892
        *((state->literal)->s + (state->literal)->length) = (char)0;
#line 892
        url = (char const   *)(state->literal)->s + 3;
#line 893
        tmp___18 = flist_exists(state->file_list, url);
        }
#line 893
        if (! tmp___18) {
          {
#line 894
          tmp___17 = flist_add_relative(state->file_list, state->file_num, url);
          }
#line 894
          if (tmp___17 == 0) {
            {
#line 897
            sgrep_progress(sgrep___0, (char *)"Including system entity \'%s\'\n",
                           url);
            }
          } else {
            {
#line 904
            sgrep_progress(sgrep___0, (char *)"Cannot include system entity \'%s\'\n",
                           url);
            }
          }
        }
      }
    }
  }
#line 909
  goto switch_break;
  case_63: /* CIL Label */ 
#line 912
  *((state->literal)->s + 0) = (char )'!';
#line 913
  *((state->literal)->s + 1) = (char )'e';
#line 914
  *((state->literal)->s + 2) = (char )'p';
  {
#line 915
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 915
    if (sgrep___0->sgml_debug) {
      {
#line 915
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 915
      tmp___19 = string_escaped(state->literal);
#line 915
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "entity_pid", tmp___19 + 3,
                  (char const   *)(state->literal)->s, state->literals, end_index);
      }
    }
#line 915
    if (state->literals <= end_index) {
      {
#line 915
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 915
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->literal)->s)),
                        state->literals, end_index);
      }
    }
#line 915
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 919
  goto switch_break;
  case_65: /* CIL Label */ 
#line 922
  *((state->literal)->s + 0) = (char )'!';
#line 923
  *((state->literal)->s + 1) = (char )'e';
#line 924
  *((state->literal)->s + 2) = (char )'s';
  {
#line 925
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 925
    if (sgrep___0->sgml_debug) {
      {
#line 925
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 925
      tmp___20 = string_escaped(state->literal);
#line 925
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "entity_sid", tmp___20 + 3,
                  (char const   *)(state->literal)->s, state->literals, end_index);
      }
    }
#line 925
    if (state->literals <= end_index) {
      {
#line 925
      *((state->literal)->s + (state->literal)->length) = (char)0;
#line 925
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->literal)->s)),
                        state->literals, end_index);
      }
    }
#line 925
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 929
  goto switch_break;
  case_68: /* CIL Label */ 
#line 932
  if ((unsigned int )state->type != 1U) {
    {
#line 933
    string_toupper(state->name2, 3);
    }
  }
  {
#line 935
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 935
    if (sgrep___0->sgml_debug) {
      {
#line 935
      *((state->name2)->s + (state->name2)->length) = (char)0;
#line 935
      tmp___21 = string_escaped(state->name2);
#line 935
      sgrep_error(sgrep___0, (char *)"%s(\"%s\"):%s:(%d,%d)\n", "entity_ndata", tmp___21 + 3,
                  (char const   *)(state->name2)->s, state->name2s, end_index);
      }
    }
#line 935
    if (state->name2s <= end_index) {
      {
#line 935
      *((state->name2)->s + (state->name2)->length) = (char)0;
#line 935
      (*(state->entry))(state, (char const   *)((char *)((char const   *)(state->name2)->s)),
                        state->name2s, end_index);
      }
    }
#line 935
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 939
  goto switch_break;
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
#line 945
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 948
  sgrep_error(sgrep___0, (char *)"SGML huh?\n");
  }
#line 949
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 951
  return;
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
void sgml_flush(SGMLScanner *sgmls ) 
{ 
  SgrepData *sgrep___0 ;
  ListIterator l ;
  Region r ;
  struct IndexWriterStruct *writer ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 955
  sgrep___0 = sgmls->sgrep;
#line 958
  pop_elements_to(sgmls, (struct ElementStackStruct *)((void *)0));
  }
#line 959
  if (sgmls->element_list) {
#line 959
    if ((unsigned long )sgmls->entry == (unsigned long )(& sgml_add_entry_to_index)) {
      {
#line 962
      writer = (struct IndexWriterStruct *)sgmls->data;
#line 966
      start_region_search(sgmls->element_list, & l);
      }
      {
#line 967
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 967
        check_get_region((ListIterator const   *)(& l), (Region const   *)(& r));
        }
        {
#line 967
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 967
          if ((unsigned long )l.node == (unsigned long )((void *)0)) {
#line 967
            goto _L;
          } else
#line 967
          if ((unsigned long )(l.node)->next == (unsigned long )((void *)0)) {
            _L: /* CIL Label */ 
#line 967
            if (l.ind == (int )(l.list)->length) {
#line 967
              r.start = -1;
#line 967
              r.end = -1;
#line 967
              goto while_break___0;
            }
#line 967
            if ((unsigned long )(l.list)->last == (unsigned long )((void *)0)) {
#line 967
              r.start = l.ind;
#line 967
              r.end = l.ind + (int )(l.list)->chars;
#line 967
              (l.ind) ++;
#line 967
              goto while_break___0;
            }
          }
#line 967
          if (l.ind == 1 << 7) {
#line 967
            l.node = (l.node)->next;
#line 967
            l.ind = 0;
          }
#line 967
          tmp = l.ind;
#line 967
          (l.ind) ++;
#line 967
          r = (l.node)->list[tmp];
#line 967
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 967
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 968
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 968
        if (! (r.start != -1)) {
#line 968
          goto while_break___1;
        }
        {
#line 969
        add_region_to_index(writer, "@elements", r.start, r.end);
        }
        {
#line 970
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 970
          check_get_region((ListIterator const   *)(& l), (Region const   *)(& r));
          }
          {
#line 970
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 970
            if ((unsigned long )l.node == (unsigned long )((void *)0)) {
#line 970
              goto _L___0;
            } else
#line 970
            if ((unsigned long )(l.node)->next == (unsigned long )((void *)0)) {
              _L___0: /* CIL Label */ 
#line 970
              if (l.ind == (int )(l.list)->length) {
#line 970
                r.start = -1;
#line 970
                r.end = -1;
#line 970
                goto while_break___3;
              }
#line 970
              if ((unsigned long )(l.list)->last == (unsigned long )((void *)0)) {
#line 970
                r.start = l.ind;
#line 970
                r.end = l.ind + (int )(l.list)->chars;
#line 970
                (l.ind) ++;
#line 970
                goto while_break___3;
              }
            }
#line 970
            if (l.ind == 1 << 7) {
#line 970
              l.node = (l.node)->next;
#line 970
              l.ind = 0;
            }
#line 970
            tmp___0 = l.ind;
#line 970
            (l.ind) ++;
#line 970
            r = (l.node)->list[tmp___0];
#line 970
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 970
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 972
      delete_region_list(sgmls->element_list);
#line 973
      sgmls->element_list = new_region_list(sgrep___0);
#line 974
      list_set_sorted(sgmls->element_list, (enum RegionListSorted )0);
#line 975
      (sgmls->element_list)->nested = 1;
      }
    }
  }
  {
#line 977
  reset_encoder(sgmls, & sgmls->encoder);
#line 978
  sgmls->state = (enum SGMLState )0;
  }
#line 979
  return;
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c"
int sgml_scan(SGMLScanner *scanner , unsigned char const   *buf , int len , int start ,
              int file_num ) 
{ 
  int i___0 ;
  int ch ;
  Encoder *encoder ;
  enum SGMLState state ;
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char tmp___4[30] ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned short const   **tmp___18 ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned short const   **tmp___24 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  unsigned short const   **tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  unsigned short const   **tmp___33 ;
  char const   *name ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  unsigned short const   **tmp___40 ;
  unsigned short const   **tmp___41 ;
  unsigned short const   **tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  unsigned short const   **tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  unsigned short const   **tmp___51 ;
  unsigned short const   **tmp___52 ;
  unsigned short const   **tmp___53 ;
  unsigned short const   **tmp___54 ;
  unsigned short const   **tmp___55 ;
  unsigned short const   **tmp___56 ;
  int tmp___57 ;
  unsigned short const   **tmp___58 ;

  {
#line 995
  ch = -1;
#line 996
  encoder = & scanner->encoder;
#line 997
  state = scanner->state;
#line 998
  sgrep___0 = scanner->sgrep;
#line 1000
  if (encoder->prev == -1) {
#line 1000
    encoder->prev = start;
  }
#line 1002
  scanner->file_num = file_num;
#line 1003
  i___0 = 0;
#line 1004
  ch = -1;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (ch == -1) {
#line 1008
      if (i___0 >= len) {
#line 1008
        goto while_break;
      }
      {
#line 1011
      if ((unsigned int )encoder->estate == 0U) {
#line 1011
        goto case_0;
      }
#line 1014
      if ((unsigned int )encoder->estate == 1U) {
#line 1014
        goto case_1;
      }
#line 1048
      if ((unsigned int )encoder->estate == 2U) {
#line 1048
        goto case_2;
      }
#line 1062
      if ((unsigned int )encoder->estate == 3U) {
#line 1062
        goto case_3;
      }
#line 1077
      if ((unsigned int )encoder->estate == 4U) {
#line 1077
        goto case_4;
      }
#line 1093
      if ((unsigned int )encoder->estate == 6U) {
#line 1093
        goto case_6;
      }
#line 1106
      if ((unsigned int )encoder->estate == 7U) {
#line 1106
        goto case_7;
      }
#line 1117
      if ((unsigned int )encoder->estate == 8U) {
#line 1117
        goto case_8;
      }
#line 1130
      if ((unsigned int )encoder->estate == 9U) {
#line 1130
        goto case_9;
      }
#line 1140
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1012
      tmp = i___0;
#line 1012
      i___0 ++;
#line 1012
      ch = (int )*(buf + tmp);
#line 1013
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1015
      if ((int const   )*(buf + i___0) < 128) {
#line 1016
        tmp___0 = i___0;
#line 1016
        i___0 ++;
#line 1016
        ch = (int )*(buf + tmp___0);
      } else
#line 1017
      if ((int const   )*(buf + i___0) < 192) {
        {
#line 1018
        ch = ' ';
#line 1019
        sgrep_error(sgrep___0, (char *)"UTF8 decoding error (<0xc0)\n");
#line 1020
        (scanner->parse_errors) ++;
#line 1021
        i___0 ++;
        }
      } else
#line 1022
      if ((int const   )*(buf + i___0) < 224) {
#line 1023
        encoder->estate = (enum EncoderState )2;
#line 1024
        encoder->char1 = (int )*(buf + i___0);
#line 1025
        i___0 ++;
#line 1026
        goto while_continue;
      } else
#line 1027
      if ((int const   )*(buf + i___0) < 240) {
#line 1028
        encoder->estate = (enum EncoderState )3;
#line 1029
        encoder->char1 = (int )*(buf + i___0);
#line 1030
        i___0 ++;
#line 1031
        goto while_continue;
      } else
#line 1032
      if ((int const   )*(buf + i___0) == 254) {
#line 1033
        encoder->estate = (enum EncoderState )6;
#line 1034
        i___0 ++;
#line 1035
        goto while_continue;
      } else
#line 1036
      if ((int const   )*(buf + i___0) == 255) {
#line 1037
        encoder->estate = (enum EncoderState )8;
#line 1038
        i___0 ++;
#line 1039
        goto while_continue;
      } else {
        {
#line 1041
        ch = ' ';
#line 1042
        sgrep_error(sgrep___0, (char *)"UTF8 decoding error (%d>=0xf0)\nn", (int const   )*(buf + i___0));
#line 1044
        (scanner->parse_errors) ++;
#line 1045
        i___0 ++;
        }
      }
#line 1047
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1049
      if ((int const   )*(buf + i___0) >= 128) {
#line 1049
        if ((int const   )*(buf + i___0) <= 191) {
#line 1050
          ch = ((encoder->char1 & 31) << 6) | (int )((int const   )*(buf + i___0) & 63);
#line 1051
          encoder->estate = (enum EncoderState )1;
#line 1052
          i___0 ++;
        } else {
          {
#line 1054
          ch = ' ';
#line 1055
          sgrep_error(sgrep___0, (char *)"UTF8 decoding error 2 (%d<0x80 || >0xbf)\n",
                      (int const   )*(buf + i___0));
#line 1057
          (scanner->parse_errors) ++;
#line 1058
          encoder->estate = (enum EncoderState )1;
#line 1059
          i___0 ++;
          }
        }
      } else {
        {
#line 1054
        ch = ' ';
#line 1055
        sgrep_error(sgrep___0, (char *)"UTF8 decoding error 2 (%d<0x80 || >0xbf)\n",
                    (int const   )*(buf + i___0));
#line 1057
        (scanner->parse_errors) ++;
#line 1058
        encoder->estate = (enum EncoderState )1;
#line 1059
        i___0 ++;
        }
      }
#line 1061
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1063
      if ((int const   )*(buf + i___0) >= 128) {
#line 1063
        if ((int const   )*(buf + i___0) <= 191) {
#line 1064
          encoder->char2 = (int )*(buf + i___0);
#line 1065
          encoder->estate = (enum EncoderState )4;
#line 1066
          i___0 ++;
#line 1067
          goto while_continue;
        } else {
          {
#line 1069
          sgrep_error(sgrep___0, (char *)"UTF8 decoding error: 3,1 (%d<0x80 || >0xbf)\n",
                      (int const   )*(buf + i___0));
#line 1071
          ch = ' ';
#line 1072
          (scanner->parse_errors) ++;
#line 1073
          encoder->estate = (enum EncoderState )1;
#line 1074
          i___0 ++;
          }
        }
      } else {
        {
#line 1069
        sgrep_error(sgrep___0, (char *)"UTF8 decoding error: 3,1 (%d<0x80 || >0xbf)\n",
                    (int const   )*(buf + i___0));
#line 1071
        ch = ' ';
#line 1072
        (scanner->parse_errors) ++;
#line 1073
        encoder->estate = (enum EncoderState )1;
#line 1074
        i___0 ++;
        }
      }
#line 1076
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1078
      if ((int const   )*(buf + i___0) >= 128) {
#line 1078
        if ((int const   )*(buf + i___0) <= 191) {
#line 1079
          ch = (((encoder->char1 & 15) << 12) | ((encoder->char2 & 63) << 6)) | (int )((int const   )*(buf + i___0) & 63);
#line 1081
          encoder->estate = (enum EncoderState )1;
#line 1082
          i___0 ++;
        } else {
          {
#line 1085
          sgrep_error(sgrep___0, (char *)"UTF8 decoding error: 3,2 (%d<0x80 || >0xbf)\n",
                      (int const   )*(buf + i___0));
#line 1087
          ch = ' ';
#line 1088
          (scanner->parse_errors) ++;
#line 1089
          encoder->estate = (enum EncoderState )1;
#line 1090
          i___0 ++;
          }
        }
      } else {
        {
#line 1085
        sgrep_error(sgrep___0, (char *)"UTF8 decoding error: 3,2 (%d<0x80 || >0xbf)\n",
                    (int const   )*(buf + i___0));
#line 1087
        ch = ' ';
#line 1088
        (scanner->parse_errors) ++;
#line 1089
        encoder->estate = (enum EncoderState )1;
#line 1090
        i___0 ++;
        }
      }
#line 1092
      goto switch_break;
      case_6: /* CIL Label */ 
#line 1094
      if ((int const   )*(buf + i___0) == 255) {
#line 1095
        encoder->estate = (enum EncoderState )7;
#line 1096
        i___0 ++;
#line 1097
        goto while_continue;
      } else {
        {
#line 1099
        sgrep_error(sgrep___0, (char *)"UTF16 decoding error Got 0xfe without 0xff\n");
#line 1100
        ch = ' ';
#line 1101
        (scanner->parse_errors) ++;
#line 1102
        encoder->estate = (enum EncoderState )1;
#line 1103
        i___0 ++;
        }
      }
#line 1105
      goto switch_break;
      case_7: /* CIL Label */ 
#line 1107
      if (i___0 + 1 >= len) {
        {
#line 1108
        sgrep_error(sgrep___0, (char *)"Odd number of bytes in UTF16-encoded file\n");
#line 1109
        i___0 ++;
#line 1110
        ch = -1;
        }
#line 1111
        goto while_continue;
      }
#line 1113
      ch = (int )(((int const   )*(buf + i___0) << 8) + (int const   )*(buf + (i___0 + 1)));
#line 1114
      i___0 += 2;
#line 1116
      goto switch_break;
      case_8: /* CIL Label */ 
#line 1118
      if ((int const   )*(buf + i___0) == 254) {
#line 1119
        encoder->estate = (enum EncoderState )9;
#line 1120
        i___0 ++;
#line 1121
        goto while_continue;
      } else {
        {
#line 1123
        sgrep_error(sgrep___0, (char *)"UTF16 decoding error Got 0xff without 0xfe\n");
#line 1124
        ch = ' ';
#line 1125
        (scanner->parse_errors) ++;
#line 1126
        encoder->estate = (enum EncoderState )1;
#line 1127
        i___0 ++;
        }
      }
#line 1129
      goto switch_break;
      case_9: /* CIL Label */ 
#line 1131
      if (i___0 + 1 >= len) {
        {
#line 1132
        sgrep_error(sgrep___0, (char *)"Odd number of bytes in UTF16-encoded file\n");
#line 1133
        i___0 ++;
#line 1134
        ch = -1;
        }
#line 1135
        goto while_continue;
      }
#line 1137
      ch = (int )(((int const   )*(buf + (i___0 + 1)) << 8) + (int const   )*(buf + i___0));
#line 1138
      i___0 += 2;
#line 1139
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1141
      __assert_fail("0 && \"Never here\"", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgml.c",
                    1141U, "sgml_scan");
      }
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 1147
    if ((unsigned int )state == 0U) {
#line 1147
      goto case_0___0;
    }
#line 1170
    if ((unsigned int )state == 2U) {
#line 1170
      goto case_2___0;
    }
#line 1187
    if ((unsigned int )state == 3U) {
#line 1187
      goto case_3___0;
    }
#line 1203
    if ((unsigned int )state == 6U) {
#line 1203
      goto case_6___0;
    }
#line 1219
    if ((unsigned int )state == 7U) {
#line 1219
      goto case_7___0;
    }
#line 1233
    if ((unsigned int )state == 8U) {
#line 1233
      goto case_8___0;
    }
#line 1250
    if ((unsigned int )state == 9U) {
#line 1250
      goto case_9___0;
    }
#line 1260
    if ((unsigned int )state == 4U) {
#line 1260
      goto case_4___0;
    }
#line 1283
    if ((unsigned int )state == 5U) {
#line 1283
      goto case_5;
    }
#line 1304
    if ((unsigned int )state == 1U) {
#line 1304
      goto case_1___0;
    }
#line 1320
    if ((unsigned int )state == 10U) {
#line 1320
      goto case_10;
    }
#line 1352
    if ((unsigned int )state == 11U) {
#line 1352
      goto case_11;
    }
#line 1361
    if ((unsigned int )state == 12U) {
#line 1361
      goto case_12;
    }
#line 1375
    if ((unsigned int )state == 13U) {
#line 1375
      goto case_13;
    }
#line 1384
    if ((unsigned int )state == 14U) {
#line 1384
      goto case_14;
    }
#line 1412
    if ((unsigned int )state == 15U) {
#line 1412
      goto case_15;
    }
#line 1451
    if ((unsigned int )state == 16U) {
#line 1451
      goto case_16;
    }
#line 1462
    if ((unsigned int )state == 17U) {
#line 1462
      goto case_17;
    }
#line 1473
    if ((unsigned int )state == 18U) {
#line 1473
      goto case_18;
    }
#line 1484
    if ((unsigned int )state == 19U) {
#line 1484
      goto case_19;
    }
#line 1489
    if ((unsigned int )state == 20U) {
#line 1489
      goto case_20;
    }
#line 1495
    if ((unsigned int )state == 21U) {
#line 1495
      goto case_21;
    }
#line 1504
    if ((unsigned int )state == 22U) {
#line 1504
      goto case_22;
    }
#line 1512
    if ((unsigned int )state == 23U) {
#line 1512
      goto case_23;
    }
#line 1542
    if ((unsigned int )state == 25U) {
#line 1542
      goto case_25;
    }
#line 1552
    if ((unsigned int )state == 26U) {
#line 1552
      goto case_26;
    }
#line 1565
    if ((unsigned int )state == 27U) {
#line 1565
      goto case_27;
    }
#line 1576
    if ((unsigned int )state == 28U) {
#line 1576
      goto case_28;
    }
#line 1587
    if ((unsigned int )state == 29U) {
#line 1587
      goto case_29;
    }
#line 1601
    if ((unsigned int )state == 30U) {
#line 1601
      goto case_30;
    }
#line 1613
    if ((unsigned int )state == 31U) {
#line 1613
      goto case_31;
    }
#line 1630
    if ((unsigned int )state == 32U) {
#line 1630
      goto case_32___1;
    }
#line 1646
    if ((unsigned int )state == 33U) {
#line 1646
      goto case_33___0;
    }
#line 1667
    if ((unsigned int )state == 34U) {
#line 1667
      goto case_34___0;
    }
#line 1680
    if ((unsigned int )state == 35U) {
#line 1680
      goto case_35;
    }
#line 1690
    if ((unsigned int )state == 36U) {
#line 1690
      goto case_36;
    }
#line 1699
    if ((unsigned int )state == 37U) {
#line 1699
      goto case_37;
    }
#line 1711
    if ((unsigned int )state == 24U) {
#line 1711
      goto case_24;
    }
#line 1728
    if ((unsigned int )state == 38U) {
#line 1728
      goto case_38;
    }
#line 1751
    if ((unsigned int )state == 39U) {
#line 1751
      goto case_39___0;
    }
#line 1780
    if ((unsigned int )state == 40U) {
#line 1780
      goto case_40;
    }
#line 1793
    if ((unsigned int )state == 41U) {
#line 1793
      goto case_41;
    }
#line 1806
    if ((unsigned int )state == 46U) {
#line 1806
      goto case_46;
    }
#line 1818
    if ((unsigned int )state == 42U) {
#line 1818
      goto case_42;
    }
#line 1832
    if ((unsigned int )state == 43U) {
#line 1832
      goto case_43;
    }
#line 1839
    if ((unsigned int )state == 45U) {
#line 1839
      goto case_45___0;
    }
#line 1848
    if ((unsigned int )state == 44U) {
#line 1848
      goto case_44;
    }
#line 1857
    if ((unsigned int )state == 47U) {
#line 1857
      goto case_47___0;
    }
#line 1863
    if ((unsigned int )state == 48U) {
#line 1863
      goto case_48;
    }
#line 1877
    if ((unsigned int )state == 49U) {
#line 1877
      goto case_49;
    }
#line 1883
    if ((unsigned int )state == 50U) {
#line 1883
      goto case_50;
    }
#line 1903
    if ((unsigned int )state == 51U) {
#line 1903
      goto case_51;
    }
#line 1927
    if ((unsigned int )state == 54U) {
#line 1927
      goto case_54;
    }
#line 1941
    if ((unsigned int )state == 52U) {
#line 1941
      goto case_52;
    }
#line 1961
    if ((unsigned int )state == 53U) {
#line 1961
      goto case_53;
    }
#line 1978
    if ((unsigned int )state == 55U) {
#line 1978
      goto case_55;
    }
#line 2008
    if ((unsigned int )state == 56U) {
#line 2008
      goto case_56;
    }
#line 2027
    if ((unsigned int )state == 57U) {
#line 2027
      goto case_57;
    }
#line 2036
    if ((unsigned int )state == 58U) {
#line 2036
      goto case_58;
    }
#line 2057
    if ((unsigned int )state == 74U) {
#line 2057
      goto case_74;
    }
#line 2066
    if ((unsigned int )state == 59U) {
#line 2066
      goto case_59;
    }
#line 2082
    if ((unsigned int )state == 60U) {
#line 2082
      goto case_60___1;
    }
#line 2099
    if ((unsigned int )state == 61U) {
#line 2099
      goto case_61___0;
    }
#line 2107
    if ((unsigned int )state == 62U) {
#line 2107
      goto case_62___3;
    }
#line 2115
    if ((unsigned int )state == 69U) {
#line 2115
      goto case_69;
    }
#line 2129
    if ((unsigned int )state == 63U) {
#line 2129
      goto case_63___2;
    }
#line 2139
    if ((unsigned int )state == 64U) {
#line 2139
      goto case_64;
    }
#line 2155
    if ((unsigned int )state == 65U) {
#line 2155
      goto case_65;
    }
#line 2164
    if ((unsigned int )state == 66U) {
#line 2164
      goto case_66;
    }
#line 2179
    if ((unsigned int )state == 67U) {
#line 2179
      goto case_67;
    }
#line 2199
    if ((unsigned int )state == 68U) {
#line 2199
      goto case_68;
    }
#line 2210
    if ((unsigned int )state == 70U) {
#line 2210
      goto case_70;
    }
#line 2219
    if ((unsigned int )state == 71U) {
#line 2219
      goto case_71;
    }
#line 2228
    if ((unsigned int )state == 72U) {
#line 2228
      goto case_72;
    }
#line 2237
    if ((unsigned int )state == 73U) {
#line 2237
      goto case_73;
    }
#line 2250
    goto switch_default___11;
    case_0___0: /* CIL Label */ 
    {
#line 1149
    if (ch == 60) {
#line 1149
      goto case_60;
    }
#line 1154
    goto switch_default___0;
    case_60: /* CIL Label */ 
#line 1150
    scanner->tags = encoder->prev;
#line 1151
    state = (enum SGMLState )10;
    {
#line 1152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1152
      encoder->prev = start + i___0;
#line 1152
      ch = -1;
#line 1152
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1153
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 1155
    if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1156
      state = (enum SGMLState )1;
#line 1157
      scanner->words = encoder->prev;
#line 1158
      (scanner->word)->length = (size_t )0;
      {
#line 1159
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1159
        if ((scanner->word)->length < 256UL) {
          {
#line 1159
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1159
            if ((scanner->word)->length < (scanner->word)->size) {
#line 1159
              *((scanner->word)->s + (scanner->word)->length) = (char )'w';
#line 1159
              ((scanner->word)->length) ++;
            } else {
              {
#line 1159
              real_string_push(scanner->word, 'w');
              }
            }
#line 1159
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 1159
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1160
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1160
        if ((scanner->word)->length < 256UL) {
          {
#line 1160
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1160
            if ((scanner->word)->length < (scanner->word)->size) {
#line 1160
              if (ch < 255) {
#line 1160
                *((scanner->word)->s + (scanner->word)->length) = (char )ch;
#line 1160
                ((scanner->word)->length) ++;
              } else {
                {
#line 1160
                real_string_push(scanner->word, ch);
                }
              }
            } else {
              {
#line 1160
              real_string_push(scanner->word, ch);
              }
            }
#line 1160
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 1160
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 1161
    if (ch == 38) {
      {
#line 1162
      scanner->entitys = encoder->prev;
#line 1163
      push_state(scanner, (enum SGMLState )4);
#line 1164
      state = (enum SGMLState )2;
      }
    }
    {
#line 1166
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1166
      encoder->prev = start + i___0;
#line 1166
      ch = -1;
#line 1166
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 1168
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1171
    scanner->character_reference = 0;
#line 1172
    if (ch == 35) {
#line 1173
      state = (enum SGMLState )6;
      {
#line 1174
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1174
        encoder->prev = start + i___0;
#line 1174
        ch = -1;
#line 1174
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 1175
    if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1176
      (scanner->name)->length = (size_t )0;
      {
#line 1177
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1177
        if ((scanner->name)->length < 256UL) {
          {
#line 1177
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1177
            if ((scanner->name)->length < (scanner->name)->size) {
#line 1177
              *((scanner->name)->s + (scanner->name)->length) = (char )'&';
#line 1177
              ((scanner->name)->length) ++;
            } else {
              {
#line 1177
              real_string_push(scanner->name, '&');
              }
            }
#line 1177
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
#line 1177
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1178
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1178
        if ((scanner->name)->length < 256UL) {
          {
#line 1178
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 1178
            if ((scanner->name)->length < (scanner->name)->size) {
#line 1178
              if (ch < 255) {
#line 1178
                *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 1178
                ((scanner->name)->length) ++;
              } else {
                {
#line 1178
                real_string_push(scanner->name, ch);
                }
              }
            } else {
              {
#line 1178
              real_string_push(scanner->name, ch);
              }
            }
#line 1178
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
#line 1178
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1179
      state = (enum SGMLState )3;
      {
#line 1180
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1180
        encoder->prev = start + i___0;
#line 1180
        ch = -1;
#line 1180
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 1182
      scanner->entitys = -1;
#line 1183
      state = pop_state(scanner);
      }
    }
#line 1185
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 1188
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 1189
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1189
        if ((scanner->name)->length < 256UL) {
          {
#line 1189
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 1189
            if ((scanner->name)->length < (scanner->name)->size) {
#line 1189
              if (ch < 255) {
#line 1189
                *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 1189
                ((scanner->name)->length) ++;
              } else {
                {
#line 1189
                real_string_push(scanner->name, ch);
                }
              }
            } else {
              {
#line 1189
              real_string_push(scanner->name, ch);
              }
            }
#line 1189
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 1189
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1190
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1190
        encoder->prev = start + i___0;
#line 1190
        ch = -1;
#line 1190
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    } else {
#line 1192
      if (ch == 59) {
        {
#line 1193
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 1193
          sgml_found(scanner, state, start + i___0);
          }
#line 1193
          if (scanner->failed) {
#line 1193
            return (-1);
          }
#line 1193
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 1194
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1194
          encoder->prev = start + i___0;
#line 1194
          ch = -1;
#line 1194
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      } else {
        {
#line 1196
        while (1) {
          while_continue___17: /* CIL Label */ ;
          {
#line 1196
          sgml_found(scanner, state, encoder->prev);
          }
#line 1196
          if (scanner->failed) {
#line 1196
            return (-1);
          }
#line 1196
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
      {
#line 1198
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 1198
        if ((scanner->name)->length < 256UL) {
          {
#line 1198
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 1198
            if ((scanner->name)->length < (scanner->name)->size) {
#line 1198
              *((scanner->name)->s + (scanner->name)->length) = (char )';';
#line 1198
              ((scanner->name)->length) ++;
            } else {
              {
#line 1198
              real_string_push(scanner->name, ';');
              }
            }
#line 1198
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
        }
#line 1198
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 1199
      state = pop_state(scanner);
      }
    }
#line 1201
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 1204
    if (ch == 120) {
#line 1205
      state = (enum SGMLState )8;
      {
#line 1206
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 1206
        encoder->prev = start + i___0;
#line 1206
        ch = -1;
#line 1206
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    } else
#line 1207
    if (ch >= 48) {
#line 1207
      if (ch <= 57) {
#line 1208
        scanner->character_reference = ch - 48;
#line 1209
        state = (enum SGMLState )7;
        {
#line 1210
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 1210
          encoder->prev = start + i___0;
#line 1210
          ch = -1;
#line 1210
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
      } else {
        {
#line 1212
        scanner->entitys = -1;
#line 1213
        scanner->character_reference = 0;
#line 1214
        (scanner->parse_errors) ++;
#line 1215
        state = pop_state(scanner);
        }
      }
    } else {
      {
#line 1212
      scanner->entitys = -1;
#line 1213
      scanner->character_reference = 0;
#line 1214
      (scanner->parse_errors) ++;
#line 1215
      state = pop_state(scanner);
      }
    }
#line 1217
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 1220
    if (ch == 59) {
#line 1221
      state = (enum SGMLState )9;
      {
#line 1222
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1222
        encoder->prev = start + i___0;
#line 1222
        ch = -1;
#line 1222
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 1223
      goto switch_break___0;
    } else
#line 1224
    if (ch >= 48) {
#line 1224
      if (ch <= 57) {
#line 1225
        scanner->character_reference = (scanner->character_reference * 10 + ch) - 48;
        {
#line 1227
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 1227
          encoder->prev = start + i___0;
#line 1227
          ch = -1;
#line 1227
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      } else {
#line 1229
        state = (enum SGMLState )9;
      }
    } else {
#line 1229
      state = (enum SGMLState )9;
    }
#line 1231
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 1234
    if (ch == 59) {
#line 1235
      state = (enum SGMLState )9;
      {
#line 1236
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 1236
        encoder->prev = start + i___0;
#line 1236
        ch = -1;
#line 1236
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
    } else
#line 1237
    if (ch >= 48) {
#line 1237
      if (ch <= 57) {
#line 1238
        scanner->character_reference = (scanner->character_reference * 16 + ch) - 48;
        {
#line 1240
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 1240
          encoder->prev = start + i___0;
#line 1240
          ch = -1;
#line 1240
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
      } else {
#line 1237
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1241
      tmp___2 = toupper(ch);
      }
#line 1241
      if (tmp___2 >= 65) {
        {
#line 1241
        tmp___3 = toupper(ch);
        }
#line 1241
        if (tmp___3 <= 70) {
          {
#line 1242
          tmp___1 = toupper(ch);
#line 1242
          scanner->character_reference = ((scanner->character_reference * 16 + tmp___1) - 65) + 10;
          }
          {
#line 1244
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 1244
            encoder->prev = start + i___0;
#line 1244
            ch = -1;
#line 1244
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        } else {
#line 1246
          state = (enum SGMLState )9;
        }
      } else {
#line 1246
        state = (enum SGMLState )9;
      }
    }
#line 1248
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
    {
#line 1252
    sprintf((char */* __restrict  */)(tmp___4), (char const   */* __restrict  */)"&#x%x;",
            scanner->character_reference);
#line 1253
    (scanner->name)->length = (size_t )0;
#line 1254
    string_cat(scanner->name, (char const   *)(tmp___4));
#line 1256
    state = pop_state(scanner);
    }
#line 1257
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 1261
    if (scanner->character_reference > 0) {
#line 1261
      if ((scanner->word_chars)->bitmap[(unsigned long )scanner->character_reference / sizeof(unsigned long )] & (1UL << (unsigned long )scanner->character_reference % sizeof(unsigned long ))) {
#line 1264
        scanner->words = scanner->entitys;
#line 1265
        (scanner->word)->length = (size_t )0;
        {
#line 1266
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 1266
          if ((scanner->word)->length < 256UL) {
            {
#line 1266
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 1266
              if ((scanner->word)->length < (scanner->word)->size) {
#line 1266
                *((scanner->word)->s + (scanner->word)->length) = (char )'w';
#line 1266
                ((scanner->word)->length) ++;
              } else {
                {
#line 1266
                real_string_push(scanner->word, 'w');
                }
              }
#line 1266
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 1266
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
        {
#line 1267
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 1267
          if ((scanner->word)->length < 256UL) {
            {
#line 1267
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 1267
              if ((scanner->word)->length < (scanner->word)->size) {
#line 1267
                if (scanner->character_reference < 255) {
#line 1267
                  *((scanner->word)->s + (scanner->word)->length) = (char )scanner->character_reference;
#line 1267
                  ((scanner->word)->length) ++;
                } else {
                  {
#line 1267
                  real_string_push(scanner->word, scanner->character_reference);
                  }
                }
              } else {
                {
#line 1267
                real_string_push(scanner->word, scanner->character_reference);
                }
              }
#line 1267
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
#line 1267
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 1268
        state = (enum SGMLState )1;
      } else {
#line 1261
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1269
    if (scanner->entitys >= 0) {
#line 1269
      if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1272
        scanner->words = scanner->entitys;
#line 1273
        (scanner->word)->length = (size_t )0;
        {
#line 1274
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 1274
          if ((scanner->word)->length < 256UL) {
            {
#line 1274
            while (1) {
              while_continue___32: /* CIL Label */ ;
#line 1274
              if ((scanner->word)->length < (scanner->word)->size) {
#line 1274
                *((scanner->word)->s + (scanner->word)->length) = (char )'w';
#line 1274
                ((scanner->word)->length) ++;
              } else {
                {
#line 1274
                real_string_push(scanner->word, 'w');
                }
              }
#line 1274
              goto while_break___32;
            }
            while_break___32: /* CIL Label */ ;
            }
          }
#line 1274
          goto while_break___31;
        }
        while_break___31: /* CIL Label */ ;
        }
        {
#line 1275
        *((scanner->name)->s + (scanner->name)->length) = (char)0;
#line 1275
        string_cat(scanner->word, (char const   *)(scanner->name)->s);
#line 1276
        state = (enum SGMLState )1;
        }
      } else {
#line 1278
        state = (enum SGMLState )0;
      }
    } else {
#line 1278
      state = (enum SGMLState )0;
    }
#line 1280
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 1284
    if (scanner->character_reference > 0) {
#line 1284
      if ((scanner->word_chars)->bitmap[(unsigned long )scanner->character_reference / sizeof(unsigned long )] & (1UL << (unsigned long )scanner->character_reference % sizeof(unsigned long ))) {
        {
#line 1287
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 1287
          if ((scanner->word)->length < 256UL) {
            {
#line 1287
            while (1) {
              while_continue___34: /* CIL Label */ ;
#line 1287
              if ((scanner->word)->length < (scanner->word)->size) {
#line 1287
                if (scanner->character_reference < 255) {
#line 1287
                  *((scanner->word)->s + (scanner->word)->length) = (char )scanner->character_reference;
#line 1287
                  ((scanner->word)->length) ++;
                } else {
                  {
#line 1287
                  real_string_push(scanner->word, scanner->character_reference);
                  }
                }
              } else {
                {
#line 1287
                real_string_push(scanner->word, scanner->character_reference);
                }
              }
#line 1287
              goto while_break___34;
            }
            while_break___34: /* CIL Label */ ;
            }
          }
#line 1287
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
#line 1288
        state = (enum SGMLState )1;
      } else {
#line 1284
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1291
    if (scanner->entitys >= 0) {
#line 1291
      if (scanner->character_reference == 0) {
        {
#line 1293
        *((scanner->name)->s + (scanner->name)->length) = (char)0;
#line 1293
        string_cat(scanner->word, (char const   *)(scanner->name)->s);
#line 1294
        state = (enum SGMLState )1;
        }
      } else {
#line 1291
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1298
      while (1) {
        while_continue___35: /* CIL Label */ ;
        {
#line 1298
        sgml_found(scanner, state, scanner->word_end);
        }
#line 1298
        if (scanner->failed) {
#line 1298
          return (-1);
        }
#line 1298
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 1299
      state = (enum SGMLState )0;
    }
#line 1302
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1305
    if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1305
      if (ch != 60) {
        {
#line 1306
        while (1) {
          while_continue___36: /* CIL Label */ ;
#line 1306
          if ((scanner->word)->length < 256UL) {
            {
#line 1306
            while (1) {
              while_continue___37: /* CIL Label */ ;
#line 1306
              if ((scanner->word)->length < (scanner->word)->size) {
#line 1306
                if (ch < 255) {
#line 1306
                  *((scanner->word)->s + (scanner->word)->length) = (char )ch;
#line 1306
                  ((scanner->word)->length) ++;
                } else {
                  {
#line 1306
                  real_string_push(scanner->word, ch);
                  }
                }
              } else {
                {
#line 1306
                real_string_push(scanner->word, ch);
                }
              }
#line 1306
              goto while_break___37;
            }
            while_break___37: /* CIL Label */ ;
            }
          }
#line 1306
          goto while_break___36;
        }
        while_break___36: /* CIL Label */ ;
        }
        {
#line 1307
        while (1) {
          while_continue___38: /* CIL Label */ ;
#line 1307
          encoder->prev = start + i___0;
#line 1307
          ch = -1;
#line 1307
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
      } else {
#line 1305
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1308
    if (ch == 38) {
      {
#line 1309
      scanner->word_end = encoder->prev;
#line 1310
      scanner->entitys = encoder->prev;
#line 1311
      push_state(scanner, (enum SGMLState )5);
#line 1312
      state = (enum SGMLState )2;
      }
      {
#line 1313
      while (1) {
        while_continue___39: /* CIL Label */ ;
#line 1313
        encoder->prev = start + i___0;
#line 1313
        ch = -1;
#line 1313
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
    } else {
      {
#line 1315
      while (1) {
        while_continue___40: /* CIL Label */ ;
        {
#line 1315
        sgml_found(scanner, state, encoder->prev);
        }
#line 1315
        if (scanner->failed) {
#line 1315
          return (-1);
        }
#line 1315
        goto while_break___40;
      }
      while_break___40: /* CIL Label */ ;
      }
#line 1316
      state = (enum SGMLState )0;
    }
#line 1318
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 1322
    if (ch == 47) {
#line 1322
      goto case_47;
    }
#line 1328
    if (ch == 33) {
#line 1328
      goto case_33;
    }
#line 1332
    if (ch == 63) {
#line 1332
      goto case_63;
    }
#line 1338
    goto switch_default___1;
    case_47: /* CIL Label */ 
#line 1323
    (scanner->gi)->length = (size_t )0;
    {
#line 1324
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 1324
      if ((scanner->gi)->length < 256UL) {
        {
#line 1324
        while (1) {
          while_continue___42: /* CIL Label */ ;
#line 1324
          if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1324
            *((scanner->gi)->s + (scanner->gi)->length) = (char )'e';
#line 1324
            ((scanner->gi)->length) ++;
          } else {
            {
#line 1324
            real_string_push(scanner->gi, 'e');
            }
          }
#line 1324
          goto while_break___42;
        }
        while_break___42: /* CIL Label */ ;
        }
      }
#line 1324
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
#line 1325
    state = (enum SGMLState )21;
    {
#line 1326
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 1326
      encoder->prev = start + i___0;
#line 1326
      ch = -1;
#line 1326
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
#line 1327
    goto switch_break___2;
    case_33: /* CIL Label */ 
#line 1329
    state = (enum SGMLState )23;
    {
#line 1330
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 1330
      encoder->prev = start + i___0;
#line 1330
      ch = -1;
#line 1330
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
#line 1331
    goto switch_break___2;
    case_63: /* CIL Label */ 
    {
#line 1333
    (scanner->pi)->length = (size_t )1;
#line 1334
    state = (enum SGMLState )30;
#line 1335
    push_state(scanner, (enum SGMLState )0);
    }
    {
#line 1336
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 1336
      encoder->prev = start + i___0;
#line 1336
      ch = -1;
#line 1336
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 1337
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 1339
    if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1340
      state = (enum SGMLState )11;
#line 1341
      (scanner->gi)->length = (size_t )0;
      {
#line 1342
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 1342
        if ((scanner->gi)->length < 256UL) {
          {
#line 1342
          while (1) {
            while_continue___47: /* CIL Label */ ;
#line 1342
            if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1342
              *((scanner->gi)->s + (scanner->gi)->length) = (char )'s';
#line 1342
              ((scanner->gi)->length) ++;
            } else {
              {
#line 1342
              real_string_push(scanner->gi, 's');
              }
            }
#line 1342
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
        }
#line 1342
        goto while_break___46;
      }
      while_break___46: /* CIL Label */ ;
      }
      {
#line 1343
      while (1) {
        while_continue___48: /* CIL Label */ ;
#line 1343
        if ((scanner->gi)->length < 256UL) {
          {
#line 1343
          while (1) {
            while_continue___49: /* CIL Label */ ;
#line 1343
            if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1343
              if (ch < 255) {
#line 1343
                *((scanner->gi)->s + (scanner->gi)->length) = (char )ch;
#line 1343
                ((scanner->gi)->length) ++;
              } else {
                {
#line 1343
                real_string_push(scanner->gi, ch);
                }
              }
            } else {
              {
#line 1343
              real_string_push(scanner->gi, ch);
              }
            }
#line 1343
            goto while_break___49;
          }
          while_break___49: /* CIL Label */ ;
          }
        }
#line 1343
        goto while_break___48;
      }
      while_break___48: /* CIL Label */ ;
      }
      {
#line 1344
      while (1) {
        while_continue___50: /* CIL Label */ ;
#line 1344
        encoder->prev = start + i___0;
#line 1344
        ch = -1;
#line 1344
        goto while_break___50;
      }
      while_break___50: /* CIL Label */ ;
      }
    } else {
#line 1346
      state = (enum SGMLState )0;
    }
#line 1348
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1350
    goto switch_break___0;
    case_11: /* CIL Label */ 
#line 1353
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 1354
      while (1) {
        while_continue___51: /* CIL Label */ ;
#line 1354
        if ((scanner->gi)->length < 256UL) {
          {
#line 1354
          while (1) {
            while_continue___52: /* CIL Label */ ;
#line 1354
            if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1354
              if (ch < 255) {
#line 1354
                *((scanner->gi)->s + (scanner->gi)->length) = (char )ch;
#line 1354
                ((scanner->gi)->length) ++;
              } else {
                {
#line 1354
                real_string_push(scanner->gi, ch);
                }
              }
            } else {
              {
#line 1354
              real_string_push(scanner->gi, ch);
              }
            }
#line 1354
            goto while_break___52;
          }
          while_break___52: /* CIL Label */ ;
          }
        }
#line 1354
        goto while_break___51;
      }
      while_break___51: /* CIL Label */ ;
      }
      {
#line 1355
      while (1) {
        while_continue___53: /* CIL Label */ ;
#line 1355
        encoder->prev = start + i___0;
#line 1355
        ch = -1;
#line 1355
        goto while_break___53;
      }
      while_break___53: /* CIL Label */ ;
      }
    } else {
#line 1357
      state = (enum SGMLState )12;
    }
#line 1359
    goto switch_break___0;
    case_12: /* CIL Label */ 
#line 1362
    if (ch == 62) {
#line 1363
      state = (enum SGMLState )20;
    } else
#line 1364
    if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1365
      (scanner->aname)->length = (size_t )1;
      {
#line 1366
      while (1) {
        while_continue___54: /* CIL Label */ ;
#line 1366
        if ((scanner->aname)->length < 256UL) {
          {
#line 1366
          while (1) {
            while_continue___55: /* CIL Label */ ;
#line 1366
            if ((scanner->aname)->length < (scanner->aname)->size) {
#line 1366
              if (ch < 255) {
#line 1366
                *((scanner->aname)->s + (scanner->aname)->length) = (char )ch;
#line 1366
                ((scanner->aname)->length) ++;
              } else {
                {
#line 1366
                real_string_push(scanner->aname, ch);
                }
              }
            } else {
              {
#line 1366
              real_string_push(scanner->aname, ch);
              }
            }
#line 1366
            goto while_break___55;
          }
          while_break___55: /* CIL Label */ ;
          }
        }
#line 1366
        goto while_break___54;
      }
      while_break___54: /* CIL Label */ ;
      }
#line 1367
      scanner->anames = encoder->prev;
#line 1368
      state = (enum SGMLState )13;
      {
#line 1369
      while (1) {
        while_continue___56: /* CIL Label */ ;
#line 1369
        encoder->prev = start + i___0;
#line 1369
        ch = -1;
#line 1369
        goto while_break___56;
      }
      while_break___56: /* CIL Label */ ;
      }
    } else {
      {
#line 1371
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 1371
        encoder->prev = start + i___0;
#line 1371
        ch = -1;
#line 1371
        goto while_break___57;
      }
      while_break___57: /* CIL Label */ ;
      }
    }
#line 1373
    goto switch_break___0;
    case_13: /* CIL Label */ 
#line 1376
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 1377
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 1377
        if ((scanner->aname)->length < 256UL) {
          {
#line 1377
          while (1) {
            while_continue___59: /* CIL Label */ ;
#line 1377
            if ((scanner->aname)->length < (scanner->aname)->size) {
#line 1377
              if (ch < 255) {
#line 1377
                *((scanner->aname)->s + (scanner->aname)->length) = (char )ch;
#line 1377
                ((scanner->aname)->length) ++;
              } else {
                {
#line 1377
                real_string_push(scanner->aname, ch);
                }
              }
            } else {
              {
#line 1377
              real_string_push(scanner->aname, ch);
              }
            }
#line 1377
            goto while_break___59;
          }
          while_break___59: /* CIL Label */ ;
          }
        }
#line 1377
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
      {
#line 1378
      while (1) {
        while_continue___60: /* CIL Label */ ;
#line 1378
        encoder->prev = start + i___0;
#line 1378
        ch = -1;
#line 1378
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
    } else {
#line 1380
      state = (enum SGMLState )14;
    }
#line 1382
    goto switch_break___0;
    case_14: /* CIL Label */ 
    {
#line 1386
    if (ch == 11) {
#line 1386
      goto case_11___0;
    }
#line 1386
    if (ch == 13) {
#line 1386
      goto case_11___0;
    }
#line 1386
    if (ch == 10) {
#line 1386
      goto case_11___0;
    }
#line 1386
    if (ch == 9) {
#line 1386
      goto case_11___0;
    }
#line 1386
    if (ch == 32) {
#line 1386
      goto case_11___0;
    }
#line 1389
    if (ch == 61) {
#line 1389
      goto case_61;
    }
#line 1394
    goto switch_default___2;
    case_11___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_9___1: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 1387
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 1387
      encoder->prev = start + i___0;
#line 1387
      ch = -1;
#line 1387
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
#line 1388
    goto switch_break___3;
    case_61: /* CIL Label */ 
#line 1390
    state = (enum SGMLState )15;
    {
#line 1391
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 1391
      encoder->prev = start + i___0;
#line 1391
      ch = -1;
#line 1391
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
#line 1392
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 1395
    if (ch == 62) {
#line 1395
      tmp___5 = 1;
    } else
#line 1395
    if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1395
      tmp___5 = 1;
    } else {
#line 1395
      tmp___5 = 0;
    }
#line 1399
    if (ch == 62) {
#line 1400
      state = (enum SGMLState )20;
    } else
#line 1401
    if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1402
      state = (enum SGMLState )12;
    } else {
#line 1405
      (scanner->parse_errors) ++;
#line 1406
      state = (enum SGMLState )12;
    }
#line 1408
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1410
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 1414
    if (ch == 11) {
#line 1414
      goto case_11___1;
    }
#line 1414
    if (ch == 13) {
#line 1414
      goto case_11___1;
    }
#line 1414
    if (ch == 10) {
#line 1414
      goto case_11___1;
    }
#line 1414
    if (ch == 9) {
#line 1414
      goto case_11___1;
    }
#line 1414
    if (ch == 32) {
#line 1414
      goto case_11___1;
    }
#line 1417
    if (ch == 62) {
#line 1417
      goto case_62;
    }
#line 1422
    if (ch == 34) {
#line 1422
      goto case_34;
    }
#line 1428
    if (ch == 39) {
#line 1428
      goto case_39;
    }
#line 1434
    goto switch_default___3;
    case_11___1: /* CIL Label */ 
    case_13___1: /* CIL Label */ 
    case_10___1: /* CIL Label */ 
    case_9___2: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    {
#line 1415
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 1415
      encoder->prev = start + i___0;
#line 1415
      ch = -1;
#line 1415
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 1416
    goto switch_break___4;
    case_62: /* CIL Label */ 
#line 1419
    (scanner->parse_errors) ++;
#line 1420
    state = (enum SGMLState )20;
#line 1421
    goto switch_break___4;
    case_34: /* CIL Label */ 
#line 1423
    state = (enum SGMLState )17;
#line 1424
    scanner->avals = start + i___0;
#line 1425
    (scanner->aval)->length = (size_t )1;
    {
#line 1426
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 1426
      encoder->prev = start + i___0;
#line 1426
      ch = -1;
#line 1426
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 1427
    goto switch_break___4;
    case_39: /* CIL Label */ 
#line 1429
    state = (enum SGMLState )18;
#line 1430
    scanner->avals = start + i___0;
#line 1431
    (scanner->aval)->length = (size_t )1;
    {
#line 1432
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 1432
      encoder->prev = start + i___0;
#line 1432
      ch = -1;
#line 1432
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
#line 1433
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 1435
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1435
      goto _L___4;
    } else {
      {
#line 1435
      tmp___6 = __ctype_b_loc();
      }
#line 1435
      if ((int const   )*(*tmp___6 + ch) & 32768) {
        _L___4: /* CIL Label */ 
#line 1436
        state = (enum SGMLState )16;
#line 1437
        scanner->avals = encoder->prev;
#line 1438
        (scanner->aval)->length = (size_t )1;
        {
#line 1439
        while (1) {
          while_continue___66: /* CIL Label */ ;
#line 1439
          if ((scanner->aval)->length < (scanner->aval)->size) {
#line 1439
            if (ch < 255) {
#line 1439
              *((scanner->aval)->s + (scanner->aval)->length) = (char )ch;
#line 1439
              ((scanner->aval)->length) ++;
            } else {
              {
#line 1439
              real_string_push(scanner->aval, ch);
              }
            }
          } else {
            {
#line 1439
            real_string_push(scanner->aval, ch);
            }
          }
#line 1439
          goto while_break___66;
        }
        while_break___66: /* CIL Label */ ;
        }
        {
#line 1440
        while (1) {
          while_continue___67: /* CIL Label */ ;
#line 1440
          encoder->prev = start + i___0;
#line 1440
          ch = -1;
#line 1440
          goto while_break___67;
        }
        while_break___67: /* CIL Label */ ;
        }
      } else {
#line 1443
        (scanner->parse_errors) ++;
#line 1444
        state = (enum SGMLState )12;
#line 1445
        goto switch_break___4;
      }
    }
#line 1447
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1449
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 1452
    if (ch == 62) {
#line 1452
      goto _L___5;
    } else {
      {
#line 1452
      tmp___7 = __ctype_b_loc();
      }
#line 1452
      if ((int const   )*(*tmp___7 + ch) & 8192) {
#line 1452
        goto _L___5;
      } else
#line 1452
      if (! ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long )))) {
        {
#line 1452
        tmp___8 = __ctype_b_loc();
        }
#line 1452
        if (! ((int const   )*(*tmp___8 + ch) & 32768)) {
          _L___5: /* CIL Label */ 
          {
#line 1454
          while (1) {
            while_continue___68: /* CIL Label */ ;
            {
#line 1454
            sgml_found(scanner, state, encoder->prev);
            }
#line 1454
            if (scanner->failed) {
#line 1454
              return (-1);
            }
#line 1454
            goto while_break___68;
          }
          while_break___68: /* CIL Label */ ;
          }
#line 1455
          state = (enum SGMLState )19;
#line 1456
          goto switch_break___0;
        }
      }
    }
    {
#line 1458
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1458
      if ((scanner->aval)->length < 256UL) {
        {
#line 1458
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 1458
          if ((scanner->aval)->length < (scanner->aval)->size) {
#line 1458
            if (ch < 255) {
#line 1458
              *((scanner->aval)->s + (scanner->aval)->length) = (char )ch;
#line 1458
              ((scanner->aval)->length) ++;
            } else {
              {
#line 1458
              real_string_push(scanner->aval, ch);
              }
            }
          } else {
            {
#line 1458
            real_string_push(scanner->aval, ch);
            }
          }
#line 1458
          goto while_break___70;
        }
        while_break___70: /* CIL Label */ ;
        }
      }
#line 1458
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 1459
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 1459
      encoder->prev = start + i___0;
#line 1459
      ch = -1;
#line 1459
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 1460
    goto switch_break___0;
    case_17: /* CIL Label */ 
#line 1463
    if (ch != 34) {
      {
#line 1464
      while (1) {
        while_continue___72: /* CIL Label */ ;
#line 1464
        if ((scanner->aval)->length < 256UL) {
          {
#line 1464
          while (1) {
            while_continue___73: /* CIL Label */ ;
#line 1464
            if ((scanner->aval)->length < (scanner->aval)->size) {
#line 1464
              if (ch < 255) {
#line 1464
                *((scanner->aval)->s + (scanner->aval)->length) = (char )ch;
#line 1464
                ((scanner->aval)->length) ++;
              } else {
                {
#line 1464
                real_string_push(scanner->aval, ch);
                }
              }
            } else {
              {
#line 1464
              real_string_push(scanner->aval, ch);
              }
            }
#line 1464
            goto while_break___73;
          }
          while_break___73: /* CIL Label */ ;
          }
        }
#line 1464
        goto while_break___72;
      }
      while_break___72: /* CIL Label */ ;
      }
      {
#line 1465
      while (1) {
        while_continue___74: /* CIL Label */ ;
#line 1465
        encoder->prev = start + i___0;
#line 1465
        ch = -1;
#line 1465
        goto while_break___74;
      }
      while_break___74: /* CIL Label */ ;
      }
#line 1466
      goto switch_break___0;
    }
    {
#line 1468
    while (1) {
      while_continue___75: /* CIL Label */ ;
      {
#line 1468
      sgml_found(scanner, state, encoder->prev);
      }
#line 1468
      if (scanner->failed) {
#line 1468
        return (-1);
      }
#line 1468
      goto while_break___75;
    }
    while_break___75: /* CIL Label */ ;
    }
#line 1469
    state = (enum SGMLState )19;
    {
#line 1470
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 1470
      encoder->prev = start + i___0;
#line 1470
      ch = -1;
#line 1470
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
#line 1471
    goto switch_break___0;
    case_18: /* CIL Label */ 
#line 1474
    if (ch != 39) {
      {
#line 1475
      while (1) {
        while_continue___77: /* CIL Label */ ;
#line 1475
        if ((scanner->aval)->length < 256UL) {
          {
#line 1475
          while (1) {
            while_continue___78: /* CIL Label */ ;
#line 1475
            if ((scanner->aval)->length < (scanner->aval)->size) {
#line 1475
              if (ch < 255) {
#line 1475
                *((scanner->aval)->s + (scanner->aval)->length) = (char )ch;
#line 1475
                ((scanner->aval)->length) ++;
              } else {
                {
#line 1475
                real_string_push(scanner->aval, ch);
                }
              }
            } else {
              {
#line 1475
              real_string_push(scanner->aval, ch);
              }
            }
#line 1475
            goto while_break___78;
          }
          while_break___78: /* CIL Label */ ;
          }
        }
#line 1475
        goto while_break___77;
      }
      while_break___77: /* CIL Label */ ;
      }
      {
#line 1476
      while (1) {
        while_continue___79: /* CIL Label */ ;
#line 1476
        encoder->prev = start + i___0;
#line 1476
        ch = -1;
#line 1476
        goto while_break___79;
      }
      while_break___79: /* CIL Label */ ;
      }
#line 1477
      goto switch_break___0;
    }
    {
#line 1479
    while (1) {
      while_continue___80: /* CIL Label */ ;
      {
#line 1479
      sgml_found(scanner, state, encoder->prev);
      }
#line 1479
      if (scanner->failed) {
#line 1479
        return (-1);
      }
#line 1479
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 1480
    state = (enum SGMLState )19;
    {
#line 1481
    while (1) {
      while_continue___81: /* CIL Label */ ;
#line 1481
      encoder->prev = start + i___0;
#line 1481
      ch = -1;
#line 1481
      goto while_break___81;
    }
    while_break___81: /* CIL Label */ ;
    }
#line 1482
    goto switch_break___0;
    case_19: /* CIL Label */ 
    {
#line 1485
    while (1) {
      while_continue___82: /* CIL Label */ ;
      {
#line 1485
      sgml_found(scanner, state, encoder->prev);
      }
#line 1485
      if (scanner->failed) {
#line 1485
        return (-1);
      }
#line 1485
      goto while_break___82;
    }
    while_break___82: /* CIL Label */ ;
    }
#line 1486
    state = (enum SGMLState )12;
#line 1487
    goto switch_break___0;
    case_20: /* CIL Label */ 
    {
#line 1490
    while (1) {
      while_continue___83: /* CIL Label */ ;
      {
#line 1490
      sgml_found(scanner, state, start + i___0);
      }
#line 1490
      if (scanner->failed) {
#line 1490
        return (-1);
      }
#line 1490
      goto while_break___83;
    }
    while_break___83: /* CIL Label */ ;
    }
#line 1491
    state = (enum SGMLState )0;
    {
#line 1492
    while (1) {
      while_continue___84: /* CIL Label */ ;
#line 1492
      encoder->prev = start + i___0;
#line 1492
      ch = -1;
#line 1492
      goto while_break___84;
    }
    while_break___84: /* CIL Label */ ;
    }
#line 1493
    goto switch_break___0;
    case_21: /* CIL Label */ 
#line 1496
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 1497
      while (1) {
        while_continue___85: /* CIL Label */ ;
#line 1497
        if ((scanner->gi)->length < 256UL) {
          {
#line 1497
          while (1) {
            while_continue___86: /* CIL Label */ ;
#line 1497
            if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1497
              if (ch < 255) {
#line 1497
                *((scanner->gi)->s + (scanner->gi)->length) = (char )ch;
#line 1497
                ((scanner->gi)->length) ++;
              } else {
                {
#line 1497
                real_string_push(scanner->gi, ch);
                }
              }
            } else {
              {
#line 1497
              real_string_push(scanner->gi, ch);
              }
            }
#line 1497
            goto while_break___86;
          }
          while_break___86: /* CIL Label */ ;
          }
        }
#line 1497
        goto while_break___85;
      }
      while_break___85: /* CIL Label */ ;
      }
      {
#line 1498
      while (1) {
        while_continue___87: /* CIL Label */ ;
#line 1498
        encoder->prev = start + i___0;
#line 1498
        ch = -1;
#line 1498
        goto while_break___87;
      }
      while_break___87: /* CIL Label */ ;
      }
    } else {
#line 1500
      state = (enum SGMLState )22;
    }
#line 1502
    goto switch_break___0;
    case_22: /* CIL Label */ 
#line 1505
    if (ch == 62) {
      {
#line 1506
      while (1) {
        while_continue___88: /* CIL Label */ ;
        {
#line 1506
        sgml_found(scanner, state, start + i___0);
        }
#line 1506
        if (scanner->failed) {
#line 1506
          return (-1);
        }
#line 1506
        goto while_break___88;
      }
      while_break___88: /* CIL Label */ ;
      }
#line 1507
      state = (enum SGMLState )0;
    }
    {
#line 1509
    while (1) {
      while_continue___89: /* CIL Label */ ;
#line 1509
      encoder->prev = start + i___0;
#line 1509
      ch = -1;
#line 1509
      goto while_break___89;
    }
    while_break___89: /* CIL Label */ ;
    }
#line 1510
    goto switch_break___0;
    case_23: /* CIL Label */ 
    {
#line 1514
    if (ch == 45) {
#line 1514
      goto case_45;
    }
#line 1520
    if (ch == 91) {
#line 1520
      goto case_91;
    }
#line 1527
    goto switch_default___4;
    case_45: /* CIL Label */ 
    {
#line 1515
    scanner->comments = scanner->tags;
#line 1516
    state = (enum SGMLState )25;
#line 1517
    push_state(scanner, (enum SGMLState )0);
    }
    {
#line 1518
    while (1) {
      while_continue___90: /* CIL Label */ ;
#line 1518
      encoder->prev = start + i___0;
#line 1518
      ch = -1;
#line 1518
      goto while_break___90;
    }
    while_break___90: /* CIL Label */ ;
    }
#line 1519
    goto switch_break___5;
    case_91: /* CIL Label */ 
#line 1521
    scanner->markeds = scanner->tags;
#line 1522
    state = (enum SGMLState )32;
#line 1523
    (scanner->gi)->length = (size_t )0;
    {
#line 1524
    while (1) {
      while_continue___91: /* CIL Label */ ;
#line 1524
      if ((scanner->gi)->length < 256UL) {
        {
#line 1524
        while (1) {
          while_continue___92: /* CIL Label */ ;
#line 1524
          if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1524
            *((scanner->gi)->s + (scanner->gi)->length) = (char )'[';
#line 1524
            ((scanner->gi)->length) ++;
          } else {
            {
#line 1524
            real_string_push(scanner->gi, '[');
            }
          }
#line 1524
          goto while_break___92;
        }
        while_break___92: /* CIL Label */ ;
        }
      }
#line 1524
      goto while_break___91;
    }
    while_break___91: /* CIL Label */ ;
    }
    {
#line 1525
    while (1) {
      while_continue___93: /* CIL Label */ ;
#line 1525
      encoder->prev = start + i___0;
#line 1525
      ch = -1;
#line 1525
      goto while_break___93;
    }
    while_break___93: /* CIL Label */ ;
    }
#line 1526
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
#line 1528
    if (ch == 68) {
#line 1528
      goto _L___6;
    } else
#line 1528
    if (ch == 100) {
      _L___6: /* CIL Label */ 
#line 1529
      state = (enum SGMLState )24;
#line 1530
      scanner->doctype_declarations = scanner->tags;
#line 1531
      (scanner->name)->length = (size_t )0;
      {
#line 1532
      while (1) {
        while_continue___94: /* CIL Label */ ;
#line 1532
        if ((scanner->name)->length < (scanner->name)->size) {
          {
#line 1532
          tmp___11 = toupper(ch);
          }
#line 1532
          if (tmp___11 < 255) {
            {
#line 1532
            tmp___9 = toupper(ch);
#line 1532
            *((scanner->name)->s + (scanner->name)->length) = (char )tmp___9;
#line 1532
            ((scanner->name)->length) ++;
            }
          } else {
            {
#line 1532
            tmp___10 = toupper(ch);
#line 1532
            real_string_push(scanner->name, tmp___10);
            }
          }
        } else {
          {
#line 1532
          tmp___10 = toupper(ch);
#line 1532
          real_string_push(scanner->name, tmp___10);
          }
        }
#line 1532
        goto while_break___94;
      }
      while_break___94: /* CIL Label */ ;
      }
      {
#line 1533
      while (1) {
        while_continue___95: /* CIL Label */ ;
#line 1533
        encoder->prev = start + i___0;
#line 1533
        ch = -1;
#line 1533
        goto while_break___95;
      }
      while_break___95: /* CIL Label */ ;
      }
    } else {
#line 1536
      (scanner->parse_errors) ++;
#line 1537
      state = (enum SGMLState )0;
    }
    switch_break___5: /* CIL Label */ ;
    }
#line 1540
    goto switch_break___0;
    case_25: /* CIL Label */ 
#line 1543
    if (ch == 45) {
#line 1544
      state = (enum SGMLState )26;
      {
#line 1545
      while (1) {
        while_continue___96: /* CIL Label */ ;
#line 1545
        encoder->prev = start + i___0;
#line 1545
        ch = -1;
#line 1545
        goto while_break___96;
      }
      while_break___96: /* CIL Label */ ;
      }
    } else {
      {
#line 1547
      (scanner->parse_errors) ++;
#line 1548
      state = pop_state(scanner);
      }
    }
#line 1550
    goto switch_break___0;
    case_26: /* CIL Label */ 
#line 1553
    if (ch == 45) {
#line 1554
      state = (enum SGMLState )28;
    } else
#line 1555
    if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1556
      state = (enum SGMLState )27;
#line 1557
      (scanner->comment_word)->length = (size_t )0;
      {
#line 1558
      while (1) {
        while_continue___97: /* CIL Label */ ;
#line 1558
        if ((scanner->comment_word)->length < 256UL) {
          {
#line 1558
          while (1) {
            while_continue___98: /* CIL Label */ ;
#line 1558
            if ((scanner->comment_word)->length < (scanner->comment_word)->size) {
#line 1558
              *((scanner->comment_word)->s + (scanner->comment_word)->length) = (char )'c';
#line 1558
              ((scanner->comment_word)->length) ++;
            } else {
              {
#line 1558
              real_string_push(scanner->comment_word, 'c');
              }
            }
#line 1558
            goto while_break___98;
          }
          while_break___98: /* CIL Label */ ;
          }
        }
#line 1558
        goto while_break___97;
      }
      while_break___97: /* CIL Label */ ;
      }
      {
#line 1559
      while (1) {
        while_continue___99: /* CIL Label */ ;
#line 1559
        if ((scanner->comment_word)->length < 256UL) {
          {
#line 1559
          while (1) {
            while_continue___100: /* CIL Label */ ;
#line 1559
            if ((scanner->comment_word)->length < (scanner->comment_word)->size) {
#line 1559
              if (ch < 255) {
#line 1559
                *((scanner->comment_word)->s + (scanner->comment_word)->length) = (char )ch;
#line 1559
                ((scanner->comment_word)->length) ++;
              } else {
                {
#line 1559
                real_string_push(scanner->comment_word, ch);
                }
              }
            } else {
              {
#line 1559
              real_string_push(scanner->comment_word, ch);
              }
            }
#line 1559
            goto while_break___100;
          }
          while_break___100: /* CIL Label */ ;
          }
        }
#line 1559
        goto while_break___99;
      }
      while_break___99: /* CIL Label */ ;
      }
#line 1560
      scanner->comment_words = encoder->prev;
    }
    {
#line 1562
    while (1) {
      while_continue___101: /* CIL Label */ ;
#line 1562
      encoder->prev = start + i___0;
#line 1562
      ch = -1;
#line 1562
      goto while_break___101;
    }
    while_break___101: /* CIL Label */ ;
    }
#line 1563
    goto switch_break___0;
    case_27: /* CIL Label */ 
#line 1567
    if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1567
      if (ch != 45) {
        {
#line 1568
        while (1) {
          while_continue___102: /* CIL Label */ ;
#line 1568
          if ((scanner->comment_word)->length < 256UL) {
            {
#line 1568
            while (1) {
              while_continue___103: /* CIL Label */ ;
#line 1568
              if ((scanner->comment_word)->length < (scanner->comment_word)->size) {
#line 1568
                if (ch < 255) {
#line 1568
                  *((scanner->comment_word)->s + (scanner->comment_word)->length) = (char )ch;
#line 1568
                  ((scanner->comment_word)->length) ++;
                } else {
                  {
#line 1568
                  real_string_push(scanner->comment_word, ch);
                  }
                }
              } else {
                {
#line 1568
                real_string_push(scanner->comment_word, ch);
                }
              }
#line 1568
              goto while_break___103;
            }
            while_break___103: /* CIL Label */ ;
            }
          }
#line 1568
          goto while_break___102;
        }
        while_break___102: /* CIL Label */ ;
        }
        {
#line 1569
        while (1) {
          while_continue___104: /* CIL Label */ ;
#line 1569
          encoder->prev = start + i___0;
#line 1569
          ch = -1;
#line 1569
          goto while_break___104;
        }
        while_break___104: /* CIL Label */ ;
        }
      } else {
#line 1567
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
      {
#line 1571
      while (1) {
        while_continue___105: /* CIL Label */ ;
        {
#line 1571
        sgml_found(scanner, state, encoder->prev);
        }
#line 1571
        if (scanner->failed) {
#line 1571
          return (-1);
        }
#line 1571
        goto while_break___105;
      }
      while_break___105: /* CIL Label */ ;
      }
#line 1572
      state = (enum SGMLState )26;
    }
#line 1574
    goto switch_break___0;
    case_28: /* CIL Label */ 
#line 1577
    if (ch == 45) {
#line 1578
      state = (enum SGMLState )29;
      {
#line 1579
      while (1) {
        while_continue___106: /* CIL Label */ ;
#line 1579
        encoder->prev = start + i___0;
#line 1579
        ch = -1;
#line 1579
        goto while_break___106;
      }
      while_break___106: /* CIL Label */ ;
      }
    } else {
#line 1581
      state = (enum SGMLState )26;
    }
#line 1583
    goto switch_break___0;
    case_29: /* CIL Label */ 
#line 1588
    if (ch == 62) {
      {
#line 1589
      while (1) {
        while_continue___107: /* CIL Label */ ;
        {
#line 1589
        sgml_found(scanner, state, start + i___0);
        }
#line 1589
        if (scanner->failed) {
#line 1589
          return (-1);
        }
#line 1589
        goto while_break___107;
      }
      while_break___107: /* CIL Label */ ;
      }
      {
#line 1590
      state = pop_state(scanner);
      }
    } else
#line 1591
    if (ch == 45) {
#line 1592
      state = (enum SGMLState )25;
    } else {
      {
#line 1593
      tmp___12 = __ctype_b_loc();
      }
#line 1593
      if (! ((int const   )*(*tmp___12 + ch) & 8192)) {
#line 1596
        (scanner->parse_errors) ++;
      }
    }
    {
#line 1598
    while (1) {
      while_continue___108: /* CIL Label */ ;
#line 1598
      encoder->prev = start + i___0;
#line 1598
      ch = -1;
#line 1598
      goto while_break___108;
    }
    while_break___108: /* CIL Label */ ;
    }
#line 1599
    goto switch_break___0;
    case_30: /* CIL Label */ 
#line 1602
    if (ch == 63) {
#line 1602
      if ((unsigned int )scanner->type == 1U) {
#line 1603
        state = (enum SGMLState )31;
      } else {
#line 1602
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 1604
    if (ch == 62) {
#line 1604
      if ((unsigned int )scanner->type != 1U) {
        {
#line 1605
        while (1) {
          while_continue___109: /* CIL Label */ ;
          {
#line 1605
          sgml_found(scanner, state, start + i___0);
          }
#line 1605
          if (scanner->failed) {
#line 1605
            return (-1);
          }
#line 1605
          goto while_break___109;
        }
        while_break___109: /* CIL Label */ ;
        }
        {
#line 1606
        state = pop_state(scanner);
        }
      } else {
#line 1604
        goto _L___8;
      }
    } else {
      _L___8: /* CIL Label */ 
      {
#line 1608
      while (1) {
        while_continue___110: /* CIL Label */ ;
#line 1608
        if ((scanner->pi)->length < 256UL) {
          {
#line 1608
          while (1) {
            while_continue___111: /* CIL Label */ ;
#line 1608
            if ((scanner->pi)->length < (scanner->pi)->size) {
#line 1608
              if (ch < 255) {
#line 1608
                *((scanner->pi)->s + (scanner->pi)->length) = (char )ch;
#line 1608
                ((scanner->pi)->length) ++;
              } else {
                {
#line 1608
                real_string_push(scanner->pi, ch);
                }
              }
            } else {
              {
#line 1608
              real_string_push(scanner->pi, ch);
              }
            }
#line 1608
            goto while_break___111;
          }
          while_break___111: /* CIL Label */ ;
          }
        }
#line 1608
        goto while_break___110;
      }
      while_break___110: /* CIL Label */ ;
      }
    }
    {
#line 1610
    while (1) {
      while_continue___112: /* CIL Label */ ;
#line 1610
      encoder->prev = start + i___0;
#line 1610
      ch = -1;
#line 1610
      goto while_break___112;
    }
    while_break___112: /* CIL Label */ ;
    }
#line 1611
    goto switch_break___0;
    case_31: /* CIL Label */ 
    {
#line 1615
    if (ch == 63) {
#line 1615
      goto case_63___0;
    }
#line 1618
    if (ch == 62) {
#line 1618
      goto case_62___0;
    }
#line 1622
    goto switch_default___5;
    case_63___0: /* CIL Label */ 
    {
#line 1616
    while (1) {
      while_continue___113: /* CIL Label */ ;
#line 1616
      if ((scanner->pi)->length < 256UL) {
        {
#line 1616
        while (1) {
          while_continue___114: /* CIL Label */ ;
#line 1616
          if ((scanner->pi)->length < (scanner->pi)->size) {
#line 1616
            *((scanner->pi)->s + (scanner->pi)->length) = (char )'?';
#line 1616
            ((scanner->pi)->length) ++;
          } else {
            {
#line 1616
            real_string_push(scanner->pi, '?');
            }
          }
#line 1616
          goto while_break___114;
        }
        while_break___114: /* CIL Label */ ;
        }
      }
#line 1616
      goto while_break___113;
    }
    while_break___113: /* CIL Label */ ;
    }
#line 1617
    goto switch_break___6;
    case_62___0: /* CIL Label */ 
    {
#line 1619
    while (1) {
      while_continue___115: /* CIL Label */ ;
      {
#line 1619
      sgml_found(scanner, state, start + i___0);
      }
#line 1619
      if (scanner->failed) {
#line 1619
        return (-1);
      }
#line 1619
      goto while_break___115;
    }
    while_break___115: /* CIL Label */ ;
    }
    {
#line 1620
    state = pop_state(scanner);
    }
#line 1621
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 1623
    while (1) {
      while_continue___116: /* CIL Label */ ;
#line 1623
      if ((scanner->pi)->length < 256UL) {
        {
#line 1623
        while (1) {
          while_continue___117: /* CIL Label */ ;
#line 1623
          if ((scanner->pi)->length < (scanner->pi)->size) {
#line 1623
            *((scanner->pi)->s + (scanner->pi)->length) = (char )'?';
#line 1623
            ((scanner->pi)->length) ++;
          } else {
            {
#line 1623
            real_string_push(scanner->pi, '?');
            }
          }
#line 1623
          goto while_break___117;
        }
        while_break___117: /* CIL Label */ ;
        }
      }
#line 1623
      goto while_break___116;
    }
    while_break___116: /* CIL Label */ ;
    }
    {
#line 1624
    while (1) {
      while_continue___118: /* CIL Label */ ;
#line 1624
      if ((scanner->pi)->length < 256UL) {
        {
#line 1624
        while (1) {
          while_continue___119: /* CIL Label */ ;
#line 1624
          if ((scanner->pi)->length < (scanner->pi)->size) {
#line 1624
            if (ch < 255) {
#line 1624
              *((scanner->pi)->s + (scanner->pi)->length) = (char )ch;
#line 1624
              ((scanner->pi)->length) ++;
            } else {
              {
#line 1624
              real_string_push(scanner->pi, ch);
              }
            }
          } else {
            {
#line 1624
            real_string_push(scanner->pi, ch);
            }
          }
#line 1624
          goto while_break___119;
        }
        while_break___119: /* CIL Label */ ;
        }
      }
#line 1624
      goto while_break___118;
    }
    while_break___118: /* CIL Label */ ;
    }
#line 1625
    state = (enum SGMLState )30;
    switch_break___6: /* CIL Label */ ;
    }
    {
#line 1627
    while (1) {
      while_continue___120: /* CIL Label */ ;
#line 1627
      encoder->prev = start + i___0;
#line 1627
      ch = -1;
#line 1627
      goto while_break___120;
    }
    while_break___120: /* CIL Label */ ;
    }
#line 1628
    goto switch_break___0;
    case_32___1: /* CIL Label */ 
#line 1635
    if ((scanner->gi)->length == 1UL) {
#line 1635
      if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1635
        goto _L___11;
      } else
#line 1635
      if (ch == 38) {
#line 1635
        goto _L___11;
      } else
#line 1635
      if (ch == 59) {
#line 1635
        goto _L___11;
      } else {
#line 1635
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 1635
    if ((scanner->gi)->length > 1UL) {
#line 1635
      if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1635
        goto _L___11;
      } else
#line 1635
      if (ch == 38) {
#line 1635
        goto _L___11;
      } else
#line 1635
      if (ch == 59) {
        _L___11: /* CIL Label */ 
        {
#line 1639
        while (1) {
          while_continue___121: /* CIL Label */ ;
#line 1639
          if ((scanner->gi)->length < 256UL) {
            {
#line 1639
            while (1) {
              while_continue___122: /* CIL Label */ ;
#line 1639
              if ((scanner->gi)->length < (scanner->gi)->size) {
#line 1639
                if (ch < 255) {
#line 1639
                  *((scanner->gi)->s + (scanner->gi)->length) = (char )ch;
#line 1639
                  ((scanner->gi)->length) ++;
                } else {
                  {
#line 1639
                  real_string_push(scanner->gi, ch);
                  }
                }
              } else {
                {
#line 1639
                real_string_push(scanner->gi, ch);
                }
              }
#line 1639
              goto while_break___122;
            }
            while_break___122: /* CIL Label */ ;
            }
          }
#line 1639
          goto while_break___121;
        }
        while_break___121: /* CIL Label */ ;
        }
        {
#line 1640
        while (1) {
          while_continue___123: /* CIL Label */ ;
#line 1640
          encoder->prev = start + i___0;
#line 1640
          ch = -1;
#line 1640
          goto while_break___123;
        }
        while_break___123: /* CIL Label */ ;
        }
      } else {
#line 1642
        state = (enum SGMLState )33;
      }
    } else {
#line 1642
      state = (enum SGMLState )33;
    }
#line 1644
    goto switch_break___0;
    case_33___0: /* CIL Label */ 
    {
#line 1647
    tmp___14 = __ctype_b_loc();
    }
#line 1647
    if ((int const   )*(*tmp___14 + ch) & 8192) {
      {
#line 1648
      while (1) {
        while_continue___124: /* CIL Label */ ;
#line 1648
        encoder->prev = start + i___0;
#line 1648
        ch = -1;
#line 1648
        goto while_break___124;
      }
      while_break___124: /* CIL Label */ ;
      }
    } else
#line 1649
    if (ch == 91) {
      {
#line 1650
      *((scanner->gi)->s + (scanner->gi)->length) = (char)0;
#line 1650
      tmp___13 = strcmp((char const   *)(scanner->gi)->s, "[CDATA");
      }
#line 1650
      if (tmp___13 == 0) {
#line 1651
        state = (enum SGMLState )34;
      } else {
        {
#line 1656
        while (1) {
          while_continue___125: /* CIL Label */ ;
          {
#line 1656
          sgml_found(scanner, state, start + i___0);
          }
#line 1656
          if (scanner->failed) {
#line 1656
            return (-1);
          }
#line 1656
          goto while_break___125;
        }
        while_break___125: /* CIL Label */ ;
        }
#line 1657
        state = (enum SGMLState )0;
      }
      {
#line 1659
      while (1) {
        while_continue___126: /* CIL Label */ ;
#line 1659
        encoder->prev = start + i___0;
#line 1659
        ch = -1;
#line 1659
        goto while_break___126;
      }
      while_break___126: /* CIL Label */ ;
      }
    } else {
#line 1662
      (scanner->parse_errors) ++;
#line 1663
      state = (enum SGMLState )0;
    }
#line 1665
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
#line 1668
    if (ch == 93) {
#line 1669
      state = (enum SGMLState )36;
    } else
#line 1670
    if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1671
      (scanner->word)->length = (size_t )0;
      {
#line 1672
      while (1) {
        while_continue___127: /* CIL Label */ ;
#line 1672
        if ((scanner->word)->length < 256UL) {
          {
#line 1672
          while (1) {
            while_continue___128: /* CIL Label */ ;
#line 1672
            if ((scanner->word)->length < (scanner->word)->size) {
#line 1672
              *((scanner->word)->s + (scanner->word)->length) = (char )'w';
#line 1672
              ((scanner->word)->length) ++;
            } else {
              {
#line 1672
              real_string_push(scanner->word, 'w');
              }
            }
#line 1672
            goto while_break___128;
          }
          while_break___128: /* CIL Label */ ;
          }
        }
#line 1672
        goto while_break___127;
      }
      while_break___127: /* CIL Label */ ;
      }
      {
#line 1673
      while (1) {
        while_continue___129: /* CIL Label */ ;
#line 1673
        if ((scanner->word)->length < 256UL) {
          {
#line 1673
          while (1) {
            while_continue___130: /* CIL Label */ ;
#line 1673
            if ((scanner->word)->length < (scanner->word)->size) {
#line 1673
              if (ch < 255) {
#line 1673
                *((scanner->word)->s + (scanner->word)->length) = (char )ch;
#line 1673
                ((scanner->word)->length) ++;
              } else {
                {
#line 1673
                real_string_push(scanner->word, ch);
                }
              }
            } else {
              {
#line 1673
              real_string_push(scanner->word, ch);
              }
            }
#line 1673
            goto while_break___130;
          }
          while_break___130: /* CIL Label */ ;
          }
        }
#line 1673
        goto while_break___129;
      }
      while_break___129: /* CIL Label */ ;
      }
#line 1674
      scanner->words = encoder->prev;
#line 1675
      state = (enum SGMLState )35;
    }
    {
#line 1677
    while (1) {
      while_continue___131: /* CIL Label */ ;
#line 1677
      encoder->prev = start + i___0;
#line 1677
      ch = -1;
#line 1677
      goto while_break___131;
    }
    while_break___131: /* CIL Label */ ;
    }
#line 1678
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 1681
    if ((scanner->word_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
#line 1681
      if (ch != 93) {
        {
#line 1682
        while (1) {
          while_continue___132: /* CIL Label */ ;
#line 1682
          if ((scanner->word)->length < 256UL) {
            {
#line 1682
            while (1) {
              while_continue___133: /* CIL Label */ ;
#line 1682
              if ((scanner->word)->length < (scanner->word)->size) {
#line 1682
                if (ch < 255) {
#line 1682
                  *((scanner->word)->s + (scanner->word)->length) = (char )ch;
#line 1682
                  ((scanner->word)->length) ++;
                } else {
                  {
#line 1682
                  real_string_push(scanner->word, ch);
                  }
                }
              } else {
                {
#line 1682
                real_string_push(scanner->word, ch);
                }
              }
#line 1682
              goto while_break___133;
            }
            while_break___133: /* CIL Label */ ;
            }
          }
#line 1682
          goto while_break___132;
        }
        while_break___132: /* CIL Label */ ;
        }
        {
#line 1683
        while (1) {
          while_continue___134: /* CIL Label */ ;
#line 1683
          encoder->prev = start + i___0;
#line 1683
          ch = -1;
#line 1683
          goto while_break___134;
        }
        while_break___134: /* CIL Label */ ;
        }
      } else {
#line 1681
        goto _L___13;
      }
    } else {
      _L___13: /* CIL Label */ 
      {
#line 1685
      while (1) {
        while_continue___135: /* CIL Label */ ;
        {
#line 1685
        sgml_found(scanner, state, encoder->prev);
        }
#line 1685
        if (scanner->failed) {
#line 1685
          return (-1);
        }
#line 1685
        goto while_break___135;
      }
      while_break___135: /* CIL Label */ ;
      }
#line 1686
      state = (enum SGMLState )34;
    }
#line 1688
    goto switch_break___0;
    case_36: /* CIL Label */ 
#line 1691
    if (ch == 93) {
#line 1692
      state = (enum SGMLState )37;
      {
#line 1693
      while (1) {
        while_continue___136: /* CIL Label */ ;
#line 1693
        encoder->prev = start + i___0;
#line 1693
        ch = -1;
#line 1693
        goto while_break___136;
      }
      while_break___136: /* CIL Label */ ;
      }
    } else {
#line 1695
      state = (enum SGMLState )34;
    }
#line 1697
    goto switch_break___0;
    case_37: /* CIL Label */ 
#line 1700
    if (ch == 62) {
      {
#line 1701
      while (1) {
        while_continue___137: /* CIL Label */ ;
        {
#line 1701
        sgml_found(scanner, state, start + i___0);
        }
#line 1701
        if (scanner->failed) {
#line 1701
          return (-1);
        }
#line 1701
        goto while_break___137;
      }
      while_break___137: /* CIL Label */ ;
      }
      {
#line 1702
      while (1) {
        while_continue___138: /* CIL Label */ ;
#line 1702
        encoder->prev = start + i___0;
#line 1702
        ch = -1;
#line 1702
        goto while_break___138;
      }
      while_break___138: /* CIL Label */ ;
      }
#line 1703
      state = (enum SGMLState )0;
    } else
#line 1704
    if (ch == 93) {
      {
#line 1705
      while (1) {
        while_continue___139: /* CIL Label */ ;
#line 1705
        encoder->prev = start + i___0;
#line 1705
        ch = -1;
#line 1705
        goto while_break___139;
      }
      while_break___139: /* CIL Label */ ;
      }
    } else {
#line 1707
      state = (enum SGMLState )34;
    }
#line 1709
    goto switch_break___0;
    case_24: /* CIL Label */ 
#line 1712
    if ((scanner->name)->length < 7UL) {
      {
#line 1712
      tmp___19 = toupper(ch);
      }
#line 1712
      if (tmp___19 == (int )*("DOCTYPE" + (scanner->name)->length)) {
        {
#line 1714
        while (1) {
          while_continue___140: /* CIL Label */ ;
#line 1714
          if ((scanner->name)->length < 256UL) {
            {
#line 1714
            while (1) {
              while_continue___141: /* CIL Label */ ;
#line 1714
              if ((scanner->name)->length < (scanner->name)->size) {
                {
#line 1714
                tmp___17 = toupper(ch);
                }
#line 1714
                if (tmp___17 < 255) {
                  {
#line 1714
                  tmp___15 = toupper(ch);
#line 1714
                  *((scanner->name)->s + (scanner->name)->length) = (char )tmp___15;
#line 1714
                  ((scanner->name)->length) ++;
                  }
                } else {
                  {
#line 1714
                  tmp___16 = toupper(ch);
#line 1714
                  real_string_push(scanner->name, tmp___16);
                  }
                }
              } else {
                {
#line 1714
                tmp___16 = toupper(ch);
#line 1714
                real_string_push(scanner->name, tmp___16);
                }
              }
#line 1714
              goto while_break___141;
            }
            while_break___141: /* CIL Label */ ;
            }
          }
#line 1714
          goto while_break___140;
        }
        while_break___140: /* CIL Label */ ;
        }
        {
#line 1715
        while (1) {
          while_continue___142: /* CIL Label */ ;
#line 1715
          encoder->prev = start + i___0;
#line 1715
          ch = -1;
#line 1715
          goto while_break___142;
        }
        while_break___142: /* CIL Label */ ;
        }
      } else {
#line 1712
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 1716
    if ((scanner->name)->length == 7UL) {
      {
#line 1716
      tmp___18 = __ctype_b_loc();
      }
#line 1716
      if ((int const   )*(*tmp___18 + ch) & 8192) {
#line 1717
        (scanner->name)->length = (size_t )0;
        {
#line 1718
        while (1) {
          while_continue___143: /* CIL Label */ ;
#line 1718
          if ((scanner->name)->length < 256UL) {
            {
#line 1718
            while (1) {
              while_continue___144: /* CIL Label */ ;
#line 1718
              if ((scanner->name)->length < (scanner->name)->size) {
#line 1718
                *((scanner->name)->s + (scanner->name)->length) = (char )'d';
#line 1718
                ((scanner->name)->length) ++;
              } else {
                {
#line 1718
                real_string_push(scanner->name, 'd');
                }
              }
#line 1718
              goto while_break___144;
            }
            while_break___144: /* CIL Label */ ;
            }
          }
#line 1718
          goto while_break___143;
        }
        while_break___143: /* CIL Label */ ;
        }
        {
#line 1719
        while (1) {
          while_continue___145: /* CIL Label */ ;
#line 1719
          if ((scanner->name)->length < 256UL) {
            {
#line 1719
            while (1) {
              while_continue___146: /* CIL Label */ ;
#line 1719
              if ((scanner->name)->length < (scanner->name)->size) {
#line 1719
                *((scanner->name)->s + (scanner->name)->length) = (char )'n';
#line 1719
                ((scanner->name)->length) ++;
              } else {
                {
#line 1719
                real_string_push(scanner->name, 'n');
                }
              }
#line 1719
              goto while_break___146;
            }
            while_break___146: /* CIL Label */ ;
            }
          }
#line 1719
          goto while_break___145;
        }
        while_break___145: /* CIL Label */ ;
        }
#line 1720
        state = (enum SGMLState )38;
        {
#line 1721
        while (1) {
          while_continue___147: /* CIL Label */ ;
#line 1721
          encoder->prev = start + i___0;
#line 1721
          ch = -1;
#line 1721
          goto while_break___147;
        }
        while_break___147: /* CIL Label */ ;
        }
      } else {
#line 1723
        (scanner->parse_errors) ++;
#line 1724
        state = (enum SGMLState )0;
      }
    } else {
#line 1723
      (scanner->parse_errors) ++;
#line 1724
      state = (enum SGMLState )0;
    }
#line 1726
    goto switch_break___0;
    case_38: /* CIL Label */ 
#line 1729
    if ((scanner->name)->length == 2UL) {
#line 1730
      if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
        {
#line 1731
        while (1) {
          while_continue___148: /* CIL Label */ ;
#line 1731
          if ((scanner->name)->length < 256UL) {
            {
#line 1731
            while (1) {
              while_continue___149: /* CIL Label */ ;
#line 1731
              if ((scanner->name)->length < (scanner->name)->size) {
#line 1731
                if (ch < 255) {
#line 1731
                  *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 1731
                  ((scanner->name)->length) ++;
                } else {
                  {
#line 1731
                  real_string_push(scanner->name, ch);
                  }
                }
              } else {
                {
#line 1731
                real_string_push(scanner->name, ch);
                }
              }
#line 1731
              goto while_break___149;
            }
            while_break___149: /* CIL Label */ ;
            }
          }
#line 1731
          goto while_break___148;
        }
        while_break___148: /* CIL Label */ ;
        }
#line 1732
        scanner->doctypes = encoder->prev;
        {
#line 1733
        while (1) {
          while_continue___150: /* CIL Label */ ;
#line 1733
          encoder->prev = start + i___0;
#line 1733
          ch = -1;
#line 1733
          goto while_break___150;
        }
        while_break___150: /* CIL Label */ ;
        }
      } else {
        {
#line 1734
        tmp___20 = __ctype_b_loc();
        }
#line 1734
        if ((int const   )*(*tmp___20 + ch) & 8192) {
          {
#line 1738
          while (1) {
            while_continue___151: /* CIL Label */ ;
#line 1738
            encoder->prev = start + i___0;
#line 1738
            ch = -1;
#line 1738
            goto while_break___151;
          }
          while_break___151: /* CIL Label */ ;
          }
        } else {
#line 1735
          (scanner->parse_errors) ++;
#line 1736
          state = (enum SGMLState )0;
        }
      }
    } else
#line 1741
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 1742
      while (1) {
        while_continue___152: /* CIL Label */ ;
#line 1742
        if ((scanner->name)->length < 256UL) {
          {
#line 1742
          while (1) {
            while_continue___153: /* CIL Label */ ;
#line 1742
            if ((scanner->name)->length < (scanner->name)->size) {
#line 1742
              if (ch < 255) {
#line 1742
                *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 1742
                ((scanner->name)->length) ++;
              } else {
                {
#line 1742
                real_string_push(scanner->name, ch);
                }
              }
            } else {
              {
#line 1742
              real_string_push(scanner->name, ch);
              }
            }
#line 1742
            goto while_break___153;
          }
          while_break___153: /* CIL Label */ ;
          }
        }
#line 1742
        goto while_break___152;
      }
      while_break___152: /* CIL Label */ ;
      }
      {
#line 1743
      while (1) {
        while_continue___154: /* CIL Label */ ;
#line 1743
        encoder->prev = start + i___0;
#line 1743
        ch = -1;
#line 1743
        goto while_break___154;
      }
      while_break___154: /* CIL Label */ ;
      }
    } else {
      {
#line 1745
      while (1) {
        while_continue___155: /* CIL Label */ ;
        {
#line 1745
        sgml_found(scanner, state, encoder->prev);
        }
#line 1745
        if (scanner->failed) {
#line 1745
          return (-1);
        }
#line 1745
        goto while_break___155;
      }
      while_break___155: /* CIL Label */ ;
      }
#line 1746
      state = (enum SGMLState )39;
    }
#line 1749
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    {
#line 1753
    if (ch == 91) {
#line 1753
      goto case_91___0;
    }
#line 1757
    if (ch == 112) {
#line 1757
      goto case_112;
    }
#line 1757
    if (ch == 80) {
#line 1757
      goto case_112;
    }
#line 1763
    if (ch == 115) {
#line 1763
      goto case_115;
    }
#line 1763
    if (ch == 83) {
#line 1763
      goto case_115;
    }
#line 1768
    if (ch == 62) {
#line 1768
      goto case_62___1;
    }
#line 1771
    goto switch_default___6;
    case_91___0: /* CIL Label */ 
#line 1754
    state = (enum SGMLState )51;
    {
#line 1755
    while (1) {
      while_continue___156: /* CIL Label */ ;
#line 1755
      encoder->prev = start + i___0;
#line 1755
      ch = -1;
#line 1755
      goto while_break___156;
    }
    while_break___156: /* CIL Label */ ;
    }
#line 1756
    goto switch_break___7;
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 1759
    scanner->publici = 1;
#line 1760
    state = (enum SGMLState )40;
    {
#line 1761
    while (1) {
      while_continue___157: /* CIL Label */ ;
#line 1761
      encoder->prev = start + i___0;
#line 1761
      ch = -1;
#line 1761
      goto while_break___157;
    }
    while_break___157: /* CIL Label */ ;
    }
#line 1762
    goto switch_break___7;
    case_115: /* CIL Label */ 
    case_83: /* CIL Label */ 
#line 1764
    scanner->systemi = 1;
#line 1765
    state = (enum SGMLState )41;
    {
#line 1766
    while (1) {
      while_continue___158: /* CIL Label */ ;
#line 1766
      encoder->prev = start + i___0;
#line 1766
      ch = -1;
#line 1766
      goto while_break___158;
    }
    while_break___158: /* CIL Label */ ;
    }
#line 1767
    goto switch_break___7;
    case_62___1: /* CIL Label */ 
#line 1769
    state = (enum SGMLState )73;
#line 1770
    goto switch_break___7;
    switch_default___6: /* CIL Label */ 
    {
#line 1772
    tmp___21 = __ctype_b_loc();
    }
#line 1772
    if (! ((int const   )*(*tmp___21 + ch) & 8192)) {
#line 1773
      (scanner->parse_errors) ++;
#line 1774
      state = (enum SGMLState )0;
    }
    {
#line 1776
    while (1) {
      while_continue___159: /* CIL Label */ ;
#line 1776
      encoder->prev = start + i___0;
#line 1776
      ch = -1;
#line 1776
      goto while_break___159;
    }
    while_break___159: /* CIL Label */ ;
    }
    switch_break___7: /* CIL Label */ ;
    }
#line 1778
    goto switch_break___0;
    case_40: /* CIL Label */ 
    {
#line 1781
    tmp___22 = toupper(ch);
    }
#line 1781
    if ((int const   )*("PUBLIC" + scanner->publici) == (int const   )tmp___22) {
#line 1782
      (scanner->publici) ++;
#line 1783
      if (scanner->publici == 6) {
#line 1784
        state = (enum SGMLState )46;
      }
      {
#line 1786
      while (1) {
        while_continue___160: /* CIL Label */ ;
#line 1786
        encoder->prev = start + i___0;
#line 1786
        ch = -1;
#line 1786
        goto while_break___160;
      }
      while_break___160: /* CIL Label */ ;
      }
    } else {
#line 1788
      (scanner->parse_errors) ++;
#line 1789
      state = (enum SGMLState )0;
    }
#line 1791
    goto switch_break___0;
    case_41: /* CIL Label */ 
    {
#line 1794
    tmp___23 = toupper(ch);
    }
#line 1794
    if ((int const   )*("SYSTEM" + scanner->systemi) == (int const   )tmp___23) {
#line 1795
      (scanner->systemi) ++;
#line 1796
      if (scanner->systemi == 6) {
#line 1797
        state = (enum SGMLState )48;
      }
      {
#line 1799
      while (1) {
        while_continue___161: /* CIL Label */ ;
#line 1799
        encoder->prev = start + i___0;
#line 1799
        ch = -1;
#line 1799
        goto while_break___161;
      }
      while_break___161: /* CIL Label */ ;
      }
    } else {
#line 1801
      (scanner->parse_errors) ++;
#line 1802
      state = (enum SGMLState )0;
    }
#line 1804
    goto switch_break___0;
    case_46: /* CIL Label */ 
#line 1807
    if (ch == 34) {
      {
#line 1808
      state = (enum SGMLState )43;
#line 1809
      push_state(scanner, (enum SGMLState )47);
      }
    } else
#line 1807
    if (ch == 39) {
      {
#line 1808
      state = (enum SGMLState )43;
#line 1809
      push_state(scanner, (enum SGMLState )47);
      }
    } else {
      {
#line 1810
      tmp___24 = __ctype_b_loc();
      }
#line 1810
      if ((int const   )*(*tmp___24 + ch) & 8192) {
        {
#line 1811
        while (1) {
          while_continue___162: /* CIL Label */ ;
#line 1811
          encoder->prev = start + i___0;
#line 1811
          ch = -1;
#line 1811
          goto while_break___162;
        }
        while_break___162: /* CIL Label */ ;
        }
      } else {
#line 1813
        (scanner->parse_errors) ++;
#line 1814
        state = (enum SGMLState )0;
      }
    }
#line 1816
    goto switch_break___0;
    case_42: /* CIL Label */ 
    {
#line 1819
    tmp___25 = __ctype_b_loc();
    }
#line 1819
    if ((int const   )*(*tmp___25 + ch) & 8192) {
      {
#line 1820
      while (1) {
        while_continue___163: /* CIL Label */ ;
#line 1820
        encoder->prev = start + i___0;
#line 1820
        ch = -1;
#line 1820
        goto while_break___163;
      }
      while_break___163: /* CIL Label */ ;
      }
    } else
#line 1822
    if (ch == 34) {
#line 1823
      state = (enum SGMLState )43;
    } else
#line 1822
    if (ch == 39) {
#line 1823
      state = (enum SGMLState )43;
    } else {
      {
#line 1825
      (scanner->parse_errors) ++;
#line 1826
      scanner->literals = -1;
#line 1827
      state = pop_state(scanner);
      }
    }
#line 1830
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 1833
    scanner->literals = start + i___0;
#line 1834
    (scanner->literal)->length = (size_t )3;
#line 1835
    if (ch == 34) {
#line 1835
      state = (enum SGMLState )45;
    } else {
#line 1835
      state = (enum SGMLState )44;
    }
    {
#line 1836
    while (1) {
      while_continue___164: /* CIL Label */ ;
#line 1836
      encoder->prev = start + i___0;
#line 1836
      ch = -1;
#line 1836
      goto while_break___164;
    }
    while_break___164: /* CIL Label */ ;
    }
#line 1837
    goto switch_break___0;
    case_45___0: /* CIL Label */ 
#line 1840
    if (ch != 34) {
      {
#line 1841
      while (1) {
        while_continue___165: /* CIL Label */ ;
#line 1841
        if ((scanner->literal)->length < 256UL) {
          {
#line 1841
          while (1) {
            while_continue___166: /* CIL Label */ ;
#line 1841
            if ((scanner->literal)->length < (scanner->literal)->size) {
#line 1841
              if (ch < 255) {
#line 1841
                *((scanner->literal)->s + (scanner->literal)->length) = (char )ch;
#line 1841
                ((scanner->literal)->length) ++;
              } else {
                {
#line 1841
                real_string_push(scanner->literal, ch);
                }
              }
            } else {
              {
#line 1841
              real_string_push(scanner->literal, ch);
              }
            }
#line 1841
            goto while_break___166;
          }
          while_break___166: /* CIL Label */ ;
          }
        }
#line 1841
        goto while_break___165;
      }
      while_break___165: /* CIL Label */ ;
      }
      {
#line 1842
      while (1) {
        while_continue___167: /* CIL Label */ ;
#line 1842
        encoder->prev = start + i___0;
#line 1842
        ch = -1;
#line 1842
        goto while_break___167;
      }
      while_break___167: /* CIL Label */ ;
      }
    } else {
      {
#line 1844
      state = pop_state(scanner);
      }
    }
#line 1846
    goto switch_break___0;
    case_44: /* CIL Label */ 
#line 1849
    if (ch != 39) {
      {
#line 1850
      while (1) {
        while_continue___168: /* CIL Label */ ;
#line 1850
        if ((scanner->literal)->length < 256UL) {
          {
#line 1850
          while (1) {
            while_continue___169: /* CIL Label */ ;
#line 1850
            if ((scanner->literal)->length < (scanner->literal)->size) {
#line 1850
              if (ch < 255) {
#line 1850
                *((scanner->literal)->s + (scanner->literal)->length) = (char )ch;
#line 1850
                ((scanner->literal)->length) ++;
              } else {
                {
#line 1850
                real_string_push(scanner->literal, ch);
                }
              }
            } else {
              {
#line 1850
              real_string_push(scanner->literal, ch);
              }
            }
#line 1850
            goto while_break___169;
          }
          while_break___169: /* CIL Label */ ;
          }
        }
#line 1850
        goto while_break___168;
      }
      while_break___168: /* CIL Label */ ;
      }
      {
#line 1851
      while (1) {
        while_continue___170: /* CIL Label */ ;
#line 1851
        encoder->prev = start + i___0;
#line 1851
        ch = -1;
#line 1851
        goto while_break___170;
      }
      while_break___170: /* CIL Label */ ;
      }
    } else {
      {
#line 1853
      state = pop_state(scanner);
      }
    }
#line 1855
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
    {
#line 1858
    while (1) {
      while_continue___171: /* CIL Label */ ;
      {
#line 1858
      sgml_found(scanner, state, encoder->prev);
      }
#line 1858
      if (scanner->failed) {
#line 1858
        return (-1);
      }
#line 1858
      goto while_break___171;
    }
    while_break___171: /* CIL Label */ ;
    }
#line 1859
    state = (enum SGMLState )48;
    {
#line 1860
    while (1) {
      while_continue___172: /* CIL Label */ ;
#line 1860
      encoder->prev = start + i___0;
#line 1860
      ch = -1;
#line 1860
      goto while_break___172;
    }
    while_break___172: /* CIL Label */ ;
    }
#line 1861
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 1864
    if (ch == 91) {
#line 1865
      state = (enum SGMLState )51;
    } else
#line 1866
    if (ch == 34) {
      {
#line 1867
      state = (enum SGMLState )43;
#line 1868
      push_state(scanner, (enum SGMLState )49);
      }
    } else
#line 1866
    if (ch == 39) {
      {
#line 1867
      state = (enum SGMLState )43;
#line 1868
      push_state(scanner, (enum SGMLState )49);
      }
    } else {
      {
#line 1869
      tmp___26 = __ctype_b_loc();
      }
#line 1869
      if ((int const   )*(*tmp___26 + ch) & 8192) {
        {
#line 1870
        while (1) {
          while_continue___173: /* CIL Label */ ;
#line 1870
          encoder->prev = start + i___0;
#line 1870
          ch = -1;
#line 1870
          goto while_break___173;
        }
        while_break___173: /* CIL Label */ ;
        }
      } else {
#line 1872
        (scanner->parse_errors) ++;
#line 1873
        state = (enum SGMLState )0;
      }
    }
#line 1875
    goto switch_break___0;
    case_49: /* CIL Label */ 
    {
#line 1878
    while (1) {
      while_continue___174: /* CIL Label */ ;
      {
#line 1878
      sgml_found(scanner, state, encoder->prev);
      }
#line 1878
      if (scanner->failed) {
#line 1878
        return (-1);
      }
#line 1878
      goto while_break___174;
    }
    while_break___174: /* CIL Label */ ;
    }
#line 1879
    state = (enum SGMLState )50;
    {
#line 1880
    while (1) {
      while_continue___175: /* CIL Label */ ;
#line 1880
      encoder->prev = start + i___0;
#line 1880
      ch = -1;
#line 1880
      goto while_break___175;
    }
    while_break___175: /* CIL Label */ ;
    }
#line 1881
    goto switch_break___0;
    case_50: /* CIL Label */ 
    {
#line 1885
    if (ch == 91) {
#line 1885
      goto case_91___1;
    }
#line 1889
    if (ch == 62) {
#line 1889
      goto case_62___2;
    }
#line 1892
    goto switch_default___7;
    case_91___1: /* CIL Label */ 
#line 1886
    state = (enum SGMLState )51;
    {
#line 1887
    while (1) {
      while_continue___176: /* CIL Label */ ;
#line 1887
      encoder->prev = start + i___0;
#line 1887
      ch = -1;
#line 1887
      goto while_break___176;
    }
    while_break___176: /* CIL Label */ ;
    }
#line 1888
    goto switch_break___8;
    case_62___2: /* CIL Label */ 
#line 1890
    state = (enum SGMLState )73;
#line 1891
    goto switch_break___8;
    switch_default___7: /* CIL Label */ 
    {
#line 1893
    tmp___27 = __ctype_b_loc();
    }
#line 1893
    if ((int const   )*(*tmp___27 + ch) & 8192) {
      {
#line 1894
      while (1) {
        while_continue___177: /* CIL Label */ ;
#line 1894
        encoder->prev = start + i___0;
#line 1894
        ch = -1;
#line 1894
        goto while_break___177;
      }
      while_break___177: /* CIL Label */ ;
      }
    } else {
#line 1896
      (scanner->parse_errors) ++;
#line 1897
      state = (enum SGMLState )0;
    }
#line 1899
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 1901
    goto switch_break___0;
    case_51: /* CIL Label */ 
    {
#line 1905
    if (ch == 60) {
#line 1905
      goto case_60___0;
    }
#line 1909
    if (ch == 37) {
#line 1909
      goto case_37___0;
    }
#line 1915
    if (ch == 93) {
#line 1915
      goto case_93;
    }
#line 1918
    goto switch_default___8;
    case_60___0: /* CIL Label */ 
#line 1906
    scanner->internal_declarations = encoder->prev;
#line 1907
    state = (enum SGMLState )52;
#line 1908
    goto switch_break___9;
    case_37___0: /* CIL Label */ 
#line 1911
    scanner->entitys = encoder->prev;
#line 1912
    state = (enum SGMLState )54;
    {
#line 1913
    while (1) {
      while_continue___178: /* CIL Label */ ;
#line 1913
      encoder->prev = start + i___0;
#line 1913
      ch = -1;
#line 1913
      goto while_break___178;
    }
    while_break___178: /* CIL Label */ ;
    }
#line 1914
    goto switch_break___9;
    case_93: /* CIL Label */ 
#line 1916
    state = (enum SGMLState )73;
#line 1917
    goto switch_break___9;
    switch_default___8: /* CIL Label */ 
    {
#line 1919
    tmp___28 = __ctype_b_loc();
    }
#line 1919
    if (! ((int const   )*(*tmp___28 + ch) & 8192)) {
#line 1920
      (scanner->parse_errors) ++;
    }
#line 1922
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
    {
#line 1924
    while (1) {
      while_continue___179: /* CIL Label */ ;
#line 1924
      encoder->prev = start + i___0;
#line 1924
      ch = -1;
#line 1924
      goto while_break___179;
    }
    while_break___179: /* CIL Label */ ;
    }
#line 1925
    goto switch_break___0;
    case_54: /* CIL Label */ 
#line 1928
    if (! ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long )))) {
#line 1930
      if (ch == 59) {
#line 1931
        state = (enum SGMLState )51;
      } else {
        {
#line 1932
        tmp___29 = __ctype_b_loc();
        }
#line 1932
        if ((int const   )*(*tmp___29 + ch) & 8192) {
#line 1933
          state = (enum SGMLState )51;
        } else {
#line 1935
          (scanner->parse_errors) ++;
#line 1936
          state = (enum SGMLState )51;
        }
      }
    }
    {
#line 1938
    while (1) {
      while_continue___180: /* CIL Label */ ;
#line 1938
      encoder->prev = start + i___0;
#line 1938
      ch = -1;
#line 1938
      goto while_break___180;
    }
    while_break___180: /* CIL Label */ ;
    }
#line 1939
    goto switch_break___0;
    case_52: /* CIL Label */ 
    {
#line 1943
    if (ch == 33) {
#line 1943
      goto case_33___1;
    }
#line 1947
    if (ch == 63) {
#line 1947
      goto case_63___1;
    }
#line 1954
    goto switch_default___9;
    case_33___1: /* CIL Label */ 
#line 1944
    state = (enum SGMLState )53;
    {
#line 1945
    while (1) {
      while_continue___181: /* CIL Label */ ;
#line 1945
      encoder->prev = start + i___0;
#line 1945
      ch = -1;
#line 1945
      goto while_break___181;
    }
    while_break___181: /* CIL Label */ ;
    }
#line 1946
    goto switch_break___10;
    case_63___1: /* CIL Label */ 
    {
#line 1948
    scanner->tags = scanner->internal_declarations;
#line 1949
    (scanner->pi)->length = (size_t )1;
#line 1950
    state = (enum SGMLState )30;
#line 1951
    push_state(scanner, (enum SGMLState )51);
    }
    {
#line 1952
    while (1) {
      while_continue___182: /* CIL Label */ ;
#line 1952
      encoder->prev = start + i___0;
#line 1952
      ch = -1;
#line 1952
      goto while_break___182;
    }
    while_break___182: /* CIL Label */ ;
    }
#line 1953
    goto switch_break___10;
    switch_default___9: /* CIL Label */ 
#line 1955
    (scanner->parse_errors) ++;
#line 1956
    state = (enum SGMLState )51;
#line 1957
    goto switch_break___10;
    switch_break___10: /* CIL Label */ ;
    }
#line 1959
    goto switch_break___0;
    case_53: /* CIL Label */ 
#line 1962
    if (ch == 45) {
      {
#line 1963
      scanner->comments = scanner->internal_declarations;
#line 1964
      push_state(scanner, (enum SGMLState )51);
#line 1965
      state = (enum SGMLState )25;
      }
      {
#line 1966
      while (1) {
        while_continue___183: /* CIL Label */ ;
#line 1966
        encoder->prev = start + i___0;
#line 1966
        ch = -1;
#line 1966
        goto while_break___183;
      }
      while_break___183: /* CIL Label */ ;
      }
    } else {
      {
#line 1967
      tmp___33 = __ctype_b_loc();
      }
#line 1967
      if ((int const   )*(*tmp___33 + ch) & 1024) {
#line 1968
        state = (enum SGMLState )55;
#line 1969
        (scanner->name)->length = (size_t )0;
        {
#line 1970
        while (1) {
          while_continue___184: /* CIL Label */ ;
#line 1970
          if ((scanner->name)->length < 256UL) {
            {
#line 1970
            while (1) {
              while_continue___185: /* CIL Label */ ;
#line 1970
              if ((scanner->name)->length < (scanner->name)->size) {
                {
#line 1970
                tmp___32 = toupper(ch);
                }
#line 1970
                if (tmp___32 < 255) {
                  {
#line 1970
                  tmp___30 = toupper(ch);
#line 1970
                  *((scanner->name)->s + (scanner->name)->length) = (char )tmp___30;
#line 1970
                  ((scanner->name)->length) ++;
                  }
                } else {
                  {
#line 1970
                  tmp___31 = toupper(ch);
#line 1970
                  real_string_push(scanner->name, tmp___31);
                  }
                }
              } else {
                {
#line 1970
                tmp___31 = toupper(ch);
#line 1970
                real_string_push(scanner->name, tmp___31);
                }
              }
#line 1970
              goto while_break___185;
            }
            while_break___185: /* CIL Label */ ;
            }
          }
#line 1970
          goto while_break___184;
        }
        while_break___184: /* CIL Label */ ;
        }
        {
#line 1971
        while (1) {
          while_continue___186: /* CIL Label */ ;
#line 1971
          encoder->prev = start + i___0;
#line 1971
          ch = -1;
#line 1971
          goto while_break___186;
        }
        while_break___186: /* CIL Label */ ;
        }
      } else {
#line 1973
        (scanner->parse_errors) ++;
#line 1974
        state = (enum SGMLState )51;
      }
    }
#line 1976
    goto switch_break___0;
    case_55: /* CIL Label */ 
    {
#line 1979
    tmp___39 = __ctype_b_loc();
    }
#line 1979
    if ((int const   )*(*tmp___39 + ch) & 1024) {
#line 1979
      if ((scanner->name)->length < 10UL) {
        {
#line 1981
        while (1) {
          while_continue___187: /* CIL Label */ ;
#line 1981
          if ((scanner->name)->length < 256UL) {
            {
#line 1981
            while (1) {
              while_continue___188: /* CIL Label */ ;
#line 1981
              if ((scanner->name)->length < (scanner->name)->size) {
#line 1981
                if (ch < 255) {
#line 1981
                  *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 1981
                  ((scanner->name)->length) ++;
                } else {
                  {
#line 1981
                  real_string_push(scanner->name, ch);
                  }
                }
              } else {
                {
#line 1981
                real_string_push(scanner->name, ch);
                }
              }
#line 1981
              goto while_break___188;
            }
            while_break___188: /* CIL Label */ ;
            }
          }
#line 1981
          goto while_break___187;
        }
        while_break___187: /* CIL Label */ ;
        }
        {
#line 1982
        while (1) {
          while_continue___189: /* CIL Label */ ;
#line 1982
          encoder->prev = start + i___0;
#line 1982
          ch = -1;
#line 1982
          goto while_break___189;
        }
        while_break___189: /* CIL Label */ ;
        }
      } else {
#line 1979
        goto _L___15;
      }
    } else {
      _L___15: /* CIL Label */ 
      {
#line 1983
      tmp___38 = __ctype_b_loc();
      }
#line 1983
      if ((int const   )*(*tmp___38 + ch) & 8192) {
        {
#line 1985
        string_toupper(scanner->name, 0);
#line 1986
        *((scanner->name)->s + (scanner->name)->length) = (char)0;
#line 1986
        name = (char const   *)(scanner->name)->s;
#line 1987
        tmp___37 = strcmp(name, "ENTITY");
        }
#line 1987
        if (tmp___37 == 0) {
#line 1988
          scanner->entity_has_systemid = 0;
#line 1989
          scanner->entity_is_ndata = 0;
#line 1990
          state = (enum SGMLState )56;
        } else {
          {
#line 1991
          tmp___36 = strcmp(name, "ELEMENT");
          }
#line 1991
          if (tmp___36 == 0) {
#line 1992
            state = (enum SGMLState )70;
          } else {
            {
#line 1993
            tmp___35 = strcmp(name, "NOTATION");
            }
#line 1993
            if (tmp___35 == 0) {
#line 1994
              state = (enum SGMLState )72;
            } else {
              {
#line 1995
              tmp___34 = strcmp(name, "ATTLIST");
              }
#line 1995
              if (tmp___34 == 0) {
#line 1996
                state = (enum SGMLState )71;
              } else {
#line 1998
                (scanner->parse_errors) ++;
#line 1999
                state = (enum SGMLState )51;
              }
            }
          }
        }
        {
#line 2001
        while (1) {
          while_continue___190: /* CIL Label */ ;
#line 2001
          encoder->prev = start + i___0;
#line 2001
          ch = -1;
#line 2001
          goto while_break___190;
        }
        while_break___190: /* CIL Label */ ;
        }
      } else {
#line 2003
        (scanner->parse_errors) ++;
#line 2004
        state = (enum SGMLState )51;
      }
    }
#line 2006
    goto switch_break___0;
    case_56: /* CIL Label */ 
#line 2009
    if (ch == 37) {
      {
#line 2012
      while (1) {
        while_continue___191: /* CIL Label */ ;
#line 2012
        encoder->prev = start + i___0;
#line 2012
        ch = -1;
#line 2012
        goto while_break___191;
      }
      while_break___191: /* CIL Label */ ;
      }
    } else
#line 2013
    if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 2014
      state = (enum SGMLState )57;
#line 2015
      (scanner->name)->length = (size_t )0;
#line 2016
      string_cat(scanner->name, "!ed");
      }
      {
#line 2017
      while (1) {
        while_continue___192: /* CIL Label */ ;
#line 2017
        if ((scanner->name)->length < (scanner->name)->size) {
#line 2017
          if (ch < 255) {
#line 2017
            *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 2017
            ((scanner->name)->length) ++;
          } else {
            {
#line 2017
            real_string_push(scanner->name, ch);
            }
          }
        } else {
          {
#line 2017
          real_string_push(scanner->name, ch);
          }
        }
#line 2017
        goto while_break___192;
      }
      while_break___192: /* CIL Label */ ;
      }
      {
#line 2018
      while (1) {
        while_continue___193: /* CIL Label */ ;
#line 2018
        encoder->prev = start + i___0;
#line 2018
        ch = -1;
#line 2018
        goto while_break___193;
      }
      while_break___193: /* CIL Label */ ;
      }
    } else {
      {
#line 2019
      tmp___40 = __ctype_b_loc();
      }
#line 2019
      if ((int const   )*(*tmp___40 + ch) & 8192) {
        {
#line 2020
        while (1) {
          while_continue___194: /* CIL Label */ ;
#line 2020
          encoder->prev = start + i___0;
#line 2020
          ch = -1;
#line 2020
          goto while_break___194;
        }
        while_break___194: /* CIL Label */ ;
        }
      } else {
#line 2022
        (scanner->parse_errors) ++;
#line 2023
        state = (enum SGMLState )51;
      }
    }
#line 2025
    goto switch_break___0;
    case_57: /* CIL Label */ 
#line 2028
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 2029
      while (1) {
        while_continue___195: /* CIL Label */ ;
#line 2029
        if ((scanner->name)->length < 256UL) {
          {
#line 2029
          while (1) {
            while_continue___196: /* CIL Label */ ;
#line 2029
            if ((scanner->name)->length < (scanner->name)->size) {
#line 2029
              if (ch < 255) {
#line 2029
                *((scanner->name)->s + (scanner->name)->length) = (char )ch;
#line 2029
                ((scanner->name)->length) ++;
              } else {
                {
#line 2029
                real_string_push(scanner->name, ch);
                }
              }
            } else {
              {
#line 2029
              real_string_push(scanner->name, ch);
              }
            }
#line 2029
            goto while_break___196;
          }
          while_break___196: /* CIL Label */ ;
          }
        }
#line 2029
        goto while_break___195;
      }
      while_break___195: /* CIL Label */ ;
      }
      {
#line 2030
      while (1) {
        while_continue___197: /* CIL Label */ ;
#line 2030
        encoder->prev = start + i___0;
#line 2030
        ch = -1;
#line 2030
        goto while_break___197;
      }
      while_break___197: /* CIL Label */ ;
      }
    } else {
#line 2032
      state = (enum SGMLState )58;
    }
#line 2034
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 2037
    if (ch == 34) {
#line 2038
      state = (enum SGMLState )61;
#line 2039
      scanner->literals = start + i___0;
      {
#line 2040
      while (1) {
        while_continue___198: /* CIL Label */ ;
#line 2040
        encoder->prev = start + i___0;
#line 2040
        ch = -1;
#line 2040
        goto while_break___198;
      }
      while_break___198: /* CIL Label */ ;
      }
    } else
#line 2041
    if (ch == 39) {
#line 2042
      state = (enum SGMLState )62;
#line 2043
      scanner->literals = start + i___0;
      {
#line 2044
      while (1) {
        while_continue___199: /* CIL Label */ ;
#line 2044
        encoder->prev = start + i___0;
#line 2044
        ch = -1;
#line 2044
        goto while_break___199;
      }
      while_break___199: /* CIL Label */ ;
      }
    } else {
      {
#line 2045
      tmp___42 = __ctype_b_loc();
      }
#line 2045
      if ((int const   )*(*tmp___42 + ch) & 8192) {
        {
#line 2046
        while (1) {
          while_continue___200: /* CIL Label */ ;
#line 2046
          encoder->prev = start + i___0;
#line 2046
          ch = -1;
#line 2046
          goto while_break___200;
        }
        while_break___200: /* CIL Label */ ;
        }
      } else {
        {
#line 2047
        tmp___41 = __ctype_b_loc();
        }
#line 2047
        if ((int const   )*(*tmp___41 + ch) & 1024) {
          {
#line 2048
          push_state(scanner, (enum SGMLState )59);
#line 2049
          (scanner->name2)->length = (size_t )0;
#line 2050
          state = (enum SGMLState )74;
          }
        } else {
#line 2052
          (scanner->parse_errors) ++;
#line 2053
          state = (enum SGMLState )51;
        }
      }
    }
#line 2055
    goto switch_break___0;
    case_74: /* CIL Label */ 
    {
#line 2058
    tmp___46 = __ctype_b_loc();
    }
#line 2058
    if ((int const   )*(*tmp___46 + ch) & 1024) {
      {
#line 2059
      while (1) {
        while_continue___201: /* CIL Label */ ;
#line 2059
        if ((scanner->name2)->length < 256UL) {
          {
#line 2059
          while (1) {
            while_continue___202: /* CIL Label */ ;
#line 2059
            if ((scanner->name2)->length < (scanner->name2)->size) {
              {
#line 2059
              tmp___45 = toupper(ch);
              }
#line 2059
              if (tmp___45 < 255) {
                {
#line 2059
                tmp___43 = toupper(ch);
#line 2059
                *((scanner->name2)->s + (scanner->name2)->length) = (char )tmp___43;
#line 2059
                ((scanner->name2)->length) ++;
                }
              } else {
                {
#line 2059
                tmp___44 = toupper(ch);
#line 2059
                real_string_push(scanner->name2, tmp___44);
                }
              }
            } else {
              {
#line 2059
              tmp___44 = toupper(ch);
#line 2059
              real_string_push(scanner->name2, tmp___44);
              }
            }
#line 2059
            goto while_break___202;
          }
          while_break___202: /* CIL Label */ ;
          }
        }
#line 2059
        goto while_break___201;
      }
      while_break___201: /* CIL Label */ ;
      }
      {
#line 2060
      while (1) {
        while_continue___203: /* CIL Label */ ;
#line 2060
        encoder->prev = start + i___0;
#line 2060
        ch = -1;
#line 2060
        goto while_break___203;
      }
      while_break___203: /* CIL Label */ ;
      }
    } else {
      {
#line 2062
      state = pop_state(scanner);
      }
    }
#line 2064
    goto switch_break___0;
    case_59: /* CIL Label */ 
    {
#line 2067
    *((scanner->name2)->s + (scanner->name2)->length) = (char)0;
#line 2067
    tmp___50 = strcmp((char const   *)(scanner->name2)->s, "SYSTEM");
    }
#line 2067
    if (tmp___50 == 0) {
      {
#line 2068
      push_state(scanner, (enum SGMLState )65);
#line 2069
      state = (enum SGMLState )42;
      }
    } else {
      {
#line 2070
      *((scanner->name2)->s + (scanner->name2)->length) = (char)0;
#line 2070
      tmp___49 = strcmp((char const   *)(scanner->name2)->s, "PUBLIC");
      }
#line 2070
      if (tmp___49 == 0) {
        {
#line 2071
        push_state(scanner, (enum SGMLState )63);
#line 2072
        state = (enum SGMLState )42;
        }
      } else {
        {
#line 2073
        *((scanner->name2)->s + (scanner->name2)->length) = (char)0;
#line 2073
        tmp___47 = strcmp((char const   *)(scanner->name2)->s, "CDATA");
        }
#line 2073
        if (tmp___47 == 0) {
#line 2075
          state = (enum SGMLState )60;
        } else {
          {
#line 2073
          *((scanner->name2)->s + (scanner->name2)->length) = (char)0;
#line 2073
          tmp___48 = strcmp((char const   *)(scanner->name2)->s, "SDATA");
          }
#line 2073
          if (tmp___48 == 0) {
#line 2075
            state = (enum SGMLState )60;
          } else {
#line 2077
            (scanner->parse_errors) ++;
#line 2078
            state = (enum SGMLState )51;
          }
        }
      }
    }
#line 2080
    goto switch_break___0;
    case_60___1: /* CIL Label */ 
#line 2083
    if (ch == 34) {
#line 2084
      state = (enum SGMLState )61;
#line 2085
      scanner->literals = start + i___0;
      {
#line 2086
      while (1) {
        while_continue___204: /* CIL Label */ ;
#line 2086
        encoder->prev = start + i___0;
#line 2086
        ch = -1;
#line 2086
        goto while_break___204;
      }
      while_break___204: /* CIL Label */ ;
      }
    } else
#line 2087
    if (ch == 39) {
#line 2088
      state = (enum SGMLState )62;
#line 2089
      scanner->literals = start + i___0;
      {
#line 2090
      while (1) {
        while_continue___205: /* CIL Label */ ;
#line 2090
        encoder->prev = start + i___0;
#line 2090
        ch = -1;
#line 2090
        goto while_break___205;
      }
      while_break___205: /* CIL Label */ ;
      }
    } else {
      {
#line 2091
      tmp___51 = __ctype_b_loc();
      }
#line 2091
      if ((int const   )*(*tmp___51 + ch) & 8192) {
        {
#line 2092
        while (1) {
          while_continue___206: /* CIL Label */ ;
#line 2092
          encoder->prev = start + i___0;
#line 2092
          ch = -1;
#line 2092
          goto while_break___206;
        }
        while_break___206: /* CIL Label */ ;
        }
      } else {
#line 2094
        (scanner->parse_errors) ++;
      }
    }
#line 2096
    goto switch_break___0;
    case_61___0: /* CIL Label */ 
#line 2100
    if (ch == 34) {
      {
#line 2101
      while (1) {
        while_continue___207: /* CIL Label */ ;
        {
#line 2101
        sgml_found(scanner, state, encoder->prev);
        }
#line 2101
        if (scanner->failed) {
#line 2101
          return (-1);
        }
#line 2101
        goto while_break___207;
      }
      while_break___207: /* CIL Label */ ;
      }
#line 2102
      state = (enum SGMLState )69;
    }
    {
#line 2104
    while (1) {
      while_continue___208: /* CIL Label */ ;
#line 2104
      encoder->prev = start + i___0;
#line 2104
      ch = -1;
#line 2104
      goto while_break___208;
    }
    while_break___208: /* CIL Label */ ;
    }
#line 2105
    goto switch_break___0;
    case_62___3: /* CIL Label */ 
#line 2108
    if (ch == 39) {
      {
#line 2109
      while (1) {
        while_continue___209: /* CIL Label */ ;
        {
#line 2109
        sgml_found(scanner, state, encoder->prev);
        }
#line 2109
        if (scanner->failed) {
#line 2109
          return (-1);
        }
#line 2109
        goto while_break___209;
      }
      while_break___209: /* CIL Label */ ;
      }
#line 2110
      state = (enum SGMLState )69;
    }
    {
#line 2112
    while (1) {
      while_continue___210: /* CIL Label */ ;
#line 2112
      encoder->prev = start + i___0;
#line 2112
      ch = -1;
#line 2112
      goto while_break___210;
    }
    while_break___210: /* CIL Label */ ;
    }
#line 2113
    goto switch_break___0;
    case_69: /* CIL Label */ 
#line 2116
    if (ch == 62) {
      {
#line 2117
      while (1) {
        while_continue___211: /* CIL Label */ ;
        {
#line 2117
        sgml_found(scanner, state, start + i___0);
        }
#line 2117
        if (scanner->failed) {
#line 2117
          return (-1);
        }
#line 2117
        goto while_break___211;
      }
      while_break___211: /* CIL Label */ ;
      }
#line 2118
      state = (enum SGMLState )51;
      {
#line 2119
      while (1) {
        while_continue___212: /* CIL Label */ ;
#line 2119
        encoder->prev = start + i___0;
#line 2119
        ch = -1;
#line 2119
        goto while_break___212;
      }
      while_break___212: /* CIL Label */ ;
      }
#line 2120
      goto switch_break___0;
    } else {
      {
#line 2121
      tmp___52 = __ctype_b_loc();
      }
#line 2121
      if ((int const   )*(*tmp___52 + ch) & 8192) {
        {
#line 2122
        while (1) {
          while_continue___213: /* CIL Label */ ;
#line 2122
          encoder->prev = start + i___0;
#line 2122
          ch = -1;
#line 2122
          goto while_break___213;
        }
        while_break___213: /* CIL Label */ ;
        }
      } else {
#line 2124
        (scanner->parse_errors) ++;
#line 2125
        state = (enum SGMLState )51;
      }
    }
#line 2127
    goto switch_break___0;
    case_63___2: /* CIL Label */ 
#line 2130
    if (scanner->literals > 0) {
      {
#line 2131
      while (1) {
        while_continue___214: /* CIL Label */ ;
        {
#line 2131
        sgml_found(scanner, state, encoder->prev);
        }
#line 2131
        if (scanner->failed) {
#line 2131
          return (-1);
        }
#line 2131
        goto while_break___214;
      }
      while_break___214: /* CIL Label */ ;
      }
#line 2132
      state = (enum SGMLState )64;
      {
#line 2133
      while (1) {
        while_continue___215: /* CIL Label */ ;
#line 2133
        encoder->prev = start + i___0;
#line 2133
        ch = -1;
#line 2133
        goto while_break___215;
      }
      while_break___215: /* CIL Label */ ;
      }
    } else {
#line 2135
      state = (enum SGMLState )51;
    }
#line 2137
    goto switch_break___0;
    case_64: /* CIL Label */ 
    {
#line 2142
    if (ch == 39) {
#line 2142
      goto case_39___1;
    }
#line 2142
    if (ch == 34) {
#line 2142
      goto case_39___1;
    }
#line 2146
    goto switch_default___10;
    case_39___1: /* CIL Label */ 
    case_34___1: /* CIL Label */ 
    {
#line 2143
    push_state(scanner, (enum SGMLState )65);
#line 2144
    state = (enum SGMLState )43;
    }
#line 2145
    goto switch_break___11;
    switch_default___10: /* CIL Label */ 
    {
#line 2147
    tmp___53 = __ctype_b_loc();
    }
#line 2147
    if ((int const   )*(*tmp___53 + ch) & 8192) {
      {
#line 2148
      while (1) {
        while_continue___216: /* CIL Label */ ;
#line 2148
        encoder->prev = start + i___0;
#line 2148
        ch = -1;
#line 2148
        goto while_break___216;
      }
      while_break___216: /* CIL Label */ ;
      }
    } else {
#line 2150
      state = (enum SGMLState )66;
    }
    switch_break___11: /* CIL Label */ ;
    }
#line 2153
    goto switch_break___0;
    case_65: /* CIL Label */ 
#line 2156
    if (scanner->literals > 0) {
      {
#line 2157
      while (1) {
        while_continue___217: /* CIL Label */ ;
        {
#line 2157
        sgml_found(scanner, state, encoder->prev);
        }
#line 2157
        if (scanner->failed) {
#line 2157
          return (-1);
        }
#line 2157
        goto while_break___217;
      }
      while_break___217: /* CIL Label */ ;
      }
#line 2158
      scanner->entity_has_systemid = 1;
#line 2159
      state = (enum SGMLState )66;
      {
#line 2160
      while (1) {
        while_continue___218: /* CIL Label */ ;
#line 2160
        encoder->prev = start + i___0;
#line 2160
        ch = -1;
#line 2160
        goto while_break___218;
      }
      while_break___218: /* CIL Label */ ;
      }
    }
#line 2162
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 2165
    if (ch == 62) {
#line 2166
      state = (enum SGMLState )69;
    } else {
      {
#line 2167
      tmp___55 = __ctype_b_loc();
      }
#line 2167
      if ((int const   )*(*tmp___55 + ch) & 1024) {
        {
#line 2168
        (scanner->name2)->length = (size_t )0;
#line 2169
        push_state(scanner, (enum SGMLState )67);
#line 2170
        state = (enum SGMLState )74;
        }
      } else {
        {
#line 2171
        tmp___54 = __ctype_b_loc();
        }
#line 2171
        if ((int const   )*(*tmp___54 + ch) & 8192) {
          {
#line 2172
          while (1) {
            while_continue___219: /* CIL Label */ ;
#line 2172
            encoder->prev = start + i___0;
#line 2172
            ch = -1;
#line 2172
            goto while_break___219;
          }
          while_break___219: /* CIL Label */ ;
          }
        } else {
#line 2174
          (scanner->parse_errors) ++;
#line 2175
          state = (enum SGMLState )51;
        }
      }
    }
#line 2177
    goto switch_break___0;
    case_67: /* CIL Label */ 
    {
#line 2180
    *((scanner->name2)->s + (scanner->name2)->length) = (char)0;
#line 2180
    tmp___57 = strcmp((char const   *)(scanner->name2)->s, "NDATA");
    }
#line 2180
    if (tmp___57 == 0) {
      {
#line 2181
      scanner->entity_is_ndata = 1;
#line 2182
      tmp___56 = __ctype_b_loc();
      }
#line 2182
      if ((int const   )*(*tmp___56 + ch) & 8192) {
        {
#line 2183
        while (1) {
          while_continue___220: /* CIL Label */ ;
#line 2183
          encoder->prev = start + i___0;
#line 2183
          ch = -1;
#line 2183
          goto while_break___220;
        }
        while_break___220: /* CIL Label */ ;
        }
      } else
#line 2184
      if ((scanner->name_start_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
        {
#line 2185
        (scanner->name2)->length = (size_t )0;
#line 2186
        string_cat(scanner->name2, "!en");
#line 2187
        scanner->name2s = encoder->prev;
#line 2188
        state = (enum SGMLState )68;
        }
      } else {
#line 2190
        (scanner->parse_errors) ++;
#line 2191
        state = (enum SGMLState )51;
      }
    } else {
#line 2194
      (scanner->parse_errors) ++;
#line 2195
      state = (enum SGMLState )51;
    }
#line 2197
    goto switch_break___0;
    case_68: /* CIL Label */ 
#line 2200
    if ((scanner->name_chars)->bitmap[(unsigned long )ch / sizeof(unsigned long )] & (1UL << (unsigned long )ch % sizeof(unsigned long ))) {
      {
#line 2201
      while (1) {
        while_continue___221: /* CIL Label */ ;
#line 2201
        if ((scanner->name2)->length < 256UL) {
          {
#line 2201
          while (1) {
            while_continue___222: /* CIL Label */ ;
#line 2201
            if ((scanner->name2)->length < (scanner->name2)->size) {
#line 2201
              if (ch < 255) {
#line 2201
                *((scanner->name2)->s + (scanner->name2)->length) = (char )ch;
#line 2201
                ((scanner->name2)->length) ++;
              } else {
                {
#line 2201
                real_string_push(scanner->name2, ch);
                }
              }
            } else {
              {
#line 2201
              real_string_push(scanner->name2, ch);
              }
            }
#line 2201
            goto while_break___222;
          }
          while_break___222: /* CIL Label */ ;
          }
        }
#line 2201
        goto while_break___221;
      }
      while_break___221: /* CIL Label */ ;
      }
      {
#line 2202
      while (1) {
        while_continue___223: /* CIL Label */ ;
#line 2202
        encoder->prev = start + i___0;
#line 2202
        ch = -1;
#line 2202
        goto while_break___223;
      }
      while_break___223: /* CIL Label */ ;
      }
    } else {
      {
#line 2204
      while (1) {
        while_continue___224: /* CIL Label */ ;
        {
#line 2204
        sgml_found(scanner, state, encoder->prev);
        }
#line 2204
        if (scanner->failed) {
#line 2204
          return (-1);
        }
#line 2204
        goto while_break___224;
      }
      while_break___224: /* CIL Label */ ;
      }
#line 2205
      state = (enum SGMLState )69;
    }
#line 2207
    goto switch_break___0;
    case_70: /* CIL Label */ 
#line 2211
    if (ch == 62) {
      {
#line 2212
      while (1) {
        while_continue___225: /* CIL Label */ ;
        {
#line 2212
        sgml_found(scanner, state, start + i___0);
        }
#line 2212
        if (scanner->failed) {
#line 2212
          return (-1);
        }
#line 2212
        goto while_break___225;
      }
      while_break___225: /* CIL Label */ ;
      }
#line 2213
      state = (enum SGMLState )51;
    }
    {
#line 2215
    while (1) {
      while_continue___226: /* CIL Label */ ;
#line 2215
      encoder->prev = start + i___0;
#line 2215
      ch = -1;
#line 2215
      goto while_break___226;
    }
    while_break___226: /* CIL Label */ ;
    }
#line 2216
    goto switch_break___0;
    case_71: /* CIL Label */ 
#line 2220
    if (ch == 62) {
      {
#line 2221
      while (1) {
        while_continue___227: /* CIL Label */ ;
        {
#line 2221
        sgml_found(scanner, state, start + i___0);
        }
#line 2221
        if (scanner->failed) {
#line 2221
          return (-1);
        }
#line 2221
        goto while_break___227;
      }
      while_break___227: /* CIL Label */ ;
      }
#line 2222
      state = (enum SGMLState )51;
    }
    {
#line 2224
    while (1) {
      while_continue___228: /* CIL Label */ ;
#line 2224
      encoder->prev = start + i___0;
#line 2224
      ch = -1;
#line 2224
      goto while_break___228;
    }
    while_break___228: /* CIL Label */ ;
    }
#line 2225
    goto switch_break___0;
    case_72: /* CIL Label */ 
#line 2229
    if (ch == 62) {
      {
#line 2230
      while (1) {
        while_continue___229: /* CIL Label */ ;
        {
#line 2230
        sgml_found(scanner, state, start + i___0);
        }
#line 2230
        if (scanner->failed) {
#line 2230
          return (-1);
        }
#line 2230
        goto while_break___229;
      }
      while_break___229: /* CIL Label */ ;
      }
#line 2231
      state = (enum SGMLState )51;
    }
    {
#line 2233
    while (1) {
      while_continue___230: /* CIL Label */ ;
#line 2233
      encoder->prev = start + i___0;
#line 2233
      ch = -1;
#line 2233
      goto while_break___230;
    }
    while_break___230: /* CIL Label */ ;
    }
#line 2234
    goto switch_break___0;
    case_73: /* CIL Label */ 
#line 2238
    if (ch == 62) {
      {
#line 2239
      while (1) {
        while_continue___231: /* CIL Label */ ;
        {
#line 2239
        sgml_found(scanner, state, start + i___0);
        }
#line 2239
        if (scanner->failed) {
#line 2239
          return (-1);
        }
#line 2239
        goto while_break___231;
      }
      while_break___231: /* CIL Label */ ;
      }
#line 2240
      state = (enum SGMLState )0;
      {
#line 2241
      while (1) {
        while_continue___232: /* CIL Label */ ;
#line 2241
        encoder->prev = start + i___0;
#line 2241
        ch = -1;
#line 2241
        goto while_break___232;
      }
      while_break___232: /* CIL Label */ ;
      }
    } else {
      {
#line 2242
      tmp___58 = __ctype_b_loc();
      }
#line 2242
      if ((int const   )*(*tmp___58 + ch) & 8192) {
        {
#line 2243
        while (1) {
          while_continue___233: /* CIL Label */ ;
#line 2243
          encoder->prev = start + i___0;
#line 2243
          ch = -1;
#line 2243
          goto while_break___233;
        }
        while_break___233: /* CIL Label */ ;
        }
      } else {
#line 2245
        (scanner->parse_errors) ++;
#line 2246
        state = (enum SGMLState )0;
      }
    }
#line 2248
    goto switch_break___0;
    switch_default___11: /* CIL Label */ 
    {
#line 2251
    sgrep_error(scanner->sgrep, (char *)"SGML-scanner in unimplemented state. Switching to PCDATA\n");
#line 2253
    state = (enum SGMLState )0;
    }
#line 2254
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2259
  scanner->state = state;
#line 2260
  return (0);
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
Displayer *new_displayer(SgrepData *sgrep___0 , FileList *files ) ;
#line 709
void delete_displayer(Displayer *d ) ;
#line 710
char const   *fetch_region(Displayer *d , Region *region , int *size ) ;
#line 712
int write_region_list(struct SgrepStruct *sgrep___0 , FILE *stream , RegionList *list ,
                      FileList *files ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
char const   *get_file_region(Displayer *displayer , int file , unsigned int start ,
                              unsigned int len ) 
{ 
  SgrepData *sgrep___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 49
  sgrep___0 = displayer->sgrep;
#line 51
  if (displayer->current_file != file) {
#line 53
    if (displayer->map) {
      {
#line 55
      unmap_file(sgrep___0, (void *)displayer->map, displayer->map_size);
#line 56
      displayer->map = (char *)((void *)0);
#line 57
      displayer->map_size = (size_t )0;
      }
    }
    {
#line 60
    displayer->current_file = file;
#line 61
    tmp = flist_name(displayer->files, displayer->current_file);
#line 61
    displayer->map_size = map_file(sgrep___0, tmp, (void **)(& displayer->map));
    }
  }
#line 65
  if ((unsigned long )displayer->map == (unsigned long )((void *)0)) {
#line 65
    return ((char const   *)((void *)0));
  }
#line 66
  if ((size_t )start >= displayer->map_size) {
    {
#line 67
    tmp___0 = flist_name(displayer->files, file);
#line 67
    sgrep_error(sgrep___0, (char *)"File \'%s\' truncated?\n", tmp___0);
    }
#line 69
    return ((char const   *)((void *)0));
  } else
#line 66
  if ((size_t )(start + len) > displayer->map_size) {
    {
#line 67
    tmp___0 = flist_name(displayer->files, file);
#line 67
    sgrep_error(sgrep___0, (char *)"File \'%s\' truncated?\n", tmp___0);
    }
#line 69
    return ((char const   *)((void *)0));
  }
#line 71
  return ((char const   *)(displayer->map + start));
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void show_file_region(Displayer *displayer , int file , unsigned int start , unsigned int len ) 
{ 
  char const   *r ;

  {
  {
#line 77
  r = get_file_region(displayer, file, start, len);
  }
#line 78
  if (r) {
    {
#line 79
    fwrite((void const   */* __restrict  */)r, (size_t )len, (size_t )1, (FILE */* __restrict  */)displayer->stream);
    }
  }
#line 81
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void check_region(Displayer *displayer , int *start , int *len ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 90
  sgrep___0 = displayer->sgrep;
#line 91
  if (*start >= displayer->last) {
#line 91
    if (! displayer->start_warned) {
      {
#line 93
      sgrep_error(sgrep___0, (char *)"Warning: region start point greater than input size detected\n");
#line 94
      displayer->start_warned = 1;
#line 95
      *len = 0;
      }
#line 96
      return;
    }
  }
#line 98
  if (*start + *len > displayer->last) {
#line 98
    if (displayer->end_warned) {
      {
#line 100
      sgrep_error(sgrep___0, (char *)"Warning: region end point greater than input size detected\n");
#line 101
      displayer->end_warned = 1;
#line 102
      *len = displayer->last - *start;
      }
    }
  }
#line 104
  return;
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
int locate_file_num(Displayer *displayer , int start ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 112
  if (displayer->current_file >= 0) {
    {
#line 112
    tmp___0 = flist_start(displayer->files, displayer->current_file);
    }
#line 112
    if (start >= tmp___0) {
      {
#line 112
      tmp___1 = flist_start(displayer->files, displayer->current_file);
#line 112
      tmp___2 = flist_length(displayer->files, displayer->current_file);
      }
#line 112
      if (start < tmp___1 + tmp___2) {
#line 116
        return (displayer->current_file);
      } else {
        {
#line 119
        tmp = flist_search(displayer->files, start);
        }
#line 119
        return (tmp);
      }
    } else {
      {
#line 119
      tmp = flist_search(displayer->files, start);
      }
#line 119
      return (tmp);
    }
  } else {
    {
#line 119
    tmp = flist_search(displayer->files, start);
    }
#line 119
    return (tmp);
  }
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
char const   *fetch_region(Displayer *d , Region *region , int *size ) 
{ 
  int fnum ;
  int start ;
  int len ;
  char const   *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 128
  if (! region) {
#line 129
    *size = 0;
#line 130
    return ((char const   *)((void *)0));
  } else
#line 128
  if (region->start == -1) {
#line 129
    *size = 0;
#line 130
    return ((char const   *)((void *)0));
  }
  {
#line 132
  start = region->start;
#line 133
  len = (region->end - start) + 1;
#line 134
  check_region(d, & start, & len);
  }
#line 135
  if (len <= 0) {
#line 136
    *size = 0;
#line 137
    tmp = -1;
#line 137
    region->end = tmp;
#line 137
    region->start = tmp;
#line 138
    return ((char const   *)((void *)0));
  }
  {
#line 140
  fnum = locate_file_num(d, region->start);
#line 141
  tmp___0 = flist_start(d->files, fnum);
#line 141
  start -= tmp___0;
#line 142
  tmp___2 = flist_length(d->files, fnum);
  }
#line 142
  if (start + len > tmp___2) {
    {
#line 144
    tmp___1 = flist_length(d->files, fnum);
#line 144
    len = tmp___1 - start;
    }
  }
  {
#line 146
  region->start += len;
#line 147
  r = get_file_region(d, fnum, (unsigned int )start, (unsigned int )len);
  }
#line 148
  if (r) {
#line 148
    *size = len;
  } else {
#line 148
    *size = 0;
  }
#line 149
  return (r);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void show_region(Displayer *displayer , int start , int len ) 
{ 
  int fnum ;
  int tmp ;
  int fstart ;
  int flen ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 160
  check_region(displayer, & start, & len);
  }
#line 161
  if (len <= 0) {
#line 161
    return;
  }
  {
#line 163
  fnum = locate_file_num(displayer, start);
  }
#line 164
  if (fnum >= 0) {
    {
#line 164
    tmp = flist_files(displayer->files);
    }
#line 164
    if (! (fnum < tmp)) {
      {
#line 164
      __assert_fail("fnum>=0 && fnum<flist_files(displayer->files)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c",
                    164U, "show_region");
      }
    }
  } else {
    {
#line 164
    __assert_fail("fnum>=0 && fnum<flist_files(displayer->files)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c",
                  164U, "show_region");
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (len > 0)) {
#line 166
      goto while_break;
    }
    {
#line 168
    tmp___0 = flist_start(displayer->files, fnum);
#line 168
    fstart = start - tmp___0;
#line 169
    tmp___1 = flist_length(displayer->files, fnum);
#line 169
    flen = tmp___1 - fstart;
    }
#line 170
    if (flen > len) {
#line 170
      flen = len;
    }
    {
#line 171
    show_file_region(displayer, fnum, (unsigned int )fstart, (unsigned int )flen);
#line 172
    start += flen;
#line 173
    len -= flen;
#line 174
    fnum ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void expand(Displayer *displayer , int ch , Region r ) 
{ 
  int i___0 ;
  char const   *name ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 185
  i___0 = -1;
#line 187
  displayer->last_char = 0;
  {
#line 190
  if (ch == 102) {
#line 190
    goto case_102;
  }
#line 211
  if (ch == 115) {
#line 211
    goto case_115;
  }
#line 214
  if (ch == 101) {
#line 214
    goto case_101;
  }
#line 217
  if (ch == 108) {
#line 217
    goto case_108;
  }
#line 220
  if (ch == 105) {
#line 220
    goto case_105;
  }
#line 227
  if (ch == 106) {
#line 227
    goto case_106;
  }
#line 234
  if (ch == 114) {
#line 234
    goto case_114;
  }
#line 237
  if (ch == 110) {
#line 237
    goto case_110;
  }
#line 240
  if (ch == 37) {
#line 240
    goto case_37;
  }
#line 243
  goto switch_default;
  case_102: /* CIL Label */ 
#line 191
  if (r.start >= displayer->last) {
    {
#line 193
    fputs((char const   */* __restrict  */)"<input exceeded>", (FILE */* __restrict  */)displayer->stream);
    }
#line 194
    goto switch_break;
  }
#line 196
  if (i___0 == -1) {
    {
#line 196
    i___0 = flist_search(displayer->files, r.start);
    }
  }
#line 197
  if (i___0 >= 0) {
    {
#line 198
    tmp = flist_name(displayer->files, i___0);
#line 198
    name = tmp;
    }
#line 199
    if (name) {
      {
#line 200
      fputs((char const   */* __restrict  */)name, (FILE */* __restrict  */)displayer->stream);
      }
    } else {
      {
#line 202
      fputs((char const   */* __restrict  */)"<stdin>", (FILE */* __restrict  */)displayer->stream);
      }
#line 203
      goto switch_break;
    }
  } else {
    {
#line 206
    sgrep_error(displayer->sgrep, (char *)"Could not find file for region (%d,%d)\n",
                r.start, r.end);
    }
  }
#line 210
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 212
  fprintf((FILE */* __restrict  */)displayer->stream, (char const   */* __restrict  */)"%d",
          r.start + displayer->first_ind);
  }
#line 213
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 215
  fprintf((FILE */* __restrict  */)displayer->stream, (char const   */* __restrict  */)"%d",
          r.end + displayer->first_ind);
  }
#line 216
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 218
  fprintf((FILE */* __restrict  */)displayer->stream, (char const   */* __restrict  */)"%d",
          (r.end - r.start) + 1);
  }
#line 219
  goto switch_break;
  case_105: /* CIL Label */ 
#line 221
  if (r.start > displayer->last) {
    {
#line 222
    tmp___0 = flist_files(displayer->files);
#line 222
    i___0 = tmp___0 - 1;
    }
  } else
#line 223
  if (i___0 == -1) {
    {
#line 223
    i___0 = flist_search(displayer->files, r.start);
    }
  }
  {
#line 224
  tmp___1 = flist_start(displayer->files, i___0);
#line 224
  fprintf((FILE */* __restrict  */)displayer->stream, (char const   */* __restrict  */)"%d",
          r.start - tmp___1);
  }
#line 226
  goto switch_break;
  case_106: /* CIL Label */ 
#line 228
  if (r.end > displayer->last) {
    {
#line 229
    tmp___2 = flist_files(displayer->files);
#line 229
    i___0 = tmp___2 - 1;
    }
  } else
#line 230
  if (i___0 == -1) {
    {
#line 230
    i___0 = flist_search(displayer->files, r.end);
    }
  }
  {
#line 231
  tmp___3 = flist_start(displayer->files, i___0);
#line 231
  fprintf((FILE */* __restrict  */)displayer->stream, (char const   */* __restrict  */)"%d",
          r.end - tmp___3);
  }
#line 233
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 235
  show_region(displayer, r.start, (r.end - r.start) + 1);
  }
#line 236
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 238
  fprintf((FILE */* __restrict  */)displayer->stream, (char const   */* __restrict  */)"%d",
          displayer->region);
  }
#line 239
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 241
  fputc('%', displayer->stream);
  }
#line 242
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 244
  fputc('%', displayer->stream);
#line 245
  fputc(ch, displayer->stream);
#line 246
  displayer->last_char = ch;
  }
#line 247
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 249
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void escape(Displayer *displayer , int ch ) 
{ 


  {
#line 257
  displayer->last_char = 0;
  {
#line 260
  if (ch == 110) {
#line 260
    goto case_110;
  }
#line 264
  if (ch == 116) {
#line 264
    goto case_116;
  }
#line 267
  if (ch == 92) {
#line 267
    goto case_92;
  }
#line 270
  if (ch == 34) {
#line 270
    goto case_34;
  }
#line 273
  if (ch == 13) {
#line 273
    goto case_13;
  }
#line 276
  if (ch == 12) {
#line 276
    goto case_12;
  }
#line 279
  if (ch == 8) {
#line 279
    goto case_8;
  }
#line 282
  if (ch == 37) {
#line 282
    goto case_37;
  }
#line 259
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 261
  fputc('\n', displayer->stream);
#line 262
  displayer->last_char = '\n';
  }
#line 263
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 265
  fputc('\t', displayer->stream);
  }
#line 266
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 268
  fputc('\\', displayer->stream);
  }
#line 269
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 271
  fputc('\"', displayer->stream);
  }
#line 272
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 274
  fputc('\r', displayer->stream);
  }
#line 275
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 277
  fputc('\f', displayer->stream);
  }
#line 278
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 280
  fputc('\b', displayer->stream);
  }
#line 281
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 283
  fputc('%', displayer->stream);
  }
#line 284
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
int display_gc_list(Displayer *displayer , RegionList *l ) 
{ 
  ListIterator lp ;
  Region r ;
  Region p ;
  int i___0 ;
  int ch ;
  struct SgrepStruct *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 298
  sgrep___0 = displayer->sgrep;
#line 300
  start_region_search(l, & lp);
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 301
    check_get_region((ListIterator const   *)(& lp), (Region const   *)(& r));
    }
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 301
        goto _L;
      } else
#line 301
      if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 301
        if (lp.ind == (int )(lp.list)->length) {
#line 301
          r.start = -1;
#line 301
          r.end = -1;
#line 301
          goto while_break___0;
        }
#line 301
        if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 301
          r.start = lp.ind;
#line 301
          r.end = lp.ind + (int )(lp.list)->chars;
#line 301
          (lp.ind) ++;
#line 301
          goto while_break___0;
        }
      }
#line 301
      if (lp.ind == 1 << 7) {
#line 301
        lp.node = (lp.node)->next;
#line 301
        lp.ind = 0;
      }
#line 301
      tmp = lp.ind;
#line 301
      (lp.ind) ++;
#line 301
      r = (lp.node)->list[tmp];
#line 301
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  if (r.start > 0) {
#line 302
    if (sgrep___0->print_all) {
      {
#line 305
      show_region(displayer, 0, r.start);
      }
    }
  }
#line 308
  if (r.start == -1) {
#line 308
    if (sgrep___0->print_all) {
      {
#line 310
      show_region(displayer, 0, displayer->last);
      }
    }
  }
  {
#line 313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 313
    if (r.start != -1) {
      {
#line 313
      tmp___1 = ferror(displayer->stream);
      }
#line 313
      if (tmp___1) {
#line 313
        goto while_break___1;
      }
    } else {
#line 313
      goto while_break___1;
    }
#line 316
    i___0 = 0;
    {
#line 316
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 316
      ch = (int )*(sgrep___0->output_style + i___0);
#line 316
      if (! ch) {
#line 316
        goto while_break___2;
      }
#line 318
      if (ch == 37) {
#line 318
        goto _L___0;
      } else
#line 318
      if (ch == 92) {
        _L___0: /* CIL Label */ 
#line 318
        if (*(sgrep___0->output_style + (i___0 + 1))) {
#line 320
          if (ch == 37) {
            {
#line 320
            i___0 ++;
#line 320
            expand(displayer, (int )*(sgrep___0->output_style + i___0), r);
            }
          }
#line 321
          if (ch == 92) {
            {
#line 321
            i___0 ++;
#line 321
            escape(displayer, (int )*(sgrep___0->output_style + i___0));
            }
          }
        } else {
          {
#line 324
          fputc(ch, displayer->stream);
#line 325
          displayer->last_char = ch;
          }
        }
      } else {
        {
#line 324
        fputc(ch, displayer->stream);
#line 325
        displayer->last_char = ch;
        }
      }
#line 316
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 328
    p = r;
    {
#line 329
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 329
      check_get_region((ListIterator const   *)(& lp), (Region const   *)(& r));
      }
      {
#line 329
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 329
        if ((unsigned long )lp.node == (unsigned long )((void *)0)) {
#line 329
          goto _L___1;
        } else
#line 329
        if ((unsigned long )(lp.node)->next == (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 329
          if (lp.ind == (int )(lp.list)->length) {
#line 329
            r.start = -1;
#line 329
            r.end = -1;
#line 329
            goto while_break___4;
          }
#line 329
          if ((unsigned long )(lp.list)->last == (unsigned long )((void *)0)) {
#line 329
            r.start = lp.ind;
#line 329
            r.end = lp.ind + (int )(lp.list)->chars;
#line 329
            (lp.ind) ++;
#line 329
            goto while_break___4;
          }
        }
#line 329
        if (lp.ind == 1 << 7) {
#line 329
          lp.node = (lp.node)->next;
#line 329
          lp.ind = 0;
        }
#line 329
        tmp___0 = lp.ind;
#line 329
        (lp.ind) ++;
#line 329
        r = (lp.node)->list[tmp___0];
#line 329
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 329
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 331
    if (r.start > 0) {
#line 331
      if (p.end < r.start - 1) {
#line 331
        if (sgrep___0->print_all) {
          {
#line 334
          show_region(displayer, p.end + 1, (r.start - p.end) - 1);
          }
        }
      }
    }
#line 336
    (displayer->region) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 338
  tmp___2 = ferror(displayer->stream);
  }
#line 338
  if (! tmp___2) {
#line 338
    if (r.start == -1) {
#line 338
      if (sgrep___0->print_all) {
#line 338
        if (p.end < displayer->last) {
          {
#line 342
          show_region(displayer, p.end + 1, (displayer->last - p.end) - 1);
          }
        }
      }
    }
  }
  {
#line 344
  tmp___3 = ferror(displayer->stream);
  }
#line 344
  if (! tmp___3) {
#line 344
    if (displayer->last_char != 10) {
#line 344
      if (sgrep___0->print_newline) {
        {
#line 346
        fputc('\n', displayer->stream);
        }
      }
    }
  }
  {
#line 347
  tmp___4 = ferror(displayer->stream);
  }
#line 347
  if (! tmp___4) {
    {
#line 347
    fflush(displayer->stream);
    }
  }
  {
#line 348
  tmp___7 = ferror(displayer->stream);
  }
#line 348
  if (tmp___7) {
    {
#line 349
    tmp___5 = __errno_location();
#line 349
    tmp___6 = strerror(*tmp___5);
#line 349
    sgrep_error(sgrep___0, (char *)"Error writing output: %s\n", tmp___6);
    }
#line 350
    return (-1);
  }
#line 352
  return (0);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void init_displayer(Displayer *displayer , SgrepData *sgrep___0 , FileList *files ) 
{ 


  {
  {
#line 356
  displayer->sgrep = sgrep___0;
#line 357
  displayer->files = (FileList const   *)files;
#line 358
  displayer->region = 1;
#line 359
  displayer->current_file = -1;
#line 360
  displayer->last = flist_total((FileList const   *)files);
#line 361
  displayer->first_ind = 0;
#line 362
  displayer->last_char = 0;
#line 363
  displayer->start_warned = 0;
#line 364
  displayer->end_warned = 0;
#line 365
  displayer->stream = (FILE *)((void *)0);
#line 366
  displayer->map = (char *)((void *)0);
#line 367
  displayer->map_size = (size_t )0;
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void clean_up_displayer(Displayer *displayer ) 
{ 
  SgrepData *sgrep___0 ;

  {
#line 371
  sgrep___0 = displayer->sgrep;
#line 372
  if ((unsigned long )displayer->map != (unsigned long )((void *)0)) {
    {
#line 373
    unmap_file(sgrep___0, (void *)displayer->map, displayer->map_size);
    }
  }
#line 375
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
Displayer *new_displayer(SgrepData *sgrep___0 , FileList *files ) 
{ 
  Displayer *d ;
  void *tmp ;

  {
  {
#line 378
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(Displayer ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c",
                           378);
#line 378
  d = (Displayer *)tmp;
#line 379
  init_displayer(d, sgrep___0, files);
  }
#line 380
  return (d);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
void delete_displayer(Displayer *d ) 
{ 
  SgrepData *sgrep___0 ;

  {
  {
#line 384
  sgrep___0 = d->sgrep;
#line 385
  clean_up_displayer(d);
#line 386
  sgrep_debug_free(sgrep___0, (void *)d);
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/output.c"
int write_region_list(struct SgrepStruct *sgrep___0 , FILE *stream , RegionList *list ,
                      FileList *files ) 
{ 
  int r ;
  Displayer displayer ;

  {
  {
#line 394
  init_displayer(& displayer, sgrep___0, files);
#line 396
  displayer.stream = stream;
#line 397
  clean_up_displayer(& displayer);
#line 398
  r = display_gc_list(& displayer, list);
  }
#line 399
  return (r);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 566 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
char const   *give_oper_name(int oper ) ;
#line 567
void free_parse_tree(SgrepData *sgrep___0 , ParseTreeNode *root ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
void real_parse_error(Parser *parser , char *error ) ;
#line 115
int get_next_char(Parser *parser ) ;
#line 116
enum Token next_token(Parser *parser ) ;
#line 118
ParseTreeNode *create_tree_node(Parser *parser , enum Oper oper ) ;
#line 119
ParseTreeNode *parse_reg_expr(Parser *parser ) ;
#line 120
ParseTreeNode *parse_basic_expr(Parser *parser ) ;
#line 121
ParseTreeNode *parse_oper_expr(Parser *parser , ParseTreeNode *left ) ;
#line 122
ParseTreeNode *parse_phrase(Parser *parser , char const   *typestr ) ;
#line 123
ParseTreeNode *parse_cons_list(Parser *parser ) ;
#line 124
ParseTreeNode *new_string_phrase(Parser *parser , SgrepString *phrase , char const   *typestr ) ;
#line 140 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
struct __anonstruct_reserved_words_30 reserved_words[54]  = 
#line 140
  {      {"in", (enum Token )0}, 
        {"not", (enum Token )1}, 
        {"containing", (enum Token )2}, 
        {"or", (enum Token )3}, 
        {"..", (enum Token )4}, 
        {"_.", (enum Token )5}, 
        {"._", (enum Token )6}, 
        {"__", (enum Token )7}, 
        {"extracting", (enum Token )8}, 
        {"quote", (enum Token )9}, 
        {"_quote", (enum Token )10}, 
        {"quote_", (enum Token )11}, 
        {"_quote_", (enum Token )12}, 
        {"equal", (enum Token )13}, 
        {"parenting", (enum Token )14}, 
        {"childrening", (enum Token )15}, 
        {"near", (enum Token )16}, 
        {"near_before", (enum Token )17}, 
        {"outer", (enum Token )18}, 
        {"inner", (enum Token )19}, 
        {"concat", (enum Token )20}, 
        {"chars", (enum Token )26}, 
        {"first", (enum Token )22}, 
        {"last", (enum Token )23}, 
        {"first_bytes", (enum Token )24}, 
        {"last_bytes", (enum Token )25}, 
        {"join", (enum Token )21}, 
        {"start", (enum Token )27}, 
        {"end", (enum Token )28}, 
        {"file", (enum Token )31}, 
        {"string", (enum Token )32}, 
        {"regex", (enum Token )33}, 
        {"pi", (enum Token )37}, 
        {"attribute", (enum Token )38}, 
        {"attvalue", (enum Token )39}, 
        {"stag", (enum Token )40}, 
        {"etag", (enum Token )41}, 
        {"comments", (enum Token )42}, 
        {"elements", (enum Token )30}, 
        {"comment_word", (enum Token )43}, 
        {"word", (enum Token )44}, 
        {"cdata", (enum Token )45}, 
        {"entity", (enum Token )46}, 
        {"prologs", (enum Token )29}, 
        {"doctype", (enum Token )34}, 
        {"doctype_pid", (enum Token )35}, 
        {"doctype_sid", (enum Token )36}, 
        {"entity_declaration", (enum Token )47}, 
        {"entity_literal", (enum Token )48}, 
        {"entity_pid", (enum Token )49}, 
        {"entity_sid", (enum Token )50}, 
        {"entity_ndata", (enum Token )51}, 
        {"raw", (enum Token )52}, 
        {(char const   *)((void *)0), (enum Token )63}};
#line 211 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
char const   *give_oper_name(int oper ) 
{ 


  {
  {
#line 214
  if (oper == 0) {
#line 214
    goto case_0;
  }
#line 215
  if (oper == 1) {
#line 215
    goto case_1;
  }
#line 216
  if (oper == 2) {
#line 216
    goto case_2;
  }
#line 217
  if (oper == 3) {
#line 217
    goto case_3;
  }
#line 218
  if (oper == 4) {
#line 218
    goto case_4;
  }
#line 219
  if (oper == 5) {
#line 219
    goto case_5;
  }
#line 220
  if (oper == 15) {
#line 220
    goto case_15;
  }
#line 221
  if (oper == 6) {
#line 221
    goto case_6;
  }
#line 222
  if (oper == 7) {
#line 222
    goto case_7;
  }
#line 223
  if (oper == 8) {
#line 223
    goto case_8;
  }
#line 224
  if (oper == 9) {
#line 224
    goto case_9;
  }
#line 225
  if (oper == 14) {
#line 225
    goto case_14;
  }
#line 226
  if (oper == 20) {
#line 226
    goto case_20;
  }
#line 227
  if (oper == 21) {
#line 227
    goto case_21;
  }
#line 228
  if (oper == 22) {
#line 228
    goto case_22;
  }
#line 229
  if (oper == 23) {
#line 229
    goto case_23;
  }
#line 230
  if (oper == 28) {
#line 230
    goto case_28;
  }
#line 231
  if (oper == 29) {
#line 231
    goto case_29;
  }
#line 232
  goto switch_default;
  case_0: /* CIL Label */ 
#line 214
  return ("in");
#line 214
  goto switch_break;
  case_1: /* CIL Label */ 
#line 215
  return ("not in");
#line 215
  goto switch_break;
  case_2: /* CIL Label */ 
#line 216
  return ("containing");
#line 216
  goto switch_break;
  case_3: /* CIL Label */ 
#line 217
  return ("not containing");
#line 217
  goto switch_break;
  case_4: /* CIL Label */ 
#line 218
  return ("equal");
#line 218
  goto switch_break;
  case_5: /* CIL Label */ 
#line 219
  return ("not equal");
#line 219
  goto switch_break;
  case_15: /* CIL Label */ 
#line 220
  return ("or");
#line 220
  goto switch_break;
  case_6: /* CIL Label */ 
#line 221
  return ("..");
#line 221
  goto switch_break;
  case_7: /* CIL Label */ 
#line 222
  return ("_.");
#line 222
  goto switch_break;
  case_8: /* CIL Label */ 
#line 223
  return ("._");
#line 223
  goto switch_break;
  case_9: /* CIL Label */ 
#line 224
  return ("__");
#line 224
  goto switch_break;
  case_14: /* CIL Label */ 
#line 225
  return ("extracting");
#line 225
  goto switch_break;
  case_20: /* CIL Label */ 
#line 226
  return ("outer");
#line 226
  goto switch_break;
  case_21: /* CIL Label */ 
#line 227
  return ("inner");
#line 227
  goto switch_break;
  case_22: /* CIL Label */ 
#line 228
  return ("concat");
#line 228
  goto switch_break;
  case_23: /* CIL Label */ 
#line 229
  return ("join");
#line 229
  goto switch_break;
  case_28: /* CIL Label */ 
#line 230
  return ("phrase");
#line 230
  goto switch_break;
  case_29: /* CIL Label */ 
#line 231
  return ("invalid");
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 232
  return ("unknown");
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 234
  return ((char const   *)0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
int get_next_char(Parser *parser ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 245
  if ((int const   )*(parser->expr_str + parser->expr_ind) == 10) {
#line 245
    goto case_10;
  }
#line 244
  goto switch_break;
  case_10: /* CIL Label */ 
#line 246
  parser->column = -1;
#line 247
  (parser->line) ++;
#line 248
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 250
  (parser->column) ++;
#line 251
  tmp___0 = parser->expr_ind;
#line 251
  (parser->expr_ind) ++;
#line 251
  tmp = (int )*((unsigned char *)parser->expr_str + tmp___0);
#line 251
  parser->ch = tmp;
#line 251
  return (tmp);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
enum Token next_token(Parser *parser ) 
{ 
  char str[513] ;
  int i___0 ;
  int j ;
  int start ;
  int ch ;
  SgrepString **phrase ;
  SgrepData *sgrep___0 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 260
  i___0 = 0;
#line 260
  j = 0;
#line 264
  sgrep___0 = parser->sgrep;
#line 268
  ch = parser->ch;
#line 269
  phrase = & parser->string_token;
#line 270
  if (ch == -1) {
    {
#line 270
    ch = get_next_char(parser);
    }
  }
#line 273
  parser->errline = parser->line;
#line 274
  parser->errcol = parser->column;
#line 275
  parser->errind = parser->expr_ind;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    if ((unsigned int )parser->scanner_state == 0U) {
#line 282
      goto case_0;
    }
#line 342
    if ((unsigned int )parser->scanner_state == 1U) {
#line 342
      goto case_1;
    }
#line 376
    if ((unsigned int )parser->scanner_state == 2U) {
#line 376
      goto case_2;
    }
#line 395
    if ((unsigned int )parser->scanner_state == 5U) {
#line 395
      goto case_5;
    }
#line 406
    if ((unsigned int )parser->scanner_state == 4U) {
#line 406
      goto case_4;
    }
#line 416
    if ((unsigned int )parser->scanner_state == 6U) {
#line 416
      goto case_6;
    }
#line 433
    if ((unsigned int )parser->scanner_state == 7U) {
#line 433
      goto case_7;
    }
#line 453
    if ((unsigned int )parser->scanner_state == 8U) {
#line 453
      goto case_8;
    }
#line 471
    if ((unsigned int )parser->scanner_state == 3U) {
#line 471
      goto case_3;
    }
#line 279
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 284
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 284
      tmp = __ctype_b_loc();
      }
#line 284
      if (! ((int const   )*(*tmp + ch) & 8192)) {
#line 284
        goto while_break___0;
      }
      {
#line 284
      ch = get_next_char(parser);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 287
    parser->errline = parser->line;
#line 288
    parser->errcol = parser->column;
#line 289
    parser->errind = parser->expr_ind;
    {
#line 292
    if (ch == 0) {
#line 292
      goto case_0___0;
    }
#line 294
    if (ch == 40) {
#line 294
      goto case_40;
    }
#line 297
    if (ch == 41) {
#line 297
      goto case_41;
    }
#line 300
    if (ch == 91) {
#line 300
      goto case_91;
    }
#line 303
    if (ch == 93) {
#line 303
      goto case_93;
    }
#line 306
    if (ch == 44) {
#line 306
      goto case_44;
    }
#line 309
    if (ch == 34) {
#line 309
      goto case_34;
    }
#line 313
    if (ch == 35) {
#line 313
      goto case_35;
    }
#line 291
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 293
    return ((enum Token )61);
    case_40: /* CIL Label */ 
#line 295
    parser->ch = -1;
#line 296
    return ((enum Token )54);
    case_41: /* CIL Label */ 
#line 298
    parser->ch = -1;
#line 299
    return ((enum Token )55);
    case_91: /* CIL Label */ 
#line 301
    parser->ch = -1;
#line 302
    return ((enum Token )56);
    case_93: /* CIL Label */ 
#line 304
    parser->ch = -1;
#line 305
    return ((enum Token )57);
    case_44: /* CIL Label */ 
#line 307
    parser->ch = -1;
#line 308
    return ((enum Token )58);
    case_34: /* CIL Label */ 
#line 310
    i___0 = 0;
#line 311
    parser->scanner_state = (enum ScannerState )1;
#line 312
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 314
    parser->scanner_state = (enum ScannerState )4;
#line 315
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 317
    tmp___1 = __ctype_b_loc();
    }
#line 317
    if ((int const   )*(*tmp___1 + ch) & 1024) {
      {
#line 319
      i___0 = 1;
#line 320
      tmp___0 = tolower(ch);
#line 320
      str[0] = (char )tmp___0;
#line 321
      parser->scanner_state = (enum ScannerState )2;
#line 322
      start = parser->column;
      }
    } else
#line 317
    if (ch == 46) {
      {
#line 319
      i___0 = 1;
#line 320
      tmp___0 = tolower(ch);
#line 320
      str[0] = (char )tmp___0;
#line 321
      parser->scanner_state = (enum ScannerState )2;
#line 322
      start = parser->column;
      }
    } else
#line 317
    if (ch == 95) {
      {
#line 319
      i___0 = 1;
#line 320
      tmp___0 = tolower(ch);
#line 320
      str[0] = (char )tmp___0;
#line 321
      parser->scanner_state = (enum ScannerState )2;
#line 322
      start = parser->column;
      }
    }
#line 324
    if (ch >= 48) {
#line 324
      if (ch <= 57) {
#line 326
        i___0 = 1;
#line 327
        str[0] = (char )ch;
#line 328
        start = parser->column;
#line 329
        parser->scanner_state = (enum ScannerState )3;
      }
    }
#line 331
    if ((unsigned int )parser->scanner_state == 0U) {
      {
#line 336
      real_parse_error(parser, (char *)"Invalid character");
      }
#line 337
      return ((enum Token )62);
    }
#line 339
    goto switch_break;
    case_1: /* CIL Label */ 
#line 343
    if (ch == 0) {
      {
#line 345
      real_parse_error(parser, (char *)"Unterminated phrase string");
      }
#line 346
      return ((enum Token )62);
    } else
#line 343
    if (ch == 10) {
      {
#line 345
      real_parse_error(parser, (char *)"Unterminated phrase string");
      }
#line 346
      return ((enum Token )62);
    }
#line 348
    if (ch < 32) {
      {
#line 349
      real_parse_error(parser, (char *)"Unprintable character in phrase");
      }
#line 350
      return ((enum Token )62);
    }
#line 352
    if (ch == 34) {
#line 352
      if (i___0 == 0) {
#line 352
        goto _L;
      } else
#line 352
      if ((int )str[i___0 - 1] != 92) {
        _L: /* CIL Label */ 
        {
#line 354
        str[i___0] = (char)0;
#line 355
        *phrase = expand_backslashes(sgrep___0, (char const   *)(str));
        }
#line 356
        if (! *phrase) {
          {
#line 357
          real_parse_error(parser, (char *)"Empty phrase");
          }
#line 358
          return ((enum Token )62);
        } else
#line 356
        if ((*phrase)->length == 0UL) {
          {
#line 357
          real_parse_error(parser, (char *)"Empty phrase");
          }
#line 358
          return ((enum Token )62);
        }
#line 360
        parser->scanner_state = (enum ScannerState )0;
#line 361
        parser->ch = -1;
#line 362
        return ((enum Token )59);
      }
    }
#line 364
    if (i___0 == 512) {
      {
#line 366
      sgrep_error(sgrep___0, (char *)"%s ( > %d ) %s %d\n%s\n%s\n", "Phrase length exceeds",
                  512, "on line", parser->line, "Either you have forgotten the quote  at the end of phrase or",
                  "you have to recompile with greater MAX_PHRASE_LENGTH.");
#line 370
      real_parse_error(parser, (char *)"");
      }
#line 371
      return ((enum Token )62);
    }
#line 373
    if ((unsigned int )parser->scanner_state == 1U) {
#line 373
      tmp___2 = i___0;
#line 373
      i___0 ++;
#line 373
      str[tmp___2] = (char )ch;
    }
#line 374
    goto switch_break;
    case_2: /* CIL Label */ 
#line 377
    if (ch == 0) {
#line 377
      goto _L___0;
    } else {
      {
#line 377
      tmp___4 = __ctype_b_loc();
      }
#line 377
      if (! ((int const   )*(*tmp___4 + ch) & 1024)) {
#line 377
        if (ch != 46) {
#line 377
          if (ch != 95) {
            _L___0: /* CIL Label */ 
#line 379
            parser->scanner_state = (enum ScannerState )0;
#line 380
            str[i___0] = (char)0;
#line 381
            j = 0;
            {
#line 381
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 381
              if (! reserved_words[j].word) {
#line 381
                goto while_break___1;
              }
              {
#line 382
              tmp___3 = strcmp(reserved_words[j].word, (char const   *)(str));
              }
#line 382
              if (tmp___3 == 0) {
#line 383
                return (reserved_words[j].t);
              }
#line 381
              j ++;
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 384
            real_parse_error(parser, (char *)"Unknown word");
            }
#line 385
            return ((enum Token )62);
          }
        }
      }
    }
#line 387
    if (i___0 == 20) {
      {
#line 389
      real_parse_error(parser, (char *)"Unknown word");
      }
#line 390
      return ((enum Token )62);
    }
    {
#line 392
    tmp___5 = i___0;
#line 392
    i___0 ++;
#line 392
    tmp___6 = tolower(ch);
#line 392
    str[tmp___5] = (char )tmp___6;
    }
#line 393
    goto switch_break;
    case_5: /* CIL Label */ 
#line 396
    if (parser->column <= 6) {
#line 396
      if ((int const   )*("#line " + (parser->column - 1)) == (int const   )ch) {
#line 398
        goto switch_break;
      } else {
#line 396
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 399
    if (parser->column == 7) {
#line 399
      if (ch >= 48) {
#line 399
        if (ch <= 57) {
#line 400
          parser->line = (ch - 48) - 1;
#line 401
          parser->scanner_state = (enum ScannerState )6;
        } else {
#line 403
          parser->scanner_state = (enum ScannerState )4;
        }
      } else {
#line 403
        parser->scanner_state = (enum ScannerState )4;
      }
    } else {
#line 403
      parser->scanner_state = (enum ScannerState )4;
    }
    case_4: /* CIL Label */ 
#line 407
    if (ch == 0) {
#line 408
      parser->scanner_state = (enum ScannerState )0;
#line 409
      return ((enum Token )61);
    } else
#line 410
    if (ch == 10) {
#line 411
      parser->scanner_state = (enum ScannerState )0;
    } else
#line 412
    if (ch == 108) {
#line 412
      if (parser->column == 2) {
#line 413
        parser->scanner_state = (enum ScannerState )5;
      }
    }
#line 415
    goto switch_break;
    case_6: /* CIL Label */ 
#line 417
    if (ch >= 48) {
#line 417
      if (ch <= 57) {
#line 418
        parser->line = parser->line * 10 + (ch - 48);
      } else {
#line 417
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 419
    if (ch == 32) {
#line 420
      parser->scanner_state = (enum ScannerState )7;
    } else
#line 421
    if (ch == 10) {
#line 422
      parser->scanner_state = (enum ScannerState )0;
    } else
#line 423
    if (ch == 0) {
#line 424
      parser->scanner_state = (enum ScannerState )0;
#line 425
      return ((enum Token )61);
    } else {
      {
#line 427
      *((parser->file)->s + (parser->file)->length) = (char)0;
#line 427
      sgrep_error(sgrep___0, (char *)"Warning: \'%s\':%d: Malformed #line directive.\n",
                  (char const   *)(parser->file)->s, parser->errline);
#line 429
      parser->line = parser->errline;
#line 430
      parser->scanner_state = (enum ScannerState )4;
      }
    }
#line 432
    goto switch_break;
    case_7: /* CIL Label */ 
#line 434
    if (ch == 34) {
#line 435
      (parser->file)->length = (size_t )0;
#line 436
      parser->scanner_state = (enum ScannerState )8;
#line 437
      goto switch_break;
    }
    {
#line 439
    *((parser->file)->s + (parser->file)->length) = (char)0;
#line 439
    sgrep_error(sgrep___0, (char *)"Warning: \'%s\':%d: Malformed #line directive.\n",
                (char const   *)(parser->file)->s, parser->errline);
#line 441
    parser->line = parser->errline;
    }
#line 442
    if (ch == 0) {
#line 443
      parser->scanner_state = (enum ScannerState )0;
#line 444
      return ((enum Token )61);
#line 445
      goto switch_break;
    }
#line 447
    if (ch == 10) {
#line 448
      parser->scanner_state = (enum ScannerState )0;
#line 449
      goto switch_break;
    }
#line 451
    parser->scanner_state = (enum ScannerState )4;
#line 452
    goto switch_break;
    case_8: /* CIL Label */ 
#line 454
    if (ch == 34) {
#line 455
      parser->scanner_state = (enum ScannerState )4;
#line 456
      goto switch_break;
    }
#line 458
    if (ch == 10) {
#line 458
      goto _L___3;
    } else
#line 458
    if (ch == 0) {
      _L___3: /* CIL Label */ 
      {
#line 459
      (parser->file)->length = (size_t )0;
#line 460
      string_cat(parser->file, "[unknown]");
#line 461
      *((parser->file)->s + (parser->file)->length) = (char)0;
#line 461
      sgrep_error(sgrep___0, (char *)"Warning: \'%s\':%d: Malformed #line directive.\n",
                  (char const   *)(parser->file)->s, parser->errline);
#line 463
      parser->line = parser->errline;
#line 464
      parser->scanner_state = (enum ScannerState )0;
      }
#line 465
      if (ch == 0) {
#line 465
        return ((enum Token )61);
      }
#line 466
      goto switch_break;
    }
    {
#line 468
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 468
      if ((parser->file)->length < (parser->file)->size) {
#line 468
        if (ch < 255) {
#line 468
          *((parser->file)->s + (parser->file)->length) = (char )ch;
#line 468
          ((parser->file)->length) ++;
        } else {
          {
#line 468
          real_string_push(parser->file, ch);
          }
        }
      } else {
        {
#line 468
        real_string_push(parser->file, ch);
        }
      }
#line 468
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 469
    goto switch_break;
    case_3: /* CIL Label */ 
#line 472
    if (ch < 48) {
      {
#line 474
      parser->scanner_state = (enum ScannerState )0;
#line 475
      str[i___0] = (char)0;
#line 476
      *phrase = init_string(sgrep___0, (size_t )i___0, (char const   *)(str));
      }
#line 477
      return ((enum Token )60);
    } else
#line 472
    if (ch > 57) {
      {
#line 474
      parser->scanner_state = (enum ScannerState )0;
#line 475
      str[i___0] = (char)0;
#line 476
      *phrase = init_string(sgrep___0, (size_t )i___0, (char const   *)(str));
      }
#line 477
      return ((enum Token )60);
    }
#line 479
    if (i___0 == 9) {
      {
#line 481
      real_parse_error(parser, (char *)"Too big number");
      }
#line 482
      return ((enum Token )62);
    }
#line 484
    tmp___7 = i___0;
#line 484
    i___0 ++;
#line 484
    str[tmp___7] = (char )ch;
#line 485
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 488
    ch = get_next_char(parser);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
void real_parse_error(Parser *parser , char *error ) 
{ 
  char erlin[80] ;
  int i___0 ;
  SgrepData *sgrep___0 ;

  {
#line 500
  sgrep___0 = parser->sgrep;
#line 502
  if ((parser->errcol - 79) + 5 > 0) {
#line 503
    parser->errind -= 74;
  } else {
#line 504
    parser->errind -= parser->errcol;
  }
#line 505
  i___0 = 0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (i___0 < 79) {
#line 505
      if (*(parser->expr_str + (i___0 + parser->errind))) {
#line 505
        if (! ((int const   )*(parser->expr_str + (i___0 + parser->errind)) != 10)) {
#line 505
          goto while_break;
        }
      } else {
#line 505
        goto while_break;
      }
    } else {
#line 505
      goto while_break;
    }
#line 509
    erlin[i___0] = (char )*(parser->expr_str + (i___0 + parser->errind));
#line 510
    if ((int )erlin[i___0] == 9) {
#line 510
      erlin[i___0] = (char )' ';
    }
#line 505
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  erlin[i___0] = (char)0;
#line 514
  if ((parser->file)->length == 0UL) {
    {
#line 515
    sgrep_error(parser->sgrep, (char *)"Parse error in command line expression");
    }
  } else {
#line 516
    *((parser->file)->s + (parser->file)->length) = (char)0;
#line 516
    if ((int const   )*((char const   *)(parser->file)->s + 0) == 45) {
      {
#line 517
      sgrep_error(parser->sgrep, (char *)"Parse error in stdin line %d", parser->errline);
      }
    } else {
      {
#line 520
      *((parser->file)->s + (parser->file)->length) = (char)0;
#line 520
      sgrep_error(parser->sgrep, (char *)"Parse error in file \'%s\' line %d", (char const   *)(parser->file)->s,
                  parser->errline);
      }
    }
  }
  {
#line 523
  sgrep_error(parser->sgrep, (char *)" column %d :\n\t%s\n%s\n", parser->errcol, error,
              erlin);
  }
#line 526
  if (parser->errcol > 74) {
#line 526
    parser->errcol = 74;
  }
#line 527
  i___0 = 0;
  {
#line 527
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 527
    if (! (i___0 < parser->errcol - 1)) {
#line 527
      goto while_break___0;
    }
    {
#line 527
    sgrep_error(sgrep___0, (char *)" ");
#line 527
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 528
  sgrep_error(sgrep___0, (char *)"^\n");
  }
#line 529
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *create_tree_node(Parser *parser , enum Oper oper ) 
{ 
  ParseTreeNode *n ;
  SgrepData *sgrep___0 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 537
  sgrep___0 = parser->sgrep;
#line 539
  if (! (parser->nodes >= 0)) {
    {
#line 539
    __assert_fail("parser->nodes>=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                  539U, "create_tree_node");
    }
  }
#line 540
  if ((unsigned long )parser->nodes == sizeof(parser->node_array) / sizeof(ParseTreeNode *)) {
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 542
      real_parse_error(parser, (char *)"Suspiciously many tree nodes\n");
      }
#line 542
      return ((ParseTreeNode *)((void *)0));
#line 542
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 543
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 546
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(ParseTreeNode ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                           546);
#line 546
  n = (ParseTreeNode *)tmp;
#line 547
  n->left = (struct ParseTreeNodeStruct *)((void *)0);
#line 548
  n->right = (struct ParseTreeNodeStruct *)((void *)0);
#line 549
  n->parent = (struct ParseTreeNodeStruct *)((void *)0);
#line 550
  n->oper = oper;
#line 551
  n->number = -1;
#line 552
  n->leaf = (ParseTreeLeaf *)((void *)0);
#line 553
  n->label_left = -1;
#line 554
  n->label_right = -1;
#line 555
  n->refcount = 0;
#line 556
  n->result = (RegionList *)((void *)0);
#line 558
  tmp___0 = parser->nodes;
#line 558
  (parser->nodes) ++;
#line 558
  parser->node_array[tmp___0] = n;
  }
#line 559
  return (n);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *create_leaf_node(Parser *parser , enum Oper oper , SgrepString *phrase ,
                                int phrase_label ) 
{ 
  ParseTreeNode *n ;
  SgrepData *sgrep___0 ;
  void *tmp ;

  {
  {
#line 570
  sgrep___0 = parser->sgrep;
#line 573
  n = create_tree_node(parser, oper);
  }
#line 574
  if (! n) {
#line 574
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 575
  n->label_left = phrase_label;
#line 577
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(struct PHRASE_NODE ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                           577);
#line 577
  n->leaf = (struct PHRASE_NODE *)tmp;
#line 578
  (n->leaf)->phrase = phrase;
#line 579
  (n->leaf)->regions = (RegionList *)((void *)0);
#line 580
  n->result = (RegionList *)((void *)0);
  }
#line 581
  return (n);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *new_string_phrase(Parser *parser , SgrepString *phrase , char const   *typestr ) 
{ 
  ParseTreeNode *n ;
  SgrepData *sgrep___0 ;
  size_t tmp ;

  {
#line 588
  sgrep___0 = parser->sgrep;
#line 590
  if ((unsigned long )phrase == (unsigned long )((void *)0)) {
    {
#line 591
    tmp = strlen(typestr);
#line 591
    phrase = init_string(sgrep___0, tmp, typestr);
    }
  } else {
    {
#line 593
    push_front(phrase, typestr);
    }
  }
  {
#line 595
  n = create_leaf_node(parser, (enum Oper )28, phrase, 2);
  }
#line 596
  if (! n) {
    {
#line 597
    delete_string(phrase);
    }
#line 598
    return ((ParseTreeNode *)((void *)0));
  }
#line 602
  (n->leaf)->next = parser->first_phrase;
#line 603
  parser->first_phrase = n->leaf;
#line 604
  return (n);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_phrase(Parser *parser , char const   *typestr ) 
{ 
  ParseTreeNode *n ;

  {
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 614
    parser->token = next_token(parser);
    }
#line 614
    if ((unsigned int )parser->token == 62U) {
#line 614
      return ((ParseTreeNode *)((void *)0));
    }
#line 614
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  if ((unsigned int )parser->token != 54U) {
    {
#line 615
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 615
      real_parse_error(parser, (char *)"Expecting \'(\'");
      }
#line 615
      return ((ParseTreeNode *)((void *)0));
#line 615
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 616
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 616
    parser->token = next_token(parser);
    }
#line 616
    if ((unsigned int )parser->token == 62U) {
#line 616
      return ((ParseTreeNode *)((void *)0));
    }
#line 616
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 617
  if ((unsigned int )parser->token != 59U) {
    {
#line 617
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 617
      real_parse_error(parser, (char *)"Expecting phrase string");
      }
#line 617
      return ((ParseTreeNode *)((void *)0));
#line 617
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 618
  n = new_string_phrase(parser, parser->string_token, typestr);
  }
#line 619
  if (! n) {
#line 619
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 623
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 623
    parser->token = next_token(parser);
    }
#line 623
    if ((unsigned int )parser->token == 62U) {
#line 623
      return ((ParseTreeNode *)((void *)0));
    }
#line 623
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 624
  if ((unsigned int )parser->token != 55U) {
    {
#line 624
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 624
      real_parse_error(parser, (char *)"Expecting \')\'");
      }
#line 624
      return ((ParseTreeNode *)((void *)0));
#line 624
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 625
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 625
    parser->token = next_token(parser);
    }
#line 625
    if ((unsigned int )parser->token == 62U) {
#line 625
      return ((ParseTreeNode *)((void *)0));
    }
#line 625
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 626
  return (n);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_cons_list(Parser *parser ) 
{ 
  int s ;
  int e ;
  int ps ;
  int pe ;
  char *cons_err ;
  ParseTreeNode *n ;
  RegionList *c_list ;
  SgrepData *sgrep___0 ;
  RegionList *tmp ;

  {
  {
#line 634
  cons_err = (char *)"invalid constant region list";
#line 637
  sgrep___0 = parser->sgrep;
#line 639
  n = create_leaf_node(parser, (enum Oper )28, (SgrepString *)((void *)0), 0);
  }
#line 640
  if (! n) {
#line 640
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 641
    parser->token = next_token(parser);
    }
#line 641
    if ((unsigned int )parser->token == 62U) {
#line 641
      return ((ParseTreeNode *)((void *)0));
    }
#line 641
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 642
  tmp = new_region_list(sgrep___0);
#line 642
  (n->leaf)->regions = tmp;
#line 642
  c_list = tmp;
#line 644
  ps = -1;
#line 644
  pe = -1;
  }
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! ((unsigned int )parser->token != 57U)) {
#line 645
      goto while_break___0;
    }
#line 648
    if ((unsigned int )parser->token != 54U) {
      {
#line 649
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 649
        real_parse_error(parser, cons_err);
        }
#line 649
        return ((ParseTreeNode *)((void *)0));
#line 649
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 650
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 650
      parser->token = next_token(parser);
      }
#line 650
      if ((unsigned int )parser->token == 62U) {
#line 650
        return ((ParseTreeNode *)((void *)0));
      }
#line 650
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 651
    if ((unsigned int )parser->token != 60U) {
      {
#line 652
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 652
        real_parse_error(parser, cons_err);
        }
#line 652
        return ((ParseTreeNode *)((void *)0));
#line 652
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 653
    s = atoi((char const   *)(parser->string_token)->s);
    }
    {
#line 654
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 654
      parser->token = next_token(parser);
      }
#line 654
      if ((unsigned int )parser->token == 62U) {
#line 654
        return ((ParseTreeNode *)((void *)0));
      }
#line 654
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 655
    if ((unsigned int )parser->token != 58U) {
      {
#line 656
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 656
        real_parse_error(parser, cons_err);
        }
#line 656
        return ((ParseTreeNode *)((void *)0));
#line 656
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 657
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 657
      parser->token = next_token(parser);
      }
#line 657
      if ((unsigned int )parser->token == 62U) {
#line 657
        return ((ParseTreeNode *)((void *)0));
      }
#line 657
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 658
    if ((unsigned int )parser->token != 60U) {
      {
#line 659
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 659
        real_parse_error(parser, cons_err);
        }
#line 659
        return ((ParseTreeNode *)((void *)0));
#line 659
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    {
#line 660
    e = atoi((char const   *)(parser->string_token)->s);
    }
    {
#line 661
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 661
      parser->token = next_token(parser);
      }
#line 661
      if ((unsigned int )parser->token == 62U) {
#line 661
        return ((ParseTreeNode *)((void *)0));
      }
#line 661
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 662
    if ((unsigned int )parser->token != 55U) {
      {
#line 663
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 663
        real_parse_error(parser, cons_err);
        }
#line 663
        return ((ParseTreeNode *)((void *)0));
#line 663
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 664
    if (e < s) {
      {
#line 665
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 665
        real_parse_error(parser, (char *)"region end point must be greater than start point");
        }
#line 665
        return ((ParseTreeNode *)((void *)0));
#line 665
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    {
#line 666
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 666
      parser->token = next_token(parser);
      }
#line 666
      if ((unsigned int )parser->token == 62U) {
#line 666
        return ((ParseTreeNode *)((void *)0));
      }
#line 666
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 667
    if (s < ps) {
#line 667
      goto _L;
    } else
#line 667
    if (s == ps) {
#line 667
      if (e <= pe) {
        _L: /* CIL Label */ 
        {
#line 668
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 668
          real_parse_error(parser, (char *)"constant gc list must be sorted");
          }
#line 668
          return ((ParseTreeNode *)((void *)0));
#line 668
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
#line 669
    if (e <= pe) {
#line 672
      c_list->nested = 1;
    } else
#line 669
    if (s == ps) {
#line 672
      c_list->nested = 1;
    }
    {
#line 674
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 674
      check_add_region((RegionList const   *)c_list, s, e);
      }
      {
#line 674
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 674
        if (c_list->length == 1 << 7) {
          {
#line 674
          insert_list_node(c_list);
          }
        }
#line 674
        (c_list->last)->list[c_list->length].start = s;
#line 674
        (c_list->last)->list[c_list->length].end = e;
#line 674
        (c_list->length) ++;
#line 674
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 674
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 675
    ps = s;
#line 675
    pe = e;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 677
  ((parser->sgrep)->statistics.constant_lists) ++;
  {
#line 678
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 678
    parser->token = next_token(parser);
    }
#line 678
    if ((unsigned int )parser->token == 62U) {
#line 678
      return ((ParseTreeNode *)((void *)0));
    }
#line 678
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 679
  return (n);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_integer_function(Parser *parser , enum Oper oper , char const   *name ) 
{ 
  ParseTreeNode *n ;
  ParseTreeNode *tmp ;
  char buf[1000] ;
  char buf___0[100] ;

  {
  {
#line 686
  tmp = create_tree_node(parser, oper);
#line 686
  n = tmp;
  }
#line 687
  if (! n) {
#line 687
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 689
    parser->token = next_token(parser);
    }
#line 689
    if ((unsigned int )parser->token == 62U) {
#line 689
      return ((ParseTreeNode *)((void *)0));
    }
#line 689
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  if ((unsigned int )parser->token != 54U) {
    {
#line 691
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 691
      real_parse_error(parser, (char *)"( expected");
      }
#line 691
      return ((ParseTreeNode *)((void *)0));
#line 691
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 692
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 692
    parser->token = next_token(parser);
    }
#line 692
    if ((unsigned int )parser->token == 62U) {
#line 692
      return ((ParseTreeNode *)((void *)0));
    }
#line 692
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 693
  if ((unsigned int )parser->token != 60U) {
    {
#line 695
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"integer expected: %s(integer,expression)",
            name);
    }
    {
#line 696
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 696
      real_parse_error(parser, buf);
      }
#line 696
      return ((ParseTreeNode *)((void *)0));
#line 696
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 698
  n->number = atoi((char const   *)(parser->string_token)->s);
#line 699
  delete_string(parser->string_token);
#line 700
  parser->string_token = (SgrepString *)((void *)0);
  }
#line 701
  if (n->number < 0) {
    {
#line 702
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 702
      real_parse_error(parser, (char *)"Negative ints not implemented for last");
      }
#line 702
      return ((ParseTreeNode *)((void *)0));
#line 702
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 703
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 703
    parser->token = next_token(parser);
    }
#line 703
    if ((unsigned int )parser->token == 62U) {
#line 703
      return ((ParseTreeNode *)((void *)0));
    }
#line 703
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 704
  if ((unsigned int )parser->token != 58U) {
    {
#line 706
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"\',\' expected: %s(integer, expression)",
            name);
    }
    {
#line 707
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 707
      real_parse_error(parser, buf___0);
      }
#line 707
      return ((ParseTreeNode *)((void *)0));
#line 707
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 708
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 710
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 710
    parser->token = next_token(parser);
    }
#line 710
    if ((unsigned int )parser->token == 62U) {
#line 710
      return ((ParseTreeNode *)((void *)0));
    }
#line 710
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 711
  n->left = parse_reg_expr(parser);
  }
#line 712
  if ((unsigned long )n->left == (unsigned long )((void *)0)) {
#line 712
    return ((ParseTreeNode *)((void *)0));
  }
#line 713
  n->right = (struct ParseTreeNodeStruct *)((void *)0);
#line 714
  if ((unsigned int )parser->token != 55U) {
    {
#line 715
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 715
      real_parse_error(parser, (char *)") expected");
      }
#line 715
      return ((ParseTreeNode *)((void *)0));
#line 715
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 716
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 716
    parser->token = next_token(parser);
    }
#line 716
    if ((unsigned int )parser->token == 62U) {
#line 716
      return ((ParseTreeNode *)((void *)0));
    }
#line 716
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 717
  return (n);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_int_oper_argument(Parser *parser , enum Oper oper ) 
{ 
  ParseTreeNode *n ;
  ParseTreeNode *tmp ;

  {
  {
#line 722
  tmp = create_tree_node(parser, oper);
#line 722
  n = tmp;
  }
#line 723
  if (! n) {
#line 723
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 724
    parser->token = next_token(parser);
    }
#line 724
    if ((unsigned int )parser->token == 62U) {
#line 724
      return ((ParseTreeNode *)((void *)0));
    }
#line 724
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  if ((unsigned int )parser->token != 54U) {
    {
#line 726
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 726
      real_parse_error(parser, (char *)"Expecting \'(\' starting integer argument for operator");
      }
#line 726
      return ((ParseTreeNode *)((void *)0));
#line 726
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 727
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 729
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 729
    parser->token = next_token(parser);
    }
#line 729
    if ((unsigned int )parser->token == 62U) {
#line 729
      return ((ParseTreeNode *)((void *)0));
    }
#line 729
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 730
  if ((unsigned int )parser->token != 60U) {
    {
#line 731
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 731
      real_parse_error(parser, (char *)"Expecting integer argument for operator");
      }
#line 731
      return ((ParseTreeNode *)((void *)0));
#line 731
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 732
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 734
  n->number = atoi((char const   *)(parser->string_token)->s);
  }
#line 735
  if (n->number < 0) {
    {
#line 736
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 736
      real_parse_error(parser, (char *)"Expecting integer value >=0");
      }
#line 736
      return ((ParseTreeNode *)((void *)0));
#line 736
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 737
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 739
  delete_string(parser->string_token);
  }
  {
#line 740
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 740
    parser->token = next_token(parser);
    }
#line 740
    if ((unsigned int )parser->token == 62U) {
#line 740
      return ((ParseTreeNode *)((void *)0));
    }
#line 740
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 741
  if ((unsigned int )parser->token != 55U) {
    {
#line 742
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 742
      real_parse_error(parser, (char *)"\')\' expected");
      }
#line 742
      return ((ParseTreeNode *)((void *)0));
#line 742
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 744
  return (n);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_basic_expr(Parser *parser ) 
{ 
  ParseTreeNode *n ;
  ParseTreeNode *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ParseTreeNode *tmp___2 ;
  ParseTreeNode *tmp___3 ;
  ParseTreeNode *tmp___4 ;
  ParseTreeNode *tmp___5 ;
  ParseTreeNode *tmp___6 ;
  ParseTreeNode *tmp___7 ;
  ParseTreeNode *tmp___8 ;
  ParseTreeNode *tmp___9 ;
  ParseTreeNode *tmp___10 ;
  ParseTreeNode *tmp___11 ;
  ParseTreeNode *tmp___12 ;
  ParseTreeNode *tmp___13 ;
  ParseTreeNode *tmp___14 ;
  ParseTreeNode *tmp___15 ;
  ParseTreeNode *tmp___16 ;
  ParseTreeNode *tmp___17 ;
  ParseTreeNode *tmp___18 ;
  ParseTreeNode *tmp___19 ;
  ParseTreeNode *tmp___20 ;
  ParseTreeNode *tmp___21 ;
  ParseTreeNode *tmp___22 ;
  ParseTreeNode *tmp___23 ;
  ParseTreeNode *tmp___24 ;
  ParseTreeNode *tmp___25 ;
  ParseTreeNode *tmp___26 ;

  {
  {
#line 752
  if ((unsigned int )parser->token == 56U) {
#line 752
    goto case_56;
  }
#line 755
  if ((unsigned int )parser->token == 26U) {
#line 755
    goto case_26;
  }
#line 764
  if ((unsigned int )parser->token == 54U) {
#line 764
    goto case_54;
  }
#line 774
  if ((unsigned int )parser->token == 20U) {
#line 774
    goto case_20;
  }
#line 774
  if ((unsigned int )parser->token == 19U) {
#line 774
    goto case_20;
  }
#line 774
  if ((unsigned int )parser->token == 18U) {
#line 774
    goto case_20;
  }
#line 792
  if ((unsigned int )parser->token == 21U) {
#line 792
    goto case_21;
  }
#line 794
  if ((unsigned int )parser->token == 22U) {
#line 794
    goto case_22;
  }
#line 796
  if ((unsigned int )parser->token == 23U) {
#line 796
    goto case_23;
  }
#line 798
  if ((unsigned int )parser->token == 24U) {
#line 798
    goto case_24;
  }
#line 800
  if ((unsigned int )parser->token == 25U) {
#line 800
    goto case_25;
  }
#line 803
  if ((unsigned int )parser->token == 59U) {
#line 803
    goto case_59;
  }
#line 809
  if ((unsigned int )parser->token == 27U) {
#line 809
    goto case_27;
  }
#line 815
  if ((unsigned int )parser->token == 28U) {
#line 815
    goto case_28;
  }
#line 821
  if ((unsigned int )parser->token == 42U) {
#line 821
    goto case_42;
  }
#line 826
  if ((unsigned int )parser->token == 30U) {
#line 826
    goto case_30;
  }
#line 831
  if ((unsigned int )parser->token == 29U) {
#line 831
    goto case_29;
  }
#line 836
  if ((unsigned int )parser->token == 45U) {
#line 836
    goto case_45;
  }
#line 842
  if ((unsigned int )parser->token == 52U) {
#line 842
    goto case_52;
  }
#line 844
  if ((unsigned int )parser->token == 31U) {
#line 844
    goto case_31;
  }
#line 846
  if ((unsigned int )parser->token == 32U) {
#line 846
    goto case_32;
  }
#line 848
  if ((unsigned int )parser->token == 33U) {
#line 848
    goto case_33;
  }
#line 850
  if ((unsigned int )parser->token == 34U) {
#line 850
    goto case_34;
  }
#line 852
  if ((unsigned int )parser->token == 35U) {
#line 852
    goto case_35;
  }
#line 854
  if ((unsigned int )parser->token == 36U) {
#line 854
    goto case_36;
  }
#line 856
  if ((unsigned int )parser->token == 47U) {
#line 856
    goto case_47;
  }
#line 858
  if ((unsigned int )parser->token == 48U) {
#line 858
    goto case_48;
  }
#line 860
  if ((unsigned int )parser->token == 49U) {
#line 860
    goto case_49;
  }
#line 862
  if ((unsigned int )parser->token == 50U) {
#line 862
    goto case_50;
  }
#line 864
  if ((unsigned int )parser->token == 51U) {
#line 864
    goto case_51;
  }
#line 866
  if ((unsigned int )parser->token == 37U) {
#line 866
    goto case_37;
  }
#line 868
  if ((unsigned int )parser->token == 38U) {
#line 868
    goto case_38;
  }
#line 870
  if ((unsigned int )parser->token == 39U) {
#line 870
    goto case_39;
  }
#line 872
  if ((unsigned int )parser->token == 40U) {
#line 872
    goto case_40;
  }
#line 874
  if ((unsigned int )parser->token == 41U) {
#line 874
    goto case_41;
  }
#line 876
  if ((unsigned int )parser->token == 43U) {
#line 876
    goto case_43;
  }
#line 878
  if ((unsigned int )parser->token == 44U) {
#line 878
    goto case_44;
  }
#line 880
  if ((unsigned int )parser->token == 46U) {
#line 880
    goto case_46;
  }
#line 884
  goto switch_default;
  case_56: /* CIL Label */ 
  {
#line 754
  tmp = parse_cons_list(parser);
  }
#line 754
  return (tmp);
  case_26: /* CIL Label */ 
  {
#line 757
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 757
    real_parse_error(parser, (char *)"\'chars\' disabled until I figure out how to fix it (JJ)");
    }
#line 757
    return ((ParseTreeNode *)((void *)0));
#line 757
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 758
  n = create_leaf_node(parser, (enum Oper )28, (SgrepString *)((void *)0), 1);
  }
#line 759
  if (! n) {
#line 759
    return ((ParseTreeNode *)((void *)0));
  }
#line 761
  (n->leaf)->regions = (parser->sgrep)->chars_list;
  {
#line 762
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 762
    parser->token = next_token(parser);
    }
#line 762
    if ((unsigned int )parser->token == 62U) {
#line 762
      return ((ParseTreeNode *)((void *)0));
    }
#line 762
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 763
  return (n);
  case_54: /* CIL Label */ 
  {
#line 765
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 765
    parser->token = next_token(parser);
    }
#line 765
    if ((unsigned int )parser->token == 62U) {
#line 765
      return ((ParseTreeNode *)((void *)0));
    }
#line 765
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 766
  n = parse_reg_expr(parser);
  }
#line 767
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 767
    return ((ParseTreeNode *)((void *)0));
  }
#line 768
  if ((unsigned int )parser->token != 55U) {
    {
#line 769
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 769
      real_parse_error(parser, (char *)") expected");
      }
#line 769
      return ((ParseTreeNode *)((void *)0));
#line 769
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 770
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 770
    parser->token = next_token(parser);
    }
#line 770
    if ((unsigned int )parser->token == 62U) {
#line 770
      return ((ParseTreeNode *)((void *)0));
    }
#line 770
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 771
  return (n);
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 776
  if ((unsigned int )parser->token == 18U) {
#line 776
    tmp___1 = 20;
  } else {
#line 776
    if ((unsigned int )parser->token == 19U) {
#line 776
      tmp___0 = 21;
    } else {
#line 776
      tmp___0 = 22;
    }
#line 776
    tmp___1 = tmp___0;
  }
  {
#line 776
  n = create_tree_node(parser, (enum Oper )tmp___1);
  }
#line 779
  if (! n) {
#line 779
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 781
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 781
    parser->token = next_token(parser);
    }
#line 781
    if ((unsigned int )parser->token == 62U) {
#line 781
      return ((ParseTreeNode *)((void *)0));
    }
#line 781
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 782
  if ((unsigned int )parser->token != 54U) {
    {
#line 783
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 783
      real_parse_error(parser, (char *)"( expected");
      }
#line 783
      return ((ParseTreeNode *)((void *)0));
#line 783
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 784
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 784
    parser->token = next_token(parser);
    }
#line 784
    if ((unsigned int )parser->token == 62U) {
#line 784
      return ((ParseTreeNode *)((void *)0));
    }
#line 784
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 785
  n->left = parse_reg_expr(parser);
  }
#line 786
  if ((unsigned long )n->left == (unsigned long )((void *)0)) {
#line 786
    return ((ParseTreeNode *)((void *)0));
  }
#line 787
  n->right = (struct ParseTreeNodeStruct *)((void *)0);
#line 788
  if ((unsigned int )parser->token != 55U) {
    {
#line 789
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 789
      real_parse_error(parser, (char *)") expected");
      }
#line 789
      return ((ParseTreeNode *)((void *)0));
#line 789
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 790
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 790
    parser->token = next_token(parser);
    }
#line 790
    if ((unsigned int )parser->token == 62U) {
#line 790
      return ((ParseTreeNode *)((void *)0));
    }
#line 790
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 791
  return (n);
  case_21: /* CIL Label */ 
  {
#line 793
  tmp___2 = parse_integer_function(parser, (enum Oper )23, "join");
  }
#line 793
  return (tmp___2);
  case_22: /* CIL Label */ 
  {
#line 795
  tmp___3 = parse_integer_function(parser, (enum Oper )24, "first");
  }
#line 795
  return (tmp___3);
  case_23: /* CIL Label */ 
  {
#line 797
  tmp___4 = parse_integer_function(parser, (enum Oper )25, "last");
  }
#line 797
  return (tmp___4);
  case_24: /* CIL Label */ 
  {
#line 799
  tmp___5 = parse_integer_function(parser, (enum Oper )26, "firs_bytes");
  }
#line 799
  return (tmp___5);
  case_25: /* CIL Label */ 
  {
#line 801
  tmp___6 = parse_integer_function(parser, (enum Oper )27, "last_bytes");
  }
#line 801
  return (tmp___6);
  case_59: /* CIL Label */ 
  {
#line 805
  n = new_string_phrase(parser, parser->string_token, "n");
  }
#line 806
  if (! n) {
#line 806
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 807
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 807
    parser->token = next_token(parser);
    }
#line 807
    if ((unsigned int )parser->token == 62U) {
#line 807
      return ((ParseTreeNode *)((void *)0));
    }
#line 807
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 808
  return (n);
  case_27: /* CIL Label */ 
  {
#line 811
  n = new_string_phrase(parser, (SgrepString *)((void *)0), "#start");
  }
#line 812
  if (! n) {
#line 812
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 813
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 813
    parser->token = next_token(parser);
    }
#line 813
    if ((unsigned int )parser->token == 62U) {
#line 813
      return ((ParseTreeNode *)((void *)0));
    }
#line 813
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 814
  return (n);
  case_28: /* CIL Label */ 
  {
#line 817
  n = new_string_phrase(parser, (SgrepString *)((void *)0), "#end");
  }
#line 818
  if (! n) {
#line 818
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 819
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 819
    parser->token = next_token(parser);
    }
#line 819
    if ((unsigned int )parser->token == 62U) {
#line 819
      return ((ParseTreeNode *)((void *)0));
    }
#line 819
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 820
  return (n);
  case_42: /* CIL Label */ 
  {
#line 822
  n = new_string_phrase(parser, (SgrepString *)((void *)0), "-");
  }
#line 823
  if (! n) {
#line 823
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 824
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 824
    parser->token = next_token(parser);
    }
#line 824
    if ((unsigned int )parser->token == 62U) {
#line 824
      return ((ParseTreeNode *)((void *)0));
    }
#line 824
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 825
  return (n);
  case_30: /* CIL Label */ 
  {
#line 827
  n = new_string_phrase(parser, (SgrepString *)((void *)0), "@elements");
  }
#line 828
  if (! n) {
#line 828
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 829
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 829
    parser->token = next_token(parser);
    }
#line 829
    if ((unsigned int )parser->token == 62U) {
#line 829
      return ((ParseTreeNode *)((void *)0));
    }
#line 829
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 830
  return (n);
  case_29: /* CIL Label */ 
  {
#line 832
  n = new_string_phrase(parser, (SgrepString *)((void *)0), "d!");
  }
#line 833
  if (! n) {
#line 833
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 834
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 834
    parser->token = next_token(parser);
    }
#line 834
    if ((unsigned int )parser->token == 62U) {
#line 834
      return ((ParseTreeNode *)((void *)0));
    }
#line 834
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 835
  return (n);
  case_45: /* CIL Label */ 
  {
#line 837
  n = new_string_phrase(parser, (SgrepString *)((void *)0), "[CDATA");
  }
#line 838
  if (! n) {
#line 838
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 839
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 839
    parser->token = next_token(parser);
    }
#line 839
    if ((unsigned int )parser->token == 62U) {
#line 839
      return ((ParseTreeNode *)((void *)0));
    }
#line 839
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 840
  return (n);
  case_52: /* CIL Label */ 
  {
#line 843
  tmp___7 = parse_phrase(parser, "");
  }
#line 843
  return (tmp___7);
  case_31: /* CIL Label */ 
  {
#line 845
  tmp___8 = parse_phrase(parser, "f");
  }
#line 845
  return (tmp___8);
  case_32: /* CIL Label */ 
  {
#line 847
  tmp___9 = parse_phrase(parser, "n");
  }
#line 847
  return (tmp___9);
  case_33: /* CIL Label */ 
  {
#line 849
  tmp___10 = parse_phrase(parser, "r");
  }
#line 849
  return (tmp___10);
  case_34: /* CIL Label */ 
  {
#line 851
  tmp___11 = parse_phrase(parser, "dn");
  }
#line 851
  return (tmp___11);
  case_35: /* CIL Label */ 
  {
#line 853
  tmp___12 = parse_phrase(parser, "dp");
  }
#line 853
  return (tmp___12);
  case_36: /* CIL Label */ 
  {
#line 855
  tmp___13 = parse_phrase(parser, "ds");
  }
#line 855
  return (tmp___13);
  case_47: /* CIL Label */ 
  {
#line 857
  tmp___14 = parse_phrase(parser, "!ed");
  }
#line 857
  return (tmp___14);
  case_48: /* CIL Label */ 
  {
#line 859
  tmp___15 = parse_phrase(parser, "!el");
  }
#line 859
  return (tmp___15);
  case_49: /* CIL Label */ 
  {
#line 861
  tmp___16 = parse_phrase(parser, "!ep");
  }
#line 861
  return (tmp___16);
  case_50: /* CIL Label */ 
  {
#line 863
  tmp___17 = parse_phrase(parser, "!es");
  }
#line 863
  return (tmp___17);
  case_51: /* CIL Label */ 
  {
#line 865
  tmp___18 = parse_phrase(parser, "!en");
  }
#line 865
  return (tmp___18);
  case_37: /* CIL Label */ 
  {
#line 867
  tmp___19 = parse_phrase(parser, "?");
  }
#line 867
  return (tmp___19);
  case_38: /* CIL Label */ 
  {
#line 869
  tmp___20 = parse_phrase(parser, "a");
  }
#line 869
  return (tmp___20);
  case_39: /* CIL Label */ 
  {
#line 871
  tmp___21 = parse_phrase(parser, "v");
  }
#line 871
  return (tmp___21);
  case_40: /* CIL Label */ 
  {
#line 873
  tmp___22 = parse_phrase(parser, "s");
  }
#line 873
  return (tmp___22);
  case_41: /* CIL Label */ 
  {
#line 875
  tmp___23 = parse_phrase(parser, "e");
  }
#line 875
  return (tmp___23);
  case_43: /* CIL Label */ 
  {
#line 877
  tmp___24 = parse_phrase(parser, "c");
  }
#line 877
  return (tmp___24);
  case_44: /* CIL Label */ 
  {
#line 879
  tmp___25 = parse_phrase(parser, "w");
  }
#line 879
  return (tmp___25);
  case_46: /* CIL Label */ 
  {
#line 881
  tmp___26 = parse_phrase(parser, "&");
  }
#line 881
  return (tmp___26);
  switch_default: /* CIL Label */ 
  {
#line 885
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 885
    real_parse_error(parser, (char *)"Basic expression expected\n");
    }
#line 885
    return ((ParseTreeNode *)((void *)0));
#line 885
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 889
  return ((ParseTreeNode *)((void *)0));
}
}
#line 893 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_reg_expr(Parser *parser ) 
{ 
  ParseTreeNode *left ;
  ParseTreeNode *tmp ;

  {
#line 896
  if ((unsigned int )parser->token == 61U) {
    {
#line 897
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 897
      real_parse_error(parser, (char *)"Unexpected end of expression");
      }
#line 897
      return ((ParseTreeNode *)((void *)0));
#line 897
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 899
  left = parse_basic_expr(parser);
  }
#line 900
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 900
    return ((ParseTreeNode *)((void *)0));
  }
#line 901
  if ((unsigned int )parser->token == 61U) {
#line 901
    return (left);
  } else
#line 901
  if ((unsigned int )parser->token == 55U) {
#line 901
    return (left);
  }
  {
#line 902
  tmp = parse_oper_expr(parser, left);
  }
#line 902
  return (tmp);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_oper_expr(Parser *parser , ParseTreeNode *left ) 
{ 
  ParseTreeNode *o ;
  ParseTreeNode *tmp ;

  {
#line 908
  o = (ParseTreeNode *)((void *)0);
  {
#line 911
  if ((unsigned int )parser->token == 16U) {
#line 911
    goto case_16;
  }
#line 914
  if ((unsigned int )parser->token == 17U) {
#line 914
    goto case_17;
  }
#line 917
  if ((unsigned int )parser->token == 0U) {
#line 917
    goto case_0;
  }
#line 920
  if ((unsigned int )parser->token == 2U) {
#line 920
    goto case_2;
  }
#line 924
  if ((unsigned int )parser->token == 13U) {
#line 924
    goto case_13;
  }
#line 928
  if ((unsigned int )parser->token == 14U) {
#line 928
    goto case_14;
  }
#line 931
  if ((unsigned int )parser->token == 15U) {
#line 931
    goto case_15;
  }
#line 934
  if ((unsigned int )parser->token == 3U) {
#line 934
    goto case_3;
  }
#line 937
  if ((unsigned int )parser->token == 4U) {
#line 937
    goto case_4;
  }
#line 940
  if ((unsigned int )parser->token == 5U) {
#line 940
    goto case_5;
  }
#line 943
  if ((unsigned int )parser->token == 6U) {
#line 943
    goto case_6;
  }
#line 946
  if ((unsigned int )parser->token == 7U) {
#line 946
    goto case_7;
  }
#line 949
  if ((unsigned int )parser->token == 8U) {
#line 949
    goto case_8;
  }
#line 952
  if ((unsigned int )parser->token == 9U) {
#line 952
    goto case_9;
  }
#line 955
  if ((unsigned int )parser->token == 11U) {
#line 955
    goto case_11;
  }
#line 958
  if ((unsigned int )parser->token == 10U) {
#line 958
    goto case_10;
  }
#line 961
  if ((unsigned int )parser->token == 12U) {
#line 961
    goto case_12;
  }
#line 964
  if ((unsigned int )parser->token == 1U) {
#line 964
    goto case_1;
  }
#line 971
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 912
  o = parse_int_oper_argument(parser, (enum Oper )18);
  }
#line 913
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 915
  o = parse_int_oper_argument(parser, (enum Oper )19);
  }
#line 916
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 918
  o = create_tree_node(parser, (enum Oper )0);
  }
#line 919
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 921
  o = create_tree_node(parser, (enum Oper )2);
  }
#line 922
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 925
  o = create_tree_node(parser, (enum Oper )4);
  }
#line 926
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 929
  o = create_tree_node(parser, (enum Oper )16);
  }
#line 930
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 932
  o = create_tree_node(parser, (enum Oper )17);
  }
#line 933
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 935
  o = create_tree_node(parser, (enum Oper )15);
  }
#line 936
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 938
  o = create_tree_node(parser, (enum Oper )6);
  }
#line 939
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 941
  o = create_tree_node(parser, (enum Oper )7);
  }
#line 942
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 944
  o = create_tree_node(parser, (enum Oper )8);
  }
#line 945
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 947
  o = create_tree_node(parser, (enum Oper )9);
  }
#line 948
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 950
  o = create_tree_node(parser, (enum Oper )14);
  }
#line 951
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 953
  o = create_tree_node(parser, (enum Oper )10);
  }
#line 954
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 956
  o = create_tree_node(parser, (enum Oper )12);
  }
#line 957
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 959
  o = create_tree_node(parser, (enum Oper )11);
  }
#line 960
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 962
  o = create_tree_node(parser, (enum Oper )13);
  }
#line 963
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 965
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 965
    parser->token = next_token(parser);
    }
#line 965
    if ((unsigned int )parser->token == 62U) {
#line 965
      return ((ParseTreeNode *)((void *)0));
    }
#line 965
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 966
  if ((unsigned int )parser->token == 2U) {
    {
#line 966
    o = create_tree_node(parser, (enum Oper )3);
    }
  } else
#line 967
  if ((unsigned int )parser->token == 0U) {
    {
#line 967
    o = create_tree_node(parser, (enum Oper )1);
    }
  } else
#line 968
  if ((unsigned int )parser->token == 13U) {
    {
#line 968
    o = create_tree_node(parser, (enum Oper )5);
    }
  } else {
    {
#line 969
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 969
      real_parse_error(parser, (char *)"\'not\' must be followed by \'in\', \'containing\' or \'equal\'");
      }
#line 969
      return ((ParseTreeNode *)((void *)0));
#line 969
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 970
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 972
    real_parse_error(parser, (char *)"Operator expected");
    }
#line 972
    return ((ParseTreeNode *)((void *)0));
#line 972
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 974
  if (! o) {
#line 974
    return ((ParseTreeNode *)((void *)0));
  }
  {
#line 975
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 975
    parser->token = next_token(parser);
    }
#line 975
    if ((unsigned int )parser->token == 62U) {
#line 975
      return ((ParseTreeNode *)((void *)0));
    }
#line 975
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 976
  o->right = parse_basic_expr(parser);
  }
#line 977
  if ((unsigned long )o->right == (unsigned long )((void *)0)) {
#line 977
    return ((ParseTreeNode *)((void *)0));
  }
#line 978
  o->left = left;
#line 979
  if ((unsigned int )parser->token == 61U) {
#line 979
    return (o);
  } else
#line 979
  if ((unsigned int )parser->token == 55U) {
#line 979
    return (o);
  }
  {
#line 980
  tmp = parse_oper_expr(parser, o);
  }
#line 980
  return (tmp);
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
ParseTreeNode *parse_string(SgrepData *sgrep___0 , char const   *str , struct PHRASE_NODE **phrase_list ) 
{ 
  ParseTreeNode *root ;
  Parser parser_l ;
  Parser *parser ;
  ParseTreeLeaf *leaf ;

  {
  {
#line 994
  parser = & parser_l;
#line 996
  parser->sgrep = sgrep___0;
#line 997
  parser->line = 1;
#line 998
  parser->column = 0;
#line 999
  parser->file = new_string(sgrep___0, (size_t )8);
#line 1000
  parser->expr_str = str;
#line 1001
  parser->expr_ind = 0;
#line 1002
  parser->ch = -1;
#line 1003
  parser->first_phrase = (struct PHRASE_NODE *)((void *)0);
#line 1004
  parser->scanner_state = (enum ScannerState )0;
#line 1005
  parser->nodes = 0;
  }
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1007
    parser->token = next_token(parser);
    }
#line 1007
    if ((unsigned int )parser->token == 62U) {
#line 1007
      return ((ParseTreeNode *)((void *)0));
    }
#line 1007
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1008
  root = parse_reg_expr(parser);
  }
#line 1010
  if ((unsigned int )parser->token == 55U) {
#line 1010
    if ((unsigned long )root != (unsigned long )((void *)0)) {
      {
#line 1012
      real_parse_error(parser, (char *)"Too many \')\'s");
#line 1013
      root = (ParseTreeNode *)((void *)0);
      }
    }
  }
  {
#line 1015
  delete_string(parser->file);
  }
#line 1017
  if ((unsigned int )parser->token != 61U) {
#line 1019
    root = (ParseTreeNode *)((void *)0);
  }
#line 1021
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    {
#line 1023
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1023
      if (! parser->nodes) {
#line 1023
        goto while_break___0;
      }
#line 1026
      (parser->nodes) --;
#line 1027
      leaf = (parser->node_array[parser->nodes])->leaf;
#line 1028
      if (leaf) {
#line 1029
        if (leaf->phrase) {
          {
#line 1030
          delete_string(leaf->phrase);
          }
        }
        {
#line 1032
        sgrep_debug_free(sgrep___0, (void *)leaf);
        }
      }
      {
#line 1034
      sgrep_debug_free(sgrep___0, (void *)parser->node_array[parser->nodes]);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1043
  *phrase_list = parser->first_phrase;
#line 1044
  return (root);
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c"
void free_parse_tree(SgrepData *sgrep___0 , ParseTreeNode *root ) 
{ 


  {
#line 1049
  if ((unsigned int )root->oper != 29U) {
#line 1049
    if (! (root->refcount != 0)) {
      {
#line 1049
      __assert_fail("root->oper!=INVALID && root->refcount!=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                    1049U, "free_parse_tree");
      }
    }
  } else {
    {
#line 1049
    __assert_fail("root->oper!=INVALID && root->refcount!=0", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                  1049U, "free_parse_tree");
    }
  }
#line 1050
  if (root->refcount == -1) {
#line 1051
    if ((unsigned int )root->oper == 28U) {
#line 1051
      if (root->leaf) {
#line 1051
        if (! ((unsigned long )(root->leaf)->phrase == (unsigned long )((void *)0))) {
          {
#line 1051
          __assert_fail("root->oper==PHRASE && root->leaf && root->leaf->phrase==((void *)0)",
                        "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                        1051U, "free_parse_tree");
          }
        }
      } else {
        {
#line 1051
        __assert_fail("root->oper==PHRASE && root->leaf && root->leaf->phrase==((void *)0)",
                      "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                      1051U, "free_parse_tree");
        }
      }
    } else {
      {
#line 1051
      __assert_fail("root->oper==PHRASE && root->leaf && root->leaf->phrase==((void *)0)",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                    1051U, "free_parse_tree");
      }
    }
    {
#line 1052
    root->refcount = 0;
#line 1053
    sgrep_debug_free(sgrep___0, (void *)root->leaf);
#line 1054
    sgrep_debug_free(sgrep___0, (void *)root);
    }
  } else {
#line 1056
    (root->refcount) --;
#line 1057
    if (root->refcount == 0) {
#line 1058
      if (root->left) {
        {
#line 1058
        free_parse_tree(sgrep___0, root->left);
        }
      }
#line 1059
      if (root->right) {
        {
#line 1059
        free_parse_tree(sgrep___0, root->right);
        }
      }
#line 1060
      if ((unsigned int )root->oper == 28U) {
#line 1061
        if (! root->leaf) {
          {
#line 1061
          __assert_fail("root->leaf", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/parser.c",
                        1061U, "free_parse_tree");
          }
        }
        {
#line 1062
        delete_string((root->leaf)->phrase);
#line 1063
        sgrep_debug_free(sgrep___0, (void *)root->leaf);
#line 1064
        root->leaf = (ParseTreeLeaf *)((void *)0);
        }
      }
      {
#line 1066
      root->oper = (enum Oper )29;
#line 1067
      sgrep_debug_free(sgrep___0, (void *)root);
      }
    }
  }
#line 1070
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 623 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
void print_scanner_help(void) ;
#line 624
int set_scanner_option(SgrepData *sgrep___0 , char const   *a ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
struct index_opt_data index_options[16]  = 
#line 6 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
  {      {(char )'h', (char *)((void *)0), (char *)"help (means this text)"}, 
        {(char )'i', (char *)((void *)0), (char *)"fold all words to lower case when indexing"}, 
        {(char )'T',
      (char *)((void *)0), (char *)"show statistics about created index files"}, 
        {(char )'V', (char *)((void *)0), (char *)"display version information"}, 
        {(char )'v', (char *)((void *)0), (char *)"verbose mode. Shows what is going on"}, 
        {(char )'c',
      (char *)"<index file>", (char *)"create new index file"}, 
        {(char )'F', (char *)"<file>", (char *)"read list of input files from <file> instead of command line"}, 
        {(char )'g',
      (char *)"<option>", (char *)"set scanner option:"}, 
        {(char )'l', (char *)"<limit>", (char *)"make a list of possible stopwords"}, 
        {(char )'L',
      (char *)"<stop file>", (char *)"write possible stopwords to file"}, 
        {(char )'S', (char *)"<stop file>", (char *)"read stop word list from file"}, 
        {(char )'m',
      (char *)"<megabytes>", (char *)"main memory available for indexing in megabytes"}, 
        {(char )'w',
      (char *)"<char list>", (char *)"set the list of characters used to recognize words"}, 
        {(char )'x',
      (char *)"<index file>", (char *)"query existing index file"}, 
        {(char )'q', (char *)"<query>", (char *)"Only can query terms"}, 
        {(char)0, (char *)((void *)0), (char *)((void *)0)}};
#line 33 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
void index_usage(SgrepData *sgrep___0 ) 
{ 
  int i___0 ;

  {
  {
#line 35
  sgrep_error(sgrep___0, (char *)"Usage: (sgindex | sgrep -I) [ -");
#line 36
  i___0 = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int )index_options[i___0].opt != 0)) {
#line 36
      goto while_break;
    }
#line 37
    if ((unsigned long )index_options[i___0].have_param != (unsigned long )((void *)0)) {
      {
#line 39
      sgrep_error(sgrep___0, (char *)" -%c %s", (int )index_options[i___0].opt, index_options[i___0].have_param);
      }
    } else {
      {
#line 42
      sgrep_error(sgrep___0, (char *)"%c", (int )index_options[i___0].opt);
      }
    }
#line 36
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  sgrep_error(sgrep___0, (char *)" ] [<files...>]\n");
#line 45
  sgrep_error(sgrep___0, (char *)"sgindex -h for help\n");
  }
#line 46
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
void print_index_help(void) 
{ 
  int i___0 ;
  char *tmp ;

  {
  {
#line 55
  printf((char const   */* __restrict  */)"Usage: (sgindex | sgrep -I) <options> <files...>\n");
#line 56
  printf((char const   */* __restrict  */)"Use \'sgrep -h\' for help on query mode options.\n");
#line 57
  printf((char const   */* __restrict  */)"\nIndexing mode options are:\n");
#line 58
  i___0 = 0;
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((int )index_options[i___0].opt != 0)) {
#line 58
      goto while_break;
    }
#line 60
    if ((unsigned long )index_options[i___0].have_param == (unsigned long )((void *)0)) {
#line 60
      tmp = (char *)"";
    } else {
#line 60
      tmp = index_options[i___0].have_param;
    }
    {
#line 60
    printf((char const   */* __restrict  */)"  -%c %-13s%s\n", (int )index_options[i___0].opt,
           tmp, index_options[i___0].what_does);
    }
#line 66
    if ((int )index_options[i___0].opt == 103) {
      {
#line 67
      print_scanner_help();
      }
    }
#line 58
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  printf((char const   */* __restrict  */)"\t--\t\tno more options\n");
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
int parse_index_options(IndexOptions *o , char **argv ) 
{ 
  int i___0 ;
  int j ;
  SgrepData *sgrep___0 ;
  int tmp ;
  char *arg ;
  int tmp___0 ;
  char *endptr ;
  char *arg___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *endptr___0 ;
  char *arg___1 ;
  char *tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *arg___2 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *arg___3 ;

  {
#line 75
  sgrep___0 = o->sgrep;
#line 77
  i___0 = 0;
#line 78
  j = 1;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 81
      if (! ((int )*(*(argv + 0)) == 45)) {
#line 81
        goto while_break;
      }
    } else {
#line 81
      goto while_break;
    }
    {
#line 84
    tmp = strcmp(*argv, "--");
    }
#line 84
    if (tmp == 0) {
#line 84
      return (i___0 + 1);
    }
    {
#line 88
    if ((int )*(*argv + j) == 103) {
#line 88
      goto case_103;
    }
#line 97
    if ((int )*(*argv + j) == 104) {
#line 97
      goto case_104;
    }
#line 101
    if ((int )*(*argv + j) == 105) {
#line 101
      goto case_105;
    }
#line 104
    if ((int )*(*argv + j) == 108) {
#line 104
      goto case_108;
    }
#line 116
    if ((int )*(*argv + j) == 109) {
#line 116
      goto case_109;
    }
#line 128
    if ((int )*(*argv + j) == 76) {
#line 128
      goto case_76;
    }
#line 132
    if ((int )*(*argv + j) == 83) {
#line 132
      goto case_83;
    }
#line 136
    if ((int )*(*argv + j) == 86) {
#line 136
      goto case_86;
    }
#line 141
    if ((int )*(*argv + j) == 118) {
#line 141
      goto case_118;
    }
#line 144
    if ((int )*(*argv + j) == 84) {
#line 144
      goto case_84;
    }
#line 153
    if ((int )*(*argv + j) == 82) {
#line 153
      goto case_82;
    }
#line 157
    if ((int )*(*argv + j) == 99) {
#line 157
      goto case_99;
    }
#line 162
    if ((int )*(*argv + j) == 120) {
#line 162
      goto case_120;
    }
#line 166
    if ((int )*(*argv + j) == 113) {
#line 166
      goto case_113;
    }
#line 177
    if ((int )*(*argv + j) == 70) {
#line 177
      goto case_70;
    }
#line 187
    if ((int )*(*argv + j) == 119) {
#line 187
      goto case_119;
    }
#line 191
    goto switch_default;
    case_103: /* CIL Label */ 
    {
#line 90
    arg = get_arg(sgrep___0, & argv, & i___0, & j);
    }
#line 91
    if (! arg) {
#line 93
      return (-1);
    } else {
      {
#line 91
      tmp___0 = set_scanner_option(o->sgrep, (char const   *)arg);
      }
#line 91
      if (tmp___0 == -1) {
#line 93
        return (-1);
      }
    }
#line 95
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 98
    print_index_help();
#line 99
    o->index_mode = (enum IndexModes )3;
    }
#line 100
    goto switch_break;
    case_105: /* CIL Label */ 
#line 102
    (o->sgrep)->ignore_case = 1;
#line 103
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 106
    tmp___1 = get_arg(sgrep___0, & argv, & i___0, & j);
#line 106
    arg___0 = tmp___1;
    }
#line 107
    if (! arg___0) {
#line 107
      return (-1);
    }
    {
#line 108
    tmp___2 = strtol((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& endptr),
                     10);
#line 108
    o->stop_word_limit = (int )tmp___2;
    }
#line 109
    if (o->stop_word_limit < 0) {
      {
#line 110
      sgrep_error(sgrep___0, (char *)"Invalid stop word limit \'%s\'\n", arg___0);
      }
#line 112
      return (-1);
    } else
#line 109
    if ((int )*endptr != 0) {
      {
#line 110
      sgrep_error(sgrep___0, (char *)"Invalid stop word limit \'%s\'\n", arg___0);
      }
#line 112
      return (-1);
    }
#line 114
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 118
    tmp___3 = get_arg(sgrep___0, & argv, & i___0, & j);
#line 118
    arg___1 = tmp___3;
    }
#line 119
    if (! arg___1) {
#line 119
      return (-1);
    }
    {
#line 120
    tmp___4 = strtol((char const   */* __restrict  */)arg___1, (char **/* __restrict  */)(& endptr___0),
                     10);
#line 120
    o->available_memory = (int )((tmp___4 * 1024L) * 1024L);
    }
#line 121
    if (o->available_memory < 0) {
      {
#line 122
      sgrep_error(sgrep___0, (char *)"Invalid memory size \'%s\'\n", arg___1);
      }
#line 124
      return (-1);
    } else
#line 121
    if ((int )*endptr___0 != 0) {
      {
#line 122
      sgrep_error(sgrep___0, (char *)"Invalid memory size \'%s\'\n", arg___1);
      }
#line 124
      return (-1);
    }
#line 126
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 129
    tmp___5 = get_arg(sgrep___0, & argv, & i___0, & j);
#line 129
    o->output_stop_word_file = (char const   *)tmp___5;
    }
#line 130
    if (! o->output_stop_word_file) {
#line 130
      return (-1);
    }
#line 131
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 133
    tmp___6 = get_arg(sgrep___0, & argv, & i___0, & j);
#line 133
    o->input_stop_word_file = (char const   *)tmp___6;
    }
#line 134
    if (! o->input_stop_word_file) {
#line 134
      return (-1);
    }
#line 135
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 137
    printf((char const   */* __restrict  */)"sgindex version %s compiled at %s\n",
           "1.94a", "Mar 10 2016");
#line 139
    o->index_mode = (enum IndexModes )3;
    }
#line 140
    goto switch_break;
    case_118: /* CIL Label */ 
#line 142
    (o->sgrep)->progress_output = 1;
#line 143
    goto switch_break;
    case_84: /* CIL Label */ 
#line 145
    o->index_stats = 1;
#line 146
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 154
    (o->sgrep)->recurse_dirs = 1;
#line 155
    sgrep_error(sgrep___0, (char *)"WARNING -R not working (yet)\n");
    }
#line 156
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 158
    tmp___7 = get_arg(sgrep___0, & argv, & i___0, & j);
#line 158
    o->file_name = (char const   *)tmp___7;
    }
#line 159
    if ((unsigned long )o->file_name == (unsigned long )((void *)0)) {
#line 159
      return (-1);
    }
#line 160
    o->index_mode = (enum IndexModes )1;
#line 161
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 163
    (o->sgrep)->index_file = get_arg(sgrep___0, & argv, & i___0, & j);
    }
#line 164
    if ((unsigned long )(o->sgrep)->index_file == (unsigned long )((void *)0)) {
#line 164
      return (-1);
    }
#line 165
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 167
    tmp___8 = get_arg(sgrep___0, & argv, & i___0, & j);
#line 167
    arg___2 = (char const   *)tmp___8;
#line 168
    tmp___9 = strcmp(arg___2, "terms");
    }
#line 168
    if (tmp___9 == 0) {
#line 169
      o->index_mode = (enum IndexModes )2;
    } else {
      {
#line 171
      sgrep_error(sgrep___0, (char *)"Don\'t know how to query \'%s\'\n", arg___2);
      }
#line 173
      return (-1);
    }
#line 175
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 179
    arg___3 = get_arg(sgrep___0, & argv, & i___0, & j);
    }
#line 180
    if ((unsigned long )arg___3 == (unsigned long )((void *)0)) {
#line 180
      return (-1);
    }
#line 181
    if ((unsigned long )o->file_list_files == (unsigned long )((void *)0)) {
      {
#line 182
      o->file_list_files = new_flist(sgrep___0);
      }
    }
    {
#line 184
    flist_add(o->file_list_files, (char const   *)arg___3);
    }
#line 185
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 188
    (o->sgrep)->word_chars = get_arg(sgrep___0, & argv, & i___0, & j);
    }
#line 189
    if (! (o->sgrep)->word_chars) {
#line 189
      return (-1);
    }
#line 190
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 192
    sgrep_error(sgrep___0, (char *)"Illegal option -%c\n", (int )*(*argv + j));
    }
#line 193
    return (-1);
#line 194
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 196
    j ++;
#line 196
    if ((int )*(*argv + j) == 0) {
#line 198
      argv ++;
#line 199
      i___0 ++;
#line 200
      j = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return (i___0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/index_main.c"
int index_main(SgrepData *sgrep___0 , int argc , char **argv ) 
{ 
  int end_options ;
  IndexOptions options ;
  FileList *file_list ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 209
  file_list = (FileList *)((void *)0);
#line 211
  set_default_index_options(sgrep___0, & options);
#line 215
  end_options = parse_index_options(& options, argv);
  }
#line 217
  if (end_options == -1) {
    {
#line 219
    index_usage(sgrep___0);
    }
#line 220
    goto error;
  }
  {
#line 224
  if ((unsigned int )options.index_mode == 1U) {
#line 224
    goto case_1;
  }
#line 240
  if ((unsigned int )options.index_mode == 2U) {
#line 240
    goto case_2;
  }
#line 248
  if ((unsigned int )options.index_mode == 3U) {
#line 248
    goto case_3;
  }
#line 251
  goto switch_default;
  case_1: /* CIL Label */ 
#line 225
  if (argc == end_options) {
#line 225
    if ((unsigned long )options.file_list_files == (unsigned long )((void *)0)) {
      {
#line 226
      sgrep_error(sgrep___0, (char *)"Can\'t read input from stdin when indexing.\n");
#line 227
      sgrep_error(sgrep___0, (char *)" Use filename \'-\' to force indexing from stdin.\n");
      }
#line 228
      goto error;
    }
  }
#line 230
  if (argc > end_options) {
    {
#line 231
    file_list = check_files(sgrep___0, argc - end_options, argv + end_options, 0,
                            (char **)((void *)0));
    }
  }
  {
#line 234
  options.file_list = file_list;
#line 235
  tmp = create_index((IndexOptions const   *)(& options));
  }
#line 235
  if (tmp == -1) {
#line 236
    goto error;
  }
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 241
  tmp___0 = index_query(& options, argc - end_options, argv + end_options);
  }
#line 241
  if (tmp___0 == -1) {
#line 243
    return (2);
  } else {
#line 245
    return (0);
  }
  case_3: /* CIL Label */ 
#line 249
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 252
  sgrep_error(sgrep___0, (char *)"sgindex: You have to give one of -c, -C -h\n");
#line 253
  index_usage(sgrep___0);
  }
#line 254
  goto error;
  switch_break: /* CIL Label */ ;
  }
#line 256
  if (file_list) {
    {
#line 256
    delete_flist(file_list);
    }
  }
#line 257
  if (options.file_list_files) {
    {
#line 257
    delete_flist(options.file_list_files);
    }
  }
#line 258
  return (0);
  error: 
#line 261
  if (file_list) {
    {
#line 261
    delete_flist(file_list);
    }
  }
#line 262
  if (options.file_list_files) {
    {
#line 262
    delete_flist(options.file_list_files);
    }
  }
#line 263
  return (2);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/sgrep.h"
int search(SgrepData *sgrep___0 , struct PHRASE_NODE *phrase_list , FileList *files ,
           int f_file , int l_file ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ACScanner AC_scanner  ;
#line 80
void new_output(SgrepData *sgrep___0 , struct ACState *s , struct PHRASE_NODE *pn ) ;
#line 82
void ACsearch(struct ACScanner *scanner , unsigned char const   *buf , int len , int start ) ;
#line 84
void enter(SgrepData *sgrep___0 , struct PHRASE_NODE *pn , struct ACState *root_state ,
           int ignore_case ) ;
#line 86
void create_fail(SgrepData *sgrep___0 , struct ACState *root_state ) ;
#line 87
void create_goto(SgrepData *sgrep___0 , struct PHRASE_NODE *phrase_list , struct ACState *root_state ,
                 int ignore_case ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void print_scanner_help(void) 
{ 


  {
  {
#line 100
  printf((char const   */* __restrict  */)"      %-12s%s\n", "sgml", "use SGML scanner");
#line 101
  printf((char const   */* __restrict  */)"      %-12s%s\n", "html", "use HTML scanner (currently same as sgml scanner)");
#line 102
  printf((char const   */* __restrict  */)"      %-12s%s\n", "xml", "use XML scanner");
#line 103
  printf((char const   */* __restrict  */)"      %-12s%s\n", "sgml-debug", "show recognized SGML tokens");
#line 104
  printf((char const   */* __restrict  */)"      %-12s%s\n", "include-entities", "  automatically include system entities");
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
int set_scanner_option(SgrepData *sgrep___0 , char const   *a ) 
{ 
  int i___0 ;
  char *arg ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 109
  tmp = sgrep_debug_strdup(sgrep___0, a, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                           109);
#line 109
  arg = tmp;
#line 110
  i___0 = 0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! *(arg + i___0)) {
#line 110
      goto while_break;
    }
    {
#line 110
    tmp___0 = tolower((int )*(arg + i___0));
#line 110
    *(arg + i___0) = (char )tmp___0;
#line 110
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  tmp___8 = strcmp((char const   *)arg, "sgml");
  }
#line 112
  if (tmp___8 == 0) {
#line 114
    sgrep___0->scanner_type = (ScannerType )0;
  } else {
    {
#line 112
    tmp___9 = strcmp((char const   *)arg, "html");
    }
#line 112
    if (tmp___9 == 0) {
#line 114
      sgrep___0->scanner_type = (ScannerType )0;
    } else {
      {
#line 115
      tmp___7 = strcmp((char const   *)arg, "xml");
      }
#line 115
      if (tmp___7 == 0) {
#line 116
        sgrep___0->scanner_type = (ScannerType )1;
      } else {
        {
#line 117
        tmp___6 = strcmp((char const   *)arg, "text");
        }
#line 117
        if (tmp___6 == 0) {
#line 118
          sgrep___0->scanner_type = (ScannerType )2;
        } else {
          {
#line 119
          tmp___5 = strcmp((char const   *)arg, "sgml-debug");
          }
#line 119
          if (tmp___5 == 0) {
#line 120
            sgrep___0->sgml_debug = 1;
          } else {
            {
#line 121
            tmp___4 = strcmp((char const   *)arg, "include-entities");
            }
#line 121
            if (tmp___4 == 0) {
#line 122
              sgrep___0->include_system_entities = 1;
            } else {
              {
#line 123
              tmp___3 = strcmp((char const   *)arg, "encoding=iso-8859-1");
              }
#line 123
              if (tmp___3 == 0) {
#line 124
                sgrep___0->default_encoding = (enum Encoding )1;
              } else {
                {
#line 125
                tmp___2 = strcmp((char const   *)arg, "encoding=utf8");
                }
#line 125
                if (tmp___2 == 0) {
#line 126
                  sgrep___0->default_encoding = (enum Encoding )2;
                } else {
                  {
#line 127
                  tmp___1 = strcmp((char const   *)arg, "encoding=utf16");
                  }
#line 127
                  if (tmp___1 == 0) {
#line 128
                    sgrep___0->default_encoding = (enum Encoding )3;
                  } else {
                    {
#line 130
                    sgrep_error(sgrep___0, (char *)"Unknown scanner argument \'%s\'\n",
                                arg);
#line 131
                    sgrep_debug_free(sgrep___0, (void *)arg);
                    }
#line 132
                    return (-1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 134
  sgrep_debug_free(sgrep___0, (void *)arg);
  }
#line 135
  return (0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ScanBuffer *new_scan_buffer(SgrepData *sgrep___0 , FileList *files ) 
{ 
  struct ScanBuffer *sc ;
  void *tmp ;

  {
  {
#line 144
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(struct ScanBuffer ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                           144);
#line 144
  sc = (struct ScanBuffer *)tmp;
#line 145
  sc->sgrep = sgrep___0;
#line 146
  sc->file_list = files;
#line 147
  sc->len = 0;
#line 148
  sc->file_num = 0;
#line 149
  sc->old_file_num = -1;
#line 150
  sc->last_file = -1;
#line 151
  sc->region_start = 0;
#line 152
  sc->map = (unsigned char const   *)((void *)0);
#line 153
  sc->map_size = 0;
  }
#line 154
  return (sc);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ScanBuffer *reset_scan_buffer(struct ScanBuffer *sc , int f_file , int l_file ) 
{ 


  {
  {
#line 159
  sc->file_num = f_file;
#line 160
  sc->last_file = l_file;
#line 161
  sc->region_start = flist_start((FileList const   *)sc->file_list, f_file);
  }
#line 162
  return (sc);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void delete_scan_buffer(struct ScanBuffer *b ) 
{ 
  SgrepData *sgrep___0 ;

  {
  {
#line 167
  sgrep___0 = b->sgrep;
#line 168
  sgrep_debug_free(sgrep___0, (void *)b);
  }
#line 169
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
int next_scan_buffer(struct ScanBuffer *sb ) 
{ 
  SgrepData *sgrep___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *map ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 179
  sgrep___0 = sb->sgrep;
#line 180
  if (sb->map) {
#line 180
    if (sb->len == sb->map_size) {
#line 181
      (sb->file_num) ++;
    }
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    tmp = flist_files((FileList const   *)sb->file_list);
    }
#line 184
    if (sb->file_num < tmp) {
      {
#line 184
      tmp___0 = flist_length((FileList const   *)sb->file_list, sb->file_num);
      }
#line 184
      if (! (tmp___0 == 0)) {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
#line 186
    (sb->file_num) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (sb->old_file_num != sb->file_num) {
#line 188
    if (sb->map) {
      {
#line 189
      unmap_file(sgrep___0, (void *)sb->map, (size_t )sb->map_size);
#line 190
      sb->map = (unsigned char const   *)((void *)0);
#line 191
      sb->map_size = 0;
      }
    }
  }
#line 193
  if (sb->last_file == -1) {
    {
#line 193
    tmp___1 = flist_files((FileList const   *)sb->file_list);
    }
#line 193
    if (sb->file_num >= tmp___1) {
#line 196
      return (0);
    } else {
#line 193
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 193
  if (sb->last_file >= 0) {
#line 193
    if (sb->file_num > sb->last_file) {
#line 196
      return (0);
    }
  }
#line 198
  if (! sb->map) {
    {
#line 200
    tmp___2 = flist_name((FileList const   *)sb->file_list, sb->file_num);
#line 200
    tmp___3 = map_file(sgrep___0, tmp___2, & map);
#line 200
    sb->map_size = (int )tmp___3;
#line 202
    sb->map = (unsigned char const   *)map;
    }
  }
#line 204
  if ((unsigned long )sb->map == (unsigned long )((void *)0)) {
    {
#line 205
    tmp___4 = flist_name((FileList const   *)sb->file_list, sb->file_num);
#line 205
    sgrep_error(sgrep___0, (char *)"Failed to scan file \'%s\'\n", tmp___4);
    }
#line 207
    return (-1);
  }
  {
#line 209
  sb->old_file_num = sb->file_num;
#line 210
  tmp___6 = flist_length((FileList const   *)sb->file_list, sb->file_num);
  }
#line 210
  if (sb->map_size != tmp___6) {
    {
#line 211
    tmp___5 = flist_name((FileList const   *)sb->file_list, sb->file_num);
#line 211
    sgrep_error(sgrep___0, (char *)"Size of file \'%s\' has changed\n", tmp___5);
    }
  }
#line 214
  sb->region_start += sb->len;
#line 215
  sb->len = sb->map_size;
#line 216
  return (sb->len);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ACState *new_state(SgrepData *sgrep___0 ) 
{ 
  int i___0 ;
  struct ACState *s ;
  void *tmp ;

  {
  {
#line 232
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(struct ACState ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                           232);
#line 232
  s = (struct ACState *)tmp;
#line 233
  i___0 = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! (i___0 < 256)) {
#line 233
      goto while_break;
    }
#line 233
    s->gotos[i___0] = (struct ACState *)((void *)0);
#line 233
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  s->output_list = (struct OutputList *)((void *)0);
#line 235
  s->next = (struct ACState *)((void *)0);
#line 236
  s->fail = (struct ACState *)((void *)0);
#line 241
  return (s);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void new_output(SgrepData *sgrep___0 , struct ACState *s , struct PHRASE_NODE *pn ) 
{ 
  struct OutputList **op ;
  void *tmp ;

  {
#line 251
  op = & s->output_list;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! ((unsigned long )*op != (unsigned long )((void *)0))) {
#line 252
      goto while_break;
    }
#line 252
    op = & (*op)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(struct OutputList ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                           253);
#line 253
  *op = (struct OutputList *)tmp;
#line 254
  (*op)->next = (struct OutputList *)((void *)0);
#line 255
  (*op)->phrase = pn;
  }
#line 256
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void enter(SgrepData *sgrep___0 , struct PHRASE_NODE *pn , struct ACState *root_state ,
           int ignore_case ) 
{ 
  struct ACState *state ;
  size_t j ;
  unsigned char pch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 265
  state = root_state;
#line 272
  if (! ((int )*((pn->phrase)->s + 0) == 110)) {
    {
#line 272
    __assert_fail("pn->phrase->s[0]==\'n\'", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                  272U, "enter");
    }
  }
#line 273
  j = (size_t )1;
#line 274
  pch = (unsigned char )*((pn->phrase)->s + j);
#line 275
  if (ignore_case) {
    {
#line 275
    tmp = toupper((int )pch);
#line 275
    pch = (unsigned char )tmp;
    }
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if ((unsigned long )state->gotos[pch] != (unsigned long )((void *)0)) {
#line 276
      if (! (j < (pn->phrase)->length)) {
#line 276
        goto while_break;
      }
    } else {
#line 276
      goto while_break;
    }
#line 278
    state = state->gotos[pch];
#line 279
    j ++;
#line 280
    pch = (unsigned char )*((pn->phrase)->s + j);
#line 281
    if (ignore_case) {
      {
#line 281
      tmp___0 = toupper((int )pch);
#line 281
      pch = (unsigned char )tmp___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 284
    if (! (j < (pn->phrase)->length)) {
#line 284
      goto while_break___0;
    }
    {
#line 286
    state->gotos[pch] = new_state(sgrep___0);
#line 287
    state = state->gotos[pch];
#line 288
    j ++;
#line 289
    pch = (unsigned char )*((pn->phrase)->s + j);
    }
#line 290
    if (ignore_case) {
      {
#line 290
      tmp___1 = toupper((int )pch);
#line 290
      pch = (unsigned char )tmp___1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 292
  new_output(sgrep___0, state, pn);
  }
#line 296
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void create_goto(SgrepData *sgrep___0 , struct PHRASE_NODE *phrase_list , struct ACState *root_state ,
                 int ignore_case ) 
{ 
  struct PHRASE_NODE *pn ;

  {
#line 309
  pn = phrase_list;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! ((unsigned long )pn != (unsigned long )((void *)0))) {
#line 309
      goto while_break;
    }
#line 310
    if ((int )*((pn->phrase)->s + 0) == 110) {
      {
#line 315
      enter(sgrep___0, pn, root_state, ignore_case);
      }
    }
#line 309
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return;
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void create_fail(SgrepData *sgrep___0 , struct ACState *root_state ) 
{ 
  int i___0 ;
  struct ACState *s ;
  struct ACState *r ;
  struct ACState *state ;
  struct ACState *first___0 ;
  struct ACState *last___0 ;
  struct OutputList *op ;

  {
#line 328
  first___0 = (struct ACState *)((void *)0);
#line 329
  last___0 = (struct ACState *)((void *)0);
#line 335
  i___0 = 0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i___0 < 256)) {
#line 335
      goto while_break;
    }
#line 337
    s = root_state->gotos[i___0];
#line 337
    if ((unsigned long )s != (unsigned long )root_state) {
#line 339
      if ((unsigned long )first___0 == (unsigned long )((void *)0)) {
#line 339
        first___0 = s;
      }
#line 340
      if ((unsigned long )last___0 != (unsigned long )((void *)0)) {
#line 340
        last___0->next = s;
      }
#line 341
      last___0 = s;
#line 342
      last___0->next = (struct ACState *)((void *)0);
#line 343
      s->fail = root_state;
    }
#line 335
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! ((unsigned long )first___0 != (unsigned long )((void *)0))) {
#line 349
      goto while_break___0;
    }
#line 351
    r = first___0;
#line 352
    first___0 = first___0->next;
#line 353
    i___0 = 0;
    {
#line 353
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 353
      if (! (i___0 < 256)) {
#line 353
        goto while_break___1;
      }
#line 353
      if ((unsigned long )r->gotos[i___0] != (unsigned long )((void *)0)) {
#line 355
        s = r->gotos[i___0];
#line 356
        last___0->next = s;
#line 357
        last___0 = s;
#line 358
        last___0->next = (struct ACState *)((void *)0);
#line 359
        if ((unsigned long )first___0 == (unsigned long )((void *)0)) {
#line 359
          first___0 = last___0;
        }
#line 360
        state = r->fail;
        {
#line 361
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 361
          if (! ((unsigned long )state->gotos[i___0] == (unsigned long )((void *)0))) {
#line 361
            goto while_break___2;
          }
#line 361
          state = state->fail;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 362
        s->fail = state->gotos[i___0];
#line 363
        op = (s->fail)->output_list;
        {
#line 363
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 363
          if (! ((unsigned long )op != (unsigned long )((void *)0))) {
#line 363
            goto while_break___3;
          }
#line 366
          if (! ((unsigned long )op->phrase != (unsigned long )((void *)0))) {
            {
#line 366
            __assert_fail("op->phrase!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                          366U, "create_fail");
            }
          }
          {
#line 367
          new_output(sgrep___0, s, op->phrase);
#line 363
          op = op->next;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 353
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 374
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
struct ACScanner *init_AC_search(SgrepData *sgrep___0 , struct PHRASE_NODE *phrase_list ) 
{ 
  int i___0 ;
  struct ACScanner *sc ;
  void *tmp ;

  {
  {
#line 385
  tmp = sgrep_debug_malloc(sgrep___0, sizeof(struct ACScanner ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                           385);
#line 385
  sc = (struct ACScanner *)tmp;
#line 386
  sc->sgrep = sgrep___0;
#line 387
  sc->root_state = new_state(sgrep___0);
#line 388
  sc->phrase_list = phrase_list;
#line 389
  sc->s = sc->root_state;
#line 390
  sc->ignore_case = sgrep___0->ignore_case;
#line 391
  create_goto(sgrep___0, phrase_list, sc->root_state, sc->ignore_case);
#line 393
  i___0 = 0;
  }
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i___0 < 256)) {
#line 393
      goto while_break;
    }
#line 394
    if ((unsigned long )(sc->root_state)->gotos[i___0] == (unsigned long )((void *)0)) {
#line 395
      (sc->root_state)->gotos[i___0] = sc->root_state;
    }
#line 393
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  create_fail(sgrep___0, sc->root_state);
  }
#line 398
  return (sc);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void delete_AC_state(SgrepData *sgrep___0 , struct ACState *as ) 
{ 
  int i___0 ;
  struct OutputList *ol ;

  {
#line 403
  i___0 = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i___0 < 256)) {
#line 403
      goto while_break;
    }
#line 404
    if (as->gotos[i___0]) {
#line 404
      if ((unsigned long )as->gotos[i___0] != (unsigned long )as) {
        {
#line 405
        delete_AC_state(sgrep___0, as->gotos[i___0]);
        }
      }
    }
    {
#line 407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 407
      if (! as->output_list) {
#line 407
        goto while_break___0;
      }
      {
#line 408
      ol = as->output_list;
#line 409
      as->output_list = (as->output_list)->next;
#line 410
      sgrep_debug_free(sgrep___0, (void *)ol);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 403
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  sgrep_debug_free(sgrep___0, (void *)as);
  }
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void delete_AC_scanner(struct ACScanner *ac ) 
{ 
  SgrepData *sgrep___0 ;

  {
  {
#line 418
  sgrep___0 = ac->sgrep;
#line 419
  delete_AC_state(sgrep___0, ac->root_state);
#line 420
  sgrep_debug_free(sgrep___0, (void *)ac);
  }
#line 421
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
void ACsearch(struct ACScanner *scanner , unsigned char const   *buf , int len , int start ) 
{ 
  struct OutputList *op ;
  int ch ;
  int i___0 ;
  struct ACState *s ;
  int tmp ;

  {
#line 439
  s = scanner->s;
#line 440
  i___0 = 0;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (i___0 < len)) {
#line 440
      goto while_break;
    }
#line 441
    if (scanner->ignore_case) {
      {
#line 441
      tmp = toupper((int )*(buf + i___0));
#line 441
      ch = tmp;
      }
    } else {
#line 441
      ch = (int )*(buf + i___0);
    }
    {
#line 442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 442
      if (! ((unsigned long )s->gotos[ch] == (unsigned long )((void *)0))) {
#line 442
        goto while_break___0;
      }
#line 443
      if (! s->fail) {
        {
#line 443
        __assert_fail("s->fail", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                      443U, "ACsearch");
        }
      }
#line 444
      s = s->fail;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 446
    s = s->gotos[ch];
#line 447
    op = s->output_list;
    {
#line 448
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 448
      if (! ((unsigned long )op != (unsigned long )((void *)0))) {
#line 448
        goto while_break___1;
      }
#line 449
      ((scanner->sgrep)->statistics.phrases) ++;
#line 450
      if (! ((unsigned long )(op->phrase)->regions != (unsigned long )((void *)0))) {
        {
#line 450
        __assert_fail("op->phrase->regions!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                      450U, "ACsearch");
        }
      }
      {
#line 451
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 451
        check_add_region((RegionList const   *)(op->phrase)->regions, (int )((((size_t )i___0 - (((op->phrase)->phrase)->length - 1UL)) + (size_t )start) + 1UL),
                         i___0 + start);
        }
        {
#line 451
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 451
          if (((op->phrase)->regions)->length == 1 << 7) {
            {
#line 451
            insert_list_node((op->phrase)->regions);
            }
          }
#line 451
          (((op->phrase)->regions)->last)->list[((op->phrase)->regions)->length].start = (int )((((size_t )i___0 - (((op->phrase)->phrase)->length - 1UL)) + (size_t )start) + 1UL);
#line 451
          (((op->phrase)->regions)->last)->list[((op->phrase)->regions)->length].end = i___0 + start;
#line 451
          (((op->phrase)->regions)->length) ++;
#line 451
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 451
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 461
      op = op->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 462
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 462
      if (! ((unsigned long )op != (unsigned long )((void *)0))) {
#line 462
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 440
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  scanner->s = s;
#line 465
  return;
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
int search(SgrepData *sgrep___0 , struct PHRASE_NODE *phrase_list , FileList *files ,
           int f_file , int l_file ) 
{ 
  int sgml_phrases ;
  int regex_phrases ;
  int ac_phrases ;
  int file_phrases ;
  int e ;
  int previous_file ;
  struct ScanBuffer *sb ;
  struct ACScanner *acs ;
  SGMLScanner *sgmls ;
  struct PHRASE_NODE *j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int start ;
  int tmp___8 ;
  int last___0 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int f ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
#line 474
  e = 0;
#line 475
  previous_file = -1;
#line 478
  if ((unsigned long )phrase_list == (unsigned long )((void *)0)) {
    {
#line 479
    sgrep_progress(sgrep___0, (char *)"No phrases. Skipping search\n");
    }
#line 480
    return (0);
  }
#line 482
  if ((unsigned long )sgrep___0->index_file == (unsigned long )((void *)0)) {
#line 483
    sb = (struct ScanBuffer *)((void *)0);
#line 484
    acs = (struct ACScanner *)((void *)0);
#line 485
    sgmls = (SGMLScanner *)((void *)0);
#line 486
    j = (struct PHRASE_NODE *)((void *)0);
#line 488
    regex_phrases = 0;
#line 488
    sgml_phrases = regex_phrases;
#line 488
    ac_phrases = sgml_phrases;
#line 488
    file_phrases = ac_phrases;
#line 491
    j = phrase_list;
    {
#line 491
    while (1) {
      while_continue: /* CIL Label */ ;
#line 491
      if (! ((unsigned long )j != (unsigned long )((void *)0))) {
#line 491
        goto while_break;
      }
#line 493
      if (! ((unsigned long )j->regions == (unsigned long )((void *)0))) {
        {
#line 493
        __assert_fail("j->regions==((void *)0)", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c",
                      493U, "search");
        }
      }
      {
#line 494
      j->regions = new_region_list(sgrep___0);
      }
#line 495
      if ((int )*((j->phrase)->s + 0) == 64) {
        {
#line 497
        list_set_sorted(j->regions, (enum RegionListSorted )0);
#line 498
        (j->regions)->nested = 1;
        }
      } else
#line 495
      if ((int )*((j->phrase)->s + 0) == 42) {
        {
#line 497
        list_set_sorted(j->regions, (enum RegionListSorted )0);
#line 498
        (j->regions)->nested = 1;
        }
      }
      {
#line 502
      if ((int )*((j->phrase)->s + 0) == 110) {
#line 502
        goto case_110;
      }
#line 505
      if ((int )*((j->phrase)->s + 0) == 114) {
#line 505
        goto case_114;
      }
#line 508
      if ((int )*((j->phrase)->s + 0) == 102) {
#line 508
        goto case_102;
      }
#line 511
      if ((int )*((j->phrase)->s + 0) == 35) {
#line 511
        goto case_35;
      }
#line 514
      goto switch_default;
      case_110: /* CIL Label */ 
#line 503
      ac_phrases ++;
#line 504
      goto switch_break;
      case_114: /* CIL Label */ 
#line 506
      regex_phrases ++;
#line 507
      goto switch_break;
      case_102: /* CIL Label */ 
#line 509
      file_phrases ++;
#line 510
      goto switch_break;
      case_35: /* CIL Label */ 
#line 513
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 515
      sgml_phrases ++;
      switch_break: /* CIL Label */ ;
      }
#line 491
      j = j->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 520
    sb = new_scan_buffer(sgrep___0, files);
#line 521
    reset_scan_buffer(sb, f_file, l_file);
    }
#line 522
    if (ac_phrases) {
      {
#line 523
      acs = init_AC_search(sgrep___0, phrase_list);
      }
    }
#line 525
    if (sgml_phrases) {
      {
#line 526
      sgmls = new_sgml_phrase_scanner(sgrep___0, files, phrase_list);
      }
    }
#line 530
    if (acs) {
#line 530
      goto _L;
    } else
#line 530
    if (sgmls) {
      _L: /* CIL Label */ 
      {
#line 530
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 530
        e = next_scan_buffer(sb);
        }
#line 530
        if (! (e > 0)) {
#line 530
          goto while_break___0;
        }
        {
#line 531
        tmp___5 = flist_files((FileList const   *)files);
        }
#line 531
        if (tmp___5 > 1) {
          {
#line 532
          tmp = flist_total((FileList const   *)files);
#line 532
          tmp___0 = flist_total((FileList const   *)files);
#line 532
          tmp___1 = flist_files((FileList const   *)files);
#line 532
          sgrep_progress(sgrep___0, (char *)"Scanning %d/%d files %d/%dK (%d%%)\n",
                         sb->file_num, tmp___1, sb->region_start / 1024, tmp___0 / 1024,
                         sb->region_start / (tmp / 100 + 1));
          }
        } else {
          {
#line 537
          tmp___2 = flist_total((FileList const   *)files);
#line 537
          tmp___3 = flist_total((FileList const   *)files);
#line 537
          tmp___4 = flist_name((FileList const   *)sb->file_list, sb->file_num);
#line 537
          sgrep_progress(sgrep___0, (char *)"Scanning file \'%s\' %d/%dK (%d%%)\n",
                         tmp___4, sb->region_start / 1024, tmp___3 / 1024, sb->region_start / (tmp___2 / 100 + 1));
          }
        }
#line 542
        if (sgrep___0->progress_callback) {
          {
#line 543
          tmp___6 = flist_total((FileList const   *)files);
#line 543
          tmp___7 = flist_files((FileList const   *)files);
#line 543
          (*(sgrep___0->progress_callback))(sgrep___0->progress_data, sb->file_num,
                                            tmp___7, sb->region_start, tmp___6);
          }
        }
#line 547
        if (ac_phrases) {
          {
#line 548
          ACsearch(acs, sb->map, sb->len, sb->region_start);
          }
        }
#line 550
        if (sgml_phrases) {
#line 551
          if (previous_file != -1) {
#line 551
            if (sb->file_num != previous_file) {
              {
#line 552
              sgml_flush(sgmls);
              }
            }
          }
          {
#line 554
          previous_file = sb->file_num;
#line 555
          sgml_scan(sgmls, sb->map, sb->len, sb->region_start, sb->file_num);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 566
    delete_scan_buffer(sb);
    }
#line 567
    if (sgmls) {
      {
#line 568
      sgml_flush(sgmls);
#line 569
      delete_sgml_scanner(sgmls);
      }
    }
#line 571
    if (acs) {
      {
#line 571
      delete_AC_scanner(acs);
      }
    }
#line 576
    j = phrase_list;
    {
#line 576
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 576
      if (! ((unsigned long )j != (unsigned long )((void *)0))) {
#line 576
        goto while_break___1;
      }
      {
#line 580
      if ((int )*((j->phrase)->s + 0) == 35) {
#line 580
        goto case_35___0;
      }
#line 594
      if ((int )*((j->phrase)->s + 0) == 102) {
#line 594
        goto case_102___0;
      }
#line 578
      goto switch_break___0;
      case_35___0: /* CIL Label */ 
      {
#line 581
      tmp___12 = strcmp((char const   *)(j->phrase)->s, "#start");
      }
#line 581
      if (tmp___12 == 0) {
        {
#line 582
        tmp___8 = flist_start((FileList const   *)files, f_file);
#line 582
        start = tmp___8;
        }
        {
#line 583
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 583
          check_add_region((RegionList const   *)j->regions, start, start);
          }
          {
#line 583
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 583
            if ((j->regions)->length == 1 << 7) {
              {
#line 583
              insert_list_node(j->regions);
              }
            }
#line 583
            ((j->regions)->last)->list[(j->regions)->length].start = start;
#line 583
            ((j->regions)->last)->list[(j->regions)->length].end = start;
#line 583
            ((j->regions)->length) ++;
#line 583
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 583
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 584
        tmp___11 = strcmp((char const   *)(j->phrase)->s, "#end");
        }
#line 584
        if (tmp___11 == 0) {
          {
#line 585
          tmp___9 = flist_start((FileList const   *)files, l_file);
#line 585
          tmp___10 = flist_length((FileList const   *)files, l_file);
#line 585
          last___0 = (tmp___9 + tmp___10) - 1;
          }
          {
#line 587
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 587
            check_add_region((RegionList const   *)j->regions, last___0, last___0);
            }
            {
#line 587
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 587
              if ((j->regions)->length == 1 << 7) {
                {
#line 587
                insert_list_node(j->regions);
                }
              }
#line 587
              ((j->regions)->last)->list[(j->regions)->length].start = last___0;
#line 587
              ((j->regions)->last)->list[(j->regions)->length].end = last___0;
#line 587
              ((j->regions)->length) ++;
#line 587
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 587
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 589
          sgrep_error(sgrep___0, (char *)"Don\'t know how to handle phrase %s\n",
                      (j->phrase)->s);
          }
        }
      }
#line 592
      goto switch_break___0;
      case_102___0: /* CIL Label */ 
#line 596
      f = f_file;
      {
#line 596
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 596
        if (! (f <= l_file)) {
#line 596
          goto while_break___6;
        }
#line 598
        if ((int )*((j->phrase)->s + ((j->phrase)->length - 1UL)) == 42) {
          {
#line 600
          tmp___18 = flist_name((FileList const   *)files, f);
#line 600
          tmp___19 = strncmp((char const   *)((j->phrase)->s + 1), tmp___18, (j->phrase)->length - 2UL);
          }
#line 600
          if (tmp___19 == 0) {
            {
#line 600
            tmp___20 = flist_length((FileList const   *)files, f);
            }
#line 600
            if (tmp___20 > 0) {
              {
#line 603
              while (1) {
                while_continue___7: /* CIL Label */ ;
                {
#line 603
                tmp___13 = flist_start((FileList const   *)files, f);
#line 603
                tmp___14 = flist_length((FileList const   *)files, f);
#line 603
                tmp___15 = flist_start((FileList const   *)files, f);
#line 603
                check_add_region((RegionList const   *)j->regions, tmp___15, (tmp___13 + tmp___14) - 1);
                }
                {
#line 603
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 603
                  if ((j->regions)->length == 1 << 7) {
                    {
#line 603
                    insert_list_node(j->regions);
                    }
                  }
                  {
#line 603
                  ((j->regions)->last)->list[(j->regions)->length].start = flist_start((FileList const   *)files,
                                                                                       f);
#line 603
                  tmp___16 = flist_start((FileList const   *)files, f);
#line 603
                  tmp___17 = flist_length((FileList const   *)files, f);
#line 603
                  ((j->regions)->last)->list[(j->regions)->length].end = (tmp___16 + tmp___17) - 1;
#line 603
                  ((j->regions)->length) ++;
                  }
#line 603
                  goto while_break___8;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 603
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
            }
          }
        } else {
          {
#line 608
          tmp___26 = flist_name((FileList const   *)files, f);
#line 608
          tmp___27 = strcmp((char const   *)((j->phrase)->s + 1), tmp___26);
          }
#line 608
          if (tmp___27 == 0) {
            {
#line 608
            tmp___28 = flist_length((FileList const   *)files, f);
            }
#line 608
            if (tmp___28 > 0) {
              {
#line 611
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 611
                tmp___21 = flist_start((FileList const   *)files, f);
#line 611
                tmp___22 = flist_length((FileList const   *)files, f);
#line 611
                tmp___23 = flist_start((FileList const   *)files, f);
#line 611
                check_add_region((RegionList const   *)j->regions, tmp___23, (tmp___21 + tmp___22) - 1);
                }
                {
#line 611
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 611
                  if ((j->regions)->length == 1 << 7) {
                    {
#line 611
                    insert_list_node(j->regions);
                    }
                  }
                  {
#line 611
                  ((j->regions)->last)->list[(j->regions)->length].start = flist_start((FileList const   *)files,
                                                                                       f);
#line 611
                  tmp___24 = flist_start((FileList const   *)files, f);
#line 611
                  tmp___25 = flist_length((FileList const   *)files, f);
#line 611
                  ((j->regions)->last)->list[(j->regions)->length].end = (tmp___24 + tmp___25) - 1;
#line 611
                  ((j->regions)->length) ++;
                  }
#line 611
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 611
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
          }
        }
#line 596
        f ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 618
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 576
      j = j->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 622
    sgrep_progress(sgrep___0, (char *)"Using lazy index file mode\n");
#line 623
    e = 0;
    }
  }
#line 625
  if (e == -1) {
#line 625
    tmp___29 = -1;
  } else {
#line 625
    tmp___29 = 0;
  }
#line 625
  return (tmp___29);
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/pmatch.c"
int index_search(SgrepData *sgrep___0 , struct IndexWriterStruct *writer , FileList *files ) 
{ 
  struct ScanBuffer *sb ;
  int previous_file ;
  SGMLScanner *sgmls ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 632
  previous_file = -1;
#line 635
  sb = new_scan_buffer(sgrep___0, files);
#line 636
  sgmls = new_sgml_index_scanner(sgrep___0, files, writer);
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 637
    tmp___6 = next_scan_buffer(sb);
    }
#line 637
    if (! (tmp___6 > 0)) {
#line 637
      goto while_break;
    }
#line 638
    if (previous_file != -1) {
#line 638
      if (sb->file_num != previous_file) {
        {
#line 639
        sgml_flush(sgmls);
        }
      }
    }
    {
#line 641
    previous_file = sb->file_num;
#line 642
    tmp = flist_total((FileList const   *)files);
#line 642
    tmp___0 = flist_total((FileList const   *)files);
#line 642
    tmp___1 = flist_name((FileList const   *)files, sb->file_num);
#line 642
    tmp___2 = flist_files((FileList const   *)files);
#line 642
    sgrep_progress(sgrep___0, (char *)"Indexing file %d/%d \'%s\' %d/%dK (%d%%)\n",
                   sb->file_num + 1, tmp___2, tmp___1, sb->region_start / 1024, tmp___0 / 1024,
                   sb->region_start / (tmp / 100 + 1));
    }
#line 647
    if (sgrep___0->progress_callback) {
      {
#line 648
      tmp___3 = flist_total((FileList const   *)files);
#line 648
      tmp___4 = flist_files((FileList const   *)files);
#line 648
      (*(sgrep___0->progress_callback))(sgrep___0->progress_data, sb->file_num, tmp___4,
                                        sb->region_start, tmp___3);
      }
    }
    {
#line 652
    tmp___5 = sgml_scan(sgmls, sb->map, sb->len, sb->region_start, sb->file_num);
    }
#line 652
    if (tmp___5 == -1) {
      {
#line 654
      delete_scan_buffer(sb);
#line 655
      delete_sgml_scanner(sgmls);
      }
#line 656
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 659
  sgml_flush(sgmls);
#line 660
  delete_scan_buffer(sb);
#line 661
  delete_sgml_scanner(sgmls);
  }
#line 662
  return (0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void show_stats(void) ;
#line 41
void show_times(void) ;
#line 42
int get_options(char **argv ) ;
#line 44
SgrepString *read_expressions(SgrepData *sgrep___0 , struct Expression *expression_list ) ;
#line 46
int environ_options(void) ;
#line 47
int run_stream(FileList *files , ParseTreeNode *root , struct PHRASE_NODE *p_list ) ;
#line 48
int run_one_by_one(FileList *files , ParseTreeNode *root , struct PHRASE_NODE *p_list ) ;
#line 50
void create_constant_lists(void) ;
#line 51
void delete_constant_lists(void) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
SgrepData *sgrep  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int have_stats  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int have_times  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int display_count  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int no_output  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int show_expr  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
char *preprocessor  =    (char *)"m4 -s";
#line 68 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int read_sgreprc  =    1;
#line 69 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
char *option_space  =    (char *)((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
struct Expression *last_expression  =    (struct Expression *)((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int num_file_list_files  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
char *file_list_files[64]  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
struct time_points tps  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
struct OptionData  const  option_data[28]  = 
#line 108
  {      {(char )'a', (char *)((void *)0), (char *)"act as a filter"}, 
        {(char )'c', (char *)((void *)0), (char *)"display only count of matching regions"}, 
        {(char )'D',
      (char *)((void *)0), (char *)"obsolete synonym for -v"}, 
        {(char )'d', (char *)((void *)0), (char *)"don\'t do concat on result list"}, 
        {(char )'h',
      (char *)((void *)0), (char *)"help (means this text)"}, 
        {(char )'i', (char *)((void *)0), (char *)"ignore case distinctions in phrases"}, 
        {(char )'I',
      (char *)((void *)0), (char *)"switches to indexing mode, when given as first option"}, 
        {(char )'l',
      (char *)((void *)0), (char *)"long output format"}, 
        {(char )'N', (char *)((void *)0), (char *)"don\'t add trailing newline"}, 
        {(char )'n', (char *)((void *)0), (char *)"don\'t read $HOME/.sgreprc or /usr/local/etc/sgreprc"}, 
        {(char )'P',
      (char *)((void *)0), (char *)"show preprocessed expression, don\'t execute it."}, 
        {(char )'q',
      (char *)((void *)0), (char *)"supress normal output"}, 
        {(char )'S', (char *)((void *)0), (char *)"stream mode (regions extend across files)"}, 
        {(char )'s',
      (char *)((void *)0), (char *)"short output format"}, 
        {(char )'T', (char *)((void *)0), (char *)"show statistics about what was done"}, 
        {(char )'t',
      (char *)((void *)0), (char *)"show information about time spent"}, 
        {(char )'V', (char *)((void *)0), (char *)"display version information"}, 
        {(char )'v', (char *)((void *)0), (char *)"verbose mode. Shows what is going on"}, 
        {(char )'e',
      (char *)"<expression>", (char *)"execute expression (after preprocessing)"}, 
        {(char )'f',
      (char *)"<file>", (char *)"read expression from file"}, 
        {(char )'F', (char *)"<file>", (char *)"read list of input files from <file> instead of command line"}, 
        {(char )'g',
      (char *)"<option>", (char *)"set scanner option:"}, 
        {(char )'O', (char *)"<file>", (char *)"reads output style from file"}, 
        {(char )'o', (char *)"<style>", (char *)"set output style. See man page for details"}, 
        {(char )'p',
      (char *)"<program>", (char *)"preprocess expression using external preprocessor"}, 
        {(char )'w',
      (char *)"<char list>", (char *)"set the list of characters used to recognize words"}, 
        {(char )'x',
      (char *)"<index file>", (char *)"use given index file instead of scanner. Implies -S"}, 
        {(char)0,
      (char *)((void *)0), (char *)((void *)0)}};
#line 148 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int main(int argc , char **argv ) 
{ 
  ParseTreeNode *root ;
  struct PHRASE_NODE *p_list ;
  FileList *input_files ;
  int end_options ;
  struct SgrepStruct sgrep_main_instance ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct OptionData  const  *o ;
  int tmp___2 ;
  struct Expression *e ;
  void *tmp___3 ;
  SgrepString *expression ;
  char buf[32768] ;
  int tmp___4 ;

  {
  {
#line 152
  input_files = (FileList *)((void *)0);
#line 157
  memset((void *)(& sgrep_main_instance), 0, sizeof(sgrep_main_instance));
#line 158
  sgrep = & sgrep_main_instance;
#line 159
  sgrep->do_concat = 1;
#line 160
  sgrep->error_stream = stderr;
#line 162
  sgrep->output_style = (char *)"%r";
#line 163
  sgrep->open_failure = 0;
#line 164
  sgrep->print_newline = 1;
#line 165
  sgrep->stdin_temp_file = (TempFile *)((void *)0);
#line 166
  sgrep->print_all = 0;
#line 167
  sgrep->chars_list = (RegionList *)((void *)0);
#line 168
  sgrep->stream_mode = 0;
#line 170
  sgrep->progress_stream = stderr;
#line 171
  sgrep->scanner_type = (ScannerType )0;
  }
#line 174
  if (argc > 0) {
    {
#line 174
    tmp___0 = strcmp((char const   *)*(argv + 0), "sgindex");
    }
#line 174
    if (tmp___0 == 0) {
#line 174
      goto _L;
    } else {
#line 174
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 174
  if (argc > 1) {
    {
#line 174
    tmp___1 = strcmp((char const   *)*(argv + 1), "-I");
    }
#line 174
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
      {
#line 177
      tmp = strcmp((char const   *)*(argv + 0), "sgindex");
      }
#line 177
      if (tmp == 0) {
        {
#line 178
        r = index_main(sgrep, argc - 1, argv + 1);
        }
      } else {
        {
#line 180
        r = index_main(sgrep, argc - 2, argv + 2);
        }
      }
      {
#line 182
      check_memory_leaks(sgrep);
      }
#line 183
      return (r);
    }
  }
  {
#line 187
  times(& tps.start);
#line 192
  end_options = -1;
#line 193
  tmp___2 = environ_options();
  }
#line 193
  if (tmp___2 == -1) {
#line 193
    goto _L___1;
  } else {
    {
#line 193
    end_options = get_options(argv + 1);
    }
#line 193
    if (end_options == -1) {
#line 193
      goto _L___1;
    } else
#line 193
    if ((unsigned long )last_expression == (unsigned long )((void *)0)) {
#line 193
      if (end_options >= argc) {
        _L___1: /* CIL Label */ 
#line 198
        o = option_data;
#line 200
        if ((unsigned long )last_expression == (unsigned long )((void *)0)) {
#line 200
          if (end_options == argc) {
            {
#line 201
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You have to give an expression line if you don\'t use -f or -e switch.\n");
            }
          }
        }
        {
#line 204
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: sgrep [ -");
        }
        {
#line 205
        while (1) {
          while_continue: /* CIL Label */ ;
#line 205
          if (! ((int const   )o->opt != 0)) {
#line 205
            goto while_break;
          }
#line 206
          if ((unsigned long )o->have_param != (unsigned long )((void *)0)) {
            {
#line 207
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -%c %s",
                    (int const   )o->opt, o->have_param);
            }
          } else {
            {
#line 209
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c",
                    (int const   )o->opt);
            }
          }
#line 210
          o ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 212
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ] \'expr\' [<files...>]\n");
#line 213
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sgrep -h for help\n");
#line 214
        exit(2);
        }
      }
    }
  }
#line 220
  if ((unsigned long )last_expression == (unsigned long )((void *)0)) {
#line 222
    if (! (end_options < argc)) {
      {
#line 222
      __assert_fail("end_options<argc", "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                    222U, "main");
      }
    }
    {
#line 223
    tmp___3 = sgrep_debug_malloc(sgrep, sizeof(struct Expression ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                                 223);
#line 223
    e = (struct Expression *)tmp___3;
#line 224
    e->type = (enum ExpressionType )1;
#line 225
    e->expr = sgrep_debug_strdup(sgrep, (char const   *)*(argv + end_options), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                                 225);
#line 226
    e->next = last_expression;
#line 227
    last_expression = e;
#line 228
    end_options ++;
    }
  }
  {
#line 234
  create_constant_lists();
#line 242
  expression = read_expressions(sgrep, last_expression);
  }
#line 244
  if (! expression) {
    {
#line 245
    exit(2);
    }
  }
  {
#line 251
  tmp___4 = preprocess(sgrep, expression->s, buf, preprocessor, (int )sizeof(buf));
  }
#line 251
  if (tmp___4 == -1) {
    {
#line 253
    exit(2);
    }
  }
  {
#line 257
  delete_string(expression);
  }
#line 263
  if (show_expr) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
            buf);
#line 265
    exit(0);
    }
  }
  {
#line 271
  root = parse_and_optimize(sgrep, (char const   *)(buf), & p_list);
  }
#line 271
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    {
#line 272
    sgrep_error(sgrep, (char *)"No query to evaluate. Bailing out.\n");
#line 273
    exit(2);
    }
  }
  {
#line 279
  times(& tps.parsing);
  }
#line 283
  if (sgrep->index_reader) {
    {
#line 284
    input_files = index_file_list(sgrep->index_reader);
    }
  }
#line 287
  if (sgrep->index_reader) {
#line 287
    if (input_files) {
#line 287
      if (end_options < argc) {
        {
#line 290
        sgrep_error(sgrep, (char *)"Warning: -F options and command line file list ignored when using index (-x).\n");
        }
      } else
#line 287
      if (num_file_list_files) {
        {
#line 290
        sgrep_error(sgrep, (char *)"Warning: -F options and command line file list ignored when using index (-x).\n");
        }
      }
    }
  }
#line 294
  if (! input_files) {
    {
#line 299
    input_files = check_files(sgrep, argc - end_options, argv + end_options, num_file_list_files,
                              file_list_files);
    }
  }
#line 310
  if (sgrep->stream_mode) {
    {
#line 311
    run_stream(input_files, root, p_list);
    }
  } else {
    {
#line 313
    run_one_by_one(input_files, root, p_list);
    }
  }
  {
#line 315
  free_parse_tree(sgrep, root);
#line 316
  delete_constant_lists();
  }
#line 321
  if (have_stats) {
    {
#line 321
    show_stats();
    }
  }
#line 326
  if (have_times) {
    {
#line 326
    show_times();
    }
  }
  {
#line 329
  delete_flist(input_files);
  }
#line 330
  if (sgrep->index_reader) {
    {
#line 331
    delete_index_reader(sgrep->index_reader);
    }
  }
#line 333
  if (sgrep->stdin_temp_file) {
    {
#line 334
    delete_temp_file(sgrep->stdin_temp_file);
    }
  }
#line 336
  if (sgrep->statistics.region_lists_now > 0) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d region lists still allocated\n",
            sgrep->statistics.region_lists_now);
    }
  }
#line 340
  if (option_space) {
    {
#line 340
    sgrep_debug_free(sgrep, (void *)option_space);
    }
  }
  {
#line 342
  check_memory_leaks(sgrep);
  }
#line 343
  if (sgrep->statistics.output == 0) {
#line 344
    return (1);
  }
#line 347
  return (0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
static struct tms t_last  ;
#line 367 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void CALC_TIME(struct tms *TIME ) 
{ 
  struct tms t_now ;

  {
  {
#line 370
  times(& t_now);
#line 371
  TIME->tms_utime += t_now.tms_utime - t_last.tms_utime;
#line 372
  TIME->tms_stime += t_now.tms_stime - t_last.tms_stime;
#line 373
  t_last = t_now;
  }
#line 374
  return;
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int run_one_by_one(FileList *files , ParseTreeNode *root , struct PHRASE_NODE *p_list ) 
{ 
  RegionList *result ;
  int i___0 ;
  int save_print_newline ;
  struct tms t_pmatch ;
  struct tms t_eval ;
  struct tms t_output ;
  int tmp ;
  int tmp___0 ;

  {
#line 390
  t_last = tps.parsing;
#line 391
  t_pmatch.tms_utime = (clock_t )0;
#line 392
  t_pmatch.tms_stime = (clock_t )0;
#line 393
  t_eval = t_pmatch;
#line 394
  t_output = t_pmatch;
#line 400
  save_print_newline = sgrep->print_newline;
#line 401
  sgrep->print_newline = 0;
#line 403
  i___0 = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 403
    tmp___0 = flist_files((FileList const   *)files);
    }
#line 403
    if (! (i___0 < tmp___0)) {
#line 403
      goto while_break;
    }
    {
#line 408
    root->result = (RegionList *)((void *)0);
#line 411
    (sgrep->chars_list)->length = flist_length((FileList const   *)files, i___0);
#line 413
    search(sgrep, p_list, files, i___0, i___0);
#line 414
    CALC_TIME(& t_pmatch);
#line 416
    result = eval(sgrep, (FileList const   *)files, root);
#line 417
    sgrep->statistics.output += (result->nodes - 1) * (1 << 7) + result->length;
#line 418
    CALC_TIME(& t_eval);
#line 421
    tmp = flist_files((FileList const   *)files);
    }
#line 421
    if (i___0 == tmp - 1) {
#line 422
      sgrep->print_newline = save_print_newline;
    }
#line 424
    if (! display_count) {
#line 424
      if (! no_output) {
#line 424
        if ((result->nodes - 1) * (1 << 7) + result->length > 0) {
          {
#line 427
          write_region_list(sgrep, stdout, result, files);
          }
        } else
#line 424
        if (sgrep->print_all) {
          {
#line 427
          write_region_list(sgrep, stdout, result, files);
          }
        }
      }
    }
#line 432
    if (sgrep->statistics.region_lists_now == sgrep->statistics.constant_lists + 1) {
      {
#line 434
      delete_region_list(result);
      }
    }
    {
#line 436
    CALC_TIME(& t_output);
    }
#line 441
    if (! (sgrep->statistics.region_lists_now == sgrep->statistics.constant_lists)) {
      {
#line 441
      __assert_fail("(sgrep->statistics).region_lists_now==(sgrep->statistics).constant_lists",
                    "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                    441U, "run_one_by_one");
      }
    }
#line 403
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (display_count) {
#line 443
    if (! no_output) {
      {
#line 445
      printf((char const   */* __restrict  */)"%d\n", sgrep->statistics.output);
      }
    }
  }
  {
#line 447
  fflush(stdout);
#line 450
  tps.acsearch = tps.parsing;
#line 451
  tps.acsearch.tms_utime += t_pmatch.tms_utime;
#line 452
  tps.acsearch.tms_stime += t_pmatch.tms_stime;
#line 453
  tps.eval = tps.acsearch;
#line 454
  tps.eval.tms_utime += t_eval.tms_utime;
#line 455
  tps.eval.tms_stime += t_eval.tms_stime;
#line 456
  tps.output = tps.eval;
#line 457
  tps.output.tms_utime += t_output.tms_utime;
#line 458
  tps.output.tms_stime += t_output.tms_stime;
  }
#line 461
  return (0);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int run_stream(FileList *files , ParseTreeNode *root , struct PHRASE_NODE *p_list ) 
{ 
  RegionList *result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 476
  tmp = flist_files((FileList const   *)files);
#line 476
  tmp___0 = search(sgrep, p_list, files, 0, tmp - 1);
  }
#line 476
  if (tmp___0 == -1) {
#line 477
    return (-1);
  }
  {
#line 479
  times(& tps.acsearch);
#line 485
  result = eval(sgrep, (FileList const   *)files, root);
  }
#line 486
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 486
    return (-1);
  }
#line 488
  if (sgrep->statistics.region_lists_now > sgrep->statistics.constant_lists + 1) {
    {
#line 489
    sgrep_error(sgrep, (char *)"Query leaked %d gc lists\n", (sgrep->statistics.region_lists_now - sgrep->statistics.constant_lists) + 1);
    }
  }
  {
#line 492
  times(& tps.eval);
#line 500
  sgrep->statistics.output = (result->nodes - 1) * (1 << 7) + result->length;
  }
#line 502
  if (display_count) {
    {
#line 504
    printf((char const   */* __restrict  */)"%d\n", (result->nodes - 1) * (1 << 7) + result->length);
    }
  }
#line 508
  if (! display_count) {
#line 508
    if (! no_output) {
#line 508
      if (sgrep->statistics.output > 0) {
        {
#line 510
        write_region_list(sgrep, stdout, result, files);
        }
      } else
#line 508
      if (sgrep->print_all) {
        {
#line 510
        write_region_list(sgrep, stdout, result, files);
        }
      }
    }
  }
  {
#line 511
  delete_region_list(result);
#line 512
  fflush(stdout);
#line 513
  times(& tps.output);
  }
#line 514
  return (0);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void print_help(void) 
{ 
  struct OptionData  const  *o ;
  char const   *tmp ;

  {
  {
#line 524
  printf((char const   */* __restrict  */)"Usage: sgrep <options> \'region expression\' [<files...>]\n");
#line 525
  printf((char const   */* __restrict  */)"If no files are given stdin is used instead.\n");
#line 526
  printf((char const   */* __restrict  */)"Use \'sgrep -I -h\' or \'sgindex -h\' for help on indexing mode options.\n");
#line 527
  printf((char const   */* __restrict  */)"\noptions are:\n");
#line 529
  o = option_data;
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! ((int const   )o->opt != 0)) {
#line 529
      goto while_break;
    }
#line 531
    if ((unsigned long )o->have_param == (unsigned long )((void *)0)) {
#line 531
      tmp = (char const   */* const  */)"";
    } else {
#line 531
      tmp = (char const   */* const  */)o->have_param;
    }
    {
#line 531
    printf((char const   */* __restrict  */)"  -%c %-12s %s\n", (int const   )o->opt,
           tmp, o->what_does);
    }
#line 537
    if ((int const   )o->opt == 103) {
      {
#line 538
      print_scanner_help();
      }
    }
#line 529
    o ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  printf((char const   */* __restrict  */)"  -- %-12s no more options\n", "");
#line 542
  printf((char const   */* __restrict  */)"Options can also be specified with SGREPOPT environment variable\n");
#line 543
  exit(0);
  }
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void create_constant_lists(void) 
{ 


  {
  {
#line 555
  sgrep->chars_list = new_region_list(sgrep);
#line 556
  to_chars(sgrep->chars_list, 1, 1);
#line 558
  (sgrep->statistics.constant_lists) ++;
  }
#line 559
  return;
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void delete_constant_lists(void) 
{ 


  {
  {
#line 562
  delete_region_list(sgrep->chars_list);
#line 563
  sgrep->chars_list = (RegionList *)((void *)0);
#line 564
  (sgrep->statistics.constant_lists) --;
  }
#line 565
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int read_expression_file(SgrepString *str , char const   *fname ) 
{ 
  FILE *stream ;
  char buf[1024] ;
  int bytes ;
  SgrepData *sgrep___0 ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 574
  sgrep___0 = str->sgrep;
#line 577
  if (str->length > 0UL) {
#line 577
    if ((int )*(str->s + (str->length - 1UL)) != 10) {
      {
#line 578
      string_cat(str, "\n");
      }
    }
  }
#line 581
  if ((int const   )*(fname + 0) == 45) {
#line 581
    if ((int const   )*(fname + 1) == 0) {
      {
#line 583
      stream = stdin;
#line 584
      string_cat(str, "#line 1 \"-\"\n");
      }
    } else {
#line 581
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 586
    stream = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 587
    if ((unsigned long )stream == (unsigned long )((void *)0)) {
      {
#line 588
      tmp = __errno_location();
#line 588
      tmp___0 = strerror(*tmp);
#line 588
      sgrep_error(sgrep___0, (char *)"Expression file \'%s\' : %s\n", fname, tmp___0);
      }
#line 590
      return (-1);
    }
    {
#line 592
    string_cat(str, "#line 1 \"");
#line 593
    string_cat(str, fname);
#line 594
    string_cat(str, "\"\n");
    }
  }
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 598
    tmp___1 = fread((void */* __restrict  */)(buf), (size_t )1, sizeof(buf) - 1UL,
                    (FILE */* __restrict  */)stream);
#line 598
    bytes = (int )tmp___1;
#line 599
    buf[bytes] = (char)0;
#line 600
    string_cat(str, (char const   *)(buf));
#line 597
    tmp___2 = feof(stream);
    }
#line 597
    if (tmp___2) {
#line 597
      goto while_break;
    } else {
      {
#line 597
      tmp___3 = ferror(stream);
      }
#line 597
      if (tmp___3) {
#line 597
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 603
  tmp___6 = ferror(stream);
  }
#line 603
  if (tmp___6) {
    {
#line 604
    tmp___4 = __errno_location();
#line 604
    tmp___5 = strerror(*tmp___4);
#line 604
    sgrep_error(sgrep___0, (char *)"Reading file \'%s\' : %s\n", fname, tmp___5);
    }
#line 606
    if ((unsigned long )stream != (unsigned long )stdin) {
      {
#line 606
      fclose(stream);
      }
    }
#line 607
    return (-1);
  }
#line 609
  if ((unsigned long )stream != (unsigned long )stdin) {
    {
#line 609
    fclose(stream);
    }
  }
#line 610
  return (0);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
SgrepString *read_expressions(SgrepData *sgrep___0 , struct Expression *expression_list ) 
{ 
  SgrepString *return_string ;
  FILE *test_stream ;
  SgrepString *sgreprc ;
  SgrepString *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 620
  if ((unsigned long )expression_list == (unsigned long )((void *)0)) {
    {
#line 621
    test_stream = (FILE *)((void *)0);
#line 622
    return_string = new_string(sgrep___0, (size_t )8192);
    }
#line 625
    if (read_sgreprc) {
      {
#line 625
      tmp___2 = getenv("HOME");
      }
#line 625
      if (tmp___2) {
        {
#line 626
        tmp = new_string(sgrep___0, (size_t )1024);
#line 626
        sgreprc = tmp;
#line 627
        tmp___0 = getenv("HOME");
#line 627
        string_cat(sgreprc, (char const   *)tmp___0);
#line 628
        string_cat(sgreprc, "/");
#line 629
        string_cat(sgreprc, ".sgreprc");
#line 630
        test_stream = fopen((char const   */* __restrict  */)sgreprc->s, (char const   */* __restrict  */)"r");
        }
#line 631
        if (test_stream) {
          {
#line 633
          *(sgreprc->s + sgreprc->length) = (char)0;
#line 633
          tmp___1 = read_expression_file(return_string, (char const   *)sgreprc->s);
          }
#line 633
          if (tmp___1 == -1) {
            {
#line 635
            delete_string(return_string);
#line 636
            return_string = (SgrepString *)((void *)0);
            }
          }
        }
        {
#line 639
        delete_string(sgreprc);
        }
      }
    }
#line 643
    if (read_sgreprc) {
#line 643
      if (! test_stream) {
        {
#line 644
        test_stream = fopen((char const   */* __restrict  */)"/usr/local/etc/sgreprc",
                            (char const   */* __restrict  */)"r");
        }
#line 645
        if (test_stream) {
          {
#line 646
          tmp___3 = read_expression_file(return_string, "/usr/local/etc/sgreprc");
          }
#line 646
          if (tmp___3 == -1) {
            {
#line 648
            delete_string(return_string);
#line 649
            return_string = (SgrepString *)((void *)0);
            }
          }
        }
      }
    }
#line 654
    if (test_stream) {
      {
#line 654
      fclose(test_stream);
      }
    }
#line 655
    return (return_string);
  }
  {
#line 659
  return_string = read_expressions(sgrep___0, expression_list->next);
  }
#line 661
  if ((unsigned long )return_string != (unsigned long )((void *)0)) {
    {
#line 663
    if ((unsigned int )expression_list->type == 0U) {
#line 663
      goto case_0;
    }
#line 670
    if ((unsigned int )expression_list->type == 1U) {
#line 670
      goto case_1;
    }
#line 662
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 664
    tmp___4 = read_expression_file(return_string, (char const   *)expression_list->expr);
    }
#line 664
    if (tmp___4 == -1) {
      {
#line 666
      delete_string(return_string);
#line 667
      return_string = (SgrepString *)((void *)0);
      }
    }
#line 669
    goto switch_break;
    case_1: /* CIL Label */ 
#line 672
    if (return_string->length > 0UL) {
#line 672
      if ((int )*(return_string->s + (return_string->length - 1UL)) != 10) {
        {
#line 674
        string_cat(return_string, "\n");
        }
      }
    }
    {
#line 676
    string_cat(return_string, "#line 1 \"\"\n");
#line 677
    string_cat(return_string, (char const   *)expression_list->expr);
    }
#line 678
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 681
  sgrep_debug_free(sgrep___0, (void *)expression_list->expr);
#line 682
  sgrep_debug_free(sgrep___0, (void *)expression_list);
  }
#line 683
  return (return_string);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void read_style_file(char *fname ) 
{ 
  int fd ;
  int l ;
  int r ;
  int *tmp ;
  char *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 694
  fd = open((char const   *)fname, 0);
  }
#line 695
  if (fd == -1) {
    {
#line 697
    tmp = __errno_location();
#line 697
    tmp___0 = strerror(*tmp);
#line 697
    sgrep_error(sgrep, (char *)"open style file %s : %s\n", fname, tmp___0);
#line 698
    exit(2);
    }
  }
  {
#line 700
  tmp___1 = lseek(fd, (__off_t )0, 2);
#line 700
  l = (int )tmp___1;
  }
#line 701
  if (l == -1) {
    {
#line 703
    tmp___2 = __errno_location();
#line 703
    tmp___3 = strerror(*tmp___2);
#line 703
    sgrep_error(sgrep, (char *)"lseek style file %s : %s\n", fname, tmp___3);
#line 704
    exit(2);
    }
  }
  {
#line 706
  lseek(fd, (__off_t )0, 0);
#line 707
  tmp___4 = sgrep_debug_malloc(sgrep, (size_t )(l + 1), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                               707);
#line 707
  sgrep->output_style = (char *)tmp___4;
#line 708
  tmp___5 = read(fd, (void *)sgrep->output_style, (size_t )l);
#line 708
  r = (int )tmp___5;
  }
#line 709
  if (r == -1) {
    {
#line 711
    tmp___6 = __errno_location();
#line 711
    tmp___7 = strerror(*tmp___6);
#line 711
    sgrep_error(sgrep, (char *)"read style file %s : %s\n", fname, tmp___7);
#line 712
    exit(2);
    }
  }
#line 714
  if (r == 0) {
    {
#line 716
    sgrep_error(sgrep, (char *)"Empty style file %s\n", fname);
#line 717
    exit(2);
    }
  }
  {
#line 719
  *(sgrep->output_style + r) = (char)0;
#line 720
  close(fd);
  }
#line 721
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int get_options(char **argv ) 
{ 
  int i___0 ;
  int j ;
  int tmp ;
  char *arg ;
  struct Expression *e ;
  void *tmp___0 ;
  char *arg___0 ;
  int tmp___1 ;
  char *arg___1 ;
  int tmp___2 ;
  char *arg___2 ;
  struct Expression *e___0 ;
  void *tmp___3 ;
  char *arg___3 ;

  {
#line 730
  i___0 = 1;
#line 731
  j = 1;
  {
#line 734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 734
    if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 734
      if (! ((int )*(*(argv + 0)) == 45)) {
#line 734
        goto while_break;
      }
    } else {
#line 734
      goto while_break;
    }
    {
#line 737
    tmp = strcmp((char const   *)*argv, "--");
    }
#line 737
    if (tmp == 0) {
#line 737
      return (i___0 + 1);
    }
    {
#line 742
    if ((int )*(*argv + j) == 104) {
#line 742
      goto case_104;
    }
#line 745
    if ((int )*(*argv + j) == 86) {
#line 745
      goto case_86;
    }
#line 750
    if ((int )*(*argv + j) == 118) {
#line 750
      goto case_118;
    }
#line 753
    if ((int )*(*argv + j) == 84) {
#line 753
      goto case_84;
    }
#line 756
    if ((int )*(*argv + j) == 116) {
#line 756
      goto case_116;
    }
#line 759
    if ((int )*(*argv + j) == 97) {
#line 759
      goto case_97;
    }
#line 762
    if ((int )*(*argv + j) == 105) {
#line 762
      goto case_105;
    }
#line 765
    if ((int )*(*argv + j) == 108) {
#line 765
      goto case_108;
    }
#line 769
    if ((int )*(*argv + j) == 115) {
#line 769
      goto case_115;
    }
#line 773
    if ((int )*(*argv + j) == 111) {
#line 773
      goto case_111;
    }
#line 778
    if ((int )*(*argv + j) == 99) {
#line 778
      goto case_99;
    }
#line 783
    if ((int )*(*argv + j) == 100) {
#line 783
      goto case_100;
    }
#line 786
    if ((int )*(*argv + j) == 78) {
#line 786
      goto case_78;
    }
#line 795
    if ((int )*(*argv + j) == 102) {
#line 795
      goto case_102;
    }
#line 807
    if ((int )*(*argv + j) == 70) {
#line 807
      goto case_70;
    }
#line 821
    if ((int )*(*argv + j) == 103) {
#line 821
      goto case_103;
    }
#line 830
    if ((int )*(*argv + j) == 101) {
#line 830
      goto case_101;
    }
#line 843
    if ((int )*(*argv + j) == 112) {
#line 843
      goto case_112;
    }
#line 847
    if ((int )*(*argv + j) == 110) {
#line 847
      goto case_110;
    }
#line 850
    if ((int )*(*argv + j) == 79) {
#line 850
      goto case_79;
    }
#line 857
    if ((int )*(*argv + j) == 80) {
#line 857
      goto case_80;
    }
#line 860
    if ((int )*(*argv + j) == 68) {
#line 860
      goto case_68;
    }
#line 863
    if ((int )*(*argv + j) == 83) {
#line 863
      goto case_83;
    }
#line 866
    if ((int )*(*argv + j) == 82) {
#line 866
      goto case_82;
    }
#line 870
    if ((int )*(*argv + j) == 113) {
#line 870
      goto case_113;
    }
#line 873
    if ((int )*(*argv + j) == 120) {
#line 873
      goto case_120;
    }
#line 887
    if ((int )*(*argv + j) == 119) {
#line 887
      goto case_119;
    }
#line 891
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 743
    print_help();
    }
#line 744
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 746
    printf((char const   */* __restrict  */)"sgrep version %s compiled at %s\n", "1.94a",
           "Mar 10 2016");
#line 748
    exit(0);
    }
#line 749
    goto switch_break;
    case_118: /* CIL Label */ 
#line 751
    sgrep->progress_output = 1;
#line 752
    goto switch_break;
    case_84: /* CIL Label */ 
#line 754
    have_stats = 1;
#line 755
    goto switch_break;
    case_116: /* CIL Label */ 
#line 757
    have_times = 1;
#line 758
    goto switch_break;
    case_97: /* CIL Label */ 
#line 760
    sgrep->print_all = 1;
#line 761
    goto switch_break;
    case_105: /* CIL Label */ 
#line 763
    sgrep->ignore_case = 1;
#line 764
    goto switch_break;
    case_108: /* CIL Label */ 
#line 766
    sgrep->output_style = (char *)"------------- #%n %f: %l (%s,%e : %i,%j)\\n%r\\n";
#line 767
    sgrep->do_concat = 0;
#line 768
    goto switch_break;
    case_115: /* CIL Label */ 
#line 770
    sgrep->output_style = (char *)"%r";
#line 771
    sgrep->do_concat = 1;
#line 772
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 774
    sgrep->output_style = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 775
    if (! sgrep->output_style) {
#line 775
      return (-1);
    }
#line 776
    sgrep->do_concat = 0;
#line 777
    goto switch_break;
    case_99: /* CIL Label */ 
#line 779
    display_count = 1;
#line 780
    sgrep->do_concat = 0;
#line 781
    no_output = 0;
#line 782
    goto switch_break;
    case_100: /* CIL Label */ 
#line 784
    sgrep->do_concat = 0;
#line 785
    goto switch_break;
    case_78: /* CIL Label */ 
#line 787
    sgrep->print_newline = 0;
#line 788
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 798
    arg = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 799
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 799
      return (-1);
    }
    {
#line 800
    tmp___0 = sgrep_debug_malloc(sgrep, sizeof(struct Expression ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                                 800);
#line 800
    e = (struct Expression *)tmp___0;
#line 801
    e->expr = sgrep_debug_strdup(sgrep, (char const   *)arg, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                                 801);
#line 802
    e->type = (enum ExpressionType )0;
#line 803
    e->next = last_expression;
#line 804
    last_expression = e;
    }
#line 806
    goto switch_break;
    case_70: /* CIL Label */ 
#line 810
    if (num_file_list_files == 64) {
      {
#line 811
      sgrep_error(sgrep, (char *)"too many file list files (more than %d -F options given)\n",
                  64);
      }
#line 814
      return (-1);
    }
    {
#line 816
    arg___0 = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 817
    if (! arg___0) {
#line 817
      return (-1);
    }
#line 818
    tmp___1 = num_file_list_files;
#line 818
    num_file_list_files ++;
#line 818
    file_list_files[tmp___1] = arg___0;
#line 819
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 823
    arg___1 = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 824
    if (! arg___1) {
#line 824
      return (-1);
    }
    {
#line 825
    tmp___2 = set_scanner_option(sgrep, (char const   *)arg___1);
    }
#line 825
    if (tmp___2 == -1) {
      {
#line 826
      exit(2);
      }
    }
#line 828
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 834
    arg___2 = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 835
    if (! arg___2) {
#line 835
      return (-1);
    }
    {
#line 836
    tmp___3 = sgrep_debug_malloc(sgrep, sizeof(struct Expression ), "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                                 836);
#line 836
    e___0 = (struct Expression *)tmp___3;
#line 837
    e___0->expr = sgrep_debug_strdup(sgrep, (char const   *)arg___2, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                                     837);
#line 838
    e___0->type = (enum ExpressionType )1;
#line 839
    e___0->next = last_expression;
#line 840
    last_expression = e___0;
    }
#line 841
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 844
    preprocessor = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 845
    if (! preprocessor) {
#line 845
      return (-1);
    }
#line 846
    goto switch_break;
    case_110: /* CIL Label */ 
#line 848
    read_sgreprc = 0;
#line 849
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 852
    arg___3 = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 853
    if (! arg___3) {
#line 853
      return (-1);
    }
    {
#line 854
    read_style_file(arg___3);
    }
#line 855
    goto switch_break;
    case_80: /* CIL Label */ 
#line 858
    show_expr = 1;
#line 859
    goto switch_break;
    case_68: /* CIL Label */ 
#line 861
    sgrep->progress_output = 1;
#line 862
    goto switch_break;
    case_83: /* CIL Label */ 
#line 864
    sgrep->stream_mode = 1;
#line 865
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 867
    sgrep->recurse_dirs = 1;
#line 868
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING -R not working (yet)\n");
    }
#line 869
    goto switch_break;
    case_113: /* CIL Label */ 
#line 871
    no_output = 1;
#line 872
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 874
    sgrep->index_file = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 875
    if (! sgrep->index_file) {
#line 875
      return (-1);
    }
#line 876
    if (sgrep->index_reader) {
      {
#line 877
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-x option used twice. Multiple indexes at once is not implemented.\n");
#line 878
      exit(2);
      }
    }
    {
#line 880
    sgrep->index_reader = new_index_reader(sgrep, (char const   *)sgrep->index_file);
    }
#line 881
    if ((unsigned long )sgrep->index_reader == (unsigned long )((void *)0)) {
      {
#line 882
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index file unusable. Bailing out.\n");
#line 883
      exit(2);
      }
    }
#line 885
    sgrep->stream_mode = 1;
#line 886
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 888
    sgrep->word_chars = get_arg(sgrep, & argv, & i___0, & j);
    }
#line 889
    if (! sgrep->word_chars) {
#line 889
      return (-1);
    }
#line 890
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 892
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal option -%c\n",
            (int )*(*argv + j));
    }
#line 893
    return (-1);
#line 894
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 896
    j ++;
#line 896
    if ((int )*(*argv + j) == 0) {
#line 898
      argv ++;
#line 899
      i___0 ++;
#line 900
      j = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  return (i___0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void show_stats(void) 
{ 


  {
  {
#line 912
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scanned %d files, having total of %dK size finding %d phrases.\n",
          sgrep->statistics.scanned_files, sgrep->statistics.scanned_bytes / 1024,
          sgrep->statistics.phrases);
#line 917
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Operator tree size was %d, optimized %d\n",
          sgrep->statistics.parse_tree_size, sgrep->statistics.parse_tree_size - sgrep->statistics.optimized_nodes);
#line 920
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Output list size was %d regions.\n",
          sgrep->statistics.output);
#line 921
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Operations:\n%15s:%-4d%6s:%-4d%5s:%-4d%5s:%-4d%11s:%-4d%3s:%-4d\n",
          "containing", sgrep->statistics.containing, "in", sgrep->statistics.in,
          "order", sgrep->statistics.order, "or", sgrep->statistics.or_oper, "extracting",
          sgrep->statistics.extracting, "quote", sgrep->statistics.quote);
#line 929
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%15s:%-4d%6s:%-4d%5s:%-4d%5s:%-4d%11s:%-4d%4s:%-4d\n",
          "not containing", sgrep->statistics.not_containing, "not in", sgrep->statistics.not_in,
          "inner", sgrep->statistics.inner, "outer", sgrep->statistics.outer, "concat",
          sgrep->statistics.concat, "join", sgrep->statistics.join);
#line 936
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%15s:%-4d%6s:%-4d\n",
          "equal", sgrep->statistics.equal, "not equal", sgrep->statistics.not_equal);
#line 939
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%15s:%-4d%6s:%-4d\n",
          "parenting", sgrep->statistics.parenting, "childrening", sgrep->statistics.childrening);
#line 942
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Total %d operations evaluated.\n",
          sgrep->statistics.operators_evaluated);
#line 944
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory:\n %dK peak memory usage, %d realloc operations\n",
          sgrep->statistics.peak_memory_usage / 1024UL, sgrep->statistics.reallocs);
#line 947
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d gc lists created",
          sgrep->statistics.region_lists);
#line 948
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d gc blocks used, %d gc blocks allocated.\n",
          sgrep->statistics.gc_nodes, sgrep->statistics.gc_nodes_allocated);
#line 950
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Longest list size was %d regions.\n",
          sgrep->statistics.longest_list);
#line 952
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Things done:\n %d %s\n %d %s, %d %s, %d %s\n",
          sgrep->statistics.scans, "gc lists scanned", sgrep->statistics.sorts_by_start,
          "sorts by start point", sgrep->statistics.sorts_by_end, "sorts by end point",
          sgrep->statistics.remove_duplicates, "remove duplicates");
#line 960
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d sorts optimized\n",
          sgrep->statistics.sorts_optimized);
  }
#line 962
  if (sgrep->statistics.optimized_phrases) {
    {
#line 964
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d same phrases\n",
            sgrep->statistics.optimized_phrases);
    }
  }
#line 966
  return;
}
}
#line 980
float calc_time(clock_t b , clock_t e ) ;
#line 980 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
static long clktck  =    0L;
#line 978 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
float calc_time(clock_t b , clock_t e ) 
{ 


  {
#line 982
  if (clktck == 0L) {
    {
#line 982
    clktck = sysconf(2);
    }
  }
#line 983
  if (clktck < 0L) {
#line 983
    return ((float )0);
  }
#line 985
  return ((float )(e - b) / (float )clktck);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void print_time(char *label , struct tms *b , struct tms *e ) 
{ 
  float sys ;
  float usr ;

  {
  {
#line 997
  usr = calc_time(b->tms_utime, e->tms_utime);
#line 998
  sys = calc_time(b->tms_stime, e->tms_stime);
#line 999
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %-18s%6.2fs %6.2fs %6.2fs\n",
          label, (double )usr, (double )sys, (double )(usr + sys));
  }
#line 1000
  return;
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
void show_times(void) 
{ 


  {
  {
#line 1010
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-18s%8s%8s%8s\n",
          "sgrep time usage", "usr", "sys", "total");
#line 1012
  print_time((char *)"parsing", & tps.start, & tps.parsing);
#line 1013
  print_time((char *)"acsearch", & tps.parsing, & tps.acsearch);
#line 1014
  print_time((char *)"evaluating", & tps.acsearch, & tps.eval);
#line 1015
  print_time((char *)"output", & tps.eval, & tps.output);
#line 1016
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -----------------------------------------\n");
#line 1017
  print_time((char *)"total", & tps.start, & tps.output);
  }
#line 1018
  if (tps.output.tms_cutime > 0L) {
    {
#line 1020
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1021
    print_time((char *)"preprocessor", (struct tms *)(& tps.start.tms_cutime), (struct tms *)(& tps.output.tms_cutime));
    }
  }
#line 1028
  return;
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c"
int environ_options(void) 
{ 
  char *av[100] ;
  int i___0 ;
  int j ;
  char *o ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 1036
  i___0 = 0;
#line 1037
  j = 0;
#line 1040
  tmp = getenv("SGREPOPT");
  }
#line 1040
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1040
    return (0);
  }
  {
#line 1042
  tmp___0 = getenv("SGREPOPT");
#line 1042
  tmp___1 = strlen((char const   *)(tmp___0 + 1));
#line 1042
  tmp___2 = sgrep_debug_malloc(sgrep, tmp___1, "/home/june/repo/benchmarks/collector/temp/sgrep-1.94a/main.c",
                               1042);
#line 1042
  o = (char *)tmp___2;
#line 1043
  option_space = o;
#line 1044
  tmp___3 = getenv("SGREPOPT");
#line 1044
  strcpy((char */* __restrict  */)o, (char const   */* __restrict  */)tmp___3);
  }
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1047
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1047
      if (! ((int )*(o + i___0) == 32)) {
#line 1047
        goto while_break___0;
      }
#line 1049
      tmp___4 = i___0;
#line 1049
      i___0 ++;
#line 1049
      *(o + tmp___4) = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1051
    if (! *(o + i___0)) {
#line 1051
      goto while_break;
    }
#line 1052
    tmp___5 = j;
#line 1052
    j ++;
#line 1052
    av[tmp___5] = o + i___0;
#line 1053
    if (j == 100) {
      {
#line 1055
      sgrep_error(sgrep, (char *)"Too complex SGREPOPT\n");
#line 1056
      exit(2);
      }
    }
    {
#line 1058
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1058
      if ((int )*(o + i___0) != 32) {
#line 1058
        if (! ((int )*(o + i___0) != 0)) {
#line 1058
          goto while_break___1;
        }
      } else {
#line 1058
        goto while_break___1;
      }
#line 1058
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1046
    if (! *(o + i___0)) {
#line 1046
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1060
  av[j] = (char *)((void *)0);
#line 1070
  i___0 = get_options(av);
  }
#line 1071
  if (i___0 == -1) {
    {
#line 1073
    tmp___6 = getenv("SGREPOPT");
#line 1073
    sgrep_error(sgrep, (char *)"Invalid SGREPOPT (SGREPOPT=%s)\n", tmp___6);
    }
#line 1074
    return (-1);
  }
#line 1076
  if (i___0 <= j) {
    {
#line 1078
    sgrep_error(sgrep, (char *)"No files or expressions allowed in SGREPOPT\n");
    }
#line 1079
    return (-1);
  }
#line 1081
  return (0);
}
}
