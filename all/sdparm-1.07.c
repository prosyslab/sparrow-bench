/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 145 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_opt_coll {
   int all ;
   int dbd ;
   int defaults ;
   int dummy ;
   int enumerate ;
   int flexible ;
   int hex ;
   int inquiry ;
   int long_out ;
   int mode_6 ;
   int num_desc ;
   int quiet ;
   int read_only ;
   int save ;
   int transport ;
   int vendor ;
   int verbose ;
};
#line 198 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_vpd_page_t {
   int vpd_num ;
   int subvalue ;
   int pdt ;
   char const   *acron ;
   char const   *name ;
};
#line 165 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_mode_descriptor_t {
   int num_descs_off ;
   int num_descs_bytes ;
   int num_descs_inc ;
   int first_desc_off ;
   int desc_len ;
   int desc_len_off ;
   int desc_len_bytes ;
   char const   *name ;
};
#line 180 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_mode_page_t {
   int page ;
   int subpage ;
   int pdt ;
   int ro ;
   char const   *acron ;
   char const   *name ;
   struct sdparm_mode_descriptor_t  const  *mp_desc ;
};
#line 192 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_transport_id_t {
   int proto_num ;
   char const   *acron ;
   char const   *name ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_mode_page_item {
   char const   *acron ;
   int page_num ;
   int subpage_num ;
   int pdt ;
   int start_byte ;
   int start_bit ;
   int num_bits ;
   int flags ;
   char const   *description ;
   char const   *extra ;
};
#line 241 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_transport_pair {
   struct sdparm_mode_page_t *mpage ;
   struct sdparm_mode_page_item *mitem ;
};
#line 251 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_command_t {
   int cmd_num ;
   char const   *name ;
   char const   *min_abbrev ;
   char const   *extra_arg ;
};
#line 258 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_val_desc_t {
   int val ;
   char const   *desc ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 207 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_vendor_name_t {
   int vendor_num ;
   char const   *acron ;
   char const   *name ;
};
#line 227 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_mode_page_it_val {
   struct sdparm_mode_page_item mpi ;
   int64_t val ;
   int64_t orig_val ;
   int descriptor_num ;
};
#line 234 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_mode_page_settings {
   int page_num ;
   int subpage_num ;
   struct sdparm_mode_page_it_val it_vals[128] ;
   int num_it_vals ;
};
#line 246 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_vendor_pair {
   struct sdparm_mode_page_t *mpage ;
   struct sdparm_mode_page_item *mitem ;
};
#line 161 "../include/sg_cmds_basic.h"
struct sg_simple_inquiry_resp {
   unsigned char peripheral_qualifier ;
   unsigned char peripheral_type ;
   unsigned char rmb ;
   unsigned char version ;
   unsigned char byte_3 ;
   unsigned char byte_5 ;
   unsigned char byte_6 ;
   unsigned char byte_7 ;
   char vendor[9] ;
   char product[17] ;
   char revision[5] ;
};
#line 2385 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
struct my_scsi_idlun {
   int mux4 ;
   int host_unique_id ;
};
#line 2385 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
typedef struct my_scsi_idlun My_scsi_idlun;
#line 233 "../include/sg_cmds_basic.h"
struct sg_pt_base;
#line 139 "../include/sg_lib.h"
struct sg_scsi_sense_hdr {
   unsigned char response_code ;
   unsigned char sense_key ;
   unsigned char asc ;
   unsigned char ascq ;
   unsigned char byte4 ;
   unsigned char byte5 ;
   unsigned char byte6 ;
   unsigned char additional_length ;
};
#line 37 "../include/sg_lib_data.h"
struct sg_lib_value_name_t {
   int value ;
   int peri_dev_type ;
   char const   *name ;
};
#line 43 "../include/sg_lib_data.h"
struct sg_lib_asc_ascq_t {
   unsigned char asc ;
   unsigned char ascq ;
   char const   *text ;
};
#line 49 "../include/sg_lib_data.h"
struct sg_lib_asc_ascq_range_t {
   unsigned char asc ;
   unsigned char ascq_min ;
   unsigned char ascq_max ;
   char const   *text ;
};
#line 1377 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
union u_t {
   unsigned short s ;
   unsigned char c[sizeof(unsigned short )] ;
};
#line 44 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 20 "/usr/include/linux/bsg.h"
struct sg_io_v4 {
   __s32 guard ;
   __u32 protocol ;
   __u32 subprotocol ;
   __u32 request_len ;
   __u64 request ;
   __u64 request_tag ;
   __u32 request_attr ;
   __u32 request_priority ;
   __u32 request_extra ;
   __u32 max_response_len ;
   __u64 response ;
   __u32 dout_iovec_count ;
   __u32 dout_xfer_len ;
   __u32 din_iovec_count ;
   __u32 din_xfer_len ;
   __u64 dout_xferp ;
   __u64 din_xferp ;
   __u32 timeout ;
   __u32 flags ;
   __u64 usr_ptr ;
   __u32 spare_in ;
   __u32 driver_status ;
   __u32 transport_status ;
   __u32 device_status ;
   __u32 retry_delay ;
   __u32 info ;
   __u32 duration ;
   __u32 response_len ;
   __s32 din_resid ;
   __s32 dout_resid ;
   __u64 generated_tag ;
   __u32 spare_out ;
   __u32 padding ;
};
#line 491 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
struct sg_pt_linux_scsi {
   struct sg_io_v4 io_hdr ;
   int in_err ;
   int os_err ;
   unsigned char tmf_request[4] ;
};
#line 498 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
struct sg_pt_base {
   struct sg_pt_linux_scsi impl ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 276 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
char const   *sdparm_code_set_arr[16] ;
#line 277
char const   *sdparm_assoc_arr[4] ;
#line 278
char const   *sdparm_desig_type_arr[16] ;
#line 280
char const   *sdparm_network_service_type_arr[32] ;
#line 281
char const   *sdparm_mode_page_policy_arr[4] ;
#line 298
struct sdparm_vpd_page_t  const  *sdp_get_vpd_detail(int page_num , int subvalue ,
                                                     int pdt ) ;
#line 333
int sdp_process_vpd_page(int sg_fd , int pn , int spn , struct sdparm_opt_coll  const  *opts ,
                         int req_pdt , int protect ) ;
#line 210 "../include/sg_lib.h"
char *sg_get_trans_proto_str(int tpi , int buff_len , char *buff ) ;
#line 281
int sg_vpd_dev_id_iter(unsigned char const   *initial_desig_desc , int page_len ,
                       int *off , int m_assoc , int m_desig_type , int m_code_set ) ;
#line 301
void dStrHex(char const   *str , int len , int no_ascii ) ;
#line 307
int sg_is_big_endian(void) ;
#line 313
int sg_ata_get_chars(unsigned short const   *word_arr , int start_word , int num_words ,
                     int is_big_endian , char *ochars ) ;
#line 329
void dWordHex(unsigned short const   *words , int num , int no_ascii , int swapb ) ;
#line 20 "../include/sg_cmds_basic.h"
int sg_ll_inquiry(int sg_fd , int cmddt , int evpd , int pg_op , void *resp , int mx_resp_len ,
                  int noisy , int verbose ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_dev_ids_quiet(unsigned char *buff , int len , int m_assoc , int m_desig_type ,
                                int m_code_set ) 
{ 
  int m ;
  int p_id ;
  int c_set ;
  int piv ;
  int assoc ;
  int desig_type ;
  int i_len ;
  int is_sas ;
  int naa ;
  int off ;
  int u ;
  int rtp ;
  unsigned char const   *ucp ;
  unsigned char const   *ip ;
  unsigned char sas_tport_addr[8] ;

  {
  {
#line 58
  rtp = 0;
#line 59
  memset((void *)(sas_tport_addr), 0, sizeof(sas_tport_addr));
#line 60
  off = -1;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    u = sg_vpd_dev_id_iter((unsigned char const   *)buff, len, & off, m_assoc, m_desig_type,
                           m_code_set);
    }
#line 61
    if (! (u == 0)) {
#line 61
      goto while_break;
    }
#line 63
    ucp = (unsigned char const   *)(buff + off);
#line 64
    i_len = (int )*(ucp + 3);
#line 65
    if ((off + i_len) + 4 > len) {
      {
#line 66
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    VPD page error: designator length longer than\n     remaining response length=%d\n",
              len - off);
      }
#line 68
      return (97);
    }
#line 70
    ip = ucp + 4;
#line 71
    p_id = (int )(((int const   )*(ucp + 0) >> 4) & 15);
#line 72
    c_set = (int )((int const   )*(ucp + 0) & 15);
#line 73
    if ((int const   )*(ucp + 1) & 128) {
#line 73
      piv = 1;
    } else {
#line 73
      piv = 0;
    }
#line 74
    if (piv) {
#line 74
      if (6 == p_id) {
#line 74
        is_sas = 1;
      } else {
#line 74
        is_sas = 0;
      }
    } else {
#line 74
      is_sas = 0;
    }
#line 75
    assoc = (int )(((int const   )*(ucp + 1) >> 4) & 3);
#line 76
    desig_type = (int )((int const   )*(ucp + 1) & 15);
    {
#line 78
    if (desig_type == 0) {
#line 78
      goto case_0;
    }
#line 80
    if (desig_type == 1) {
#line 80
      goto case_1;
    }
#line 82
    if (desig_type == 2) {
#line 82
      goto case_2;
    }
#line 91
    if (desig_type == 3) {
#line 91
      goto case_3;
    }
#line 156
    if (desig_type == 4) {
#line 156
      goto case_4;
    }
#line 169
    if (desig_type == 5) {
#line 169
      goto case_5;
    }
#line 171
    if (desig_type == 6) {
#line 171
      goto case_6;
    }
#line 173
    if (desig_type == 7) {
#line 173
      goto case_7;
    }
#line 175
    if (desig_type == 8) {
#line 175
      goto case_8;
    }
#line 187
    goto switch_default;
    case_0: /* CIL Label */ 
#line 79
    goto switch_break;
    case_1: /* CIL Label */ 
#line 81
    goto switch_break;
    case_2: /* CIL Label */ 
#line 83
    if (8 != i_len) {
#line 83
      if (12 != i_len) {
#line 83
        if (16 != i_len) {
          {
#line 84
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expect 8, 12 and 16 byte EUI, got %d>>\n",
                  i_len);
          }
        }
      }
    }
    {
#line 86
    printf((char const   */* __restrict  */)"0x");
#line 87
    m = 0;
    }
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 87
      if (! (m < i_len)) {
#line 87
        goto while_break___0;
      }
      {
#line 88
      printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 87
      m ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 89
    printf((char const   */* __restrict  */)"\n");
    }
#line 90
    goto switch_break;
    case_3: /* CIL Label */ 
#line 92
    if (1 != c_set) {
      {
#line 93
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected code set %d for NAA>>\n",
              c_set);
#line 95
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 96
      goto switch_break;
    }
#line 98
    naa = (int )(((int const   )*(ip + 0) >> 4) & 255);
#line 99
    if (naa < 2) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA [0x%x]>>\n",
              naa);
#line 101
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 102
      goto switch_break;
    } else
#line 99
    if (naa > 6) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA [0x%x]>>\n",
              naa);
#line 101
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 102
      goto switch_break;
    } else
#line 99
    if (4 == naa) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA [0x%x]>>\n",
              naa);
#line 101
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 102
      goto switch_break;
    }
#line 104
    if (2 == naa) {
#line 105
      if (8 != i_len) {
        {
#line 106
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA 2 identifier length: 0x%x>>\n",
                i_len);
#line 108
        dStrHex((char const   *)ip, i_len, 0);
        }
#line 109
        goto switch_break;
      }
      {
#line 111
      printf((char const   */* __restrict  */)"0x");
#line 112
      m = 0;
      }
      {
#line 112
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 112
        if (! (m < 8)) {
#line 112
          goto while_break___1;
        }
        {
#line 113
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 112
        m ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 114
      printf((char const   */* __restrict  */)"\n");
      }
    } else
#line 115
    if (3 == naa) {
#line 115
      goto _L___0;
    } else
#line 115
    if (5 == naa) {
      _L___0: /* CIL Label */ 
#line 117
      if (8 != i_len) {
        {
#line 118
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA 3 or 5 identifier length: 0x%x>>\n",
                i_len);
#line 120
        dStrHex((char const   *)ip, i_len, 0);
        }
#line 121
        goto switch_break;
      }
#line 123
      if (0 == is_sas) {
#line 123
        goto _L;
      } else
#line 123
      if (1 != assoc) {
        _L: /* CIL Label */ 
        {
#line 124
        printf((char const   */* __restrict  */)"0x");
#line 125
        m = 0;
        }
        {
#line 125
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 125
          if (! (m < 8)) {
#line 125
            goto while_break___2;
          }
          {
#line 126
          printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 125
          m ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 127
        printf((char const   */* __restrict  */)"\n");
        }
      } else
#line 128
      if (rtp) {
        {
#line 129
        printf((char const   */* __restrict  */)"0x");
#line 130
        m = 0;
        }
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 130
          if (! (m < 8)) {
#line 130
            goto while_break___3;
          }
          {
#line 131
          printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 130
          m ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 132
        printf((char const   */* __restrict  */)",0x%x\n", rtp);
#line 133
        rtp = 0;
        }
      } else {
#line 135
        if (sas_tport_addr[0]) {
          {
#line 136
          printf((char const   */* __restrict  */)"0x");
#line 137
          m = 0;
          }
          {
#line 137
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 137
            if (! (m < 8)) {
#line 137
              goto while_break___4;
            }
            {
#line 138
            printf((char const   */* __restrict  */)"%02x", (unsigned int )sas_tport_addr[m]);
#line 137
            m ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 139
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 141
        memcpy((void */* __restrict  */)(sas_tport_addr), (void const   */* __restrict  */)ip,
               sizeof(sas_tport_addr));
        }
      }
    } else
#line 143
    if (6 == naa) {
#line 144
      if (16 != i_len) {
        {
#line 145
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA 6 identifier length: 0x%x>>\n",
                i_len);
#line 147
        dStrHex((char const   *)ip, i_len, 0);
        }
#line 148
        goto switch_break;
      }
      {
#line 150
      printf((char const   */* __restrict  */)"0x");
#line 151
      m = 0;
      }
      {
#line 151
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 151
        if (! (m < 16)) {
#line 151
          goto while_break___5;
        }
        {
#line 152
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 151
        m ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 153
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 155
    goto switch_break;
    case_4: /* CIL Label */ 
#line 157
    if (0 == is_sas) {
#line 158
      goto switch_break;
    } else
#line 157
    if (1 != c_set) {
#line 158
      goto switch_break;
    } else
#line 157
    if (1 != assoc) {
#line 158
      goto switch_break;
    } else
#line 157
    if (4 != i_len) {
#line 158
      goto switch_break;
    }
#line 159
    rtp = (int )(((int const   )*(ip + 2) << 8) | (int const   )*(ip + 3));
#line 160
    if (sas_tport_addr[0]) {
      {
#line 161
      printf((char const   */* __restrict  */)"0x");
#line 162
      m = 0;
      }
      {
#line 162
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 162
        if (! (m < 8)) {
#line 162
          goto while_break___6;
        }
        {
#line 163
        printf((char const   */* __restrict  */)"%02x", (unsigned int )sas_tport_addr[m]);
#line 162
        m ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 164
      printf((char const   */* __restrict  */)",0x%x\n", rtp);
#line 165
      memset((void *)(sas_tport_addr), 0, sizeof(sas_tport_addr));
#line 166
      rtp = 0;
      }
    }
#line 168
    goto switch_break;
    case_5: /* CIL Label */ 
#line 170
    goto switch_break;
    case_6: /* CIL Label */ 
#line 172
    goto switch_break;
    case_7: /* CIL Label */ 
#line 174
    goto switch_break;
    case_8: /* CIL Label */ 
#line 176
    if (3 != c_set) {
      {
#line 177
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected UTF-8 code_set>>\n");
#line 178
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 179
      goto switch_break;
    }
    {
#line 185
    printf((char const   */* __restrict  */)"%s\n", (char const   *)ip);
    }
#line 186
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if (sas_tport_addr[0]) {
    {
#line 192
    printf((char const   */* __restrict  */)"0x");
#line 193
    m = 0;
    }
    {
#line 193
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 193
      if (! (m < 8)) {
#line 193
        goto while_break___7;
      }
      {
#line 194
      printf((char const   */* __restrict  */)"%02x", (unsigned int )sas_tport_addr[m]);
#line 193
      m ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 195
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 197
  if (-2 == u) {
    {
#line 198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"VPD page error: short designator near offset %d\n",
            off);
    }
#line 200
    return (97);
  }
#line 202
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static void decode_designation_descriptor(unsigned char const   *ucp , int i_len ,
                                          int long_out , int print_assoc ) 
{ 
  int m ;
  int p_id ;
  int piv ;
  int c_set ;
  int assoc ;
  int desig_type ;
  int ci_off ;
  int c_id ;
  int d_id ;
  int naa ;
  int vsi ;
  int k ;
  unsigned char const   *ip ;
  uint64_t vsei ;
  uint64_t id_ext ;
  char b[64] ;
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 216
  ip = ucp + 4;
#line 217
  p_id = (int )(((int const   )*(ucp + 0) >> 4) & 15);
#line 218
  c_set = (int )((int const   )*(ucp + 0) & 15);
#line 219
  if ((int const   )*(ucp + 1) & 128) {
#line 219
    piv = 1;
  } else {
#line 219
    piv = 0;
  }
#line 220
  assoc = (int )(((int const   )*(ucp + 1) >> 4) & 3);
#line 221
  desig_type = (int )((int const   )*(ucp + 1) & 15);
#line 222
  if (print_assoc) {
    {
#line 223
    printf((char const   */* __restrict  */)"  %s:\n", sdparm_assoc_arr[assoc]);
    }
  }
  {
#line 224
  printf((char const   */* __restrict  */)"    designator type: %s,  code set: %s\n",
         sdparm_desig_type_arr[desig_type], sdparm_code_set_arr[c_set]);
  }
#line 226
  if (piv) {
#line 226
    if (1 == assoc) {
      {
#line 227
      tmp = sg_get_trans_proto_str(p_id, (int )sizeof(b), b);
#line 227
      printf((char const   */* __restrict  */)"     transport: %s\n", tmp);
      }
    } else
#line 226
    if (2 == assoc) {
      {
#line 227
      tmp = sg_get_trans_proto_str(p_id, (int )sizeof(b), b);
#line 227
      printf((char const   */* __restrict  */)"     transport: %s\n", tmp);
      }
    }
  }
  {
#line 231
  if (desig_type == 0) {
#line 231
    goto case_0;
  }
#line 244
  if (desig_type == 1) {
#line 244
    goto case_1;
  }
#line 249
  if (desig_type == 2) {
#line 249
    goto case_2;
  }
#line 302
  if (desig_type == 3) {
#line 302
    goto case_3;
  }
#line 405
  if (desig_type == 4) {
#line 405
    goto case_4;
  }
#line 415
  if (desig_type == 5) {
#line 415
    goto case_5;
  }
#line 425
  if (desig_type == 6) {
#line 425
    goto case_6;
  }
#line 435
  if (desig_type == 7) {
#line 435
    goto case_7;
  }
#line 445
  if (desig_type == 8) {
#line 445
    goto case_8;
  }
#line 458
  goto switch_default;
  case_0: /* CIL Label */ 
#line 232
  k = 0;
#line 233
  if (1 == c_set) {
#line 233
    goto _L;
  } else
#line 233
  if (2 == c_set) {
    _L: /* CIL Label */ 
#line 234
    k = 0;
    {
#line 234
    while (1) {
      while_continue: /* CIL Label */ ;
#line 234
      if (k < i_len) {
        {
#line 234
        tmp___0 = __ctype_b_loc();
        }
#line 234
        if (! ((int const   )*(*tmp___0 + (int )*(ip + k)) & 16384)) {
#line 234
          goto while_break;
        }
      } else {
#line 234
        goto while_break;
      }
#line 234
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 236
    if (k >= i_len) {
#line 237
      k = 1;
    }
  }
#line 239
  if (k) {
    {
#line 240
    printf((char const   */* __restrict  */)"      vendor specific: %.*s\n", i_len,
           ip);
    }
  } else {
    {
#line 242
    dStrHex((char const   *)ip, i_len, 0);
    }
  }
#line 243
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 245
  printf((char const   */* __restrict  */)"      vendor id: %.8s\n", ip);
  }
#line 246
  if (i_len > 8) {
    {
#line 247
    printf((char const   */* __restrict  */)"      vendor specific: %.*s\n", i_len - 8,
           ip + 8);
    }
  }
#line 248
  goto switch_break;
  case_2: /* CIL Label */ 
#line 250
  if (! long_out) {
#line 251
    if (8 != i_len) {
#line 251
      if (12 != i_len) {
#line 251
        if (16 != i_len) {
          {
#line 252
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expect 8, 12 and 16 byte EUI, got %d>>\n",
                  i_len);
#line 254
          dStrHex((char const   *)ip, i_len, 0);
          }
#line 255
          goto switch_break;
        }
      }
    }
    {
#line 257
    printf((char const   */* __restrict  */)"      0x");
#line 258
    m = 0;
    }
    {
#line 258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 258
      if (! (m < i_len)) {
#line 258
        goto while_break___0;
      }
      {
#line 259
      printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 258
      m ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 260
    printf((char const   */* __restrict  */)"\n");
    }
#line 261
    goto switch_break;
  }
  {
#line 263
  printf((char const   */* __restrict  */)"      EUI-64 based %d byte identifier\n",
         i_len);
  }
#line 264
  if (1 != c_set) {
    {
#line 265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set (1)>>\n");
#line 266
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 267
    goto switch_break;
  }
#line 269
  ci_off = 0;
#line 270
  if (16 == i_len) {
#line 271
    ci_off = 8;
#line 272
    id_ext = (uint64_t )0;
#line 273
    m = 0;
    {
#line 273
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 273
      if (! (m < 8)) {
#line 273
        goto while_break___1;
      }
#line 274
      if (m > 0) {
#line 275
        id_ext <<= 8;
      }
#line 276
      id_ext |= (unsigned long )*(ip + m);
#line 273
      m ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 278
    printf((char const   */* __restrict  */)"      Identifier extension: 0x%lx\n",
           id_ext);
    }
  } else
#line 279
  if (8 != i_len) {
#line 279
    if (12 != i_len) {
      {
#line 280
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << can only decode 8, 12 and 16 byte ids>>\n");
#line 282
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 283
      goto switch_break;
    }
  }
  {
#line 285
  c_id = (int )((((int const   )*(ip + ci_off) << 16) | ((int const   )*(ip + (ci_off + 1)) << 8)) | (int const   )*(ip + (ci_off + 2)));
#line 287
  printf((char const   */* __restrict  */)"      IEEE Company_id: 0x%x\n", c_id);
#line 288
  vsei = (uint64_t )0;
#line 289
  m = 0;
  }
  {
#line 289
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 289
    if (! (m < 5)) {
#line 289
      goto while_break___2;
    }
#line 290
    if (m > 0) {
#line 291
      vsei <<= 8;
    }
#line 292
    vsei |= (unsigned long )*(ip + ((ci_off + 3) + m));
#line 289
    m ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 294
  printf((char const   */* __restrict  */)"      Vendor Specific Extension Identifier: 0x%lx\n",
         vsei);
  }
#line 296
  if (12 == i_len) {
    {
#line 297
    d_id = (int )(((((unsigned int )*(ip + 8) << 24) | (unsigned int )((int const   )*(ip + 9) << 16)) | (unsigned int )((int const   )*(ip + 10) << 8)) | (unsigned int )*(ip + 11));
#line 299
    printf((char const   */* __restrict  */)"      Directory ID: 0x%x\n", d_id);
    }
  }
#line 301
  goto switch_break;
  case_3: /* CIL Label */ 
#line 303
  if (1 != c_set) {
    {
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected code set %d for NAA>>\n",
            c_set);
#line 306
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 307
    goto switch_break;
  }
#line 309
  naa = (int )(((int const   )*(ip + 0) >> 4) & 255);
#line 310
  if (! (2 == naa)) {
#line 310
    if (! (5 == naa)) {
#line 310
      if (! (6 == naa)) {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA [0x%x]>>\n",
                naa);
#line 312
        dStrHex((char const   *)ip, i_len, 0);
        }
#line 313
        goto switch_break;
      }
    }
  }
#line 315
  if (2 == naa) {
#line 316
    if (8 != i_len) {
      {
#line 317
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA 2 identifier length: 0x%x>>\n",
              i_len);
#line 319
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 320
      goto switch_break;
    }
#line 322
    d_id = (int )((((int const   )*(ip + 0) & 15) << 8) | (int const   )*(ip + 1));
#line 323
    c_id = (int )((((int const   )*(ip + 2) << 16) | ((int const   )*(ip + 3) << 8)) | (int const   )*(ip + 4));
#line 324
    vsi = (int )((((int const   )*(ip + 5) << 16) | ((int const   )*(ip + 6) << 8)) | (int const   )*(ip + 7));
#line 325
    if (long_out) {
      {
#line 326
      printf((char const   */* __restrict  */)"      NAA 2, vendor specific identifier A: 0x%x\n",
             d_id);
#line 328
      printf((char const   */* __restrict  */)"      IEEE Company_id: 0x%x\n", c_id);
#line 329
      printf((char const   */* __restrict  */)"      vendor specific identifier B: 0x%x\n",
             vsi);
#line 330
      printf((char const   */* __restrict  */)"      [0x");
#line 331
      m = 0;
      }
      {
#line 331
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 331
        if (! (m < 8)) {
#line 331
          goto while_break___3;
        }
        {
#line 332
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 331
        m ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 333
      printf((char const   */* __restrict  */)"]\n");
      }
    }
    {
#line 335
    printf((char const   */* __restrict  */)"      0x");
#line 336
    m = 0;
    }
    {
#line 336
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 336
      if (! (m < 8)) {
#line 336
        goto while_break___4;
      }
      {
#line 337
      printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 336
      m ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 338
    printf((char const   */* __restrict  */)"\n");
    }
  } else
#line 339
  if (5 == naa) {
#line 340
    if (8 != i_len) {
      {
#line 341
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA 5 identifier length: 0x%x>>\n",
              i_len);
#line 343
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 344
      goto switch_break;
    }
#line 346
    c_id = (int )((((((int const   )*(ip + 0) & 15) << 20) | ((int const   )*(ip + 1) << 12)) | ((int const   )*(ip + 2) << 4)) | (((int const   )*(ip + 3) & 240) >> 4));
#line 348
    vsei = (uint64_t )((int const   )*(ip + 3) & 15);
#line 349
    m = 1;
    {
#line 349
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 349
      if (! (m < 5)) {
#line 349
        goto while_break___5;
      }
#line 350
      vsei <<= 8;
#line 351
      vsei |= (unsigned long )*(ip + (3 + m));
#line 349
      m ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 353
    if (long_out) {
      {
#line 354
      printf((char const   */* __restrict  */)"      NAA 5, IEEE Company_id: 0x%x\n",
             c_id);
#line 355
      printf((char const   */* __restrict  */)"      Vendor Specific Identifier: 0x%lx\n",
             vsei);
#line 357
      printf((char const   */* __restrict  */)"      [0x");
#line 358
      m = 0;
      }
      {
#line 358
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 358
        if (! (m < 8)) {
#line 358
          goto while_break___6;
        }
        {
#line 359
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 358
        m ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 360
      printf((char const   */* __restrict  */)"]\n");
      }
    } else {
      {
#line 362
      printf((char const   */* __restrict  */)"      0x");
#line 363
      m = 0;
      }
      {
#line 363
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 363
        if (! (m < 8)) {
#line 363
          goto while_break___7;
        }
        {
#line 364
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 363
        m ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 365
      printf((char const   */* __restrict  */)"\n");
      }
    }
  } else
#line 367
  if (6 == naa) {
#line 368
    if (16 != i_len) {
      {
#line 369
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << unexpected NAA 6 identifier length: 0x%x>>\n",
              i_len);
#line 371
      dStrHex((char const   *)ip, i_len, 0);
      }
#line 372
      goto switch_break;
    }
#line 374
    c_id = (int )((((((int const   )*(ip + 0) & 15) << 20) | ((int const   )*(ip + 1) << 12)) | ((int const   )*(ip + 2) << 4)) | (((int const   )*(ip + 3) & 240) >> 4));
#line 376
    vsei = (uint64_t )((int const   )*(ip + 3) & 15);
#line 377
    m = 1;
    {
#line 377
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 377
      if (! (m < 5)) {
#line 377
        goto while_break___8;
      }
#line 378
      vsei <<= 8;
#line 379
      vsei |= (unsigned long )*(ip + (3 + m));
#line 377
      m ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 381
    if (long_out) {
      {
#line 382
      printf((char const   */* __restrict  */)"      NAA 6, IEEE Company_id: 0x%x\n",
             c_id);
#line 383
      printf((char const   */* __restrict  */)"      Vendor Specific Identifier: 0x%lx\n",
             vsei);
#line 385
      vsei = (uint64_t )0;
#line 386
      m = 0;
      }
      {
#line 386
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 386
        if (! (m < 8)) {
#line 386
          goto while_break___9;
        }
#line 387
        if (m > 0) {
#line 388
          vsei <<= 8;
        }
#line 389
        vsei |= (unsigned long )*(ip + (8 + m));
#line 386
        m ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 391
      printf((char const   */* __restrict  */)"      Vendor Specific Identifier Extension: 0x%lx\n",
             vsei);
#line 393
      printf((char const   */* __restrict  */)"      [0x");
#line 394
      m = 0;
      }
      {
#line 394
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 394
        if (! (m < 16)) {
#line 394
          goto while_break___10;
        }
        {
#line 395
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 394
        m ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 396
      printf((char const   */* __restrict  */)"]\n");
      }
    } else {
      {
#line 398
      printf((char const   */* __restrict  */)"      0x");
#line 399
      m = 0;
      }
      {
#line 399
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 399
        if (! (m < 16)) {
#line 399
          goto while_break___11;
        }
        {
#line 400
        printf((char const   */* __restrict  */)"%02x", (unsigned int )*(ip + m));
#line 399
        m ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 401
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 404
  goto switch_break;
  case_4: /* CIL Label */ 
#line 406
  if (1 != c_set) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, target port association, length 4>>\n");
#line 409
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 410
    goto switch_break;
  } else
#line 406
  if (1 != assoc) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, target port association, length 4>>\n");
#line 409
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 410
    goto switch_break;
  } else
#line 406
  if (4 != i_len) {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, target port association, length 4>>\n");
#line 409
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 410
    goto switch_break;
  }
  {
#line 412
  d_id = (int )(((int const   )*(ip + 2) << 8) | (int const   )*(ip + 3));
#line 413
  printf((char const   */* __restrict  */)"      Relative target port: 0x%x\n", d_id);
  }
#line 414
  goto switch_break;
  case_5: /* CIL Label */ 
#line 416
  if (1 != c_set) {
    {
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, target port association, length 4>>\n");
#line 419
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 420
    goto switch_break;
  } else
#line 416
  if (1 != assoc) {
    {
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, target port association, length 4>>\n");
#line 419
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 420
    goto switch_break;
  } else
#line 416
  if (4 != i_len) {
    {
#line 417
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, target port association, length 4>>\n");
#line 419
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 420
    goto switch_break;
  }
  {
#line 422
  d_id = (int )(((int const   )*(ip + 2) << 8) | (int const   )*(ip + 3));
#line 423
  printf((char const   */* __restrict  */)"      Target port group: 0x%x\n", d_id);
  }
#line 424
  goto switch_break;
  case_6: /* CIL Label */ 
#line 426
  if (1 != c_set) {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, logical unit association, length 4>>\n");
#line 429
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 430
    goto switch_break;
  } else
#line 426
  if (0 != assoc) {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, logical unit association, length 4>>\n");
#line 429
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 430
    goto switch_break;
  } else
#line 426
  if (4 != i_len) {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected binary code_set, logical unit association, length 4>>\n");
#line 429
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 430
    goto switch_break;
  }
  {
#line 432
  d_id = (int )(((int const   )*(ip + 2) << 8) | (int const   )*(ip + 3));
#line 433
  printf((char const   */* __restrict  */)"      Logical unit group: 0x%x\n", d_id);
  }
#line 434
  goto switch_break;
  case_7: /* CIL Label */ 
#line 436
  if (1 != c_set) {
    {
#line 437
    printf((char const   */* __restrict  */)"      << expected binary code_set, logical unit association>>\n");
#line 439
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 440
    goto switch_break;
  } else
#line 436
  if (0 != assoc) {
    {
#line 437
    printf((char const   */* __restrict  */)"      << expected binary code_set, logical unit association>>\n");
#line 439
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 440
    goto switch_break;
  }
  {
#line 442
  printf((char const   */* __restrict  */)"      MD5 logical unit identifier:\n");
#line 443
  dStrHex((char const   *)ip, i_len, 0);
  }
#line 444
  goto switch_break;
  case_8: /* CIL Label */ 
#line 446
  if (3 != c_set) {
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      << expected UTF-8 code_set>>\n");
#line 448
    dStrHex((char const   *)ip, i_len, 0);
    }
#line 449
    goto switch_break;
  }
  {
#line 451
  printf((char const   */* __restrict  */)"      SCSI name string:\n");
#line 456
  printf((char const   */* __restrict  */)"      %s\n", (char const   *)ip);
  }
#line 457
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 459
  dStrHex((char const   *)ip, i_len, 0);
  }
#line 460
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 462
  return;
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_dev_ids(char const   *print_if_found , unsigned char *buff , int len ,
                          int m_assoc , int m_desig_type , int m_code_set , int long_out ,
                          int quiet ) 
{ 
  int i_len ;
  int assoc ;
  int printed ;
  int off ;
  int u ;
  unsigned char const   *ucp ;
  int tmp ;

  {
#line 474
  if (quiet) {
    {
#line 475
    tmp = decode_dev_ids_quiet(buff, len, m_assoc, m_desig_type, m_code_set);
    }
#line 475
    return (tmp);
  }
#line 477
  off = -1;
#line 478
  printed = 0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 479
    u = sg_vpd_dev_id_iter((unsigned char const   *)buff, len, & off, m_assoc, m_desig_type,
                           m_code_set);
    }
#line 479
    if (! (u == 0)) {
#line 479
      goto while_break;
    }
#line 481
    ucp = (unsigned char const   *)(buff + off);
#line 482
    i_len = (int )*(ucp + 3);
#line 483
    if ((off + i_len) + 4 > len) {
      {
#line 484
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    VPD page error: designator length longer than\n     remaining response length=%d\n",
              len - off);
      }
#line 486
      return (97);
    }
#line 488
    assoc = (int )(((int const   )*(ucp + 1) >> 4) & 3);
#line 489
    if (print_if_found) {
#line 489
      if (0 == printed) {
        {
#line 490
        printed = 1;
#line 491
        printf((char const   */* __restrict  */)"  %s:\n", print_if_found);
        }
      }
    }
#line 493
    if ((unsigned long )((void *)0) == (unsigned long )print_if_found) {
      {
#line 494
      printf((char const   */* __restrict  */)"  %s:\n", sdparm_assoc_arr[assoc]);
      }
    }
    {
#line 495
    decode_designation_descriptor(ucp, i_len, long_out, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  if (-2 == u) {
    {
#line 498
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"VPD page error: short designator around offset %d\n",
            off);
    }
#line 500
    return (97);
  }
#line 502
  return (0);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_mode_policy_vpd(unsigned char *buff , int len ) 
{ 
  int k ;
  int bump ;
  unsigned char *ucp ;

  {
#line 512
  if (len < 4) {
    {
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mode page policy VPD page length too short=%d\n",
            len);
    }
#line 515
    return (97);
  }
#line 517
  len -= 4;
#line 518
  ucp = buff + 4;
#line 519
  k = 0;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! (k < len)) {
#line 519
      goto while_break;
    }
#line 520
    bump = 4;
#line 521
    if (k + bump > len) {
      {
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mode page policy VPD page, short descriptor length=%d, left=%d\n",
              bump, len - k);
      }
#line 524
      return (97);
    }
    {
#line 526
    printf((char const   */* __restrict  */)"  Policy page code: 0x%x", (int )*(ucp + 0) & 63);
    }
#line 527
    if (*(ucp + 1)) {
      {
#line 528
      printf((char const   */* __restrict  */)",  subpage code: 0x%x\n", (int )*(ucp + 1));
      }
    } else {
      {
#line 530
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 531
    printf((char const   */* __restrict  */)"    MLUS=%d,  Policy: %s\n", ! (! ((int )*(ucp + 2) & 128)),
           sdparm_mode_page_policy_arr[(int )*(ucp + 2) & 3]);
#line 519
    k += bump;
#line 519
    ucp += bump;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return (0);
}
}
#line 538 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_man_net_vpd(unsigned char *buff , int len ) 
{ 
  int k ;
  int bump ;
  int na_len ;
  unsigned char *ucp ;

  {
#line 544
  if (len < 4) {
    {
#line 545
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Management network addresses VPD page length too short=%d\n",
            len);
    }
#line 547
    return (97);
  }
#line 549
  len -= 4;
#line 550
  ucp = buff + 4;
#line 551
  k = 0;
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 551
    if (! (k < len)) {
#line 551
      goto while_break;
    }
    {
#line 552
    printf((char const   */* __restrict  */)"  %s, Service type: %s\n", sdparm_assoc_arr[((int )*(ucp + 0) >> 5) & 3],
           sdparm_network_service_type_arr[(int )*(ucp + 0) & 31]);
#line 555
    na_len = ((int )*(ucp + 2) << 8) + (int )*(ucp + 3);
#line 556
    bump = 4 + na_len;
    }
#line 557
    if (k + bump > len) {
      {
#line 558
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Management network addresses VPD page, short descriptor length=%d, left=%d\n",
              bump, len - k);
      }
#line 560
      return (97);
    }
#line 562
    if (na_len > 0) {
      {
#line 563
      printf((char const   */* __restrict  */)"    %s\n", ucp + 4);
      }
    }
#line 551
    k += bump;
#line 551
    ucp += bump;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return (0);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_proto_lu_vpd(unsigned char *buff , int len ) 
{ 
  int k ;
  int bump ;
  int rel_port ;
  int desc_len ;
  int proto ;
  unsigned char *ucp ;

  {
#line 576
  if (len < 4) {
    {
#line 577
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Protocol-specific logical unit information VPD page length too short=%d\n",
            len);
    }
#line 579
    return (97);
  }
#line 581
  len -= 4;
#line 582
  ucp = buff + 4;
#line 583
  k = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (k < len)) {
#line 583
      goto while_break;
    }
    {
#line 584
    rel_port = ((int )*(ucp + 0) << 8) + (int )*(ucp + 1);
#line 585
    printf((char const   */* __restrict  */)"Relative port=%d\n", rel_port);
#line 586
    proto = (int )*(ucp + 2) & 15;
#line 587
    desc_len = ((int )*(ucp + 6) << 8) + (int )*(ucp + 7);
#line 588
    bump = 8 + desc_len;
    }
#line 589
    if (k + bump > len) {
      {
#line 590
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Protocol-specific logical unit information VPD page, short descriptor length=%d, left=%d\n",
              bump, len - k);
      }
#line 593
      return (97);
    }
#line 595
    if (desc_len > 0) {
      {
#line 597
      if (proto == 6) {
#line 597
        goto case_6;
      }
#line 601
      goto switch_default;
      case_6: /* CIL Label */ 
      {
#line 598
      printf((char const   */* __restrict  */)" Protocol identifier: SAS\n");
#line 599
      printf((char const   */* __restrict  */)" TLR control supported: %d\n", ! (! ((int )*(ucp + 8) & 1)));
      }
#line 600
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 602
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected proto=%d\n",
              proto);
#line 603
      dStrHex((char const   *)ucp, bump, 1);
      }
#line 604
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 583
    k += bump;
#line 583
    ucp += bump;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  return (0);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_proto_port_vpd(unsigned char *buff , int len ) 
{ 
  int k ;
  int bump ;
  int rel_port ;
  int desc_len ;
  int proto ;
  unsigned char *ucp ;

  {
#line 618
  if (len < 4) {
    {
#line 619
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Protocol-specific port information VPD page length too short=%d\n",
            len);
    }
#line 621
    return (97);
  }
#line 623
  len -= 4;
#line 624
  ucp = buff + 4;
#line 625
  k = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (! (k < len)) {
#line 625
      goto while_break;
    }
    {
#line 626
    rel_port = ((int )*(ucp + 0) << 8) + (int )*(ucp + 1);
#line 627
    printf((char const   */* __restrict  */)"Relative port=%d\n", rel_port);
#line 628
    proto = (int )*(ucp + 2) & 15;
#line 629
    desc_len = ((int )*(ucp + 6) << 8) + (int )*(ucp + 7);
#line 630
    bump = 8 + desc_len;
    }
#line 631
    if (k + bump > len) {
      {
#line 632
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Protocol-specific port information VPD page, short descriptor length=%d, left=%d\n",
              bump, len - k);
      }
#line 635
      return (97);
    }
#line 637
    if (desc_len > 0) {
      {
#line 640
      goto switch_default;
      switch_default: /* CIL Label */ 
      {
#line 641
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected proto=%d\n",
              proto);
#line 642
      dStrHex((char const   *)ucp, bump, 1);
      }
#line 643
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 625
    k += bump;
#line 625
    ucp += bump;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  return (0);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_scsi_ports_vpd(unsigned char *buff , int len , int long_out , int quiet ) 
{ 
  int k ;
  int bump ;
  int rel_port ;
  int ip_tid_len ;
  int tpd_len ;
  int res ;
  unsigned char *ucp ;

  {
#line 657
  if (len < 4) {
    {
#line 658
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SCSI Ports VPD page length too short=%d\n",
            len);
    }
#line 659
    return (97);
  }
#line 661
  len -= 4;
#line 662
  ucp = buff + 4;
#line 663
  k = 0;
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 663
    if (! (k < len)) {
#line 663
      goto while_break;
    }
    {
#line 664
    rel_port = ((int )*(ucp + 2) << 8) + (int )*(ucp + 3);
#line 665
    printf((char const   */* __restrict  */)"Relative port=%d\n", rel_port);
#line 666
    ip_tid_len = ((int )*(ucp + 6) << 8) + (int )*(ucp + 7);
#line 667
    bump = 8 + ip_tid_len;
    }
#line 668
    if (k + bump > len) {
      {
#line 669
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SCSI Ports VPD page, short descriptor length=%d, left=%d\n",
              bump, len - k);
      }
#line 671
      return (97);
    }
#line 673
    if (ip_tid_len > 0) {
      {
#line 680
      printf((char const   */* __restrict  */)" Initiator port transport id:\n");
#line 681
      dStrHex((char const   *)(ucp + 8), ip_tid_len, 1);
      }
    }
#line 683
    tpd_len = ((int )*(ucp + (bump + 2)) << 8) + (int )*(ucp + (bump + 3));
#line 684
    if (((k + bump) + tpd_len) + 4 > len) {
      {
#line 685
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SCSI Ports VPD page, short descriptor(tgt) length=%d, left=%d\n",
              bump, len - k);
      }
#line 687
      return (97);
    }
#line 689
    if (tpd_len > 0) {
      {
#line 690
      res = decode_dev_ids(" Target port descriptor(s)", (ucp + bump) + 4, tpd_len,
                           1, -1, -1, long_out, quiet);
      }
#line 693
      if (res) {
#line 694
        return (res);
      }
    }
#line 696
    bump += tpd_len + 4;
#line 663
    k += bump;
#line 663
    ucp += bump;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return (0);
}
}
#line 702 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_ext_inq_vpd(unsigned char *b , int len , int long_out , int protect ) 
{ 
  int n ;

  {
#line 707
  if (len < 7) {
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extended INQUIRY data VPD page length too short=%d\n",
            len);
    }
#line 710
    return (97);
  }
#line 712
  if (long_out) {
    {
#line 713
    n = ((int )*(b + 4) >> 6) & 3;
#line 714
    printf((char const   */* __restrict  */)"  ACTIVATE_MICROCODE=%d", n);
    }
#line 715
    if (1 == n) {
      {
#line 716
      printf((char const   */* __restrict  */)" [before final WRITE BUFFER]\n");
      }
    } else
#line 717
    if (2 == n) {
      {
#line 718
      printf((char const   */* __restrict  */)" [after power on or hard reset]\n");
      }
    } else {
      {
#line 720
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 721
    n = ((int )*(b + 4) >> 3) & 7;
#line 722
    printf((char const   */* __restrict  */)"  SPT=%d", n);
    }
#line 723
    if (protect) {
      {
#line 726
      if (n == 0) {
#line 726
        goto case_0;
      }
#line 729
      if (n == 1) {
#line 729
        goto case_1;
      }
#line 732
      if (n == 2) {
#line 732
        goto case_2;
      }
#line 735
      if (n == 3) {
#line 735
        goto case_3;
      }
#line 738
      if (n == 4) {
#line 738
        goto case_4;
      }
#line 741
      if (n == 5) {
#line 741
        goto case_5;
      }
#line 744
      if (n == 7) {
#line 744
        goto case_7;
      }
#line 747
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 727
      printf((char const   */* __restrict  */)" [protection type 1 supported]\n");
      }
#line 728
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 730
      printf((char const   */* __restrict  */)" [protection types 1 and 2 supported]\n");
      }
#line 731
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 733
      printf((char const   */* __restrict  */)" [protection type 2 supported]\n");
      }
#line 734
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 736
      printf((char const   */* __restrict  */)" [protection types 1 and 3 supported]\n");
      }
#line 737
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 739
      printf((char const   */* __restrict  */)" [protection type 3 supported]\n");
      }
#line 740
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 742
      printf((char const   */* __restrict  */)" [protection types 2 and 3 supported]\n");
      }
#line 743
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 745
      printf((char const   */* __restrict  */)" [protection types 1, 2 and 3 supported]\n");
      }
#line 746
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 748
      printf((char const   */* __restrict  */)"\n");
      }
#line 749
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 752
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 753
    printf((char const   */* __restrict  */)"  GRD_CHK=%d\n", ! (! ((int )*(b + 4) & 4)));
#line 754
    printf((char const   */* __restrict  */)"  APP_CHK=%d\n", ! (! ((int )*(b + 4) & 2)));
#line 755
    printf((char const   */* __restrict  */)"  REF_CHK=%d\n", ! (! ((int )*(b + 4) & 1)));
#line 756
    printf((char const   */* __restrict  */)"  UASK_SUP=%d\n", ! (! ((int )*(b + 5) & 32)));
#line 757
    printf((char const   */* __restrict  */)"  GROUP_SUP=%d\n", ! (! ((int )*(b + 5) & 16)));
#line 758
    printf((char const   */* __restrict  */)"  PRIOR_SUP=%d\n", ! (! ((int )*(b + 5) & 8)));
#line 759
    printf((char const   */* __restrict  */)"  HEADSUP=%d\n", ! (! ((int )*(b + 5) & 4)));
#line 760
    printf((char const   */* __restrict  */)"  ORDSUP=%d\n", ! (! ((int )*(b + 5) & 2)));
#line 761
    printf((char const   */* __restrict  */)"  SIMPSUP=%d\n", ! (! ((int )*(b + 5) & 1)));
#line 762
    printf((char const   */* __restrict  */)"  WU_SUP=%d\n", ! (! ((int )*(b + 6) & 8)));
#line 763
    printf((char const   */* __restrict  */)"  CRD_SUP=%d\n", ! (! ((int )*(b + 6) & 4)));
#line 764
    printf((char const   */* __restrict  */)"  NV_SUP=%d\n", ! (! ((int )*(b + 6) & 2)));
#line 765
    printf((char const   */* __restrict  */)"  V_SUP=%d\n", ! (! ((int )*(b + 6) & 1)));
#line 766
    printf((char const   */* __restrict  */)"  P_I_I_SUP=%d\n", ! (! ((int )*(b + 7) & 16)));
#line 767
    printf((char const   */* __restrict  */)"  LUICLR=%d\n", ! (! ((int )*(b + 7) & 1)));
#line 768
    printf((char const   */* __restrict  */)"  R_SUP=%d\n", ! (! ((int )*(b + 8) & 16)));
#line 769
    printf((char const   */* __restrict  */)"  CBCS=%d\n", ! (! ((int )*(b + 8) & 1)));
#line 770
    printf((char const   */* __restrict  */)"  Multi I_T nexus microcode download=%d\n",
           (int )*(b + 9) & 15);
#line 771
    printf((char const   */* __restrict  */)"  Extended self-test completion minutes=%d\n",
           ((int )*(b + 10) << 8) + (int )*(b + 11));
#line 773
    printf((char const   */* __restrict  */)"  POA_SUP=%d\n", ! (! ((int )*(b + 12) & 128)));
#line 774
    printf((char const   */* __restrict  */)"  HRA_SUP=%d\n", ! (! ((int )*(b + 12) & 64)));
#line 775
    printf((char const   */* __restrict  */)"  VSA_SUP=%d\n", ! (! ((int )*(b + 12) & 32)));
    }
  } else {
    {
#line 777
    printf((char const   */* __restrict  */)"  ACTIVATE_MICROCODE=%d SPT=%d GRD_CHK=%d APP_CHK=%d REF_CHK=%d\n",
           ((int )*(b + 4) >> 6) & 3, ((int )*(b + 4) >> 3) & 7, ! (! ((int )*(b + 4) & 4)),
           ! (! ((int )*(b + 4) & 2)), ! (! ((int )*(b + 4) & 1)));
#line 780
    printf((char const   */* __restrict  */)"  UASK_SUP=%d GROUP_SUP=%d PRIOR_SUP=%d HEADSUP=%d ORDSUP=%d SIMPSUP=%d\n",
           ! (! ((int )*(b + 5) & 32)), ! (! ((int )*(b + 5) & 16)), ! (! ((int )*(b + 5) & 8)),
           ! (! ((int )*(b + 5) & 4)), ! (! ((int )*(b + 5) & 2)), ! (! ((int )*(b + 5) & 1)));
#line 784
    printf((char const   */* __restrict  */)"  WU_SUP=%d CRD_SUP=%d NV_SUP=%d V_SUP=%d\n",
           ! (! ((int )*(b + 6) & 8)), ! (! ((int )*(b + 6) & 4)), ! (! ((int )*(b + 6) & 2)),
           ! (! ((int )*(b + 6) & 1)));
#line 787
    printf((char const   */* __restrict  */)"  P_I_I_SUP=%d LUICLR=%d R_SUP=%d CBCS=%d\n",
           ! (! ((int )*(b + 7) & 16)), ! (! ((int )*(b + 7) & 1)), ! (! ((int )*(b + 8) & 16)),
           ! (! ((int )*(b + 8) & 1)));
#line 790
    printf((char const   */* __restrict  */)"  Multi I_T nexus microcode download=%d\n",
           (int )*(b + 9) & 15);
#line 791
    printf((char const   */* __restrict  */)"  Extended self-test completion minutes=%d\n",
           ((int )*(b + 10) << 8) + (int )*(b + 11));
#line 793
    printf((char const   */* __restrict  */)"  POA_SUP=%d HRA_SUP=%d VSA_SUP=%d\n",
           ! (! ((int )*(b + 12) & 128)), ! (! ((int )*(b + 12) & 64)), ! (! ((int )*(b + 12) & 32)));
    }
  }
#line 796
  return (0);
}
}
#line 800 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_ata_info_vpd(unsigned char *buff , int len , int long_out , int do_hex ) 
{ 
  char b[80] ;
  int num ;
  int is_be ;
  char const   *cp ;

  {
#line 807
  if (len < 36) {
    {
#line 808
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ATA information VPD page length too short=%d\n",
            len);
    }
#line 810
    return (97);
  }
  {
#line 812
  memcpy((void */* __restrict  */)(b), (void const   */* __restrict  */)(buff + 8),
         (size_t )8);
#line 813
  b[8] = (char )'\000';
#line 814
  printf((char const   */* __restrict  */)"  SAT Vendor identification: %s\n", b);
#line 815
  memcpy((void */* __restrict  */)(b), (void const   */* __restrict  */)(buff + 16),
         (size_t )16);
#line 816
  b[16] = (char )'\000';
#line 817
  printf((char const   */* __restrict  */)"  SAT Product identification: %s\n", b);
#line 818
  memcpy((void */* __restrict  */)(b), (void const   */* __restrict  */)(buff + 32),
         (size_t )4);
#line 819
  b[4] = (char )'\000';
#line 820
  printf((char const   */* __restrict  */)"  SAT Product revision level: %s\n", b);
  }
#line 821
  if (len < 56) {
#line 822
    return (97);
  }
#line 823
  if (long_out) {
    {
#line 824
    printf((char const   */* __restrict  */)"  Signature (Device to host FIS):\n");
#line 825
    dStrHex((char const   *)buff + 36, 20, 1);
    }
  }
#line 827
  if (len < 60) {
#line 828
    return (97);
  }
  {
#line 829
  is_be = sg_is_big_endian();
  }
#line 830
  if (236 == (int )*(buff + 56)) {
#line 830
    goto _L;
  } else
#line 830
  if (161 == (int )*(buff + 56)) {
    _L: /* CIL Label */ 
#line 831
    if (161 == (int )*(buff + 56)) {
#line 831
      cp = "PACKET ";
    } else {
#line 831
      cp = "";
    }
    {
#line 832
    printf((char const   */* __restrict  */)"  ATA command IDENTIFY %sDEVICE response summary:\n",
           cp);
#line 833
    num = sg_ata_get_chars((unsigned short const   *)(buff + 60), 27, 20, is_be, b);
#line 835
    b[num] = (char )'\000';
#line 836
    printf((char const   */* __restrict  */)"    model: %s\n", b);
#line 837
    num = sg_ata_get_chars((unsigned short const   *)(buff + 60), 10, 10, is_be, b);
#line 839
    b[num] = (char )'\000';
#line 840
    printf((char const   */* __restrict  */)"    serial number: %s\n", b);
#line 841
    num = sg_ata_get_chars((unsigned short const   *)(buff + 60), 23, 4, is_be, b);
#line 843
    b[num] = (char )'\000';
#line 844
    printf((char const   */* __restrict  */)"    firmware revision: %s\n", b);
    }
#line 845
    if (long_out) {
      {
#line 846
      printf((char const   */* __restrict  */)"  ATA command IDENTIFY %sDEVICE response in hex:\n",
             cp);
      }
    }
  } else
#line 847
  if (long_out) {
    {
#line 848
    printf((char const   */* __restrict  */)"  ATA command 0x%x got following response:\n",
           (unsigned int )*(buff + 56));
    }
  }
#line 850
  if (len < 572) {
#line 851
    return (97);
  }
#line 852
  if (do_hex) {
    {
#line 853
    dStrHex((char const   *)(buff + 60), 512, 0);
    }
  } else
#line 854
  if (long_out) {
    {
#line 855
    dWordHex((unsigned short const   *)(buff + 60), 256, 0, is_be);
    }
  }
#line 856
  return (0);
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_power_condition(unsigned char *buff , int len ) 
{ 


  {
#line 863
  if (len < 18) {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Power condition VPD page length too short=%d\n",
            len);
    }
#line 866
    return (97);
  }
  {
#line 868
  printf((char const   */* __restrict  */)"  Standby_y=%d Standby_z=%d Idle_c=%d Idle_b=%d Idle_a=%d\n",
         ! (! ((int )*(buff + 4) & 2)), ! (! ((int )*(buff + 4) & 1)), ! (! ((int )*(buff + 5) & 4)),
         ! (! ((int )*(buff + 5) & 2)), ! (! ((int )*(buff + 5) & 1)));
#line 871
  printf((char const   */* __restrict  */)"  Stopped condition recovery time (ms) %d\n",
         ((int )*(buff + 6) << 8) + (int )*(buff + 7));
#line 873
  printf((char const   */* __restrict  */)"  Standby_z condition recovery time (ms) %d\n",
         ((int )*(buff + 8) << 8) + (int )*(buff + 9));
#line 875
  printf((char const   */* __restrict  */)"  Standby_y condition recovery time (ms) %d\n",
         ((int )*(buff + 10) << 8) + (int )*(buff + 11));
#line 877
  printf((char const   */* __restrict  */)"  Idle_a condition recovery time (ms) %d\n",
         ((int )*(buff + 12) << 8) + (int )*(buff + 13));
#line 879
  printf((char const   */* __restrict  */)"  Idle_b condition recovery time (ms) %d\n",
         ((int )*(buff + 14) << 8) + (int )*(buff + 15));
#line 881
  printf((char const   */* __restrict  */)"  Idle_c condition recovery time (ms) %d\n",
         ((int )*(buff + 16) << 8) + (int )*(buff + 17));
  }
#line 883
  return (0);
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static char const   *power_unit_arr[8]  = 
#line 886
  {      "Gigawatts",      "Megawatts",      "Kilowatts",      "Watts", 
        "Milliwatts",      "Microwatts",      "Unit reserved",      "Unit reserved"};
#line 899 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_power_consumption_vpd(unsigned char *buff , int len ) 
{ 
  int k ;
  int bump ;
  unsigned char *ucp ;
  unsigned int value ;

  {
#line 906
  if (len < 4) {
    {
#line 907
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Power consumption VPD page length too short=%d\n",
            len);
    }
#line 909
    return (97);
  }
#line 911
  len -= 4;
#line 912
  ucp = buff + 4;
#line 913
  k = 0;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! (k < len)) {
#line 913
      goto while_break;
    }
#line 914
    bump = 4;
#line 915
    if (k + bump > len) {
      {
#line 916
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Power consumption VPD page, short descriptor length=%d, left=%d\n",
              bump, len - k);
      }
#line 918
      return (97);
    }
    {
#line 920
    value = (unsigned int )(((int )*(ucp + 2) << 8) + (int )*(ucp + 3));
#line 921
    printf((char const   */* __restrict  */)"  Power consumption identifier: 0x%x",
           (int )*(ucp + 0));
    }
#line 922
    if (value >= 1000U) {
#line 922
      if (((int )*(ucp + 1) & 7) > 0) {
        {
#line 923
        printf((char const   */* __restrict  */)"    Maximum power consumption: %d.%03d %s\n",
               value / 1000U, value % 1000U, power_unit_arr[((int )*(ucp + 1) & 7) - 1]);
        }
      } else {
        {
#line 927
        printf((char const   */* __restrict  */)"    Maximum power consumption: %d %s\n",
               value, power_unit_arr[(int )*(ucp + 1) & 7]);
        }
      }
    } else {
      {
#line 927
      printf((char const   */* __restrict  */)"    Maximum power consumption: %d %s\n",
             value, power_unit_arr[(int )*(ucp + 1) & 7]);
      }
    }
#line 913
    k += bump;
#line 913
    ucp += bump;
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  return (0);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_block_limits_vpd(unsigned char *buff , int len ) 
{ 
  unsigned int u ;
  int m ;
  uint64_t mwsl ;

  {
#line 941
  if (len < 16) {
    {
#line 942
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Block limits VPD page length too short=%d\n",
            len);
    }
#line 944
    return (97);
  }
  {
#line 946
  printf((char const   */* __restrict  */)"  Write same no zero (WSNZ): %d\n", ! (! ((int )*(buff + 4) & 1)));
#line 947
  printf((char const   */* __restrict  */)"  Maximum compare and write length: %u blocks\n",
         (int )*(buff + 5));
#line 948
  u = (unsigned int )(((int )*(buff + 6) << 8) | (int )*(buff + 7));
#line 949
  printf((char const   */* __restrict  */)"  Optimal transfer length granularity: %u blocks\n",
         u);
#line 950
  u = ((((unsigned int )*(buff + 8) << 24) | (unsigned int )((int )*(buff + 9) << 16)) | (unsigned int )((int )*(buff + 10) << 8)) | (unsigned int )*(buff + 11);
#line 952
  printf((char const   */* __restrict  */)"  Maximum transfer length: %u blocks\n",
         u);
#line 953
  u = ((((unsigned int )*(buff + 12) << 24) | (unsigned int )((int )*(buff + 13) << 16)) | (unsigned int )((int )*(buff + 14) << 8)) | (unsigned int )*(buff + 15);
#line 955
  printf((char const   */* __restrict  */)"  Optimal transfer length: %u blocks\n",
         u);
  }
#line 956
  if (len > 19) {
    {
#line 957
    u = ((((unsigned int )*(buff + 16) << 24) | (unsigned int )((int )*(buff + 17) << 16)) | (unsigned int )((int )*(buff + 18) << 8)) | (unsigned int )*(buff + 19);
#line 959
    printf((char const   */* __restrict  */)"  Maximum prefetch, xdread, xdwrite transfer length: %u blocks\n",
           u);
    }
  }
#line 962
  if (len > 27) {
    {
#line 963
    u = ((((unsigned int )*(buff + 20) << 24) | (unsigned int )((int )*(buff + 21) << 16)) | (unsigned int )((int )*(buff + 22) << 8)) | (unsigned int )*(buff + 23);
#line 965
    printf((char const   */* __restrict  */)"  Maximum unmap LBA count: %u\n", u);
#line 966
    u = ((((unsigned int )*(buff + 24) << 24) | (unsigned int )((int )*(buff + 25) << 16)) | (unsigned int )((int )*(buff + 26) << 8)) | (unsigned int )*(buff + 27);
#line 968
    printf((char const   */* __restrict  */)"  Maximum unmap block descriptor count: %u\n",
           u);
    }
  }
#line 970
  if (len > 35) {
    {
#line 971
    u = ((((unsigned int )*(buff + 28) << 24) | (unsigned int )((int )*(buff + 29) << 16)) | (unsigned int )((int )*(buff + 30) << 8)) | (unsigned int )*(buff + 31);
#line 973
    printf((char const   */* __restrict  */)"  Optimal unmap granularity: %u\n", u);
#line 974
    printf((char const   */* __restrict  */)"  Unmap granularity alignment valid: %u\n",
           ! (! ((int )*(buff + 32) & 128)));
#line 976
    u = ((((unsigned int )((int )*(buff + 32) & 127) << 24) | (unsigned int )((int )*(buff + 33) << 16)) | (unsigned int )((int )*(buff + 34) << 8)) | (unsigned int )*(buff + 35);
#line 978
    printf((char const   */* __restrict  */)"  Unmap granularity alignment: %u\n",
           u);
    }
  }
#line 980
  if (len > 43) {
#line 981
    mwsl = (uint64_t )0;
#line 982
    m = 0;
    {
#line 982
    while (1) {
      while_continue: /* CIL Label */ ;
#line 982
      if (! (m < 8)) {
#line 982
        goto while_break;
      }
#line 983
      if (m > 0) {
#line 984
        mwsl <<= 8;
      }
#line 985
      mwsl |= (unsigned long )*(buff + (36 + m));
#line 982
      m ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 987
    printf((char const   */* __restrict  */)"  Maximum write same length: 0x%lx blocks\n",
           mwsl);
    }
  }
#line 989
  return (0);
}
}
#line 993 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_block_dev_chars_vpd(unsigned char *buff , int len ) 
{ 
  unsigned int u ;

  {
#line 998
  if (len < 64) {
    {
#line 999
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Block device capabilities VPD page length too short=%d\n",
            len);
    }
#line 1001
    return (97);
  }
#line 1003
  u = (unsigned int )(((int )*(buff + 4) << 8) | (int )*(buff + 5));
#line 1004
  if (0U == u) {
    {
#line 1005
    printf((char const   */* __restrict  */)"  Medium rotation rate is not reported\n");
    }
  } else
#line 1006
  if (1U == u) {
    {
#line 1007
    printf((char const   */* __restrict  */)"  Non-rotating medium (e.g. solid state)\n");
    }
  } else
#line 1008
  if (u < 1025U) {
    {
#line 1009
    printf((char const   */* __restrict  */)"  Reserved [0x%x]\n", u);
    }
  } else
#line 1008
  if (65535U == u) {
    {
#line 1009
    printf((char const   */* __restrict  */)"  Reserved [0x%x]\n", u);
    }
  } else {
    {
#line 1011
    printf((char const   */* __restrict  */)"  Nominal rotation rate: %d rpm\n", u);
    }
  }
  {
#line 1012
  u = (unsigned int )((int )*(buff + 7) & 15);
#line 1013
  printf((char const   */* __restrict  */)"  Nominal form factor");
  }
  {
#line 1015
  if (u == 0U) {
#line 1015
    goto case_0;
  }
#line 1018
  if (u == 1U) {
#line 1018
    goto case_1;
  }
#line 1021
  if (u == 2U) {
#line 1021
    goto case_2;
  }
#line 1024
  if (u == 3U) {
#line 1024
    goto case_3;
  }
#line 1027
  if (u == 4U) {
#line 1027
    goto case_4;
  }
#line 1030
  if (u == 5U) {
#line 1030
    goto case_5;
  }
#line 1033
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1016
  printf((char const   */* __restrict  */)" not reported\n");
  }
#line 1017
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1019
  printf((char const   */* __restrict  */)": 5.25 inch\n");
  }
#line 1020
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1022
  printf((char const   */* __restrict  */)": 3.5 inch\n");
  }
#line 1023
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1025
  printf((char const   */* __restrict  */)": 2.5 inch\n");
  }
#line 1026
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1028
  printf((char const   */* __restrict  */)": 1.8 inch\n");
  }
#line 1029
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1031
  printf((char const   */* __restrict  */)": less then 1.8 inch\n");
  }
#line 1032
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1034
  printf((char const   */* __restrict  */)": reserved\n");
  }
#line 1035
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1037
  return (0);
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_tape_dev_caps_vpd(unsigned char *buff , int len ) 
{ 


  {
#line 1044
  if (len < 6) {
    {
#line 1045
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sequential access device capabilities VPD page length too short=%d\n",
            len);
    }
#line 1047
    return (97);
  }
  {
#line 1049
  printf((char const   */* __restrict  */)"  Worm: %d\n", ! (! ((int )*(buff + 4) & 1)));
  }
#line 1050
  return (0);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_tape_man_ass_sn_vpd(unsigned char *buff , int len ) 
{ 


  {
#line 1057
  if (len < 64) {
    {
#line 1058
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Manufacturer-assigned serial number VPD page length too short=%d\n",
            len);
    }
#line 1060
    return (97);
  }
  {
#line 1062
  printf((char const   */* __restrict  */)"  Manufacturer-assigned serial number: %.*s\n",
         len - 4, buff + 4);
  }
#line 1064
  return (0);
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_block_lb_prov_vpd(unsigned char *b , int len ) 
{ 
  int dp ;
  unsigned char const   *ucp ;
  int i_len ;

  {
#line 1073
  if (len < 4) {
    {
#line 1074
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Logical block provisioning page too short=%d\n",
            len);
    }
#line 1076
    return (97);
  }
  {
#line 1078
  printf((char const   */* __restrict  */)"  Unmap command supported (LBPU): %d\n",
         ! (! (128 & (int )*(b + 5))));
#line 1079
  printf((char const   */* __restrict  */)"  Write same (16) with unmap bit supported (LBWS): %d\n",
         ! (! (64 & (int )*(b + 5))));
#line 1081
  printf((char const   */* __restrict  */)"  Write same (10) with unmap bit supported (LBWS10): %d\n",
         ! (! (32 & (int )*(b + 5))));
#line 1083
  printf((char const   */* __restrict  */)"  Logical block provisioning read zeros (LBPRZ): %d\n",
         ! (! (4 & (int )*(b + 5))));
#line 1085
  printf((char const   */* __restrict  */)"  Anchored LBAs supported (ANC_SUP): %d\n",
         ! (! (2 & (int )*(b + 5))));
#line 1086
  printf((char const   */* __restrict  */)"  Threshold exponent: %d\n", (int )*(b + 4));
#line 1087
  dp = ! (! ((int )*(b + 5) & 1));
#line 1088
  printf((char const   */* __restrict  */)"  Descriptor present: %d\n", dp);
#line 1089
  printf((char const   */* __restrict  */)"  Provisioning type: %d\n", (int )*(b + 6) & 7);
  }
#line 1090
  if (dp) {
#line 1094
    ucp = (unsigned char const   *)(b + 8);
#line 1095
    i_len = (int )*(ucp + 3);
#line 1096
    if (0 == i_len) {
      {
#line 1097
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Logical block provisioning page provisioning group descriptor too short=%d\n",
              i_len);
      }
#line 1099
      return (0);
    }
    {
#line 1101
    printf((char const   */* __restrict  */)"  Provisioning group descriptor\n");
#line 1102
    decode_designation_descriptor(ucp, i_len, 0, 1);
    }
  }
#line 1104
  return (0);
}
}
#line 1108 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_tapealert_supported_vpd(unsigned char *b , int len ) 
{ 


  {
#line 1111
  if (len < 12) {
    {
#line 1112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"TapeAlert supported flags length too short=%d\n",
            len);
    }
#line 1114
    return (97);
  }
  {
#line 1116
  printf((char const   */* __restrict  */)"  Flag01h: %d  02h: %d  03h: %d  04h: %d  05h: %d  06h: %d  07h: %d  08h: %d\n",
         ! (! ((int )*(b + 4) & 128)), ! (! ((int )*(b + 4) & 64)), ! (! ((int )*(b + 4) & 32)),
         ! (! ((int )*(b + 4) & 16)), ! (! ((int )*(b + 4) & 8)), ! (! ((int )*(b + 4) & 4)),
         ! (! ((int )*(b + 4) & 2)), ! (! ((int )*(b + 4) & 1)));
#line 1120
  printf((char const   */* __restrict  */)"  Flag09h: %d  0ah: %d  0bh: %d  0ch: %d  0dh: %d  0eh: %d  0fh: %d  10h: %d\n",
         ! (! ((int )*(b + 5) & 128)), ! (! ((int )*(b + 5) & 64)), ! (! ((int )*(b + 5) & 32)),
         ! (! ((int )*(b + 5) & 16)), ! (! ((int )*(b + 5) & 8)), ! (! ((int )*(b + 5) & 4)),
         ! (! ((int )*(b + 5) & 2)), ! (! ((int )*(b + 5) & 1)));
#line 1124
  printf((char const   */* __restrict  */)"  Flag11h: %d  12h: %d  13h: %d  14h: %d  15h: %d  16h: %d  17h: %d  18h: %d\n",
         ! (! ((int )*(b + 6) & 128)), ! (! ((int )*(b + 6) & 64)), ! (! ((int )*(b + 6) & 32)),
         ! (! ((int )*(b + 6) & 16)), ! (! ((int )*(b + 6) & 8)), ! (! ((int )*(b + 6) & 4)),
         ! (! ((int )*(b + 6) & 2)), ! (! ((int )*(b + 6) & 1)));
#line 1128
  printf((char const   */* __restrict  */)"  Flag19h: %d  1ah: %d  1bh: %d  1ch: %d  1dh: %d  1eh: %d  1fh: %d  20h: %d\n",
         ! (! ((int )*(b + 7) & 128)), ! (! ((int )*(b + 7) & 64)), ! (! ((int )*(b + 7) & 32)),
         ! (! ((int )*(b + 7) & 16)), ! (! ((int )*(b + 7) & 8)), ! (! ((int )*(b + 7) & 4)),
         ! (! ((int )*(b + 7) & 2)), ! (! ((int )*(b + 7) & 1)));
#line 1132
  printf((char const   */* __restrict  */)"  Flag21h: %d  22h: %d  23h: %d  24h: %d  25h: %d  26h: %d  27h: %d  28h: %d\n",
         ! (! ((int )*(b + 8) & 128)), ! (! ((int )*(b + 8) & 64)), ! (! ((int )*(b + 8) & 32)),
         ! (! ((int )*(b + 8) & 16)), ! (! ((int )*(b + 8) & 8)), ! (! ((int )*(b + 8) & 4)),
         ! (! ((int )*(b + 8) & 2)), ! (! ((int )*(b + 8) & 1)));
#line 1136
  printf((char const   */* __restrict  */)"  Flag29h: %d  2ah: %d  2bh: %d  2ch: %d  2dh: %d  2eh: %d  2fh: %d  30h: %d\n",
         ! (! ((int )*(b + 9) & 128)), ! (! ((int )*(b + 9) & 64)), ! (! ((int )*(b + 9) & 32)),
         ! (! ((int )*(b + 9) & 16)), ! (! ((int )*(b + 9) & 8)), ! (! ((int )*(b + 9) & 4)),
         ! (! ((int )*(b + 9) & 2)), ! (! ((int )*(b + 9) & 1)));
#line 1140
  printf((char const   */* __restrict  */)"  Flag31h: %d  32h: %d  33h: %d  34h: %d  35h: %d  36h: %d  37h: %d  38h: %d\n",
         ! (! ((int )*(b + 10) & 128)), ! (! ((int )*(b + 10) & 64)), ! (! ((int )*(b + 10) & 32)),
         ! (! ((int )*(b + 10) & 16)), ! (! ((int )*(b + 10) & 8)), ! (! ((int )*(b + 10) & 4)),
         ! (! ((int )*(b + 10) & 2)), ! (! ((int )*(b + 10) & 1)));
#line 1144
  printf((char const   */* __restrict  */)"  Flag39h: %d  3ah: %d  3bh: %d  3ch: %d  3dh: %d  3eh: %d  3fh: %d  40h: %d\n",
         ! (! ((int )*(b + 11) & 128)), ! (! ((int )*(b + 11) & 64)), ! (! ((int )*(b + 11) & 32)),
         ! (! ((int )*(b + 11) & 16)), ! (! ((int )*(b + 11) & 8)), ! (! ((int )*(b + 11) & 4)),
         ! (! ((int )*(b + 11) & 2)), ! (! ((int )*(b + 11) & 1)));
  }
#line 1148
  return (0);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_referrals_vpd(unsigned char *b , int len ) 
{ 
  unsigned int u ;

  {
#line 1157
  if (len < 16) {
    {
#line 1158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Referrals VPD page length too short=%d\n",
            len);
    }
#line 1159
    return (97);
  }
  {
#line 1161
  u = ((((unsigned int )*(b + 8) << 24) | (unsigned int )((int )*(b + 9) << 16)) | (unsigned int )((int )*(b + 10) << 8)) | (unsigned int )*(b + 11);
#line 1162
  printf((char const   */* __restrict  */)"  User data segment size: %u\n", u);
#line 1163
  u = ((((unsigned int )*(b + 12) << 24) | (unsigned int )((int )*(b + 13) << 16)) | (unsigned int )((int )*(b + 14) << 8)) | (unsigned int )*(b + 15);
#line 1165
  printf((char const   */* __restrict  */)"  User data segment multiplier: %u\n",
         u);
  }
#line 1166
  return (0);
}
}
#line 1170 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
char const   *sg_ansi_version_arr[16]  = 
#line 1170
  {      "no conformance claimed",      "SCSI-1",      "SCSI-2",      "SPC", 
        "SPC-2",      "SPC-3",      "SPC-4",      "reserved [7h]", 
        "ecma=1, [8h]",      "ecma=1, [9h]",      "ecma=1, [Ah]",      "ecma=1, [Bh]", 
        "reserved [Ch]",      "reserved [Dh]",      "reserved [Eh]",      "reserved [Fh]"};
#line 1190 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
static int decode_std_inq(int sg_fd , struct sdparm_opt_coll  const  *opts ) 
{ 
  int res ;
  int verb ;
  int sz ;
  int len ;
  int pqual ;
  unsigned char b[252] ;

  {
#line 1196
  if (opts->verbose > 0) {
#line 1196
    verb = (int )(opts->verbose - 1);
  } else {
#line 1196
    verb = 0;
  }
  {
#line 1197
  sz = (int )sizeof(b);
#line 1198
  memset((void *)(b), 0, sizeof(b));
  }
#line 1199
  if (opts->long_out) {
#line 1199
    sz = (int )sizeof(b);
  } else {
#line 1199
    sz = 36;
  }
  {
#line 1200
  res = sg_ll_inquiry(sg_fd, 0, 0, 0, (void *)(b), sz, 0, verb);
  }
#line 1201
  if (res) {
    {
#line 1202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INQUIRY fetching standar response failed\n");
    }
#line 1203
    return (res);
  }
#line 1205
  pqual = ((int )b[0] & 224) >> 5;
#line 1206
  if (0 == pqual) {
    {
#line 1207
    printf((char const   */* __restrict  */)"standard INQUIRY:\n");
    }
  } else
#line 1208
  if (1 == pqual) {
    {
#line 1209
    printf((char const   */* __restrict  */)"standard INQUIRY: [qualifier indicates no connected LU]\n");
    }
  } else
#line 1211
  if (3 == pqual) {
    {
#line 1212
    printf((char const   */* __restrict  */)"standard INQUIRY: [qualifier indicates not capable of supporting LU]\n");
    }
  } else {
    {
#line 1215
    printf((char const   */* __restrict  */)"standard INQUIRY: [reserved or vendor specific qualifier [%d]]\n",
           pqual);
    }
  }
#line 1217
  len = (int )b[4] + 5;
#line 1218
  if (len <= sz) {
#line 1218
    len = len;
  } else {
#line 1218
    len = sz;
  }
#line 1219
  if (opts->hex) {
    {
#line 1220
    dStrHex((char const   *)(b), len, 0);
    }
#line 1221
    return (0);
  }
  {
#line 1223
  printf((char const   */* __restrict  */)"  PQual=%d  Device_type=%d  RMB=%d  version=0x%02x ",
         pqual, (int )b[0] & 31, ! (! ((int )b[1] & 128)), (unsigned int )b[2]);
#line 1225
  printf((char const   */* __restrict  */)" [%s]\n", sg_ansi_version_arr[(int )b[2] & 15]);
#line 1226
  printf((char const   */* __restrict  */)"  [AERC=%d]  [TrmTsk=%d]  NormACA=%d  HiSUP=%d  Resp_data_format=%d\n  SCCS=%d  ",
         ! (! ((int )b[3] & 128)), ! (! ((int )b[3] & 64)), ! (! ((int )b[3] & 32)),
         ! (! ((int )b[3] & 16)), (int )b[3] & 15, ! (! ((int )b[5] & 128)));
#line 1230
  printf((char const   */* __restrict  */)"ACC=%d  TPGS=%d  3PC=%d  Protect=%d ",
         ! (! ((int )b[5] & 64)), ((int )b[5] & 48) >> 4, ! (! ((int )b[5] & 8)),
         ! (! ((int )b[5] & 1)));
#line 1233
  printf((char const   */* __restrict  */)" BQue=%d\n  EncServ=%d  ", ! (! ((int )b[6] & 128)),
         ! (! ((int )b[6] & 64)));
  }
#line 1234
  if ((int )b[6] & 16) {
    {
#line 1235
    printf((char const   */* __restrict  */)"MultiP=1 (VS=%d)  ", ! (! ((int )b[6] & 32)));
    }
  } else {
    {
#line 1237
    printf((char const   */* __restrict  */)"MultiP=0  ");
    }
  }
  {
#line 1238
  printf((char const   */* __restrict  */)"[MChngr=%d]  [ACKREQQ=%d]  Addr16=%d\n  [RelAdr=%d]  ",
         ! (! ((int )b[6] & 8)), ! (! ((int )b[6] & 4)), ! (! ((int )b[6] & 1)), ! (! ((int )b[7] & 128)));
#line 1241
  printf((char const   */* __restrict  */)"WBus16=%d  Sync=%d  Linked=%d  [TranDis=%d]  ",
         ! (! ((int )b[7] & 32)), ! (! ((int )b[7] & 16)), ! (! ((int )b[7] & 8)),
         ! (! ((int )b[7] & 4)));
#line 1244
  printf((char const   */* __restrict  */)"CmdQue=%d\n", ! (! ((int )b[7] & 2)));
#line 1245
  printf((char const   */* __restrict  */)"  Vendor_identification: %.8s\n", b + 8);
#line 1246
  printf((char const   */* __restrict  */)"  Product_identification: %.16s\n", b + 16);
#line 1247
  printf((char const   */* __restrict  */)"  Product_revision_level: %.4s\n", b + 32);
  }
#line 1248
  return (0);
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_vpd.c"
int sdp_process_vpd_page(int sg_fd , int pn , int spn , struct sdparm_opt_coll  const  *opts ,
                         int req_pdt , int protect ) 
{ 
  int res ;
  int len ;
  int k ;
  int verb ;
  int dev_pdt ;
  int pdt ;
  unsigned char b[572] ;
  int sz ;
  unsigned char *up ;
  struct sdparm_vpd_page_t  const  *vpp ;
  char const   *vpd_name ;
  int adc ;
  int sbc ;
  int ssc ;
  int tmp ;
  int tmp___0 ;

  {
#line 1263
  adc = 0;
#line 1264
  sbc = 0;
#line 1265
  ssc = 0;
#line 1267
  if (opts->verbose > 0) {
#line 1267
    verb = (int )(opts->verbose - 1);
  } else {
#line 1267
    verb = 0;
  }
  {
#line 1268
  sz = (int )sizeof(b);
#line 1269
  memset((void *)(b), 0, (size_t )sz);
  }
#line 1270
  if (pn < 0) {
#line 1271
    if (-2 == pn) {
      {
#line 1272
      tmp = decode_std_inq(sg_fd, opts);
      }
#line 1272
      return (tmp);
    } else
#line 1273
    if (opts->all) {
#line 1274
      pn = 0;
    } else {
#line 1276
      pn = 131;
    }
  }
#line 1278
  if (137 == pn) {
#line 1278
    sz = 572;
  } else {
#line 1278
    sz = 252;
  }
  {
#line 1279
  res = sg_ll_inquiry(sg_fd, 0, 1, pn, (void *)(b), sz, 0, verb);
  }
#line 1280
  if (res) {
    {
#line 1281
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INQUIRY fetching VPD page=0x%x failed\n",
            pn);
    }
#line 1282
    return (res);
  }
#line 1284
  dev_pdt = (int )b[0] & 31;
#line 1285
  if (req_pdt >= 0) {
#line 1285
    if (req_pdt != dev_pdt) {
      {
#line 1286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"given peripheral device type [%d] differs from reported [%d]\n",
              req_pdt, dev_pdt);
#line 1288
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  start with given pdt\n");
#line 1289
      pdt = req_pdt;
      }
    } else {
#line 1291
      pdt = dev_pdt;
    }
  } else {
#line 1291
    pdt = dev_pdt;
  }
  {
#line 1294
  if (pn == 0) {
#line 1294
    goto case_0;
  }
#line 1318
  if (pn == 137) {
#line 1318
    goto case_137;
  }
#line 1344
  if (pn == 131) {
#line 1344
    goto case_131;
  }
#line 1380
  if (pn == 134) {
#line 1380
    goto case_134;
  }
#line 1401
  if (pn == 133) {
#line 1401
    goto case_133;
  }
#line 1422
  if (pn == 135) {
#line 1422
    goto case_135;
  }
#line 1443
  if (pn == 138) {
#line 1443
    goto case_138;
  }
#line 1464
  if (pn == 141) {
#line 1464
    goto case_141;
  }
#line 1485
  if (pn == 144) {
#line 1485
    goto case_144;
  }
#line 1507
  if (pn == 145) {
#line 1507
    goto case_145;
  }
#line 1529
  if (pn == 136) {
#line 1529
    goto case_136;
  }
#line 1550
  if (pn == 132) {
#line 1550
    goto case_132;
  }
#line 1575
  if (pn == 128) {
#line 1575
    goto case_128;
  }
#line 1594
  if (pn == 176) {
#line 1594
    goto case_176;
  }
#line 1638
  if (pn == 177) {
#line 1638
    goto case_177;
  }
#line 1686
  if (pn == 178) {
#line 1686
    goto case_178;
  }
#line 1722
  if (pn == 179) {
#line 1722
    goto case_179;
  }
#line 1765
  if (pn == 180) {
#line 1765
    goto case_180;
  }
#line 1789
  goto switch_default___3;
  case_0: /* CIL Label */ 
#line 1295
  if ((int )b[1] != pn) {
#line 1296
    goto dumb_inq;
  }
  {
#line 1297
  len = ((int )b[2] << 8) + (int )b[3];
#line 1298
  printf((char const   */* __restrict  */)"Supported VPD pages VPD page:\n");
  }
#line 1299
  if (opts->hex) {
    {
#line 1300
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1301
    return (0);
  }
#line 1303
  if (len > 0) {
#line 1304
    k = 0;
    {
#line 1304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1304
      if (! (k < len)) {
#line 1304
        goto while_break;
      }
      {
#line 1305
      vpp = sdp_get_vpd_detail((int )b[4 + k], -1, pdt);
      }
#line 1306
      if (vpp) {
#line 1307
        if (opts->long_out) {
          {
#line 1308
          printf((char const   */* __restrict  */)"  [0x%02x] %s [%s]\n", (int )b[4 + k],
                 vpp->name, vpp->acron);
          }
        } else {
          {
#line 1311
          printf((char const   */* __restrict  */)"  %s [%s]\n", vpp->name, vpp->acron);
          }
        }
      } else {
        {
#line 1313
        printf((char const   */* __restrict  */)"  0x%x\n", (int )b[4 + k]);
        }
      }
#line 1304
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1316
    printf((char const   */* __restrict  */)"  <empty>\n");
    }
  }
#line 1317
  goto switch_break;
  case_137: /* CIL Label */ 
#line 1319
  if ((int )b[1] != pn) {
#line 1320
    goto dumb_inq;
  }
#line 1321
  len = ((int )b[2] << 8) + (int )b[3];
#line 1322
  if (len > sz) {
    {
#line 1323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to ATA information VPD page truncated\n");
#line 1325
    len = sz;
    }
  }
#line 1327
  if (3 == (int )opts->hex) {
    {
#line 1328
    tmp___0 = sg_is_big_endian();
#line 1328
    dWordHex((unsigned short const   *)(b + 60), 256, -2, tmp___0);
    }
#line 1330
    return (0);
  }
#line 1332
  if (opts->long_out) {
    {
#line 1333
    printf((char const   */* __restrict  */)"ATA information [0x89] VPD page:\n");
    }
  } else {
    {
#line 1335
    printf((char const   */* __restrict  */)"ATA information VPD page:\n");
    }
  }
#line 1336
  if (opts->hex) {
#line 1336
    if (2 != (int )opts->hex) {
      {
#line 1337
      dStrHex((char const   *)(b), len + 4, 0);
      }
#line 1338
      return (0);
    }
  }
  {
#line 1340
  res = decode_ata_info_vpd(b, len + 4, (int )opts->long_out, (int )opts->hex);
  }
#line 1341
  if (res) {
#line 1342
    return (res);
  }
#line 1343
  goto switch_break;
  case_131: /* CIL Label */ 
#line 1345
  if ((int )b[1] != pn) {
#line 1346
    goto dumb_inq;
  }
#line 1347
  len = ((int )b[2] << 8) + (int )b[3];
#line 1348
  if (len > sz) {
    {
#line 1349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to device identification VPD page truncated\n");
#line 1351
    len = sz;
    }
  }
#line 1353
  if (opts->long_out) {
    {
#line 1354
    printf((char const   */* __restrict  */)"Device identification [0x83] VPD page:\n");
    }
  } else
#line 1355
  if (! opts->quiet) {
    {
#line 1356
    printf((char const   */* __restrict  */)"Device identification VPD page:\n");
    }
  }
#line 1357
  if (opts->hex) {
    {
#line 1358
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1359
    return (0);
  }
#line 1361
  res = 0;
#line 1362
  if (0 == spn) {
    {
#line 1363
    res = decode_dev_ids(sdparm_assoc_arr[0], b + 4, len, 0, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  } else
#line 1362
  if (1 & spn) {
    {
#line 1363
    res = decode_dev_ids(sdparm_assoc_arr[0], b + 4, len, 0, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  }
#line 1366
  if (0 == spn) {
    {
#line 1367
    res = decode_dev_ids(sdparm_assoc_arr[1], b + 4, len, 1, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  } else
#line 1366
  if (2 & spn) {
    {
#line 1367
    res = decode_dev_ids(sdparm_assoc_arr[1], b + 4, len, 1, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  }
#line 1370
  if (0 == spn) {
    {
#line 1371
    res = decode_dev_ids(sdparm_assoc_arr[2], b + 4, len, 2, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  } else
#line 1370
  if (4 & spn) {
    {
#line 1371
    res = decode_dev_ids(sdparm_assoc_arr[2], b + 4, len, 2, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  }
#line 1374
  if (32 & spn) {
    {
#line 1375
    res = decode_dev_ids((char const   *)((void *)0), b + 4, len, -1, -1, -1, (int )opts->long_out,
                         (int )opts->quiet);
    }
  }
#line 1377
  if (res) {
#line 1378
    return (res);
  }
#line 1379
  goto switch_break;
  case_134: /* CIL Label */ 
#line 1381
  if ((int )b[1] != pn) {
#line 1382
    goto dumb_inq;
  }
#line 1383
  len = ((int )b[2] << 8) + (int )b[3];
#line 1384
  if (len > sz) {
    {
#line 1385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Extended inquiry data VPD page truncated\n");
#line 1387
    len = sz;
    }
  }
#line 1389
  if (opts->long_out) {
    {
#line 1390
    printf((char const   */* __restrict  */)"Extended inquiry data [0x86] VPD page:\n");
    }
  } else
#line 1391
  if (! opts->quiet) {
    {
#line 1392
    printf((char const   */* __restrict  */)"Extended inquiry data VPD page:\n");
    }
  }
#line 1393
  if (opts->hex) {
    {
#line 1394
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1395
    return (0);
  }
  {
#line 1397
  res = decode_ext_inq_vpd(b, len + 4, (int )opts->long_out, protect);
  }
#line 1398
  if (res) {
#line 1399
    return (res);
  }
#line 1400
  goto switch_break;
  case_133: /* CIL Label */ 
#line 1402
  if ((int )b[1] != pn) {
#line 1403
    goto dumb_inq;
  }
#line 1404
  len = ((int )b[2] << 8) + (int )b[3];
#line 1405
  if (len > sz) {
    {
#line 1406
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Management network addresses VPD page truncated\n");
#line 1408
    len = sz;
    }
  }
#line 1410
  if (opts->long_out) {
    {
#line 1411
    printf((char const   */* __restrict  */)"Management network addresses [0x85] VPD page:\n");
    }
  } else {
    {
#line 1413
    printf((char const   */* __restrict  */)"Management network addresses VPD page:\n");
    }
  }
#line 1414
  if (opts->hex) {
    {
#line 1415
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1416
    return (0);
  }
  {
#line 1418
  res = decode_man_net_vpd(b, len + 4);
  }
#line 1419
  if (res) {
#line 1420
    return (res);
  }
#line 1421
  goto switch_break;
  case_135: /* CIL Label */ 
#line 1423
  if ((int )b[1] != pn) {
#line 1424
    goto dumb_inq;
  }
#line 1425
  len = ((int )b[2] << 8) + (int )b[3];
#line 1426
  if (len > sz) {
    {
#line 1427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Mode page policy VPD page truncated\n");
#line 1429
    len = sz;
    }
  }
#line 1431
  if (opts->long_out) {
    {
#line 1432
    printf((char const   */* __restrict  */)"Mode page policy [0x87] VPD page:\n");
    }
  } else {
    {
#line 1434
    printf((char const   */* __restrict  */)"mode page policy VPD page:\n");
    }
  }
#line 1435
  if (opts->hex) {
    {
#line 1436
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1437
    return (0);
  }
  {
#line 1439
  res = decode_mode_policy_vpd(b, len + 4);
  }
#line 1440
  if (res) {
#line 1441
    return (res);
  }
#line 1442
  goto switch_break;
  case_138: /* CIL Label */ 
#line 1444
  if ((int )b[1] != pn) {
#line 1445
    goto dumb_inq;
  }
#line 1446
  len = ((int )b[2] << 8) + (int )b[3];
#line 1447
  if (len > sz) {
    {
#line 1448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Power condition VPD page truncated\n");
#line 1450
    len = sz;
    }
  }
#line 1452
  if (opts->long_out) {
    {
#line 1453
    printf((char const   */* __restrict  */)"Power condition [0x8a] VPD page:\n");
    }
  } else
#line 1454
  if (! opts->quiet) {
    {
#line 1455
    printf((char const   */* __restrict  */)"Power condition VPD page:\n");
    }
  }
#line 1456
  if (opts->hex) {
    {
#line 1457
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1458
    return (0);
  }
  {
#line 1460
  res = decode_power_condition(b, len + 4);
  }
#line 1461
  if (res) {
#line 1462
    return (res);
  }
#line 1463
  goto switch_break;
  case_141: /* CIL Label */ 
#line 1465
  if ((int )b[1] != pn) {
#line 1466
    goto dumb_inq;
  }
#line 1467
  len = ((int )b[2] << 8) + (int )b[3];
#line 1468
  if (len > sz) {
    {
#line 1469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Power consumption VPD page truncated\n");
#line 1471
    len = sz;
    }
  }
#line 1473
  if (opts->long_out) {
    {
#line 1474
    printf((char const   */* __restrict  */)"Power consumption [0x8d] VPD page:\n");
    }
  } else {
    {
#line 1476
    printf((char const   */* __restrict  */)"Power consumption VPD page:\n");
    }
  }
#line 1477
  if (opts->hex) {
    {
#line 1478
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1479
    return (0);
  }
  {
#line 1481
  res = decode_power_consumption_vpd(b, len + 4);
  }
#line 1482
  if (res) {
#line 1483
    return (res);
  }
#line 1484
  goto switch_break;
  case_144: /* CIL Label */ 
#line 1486
  if ((int )b[1] != pn) {
#line 1487
    goto dumb_inq;
  }
#line 1488
  len = ((int )b[2] << 8) + (int )b[3];
#line 1489
  if (len > sz) {
    {
#line 1490
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Protocol-specific logical unit information VPD page truncated\n");
#line 1492
    len = sz;
    }
  }
#line 1494
  if (opts->long_out) {
    {
#line 1495
    printf((char const   */* __restrict  */)"Protocol-specific logical unit information [0x90] VPD page:\n");
    }
  } else {
    {
#line 1498
    printf((char const   */* __restrict  */)"Protocol-specific logical unit information VPD page:\n");
    }
  }
#line 1499
  if (opts->hex) {
    {
#line 1500
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1501
    return (0);
  }
  {
#line 1503
  res = decode_proto_lu_vpd(b, len + 4);
  }
#line 1504
  if (res) {
#line 1505
    return (res);
  }
#line 1506
  goto switch_break;
  case_145: /* CIL Label */ 
#line 1508
  if ((int )b[1] != pn) {
#line 1509
    goto dumb_inq;
  }
#line 1510
  len = ((int )b[2] << 8) + (int )b[3];
#line 1511
  if (len > sz) {
    {
#line 1512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Protocol-specific port information VPD page truncated\n");
#line 1514
    len = sz;
    }
  }
#line 1516
  if (opts->long_out) {
    {
#line 1517
    printf((char const   */* __restrict  */)"Protocol-specific port information [0x91] VPD page:\n");
    }
  } else {
    {
#line 1520
    printf((char const   */* __restrict  */)"Protocol-specific port information VPD page:\n");
    }
  }
#line 1521
  if (opts->hex) {
    {
#line 1522
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1523
    return (0);
  }
  {
#line 1525
  res = decode_proto_port_vpd(b, len + 4);
  }
#line 1526
  if (res) {
#line 1527
    return (res);
  }
#line 1528
  goto switch_break;
  case_136: /* CIL Label */ 
#line 1530
  if ((int )b[1] != pn) {
#line 1531
    goto dumb_inq;
  }
#line 1532
  len = ((int )b[2] << 8) + (int )b[3];
#line 1533
  if (len > sz) {
    {
#line 1534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to SCSI Ports VPD page truncated\n");
#line 1536
    len = sz;
    }
  }
#line 1538
  if (opts->long_out) {
    {
#line 1539
    printf((char const   */* __restrict  */)"SCSI Ports [0x88] VPD page:\n");
    }
  } else {
    {
#line 1541
    printf((char const   */* __restrict  */)"SCSI Ports VPD page:\n");
    }
  }
#line 1542
  if (opts->hex) {
    {
#line 1543
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1544
    return (0);
  }
  {
#line 1546
  res = decode_scsi_ports_vpd(b, len + 4, (int )opts->long_out, (int )opts->quiet);
  }
#line 1547
  if (res) {
#line 1548
    return (res);
  }
#line 1549
  goto switch_break;
  case_132: /* CIL Label */ 
#line 1551
  if ((int )b[1] != pn) {
#line 1552
    goto dumb_inq;
  }
#line 1553
  len = ((int )b[2] << 8) + (int )b[3];
#line 1554
  if (len > sz) {
    {
#line 1555
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Software interface identification VPD page truncated\n");
#line 1557
    len = sz;
    }
  }
#line 1559
  if (opts->long_out) {
    {
#line 1560
    printf((char const   */* __restrict  */)"Software interface identification [0x84] VPD page:\n");
    }
  } else {
    {
#line 1562
    printf((char const   */* __restrict  */)"Software interface identification VPD page:\n");
    }
  }
#line 1563
  if (opts->hex) {
    {
#line 1564
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1565
    return (0);
  }
#line 1567
  up = b + 4;
  {
#line 1568
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1568
    if (! (len > 5)) {
#line 1568
      goto while_break___0;
    }
    {
#line 1569
    printf((char const   */* __restrict  */)"    ");
#line 1570
    k = 0;
    }
    {
#line 1570
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1570
      if (! (k < 6)) {
#line 1570
        goto while_break___1;
      }
      {
#line 1571
      printf((char const   */* __restrict  */)"%02x", (unsigned int )*(up + k));
#line 1570
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1572
    printf((char const   */* __restrict  */)"\n");
#line 1568
    len -= 6;
#line 1568
    up += 6;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1574
  goto switch_break;
  case_128: /* CIL Label */ 
#line 1576
  if ((int )b[1] != pn) {
#line 1577
    goto dumb_inq;
  }
#line 1578
  len = ((int )b[2] << 8) + (int )b[3];
#line 1579
  if (opts->long_out) {
    {
#line 1580
    printf((char const   */* __restrict  */)"Unit serial number [0x80] VPD page:\n");
    }
  } else {
    {
#line 1582
    printf((char const   */* __restrict  */)"Unit serial number VPD page:\n");
    }
  }
#line 1583
  if (opts->hex) {
    {
#line 1584
    dStrHex((char const   *)(b), len + 4, 0);
    }
  } else
#line 1585
  if (len > 0) {
#line 1586
    if (len + 4 < (int )sizeof(b)) {
#line 1587
      b[len + 4] = (unsigned char )'\000';
    } else {
#line 1589
      b[sizeof(b) - 1UL] = (unsigned char )'\000';
    }
    {
#line 1590
    printf((char const   */* __restrict  */)"  %s\n", b + 4);
    }
  } else {
    {
#line 1592
    printf((char const   */* __restrict  */)"  <empty>\n");
    }
  }
#line 1593
  goto switch_break;
  case_176: /* CIL Label */ 
#line 1595
  if ((int )b[1] != pn) {
#line 1596
    goto dumb_inq;
  }
  {
#line 1598
  if (pdt == 7) {
#line 1598
    goto case_7;
  }
#line 1598
  if (pdt == 4) {
#line 1598
    goto case_7;
  }
#line 1598
  if (pdt == 0) {
#line 1598
    goto case_7;
  }
#line 1602
  if (pdt == 8) {
#line 1602
    goto case_8;
  }
#line 1602
  if (pdt == 1) {
#line 1602
    goto case_8;
  }
#line 1606
  if (pdt == 17) {
#line 1606
    goto case_17;
  }
#line 1610
  goto switch_default;
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 1599
  vpd_name = "Block limits";
#line 1600
  sbc = 1;
#line 1601
  goto switch_break___0;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1603
  vpd_name = "Sequential access device capabilities";
#line 1604
  ssc = 1;
#line 1605
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 1607
  vpd_name = "OSD information";
#line 1609
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1611
  vpd_name = "unexpected pdt for B0h";
#line 1612
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1614
  len = ((int )b[2] << 8) + (int )b[3];
#line 1615
  if (len > sz) {
    {
#line 1616
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to %s VPD page truncated\n",
            vpd_name);
#line 1618
    len = sz;
    }
  }
#line 1620
  if (opts->long_out) {
    {
#line 1621
    printf((char const   */* __restrict  */)"%s [0xb0] VPD page:\n", vpd_name);
    }
  } else {
    {
#line 1623
    printf((char const   */* __restrict  */)"%s VPD page:\n", vpd_name);
    }
  }
#line 1624
  if (opts->hex) {
    {
#line 1625
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1626
    return (0);
  }
#line 1628
  res = 0;
#line 1629
  if (ssc) {
    {
#line 1630
    res = decode_tape_dev_caps_vpd(b, len + 4);
    }
  } else
#line 1631
  if (sbc) {
    {
#line 1632
    res = decode_block_limits_vpd(b, len + 4);
    }
  } else {
    {
#line 1634
    dStrHex((char const   *)(b), len + 4, 0);
    }
  }
#line 1635
  if (res) {
#line 1636
    return (res);
  }
#line 1637
  goto switch_break;
  case_177: /* CIL Label */ 
#line 1639
  if ((int )b[1] != pn) {
#line 1640
    goto dumb_inq;
  }
  {
#line 1642
  if (pdt == 7) {
#line 1642
    goto case_7___0;
  }
#line 1642
  if (pdt == 4) {
#line 1642
    goto case_7___0;
  }
#line 1642
  if (pdt == 0) {
#line 1642
    goto case_7___0;
  }
#line 1646
  if (pdt == 8) {
#line 1646
    goto case_8___0;
  }
#line 1646
  if (pdt == 1) {
#line 1646
    goto case_8___0;
  }
#line 1650
  if (pdt == 17) {
#line 1650
    goto case_17___0;
  }
#line 1654
  if (pdt == 18) {
#line 1654
    goto case_18;
  }
#line 1658
  goto switch_default___0;
  case_7___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_0___1: /* CIL Label */ 
#line 1643
  vpd_name = "Block device characteristics";
#line 1644
  sbc = 1;
#line 1645
  goto switch_break___1;
  case_8___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 1647
  vpd_name = "Manufactured assigned serial number";
#line 1648
  ssc = 1;
#line 1649
  goto switch_break___1;
  case_17___0: /* CIL Label */ 
#line 1651
  vpd_name = "Security token";
#line 1653
  goto switch_break___1;
  case_18: /* CIL Label */ 
#line 1655
  vpd_name = "Manufactured assigned serial number";
#line 1656
  adc = 1;
#line 1657
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1659
  vpd_name = "unexpected pdt for B1h";
#line 1660
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1662
  len = ((int )b[2] << 8) + (int )b[3];
#line 1663
  if (len > sz) {
    {
#line 1664
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to %s VPD page truncated\n",
            vpd_name);
#line 1666
    len = sz;
    }
  }
#line 1668
  if (opts->long_out) {
    {
#line 1669
    printf((char const   */* __restrict  */)"%s [0xb1] VPD page:\n", vpd_name);
    }
  } else {
    {
#line 1671
    printf((char const   */* __restrict  */)"%s VPD page:\n", vpd_name);
    }
  }
#line 1672
  if (opts->hex) {
    {
#line 1673
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1674
    return (0);
  }
#line 1676
  res = 0;
#line 1677
  if (ssc) {
    {
#line 1678
    res = decode_tape_man_ass_sn_vpd(b, len + 4);
    }
  } else
#line 1677
  if (adc) {
    {
#line 1678
    res = decode_tape_man_ass_sn_vpd(b, len + 4);
    }
  } else
#line 1679
  if (sbc) {
    {
#line 1680
    res = decode_block_dev_chars_vpd(b, len + 4);
    }
  } else {
    {
#line 1682
    dStrHex((char const   *)(b), len + 4, 0);
    }
  }
#line 1683
  if (res) {
#line 1684
    return (res);
  }
#line 1685
  goto switch_break;
  case_178: /* CIL Label */ 
#line 1687
  if ((int )b[1] != pn) {
#line 1688
    goto dumb_inq;
  }
#line 1690
  len = ((int )b[2] << 8) + (int )b[3];
  {
#line 1692
  if (pdt == 7) {
#line 1692
    goto case_7___1;
  }
#line 1692
  if (pdt == 4) {
#line 1692
    goto case_7___1;
  }
#line 1692
  if (pdt == 0) {
#line 1692
    goto case_7___1;
  }
#line 1696
  if (pdt == 8) {
#line 1696
    goto case_8___1;
  }
#line 1696
  if (pdt == 1) {
#line 1696
    goto case_8___1;
  }
#line 1700
  goto switch_default___1;
  case_7___1: /* CIL Label */ 
  case_4___1: /* CIL Label */ 
  case_0___2: /* CIL Label */ 
#line 1693
  vpd_name = "Logical block provisioning";
#line 1694
  sbc = 1;
#line 1695
  goto switch_break___2;
  case_8___1: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
#line 1697
  vpd_name = "TapeAlert supported flags";
#line 1698
  ssc = 1;
#line 1699
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
#line 1701
  vpd_name = "unexpected pdt for B2h";
#line 1702
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1704
  if (opts->long_out) {
    {
#line 1705
    printf((char const   */* __restrict  */)"%s [0xb2] VPD page:\n", vpd_name);
    }
  } else {
    {
#line 1707
    printf((char const   */* __restrict  */)"%s VPD page:\n", vpd_name);
    }
  }
#line 1708
  if (opts->hex) {
    {
#line 1709
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1710
    return (0);
  }
#line 1712
  res = 0;
#line 1713
  if (ssc) {
    {
#line 1714
    res = decode_tapealert_supported_vpd(b, len + 4);
    }
  } else
#line 1715
  if (sbc) {
    {
#line 1716
    res = decode_block_lb_prov_vpd(b, len + 4);
    }
  } else {
    {
#line 1718
    dStrHex((char const   *)(b), len + 4, 0);
    }
  }
#line 1719
  if (res) {
#line 1720
    return (res);
  }
#line 1721
  goto switch_break;
  case_179: /* CIL Label */ 
#line 1723
  if ((int )b[1] != pn) {
#line 1724
    goto dumb_inq;
  }
#line 1725
  len = ((int )b[2] << 8) + (int )b[3];
  {
#line 1727
  if (pdt == 7) {
#line 1727
    goto case_7___2;
  }
#line 1727
  if (pdt == 4) {
#line 1727
    goto case_7___2;
  }
#line 1727
  if (pdt == 0) {
#line 1727
    goto case_7___2;
  }
#line 1731
  if (pdt == 8) {
#line 1731
    goto case_8___2;
  }
#line 1731
  if (pdt == 1) {
#line 1731
    goto case_8___2;
  }
#line 1735
  goto switch_default___2;
  case_7___2: /* CIL Label */ 
  case_4___2: /* CIL Label */ 
  case_0___3: /* CIL Label */ 
#line 1728
  vpd_name = "Referrals";
#line 1729
  sbc = 1;
#line 1730
  goto switch_break___3;
  case_8___2: /* CIL Label */ 
  case_1___2: /* CIL Label */ 
#line 1732
  vpd_name = "Automation device serial number";
#line 1733
  ssc = 1;
#line 1734
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
#line 1736
  vpd_name = "unexpected pdt for B3h";
#line 1737
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1739
  if (opts->long_out) {
    {
#line 1740
    printf((char const   */* __restrict  */)"%s [0xb3] VPD page:\n", vpd_name);
    }
  } else {
    {
#line 1742
    printf((char const   */* __restrict  */)"%s VPD page:\n", vpd_name);
    }
  }
#line 1743
  if (opts->hex) {
    {
#line 1744
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1745
    return (0);
  }
#line 1747
  res = 0;
#line 1748
  if (ssc) {
#line 1750
    if (len > 0) {
#line 1751
      if (len + 4 < (int )sizeof(b)) {
#line 1752
        b[len + 4] = (unsigned char )'\000';
      } else {
#line 1754
        b[sizeof(b) - 1UL] = (unsigned char )'\000';
      }
      {
#line 1755
      printf((char const   */* __restrict  */)"  serial number: %s\n", b + 4);
      }
    } else {
      {
#line 1757
      printf((char const   */* __restrict  */)"  serial number: <empty>\n");
      }
    }
  } else
#line 1758
  if (sbc) {
    {
#line 1759
    res = decode_referrals_vpd(b, len + 4);
    }
  } else {
    {
#line 1761
    dStrHex((char const   *)(b), len + 4, 0);
    }
  }
#line 1762
  if (res) {
#line 1763
    return (res);
  }
#line 1764
  goto switch_break;
  case_180: /* CIL Label */ 
#line 1766
  if ((int )b[1] != pn) {
#line 1767
    goto dumb_inq;
  }
#line 1768
  len = ((int )b[2] << 8) + (int )b[3];
#line 1769
  if (len > sz) {
    {
#line 1770
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Response to Data transfer device element address VPD page truncated\n");
#line 1772
    len = sz;
    }
  }
#line 1774
  if (opts->long_out) {
    {
#line 1775
    printf((char const   */* __restrict  */)"Data transfer device element address [0xB4] VPD page:\n");
    }
  } else {
    {
#line 1777
    printf((char const   */* __restrict  */)"Data transfer device element address VPD page:\n");
    }
  }
#line 1778
  if (opts->hex) {
    {
#line 1779
    dStrHex((char const   *)(b), len + 4, 0);
    }
#line 1780
    return (0);
  } else
#line 1781
  if (len > 0) {
    {
#line 1782
    printf((char const   */* __restrict  */)"  0x");
#line 1783
    k = 0;
    }
    {
#line 1783
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1783
      if (! (k < len)) {
#line 1783
        goto while_break___2;
      }
      {
#line 1784
      printf((char const   */* __restrict  */)"%02x", (unsigned int )b[4 + k]);
#line 1783
      k ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1785
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 1787
    printf((char const   */* __restrict  */)"  <empty>\n");
    }
  }
#line 1788
  goto switch_break;
  switch_default___3: /* CIL Label */ 
#line 1790
  if ((int )b[1] != pn) {
#line 1791
    goto dumb_inq;
  }
  {
#line 1792
  len = (((int )b[2] << 8) + (int )b[3]) + 4;
#line 1793
  vpp = sdp_get_vpd_detail(pn, -1, pdt);
  }
#line 1794
  if (vpp) {
    {
#line 1795
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s VPD page in hex:\n",
            vpp->name);
    }
  } else {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"VPD page 0x%x in hex:\n",
            pn);
    }
  }
#line 1798
  if (len > (int )sizeof(b)) {
#line 1799
    if (opts->verbose) {
      {
#line 1800
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"page length=%d too long, trim\n",
              len);
      }
    }
#line 1801
    len = (int )sizeof(b);
  }
  {
#line 1803
  dStrHex((char const   *)(b), len, 0);
  }
#line 1804
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1806
  return (0);
  dumb_inq: 
  {
#line 1809
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malformed VPD response, VPD pages probably not supported\n");
  }
#line 1811
  return (97);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_mode_page_t sdparm_gen_mode_pg[41] ;
#line 264
struct sdparm_vpd_page_t sdparm_vpd_pg[34] ;
#line 265
struct sdparm_transport_id_t sdparm_transport_id[17] ;
#line 266
struct sdparm_transport_pair sdparm_transport_mp[16] ;
#line 270
struct sdparm_mode_page_item sdparm_mitem_arr[379] ;
#line 271
struct sdparm_command_t sdparm_command_arr[12] ;
#line 272
struct sdparm_val_desc_t sdparm_profile_arr[37] ;
#line 274
char const   *sdparm_pdt_doc_strs[32] ;
#line 279
char const   *sdparm_ansi_version_arr[8] ;
#line 47 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_descriptor_t ssc_mpa_desc  = 
#line 47 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
     {3, 1, 1, 8, 2, -1, -1, "SSC medium partition"};
#line 54 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_descriptor_t smc_tg_desc  = 
#line 54
     {1, 1, -1, 2, 2, -1, -1, "SMC transport geometry"};
#line 61 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_descriptor_t sbc_lbp_desc  = 
#line 61
     {2, 2, -1, 16, 8, -1, -1, "SBC logical block provisioning"};
#line 67 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_descriptor_t sbc_atag_desc  = 
#line 67
     {2, 2, -1, 16, 24, -1, -1, "SBC application tag"};
#line 74 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_mode_page_t sdparm_gen_mode_pg[41]  = 
#line 74
  {      {14, 2, 18, 0, "addp", "DT device primary port (ADC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {14,
      3, 18, 0, "adlu", "logical unit (ADC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {14,
      1, 18, 0, "adtd", "Targer device (ADC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {14,
      4, 18, 0, "adts", "Targer device serial number (ADC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {26,
      241, -1, 0, "apo", "SAT ATA Power condition", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {10,
      2, 0, 0, "atag", "Application tag (SBC)", (struct sdparm_mode_descriptor_t  const  *)(& sbc_atag_desc)}, 
        {28,
      1, 0, 0, "bc", "Background control (SBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {8,
      0, 0, 0, "ca", "Caching (SBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {42,
      0, 5, 1, "cms", "CD/DVD (MM) capabilities and mechanical status (MMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {10,
      0, -1, 0, "co", "Control", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {10,
      1, -1, 0, "coe", "Control extension", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {10,
      240, -1, 0, "cdp", "Control data protection (SSC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {15,
      0, 1, 0, "dac", "Data compression (SSC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {16,
      0, 1, 0, "dc", "Device configuration (SSC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {31,
      0, 8, 0, "dca", "Device capabilities (SMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {16,
      1, 1, 0, "dce", "Device configuration extension (SSC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {2,
      0, -1, 0, "dr", "Disconnect-reconnect (SPC + transports)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {29,
      0, 8, 0, "eaa", "Element address assignment (SMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {31,
      65, 8, 0, "edc", "Extended device capabilities (SMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {20,
      0, 13, 0, "esm", "Enclosure services management (SES)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {3,
      0, 0, 0, "fo", "Format (SBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {28,
      0, -1, 0, "ie", "Informational exceptions control", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {28,
      2, 0, 0, "lbp", "Logical block provisioning (SBC)", (struct sdparm_mode_descriptor_t  const  *)(& sbc_lbp_desc)}, 
        {29,
      0, 1, 0, "mco", "Medium configuration (SSC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {17,
      0, 1, 0, "mpa", "Medium partition (SSC)", (struct sdparm_mode_descriptor_t  const  *)(& ssc_mpa_desc)}, 
        {3,
      0, 5, 0, "mrw", "Mount rainier reWritable (MMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {10,
      241, -1, 0, "pat", "SAT pATA control", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {24,
      0, -1, 0, "pl", "Protocol specific logical unit", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {26,
      0, -1, 0, "po", "Power condition", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {26,
      1, -1, 0, "ps", "Power consumption", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {13,
      0, 0, 0, "poo", "Power condition - old version", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      0, -1, 0, "pp", "Protocol specific port", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {6,
      0, 14, 0, "rbc", "RBC device parameters (RBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {4,
      0, 0, 0, "rd", "Rigid disk (SBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {1,
      0, -1, 0, "rw", "Read write error recovery", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {30,
      0, 8, 0, "tgp", "Transport geometry parameters (SMC)", (struct sdparm_mode_descriptor_t  const  *)(& smc_tg_desc)}, 
        {29,
      0, 5, 0, "tp", "Timeout and protect (MMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {7,
      0, 0, 0, "ve", "Verify error recovery (SBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {5,
      0, 5, 0, "wp", "Write parameters (MMC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {16,
      0, 0, 0, "xo", "XOR control (SBC)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 141 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_transport_id_t sdparm_transport_id[17]  = 
#line 141
  {      {0, "fcp", "Fibre channel (FCP)"}, 
        {1, "spi", "SCSI parallel interface (SPI)"}, 
        {2, "ssa", "Serial storage architecture (SSA)"}, 
        {3, "sbp", "Serial bus (SBP)"}, 
        {4, "srp", "SCSI remote DMA (SRP)"}, 
        {5, "iscsi", "Internet SCSI (iSCSI)"}, 
        {6, "sas", "Serial attached SCSI (SAS)"}, 
        {7, "adt", "Automation/Drive interface (ADT)"}, 
        {8, "ata", "AT attachment interface (ATA/ATAPI)"}, 
        {9, "u0x9", (char const   *)((void *)0)}, 
        {10, "u0xa", (char const   *)((void *)0)}, 
        {11, "u0xb", (char const   *)((void *)0)}, 
        {12, "u0xc", (char const   *)((void *)0)}, 
        {13, "u0xd", (char const   *)((void *)0)}, 
        {14, "u0xe", (char const   *)((void *)0)}, 
        {15, "none", "No specific"}, 
        {0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 162 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_t sdparm_fcp_mode_pg[6]  = {      {2, 0, -1, 0, "dr", "Disconnect-reconnect (FCP)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {24,
      0, -1, 0, "luc", "lu: control (FCP)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      0, -1, 0, "pc", "port: control (FCP)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {24,
      0, -1, 0, "pl", "lu: control (generic name)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      0, -1, 0, "pp", "port: control (generic name)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 171 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_t sdparm_spi_mode_pg[10]  = 
#line 171
  {      {2, 0, -1, 0, "dr", "Disconnect-reconnect (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {24,
      0, -1, 0, "luc", "lu: control (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      1, -1, 0, "mc", "port: margin control (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      3, -1, 0, "ns", "port: negotiated settings (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      0, -1, 0, "psf", "port: short format (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      4, -1, 1, "rtc", "port: report transfer capabilities (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      2, -1, 0, "stc", "port: saved training config value (SPI)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {24,
      0, -1, 0, "pl", "lu: control (generic name)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      0, -1, 0, "pp", "port: short format (generic name)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 190 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_t sdparm_srp_mode_pg[2]  = {      {2, 0, -1, 0, "dr", "Disconnect-reconnect (SRP)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 195 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_descriptor_t sas_pcd_desc  = 
#line 195
     {7, 1, 0, 8, 48, -1, -1, "SAS phy"};
#line 199 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_descriptor_t sas_e_phy_desc  = 
#line 199
     {7, 1, 0, 8, -1, 2, 2, "Enhanced phy"};
#line 206 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_t sdparm_sas_mode_pg[7]  = {      {2, 0, -1, 0, "dr", "Disconnect-reconnect (SAS)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {24,
      0, -1, 0, "pl", "Protocol specific logical unit (SAS)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      1, -1, 0, "pcd", "Phy control and discover (SAS)", (struct sdparm_mode_descriptor_t  const  *)(& sas_pcd_desc)}, 
        {25,
      0, -1, 0, "pp", "Protocol specific port (SAS)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {25,
      3, -1, 0, "sep", "Enhanced phy control (SAS)", (struct sdparm_mode_descriptor_t  const  *)(& sas_e_phy_desc)}, 
        {25,
      2, -1, 0, "spc", "Shared port control (SAS)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 223 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_vpd_page_t sdparm_vpd_pg[34]  = 
#line 223
  {      {137, 0, -1, "ai", "ATA information (SAT)"}, 
        {130, 0, -1, "aod", "ASCII implemented operating definition (obs)"}, 
        {179, 0, 1, "adsn", "Automation device serial number (SSC)"}, 
        {176, 0, 0, "bl", "Block limits (SBC)"}, 
        {177, 0, 0, "bdc", "Block device characteristics (SBC)"}, 
        {140, 0, -1, "cfa", "CFA profile information"}, 
        {139, 0, -1, "dc", "Device constituents"}, 
        {131, 0, -1, "di", "Device identification"}, 
        {131, 32, -1, "di_asis", "Like \'di\' but designators ordered as found"}, 
        {131, 1, -1, "di_lu", "Device identification, lu only"}, 
        {131, 2, -1, "di_port", "Device identification, target port only"}, 
        {131, 4, -1, "di_target", "Device identification, target device only"}, 
        {134, 0, -1, "ei", "Extended inquiry data"}, 
        {180, 0, 1, "dtde", "Data transfer device element address (SSC)"}, 
        {129, 0, -1, "iod", "Implemented operating definition (obs)"}, 
        {178, 0, 0, "lbpv", "Logical block provisioning (SBC)"}, 
        {177, 0, 1, "mas", "Manufacturer assigned serial number (SSC)"}, 
        {177, 0, 18, "masa", "Manufacturer assigned serial number (ADC)"}, 
        {133, 0, -1, "mna", "Management network addresses"}, 
        {135, 0, -1, "mpp", "Mode page policy"}, 
        {176, 0, 17, "oi", "OSD information"}, 
        {138, 0, -1, "pc", "Power condition"}, 
        {141, 0, -1, "psm", "Power consumption"}, 
        {144, 0, -1, "pslu", "Protocol-specific logical unit information"}, 
        {145, 0, -1, "pspo", "Protocol-specific port information"}, 
        {179, 0, 0, "ref", "Referrals (SBC)"}, 
        {176, 0, 1, "sad", "Sequential access device capabilities (SSC)"}, 
        {132, 0, -1, "sii", "Software interface identification"}, 
        {-2, 0, -1, "sinq", "Standard inquiry response"}, 
        {128, 0, -1, "sn", "Unit serial number"}, 
        {136, 0, -1, "sp", "SCSI ports"}, 
        {0, 0, -1, "sv", "Supported VPD pages"}, 
        {178, 0, 1, "tas", "TapeAlert supported flags (SSC)"}, 
        {0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 276 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_mode_page_item sdparm_mitem_arr[379]  = 
#line 276
  {      {"AWRE", 1, 0, -1, 2, 7, 1, 1, "Automatic write reallocation enabled", (char const   *)((void *)0)}, 
        {"ARRE",
      1, 0, -1, 2, 6, 1, 1, "Automatic read reallocation enabled", (char const   *)((void *)0)}, 
        {"TB",
      1, 0, -1, 2, 5, 1, 0, "Transfer block", (char const   *)((void *)0)}, 
        {"RC", 1, 0, -1, 2, 4, 1, 0, "Read continuous", "0: error recovery may cause delays\t1: transfer data without waiting for error recovery"}, 
        {"EER",
      1, 0, -1, 2, 3, 1, 0, "Enable early recovery", "1: increase chance of mis-detection or mis-correction of error"}, 
        {"PER",
      1, 0, -1, 2, 2, 1, 1, "Post error", "0: do not post recovered errors\t1: report recovered errors (via sense key: recovered error)"}, 
        {"DTE",
      1, 0, -1, 2, 1, 1, 0, "Data terminate on error", "1: terminate data transfer when recovered error detected"}, 
        {"DCR",
      1, 0, -1, 2, 0, 1, 0, "Disable correction", (char const   *)((void *)0)}, 
        {"RRC", 1, 0, -1, 3, 7, 8, 0, "Read retry count", (char const   *)((void *)0)}, 
        {"COR_S",
      1, 0, -1, 4, 7, 8, 0, "Correction span (obsolete)", (char const   *)((void *)0)}, 
        {"HOC",
      1, 0, -1, 5, 7, 8, 0, "Head offset count (obsolete)", (char const   *)((void *)0)}, 
        {"DSOC",
      1, 0, -1, 6, 7, 8, 0, "Data strobe offset count (obsolete)", (char const   *)((void *)0)}, 
        {"LBPERE",
      1, 0, 0, 7, 7, 1, 0, "Logical block provisioning error reporting enabled", (char const   *)((void *)0)}, 
        {"EMCDR",
      1, 0, 5, 7, 1, 2, 0, "Enhanced media certification and defect reporting", (char const   *)((void *)0)}, 
        {"WRC",
      1, 0, -1, 8, 7, 8, 0, "Write retry count", (char const   *)((void *)0)}, 
        {"ERWS", 1, 0, 5, 9, 7, 24, 0, "Error reporting window size (blocks)", (char const   *)((void *)0)}, 
        {"RTL",
      1, 0, 0, 10, 7, 16, 0, "Recovery time limit (ms)", "0: default, -1: 65.5 seconds"}, 
        {"BFR",
      2, 0, -1, 2, 7, 8, 0, "Buffer full ratio", "fraction where this value is numerator, 256 is denominator"}, 
        {"BER",
      2, 0, -1, 3, 7, 8, 0, "Buffer empty ratio", "fraction where this value is numerator, 256 is denominator"}, 
        {"BIL",
      2, 0, -1, 4, 7, 16, 0, "Bus inactivity limit", "for unit see specific transport"}, 
        {"DTL",
      2, 0, -1, 6, 7, 16, 0, "Disconnect time limit", "for unit see specific transport"}, 
        {"CTL",
      2, 0, -1, 8, 7, 16, 0, "Connect time limit", "for unit see specific transport"}, 
        {"MBS",
      2, 0, -1, 10, 7, 16, 0, "Maximum burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"EMDP",
      2, 0, -1, 12, 7, 1, 0, "Enable modify data pointers", "1: target may send data out of order"}, 
        {"FA",
      2, 0, -1, 12, 6, 3, 0, "Fair arbitration", (char const   *)((void *)0)}, 
        {"DIMM", 2, 0, -1, 12, 3, 1, 0, "Disconnect immediate", (char const   *)((void *)0)}, 
        {"DTDC",
      2, 0, -1, 12, 2, 3, 0, "Data transfer disconnect control", (char const   *)((void *)0)}, 
        {"FBS",
      2, 0, -1, 14, 7, 16, 0, "First burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"TPZ",
      3, 0, 0, 2, 7, 16, 0, "Tracks per zone", (char const   *)((void *)0)}, 
        {"ASPZ", 3, 0, 0, 4, 7, 16, 0, "Alternate sectors per zone", (char const   *)((void *)0)}, 
        {"ATPZ",
      3, 0, 0, 6, 7, 16, 0, "Alternate tracks per zone", (char const   *)((void *)0)}, 
        {"ATPLU",
      3, 0, 0, 8, 7, 16, 0, "Alternate tracks per logical unit", (char const   *)((void *)0)}, 
        {"SPT",
      3, 0, 0, 10, 7, 16, 0, "Sectors per track", (char const   *)((void *)0)}, 
        {"DBPPS", 3, 0, 0, 12, 7, 16, 0, "Data bytes per physical sector", (char const   *)((void *)0)}, 
        {"INTLV",
      3, 0, 0, 14, 7, 16, 0, "Interleave", (char const   *)((void *)0)}, 
        {"TSF", 3, 0, 0, 16, 7, 16, 0, "Track skew factor", (char const   *)((void *)0)}, 
        {"CSF",
      3, 0, 0, 18, 7, 16, 0, "Cylinder skew factor", (char const   *)((void *)0)}, 
        {"SSEC",
      3, 0, 0, 20, 7, 1, 0, "Soft sector", (char const   *)((void *)0)}, 
        {"HSEC", 3, 0, 0, 20, 6, 1, 0, "Hard sector", (char const   *)((void *)0)}, 
        {"RMB", 3, 0, 0, 20, 5, 1, 0, "Removable", (char const   *)((void *)0)}, 
        {"SURF", 3, 0, 0, 20, 4, 1, 0, "Surface", (char const   *)((void *)0)}, 
        {"LBAS", 3, 0, 5, 3, 0, 1, 0, "LBA space", (char const   *)((void *)0)}, 
        {"NOC", 4, 0, 0, 2, 7, 24, 0, "Number of cylinders", (char const   *)((void *)0)}, 
        {"NOH",
      4, 0, 0, 5, 7, 8, 0, "Number of heads", (char const   *)((void *)0)}, 
        {"SCWP", 4, 0, 0, 6, 7, 24, 0, "Starting cylinder for write precompensation",
      (char const   *)((void *)0)}, 
        {"SCRWC", 4, 0, 0, 9, 7, 24, 0, "Starting cylinder for reduced write current",
      (char const   *)((void *)0)}, 
        {"DSR", 4, 0, 0, 12, 7, 16, 0, "Device step rate", (char const   *)((void *)0)}, 
        {"LZC",
      4, 0, 0, 14, 7, 24, 0, "Landing zone cylinder", (char const   *)((void *)0)}, 
        {"RPL",
      4, 0, 0, 17, 1, 2, 0, "Rotational position locking", (char const   *)((void *)0)}, 
        {"ROTO",
      4, 0, 0, 18, 7, 8, 0, "Rotational offset", (char const   *)((void *)0)}, 
        {"MRR", 4, 0, 0, 20, 7, 16, 0, "Medium rotation rate (rpm)", (char const   *)((void *)0)}, 
        {"BUFE",
      5, 0, 5, 2, 6, 1, 1, "Buffer underrun free recording enable", (char const   *)((void *)0)}, 
        {"LS_V",
      5, 0, 5, 2, 5, 1, 0, "Link size valid", (char const   *)((void *)0)}, 
        {"TST_W", 5, 0, 5, 2, 4, 1, 0, "Test write", (char const   *)((void *)0)}, 
        {"WR_T", 5, 0, 5, 2, 3, 4, 1, "Write type", "0: packet/incremental; 1: track-at-once\t2: session-at-once; 3: raw; 4: layer jump recording"}, 
        {"MULTI_S",
      5, 0, 5, 3, 7, 2, 1, "Multi session", "0: next session not allowed (no BO pointer)\t1: next session not allowed\t3: next seesion allowed (indicated by BO pointer)"}, 
        {"FP",
      5, 0, 5, 3, 5, 1, 0, "Fixed packet type", (char const   *)((void *)0)}, 
        {"COPY", 5, 0, 5, 3, 4, 1, 0, "Serial copy management system (SCMS) enable",
      (char const   *)((void *)0)}, 
        {"TRACK_M", 5, 0, 5, 3, 3, 4, 0, "Track mode", (char const   *)((void *)0)}, 
        {"DBT", 5, 0, 5, 4, 3, 4, 0, "Data block type", (char const   *)((void *)0)}, 
        {"LINK_S",
      5, 0, 5, 5, 7, 8, 0, "Link size", (char const   *)((void *)0)}, 
        {"IAC", 5, 0, 5, 7, 5, 6, 0, "Initiator application code", (char const   *)((void *)0)}, 
        {"SESS_F",
      5, 0, 5, 8, 7, 8, 0, "Session format", (char const   *)((void *)0)}, 
        {"PACK_S", 5, 0, 5, 10, 7, 32, 0, "Packet size", (char const   *)((void *)0)}, 
        {"APL",
      5, 0, 5, 14, 7, 16, 0, "Audio pause length (blocks)", (char const   *)((void *)0)}, 
        {"WCD",
      6, 0, 14, 2, 0, 1, 1, "Write cache disable", (char const   *)((void *)0)}, 
        {"LBS", 6, 0, 14, 3, 7, 16, 1, "Logical block size", (char const   *)((void *)0)}, 
        {"NLBS",
      6, 0, 14, 5, 7, 40, 3, "Number of logical blocks", (char const   *)((void *)0)}, 
        {"P_P",
      6, 0, 14, 10, 7, 8, 0, "Power/performance", (char const   *)((void *)0)}, 
        {"READD", 6, 0, 14, 11, 3, 1, 0, "Read disable", (char const   *)((void *)0)}, 
        {"WRITED",
      6, 0, 14, 11, 2, 1, 0, "Write disable", (char const   *)((void *)0)}, 
        {"FORMATD", 6, 0, 14, 11, 1, 1, 0, "Format disable", (char const   *)((void *)0)}, 
        {"LOCKD",
      6, 0, 14, 11, 0, 1, 0, "Lock disable", (char const   *)((void *)0)}, 
        {"V_EER", 7, 0, 0, 2, 3, 1, 0, "Enable early recovery", (char const   *)((void *)0)}, 
        {"V_PER",
      7, 0, 0, 2, 2, 1, 0, "Post error", (char const   *)((void *)0)}, 
        {"V_DTE", 7, 0, 0, 2, 1, 1, 0, "Data terminate on error", (char const   *)((void *)0)}, 
        {"V_DCR",
      7, 0, 0, 2, 0, 1, 0, "Disable correction", (char const   *)((void *)0)}, 
        {"V_RC", 7, 0, 0, 3, 7, 8, 0, "Verify retry count", (char const   *)((void *)0)}, 
        {"V_COR_S",
      7, 0, 0, 4, 7, 8, 0, "Verify correction span (obsolete)", (char const   *)((void *)0)}, 
        {"V_RTL",
      7, 0, 0, 10, 7, 16, 0, "Verify recovery time limit (ms)", (char const   *)((void *)0)}, 
        {"IC",
      8, 0, 0, 2, 7, 1, 0, "Initiator control", "0: disk uses own adaptive caching algorithm\t1: disk caching algorithm controlled by NCS or CCS"}, 
        {"ABPF",
      8, 0, 0, 2, 6, 1, 0, "Abort pre-fetch", (char const   *)((void *)0)}, 
        {"CAP", 8, 0, 0, 2, 5, 1, 0, "Caching analysis permitted", (char const   *)((void *)0)}, 
        {"DISC",
      8, 0, 0, 2, 4, 1, 0, "Discontinuity", "0: pre-fetch truncated or wrapped at time discontinuity\t1: pre-fetch continues across time discontinuity"}, 
        {"SIZE",
      8, 0, 0, 2, 3, 1, 0, "Size enable", "0: number of cache segments (NCS) controls cache segmentation\t1: the cache segment size (CCS) controls cache segmentation"}, 
        {"WCE",
      8, 0, 0, 2, 2, 1, 1, "Write cache enable", (char const   *)((void *)0)}, 
        {"MF", 8, 0, 0, 2, 1, 1, 0, "Multiplication factor", "0: MIPF and MAPF specify blocks\t1: multiply MIPF and MAPF by blocks in read command"}, 
        {"RCD",
      8, 0, 0, 2, 0, 1, 1, "Read cache disable", (char const   *)((void *)0)}, 
        {"DRRP", 8, 0, 0, 3, 7, 4, 0, "Demand read retention priority", "0: treat requested and other data equally\t1: replace requested data before other data\t15: replace other data before requested data"}, 
        {"WRP",
      8, 0, 0, 3, 3, 4, 0, "Write retention priority", "0: treat requested and other data equally\t1: replace requested data before other data\t15: replace other data before requested data"}, 
        {"DPTL",
      8, 0, 0, 4, 7, 16, 0, "Disable pre-fetch transfer length", (char const   *)((void *)0)}, 
        {"MIPF",
      8, 0, 0, 6, 7, 16, 0, "Minimum pre-fetch", (char const   *)((void *)0)}, 
        {"MAPF", 8, 0, 0, 8, 7, 16, 0, "Maximum pre-fetch", (char const   *)((void *)0)}, 
        {"MAPFC",
      8, 0, 0, 10, 7, 16, 0, "Maximum pre-fetch ceiling", (char const   *)((void *)0)}, 
        {"FSW",
      8, 0, 0, 12, 7, 1, 0, "Force sequential write", (char const   *)((void *)0)}, 
        {"LBCSS",
      8, 0, 0, 12, 6, 1, 0, "Logical block cache segment size", "0: CSS unit is bytes; 1: CSS unit is blocks"}, 
        {"DRA",
      8, 0, 0, 12, 5, 1, 0, "Disable read ahead", (char const   *)((void *)0)}, 
        {"NV_DIS", 8, 0, 0, 12, 0, 1, 0, "Non-volatile cache disable", (char const   *)((void *)0)}, 
        {"NCS",
      8, 0, 0, 13, 7, 8, 0, "Number of cache segments", (char const   *)((void *)0)}, 
        {"CSS",
      8, 0, 0, 14, 7, 16, 0, "Cache segment size", (char const   *)((void *)0)}, 
        {"TST", 10, 0, -1, 2, 7, 3, 0, "Task set type", "0: lu maintains one task set for all I_T nexuses\t1: lu maintains separate task sets for each I_T nexus"}, 
        {"TMF_ONLY",
      10, 0, -1, 2, 4, 1, 0, "Task management functions only", (char const   *)((void *)0)}, 
        {"DPICZ",
      10, 0, -1, 2, 3, 1, 0, "Disable protection information check if protect field zero",
      (char const   *)((void *)0)}, 
        {"D_SENSE", 10, 0, -1, 2, 2, 1, 0, "Descriptor format sense data", (char const   *)((void *)0)}, 
        {"GLTSD",
      10, 0, -1, 2, 1, 1, 0, "Global logging target save disable", (char const   *)((void *)0)}, 
        {"RLEC",
      10, 0, -1, 2, 0, 1, 0, "Report log exception condition", (char const   *)((void *)0)}, 
        {"QAM",
      10, 0, -1, 3, 7, 4, 0, "Queue algorithm modifier", "0: restricted re-ordering; 1: unrestricted"}, 
        {"NUAR",
      10, 0, -1, 3, 3, 1, 0, "No unit attention on release", (char const   *)((void *)0)}, 
        {"QERR",
      10, 0, -1, 3, 2, 2, 0, "Queue error management", "0: only affected task gets CC; 1: affected tasks aborted\t3: affected tasks aborted on same I_T nexus"}, 
        {"RAC",
      10, 0, -1, 4, 6, 1, 0, "Report a check", (char const   *)((void *)0)}, 
        {"UA_INTLCK", 10, 0, -1, 4, 5, 2, 0, "Unit attention interlocks control", "0: unit attention cleared with check condition status\t2: unit attention not cleared with check condition status\t3: as 2 plus ua on busy, task set full or reservation conflict"}, 
        {"SWP",
      10, 0, -1, 4, 3, 1, 1, "Software write protect", (char const   *)((void *)0)}, 
        {"ATO",
      10, 0, -1, 5, 7, 1, 0, "Application tag owner", (char const   *)((void *)0)}, 
        {"TAS",
      10, 0, -1, 5, 6, 1, 0, "Task aborted status", "0: tasks aborted without response to app client\t1: any other I_T nexuses receive task aborted"}, 
        {"ATMPE",
      10, 0, -1, 5, 5, 1, 0, "Application tag mode page enabled", (char const   *)((void *)0)}, 
        {"RWWP",
      10, 0, -1, 5, 4, 1, 0, "Reject write without protection", (char const   *)((void *)0)}, 
        {"AUTOLOAD",
      10, 0, -1, 5, 2, 3, 0, "Autoload mode", "0: medium loaded for full access\t1: loaded for medium auxiliary access only\t2: medium shall not be loaded"}, 
        {"BTP",
      10, 0, -1, 8, 7, 16, 0, "Busy timeout period (100us)", "0: undefined\t0ffffh (-1): unlimited"}, 
        {"ESTCT",
      10, 0, -1, 10, 7, 16, 0, "Extended self test completion time (sec)", "0ffffh (-1) takes 65535 seconds or longer"}, 
        {"TCMOS",
      10, 1, -1, 4, 2, 1, 0, "Timestamp changeable by methods outside standard", (char const   *)((void *)0)}, 
        {"SCSIP",
      10, 1, -1, 4, 1, 1, 0, "SCSI timestamp commands take precedence over other methods",
      (char const   *)((void *)0)}, 
        {"IALUAE", 10, 1, -1, 4, 0, 1, 0, "Implicit asymmetric logical unit access enabled",
      (char const   *)((void *)0)}, 
        {"INIT_PR", 10, 1, -1, 5, 3, 4, 0, "Initial command priority", "0: none or vendor\t1: highest\t15: lowest"}, 
        {"AT_LAST",
      10, 2, 0, 16, 7, 1, 0, "Last", (char const   *)((void *)0)}, 
        {"AT_LBAT", 10, 2, 0, 22, 7, 16, 0, "Logical block application tag", (char const   *)((void *)0)}, 
        {"AT_LBA",
      10, 2, 0, 24, 7, 64, 2, "Logical block address", (char const   *)((void *)0)}, 
        {"AT_COUNT",
      10, 2, 0, 32, 7, 64, 2, "Logical block count", (char const   *)((void *)0)}, 
        {"LBPM",
      10, 240, 1, 4, 7, 8, 0, "Logical block protection method", "0: none\t1: Reed-Solomon CRC"}, 
        {"LBPIL",
      10, 240, 1, 5, 5, 6, 0, "Logical block protection information length", (char const   *)((void *)0)}, 
        {"LBP_W",
      10, 240, 1, 6, 7, 1, 0, "Logical block protection during write", (char const   *)((void *)0)}, 
        {"LBP_R",
      10, 240, 1, 6, 6, 1, 0, "Logical block protection during read", (char const   *)((void *)0)}, 
        {"RBDP",
      10, 240, 1, 6, 5, 1, 0, "Recover buffered data protected", (char const   *)((void *)0)}, 
        {"MWD2",
      10, 241, -1, 4, 6, 1, 0, "Multi word DMA bit 2", (char const   *)((void *)0)}, 
        {"MWD1",
      10, 241, -1, 4, 5, 1, 0, "Multi word DMA bit 1", (char const   *)((void *)0)}, 
        {"MWD0",
      10, 241, -1, 4, 4, 1, 0, "Multi word DMA bit 0", (char const   *)((void *)0)}, 
        {"PIO4",
      10, 241, -1, 4, 1, 1, 0, "Parallel IO bit 4", (char const   *)((void *)0)}, 
        {"PIO3", 10, 241, -1, 4, 0, 1, 0, "Parallel IO bit 3", (char const   *)((void *)0)}, 
        {"UDMA6",
      10, 241, -1, 5, 6, 1, 0, "Ultra DMA bit 6", (char const   *)((void *)0)}, 
        {"UDMA5", 10, 241, -1, 5, 5, 1, 0, "Ultra DMA bit 5", (char const   *)((void *)0)}, 
        {"UDMA4",
      10, 241, -1, 5, 4, 1, 0, "Ultra DMA bit 4", (char const   *)((void *)0)}, 
        {"UDMA3", 10, 241, -1, 5, 3, 1, 0, "Ultra DMA bit 3", (char const   *)((void *)0)}, 
        {"UDMA2",
      10, 241, -1, 5, 2, 1, 0, "Ultra DMA bit 2", (char const   *)((void *)0)}, 
        {"UDMA1", 10, 241, -1, 5, 1, 1, 0, "Ultra DMA bit 1", (char const   *)((void *)0)}, 
        {"UDMA0",
      10, 241, -1, 5, 0, 1, 0, "Ultra DMA bit 0", (char const   *)((void *)0)}, 
        {"IDLE-OLD", 13, 0, 0, 3, 1, 1, 0, "Idle timer active", (char const   *)((void *)0)}, 
        {"STBY-OLD",
      13, 0, 0, 3, 0, 1, 0, "Standby timer active", (char const   *)((void *)0)}, 
        {"ICT-OLD", 13, 0, 0, 4, 7, 32, 0, "Idle condition timer (100 ms)", (char const   *)((void *)0)}, 
        {"SCT-OLD",
      13, 0, 0, 8, 7, 32, 0, "Standby condition timer (100 ms)", (char const   *)((void *)0)}, 
        {"DCE",
      15, 0, 1, 2, 7, 1, 1, "Data compression enable", (char const   *)((void *)0)}, 
        {"DCC",
      15, 0, 1, 2, 6, 1, 1, "Data compression capable", (char const   *)((void *)0)}, 
        {"DDE",
      15, 0, 1, 3, 7, 1, 1, "Data decompression enable", (char const   *)((void *)0)}, 
        {"RED",
      15, 0, 1, 3, 6, 2, 0, "Report exception on decompression", (char const   *)((void *)0)}, 
        {"COMPR_A",
      15, 0, 1, 4, 7, 32, 0, "Compression algorithm", "0: none; 5: ALDC (2048 byte): 16: IDRC; 32: DCLZ"}, 
        {"DCOMPR_A",
      15, 0, 1, 8, 7, 32, 0, "Decompression algorithm", "0: none; 5: ALDC (2048 byte): 16: IDRC; 32: DCLZ"}, 
        {"XORDIS",
      16, 0, 0, 2, 1, 1, 0, "XOR disable", (char const   *)((void *)0)}, 
        {"MXWS", 16, 0, 0, 4, 7, 32, 0, "Maximum XOR write size (blocks)", (char const   *)((void *)0)}, 
        {"CAF",
      16, 0, 1, 2, 5, 1, 0, "Change active format", (char const   *)((void *)0)}, 
        {"ACT_F", 16, 0, 1, 2, 4, 5, 0, "Active format", (char const   *)((void *)0)}, 
        {"ACT_P",
      16, 0, 1, 3, 7, 8, 0, "Active partition", (char const   *)((void *)0)}, 
        {"WOBFR", 16, 0, 1, 4, 7, 8, 0, "Write object buffer full ratio", (char const   *)((void *)0)}, 
        {"ROBER",
      16, 0, 1, 5, 7, 8, 0, "Read object buffer empty ratio", (char const   *)((void *)0)}, 
        {"WDT",
      16, 0, 1, 6, 7, 16, 0, "Write delay time (100 ms)", (char const   *)((void *)0)}, 
        {"OBR",
      16, 0, 1, 8, 7, 1, 0, "Object buffer recovery", (char const   *)((void *)0)}, 
        {"LOIS",
      16, 0, 1, 8, 6, 1, 0, "Logical object identifiers supported", (char const   *)((void *)0)}, 
        {"RSMK",
      16, 0, 1, 8, 5, 1, 1, "Report setmarks (obsolete)", (char const   *)((void *)0)}, 
        {"AVC",
      16, 0, 1, 8, 4, 1, 0, "Automatic velocity control", (char const   *)((void *)0)}, 
        {"SOCF",
      16, 0, 1, 8, 3, 2, 0, "Stop on consecutive filemarks", (char const   *)((void *)0)}, 
        {"ROBO",
      16, 0, 1, 8, 1, 1, 0, "Recover object buffer order", (char const   *)((void *)0)}, 
        {"REW",
      16, 0, 1, 8, 0, 1, 0, "Report early warning", (char const   *)((void *)0)}, 
        {"GAP_S", 16, 0, 1, 9, 7, 8, 0, "Gap size (obsolete)", (char const   *)((void *)0)}, 
        {"EOD_D",
      16, 0, 1, 10, 7, 3, 0, "EOD (end-of-data) defined", "0: default; 1: format defined; 2: SOCF; 3: not supported"}, 
        {"EEG",
      16, 0, 1, 10, 4, 1, 0, "Enable EOD generation", (char const   *)((void *)0)}, 
        {"SEW",
      16, 0, 1, 10, 3, 1, 1, "Synchronize early warning", (char const   *)((void *)0)}, 
        {"SWP_T",
      16, 0, 1, 10, 2, 1, 0, "Software write protect (tape)", (char const   *)((void *)0)}, 
        {"BAML",
      16, 0, 1, 10, 1, 1, 0, "Block address mode lock", (char const   *)((void *)0)}, 
        {"BAM",
      16, 0, 1, 10, 0, 1, 0, "Block address mode", (char const   *)((void *)0)}, 
        {"OBSAEW", 16, 0, 1, 11, 7, 24, 0, "Object buffer size at early warning", (char const   *)((void *)0)}, 
        {"SDCA",
      16, 0, 1, 14, 7, 8, 1, "Select data compression algorithm", (char const   *)((void *)0)}, 
        {"WTRE",
      16, 0, 1, 15, 7, 2, 0, "WORM tamper read enable", (char const   *)((void *)0)}, 
        {"OIR",
      16, 0, 1, 15, 5, 1, 0, "Only if reserved", (char const   *)((void *)0)}, 
        {"ROR", 16, 0, 1, 15, 4, 2, 0, "Rewind on reset", "0: vendor specific; 1: to BOP 0 on lu reset\t2: hold position on lu reset"}, 
        {"ASOCWP",
      16, 0, 1, 15, 2, 1, 0, "Associated write protection", (char const   *)((void *)0)}, 
        {"PERSWP",
      16, 0, 1, 15, 1, 1, 0, "Persistent write protection", (char const   *)((void *)0)}, 
        {"PRMWP",
      16, 0, 1, 15, 0, 1, 0, "Permanent write protection", (char const   *)((void *)0)}, 
        {"TARPF",
      16, 1, 1, 4, 3, 1, 0, "TapeAlert respect parameter fields", (char const   *)((void *)0)}, 
        {"TASER",
      16, 1, 1, 4, 2, 1, 0, "TapeAlert select except reporting", (char const   *)((void *)0)}, 
        {"TARPC",
      16, 1, 1, 4, 1, 1, 0, "TapeAlert respect page control", (char const   *)((void *)0)}, 
        {"TAPLSD",
      16, 1, 1, 4, 0, 1, 0, "TapeAlert prevent log sense deactivation", (char const   *)((void *)0)}, 
        {"SEM",
      16, 1, 1, 5, 3, 4, 0, "Short erase mode", "0: as per SSC-2; 1: erase has no effect; 2: record EOD indication"}, 
        {"MAX_AP",
      17, 0, 1, 2, 7, 8, 0, "Maximum additional partitions", (char const   *)((void *)0)}, 
        {"APD",
      17, 0, 1, 3, 7, 8, 0, "Additional partitions defined", (char const   *)((void *)0)}, 
        {"FDP",
      17, 0, 1, 4, 7, 1, 0, "Fixed data partitions", (char const   *)((void *)0)}, 
        {"SDP",
      17, 0, 1, 4, 6, 1, 0, "Select data partitions", (char const   *)((void *)0)}, 
        {"IDP",
      17, 0, 1, 4, 5, 1, 0, "Initiator defined partitions", (char const   *)((void *)0)}, 
        {"PSUM",
      17, 0, 1, 4, 4, 2, 0, "Partition size unit of measure", "0: bytes; 1: kilobytes; 2: megabytes; 3: 10**(partition_units)"}, 
        {"POFM",
      17, 0, 1, 4, 2, 1, 0, "Partition on format", (char const   *)((void *)0)}, 
        {"CLEAR", 17, 0, 1, 4, 1, 1, 0, "Erase partition(s) (in concert with ADDP)",
      (char const   *)((void *)0)}, 
        {"ADDP", 17, 0, 1, 4, 0, 1, 0, "Additional partition bit (in concert with CLEAR)",
      (char const   *)((void *)0)}, 
        {"MFR", 17, 0, 1, 5, 7, 8, 0, "Medium format recognition", "0: incapable; 1: format recognition; 2: partition recognition\t3: format and partition recognition"}, 
        {"PART_U",
      17, 0, 1, 6, 3, 4, 0, "Partition units (exponent of 10, bytes)", (char const   *)((void *)0)}, 
        {"P_SZ",
      17, 0, 1, 8, 7, 16, 0, "Partition size", (char const   *)((void *)0)}, 
        {"ENBLTC", 20, 0, 13, 5, 0, 1, 1, "Enable timed completion", (char const   *)((void *)0)}, 
        {"MTCT",
      20, 0, 13, 6, 7, 16, 1, "Maximum task completion time (100ms)", (char const   *)((void *)0)}, 
        {"LUPID",
      24, 0, -1, 2, 3, 4, 0, "Logical unit\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi\t[try adding \'-t <transport>\' to get more fields]"}, 
        {"PPID",
      25, 0, -1, 2, 3, 4, 0, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi\t[try adding \'-t <transport>\' to get more fields]"}, 
        {"PM_BG",
      26, 0, -1, 2, 7, 2, 0, "Power management, background functions, precedence",
      "0: vendor specific; 1: background function higher\t2: power management higher"}, 
        {"STANDBY_Y",
      26, 0, -1, 2, 0, 1, 0, "Standby_y timer enable", (char const   *)((void *)0)}, 
        {"IDLE_C",
      26, 0, -1, 3, 3, 1, 0, "Idle_c timer enable", (char const   *)((void *)0)}, 
        {"IDLE_B", 26, 0, -1, 3, 2, 1, 0, "Idle_b timer enable", (char const   *)((void *)0)}, 
        {"IDLE",
      26, 0, -1, 3, 1, 1, 0, "Idle_a timer enable", "named IDLE prior to spc4r18, thence IDLE_A"}, 
        {"STANDBY",
      26, 0, -1, 3, 0, 1, 0, "Standby_z timer enable", "named STANDBY prior to spc4r18, thence STANDBY_Z"}, 
        {"ICT",
      26, 0, -1, 4, 7, 32, 0, "Idle_a condition timer (100 ms)", "named IDLE prior to spc4r18, thence IDLE_A"}, 
        {"SCT",
      26, 0, -1, 8, 7, 32, 0, "Standby_z condition timer (100 ms)", "named STANDBY prior to spc4r18, thence STANDBY_Z"}, 
        {"IBCT",
      26, 0, -1, 12, 7, 32, 0, "Idle_b condition timer (100 ms)", (char const   *)((void *)0)}, 
        {"ICCT",
      26, 0, -1, 16, 7, 32, 0, "Idle_c condition timer (100 ms)", (char const   *)((void *)0)}, 
        {"SYCT",
      26, 0, -1, 20, 7, 32, 0, "Standby_y condition timer (100 ms)", (char const   *)((void *)0)}, 
        {"FIDCPC",
      26, 0, -1, 39, 7, 2, 0, "From idle command processing control", "0: reserved (SAS-2); 1: disabled; 2: enabled\n"}, 
        {"FSBCPC",
      26, 0, -1, 39, 5, 2, 0, "From standby command processing control", "0: reserved (SAS-2); 1: disabled; 2: enabled\n"}, 
        {"FSTCPC",
      26, 0, -1, 39, 3, 2, 0, "From stopped command processing control", "0: reserved (SAS-2); 1: disabled; 2: enabled\n"}, 
        {"ps_id",
      26, 1, -1, 7, 7, 8, 0, "Power consumption identifier", "references Power consumption VPD page"}, 
        {"APMP",
      26, 241, -1, 5, 0, 1, 0, "Advanced Power Management (APM) enabled/change", (char const   *)((void *)0)}, 
        {"APM",
      26, 241, -1, 6, 7, 8, 0, "Advanced Power Management (APM) value", (char const   *)((void *)0)}, 
        {"PERF",
      28, 0, -1, 2, 7, 1, 0, "Performance (impact of ie operations)", "0: normal (some delays); 1: abridge ie operations"}, 
        {"EBF",
      28, 0, -1, 2, 5, 1, 0, "Enable background function", (char const   *)((void *)0)}, 
        {"EWASC",
      28, 0, -1, 2, 4, 1, 1, "Enable warning", (char const   *)((void *)0)}, 
        {"DEXCPT", 28, 0, -1, 2, 3, 1, 1, "Disable exceptions", (char const   *)((void *)0)}, 
        {"TEST",
      28, 0, -1, 2, 2, 1, 0, "Test (simulate device failure)", (char const   *)((void *)0)}, 
        {"EBACKERR",
      28, 0, -1, 2, 1, 1, 0, "Enable background (scan + self test) error reporting",
      (char const   *)((void *)0)}, 
        {"LOGERR", 28, 0, -1, 2, 0, 1, 0, "Log informational exception errors", (char const   *)((void *)0)}, 
        {"MRIE",
      28, 0, -1, 3, 3, 4, 1, "Method of reporting informational exceptions", "0: no reporting; 1: async reporting (obs); 2: unit attention\t3: conditional recovered error; 4: recovered error\t5: check condition with no sense; 6: request sense only"}, 
        {"INTT",
      28, 0, -1, 4, 7, 32, 0, "Interval timer (100 ms)", (char const   *)((void *)0)}, 
        {"REPC",
      28, 0, -1, 8, 7, 32, 0, "Report count (or Test flag number [SSC-3])", (char const   *)((void *)0)}, 
        {"S_L_FULL",
      28, 1, 0, 4, 2, 1, 0, "Suspend on log full", (char const   *)((void *)0)}, 
        {"LOWIR", 28, 1, 0, 4, 1, 1, 0, "Log only when intervention required", (char const   *)((void *)0)}, 
        {"EN_BMS",
      28, 1, 0, 4, 0, 1, 0, "Enable background medium scan", (char const   *)((void *)0)}, 
        {"EN_PS",
      28, 1, 0, 5, 0, 1, 0, "Enable pre-scan", (char const   *)((void *)0)}, 
        {"BMS_I", 28, 1, 0, 6, 7, 16, 0, "Background medium scan interval time (hour)",
      (char const   *)((void *)0)}, 
        {"BPS_TL", 28, 1, 0, 8, 7, 16, 0, "Background pre-scan time limit (hour)", (char const   *)((void *)0)}, 
        {"MIN_IDLE",
      28, 1, 0, 10, 7, 16, 0, "Minumum idle time before background scan (ms)", (char const   *)((void *)0)}, 
        {"MAX_SUSP",
      28, 1, 0, 12, 7, 16, 0, "Maximum time to suspend background scan (ms)", (char const   *)((void *)0)}, 
        {"SITUA",
      28, 2, 0, 4, 0, 1, 0, "Single initiator threshold unit attention", (char const   *)((void *)0)}, 
        {"LBP_EN",
      28, 2, 0, 16, 7, 1, 0, "Threshold enabled", (char const   *)((void *)0)}, 
        {"LBP_TYPE", 28, 2, 0, 16, 5, 3, 0, "Threshold type", (char const   *)((void *)0)}, 
        {"LBP_ARM",
      28, 2, 0, 16, 2, 3, 0, "Threshold arming", (char const   *)((void *)0)}, 
        {"LBP_RES", 28, 2, 0, 17, 7, 8, 0, "Threshold resource", (char const   *)((void *)0)}, 
        {"LBP_COUNT",
      28, 2, 0, 20, 7, 32, 0, "Threshold count", (char const   *)((void *)0)}, 
        {"WORMM", 29, 0, 1, 2, 0, 1, 0, "Worm mode", (char const   *)((void *)0)}, 
        {"WMLR", 29, 0, 1, 4, 7, 8, 0, "Worm mode label restrictions", "0: disallow overwrite; 1: disallow some format labels overwrite\t2: allow all format labels to be overwritten"}, 
        {"WMFR",
      29, 0, 1, 5, 7, 8, 0, "Worm mode filemark restrictions", "2: allow filemarks before EOD except closest to BOP\t3: allow any number of filemarks before EOD"}, 
        {"G3E",
      29, 0, 5, 4, 3, 1, 0, "Group 3 timeout capability enable", (char const   *)((void *)0)}, 
        {"TMOE",
      29, 0, 5, 4, 2, 1, 0, "Timeout enable", (char const   *)((void *)0)}, 
        {"DISP", 29, 0, 5, 4, 1, 1, 0, "Disable (unavailable) until power cycle", (char const   *)((void *)0)}, 
        {"SWPP",
      29, 0, 5, 4, 0, 1, 0, "Software write protect until power cycle", (char const   *)((void *)0)}, 
        {"G1MT",
      29, 0, 5, 6, 7, 16, 0, "Group 1 minimum timeout (sec)", (char const   *)((void *)0)}, 
        {"G2MT",
      29, 0, 5, 8, 7, 16, 0, "Group 2 minimum timeout (sec)", (char const   *)((void *)0)}, 
        {"FMTEA",
      29, 0, 8, 2, 7, 16, 0, "First medium transport element address", (char const   *)((void *)0)}, 
        {"NMTE",
      29, 0, 8, 4, 7, 16, 0, "Number of medium transport elements", (char const   *)((void *)0)}, 
        {"FSEA",
      29, 0, 8, 6, 7, 16, 0, "First storage element address", (char const   *)((void *)0)}, 
        {"NSE",
      29, 0, 8, 8, 7, 16, 0, "Number of storage elements", (char const   *)((void *)0)}, 
        {"FIEEA",
      29, 0, 8, 10, 7, 16, 0, "First import/export element address", (char const   *)((void *)0)}, 
        {"NIEE",
      29, 0, 8, 12, 7, 16, 0, "Number of import/export elements", (char const   *)((void *)0)}, 
        {"FDTEA",
      29, 0, 8, 14, 7, 16, 0, "First data transfer element address", (char const   *)((void *)0)}, 
        {"NDTE",
      29, 0, 8, 16, 7, 16, 0, "Number of data transfer elements", (char const   *)((void *)0)}, 
        {"ROTAT",
      30, 0, 8, 2, 0, 1, 0, "Rotation for double sided media handling", (char const   *)((void *)0)}, 
        {"MNTES",
      30, 0, 8, 3, 7, 8, 0, "Member number in transport element set", (char const   *)((void *)0)}, 
        {"STORDT",
      31, 0, 8, 2, 3, 1, 0, "Storage for data transfer element", (char const   *)((void *)0)}, 
        {"STORIE",
      31, 0, 8, 2, 2, 1, 0, "Storage for import/export element", (char const   *)((void *)0)}, 
        {"STORST",
      31, 0, 8, 2, 1, 1, 0, "Storage for storage element", (char const   *)((void *)0)}, 
        {"STORMT",
      31, 0, 8, 2, 0, 1, 0, "Storage for medium transport element", (char const   *)((void *)0)}, 
        {"ACE",
      31, 0, 8, 3, 2, 1, 0, "Auto clean enabled", (char const   *)((void *)0)}, 
        {"VTRP", 31, 0, 8, 3, 1, 1, 0, "Volume tag reader present", (char const   *)((void *)0)}, 
        {"S2C",
      31, 0, 8, 3, 0, 1, 0, "SMC-2 capabilities supported", (char const   *)((void *)0)}, 
        {"MT_RA",
      31, 0, 8, 4, 7, 2, 0, "Medium transport elements support Read Attribute", (char const   *)((void *)0)}, 
        {"MT2DT",
      31, 0, 8, 4, 3, 1, 0, "Medium transport -> data transfer; Move Medium", (char const   *)((void *)0)}, 
        {"MT2IE",
      31, 0, 8, 4, 2, 1, 0, "Medium transport -> import/export; Move Medium", (char const   *)((void *)0)}, 
        {"MT2ST",
      31, 0, 8, 4, 1, 1, 0, "Medium transport -> storage; Move Medium", (char const   *)((void *)0)}, 
        {"MT2MT",
      31, 0, 8, 4, 0, 1, 0, "Medium transport -> medium transport; Move Medium", (char const   *)((void *)0)}, 
        {"ST_RA",
      31, 0, 8, 5, 7, 2, 0, "Storage elements support Read Attribute", (char const   *)((void *)0)}, 
        {"ST2DT",
      31, 0, 8, 5, 3, 1, 0, "Storage -> data transfer; Move Medium", (char const   *)((void *)0)}, 
        {"ST2IE",
      31, 0, 8, 5, 2, 1, 0, "Storage -> import/export; Move Medium", (char const   *)((void *)0)}, 
        {"ST2ST",
      31, 0, 8, 5, 1, 1, 0, "Storage -> storage; Move Medium", (char const   *)((void *)0)}, 
        {"ST2MT",
      31, 0, 8, 5, 0, 1, 0, "Storage -> medium transport; Move Medium", (char const   *)((void *)0)}, 
        {"IE_RA",
      31, 0, 8, 6, 7, 2, 0, "Import/export elements support Read Attribute", (char const   *)((void *)0)}, 
        {"IE2DT",
      31, 0, 8, 6, 3, 1, 0, "Import/export -> data transfer; Move Medium", (char const   *)((void *)0)}, 
        {"IE2IE",
      31, 0, 8, 6, 2, 1, 0, "Import/export -> import/export; Move Medium", (char const   *)((void *)0)}, 
        {"IE2ST",
      31, 0, 8, 6, 1, 1, 0, "Import/export -> storage; Move Medium", (char const   *)((void *)0)}, 
        {"IE2MT",
      31, 0, 8, 6, 0, 1, 0, "Import/export -> medium transport; Move Medium", (char const   *)((void *)0)}, 
        {"DT_RA",
      31, 0, 8, 7, 7, 2, 0, "Data transfer elements support Read Attribute", (char const   *)((void *)0)}, 
        {"DT2DT",
      31, 0, 8, 7, 3, 1, 0, "Data transfer -> data transfer; Move Medium", (char const   *)((void *)0)}, 
        {"DT2IE",
      31, 0, 8, 7, 2, 1, 0, "Data transfer -> import/export; Move Medium", (char const   *)((void *)0)}, 
        {"DT2ST",
      31, 0, 8, 7, 1, 1, 0, "Data transfer -> storage; Move Medium", (char const   *)((void *)0)}, 
        {"DT2MT",
      31, 0, 8, 7, 0, 1, 0, "Data transfer -> medium transport; Move Medium", (char const   *)((void *)0)}, 
        {"MT_WA",
      31, 0, 8, 12, 7, 2, 0, "Medium transport elements support Write Attribute",
      (char const   *)((void *)0)}, 
        {"MTEDT", 31, 0, 8, 12, 3, 1, 0, "Medium transport -> data transfer; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"MTEIE", 31, 0, 8, 12, 2, 1, 0, "Medium transport -> import/export; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"MTEST", 31, 0, 8, 12, 1, 1, 0, "Medium transport -> storage; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"MTEMT", 31, 0, 8, 12, 0, 1, 0, "Medium transport -> medium transport; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"ST_WA", 31, 0, 8, 13, 7, 2, 0, "Storage elements support Write Attribute",
      (char const   *)((void *)0)}, 
        {"STEDT", 31, 0, 8, 13, 3, 1, 0, "Storage -> data transfer; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"STEIE", 31, 0, 8, 13, 2, 1, 0, "Storage -> import/export; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"STEST", 31, 0, 8, 13, 1, 1, 0, "Storage -> storage; Exchange Medium", (char const   *)((void *)0)}, 
        {"STEMT",
      31, 0, 8, 13, 0, 1, 0, "Storage -> medium transport; Exchange Medium", (char const   *)((void *)0)}, 
        {"IE_WA",
      31, 0, 8, 14, 7, 2, 0, "Import/export elements support Write Attribute", (char const   *)((void *)0)}, 
        {"IEEDT",
      31, 0, 8, 14, 3, 1, 0, "Import/export -> data transfer; Exchange Medium", (char const   *)((void *)0)}, 
        {"IEEIE",
      31, 0, 8, 14, 2, 1, 0, "Import/export -> import/export; Exchange Medium", (char const   *)((void *)0)}, 
        {"IEEST",
      31, 0, 8, 14, 1, 1, 0, "Import/export -> storage; Exchange Medium", (char const   *)((void *)0)}, 
        {"IEEMT",
      31, 0, 8, 14, 0, 1, 0, "Import/export -> medium transport; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"DT_WA", 31, 0, 8, 15, 7, 2, 0, "Data transfer elements support Write Attribute",
      (char const   *)((void *)0)}, 
        {"DTEDT", 31, 0, 8, 15, 3, 1, 0, "Data transfer -> data transfer; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"DTEIE", 31, 0, 8, 15, 2, 1, 0, "Data transfer -> import/export; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"DTEST", 31, 0, 8, 15, 1, 1, 0, "Data transfer -> storage; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"DTEMT", 31, 0, 8, 15, 0, 1, 0, "Data transfer -> medium transport; Exchange Medium",
      (char const   *)((void *)0)}, 
        {"MVPRV", 31, 65, 8, 4, 5, 1, 0, "Move prevented to import/export element", (char const   *)((void *)0)}, 
        {"MVCL",
      31, 65, 8, 4, 4, 1, 0, "Move closes import/export element", (char const   *)((void *)0)}, 
        {"MVOP",
      31, 65, 8, 4, 3, 1, 0, "Move opens import/export element", (char const   *)((void *)0)}, 
        {"USRCL",
      31, 65, 8, 4, 2, 1, 0, "User control import/export element close", (char const   *)((void *)0)}, 
        {"USROP",
      31, 65, 8, 4, 1, 1, 0, "User control import/export element open", (char const   *)((void *)0)}, 
        {"IEST",
      31, 65, 8, 4, 0, 1, 0, "Import/export element state", (char const   *)((void *)0)}, 
        {"DTETA",
      31, 65, 8, 5, 4, 1, 0, "Data transfer element empty on door access", (char const   *)((void *)0)}, 
        {"RSSEA",
      31, 65, 8, 5, 3, 1, 0, "Return to source storage element address", (char const   *)((void *)0)}, 
        {"MVTRY",
      31, 65, 8, 5, 2, 1, 0, "Move tray", (char const   *)((void *)0)}, 
        {"IEMGZ", 31, 65, 8, 5, 1, 1, 0, "Import/export magazine", (char const   *)((void *)0)}, 
        {"SMGZ",
      31, 65, 8, 5, 0, 1, 0, "Storage magazine", (char const   *)((void *)0)}, 
        {"TREXC", 31, 65, 8, 6, 2, 1, 0, "True exchange capable", (char const   *)((void *)0)}, 
        {"LCKIE",
      31, 65, 8, 6, 1, 1, 0, "Lock import/export element", (char const   *)((void *)0)}, 
        {"LCKD",
      31, 65, 8, 6, 0, 1, 0, "Lock door", (char const   *)((void *)0)}, 
        {"SPMER", 31, 65, 8, 7, 2, 1, 0, "Source pre-move eject required", (char const   *)((void *)0)}, 
        {"DPMER",
      31, 65, 8, 7, 1, 1, 0, "Destination pre-move eject required", (char const   *)((void *)0)}, 
        {"PEPOS",
      31, 65, 8, 7, 0, 1, 0, "Pre-eject position", (char const   *)((void *)0)}, 
        {"UCST", 31, 65, 8, 8, 0, 1, 0, "Unassigned cleaning storage", (char const   *)((void *)0)}, 
        {"D_RAM_R",
      42, 0, 5, 2, 5, 1, 0, "DVD-RAM read", (char const   *)((void *)0)}, 
        {"D_R_R", 42, 0, 5, 2, 4, 1, 0, "DVD-R read", (char const   *)((void *)0)}, 
        {"D_ROM_R", 42, 0, 5, 2, 3, 1, 0, "DVD-ROM read", (char const   *)((void *)0)}, 
        {"METH2",
      42, 0, 5, 2, 2, 1, 0, "Method 2", (char const   *)((void *)0)}, 
        {"CD_RW_R", 42, 0, 5, 2, 1, 1, 0, "CD-RW read", (char const   *)((void *)0)}, 
        {"CD_R_R",
      42, 0, 5, 2, 0, 1, 0, "CD-R read", (char const   *)((void *)0)}, 
        {"D_RAM_W", 42, 0, 5, 3, 5, 1, 0, "DVD-RAM write", (char const   *)((void *)0)}, 
        {"D_R_W",
      42, 0, 5, 3, 4, 1, 0, "DVD-R write", (char const   *)((void *)0)}, 
        {"TST_WR", 42, 0, 5, 3, 2, 1, 0, "Test write", (char const   *)((void *)0)}, 
        {"CD_RW_W", 42, 0, 5, 3, 1, 1, 0, "CD-RW write", (char const   *)((void *)0)}, 
        {"CD_R_W",
      42, 0, 5, 3, 0, 1, 0, "CD-R write", (char const   *)((void *)0)}, 
        {"BUF", 42, 0, 5, 4, 7, 1, 0, "Buffer underrun free recording", (char const   *)((void *)0)}, 
        {"MULT_S",
      42, 0, 5, 4, 6, 1, 0, "Multi session", (char const   *)((void *)0)}, 
        {"M2F2", 42, 0, 5, 4, 5, 1, 0, "Mode 2 form 2", (char const   *)((void *)0)}, 
        {"M2F1",
      42, 0, 5, 4, 4, 1, 0, "Mode 2 form 1", (char const   *)((void *)0)}, 
        {"DP_2", 42, 0, 5, 4, 3, 1, 0, "Digital port 2", (char const   *)((void *)0)}, 
        {"DP_1",
      42, 0, 5, 4, 2, 1, 0, "Digital port 1", (char const   *)((void *)0)}, 
        {"COMP", 42, 0, 5, 4, 1, 1, 0, "Composite", (char const   *)((void *)0)}, 
        {"AUDIO_P", 42, 0, 5, 4, 0, 1, 0, "Audio play", (char const   *)((void *)0)}, 
        {"RBC",
      42, 0, 5, 5, 7, 1, 0, "Read bar code", (char const   *)((void *)0)}, 
        {"UPC", 42, 0, 5, 5, 6, 1, 0, "Uniform product code", (char const   *)((void *)0)}, 
        {"ISRC",
      42, 0, 5, 5, 5, 1, 0, "International standard recording code", (char const   *)((void *)0)}, 
        {"C2PS",
      42, 0, 5, 5, 4, 1, 0, "C 2 pointers supported", (char const   *)((void *)0)}, 
        {"RW_DC",
      42, 0, 5, 5, 3, 1, 0, "R-W de-interleaved and corrected", (char const   *)((void *)0)}, 
        {"RW_S",
      42, 0, 5, 5, 2, 1, 0, "R-W supported", (char const   *)((void *)0)}, 
        {"CDDA_SA", 42, 0, 5, 5, 1, 1, 0, "CD-DA stream accurate", (char const   *)((void *)0)}, 
        {"CDDA_CS",
      42, 0, 5, 5, 0, 1, 0, "CD-DA commands supported", (char const   *)((void *)0)}, 
        {"LMT",
      42, 0, 5, 6, 7, 3, 0, "Loading mechanism type", (char const   *)((void *)0)}, 
        {"EJECT",
      42, 0, 5, 6, 3, 1, 0, "Eject (individual or magazine)", (char const   *)((void *)0)}, 
        {"PJ",
      42, 0, 5, 6, 2, 1, 0, "Prevent jumper", (char const   *)((void *)0)}, 
        {"LS", 42, 0, 5, 6, 1, 1, 0, "Lock state", (char const   *)((void *)0)}, 
        {"LOCK", 42, 0, 5, 6, 0, 1, 0, "Lock (supported)", (char const   *)((void *)0)}, 
        {"RWILI",
      42, 0, 5, 7, 5, 1, 0, "R-W in lead in", (char const   *)((void *)0)}, 
        {"SCC", 42, 0, 5, 7, 4, 1, 0, "Side change capable", (char const   *)((void *)0)}, 
        {"SSS",
      42, 0, 5, 7, 3, 1, 0, "Software slot selection", (char const   *)((void *)0)}, 
        {"CSDP",
      42, 0, 5, 7, 2, 1, 0, "Changer supports disc present", (char const   *)((void *)0)}, 
        {"SCM",
      42, 0, 5, 7, 1, 1, 0, "Separate channel mute", (char const   *)((void *)0)}, 
        {"SVL",
      42, 0, 5, 7, 0, 1, 0, "Separate volume levels", (char const   *)((void *)0)}, 
        {"MRSS",
      42, 0, 5, 8, 7, 16, 0, "Maximum read speed supported (kBps) (obs)", (char const   *)((void *)0)}, 
        {"NVLS",
      42, 0, 5, 10, 7, 16, 0, "Number of volume levels supported", (char const   *)((void *)0)}, 
        {"BSS",
      42, 0, 5, 12, 7, 16, 0, "Buffer size supported (1024 bytes)", (char const   *)((void *)0)}, 
        {"LENGTH",
      42, 0, 5, 17, 5, 2, 0, "Length (bit length of IEC958 words)", (char const   *)((void *)0)}, 
        {"LSBF",
      42, 0, 5, 17, 3, 1, 0, "LSB (least significant bit) first", (char const   *)((void *)0)}, 
        {"RCK",
      42, 0, 5, 17, 2, 1, 0, "High on LRCK indicates left channel", (char const   *)((void *)0)}, 
        {"BCKF",
      42, 0, 5, 17, 1, 1, 0, "BCK signal falling edge", (char const   *)((void *)0)}, 
        {"CMRS",
      42, 0, 5, 22, 7, 16, 0, "Copy management revision supported", (char const   *)((void *)0)}, 
        {"RCS",
      42, 0, 5, 27, 1, 2, 0, "Rotation control selected", (char const   *)((void *)0)}, 
        {"CWSS",
      42, 0, 5, 28, 7, 16, 0, "Current write speed selected", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 1202 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_item sdparm_mitem_fcp_arr[25]  = 
#line 1202
  {      {"BFR", 2, 0, -1, 2, 7, 8, 0, "Buffer full ratio", (char const   *)((void *)0)}, 
        {"BER",
      2, 0, -1, 3, 7, 8, 0, "Buffer empty ratio", (char const   *)((void *)0)}, 
        {"BIL", 2, 0, -1, 4, 7, 16, 1, "Bus inactivity limit (transmission words)", (char const   *)((void *)0)}, 
        {"DTL",
      2, 0, -1, 6, 7, 16, 1, "Disconnect time limit (128 transmission words)", (char const   *)((void *)0)}, 
        {"CTL",
      2, 0, -1, 8, 7, 16, 1, "Connect time limit (128 transmission words)", (char const   *)((void *)0)}, 
        {"MBS",
      2, 0, -1, 10, 7, 16, 5, "Maximum burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"EMDP",
      2, 0, -1, 12, 7, 1, 4, "Enable modify data pointers", (char const   *)((void *)0)}, 
        {"FAA",
      2, 0, -1, 12, 6, 1, 0, "Fairness access A [FCP_DATA]", (char const   *)((void *)0)}, 
        {"FAB",
      2, 0, -1, 12, 5, 1, 0, "Fairness access B [FCP_XFER]", (char const   *)((void *)0)}, 
        {"FAC",
      2, 0, -1, 12, 4, 1, 0, "Fairness access C [FCP_RSP]", (char const   *)((void *)0)}, 
        {"FBS",
      2, 0, -1, 14, 7, 16, 4, "First burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"LUPID",
      24, 0, -1, 2, 3, 4, 5, "Logical unit\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"EPDC",
      24, 0, -1, 3, 0, 1, 1, "Enable precise delivery checking", (char const   *)((void *)0)}, 
        {"PPID",
      25, 0, -1, 2, 3, 4, 5, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"DTFD",
      25, 0, -1, 3, 7, 1, 1, "Disable target fabric discovery", (char const   *)((void *)0)}, 
        {"PLPB",
      25, 0, -1, 3, 6, 1, 1, "Prevent loop port bypass", (char const   *)((void *)0)}, 
        {"DDIS",
      25, 0, -1, 3, 5, 1, 0, "Disable discovery", (char const   *)((void *)0)}, 
        {"DLM", 25, 0, -1, 3, 4, 1, 0, "Disable loop master", (char const   *)((void *)0)}, 
        {"RHA",
      25, 0, -1, 3, 3, 1, 0, "Require hard address", (char const   *)((void *)0)}, 
        {"ALWI",
      25, 0, -1, 3, 2, 1, 0, "Allow login without loop initialization", (char const   *)((void *)0)}, 
        {"DTIPE",
      25, 0, -1, 3, 1, 1, 0, "Disable target initialized port enable", (char const   *)((void *)0)}, 
        {"DTOLI",
      25, 0, -1, 3, 0, 1, 0, "Disable target originated loop initialization", (char const   *)((void *)0)}, 
        {"RRTVU",
      25, 0, -1, 6, 2, 3, 0, "Resource recovery timeout value unit", (char const   *)((void *)0)}, 
        {"SIRRTV",
      25, 0, -1, 7, 7, 8, 0, "Sequence initiative resource recovery timeout value",
      (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), 0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0),
      (char const   *)((void *)0)}};
#line 1262 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_item sdparm_mitem_spi_arr[60]  = 
#line 1262
  {      {"BFR", 2, 0, -1, 2, 7, 8, 0, "Buffer full ratio", (char const   *)((void *)0)}, 
        {"BER",
      2, 0, -1, 3, 7, 8, 0, "Buffer empty ratio", (char const   *)((void *)0)}, 
        {"BIL", 2, 0, -1, 4, 7, 16, 1, "Bus inactivity limit (100 us)", (char const   *)((void *)0)}, 
        {"PDTL",
      2, 0, -1, 6, 7, 16, 1, "Physical disconnect time limit (100 us)", (char const   *)((void *)0)}, 
        {"CTL",
      2, 0, -1, 8, 7, 16, 1, "Connect time limit (100 us)", (char const   *)((void *)0)}, 
        {"MBS",
      2, 0, -1, 10, 7, 16, 5, "Maximum burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"EMDP",
      2, 0, -1, 12, 7, 1, 4, "Enable modify data pointers", (char const   *)((void *)0)}, 
        {"FA",
      2, 0, -1, 12, 6, 3, 0, "Fair arbitration", (char const   *)((void *)0)}, 
        {"DIMM", 2, 0, -1, 12, 3, 1, 0, "Disconnect immediate", (char const   *)((void *)0)}, 
        {"DTDC",
      2, 0, -1, 12, 2, 3, 0, "Data transfer disconnect control", (char const   *)((void *)0)}, 
        {"LUPID",
      24, 0, -1, 2, 3, 4, 5, "Logical unit\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"PPID",
      25, 0, -1, 2, 3, 4, 5, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"STT",
      25, 0, -1, 4, 7, 16, 1, "Synchronous transfer timeout (ms)", (char const   *)((void *)0)}, 
        {"PPID_1",
      25, 1, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"DS",
      25, 1, -1, 7, 7, 4, 0, "Driver strength", (char const   *)((void *)0)}, 
        {"DA", 25, 1, -1, 8, 7, 4, 0, "Driver asymmetry", (char const   *)((void *)0)}, 
        {"DP",
      25, 1, -1, 8, 3, 4, 0, "Driver precompensation", (char const   *)((void *)0)}, 
        {"DSR",
      25, 1, -1, 9, 7, 4, 0, "Driver slew rate", (char const   *)((void *)0)}, 
        {"PPID_2", 25, 2, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier",
      "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"DB0", 25, 2, -1, 10, 7, 32, 2, "DB(0) value", (char const   *)((void *)0)}, 
        {"DB1",
      25, 2, -1, 14, 7, 32, 2, "DB(1) value", (char const   *)((void *)0)}, 
        {"DB2", 25, 2, -1, 18, 7, 32, 2, "DB(2) value", (char const   *)((void *)0)}, 
        {"DB3",
      25, 2, -1, 22, 7, 32, 2, "DB(3) value", (char const   *)((void *)0)}, 
        {"DB4", 25, 2, -1, 26, 7, 32, 2, "DB(4) value", (char const   *)((void *)0)}, 
        {"DB5",
      25, 2, -1, 30, 7, 32, 2, "DB(5) value", (char const   *)((void *)0)}, 
        {"DB6", 25, 2, -1, 34, 7, 32, 2, "DB(6) value", (char const   *)((void *)0)}, 
        {"DB7",
      25, 2, -1, 38, 7, 32, 2, "DB(7) value", (char const   *)((void *)0)}, 
        {"DB8", 25, 2, -1, 42, 7, 32, 2, "DB(8) value", (char const   *)((void *)0)}, 
        {"DB9",
      25, 2, -1, 46, 7, 32, 2, "DB(9) value", (char const   *)((void *)0)}, 
        {"DB10", 25, 2, -1, 50, 7, 32, 2, "DB(10) value", (char const   *)((void *)0)}, 
        {"DB11",
      25, 2, -1, 54, 7, 32, 2, "DB(11) value", (char const   *)((void *)0)}, 
        {"DB12", 25, 2, -1, 58, 7, 32, 2, "DB(12) value", (char const   *)((void *)0)}, 
        {"DB13",
      25, 2, -1, 62, 7, 32, 2, "DB(13) value", (char const   *)((void *)0)}, 
        {"DB14", 25, 2, -1, 66, 7, 32, 2, "DB(14) value", (char const   *)((void *)0)}, 
        {"DB15",
      25, 2, -1, 70, 7, 32, 2, "DB(15) value", (char const   *)((void *)0)}, 
        {"P_CRCA", 25, 2, -1, 74, 7, 32, 2, "P_CRCA value", (char const   *)((void *)0)}, 
        {"P1",
      25, 2, -1, 78, 7, 32, 2, "P1 value", (char const   *)((void *)0)}, 
        {"BSY", 25, 2, -1, 82, 7, 32, 2, "BSY value", (char const   *)((void *)0)}, 
        {"SEL", 25, 2, -1, 86, 7, 32, 2, "SEL value", (char const   *)((void *)0)}, 
        {"RST", 25, 2, -1, 90, 7, 32, 2, "RST value", (char const   *)((void *)0)}, 
        {"REQ", 25, 2, -1, 94, 7, 32, 2, "REQ value", (char const   *)((void *)0)}, 
        {"ACK", 25, 2, -1, 98, 7, 32, 2, "ACK value", (char const   *)((void *)0)}, 
        {"ATN", 25, 2, -1, 102, 7, 32, 2, "ATN value", (char const   *)((void *)0)}, 
        {"C_D", 25, 2, -1, 106, 7, 32, 2, "C/D value", (char const   *)((void *)0)}, 
        {"I_O", 25, 2, -1, 110, 7, 32, 2, "I/O value", (char const   *)((void *)0)}, 
        {"MSG", 25, 2, -1, 114, 7, 32, 2, "MSG value", (char const   *)((void *)0)}, 
        {"PPID_3", 25, 3, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier",
      "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"TPF", 25, 3, -1, 6, 7, 8, 0, "Transfer period factor", (char const   *)((void *)0)}, 
        {"RAO",
      25, 3, -1, 8, 7, 8, 0, "REQ/ACK offset", (char const   *)((void *)0)}, 
        {"TWE", 25, 3, -1, 9, 7, 8, 0, "Transfer width exponent", (char const   *)((void *)0)}, 
        {"POB",
      25, 3, -1, 10, 6, 7, 0, "Protocol option bits", (char const   *)((void *)0)}, 
        {"TM",
      25, 3, -1, 11, 3, 2, 0, "Transceiver mode", (char const   *)((void *)0)}, 
        {"SPE", 25, 3, -1, 11, 1, 1, 0, "Sent PCOMP_EN bit (for current I_T nexus)",
      (char const   *)((void *)0)}, 
        {"RPE", 25, 3, -1, 11, 0, 1, 0, "Received PCOMP_EN bit (for current I_T nexus)",
      (char const   *)((void *)0)}, 
        {"PPID_4", 25, 4, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier",
      "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"MTPF", 25, 4, -1, 6, 7, 8, 0, "Minimum transfer period factor", (char const   *)((void *)0)}, 
        {"MRAO",
      25, 4, -1, 8, 7, 8, 0, "Maximum REQ/ACK offset", (char const   *)((void *)0)}, 
        {"MTWE",
      25, 4, -1, 9, 7, 8, 0, "Maximum transfer width exponent", (char const   *)((void *)0)}, 
        {"POBS",
      25, 4, -1, 10, 7, 8, 0, "Protocol option bits supported", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 1404 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_item sdparm_mitem_srp_arr[4]  = {      {"MBS", 2, 0, -1, 10, 7, 16, 5, "Maximum burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"EMDP",
      2, 0, -1, 12, 7, 1, 4, "Enable modify data pointers", (char const   *)((void *)0)}, 
        {"FBS",
      2, 0, -1, 14, 7, 16, 4, "First burst size (512 bytes)", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 1416 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
static struct sdparm_mode_page_item sdparm_mitem_sas_arr[57]  = 
#line 1416
  {      {"BITL", 2, 0, -1, 4, 7, 16, 1, "Bus inactivity time limit (100us)", (char const   *)((void *)0)}, 
        {"MCTL",
      2, 0, -1, 8, 7, 16, 1, "Maximum connect time limit (100us)", (char const   *)((void *)0)}, 
        {"MBS",
      2, 0, -1, 10, 7, 16, 5, "Maximum burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"FBS",
      2, 0, -1, 14, 7, 16, 4, "First burst size (512 bytes)", (char const   *)((void *)0)}, 
        {"LUPID",
      24, 0, -1, 2, 3, 4, 5, "Logical unit\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"TLR",
      24, 0, -1, 2, 4, 1, 0, "Transport layer retries (supported)", (char const   *)((void *)0)}, 
        {"PPID",
      25, 0, -1, 2, 3, 4, 5, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"CAWT",
      25, 0, -1, 2, 6, 1, 0, "Continue AWT (arbitration wait time (timer))", (char const   *)((void *)0)}, 
        {"BAE",
      25, 0, -1, 2, 5, 1, 0, "Broadcast asynchronous event", (char const   *)((void *)0)}, 
        {"RLM",
      25, 0, -1, 2, 4, 1, 1, "Ready LED meaning", "0: usually on, flash when command processing; off when stopped\t1: usually off, flash when command processing"}, 
        {"ITNLT",
      25, 0, -1, 4, 7, 16, 1, "I_T nexus loss time (ms)", "0: vendor specific\t0ffffh (-1): never recognize IT nexus loss"}, 
        {"IRT",
      25, 0, -1, 6, 7, 16, 1, "Initiator response timeout (ms)", "0: disable initiator response timeout timer"}, 
        {"RTOL",
      25, 0, -1, 8, 7, 16, 1, "Reject to open limit (10 us)", "0: vendor specific"}, 
        {"PPID_1",
      25, 1, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"GENC",
      25, 1, -1, 6, 7, 8, 0, "Generation code", "0: unknown, 1..255: valid"}, 
        {"NOP", 25, 1, -1, 7, 7, 8, 1, "Number of phys", "one descriptor per phy"}, 
        {"PHID", 25, 1, -1, 9, 7, 8, 0, "Phy identifier", (char const   *)((void *)0)}, 
        {"ADT",
      25, 1, -1, 12, 6, 3, 0, "Attached device type", "0: no device attached; 1: end device\t2: expander device; 3: expander device (fanout, SAS-1.1)"}, 
        {"AREAS",
      25, 1, -1, 12, 3, 4, 0, "Attached reason (other end did link reset)", "0: unknown; 1: power on; 2: hard reset; 3: SMP phy control\t4: loss of dword sync; 5: mux problem; ..."}, 
        {"REAS",
      25, 1, -1, 13, 7, 4, 0, "Reason (for starting link reset)", "0: unknown; 1: power on; 2: hard reset; 3: SMP phy control\t4: loss of dword sync; 5: mux problem; ..."}, 
        {"NPLR",
      25, 1, -1, 13, 3, 4, 0, "Negotiated logical link rate", "0: unknown; 1: disabled; 2: phy reset problem; 3: spinup hold\t4: port selector; 8: 1.5 Gbps; 9: 3 Gbps; 10: 6 Gbps; 11: 12 Gbps"}, 
        {"ASIP",
      25, 1, -1, 14, 3, 1, 0, "Attached SSP initiator port", (char const   *)((void *)0)}, 
        {"ATIP",
      25, 1, -1, 14, 2, 1, 0, "Attached STP initiator port", (char const   *)((void *)0)}, 
        {"AMIP",
      25, 1, -1, 14, 1, 1, 0, "Attached SMP initiator port", (char const   *)((void *)0)}, 
        {"ASTP",
      25, 1, -1, 15, 3, 1, 0, "Attached SSP target port", (char const   *)((void *)0)}, 
        {"ATTP",
      25, 1, -1, 15, 2, 1, 0, "Attached STP target port", (char const   *)((void *)0)}, 
        {"AMTP",
      25, 1, -1, 15, 1, 1, 0, "Attached SMP target port", (char const   *)((void *)0)}, 
        {"SASA",
      25, 1, -1, 16, 7, 64, 3, "SAS address", (char const   *)((void *)0)}, 
        {"ASASA", 25, 1, -1, 24, 7, 64, 3, "Attached SAS address", (char const   *)((void *)0)}, 
        {"APHID",
      25, 1, -1, 32, 7, 8, 0, "Attached phy identifier", (char const   *)((void *)0)}, 
        {"APOWCAP",
      25, 1, -1, 33, 6, 2, 0, "Attached power capable", "0: not; 1: can consume; 2: can source"}, 
        {"ASLCAP",
      25, 1, -1, 33, 4, 1, 0, "Attached slumber capable", (char const   *)((void *)0)}, 
        {"APACAP",
      25, 1, -1, 33, 3, 1, 0, "Attached partial capable", (char const   *)((void *)0)}, 
        {"AIZPER",
      25, 1, -1, 33, 2, 1, 0, "Attached inside ZPSDS persistent", (char const   *)((void *)0)}, 
        {"AREQIZ",
      25, 1, -1, 33, 1, 1, 0, "Attached request inside ZPSDS", (char const   *)((void *)0)}, 
        {"ABRCAP",
      25, 1, -1, 33, 0, 1, 0, "Attached break reply capable", (char const   *)((void *)0)}, 
        {"PMILR",
      25, 1, -1, 40, 7, 4, 0, "Programmed minimum link rate", "0: not programmed; 8: 1.5 Gbps; 9: 3 Gbps; 10: 6 Gbps; 11: 12 Gbps"}, 
        {"HMILR",
      25, 1, -1, 40, 3, 4, 0, "Hardware minimum link rate", "8: 1.5 Gbps; 9: 3 Gbps; 10: 6 Gbps; 11: 12 Gbps"}, 
        {"PMALR",
      25, 1, -1, 41, 7, 4, 0, "Programmed maximum link rate", "0: not programmed; 8: 1.5 Gbps; 9: 3 Gbps; 10: 6 Gbps; 11: 12 Gbps"}, 
        {"HMALR",
      25, 1, -1, 41, 3, 4, 0, "Hardware maximum link rate", "8: 1.5 Gbps; 9: 3 Gbps; 10: 6 Gbps; 11: 12 Gbps"}, 
        {"PPID_2",
      25, 2, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"PLT",
      25, 2, -1, 6, 7, 16, 0, "Power loss timeout(ms)", (char const   *)((void *)0)}, 
        {"PGRATO",
      25, 2, -1, 9, 7, 8, 0, "Power grant timeout(sec)", (char const   *)((void *)0)}, 
        {"PPID_3",
      25, 3, -1, 5, 3, 4, 0, "Port\'s (transport) protocol identifier", "0: fcp; 1: spi; 4: srp; 5: iscsi; 6: sas; 7: adt; 8: ata/atapi"}, 
        {"GENC_1",
      25, 3, -1, 6, 7, 8, 0, "Generation code", "0: unknown, 1..255: valid"}, 
        {"NOP_1", 25, 3, -1, 7, 7, 8, 0, "Number of phys", "one descriptor per phy"}, 
        {"PHID_1",
      25, 3, -1, 9, 7, 8, 0, "Phy identifier", (char const   *)((void *)0)}, 
        {"PPCAP", 25, 3, -1, 12, 7, 32, 2, "Programmed phy capabilities", (char const   *)((void *)0)}, 
        {"CPCAP",
      25, 3, -1, 16, 7, 32, 2, "Current phy capabilities", (char const   *)((void *)0)}, 
        {"APCAP",
      25, 3, -1, 20, 7, 32, 2, "Attached phy capabilities", (char const   *)((void *)0)}, 
        {"OPT_M_EN",
      25, 3, -1, 26, 5, 1, 0, "Optical mode enabled", (char const   *)((void *)0)}, 
        {"N_SSC",
      25, 3, -1, 26, 4, 1, 0, "Negotiated spread spectrum clocking", (char const   *)((void *)0)}, 
        {"N_PLR",
      25, 3, -1, 26, 3, 4, 0, "Negotiated physical link rate", "6: resetting; 7: attached unsupported\t8: 1.5 Gbps; 9: 3 Gbps; 10: 6 Gbps; 11: 12 Gbps"}, 
        {"EN_SL",
      25, 3, -1, 27, 2, 1, 0, "Enable slumber phy power condition", (char const   *)((void *)0)}, 
        {"EN_PA",
      25, 3, -1, 27, 1, 1, 0, "Enable partial phy power condition", (char const   *)((void *)0)}, 
        {"HMS",
      25, 3, -1, 27, 0, 1, 0, "Hardware muxing supported", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 1575 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_transport_pair sdparm_transport_mp[16]  = 
#line 1575
  {      {sdparm_fcp_mode_pg, sdparm_mitem_fcp_arr}, 
        {sdparm_spi_mode_pg, sdparm_mitem_spi_arr}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0),
      (struct sdparm_mode_page_item *)((void *)0)}, 
        {sdparm_srp_mode_pg, sdparm_mitem_srp_arr}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}, 
        {sdparm_sas_mode_pg,
      sdparm_mitem_sas_arr}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0),
      (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0),
      (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0),
      (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0),
      (struct sdparm_mode_page_item *)((void *)0)}, 
        {(struct sdparm_mode_page_t *)((void *)0), (struct sdparm_mode_page_item *)((void *)0)}};
#line 1595 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_pdt_doc_strs[32]  = 
#line 1595
  {      "SBC-3",      "SSC-3",      "SSC",      "SPC-2", 
        "SBC",      "MMC-5",      "SCSI-2",      "SBC-2", 
        "SMC-2",      "SCSI-2",      "SCSI-2",      "SCSI-2", 
        "SCC-2",      "SES-2",      "RBC",      "OCRW", 
        "BCC",      "OSD-2",      "ADC",      "SPC-4", 
        "unknown",      "unknown",      "unknown",      "unknown", 
        "unknown",      "unknown",      "unknown",      "unknown", 
        "unknown",      "unknown",      "SPC-4",      "SPC-4"};
#line 1624 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_code_set_arr[16]  = 
#line 1624
  {      "Reserved [0x0]",      "Binary",      "ASCII",      "UTF-8", 
        "Reserved [0x4]",      "Reserved [0x5]",      "Reserved [0x6]",      "Reserved [0x7]", 
        "Reserved [0x8]",      "Reserved [0x9]",      "Reserved [0xa]",      "Reserved [0xb]", 
        "Reserved [0xc]",      "Reserved [0xd]",      "Reserved [0xe]",      "Reserved [0xf]"};
#line 1635 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_assoc_arr[4]  = {      "Addressed logical unit",      "Target port",      "Target device that contains addressed lu",      "Reserved [0x3]"};
#line 1643 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_desig_type_arr[16]  = 
#line 1643
  {      "vendor specific [0x0]",      "T10 vendor identification",      "EUI-64 based",      "NAA", 
        "Relative target port",      "Target port group",      "Logical unit group",      "MD5 logical unit identifier", 
        "SCSI name string",      "Reserved [0x9]",      "Reserved [0xa]",      "Reserved [0xb]", 
        "Reserved [0xc]",      "Reserved [0xd]",      "Reserved [0xe]",      "Reserved [0xf]"};
#line 1658 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_ansi_version_arr[8]  = 
#line 1658
  {      "no conformance claimed",      "SCSI-1",      "SCSI-2",      "SPC", 
        "SPC-2",      "SPC-3",      "SPC-4",      "ANSI version: 7"};
#line 1670 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_network_service_type_arr[32]  = 
#line 1670
  {      "unspecified",      "storage configuration service",      "diagnostics",      "status", 
        "logging",      "code download",      "administrative configuration service",      "reserved[0x7]", 
        "reserved[0x8]",      "reserved[0x9]",      "reserved[0xa]",      "reserved[0xb]", 
        "reserved[0xc]",      "reserved[0xd]",      "reserved[0xe]",      "reserved[0xf]", 
        "reserved[0x10]",      "reserved[0x11]",      "reserved[0x12]",      "reserved[0x13]", 
        "reserved[0x14]",      "reserved[0x15]",      "reserved[0x16]",      "reserved[0x17]", 
        "reserved[0x18]",      "reserved[0x19]",      "reserved[0x1a]",      "reserved[0x1b]", 
        "reserved[0x1c]",      "reserved[0x1d]",      "reserved[0x1e]",      "reserved[0x1f]"};
#line 1688 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
char const   *sdparm_mode_page_policy_arr[4]  = {      "shared",      "per target port",      "per initiator port (obsolete)",      "per I_T nexus"};
#line 1696 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_command_t sdparm_command_arr[12]  = 
#line 1696
  {      {9, "capacity", "ca", (char const   *)((void *)0)}, 
        {5, "eject", "ej", (char const   *)((void *)0)}, 
        {4, "load", "lo", (char const   *)((void *)0)}, 
        {11, "profile", "pr", (char const   *)((void *)0)}, 
        {1, "ready", "re", (char const   *)((void *)0)}, 
        {7, "sense", "se", (char const   *)((void *)0)}, 
        {10, "speed", "sp", "new_speed_kbps"}, 
        {2, "start", "sta", (char const   *)((void *)0)}, 
        {3, "stop", "sto", (char const   *)((void *)0)}, 
        {8, "sync", "sy", (char const   *)((void *)0)}, 
        {6, "unlock", "un", (char const   *)((void *)0)}, 
        {-1, (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 1712 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data.c"
struct sdparm_val_desc_t sdparm_profile_arr[37]  = 
#line 1712
  {      {0, "No current profile"}, 
        {1, "Non-removable disk (obs)"}, 
        {2, "Removable disk"}, 
        {3, "Magneto optical erasable"}, 
        {4, "Optical write once"}, 
        {5, "AS-MO"}, 
        {8, "CD-ROM"}, 
        {9, "CD-R"}, 
        {10, "CD-RW"}, 
        {16, "DVD-ROM"}, 
        {17, "DVD-R sequential recording"}, 
        {18, "DVD-RAM"}, 
        {19, "DVD-RW restricted overwrite"}, 
        {20, "DVD-RW sequential recording"}, 
        {21, "DVD-R dual layer sequental recording"}, 
        {22, "DVD-R dual layer jump recording"}, 
        {23, "DVD-RW dual layer"}, 
        {24, "DVD-Download disc recording"}, 
        {26, "DVD+RW"}, 
        {27, "DVD+R"}, 
        {32, "DDCD-ROM"}, 
        {33, "DDCD-R"}, 
        {34, "DDCD-RW"}, 
        {42, "DVD+RW dual layer"}, 
        {43, "DVD+R dual layer"}, 
        {64, "BD-ROM"}, 
        {65, "BD-R SRM"}, 
        {66, "BD-R RRM"}, 
        {67, "BD-RE"}, 
        {80, "HD DVD-ROM"}, 
        {81, "HD DVD-R"}, 
        {82, "HD DVD-RAM"}, 
        {83, "HD DVD-RW"}, 
        {88, "HD DVD-R dual layer"}, 
        {90, "HD DVD-RW dual layer"}, 
        {65535, "Non-conforming profile"}, 
        {-1, (char const   *)((void *)0)}};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int map_if_lk24(int sg_fd , char const   *device_name , int rw , int verbose ) ;
#line 267 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_vendor_name_t sdparm_vendor_id[5] ;
#line 269
int sdparm_vendor_mp_len ;
#line 288
int sdp_get_mp_len(unsigned char *mp ) ;
#line 289
struct sdparm_mode_page_t  const  *sdp_get_mode_detail(int page_num , int subpage_num ,
                                                       int pdt , int transp_proto ,
                                                       int vendor_num ) ;
#line 292
struct sdparm_mode_page_t  const  *sdp_get_mpage_name(int page_num , int subpage_num ,
                                                      int pdt , int transp_proto ,
                                                      int vendor_num , int plus_acron ,
                                                      int hex , char *bp , int max_b_len ) ;
#line 296
struct sdparm_mode_page_t  const  *sdp_find_mp_by_acron(char const   *ap , int transp_proto ,
                                                        int vendor_num ) ;
#line 300
struct sdparm_vpd_page_t  const  *sdp_find_vpd_by_acron(char const   *ap ) ;
#line 302
char const   *sdp_get_transport_name(int proto_num ) ;
#line 303
struct sdparm_transport_id_t  const  *sdp_find_transport_by_acron(char const   *ap ) ;
#line 305
char const   *sdp_get_vendor_name(int vendor_num ) ;
#line 306
struct sdparm_vendor_name_t  const  *sdp_find_vendor_by_acron(char const   *ap ) ;
#line 308
struct sdparm_vendor_pair  const  *sdp_get_vendor_pair(int vendor_num ) ;
#line 309
struct sdparm_mode_page_item  const  *sdp_find_mitem_by_acron(char const   *ap , int *from ,
                                                              int transp_proto , int vendor_num ) ;
#line 312
uint64_t sdp_get_big_endian(unsigned char const   *from , int start_bit , int num_bits ) ;
#line 316
uint64_t sdp_mp_get_value(struct sdparm_mode_page_item  const  *mpi , unsigned char const   *mp ) ;
#line 318
uint64_t sdp_mp_get_value_check(struct sdparm_mode_page_item  const  *mpi , unsigned char const   *mp ,
                                int *all_set ) ;
#line 321
void sdp_mp_set_value(uint64_t val , struct sdparm_mode_page_item  const  *mpi , unsigned char *mp ) ;
#line 325
char *sdp_get_pdt_doc_str(int pdt , int buff_len , char *buff ) ;
#line 341
struct sdparm_command_t  const  *sdp_build_cmd(char const   *cmd_str , int *rwp ,
                                               int *argp ) ;
#line 343
void sdp_enumerate_commands(void) ;
#line 344
int sdp_process_cmd(int sg_fd , struct sdparm_command_t  const  *scmdp , int cmd_arg ,
                    int pdt , struct sdparm_opt_coll  const  *opts ) ;
#line 206 "../include/sg_lib.h"
char *sg_get_pdt_str(int pdt , int buff_len , char *buff ) ;
#line 290
char *safe_strerror(int errnum ) ;
#line 344
int sg_get_num_nomult(char const   *buf ) ;
#line 48 "../include/sg_cmds_basic.h"
int sg_ll_mode_select6(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                       int noisy , int verbose ) ;
#line 56
int sg_ll_mode_select10(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                        int noisy , int verbose ) ;
#line 64
int sg_ll_mode_sense6(int sg_fd , int dbd , int pc , int pg_code , int sub_pg_code ,
                      void *resp , int mx_resp_len , int noisy , int verbose ) ;
#line 73
int sg_ll_mode_sense10(int sg_fd , int llbaa , int dbd , int pc , int pg_code , int sub_pg_code ,
                       void *resp , int mx_resp_len , int noisy , int verbose ) ;
#line 179
int sg_simple_inquiry(int sg_fd , struct sg_simple_inquiry_resp *inq_data , int noisy ,
                      int verbose ) ;
#line 189
int sg_mode_page_offset(unsigned char const   *resp , int resp_len , int mode_sense_6 ,
                        char *err_buff , int err_buff_len ) ;
#line 210
int sg_get_mode_page_controls(int sg_fd , int mode6 , int pg_code , int sub_pg_code ,
                              int dbd , int flexible , int mx_mpage_len , int *success_mask ,
                              void **pcontrol_arr , int *reported_len , int verbose ) ;
#line 218
int sg_cmds_open_device(char const   *device_name , int read_only , int verbose ) ;
#line 228
int sg_cmds_close_device(int device_fd ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static char *version_str  =    (char *)"1.07 20120121 [svn: r188]";
#line 83 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static struct option long_options[25]  = 
#line 83
  {      {"six", 0, (int *)0, '6'}, 
        {"all", 0, (int *)0, 'a'}, 
        {"dbd", 0, (int *)0, 'B'}, 
        {"clear", 1, (int *)0, 'c'}, 
        {"command", 1, (int *)0, 'C'}, 
        {"defaults", 0, (int *)0, 'D'}, 
        {"dummy", 0, (int *)0, 'd'}, 
        {"enumerate", 0, (int *)0, 'e'}, 
        {"flexible", 0, (int *)0, 'f'}, 
        {"get", 1, (int *)0, 'g'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hex", 0, (int *)0, 'H'}, 
        {"inquiry", 0, (int *)0, 'i'}, 
        {"long", 0, (int *)0, 'l'}, 
        {"num-desc", 0, (int *)0, 'n'}, 
        {"page", 1, (int *)0, 'p'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"readonly", 0, (int *)0, 'r'}, 
        {"set", 1, (int *)0, 's'}, 
        {"save", 0, (int *)0, 'S'}, 
        {"transport", 1, (int *)0, 't'}, 
        {"vendor", 1, (int *)0, 'M'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 114 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void usage(void) 
{ 


  {
  {
#line 117
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: sdparm [--all] [--clear=STR] [--command=CMD] [--dbd] [--defaults]\n              [--dummy] [--flexible] [--get=STR] [--help] [--hex] [--inquiry]\n              [--long] [--num-desc] [--page=PG[,SPG]] [--quiet] [--readonly]\n              [--save] [--set=STR] [--six] [--transport=TN] [--vendor=VN]\n              [--verbose] [--version] DEVICE [DEVICE...]\n\n       sdparm --enumerate [--all] [--inquiry] [--long] [--page=PG[,SPG]]\n              [--transport=TN] [--vendor=VN]\n  where:\n    --all | -a            list all known fields for given device\n    --clear=STR | -c STR    clear (zero) field value(s)\n    --command=CMD | -C CMD    perform CMD (e.g. \'eject\')\n    --dbd | -B            set DBD bit in mode sense cdb\n    --defaults | -D       set a mode page to its default values\n    --dummy | -d          don\'t write back modified mode page\n    --enumerate | -e      list known pages and fields (ignore device)\n    --flexible | -f       compensate for common errors, relax some checks\n    --get=STR | -g STR    get (fetch) field value(s)\n    --help | -h           print out usage message\n    --hex | -H            output in hex rather than name/value pairs\n    --inquiry | -i        output INQUIRY VPD page(s) (def: mode page(s))\n                          use --page=PG for VPD number (-1 for std inq)\n    --long | -l           add description to field output\n    --num-desc | -n       report number of mode page descriptors\n    --page=PG[,SPG] | -p PG[,SPG]    page (and optionally subpage) number\n                          [or abbrev] to output, change or enumerate\n    --quiet | -q          suppress device vendor/product/revision string line\n    --readonly | -r       force read-only open of DEVICE (def: either\n                          read-write or read-only). For ATA disks\n    --save | -S           place mode changes in saved page as well\n    --set=STR | -s STR    set field value(s)\n    --six | -6            use 6 byte SCSI mode cdbs (def: 10 byte)\n    --transport=TN | -t TN    transport protocol number [or abbrev]\n    --vendor=VN | -M VN    vendor (manufacturer) number [or abbrev]\n    --verbose | -v        increase verbosity\n    --version | -V        print version string and exit\n\nView or change SCSI mode page fields (e.g. of a disk or CD/DVD drive).\nSTR can be <acronym>[=val] or <start_byte>:<start_bit>:<num_bits>[=val].\n");
  }
#line 182
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void enumerate_mpages(int transport , int vendor ) 
{ 
  struct sdparm_mode_page_t  const  *mpp ;
  struct sdparm_vendor_pair  const  *vpp ;

  {
#line 189
  if (vendor >= 0) {
    {
#line 192
    vpp = sdp_get_vendor_pair(vendor);
    }
#line 193
    if ((unsigned long )((void *)0) == (unsigned long )vpp) {
      {
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad vendor number\n");
      }
#line 195
      return;
    }
#line 197
    mpp = (struct sdparm_mode_page_t  const  *)vpp->mpage;
  } else
#line 198
  if (transport >= 0) {
#line 198
    if (transport < 16) {
#line 199
      mpp = (struct sdparm_mode_page_t  const  *)sdparm_transport_mp[transport].mpage;
    } else {
#line 201
      mpp = (struct sdparm_mode_page_t  const  *)(sdparm_gen_mode_pg);
    }
  } else {
#line 201
    mpp = (struct sdparm_mode_page_t  const  *)(sdparm_gen_mode_pg);
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (mpp) {
#line 203
      if (! mpp->acron) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 204
    if (mpp->name) {
#line 205
      if (mpp->subpage) {
        {
#line 206
        printf((char const   */* __restrict  */)"  %-4s 0x%02x,0x%02x  %s\n", mpp->acron,
               mpp->page, mpp->subpage, mpp->name);
        }
      } else {
        {
#line 209
        printf((char const   */* __restrict  */)"  %-4s 0x%02x       %s\n", mpp->acron,
               mpp->page, mpp->name);
        }
      }
    }
#line 203
    mpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void enumerate_vpds(void) 
{ 
  struct sdparm_vpd_page_t  const  *vpp ;

  {
#line 220
  vpp = (struct sdparm_vpd_page_t  const  *)(sdparm_vpd_pg);
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! vpp->acron) {
#line 220
      goto while_break;
    }
#line 221
    if (vpp->name) {
#line 222
      if (vpp->vpd_num < 0) {
        {
#line 223
        printf((char const   */* __restrict  */)"  %-10s -1        %s\n", vpp->acron,
               vpp->name);
        }
      } else {
        {
#line 225
        printf((char const   */* __restrict  */)"  %-10s 0x%02x      %s\n", vpp->acron,
               vpp->vpd_num, vpp->name);
        }
      }
    }
#line 220
    vpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void enumerate_transports(void) 
{ 
  struct sdparm_transport_id_t  const  *tip ;

  {
#line 236
  tip = (struct sdparm_transport_id_t  const  *)(sdparm_transport_id);
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! tip->acron) {
#line 236
      goto while_break;
    }
#line 237
    if (tip->name) {
      {
#line 238
      printf((char const   */* __restrict  */)"  %-6s 0x%02x     %s\n", tip->acron,
             tip->proto_num, tip->name);
      }
    }
#line 236
    tip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void enumerate_vendors(void) 
{ 
  struct sdparm_vendor_name_t  const  *vnp ;

  {
#line 248
  vnp = (struct sdparm_vendor_name_t  const  *)(sdparm_vendor_id);
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! vnp->acron) {
#line 248
      goto while_break;
    }
#line 249
    if (vnp->name) {
      {
#line 250
      printf((char const   */* __restrict  */)"  %-6s 0x%02x     %s\n", vnp->acron,
             vnp->vendor_num, vnp->name);
      }
    }
#line 248
    vnp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void print_mp_extra(char const   *extra ) 
{ 
  int n ;
  char b[128] ;
  char *cp ;
  char *p ;

  {
#line 263
  p = (char *)extra;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 263
    cp = strchr((char const   *)p, '\t');
    }
#line 263
    if (! cp) {
#line 263
      goto while_break;
    }
#line 264
    n = (int )(cp - p);
#line 265
    if (n > (int )(sizeof(b) - 1UL)) {
#line 266
      n = (int )(sizeof(b) - 1UL);
    }
    {
#line 267
    strncpy((char */* __restrict  */)(b), (char const   */* __restrict  */)p, (size_t )n);
#line 268
    b[n] = (char )'\000';
#line 269
    printf((char const   */* __restrict  */)"\t%s\n", b);
#line 263
    p = cp + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  printf((char const   */* __restrict  */)"\t%s\n", p);
  }
#line 272
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void enumerate_mitems(int pn , int spn , int pdt , struct sdparm_opt_coll  const  *opts ) 
{ 
  int t_pn ;
  int t_spn ;
  int t_pdt ;
  int vendor ;
  int transp ;
  int long_o ;
  struct sdparm_mode_page_t  const  *mpp ;
  struct sdparm_mode_page_item  const  *mpi ;
  char buff[128] ;
  char b[128] ;
  int found ;
  struct sdparm_vendor_pair  const  *vpp ;
  char *tmp ;
  struct sdparm_mode_descriptor_t  const  *mdp ;

  {
#line 280
  mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
#line 284
  found = 0;
#line 286
  t_pn = -1;
#line 287
  t_spn = -1;
#line 288
  t_pdt = -2;
#line 289
  vendor = (int )opts->vendor;
#line 290
  transp = (int )opts->transport;
#line 291
  long_o = (int )opts->long_out;
#line 292
  if (vendor >= 0) {
    {
#line 295
    vpp = sdp_get_vendor_pair(vendor);
    }
#line 296
    if (vpp) {
#line 296
      mpi = (struct sdparm_mode_page_item  const  *)vpp->mitem;
    } else {
#line 296
      mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
    }
  } else
#line 297
  if (transp >= 0) {
#line 297
    if (transp < 16) {
#line 298
      mpi = (struct sdparm_mode_page_item  const  *)sdparm_transport_mp[transp].mitem;
    } else {
#line 300
      mpi = (struct sdparm_mode_page_item  const  *)(sdparm_mitem_arr);
    }
  } else {
#line 300
    mpi = (struct sdparm_mode_page_item  const  *)(sdparm_mitem_arr);
  }
#line 301
  if ((unsigned long )((void *)0) == (unsigned long )mpi) {
#line 302
    return;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! mpi->acron) {
#line 304
      goto while_break;
    }
#line 305
    if (pdt >= 0) {
#line 305
      if (mpi->pdt >= 0) {
#line 305
        if (pdt != (int )mpi->pdt) {
#line 306
          goto __Cont;
        }
      }
    }
#line 307
    if (t_pn != (int )mpi->page_num) {
#line 307
      goto _L;
    } else
#line 307
    if (t_spn != (int )mpi->subpage_num) {
#line 307
      goto _L;
    } else
#line 307
    if (t_pdt != (int )mpi->pdt) {
      _L: /* CIL Label */ 
#line 309
      t_pn = (int )mpi->page_num;
#line 310
      t_spn = (int )mpi->subpage_num;
#line 311
      t_pdt = (int )mpi->pdt;
#line 312
      if (pn >= 0) {
#line 312
        if (pn != t_pn) {
#line 313
          goto __Cont;
        } else
#line 312
        if (spn != t_spn) {
#line 313
          goto __Cont;
        }
      }
#line 314
      if (pdt >= 0) {
#line 314
        if (pdt != t_pdt) {
#line 315
          goto __Cont;
        }
      }
      {
#line 316
      mpp = sdp_get_mpage_name(t_pn, t_spn, t_pdt, transp, vendor, long_o, 1, buff,
                               (int )sizeof(buff));
      }
#line 318
      if (long_o) {
#line 318
        if (transp < 0) {
#line 318
          if (vendor < 0) {
            {
#line 319
            tmp = sdp_get_pdt_doc_str(t_pdt, (int )sizeof(b), b);
#line 319
            printf((char const   */* __restrict  */)"%s [%s] mode page:\n", buff,
                   tmp);
            }
          } else {
            {
#line 322
            printf((char const   */* __restrict  */)"%s mode page:\n", buff);
            }
          }
        } else {
          {
#line 322
          printf((char const   */* __restrict  */)"%s mode page:\n", buff);
          }
        }
      } else {
        {
#line 322
        printf((char const   */* __restrict  */)"%s mode page:\n", buff);
        }
      }
    } else
#line 324
    if (pn >= 0) {
#line 324
      if (pn != t_pn) {
#line 325
        goto __Cont;
      } else
#line 324
      if (spn != t_spn) {
#line 325
        goto __Cont;
      }
    }
    {
#line 327
    printf((char const   */* __restrict  */)"  %-10s [0x%02x:%d:%-2d]  %s\n", mpi->acron,
           mpi->start_byte, mpi->start_bit, mpi->num_bits, mpi->description);
    }
#line 329
    if (long_o > 1) {
#line 329
      if (mpi->extra) {
        {
#line 330
        print_mp_extra((char const   *)mpi->extra);
        }
      }
    }
#line 331
    found = 1;
    __Cont: /* CIL Label */ 
#line 304
    mpi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  if (! found) {
#line 333
    if (pn >= 0) {
      {
#line 334
      sdp_get_mpage_name(pn, spn, pdt, transp, vendor, long_o, 1, buff, (int )sizeof(buff));
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page: no items found\n",
              buff);
      }
    }
  }
#line 338
  if (found) {
#line 338
    if (mpp) {
#line 338
      if (mpp->mp_desc) {
#line 338
        if (long_o) {
#line 339
          mdp = (struct sdparm_mode_descriptor_t  const  *)mpp->mp_desc;
#line 341
          if (mdp->name) {
            {
#line 342
            printf((char const   */* __restrict  */)"  <<%s mode descriptor>>\n",
                   mdp->name);
            }
          } else {
            {
#line 344
            printf((char const   */* __restrict  */)"  <<mode descriptor>>\n");
            }
          }
          {
#line 345
          printf((char const   */* __restrict  */)"    num_descs_off=%d, num_descs_bytes=%d, num_descs_inc=%d, first_desc_off=%d\n",
                 mdp->num_descs_off, mdp->num_descs_bytes, mdp->num_descs_inc, mdp->first_desc_off);
          }
#line 349
          if (mdp->desc_len > 0) {
            {
#line 350
            printf((char const   */* __restrict  */)"    descriptor_len=%d\n", mdp->desc_len);
            }
          } else {
            {
#line 352
            printf((char const   */* __restrict  */)"    desc_len_off=%d, desc_len_bytes=%d\n",
                   mdp->desc_len_off, mdp->desc_len_bytes);
            }
          }
        }
      }
    }
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void list_mp_settings(struct sdparm_mode_page_settings  const  *mps , int get ) 
{ 
  struct sdparm_mode_page_item  const  *mpip ;
  int k ;

  {
  {
#line 363
  printf((char const   */* __restrict  */)"mp_settings: page,subpage=0x%x,0x%x  num=%d\n",
         mps->page_num, mps->subpage_num, mps->num_it_vals);
#line 365
  k = 0;
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! (k < (int )mps->num_it_vals)) {
#line 365
      goto while_break;
    }
#line 366
    mpip = & mps->it_vals[k].mpi;
#line 367
    if (get) {
      {
#line 368
      printf((char const   */* __restrict  */)"  [0x%x,0x%x]", mpip->page_num, mpip->subpage_num);
      }
    }
    {
#line 370
    printf((char const   */* __restrict  */)"  pdt=%d start_byte=0x%x start_bit=%d num_bits=%d  val=%ld",
           mpip->pdt, mpip->start_byte, mpip->start_bit, mpip->num_bits, mps->it_vals[k].val);
    }
#line 373
    if (mpip->acron) {
      {
#line 374
      printf((char const   */* __restrict  */)"  acronym: %s", mpip->acron);
      }
#line 375
      if (mps->it_vals[k].descriptor_num > 0) {
        {
#line 376
        printf((char const   */* __restrict  */)"  descriptor_num=%d\n", mps->it_vals[k].descriptor_num);
        }
      } else {
        {
#line 378
        printf((char const   */* __restrict  */)"\n");
        }
      }
    } else {
      {
#line 380
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 365
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void print_mp_entry(char const   *pre , int smask , struct sdparm_mode_page_item  const  *mpi ,
                           unsigned char const   *cur_mp , unsigned char const   *cha_mp ,
                           unsigned char const   *def_mp , unsigned char const   *sav_mp ,
                           int long_out , int force_decimal ) 
{ 
  int sep ;
  int all_set ;
  uint64_t u ;
  char const   *acron ;
  char const   *tmp___0 ;
  uint64_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 395
  sep = 0;
#line 400
  all_set = 0;
#line 401
  if (mpi->acron) {
#line 401
    acron = (char const   *)mpi->acron;
  } else {
#line 401
    acron = "";
  }
  {
#line 402
  u = sdp_mp_get_value_check(mpi, cur_mp, & all_set);
#line 403
  printf((char const   */* __restrict  */)"%s%-10s", pre, acron);
  }
#line 404
  if (force_decimal) {
    {
#line 405
    printf((char const   */* __restrict  */)"%ld", (int64_t )u);
    }
  } else
#line 406
  if (mpi->flags & 2) {
    {
#line 407
    printf((char const   */* __restrict  */)"0x%lx", u);
    }
  } else
#line 408
  if (all_set) {
    {
#line 409
    printf((char const   */* __restrict  */)" -1");
    }
  } else {
    {
#line 411
    printf((char const   */* __restrict  */)"%3lu", u);
    }
  }
#line 412
  if (smask & 14) {
    {
#line 413
    printf((char const   */* __restrict  */)"  [");
    }
#line 414
    if (cha_mp) {
#line 414
      if (smask & 2) {
        {
#line 415
        tmp___1 = sdp_mp_get_value(mpi, cha_mp);
        }
#line 415
        if (tmp___1) {
#line 415
          tmp___0 = "y";
        } else {
#line 415
          tmp___0 = "n";
        }
        {
#line 415
        printf((char const   */* __restrict  */)"cha: %s", tmp___0);
#line 417
        sep = 1;
        }
      }
    }
#line 419
    if (def_mp) {
#line 419
      if (smask & 4) {
        {
#line 420
        all_set = 0;
#line 421
        u = sdp_mp_get_value_check(mpi, def_mp, & all_set);
        }
#line 422
        if (sep) {
#line 422
          tmp___2 = ", ";
        } else {
#line 422
          tmp___2 = " ";
        }
        {
#line 422
        printf((char const   */* __restrict  */)"%sdef:", tmp___2);
        }
#line 423
        if (force_decimal) {
          {
#line 424
          printf((char const   */* __restrict  */)"%ld", (int64_t )u);
          }
        } else
#line 425
        if (mpi->flags & 2) {
          {
#line 426
          printf((char const   */* __restrict  */)"0x%lx", u);
          }
        } else
#line 427
        if (all_set) {
          {
#line 428
          printf((char const   */* __restrict  */)" -1");
          }
        } else {
          {
#line 430
          printf((char const   */* __restrict  */)"%3lu", u);
          }
        }
#line 431
        sep = 1;
      }
    }
#line 433
    if (sav_mp) {
#line 433
      if (smask & 8) {
        {
#line 434
        all_set = 0;
#line 435
        u = sdp_mp_get_value_check(mpi, sav_mp, & all_set);
        }
#line 436
        if (sep) {
#line 436
          tmp___3 = ", ";
        } else {
#line 436
          tmp___3 = " ";
        }
        {
#line 436
        printf((char const   */* __restrict  */)"%ssav:", tmp___3);
        }
#line 437
        if (force_decimal) {
          {
#line 438
          printf((char const   */* __restrict  */)"%ld", (int64_t )u);
          }
        } else
#line 439
        if (mpi->flags & 2) {
          {
#line 440
          printf((char const   */* __restrict  */)"0x%lx", u);
          }
        } else
#line 441
        if (all_set) {
          {
#line 442
          printf((char const   */* __restrict  */)" -1");
          }
        } else {
          {
#line 444
          printf((char const   */* __restrict  */)"%3lu", u);
          }
        }
      }
    }
    {
#line 446
    printf((char const   */* __restrict  */)"]");
    }
  }
#line 448
  if (long_out) {
#line 448
    if (mpi->description) {
      {
#line 449
      printf((char const   */* __restrict  */)"  %s", mpi->description);
      }
    }
  }
  {
#line 450
  printf((char const   */* __restrict  */)"\n");
  }
#line 451
  if (long_out > 1) {
#line 451
    if (mpi->extra) {
      {
#line 452
      print_mp_extra((char const   *)mpi->extra);
      }
    }
  }
#line 453
  return;
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void print_mp_arr_entry(char const   *pre , int smask , struct sdparm_mode_page_item  const  *mpi ,
                               void **pc_arr , int long_out , int force_decimal ) 
{ 
  unsigned char const   *cur_mp ;
  unsigned char const   *cha_mp ;
  unsigned char const   *def_mp ;
  unsigned char const   *sav_mp ;

  {
  {
#line 460
  cur_mp = (unsigned char const   *)*(pc_arr + 0);
#line 461
  cha_mp = (unsigned char const   *)*(pc_arr + 1);
#line 462
  def_mp = (unsigned char const   *)*(pc_arr + 2);
#line 463
  sav_mp = (unsigned char const   *)*(pc_arr + 3);
#line 465
  print_mp_entry(pre, smask, mpi, cur_mp, cha_mp, def_mp, sav_mp, long_out, force_decimal);
  }
#line 467
  return;
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int ll_mode_sense(int fd , struct sdparm_opt_coll  const  *opts , int pn ,
                         int spn , unsigned char *resp , int mx_resp_len , int noisy ,
                         int verb ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 473
  if (opts->mode_6) {
    {
#line 474
    tmp = sg_ll_mode_sense6(fd, (int )opts->dbd, 0, pn, spn, (void *)resp, mx_resp_len,
                            noisy, verb);
    }
#line 474
    return (tmp);
  } else {
    {
#line 477
    tmp___0 = sg_ll_mode_sense10(fd, 0, (int )opts->dbd, 0, pn, spn, (void *)resp,
                                 mx_resp_len, noisy, verb);
    }
#line 477
    return (tmp___0);
  }
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void check_mode_page(unsigned char *cur_mp , int pn , int rep_len , struct sdparm_opt_coll  const  *opts ) 
{ 
  int pn_in_page ;

  {
#line 486
  pn_in_page = (int )*(cur_mp + 0) & 63;
#line 488
  if (pn != pn_in_page) {
#line 489
    if (pn == 26) {
#line 489
      if (! (pn_in_page == 13)) {
#line 489
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 496
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> warning: mode page seems malformed\n   The page number field should be 0x%02x, but is 0x%02x",
              pn, pn_in_page);
      }
#line 499
      if (! opts->flexible) {
        {
#line 500
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"; try \'--flexible\'");
        }
      }
      {
#line 501
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  } else
#line 503
  if (opts->verbose) {
#line 503
    if (rep_len > 2560) {
      {
#line 504
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> warning: mode page length=%d too long",
              rep_len);
      }
#line 506
      if (! opts->flexible) {
        {
#line 507
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", perhaps try \'--flexible\'");
        }
      }
      {
#line 508
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 510
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static void print_mpage_extra_desc(void **pc_arr , int rep_len , struct sdparm_mode_page_t  const  *mpp ,
                                   struct sdparm_mode_page_item  const  *fdesc_mpi ,
                                   struct sdparm_mode_page_item  const  *last_mpi ,
                                   struct sdparm_opt_coll  const  *opts , int smask ) 
{ 
  struct sdparm_mode_descriptor_t  const  *mdp ;
  struct sdparm_mode_page_item  const  *mpi ;
  unsigned char const   *cur_mp ;
  unsigned char const   *cha_mp ;
  unsigned char const   *def_mp ;
  unsigned char const   *sav_mp ;
  unsigned char const   *ucp ;
  struct sdparm_mode_page_item ampi ;
  uint64_t u ;
  int k ;
  int num ;
  int len ;
  int d_off ;
  int n ;
  int bad ;
  char b[32] ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 522
  mdp = (struct sdparm_mode_descriptor_t  const  *)mpp->mp_desc;
#line 524
  cur_mp = (unsigned char const   *)*(pc_arr + 0);
#line 525
  cha_mp = (unsigned char const   *)*(pc_arr + 1);
#line 526
  def_mp = (unsigned char const   *)*(pc_arr + 2);
#line 527
  sav_mp = (unsigned char const   *)*(pc_arr + 3);
#line 534
  if ((unsigned long )((void *)0) == (unsigned long )mdp) {
#line 536
    return;
  } else
#line 534
  if ((unsigned long )((void *)0) == (unsigned long )cur_mp) {
#line 536
    return;
  } else
#line 534
  if (rep_len < 4) {
#line 536
    return;
  } else
#line 534
  if (mdp->num_descs_off >= (int const   )rep_len) {
#line 536
    return;
  }
#line 537
  if (mdp->num_descs_inc < 0) {
#line 537
    if (mdp->desc_len > 0) {
      {
#line 538
      tmp = sdp_get_big_endian(cur_mp + mdp->num_descs_off, 7, (int )(mdp->num_descs_bytes * 8));
#line 538
      u = tmp / (uint64_t )mdp->desc_len;
      }
    } else {
      {
#line 541
      tmp___0 = sdp_get_big_endian(cur_mp + mdp->num_descs_off, 7, (int )(mdp->num_descs_bytes * 8));
#line 541
      u = tmp___0 + (uint64_t )mdp->num_descs_inc;
      }
    }
  } else {
    {
#line 541
    tmp___0 = sdp_get_big_endian(cur_mp + mdp->num_descs_off, 7, (int )(mdp->num_descs_bytes * 8));
#line 541
    u = tmp___0 + (uint64_t )mdp->num_descs_inc;
    }
  }
#line 543
  num = (int )u;
#line 544
  if (opts->verbose) {
    {
#line 545
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    >>> mode page says it has %d descriptors\n",
            num);
    }
  }
#line 547
  if (u < 2UL) {
#line 548
    return;
  } else
#line 547
  if (u > 256UL) {
#line 548
    return;
  }
#line 549
  if (mdp->desc_len <= 0) {
    {
#line 550
    ucp = (cur_mp + mdp->first_desc_off) + mdp->desc_len_off;
#line 551
    u = sdp_get_big_endian(ucp, 7, (int )(mdp->desc_len_bytes * 8));
#line 552
    len = (int )((uint64_t )(mdp->desc_len_off + mdp->desc_len_bytes) + u);
    }
  } else {
#line 554
    len = (int )mdp->desc_len;
  }
#line 555
  d_off = (int )(mdp->first_desc_off + (int const   )len);
#line 556
  k = 1;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (k < num)) {
#line 556
      goto while_break;
    }
#line 557
    bad = 0;
#line 558
    mpi = fdesc_mpi;
    {
#line 558
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 558
      if (! ((unsigned long )mpi <= (unsigned long )last_mpi)) {
#line 558
        goto while_break___0;
      }
      {
#line 559
      strncpy((char */* __restrict  */)(b), (char const   */* __restrict  */)mpi->acron,
              sizeof(b));
#line 560
      ampi = (struct sdparm_mode_page_item )*mpi;
#line 561
      b[sizeof(b) - 8UL] = (char )'\000';
#line 562
      tmp___1 = strlen((char const   *)(b));
#line 562
      n = (int )tmp___1;
#line 563
      snprintf((char */* __restrict  */)(b + n), sizeof(b) - (unsigned long )n, (char const   */* __restrict  */)".%d",
               k);
#line 564
      ampi.acron = (char const   *)(b);
#line 565
      ampi.start_byte += d_off - (int )mdp->first_desc_off;
      }
#line 566
      if (ampi.start_byte >= rep_len) {
        {
#line 567
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"descriptor overflows reply len (%d) for %s\n",
                rep_len, ampi.acron);
#line 569
        bad = 1;
        }
#line 570
        goto while_break___0;
      }
      {
#line 572
      print_mp_entry("  ", smask, (struct sdparm_mode_page_item  const  *)(& ampi),
                     cur_mp, cha_mp, def_mp, sav_mp, (int )opts->long_out, 0);
#line 558
      mpi ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 575
    if (bad) {
#line 576
      goto while_break;
    }
#line 577
    if (mdp->desc_len <= 0) {
      {
#line 578
      ucp = (cur_mp + d_off) + mdp->desc_len_off;
#line 579
      u = sdp_get_big_endian(ucp, 7, (int )(mdp->desc_len_bytes * 8));
#line 580
      len = (int )((uint64_t )(mdp->desc_len_off + mdp->desc_len_bytes) + u);
      }
    }
#line 556
    k ++;
#line 556
    d_off += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  return;
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int print_direct_access_info(int sg_fd , struct sdparm_opt_coll  const  *opts ,
                                    int verb ) 
{ 
  int res ;
  int v ;
  unsigned char cur_mp[252] ;
  int tmp ;

  {
  {
#line 594
  memset((void *)(cur_mp), 0, sizeof(cur_mp));
#line 595
  res = ll_mode_sense(sg_fd, opts, 63, 0, cur_mp, 8, 0, verb);
  }
#line 596
  if (0 == res) {
#line 597
    if (opts->mode_6) {
#line 597
      tmp = 2;
    } else {
#line 597
      tmp = 3;
    }
    {
#line 597
    v = (int )cur_mp[tmp];
#line 598
    printf((char const   */* __restrict  */)"    Direct access device specific parameters: WP=%d  DPOFUA=%d\n",
           ! (! (v & 128)), ! (! (v & 16)));
    }
  } else
#line 600
  if (2 == res) {
    {
#line 601
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, device not ready\n");
    }
#line 602
    return (res);
  } else
#line 603
  if (9 == res) {
#line 604
    if (opts->mode_6) {
      {
#line 605
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"6 byte MODE SENSE cdb not supported, try again without \'-6\' option\n");
      }
    } else {
      {
#line 608
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"10 byte MODE SENSE cdb not supported, try again with \'-6\' option\n");
      }
    }
#line 610
    return (res);
  } else
#line 611
  if (6 == res) {
    {
#line 612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, unit attention\n");
    }
#line 613
    return (res);
  } else
#line 614
  if (11 == res) {
    {
#line 615
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, aborted command\n");
    }
#line 616
    return (res);
  }
#line 618
  return (0);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int print_mode_pages(int sg_fd , int pn , int spn , int pdt , struct sdparm_opt_coll  const  *opts ) 
{ 
  int res ;
  int len ;
  int verb ;
  int smask ;
  int single_pg ;
  int fetch_pg ;
  int rep_len ;
  int orig_pn ;
  int warned ;
  int first_desc_off ;
  struct sdparm_mode_page_item  const  *mpi ;
  struct sdparm_mode_page_item  const  *hmpi ;
  struct sdparm_mode_page_item  const  *fdesc_mpi ;
  struct sdparm_mode_page_t  const  *mpp ;
  struct sdparm_mode_descriptor_t  const  *mdp ;
  unsigned char cur_mp[252] ;
  unsigned char cha_mp[252] ;
  unsigned char def_mp[252] ;
  unsigned char sav_mp[252] ;
  void *pc_arr[4] ;
  char buff[128] ;
  struct sdparm_vendor_pair  const  *vpp ;
  int tmp ;
  int num ;
  uint64_t u ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  char const   *tmp___2 ;

  {
#line 630
  fdesc_mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
#line 631
  mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
#line 640
  buff[0] = (char )'\000';
#line 641
  if (opts->verbose > 0) {
#line 641
    verb = (int )(opts->verbose - 1);
  } else {
#line 641
    verb = 0;
  }
#line 642
  if (0 == pdt) {
#line 642
    if (opts->long_out > 0) {
#line 642
      if (0 == (int )opts->quiet) {
        {
#line 643
        res = print_direct_access_info(sg_fd, opts, verb);
        }
#line 643
        if (0 != res) {
#line 644
          return (res);
        }
      }
    }
  }
#line 646
  orig_pn = pn;
#line 648
  if (opts->vendor >= 0) {
    {
#line 651
    vpp = sdp_get_vendor_pair((int )opts->vendor);
    }
#line 652
    if (vpp) {
#line 652
      mpi = (struct sdparm_mode_page_item  const  *)vpp->mitem;
    } else {
#line 652
      mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
    }
  } else
#line 653
  if (opts->transport >= 0) {
#line 653
    if (opts->transport < 16) {
#line 654
      mpi = (struct sdparm_mode_page_item  const  *)sdparm_transport_mp[opts->transport].mitem;
    } else {
#line 656
      mpi = (struct sdparm_mode_page_item  const  *)(sdparm_mitem_arr);
    }
  } else {
#line 656
    mpi = (struct sdparm_mode_page_item  const  *)(sdparm_mitem_arr);
  }
#line 657
  if ((unsigned long )((void *)0) == (unsigned long )mpi) {
#line 658
    return (99);
  }
#line 660
  hmpi = mpi;
#line 661
  if (pn >= 0) {
#line 662
    single_pg = 1;
#line 663
    fetch_pg = 1;
    {
#line 664
    while (1) {
      while_continue: /* CIL Label */ ;
#line 664
      if (! mpi->acron) {
#line 664
        goto while_break;
      }
#line 665
      if (pn == (int )mpi->page_num) {
#line 665
        if (spn == (int )mpi->subpage_num) {
#line 666
          if (pdt < 0) {
#line 668
            goto while_break;
          } else
#line 666
          if (mpi->pdt < 0) {
#line 668
            goto while_break;
          } else
#line 666
          if (pdt == (int )mpi->pdt) {
#line 668
            goto while_break;
          } else
#line 666
          if (opts->flexible) {
#line 668
            goto while_break;
          }
        }
      }
#line 664
      mpi ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 671
    if ((unsigned long )((void *)0) == (unsigned long )mpi->acron) {
#line 672
      if (opts->hex) {
#line 673
        mpi = hmpi;
      } else {
        {
#line 675
        sdp_get_mpage_name(pn, spn, pdt, (int )opts->transport, (int )opts->vendor,
                           0, 0, buff, (int )sizeof(buff));
        }
#line 677
        if (opts->vendor < 0) {
#line 677
          if (0 == pn) {
            {
#line 678
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page seems to be vendor specific, try \'--vendor=VN\'.\nOtherwise add \'-H\' to see page in hex.\n",
                    buff);
            }
          } else
#line 677
          if (pn >= 32) {
            {
#line 678
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page seems to be vendor specific, try \'--vendor=VN\'.\nOtherwise add \'-H\' to see page in hex.\n",
                    buff);
            }
          } else {
            {
#line 682
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page, no fields found, add \'-H\' to see page in hex.\n",
                    buff);
            }
          }
        } else {
          {
#line 682
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page, no fields found, add \'-H\' to see page in hex.\n",
                  buff);
          }
        }
      }
    }
  } else {
#line 687
    single_pg = 0;
#line 688
    fetch_pg = 0;
#line 689
    mpi = hmpi;
  }
#line 691
  mdp = (struct sdparm_mode_descriptor_t  const  *)((void *)0);
#line 694
  smask = 0;
#line 694
  len = 0;
#line 694
  warned = 0;
  {
#line 694
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 694
    if (! mpi->acron) {
#line 694
      goto while_break___0;
    }
#line 695
    if (0 == fetch_pg) {
#line 696
      if (pdt >= 0) {
#line 696
        if (mpi->pdt >= 0) {
#line 696
          if (pdt != (int )mpi->pdt) {
#line 696
            if (0 == (int )opts->flexible) {
#line 698
              goto __Cont;
            }
          }
        }
      }
#line 699
      if (orig_pn >= 0) {
#line 699
        tmp = 1;
      } else {
#line 699
        tmp = (int )opts->all;
      }
#line 699
      if (! tmp) {
#line 699
        if (! (1 & (int )mpi->flags)) {
#line 701
          goto __Cont;
        }
      }
#line 702
      if (pn != (int )mpi->page_num) {
#line 702
        goto _L;
      } else
#line 702
      if (spn != (int )mpi->subpage_num) {
        _L: /* CIL Label */ 
#line 703
        if (fdesc_mpi) {
#line 704
          hmpi = mpi - 1;
#line 705
          if (pn == (int )hmpi->page_num) {
#line 705
            if (spn == (int )hmpi->subpage_num) {
              {
#line 706
              print_mpage_extra_desc(pc_arr, rep_len, mpp, fdesc_mpi, hmpi, opts,
                                     smask);
              }
            }
          }
        }
#line 709
        if (single_pg) {
#line 710
          goto while_break___0;
        }
#line 711
        fetch_pg = 1;
#line 712
        pn = (int )mpi->page_num;
#line 713
        spn = (int )mpi->subpage_num;
      }
    }
#line 716
    if (fetch_pg) {
      {
#line 718
      mpp = sdp_get_mpage_name(pn, spn, pdt, (int )opts->transport, (int )opts->vendor,
                               (int )opts->long_out, (int )opts->hex, buff, (int )sizeof(buff));
#line 721
      smask = 0;
#line 722
      warned = 0;
#line 723
      fdesc_mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
#line 724
      pc_arr[0] = (void *)(cur_mp);
#line 725
      pc_arr[1] = (void *)(cha_mp);
#line 726
      pc_arr[2] = (void *)(def_mp);
#line 727
      pc_arr[3] = (void *)(sav_mp);
#line 728
      res = sg_get_mode_page_controls(sg_fd, (int )opts->mode_6, pn, spn, (int )opts->dbd,
                                      (int )opts->flexible, 252, & smask, pc_arr,
                                      & rep_len, verb);
      }
#line 732
      if (9 == res) {
#line 733
        if (opts->mode_6) {
          {
#line 734
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"6 byte MODE SENSE cdb not supported, try again without \'-6\' option\n");
          }
        } else {
          {
#line 737
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"10 byte MODE SENSE cdb not supported, try again with \'-6\' option\n");
          }
        }
#line 739
        return (res);
      } else
#line 740
      if (2 == res) {
        {
#line 741
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MODE SENSE failed, device not ready\n");
        }
#line 742
        return (res);
      } else
#line 743
      if (6 == res) {
        {
#line 744
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, unit attention\n");
        }
#line 746
        return (res);
      } else
#line 747
      if (11 == res) {
        {
#line 748
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, aborted command\n");
        }
#line 750
        return (res);
      }
#line 753
      if (mpp) {
#line 753
        if (! opts->hex) {
#line 753
          mdp = (struct sdparm_mode_descriptor_t  const  *)mpp->mp_desc;
        } else {
#line 753
          mdp = (struct sdparm_mode_descriptor_t  const  *)((void *)0);
        }
      } else {
#line 753
        mdp = (struct sdparm_mode_descriptor_t  const  *)((void *)0);
      }
#line 754
      if (mdp) {
#line 754
        first_desc_off = (int )mdp->first_desc_off;
      } else {
#line 754
        first_desc_off = 0;
      }
#line 755
      if (first_desc_off > 1) {
#line 756
        res = 0;
#line 756
        fdesc_mpi = mpi;
        {
#line 756
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 756
          if (fdesc_mpi) {
#line 756
            if (pn == (int )fdesc_mpi->page_num) {
#line 756
              if (! (spn == (int )fdesc_mpi->subpage_num)) {
#line 756
                goto while_break___1;
              }
            } else {
#line 756
              goto while_break___1;
            }
          } else {
#line 756
            goto while_break___1;
          }
#line 759
          if (fdesc_mpi->start_byte >= (int const   )first_desc_off) {
#line 760
            res = 1;
#line 761
            goto while_break___1;
          }
#line 756
          fdesc_mpi ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 764
        if (0 == res) {
#line 765
          fdesc_mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
        }
      }
#line 767
      if (opts->num_desc) {
#line 768
        num = 0;
#line 771
        if (fdesc_mpi) {
#line 771
          if (smask & 1) {
#line 772
            if (mdp->num_descs_inc < 0) {
#line 772
              if (mdp->desc_len > 0) {
                {
#line 773
                tmp___0 = sdp_get_big_endian((unsigned char const   *)(cur_mp + mdp->num_descs_off),
                                             7, (int )(mdp->num_descs_bytes * 8));
#line 773
                u = tmp___0 / (uint64_t )mdp->desc_len;
                }
              } else {
                {
#line 777
                tmp___1 = sdp_get_big_endian((unsigned char const   *)(cur_mp + mdp->num_descs_off),
                                             7, (int )(mdp->num_descs_bytes * 8));
#line 777
                u = tmp___1 + (uint64_t )mdp->num_descs_inc;
                }
              }
            } else {
              {
#line 777
              tmp___1 = sdp_get_big_endian((unsigned char const   *)(cur_mp + mdp->num_descs_off),
                                           7, (int )(mdp->num_descs_bytes * 8));
#line 777
              u = tmp___1 + (uint64_t )mdp->num_descs_inc;
              }
            }
#line 780
            num = (int )u;
          }
        }
#line 782
        if (opts->long_out) {
          {
#line 783
          printf((char const   */* __restrict  */)"number of descriptors=%d\n", num);
          }
        } else {
          {
#line 785
          printf((char const   */* __restrict  */)"%d\n", num);
          }
        }
#line 786
        return (0);
      }
#line 788
      if (smask & 1) {
        {
#line 789
        len = sdp_get_mp_len(cur_mp);
#line 790
        printf((char const   */* __restrict  */)"%s ", buff);
        }
#line 791
        if (opts->verbose) {
#line 792
          if (spn) {
            {
#line 793
            printf((char const   */* __restrict  */)"[0x%x,0x%x] ", pn, spn);
            }
          } else {
            {
#line 795
            printf((char const   */* __restrict  */)"[0x%x] ", pn);
            }
          }
        }
        {
#line 797
        printf((char const   */* __restrict  */)"mode page");
        }
#line 798
        if (opts->long_out > 1) {
          {
#line 799
          printf((char const   */* __restrict  */)" [PS=%d]:\n", ! (! ((int )cur_mp[0] & 128)));
          }
        } else
#line 798
        if (opts->verbose) {
          {
#line 799
          printf((char const   */* __restrict  */)" [PS=%d]:\n", ! (! ((int )cur_mp[0] & 128)));
          }
        } else {
          {
#line 801
          printf((char const   */* __restrict  */)":\n");
          }
        }
        {
#line 802
        check_mode_page(cur_mp, pn, rep_len, opts);
        }
#line 803
        if (opts->hex) {
#line 804
          if (len > (int )sizeof(cur_mp)) {
            {
#line 805
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> decoded page length too large=%d, trim\n",
                    len);
#line 807
            len = (int )sizeof(cur_mp);
            }
          }
          {
#line 809
          printf((char const   */* __restrict  */)"    Current:\n");
#line 810
          dStrHex((char const   *)(cur_mp), len, 1);
          }
#line 811
          if (smask & 2) {
            {
#line 812
            printf((char const   */* __restrict  */)"    Changeable:\n");
#line 813
            dStrHex((char const   *)(cha_mp), len, 1);
            }
          }
#line 815
          if (smask & 4) {
            {
#line 816
            printf((char const   */* __restrict  */)"    Default:\n");
#line 817
            dStrHex((char const   *)(def_mp), len, 1);
            }
          }
#line 819
          if (smask & 8) {
            {
#line 820
            printf((char const   */* __restrict  */)"    Saved:\n");
#line 821
            dStrHex((char const   *)(sav_mp), len, 1);
            }
          }
        }
      } else
#line 825
      if (opts->verbose) {
#line 825
        goto _L___0;
      } else
#line 825
      if (single_pg) {
        _L___0: /* CIL Label */ 
#line 826
        if (spn) {
#line 826
          tmp___2 = "sub";
        } else {
#line 826
          tmp___2 = "";
        }
        {
#line 826
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> %s mode %spage ",
                buff, tmp___2);
        }
#line 828
        if (opts->verbose) {
#line 829
          if (spn) {
            {
#line 830
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[0x%x,0x%x] ",
                    pn, spn);
            }
          } else {
            {
#line 832
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[0x%x] ",
                    pn);
            }
          }
        }
#line 834
        if (5 == res) {
          {
#line 835
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not found\n");
          }
        } else
#line 836
        if (0 == res) {
          {
#line 837
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"some problem\n");
          }
        } else {
          {
#line 839
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed\n");
          }
        }
      }
    }
#line 843
    if (smask) {
#line 843
      if (! opts->hex) {
#line 844
        if (mpi->start_byte >= (int const   )len) {
#line 845
          if (0 == (int )opts->flexible) {
#line 845
            if (0 == (int )opts->verbose) {
#line 846
              goto __Cont;
            }
          }
#line 847
          if (0 == warned) {
#line 848
            warned = 1;
#line 849
            if (opts->flexible) {
              {
#line 850
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> hereafter field position exceeds mode page length=%d\n",
                      len);
              }
            } else {
              {
#line 853
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" >> skipping rest as field position exceeds mode page length=%d\n",
                      len);
              }
#line 855
              goto __Cont;
            }
          }
#line 858
          if (0 == (int )opts->flexible) {
#line 859
            goto __Cont;
          }
        }
        {
#line 861
        print_mp_arr_entry("  ", smask, mpi, pc_arr, (int )opts->long_out, 0);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 694
    mpi ++;
#line 694
    fetch_pg = 0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 864
  if (mpi) {
#line 864
    if ((unsigned long )((void *)0) == (unsigned long )mpi->acron) {
#line 864
      if (fdesc_mpi) {
#line 865
        mpi --;
#line 866
        if (pn == (int )mpi->page_num) {
#line 866
          if (spn == (int )mpi->subpage_num) {
            {
#line 867
            print_mpage_extra_desc(pc_arr, rep_len, mpp, fdesc_mpi, mpi, opts, smask);
            }
          }
        }
      }
    }
  }
#line 870
  return (0);
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int check_desc_convert_mpi(int desc_num , struct sdparm_mode_page_t  const  *mpp ,
                                  struct sdparm_mode_page_item  const  *ref_mpi ,
                                  struct sdparm_mode_page_item *out_mpi , char *b ,
                                  int b_len ) 
{ 
  int n ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 882
  if (mpp) {
#line 882
    if (mpp->mp_desc) {
#line 882
      if (ref_mpi->acron) {
        {
#line 883
        *out_mpi = (struct sdparm_mode_page_item )*ref_mpi;
#line 884
        strncpy((char */* __restrict  */)b, (char const   */* __restrict  */)ref_mpi->acron,
                (size_t )b_len);
        }
#line 885
        if (b_len > 10) {
#line 885
          tmp = b_len - 8;
        } else {
#line 885
          tmp = 4;
        }
        {
#line 885
        *(b + tmp) = (char )'\000';
#line 886
        tmp___0 = strlen((char const   *)b);
#line 886
        n = (int )tmp___0;
#line 887
        snprintf((char */* __restrict  */)(b + n), (size_t )(b_len - n), (char const   */* __restrict  */)".%d",
                 desc_num);
#line 888
        out_mpi->acron = (char const   *)b;
        }
#line 889
        return (1);
      } else {
#line 891
        return (0);
      }
    } else {
#line 891
      return (0);
    }
  } else {
#line 891
    return (0);
  }
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int desc_adjust_start_byte(int desc_num , struct sdparm_mode_page_t  const  *mpp ,
                                  unsigned char *cur_mp , int rep_len , struct sdparm_mode_page_item *mpi ,
                                  struct sdparm_opt_coll  const  *opts ) 
{ 
  struct sdparm_mode_descriptor_t  const  *mdp ;
  uint64_t u ;
  unsigned char const   *ucp ;
  int d_off ;
  int sb_off ;
  int j ;
  uint64_t tmp ;
  uint64_t tmp___0 ;

  {
#line 906
  mdp = (struct sdparm_mode_descriptor_t  const  *)mpp->mp_desc;
#line 907
  if (mdp->num_descs_off < (int const   )rep_len) {
#line 907
    if (mdp->num_descs_off < 64) {
#line 908
      if (mdp->num_descs_inc < 0) {
#line 908
        if (mdp->desc_len > 0) {
          {
#line 909
          tmp = sdp_get_big_endian((unsigned char const   *)(cur_mp + mdp->num_descs_off),
                                   7, (int )(mdp->num_descs_bytes * 8));
#line 909
          u = tmp / (uint64_t )mdp->desc_len;
          }
        } else {
          {
#line 912
          tmp___0 = sdp_get_big_endian((unsigned char const   *)(cur_mp + mdp->num_descs_off),
                                       7, (int )(mdp->num_descs_bytes * 8));
#line 912
          u = tmp___0 + (uint64_t )mdp->num_descs_inc;
          }
        }
      } else {
        {
#line 912
        tmp___0 = sdp_get_big_endian((unsigned char const   *)(cur_mp + mdp->num_descs_off),
                                     7, (int )(mdp->num_descs_bytes * 8));
#line 912
        u = tmp___0 + (uint64_t )mdp->num_descs_inc;
        }
      }
#line 914
      if ((uint64_t )desc_num < u) {
#line 915
        if (mdp->desc_len > 0) {
#line 916
          mpi->start_byte += (int )(mdp->desc_len * (int const   )desc_num);
#line 917
          if (mpi->start_byte < rep_len) {
#line 918
            return (1);
          }
        } else
#line 919
        if (mdp->desc_len_off > 0) {
#line 922
          sb_off = mpi->start_byte - (int )mdp->first_desc_off;
#line 923
          d_off = (int )mdp->first_desc_off;
#line 924
          j = 0;
          {
#line 924
          while (1) {
            while_continue: /* CIL Label */ ;
#line 925
            if (j > desc_num) {
              {
#line 926
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> descriptor number sanity ...\n");
              }
#line 927
              goto while_break;
            }
#line 929
            if (j == desc_num) {
#line 930
              mpi->start_byte = d_off + sb_off;
#line 931
              if (mpi->start_byte < rep_len) {
#line 932
                return (1);
              } else {
                {
#line 934
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> new start_byte exceeds current page ...\n");
                }
              }
#line 936
              goto while_break;
            }
            {
#line 938
            ucp = (unsigned char const   *)((cur_mp + d_off) + mdp->desc_len_off);
#line 939
            u = sdp_get_big_endian(ucp, 7, (int )(mdp->desc_len_bytes * 8));
#line 941
            d_off = (int )((uint64_t )d_off + ((uint64_t )(mdp->desc_len_off + mdp->desc_len_bytes) + u));
            }
#line 943
            if (d_off >= rep_len) {
              {
#line 944
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> descriptor number too large for current page ...\n");
              }
#line 946
              goto while_break;
            }
#line 924
            j ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
      } else
#line 950
      if (opts->verbose) {
        {
#line 951
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    >> mode page says it has only %d descriptors\n",
                (int )u);
        }
      }
    }
  }
#line 954
  return (0);
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int print_mode_items(int sg_fd , struct sdparm_mode_page_settings  const  *mps ,
                            int pdt , struct sdparm_opt_coll  const  *opts ) 
{ 
  int k ;
  int res ;
  int verb ;
  int smask ;
  int pn ;
  int spn ;
  int warned ;
  int rep_len ;
  int len ;
  int desc_num ;
  int adapt ;
  int long_o ;
  uint64_t u ;
  int64_t val ;
  struct sdparm_mode_page_item  const  *mpi ;
  struct sdparm_mode_page_item ampi ;
  struct sdparm_mode_page_t  const  *mpp ;
  unsigned char cur_mp[252] ;
  unsigned char cha_mp[252] ;
  unsigned char def_mp[252] ;
  unsigned char sav_mp[252] ;
  struct sdparm_mode_page_it_val  const  *ivp ;
  char buff[128] ;
  char b_tmp[32] ;
  void *pc_arr[4] ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 968
  mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
#line 978
  warned = 0;
#line 979
  if (opts->verbose > 0) {
#line 979
    verb = (int )(opts->verbose - 1);
  } else {
#line 979
    verb = 0;
  }
#line 980
  long_o = (int )opts->long_out;
#line 981
  k = 0;
#line 981
  pn = 0;
#line 981
  spn = 0;
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! (k < (int )mps->num_it_vals)) {
#line 981
      goto while_break;
    }
    {
#line 982
    ivp = (struct sdparm_mode_page_it_val  const  *)(& mps->it_vals[k]);
#line 983
    val = (int64_t )ivp->val;
#line 984
    desc_num = (int )ivp->descriptor_num;
#line 985
    mpi = & ivp->mpi;
#line 986
    mpp = sdp_get_mpage_name((int )mpi->page_num, (int )mpi->subpage_num, (int )mpi->pdt,
                             (int )opts->transport, (int )opts->vendor, long_o, (int )opts->hex,
                             buff, (int )sizeof(buff));
    }
#line 989
    if (desc_num > 0) {
      {
#line 990
      tmp___0 = check_desc_convert_mpi(desc_num, mpp, mpi, & ampi, b_tmp, (int )sizeof(b_tmp));
      }
#line 990
      if (tmp___0) {
#line 992
        adapt = 1;
#line 993
        mpi = (struct sdparm_mode_page_item  const  *)(& ampi);
      } else {
#line 995
        if (mpi->acron) {
#line 995
          tmp = mpi->acron;
        } else {
#line 995
          tmp = (char const   */* const  */)"";
        }
        {
#line 995
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t decode descriptors for %s in %s mode page\n",
                tmp, buff);
        }
#line 997
        return (1);
      }
    } else {
#line 1000
      adapt = 0;
    }
#line 1001
    if (0 == k) {
#line 1001
      goto _L;
    } else
#line 1001
    if (pn != (int )mpi->page_num) {
#line 1001
      goto _L;
    } else
#line 1001
    if (spn != (int )mpi->subpage_num) {
      _L: /* CIL Label */ 
#line 1002
      pn = (int )mpi->page_num;
#line 1003
      spn = (int )mpi->subpage_num;
#line 1004
      smask = 0;
#line 1005
      res = 0;
      {
#line 1007
      if (val == 0L) {
#line 1007
        goto case_0;
      }
#line 1017
      if (val == 2L) {
#line 1017
        goto case_2;
      }
#line 1017
      if (val == 1L) {
#line 1017
        goto case_2;
      }
#line 1026
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 1008
      pc_arr[0] = (void *)(cur_mp);
#line 1009
      pc_arr[1] = (void *)(cha_mp);
#line 1010
      pc_arr[2] = (void *)(def_mp);
#line 1011
      pc_arr[3] = (void *)(sav_mp);
#line 1012
      res = sg_get_mode_page_controls(sg_fd, (int )opts->mode_6, pn, spn, (int )opts->dbd,
                                      (int )opts->flexible, 252, & smask, pc_arr,
                                      & rep_len, verb);
      }
#line 1015
      goto switch_break;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      {
#line 1018
      pc_arr[0] = (void *)(cur_mp);
#line 1019
      pc_arr[1] = (void *)0;
#line 1020
      pc_arr[2] = (void *)0;
#line 1021
      pc_arr[3] = (void *)0;
#line 1022
      res = sg_get_mode_page_controls(sg_fd, (int )opts->mode_6, pn, spn, (int )opts->dbd,
                                      (int )opts->flexible, 252, & smask, pc_arr,
                                      & rep_len, verb);
      }
#line 1025
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1027
      if (mpi->acron) {
        {
#line 1028
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad value given to %s\n",
                mpi->acron);
        }
      } else {
        {
#line 1031
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad value given to 0x%x:%d:%d\n",
                mpi->start_byte, mpi->start_bit, mpi->num_bits);
        }
      }
#line 1033
      return (1);
      switch_break: /* CIL Label */ ;
      }
#line 1035
      if (9 == res) {
#line 1036
        if (opts->mode_6) {
          {
#line 1037
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"6 byte MODE SENSE cdb not supported, try again without \'-6\' option\n");
          }
        } else {
          {
#line 1040
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"10 byte MODE SENSE cdb not supported, try again with \'-6\' option\n");
          }
        }
#line 1042
        return (res);
      } else
#line 1043
      if (2 == res) {
        {
#line 1044
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MODE SENSE failed, device not ready\n");
        }
#line 1045
        return (res);
      } else
#line 1046
      if (6 == res) {
        {
#line 1047
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MODE SENSE failed, unit attention\n");
        }
#line 1048
        return (res);
      } else
#line 1049
      if (11 == res) {
        {
#line 1050
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MODE SENSE failed, aborted command\n");
        }
#line 1051
        return (res);
      }
#line 1053
      if (0 == smask) {
#line 1053
        if (res) {
#line 1054
          if (mpi->acron) {
            {
#line 1055
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                    mpi->acron);
            }
          } else {
            {
#line 1057
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%x:%d:%d ",
                    mpi->start_byte, mpi->start_bit, mpi->num_bits);
            }
          }
#line 1059
          if (5 == res) {
            {
#line 1060
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not found in ");
            }
          } else {
#line 1062
            if (verb) {
#line 1062
              tmp___1 = "";
            } else {
#line 1062
              tmp___1 = "(try adding \'-vv\') ";
            }
            {
#line 1062
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error %sin ",
                    tmp___1);
            }
          }
          {
#line 1064
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page\n",
                  buff);
          }
#line 1065
          return (res);
        }
      }
#line 1067
      if (smask & 1) {
        {
#line 1068
        check_mode_page(cur_mp, pn, rep_len, opts);
        }
      }
    }
#line 1070
    if (adapt) {
      {
#line 1071
      tmp___2 = desc_adjust_start_byte(desc_num, mpp, cur_mp, rep_len, & ampi, opts);
      }
#line 1071
      if (! tmp___2) {
        {
#line 1073
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> failed to find field acronym: %s in current page\n",
                mpi->acron);
        }
#line 1075
        return (99);
      }
    }
#line 1078
    if (pdt >= 0) {
#line 1078
      if (0 == warned) {
#line 1078
        if (mpi->acron) {
#line 1078
          if (mpi->pdt >= 0) {
#line 1078
            if (pdt != (int )mpi->pdt) {
              {
#line 1080
              warned = 1;
#line 1081
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: peripheral device type (pdt) is 0x%x but acronym %s\n   is associated with pdt 0x%x.\n",
                      pdt, ivp->mpi.acron, ivp->mpi.pdt);
              }
            }
          }
        }
      }
    }
#line 1085
    if (smask & 1) {
      {
#line 1085
      tmp___3 = sdp_get_mp_len(cur_mp);
#line 1085
      len = tmp___3;
      }
    } else {
#line 1085
      len = 0;
    }
#line 1086
    if (mpi->start_byte >= (int const   )len) {
      {
#line 1087
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> warning: ");
      }
#line 1088
      if (mpi->acron) {
        {
#line 1089
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                mpi->acron);
        }
      } else {
        {
#line 1091
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%x:%d:%d ",
                mpi->start_byte, mpi->start_bit, mpi->num_bits);
        }
      }
      {
#line 1093
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"field position exceeds mode page length=%d\n",
              len);
      }
#line 1095
      if (! opts->flexible) {
#line 1096
        goto __Cont;
      }
    }
#line 1098
    if (0L == val) {
#line 1099
      if (opts->hex) {
#line 1100
        if (smask & 1) {
          {
#line 1101
          u = sdp_mp_get_value(mpi, (unsigned char const   *)(cur_mp));
#line 1102
          printf((char const   */* __restrict  */)"0x%02lx ", u);
          }
        } else {
          {
#line 1104
          printf((char const   */* __restrict  */)"-    ");
          }
        }
#line 1105
        if (smask & 2) {
          {
#line 1106
          u = sdp_mp_get_value(mpi, (unsigned char const   *)(cha_mp));
#line 1107
          printf((char const   */* __restrict  */)"0x%02lx ", u);
          }
        } else {
          {
#line 1109
          printf((char const   */* __restrict  */)"-    ");
          }
        }
#line 1110
        if (smask & 4) {
          {
#line 1111
          u = sdp_mp_get_value(mpi, (unsigned char const   *)(def_mp));
#line 1112
          printf((char const   */* __restrict  */)"0x%02lx ", u);
          }
        } else {
          {
#line 1114
          printf((char const   */* __restrict  */)"-    ");
          }
        }
#line 1115
        if (smask & 8) {
          {
#line 1116
          u = sdp_mp_get_value(mpi, (unsigned char const   *)(sav_mp));
#line 1117
          printf((char const   */* __restrict  */)"0x%02lx ", u);
          }
        } else {
          {
#line 1119
          printf((char const   */* __restrict  */)"-    ");
          }
        }
        {
#line 1120
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 1122
        print_mp_arr_entry("", smask, mpi, pc_arr, long_o, 0);
        }
      }
    } else
#line 1123
    if (1L == val) {
#line 1124
      if (opts->hex) {
#line 1125
        if (smask & 1) {
          {
#line 1126
          u = sdp_mp_get_value(mpi, (unsigned char const   *)(cur_mp));
#line 1127
          printf((char const   */* __restrict  */)"0x%02lx ", u);
          }
        } else {
          {
#line 1129
          printf((char const   */* __restrict  */)"-    ");
          }
        }
        {
#line 1130
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 1132
        print_mp_arr_entry("", smask & 1, mpi, pc_arr, long_o, 0);
        }
      }
    } else
#line 1133
    if (2L == val) {
#line 1134
      if (opts->hex) {
#line 1135
        if (smask & 1) {
          {
#line 1136
          u = sdp_mp_get_value(mpi, (unsigned char const   *)(cur_mp));
#line 1137
          printf((char const   */* __restrict  */)"%02ld ", (int64_t )u);
          }
        } else {
          {
#line 1139
          printf((char const   */* __restrict  */)"-    ");
          }
        }
        {
#line 1140
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 1142
        print_mp_arr_entry("", smask & 1, mpi, pc_arr, long_o, 1);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 981
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1145
  return (0);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int change_mode_page(int sg_fd , int pdt , struct sdparm_mode_page_settings  const  *mps ,
                            struct sdparm_opt_coll  const  *opts ) 
{ 
  int k ;
  int off ;
  int md_len ;
  int len ;
  int res ;
  int desc_num ;
  int pn ;
  int spn ;
  char ebuff[256] ;
  struct sdparm_mode_page_t  const  *mpp ;
  unsigned char mdpg[2048] ;
  struct sdparm_mode_page_it_val  const  *ivp ;
  struct sdparm_mode_page_item  const  *mpi ;
  struct sdparm_mode_page_item ampi ;
  char b[128] ;
  char b_tmp[32] ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 1159
  mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
#line 1167
  if (pdt >= 0) {
#line 1169
    k = 0;
    {
#line 1169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1169
      if (! (k < (int )mps->num_it_vals)) {
#line 1169
        goto while_break;
      }
#line 1170
      ivp = (struct sdparm_mode_page_it_val  const  *)(& mps->it_vals[k]);
#line 1171
      if (ivp->mpi.acron) {
#line 1171
        if (ivp->mpi.pdt >= 0) {
#line 1171
          if (pdt != (int )ivp->mpi.pdt) {
            {
#line 1173
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: peripheral device type (pdt) is 0x%x but acronym %s\n  is associated with pdt 0x%x. To bypass use numeric addressing mode.\n",
                    pdt, ivp->mpi.acron, ivp->mpi.pdt);
            }
#line 1177
            return (1);
          }
        }
      }
#line 1169
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1181
  pn = (int )mps->page_num;
#line 1182
  spn = (int )mps->subpage_num;
#line 1183
  mpp = sdp_get_mpage_name(pn, spn, pdt, (int )opts->transport, (int )opts->vendor,
                           0, 0, b, (int )sizeof(b));
#line 1185
  memset((void *)(mdpg), 0, sizeof(mdpg));
#line 1186
  res = ll_mode_sense(sg_fd, opts, pn, spn, mdpg, 4, 1, (int )opts->verbose);
  }
#line 1187
  if (0 != res) {
#line 1188
    if (2 == res) {
      {
#line 1189
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, device not ready\n");
      }
    } else
#line 1190
    if (9 == res) {
#line 1191
      if (opts->mode_6) {
        {
#line 1192
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"6 byte MODE SENSE cdb not supported, try again without \'-6\' option\n");
        }
      } else {
        {
#line 1195
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"10 byte MODE SENSE cdb not supported, try again with \'-6\' option\n");
        }
      }
    } else
#line 1197
    if (6 == res) {
      {
#line 1198
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, unit attention\n");
      }
    } else
#line 1199
    if (11 == res) {
      {
#line 1200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode sense command failed, aborted command\n");
      }
    }
    {
#line 1201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: failed fetching page: %s\n",
            b);
    }
#line 1203
    return (res);
  }
#line 1205
  if (opts->mode_6) {
#line 1205
    md_len = (int )mdpg[0] + 1;
  } else {
#line 1205
    md_len = (((int )mdpg[0] << 8) + (int )mdpg[1]) + 2;
  }
#line 1206
  if (md_len > (int )sizeof(mdpg)) {
    {
#line 1207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: mode data length=%d exceeds allocation length=%d\n",
            md_len, (int )sizeof(mdpg));
    }
#line 1209
    return (97);
  }
  {
#line 1211
  res = ll_mode_sense(sg_fd, opts, pn, spn, mdpg, md_len, 1, (int )opts->verbose);
  }
#line 1212
  if (0 != res) {
    {
#line 1213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: failed fetching page: %s\n",
            b);
    }
#line 1214
    return (res);
  }
  {
#line 1216
  off = sg_mode_page_offset((unsigned char const   *)(mdpg), md_len, (int )opts->mode_6,
                            ebuff, 256);
  }
#line 1217
  if (off < 0) {
    {
#line 1218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: page offset failed: %s\n",
            ebuff);
    }
#line 1219
    return (97);
  }
  {
#line 1221
  len = sdp_get_mp_len(mdpg + off);
#line 1222
  mdpg[0] = (unsigned char)0;
  }
#line 1223
  if (! opts->mode_6) {
#line 1224
    mdpg[1] = (unsigned char)0;
  }
#line 1225
  if (0 == pdt) {
#line 1226
    if (opts->mode_6) {
#line 1226
      tmp = 2;
    } else {
#line 1226
      tmp = 3;
    }
#line 1226
    mdpg[tmp] = (unsigned char)0;
  }
#line 1228
  k = 0;
  {
#line 1228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1228
    if (! (k < (int )mps->num_it_vals)) {
#line 1228
      goto while_break___0;
    }
#line 1229
    ivp = (struct sdparm_mode_page_it_val  const  *)(& mps->it_vals[k]);
#line 1230
    mpi = & ivp->mpi;
#line 1231
    desc_num = (int )ivp->descriptor_num;
#line 1232
    if (desc_num > 0) {
      {
#line 1233
      tmp___2 = check_desc_convert_mpi(desc_num, mpp, mpi, & ampi, b_tmp, (int )sizeof(b_tmp));
      }
#line 1233
      if (tmp___2) {
        {
#line 1235
        mpi = (struct sdparm_mode_page_item  const  *)(& ampi);
#line 1236
        tmp___0 = desc_adjust_start_byte(desc_num, mpp, mdpg + off, len, & ampi, opts);
        }
#line 1236
        if (! tmp___0) {
          {
#line 1238
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> failed to find field acronym: %s in current page\n",
                  mpi->acron);
          }
#line 1240
          return (99);
        }
      } else {
#line 1243
        if (mpi->acron) {
#line 1243
          tmp___1 = mpi->acron;
        } else {
#line 1243
          tmp___1 = (char const   */* const  */)"";
        }
        {
#line 1243
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t decode descriptors for %s in %s mode page\n",
                tmp___1, b);
        }
#line 1245
        return (1);
      }
    }
#line 1248
    if (mpi->start_byte >= (int const   )len) {
      {
#line 1250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The start_byte of ");
      }
#line 1251
      if (mpi->acron) {
        {
#line 1252
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                mpi->acron);
        }
      } else {
        {
#line 1254
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"0x%x:%d:%d ",
                mpi->start_byte, mpi->start_bit, mpi->num_bits);
        }
      }
      {
#line 1256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exceeds length of this mode page: %d [0x%x]\n",
              len, len);
      }
#line 1258
      if (opts->flexible) {
        {
#line 1259
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    applying anyway\n");
        }
      } else {
        {
#line 1261
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    nothing modified, use \'--flexible\' to override\n");
        }
#line 1263
        return (97);
      }
    }
#line 1266
    if (ivp->val >= 0L) {
#line 1266
      if (ivp->orig_val > 0L) {
#line 1266
        if (ivp->orig_val > ivp->val) {
#line 1266
          if (0 == (int )opts->quiet) {
            {
#line 1268
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: given value (%ld) truncated to %ld by field size [%d bits]\n",
                    ivp->orig_val, ivp->val, mpi->num_bits);
#line 1271
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    applying anyway\n");
            }
          }
        }
      }
    }
    {
#line 1273
    sdp_mp_set_value((uint64_t )ivp->val, mpi, mdpg + off);
#line 1228
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1276
  if (! ((int )mdpg[off] & 128)) {
#line 1276
    if (opts->save) {
      {
#line 1277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: mode page indicates it is not savable but\n    \'--save\' option given (try without it)\n");
      }
#line 1280
      return (97);
    }
  }
#line 1282
  mdpg[off] = (unsigned char )((int )mdpg[off] & 127);
#line 1283
  if (opts->dummy) {
    {
#line 1284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mode data that would have been written:\n");
#line 1285
    dStrHex((char const   *)(mdpg), md_len, 1);
    }
#line 1286
    return (0);
  }
#line 1288
  if (opts->mode_6) {
    {
#line 1289
    res = sg_ll_mode_select6(sg_fd, 1, (int )opts->save, (void *)(mdpg), md_len, 1,
                             (int )opts->verbose);
    }
  } else {
    {
#line 1292
    res = sg_ll_mode_select10(sg_fd, 1, (int )opts->save, (void *)(mdpg), md_len,
                              1, (int )opts->verbose);
    }
  }
#line 1294
  if (0 != res) {
    {
#line 1295
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"change_mode_page: failed setting page: %s\n",
            b);
    }
#line 1296
    return (res);
  }
#line 1298
  return (0);
}
}
#line 1305 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int set_def_mode_page(int sg_fd , int pn , int spn , unsigned char *mode_pg ,
                             int mode_pg_len , struct sdparm_opt_coll  const  *opts ) 
{ 
  int len ;
  int off ;
  int md_len ;
  unsigned char *mdp ;
  char ebuff[256] ;
  int ret ;
  char buff[128] ;
  void *tmp ;

  {
  {
#line 1312
  ret = -1;
#line 1315
  len = mode_pg_len + 128;
#line 1316
  tmp = malloc((size_t )len);
#line 1316
  mdp = (unsigned char *)tmp;
  }
#line 1317
  if ((unsigned long )((void *)0) == (unsigned long )mdp) {
    {
#line 1318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: malloc failed, out of memory\n");
    }
#line 1319
    return (15);
  }
  {
#line 1321
  memset((void *)mdp, 0, (size_t )len);
#line 1322
  ret = ll_mode_sense(sg_fd, opts, pn, spn, mdp, 4, 1, (int )opts->verbose);
  }
#line 1323
  if (0 != ret) {
    {
#line 1324
    sdp_get_mpage_name(pn, spn, -1, (int )opts->transport, (int )opts->vendor, 0,
                       0, buff, (int )sizeof(buff));
#line 1326
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: failed fetching page: %s\n",
            buff);
    }
#line 1328
    goto err_out;
  }
#line 1330
  if (opts->mode_6) {
#line 1330
    md_len = (int )*(mdp + 0) + 1;
  } else {
#line 1330
    md_len = (((int )*(mdp + 0) << 8) + (int )*(mdp + 1)) + 2;
  }
#line 1331
  if (md_len > len) {
    {
#line 1332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: mode data length=%d exceeds allocation length=%d\n",
            md_len, len);
#line 1334
    ret = 97;
    }
#line 1335
    goto err_out;
  }
  {
#line 1337
  ret = ll_mode_sense(sg_fd, opts, pn, spn, mdp, md_len, 1, (int )opts->verbose);
  }
#line 1338
  if (0 != ret) {
    {
#line 1339
    sdp_get_mpage_name(pn, spn, -1, (int )opts->transport, (int )opts->vendor, 0,
                       0, buff, (int )sizeof(buff));
#line 1341
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: failed fetching page: %s\n",
            buff);
    }
#line 1343
    goto err_out;
  }
  {
#line 1345
  off = sg_mode_page_offset((unsigned char const   *)mdp, len, (int )opts->mode_6,
                            ebuff, 256);
  }
#line 1346
  if (off < 0) {
    {
#line 1347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: page offset failed: %s\n",
            ebuff);
#line 1349
    ret = 97;
    }
#line 1350
    goto err_out;
  }
#line 1352
  *(mdp + 0) = (unsigned char)0;
#line 1353
  if (! opts->mode_6) {
#line 1354
    *(mdp + 1) = (unsigned char)0;
  }
#line 1355
  if (md_len - off > mode_pg_len) {
    {
#line 1356
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: mode length length=%d exceeds new contents length=%d\n",
            md_len - off, mode_pg_len);
#line 1358
    ret = 97;
    }
#line 1359
    goto err_out;
  }
  {
#line 1361
  memcpy((void */* __restrict  */)(mdp + off), (void const   */* __restrict  */)mode_pg,
         (size_t )(md_len - off));
#line 1362
  *(mdp + off) = (unsigned char )((int )*(mdp + off) & 127);
  }
#line 1363
  if (opts->dummy) {
    {
#line 1364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mode data that would have been written:\n");
#line 1365
    dStrHex((char const   *)mdp, md_len, 1);
#line 1366
    ret = 0;
    }
#line 1367
    goto err_out;
  }
#line 1369
  if (opts->mode_6) {
    {
#line 1370
    ret = sg_ll_mode_select6(sg_fd, 1, (int )opts->save, (void *)mdp, md_len, 1, (int )opts->verbose);
    }
  } else {
    {
#line 1373
    ret = sg_ll_mode_select10(sg_fd, 1, (int )opts->save, (void *)mdp, md_len, 1,
                              (int )opts->verbose);
    }
  }
#line 1375
  if (0 != ret) {
    {
#line 1376
    sdp_get_mpage_name(pn, spn, -1, (int )opts->transport, (int )opts->vendor, 0,
                       0, buff, (int )sizeof(buff));
#line 1378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_def_mode_page: failed setting page: %s\n",
            buff);
    }
#line 1380
    goto err_out;
  }
  err_out: 
  {
#line 1384
  free((void *)mdp);
  }
#line 1385
  return (ret);
}
}
#line 1388 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int set_mp_defaults(int sg_fd , int pn , int spn , int pdt , struct sdparm_opt_coll  const  *opts ) 
{ 
  int smask ;
  int res ;
  int len ;
  int rep_len ;
  unsigned char cur_mp[252] ;
  unsigned char def_mp[252] ;
  char buff[128] ;
  void *pc_arr[4] ;
  int tmp ;

  {
  {
#line 1398
  smask = 0;
#line 1399
  pc_arr[0] = (void *)(cur_mp);
#line 1400
  pc_arr[1] = (void *)0;
#line 1401
  pc_arr[2] = (void *)(def_mp);
#line 1402
  pc_arr[3] = (void *)0;
#line 1403
  res = sg_get_mode_page_controls(sg_fd, (int )opts->mode_6, pn, spn, (int )opts->dbd,
                                  (int )opts->flexible, 252, & smask, pc_arr, & rep_len,
                                  (int )opts->verbose);
  }
#line 1406
  if (9 == res) {
#line 1407
    if (opts->mode_6) {
      {
#line 1408
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"6 byte MODE SENSE cdb not supported, try again without \'-6\' option\n");
      }
    } else {
      {
#line 1411
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"10 byte MODE SENSE cdb not supported, try again with \'-6\' option\n");
      }
    }
#line 1413
    return (res);
  } else
#line 1415
  if (2 == res) {
    {
#line 1416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MODE SENSE failed, device not ready\n");
    }
#line 1417
    return (res);
  } else
#line 1418
  if (11 == res) {
    {
#line 1419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MODE SENSE failed, aborted command\n");
    }
#line 1420
    return (res);
  }
#line 1422
  if (opts->verbose) {
#line 1422
    if (0 == (int )opts->flexible) {
#line 1422
      if (rep_len > 2560) {
        {
#line 1423
        sdp_get_mpage_name(pn, spn, pdt, (int )opts->transport, (int )opts->vendor,
                           0, 0, buff, (int )sizeof(buff));
#line 1425
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s mode page length=%d too long, perhaps try \'--flexible\'\n",
                buff, rep_len);
        }
      }
    }
  }
#line 1428
  if (smask & 1) {
    {
#line 1429
    len = sdp_get_mp_len(cur_mp);
    }
#line 1430
    if (smask & 4) {
      {
#line 1431
      tmp = set_def_mode_page(sg_fd, pn, spn, def_mp, len, opts);
      }
#line 1431
      return (tmp);
    } else {
      {
#line 1434
      sdp_get_mpage_name(pn, spn, pdt, (int )opts->transport, (int )opts->vendor,
                         0, 0, buff, (int )sizeof(buff));
#line 1436
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> %s mode page (default) not supported\n",
              buff);
      }
#line 1438
      return (5);
    }
  } else {
    {
#line 1441
    sdp_get_mpage_name(pn, spn, pdt, (int )opts->transport, (int )opts->vendor, 0,
                       0, buff, (int )sizeof(buff));
#line 1443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> %s mode page not supported\n",
            buff);
    }
#line 1444
    return (5);
  }
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int64_t get_llnum(char const   *buf ) 
{ 
  int res ;
  int len ;
  int64_t num ;
  uint64_t unum ;
  size_t tmp ;
  int tmp___0 ;
  int64_t tmp___1 ;

  {
#line 1458
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1459
    return ((int64_t )-1);
  } else
#line 1458
  if (0 == (int )*(buf + 0)) {
#line 1459
    return ((int64_t )-1);
  }
  {
#line 1460
  tmp = strlen(buf);
#line 1460
  len = (int )tmp;
  }
#line 1461
  if (48 == (int )*(buf + 0)) {
#line 1461
    if (120 == (int )*(buf + 1)) {
      {
#line 1462
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1463
      num = (int64_t )unum;
      }
    } else
#line 1461
    if (88 == (int )*(buf + 1)) {
      {
#line 1462
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1463
      num = (int64_t )unum;
      }
    } else {
#line 1461
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1464
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 1464
    if (72 == tmp___0) {
      {
#line 1465
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1466
      num = (int64_t )unum;
      }
    } else {
      {
#line 1468
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%ld",
                   & num);
      }
    }
  }
#line 1469
  if (1 == res) {
#line 1469
    tmp___1 = num;
  } else {
#line 1469
    tmp___1 = (int64_t )-1;
  }
#line 1469
  return (tmp___1);
}
}
#line 1472 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int build_mp_settings(char const   *arg , struct sdparm_mode_page_settings *mps ,
                             struct sdparm_opt_coll *opts , int clear , int get ) 
{ 
  int len ;
  int b_sz ;
  int num ;
  int from ;
  int cont ;
  int colon ;
  unsigned int u ;
  int64_t ll ;
  char buff[64] ;
  char acron[64] ;
  char vb[64] ;
  char const   *cp ;
  char const   *ncp ;
  char const   *ecp ;
  struct sdparm_mode_page_it_val *ivp ;
  struct sdparm_mode_page_item  const  *mpi ;
  struct sdparm_mode_page_item  const  *prev_mpi ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int64_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int64_t ll___0 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
#line 1489
  b_sz = (int )(sizeof(buff) - 1UL);
#line 1490
  cp = arg;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if (! (mps->num_it_vals < 128)) {
#line 1491
      goto while_break;
    }
    {
#line 1492
    memset((void *)(buff), 0, sizeof(buff));
#line 1493
    ivp = & mps->it_vals[mps->num_it_vals];
    }
#line 1494
    if (0 == (int )*cp) {
#line 1495
      goto while_break;
    }
    {
#line 1496
    tmp = strchr(cp, ',');
#line 1496
    ncp = (char const   *)tmp;
    }
#line 1497
    if (ncp) {
#line 1498
      len = (int )(ncp - cp);
#line 1499
      if (len <= 0) {
#line 1500
        cp ++;
#line 1501
        goto while_continue;
      }
#line 1503
      if (len < b_sz) {
#line 1503
        tmp___0 = len;
      } else {
#line 1503
        tmp___0 = b_sz;
      }
      {
#line 1503
      strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)cp,
              (size_t )tmp___0);
      }
    } else {
      {
#line 1505
      strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)cp,
              (size_t )b_sz);
      }
    }
    {
#line 1506
    tmp___2 = strchr((char const   *)(buff), ':');
    }
#line 1506
    if (tmp___2) {
#line 1506
      colon = 1;
    } else {
#line 1506
      colon = 0;
    }
    {
#line 1507
    tmp___12 = __ctype_b_loc();
    }
#line 1507
    if ((int const   )*(*tmp___12 + (int )buff[0]) & 1024) {
#line 1507
      if (! colon) {
#line 1507
        goto _L;
      } else {
#line 1507
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1507
      tmp___13 = __ctype_b_loc();
      }
#line 1507
      if ((int const   )*(*tmp___13 + (int )buff[0]) & 2048) {
#line 1507
        if (95 == (int )buff[1]) {
          _L: /* CIL Label */ 
          {
#line 1509
          tmp___3 = strchr((char const   *)(buff), '=');
#line 1509
          ecp = (char const   *)tmp___3;
          }
#line 1510
          if (ecp) {
            {
#line 1511
            strncpy((char */* __restrict  */)(acron), (char const   */* __restrict  */)(buff),
                    (size_t )(ecp - (char const   *)(buff)));
#line 1512
            acron[ecp - (char const   *)(buff)] = (char )'\000';
#line 1513
            strcpy((char */* __restrict  */)(vb), (char const   */* __restrict  */)(ecp + 1));
#line 1514
            tmp___4 = strcmp("-1", (char const   *)(vb));
            }
#line 1514
            if (0 == tmp___4) {
#line 1515
              ivp->val = (int64_t )-1;
            } else {
              {
#line 1517
              ivp->val = get_llnum((char const   *)(vb));
              }
#line 1518
              if (-1L == ivp->val) {
                {
#line 1519
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to decode: %s value\n",
                        buff);
#line 1521
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    expected: <acronym>[=<val>]\n");
                }
#line 1522
                return (-1);
              }
            }
          } else {
            {
#line 1526
            strcpy((char */* __restrict  */)(acron), (char const   */* __restrict  */)(buff));
            }
#line 1527
            if (clear) {
#line 1527
              ivp->val = (int64_t )0;
            } else
#line 1527
            if (get) {
#line 1527
              ivp->val = (int64_t )0;
            } else {
#line 1527
              ivp->val = (int64_t )-1;
            }
          }
          {
#line 1529
          tmp___6 = strchr((char const   *)(acron), '.');
#line 1529
          ecp = (char const   *)tmp___6;
          }
#line 1529
          if (ecp) {
            {
#line 1530
            strcpy((char */* __restrict  */)(vb), (char const   */* __restrict  */)(acron));
#line 1531
            strncpy((char */* __restrict  */)(acron), (char const   */* __restrict  */)(vb),
                    (size_t )(ecp - (char const   *)(acron)));
#line 1532
            acron[ecp - (char const   *)(acron)] = (char )'\000';
#line 1533
            strcpy((char */* __restrict  */)(vb), (char const   */* __restrict  */)(ecp + 1));
#line 1534
            tmp___5 = get_llnum((char const   *)(vb));
#line 1534
            ivp->descriptor_num = (int )tmp___5;
            }
#line 1535
            if (ivp->descriptor_num < 0) {
              {
#line 1536
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to decode: %s descriptor number\n",
                      buff);
#line 1538
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    expected: <acronym_name>[.<desc_num>][=<val>]\n");
              }
#line 1540
              return (-1);
            }
          }
#line 1543
          ivp->orig_val = ivp->val;
#line 1544
          from = 0;
#line 1545
          cont = 0;
#line 1546
          prev_mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
#line 1547
          if (get) {
            {
#line 1548
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 1549
              mpi = sdp_find_mitem_by_acron((char const   *)(acron), & from, opts->transport,
                                            opts->vendor);
              }
#line 1552
              if ((unsigned long )((void *)0) == (unsigned long )mpi) {
#line 1553
                if (cont) {
#line 1554
                  mpi = prev_mpi;
#line 1555
                  goto while_break___0;
                }
#line 1557
                if (opts->vendor < 0) {
#line 1557
                  if (opts->transport < 0) {
                    {
#line 1558
                    from = 0;
#line 1559
                    mpi = sdp_find_mitem_by_acron((char const   *)(acron), & from,
                                                  6, -1);
                    }
#line 1561
                    if ((unsigned long )((void *)0) == (unsigned long )mpi) {
                      {
#line 1562
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t find field acronym: %s\n",
                              acron);
#line 1564
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [perhaps a \'--transport=<tn>\' or \'--vendor=<vn>\' option is needed]\n");
                      }
#line 1567
                      return (-1);
                    } else {
#line 1569
                      opts->transport = 6;
                    }
                  } else {
                    {
#line 1571
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t find field acronym: %s\n",
                            acron);
                    }
#line 1573
                    return (-1);
                  }
                } else {
                  {
#line 1571
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t find field acronym: %s\n",
                          acron);
                  }
#line 1573
                  return (-1);
                }
              }
#line 1576
              if (mps->page_num < 0) {
#line 1577
                mps->page_num = (int )mpi->page_num;
#line 1578
                mps->subpage_num = (int )mpi->subpage_num;
#line 1579
                goto while_break___0;
              }
#line 1581
              cont = 1;
#line 1582
              prev_mpi = mpi;
#line 1548
              if (! (mps->page_num != (int )mpi->page_num)) {
#line 1548
                if (! (mps->subpage_num != (int )mpi->subpage_num)) {
#line 1548
                  goto while_break___0;
                }
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 1588
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 1589
              mpi = sdp_find_mitem_by_acron((char const   *)(acron), & from, opts->transport,
                                            opts->vendor);
              }
#line 1591
              if ((unsigned long )((void *)0) == (unsigned long )mpi) {
#line 1592
                if (cont) {
                  {
#line 1593
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode page of acronym: %s [0x%x,0x%x] doesn\'t match prior\n",
                          acron, prev_mpi->page_num, prev_mpi->subpage_num);
#line 1597
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    mode page: 0x%x,0x%x\n",
                          mps->page_num, mps->subpage_num);
#line 1599
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For \'--set\' and \'--clear\' all fields must be in the same mode page\n");
                  }
#line 1602
                  return (-1);
                }
#line 1604
                if (opts->vendor < 0) {
#line 1604
                  if (opts->transport < 0) {
                    {
#line 1605
                    from = 0;
#line 1606
                    mpi = sdp_find_mitem_by_acron((char const   *)(acron), & from,
                                                  6, -1);
                    }
#line 1608
                    if ((unsigned long )((void *)0) == (unsigned long )mpi) {
                      {
#line 1609
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t find field acronym: %s\n",
                              acron);
#line 1611
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [perhaps a \'--transport=<tn>\' or \'--vendor=<vn>\' option is needed]\n");
                      }
#line 1614
                      return (-1);
                    } else {
#line 1616
                      opts->transport = 6;
                    }
                  } else {
                    {
#line 1618
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t find field acronym: %s\n",
                            acron);
                    }
#line 1620
                    return (-1);
                  }
                } else {
                  {
#line 1618
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t find field acronym: %s\n",
                          acron);
                  }
#line 1620
                  return (-1);
                }
              }
#line 1623
              if (mps->page_num < 0) {
#line 1624
                mps->page_num = (int )mpi->page_num;
#line 1625
                mps->subpage_num = (int )mpi->subpage_num;
#line 1626
                goto while_break___1;
              }
#line 1628
              cont = 1;
#line 1629
              prev_mpi = mpi;
#line 1588
              if (! (mps->page_num != (int )mpi->page_num)) {
#line 1588
                if (! (mps->subpage_num != (int )mpi->subpage_num)) {
#line 1588
                  goto while_break___1;
                }
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 1635
          if (mpi->num_bits < 64) {
#line 1636
            ll = (int64_t )1;
#line 1637
            ivp->val &= (ll << mpi->num_bits) - 1L;
          }
#line 1639
          ivp->mpi = (struct sdparm_mode_page_item )*mpi;
        } else {
#line 1507
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1642
        tmp___9 = strncmp("0x", (char const   *)(buff), (size_t )2);
        }
#line 1642
        if (0 == tmp___9) {
          {
#line 1644
          num = sscanf((char const   */* __restrict  */)(buff + 2), (char const   */* __restrict  */)"%x:%d:%d=%s",
                       & u, & ivp->mpi.start_bit, & ivp->mpi.num_bits, vb);
#line 1646
          ivp->mpi.start_byte = (int )u;
          }
        } else {
          {
#line 1642
          tmp___10 = strncmp("0X", (char const   *)(buff), (size_t )2);
          }
#line 1642
          if (0 == tmp___10) {
            {
#line 1644
            num = sscanf((char const   */* __restrict  */)(buff + 2), (char const   */* __restrict  */)"%x:%d:%d=%s",
                         & u, & ivp->mpi.start_bit, & ivp->mpi.num_bits, vb);
#line 1646
            ivp->mpi.start_byte = (int )u;
            }
          } else {
            {
#line 1648
            tmp___8 = strstr((char const   *)(buff), "h:");
            }
#line 1648
            if (tmp___8) {
              {
#line 1649
              num = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%xh:%d:%d=%s",
                           & u, & ivp->mpi.start_bit, & ivp->mpi.num_bits, vb);
#line 1651
              ivp->mpi.start_byte = (int )u;
              }
            } else {
              {
#line 1652
              tmp___7 = strstr((char const   *)(buff), "H:");
              }
#line 1652
              if (tmp___7) {
                {
#line 1653
                num = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%xH:%d:%d=%s",
                             & u, & ivp->mpi.start_bit, & ivp->mpi.num_bits, vb);
#line 1655
                ivp->mpi.start_byte = (int )u;
                }
              } else {
                {
#line 1657
                num = sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%d:%d:%d=%s",
                             & ivp->mpi.start_byte, & ivp->mpi.start_bit, & ivp->mpi.num_bits,
                             vb);
                }
              }
            }
          }
        }
#line 1660
        if (num < 3) {
          {
#line 1661
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to decode: %s\n",
                  buff);
#line 1662
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    expected: start_byte:start_bit:num_bits[=<val>]\n");
          }
#line 1664
          return (-1);
        }
#line 1666
        if (3 == num) {
#line 1667
          if (clear) {
#line 1667
            ivp->val = (int64_t )0;
          } else
#line 1667
          if (get) {
#line 1667
            ivp->val = (int64_t )0;
          } else {
#line 1667
            ivp->val = (int64_t )-1;
          }
        } else {
          {
#line 1669
          tmp___11 = strcmp("-1", (char const   *)(vb));
          }
#line 1669
          if (0 == tmp___11) {
#line 1670
            ivp->val = (int64_t )-1;
          } else {
            {
#line 1672
            ivp->val = get_llnum((char const   *)(vb));
            }
#line 1673
            if (-1L == ivp->val) {
              {
#line 1674
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to decode start_byte:start_bit:num_bits value\n");
              }
#line 1676
              return (-1);
            }
          }
        }
#line 1680
        ivp->mpi.pdt = -1;
#line 1681
        if (ivp->mpi.start_byte < 0) {
          {
#line 1682
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need positive start byte offset\n");
          }
#line 1683
          return (-1);
        }
#line 1685
        if (ivp->mpi.start_bit < 0) {
          {
#line 1686
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need start bit in 0..7 range (inclusive)\n");
          }
#line 1688
          return (-1);
        } else
#line 1685
        if (ivp->mpi.start_bit > 7) {
          {
#line 1686
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need start bit in 0..7 range (inclusive)\n");
          }
#line 1688
          return (-1);
        }
#line 1690
        if (ivp->mpi.num_bits < 1) {
          {
#line 1691
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need number of bits in 1..64 range (inclusive)\n");
          }
#line 1693
          return (-1);
        } else
#line 1690
        if (ivp->mpi.num_bits > 64) {
          {
#line 1691
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need number of bits in 1..64 range (inclusive)\n");
          }
#line 1693
          return (-1);
        }
#line 1695
        if (mps->page_num < 0) {
          {
#line 1696
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need \'--page=\' option for mode page name or number\n");
          }
#line 1698
          return (-1);
        } else
#line 1699
        if (get) {
#line 1700
          ivp->mpi.page_num = mps->page_num;
#line 1701
          ivp->mpi.subpage_num = mps->subpage_num;
        }
#line 1703
        ivp->orig_val = ivp->val;
#line 1704
        if (ivp->mpi.num_bits < 64) {
#line 1705
          ll___0 = (int64_t )1;
#line 1707
          ivp->val &= (ll___0 << ivp->mpi.num_bits) - 1L;
        }
      }
    }
#line 1710
    (mps->num_it_vals) ++;
#line 1711
    if (ncp) {
#line 1712
      cp = ncp + 1;
    } else {
#line 1714
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1716
  return (0);
}
}
#line 1719 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int open_and_simple_inquiry(char const   *device_name , int rw , int *pdt ,
                                   int *protect , struct sdparm_opt_coll  const  *opts ) 
{ 
  int res ;
  int verb ;
  int sg_fd ;
  int l_pdt ;
  struct sg_simple_inquiry_resp sir ;
  char b[32] ;
  char *tmp ;
  char const   *tmp___0 ;
  int sg_sg_fd ;
  char *tmp___1 ;

  {
#line 1727
  if (opts->verbose > 0) {
#line 1727
    verb = (int )(opts->verbose - 1);
  } else {
#line 1727
    verb = 0;
  }
  {
#line 1728
  sg_fd = sg_cmds_open_device(device_name, ! rw, verb);
  }
#line 1729
  if (sg_fd < 0) {
    {
#line 1730
    tmp = safe_strerror(- sg_fd);
    }
#line 1730
    if (rw) {
#line 1730
      tmp___0 = "read/write";
    } else {
#line 1730
      tmp___0 = "read only";
    }
    {
#line 1730
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"open error: %s [%s]: %s\n",
            device_name, tmp___0, tmp);
    }
#line 1732
    return (-1);
  }
  {
#line 1734
  res = sg_simple_inquiry(sg_fd, & sir, 0, verb);
  }
#line 1735
  if (res) {
#line 1737
    if (-1 == res) {
      {
#line 1740
      sg_sg_fd = map_if_lk24(sg_fd, device_name, rw, (int )opts->verbose);
      }
#line 1741
      if (sg_sg_fd < 0) {
#line 1742
        goto err_out;
      }
      {
#line 1743
      sg_cmds_close_device(sg_fd);
#line 1744
      sg_fd = sg_sg_fd;
#line 1745
      res = sg_simple_inquiry(sg_fd, & sir, 0, verb);
      }
#line 1746
      if (sg_sg_fd < 0) {
#line 1747
        goto err_out;
      }
    }
#line 1750
    if (res) {
      {
#line 1751
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SCSI INQUIRY command failed on %s\n",
              device_name);
      }
#line 1753
      goto err_out;
    }
  }
#line 1756
  l_pdt = (int )sir.peripheral_type;
#line 1757
  if (4 == l_pdt) {
#line 1758
    *pdt = 0;
  } else
#line 1757
  if (7 == l_pdt) {
#line 1758
    *pdt = 0;
  } else {
#line 1760
    *pdt = l_pdt;
  }
#line 1761
  if (protect) {
#line 1762
    *protect = (int )sir.byte_5 & 1;
  }
#line 1763
  if (0 == (int )opts->hex) {
#line 1763
    if (0 == (int )opts->quiet) {
      {
#line 1764
      printf((char const   */* __restrict  */)"    %s: %.8s  %.16s  %.4s", device_name,
             sir.vendor, sir.product, sir.revision);
      }
#line 1766
      if (0 != l_pdt) {
        {
#line 1767
        tmp___1 = sg_get_pdt_str(l_pdt, (int )sizeof(b), b);
#line 1767
        printf((char const   */* __restrict  */)"  [%s]", tmp___1);
        }
      }
      {
#line 1768
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 1770
  return (sg_fd);
  err_out: 
  {
#line 1773
  sg_cmds_close_device(sg_fd);
  }
#line 1774
  return (-1);
}
}
#line 1778 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int process_mode(int sg_fd , struct sdparm_mode_page_settings  const  *mps ,
                        int pn , int spn , int rw , int get , struct sdparm_opt_coll  const  *opts ,
                        int pdt ) 
{ 
  int res ;
  struct sdparm_mode_page_t  const  *mpp ;

  {
#line 1786
  if (pn > 62) {
#line 1786
    goto _L;
  } else
#line 1786
  if (spn > 254) {
    _L: /* CIL Label */ 
#line 1787
    if (63 == pn) {
      {
#line 1788
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Does not support requesting all mode pages or subpages this way.\n  Try \'--all\' option.\n");
      }
    } else
#line 1787
    if (255 == spn) {
      {
#line 1788
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Does not support requesting all mode pages or subpages this way.\n  Try \'--all\' option.\n");
      }
    } else {
      {
#line 1791
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepts mode page numbers from 0 to 62 .\n  Accepts mode subpage numbers from 0 to 254 .\n  For VPD pages add a \'--inquiry\' option.\n");
      }
    }
#line 1794
    return (1);
  }
#line 1796
  if (pn > 0) {
#line 1796
    if (pdt >= 0) {
      {
#line 1797
      mpp = sdp_get_mode_detail(pn, spn, pdt, (int )opts->transport, (int )opts->vendor);
      }
#line 1799
      if ((unsigned long )((void *)0) == (unsigned long )mpp) {
        {
#line 1800
        mpp = sdp_get_mode_detail(pn, spn, -1, (int )opts->transport, (int )opts->vendor);
        }
      }
#line 1802
      if (mpp) {
#line 1802
        if (mpp->name) {
#line 1802
          if (mpp->pdt >= 0) {
#line 1802
            if (pdt != (int )mpp->pdt) {
              {
#line 1803
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> Warning: %s mode page associated with\n",
                      mpp->name);
#line 1805
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   peripheral device type 0x%x but device pdt is 0x%x\n",
                      mpp->pdt, pdt);
              }
#line 1807
              if (! opts->flexible) {
                {
#line 1808
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   may need \'--flexible\' option to override\n");
                }
              }
            }
          }
        }
      }
    }
  }
#line 1812
  if (opts->defaults) {
    {
#line 1813
    res = set_mp_defaults(sg_fd, pn, spn, pdt, opts);
    }
  } else
#line 1814
  if (rw) {
#line 1815
    if (mps->num_it_vals < 1) {
      {
#line 1816
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no fields found to set or clear\n");
      }
#line 1817
      return (99);
    }
    {
#line 1819
    res = change_mode_page(sg_fd, pdt, mps, opts);
    }
#line 1820
    if (res) {
#line 1821
      return (res);
    }
  } else
#line 1822
  if (get) {
#line 1823
    if (mps->num_it_vals < 1) {
      {
#line 1824
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no fields found to get\n");
      }
#line 1825
      return (99);
    }
    {
#line 1827
    res = print_mode_items(sg_fd, mps, pdt, opts);
    }
  } else {
    {
#line 1829
    res = print_mode_pages(sg_fd, pn, spn, pdt, opts);
    }
  }
#line 1830
  return (res);
}
}
#line 1834 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
int main(int argc , char **argv ) 
{ 
  int sg_fd ;
  int res ;
  int c ;
  int pdt ;
  int req_pdt ;
  int k ;
  int orig_transport ;
  int r ;
  struct sdparm_opt_coll opts ;
  char const   *clear_str ;
  char const   *cmd_str ;
  char const   *get_str ;
  char const   *set_str ;
  char const   *page_str ;
  char const   *device_name_arr[256] ;
  int num_devices ;
  int pn ;
  int spn ;
  int rw ;
  int protect ;
  int cmd_arg ;
  struct sdparm_mode_page_t  const  *mpp ;
  struct sdparm_transport_id_t  const  *tip ;
  struct sdparm_vpd_page_t  const  *vpp ;
  struct sdparm_vendor_name_t  const  *vnp ;
  struct sdparm_mode_page_settings mp_settings ;
  char *cp ;
  char const   *ccp ;
  struct sdparm_command_t  const  *scmdp ;
  int ret ;
  int option_index ;
  struct sdparm_vendor_pair  const  *vpp___0 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct sdparm_opt_coll t_opts ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1839
  clear_str = (char const   *)((void *)0);
#line 1840
  cmd_str = (char const   *)((void *)0);
#line 1841
  get_str = (char const   *)((void *)0);
#line 1842
  set_str = (char const   *)((void *)0);
#line 1843
  page_str = (char const   *)((void *)0);
#line 1845
  num_devices = 0;
#line 1846
  pn = -1;
#line 1847
  spn = -1;
#line 1848
  rw = 0;
#line 1849
  protect = 0;
#line 1850
  cmd_arg = -1;
#line 1851
  mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
#line 1853
  vpp = (struct sdparm_vpd_page_t  const  *)((void *)0);
#line 1858
  scmdp = (struct sdparm_command_t  const  *)((void *)0);
#line 1859
  ret = 0;
#line 1864
  memset((void *)(& opts), 0, sizeof(opts));
#line 1865
  opts.transport = -1;
#line 1866
  opts.vendor = -1;
#line 1867
  memset((void *)(device_name_arr), 0, sizeof(device_name_arr));
#line 1868
  memset((void *)(& mp_settings), 0, sizeof(mp_settings));
#line 1869
  pdt = -1;
  }
  {
#line 1870
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1871
    option_index = 0;
#line 1877
    c = getopt_long(argc, (char * const  *)argv, "6aBc:C:dDefg:hHilM:np:qrs:St:vV",
                    (struct option  const  *)(long_options), & option_index);
    }
#line 1880
    if (c == -1) {
#line 1881
      goto while_break;
    }
    {
#line 1884
    if (c == 54) {
#line 1884
      goto case_54;
    }
#line 1887
    if (c == 97) {
#line 1887
      goto case_97;
    }
#line 1890
    if (c == 66) {
#line 1890
      goto case_66;
    }
#line 1893
    if (c == 99) {
#line 1893
      goto case_99;
    }
#line 1897
    if (c == 67) {
#line 1897
      goto case_67;
    }
#line 1899
    if (c == 100) {
#line 1899
      goto case_100;
    }
#line 1902
    if (c == 68) {
#line 1902
      goto case_68;
    }
#line 1906
    if (c == 101) {
#line 1906
      goto case_101;
    }
#line 1909
    if (c == 102) {
#line 1909
      goto case_102;
    }
#line 1912
    if (c == 103) {
#line 1912
      goto case_103;
    }
#line 1916
    if (c == 63) {
#line 1916
      goto case_63;
    }
#line 1916
    if (c == 104) {
#line 1916
      goto case_63;
    }
#line 1919
    if (c == 72) {
#line 1919
      goto case_72;
    }
#line 1922
    if (c == 105) {
#line 1922
      goto case_105;
    }
#line 1925
    if (c == 108) {
#line 1925
      goto case_108;
    }
#line 1928
    if (c == 77) {
#line 1928
      goto case_77;
    }
#line 1954
    if (c == 110) {
#line 1954
      goto case_110;
    }
#line 1957
    if (c == 113) {
#line 1957
      goto case_113;
    }
#line 1960
    if (c == 112) {
#line 1960
      goto case_112;
    }
#line 1968
    if (c == 114) {
#line 1968
      goto case_114;
    }
#line 1971
    if (c == 115) {
#line 1971
      goto case_115;
    }
#line 1975
    if (c == 83) {
#line 1975
      goto case_83;
    }
#line 1978
    if (c == 116) {
#line 1978
      goto case_116;
    }
#line 2001
    if (c == 118) {
#line 2001
      goto case_118;
    }
#line 2004
    if (c == 86) {
#line 2004
      goto case_86;
    }
#line 2012
    goto switch_default;
    case_54: /* CIL Label */ 
#line 1885
    (opts.mode_6) ++;
#line 1886
    goto switch_break;
    case_97: /* CIL Label */ 
#line 1888
    (opts.all) ++;
#line 1889
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1891
    (opts.dbd) ++;
#line 1892
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1894
    clear_str = (char const   *)optarg;
#line 1895
    rw = 1;
#line 1896
    goto switch_break;
    case_67: /* CIL Label */ 
#line 1898
    cmd_str = (char const   *)optarg;
    case_100: /* CIL Label */ 
#line 1900
    (opts.dummy) ++;
#line 1901
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1903
    (opts.defaults) ++;
#line 1904
    rw = 1;
#line 1905
    goto switch_break;
    case_101: /* CIL Label */ 
#line 1907
    (opts.enumerate) ++;
#line 1908
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1910
    (opts.flexible) ++;
#line 1911
    goto switch_break;
    case_103: /* CIL Label */ 
#line 1913
    get_str = (char const   *)optarg;
#line 1914
    goto switch_break;
    case_63: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 1917
    usage();
    }
#line 1918
    return (0);
    case_72: /* CIL Label */ 
#line 1920
    (opts.hex) ++;
#line 1921
    goto switch_break;
    case_105: /* CIL Label */ 
#line 1923
    (opts.inquiry) ++;
#line 1924
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1926
    (opts.long_out) ++;
#line 1927
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 1929
    tmp = __ctype_b_loc();
    }
#line 1929
    if ((int const   )*(*tmp + (int )*(optarg + 0)) & 1024) {
      {
#line 1930
      vnp = sdp_find_vendor_by_acron((char const   *)optarg);
      }
#line 1931
      if ((unsigned long )((void *)0) == (unsigned long )vnp) {
        {
#line 1932
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"abbreviation does not match a vendor\n");
#line 1934
        printf((char const   */* __restrict  */)"Available vendors:\n");
#line 1935
        enumerate_vendors();
        }
#line 1936
        return (1);
      } else {
#line 1938
        opts.vendor = (int )vnp->vendor_num;
      }
    } else {
      {
#line 1942
      res = sg_get_num_nomult((char const   *)optarg);
#line 1943
      vpp___0 = sdp_get_vendor_pair(res);
      }
#line 1944
      if ((unsigned long )((void *)0) == (unsigned long )vpp___0) {
        {
#line 1945
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad vendor value after \'-M\'  (or \'--vendor=\') option\n");
#line 1947
        printf((char const   */* __restrict  */)"Available vendors:\n");
#line 1948
        enumerate_vendors();
        }
#line 1949
        return (1);
      }
#line 1951
      opts.vendor = res;
    }
#line 1953
    goto switch_break;
    case_110: /* CIL Label */ 
#line 1955
    (opts.num_desc) ++;
#line 1956
    goto switch_break;
    case_113: /* CIL Label */ 
#line 1958
    (opts.quiet) ++;
#line 1959
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1961
    if (page_str) {
      {
#line 1962
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"only one \'--page=\' option permitted\n");
#line 1963
      usage();
      }
#line 1964
      return (1);
    } else {
#line 1966
      page_str = (char const   *)optarg;
    }
#line 1967
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1969
    (opts.read_only) ++;
#line 1970
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1972
    set_str = (char const   *)optarg;
#line 1973
    rw = 1;
#line 1974
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1976
    (opts.save) ++;
#line 1977
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1979
    tmp___0 = __ctype_b_loc();
    }
#line 1979
    if ((int const   )*(*tmp___0 + (int )*(optarg + 0)) & 1024) {
      {
#line 1980
      tip = sdp_find_transport_by_acron((char const   *)optarg);
      }
#line 1981
      if ((unsigned long )((void *)0) == (unsigned long )tip) {
        {
#line 1982
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"abbreviation does not match a transport protocol\n");
#line 1984
        printf((char const   */* __restrict  */)"Available transport protocols:\n");
#line 1985
        enumerate_transports();
        }
#line 1986
        return (1);
      } else {
#line 1988
        opts.transport = (int )tip->proto_num;
      }
    } else {
      {
#line 1990
      res = sg_get_num_nomult((char const   *)optarg);
      }
#line 1991
      if (res < 0) {
        {
#line 1992
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad transport value after \'-t\' option\n");
#line 1994
        printf((char const   */* __restrict  */)"Available transport protocols:\n");
#line 1995
        enumerate_transports();
        }
#line 1996
        return (1);
      } else
#line 1991
      if (res > 15) {
        {
#line 1992
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad transport value after \'-t\' option\n");
#line 1994
        printf((char const   */* __restrict  */)"Available transport protocols:\n");
#line 1995
        enumerate_transports();
        }
#line 1996
        return (1);
      }
#line 1998
      opts.transport = res;
    }
#line 2000
    goto switch_break;
    case_118: /* CIL Label */ 
#line 2002
    (opts.verbose) ++;
#line 2003
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 2005
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"version: %s\n",
            version_str);
    }
#line 2006
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 2013
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognised option code 0x%x ??\n",
            c);
#line 2014
    usage();
    }
#line 2015
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2018
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2018
    if (! (optind < argc)) {
#line 2018
      goto while_break___0;
    }
#line 2019
    if (num_devices < 256) {
#line 2020
      tmp___1 = num_devices;
#line 2020
      num_devices ++;
#line 2020
      device_name_arr[tmp___1] = (char const   *)*(argv + optind);
#line 2021
      optind ++;
    } else {
      {
#line 2023
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2023
        if (! (optind < argc)) {
#line 2023
          goto while_break___1;
        }
        {
#line 2024
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected extra argument: %s\n",
                *(argv + optind));
#line 2023
        optind ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2026
      usage();
      }
#line 2027
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2031
  if (opts.read_only) {
#line 2032
    rw = 0;
  }
#line 2034
  if ((! (! get_str) + ! (! set_str)) + ! (! clear_str) > 1) {
    {
#line 2035
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can only give one of \'--get=\', \'--set=\' and \'--clear=\'\n");
    }
#line 2037
    return (1);
  }
#line 2044
  if (page_str) {
    {
#line 2045
    tmp___3 = strcmp("-1", page_str);
    }
#line 2045
    if (0 == tmp___3) {
#line 2046
      opts.inquiry = 1;
#line 2047
      pn = -2;
    } else {
      {
#line 2045
      tmp___4 = strcmp("-2", page_str);
      }
#line 2045
      if (0 == tmp___4) {
#line 2046
        opts.inquiry = 1;
#line 2047
        pn = -2;
      } else {
        {
#line 2048
        tmp___2 = __ctype_b_loc();
        }
#line 2048
        if ((int const   )*(*tmp___2 + (int )*(page_str + 0)) & 1024) {
          {
#line 2049
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 2050
            mpp = sdp_find_mp_by_acron(page_str, opts.transport, opts.vendor);
            }
#line 2052
            if (mpp) {
#line 2053
              goto while_break___2;
            }
            {
#line 2054
            vpp = sdp_find_vpd_by_acron(page_str);
            }
#line 2055
            if (vpp) {
#line 2056
              goto while_break___2;
            }
#line 2057
            orig_transport = opts.transport;
#line 2058
            if (opts.vendor < 0) {
#line 2058
              if (opts.transport < 0) {
                {
#line 2059
                opts.transport = 6;
#line 2060
                mpp = sdp_find_mp_by_acron(page_str, opts.transport, opts.vendor);
                }
#line 2062
                if (mpp) {
#line 2063
                  goto while_break___2;
                }
              }
            }
#line 2065
            if (opts.vendor < 0) {
#line 2065
              if (orig_transport < 0) {
                {
#line 2066
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"abbreviation matches neither a mode page nor a VPD page\n    [perhaps a \'--transport=<tn>\' or \'--vendor=<vn>\' option is needed]\n");
                }
              } else {
                {
#line 2071
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"abbreviation matches neither a mode page nor a VPD page\n");
                }
              }
            } else {
              {
#line 2071
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"abbreviation matches neither a mode page nor a VPD page\n");
              }
            }
#line 2073
            if (opts.inquiry) {
              {
#line 2074
              printf((char const   */* __restrict  */)"available VPD pages:\n");
#line 2075
              enumerate_vpds();
              }
#line 2076
              return (1);
            } else {
              {
#line 2078
              printf((char const   */* __restrict  */)"available mode pages");
              }
#line 2079
              if (opts.vendor >= 0) {
                {
#line 2080
                printf((char const   */* __restrict  */)" (for given vendor):\n");
                }
              } else
#line 2081
              if (orig_transport >= 0) {
                {
#line 2082
                printf((char const   */* __restrict  */)" (for given transport):\n");
                }
              } else {
                {
#line 2084
                printf((char const   */* __restrict  */)":\n");
                }
              }
              {
#line 2085
              enumerate_mpages(orig_transport, opts.vendor);
              }
#line 2086
              return (1);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2089
          if (vpp) {
#line 2090
            pn = (int )vpp->vpd_num;
#line 2091
            spn = (int )vpp->subvalue;
#line 2092
            opts.inquiry = 1;
#line 2093
            pdt = (int )vpp->pdt;
          } else {
#line 2095
            if (opts.inquiry) {
              {
#line 2096
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"matched mode page acronym but given \'-i\' so expecting a VPD page\n");
              }
#line 2098
              return (1);
            }
#line 2100
            pn = (int )mpp->page;
#line 2101
            spn = (int )mpp->subpage;
#line 2102
            pdt = (int )mpp->pdt;
          }
        } else {
          {
#line 2105
          cp = strchr(page_str, ',');
#line 2106
          pn = sg_get_num_nomult(page_str);
          }
#line 2107
          if (pn < 0) {
#line 2107
            goto _L;
          } else
#line 2107
          if (pn > 255) {
            _L: /* CIL Label */ 
            {
#line 2108
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad page code value after \'-p\' option\n");
            }
#line 2110
            if (opts.inquiry) {
              {
#line 2111
              printf((char const   */* __restrict  */)"available VPD pages:\n");
#line 2112
              enumerate_vpds();
              }
#line 2113
              return (1);
            } else {
              {
#line 2115
              printf((char const   */* __restrict  */)"available mode pages");
              }
#line 2116
              if (opts.vendor >= 0) {
                {
#line 2117
                printf((char const   */* __restrict  */)" (for given vendor):\n");
                }
              } else
#line 2118
              if (opts.transport >= 0) {
                {
#line 2119
                printf((char const   */* __restrict  */)" (for given transport):\n");
                }
              } else {
                {
#line 2121
                printf((char const   */* __restrict  */)":\n");
                }
              }
              {
#line 2122
              enumerate_mpages(opts.transport, opts.vendor);
              }
#line 2123
              return (1);
            }
          }
#line 2126
          if (cp) {
            {
#line 2127
            spn = sg_get_num_nomult((char const   *)(cp + 1));
            }
#line 2128
            if (spn < 0) {
              {
#line 2129
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad second value after \'-p\' option\n");
              }
#line 2131
              return (1);
            } else
#line 2128
            if (spn > 255) {
              {
#line 2129
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad second value after \'-p\' option\n");
              }
#line 2131
              return (1);
            }
          } else {
#line 2134
            spn = 0;
          }
        }
      }
    }
  }
#line 2138
  if (opts.inquiry) {
#line 2139
    if (set_str) {
      {
#line 2141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--inquiry\' option lists VPD pages so other options that are\nconcerned with mode pages are inappropriate\n");
      }
#line 2144
      return (1);
    } else
#line 2139
    if (clear_str) {
      {
#line 2141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--inquiry\' option lists VPD pages so other options that are\nconcerned with mode pages are inappropriate\n");
      }
#line 2144
      return (1);
    } else
#line 2139
    if (get_str) {
      {
#line 2141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--inquiry\' option lists VPD pages so other options that are\nconcerned with mode pages are inappropriate\n");
      }
#line 2144
      return (1);
    } else
#line 2139
    if (cmd_str) {
      {
#line 2141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--inquiry\' option lists VPD pages so other options that are\nconcerned with mode pages are inappropriate\n");
      }
#line 2144
      return (1);
    } else
#line 2139
    if (opts.defaults) {
      {
#line 2141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--inquiry\' option lists VPD pages so other options that are\nconcerned with mode pages are inappropriate\n");
      }
#line 2144
      return (1);
    } else
#line 2139
    if (opts.save) {
      {
#line 2141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--inquiry\' option lists VPD pages so other options that are\nconcerned with mode pages are inappropriate\n");
      }
#line 2144
      return (1);
    }
#line 2146
    if (pn > 255) {
      {
#line 2147
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"VPD page numbers are from 0 to 255\n");
      }
#line 2148
      return (1);
    }
#line 2150
    if (opts.enumerate) {
      {
#line 2151
      printf((char const   */* __restrict  */)"VPD pages:\n");
#line 2152
      enumerate_vpds();
      }
#line 2153
      return (0);
    }
  } else
#line 2155
  if (cmd_str) {
#line 2156
    if (set_str) {
      {
#line 2157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--command=\' option is not valid with other options that are\nconcerned with mode pages\n");
      }
#line 2159
      return (1);
    } else
#line 2156
    if (clear_str) {
      {
#line 2157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--command=\' option is not valid with other options that are\nconcerned with mode pages\n");
      }
#line 2159
      return (1);
    } else
#line 2156
    if (get_str) {
      {
#line 2157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--command=\' option is not valid with other options that are\nconcerned with mode pages\n");
      }
#line 2159
      return (1);
    } else
#line 2156
    if (opts.defaults) {
      {
#line 2157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--command=\' option is not valid with other options that are\nconcerned with mode pages\n");
      }
#line 2159
      return (1);
    } else
#line 2156
    if (opts.save) {
      {
#line 2157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--command=\' option is not valid with other options that are\nconcerned with mode pages\n");
      }
#line 2159
      return (1);
    }
#line 2161
    if (opts.enumerate) {
      {
#line 2162
      printf((char const   */* __restrict  */)"Available commands:\n");
#line 2163
      sdp_enumerate_commands();
      }
#line 2164
      return (0);
    }
    {
#line 2166
    scmdp = sdp_build_cmd(cmd_str, & rw, & cmd_arg);
    }
#line 2167
    if ((unsigned long )((void *)0) == (unsigned long )scmdp) {
      {
#line 2168
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--command=%s\' not found\n",
              cmd_str);
#line 2169
      printf((char const   */* __restrict  */)"available commands\n");
#line 2170
      sdp_enumerate_commands();
      }
#line 2171
      return (1);
    }
#line 2173
    if (opts.read_only) {
#line 2174
      rw = 0;
    }
  } else {
#line 2177
    if (pn < 0) {
#line 2178
      mp_settings.page_num = -1;
#line 2179
      mp_settings.subpage_num = -1;
    } else {
#line 2181
      mp_settings.page_num = pn;
#line 2182
      mp_settings.subpage_num = spn;
    }
#line 2184
    if (get_str) {
#line 2185
      if (set_str) {
        {
#line 2186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--get=\' can\'t be used with \'--set=\' or \'--clear=\'\n");
        }
#line 2188
        return (1);
      } else
#line 2185
      if (clear_str) {
        {
#line 2186
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--get=\' can\'t be used with \'--set=\' or \'--clear=\'\n");
        }
#line 2188
        return (1);
      }
      {
#line 2190
      tmp___5 = build_mp_settings(get_str, & mp_settings, & opts, 0, 1);
      }
#line 2190
      if (tmp___5) {
#line 2191
        return (1);
      }
    }
#line 2193
    if (1 == opts.enumerate) {
#line 2194
      if (num_devices > 0) {
        {
#line 2197
        printf((char const   */* __restrict  */)"<scsi_device> as well as most options are ignored when \'--enumerate\' is given\n");
        }
      } else
#line 2194
      if (set_str) {
        {
#line 2197
        printf((char const   */* __restrict  */)"<scsi_device> as well as most options are ignored when \'--enumerate\' is given\n");
        }
      } else
#line 2194
      if (clear_str) {
        {
#line 2197
        printf((char const   */* __restrict  */)"<scsi_device> as well as most options are ignored when \'--enumerate\' is given\n");
        }
      } else
#line 2194
      if (get_str) {
        {
#line 2197
        printf((char const   */* __restrict  */)"<scsi_device> as well as most options are ignored when \'--enumerate\' is given\n");
        }
      } else
#line 2194
      if (opts.save) {
        {
#line 2197
        printf((char const   */* __restrict  */)"<scsi_device> as well as most options are ignored when \'--enumerate\' is given\n");
        }
      }
#line 2199
      if (pn < 0) {
#line 2200
        if (opts.vendor >= 0) {
          {
#line 2201
          ccp = sdp_get_vendor_name(opts.vendor);
          }
#line 2202
          if (ccp) {
            {
#line 2203
            printf((char const   */* __restrict  */)"Mode pages for %s vendor:\n",
                   ccp);
            }
          } else {
            {
#line 2205
            printf((char const   */* __restrict  */)"Mode pages for vendor 0x%x:\n",
                   opts.vendor);
            }
          }
#line 2206
          if (opts.all) {
            {
#line 2207
            enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& opts));
            }
          } else {
            {
#line 2209
            enumerate_mpages(opts.transport, opts.vendor);
            }
          }
        } else
#line 2211
        if (opts.transport >= 0) {
          {
#line 2212
          ccp = sdp_get_transport_name(opts.transport);
          }
#line 2213
          if (ccp) {
            {
#line 2214
            printf((char const   */* __restrict  */)"Mode pages for %s transport protocol:\n",
                   ccp);
            }
          } else {
            {
#line 2217
            printf((char const   */* __restrict  */)"Mode pages for transport protocol 0x%x:\n",
                   opts.transport);
            }
          }
#line 2219
          if (opts.all) {
            {
#line 2220
            enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& opts));
            }
          } else {
            {
#line 2222
            enumerate_mpages(opts.transport, opts.vendor);
            }
          }
        } else
#line 2225
        if (opts.long_out) {
          {
#line 2226
          printf((char const   */* __restrict  */)"Mode pages (not related to any transport protocol or vendor):\n");
#line 2228
          enumerate_mpages(-1, -1);
#line 2229
          printf((char const   */* __restrict  */)"\n");
#line 2230
          printf((char const   */* __restrict  */)"Transport protocols:\n");
#line 2231
          enumerate_transports();
#line 2232
          printf((char const   */* __restrict  */)"\n");
#line 2233
          printf((char const   */* __restrict  */)"Vendors:\n");
#line 2234
          enumerate_vendors();
          }
#line 2235
          if (opts.all) {
            {
#line 2238
            printf((char const   */* __restrict  */)"\n");
#line 2239
            t_opts = opts;
#line 2240
            enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& opts));
#line 2241
            k = 0;
            }
            {
#line 2241
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2241
              if (! (k < 16)) {
#line 2241
                goto while_break___3;
              }
              {
#line 2242
              ccp = sdp_get_transport_name(k);
              }
#line 2243
              if ((unsigned long )((void *)0) == (unsigned long )ccp) {
#line 2244
                goto __Cont;
              }
              {
#line 2245
              printf((char const   */* __restrict  */)"\n");
#line 2246
              printf((char const   */* __restrict  */)"Mode pages for %s transport protocol:\n",
                     ccp);
#line 2248
              t_opts.transport = k;
#line 2249
              t_opts.vendor = -1;
#line 2250
              enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& t_opts));
              }
              __Cont: /* CIL Label */ 
#line 2241
              k ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 2252
            k = 0;
            {
#line 2252
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2252
              if (! (k < sdparm_vendor_mp_len)) {
#line 2252
                goto while_break___4;
              }
              {
#line 2253
              ccp = sdp_get_vendor_name(k);
              }
#line 2254
              if ((unsigned long )((void *)0) == (unsigned long )ccp) {
#line 2255
                goto while_break___4;
              }
              {
#line 2256
              printf((char const   */* __restrict  */)"\n");
#line 2257
              printf((char const   */* __restrict  */)"Mode pages for %s vendor:\n",
                     ccp);
#line 2258
              t_opts.transport = -1;
#line 2259
              t_opts.vendor = k;
#line 2260
              enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& t_opts));
#line 2252
              k ++;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
#line 2263
            k = 0;
            {
#line 2263
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2263
              if (! (k < 16)) {
#line 2263
                goto while_break___5;
              }
              {
#line 2264
              ccp = sdp_get_transport_name(k);
              }
#line 2265
              if ((unsigned long )((void *)0) == (unsigned long )ccp) {
#line 2266
                goto __Cont___0;
              }
              {
#line 2267
              printf((char const   */* __restrict  */)"\n");
#line 2268
              printf((char const   */* __restrict  */)"Mode pages for %s transport protocol:\n",
                     ccp);
#line 2270
              enumerate_mpages(k, -1);
              }
              __Cont___0: /* CIL Label */ 
#line 2263
              k ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2272
            k = 0;
            {
#line 2272
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2272
              if (! (k < sdparm_vendor_mp_len)) {
#line 2272
                goto while_break___6;
              }
              {
#line 2273
              ccp = sdp_get_vendor_name(k);
              }
#line 2274
              if ((unsigned long )((void *)0) == (unsigned long )ccp) {
#line 2275
                goto while_break___6;
              }
              {
#line 2276
              printf((char const   */* __restrict  */)"\n");
#line 2277
              printf((char const   */* __restrict  */)"Mode pages for %s vendor:\n",
                     ccp);
#line 2278
              enumerate_mpages(-1, k);
#line 2272
              k ++;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          {
#line 2281
          printf((char const   */* __restrict  */)"\n");
#line 2282
          printf((char const   */* __restrict  */)"Commands:\n");
#line 2283
          sdp_enumerate_commands();
          }
        } else {
          {
#line 2285
          printf((char const   */* __restrict  */)"Mode pages:\n");
#line 2286
          enumerate_mpages(-1, -1);
          }
#line 2287
          if (opts.all) {
            {
#line 2288
            enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& opts));
            }
          }
        }
      } else {
        {
#line 2292
        enumerate_mitems(pn, spn, pdt, (struct sdparm_opt_coll  const  *)(& opts));
        }
      }
#line 2293
      return (0);
    } else
#line 2294
    if (opts.enumerate) {
      {
#line 2295
      printf((char const   */* __restrict  */)"Available commands:\n");
#line 2296
      sdp_enumerate_commands();
      }
#line 2297
      return (0);
    }
#line 2300
    if (opts.num_desc > 0) {
#line 2300
      if (pn < 0) {
        {
#line 2301
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"when \'--num-desc\' is given an explicit mode page is required\n");
        }
#line 2303
        return (1);
      }
    }
#line 2306
    if (opts.defaults) {
#line 2306
      if (set_str) {
        {
#line 2307
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--get=\', \'--set=\' or \'--clear=\' can\'t be used with \'--defaults\'\n");
        }
#line 2309
        return (1);
      } else
#line 2306
      if (clear_str) {
        {
#line 2307
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--get=\', \'--set=\' or \'--clear=\' can\'t be used with \'--defaults\'\n");
        }
#line 2309
        return (1);
      } else
#line 2306
      if (get_str) {
        {
#line 2307
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'--get=\', \'--set=\' or \'--clear=\' can\'t be used with \'--defaults\'\n");
        }
#line 2309
        return (1);
      }
    }
#line 2312
    if (set_str) {
      {
#line 2313
      tmp___6 = build_mp_settings(set_str, & mp_settings, & opts, 0, 0);
      }
#line 2313
      if (tmp___6) {
#line 2314
        return (1);
      }
    }
#line 2316
    if (clear_str) {
      {
#line 2317
      tmp___7 = build_mp_settings(clear_str, & mp_settings, & opts, 1, 0);
      }
#line 2317
      if (tmp___7) {
#line 2318
        return (1);
      }
    }
#line 2321
    if (opts.verbose) {
#line 2321
      if (mp_settings.num_it_vals > 0) {
        {
#line 2322
        list_mp_settings((struct sdparm_mode_page_settings  const  *)(& mp_settings),
                         (unsigned long )((void *)0) != (unsigned long )get_str);
        }
      }
    }
#line 2324
    if (opts.defaults) {
#line 2324
      if (pn < 0) {
        {
#line 2325
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"to set defaults, the \'--page=\' option must be used\n");
        }
#line 2327
        return (1);
      }
    }
  }
#line 2331
  if (0 == num_devices) {
    {
#line 2332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"one or more device names required\n");
#line 2333
    usage();
    }
#line 2334
    return (1);
  }
#line 2337
  req_pdt = pdt;
#line 2338
  ret = 0;
#line 2339
  k = 0;
  {
#line 2339
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2339
    if (! (k < num_devices)) {
#line 2339
      goto while_break___7;
    }
#line 2340
    r = 0;
#line 2341
    pdt = -1;
#line 2342
    if (opts.verbose > 0) {
      {
#line 2343
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>> about to open device name: %s\n",
              device_name_arr[k]);
      }
    }
    {
#line 2345
    sg_fd = open_and_simple_inquiry(device_name_arr[k], rw, & pdt, & protect, (struct sdparm_opt_coll  const  *)(& opts));
    }
#line 2347
    if (sg_fd < 0) {
#line 2348
      r = 15;
#line 2349
      if (0 == ret) {
#line 2350
        ret = r;
      }
#line 2351
      goto __Cont___1;
    }
#line 2354
    if (opts.inquiry) {
#line 2355
      if (spn < 0) {
#line 2355
        tmp___8 = 0;
      } else {
#line 2355
        tmp___8 = spn;
      }
      {
#line 2355
      r = sdp_process_vpd_page(sg_fd, pn, tmp___8, (struct sdparm_opt_coll  const  *)(& opts),
                               req_pdt, protect);
      }
    } else
#line 2358
    if (cmd_str) {
#line 2358
      if (scmdp) {
        {
#line 2359
        r = sdp_process_cmd(sg_fd, scmdp, cmd_arg, pdt, (struct sdparm_opt_coll  const  *)(& opts));
        }
      } else {
        {
#line 2361
        r = process_mode(sg_fd, (struct sdparm_mode_page_settings  const  *)(& mp_settings),
                         pn, spn, rw, (unsigned long )((void *)0) != (unsigned long )get_str,
                         (struct sdparm_opt_coll  const  *)(& opts), pdt);
        }
      }
    } else {
      {
#line 2361
      r = process_mode(sg_fd, (struct sdparm_mode_page_settings  const  *)(& mp_settings),
                       pn, spn, rw, (unsigned long )((void *)0) != (unsigned long )get_str,
                       (struct sdparm_opt_coll  const  *)(& opts), pdt);
      }
    }
    {
#line 2365
    res = sg_cmds_close_device(sg_fd);
    }
#line 2366
    if (res < 0) {
      {
#line 2367
      tmp___9 = safe_strerror(- sg_fd);
#line 2367
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"close error: %s\n",
              tmp___9);
      }
#line 2368
      if (0 == r) {
#line 2369
        r = 15;
      }
    }
#line 2371
    if (r) {
#line 2371
      if (0 == ret) {
#line 2372
        ret = r;
      } else
#line 2371
      if (15 == ret) {
#line 2372
        ret = r;
      }
    }
    __Cont___1: /* CIL Label */ 
#line 2339
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2374
  if (ret >= 0) {
#line 2374
    tmp___10 = ret;
  } else {
#line 2374
    tmp___10 = 99;
  }
#line 2374
  return (tmp___10);
}
}
#line 2404 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int find_corresponding_sg_fd(int oth_fd , char const   *device_name , int rw ,
                                    int verbose ) 
{ 
  int fd ;
  int err ;
  int bus ;
  int bbus ;
  int k ;
  int v ;
  My_scsi_idlun m_idlun ;
  My_scsi_idlun mm_idlun ;
  char name[256] ;
  int num_nodevs ;
  int num_sgdevs ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 2411
  num_nodevs = 0;
#line 2412
  num_sgdevs = 0;
#line 2414
  err = ioctl(oth_fd, 21382UL, & bus);
  }
#line 2415
  if (err < 0) {
    {
#line 2416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not present a standard Linux SCSI device interface (a\nSCSI_IOCTL_GET_BUS_NUMBER ioctl to it failed). Examples of typical\n",
            device_name);
#line 2419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"names of devices that do are /dev/sda, /dev/scd0, dev/st0, /dev/osst0,\nand /dev/sg0. An example of a typical non-SCSI device name is /dev/hdd.\n");
    }
#line 2422
    return (-2);
  }
  {
#line 2424
  err = ioctl(oth_fd, 21378UL, & m_idlun);
  }
#line 2425
  if (err < 0) {
#line 2426
    if (verbose) {
      {
#line 2427
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not understand SCSI commands(2)\n",
              device_name);
      }
    }
#line 2429
    return (-2);
  }
#line 2432
  fd = -2;
#line 2433
  k = 0;
  {
#line 2433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2433
    if (k < 256) {
#line 2433
      if (! (num_nodevs < 4)) {
#line 2433
        goto while_break;
      }
    } else {
#line 2433
      goto while_break;
    }
    {
#line 2434
    snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"/dev/sg%d",
             k);
#line 2435
    fd = open((char const   *)(name), 2048);
    }
#line 2436
    if (fd < 0) {
      {
#line 2437
      tmp = __errno_location();
      }
#line 2437
      if (19 != *tmp) {
#line 2438
        num_sgdevs ++;
      }
      {
#line 2439
      tmp___0 = __errno_location();
      }
#line 2439
      if (19 == *tmp___0) {
#line 2441
        num_nodevs ++;
#line 2442
        goto __Cont;
      } else {
        {
#line 2439
        tmp___1 = __errno_location();
        }
#line 2439
        if (2 == *tmp___1) {
#line 2441
          num_nodevs ++;
#line 2442
          goto __Cont;
        } else {
          {
#line 2439
          tmp___2 = __errno_location();
          }
#line 2439
          if (6 == *tmp___2) {
#line 2441
            num_nodevs ++;
#line 2442
            goto __Cont;
          }
        }
      }
      {
#line 2444
      tmp___3 = __errno_location();
      }
#line 2444
      if (16 == *tmp___3) {
#line 2445
        goto __Cont;
      } else {
#line 2447
        goto while_break;
      }
    } else {
#line 2449
      num_sgdevs ++;
    }
    {
#line 2450
    err = ioctl(fd, 21382UL, & bbus);
    }
#line 2451
    if (err < 0) {
#line 2452
      if (verbose) {
        {
#line 2453
        perror("SCSI_IOCTL_GET_BUS_NUMBER failed");
        }
      }
#line 2454
      return (-2);
    }
    {
#line 2456
    err = ioctl(fd, 21378UL, & mm_idlun);
    }
#line 2457
    if (err < 0) {
#line 2458
      if (verbose) {
        {
#line 2459
        perror("SCSI_IOCTL_GET_IDLUN failed");
        }
      }
#line 2460
      return (-2);
    }
#line 2462
    if (bus == bbus) {
#line 2462
      if ((m_idlun.mux4 & 255) == (mm_idlun.mux4 & 255)) {
#line 2462
        if (((m_idlun.mux4 >> 8) & 255) == ((mm_idlun.mux4 >> 8) & 255)) {
#line 2462
          if (((m_idlun.mux4 >> 16) & 255) == ((mm_idlun.mux4 >> 16) & 255)) {
#line 2468
            goto while_break;
          } else {
            {
#line 2470
            close(fd);
#line 2471
            fd = -2;
            }
          }
        } else {
          {
#line 2470
          close(fd);
#line 2471
          fd = -2;
          }
        }
      } else {
        {
#line 2470
        close(fd);
#line 2471
        fd = -2;
        }
      }
    } else {
      {
#line 2470
      close(fd);
#line 2471
      fd = -2;
      }
    }
    __Cont: /* CIL Label */ 
#line 2433
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2474
  if (0 == num_sgdevs) {
    {
#line 2475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No /dev/sg* devices found; is the sg driver loaded?\n");
    }
#line 2477
    return (-2);
  }
#line 2479
  if (fd >= 0) {
    {
#line 2480
    tmp___4 = ioctl(fd, 8834UL, & v);
    }
#line 2480
    if (tmp___4 < 0) {
      {
#line 2481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"requires lk 2.4 (sg driver) or lk 2.6\n");
#line 2482
      close(fd);
      }
#line 2483
      return (-2);
    } else
#line 2480
    if (v < 30000) {
      {
#line 2481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"requires lk 2.4 (sg driver) or lk 2.6\n");
#line 2482
      close(fd);
      }
#line 2483
      return (-2);
    }
    {
#line 2485
    close(fd);
    }
#line 2486
    if (verbose) {
      {
#line 2487
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">> mapping %s to %s (in lk 2.4 series)\n",
              device_name, name);
      }
    }
#line 2490
    if (rw) {
#line 2490
      tmp___5 = 2;
    } else {
#line 2490
      tmp___5 = 0;
    }
    {
#line 2490
    tmp___6 = open((char const   *)(name), 2048 | tmp___5);
    }
#line 2490
    return (tmp___6);
  } else {
#line 2493
    return (fd);
  }
}
}
#line 2496 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.c"
static int map_if_lk24(int sg_fd , char const   *device_name , int rw , int verbose ) 
{ 
  struct utsname a_uts ;
  int two ;
  int four ;
  int res ;
  struct stat a_stat ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2505
  tmp___0 = stat((char const   */* __restrict  */)device_name, (struct stat */* __restrict  */)(& a_stat));
  }
#line 2505
  if (tmp___0 < 0) {
    {
#line 2506
    tmp = __errno_location();
#line 2506
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to \'stat\' %s, errno=%d\n",
            device_name, *tmp);
#line 2508
    perror("stat failed");
    }
#line 2509
    return (-1);
  }
#line 2511
  if (! ((a_stat.st_mode & 61440U) == 24576U)) {
#line 2511
    if (! ((a_stat.st_mode & 61440U) == 8192U)) {
      {
#line 2512
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected %s to be a block or char device\n",
              device_name);
      }
#line 2514
      return (-1);
    }
  }
  {
#line 2516
  tmp___1 = uname(& a_uts);
  }
#line 2516
  if (tmp___1 < 0) {
    {
#line 2517
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uname system call failed, couldn\'t send SG_IO ioctl to %s\n",
            device_name);
    }
#line 2519
    return (-1);
  }
  {
#line 2521
  res = sscanf((char const   */* __restrict  */)(a_uts.release), (char const   */* __restrict  */)"%d.%d",
               & two, & four);
  }
#line 2522
  if (2 != res) {
    {
#line 2523
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to read uname release\n");
    }
#line 2524
    return (-1);
  }
#line 2526
  if (2 == two) {
#line 2526
    if (! (4 == four)) {
      {
#line 2527
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to access %s, ATA disk?\n",
              device_name);
      }
#line 2529
      return (-1);
    }
  } else {
    {
#line 2527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to access %s, ATA disk?\n",
            device_name);
    }
#line 2529
    return (-1);
  }
  {
#line 2531
  tmp___2 = find_corresponding_sg_fd(sg_fd, device_name, rw, verbose);
  }
#line 2531
  return (tmp___2);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
struct sdparm_vendor_pair sdparm_vendor_mp[4] ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
struct sdparm_vendor_name_t sdparm_vendor_id[5]  = {      {0, "sea", "Seagate disk"}, 
        {1, "hit", "Hitachi disk"}, 
        {2, "max", "Maxtor disk"}, 
        {3, "fuj", "Fujitsu disk"}, 
        {0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 52 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_t sdparm_v_seagate_mode_pg[2]  = {      {0, 0, 0, 0, "ua", "Unit attention (seagate)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 57 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_item sdparm_mitem_v_seagate_arr[14]  = 
#line 57
  {      {"PM", 0, 0, 0, 2, 7, 1, 1, "Performance Mode", "0: adaptive cache (\'server mode\')\t1: number of cache segments as per caching page (\'desktop mode\')"}, 
        {"SSM",
      0, 0, 0, 2, 6, 1, 0, "Synchronous select mode (SPI)", "0: drive will not initiate WDTR or SDTR\t1: drive may initiate WDTR or SDTR"}, 
        {"IL",
      0, 0, 0, 2, 5, 1, 1, "Inquiry length", "0: more than 36 bytes in response\t1: 36 byte response as per SCSI-2"}, 
        {"UA",
      0, 0, 0, 2, 4, 1, 1, "Unit attention", "0: unit attention condition for all initiators after reset\t1: no check condition with unit attention after reset"}, 
        {"DFUA",
      0, 0, 0, 2, 3, 1, 0, "Disable force unit access (FUA)", "0: honour FUA bit setting on READ and WRITE commands\t1: ignore FUA bit setting"}, 
        {"ROUND",
      0, 0, 0, 2, 2, 1, 0, "Reporting of log parameter rounding (wrap around)", "0: do not report (silently round)\t1: report rounding (as per SPC-4)"}, 
        {"STRICT",
      0, 0, 0, 2, 1, 1, 1, "Strict when trying to alter unchangeable mode page fields",
      "0: silently ignore\t1: report as error"}, 
        {"SCSI2", 0, 0, 0, 2, 0, 1, 1, "SCSI-2 lengths for control and caching mode pages",
      "0: as per recent standards\t1: SCSI-2 lengths: control, 6; caching, 10"}, 
        {"SSEEK", 0, 0, 0, 3, 6, 1, 0, "Self seek", "0: off (normal operating mode)\t1: enter self seek mode (test power dissipation, acoustics, etc)"}, 
        {"JIT3",
      0, 0, 0, 4, 3, 1, 0, "Just in time 3, slowest seek type", "0: can not use this seek type in seek speed algorithm\t1: can use this seek type in seek speed algorithm"}, 
        {"JIT2",
      0, 0, 0, 4, 2, 1, 0, "Just in time 2, second slowest seek type", "0: can not use this seek type in seek speed algorithm\t1: can use this seek type in seek speed algorithm"}, 
        {"JIT1",
      0, 0, 0, 4, 1, 1, 0, "Just in time 1, second fastest seek type", "0: can not use this seek type in seek speed algorithm\t1: can use this seek type in seek speed algorithm"}, 
        {"JIT0",
      0, 0, 0, 4, 0, 1, 0, "Just in time 0, fastest seek type", "0: can not use this seek type in seek speed algorithm\t1: can use this seek type in seek speed algorithm"}, 
        {(char const   *)((void *)0),
      0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 115 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_t sdparm_v_hitachi_mode_pg[2]  = {      {0, 0, 0, 0, "vup", "Vendor unique parameters (hitachi)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 121 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_item sdparm_mitem_v_hitachi_arr[16]  = 
#line 121
  {      {"MRG", 0, 0, 0, 2, 3, 1, 0, "Merge Glist into Plist (during format)", (char const   *)((void *)0)}, 
        {"VGMDE",
      0, 0, 0, 3, 6, 1, 1, "Veggie mode (do random seeks when idle)", (char const   *)((void *)0)}, 
        {"RRNDE",
      0, 0, 0, 3, 1, 1, 0, "Report recovered non data errors (when PER set)", (char const   *)((void *)0)}, 
        {"FDD",
      0, 0, 0, 5, 4, 1, 0, "Format degraded disable (reporting for Test Unit Ready)",
      (char const   *)((void *)0)}, 
        {"CAEN", 0, 0, 0, 5, 1, 1, 1, "Command aging enable", (char const   *)((void *)0)}, 
        {"IGRA",
      0, 0, 0, 6, 7, 1, 1, "Ignore reassigned LBA (when RC also set)", (char const   *)((void *)0)}, 
        {"AVERP",
      0, 0, 0, 6, 6, 1, 1, "AV ERP mode (maximum retry count for read errors)", "0: use default (ignore RRC)\t1: use RRC field"}, 
        {"OCT",
      0, 0, 0, 6, 3, 12, 0, "Overall command timer, 0 -> disabled (50 ms)", (char const   *)((void *)0)}, 
        {"TT",
      0, 0, 0, 9, 7, 8, 0, "Temperature threshold (celsius), 0 -> 85C", (char const   *)((void *)0)}, 
        {"CAL",
      0, 0, 0, 10, 7, 16, 0, "Command aging limit (50 ms), 0 -> 85C", (char const   *)((void *)0)}, 
        {"RRT",
      0, 0, 0, 12, 7, 8, 0, "Read reporting threshold for read recovered errors when PER set",
      (char const   *)((void *)0)}, 
        {"WRT", 0, 0, 0, 13, 7, 8, 0, "Write reporting threshold for write recovered errors when PER set",
      (char const   *)((void *)0)}, 
        {"DRRT", 0, 0, 0, 14, 7, 1, 0, "Disable restore reassign target", "0: REASSIGN attempts to recovery old data\t1: REASSIGN ignores old data"}, 
        {"FFMT",
      0, 0, 0, 14, 3, 1, 0, "Fast format enable, format without writes to customer media",
      (char const   *)((void *)0)}, 
        {"FCERT", 0, 0, 0, 15, 5, 1, 0, "Format certification (enable)", (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      0, 0, 0, 0, 0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 163 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_t sdparm_v_maxtor_mode_pg[2]  = {      {0, 0, 0, 0, "uac", "Unit attention condition (maxtor)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 169 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_item sdparm_mitem_v_maxtor_arr[1]  = {      {"DUA", 0, 0, 0, 2, 4, 1, 1, "Disable unit attention", (char const   *)((void *)0)}};
#line 175 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_t sdparm_v_fujitsu_mode_pg[2]  = {      {33, 0, 0, 0, "aerp", "Additional error recovery parameters (fujitsu)", (struct sdparm_mode_descriptor_t  const  *)((void *)0)}, 
        {0,
      0, 0, 0, (char const   *)((void *)0), (char const   *)((void *)0), (struct sdparm_mode_descriptor_t  const  *)((void *)0)}};
#line 181 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
static struct sdparm_mode_page_item sdparm_mitem_v_fujitsu_arr[1]  = {      {"RDSE", 33, 0, 0, 2, 3, 4, 1, "Retries during a seek error", "0: no repositioning retries"}};
#line 188 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
struct sdparm_vendor_pair sdparm_vendor_mp[4]  = {      {sdparm_v_seagate_mode_pg, sdparm_mitem_v_seagate_arr}, 
        {sdparm_v_hitachi_mode_pg, sdparm_mitem_v_hitachi_arr}, 
        {sdparm_v_maxtor_mode_pg, sdparm_mitem_v_maxtor_arr}, 
        {sdparm_v_fujitsu_mode_pg, sdparm_mitem_v_fujitsu_arr}};
#line 195 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_data_vendor.c"
int sdparm_vendor_mp_len  =    (int )(sizeof(sdparm_vendor_mp) / sizeof(sdparm_vendor_mp[0]));
#line 131 "../include/sg_lib.h"
void sg_get_scsi_status_str(int scsi_status , int buff_len , char *buff ) ;
#line 194
int sg_get_sense_progress_fld(unsigned char const   *sensep , int sb_len , int *progress_outp ) ;
#line 200
void sg_get_sense_str(char const   *leadin , unsigned char const   *sense_buffer ,
                      int sb_len , int raw_sinfo , int buff_len , char *buff ) ;
#line 212
FILE *sg_warnings_strm ;
#line 258
int sg_err_category_sense(unsigned char const   *sense_buffer , int sb_len ) ;
#line 29 "../include/sg_cmds_basic.h"
int sg_ll_log_select(int sg_fd , int pcr , int sp , int pc , int pg_code , int subpg_code ,
                     unsigned char *paramp , int param_len , int noisy , int verbose ) ;
#line 39
int sg_ll_log_sense(int sg_fd , int ppc , int sp , int pc , int pg_code , int subpg_code ,
                    int paramp , unsigned char *resp , int mx_resp_len , int noisy ,
                    int verbose ) ;
#line 84
int sg_ll_prevent_allow(int sg_fd , int prevent , int noisy , int verbose ) ;
#line 92
int sg_ll_readcap_10(int sg_fd , int pmi , unsigned int lba , void *resp , int mx_resp_len ,
                     int noisy , int verbose ) ;
#line 101
int sg_ll_readcap_16(int sg_fd , int pmi , uint64_t llba , void *resp , int mx_resp_len ,
                     int noisy , int verbose ) ;
#line 108
int sg_ll_report_luns(int sg_fd , int select_report , void *resp , int mx_resp_len ,
                      int noisy , int verbose ) ;
#line 115
int sg_ll_request_sense(int sg_fd , int desc , void *resp , int mx_resp_len , int noisy ,
                        int verbose ) ;
#line 128
int sg_ll_start_stop_unit(int sg_fd , int immed , int pc_mod__fl_num , int power_cond ,
                          int noflush__fl , int loej , int start , int noisy , int verbose ) ;
#line 137
int sg_ll_sync_cache_10(int sg_fd , int sync_nv , int immed , int group , unsigned int lba ,
                        unsigned int count , int noisy , int verbose ) ;
#line 146
int sg_ll_test_unit_ready(int sg_fd , int pack_id , int noisy , int verbose ) ;
#line 156
int sg_ll_test_unit_ready_progress(int sg_fd , int pack_id , int *progress , int noisy ,
                                   int verbose ) ;
#line 223
int sg_cmds_open_flags(char const   *device_name , int flags , int verbose ) ;
#line 230
char const   *sg_cmds_version(void) ;
#line 244
int sg_cmds_process_resp(struct sg_pt_base *ptvp , char const   *leadin , int pt_res ,
                         int mx_di_len , unsigned char const   *sbp , int noisy ,
                         int verbose , int *o_sense_cat ) ;
#line 32 "../include/sg_pt.h"
int scsi_pt_open_device(char const   *device_name , int read_only , int verbose ) ;
#line 38
int scsi_pt_open_flags(char const   *device_name , int flags , int verbose ) ;
#line 42
int scsi_pt_close_device(int device_fd ) ;
#line 49
struct sg_pt_base *construct_scsi_pt_obj(void) ;
#line 56
void set_scsi_pt_cdb(struct sg_pt_base *vp , unsigned char const   *cdb , int cdb_len ) ;
#line 59
void set_scsi_pt_sense(struct sg_pt_base *vp , unsigned char *sense , int max_sense_len ) ;
#line 62
void set_scsi_pt_data_in(struct sg_pt_base *vp , unsigned char *dxferp , int dxfer_len ) ;
#line 65
void set_scsi_pt_data_out(struct sg_pt_base *vp , unsigned char const   *dxferp ,
                          int dxfer_len ) ;
#line 68
void set_scsi_pt_packet_id(struct sg_pt_base *vp , int pack_id ) ;
#line 95
int do_scsi_pt(struct sg_pt_base *vp , int fd , int time_secs , int verbose ) ;
#line 104
int get_scsi_pt_result_category(struct sg_pt_base  const  *vp ) ;
#line 107
int get_scsi_pt_resid(struct sg_pt_base  const  *vp ) ;
#line 110
int get_scsi_pt_status_response(struct sg_pt_base  const  *vp ) ;
#line 113
int get_scsi_pt_sense_len(struct sg_pt_base  const  *vp ) ;
#line 116
char *get_scsi_pt_os_err_str(struct sg_pt_base  const  *vp , int max_b_len , char *b ) ;
#line 120
char *get_scsi_pt_transport_err_str(struct sg_pt_base  const  *vp , int max_b_len ,
                                    char *b ) ;
#line 124
int get_scsi_pt_duration_ms(struct sg_pt_base  const  *vp ) ;
#line 130
void destruct_scsi_pt_obj(struct sg_pt_base *vp ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
static char *version_str___0  =    (char *)"1.55 20110730";
#line 79 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
char const   *sg_cmds_version(void) 
{ 


  {
#line 82
  return ((char const   *)version_str___0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_cmds_open_device(char const   *device_name , int read_only , int verbose ) 
{ 
  int tmp ;

  {
  {
#line 90
  tmp = scsi_pt_open_device(device_name, read_only, verbose);
  }
#line 90
  return (tmp);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_cmds_open_flags(char const   *device_name , int flags , int verbose ) 
{ 
  int tmp ;

  {
  {
#line 98
  tmp = scsi_pt_open_flags(device_name, flags, verbose);
  }
#line 98
  return (tmp);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_cmds_close_device(int device_fd ) 
{ 
  int tmp ;

  {
  {
#line 105
  tmp = scsi_pt_close_device(device_fd);
  }
#line 105
  return (tmp);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_cmds_process_resp(struct sg_pt_base *ptvp , char const   *leadin , int pt_res ,
                         int mx_di_len , unsigned char const   *sbp , int noisy ,
                         int verbose , int *o_sense_cat ) 
{ 
  int got ;
  int cat ;
  int duration ;
  int slen ;
  int scat ;
  int n ;
  int resid ;
  int resp_code ;
  int check_data_in ;
  char b[1024] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 124
  check_data_in = 0;
#line 127
  if ((unsigned long )((void *)0) == (unsigned long )leadin) {
#line 128
    leadin = "";
  }
#line 129
  if (pt_res < 0) {
#line 130
    if (noisy) {
      {
#line 131
      tmp = safe_strerror(- pt_res);
#line 131
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: pass through os error: %s\n",
              leadin, tmp);
      }
    } else
#line 130
    if (verbose) {
      {
#line 131
      tmp = safe_strerror(- pt_res);
#line 131
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: pass through os error: %s\n",
              leadin, tmp);
      }
    }
#line 133
    return (-1);
  } else
#line 134
  if (1 == pt_res) {
    {
#line 135
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: bad pass through setup\n",
            leadin);
    }
#line 136
    return (-1);
  } else
#line 137
  if (2 == pt_res) {
    {
#line 138
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: pass through timeout\n",
            leadin);
    }
#line 139
    return (-1);
  }
#line 141
  if (verbose > 2) {
    {
#line 141
    duration = get_scsi_pt_duration_ms((struct sg_pt_base  const  *)ptvp);
    }
#line 141
    if (duration >= 0) {
      {
#line 142
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"      duration=%d ms\n",
              duration);
      }
    }
  }
#line 143
  if (mx_di_len > 0) {
    {
#line 143
    tmp___0 = get_scsi_pt_resid((struct sg_pt_base  const  *)ptvp);
#line 143
    resid = tmp___0;
    }
  } else {
#line 143
    resid = 0;
  }
  {
#line 144
  slen = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 145
  cat = get_scsi_pt_result_category((struct sg_pt_base  const  *)ptvp);
  }
  {
#line 146
  if (cat == 0) {
#line 146
    goto case_0;
  }
#line 169
  if (cat == 1) {
#line 169
    goto case_1;
  }
#line 176
  if (cat == 2) {
#line 176
    goto case_2;
  }
#line 208
  if (cat == 3) {
#line 208
    goto case_3___0;
  }
#line 214
  if (cat == 4) {
#line 214
    goto case_4;
  }
#line 220
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 147
  if (slen > 7) {
#line 148
    resp_code = (int )((int const   )*(sbp + 0) & 127);
#line 150
    if (resp_code >= 112) {
#line 151
      if (resp_code < 114) {
#line 152
        if (0 != (15 & (int )*(sbp + 2))) {
          {
#line 153
          sg_err_category_sense(sbp, slen);
          }
        }
      } else
#line 154
      if (resp_code < 116) {
#line 155
        if (0 != (15 & (int )*(sbp + 1))) {
          {
#line 156
          sg_err_category_sense(sbp, slen);
          }
        }
      }
    }
  }
#line 160
  if (mx_di_len > 0) {
#line 161
    got = mx_di_len - resid;
#line 162
    if (verbose) {
#line 162
      if (resid > 0) {
        {
#line 163
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    %s: pass-through requested %d bytes but got %d bytes\n",
                leadin, mx_di_len, got);
        }
      }
    }
#line 166
    return (got);
  } else {
#line 168
    return (0);
  }
  case_1: /* CIL Label */ 
#line 170
  if (verbose) {
    {
#line 171
    tmp___1 = get_scsi_pt_status_response((struct sg_pt_base  const  *)ptvp);
#line 171
    sg_get_scsi_status_str(tmp___1, (int )sizeof(b), b);
#line 173
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: scsi status: %s\n",
            leadin, b);
    }
  } else
#line 170
  if (noisy) {
    {
#line 171
    tmp___1 = get_scsi_pt_status_response((struct sg_pt_base  const  *)ptvp);
#line 171
    sg_get_scsi_status_str(tmp___1, (int )sizeof(b), b);
#line 173
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: scsi status: %s\n",
            leadin, b);
    }
  }
#line 175
  return (-1);
  case_2: /* CIL Label */ 
  {
#line 177
  scat = sg_err_category_sense(sbp, slen);
  }
  {
#line 184
  if (scat == 20) {
#line 184
    goto case_20;
  }
#line 184
  if (scat == 11) {
#line 184
    goto case_20;
  }
#line 184
  if (scat == 5) {
#line 184
    goto case_20;
  }
#line 184
  if (scat == 9) {
#line 184
    goto case_20;
  }
#line 184
  if (scat == 6) {
#line 184
    goto case_20;
  }
#line 184
  if (scat == 2) {
#line 184
    goto case_20;
  }
#line 188
  if (scat == 3) {
#line 188
    goto case_3;
  }
#line 188
  if (scat == 21) {
#line 188
    goto case_3;
  }
#line 190
  goto switch_default;
  case_20: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 185
  n = 0;
#line 186
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 189
  check_data_in ++;
  switch_default: /* CIL Label */ 
#line 191
  n = noisy;
#line 192
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 194
  if (verbose) {
#line 194
    goto _L;
  } else
#line 194
  if (n) {
    _L: /* CIL Label */ 
    {
#line 195
    sg_get_sense_str(leadin, sbp, slen, verbose > 1, (int )sizeof(b), b);
#line 197
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s",
            b);
    }
#line 198
    if (mx_di_len > 0) {
#line 198
      if (resid > 0) {
#line 199
        got = mx_di_len - resid;
#line 200
        if (verbose > 2) {
          {
#line 201
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    pass-through requested %d bytes but got %d bytes\n",
                  mx_di_len, got);
          }
        } else
#line 200
        if (check_data_in) {
          {
#line 201
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    pass-through requested %d bytes but got %d bytes\n",
                  mx_di_len, got);
          }
        } else
#line 200
        if (got > 0) {
          {
#line 201
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    pass-through requested %d bytes but got %d bytes\n",
                  mx_di_len, got);
          }
        }
      }
    }
  }
#line 205
  if (o_sense_cat) {
#line 206
    *o_sense_cat = scat;
  }
#line 207
  return (-2);
  case_3___0: /* CIL Label */ 
#line 209
  if (verbose) {
    {
#line 210
    get_scsi_pt_transport_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b),
                                  b);
#line 211
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: transport: %s\n",
            leadin, b);
    }
  } else
#line 209
  if (noisy) {
    {
#line 210
    get_scsi_pt_transport_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b),
                                  b);
#line 211
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: transport: %s\n",
            leadin, b);
    }
  }
#line 213
  return (-1);
  case_4: /* CIL Label */ 
#line 215
  if (verbose) {
    {
#line 216
    get_scsi_pt_os_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b), b);
#line 217
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: os: %s\n",
            leadin, b);
    }
  } else
#line 215
  if (noisy) {
    {
#line 216
    get_scsi_pt_os_err_str((struct sg_pt_base  const  *)ptvp, (int )sizeof(b), b);
#line 217
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: os: %s\n",
            leadin, b);
    }
  }
#line 219
  return (-1);
  switch_default___0: /* CIL Label */ 
  {
#line 221
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s: unknown pass through result category (%d)\n",
          leadin, cat);
  }
#line 223
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_inquiry(int sg_fd , int cmddt , int evpd , int pg_op , void *resp , int mx_resp_len ,
                  int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char inqCmdBlk[6] ;
  unsigned char sense_b[64] ;
  unsigned char *up ;
  struct sg_pt_base *ptvp ;

  {
#line 236
  inqCmdBlk[0] = (unsigned char)18;
#line 236
  inqCmdBlk[1] = (unsigned char)0;
#line 236
  inqCmdBlk[2] = (unsigned char)0;
#line 236
  inqCmdBlk[3] = (unsigned char)0;
#line 236
  inqCmdBlk[4] = (unsigned char)0;
#line 236
  inqCmdBlk[5] = (unsigned char)0;
#line 241
  if (cmddt) {
#line 242
    inqCmdBlk[1] = (unsigned char )((int )inqCmdBlk[1] | 2);
  }
#line 243
  if (evpd) {
#line 244
    inqCmdBlk[1] = (unsigned char )((int )inqCmdBlk[1] | 1);
  }
#line 245
  inqCmdBlk[2] = (unsigned char )pg_op;
#line 247
  inqCmdBlk[3] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 248
  inqCmdBlk[4] = (unsigned char )(mx_resp_len & 255);
#line 249
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 250
    sg_warnings_strm = stderr;
  }
#line 251
  if (verbose) {
    {
#line 252
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    inquiry cdb: ");
#line 253
    k = 0;
    }
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (! (k < 6)) {
#line 253
        goto while_break;
      }
      {
#line 254
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )inqCmdBlk[k]);
#line 253
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 255
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 257
  if (resp) {
#line 257
    if (mx_resp_len > 0) {
#line 258
      up = (unsigned char *)resp;
#line 259
      *(up + 0) = (unsigned char)127;
#line 260
      if (mx_resp_len > 4) {
#line 261
        *(up + 4) = (unsigned char)0;
      }
    }
  }
  {
#line 263
  ptvp = construct_scsi_pt_obj();
  }
#line 264
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 265
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: out of memory\n");
    }
#line 266
    return (-1);
  }
  {
#line 268
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(inqCmdBlk), (int )sizeof(inqCmdBlk));
#line 269
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 270
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 271
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 272
  ret = sg_cmds_process_resp(ptvp, "inquiry", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
#line 274
  destruct_scsi_pt_obj(ptvp);
  }
#line 275
  if (! (-1 == ret)) {
#line 277
    if (-2 == ret) {
      {
#line 281
      if (sense_cat == 11) {
#line 281
        goto case_11;
      }
#line 281
      if (sense_cat == 5) {
#line 281
        goto case_11;
      }
#line 281
      if (sense_cat == 9) {
#line 281
        goto case_11;
      }
#line 285
      if (sense_cat == 20) {
#line 285
        goto case_20;
      }
#line 285
      if (sense_cat == 21) {
#line 285
        goto case_20;
      }
#line 288
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 282
      ret = sense_cat;
#line 283
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 286
      ret = 0;
#line 287
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 289
      ret = -1;
#line 290
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 292
    if (ret < 4) {
#line 293
      if (verbose) {
        {
#line 294
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: got too few bytes (%d)\n",
                ret);
        }
      }
#line 296
      ret = 97;
    } else {
#line 298
      ret = 0;
    }
  }
#line 300
  return (ret);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_simple_inquiry(int sg_fd , struct sg_simple_inquiry_resp *inq_data , int noisy ,
                      int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char inqCmdBlk[6] ;
  unsigned char sense_b[64] ;
  unsigned char inq_resp[36] ;
  struct sg_pt_base *ptvp ;

  {
#line 312
  inqCmdBlk[0] = (unsigned char)18;
#line 312
  inqCmdBlk[1] = (unsigned char)0;
#line 312
  inqCmdBlk[2] = (unsigned char)0;
#line 312
  inqCmdBlk[3] = (unsigned char)0;
#line 312
  inqCmdBlk[4] = (unsigned char)0;
#line 312
  inqCmdBlk[5] = (unsigned char)0;
#line 317
  if (inq_data) {
    {
#line 318
    memset((void *)inq_data, 0, sizeof(*inq_data));
#line 319
    inq_data->peripheral_qualifier = (unsigned char)3;
#line 320
    inq_data->peripheral_type = (unsigned char)31;
    }
  }
#line 322
  inqCmdBlk[4] = (unsigned char )sizeof(inq_resp);
#line 323
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 324
    sg_warnings_strm = stderr;
  }
#line 325
  if (verbose) {
    {
#line 326
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    inquiry cdb: ");
#line 327
    k = 0;
    }
    {
#line 327
    while (1) {
      while_continue: /* CIL Label */ ;
#line 327
      if (! (k < 6)) {
#line 327
        goto while_break;
      }
      {
#line 328
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )inqCmdBlk[k]);
#line 327
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 329
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 331
  memset((void *)(inq_resp), 0, sizeof(inq_resp));
#line 332
  inq_resp[0] = (unsigned char)127;
#line 333
  ptvp = construct_scsi_pt_obj();
  }
#line 334
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 335
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: out of memory\n");
    }
#line 336
    return (-1);
  }
  {
#line 338
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(inqCmdBlk), (int )sizeof(inqCmdBlk));
#line 339
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 340
  set_scsi_pt_data_in(ptvp, inq_resp, (int )sizeof(inq_resp));
#line 341
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 342
  ret = sg_cmds_process_resp(ptvp, "inquiry", res, (int )sizeof(inq_resp), (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 344
  if (! (-1 == ret)) {
#line 346
    if (-2 == ret) {
      {
#line 350
      if (sense_cat == 11) {
#line 350
        goto case_11;
      }
#line 350
      if (sense_cat == 5) {
#line 350
        goto case_11;
      }
#line 350
      if (sense_cat == 9) {
#line 350
        goto case_11;
      }
#line 354
      if (sense_cat == 20) {
#line 354
        goto case_20;
      }
#line 354
      if (sense_cat == 21) {
#line 354
        goto case_20;
      }
#line 357
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 351
      ret = sense_cat;
#line 352
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 355
      ret = 0;
#line 356
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 358
      ret = -1;
#line 359
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 361
    if (ret < 4) {
#line 362
      if (verbose) {
        {
#line 363
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"inquiry: got too few bytes (%d)\n",
                ret);
        }
      }
#line 365
      ret = 97;
    } else {
#line 367
      ret = 0;
    }
  }
#line 369
  if (0 == ret) {
#line 370
    inq_data->peripheral_qualifier = (unsigned char )(((int )inq_resp[0] >> 5) & 7);
#line 371
    inq_data->peripheral_type = (unsigned char )((int )inq_resp[0] & 31);
#line 372
    if ((int )inq_resp[1] & 128) {
#line 372
      inq_data->rmb = (unsigned char)1;
    } else {
#line 372
      inq_data->rmb = (unsigned char)0;
    }
    {
#line 373
    inq_data->version = inq_resp[2];
#line 374
    inq_data->byte_3 = inq_resp[3];
#line 375
    inq_data->byte_5 = inq_resp[5];
#line 376
    inq_data->byte_6 = inq_resp[6];
#line 377
    inq_data->byte_7 = inq_resp[7];
#line 378
    memcpy((void */* __restrict  */)(inq_data->vendor), (void const   */* __restrict  */)(inq_resp + 8),
           (size_t )8);
#line 379
    memcpy((void */* __restrict  */)(inq_data->product), (void const   */* __restrict  */)(inq_resp + 16),
           (size_t )16);
#line 380
    memcpy((void */* __restrict  */)(inq_data->revision), (void const   */* __restrict  */)(inq_resp + 32),
           (size_t )4);
    }
  }
  {
#line 382
  destruct_scsi_pt_obj(ptvp);
  }
#line 383
  return (ret);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_test_unit_ready_progress(int sg_fd , int pack_id , int *progress , int noisy ,
                                   int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char turCmdBlk[6] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;
  int slen ;
  int tmp ;
  int tmp___0 ;

  {
#line 398
  turCmdBlk[0] = (unsigned char)0;
#line 398
  turCmdBlk[1] = (unsigned char)0;
#line 398
  turCmdBlk[2] = (unsigned char)0;
#line 398
  turCmdBlk[3] = (unsigned char)0;
#line 398
  turCmdBlk[4] = (unsigned char)0;
#line 398
  turCmdBlk[5] = (unsigned char)0;
#line 402
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 403
    sg_warnings_strm = stderr;
  }
#line 404
  if (verbose) {
    {
#line 405
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    test unit ready cdb: ");
#line 406
    k = 0;
    }
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
#line 406
      if (! (k < 6)) {
#line 406
        goto while_break;
      }
      {
#line 407
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )turCmdBlk[k]);
#line 406
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 408
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 411
  ptvp = construct_scsi_pt_obj();
  }
#line 412
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 413
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"test unit ready: out of memory\n");
    }
#line 414
    return (-1);
  }
  {
#line 416
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(turCmdBlk), (int )sizeof(turCmdBlk));
#line 417
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 418
  set_scsi_pt_packet_id(ptvp, pack_id);
#line 419
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 420
  ret = sg_cmds_process_resp(ptvp, "test unit ready", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 422
  if (! (-1 == ret)) {
#line 424
    if (-2 == ret) {
#line 425
      if (progress) {
        {
#line 426
        tmp = get_scsi_pt_sense_len((struct sg_pt_base  const  *)ptvp);
#line 426
        slen = tmp;
#line 428
        tmp___0 = sg_get_sense_progress_fld((unsigned char const   *)(sense_b), slen,
                                            progress);
        }
#line 428
        if (! tmp___0) {
#line 429
          *progress = -1;
        }
      }
      {
#line 434
      if (sense_cat == 11) {
#line 434
        goto case_11;
      }
#line 434
      if (sense_cat == 2) {
#line 434
        goto case_11;
      }
#line 434
      if (sense_cat == 6) {
#line 434
        goto case_11;
      }
#line 438
      if (sense_cat == 20) {
#line 438
        goto case_20;
      }
#line 438
      if (sense_cat == 21) {
#line 438
        goto case_20;
      }
#line 443
      goto switch_default;
      case_11: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_6: /* CIL Label */ 
#line 435
      ret = sense_cat;
#line 436
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 439
      ret = 0;
#line 440
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 444
      ret = -1;
#line 445
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 448
      ret = 0;
    }
  }
  {
#line 450
  destruct_scsi_pt_obj(ptvp);
  }
#line 451
  return (ret);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_test_unit_ready(int sg_fd , int pack_id , int noisy , int verbose ) 
{ 
  int tmp ;

  {
  {
#line 462
  tmp = sg_ll_test_unit_ready_progress(sg_fd, pack_id, (int *)((void *)0), noisy,
                                       verbose);
  }
#line 462
  return (tmp);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_sync_cache_10(int sg_fd , int sync_nv , int immed , int group , unsigned int lba ,
                        unsigned int count , int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char scCmdBlk[10] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 477
  scCmdBlk[0] = (unsigned char)53;
#line 477
  scCmdBlk[1] = (unsigned char)0;
#line 477
  scCmdBlk[2] = (unsigned char)0;
#line 477
  scCmdBlk[3] = (unsigned char)0;
#line 477
  scCmdBlk[4] = (unsigned char)0;
#line 477
  scCmdBlk[5] = (unsigned char)0;
#line 477
  scCmdBlk[6] = (unsigned char)0;
#line 477
  scCmdBlk[7] = (unsigned char)0;
#line 477
  scCmdBlk[8] = (unsigned char)0;
#line 477
  scCmdBlk[9] = (unsigned char)0;
#line 482
  if (sync_nv) {
#line 483
    scCmdBlk[1] = (unsigned char )((int )scCmdBlk[1] | 4);
  }
#line 484
  if (immed) {
#line 485
    scCmdBlk[1] = (unsigned char )((int )scCmdBlk[1] | 2);
  }
#line 486
  scCmdBlk[2] = (unsigned char )((lba >> 24) & 255U);
#line 487
  scCmdBlk[3] = (unsigned char )((lba >> 16) & 255U);
#line 488
  scCmdBlk[4] = (unsigned char )((lba >> 8) & 255U);
#line 489
  scCmdBlk[5] = (unsigned char )(lba & 255U);
#line 490
  scCmdBlk[6] = (unsigned char )(group & 31);
#line 491
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 492
    sg_warnings_strm = stderr;
  }
#line 493
  if (count > 65535U) {
    {
#line 494
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"count too big\n");
    }
#line 495
    return (-1);
  }
#line 497
  scCmdBlk[7] = (unsigned char )((count >> 8) & 255U);
#line 498
  scCmdBlk[8] = (unsigned char )(count & 255U);
#line 500
  if (verbose) {
    {
#line 501
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    synchronize cache(10) cdb: ");
#line 502
    k = 0;
    }
    {
#line 502
    while (1) {
      while_continue: /* CIL Label */ ;
#line 502
      if (! (k < 10)) {
#line 502
        goto while_break;
      }
      {
#line 503
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )scCmdBlk[k]);
#line 502
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 504
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 506
  ptvp = construct_scsi_pt_obj();
  }
#line 507
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 508
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"synchronize cache(10): out of memory\n");
    }
#line 509
    return (-1);
  }
  {
#line 511
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(scCmdBlk), (int )sizeof(scCmdBlk));
#line 512
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 513
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 514
  ret = sg_cmds_process_resp(ptvp, "synchronize cache(10)", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 516
  if (! (-1 == ret)) {
#line 518
    if (-2 == ret) {
      {
#line 524
      if (sense_cat == 11) {
#line 524
        goto case_11;
      }
#line 524
      if (sense_cat == 5) {
#line 524
        goto case_11;
      }
#line 524
      if (sense_cat == 9) {
#line 524
        goto case_11;
      }
#line 524
      if (sense_cat == 6) {
#line 524
        goto case_11;
      }
#line 524
      if (sense_cat == 2) {
#line 524
        goto case_11;
      }
#line 528
      if (sense_cat == 20) {
#line 528
        goto case_20;
      }
#line 528
      if (sense_cat == 21) {
#line 528
        goto case_20;
      }
#line 531
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 525
      ret = sense_cat;
#line 526
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 529
      ret = 0;
#line 530
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 532
      ret = -1;
#line 533
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 536
      ret = 0;
    }
  }
  {
#line 538
  destruct_scsi_pt_obj(ptvp);
  }
#line 539
  return (ret);
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_readcap_16(int sg_fd , int pmi , uint64_t llba , void *resp , int mx_resp_len ,
                     int noisy , int verbose ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rcCmdBlk[16] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 552
  rcCmdBlk[0] = (unsigned char)158;
#line 552
  rcCmdBlk[1] = (unsigned char)16;
#line 552
  rcCmdBlk[2] = (unsigned char)0;
#line 552
  rcCmdBlk[3] = (unsigned char)0;
#line 552
  rcCmdBlk[4] = (unsigned char)0;
#line 552
  rcCmdBlk[5] = (unsigned char)0;
#line 552
  rcCmdBlk[6] = (unsigned char)0;
#line 552
  rcCmdBlk[7] = (unsigned char)0;
#line 552
  rcCmdBlk[8] = (unsigned char)0;
#line 552
  rcCmdBlk[9] = (unsigned char)0;
#line 552
  rcCmdBlk[10] = (unsigned char)0;
#line 552
  rcCmdBlk[11] = (unsigned char)0;
#line 552
  rcCmdBlk[12] = (unsigned char)0;
#line 552
  rcCmdBlk[13] = (unsigned char)0;
#line 552
  rcCmdBlk[14] = (unsigned char)0;
#line 552
  rcCmdBlk[15] = (unsigned char)0;
#line 558
  if (pmi) {
#line 559
    rcCmdBlk[14] = (unsigned char )((int )rcCmdBlk[14] | 1);
#line 560
    rcCmdBlk[2] = (unsigned char )((llba >> 56) & 255UL);
#line 561
    rcCmdBlk[3] = (unsigned char )((llba >> 48) & 255UL);
#line 562
    rcCmdBlk[4] = (unsigned char )((llba >> 40) & 255UL);
#line 563
    rcCmdBlk[5] = (unsigned char )((llba >> 32) & 255UL);
#line 564
    rcCmdBlk[6] = (unsigned char )((llba >> 24) & 255UL);
#line 565
    rcCmdBlk[7] = (unsigned char )((llba >> 16) & 255UL);
#line 566
    rcCmdBlk[8] = (unsigned char )((llba >> 8) & 255UL);
#line 567
    rcCmdBlk[9] = (unsigned char )(llba & 255UL);
  }
#line 570
  rcCmdBlk[10] = (unsigned char )((mx_resp_len >> 24) & 255);
#line 571
  rcCmdBlk[11] = (unsigned char )((mx_resp_len >> 16) & 255);
#line 572
  rcCmdBlk[12] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 573
  rcCmdBlk[13] = (unsigned char )(mx_resp_len & 255);
#line 574
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 575
    sg_warnings_strm = stderr;
  }
#line 576
  if (verbose) {
    {
#line 577
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    read capacity (16) cdb: ");
#line 578
    k = 0;
    }
    {
#line 578
    while (1) {
      while_continue: /* CIL Label */ ;
#line 578
      if (! (k < 16)) {
#line 578
        goto while_break;
      }
      {
#line 579
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rcCmdBlk[k]);
#line 578
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 580
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 582
  ptvp = construct_scsi_pt_obj();
  }
#line 583
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 584
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"read capacity (16): out of memory\n");
    }
#line 585
    return (-1);
  }
  {
#line 587
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rcCmdBlk), (int )sizeof(rcCmdBlk));
#line 588
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 589
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 590
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 591
  ret = sg_cmds_process_resp(ptvp, "read capacity (16)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 593
  if (! (-1 == ret)) {
#line 595
    if (-2 == ret) {
      {
#line 601
      if (sense_cat == 11) {
#line 601
        goto case_11;
      }
#line 601
      if (sense_cat == 5) {
#line 601
        goto case_11;
      }
#line 601
      if (sense_cat == 9) {
#line 601
        goto case_11;
      }
#line 601
      if (sense_cat == 6) {
#line 601
        goto case_11;
      }
#line 601
      if (sense_cat == 2) {
#line 601
        goto case_11;
      }
#line 605
      if (sense_cat == 20) {
#line 605
        goto case_20;
      }
#line 605
      if (sense_cat == 21) {
#line 605
        goto case_20;
      }
#line 608
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 602
      ret = sense_cat;
#line 603
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 606
      ret = 0;
#line 607
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 609
      ret = -1;
#line 610
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 613
      ret = 0;
    }
  }
  {
#line 615
  destruct_scsi_pt_obj(ptvp);
  }
#line 616
  return (ret);
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_readcap_10(int sg_fd , int pmi , unsigned int lba , void *resp , int mx_resp_len ,
                     int noisy , int verbose ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rcCmdBlk[10] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 629
  rcCmdBlk[0] = (unsigned char)37;
#line 629
  rcCmdBlk[1] = (unsigned char)0;
#line 629
  rcCmdBlk[2] = (unsigned char)0;
#line 629
  rcCmdBlk[3] = (unsigned char)0;
#line 629
  rcCmdBlk[4] = (unsigned char)0;
#line 629
  rcCmdBlk[5] = (unsigned char)0;
#line 629
  rcCmdBlk[6] = (unsigned char)0;
#line 629
  rcCmdBlk[7] = (unsigned char)0;
#line 629
  rcCmdBlk[8] = (unsigned char)0;
#line 629
  rcCmdBlk[9] = (unsigned char)0;
#line 634
  if (pmi) {
#line 635
    rcCmdBlk[8] = (unsigned char )((int )rcCmdBlk[8] | 1);
#line 636
    rcCmdBlk[2] = (unsigned char )((lba >> 24) & 255U);
#line 637
    rcCmdBlk[3] = (unsigned char )((lba >> 16) & 255U);
#line 638
    rcCmdBlk[4] = (unsigned char )((lba >> 8) & 255U);
#line 639
    rcCmdBlk[5] = (unsigned char )(lba & 255U);
  }
#line 641
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 642
    sg_warnings_strm = stderr;
  }
#line 643
  if (verbose) {
    {
#line 644
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    read capacity (10) cdb: ");
#line 645
    k = 0;
    }
    {
#line 645
    while (1) {
      while_continue: /* CIL Label */ ;
#line 645
      if (! (k < 10)) {
#line 645
        goto while_break;
      }
      {
#line 646
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rcCmdBlk[k]);
#line 645
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 647
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 649
  ptvp = construct_scsi_pt_obj();
  }
#line 650
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 651
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"read capacity (10): out of memory\n");
    }
#line 652
    return (-1);
  }
  {
#line 654
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rcCmdBlk), (int )sizeof(rcCmdBlk));
#line 655
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 656
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 657
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 658
  ret = sg_cmds_process_resp(ptvp, "read capacity (10)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 660
  if (! (-1 == ret)) {
#line 662
    if (-2 == ret) {
      {
#line 668
      if (sense_cat == 11) {
#line 668
        goto case_11;
      }
#line 668
      if (sense_cat == 5) {
#line 668
        goto case_11;
      }
#line 668
      if (sense_cat == 9) {
#line 668
        goto case_11;
      }
#line 668
      if (sense_cat == 6) {
#line 668
        goto case_11;
      }
#line 668
      if (sense_cat == 2) {
#line 668
        goto case_11;
      }
#line 672
      if (sense_cat == 20) {
#line 672
        goto case_20;
      }
#line 672
      if (sense_cat == 21) {
#line 672
        goto case_20;
      }
#line 675
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 669
      ret = sense_cat;
#line 670
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 673
      ret = 0;
#line 674
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 676
      ret = -1;
#line 677
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 680
      ret = 0;
    }
  }
  {
#line 682
  destruct_scsi_pt_obj(ptvp);
  }
#line 683
  return (ret);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_sense6(int sg_fd , int dbd , int pc , int pg_code , int sub_pg_code ,
                      void *resp , int mx_resp_len , int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[6] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 696
  modesCmdBlk[0] = (unsigned char)26;
#line 696
  modesCmdBlk[1] = (unsigned char)0;
#line 696
  modesCmdBlk[2] = (unsigned char)0;
#line 696
  modesCmdBlk[3] = (unsigned char)0;
#line 696
  modesCmdBlk[4] = (unsigned char)0;
#line 696
  modesCmdBlk[5] = (unsigned char)0;
#line 701
  if (dbd) {
#line 701
    tmp = 8;
  } else {
#line 701
    tmp = 0;
  }
#line 701
  modesCmdBlk[1] = (unsigned char )tmp;
#line 702
  modesCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 703
  modesCmdBlk[3] = (unsigned char )(sub_pg_code & 255);
#line 704
  modesCmdBlk[4] = (unsigned char )(mx_resp_len & 255);
#line 705
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 706
    sg_warnings_strm = stderr;
  }
#line 707
  if (mx_resp_len > 255) {
    {
#line 708
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len too big\n");
    }
#line 709
    return (-1);
  }
#line 711
  if (verbose) {
    {
#line 712
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (6) cdb: ");
#line 713
    k = 0;
    }
    {
#line 713
    while (1) {
      while_continue: /* CIL Label */ ;
#line 713
      if (! (k < 6)) {
#line 713
        goto while_break;
      }
      {
#line 714
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 713
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 715
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 717
  ptvp = construct_scsi_pt_obj();
  }
#line 718
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 719
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode sense (6): out of memory\n");
    }
#line 720
    return (-1);
  }
  {
#line 722
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 723
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 724
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 725
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 726
  ret = sg_cmds_process_resp(ptvp, "mode sense (6)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 728
  if (! (-1 == ret)) {
#line 730
    if (-2 == ret) {
      {
#line 736
      if (sense_cat == 11) {
#line 736
        goto case_11;
      }
#line 736
      if (sense_cat == 6) {
#line 736
        goto case_11;
      }
#line 736
      if (sense_cat == 5) {
#line 736
        goto case_11;
      }
#line 736
      if (sense_cat == 9) {
#line 736
        goto case_11;
      }
#line 736
      if (sense_cat == 2) {
#line 736
        goto case_11;
      }
#line 740
      if (sense_cat == 20) {
#line 740
        goto case_20;
      }
#line 740
      if (sense_cat == 21) {
#line 740
        goto case_20;
      }
#line 743
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 737
      ret = sense_cat;
#line 738
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 741
      ret = 0;
#line 742
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 744
      ret = -1;
#line 745
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 748
      if (verbose > 2) {
#line 748
        if (ret > 0) {
#line 749
          if (ret > 256) {
#line 749
            tmp___0 = ", first 256 bytes";
          } else {
#line 749
            tmp___0 = "";
          }
          {
#line 749
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (6): response%s\n",
                  tmp___0);
          }
#line 751
          if (ret > 256) {
#line 751
            tmp___1 = 256;
          } else {
#line 751
            tmp___1 = ret;
          }
          {
#line 751
          dStrHex((char const   *)resp, tmp___1, -1);
          }
        }
      }
#line 753
      ret = 0;
    }
  }
  {
#line 755
  destruct_scsi_pt_obj(ptvp);
  }
#line 756
  return (ret);
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_sense10(int sg_fd , int llbaa , int dbd , int pc , int pg_code , int sub_pg_code ,
                       void *resp , int mx_resp_len , int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[10] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 770
  modesCmdBlk[0] = (unsigned char)90;
#line 770
  modesCmdBlk[1] = (unsigned char)0;
#line 770
  modesCmdBlk[2] = (unsigned char)0;
#line 770
  modesCmdBlk[3] = (unsigned char)0;
#line 770
  modesCmdBlk[4] = (unsigned char)0;
#line 770
  modesCmdBlk[5] = (unsigned char)0;
#line 770
  modesCmdBlk[6] = (unsigned char)0;
#line 770
  modesCmdBlk[7] = (unsigned char)0;
#line 770
  modesCmdBlk[8] = (unsigned char)0;
#line 770
  modesCmdBlk[9] = (unsigned char)0;
#line 775
  if (dbd) {
#line 775
    tmp = 8;
  } else {
#line 775
    tmp = 0;
  }
#line 775
  if (llbaa) {
#line 775
    tmp___0 = 16;
  } else {
#line 775
    tmp___0 = 0;
  }
#line 775
  modesCmdBlk[1] = (unsigned char )(tmp | tmp___0);
#line 776
  modesCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 777
  modesCmdBlk[3] = (unsigned char )(sub_pg_code & 255);
#line 778
  modesCmdBlk[7] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 779
  modesCmdBlk[8] = (unsigned char )(mx_resp_len & 255);
#line 780
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 781
    sg_warnings_strm = stderr;
  }
#line 782
  if (mx_resp_len > 65535) {
    {
#line 783
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len too big\n");
    }
#line 784
    return (-1);
  }
#line 786
  if (verbose) {
    {
#line 787
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (10) cdb: ");
#line 788
    k = 0;
    }
    {
#line 788
    while (1) {
      while_continue: /* CIL Label */ ;
#line 788
      if (! (k < 10)) {
#line 788
        goto while_break;
      }
      {
#line 789
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 788
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 790
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 792
  ptvp = construct_scsi_pt_obj();
  }
#line 793
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 794
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode sense (10): out of memory\n");
    }
#line 795
    return (-1);
  }
  {
#line 797
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 798
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 799
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 800
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 801
  ret = sg_cmds_process_resp(ptvp, "mode sense (10)", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 803
  if (! (-1 == ret)) {
#line 805
    if (-2 == ret) {
      {
#line 811
      if (sense_cat == 11) {
#line 811
        goto case_11;
      }
#line 811
      if (sense_cat == 6) {
#line 811
        goto case_11;
      }
#line 811
      if (sense_cat == 5) {
#line 811
        goto case_11;
      }
#line 811
      if (sense_cat == 9) {
#line 811
        goto case_11;
      }
#line 811
      if (sense_cat == 2) {
#line 811
        goto case_11;
      }
#line 815
      if (sense_cat == 20) {
#line 815
        goto case_20;
      }
#line 815
      if (sense_cat == 21) {
#line 815
        goto case_20;
      }
#line 818
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 812
      ret = sense_cat;
#line 813
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 816
      ret = 0;
#line 817
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 819
      ret = -1;
#line 820
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 823
      if (verbose > 2) {
#line 823
        if (ret > 0) {
#line 824
          if (ret > 256) {
#line 824
            tmp___1 = ", first 256 bytes";
          } else {
#line 824
            tmp___1 = "";
          }
          {
#line 824
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode sense (10): response%s\n",
                  tmp___1);
          }
#line 826
          if (ret > 256) {
#line 826
            tmp___2 = 256;
          } else {
#line 826
            tmp___2 = ret;
          }
          {
#line 826
          dStrHex((char const   *)resp, tmp___2, -1);
          }
        }
      }
#line 828
      ret = 0;
    }
  }
  {
#line 830
  destruct_scsi_pt_obj(ptvp);
  }
#line 831
  return (ret);
}
}
#line 839 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_select6(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                       int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[6] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 844
  modesCmdBlk[0] = (unsigned char)21;
#line 844
  modesCmdBlk[1] = (unsigned char)0;
#line 844
  modesCmdBlk[2] = (unsigned char)0;
#line 844
  modesCmdBlk[3] = (unsigned char)0;
#line 844
  modesCmdBlk[4] = (unsigned char)0;
#line 844
  modesCmdBlk[5] = (unsigned char)0;
#line 849
  modesCmdBlk[1] = (unsigned char )(((pf << 4) & 16) | (sp & 1));
#line 850
  modesCmdBlk[4] = (unsigned char )(param_len & 255);
#line 851
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 852
    sg_warnings_strm = stderr;
  }
#line 853
  if (param_len > 255) {
    {
#line 854
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (6): param_len too big\n");
    }
#line 855
    return (-1);
  }
#line 857
  if (verbose) {
    {
#line 858
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (6) cdb: ");
#line 859
    k = 0;
    }
    {
#line 859
    while (1) {
      while_continue: /* CIL Label */ ;
#line 859
      if (! (k < 6)) {
#line 859
        goto while_break;
      }
      {
#line 860
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 859
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 861
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 863
  if (verbose > 1) {
    {
#line 864
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (6) parameter list\n");
#line 865
    dStrHex((char const   *)paramp, param_len, -1);
    }
  }
  {
#line 868
  ptvp = construct_scsi_pt_obj();
  }
#line 869
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 870
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (6): out of memory\n");
    }
#line 871
    return (-1);
  }
  {
#line 873
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 874
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 875
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)((unsigned char *)paramp), param_len);
#line 876
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 877
  ret = sg_cmds_process_resp(ptvp, "mode select (6)", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 879
  if (! (-1 == ret)) {
#line 881
    if (-2 == ret) {
      {
#line 887
      if (sense_cat == 11) {
#line 887
        goto case_11;
      }
#line 887
      if (sense_cat == 6) {
#line 887
        goto case_11;
      }
#line 887
      if (sense_cat == 5) {
#line 887
        goto case_11;
      }
#line 887
      if (sense_cat == 9) {
#line 887
        goto case_11;
      }
#line 887
      if (sense_cat == 2) {
#line 887
        goto case_11;
      }
#line 891
      if (sense_cat == 20) {
#line 891
        goto case_20;
      }
#line 891
      if (sense_cat == 21) {
#line 891
        goto case_20;
      }
#line 894
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 888
      ret = sense_cat;
#line 889
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 892
      ret = 0;
#line 893
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 895
      ret = -1;
#line 896
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 899
      ret = 0;
    }
  }
  {
#line 901
  destruct_scsi_pt_obj(ptvp);
  }
#line 902
  return (ret);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_mode_select10(int sg_fd , int pf , int sp , void *paramp , int param_len ,
                        int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char modesCmdBlk[10] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 915
  modesCmdBlk[0] = (unsigned char)85;
#line 915
  modesCmdBlk[1] = (unsigned char)0;
#line 915
  modesCmdBlk[2] = (unsigned char)0;
#line 915
  modesCmdBlk[3] = (unsigned char)0;
#line 915
  modesCmdBlk[4] = (unsigned char)0;
#line 915
  modesCmdBlk[5] = (unsigned char)0;
#line 915
  modesCmdBlk[6] = (unsigned char)0;
#line 915
  modesCmdBlk[7] = (unsigned char)0;
#line 915
  modesCmdBlk[8] = (unsigned char)0;
#line 915
  modesCmdBlk[9] = (unsigned char)0;
#line 920
  modesCmdBlk[1] = (unsigned char )(((pf << 4) & 16) | (sp & 1));
#line 921
  modesCmdBlk[7] = (unsigned char )((param_len >> 8) & 255);
#line 922
  modesCmdBlk[8] = (unsigned char )(param_len & 255);
#line 923
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 924
    sg_warnings_strm = stderr;
  }
#line 925
  if (param_len > 65535) {
    {
#line 926
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (10): param_len too big\n");
    }
#line 927
    return (-1);
  }
#line 929
  if (verbose) {
    {
#line 930
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (10) cdb: ");
#line 931
    k = 0;
    }
    {
#line 931
    while (1) {
      while_continue: /* CIL Label */ ;
#line 931
      if (! (k < 10)) {
#line 931
        goto while_break;
      }
      {
#line 932
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )modesCmdBlk[k]);
#line 931
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 933
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 935
  if (verbose > 1) {
    {
#line 936
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    mode select (10) parameter list\n");
#line 937
    dStrHex((char const   *)paramp, param_len, -1);
    }
  }
  {
#line 940
  ptvp = construct_scsi_pt_obj();
  }
#line 941
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 942
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mode select (10): out of memory\n");
    }
#line 943
    return (-1);
  }
  {
#line 945
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(modesCmdBlk), (int )sizeof(modesCmdBlk));
#line 946
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 947
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)((unsigned char *)paramp), param_len);
#line 948
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 949
  ret = sg_cmds_process_resp(ptvp, "mode select (10)", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 951
  if (! (-1 == ret)) {
#line 953
    if (-2 == ret) {
      {
#line 959
      if (sense_cat == 11) {
#line 959
        goto case_11;
      }
#line 959
      if (sense_cat == 6) {
#line 959
        goto case_11;
      }
#line 959
      if (sense_cat == 5) {
#line 959
        goto case_11;
      }
#line 959
      if (sense_cat == 9) {
#line 959
        goto case_11;
      }
#line 959
      if (sense_cat == 2) {
#line 959
        goto case_11;
      }
#line 963
      if (sense_cat == 20) {
#line 963
        goto case_20;
      }
#line 963
      if (sense_cat == 21) {
#line 963
        goto case_20;
      }
#line 966
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 960
      ret = sense_cat;
#line 961
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 964
      ret = 0;
#line 965
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 967
      ret = -1;
#line 968
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 971
      ret = 0;
    }
  }
  {
#line 973
  destruct_scsi_pt_obj(ptvp);
  }
#line 974
  return (ret);
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_mode_page_offset(unsigned char const   *resp , int resp_len , int mode_sense_6 ,
                        char *err_buff , int err_buff_len ) 
{ 
  int bd_len ;
  int calc_len ;
  int offset ;

  {
#line 991
  if ((unsigned long )((void *)0) == (unsigned long )resp) {
    {
#line 993
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too short: %d\n",
             resp_len);
    }
#line 995
    return (-1);
  } else
#line 991
  if (resp_len < 4) {
    {
#line 993
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too short: %d\n",
             resp_len);
    }
#line 995
    return (-1);
  } else
#line 991
  if (! mode_sense_6) {
#line 991
    if (resp_len < 8) {
      {
#line 993
      snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too short: %d\n",
               resp_len);
      }
#line 995
      return (-1);
    }
  }
#line 997
  if (mode_sense_6) {
#line 998
    calc_len = (int )((int const   )*(resp + 0) + 1);
#line 999
    bd_len = (int )*(resp + 3);
#line 1000
    offset = bd_len + 4;
  } else {
#line 1002
    calc_len = (int )((((int const   )*(resp + 0) << 8) + (int const   )*(resp + 1)) + 2);
#line 1003
    bd_len = (int )(((int const   )*(resp + 6) << 8) + (int const   )*(resp + 7));
#line 1005
    offset = bd_len + 8;
  }
#line 1007
  if (offset + 2 > resp_len) {
    {
#line 1008
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"given response length too small, offset=%d given_len=%d bd_len=%d\n",
             offset, resp_len, bd_len);
#line 1011
    offset = -1;
    }
  } else
#line 1012
  if (offset + 2 > calc_len) {
    {
#line 1013
    snprintf((char */* __restrict  */)err_buff, (size_t )err_buff_len, (char const   */* __restrict  */)"calculated response length too small, offset=%d calc_len=%d bd_len=%d\n",
             offset, calc_len, bd_len);
#line 1016
    offset = -1;
    }
  }
#line 1018
  return (offset);
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_get_mode_page_controls(int sg_fd , int mode6 , int pg_code , int sub_pg_code ,
                              int dbd , int flexible , int mx_mpage_len , int *success_mask ,
                              void **pcontrol_arr , int *reported_len , int verbose ) 
{ 
  int k ;
  int n ;
  int res ;
  int offset ;
  int calc_len ;
  int xfer_len ;
  int resp_mode6 ;
  unsigned char buff[1024] ;
  char ebuff[256] ;
  int first_err ;
  int tmp ;

  {
#line 1047
  first_err = 0;
#line 1049
  if (success_mask) {
#line 1050
    *success_mask = 0;
  }
#line 1051
  if (reported_len) {
#line 1052
    *reported_len = 0;
  }
#line 1053
  if (mx_mpage_len < 4) {
#line 1054
    return (0);
  }
#line 1055
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1056
    sg_warnings_strm = stderr;
  }
  {
#line 1057
  memset((void *)(ebuff), 0, sizeof(ebuff));
#line 1059
  memset((void *)(buff), 0, (size_t )8);
  }
#line 1060
  if (mode6) {
    {
#line 1061
    res = sg_ll_mode_sense6(sg_fd, dbd, 0, pg_code, sub_pg_code, (void *)(buff), 8,
                            0, verbose);
    }
  } else {
    {
#line 1065
    res = sg_ll_mode_sense10(sg_fd, 0, dbd, 0, pg_code, sub_pg_code, (void *)(buff),
                             8, 0, verbose);
    }
  }
#line 1068
  if (0 != res) {
#line 1069
    return (res);
  }
#line 1070
  n = (int )buff[0];
#line 1071
  if (reported_len) {
#line 1072
    if (mode6) {
#line 1072
      *reported_len = n + 1;
    } else {
#line 1072
      *reported_len = ((n << 8) + (int )buff[1]) + 2;
    }
  }
#line 1073
  resp_mode6 = mode6;
#line 1074
  if (flexible) {
#line 1075
    if (mode6) {
#line 1075
      if (n < 3) {
#line 1076
        resp_mode6 = 0;
#line 1077
        if (verbose) {
          {
#line 1078
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)">>> msense(6) but resp[0]=%d so try msense(10) response processing\n",
                  n);
          }
        }
      }
    }
#line 1081
    if (0 == mode6) {
#line 1081
      if (n > 5) {
#line 1082
        if (n > 11) {
#line 1082
          if (0 == n % 2) {
#line 1082
            if (0 == (int )buff[4]) {
#line 1082
              if (0 == (int )buff[5]) {
#line 1082
                if (0 == (int )buff[6]) {
#line 1084
                  buff[1] = (unsigned char )n;
#line 1085
                  buff[0] = (unsigned char)0;
#line 1086
                  if (verbose) {
                    {
#line 1087
                    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)">>> msense(10) but resp[0]=%d and not msense(6) response so fix length\n",
                            n);
                    }
                  }
                } else {
#line 1090
                  resp_mode6 = 1;
                }
              } else {
#line 1090
                resp_mode6 = 1;
              }
            } else {
#line 1090
              resp_mode6 = 1;
            }
          } else {
#line 1090
            resp_mode6 = 1;
          }
        } else {
#line 1090
          resp_mode6 = 1;
        }
      }
    }
  }
#line 1093
  if (verbose) {
#line 1093
    if (resp_mode6 != mode6) {
#line 1094
      if (mode6) {
#line 1094
        tmp = 6;
      } else {
#line 1094
        tmp = 10;
      }
      {
#line 1094
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)">>> msense(%d) but resp[0]=%d so switch response processing\n",
              tmp, (int )buff[0]);
      }
    }
  }
#line 1097
  if (resp_mode6) {
#line 1097
    calc_len = (int )buff[0] + 1;
  } else {
#line 1097
    calc_len = (((int )buff[0] << 8) + (int )buff[1]) + 2;
  }
#line 1098
  if (calc_len > 1024) {
#line 1099
    calc_len = 1024;
  }
  {
#line 1100
  offset = sg_mode_page_offset((unsigned char const   *)(buff), calc_len, resp_mode6,
                               ebuff, 256);
  }
#line 1102
  if (offset < 0) {
#line 1103
    if (0 != (int )ebuff[0]) {
#line 1103
      if (verbose > 0) {
        {
#line 1104
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"sg_get_mode_page_controls: %s\n",
                ebuff);
        }
      }
    }
#line 1106
    return (97);
  }
#line 1108
  xfer_len = calc_len - offset;
#line 1109
  if (xfer_len > mx_mpage_len) {
#line 1110
    xfer_len = mx_mpage_len;
  }
#line 1112
  k = 0;
  {
#line 1112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1112
    if (! (k < 4)) {
#line 1112
      goto while_break;
    }
#line 1113
    if ((unsigned long )((void *)0) == (unsigned long )*(pcontrol_arr + k)) {
#line 1114
      goto __Cont;
    }
    {
#line 1115
    memset(*(pcontrol_arr + k), 0, (size_t )mx_mpage_len);
    }
#line 1116
    if (mode6) {
      {
#line 1117
      res = sg_ll_mode_sense6(sg_fd, dbd, k, pg_code, sub_pg_code, (void *)(buff),
                              calc_len, 0, verbose);
      }
    } else {
      {
#line 1121
      res = sg_ll_mode_sense10(sg_fd, 0, dbd, k, pg_code, sub_pg_code, (void *)(buff),
                               calc_len, 0, verbose);
      }
    }
#line 1124
    if (0 != res) {
#line 1125
      if (0 == first_err) {
#line 1126
        first_err = res;
      }
#line 1127
      if (0 == k) {
#line 1128
        goto while_break;
      } else {
#line 1130
        goto __Cont;
      }
    }
#line 1132
    if (xfer_len > 0) {
      {
#line 1133
      memcpy((void */* __restrict  */)*(pcontrol_arr + k), (void const   */* __restrict  */)(buff + offset),
             (size_t )xfer_len);
      }
    }
#line 1134
    if (success_mask) {
#line 1135
      *success_mask |= 1 << k;
    }
    __Cont: /* CIL Label */ 
#line 1112
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1137
  return (first_err);
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_request_sense(int sg_fd , int desc , void *resp , int mx_resp_len , int noisy ,
                        int verbose ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rsCmdBlk[6] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 1149
  rsCmdBlk[0] = (unsigned char)3;
#line 1149
  rsCmdBlk[1] = (unsigned char)0;
#line 1149
  rsCmdBlk[2] = (unsigned char)0;
#line 1149
  rsCmdBlk[3] = (unsigned char)0;
#line 1149
  rsCmdBlk[4] = (unsigned char)0;
#line 1149
  rsCmdBlk[5] = (unsigned char)0;
#line 1154
  if (desc) {
#line 1155
    rsCmdBlk[1] = (unsigned char )((int )rsCmdBlk[1] | 1);
  }
#line 1156
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1157
    sg_warnings_strm = stderr;
  }
#line 1158
  if (mx_resp_len > 255) {
    {
#line 1159
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len cannot exceed 255\n");
    }
#line 1160
    return (-1);
  }
#line 1162
  rsCmdBlk[4] = (unsigned char )(mx_resp_len & 255);
#line 1163
  if (verbose) {
    {
#line 1164
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Request Sense cmd: ");
#line 1165
    k = 0;
    }
    {
#line 1165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1165
      if (! (k < 6)) {
#line 1165
        goto while_break;
      }
      {
#line 1166
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rsCmdBlk[k]);
#line 1165
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1167
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1170
  ptvp = construct_scsi_pt_obj();
  }
#line 1171
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1172
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"request sense: out of memory\n");
    }
#line 1173
    return (-1);
  }
  {
#line 1175
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rsCmdBlk), (int )sizeof(rsCmdBlk));
#line 1176
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1177
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 1178
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 1179
  ret = sg_cmds_process_resp(ptvp, "request sense", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 1181
  if (! (-1 == ret)) {
#line 1183
    if (-2 == ret) {
      {
#line 1187
      if (sense_cat == 11) {
#line 1187
        goto case_11;
      }
#line 1187
      if (sense_cat == 5) {
#line 1187
        goto case_11;
      }
#line 1187
      if (sense_cat == 9) {
#line 1187
        goto case_11;
      }
#line 1191
      if (sense_cat == 20) {
#line 1191
        goto case_20;
      }
#line 1191
      if (sense_cat == 21) {
#line 1191
        goto case_20;
      }
#line 1195
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1188
      ret = sense_cat;
#line 1189
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1192
      ret = 0;
#line 1193
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1196
      ret = -1;
#line 1197
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 1200
    if (mx_resp_len >= 8) {
#line 1200
      if (ret < 8) {
#line 1201
        if (verbose) {
          {
#line 1202
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    request sense: got %d bytes in response, too short\n",
                  ret);
          }
        }
#line 1204
        ret = -1;
      } else {
#line 1206
        ret = 0;
      }
    } else {
#line 1206
      ret = 0;
    }
  }
  {
#line 1208
  destruct_scsi_pt_obj(ptvp);
  }
#line 1209
  return (ret);
}
}
#line 1217 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_report_luns(int sg_fd , int select_report , void *resp , int mx_resp_len ,
                      int noisy , int verbose ) 
{ 
  int k ;
  int ret ;
  int res ;
  int sense_cat ;
  unsigned char rlCmdBlk[12] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 1222
  rlCmdBlk[0] = (unsigned char)160;
#line 1222
  rlCmdBlk[1] = (unsigned char)0;
#line 1222
  rlCmdBlk[2] = (unsigned char)0;
#line 1222
  rlCmdBlk[3] = (unsigned char)0;
#line 1222
  rlCmdBlk[4] = (unsigned char)0;
#line 1222
  rlCmdBlk[5] = (unsigned char)0;
#line 1222
  rlCmdBlk[6] = (unsigned char)0;
#line 1222
  rlCmdBlk[7] = (unsigned char)0;
#line 1222
  rlCmdBlk[8] = (unsigned char)0;
#line 1222
  rlCmdBlk[9] = (unsigned char)0;
#line 1222
  rlCmdBlk[10] = (unsigned char)0;
#line 1222
  rlCmdBlk[11] = (unsigned char)0;
#line 1227
  rlCmdBlk[2] = (unsigned char )(select_report & 255);
#line 1228
  rlCmdBlk[6] = (unsigned char )((mx_resp_len >> 24) & 255);
#line 1229
  rlCmdBlk[7] = (unsigned char )((mx_resp_len >> 16) & 255);
#line 1230
  rlCmdBlk[8] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 1231
  rlCmdBlk[9] = (unsigned char )(mx_resp_len & 255);
#line 1232
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1233
    sg_warnings_strm = stderr;
  }
#line 1234
  if (verbose) {
    {
#line 1235
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    report luns cdb: ");
#line 1236
    k = 0;
    }
    {
#line 1236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1236
      if (! (k < 12)) {
#line 1236
        goto while_break;
      }
      {
#line 1237
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )rlCmdBlk[k]);
#line 1236
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1238
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1241
  ptvp = construct_scsi_pt_obj();
  }
#line 1242
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1243
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"report luns: out of memory\n");
    }
#line 1244
    return (-1);
  }
  {
#line 1246
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(rlCmdBlk), (int )sizeof(rlCmdBlk));
#line 1247
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1248
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 1249
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 1250
  ret = sg_cmds_process_resp(ptvp, "report luns", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 1252
  if (! (-1 == ret)) {
#line 1254
    if (-2 == ret) {
      {
#line 1259
      if (sense_cat == 2) {
#line 1259
        goto case_2;
      }
#line 1259
      if (sense_cat == 11) {
#line 1259
        goto case_2;
      }
#line 1259
      if (sense_cat == 5) {
#line 1259
        goto case_2;
      }
#line 1259
      if (sense_cat == 9) {
#line 1259
        goto case_2;
      }
#line 1263
      if (sense_cat == 20) {
#line 1263
        goto case_20;
      }
#line 1263
      if (sense_cat == 21) {
#line 1263
        goto case_20;
      }
#line 1266
      goto switch_default;
      case_2: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 1260
      ret = sense_cat;
#line 1261
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1264
      ret = 0;
#line 1265
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1267
      ret = -1;
#line 1268
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1271
      ret = 0;
    }
  }
  {
#line 1272
  destruct_scsi_pt_obj(ptvp);
  }
#line 1273
  return (ret);
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_log_sense(int sg_fd , int ppc , int sp , int pc , int pg_code , int subpg_code ,
                    int paramp , unsigned char *resp , int mx_resp_len , int noisy ,
                    int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char logsCmdBlk[10] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1287
  logsCmdBlk[0] = (unsigned char)77;
#line 1287
  logsCmdBlk[1] = (unsigned char)0;
#line 1287
  logsCmdBlk[2] = (unsigned char)0;
#line 1287
  logsCmdBlk[3] = (unsigned char)0;
#line 1287
  logsCmdBlk[4] = (unsigned char)0;
#line 1287
  logsCmdBlk[5] = (unsigned char)0;
#line 1287
  logsCmdBlk[6] = (unsigned char)0;
#line 1287
  logsCmdBlk[7] = (unsigned char)0;
#line 1287
  logsCmdBlk[8] = (unsigned char)0;
#line 1287
  logsCmdBlk[9] = (unsigned char)0;
#line 1292
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1293
    sg_warnings_strm = stderr;
  }
#line 1294
  if (mx_resp_len > 65535) {
    {
#line 1295
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"mx_resp_len too big\n");
    }
#line 1296
    return (-1);
  }
#line 1298
  if (ppc) {
#line 1298
    tmp = 2;
  } else {
#line 1298
    tmp = 0;
  }
#line 1298
  if (sp) {
#line 1298
    tmp___0 = 1;
  } else {
#line 1298
    tmp___0 = 0;
  }
#line 1298
  logsCmdBlk[1] = (unsigned char )(tmp | tmp___0);
#line 1299
  logsCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 1300
  logsCmdBlk[3] = (unsigned char )(subpg_code & 255);
#line 1301
  logsCmdBlk[5] = (unsigned char )((paramp >> 8) & 255);
#line 1302
  logsCmdBlk[6] = (unsigned char )(paramp & 255);
#line 1303
  logsCmdBlk[7] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 1304
  logsCmdBlk[8] = (unsigned char )(mx_resp_len & 255);
#line 1305
  if (verbose) {
    {
#line 1306
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    log sense cdb: ");
#line 1307
    k = 0;
    }
    {
#line 1307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1307
      if (! (k < 10)) {
#line 1307
        goto while_break;
      }
      {
#line 1308
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )logsCmdBlk[k]);
#line 1307
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1309
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1312
  ptvp = construct_scsi_pt_obj();
  }
#line 1313
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1314
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"log sense: out of memory\n");
    }
#line 1315
    return (-1);
  }
  {
#line 1317
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(logsCmdBlk), (int )sizeof(logsCmdBlk));
#line 1318
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1319
  set_scsi_pt_data_in(ptvp, resp, mx_resp_len);
#line 1320
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 1321
  ret = sg_cmds_process_resp(ptvp, "log sense", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 1323
  if (! (-1 == ret)) {
#line 1325
    if (-2 == ret) {
      {
#line 1331
      if (sense_cat == 11) {
#line 1331
        goto case_11;
      }
#line 1331
      if (sense_cat == 6) {
#line 1331
        goto case_11;
      }
#line 1331
      if (sense_cat == 5) {
#line 1331
        goto case_11;
      }
#line 1331
      if (sense_cat == 9) {
#line 1331
        goto case_11;
      }
#line 1331
      if (sense_cat == 2) {
#line 1331
        goto case_11;
      }
#line 1335
      if (sense_cat == 20) {
#line 1335
        goto case_20;
      }
#line 1335
      if (sense_cat == 21) {
#line 1335
        goto case_20;
      }
#line 1338
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1332
      ret = sense_cat;
#line 1333
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1336
      ret = 0;
#line 1337
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1339
      ret = -1;
#line 1340
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1343
      if (mx_resp_len > 3) {
#line 1343
        if (ret < 4) {
#line 1345
          *(resp + 2) = (unsigned char)0;
#line 1346
          *(resp + 3) = (unsigned char)0;
        }
      }
#line 1348
      ret = 0;
    }
  }
  {
#line 1350
  destruct_scsi_pt_obj(ptvp);
  }
#line 1351
  return (ret);
}
}
#line 1359 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_log_select(int sg_fd , int pcr , int sp , int pc , int pg_code , int subpg_code ,
                     unsigned char *paramp , int param_len , int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char logsCmdBlk[10] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1365
  logsCmdBlk[0] = (unsigned char)76;
#line 1365
  logsCmdBlk[1] = (unsigned char)0;
#line 1365
  logsCmdBlk[2] = (unsigned char)0;
#line 1365
  logsCmdBlk[3] = (unsigned char)0;
#line 1365
  logsCmdBlk[4] = (unsigned char)0;
#line 1365
  logsCmdBlk[5] = (unsigned char)0;
#line 1365
  logsCmdBlk[6] = (unsigned char)0;
#line 1365
  logsCmdBlk[7] = (unsigned char)0;
#line 1365
  logsCmdBlk[8] = (unsigned char)0;
#line 1365
  logsCmdBlk[9] = (unsigned char)0;
#line 1370
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1371
    sg_warnings_strm = stderr;
  }
#line 1372
  if (param_len > 65535) {
    {
#line 1373
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"log select: param_len too big\n");
    }
#line 1374
    return (-1);
  }
#line 1376
  if (pcr) {
#line 1376
    tmp = 2;
  } else {
#line 1376
    tmp = 0;
  }
#line 1376
  if (sp) {
#line 1376
    tmp___0 = 1;
  } else {
#line 1376
    tmp___0 = 0;
  }
#line 1376
  logsCmdBlk[1] = (unsigned char )(tmp | tmp___0);
#line 1377
  logsCmdBlk[2] = (unsigned char )(((pc << 6) & 192) | (pg_code & 63));
#line 1378
  logsCmdBlk[3] = (unsigned char )(subpg_code & 255);
#line 1379
  logsCmdBlk[7] = (unsigned char )((param_len >> 8) & 255);
#line 1380
  logsCmdBlk[8] = (unsigned char )(param_len & 255);
#line 1381
  if (verbose) {
    {
#line 1382
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    log select cdb: ");
#line 1383
    k = 0;
    }
    {
#line 1383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1383
      if (! (k < 10)) {
#line 1383
        goto while_break;
      }
      {
#line 1384
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )logsCmdBlk[k]);
#line 1383
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1385
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
#line 1387
  if (verbose > 1) {
#line 1387
    if (param_len > 0) {
      {
#line 1388
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    log select parameter list\n");
#line 1389
      dStrHex((char const   *)paramp, param_len, -1);
      }
    }
  }
  {
#line 1392
  ptvp = construct_scsi_pt_obj();
  }
#line 1393
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1394
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"log select: out of memory\n");
    }
#line 1395
    return (-1);
  }
  {
#line 1397
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(logsCmdBlk), (int )sizeof(logsCmdBlk));
#line 1398
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1399
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)paramp, param_len);
#line 1400
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 1401
  ret = sg_cmds_process_resp(ptvp, "log select", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 1403
  if (! (-1 == ret)) {
#line 1405
    if (-2 == ret) {
      {
#line 1411
      if (sense_cat == 11) {
#line 1411
        goto case_11;
      }
#line 1411
      if (sense_cat == 6) {
#line 1411
        goto case_11;
      }
#line 1411
      if (sense_cat == 5) {
#line 1411
        goto case_11;
      }
#line 1411
      if (sense_cat == 9) {
#line 1411
        goto case_11;
      }
#line 1411
      if (sense_cat == 2) {
#line 1411
        goto case_11;
      }
#line 1415
      if (sense_cat == 20) {
#line 1415
        goto case_20;
      }
#line 1415
      if (sense_cat == 21) {
#line 1415
        goto case_20;
      }
#line 1418
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1412
      ret = sense_cat;
#line 1413
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1416
      ret = 0;
#line 1417
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1419
      ret = -1;
#line 1420
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1423
      ret = 0;
    }
  }
  {
#line 1425
  destruct_scsi_pt_obj(ptvp);
  }
#line 1426
  return (ret);
}
}
#line 1440 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_start_stop_unit(int sg_fd , int immed , int pc_mod__fl_num , int power_cond ,
                          int noflush__fl , int loej , int start , int noisy , int verbose ) 
{ 
  unsigned char ssuBlk[6] ;
  unsigned char sense_b[64] ;
  int k ;
  int res ;
  int ret ;
  int sense_cat ;
  struct sg_pt_base *ptvp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1445
  ssuBlk[0] = (unsigned char)27;
#line 1445
  ssuBlk[1] = (unsigned char)0;
#line 1445
  ssuBlk[2] = (unsigned char)0;
#line 1445
  ssuBlk[3] = (unsigned char)0;
#line 1445
  ssuBlk[4] = (unsigned char)0;
#line 1445
  ssuBlk[5] = (unsigned char)0;
#line 1450
  ssuBlk[1] = (unsigned char )(immed & 1);
#line 1451
  ssuBlk[3] = (unsigned char )(pc_mod__fl_num & 15);
#line 1452
  if (noflush__fl) {
#line 1452
    tmp = 4;
  } else {
#line 1452
    tmp = 0;
  }
#line 1452
  if (loej) {
#line 1452
    tmp___0 = 2;
  } else {
#line 1452
    tmp___0 = 0;
  }
#line 1452
  if (start) {
#line 1452
    tmp___1 = 1;
  } else {
#line 1452
    tmp___1 = 0;
  }
#line 1452
  ssuBlk[4] = (unsigned char )(((((power_cond & 15) << 4) | tmp) | tmp___0) | tmp___1);
#line 1454
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1455
    sg_warnings_strm = stderr;
  }
#line 1456
  if (verbose) {
    {
#line 1457
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Start stop unit command:");
#line 1458
    k = 0;
    }
    {
#line 1458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1458
      if (! (k < (int )sizeof(ssuBlk))) {
#line 1458
        goto while_break;
      }
      {
#line 1459
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)" %02x",
              (int )ssuBlk[k]);
#line 1458
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1460
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1463
  ptvp = construct_scsi_pt_obj();
  }
#line 1464
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1465
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"start stop unit: out of memory\n");
    }
#line 1466
    return (-1);
  }
  {
#line 1468
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(ssuBlk), (int )sizeof(ssuBlk));
#line 1469
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1470
  res = do_scsi_pt(ptvp, sg_fd, 120, verbose);
#line 1471
  ret = sg_cmds_process_resp(ptvp, "start stop unit", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 1473
  if (! (-1 == ret)) {
#line 1475
    if (-2 == ret) {
      {
#line 1481
      if (sense_cat == 11) {
#line 1481
        goto case_11;
      }
#line 1481
      if (sense_cat == 6) {
#line 1481
        goto case_11;
      }
#line 1481
      if (sense_cat == 5) {
#line 1481
        goto case_11;
      }
#line 1481
      if (sense_cat == 9) {
#line 1481
        goto case_11;
      }
#line 1481
      if (sense_cat == 2) {
#line 1481
        goto case_11;
      }
#line 1485
      if (sense_cat == 20) {
#line 1485
        goto case_20;
      }
#line 1485
      if (sense_cat == 21) {
#line 1485
        goto case_20;
      }
#line 1488
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1482
      ret = sense_cat;
#line 1483
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1486
      ret = 0;
#line 1487
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1489
      ret = -1;
#line 1490
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1493
      ret = 0;
    }
  }
  {
#line 1494
  destruct_scsi_pt_obj(ptvp);
  }
#line 1495
  return (ret);
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_basic.c"
int sg_ll_prevent_allow(int sg_fd , int prevent , int noisy , int verbose ) 
{ 
  int k ;
  int res ;
  int ret ;
  int sense_cat ;
  unsigned char pCmdBlk[6] ;
  unsigned char sense_b[64] ;
  struct sg_pt_base *ptvp ;

  {
#line 1510
  pCmdBlk[0] = (unsigned char)30;
#line 1510
  pCmdBlk[1] = (unsigned char)0;
#line 1510
  pCmdBlk[2] = (unsigned char)0;
#line 1510
  pCmdBlk[3] = (unsigned char)0;
#line 1510
  pCmdBlk[4] = (unsigned char)0;
#line 1510
  pCmdBlk[5] = (unsigned char)0;
#line 1515
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1516
    sg_warnings_strm = stderr;
  }
#line 1517
  if (prevent < 0) {
    {
#line 1518
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"prevent argument should be 0, 1, 2 or 3\n");
    }
#line 1519
    return (-1);
  } else
#line 1517
  if (prevent > 3) {
    {
#line 1518
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"prevent argument should be 0, 1, 2 or 3\n");
    }
#line 1519
    return (-1);
  }
#line 1521
  pCmdBlk[4] = (unsigned char )((int )pCmdBlk[4] | (prevent & 3));
#line 1522
  if (verbose) {
    {
#line 1523
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Prevent allow medium removal cdb: ");
#line 1524
    k = 0;
    }
    {
#line 1524
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1524
      if (! (k < 6)) {
#line 1524
        goto while_break;
      }
      {
#line 1525
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )pCmdBlk[k]);
#line 1524
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1526
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 1529
  ptvp = construct_scsi_pt_obj();
  }
#line 1530
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 1531
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"prevent allow medium removal: out of memory\n");
    }
#line 1533
    return (-1);
  }
  {
#line 1535
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(pCmdBlk), (int )sizeof(pCmdBlk));
#line 1536
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 1537
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 1538
  ret = sg_cmds_process_resp(ptvp, "prevent allow medium removal", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 1540
  if (! (-1 == ret)) {
#line 1542
    if (-2 == ret) {
      {
#line 1548
      if (sense_cat == 11) {
#line 1548
        goto case_11;
      }
#line 1548
      if (sense_cat == 6) {
#line 1548
        goto case_11;
      }
#line 1548
      if (sense_cat == 5) {
#line 1548
        goto case_11;
      }
#line 1548
      if (sense_cat == 9) {
#line 1548
        goto case_11;
      }
#line 1548
      if (sense_cat == 2) {
#line 1548
        goto case_11;
      }
#line 1552
      if (sense_cat == 20) {
#line 1552
        goto case_20;
      }
#line 1552
      if (sense_cat == 21) {
#line 1552
        goto case_20;
      }
#line 1555
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 1549
      ret = sense_cat;
#line 1550
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 1553
      ret = 0;
#line 1554
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1556
      ret = -1;
#line 1557
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1560
      ret = 0;
    }
  }
  {
#line 1561
  destruct_scsi_pt_obj(ptvp);
  }
#line 1562
  return (ret);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 107 "../include/sg_lib.h"
char const   *sg_lib_version(void) ;
#line 112
int sg_get_command_size(unsigned char opcode ) ;
#line 117
void sg_get_command_name(unsigned char const   *cmdp , int peri_type , int buff_len ,
                         char *buff ) ;
#line 122
void sg_get_opcode_name(unsigned char cmd_byte0 , int peri_type , int buff_len , char *buff ) ;
#line 127
void sg_get_opcode_sa_name(unsigned char cmd_byte0 , int service_action , int peri_type ,
                           int buff_len , char *buff ) ;
#line 157
int sg_scsi_normalize_sense(unsigned char const   *sensep , int sb_len , struct sg_scsi_sense_hdr *sshp ) ;
#line 164
unsigned char const   *sg_scsi_sense_desc_find(unsigned char const   *sensep , int sense_len ,
                                               int desc_type ) ;
#line 168
char *sg_get_sense_key_str(int sense_key , int buff_len , char *buff ) ;
#line 171
char *sg_get_asc_ascq_str(int asc , int ascq , int buff_len , char *buff ) ;
#line 177
int sg_get_sense_info_fld(unsigned char const   *sensep , int sb_len , uint64_t *info_outp ) ;
#line 184
int sg_get_sense_filemark_eom_ili(unsigned char const   *sensep , int sb_len , int *filemark_p ,
                                  int *eom_p , int *ili_p ) ;
#line 214
void sg_set_warnings_strm(FILE *warnings_strm ) ;
#line 218
void sg_print_command(unsigned char const   *command ) ;
#line 219
void sg_print_sense(char const   *leadin , unsigned char const   *sense_buffer , int sb_len ,
                    int raw_sinfo ) ;
#line 222
void sg_print_scsi_status(int scsi_status ) ;
#line 338
int sg_get_num(char const   *buf ) ;
#line 351
int64_t sg_get_llnum(char const   *buf ) ;
#line 359
int sg_set_text_mode(int fd ) ;
#line 363
int sg_set_binary_mode(int fd ) ;
#line 57 "../include/sg_lib_data.h"
char const   *sg_lib_version_str ;
#line 59
struct sg_lib_value_name_t sg_lib_normal_opcodes[182] ;
#line 60
struct sg_lib_value_name_t sg_lib_maint_in_arr[9] ;
#line 61
struct sg_lib_value_name_t sg_lib_maint_out_arr[7] ;
#line 62
struct sg_lib_value_name_t sg_lib_pr_in_arr[5] ;
#line 63
struct sg_lib_value_name_t sg_lib_pr_out_arr[9] ;
#line 64
struct sg_lib_value_name_t sg_lib_serv_in12_arr[2] ;
#line 65
struct sg_lib_value_name_t sg_lib_serv_out12_arr[2] ;
#line 66
struct sg_lib_value_name_t sg_lib_serv_in16_arr[5] ;
#line 67
struct sg_lib_value_name_t sg_lib_serv_out16_arr[3] ;
#line 68
struct sg_lib_value_name_t sg_lib_variable_length_arr[70] ;
#line 69
struct sg_lib_asc_ascq_range_t sg_lib_asc_ascq_range[7] ;
#line 70
struct sg_lib_asc_ascq_t sg_lib_asc_ascq[648] ;
#line 71
char const   *sg_lib_sense_key_desc[16] ;
#line 72
char const   *sg_lib_pdt_strs[32] ;
#line 73
char const   *sg_lib_transport_proto_strs[16] ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
FILE *sg_warnings_strm  =    (FILE *)((void *)0);
#line 48
static void dStrHexErr(char const   *str , int len , int b_len , char *b ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static struct sg_lib_value_name_t  const  *get_value_name(struct sg_lib_value_name_t  const  *arr ,
                                                          int value , int peri_type ) 
{ 
  struct sg_lib_value_name_t  const  *vp ;
  struct sg_lib_value_name_t  const  *holdp ;

  {
#line 58
  vp = arr;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! vp->name) {
#line 61
      goto while_break;
    }
#line 62
    if (value == (int )vp->value) {
#line 63
      if (peri_type == (int )vp->peri_dev_type) {
#line 64
        return (vp);
      }
#line 65
      holdp = vp;
      {
#line 66
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 66
        if ((vp + 1)->name) {
#line 66
          if (! (value == (int )(vp + 1)->value)) {
#line 66
            goto while_break___0;
          }
        } else {
#line 66
          goto while_break___0;
        }
#line 67
        vp ++;
#line 68
        if (peri_type == (int )vp->peri_dev_type) {
#line 69
          return (vp);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 71
      return (holdp);
    }
#line 61
    vp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return ((struct sg_lib_value_name_t  const  *)((void *)0));
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_set_warnings_strm(FILE *warnings_strm ) 
{ 


  {
#line 80
  sg_warnings_strm = warnings_strm;
#line 81
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_print_command(unsigned char const   *command ) 
{ 
  int k ;
  int sz ;
  char buff[128] ;

  {
  {
#line 91
  sg_get_command_name(command, 0, 128, buff);
#line 92
  buff[127] = (char )'\000';
  }
#line 94
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 95
    sg_warnings_strm = stderr;
  }
  {
#line 96
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s [",
          buff);
  }
#line 97
  if (127 == (int )*(command + 0)) {
#line 98
    sz = (int )((int const   )*(command + 7) + 8);
  } else {
    {
#line 100
    sz = sg_get_command_size((unsigned char )*(command + 0));
    }
  }
#line 101
  k = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (k < sz)) {
#line 101
      goto while_break;
    }
    {
#line 102
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
            (int const   )*(command + k));
#line 101
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 103
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"]\n");
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_get_scsi_status_str(int scsi_status , int buff_len , char *buff ) 
{ 
  char const   *ccp ;

  {
#line 111
  scsi_status &= 126;
  {
#line 113
  if (scsi_status == 0) {
#line 113
    goto case_0;
  }
#line 114
  if (scsi_status == 2) {
#line 114
    goto case_2;
  }
#line 115
  if (scsi_status == 4) {
#line 115
    goto case_4;
  }
#line 116
  if (scsi_status == 8) {
#line 116
    goto case_8;
  }
#line 117
  if (scsi_status == 16) {
#line 117
    goto case_16;
  }
#line 118
  if (scsi_status == 20) {
#line 118
    goto case_20;
  }
#line 119
  if (scsi_status == 24) {
#line 119
    goto case_24;
  }
#line 120
  if (scsi_status == 34) {
#line 120
    goto case_34;
  }
#line 121
  if (scsi_status == 40) {
#line 121
    goto case_40;
  }
#line 122
  if (scsi_status == 48) {
#line 122
    goto case_48;
  }
#line 123
  if (scsi_status == 64) {
#line 123
    goto case_64;
  }
#line 124
  goto switch_default;
  case_0: /* CIL Label */ 
#line 113
  ccp = "Good";
#line 113
  goto switch_break;
  case_2: /* CIL Label */ 
#line 114
  ccp = "Check Condition";
#line 114
  goto switch_break;
  case_4: /* CIL Label */ 
#line 115
  ccp = "Condition Met";
#line 115
  goto switch_break;
  case_8: /* CIL Label */ 
#line 116
  ccp = "Busy";
#line 116
  goto switch_break;
  case_16: /* CIL Label */ 
#line 117
  ccp = "Intermediate (obsolete)";
#line 117
  goto switch_break;
  case_20: /* CIL Label */ 
#line 118
  ccp = "Intermediate-Condition Met (obs)";
#line 118
  goto switch_break;
  case_24: /* CIL Label */ 
#line 119
  ccp = "Reservation Conflict";
#line 119
  goto switch_break;
  case_34: /* CIL Label */ 
#line 120
  ccp = "Command Terminated (obsolete)";
#line 120
  goto switch_break;
  case_40: /* CIL Label */ 
#line 121
  ccp = "Task set Full";
#line 121
  goto switch_break;
  case_48: /* CIL Label */ 
#line 122
  ccp = "ACA Active";
#line 122
  goto switch_break;
  case_64: /* CIL Label */ 
#line 123
  ccp = "Task Aborted";
#line 123
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 124
  ccp = "Unknown status";
#line 124
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 126
  strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)ccp, (size_t )buff_len);
  }
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_print_scsi_status(int scsi_status ) 
{ 
  char buff[128] ;

  {
  {
#line 134
  sg_get_scsi_status_str(scsi_status, (int )(sizeof(buff) - 1UL), buff);
#line 135
  buff[sizeof(buff) - 1UL] = (char )'\000';
  }
#line 136
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 137
    sg_warnings_strm = stderr;
  }
  {
#line 138
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s ",
          buff);
  }
#line 139
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
char *sg_get_sense_key_str(int sense_key , int buff_len , char *buff ) 
{ 


  {
#line 145
  if (sense_key >= 0) {
#line 145
    if (sense_key < 16) {
      {
#line 146
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
               sg_lib_sense_key_desc[sense_key]);
      }
    } else {
      {
#line 148
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"invalid value: 0x%x",
               sense_key);
      }
    }
  } else {
    {
#line 148
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"invalid value: 0x%x",
             sense_key);
    }
  }
#line 149
  return (buff);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
char *sg_get_asc_ascq_str(int asc , int ascq , int buff_len , char *buff ) 
{ 
  int k ;
  int num ;
  int rlen ;
  int found ;
  struct sg_lib_asc_ascq_t *eip ;
  struct sg_lib_asc_ascq_range_t *ei2p ;
  int tmp ;
  int tmp___0 ;

  {
#line 156
  found = 0;
#line 160
  k = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! sg_lib_asc_ascq_range[k].text) {
#line 160
      goto while_break;
    }
#line 161
    ei2p = & sg_lib_asc_ascq_range[k];
#line 162
    if ((int )ei2p->asc == asc) {
#line 162
      if (ascq >= (int )ei2p->ascq_min) {
#line 162
        if (ascq <= (int )ei2p->ascq_max) {
          {
#line 165
          found = 1;
#line 166
          num = snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Additional sense: ");
#line 167
          rlen = buff_len - num;
          }
#line 168
          if (rlen > 0) {
#line 168
            tmp = rlen;
          } else {
#line 168
            tmp = 0;
          }
          {
#line 168
          tmp___0 = snprintf((char */* __restrict  */)(buff + num), (size_t )tmp,
                             (char const   */* __restrict  */)ei2p->text, ascq);
#line 168
          num += tmp___0;
          }
        }
      }
    }
#line 160
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  if (found) {
#line 173
    return (buff);
  }
#line 175
  k = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! sg_lib_asc_ascq[k].text) {
#line 175
      goto while_break___0;
    }
#line 176
    eip = & sg_lib_asc_ascq[k];
#line 177
    if ((int )eip->asc == asc) {
#line 177
      if ((int )eip->ascq == ascq) {
        {
#line 179
        found = 1;
#line 180
        snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Additional sense: %s",
                 eip->text);
        }
      }
    }
#line 175
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  if (! found) {
#line 184
    if (asc >= 128) {
      {
#line 185
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"vendor specific ASC=%2x, ASCQ=%2x",
               asc, ascq);
      }
    } else
#line 187
    if (ascq >= 128) {
      {
#line 188
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"ASC=%2x, vendor specific qualification ASCQ=%2x",
               asc, ascq);
      }
    } else {
      {
#line 191
      snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"ASC=%2x, ASCQ=%2x",
               asc, ascq);
      }
    }
  }
#line 193
  return (buff);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
unsigned char const   *sg_scsi_sense_desc_find(unsigned char const   *sensep , int sense_len ,
                                               int desc_type ) 
{ 
  int add_sen_len ;
  int add_len ;
  int desc_len ;
  int k ;
  unsigned char const   *descp ;

  {
#line 203
  if (sense_len < 8) {
#line 204
    return ((unsigned char const   *)((void *)0));
  } else {
#line 203
    add_sen_len = (int )*(sensep + 7);
#line 203
    if (0 == add_sen_len) {
#line 204
      return ((unsigned char const   *)((void *)0));
    }
  }
#line 205
  if ((int const   )*(sensep + 0) < 114) {
#line 206
    return ((unsigned char const   *)((void *)0));
  } else
#line 205
  if ((int const   )*(sensep + 0) > 115) {
#line 206
    return ((unsigned char const   *)((void *)0));
  }
#line 207
  if (add_sen_len < sense_len - 8) {
#line 207
    add_sen_len = add_sen_len;
  } else {
#line 207
    add_sen_len = sense_len - 8;
  }
#line 209
  descp = sensep + 8;
#line 210
  desc_len = 0;
#line 210
  k = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (k < add_sen_len)) {
#line 210
      goto while_break;
    }
#line 211
    descp += desc_len;
#line 212
    if (k < add_sen_len - 1) {
#line 212
      add_len = (int )*(descp + 1);
    } else {
#line 212
      add_len = -1;
    }
#line 213
    desc_len = add_len + 2;
#line 214
    if ((int const   )*(descp + 0) == (int const   )desc_type) {
#line 215
      return (descp);
    }
#line 216
    if (add_len < 0) {
#line 217
      goto while_break;
    }
#line 210
    k += desc_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return ((unsigned char const   *)((void *)0));
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_get_sense_info_fld(unsigned char const   *sensep , int sb_len , uint64_t *info_outp ) 
{ 
  int j ;
  unsigned char const   *ucp ;
  uint64_t ull ;
  int tmp ;

  {
#line 230
  if (info_outp) {
#line 231
    *info_outp = (uint64_t )0;
  }
#line 232
  if (sb_len < 7) {
#line 233
    return (0);
  }
  {
#line 236
  if (((int const   )*(sensep + 0) & 127) == 113) {
#line 236
    goto case_113;
  }
#line 236
  if (((int const   )*(sensep + 0) & 127) == 112) {
#line 236
    goto case_113;
  }
#line 242
  if (((int const   )*(sensep + 0) & 127) == 115) {
#line 242
    goto case_115;
  }
#line 242
  if (((int const   )*(sensep + 0) & 127) == 114) {
#line 242
    goto case_115;
  }
#line 256
  goto switch_default;
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 237
  if (info_outp) {
#line 238
    *info_outp = (uint64_t )(((((unsigned int )*(sensep + 3) << 24) + (unsigned int )((int const   )*(sensep + 4) << 16)) + (unsigned int )((int const   )*(sensep + 5) << 8)) + (unsigned int )*(sensep + 6));
  }
#line 240
  if ((int const   )*(sensep + 0) & 128) {
#line 240
    tmp = 1;
  } else {
#line 240
    tmp = 0;
  }
#line 240
  return (tmp);
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 243
  ucp = sg_scsi_sense_desc_find(sensep, sb_len, 0);
  }
#line 244
  if (ucp) {
#line 244
    if (10 == (int )*(ucp + 1)) {
#line 245
      ull = (uint64_t )0;
#line 246
      j = 0;
      {
#line 246
      while (1) {
        while_continue: /* CIL Label */ ;
#line 246
        if (! (j < 8)) {
#line 246
          goto while_break;
        }
#line 247
        if (j > 0) {
#line 248
          ull <<= 8;
        }
#line 249
        ull |= (unsigned long )*(ucp + (4 + j));
#line 246
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 251
      if (info_outp) {
#line 252
        *info_outp = ull;
      }
#line 253
      return (! (! ((int const   )*(ucp + 2) & 128)));
    } else {
#line 255
      return (0);
    }
  } else {
#line 255
    return (0);
  }
  switch_default: /* CIL Label */ 
#line 257
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_get_sense_filemark_eom_ili(unsigned char const   *sensep , int sb_len , int *filemark_p ,
                                  int *eom_p , int *ili_p ) 
{ 
  unsigned char const   *ucp ;

  {
#line 267
  if (sb_len < 7) {
#line 268
    return (0);
  }
  {
#line 271
  if (((int const   )*(sensep + 0) & 127) == 113) {
#line 271
    goto case_113;
  }
#line 271
  if (((int const   )*(sensep + 0) & 127) == 112) {
#line 271
    goto case_113;
  }
#line 283
  if (((int const   )*(sensep + 0) & 127) == 115) {
#line 283
    goto case_115;
  }
#line 283
  if (((int const   )*(sensep + 0) & 127) == 114) {
#line 283
    goto case_115;
  }
#line 298
  goto switch_default;
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 272
  if ((int const   )*(sensep + 2) & 224) {
#line 273
    if (filemark_p) {
#line 274
      *filemark_p = ! (! ((int const   )*(sensep + 2) & 128));
    }
#line 275
    if (eom_p) {
#line 276
      *eom_p = ! (! ((int const   )*(sensep + 2) & 64));
    }
#line 277
    if (ili_p) {
#line 278
      *ili_p = ! (! ((int const   )*(sensep + 2) & 32));
    }
#line 279
    return (1);
  } else {
#line 281
    return (0);
  }
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 285
  ucp = sg_scsi_sense_desc_find(sensep, sb_len, 4);
  }
#line 286
  if (ucp) {
#line 286
    if ((int const   )*(ucp + 1) >= 2) {
#line 287
      if ((int const   )*(ucp + 3) & 224) {
#line 288
        if (filemark_p) {
#line 289
          *filemark_p = ! (! ((int const   )*(ucp + 3) & 128));
        }
#line 290
        if (eom_p) {
#line 291
          *eom_p = ! (! ((int const   )*(ucp + 3) & 64));
        }
#line 292
        if (ili_p) {
#line 293
          *ili_p = ! (! ((int const   )*(ucp + 3) & 32));
        }
#line 294
        return (1);
      }
    }
  }
#line 297
  return (0);
  switch_default: /* CIL Label */ 
#line 299
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_get_sense_progress_fld(unsigned char const   *sensep , int sb_len , int *progress_outp ) 
{ 
  unsigned char const   *ucp ;
  int sk ;
  int sk_pr ;
  int tmp ;

  {
#line 316
  if (sb_len < 7) {
#line 317
    return (0);
  }
  {
#line 320
  if (((int const   )*(sensep + 0) & 127) == 113) {
#line 320
    goto case_113;
  }
#line 320
  if (((int const   )*(sensep + 0) & 127) == 112) {
#line 320
    goto case_113;
  }
#line 332
  if (((int const   )*(sensep + 0) & 127) == 115) {
#line 332
    goto case_115;
  }
#line 332
  if (((int const   )*(sensep + 0) & 127) == 114) {
#line 332
    goto case_115;
  }
#line 348
  goto switch_default;
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
#line 321
  sk = (int )((int const   )*(sensep + 2) & 15);
#line 322
  if (sb_len < 18) {
#line 324
    return (0);
  } else
#line 322
  if (0 != sk) {
#line 322
    if (2 != sk) {
#line 324
      return (0);
    }
  }
#line 325
  if ((int const   )*(sensep + 15) & 128) {
#line 326
    if (progress_outp) {
#line 327
      *progress_outp = (int )(((int const   )*(sensep + 16) << 8) + (int const   )*(sensep + 17));
    }
#line 328
    return (1);
  } else {
#line 330
    return (0);
  }
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
#line 334
  sk = (int )((int const   )*(sensep + 1) & 15);
#line 335
  if (0 == sk) {
#line 335
    tmp = 1;
  } else
#line 335
  if (2 == sk) {
#line 335
    tmp = 1;
  } else {
#line 335
    tmp = 0;
  }
#line 335
  sk_pr = tmp;
#line 336
  if (sk_pr) {
    {
#line 336
    ucp = sg_scsi_sense_desc_find(sensep, sb_len, 2);
    }
#line 336
    if (ucp) {
#line 336
      if (6 == (int )*(ucp + 1)) {
#line 336
        if (128 & (int )*(ucp + 4)) {
#line 338
          if (progress_outp) {
#line 339
            *progress_outp = (int )(((int const   )*(ucp + 5) << 8) + (int const   )*(ucp + 6));
          }
#line 340
          return (1);
        } else {
#line 336
          goto _L___1;
        }
      } else {
#line 336
        goto _L___1;
      }
    } else {
#line 336
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 341
    ucp = sg_scsi_sense_desc_find(sensep, sb_len, 10);
    }
#line 341
    if (ucp) {
#line 341
      if (6 == (int )*(ucp + 1)) {
#line 343
        if (progress_outp) {
#line 344
          *progress_outp = (int )(((int const   )*(ucp + 6) << 8) + (int const   )*(ucp + 7));
        }
#line 345
        return (1);
      } else {
#line 347
        return (0);
      }
    } else {
#line 347
      return (0);
    }
  }
  switch_default: /* CIL Label */ 
#line 349
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
char *sg_get_pdt_str(int pdt , int buff_len , char *buff ) 
{ 


  {
#line 356
  if (pdt < 0) {
    {
#line 357
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad pdt");
    }
  } else
#line 356
  if (pdt > 31) {
    {
#line 357
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad pdt");
    }
  } else {
    {
#line 359
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
             sg_lib_pdt_strs[pdt]);
    }
  }
#line 360
  return (buff);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
char *sg_get_trans_proto_str(int tpi , int buff_len , char *buff ) 
{ 


  {
#line 366
  if (tpi < 0) {
    {
#line 367
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad tpi");
    }
  } else
#line 366
  if (tpi > 15) {
    {
#line 367
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad tpi");
    }
  } else {
    {
#line 369
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
             sg_lib_transport_proto_strs[tpi]);
    }
  }
#line 370
  return (buff);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static int decode_tpgs_state(int st , char *b , int blen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 384
  if (st == 0) {
#line 384
    goto case_0;
  }
#line 386
  if (st == 1) {
#line 386
    goto case_1;
  }
#line 388
  if (st == 2) {
#line 388
    goto case_2;
  }
#line 390
  if (st == 3) {
#line 390
    goto case_3;
  }
#line 392
  if (st == 14) {
#line 392
    goto case_14;
  }
#line 394
  if (st == 15) {
#line 394
    goto case_15;
  }
#line 396
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 385
  tmp = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"active/optimized");
  }
#line 385
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 387
  tmp___0 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"active/non optimized");
  }
#line 387
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 389
  tmp___1 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"standby");
  }
#line 389
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 391
  tmp___2 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"unavailable");
  }
#line 391
  return (tmp___2);
  case_14: /* CIL Label */ 
  {
#line 393
  tmp___3 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"offline");
  }
#line 393
  return (tmp___3);
  case_15: /* CIL Label */ 
  {
#line 395
  tmp___4 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"transitioning between states");
  }
#line 395
  return (tmp___4);
  switch_default: /* CIL Label */ 
  {
#line 397
  tmp___5 = snprintf((char */* __restrict  */)b, (size_t )blen, (char const   */* __restrict  */)"unknown: 0x%x",
                     st);
  }
#line 397
  return (tmp___5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static int uds_referral_descriptor_str(char *sp , unsigned char const   *dp , int alen ) 
{ 
  int n ;
  int dlen ;
  int k ;
  int j ;
  int g ;
  int f ;
  int tpgd ;
  unsigned char const   *tp ;
  uint64_t ull ;
  char c[40] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 404
  n = 0;
#line 405
  dlen = alen - 2;
#line 411
  tmp = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"   Not all referrals: %d\n",
                ! (! ((int const   )*(dp + 2) & 1)));
#line 411
  n += tmp;
#line 412
  dp += 4;
#line 413
  k = 0;
#line 413
  f = 1;
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (k + 4 < dlen)) {
#line 413
      goto while_break;
    }
    {
#line 414
    tpgd = (int )*(dp + 3);
#line 415
    g = tpgd * 4 + 20;
#line 416
    tmp___0 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"    Descriptor %d\n",
                      f);
#line 416
    n += tmp___0;
    }
#line 417
    if (k + g > dlen) {
      {
#line 418
      tmp___1 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"      truncated descriptor, stop\n");
#line 418
      n += tmp___1;
      }
#line 419
      return (n);
    }
#line 421
    ull = (uint64_t )0;
#line 422
    j = 0;
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 422
      if (! (j < 8)) {
#line 422
        goto while_break___0;
      }
#line 423
      if (j > 0) {
#line 424
        ull <<= 8;
      }
#line 425
      ull |= (unsigned long )*(dp + (4 + j));
#line 422
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 427
    tmp___2 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"      first uds LBA: 0x%lx\n",
                      ull);
#line 427
    n += tmp___2;
#line 428
    ull = (uint64_t )0;
#line 429
    j = 0;
    }
    {
#line 429
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 429
      if (! (j < 8)) {
#line 429
        goto while_break___1;
      }
#line 430
      if (j > 0) {
#line 431
        ull <<= 8;
      }
#line 432
      ull |= (unsigned long )*(dp + (12 + j));
#line 429
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 434
    tmp___3 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"      last uds LBA:  0x%lx\n",
                      ull);
#line 434
    n += tmp___3;
#line 435
    j = 0;
    }
    {
#line 435
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 435
      if (! (j < tpgd)) {
#line 435
        goto while_break___2;
      }
      {
#line 436
      tp = (dp + 20) + j * 4;
#line 437
      decode_tpgs_state((int )((int const   )*(tp + 0) & 15), c, (int )sizeof(c));
#line 438
      tmp___4 = sprintf((char */* __restrict  */)(sp + n), (char const   */* __restrict  */)"        tpg: %d  state: %s\n",
                        ((int const   )*(tp + 2) << 8) + (int const   )*(tp + 3),
                        c);
#line 438
      n += tmp___4;
#line 435
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 413
    k += g;
#line 413
    dp += g;
#line 413
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (n);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static char const   *sdata_src[3]  = {      "unknown",      "Extended Copy command source device",      "Extended Copy command destination device"};
#line 454 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static void sg_get_sense_descriptors_str(unsigned char const   *sense_buffer , int sb_len ,
                                         int buff_len , char *buff ) 
{ 
  int add_sen_len ;
  int add_len ;
  int desc_len ;
  int k ;
  int j ;
  int sense_key ;
  int processed ;
  int n ;
  int progress ;
  int pr ;
  int rem ;
  unsigned char const   *descp ;
  char const   *dtsp ;
  char b[2048] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int extend ;
  int sector_count ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char c[200] ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t tmp___79 ;

  {
#line 461
  dtsp = "   >> descriptor too short";
#line 464
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 465
    return;
  } else
#line 464
  if (buff_len <= 0) {
#line 465
    return;
  }
#line 466
  *(buff + 0) = (char )'\000';
#line 467
  if (sb_len < 8) {
#line 468
    return;
  } else {
#line 467
    add_sen_len = (int )*(sense_buffer + 7);
#line 467
    if (0 == add_sen_len) {
#line 468
      return;
    }
  }
#line 469
  if (add_sen_len < sb_len - 8) {
#line 469
    add_sen_len = add_sen_len;
  } else {
#line 469
    add_sen_len = sb_len - 8;
  }
#line 470
  descp = sense_buffer + 8;
#line 471
  sense_key = (int )((int const   )*(sense_buffer + 1) & 15);
#line 472
  desc_len = 0;
#line 472
  k = 0;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (k < add_sen_len)) {
#line 472
      goto while_break;
    }
#line 473
    descp += desc_len;
#line 474
    if (k < add_sen_len - 1) {
#line 474
      add_len = (int )*(descp + 1);
    } else {
#line 474
      add_len = -1;
    }
#line 475
    if ((k + add_len) + 2 > add_sen_len) {
#line 476
      add_len = (add_sen_len - k) - 2;
    }
    {
#line 477
    desc_len = add_len + 2;
#line 478
    n = 0;
#line 479
    tmp = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"  Descriptor type: ");
#line 479
    n += tmp;
#line 480
    processed = 1;
    }
    {
#line 482
    if ((int const   )*(descp + 0) == 0) {
#line 482
      goto case_0;
    }
#line 494
    if ((int const   )*(descp + 0) == 1) {
#line 494
      goto case_1;
    }
#line 506
    if ((int const   )*(descp + 0) == 2) {
#line 506
      goto case_2;
    }
#line 577
    if ((int const   )*(descp + 0) == 3) {
#line 577
      goto case_3___0;
    }
#line 586
    if ((int const   )*(descp + 0) == 4) {
#line 586
      goto case_4___0;
    }
#line 602
    if ((int const   )*(descp + 0) == 5) {
#line 602
      goto case_5___0;
    }
#line 612
    if ((int const   )*(descp + 0) == 6) {
#line 612
      goto case_6___0;
    }
#line 616
    if ((int const   )*(descp + 0) == 7) {
#line 616
      goto case_7;
    }
#line 620
    if ((int const   )*(descp + 0) == 8) {
#line 620
      goto case_8;
    }
#line 624
    if ((int const   )*(descp + 0) == 9) {
#line 624
      goto case_9;
    }
#line 648
    if ((int const   )*(descp + 0) == 10) {
#line 648
      goto case_10___0;
    }
#line 662
    if ((int const   )*(descp + 0) == 11) {
#line 662
      goto case_11;
    }
#line 671
    if ((int const   )*(descp + 0) == 12) {
#line 671
      goto case_12;
    }
#line 703
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 483
    tmp___0 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Information\n");
#line 483
    n += tmp___0;
    }
#line 484
    if (add_len >= 10) {
#line 484
      if (128 & (int )*(descp + 2)) {
        {
#line 485
        tmp___1 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    0x");
#line 485
        n += tmp___1;
#line 486
        j = 0;
        }
        {
#line 486
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 486
          if (! (j < 8)) {
#line 486
            goto while_break___0;
          }
          {
#line 487
          tmp___2 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%02x",
                            (int const   )*(descp + (4 + j)));
#line 487
          n += tmp___2;
#line 486
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 488
        tmp___3 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 488
        n += tmp___3;
        }
      } else {
        {
#line 490
        tmp___4 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                          dtsp);
#line 490
        n += tmp___4;
#line 491
        processed = 0;
        }
      }
    } else {
      {
#line 490
      tmp___4 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                        dtsp);
#line 490
      n += tmp___4;
#line 491
      processed = 0;
      }
    }
#line 493
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 495
    tmp___5 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Command specific\n");
#line 495
    n += tmp___5;
    }
#line 496
    if (add_len >= 10) {
      {
#line 497
      tmp___6 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    0x");
#line 497
      n += tmp___6;
#line 498
      j = 0;
      }
      {
#line 498
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 498
        if (! (j < 8)) {
#line 498
          goto while_break___1;
        }
        {
#line 499
        tmp___7 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%02x",
                          (int const   )*(descp + (4 + j)));
#line 499
        n += tmp___7;
#line 498
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 500
      tmp___8 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 500
      n += tmp___8;
      }
    } else {
      {
#line 502
      tmp___9 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                        dtsp);
#line 502
      n += tmp___9;
#line 503
      processed = 0;
      }
    }
#line 505
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 507
    tmp___10 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Sense key specific:");
#line 507
    n += tmp___10;
    }
    {
#line 509
    if (sense_key == 5) {
#line 509
      goto case_5;
    }
#line 526
    if (sense_key == 1) {
#line 526
      goto case_1___0;
    }
#line 526
    if (sense_key == 3) {
#line 526
      goto case_1___0;
    }
#line 526
    if (sense_key == 4) {
#line 526
      goto case_1___0;
    }
#line 537
    if (sense_key == 2) {
#line 537
      goto case_2___0;
    }
#line 537
    if (sense_key == 0) {
#line 537
      goto case_2___0;
    }
#line 549
    if (sense_key == 10) {
#line 549
      goto case_10;
    }
#line 565
    if (sense_key == 6) {
#line 565
      goto case_6;
    }
#line 570
    goto switch_default;
    case_5: /* CIL Label */ 
    {
#line 510
    tmp___11 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Field pointer\n");
#line 510
    n += tmp___11;
    }
#line 511
    if (add_len < 6) {
      {
#line 512
      tmp___12 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 512
      n += tmp___12;
#line 513
      processed = 0;
      }
#line 514
      goto switch_break___0;
    }
#line 516
    if ((int const   )*(descp + 4) & 64) {
#line 516
      tmp___13 = "Command";
    } else {
#line 516
      tmp___13 = "Data";
    }
    {
#line 516
    tmp___14 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Error in %s byte %d",
                       tmp___13, ((int const   )*(descp + 5) << 8) | (int const   )*(descp + 6));
#line 516
    n += tmp___14;
    }
#line 519
    if ((int const   )*(descp + 4) & 8) {
      {
#line 520
      tmp___15 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" bit %d\n",
                         (int const   )*(descp + 4) & 7);
#line 520
      n += tmp___15;
      }
    } else {
      {
#line 522
      tmp___16 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 522
      n += tmp___16;
      }
    }
#line 523
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 527
    tmp___17 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Actual retry count\n");
#line 527
    n += tmp___17;
    }
#line 528
    if (add_len < 6) {
      {
#line 529
      tmp___18 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 529
      n += tmp___18;
#line 530
      processed = 0;
      }
#line 531
      goto switch_break___0;
    }
    {
#line 533
    tmp___19 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    0x%02x%02x\n",
                       (int const   )*(descp + 5), (int const   )*(descp + 6));
#line 533
    n += tmp___19;
    }
#line 535
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 538
    tmp___20 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Progress indication: ");
#line 538
    n += tmp___20;
    }
#line 539
    if (add_len < 6) {
      {
#line 540
      tmp___21 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 540
      n += tmp___21;
#line 541
      processed = 0;
      }
#line 542
      goto switch_break___0;
    }
    {
#line 544
    progress = (int )(((int const   )*(descp + 5) << 8) + (int const   )*(descp + 6));
#line 545
    pr = (progress * 100) / 65536;
#line 546
    rem = ((progress * 100) % 65536) / 655;
#line 547
    tmp___22 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%d.%02d%%\n",
                       pr, rem);
#line 547
    n += tmp___22;
    }
#line 548
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 550
    tmp___23 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Segment pointer\n");
#line 550
    n += tmp___23;
    }
#line 551
    if (add_len < 6) {
      {
#line 552
      tmp___24 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 552
      n += tmp___24;
#line 553
      processed = 0;
      }
#line 554
      goto switch_break___0;
    }
#line 556
    if ((int const   )*(descp + 4) & 32) {
#line 556
      tmp___25 = "segment descriptor";
    } else {
#line 556
      tmp___25 = "parameter list";
    }
    {
#line 556
    tmp___26 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Relative to start of %s, byte %d",
                       tmp___25, ((int const   )*(descp + 5) << 8) | (int const   )*(descp + 6));
#line 556
    n += tmp___26;
    }
#line 560
    if ((int const   )*(descp + 4) & 8) {
      {
#line 561
      tmp___27 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" bit %d\n",
                         (int const   )*(descp + 4) & 7);
#line 561
      n += tmp___27;
      }
    } else {
      {
#line 563
      tmp___28 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 563
      n += tmp___28;
      }
    }
#line 564
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 566
    tmp___29 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Unit attention condition queue: ");
#line 566
    n += tmp___29;
#line 567
    tmp___30 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"overflow flag is %d\n",
                       ! (! ((int const   )*(descp + 4) & 1)));
#line 567
    n += tmp___30;
    }
#line 569
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 571
    tmp___31 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" Sense_key: 0x%x unexpected\n",
                       sense_key);
#line 571
    n += tmp___31;
#line 573
    processed = 0;
    }
#line 574
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 576
    goto switch_break;
    case_3___0: /* CIL Label */ 
    {
#line 578
    tmp___32 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Field replaceable unit\n");
#line 578
    n += tmp___32;
    }
#line 579
    if (add_len >= 2) {
      {
#line 580
      tmp___33 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    code=0x%x\n",
                         (int const   )*(descp + 3));
#line 580
      n += tmp___33;
      }
    } else {
      {
#line 582
      tmp___34 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 582
      n += tmp___34;
#line 583
      processed = 0;
      }
    }
#line 585
    goto switch_break;
    case_4___0: /* CIL Label */ 
    {
#line 587
    tmp___35 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Stream commands\n");
#line 587
    n += tmp___35;
    }
#line 588
    if (add_len >= 2) {
#line 589
      if ((int const   )*(descp + 3) & 128) {
        {
#line 590
        tmp___36 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    FILEMARK");
#line 590
        n += tmp___36;
        }
      }
#line 591
      if ((int const   )*(descp + 3) & 64) {
        {
#line 592
        tmp___37 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    End Of Medium (EOM)");
#line 592
        n += tmp___37;
        }
      }
#line 593
      if ((int const   )*(descp + 3) & 32) {
        {
#line 594
        tmp___38 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Incorrect Length Indicator (ILI)");
#line 594
        n += tmp___38;
        }
      }
      {
#line 596
      tmp___39 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 596
      n += tmp___39;
      }
    } else {
      {
#line 598
      tmp___40 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 598
      n += tmp___40;
#line 599
      processed = 0;
      }
    }
#line 601
    goto switch_break;
    case_5___0: /* CIL Label */ 
    {
#line 603
    tmp___41 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Block commands\n");
#line 603
    n += tmp___41;
    }
#line 604
    if (add_len >= 2) {
#line 605
      if ((int const   )*(descp + 3) & 32) {
#line 605
        tmp___42 = "set";
      } else {
#line 605
        tmp___42 = "clear";
      }
      {
#line 605
      tmp___43 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Incorrect Length Indicator (ILI) %s\n",
                         tmp___42);
#line 605
      n += tmp___43;
      }
    } else {
      {
#line 608
      tmp___44 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 608
      n += tmp___44;
#line 609
      processed = 0;
      }
    }
#line 611
    goto switch_break;
    case_6___0: /* CIL Label */ 
    {
#line 613
    tmp___45 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"OSD object identification\n");
#line 613
    n += tmp___45;
#line 614
    processed = 0;
    }
#line 615
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 617
    tmp___46 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"OSD response integrity check value\n");
#line 617
    n += tmp___46;
#line 618
    processed = 0;
    }
#line 619
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 621
    tmp___47 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"OSD attribute identification\n");
#line 621
    n += tmp___47;
#line 622
    processed = 0;
    }
#line 623
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 625
    tmp___48 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"ATA Status Return\n");
#line 625
    n += tmp___48;
    }
#line 626
    if (add_len >= 12) {
#line 629
      extend = (int )((int const   )*(descp + 2) & 1);
#line 630
      if (extend) {
#line 630
        tmp___49 = (int const   )*(descp + 4) << 8;
      } else {
#line 630
        tmp___49 = (int const   )0;
      }
      {
#line 630
      sector_count = (int )((int const   )*(descp + 5) + tmp___49);
#line 631
      tmp___50 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    extend=%d  error=0x%x  sector_count=0x%x\n",
                         extend, (int const   )*(descp + 3), sector_count);
#line 631
      n += tmp___50;
      }
#line 634
      if (extend) {
        {
#line 635
        tmp___51 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    lba=0x%02x%02x%02x%02x%02x%02x\n",
                           (int const   )*(descp + 10), (int const   )*(descp + 8),
                           (int const   )*(descp + 6), (int const   )*(descp + 11),
                           (int const   )*(descp + 9), (int const   )*(descp + 7));
#line 635
        n += tmp___51;
        }
      } else {
        {
#line 639
        tmp___52 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    lba=0x%02x%02x%02x\n",
                           (int const   )*(descp + 11), (int const   )*(descp + 9),
                           (int const   )*(descp + 7));
#line 639
        n += tmp___52;
        }
      }
      {
#line 641
      tmp___53 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    device=0x%x  status=0x%x\n",
                         (int const   )*(descp + 12), (int const   )*(descp + 13));
#line 641
      n += tmp___53;
      }
    } else {
      {
#line 644
      tmp___54 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 644
      n += tmp___54;
#line 645
      processed = 0;
      }
    }
#line 647
    goto switch_break;
    case_10___0: /* CIL Label */ 
    {
#line 649
    tmp___55 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Progress indication\n");
#line 649
    n += tmp___55;
    }
#line 650
    if (add_len < 6) {
      {
#line 651
      tmp___56 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 651
      n += tmp___56;
#line 652
      processed = 0;
      }
#line 653
      goto switch_break;
    }
    {
#line 655
    progress = (int )(((int const   )*(descp + 6) << 8) + (int const   )*(descp + 7));
#line 656
    pr = (progress * 100) / 65536;
#line 657
    rem = ((progress * 100) % 65536) / 655;
#line 658
    tmp___57 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    %d.02%d%%",
                       pr, rem);
#line 658
    n += tmp___57;
#line 659
    tmp___58 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" [sense_key=0x%x asc,ascq=0x%x,0x%x]\n",
                       (int const   )*(descp + 2), (int const   )*(descp + 3), (int const   )*(descp + 4));
#line 659
    n += tmp___58;
    }
#line 661
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 663
    tmp___59 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"User data segment referral\n");
#line 663
    n += tmp___59;
    }
#line 664
    if (add_len < 2) {
      {
#line 665
      tmp___60 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 665
      n += tmp___60;
#line 666
      processed = 0;
      }
#line 667
      goto switch_break;
    }
    {
#line 669
    tmp___61 = uds_referral_descriptor_str(b + n, descp, add_len);
#line 669
    n += tmp___61;
    }
#line 670
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 672
    tmp___62 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Forwarded sense data\n");
#line 672
    n += tmp___62;
    }
#line 673
    if (add_len < 2) {
      {
#line 674
      tmp___63 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s\n",
                         dtsp);
#line 674
      n += tmp___63;
#line 675
      processed = 0;
      }
#line 676
      goto switch_break;
    }
#line 678
    if ((int const   )*(descp + 2) & 128) {
#line 678
      tmp___64 = "set";
    } else {
#line 678
      tmp___64 = "clear";
    }
    {
#line 678
    tmp___65 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    FSDT: %s\n",
                       tmp___64);
#line 678
    n += tmp___65;
#line 680
    j = (int )((int const   )*(descp + 2) & 15);
    }
#line 681
    if (j < 3) {
      {
#line 682
      tmp___66 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Sense data source: %s\n",
                         sdata_src[j]);
#line 682
      n += tmp___66;
      }
    } else {
      {
#line 685
      tmp___67 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Sense data source: reserved [%d]\n",
                         j);
#line 685
      n += tmp___67;
      }
    }
    {
#line 690
    sg_get_scsi_status_str((int )*(descp + 3), (int )(sizeof(c) - 1UL), c);
#line 691
    c[sizeof(c) - 1UL] = (char )'\000';
#line 692
    tmp___68 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    Forwarded status: %s\n",
                       c);
#line 692
    n += tmp___68;
    }
#line 693
    if (add_len > 2) {
      {
#line 695
      tmp___69 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" vvvvvvvvvvvvvvvv\n");
#line 695
      n += tmp___69;
#line 696
      sg_get_sense_str((char const   *)((void *)0), descp + 4, add_len - 2, 0, (int )sizeof(c),
                       c);
#line 698
      tmp___70 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%s",
                         c);
#line 698
      n += tmp___70;
#line 699
      tmp___71 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)" ^^^^^^^^^^^^^^^^\n");
#line 699
      n += tmp___71;
      }
    }
#line 702
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 704
    if ((int const   )*(descp + 0) >= 128) {
      {
#line 705
      tmp___72 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Vendor specific [0x%x]\n",
                         (int const   )*(descp + 0));
#line 705
      n += tmp___72;
      }
    } else {
      {
#line 707
      tmp___73 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"Unknown [0x%x]\n",
                         (int const   )*(descp + 0));
#line 707
      n += tmp___73;
      }
    }
#line 708
    processed = 0;
#line 709
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 711
    if (! processed) {
#line 712
      if (add_len > 0) {
        {
#line 713
        tmp___74 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    ");
#line 713
        n += tmp___74;
#line 714
        j = 0;
        }
        {
#line 714
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 714
          if (! (j < add_len)) {
#line 714
            goto while_break___2;
          }
#line 715
          if (j > 0) {
#line 715
            if (0 == j % 24) {
              {
#line 716
              tmp___75 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n    ");
#line 716
              n += tmp___75;
              }
            }
          }
          {
#line 717
          tmp___76 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"%02x ",
                             (int const   )*(descp + (j + 2)));
#line 717
          n += tmp___76;
#line 714
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 719
        tmp___77 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"\n");
#line 719
        n += tmp___77;
        }
      }
    }
#line 722
    if (add_len < 0) {
      {
#line 723
      tmp___78 = sprintf((char */* __restrict  */)(b + n), (char const   */* __restrict  */)"    short descriptor\n");
#line 723
      n += tmp___78;
      }
    }
    {
#line 724
    tmp___79 = strlen((char const   *)buff);
#line 724
    j = (int )tmp___79;
    }
#line 725
    if (n + j >= buff_len) {
      {
#line 726
      strncpy((char */* __restrict  */)(buff + j), (char const   */* __restrict  */)(b),
              (size_t )(buff_len - j));
#line 727
      *(buff + (buff_len - 1)) = (char )'\000';
      }
#line 728
      goto while_break;
    }
    {
#line 730
    strcpy((char */* __restrict  */)(buff + j), (char const   */* __restrict  */)(b));
    }
#line 731
    if (add_len < 0) {
#line 732
      goto while_break;
    }
#line 472
    k += desc_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_get_sense_str(char const   *leadin , unsigned char const   *sense_buffer ,
                      int sb_len , int raw_sinfo , int buff_len , char *buff ) 
{ 
  int len ;
  int valid ;
  int progress ;
  int n ;
  int r ;
  int pr ;
  int rem ;
  unsigned int info ;
  int descriptor_format ;
  char const   *error ;
  char error_buff[64] ;
  char b[256] ;
  struct sg_scsi_sense_hdr ssh ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
#line 743
  descriptor_format = 0;
#line 744
  error = (char const   *)((void *)0);
#line 749
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 750
    return;
  } else
#line 749
  if (buff_len <= 0) {
#line 750
    return;
  }
#line 751
  *(buff + (buff_len - 1)) = (char )'\000';
#line 752
  buff_len --;
#line 753
  n = 0;
#line 754
  if (sb_len < 1) {
    {
#line 755
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"sense buffer empty\n");
    }
#line 756
    return;
  }
#line 758
  if (leadin) {
    {
#line 759
    tmp = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n), (char const   */* __restrict  */)"%s: ",
                   leadin);
#line 759
    n += tmp;
    }
#line 760
    if (n >= buff_len) {
#line 761
      return;
    }
  }
  {
#line 763
  len = sb_len;
#line 764
  tmp___35 = sg_scsi_normalize_sense(sense_buffer, sb_len, & ssh);
  }
#line 764
  if (tmp___35) {
    {
#line 766
    if ((int )ssh.response_code == 112) {
#line 766
      goto case_112;
    }
#line 771
    if ((int )ssh.response_code == 113) {
#line 771
      goto case_113;
    }
#line 777
    if ((int )ssh.response_code == 114) {
#line 777
      goto case_114;
    }
#line 781
    if ((int )ssh.response_code == 115) {
#line 781
      goto case_115;
    }
#line 785
    if ((int )ssh.response_code == 0) {
#line 785
      goto case_0;
    }
#line 788
    goto switch_default;
    case_112: /* CIL Label */ 
#line 767
    error = "Fixed format, current";
#line 768
    if (sb_len > 7) {
#line 768
      len = (int )((int const   )*(sense_buffer + 7) + 8);
    } else {
#line 768
      len = sb_len;
    }
#line 769
    if (len > sb_len) {
#line 769
      len = sb_len;
    } else {
#line 769
      len = len;
    }
#line 770
    goto switch_break;
    case_113: /* CIL Label */ 
#line 773
    error = "Fixed format, <<<deferred>>>";
#line 774
    if (sb_len > 7) {
#line 774
      len = (int )((int const   )*(sense_buffer + 7) + 8);
    } else {
#line 774
      len = sb_len;
    }
#line 775
    if (len > sb_len) {
#line 775
      len = sb_len;
    } else {
#line 775
      len = len;
    }
#line 776
    goto switch_break;
    case_114: /* CIL Label */ 
#line 778
    descriptor_format = 1;
#line 779
    error = "Descriptor format, current";
#line 780
    goto switch_break;
    case_115: /* CIL Label */ 
#line 782
    descriptor_format = 1;
#line 783
    error = "Descriptor format, <<<deferred>>>";
#line 784
    goto switch_break;
    case_0: /* CIL Label */ 
#line 786
    error = "Response code: 0x0 (?)";
#line 787
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 789
    snprintf((char */* __restrict  */)(error_buff), sizeof(error_buff), (char const   */* __restrict  */)"Unknown response code: 0x%x",
             (int )ssh.response_code);
#line 791
    error = (char const   *)(error_buff);
    }
#line 792
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 794
    tmp___0 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                       (char const   */* __restrict  */)" %s;  Sense key: %s\n ",
                       error, sg_lib_sense_key_desc[ssh.sense_key]);
#line 794
    n += tmp___0;
    }
#line 796
    if (n >= buff_len) {
#line 797
      return;
    }
#line 798
    if (descriptor_format) {
      {
#line 799
      tmp___1 = sg_get_asc_ascq_str((int )ssh.asc, (int )ssh.ascq, (int )sizeof(b),
                                    b);
#line 799
      tmp___2 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                         (char const   */* __restrict  */)"%s\n", tmp___1);
#line 799
      n += tmp___2;
      }
#line 802
      if (n >= buff_len) {
#line 803
        return;
      }
      {
#line 804
      sg_get_sense_descriptors_str(sense_buffer, len, buff_len - n, buff + n);
#line 806
      tmp___3 = strlen((char const   *)buff);
#line 806
      n = (int )tmp___3;
      }
#line 807
      if (n >= buff_len) {
#line 808
        return;
      }
    } else
#line 809
    if (len > 2) {
#line 810
      if (len > 12) {
        {
#line 811
        tmp___4 = sg_get_asc_ascq_str((int )ssh.asc, (int )ssh.ascq, (int )sizeof(b),
                                      b);
#line 811
        tmp___5 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                           (char const   */* __restrict  */)"%s\n", tmp___4);
#line 811
        n += tmp___5;
        }
#line 814
        if (n >= buff_len) {
#line 815
          return;
        }
      }
#line 817
      r = 0;
#line 818
      valid = (int )((int const   )*(sense_buffer + 0) & 128);
#line 819
      if (len > 6) {
#line 820
        info = (unsigned int )(((((int const   )*(sense_buffer + 3) << 24) | ((int const   )*(sense_buffer + 4) << 16)) | ((int const   )*(sense_buffer + 5) << 8)) | (int const   )*(sense_buffer + 6));
#line 823
        if (valid) {
          {
#line 824
          tmp___6 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Info fld=0x%x [%u] ",
                            info, info);
#line 824
          r += tmp___6;
          }
        } else
#line 826
        if (info > 0U) {
          {
#line 827
          tmp___7 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Valid=0, Info fld=0x%x [%u] ",
                            info, info);
#line 827
          r += tmp___7;
          }
        }
      } else {
#line 830
        info = 0U;
      }
#line 831
      if ((int const   )*(sense_buffer + 2) & 224) {
#line 832
        if ((int const   )*(sense_buffer + 2) & 128) {
          {
#line 833
          tmp___8 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" FMK");
#line 833
          r += tmp___8;
          }
        }
#line 835
        if ((int const   )*(sense_buffer + 2) & 64) {
          {
#line 836
          tmp___9 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" EOM");
#line 836
          r += tmp___9;
          }
        }
#line 838
        if ((int const   )*(sense_buffer + 2) & 32) {
          {
#line 839
          tmp___10 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" ILI");
#line 839
          r += tmp___10;
          }
        }
        {
#line 841
        tmp___11 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 841
        r += tmp___11;
        }
      } else
#line 842
      if (valid) {
        {
#line 843
        tmp___12 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 843
        r += tmp___12;
        }
      } else
#line 842
      if (info > 0U) {
        {
#line 843
        tmp___12 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 843
        r += tmp___12;
        }
      }
#line 844
      if (len >= 14) {
#line 844
        if (*(sense_buffer + 14)) {
          {
#line 845
          tmp___13 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Field replaceable unit code: %d\n",
                             (int const   )*(sense_buffer + 14));
#line 845
          r += tmp___13;
          }
        }
      }
#line 847
      if (len >= 18) {
#line 847
        if ((int const   )*(sense_buffer + 15) & 128) {
          {
#line 850
          if ((int )ssh.sense_key == 5) {
#line 850
            goto case_5;
          }
#line 862
          if ((int )ssh.sense_key == 2) {
#line 862
            goto case_2;
          }
#line 862
          if ((int )ssh.sense_key == 0) {
#line 862
            goto case_2;
          }
#line 871
          if ((int )ssh.sense_key == 1) {
#line 871
            goto case_1;
          }
#line 871
          if ((int )ssh.sense_key == 3) {
#line 871
            goto case_1;
          }
#line 871
          if ((int )ssh.sense_key == 4) {
#line 871
            goto case_1;
          }
#line 876
          if ((int )ssh.sense_key == 10) {
#line 876
            goto case_10;
          }
#line 888
          if ((int )ssh.sense_key == 6) {
#line 888
            goto case_6;
          }
#line 893
          goto switch_default___0;
          case_5: /* CIL Label */ 
#line 851
          if ((int const   )*(sense_buffer + 15) & 64) {
#line 851
            tmp___14 = "Command";
          } else {
#line 851
            tmp___14 = "Data";
          }
          {
#line 851
          tmp___15 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Sense Key Specific: Error in %s byte %d",
                             tmp___14, ((int const   )*(sense_buffer + 16) << 8) | (int const   )*(sense_buffer + 17));
#line 851
          r += tmp___15;
          }
#line 855
          if ((int const   )*(sense_buffer + 15) & 8) {
            {
#line 856
            tmp___16 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" bit %d\n",
                               (int const   )*(sense_buffer + 15) & 7);
#line 856
            r += tmp___16;
            }
          } else {
            {
#line 859
            tmp___17 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 859
            r += tmp___17;
            }
          }
#line 860
          goto switch_break___0;
          case_2: /* CIL Label */ 
          case_0___0: /* CIL Label */ 
          {
#line 863
          progress = (int )(((int const   )*(sense_buffer + 16) << 8) + (int const   )*(sense_buffer + 17));
#line 864
          pr = (progress * 100) / 65536;
#line 865
          rem = ((progress * 100) % 65536) / 655;
#line 866
          tmp___18 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Progress indication: %d.%02d%%\n",
                             pr, rem);
#line 866
          r += tmp___18;
          }
#line 868
          goto switch_break___0;
          case_1: /* CIL Label */ 
          case_3: /* CIL Label */ 
          case_4: /* CIL Label */ 
          {
#line 872
          tmp___19 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Actual retry count: 0x%02x%02x\n",
                             (int const   )*(sense_buffer + 16), (int const   )*(sense_buffer + 17));
#line 872
          r += tmp___19;
          }
#line 875
          goto switch_break___0;
          case_10: /* CIL Label */ 
          {
#line 877
          tmp___20 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Segment pointer: ");
#line 877
          r += tmp___20;
          }
#line 878
          if ((int const   )*(sense_buffer + 15) & 32) {
#line 878
            tmp___21 = "segment descriptor";
          } else {
#line 878
            tmp___21 = "parameter list";
          }
          {
#line 878
          tmp___22 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"Relative to start of %s, byte %d",
                             tmp___21, ((int const   )*(sense_buffer + 16) << 8) + (int const   )*(sense_buffer + 17));
#line 878
          r += tmp___22;
          }
#line 882
          if ((int const   )*(sense_buffer + 15) & 8) {
            {
#line 883
            tmp___23 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)" bit %d\n",
                               (int const   )*(sense_buffer + 15) & 7);
#line 883
            r += tmp___23;
            }
          } else {
            {
#line 886
            tmp___24 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"\n");
#line 886
            r += tmp___24;
            }
          }
#line 887
          goto switch_break___0;
          case_6: /* CIL Label */ 
          {
#line 889
          tmp___25 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Unit attention condition queue: ");
#line 889
          r += tmp___25;
#line 890
          tmp___26 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"overflow flag is %d\n",
                             ! (! ((int const   )*(sense_buffer + 15) & 1)));
#line 890
          r += tmp___26;
          }
#line 892
          goto switch_break___0;
          switch_default___0: /* CIL Label */ 
          {
#line 894
          tmp___27 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  Sense_key: 0x%x unexpected\n",
                             (int )ssh.sense_key);
#line 894
          r += tmp___27;
          }
#line 896
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 899
      if (r > 0) {
        {
#line 900
        tmp___28 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                            (char const   */* __restrict  */)"%s", b);
#line 900
        n += tmp___28;
        }
#line 901
        if (n >= buff_len) {
#line 902
          return;
        }
      }
    } else {
      {
#line 905
      tmp___29 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                          (char const   */* __restrict  */)" fixed descriptor length too short, len=%d\n",
                          len);
#line 905
      n += tmp___29;
      }
#line 907
      if (n >= buff_len) {
#line 908
        return;
      }
    }
  } else {
#line 911
    if (sb_len < 4) {
      {
#line 912
      tmp___30 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                          (char const   */* __restrict  */)"sense buffer too short (4 byte minimum)\n");
#line 912
      n += tmp___30;
      }
#line 914
      return;
    }
    {
#line 916
    r = 0;
#line 917
    tmp___31 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"Probably uninitialized data.\n  Try to view as SCSI-1 non-extended sense:\n");
#line 917
    r += tmp___31;
#line 919
    tmp___32 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  AdValid=%d  Error class=%d  Error code=%d\n",
                       ! (! ((int const   )*(sense_buffer + 0) & 128)), ((int const   )*(sense_buffer + 0) >> 4) & 7,
                       (int const   )*(sense_buffer + 0) & 15);
#line 919
    r += tmp___32;
    }
#line 923
    if ((int const   )*(sense_buffer + 0) & 128) {
      {
#line 924
      tmp___33 = sprintf((char */* __restrict  */)(b + r), (char const   */* __restrict  */)"  lba=0x%x\n",
                         ((((int const   )*(sense_buffer + 1) & 31) << 16) + ((int const   )*(sense_buffer + 2) << 8)) + (int const   )*(sense_buffer + 3));
#line 924
      r += tmp___33;
      }
    }
    {
#line 927
    tmp___34 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                        (char const   */* __restrict  */)"%s\n", b);
#line 927
    n += tmp___34;
    }
#line 928
    if (n >= buff_len) {
#line 929
      return;
    }
#line 930
    len = sb_len;
#line 931
    if (len > 32) {
#line 932
      len = 32;
    }
  }
#line 934
  if (raw_sinfo) {
    {
#line 935
    tmp___36 = snprintf((char */* __restrict  */)(buff + n), (size_t )(buff_len - n),
                        (char const   */* __restrict  */)" Raw sense data (in hex):\n");
#line 935
    n += tmp___36;
    }
#line 936
    if (n >= buff_len) {
#line 937
      return;
    }
    {
#line 938
    dStrHexErr((char const   *)sense_buffer, len, buff_len - n, buff + n);
    }
  }
#line 940
  return;
}
}
#line 943 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_print_sense(char const   *leadin , unsigned char const   *sense_buffer , int sb_len ,
                    int raw_sinfo ) 
{ 
  char b[1024] ;

  {
  {
#line 949
  sg_get_sense_str(leadin, sense_buffer, sb_len, raw_sinfo, (int )sizeof(b), b);
  }
#line 950
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 951
    sg_warnings_strm = stderr;
  }
  {
#line 952
  fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%s",
          b);
  }
#line 953
  return;
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_scsi_normalize_sense(unsigned char const   *sensep , int sb_len , struct sg_scsi_sense_hdr *sshp ) 
{ 


  {
#line 959
  if (sshp) {
    {
#line 960
    memset((void *)sshp, 0, sizeof(struct sg_scsi_sense_hdr ));
    }
  }
#line 961
  if ((unsigned long )((void *)0) == (unsigned long )sensep) {
#line 962
    return (0);
  } else
#line 961
  if (0 == sb_len) {
#line 962
    return (0);
  } else
#line 961
  if (112 != (112 & (int )*(sensep + 0))) {
#line 962
    return (0);
  }
#line 963
  if (sshp) {
#line 964
    sshp->response_code = (unsigned char )(127 & (int )*(sensep + 0));
#line 965
    if ((int )sshp->response_code >= 114) {
#line 966
      if (sb_len > 1) {
#line 967
        sshp->sense_key = (unsigned char )(15 & (int )*(sensep + 1));
      }
#line 968
      if (sb_len > 2) {
#line 969
        sshp->asc = (unsigned char )*(sensep + 2);
      }
#line 970
      if (sb_len > 3) {
#line 971
        sshp->ascq = (unsigned char )*(sensep + 3);
      }
#line 972
      if (sb_len > 7) {
#line 973
        sshp->additional_length = (unsigned char )*(sensep + 7);
      }
    } else {
#line 975
      if (sb_len > 2) {
#line 976
        sshp->sense_key = (unsigned char )(15 & (int )*(sensep + 2));
      }
#line 977
      if (sb_len > 7) {
#line 978
        if (sb_len < (int )((int const   )*(sensep + 7) + 8)) {
#line 978
          sb_len = sb_len;
        } else {
#line 978
          sb_len = (int )((int const   )*(sensep + 7) + 8);
        }
#line 980
        if (sb_len > 12) {
#line 981
          sshp->asc = (unsigned char )*(sensep + 12);
        }
#line 982
        if (sb_len > 13) {
#line 983
          sshp->ascq = (unsigned char )*(sensep + 13);
        }
      }
    }
  }
#line 987
  return (1);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_err_category_sense(unsigned char const   *sense_buffer , int sb_len ) 
{ 
  struct sg_scsi_sense_hdr ssh ;
  int tmp ;

  {
#line 997
  if (sense_buffer) {
#line 997
    if (sb_len > 2) {
      {
#line 997
      tmp = sg_scsi_normalize_sense(sense_buffer, sb_len, & ssh);
      }
#line 997
      if (tmp) {
        {
#line 1000
        if ((int )ssh.sense_key == 0) {
#line 1000
          goto case_0;
        }
#line 1002
        if ((int )ssh.sense_key == 1) {
#line 1002
          goto case_1;
        }
#line 1004
        if ((int )ssh.sense_key == 2) {
#line 1004
          goto case_2;
        }
#line 1008
        if ((int )ssh.sense_key == 8) {
#line 1008
          goto case_8;
        }
#line 1008
        if ((int )ssh.sense_key == 4) {
#line 1008
          goto case_8;
        }
#line 1008
        if ((int )ssh.sense_key == 3) {
#line 1008
          goto case_8;
        }
#line 1010
        if ((int )ssh.sense_key == 6) {
#line 1010
          goto case_6;
        }
#line 1013
        if ((int )ssh.sense_key == 5) {
#line 1013
          goto case_5;
        }
#line 1019
        if ((int )ssh.sense_key == 11) {
#line 1019
          goto case_11;
        }
#line 1021
        goto switch_default;
        case_0: /* CIL Label */ 
#line 1001
        return (20);
        case_1: /* CIL Label */ 
#line 1003
        return (21);
        case_2: /* CIL Label */ 
#line 1005
        return (2);
        case_8: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 1009
        return (3);
        case_6: /* CIL Label */ 
#line 1011
        return (6);
        case_5: /* CIL Label */ 
#line 1014
        if (32 == (int )ssh.asc) {
#line 1014
          if (0 == (int )ssh.ascq) {
#line 1015
            return (9);
          } else {
#line 1017
            return (5);
          }
        } else {
#line 1017
          return (5);
        }
#line 1018
        goto switch_break;
        case_11: /* CIL Label */ 
#line 1020
        return (11);
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1025
  return (98);
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_get_command_size(unsigned char opcode ) 
{ 


  {
  {
#line 1033
  if ((((int )opcode >> 5) & 7) == 0) {
#line 1033
    goto case_0;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 7) {
#line 1035
    goto case_7;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 6) {
#line 1035
    goto case_7;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 2) {
#line 1035
    goto case_7;
  }
#line 1035
  if ((((int )opcode >> 5) & 7) == 1) {
#line 1035
    goto case_7;
  }
#line 1037
  if ((((int )opcode >> 5) & 7) == 5) {
#line 1037
    goto case_5;
  }
#line 1037
  if ((((int )opcode >> 5) & 7) == 3) {
#line 1037
    goto case_5;
  }
#line 1040
  if ((((int )opcode >> 5) & 7) == 4) {
#line 1040
    goto case_4;
  }
#line 1042
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1034
  return (6);
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1036
  return (10);
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1038
  return (12);
#line 1039
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1041
  return (16);
  switch_default: /* CIL Label */ 
#line 1043
  return (10);
  switch_break: /* CIL Label */ ;
  }
#line 1045
  return (0);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_get_command_name(unsigned char const   *cmdp , int peri_type , int buff_len ,
                         char *buff ) 
{ 
  int service_action ;

  {
#line 1053
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 1054
    return;
  } else
#line 1053
  if (buff_len < 1) {
#line 1054
    return;
  }
#line 1055
  if ((unsigned long )((void *)0) == (unsigned long )cmdp) {
    {
#line 1056
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)"<null> command pointer",
            (size_t )buff_len);
    }
#line 1057
    return;
  }
#line 1059
  if (127 == (int )*(cmdp + 0)) {
#line 1059
    service_action = (int )((int const   )*(cmdp + 1) & 31);
  } else {
#line 1059
    service_action = (int )(((int const   )*(cmdp + 8) << 8) | (int const   )*(cmdp + 9));
  }
  {
#line 1061
  sg_get_opcode_sa_name((unsigned char )*(cmdp + 0), service_action, peri_type, buff_len,
                        buff);
  }
#line 1062
  return;
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_get_opcode_sa_name(unsigned char cmd_byte0 , int service_action , int peri_type ,
                           int buff_len , char *buff ) 
{ 
  struct sg_lib_value_name_t  const  *vnp ;

  {
#line 1071
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 1072
    return;
  } else
#line 1071
  if (buff_len < 1) {
#line 1072
    return;
  }
  {
#line 1074
  if ((int )cmd_byte0 == 127) {
#line 1074
    goto case_127;
  }
#line 1083
  if ((int )cmd_byte0 == 163) {
#line 1083
    goto case_163;
  }
#line 1091
  if ((int )cmd_byte0 == 164) {
#line 1091
    goto case_164;
  }
#line 1099
  if ((int )cmd_byte0 == 171) {
#line 1099
    goto case_171;
  }
#line 1107
  if ((int )cmd_byte0 == 169) {
#line 1107
    goto case_169;
  }
#line 1115
  if ((int )cmd_byte0 == 158) {
#line 1115
    goto case_158;
  }
#line 1123
  if ((int )cmd_byte0 == 159) {
#line 1123
    goto case_159;
  }
#line 1131
  if ((int )cmd_byte0 == 94) {
#line 1131
    goto case_94;
  }
#line 1139
  if ((int )cmd_byte0 == 95) {
#line 1139
    goto case_95;
  }
#line 1147
  goto switch_default;
  case_127: /* CIL Label */ 
  {
#line 1075
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_variable_length_arr),
                       service_action, peri_type);
  }
#line 1077
  if (vnp) {
    {
#line 1078
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1080
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Variable length service action=0x%x",
             service_action);
    }
  }
#line 1082
  goto switch_break;
  case_163: /* CIL Label */ 
  {
#line 1084
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_maint_in_arr),
                       service_action, peri_type);
  }
#line 1085
  if (vnp) {
    {
#line 1086
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1088
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Maintenance in service action=0x%x",
             service_action);
    }
  }
#line 1090
  goto switch_break;
  case_164: /* CIL Label */ 
  {
#line 1092
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_maint_out_arr),
                       service_action, peri_type);
  }
#line 1093
  if (vnp) {
    {
#line 1094
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1096
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Maintenance out service action=0x%x",
             service_action);
    }
  }
#line 1098
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 1100
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_in12_arr),
                       service_action, peri_type);
  }
#line 1101
  if (vnp) {
    {
#line 1102
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1104
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action in(12)=0x%x",
             service_action);
    }
  }
#line 1106
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 1108
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_out12_arr),
                       service_action, peri_type);
  }
#line 1109
  if (vnp) {
    {
#line 1110
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1112
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action out(12)=0x%x",
             service_action);
    }
  }
#line 1114
  goto switch_break;
  case_158: /* CIL Label */ 
  {
#line 1116
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_in16_arr),
                       service_action, peri_type);
  }
#line 1117
  if (vnp) {
    {
#line 1118
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1120
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action in(16)=0x%x",
             service_action);
    }
  }
#line 1122
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 1124
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_serv_out16_arr),
                       service_action, peri_type);
  }
#line 1125
  if (vnp) {
    {
#line 1126
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1128
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Service action out(16)=0x%x",
             service_action);
    }
  }
#line 1130
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 1132
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_pr_in_arr), service_action,
                       peri_type);
  }
#line 1133
  if (vnp) {
    {
#line 1134
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1136
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Persistent reserve in, service action=0x%x",
             service_action);
    }
  }
#line 1138
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 1140
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_pr_out_arr),
                       service_action, peri_type);
  }
#line 1141
  if (vnp) {
    {
#line 1142
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1144
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Persistent reserve out, service action=0x%x",
             service_action);
    }
  }
#line 1146
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1148
  sg_get_opcode_name(cmd_byte0, peri_type, buff_len, buff);
  }
#line 1149
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1151
  return;
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void sg_get_opcode_name(unsigned char cmd_byte0 , int peri_type , int buff_len , char *buff ) 
{ 
  struct sg_lib_value_name_t  const  *vnp ;
  int grp ;

  {
#line 1160
  if ((unsigned long )((void *)0) == (unsigned long )buff) {
#line 1161
    return;
  } else
#line 1160
  if (buff_len < 1) {
#line 1161
    return;
  }
#line 1162
  if (127 == (int )cmd_byte0) {
    {
#line 1163
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)"Variable length",
            (size_t )buff_len);
    }
#line 1164
    return;
  }
#line 1166
  grp = ((int )cmd_byte0 >> 5) & 7;
  {
#line 1172
  if (grp == 5) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 4) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 2) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 1) {
#line 1172
    goto case_5;
  }
#line 1172
  if (grp == 0) {
#line 1172
    goto case_5;
  }
#line 1179
  if (grp == 3) {
#line 1179
    goto case_3;
  }
#line 1183
  if (grp == 7) {
#line 1183
    goto case_7;
  }
#line 1183
  if (grp == 6) {
#line 1183
    goto case_7;
  }
#line 1186
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1173
  vnp = get_value_name((struct sg_lib_value_name_t  const  *)(sg_lib_normal_opcodes),
                       (int )cmd_byte0, peri_type);
  }
#line 1174
  if (vnp) {
    {
#line 1175
    strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)vnp->name,
            (size_t )buff_len);
    }
  } else {
    {
#line 1177
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Opcode=0x%x",
             (int )cmd_byte0);
    }
  }
#line 1178
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1180
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Reserved [0x%x]",
           (int )cmd_byte0);
  }
#line 1181
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 1184
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Vendor specific [0x%x]",
           (int )cmd_byte0);
  }
#line 1185
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1187
  snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"Opcode=0x%x",
           (int )cmd_byte0);
  }
#line 1188
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1190
  return;
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_vpd_dev_id_iter(unsigned char const   *initial_desig_desc , int page_len ,
                       int *off , int m_assoc , int m_desig_type , int m_code_set ) 
{ 
  unsigned char const   *ucp ;
  int k ;
  int c_set ;
  int assoc ;
  int desig_type ;
  int tmp ;

  {
#line 1208
  k = *off;
#line 1208
  ucp = initial_desig_desc;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! (k + 3 < page_len)) {
#line 1208
      goto while_break;
    }
#line 1209
    if (k < 0) {
#line 1209
      k = 0;
    } else {
#line 1209
      k = (k + (int )*(ucp + (k + 3))) + 4;
    }
#line 1210
    if (k + 4 > page_len) {
#line 1211
      goto while_break;
    }
#line 1212
    c_set = (int )((int const   )*(ucp + k) & 15);
#line 1213
    if (m_code_set >= 0) {
#line 1213
      if (m_code_set != c_set) {
#line 1214
        goto __Cont;
      }
    }
#line 1215
    assoc = (int )(((int const   )*(ucp + (k + 1)) >> 4) & 3);
#line 1216
    if (m_assoc >= 0) {
#line 1216
      if (m_assoc != assoc) {
#line 1217
        goto __Cont;
      }
    }
#line 1218
    desig_type = (int )((int const   )*(ucp + (k + 1)) & 15);
#line 1219
    if (m_desig_type >= 0) {
#line 1219
      if (m_desig_type != desig_type) {
#line 1220
        goto __Cont;
      }
    }
#line 1221
    *off = k;
#line 1222
    return (0);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1224
  if (k == page_len) {
#line 1224
    tmp = -1;
  } else {
#line 1224
    tmp = -2;
  }
#line 1224
  return (tmp);
}
}
#line 1233 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static char safe_errbuf[64]  = 
#line 1233
  {      (char )'u',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'e',      (char )'r',      (char )'r',      (char )'n', 
        (char )'o',      (char )':',      (char )' ',      (char)0};
#line 1236 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
char *safe_strerror(int errnum ) 
{ 
  size_t len ;
  char *errstr ;

  {
#line 1242
  if (errnum < 0) {
#line 1243
    errnum = - errnum;
  }
  {
#line 1244
  errstr = strerror(errnum);
  }
#line 1245
  if ((unsigned long )((void *)0) == (unsigned long )errstr) {
    {
#line 1246
    len = strlen((char const   *)(safe_errbuf));
#line 1247
    snprintf((char */* __restrict  */)(safe_errbuf + len), sizeof(safe_errbuf) - len,
             (char const   */* __restrict  */)"%i", errnum);
#line 1248
    safe_errbuf[sizeof(safe_errbuf) - 1UL] = (char )'\000';
    }
#line 1249
    return (safe_errbuf);
  }
#line 1251
  return (errstr);
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void dStrHex(char const   *str , int len , int no_ascii ) 
{ 
  char const   *p ;
  char const   *formatstr ;
  unsigned char c ;
  char buff[82] ;
  int a ;
  int bpstart ;
  int cpstart ;
  int cpos ;
  int bpos ;
  int i ;
  int k ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1264
  p = str;
#line 1268
  a = 0;
#line 1269
  bpstart = 5;
#line 1270
  cpstart = 60;
#line 1271
  cpos = cpstart;
#line 1272
  bpos = bpstart;
#line 1275
  if (len <= 0) {
#line 1276
    return;
  }
#line 1277
  if (0 == no_ascii) {
#line 1277
    formatstr = "%.76s\n";
  } else {
#line 1277
    formatstr = "%.56s\n";
  }
  {
#line 1278
  memset((void *)(buff), ' ', (size_t )80);
#line 1279
  buff[80] = (char )'\000';
  }
#line 1280
  if (no_ascii < 0) {
#line 1281
    k = 0;
    {
#line 1281
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1281
      if (! (k < len)) {
#line 1281
        goto while_break;
      }
#line 1282
      tmp = p;
#line 1282
      p ++;
#line 1282
      c = (unsigned char )*tmp;
#line 1283
      bpos += 3;
#line 1284
      if (bpos == bpstart + 27) {
#line 1285
        bpos ++;
      }
      {
#line 1286
      sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
              (int )c);
#line 1287
      buff[bpos + 2] = (char )' ';
      }
#line 1288
      if (k > 0) {
#line 1288
        if (0 == (k + 1) % 16) {
          {
#line 1289
          printf((char const   */* __restrict  */)formatstr, buff);
#line 1290
          bpos = bpstart;
#line 1291
          memset((void *)(buff), ' ', (size_t )80);
          }
        }
      }
#line 1281
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1294
    if (bpos > bpstart) {
      {
#line 1295
      buff[bpos + 2] = (char )'\000';
#line 1296
      printf((char const   */* __restrict  */)"%s\n", buff);
      }
    }
#line 1298
    return;
  }
  {
#line 1301
  k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
              a);
#line 1302
  buff[k + 1] = (char )' ';
#line 1304
  i = 0;
  }
  {
#line 1304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1304
    if (! (i < len)) {
#line 1304
      goto while_break___0;
    }
#line 1305
    tmp___0 = p;
#line 1305
    p ++;
#line 1305
    c = (unsigned char )*tmp___0;
#line 1306
    bpos += 3;
#line 1307
    if (bpos == bpstart + 27) {
#line 1308
      bpos ++;
    }
    {
#line 1309
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
            (int )c);
#line 1310
    buff[bpos + 2] = (char )' ';
    }
#line 1311
    if (no_ascii) {
#line 1312
      tmp___1 = cpos;
#line 1312
      cpos ++;
#line 1312
      buff[tmp___1] = (char )' ';
    } else {
#line 1314
      if ((int )c < 32) {
#line 1315
        c = (unsigned char )'.';
      } else
#line 1314
      if ((int )c >= 127) {
#line 1315
        c = (unsigned char )'.';
      }
#line 1316
      tmp___2 = cpos;
#line 1316
      cpos ++;
#line 1316
      buff[tmp___2] = (char )c;
    }
#line 1318
    if (cpos > cpstart + 15) {
      {
#line 1319
      printf((char const   */* __restrict  */)formatstr, buff);
#line 1320
      bpos = bpstart;
#line 1321
      cpos = cpstart;
#line 1322
      a += 16;
#line 1323
      memset((void *)(buff), ' ', (size_t )80);
#line 1324
      k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
                  a);
#line 1325
      buff[k + 1] = (char )' ';
      }
    }
#line 1304
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1328
  if (cpos > cpstart) {
    {
#line 1329
    buff[cpos] = (char )'\000';
#line 1330
    printf((char const   */* __restrict  */)"%s\n", buff);
    }
  }
#line 1332
  return;
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static void dStrHexErr(char const   *str , int len , int b_len , char *b ) 
{ 
  char const   *p ;
  unsigned char c ;
  char buff[82] ;
  int bpstart ;
  int bpos ;
  int k ;
  int n ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1339
  p = str;
#line 1342
  bpstart = 5;
#line 1343
  bpos = bpstart;
#line 1346
  if (len <= 0) {
#line 1347
    return;
  }
  {
#line 1348
  n = 0;
#line 1349
  memset((void *)(buff), ' ', (size_t )80);
#line 1350
  buff[80] = (char )'\000';
#line 1351
  k = 0;
  }
  {
#line 1351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1351
    if (! (k < len)) {
#line 1351
      goto while_break;
    }
#line 1352
    tmp = p;
#line 1352
    p ++;
#line 1352
    c = (unsigned char )*tmp;
#line 1353
    bpos += 3;
#line 1354
    if (bpos == bpstart + 27) {
#line 1355
      bpos ++;
    }
    {
#line 1356
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.2x",
            (int )c);
#line 1357
    buff[bpos + 2] = (char )' ';
    }
#line 1358
    if (k > 0) {
#line 1358
      if (0 == (k + 1) % 16) {
        {
#line 1359
        tmp___0 = snprintf((char */* __restrict  */)(b + n), (size_t )(b_len - n),
                           (char const   */* __restrict  */)"%.60s\n", buff);
#line 1359
        n += tmp___0;
        }
#line 1360
        if (n >= b_len) {
#line 1361
          return;
        }
        {
#line 1362
        bpos = bpstart;
#line 1363
        memset((void *)(buff), ' ', (size_t )80);
        }
      }
    }
#line 1351
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1366
  if (bpos > bpstart) {
    {
#line 1367
    tmp___1 = snprintf((char */* __restrict  */)(b + n), (size_t )(b_len - n), (char const   */* __restrict  */)"%.60s\n",
                       buff);
#line 1367
    n += tmp___1;
    }
  }
#line 1368
  return;
}
}
#line 1374 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_is_big_endian(void) 
{ 
  union u_t u ;

  {
#line 1382
  u.s = (unsigned short)258;
#line 1383
  return ((int )u.c[0] == 1);
}
}
#line 1387 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
static unsigned short swapb_ushort(unsigned short u ) 
{ 
  unsigned short r ;

  {
#line 1392
  r = (unsigned short )(((int )u >> 8) & 255);
#line 1393
  r = (unsigned short )((int )r | (((int )u & 255) << 8));
#line 1394
  return (r);
}
}
#line 1407 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
void dWordHex(unsigned short const   *words , int num , int no_ascii , int swapb ) 
{ 
  unsigned short const   *p ;
  unsigned short c ;
  char buff[82] ;
  unsigned char upp ;
  unsigned char low ;
  int a ;
  int bpstart ;
  int cpstart ;
  int cpos ;
  int bpos ;
  int i ;
  int k ;
  unsigned short const   *tmp ;
  unsigned short const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1410
  p = words;
#line 1414
  a = 0;
#line 1415
  bpstart = 3;
#line 1416
  cpstart = 52;
#line 1417
  cpos = cpstart;
#line 1418
  bpos = bpstart;
#line 1421
  if (num <= 0) {
#line 1422
    return;
  }
  {
#line 1423
  memset((void *)(buff), ' ', (size_t )80);
#line 1424
  buff[80] = (char )'\000';
  }
#line 1425
  if (no_ascii < 0) {
#line 1426
    k = 0;
    {
#line 1426
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1426
      if (! (k < num)) {
#line 1426
        goto while_break;
      }
#line 1427
      tmp = p;
#line 1427
      p ++;
#line 1427
      c = (unsigned short )*tmp;
#line 1428
      if (swapb) {
        {
#line 1429
        c = swapb_ushort(c);
        }
      }
      {
#line 1430
      bpos += 5;
#line 1431
      sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.4x",
              (unsigned int )c);
#line 1432
      buff[bpos + 4] = (char )' ';
      }
#line 1433
      if (k > 0) {
#line 1433
        if (0 == (k + 1) % 8) {
#line 1434
          if (-2 == no_ascii) {
            {
#line 1435
            printf((char const   */* __restrict  */)"%.39s\n", buff + 8);
            }
          } else {
            {
#line 1437
            printf((char const   */* __restrict  */)"%.47s\n", buff);
            }
          }
          {
#line 1438
          bpos = bpstart;
#line 1439
          memset((void *)(buff), ' ', (size_t )80);
          }
        }
      }
#line 1426
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1442
    if (bpos > bpstart) {
#line 1443
      if (-2 == no_ascii) {
        {
#line 1444
        printf((char const   */* __restrict  */)"%.39s\n", buff + 8);
        }
      } else {
        {
#line 1446
        printf((char const   */* __restrict  */)"%.47s\n", buff);
        }
      }
    }
#line 1448
    return;
  }
  {
#line 1451
  k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
              a);
#line 1452
  buff[k + 1] = (char )' ';
#line 1454
  i = 0;
  }
  {
#line 1454
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1454
    if (! (i < num)) {
#line 1454
      goto while_break___0;
    }
#line 1455
    tmp___0 = p;
#line 1455
    p ++;
#line 1455
    c = (unsigned short )*tmp___0;
#line 1456
    if (swapb) {
      {
#line 1457
      c = swapb_ushort(c);
      }
    }
    {
#line 1458
    bpos += 5;
#line 1459
    sprintf((char */* __restrict  */)(& buff[bpos]), (char const   */* __restrict  */)"%.4x",
            (unsigned int )c);
#line 1460
    buff[bpos + 4] = (char )' ';
    }
#line 1461
    if (no_ascii) {
#line 1462
      tmp___1 = cpos;
#line 1462
      cpos ++;
#line 1462
      buff[tmp___1] = (char )' ';
#line 1463
      tmp___2 = cpos;
#line 1463
      cpos ++;
#line 1463
      buff[tmp___2] = (char )' ';
#line 1464
      tmp___3 = cpos;
#line 1464
      cpos ++;
#line 1464
      buff[tmp___3] = (char )' ';
    } else {
#line 1466
      upp = (unsigned char )(((int )c >> 8) & 255);
#line 1467
      low = (unsigned char )((int )c & 255);
#line 1468
      if ((int )upp < 32) {
#line 1469
        upp = (unsigned char )'.';
      } else
#line 1468
      if ((int )upp >= 127) {
#line 1469
        upp = (unsigned char )'.';
      }
#line 1470
      tmp___4 = cpos;
#line 1470
      cpos ++;
#line 1470
      buff[tmp___4] = (char )upp;
#line 1471
      if ((int )low < 32) {
#line 1472
        low = (unsigned char )'.';
      } else
#line 1471
      if ((int )low >= 127) {
#line 1472
        low = (unsigned char )'.';
      }
#line 1473
      tmp___5 = cpos;
#line 1473
      cpos ++;
#line 1473
      buff[tmp___5] = (char )low;
#line 1474
      tmp___6 = cpos;
#line 1474
      cpos ++;
#line 1474
      buff[tmp___6] = (char )' ';
    }
#line 1476
    if (cpos > cpstart + 23) {
      {
#line 1477
      printf((char const   */* __restrict  */)"%.76s\n", buff);
#line 1478
      bpos = bpstart;
#line 1479
      cpos = cpstart;
#line 1480
      a += 8;
#line 1481
      memset((void *)(buff), ' ', (size_t )80);
#line 1482
      k = sprintf((char */* __restrict  */)(buff + 1), (char const   */* __restrict  */)"%.2x",
                  a);
#line 1483
      buff[k + 1] = (char )' ';
      }
    }
#line 1454
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1486
  if (cpos > cpstart) {
    {
#line 1487
    printf((char const   */* __restrict  */)"%.76s\n", buff);
    }
  }
#line 1488
  return;
}
}
#line 1494 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_get_num(char const   *buf ) 
{ 
  int res ;
  int num ;
  int n ;
  int len ;
  unsigned int unum ;
  char *cp ;
  char c ;
  char c2 ;
  char c3 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1500
  c = (char )'c';
#line 1503
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1504
    return (-1);
  } else
#line 1503
  if (0 == (int )*(buf + 0)) {
#line 1504
    return (-1);
  }
  {
#line 1505
  tmp = strlen(buf);
#line 1505
  len = (int )tmp;
  }
#line 1506
  if (48 == (int )*(buf + 0)) {
#line 1506
    if (120 == (int )*(buf + 1)) {
      {
#line 1507
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1508
      num = (int )unum;
      }
    } else
#line 1506
    if (88 == (int )*(buf + 1)) {
      {
#line 1507
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1508
      num = (int )unum;
      }
    } else {
#line 1506
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1509
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 1509
    if (72 == tmp___0) {
      {
#line 1510
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 1511
      num = (int )unum;
      }
    } else {
      {
#line 1513
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d%c%c%c",
                   & num, & c, & c2, & c3);
      }
    }
  }
#line 1514
  if (res < 1) {
#line 1515
    return (-1);
  } else
#line 1516
  if (1 == res) {
#line 1517
    return (num);
  } else {
#line 1519
    if (res > 2) {
      {
#line 1520
      tmp___1 = toupper((int )c2);
#line 1520
      c2 = (char )tmp___1;
      }
    }
#line 1521
    if (res > 3) {
      {
#line 1522
      tmp___2 = toupper((int )c3);
#line 1522
      c3 = (char )tmp___2;
      }
    }
    {
#line 1523
    tmp___3 = toupper((int )c);
    }
    {
#line 1524
    if (tmp___3 == 67) {
#line 1524
      goto case_67;
    }
#line 1526
    if (tmp___3 == 87) {
#line 1526
      goto case_87;
    }
#line 1528
    if (tmp___3 == 66) {
#line 1528
      goto case_66;
    }
#line 1530
    if (tmp___3 == 75) {
#line 1530
      goto case_75;
    }
#line 1538
    if (tmp___3 == 77) {
#line 1538
      goto case_77;
    }
#line 1546
    if (tmp___3 == 71) {
#line 1546
      goto case_71;
    }
#line 1554
    if (tmp___3 == 88) {
#line 1554
      goto case_88;
    }
#line 1564
    goto switch_default;
    case_67: /* CIL Label */ 
#line 1525
    return (num);
    case_87: /* CIL Label */ 
#line 1527
    return (num * 2);
    case_66: /* CIL Label */ 
#line 1529
    return (num * 512);
    case_75: /* CIL Label */ 
#line 1531
    if (2 == res) {
#line 1532
      return (num * 1024);
    }
#line 1533
    if (66 == (int )c2) {
#line 1534
      return (num * 1000);
    } else
#line 1533
    if (68 == (int )c2) {
#line 1534
      return (num * 1000);
    }
#line 1535
    if (73 == (int )c2) {
#line 1535
      if (4 == res) {
#line 1535
        if (66 == (int )c3) {
#line 1536
          return (num * 1024);
        }
      }
    }
#line 1537
    return (-1);
    case_77: /* CIL Label */ 
#line 1539
    if (2 == res) {
#line 1540
      return (num * 1048576);
    }
#line 1541
    if (66 == (int )c2) {
#line 1542
      return (num * 1000000);
    } else
#line 1541
    if (68 == (int )c2) {
#line 1542
      return (num * 1000000);
    }
#line 1543
    if (73 == (int )c2) {
#line 1543
      if (4 == res) {
#line 1543
        if (66 == (int )c3) {
#line 1544
          return (num * 1048576);
        }
      }
    }
#line 1545
    return (-1);
    case_71: /* CIL Label */ 
#line 1547
    if (2 == res) {
#line 1548
      return (num * 1073741824);
    }
#line 1549
    if (66 == (int )c2) {
#line 1550
      return (num * 1000000000);
    } else
#line 1549
    if (68 == (int )c2) {
#line 1550
      return (num * 1000000000);
    }
#line 1551
    if (73 == (int )c2) {
#line 1551
      if (4 == res) {
#line 1551
        if (66 == (int )c3) {
#line 1552
          return (num * 1073741824);
        }
      }
    }
#line 1553
    return (-1);
    case_88: /* CIL Label */ 
    {
#line 1555
    cp = strchr(buf, 'x');
    }
#line 1556
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 1557
      cp = strchr(buf, 'X');
      }
    }
#line 1558
    if (cp) {
      {
#line 1559
      n = sg_get_num((char const   *)(cp + 1));
      }
#line 1560
      if (-1 != n) {
#line 1561
        return (num * n);
      }
    }
#line 1563
    return (-1);
    switch_default: /* CIL Label */ 
#line 1565
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1566
      sg_warnings_strm = stderr;
    }
    {
#line 1567
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"unrecognized multiplier\n");
    }
#line 1568
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 1577 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_get_num_nomult(char const   *buf ) 
{ 
  int res ;
  int len ;
  int num ;
  unsigned int unum ;
  char const   *commap ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1584
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1585
    return (-1);
  } else
#line 1584
  if (0 == (int )*(buf + 0)) {
#line 1585
    return (-1);
  }
  {
#line 1586
  tmp = strlen(buf);
#line 1586
  len = (int )tmp;
#line 1587
  tmp___0 = strchr(buf + 1, ',');
#line 1587
  commap = (char const   *)tmp___0;
  }
#line 1588
  if (48 == (int )*(buf + 0)) {
#line 1588
    if (120 == (int )*(buf + 1)) {
      {
#line 1589
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1590
      num = (int )unum;
      }
    } else
#line 1588
    if (88 == (int )*(buf + 1)) {
      {
#line 1589
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%x",
                   & unum);
#line 1590
      num = (int )unum;
      }
    } else {
#line 1588
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1591
  if (commap) {
    {
#line 1591
    tmp___2 = toupper((int )*(commap - 1));
    }
#line 1591
    if (72 == tmp___2) {
      {
#line 1592
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 1593
      num = (int )unum;
      }
    } else {
#line 1591
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1594
  if ((unsigned long )((void *)0) == (unsigned long )commap) {
    {
#line 1594
    tmp___1 = toupper((int )*(buf + (len - 1)));
    }
#line 1594
    if (72 == tmp___1) {
      {
#line 1595
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%x",
                   & unum);
#line 1596
      num = (int )unum;
      }
    } else {
      {
#line 1598
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d",
                   & num);
      }
    }
  } else {
    {
#line 1598
    res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%d",
                 & num);
    }
  }
#line 1599
  if (1 == res) {
#line 1600
    return (num);
  } else {
#line 1602
    return (-1);
  }
}
}
#line 1609 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int64_t sg_get_llnum(char const   *buf ) 
{ 
  int res ;
  int len ;
  int64_t num ;
  int64_t ll ;
  uint64_t unum ;
  char *cp ;
  char c ;
  char c2 ;
  char c3 ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1616
  c = (char )'c';
#line 1619
  if ((unsigned long )((void *)0) == (unsigned long )buf) {
#line 1620
    return ((int64_t )-1LL);
  } else
#line 1619
  if (0 == (int )*(buf + 0)) {
#line 1620
    return ((int64_t )-1LL);
  }
  {
#line 1621
  tmp = strlen(buf);
#line 1621
  len = (int )tmp;
  }
#line 1622
  if (48 == (int )*(buf + 0)) {
#line 1622
    if (120 == (int )*(buf + 1)) {
      {
#line 1623
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1624
      num = (int64_t )unum;
      }
    } else
#line 1622
    if (88 == (int )*(buf + 1)) {
      {
#line 1623
      res = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1624
      num = (int64_t )unum;
      }
    } else {
#line 1622
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1625
    tmp___0 = toupper((int )*(buf + (len - 1)));
    }
#line 1625
    if (72 == tmp___0) {
      {
#line 1626
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%lx",
                   & unum);
#line 1627
      num = (int64_t )unum;
      }
    } else {
      {
#line 1629
      res = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"%ld%c%c%c",
                   & num, & c, & c2, & c3);
      }
    }
  }
#line 1630
  if (res < 1) {
#line 1631
    return ((int64_t )-1LL);
  } else
#line 1632
  if (1 == res) {
#line 1633
    return (num);
  } else {
#line 1635
    if (res > 2) {
      {
#line 1636
      tmp___1 = toupper((int )c2);
#line 1636
      c2 = (char )tmp___1;
      }
    }
#line 1637
    if (res > 3) {
      {
#line 1638
      tmp___2 = toupper((int )c3);
#line 1638
      c3 = (char )tmp___2;
      }
    }
    {
#line 1639
    tmp___3 = toupper((int )c);
    }
    {
#line 1640
    if (tmp___3 == 67) {
#line 1640
      goto case_67;
    }
#line 1642
    if (tmp___3 == 87) {
#line 1642
      goto case_87;
    }
#line 1644
    if (tmp___3 == 66) {
#line 1644
      goto case_66;
    }
#line 1646
    if (tmp___3 == 75) {
#line 1646
      goto case_75;
    }
#line 1654
    if (tmp___3 == 77) {
#line 1654
      goto case_77;
    }
#line 1662
    if (tmp___3 == 71) {
#line 1662
      goto case_71;
    }
#line 1670
    if (tmp___3 == 84) {
#line 1670
      goto case_84;
    }
#line 1678
    if (tmp___3 == 80) {
#line 1678
      goto case_80;
    }
#line 1686
    if (tmp___3 == 88) {
#line 1686
      goto case_88;
    }
#line 1696
    goto switch_default;
    case_67: /* CIL Label */ 
#line 1641
    return (num);
    case_87: /* CIL Label */ 
#line 1643
    return (num * 2L);
    case_66: /* CIL Label */ 
#line 1645
    return (num * 512L);
    case_75: /* CIL Label */ 
#line 1647
    if (2 == res) {
#line 1648
      return (num * 1024L);
    }
#line 1649
    if (66 == (int )c2) {
#line 1650
      return (num * 1000L);
    } else
#line 1649
    if (68 == (int )c2) {
#line 1650
      return (num * 1000L);
    }
#line 1651
    if (73 == (int )c2) {
#line 1651
      if (4 == res) {
#line 1651
        if (66 == (int )c3) {
#line 1652
          return (num * 1024L);
        }
      }
    }
#line 1653
    return ((int64_t )-1LL);
    case_77: /* CIL Label */ 
#line 1655
    if (2 == res) {
#line 1656
      return (num * 1048576L);
    }
#line 1657
    if (66 == (int )c2) {
#line 1658
      return (num * 1000000L);
    } else
#line 1657
    if (68 == (int )c2) {
#line 1658
      return (num * 1000000L);
    }
#line 1659
    if (73 == (int )c2) {
#line 1659
      if (4 == res) {
#line 1659
        if (66 == (int )c3) {
#line 1660
          return (num * 1048576L);
        }
      }
    }
#line 1661
    return ((int64_t )-1LL);
    case_71: /* CIL Label */ 
#line 1663
    if (2 == res) {
#line 1664
      return (num * 1073741824L);
    }
#line 1665
    if (66 == (int )c2) {
#line 1666
      return (num * 1000000000L);
    } else
#line 1665
    if (68 == (int )c2) {
#line 1666
      return (num * 1000000000L);
    }
#line 1667
    if (73 == (int )c2) {
#line 1667
      if (4 == res) {
#line 1667
        if (66 == (int )c3) {
#line 1668
          return (num * 1073741824L);
        }
      }
    }
#line 1669
    return ((int64_t )-1LL);
    case_84: /* CIL Label */ 
#line 1671
    if (2 == res) {
#line 1672
      return ((int64_t )((long long )num * 1099511627776LL));
    }
#line 1673
    if (66 == (int )c2) {
#line 1674
      return ((int64_t )((long long )num * 1000000000000LL));
    } else
#line 1673
    if (68 == (int )c2) {
#line 1674
      return ((int64_t )((long long )num * 1000000000000LL));
    }
#line 1675
    if (73 == (int )c2) {
#line 1675
      if (4 == res) {
#line 1675
        if (66 == (int )c3) {
#line 1676
          return ((int64_t )((long long )num * 1099511627776LL));
        }
      }
    }
#line 1677
    return ((int64_t )-1LL);
    case_80: /* CIL Label */ 
#line 1679
    if (2 == res) {
#line 1680
      return ((int64_t )(((long long )num * 1099511627776LL) * 1024LL));
    }
#line 1681
    if (66 == (int )c2) {
#line 1682
      return ((int64_t )(((long long )num * 1000000000000LL) * 1000LL));
    } else
#line 1681
    if (68 == (int )c2) {
#line 1682
      return ((int64_t )(((long long )num * 1000000000000LL) * 1000LL));
    }
#line 1683
    if (73 == (int )c2) {
#line 1683
      if (4 == res) {
#line 1683
        if (66 == (int )c3) {
#line 1684
          return ((int64_t )(((long long )num * 1099511627776LL) * 1024LL));
        }
      }
    }
#line 1685
    return ((int64_t )-1LL);
    case_88: /* CIL Label */ 
    {
#line 1687
    cp = strchr(buf, 'x');
    }
#line 1688
    if ((unsigned long )((void *)0) == (unsigned long )cp) {
      {
#line 1689
      cp = strchr(buf, 'X');
      }
    }
#line 1690
    if (cp) {
      {
#line 1691
      ll = sg_get_llnum((char const   *)(cp + 1));
      }
#line 1692
      if (-1LL != (long long )ll) {
#line 1693
        return (num * ll);
      }
    }
#line 1695
    return ((int64_t )-1LL);
    switch_default: /* CIL Label */ 
#line 1697
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 1698
      sg_warnings_strm = stderr;
    }
    {
#line 1699
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"unrecognized multiplier\n");
    }
#line 1700
    return ((int64_t )-1LL);
    switch_break: /* CIL Label */ ;
    }
  }
}
}
#line 1709 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_ata_get_chars(unsigned short const   *word_arr , int start_word , int num_words ,
                     int is_big_endian , char *ochars ) 
{ 
  int k ;
  unsigned short s ;
  char a ;
  char b ;
  char *op ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1716
  op = ochars;
#line 1718
  k = start_word;
  {
#line 1718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1718
    if (! (k < start_word + num_words)) {
#line 1718
      goto while_break;
    }
#line 1719
    s = (unsigned short )*(word_arr + k);
#line 1720
    if (is_big_endian) {
#line 1721
      a = (char )((int )s & 255);
#line 1722
      b = (char )(((int )s >> 8) & 255);
    } else {
#line 1724
      a = (char )(((int )s >> 8) & 255);
#line 1725
      b = (char )((int )s & 255);
    }
#line 1727
    if ((int )a == 0) {
#line 1728
      goto while_break;
    }
#line 1729
    tmp = op;
#line 1729
    op ++;
#line 1729
    *tmp = a;
#line 1730
    if ((int )b == 0) {
#line 1731
      goto while_break;
    }
#line 1732
    tmp___0 = op;
#line 1732
    op ++;
#line 1732
    *tmp___0 = b;
#line 1718
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1734
  return ((int )(op - ochars));
}
}
#line 1737 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
char const   *sg_lib_version(void) 
{ 


  {
#line 1740
  return (sg_lib_version_str);
}
}
#line 1768 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_set_text_mode(int fd ) 
{ 


  {
#line 1771
  return (fd);
}
}
#line 1774 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib.c"
int sg_set_binary_mode(int fd ) 
{ 


  {
#line 1777
  return (fd);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
char const   *sg_lib_version_str  =    "1.71 20111025";
#line 20 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_normal_opcodes[182]  = 
#line 20
  {      {0, 0, "Test Unit Ready"}, 
        {1, 0, "Rezero Unit"}, 
        {1, 1, "Rewind"}, 
        {3, 0, "Request Sense"}, 
        {4, 0, "Format Unit"}, 
        {4, 1, "Format medium"}, 
        {4, 2, "Format"}, 
        {5, 0, "Read Block Limits"}, 
        {7, 0, "Reassign Blocks"}, 
        {7, 8, "Initialize element status"}, 
        {8, 0, "Read(6)"}, 
        {8, 3, "Receive"}, 
        {10, 0, "Write(6)"}, 
        {10, 2, "Print"}, 
        {10, 3, "Send"}, 
        {11, 0, "Seek(6)"}, 
        {11, 1, "Set capacity"}, 
        {11, 2, "Slew and print"}, 
        {15, 0, "Read reverse(6)"}, 
        {16, 0, "Write filemarks(6)"}, 
        {16, 2, "Synchronize buffer"}, 
        {17, 0, "Space(6)"}, 
        {18, 0, "Inquiry"}, 
        {19, 0, "Verify(6)"}, 
        {20, 0, "Recover buffered data"}, 
        {21, 0, "Mode select(6)"}, 
        {22, 0, "Reserve(6)"}, 
        {22, 8, "Reserve element(6)"}, 
        {23, 0, "Release(6)"}, 
        {23, 8, "Release element(6)"}, 
        {24, 0, "Copy"}, 
        {25, 0, "Erase(6)"}, 
        {26, 0, "Mode sense(6)"}, 
        {27, 0, "Start stop unit"}, 
        {27, 1, "Load unload"}, 
        {27, 18, "Load unload"}, 
        {27, 2, "Stop print"}, 
        {28, 0, "Receive diagnostic results"}, 
        {29, 0, "Send diagnostic"}, 
        {30, 0, "Prevent allow medium removal"}, 
        {35, 0, "Read Format capacities"}, 
        {36, 0, "Set window"}, 
        {37, 0, "Read capacity(10)"}, 
        {37, 15, "Read card capacity"}, 
        {40, 0, "Read(10)"}, 
        {41, 0, "Read generation"}, 
        {42, 0, "Write(10)"}, 
        {43, 0, "Seek(10)"}, 
        {43, 1, "Locate(10)"}, 
        {43, 8, "Position to element"}, 
        {44, 0, "Erase(10)"}, 
        {45, 0, "Read updated block"}, 
        {46, 0, "Write and verify(10)"}, 
        {47, 0, "Verify(10)"}, 
        {48, 0, "Search data high(10)"}, 
        {49, 0, "Search data equal(10)"}, 
        {50, 0, "Search data low(10)"}, 
        {51, 0, "Set limits(10)"}, 
        {52, 0, "Pre-fetch(10)"}, 
        {52, 1, "Read position"}, 
        {53, 0, "Synchronize cache(10)"}, 
        {54, 0, "Lock unlock cache(10)"}, 
        {55, 0, "Read defect data(10)"}, 
        {55, 8, "Initialize element status with range"}, 
        {56, 0, "Medium scan"}, 
        {57, 0, "Compare"}, 
        {58, 0, "Copy and verify"}, 
        {59, 0, "Write buffer"}, 
        {60, 0, "Read buffer"}, 
        {61, 0, "Update block"}, 
        {62, 0, "Read long(10)"}, 
        {63, 0, "Write long(10)"}, 
        {64, 0, "Change definition"}, 
        {65, 0, "Write same(10)"}, 
        {66, 0, "Unmap"}, 
        {66, 5, "Read sub-channel"}, 
        {67, 5, "Read TOC/PMA/ATIP"}, 
        {68, 0, "Report density support"}, 
        {69, 5, "Play audio(10)"}, 
        {70, 5, "Get configuration"}, 
        {71, 5, "Play audio msf"}, 
        {72, 0, "Sanitize"}, 
        {74, 5, "Get event status notification"}, 
        {75, 5, "Pause/resume"}, 
        {76, 0, "Log select"}, 
        {77, 0, "Log sense"}, 
        {78, 0, "Stop play/scan"}, 
        {80, 0, "Xdwrite(10)"}, 
        {81, 0, "Xpwrite(10)"}, 
        {81, 5, "Read disk information"}, 
        {82, 0, "Xdread(10)"}, 
        {82, 5, "Read track information"}, 
        {83, 0, "Reserve track"}, 
        {84, 0, "Send OPC information"}, 
        {85, 0, "Mode select(10)"}, 
        {86, 0, "Reserve(10)"}, 
        {86, 8, "Reserve element(10)"}, 
        {87, 0, "Release(10)"}, 
        {87, 8, "Release element(10)"}, 
        {88, 0, "Repair track"}, 
        {90, 0, "Mode sense(10)"}, 
        {91, 0, "Close track/session"}, 
        {92, 0, "Read buffer capacity"}, 
        {93, 0, "Send cue sheet"}, 
        {94, 0, "Persistent reserve in"}, 
        {95, 0, "Persistent reserve out"}, 
        {126, 0, "Extended cdb (XCBD)"}, 
        {128, 0, "Xdwrite extended(16)"}, 
        {128, 1, "Write filemarks(16)"}, 
        {129, 0, "Rebuild(16)"}, 
        {129, 1, "Read reverse(16)"}, 
        {130, 0, "Regenerate(16)"}, 
        {131, 0, "Extended copy"}, 
        {132, 0, "Receive copy results"}, 
        {133, 0, "ATA command pass through(16)"}, 
        {134, 0, "Access control in"}, 
        {135, 0, "Access control out"}, 
        {136, 0, "Read(16)"}, 
        {137, 0, "Compare and write"}, 
        {138, 0, "Write(16)"}, 
        {139, 0, "Orwrite(16)"}, 
        {140, 0, "Read attribute"}, 
        {141, 0, "Write attribute"}, 
        {142, 0, "Write and verify(16)"}, 
        {143, 0, "Verify(16)"}, 
        {144, 0, "Pre-fetch(16)"}, 
        {145, 0, "Synchronize cache(16)"}, 
        {145, 1, "Space(16)"}, 
        {146, 0, "Lock unlock cache(16)"}, 
        {146, 1, "Locate(16)"}, 
        {147, 0, "Write same(16)"}, 
        {147, 1, "Erase(16)"}, 
        {158, 0, "Service action in(16)"}, 
        {159, 0, "Service action out(16)"}, 
        {160, 0, "Report luns"}, 
        {161, 0, "ATA command pass through(12)"}, 
        {161, 5, "Blank"}, 
        {162, 0, "Security protocol in"}, 
        {163, 0, "Maintenance in"}, 
        {163, 5, "Send key"}, 
        {164, 0, "Maintenance out"}, 
        {164, 5, "Report key"}, 
        {165, 0, "Move medium"}, 
        {165, 5, "Play audio(12)"}, 
        {166, 0, "Exchange medium"}, 
        {166, 5, "Load/unload medium"}, 
        {167, 0, "Move medium attached"}, 
        {167, 5, "Set read ahead"}, 
        {168, 0, "Read(12)"}, 
        {169, 0, "Service action out(12)"}, 
        {170, 0, "Write(12)"}, 
        {171, 0, "Service action in(12)"}, 
        {172, 0, "erase(12)"}, 
        {172, 5, "Get performance"}, 
        {173, 5, "Read DVD/BD structure"}, 
        {174, 0, "Write and verify(12)"}, 
        {175, 0, "Verify(12)"}, 
        {176, 0, "Search data high(12)"}, 
        {177, 0, "Search data equal(12)"}, 
        {177, 8, "Open/close import/export element"}, 
        {178, 0, "Search data low(12)"}, 
        {179, 0, "Set limits(12)"}, 
        {180, 0, "Read element status attached"}, 
        {181, 0, "Security protocol out"}, 
        {181, 8, "Request volume element address"}, 
        {182, 0, "Send volume tag"}, 
        {182, 5, "Set streaming"}, 
        {183, 0, "Read defect data(12)"}, 
        {184, 0, "Read element status"}, 
        {185, 0, "Read CD msf"}, 
        {186, 0, "Redundancy group in"}, 
        {186, 5, "Scan"}, 
        {187, 0, "Redundancy group out"}, 
        {187, 5, "Set CD speed"}, 
        {188, 0, "Spare in"}, 
        {189, 0, "Spare out"}, 
        {189, 5, "Mechanism status"}, 
        {190, 0, "Volume set in"}, 
        {190, 5, "Read CD"}, 
        {191, 0, "Volume set out"}, 
        {191, 5, "Send DVD/BD structure"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 205 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_maint_in_arr[9]  = 
#line 205
  {      {5, 0, "Report identifying information"}, 
        {10, 0, "Report target port groups"}, 
        {11, 0, "Report aliases"}, 
        {12, 0, "Report supported operation codes"}, 
        {13, 0, "Report supported task management functions"}, 
        {14, 0, "Report priority"}, 
        {15, 0, "Report timestamp"}, 
        {16, 0, "Maintenance in"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 218 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_maint_out_arr[7]  = {      {6, 0, "Set identifying information"}, 
        {10, 0, "Set target port groups"}, 
        {11, 0, "Change aliases"}, 
        {14, 0, "Set priority"}, 
        {15, 0, "Set timestamp"}, 
        {16, 0, "Maintenance out"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 229 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_in12_arr[2]  = {      {1, 0, "Read media serial number"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 234 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_out12_arr[2]  = {      {255, 0, "Impossible command name"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 239 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_in16_arr[5]  = {      {16, 0, "Read capacity(16)"}, 
        {17, 0, "Read long(16)"}, 
        {18, 0, "Get LBA status"}, 
        {19, 0, "Report referrals"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 247 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_serv_out16_arr[3]  = {      {17, 0, "Write long(16)"}, 
        {31, 18, "Notify data transfer device(16)"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 253 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_pr_in_arr[5]  = {      {0, 0, "Persistent reserve in, read keys"}, 
        {1, 0, "Persistent reserve in, read reservation"}, 
        {2, 0, "Persistent reserve in, report capabilities"}, 
        {3, 0, "Persistent reserve in, read full status"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 261 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_pr_out_arr[9]  = 
#line 261
  {      {0, 0, "Persistent reserve out, register"}, 
        {1, 0, "Persistent reserve out, reserve"}, 
        {2, 0, "Persistent reserve out, release"}, 
        {3, 0, "Persistent reserve out, clear"}, 
        {4, 0, "Persistent reserve out, preempt"}, 
        {5, 0, "Persistent reserve out, preempt and abort"}, 
        {6, 0, "Persistent reserve out, register and ignore existing key"}, 
        {7, 0, "Persistent reserve out, register and move"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 273 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_value_name_t sg_lib_variable_length_arr[70]  = 
#line 273
  {      {1, 0, "Rebuild(32)"}, 
        {2, 0, "Regenerate(32)"}, 
        {3, 0, "Xdread(32)"}, 
        {4, 0, "Xdwrite(32)"}, 
        {5, 0, "Xdwrite extended(32)"}, 
        {6, 0, "Xpwrite(32)"}, 
        {7, 0, "Xdwriteread(32)"}, 
        {8, 0, "Xdwrite extended(64)"}, 
        {9, 0, "Read(32)"}, 
        {10, 0, "Verify(32)"}, 
        {11, 0, "Write(32)"}, 
        {12, 0, "Write an verify(32)"}, 
        {13, 0, "Write same(32)"}, 
        {14, 0, "Orwrite(32)"}, 
        {6144, 0, "Receive credential"}, 
        {34817, 0, "Format OSD (osd)"}, 
        {34818, 0, "Create (osd)"}, 
        {34819, 0, "List (osd)"}, 
        {34821, 0, "Read (osd)"}, 
        {34822, 0, "Write (osd)"}, 
        {34823, 0, "Append (osd)"}, 
        {34824, 0, "Flush (osd)"}, 
        {34826, 0, "Remove (osd)"}, 
        {34827, 0, "Create partition (osd)"}, 
        {34828, 0, "Remove partition (osd)"}, 
        {34830, 0, "Get attributes (osd)"}, 
        {34831, 0, "Set attributes (osd)"}, 
        {34834, 0, "Create and write (osd)"}, 
        {34837, 0, "Create collection (osd)"}, 
        {34838, 0, "Remove collection (osd)"}, 
        {34839, 0, "List collection (osd)"}, 
        {34840, 0, "Set key (osd)"}, 
        {34841, 0, "Set master key (osd)"}, 
        {34842, 0, "Flush collection (osd)"}, 
        {34843, 0, "Flush partition (osd)"}, 
        {34844, 0, "Flush OSD (osd)"}, 
        {34944, 0, "Object structure check (osd-2)"}, 
        {34945, 0, "Format OSD (osd-2)"}, 
        {34946, 0, "Create (osd-2)"}, 
        {34947, 0, "List (osd-2)"}, 
        {34948, 0, "Punch (osd-2)"}, 
        {34949, 0, "Read (osd-2)"}, 
        {34950, 0, "Write (osd-2)"}, 
        {34951, 0, "Append (osd-2)"}, 
        {34952, 0, "Flush (osd-2)"}, 
        {34953, 0, "Clear (osd-2)"}, 
        {34954, 0, "Remove (osd-2)"}, 
        {34955, 0, "Create partition (osd-2)"}, 
        {34956, 0, "Remove partition (osd-2)"}, 
        {34958, 0, "Get attributes (osd-2)"}, 
        {34959, 0, "Set attributes (osd-2)"}, 
        {34962, 0, "Create and write (osd-2)"}, 
        {34965, 0, "Create collection (osd-2)"}, 
        {34966, 0, "Remove collection (osd-2)"}, 
        {34967, 0, "List collection (osd-2)"}, 
        {34968, 0, "Set key (osd-2)"}, 
        {34969, 0, "Set master key (osd-2)"}, 
        {34970, 0, "Flush collection (osd-2)"}, 
        {34971, 0, "Flush partition (osd-2)"}, 
        {34972, 0, "Flush OSD (osd-2)"}, 
        {34976, 0, "Query (osd-2)"}, 
        {34977, 0, "Remove member objects (osd-2)"}, 
        {34978, 0, "Get member attributes (osd-2)"}, 
        {34979, 0, "Set member attributes (osd-2)"}, 
        {34993, 0, "Read map (osd-2)"}, 
        {36732, 0, "Perform SCSI command (osd-2)"}, 
        {36733, 0, "Perform task management function (osd-2)"}, 
        {36734, 0, "Perform SCSI command (osd)"}, 
        {36735, 0, "Perform task management function (osd)"}, 
        {65535, 0, (char const   *)((void *)0)}};
#line 349 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_asc_ascq_range_t sg_lib_asc_ascq_range[7]  = {      {(unsigned char)64, (unsigned char)1, (unsigned char)127, "Ram failure [0x%x]"}, 
        {(unsigned char)64,
      (unsigned char)128, (unsigned char)255, "Diagnostic failure on component [0x%x]"}, 
        {(unsigned char)65,
      (unsigned char)1, (unsigned char)255, "Data path failure [0x%x]"}, 
        {(unsigned char)66, (unsigned char)1, (unsigned char)255, "Power-on or self-test failure [0x%x]"}, 
        {(unsigned char)77,
      (unsigned char)0, (unsigned char)255, "Tagged overlapped commands [0x%x]"}, 
        {(unsigned char)112, (unsigned char)0, (unsigned char)255, "Decompression exception short algorithm id of 0x%x"}, 
        {(unsigned char)0,
      (unsigned char)0, (unsigned char)0, (char const   *)((void *)0)}};
#line 360 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
struct sg_lib_asc_ascq_t sg_lib_asc_ascq[648]  = 
#line 360
  {      {(unsigned char)0, (unsigned char)0, "No additional sense information"}, 
        {(unsigned char)0, (unsigned char)1, "Filemark detected"}, 
        {(unsigned char)0, (unsigned char)2, "End-of-partition/medium detected"}, 
        {(unsigned char)0, (unsigned char)3, "Setmark detected"}, 
        {(unsigned char)0, (unsigned char)4, "Beginning-of-partition/medium detected"}, 
        {(unsigned char)0,
      (unsigned char)5, "End-of-data detected"}, 
        {(unsigned char)0, (unsigned char)6, "I/O process terminated"}, 
        {(unsigned char)0, (unsigned char)7, "Programmable early warning detected"}, 
        {(unsigned char)0, (unsigned char)17, "Audio play operation in progress"}, 
        {(unsigned char)0, (unsigned char)18, "Audio play operation paused"}, 
        {(unsigned char)0, (unsigned char)19, "Audio play operation successfully completed"}, 
        {(unsigned char)0,
      (unsigned char)20, "Audio play operation stopped due to error"}, 
        {(unsigned char)0, (unsigned char)21, "No current audio status to return"}, 
        {(unsigned char)0, (unsigned char)22, "operation in progress"}, 
        {(unsigned char)0, (unsigned char)23, "Cleaning requested"}, 
        {(unsigned char)0, (unsigned char)24, "Erase operation in progress"}, 
        {(unsigned char)0, (unsigned char)25, "Locate operation in progress"}, 
        {(unsigned char)0, (unsigned char)26, "Rewind operation in progress"}, 
        {(unsigned char)0, (unsigned char)27, "Set capacity operation in progress"}, 
        {(unsigned char)0, (unsigned char)28, "Verify operation in progress"}, 
        {(unsigned char)0, (unsigned char)29, "ATA pass through information available"}, 
        {(unsigned char)0,
      (unsigned char)30, "Conflicting SA creation request"}, 
        {(unsigned char)0, (unsigned char)31, "Logical unit transitioning to another power condition"}, 
        {(unsigned char)1,
      (unsigned char)0, "No index/sector signal"}, 
        {(unsigned char)2, (unsigned char)0, "No seek complete"}, 
        {(unsigned char)3, (unsigned char)0, "Peripheral device write fault"}, 
        {(unsigned char)3, (unsigned char)1, "No write current"}, 
        {(unsigned char)3, (unsigned char)2, "Excessive write errors"}, 
        {(unsigned char)4, (unsigned char)0, "Logical unit not ready, cause not reportable"}, 
        {(unsigned char)4,
      (unsigned char)1, "Logical unit is in process of becoming ready"}, 
        {(unsigned char)4, (unsigned char)2, "Logical unit not ready, initializing command required"}, 
        {(unsigned char)4,
      (unsigned char)3, "Logical unit not ready, manual intervention required"}, 
        {(unsigned char)4, (unsigned char)4, "Logical unit not ready, format in progress"}, 
        {(unsigned char)4,
      (unsigned char)5, "Logical unit not ready, rebuild in progress"}, 
        {(unsigned char)4, (unsigned char)6, "Logical unit not ready, recalculation in progress"}, 
        {(unsigned char)4,
      (unsigned char)7, "Logical unit not ready, operation in progress"}, 
        {(unsigned char)4, (unsigned char)8, "Logical unit not ready, long write in progress"}, 
        {(unsigned char)4,
      (unsigned char)9, "Logical unit not ready, self-test in progress"}, 
        {(unsigned char)4, (unsigned char)10, "Logical unit not accessible, asymmetric access state transition"}, 
        {(unsigned char)4,
      (unsigned char)11, "Logical unit not accessible, target port in standby state"}, 
        {(unsigned char)4,
      (unsigned char)12, "Logical unit not accessible, target port in unavailable state"}, 
        {(unsigned char)4,
      (unsigned char)13, "Logical unit not ready, structure check required"}, 
        {(unsigned char)4, (unsigned char)16, "Logical unit not ready, auxiliary memory not accessible"}, 
        {(unsigned char)4,
      (unsigned char)17, "Logical unit not ready, notify (enable spinup) required"}, 
        {(unsigned char)4,
      (unsigned char)18, "Logical unit not ready, offline"}, 
        {(unsigned char)4, (unsigned char)19, "Logical unit not ready, SA creation in progress"}, 
        {(unsigned char)4,
      (unsigned char)20, "Logical unit not ready, space allocation in progress"}, 
        {(unsigned char)4, (unsigned char)21, "Logical unit not ready, robotics disabled"}, 
        {(unsigned char)4,
      (unsigned char)22, "Logical unit not ready, configuration required"}, 
        {(unsigned char)4, (unsigned char)23, "Logical unit not ready, calibration required"}, 
        {(unsigned char)4,
      (unsigned char)24, "Logical unit not ready, a door is open"}, 
        {(unsigned char)4, (unsigned char)25, "Logical unit not ready, operating in sequential mode"}, 
        {(unsigned char)4,
      (unsigned char)26, "Logical unit not ready, start stop unit command in progress"}, 
        {(unsigned char)4,
      (unsigned char)27, "Logical unit not ready, sanitize in progress"}, 
        {(unsigned char)4, (unsigned char)28, "Logical unit not ready, additional power use not yet granted"}, 
        {(unsigned char)5,
      (unsigned char)0, "Logical unit does not respond to selection"}, 
        {(unsigned char)6, (unsigned char)0, "No reference position found"}, 
        {(unsigned char)7, (unsigned char)0, "Multiple peripheral devices selected"}, 
        {(unsigned char)8,
      (unsigned char)0, "Logical unit communication failure"}, 
        {(unsigned char)8, (unsigned char)1, "Logical unit communication time-out"}, 
        {(unsigned char)8, (unsigned char)2, "Logical unit communication parity error"}, 
        {(unsigned char)8,
      (unsigned char)3, "Logical unit communication CRC error (Ultra-DMA/32)"}, 
        {(unsigned char)8, (unsigned char)4, "Unreachable copy target"}, 
        {(unsigned char)9, (unsigned char)0, "Track following error"}, 
        {(unsigned char)9, (unsigned char)1, "Tracking servo failure"}, 
        {(unsigned char)9, (unsigned char)2, "Focus servo failure"}, 
        {(unsigned char)9, (unsigned char)3, "Spindle servo failure"}, 
        {(unsigned char)9, (unsigned char)4, "Head select fault"}, 
        {(unsigned char)10, (unsigned char)0, "Error log overflow"}, 
        {(unsigned char)11, (unsigned char)0, "Warning"}, 
        {(unsigned char)11, (unsigned char)1, "Warning - specified temperature exceeded"}, 
        {(unsigned char)11,
      (unsigned char)2, "Warning - enclosure degraded"}, 
        {(unsigned char)11, (unsigned char)3, "Warning - background self-test failed"}, 
        {(unsigned char)11,
      (unsigned char)4, "Warning - background pre-scan detected medium error"}, 
        {(unsigned char)11, (unsigned char)5, "Warning - background medium scan detected medium error"}, 
        {(unsigned char)11,
      (unsigned char)6, "Warning - non-volatile cache now volatile"}, 
        {(unsigned char)11, (unsigned char)7, "Warning - degraded power to non-volatile cache"}, 
        {(unsigned char)11,
      (unsigned char)8, "Warning - power loss expected"}, 
        {(unsigned char)12, (unsigned char)0, "Write error"}, 
        {(unsigned char)12, (unsigned char)1, "Write error - recovered with auto reallocation"}, 
        {(unsigned char)12,
      (unsigned char)2, "Write error - auto reallocation failed"}, 
        {(unsigned char)12, (unsigned char)3, "Write error - recommend reassignment"}, 
        {(unsigned char)12,
      (unsigned char)4, "Compression check miscompare error"}, 
        {(unsigned char)12, (unsigned char)5, "Data expansion occurred during compression"}, 
        {(unsigned char)12,
      (unsigned char)6, "Block not compressible"}, 
        {(unsigned char)12, (unsigned char)7, "Write error - recovery needed"}, 
        {(unsigned char)12, (unsigned char)8, "Write error - recovery failed"}, 
        {(unsigned char)12, (unsigned char)9, "Write error - loss of streaming"}, 
        {(unsigned char)12, (unsigned char)10, "Write error - padding blocks added"}, 
        {(unsigned char)12,
      (unsigned char)11, "Auxiliary memory write error"}, 
        {(unsigned char)12, (unsigned char)12, "Write error - unexpected unsolicited data"}, 
        {(unsigned char)12,
      (unsigned char)13, "Write error - not enough unsolicited data"}, 
        {(unsigned char)12, (unsigned char)15, "Defects in error window"}, 
        {(unsigned char)13, (unsigned char)0, "Error detected by third party temporary initiator"}, 
        {(unsigned char)13,
      (unsigned char)1, "Third party device failure"}, 
        {(unsigned char)13, (unsigned char)2, "Copy target device not reachable"}, 
        {(unsigned char)13, (unsigned char)3, "Incorrect copy target device type"}, 
        {(unsigned char)13, (unsigned char)4, "Copy target device data underrun"}, 
        {(unsigned char)13, (unsigned char)5, "Copy target device data overrun"}, 
        {(unsigned char)14, (unsigned char)0, "Invalid information unit"}, 
        {(unsigned char)14, (unsigned char)1, "Information unit too short"}, 
        {(unsigned char)14, (unsigned char)2, "Information unit too long"}, 
        {(unsigned char)14, (unsigned char)3, "Invalid field in command information unit"}, 
        {(unsigned char)16,
      (unsigned char)0, "Id CRC or ECC error"}, 
        {(unsigned char)16, (unsigned char)1, "Logical block guard check failed"}, 
        {(unsigned char)16, (unsigned char)2, "Logical block application tag check failed"}, 
        {(unsigned char)16,
      (unsigned char)3, "Logical block reference tag check failed"}, 
        {(unsigned char)16, (unsigned char)4, "Logical block protection error on recover buffered data"}, 
        {(unsigned char)16,
      (unsigned char)5, "Logical block protection method error"}, 
        {(unsigned char)17, (unsigned char)0, "Unrecovered read error"}, 
        {(unsigned char)17, (unsigned char)1, "Read retries exhausted"}, 
        {(unsigned char)17, (unsigned char)2, "Error too long to correct"}, 
        {(unsigned char)17, (unsigned char)3, "Multiple read errors"}, 
        {(unsigned char)17, (unsigned char)4, "Unrecovered read error - auto reallocate failed"}, 
        {(unsigned char)17,
      (unsigned char)5, "L-EC uncorrectable error"}, 
        {(unsigned char)17, (unsigned char)6, "CIRC unrecovered error"}, 
        {(unsigned char)17, (unsigned char)7, "Data re-synchronization error"}, 
        {(unsigned char)17, (unsigned char)8, "Incomplete block read"}, 
        {(unsigned char)17, (unsigned char)9, "No gap found"}, 
        {(unsigned char)17, (unsigned char)10, "Miscorrected error"}, 
        {(unsigned char)17, (unsigned char)11, "Unrecovered read error - recommend reassignment"}, 
        {(unsigned char)17,
      (unsigned char)12, "Unrecovered read error - recommend rewrite the data"}, 
        {(unsigned char)17, (unsigned char)13, "De-compression CRC error"}, 
        {(unsigned char)17, (unsigned char)14, "Cannot decompress using declared algorithm"}, 
        {(unsigned char)17,
      (unsigned char)15, "Error reading UPC/EAN number"}, 
        {(unsigned char)17, (unsigned char)16, "Error reading ISRC number"}, 
        {(unsigned char)17, (unsigned char)17, "Read error - loss of streaming"}, 
        {(unsigned char)17, (unsigned char)18, "Auxiliary memory read error"}, 
        {(unsigned char)17, (unsigned char)19, "Read error - failed retransmission request"}, 
        {(unsigned char)17,
      (unsigned char)20, "Read error - LBA marked bad by application client"}, 
        {(unsigned char)18, (unsigned char)0, "Address mark not found for id field"}, 
        {(unsigned char)19,
      (unsigned char)0, "Address mark not found for data field"}, 
        {(unsigned char)20, (unsigned char)0, "Recorded entity not found"}, 
        {(unsigned char)20, (unsigned char)1, "Record not found"}, 
        {(unsigned char)20, (unsigned char)2, "Filemark or setmark not found"}, 
        {(unsigned char)20, (unsigned char)3, "End-of-data not found"}, 
        {(unsigned char)20, (unsigned char)4, "Block sequence error"}, 
        {(unsigned char)20, (unsigned char)5, "Record not found - recommend reassignment"}, 
        {(unsigned char)20,
      (unsigned char)6, "Record not found - data auto-reallocated"}, 
        {(unsigned char)20, (unsigned char)7, "Locate operation failure"}, 
        {(unsigned char)21, (unsigned char)0, "Random positioning error"}, 
        {(unsigned char)21, (unsigned char)1, "Mechanical positioning error"}, 
        {(unsigned char)21, (unsigned char)2, "Positioning error detected by read of medium"}, 
        {(unsigned char)22,
      (unsigned char)0, "Data synchronization mark error"}, 
        {(unsigned char)22, (unsigned char)1, "Data sync error - data rewritten"}, 
        {(unsigned char)22, (unsigned char)2, "Data sync error - recommend rewrite"}, 
        {(unsigned char)22,
      (unsigned char)3, "Data sync error - data auto-reallocated"}, 
        {(unsigned char)22, (unsigned char)4, "Data sync error - recommend reassignment"}, 
        {(unsigned char)23,
      (unsigned char)0, "Recovered data with no error correction applied"}, 
        {(unsigned char)23, (unsigned char)1, "Recovered data with retries"}, 
        {(unsigned char)23, (unsigned char)2, "Recovered data with positive head offset"}, 
        {(unsigned char)23,
      (unsigned char)3, "Recovered data with negative head offset"}, 
        {(unsigned char)23, (unsigned char)4, "Recovered data with retries and/or circ applied"}, 
        {(unsigned char)23,
      (unsigned char)5, "Recovered data using previous sector id"}, 
        {(unsigned char)23, (unsigned char)6, "Recovered data without ECC - data auto-reallocated"}, 
        {(unsigned char)23,
      (unsigned char)7, "Recovered data without ECC - recommend reassignment"}, 
        {(unsigned char)23, (unsigned char)8, "Recovered data without ECC - recommend rewrite"}, 
        {(unsigned char)23,
      (unsigned char)9, "Recovered data without ECC - data rewritten"}, 
        {(unsigned char)24, (unsigned char)0, "Recovered data with error correction applied"}, 
        {(unsigned char)24,
      (unsigned char)1, "Recovered data with error corr. & retries applied"}, 
        {(unsigned char)24, (unsigned char)2, "Recovered data - data auto-reallocated"}, 
        {(unsigned char)24,
      (unsigned char)3, "Recovered data with CIRC"}, 
        {(unsigned char)24, (unsigned char)4, "Recovered data with L-EC"}, 
        {(unsigned char)24, (unsigned char)5, "Recovered data - recommend reassignment"}, 
        {(unsigned char)24,
      (unsigned char)6, "Recovered data - recommend rewrite"}, 
        {(unsigned char)24, (unsigned char)7, "Recovered data with ECC - data rewritten"}, 
        {(unsigned char)24,
      (unsigned char)8, "Recovered data with linking"}, 
        {(unsigned char)25, (unsigned char)0, "Defect list error"}, 
        {(unsigned char)25, (unsigned char)1, "Defect list not available"}, 
        {(unsigned char)25, (unsigned char)2, "Defect list error in primary list"}, 
        {(unsigned char)25, (unsigned char)3, "Defect list error in grown list"}, 
        {(unsigned char)26, (unsigned char)0, "Parameter list length error"}, 
        {(unsigned char)27, (unsigned char)0, "Synchronous data transfer error"}, 
        {(unsigned char)28, (unsigned char)0, "Defect list not found"}, 
        {(unsigned char)28, (unsigned char)1, "Primary defect list not found"}, 
        {(unsigned char)28, (unsigned char)2, "Grown defect list not found"}, 
        {(unsigned char)29, (unsigned char)0, "Miscompare during verify operation"}, 
        {(unsigned char)29, (unsigned char)1, "Miscompare verify of unmapped lba"}, 
        {(unsigned char)30, (unsigned char)0, "Recovered id with ECC correction"}, 
        {(unsigned char)31, (unsigned char)0, "Partial defect list transfer"}, 
        {(unsigned char)32, (unsigned char)0, "Invalid command operation code"}, 
        {(unsigned char)32, (unsigned char)1, "Access denied - initiator pending-enrolled"}, 
        {(unsigned char)32,
      (unsigned char)2, "Access denied - no access rights"}, 
        {(unsigned char)32, (unsigned char)3, "Access denied - invalid mgmt id key"}, 
        {(unsigned char)32,
      (unsigned char)4, "Illegal command while in write capable state"}, 
        {(unsigned char)32, (unsigned char)5, "Write type operation while in read capable state (obs)"}, 
        {(unsigned char)32,
      (unsigned char)6, "Illegal command while in explicit address mode"}, 
        {(unsigned char)32, (unsigned char)7, "Illegal command while in implicit address mode"}, 
        {(unsigned char)32,
      (unsigned char)8, "Access denied - enrollment conflict"}, 
        {(unsigned char)32, (unsigned char)9, "Access denied - invalid LU identifier"}, 
        {(unsigned char)32,
      (unsigned char)10, "Access denied - invalid proxy token"}, 
        {(unsigned char)32, (unsigned char)11, "Access denied - ACL LUN conflict"}, 
        {(unsigned char)32, (unsigned char)12, "Illegal command when not in append-only mode"}, 
        {(unsigned char)33,
      (unsigned char)0, "Logical block address out of range"}, 
        {(unsigned char)33, (unsigned char)1, "Invalid element address"}, 
        {(unsigned char)33, (unsigned char)2, "Invalid address for write"}, 
        {(unsigned char)33, (unsigned char)3, "Invalid write crossing layer jump"}, 
        {(unsigned char)34, (unsigned char)0, "Illegal function (use 20 00, 24 00, or 26 00)"}, 
        {(unsigned char)35,
      (unsigned char)0, "Invalid token operation, cause not reportable"}, 
        {(unsigned char)36, (unsigned char)0, "Invalid field in cdb"}, 
        {(unsigned char)36, (unsigned char)1, "CDB decryption error"}, 
        {(unsigned char)36, (unsigned char)2, "Invalid cdb field while in explicit block model (obs)"}, 
        {(unsigned char)36,
      (unsigned char)3, "Invalid cdb field while in implicit block model (obs)"}, 
        {(unsigned char)36, (unsigned char)4, "Security audit value frozen"}, 
        {(unsigned char)36, (unsigned char)5, "Security working key frozen"}, 
        {(unsigned char)36, (unsigned char)6, "Nonce not unique"}, 
        {(unsigned char)36, (unsigned char)7, "Nonce timestamp out of range"}, 
        {(unsigned char)36, (unsigned char)8, "Invalid xcdb"}, 
        {(unsigned char)37, (unsigned char)0, "Logical unit not supported"}, 
        {(unsigned char)38, (unsigned char)0, "Invalid field in parameter list"}, 
        {(unsigned char)38, (unsigned char)1, "Parameter not supported"}, 
        {(unsigned char)38, (unsigned char)2, "Parameter value invalid"}, 
        {(unsigned char)38, (unsigned char)3, "Threshold parameters not supported"}, 
        {(unsigned char)38, (unsigned char)4, "Invalid release of persistent reservation"}, 
        {(unsigned char)38,
      (unsigned char)5, "Data decryption error"}, 
        {(unsigned char)38, (unsigned char)6, "Too many target descriptors"}, 
        {(unsigned char)38, (unsigned char)7, "Unsupported target descriptor type code"}, 
        {(unsigned char)38,
      (unsigned char)8, "Too many segment descriptors"}, 
        {(unsigned char)38, (unsigned char)9, "Unsupported segment descriptor type code"}, 
        {(unsigned char)38,
      (unsigned char)10, "Unexpected inexact segment"}, 
        {(unsigned char)38, (unsigned char)11, "Inline data length exceeded"}, 
        {(unsigned char)38, (unsigned char)12, "Invalid operation for copy source or destination"}, 
        {(unsigned char)38,
      (unsigned char)13, "Copy segment granularity violation"}, 
        {(unsigned char)38, (unsigned char)14, "Invalid parameter while port is enabled"}, 
        {(unsigned char)38,
      (unsigned char)15, "Invalid data-out buffer integrity check value"}, 
        {(unsigned char)38, (unsigned char)16, "Data decryption key fail limit reached"}, 
        {(unsigned char)38,
      (unsigned char)17, "Incomplete key-associated data set"}, 
        {(unsigned char)38, (unsigned char)18, "Vendor specific key reference not found"}, 
        {(unsigned char)39,
      (unsigned char)0, "Write protected"}, 
        {(unsigned char)39, (unsigned char)1, "Hardware write protected"}, 
        {(unsigned char)39, (unsigned char)2, "Logical unit software write protected"}, 
        {(unsigned char)39,
      (unsigned char)3, "Associated write protect"}, 
        {(unsigned char)39, (unsigned char)4, "Persistent write protect"}, 
        {(unsigned char)39, (unsigned char)5, "Permanent write protect"}, 
        {(unsigned char)39, (unsigned char)6, "Conditional write protect"}, 
        {(unsigned char)39, (unsigned char)7, "Space allocation failed write protect"}, 
        {(unsigned char)40,
      (unsigned char)0, "Not ready to ready change, medium may have changed"}, 
        {(unsigned char)40, (unsigned char)1, "Import or export element accessed"}, 
        {(unsigned char)40, (unsigned char)2, "Format-layer may have changed"}, 
        {(unsigned char)40, (unsigned char)3, "Import/export element accessed, medium changed"}, 
        {(unsigned char)41,
      (unsigned char)0, "Power on, reset, or bus device reset occurred"}, 
        {(unsigned char)41, (unsigned char)1, "Power on occurred"}, 
        {(unsigned char)41, (unsigned char)2, "SCSI bus reset occurred"}, 
        {(unsigned char)41, (unsigned char)3, "Bus device reset function occurred"}, 
        {(unsigned char)41, (unsigned char)4, "Device internal reset"}, 
        {(unsigned char)41, (unsigned char)5, "Transceiver mode changed to single-ended"}, 
        {(unsigned char)41,
      (unsigned char)6, "Transceiver mode changed to lvd"}, 
        {(unsigned char)41, (unsigned char)7, "I_T nexus loss occurred"}, 
        {(unsigned char)42, (unsigned char)0, "Parameters changed"}, 
        {(unsigned char)42, (unsigned char)1, "Mode parameters changed"}, 
        {(unsigned char)42, (unsigned char)2, "Log parameters changed"}, 
        {(unsigned char)42, (unsigned char)3, "Reservations preempted"}, 
        {(unsigned char)42, (unsigned char)4, "Reservations released"}, 
        {(unsigned char)42, (unsigned char)5, "Registrations preempted"}, 
        {(unsigned char)42, (unsigned char)6, "Asymmetric access state changed"}, 
        {(unsigned char)42, (unsigned char)7, "Implicit asymmetric access state transition failed"}, 
        {(unsigned char)42,
      (unsigned char)8, "Priority changed"}, 
        {(unsigned char)42, (unsigned char)9, "Capacity data has changed"}, 
        {(unsigned char)42, (unsigned char)12, "Error recovery attributes have changed"}, 
        {(unsigned char)42,
      (unsigned char)13, "Data encryption capabilities changed"}, 
        {(unsigned char)42, (unsigned char)16, "Timestamp changed"}, 
        {(unsigned char)42, (unsigned char)17, "Data encryption parameters changed by another i_t nexus"}, 
        {(unsigned char)42,
      (unsigned char)18, "Data encryption parameters changed by vendor specific event"}, 
        {(unsigned char)42,
      (unsigned char)19, "Data encryption key instance counter has changed"}, 
        {(unsigned char)42, (unsigned char)10, "Error history i_t nexus cleared"}, 
        {(unsigned char)42, (unsigned char)11, "Error history snapshot released"}, 
        {(unsigned char)42, (unsigned char)20, "SA creation capabilities data has changed"}, 
        {(unsigned char)43,
      (unsigned char)0, "Copy cannot execute since host cannot disconnect"}, 
        {(unsigned char)44, (unsigned char)0, "Command sequence error"}, 
        {(unsigned char)44, (unsigned char)1, "Too many windows specified"}, 
        {(unsigned char)44, (unsigned char)2, "Invalid combination of windows specified"}, 
        {(unsigned char)44,
      (unsigned char)3, "Current program area is not empty"}, 
        {(unsigned char)44, (unsigned char)4, "Current program area is empty"}, 
        {(unsigned char)44, (unsigned char)5, "Illegal power condition request"}, 
        {(unsigned char)44, (unsigned char)6, "Persistent prevent conflict"}, 
        {(unsigned char)44, (unsigned char)7, "Previous busy status"}, 
        {(unsigned char)44, (unsigned char)8, "Previous task set full status"}, 
        {(unsigned char)44, (unsigned char)9, "Previous reservation conflict status"}, 
        {(unsigned char)44,
      (unsigned char)10, "Partition or collection contains user objects"}, 
        {(unsigned char)44, (unsigned char)11, "Not reserved"}, 
        {(unsigned char)44, (unsigned char)12, "ORWRITE generation does not match"}, 
        {(unsigned char)45, (unsigned char)0, "Overwrite error on update in place"}, 
        {(unsigned char)46, (unsigned char)0, "Insufficient time for operation"}, 
        {(unsigned char)47, (unsigned char)0, "Commands cleared by another initiator"}, 
        {(unsigned char)47,
      (unsigned char)1, "Commands cleared by power loss notification"}, 
        {(unsigned char)47, (unsigned char)2, "Commands cleared by device server"}, 
        {(unsigned char)48, (unsigned char)0, "Incompatible medium installed"}, 
        {(unsigned char)48, (unsigned char)1, "Cannot read medium - unknown format"}, 
        {(unsigned char)48,
      (unsigned char)2, "Cannot read medium - incompatible format"}, 
        {(unsigned char)48, (unsigned char)3, "Cleaning cartridge installed"}, 
        {(unsigned char)48, (unsigned char)4, "Cannot write medium - unknown format"}, 
        {(unsigned char)48,
      (unsigned char)5, "Cannot write medium - incompatible format"}, 
        {(unsigned char)48, (unsigned char)6, "Cannot format medium - incompatible medium"}, 
        {(unsigned char)48,
      (unsigned char)7, "Cleaning failure"}, 
        {(unsigned char)48, (unsigned char)8, "Cannot write - application code mismatch"}, 
        {(unsigned char)48,
      (unsigned char)9, "Current session not fixated for append"}, 
        {(unsigned char)48, (unsigned char)10, "Cleaning request rejected"}, 
        {(unsigned char)48, (unsigned char)11, "Cleaning tape expired"}, 
        {(unsigned char)48, (unsigned char)12, "WORM medium - overwrite attempted"}, 
        {(unsigned char)48, (unsigned char)13, "WORM medium - integrity check"}, 
        {(unsigned char)48, (unsigned char)16, "Medium not formatted"}, 
        {(unsigned char)48, (unsigned char)17, "Incompatible volume type"}, 
        {(unsigned char)48, (unsigned char)18, "Incompatible volume qualifier"}, 
        {(unsigned char)48, (unsigned char)19, "Cleaning volume expired"}, 
        {(unsigned char)49, (unsigned char)0, "Medium format corrupted"}, 
        {(unsigned char)49, (unsigned char)1, "Format command failed"}, 
        {(unsigned char)49, (unsigned char)2, "Zoned formatting failed due to spare linking"}, 
        {(unsigned char)49,
      (unsigned char)3, "Sanitize command failed"}, 
        {(unsigned char)50, (unsigned char)0, "No defect spare location available"}, 
        {(unsigned char)50, (unsigned char)1, "Defect list update failure"}, 
        {(unsigned char)51, (unsigned char)0, "Tape length error"}, 
        {(unsigned char)52, (unsigned char)0, "Enclosure failure"}, 
        {(unsigned char)53, (unsigned char)0, "Enclosure services failure"}, 
        {(unsigned char)53, (unsigned char)1, "Unsupported enclosure function"}, 
        {(unsigned char)53, (unsigned char)2, "Enclosure services unavailable"}, 
        {(unsigned char)53, (unsigned char)3, "Enclosure services transfer failure"}, 
        {(unsigned char)53,
      (unsigned char)4, "Enclosure services transfer refused"}, 
        {(unsigned char)53, (unsigned char)5, "Enclosure services checksum error"}, 
        {(unsigned char)54, (unsigned char)0, "Ribbon, ink, or toner failure"}, 
        {(unsigned char)55, (unsigned char)0, "Rounded parameter"}, 
        {(unsigned char)56, (unsigned char)0, "Event status notification"}, 
        {(unsigned char)56, (unsigned char)2, "Esn - power management class event"}, 
        {(unsigned char)56, (unsigned char)4, "Esn - media class event"}, 
        {(unsigned char)56, (unsigned char)6, "Esn - device busy class event"}, 
        {(unsigned char)56, (unsigned char)7, "Thin provisioning soft threshold reached"}, 
        {(unsigned char)57,
      (unsigned char)0, "Saving parameters not supported"}, 
        {(unsigned char)58, (unsigned char)0, "Medium not present"}, 
        {(unsigned char)58, (unsigned char)1, "Medium not present - tray closed"}, 
        {(unsigned char)58, (unsigned char)2, "Medium not present - tray open"}, 
        {(unsigned char)58, (unsigned char)3, "Medium not present - loadable"}, 
        {(unsigned char)58, (unsigned char)4, "Medium not present - medium auxiliary memory accessible"}, 
        {(unsigned char)59,
      (unsigned char)0, "Sequential positioning error"}, 
        {(unsigned char)59, (unsigned char)1, "Tape position error at beginning-of-medium"}, 
        {(unsigned char)59,
      (unsigned char)2, "Tape position error at end-of-medium"}, 
        {(unsigned char)59, (unsigned char)3, "Tape or electronic vertical forms unit not ready"}, 
        {(unsigned char)59,
      (unsigned char)4, "Slew failure"}, 
        {(unsigned char)59, (unsigned char)5, "Paper jam"}, 
        {(unsigned char)59, (unsigned char)6, "Failed to sense top-of-form"}, 
        {(unsigned char)59, (unsigned char)7, "Failed to sense bottom-of-form"}, 
        {(unsigned char)59, (unsigned char)8, "Reposition error"}, 
        {(unsigned char)59, (unsigned char)9, "Read past end of medium"}, 
        {(unsigned char)59, (unsigned char)10, "Read past beginning of medium"}, 
        {(unsigned char)59, (unsigned char)11, "Position past end of medium"}, 
        {(unsigned char)59, (unsigned char)12, "Position past beginning of medium"}, 
        {(unsigned char)59, (unsigned char)13, "Medium destination element full"}, 
        {(unsigned char)59, (unsigned char)14, "Medium source element empty"}, 
        {(unsigned char)59, (unsigned char)15, "End of medium reached"}, 
        {(unsigned char)59, (unsigned char)17, "Medium magazine not accessible"}, 
        {(unsigned char)59, (unsigned char)18, "Medium magazine removed"}, 
        {(unsigned char)59, (unsigned char)19, "Medium magazine inserted"}, 
        {(unsigned char)59, (unsigned char)20, "Medium magazine locked"}, 
        {(unsigned char)59, (unsigned char)21, "Medium magazine unlocked"}, 
        {(unsigned char)59, (unsigned char)22, "Mechanical positioning or changer error"}, 
        {(unsigned char)59,
      (unsigned char)23, "Read past end of user object"}, 
        {(unsigned char)59, (unsigned char)24, "Element disabled"}, 
        {(unsigned char)59, (unsigned char)25, "Element enabled"}, 
        {(unsigned char)59, (unsigned char)26, "Data transfer device removed"}, 
        {(unsigned char)59, (unsigned char)27, "Data transfer device inserted"}, 
        {(unsigned char)61, (unsigned char)0, "Invalid bits in identify message"}, 
        {(unsigned char)62, (unsigned char)0, "Logical unit has not self-configured yet"}, 
        {(unsigned char)62,
      (unsigned char)1, "Logical unit failure"}, 
        {(unsigned char)62, (unsigned char)2, "Timeout on logical unit"}, 
        {(unsigned char)62, (unsigned char)3, "Logical unit failed self-test"}, 
        {(unsigned char)62, (unsigned char)4, "Logical unit unable to update self-test log"}, 
        {(unsigned char)63,
      (unsigned char)0, "Target operating conditions have changed"}, 
        {(unsigned char)63, (unsigned char)1, "Microcode has been changed"}, 
        {(unsigned char)63, (unsigned char)2, "Changed operating definition"}, 
        {(unsigned char)63, (unsigned char)3, "Inquiry data has changed"}, 
        {(unsigned char)63, (unsigned char)4, "Component device attached"}, 
        {(unsigned char)63, (unsigned char)5, "Device identifier changed"}, 
        {(unsigned char)63, (unsigned char)6, "Redundancy group created or modified"}, 
        {(unsigned char)63,
      (unsigned char)7, "Redundancy group deleted"}, 
        {(unsigned char)63, (unsigned char)8, "Spare created or modified"}, 
        {(unsigned char)63, (unsigned char)9, "Spare deleted"}, 
        {(unsigned char)63, (unsigned char)10, "Volume set created or modified"}, 
        {(unsigned char)63, (unsigned char)11, "Volume set deleted"}, 
        {(unsigned char)63, (unsigned char)12, "Volume set deassigned"}, 
        {(unsigned char)63, (unsigned char)13, "Volume set reassigned"}, 
        {(unsigned char)63, (unsigned char)14, "Reported luns data has changed"}, 
        {(unsigned char)63, (unsigned char)15, "Echo buffer overwritten"}, 
        {(unsigned char)63, (unsigned char)16, "Medium loadable"}, 
        {(unsigned char)63, (unsigned char)17, "Medium auxiliary memory accessible"}, 
        {(unsigned char)63,
      (unsigned char)18, "iSCSI IP address added"}, 
        {(unsigned char)63, (unsigned char)19, "iSCSI IP address removed"}, 
        {(unsigned char)63, (unsigned char)20, "iSCSI IP address changed"}, 
        {(unsigned char)64, (unsigned char)0, "Ram failure (should use 40 nn)"}, 
        {(unsigned char)65, (unsigned char)0, "Data path failure (should use 40 nn)"}, 
        {(unsigned char)66,
      (unsigned char)0, "Power-on or self-test failure (should use 40 nn)"}, 
        {(unsigned char)67, (unsigned char)0, "Message error"}, 
        {(unsigned char)68, (unsigned char)0, "Internal target failure"}, 
        {(unsigned char)68, (unsigned char)113, "ATA device failed Set Features"}, 
        {(unsigned char)69, (unsigned char)0, "Select or reselect failure"}, 
        {(unsigned char)70, (unsigned char)0, "Unsuccessful soft reset"}, 
        {(unsigned char)71, (unsigned char)0, "SCSI parity error"}, 
        {(unsigned char)71, (unsigned char)1, "Data phase CRC error detected"}, 
        {(unsigned char)71, (unsigned char)2, "SCSI parity error detected during st data phase"}, 
        {(unsigned char)71,
      (unsigned char)3, "Information unit iuCRC error detected"}, 
        {(unsigned char)71, (unsigned char)4, "Asynchronous information protection error detected"}, 
        {(unsigned char)71,
      (unsigned char)5, "Protocol service CRC error"}, 
        {(unsigned char)71, (unsigned char)6, "Phy test function in progress"}, 
        {(unsigned char)71, (unsigned char)127, "Some commands cleared by iSCSI protocol event"}, 
        {(unsigned char)72,
      (unsigned char)0, "Initiator detected error message received"}, 
        {(unsigned char)73, (unsigned char)0, "Invalid message error"}, 
        {(unsigned char)74, (unsigned char)0, "Command phase error"}, 
        {(unsigned char)75, (unsigned char)0, "Data phase error"}, 
        {(unsigned char)75, (unsigned char)1, "Invalid target port transfer tag received"}, 
        {(unsigned char)75,
      (unsigned char)2, "Too much write data"}, 
        {(unsigned char)75, (unsigned char)3, "Ack/nak timeout"}, 
        {(unsigned char)75, (unsigned char)4, "Nak received"}, 
        {(unsigned char)75, (unsigned char)5, "Data offset error"}, 
        {(unsigned char)75, (unsigned char)6, "Initiator response timeout"}, 
        {(unsigned char)75, (unsigned char)7, "Connection lost"}, 
        {(unsigned char)76, (unsigned char)0, "Logical unit failed self-configuration"}, 
        {(unsigned char)78,
      (unsigned char)0, "Overlapped commands attempted"}, 
        {(unsigned char)80, (unsigned char)0, "Write append error"}, 
        {(unsigned char)80, (unsigned char)1, "Write append position error"}, 
        {(unsigned char)80, (unsigned char)2, "Position error related to timing"}, 
        {(unsigned char)81, (unsigned char)0, "Erase failure"}, 
        {(unsigned char)81, (unsigned char)1, "Erase failure - incomplete erase operation detected"}, 
        {(unsigned char)82,
      (unsigned char)0, "Cartridge fault"}, 
        {(unsigned char)83, (unsigned char)0, "Media load or eject failed"}, 
        {(unsigned char)83, (unsigned char)1, "Unload tape failure"}, 
        {(unsigned char)83, (unsigned char)2, "Medium removal prevented"}, 
        {(unsigned char)83, (unsigned char)3, "Medium removal prevented by data transfer element"}, 
        {(unsigned char)83,
      (unsigned char)4, "Medium thread or unthread failure"}, 
        {(unsigned char)83, (unsigned char)5, "Volume identifier invalid"}, 
        {(unsigned char)83, (unsigned char)6, "Volume identifier missing"}, 
        {(unsigned char)83, (unsigned char)7, "Duplicate volume identifier"}, 
        {(unsigned char)83, (unsigned char)8, "Element status unknown"}, 
        {(unsigned char)84, (unsigned char)0, "SCSI to host system interface failure"}, 
        {(unsigned char)85,
      (unsigned char)0, "System resource failure"}, 
        {(unsigned char)85, (unsigned char)1, "System buffer full"}, 
        {(unsigned char)85, (unsigned char)2, "Insufficient reservation resources"}, 
        {(unsigned char)85, (unsigned char)3, "Insufficient resources"}, 
        {(unsigned char)85, (unsigned char)4, "Insufficient registration resources"}, 
        {(unsigned char)85,
      (unsigned char)5, "Insufficient access control resources"}, 
        {(unsigned char)85, (unsigned char)6, "Auxiliary memory out of space"}, 
        {(unsigned char)85, (unsigned char)7, "Quota error"}, 
        {(unsigned char)85, (unsigned char)8, "Maximum number of supplemental decryption keys exceeded"}, 
        {(unsigned char)85,
      (unsigned char)9, "Medium auxiliary memory not accessible"}, 
        {(unsigned char)85, (unsigned char)10, "Data currently unavailable"}, 
        {(unsigned char)85, (unsigned char)11, "Insufficient power for operation"}, 
        {(unsigned char)87, (unsigned char)0, "Unable to recover table-of-contents"}, 
        {(unsigned char)88,
      (unsigned char)0, "Generation does not exist"}, 
        {(unsigned char)89, (unsigned char)0, "Updated block read"}, 
        {(unsigned char)90, (unsigned char)0, "Operator request or state change input"}, 
        {(unsigned char)90,
      (unsigned char)1, "Operator medium removal request"}, 
        {(unsigned char)90, (unsigned char)2, "Operator selected write protect"}, 
        {(unsigned char)90, (unsigned char)3, "Operator selected write permit"}, 
        {(unsigned char)91, (unsigned char)0, "Log exception"}, 
        {(unsigned char)91, (unsigned char)1, "Threshold condition met"}, 
        {(unsigned char)91, (unsigned char)2, "Log counter at maximum"}, 
        {(unsigned char)91, (unsigned char)3, "Log list codes exhausted"}, 
        {(unsigned char)92, (unsigned char)0, "Rpl status change"}, 
        {(unsigned char)92, (unsigned char)1, "Spindles synchronized"}, 
        {(unsigned char)92, (unsigned char)2, "Spindles not synchronized"}, 
        {(unsigned char)93, (unsigned char)0, "Failure prediction threshold exceeded"}, 
        {(unsigned char)93,
      (unsigned char)1, "Media failure prediction threshold exceeded"}, 
        {(unsigned char)93, (unsigned char)2, "Logical unit failure prediction threshold exceeded"}, 
        {(unsigned char)93,
      (unsigned char)3, "spare area exhaustion prediction threshold exceeded"}, 
        {(unsigned char)93, (unsigned char)16, "Hardware impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)17, "Hardware impending failure drive error rate too high"}, 
        {(unsigned char)93, (unsigned char)18, "Hardware impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)19, "Hardware impending failure seek error rate too high"}, 
        {(unsigned char)93, (unsigned char)20, "Hardware impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)21, "Hardware impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)22, "Hardware impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)23, "Hardware impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)24, "Hardware impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)25, "Hardware impending failure throughput performance"}, 
        {(unsigned char)93, (unsigned char)26, "Hardware impending failure seek time performance"}, 
        {(unsigned char)93,
      (unsigned char)27, "Hardware impending failure spin-up retry count"}, 
        {(unsigned char)93, (unsigned char)28, "Hardware impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)32, "Controller impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)33, "Controller impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)34, "Controller impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)35, "Controller impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)36, "Controller impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)37, "Controller impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)38, "Controller impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)39, "Controller impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)40, "Controller impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)41, "Controller impending failure throughput performance"}, 
        {(unsigned char)93, (unsigned char)42, "Controller impending failure seek time performance"}, 
        {(unsigned char)93,
      (unsigned char)43, "Controller impending failure spin-up retry count"}, 
        {(unsigned char)93, (unsigned char)44, "Controller impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)48, "Data channel impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)49, "Data channel impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)50, "Data channel impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)51, "Data channel impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)52, "Data channel impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)53, "Data channel impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)54, "Data channel impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)55, "Data channel impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)56, "Data channel impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)57, "Data channel impending failure throughput performance"}, 
        {(unsigned char)93,
      (unsigned char)58, "Data channel impending failure seek time performance"}, 
        {(unsigned char)93, (unsigned char)59, "Data channel impending failure spin-up retry count"}, 
        {(unsigned char)93,
      (unsigned char)60, "Data channel impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)64, "Servo impending failure general hard drive failure"}, 
        {(unsigned char)93, (unsigned char)65, "Servo impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)66, "Servo impending failure data error rate too high"}, 
        {(unsigned char)93, (unsigned char)67, "Servo impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)68, "Servo impending failure too many block reassigns"}, 
        {(unsigned char)93, (unsigned char)69, "Servo impending failure access times too high"}, 
        {(unsigned char)93,
      (unsigned char)70, "Servo impending failure start unit times too high"}, 
        {(unsigned char)93, (unsigned char)71, "Servo impending failure channel parametrics"}, 
        {(unsigned char)93,
      (unsigned char)72, "Servo impending failure controller detected"}, 
        {(unsigned char)93, (unsigned char)73, "Servo impending failure throughput performance"}, 
        {(unsigned char)93,
      (unsigned char)74, "Servo impending failure seek time performance"}, 
        {(unsigned char)93, (unsigned char)75, "Servo impending failure spin-up retry count"}, 
        {(unsigned char)93,
      (unsigned char)76, "Servo impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)80, "Spindle impending failure general hard drive failure"}, 
        {(unsigned char)93, (unsigned char)81, "Spindle impending failure drive error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)82, "Spindle impending failure data error rate too high"}, 
        {(unsigned char)93, (unsigned char)83, "Spindle impending failure seek error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)84, "Spindle impending failure too many block reassigns"}, 
        {(unsigned char)93, (unsigned char)85, "Spindle impending failure access times too high"}, 
        {(unsigned char)93,
      (unsigned char)86, "Spindle impending failure start unit times too high"}, 
        {(unsigned char)93, (unsigned char)87, "Spindle impending failure channel parametrics"}, 
        {(unsigned char)93,
      (unsigned char)88, "Spindle impending failure controller detected"}, 
        {(unsigned char)93, (unsigned char)89, "Spindle impending failure throughput performance"}, 
        {(unsigned char)93,
      (unsigned char)90, "Spindle impending failure seek time performance"}, 
        {(unsigned char)93, (unsigned char)91, "Spindle impending failure spin-up retry count"}, 
        {(unsigned char)93,
      (unsigned char)92, "Spindle impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)96, "Firmware impending failure general hard drive failure"}, 
        {(unsigned char)93,
      (unsigned char)97, "Firmware impending failure drive error rate too high"}, 
        {(unsigned char)93, (unsigned char)98, "Firmware impending failure data error rate too high"}, 
        {(unsigned char)93,
      (unsigned char)99, "Firmware impending failure seek error rate too high"}, 
        {(unsigned char)93, (unsigned char)100, "Firmware impending failure too many block reassigns"}, 
        {(unsigned char)93,
      (unsigned char)101, "Firmware impending failure access times too high"}, 
        {(unsigned char)93, (unsigned char)102, "Firmware impending failure start unit times too high"}, 
        {(unsigned char)93,
      (unsigned char)103, "Firmware impending failure channel parametrics"}, 
        {(unsigned char)93, (unsigned char)104, "Firmware impending failure controller detected"}, 
        {(unsigned char)93,
      (unsigned char)105, "Firmware impending failure throughput performance"}, 
        {(unsigned char)93, (unsigned char)106, "Firmware impending failure seek time performance"}, 
        {(unsigned char)93,
      (unsigned char)107, "Firmware impending failure spin-up retry count"}, 
        {(unsigned char)93, (unsigned char)108, "Firmware impending failure drive calibration retry count"}, 
        {(unsigned char)93,
      (unsigned char)255, "Failure prediction threshold exceeded (false)"}, 
        {(unsigned char)94, (unsigned char)0, "Low power condition on"}, 
        {(unsigned char)94, (unsigned char)1, "Idle condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)2, "Standby condition activated by timer"}, 
        {(unsigned char)94,
      (unsigned char)3, "Idle condition activated by command"}, 
        {(unsigned char)94, (unsigned char)4, "Standby condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)5, "Idle_b condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)6, "Idle_b condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)7, "Idle_c condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)8, "Idle_c condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)9, "Standby_y condition activated by timer"}, 
        {(unsigned char)94, (unsigned char)10, "Standby_y condition activated by command"}, 
        {(unsigned char)94,
      (unsigned char)65, "Power state change to active"}, 
        {(unsigned char)94, (unsigned char)66, "Power state change to idle"}, 
        {(unsigned char)94, (unsigned char)67, "Power state change to standby"}, 
        {(unsigned char)94, (unsigned char)69, "Power state change to sleep"}, 
        {(unsigned char)94, (unsigned char)71, "Power state change to device control"}, 
        {(unsigned char)96,
      (unsigned char)0, "Lamp failure"}, 
        {(unsigned char)97, (unsigned char)0, "Video acquisition error"}, 
        {(unsigned char)97, (unsigned char)1, "Unable to acquire video"}, 
        {(unsigned char)97, (unsigned char)2, "Out of focus"}, 
        {(unsigned char)98, (unsigned char)0, "Scan head positioning error"}, 
        {(unsigned char)99, (unsigned char)0, "End of user area encountered on this track"}, 
        {(unsigned char)99,
      (unsigned char)1, "Packet does not fit in available space"}, 
        {(unsigned char)100, (unsigned char)0, "Illegal mode for this track"}, 
        {(unsigned char)100, (unsigned char)1, "Invalid packet size"}, 
        {(unsigned char)101, (unsigned char)0, "Voltage fault"}, 
        {(unsigned char)102, (unsigned char)0, "Automatic document feeder cover up"}, 
        {(unsigned char)102,
      (unsigned char)1, "Automatic document feeder lift up"}, 
        {(unsigned char)102, (unsigned char)2, "Document jam in automatic document feeder"}, 
        {(unsigned char)102,
      (unsigned char)3, "Document miss feed automatic in document feeder"}, 
        {(unsigned char)103, (unsigned char)0, "Configuration failure"}, 
        {(unsigned char)103, (unsigned char)1, "Configuration of incapable logical units failed"}, 
        {(unsigned char)103,
      (unsigned char)2, "Add logical unit failed"}, 
        {(unsigned char)103, (unsigned char)3, "Modification of logical unit failed"}, 
        {(unsigned char)103,
      (unsigned char)4, "Exchange of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)5, "Remove of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)6, "Attachment of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)7, "Creation of logical unit failed"}, 
        {(unsigned char)103, (unsigned char)8, "Assign failure occurred"}, 
        {(unsigned char)103, (unsigned char)9, "Multiply assigned logical unit"}, 
        {(unsigned char)103, (unsigned char)10, "Set target port groups command failed"}, 
        {(unsigned char)103,
      (unsigned char)11, "ATA device feature not enabled"}, 
        {(unsigned char)104, (unsigned char)0, "Logical unit not configured"}, 
        {(unsigned char)105, (unsigned char)0, "Data loss on logical unit"}, 
        {(unsigned char)105, (unsigned char)1, "Multiple logical unit failures"}, 
        {(unsigned char)105, (unsigned char)2, "Parity/data mismatch"}, 
        {(unsigned char)106, (unsigned char)0, "Informational, refer to log"}, 
        {(unsigned char)107, (unsigned char)0, "State change has occurred"}, 
        {(unsigned char)107, (unsigned char)1, "Redundancy level got better"}, 
        {(unsigned char)107, (unsigned char)2, "Redundancy level got worse"}, 
        {(unsigned char)108, (unsigned char)0, "Rebuild failure occurred"}, 
        {(unsigned char)109, (unsigned char)0, "Recalculate failure occurred"}, 
        {(unsigned char)110, (unsigned char)0, "Command to logical unit failed"}, 
        {(unsigned char)111, (unsigned char)0, "Copy protection key exchange failure - authentication failure"}, 
        {(unsigned char)111,
      (unsigned char)1, "Copy protection key exchange failure - key not present"}, 
        {(unsigned char)111,
      (unsigned char)2, "Copy protection key exchange failure - key not established"}, 
        {(unsigned char)111,
      (unsigned char)3, "Read of scrambled sector without authentication"}, 
        {(unsigned char)111, (unsigned char)4, "Media region code is mismatched to logical unit region"}, 
        {(unsigned char)111,
      (unsigned char)5, "Drive region must be permanent/region reset count error"}, 
        {(unsigned char)111,
      (unsigned char)6, "Insufficient block count for binding nonce recording"}, 
        {(unsigned char)111, (unsigned char)7, "Conflict in binding nonce recording"}, 
        {(unsigned char)113,
      (unsigned char)0, "Decompression exception long algorithm id"}, 
        {(unsigned char)114, (unsigned char)0, "Session fixation error"}, 
        {(unsigned char)114, (unsigned char)1, "Session fixation error writing lead-in"}, 
        {(unsigned char)114,
      (unsigned char)2, "Session fixation error writing lead-out"}, 
        {(unsigned char)114, (unsigned char)3, "Session fixation error - incomplete track in session"}, 
        {(unsigned char)114,
      (unsigned char)4, "Empty or partially written reserved track"}, 
        {(unsigned char)114, (unsigned char)5, "No more track reservations allowed"}, 
        {(unsigned char)114,
      (unsigned char)6, "RMZ extension is not allowed"}, 
        {(unsigned char)114, (unsigned char)7, "No more test zone extensions are allowed"}, 
        {(unsigned char)115,
      (unsigned char)0, "CD control error"}, 
        {(unsigned char)115, (unsigned char)1, "Power calibration area almost full"}, 
        {(unsigned char)115,
      (unsigned char)2, "Power calibration area is full"}, 
        {(unsigned char)115, (unsigned char)3, "Power calibration area error"}, 
        {(unsigned char)115, (unsigned char)4, "Program memory area update failure"}, 
        {(unsigned char)115,
      (unsigned char)5, "Program memory area is full"}, 
        {(unsigned char)115, (unsigned char)6, "RMA/PMA is almost full"}, 
        {(unsigned char)115, (unsigned char)16, "Current power calibration area almost full"}, 
        {(unsigned char)115,
      (unsigned char)17, "Current power calibration area is full"}, 
        {(unsigned char)115, (unsigned char)23, "RDZ is full"}, 
        {(unsigned char)116, (unsigned char)0, "Security error"}, 
        {(unsigned char)116, (unsigned char)1, "Unable to decrypt data"}, 
        {(unsigned char)116, (unsigned char)2, "Unencrypted data encountered while decrypting"}, 
        {(unsigned char)116,
      (unsigned char)3, "Incorrect data encryption key"}, 
        {(unsigned char)116, (unsigned char)4, "Cryptographic integrity validation failed"}, 
        {(unsigned char)116,
      (unsigned char)5, "Error decrypting data"}, 
        {(unsigned char)116, (unsigned char)6, "Unknown signature verification key"}, 
        {(unsigned char)116,
      (unsigned char)7, "Encryption parameters not useable"}, 
        {(unsigned char)116, (unsigned char)8, "Digital signature validation failure"}, 
        {(unsigned char)116,
      (unsigned char)9, "Encryption mode mismatch on read"}, 
        {(unsigned char)116, (unsigned char)10, "Encrypted block not raw read enabled"}, 
        {(unsigned char)116,
      (unsigned char)11, "Incorrect Encryption parameters"}, 
        {(unsigned char)116, (unsigned char)12, "Unable to decrypt parameter list"}, 
        {(unsigned char)116, (unsigned char)13, "Encryption algorithm disabled"}, 
        {(unsigned char)116, (unsigned char)16, "SA creation parameter value invalid"}, 
        {(unsigned char)116,
      (unsigned char)17, "SA creation parameter value rejected"}, 
        {(unsigned char)116, (unsigned char)18, "Invalid SA usage"}, 
        {(unsigned char)116, (unsigned char)33, "Data encryption configuration prevented"}, 
        {(unsigned char)116,
      (unsigned char)48, "SA creation parameter not supported"}, 
        {(unsigned char)116, (unsigned char)64, "Authentication failed"}, 
        {(unsigned char)116, (unsigned char)97, "External data encryption key manager access error"}, 
        {(unsigned char)116,
      (unsigned char)98, "External data encryption key manager error"}, 
        {(unsigned char)116, (unsigned char)99, "External data encryption key not found"}, 
        {(unsigned char)116,
      (unsigned char)100, "External data encryption request not authorized"}, 
        {(unsigned char)116, (unsigned char)110, "External data encryption control timeout"}, 
        {(unsigned char)116,
      (unsigned char)111, "External data encryption control error"}, 
        {(unsigned char)116, (unsigned char)113, "Logical unit access not authorized"}, 
        {(unsigned char)116,
      (unsigned char)121, "Security conflict in translated device"}, 
        {(unsigned char)0, (unsigned char)0, (char const   *)((void *)0)}};
#line 1040 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
char const   *sg_lib_sense_key_desc[16]  = 
#line 1040
  {      "No Sense",      "Recovered Error",      "Not Ready",      "Medium Error", 
        "Hardware Error",      "Illegal Request",      "Unit Attention",      "Data Protect", 
        "Blank Check",      "Key=9",      "Copy Aborted",      "Aborted Command", 
        "Equal",      "Volume Overflow",      "Miscompare",      "Completed"};
#line 1065 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
char const   *sg_lib_pdt_strs[32]  = 
#line 1065
  {      "disk",      "tape",      "printer",      "processor", 
        "write once optical disk",      "cd/dvd",      "scanner",      "optical memory device", 
        "medium changer",      "communications",      "graphics [0xa]",      "graphics [0xb]", 
        "storage array controller",      "enclosure services device",      "simplified direct access device",      "optical card reader/writer device", 
        "bridge controller commands",      "object based storage",      "automation/driver interface",      "security manager device", 
        "0x14",      "0x15",      "0x16",      "0x17", 
        "0x18",      "0x19",      "0x1a",      "0x1b", 
        "0x1c",      "0x1d",      "well known logical unit",      "no physical device on this lu"};
#line 1092 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_lib_data.c"
char const   *sg_lib_transport_proto_strs[16]  = 
#line 1092
  {      "Fibre Channel Protocol for SCSI (FCP-2)",      "SCSI Parallel Interface (SPI-5)",      "Serial Storage Architecture SCSI-3 Protocol (SSA-S3P)",      "Serial Bus Protocol for IEEE 1394 (SBP-3)", 
        "SCSI RDMA Protocol (SRP)",      "Internet SCSI (iSCSI)",      "Serial Attached SCSI Protocol (SPL-2)",      "Automation/Drive Interface Transport (ADT-2)", 
        "AT Attachment Interface (ACS-2)",      "USB Attached SCSI (UAS-2)",      "Oxa",      "Oxb", 
        "Oxc",      "Oxd",      "Oxe",      "No specific protocol"};
#line 28 "../include/sg_pt.h"
char const   *scsi_pt_version(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_common.c"
static char const   *scsi_pt_version_str  =    "2.08 20110207";
#line 19 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_common.c"
char const   *scsi_pt_version(void) 
{ 


  {
#line 22
  return (scsi_pt_version_str);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 53 "../include/sg_pt.h"
void clear_scsi_pt_obj(struct sg_pt_base *vp ) ;
#line 69
void set_scsi_pt_tag(struct sg_pt_base *vp , uint64_t tag ) ;
#line 70
void set_scsi_pt_task_management(struct sg_pt_base *vp , int tmf_code ) ;
#line 72
void set_scsi_pt_task_attr(struct sg_pt_base *vp , int attribute , int priority ) ;
#line 84
void set_scsi_pt_flags(struct sg_pt_base *vp , int flags ) ;
#line 115
int get_scsi_pt_os_err(struct sg_pt_base  const  *vp ) ;
#line 119
int get_scsi_pt_transport_err(struct sg_pt_base  const  *vp ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static char const   *linux_host_bytes[14]  = 
#line 32 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
  {      "DID_OK",      "DID_NO_CONNECT",      "DID_BUS_BUSY",      "DID_TIME_OUT", 
        "DID_BAD_TARGET",      "DID_ABORT",      "DID_PARITY",      "DID_ERROR", 
        "DID_RESET",      "DID_BAD_INTR",      "DID_PASSTHROUGH",      "DID_SOFT_ERROR", 
        "DID_IMM_RETRY",      "DID_REQUEUE"};
#line 42 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static char const   *linux_driver_bytes[9]  = 
#line 42
  {      "DRIVER_OK",      "DRIVER_BUSY",      "DRIVER_SOFT",      "DRIVER_MEDIA", 
        "DRIVER_ERROR",      "DRIVER_INVALID",      "DRIVER_TIMEOUT",      "DRIVER_HARD", 
        "DRIVER_SENSE"};
#line 51 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static char const   *linux_driver_suggests[9]  = 
#line 51
  {      "SUGGEST_OK",      "SUGGEST_RETRY",      "SUGGEST_ABORT",      "SUGGEST_REMAP", 
        "SUGGEST_DIE",      "UNKNOWN",      "UNKNOWN",      "UNKNOWN", 
        "SUGGEST_SENSE"};
#line 502 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static int bsg_major_checked  =    0;
#line 503 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static int bsg_major  =    0;
#line 507 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static void find_bsg_major(int verbose ) 
{ 
  char const   *proc_devices ;
  FILE *fp ;
  char a[128] ;
  char b[128] ;
  char *cp ;
  int n ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 510
  proc_devices = "/proc/devices";
#line 517
  fp = fopen((char const   */* __restrict  */)proc_devices, (char const   */* __restrict  */)"r");
  }
#line 517
  if ((unsigned long )((void *)0) == (unsigned long )fp) {
#line 518
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 519
      sg_warnings_strm = stderr;
    }
#line 520
    if (verbose) {
      {
#line 521
      tmp = __errno_location();
#line 521
      tmp___0 = strerror(*tmp);
#line 521
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"fopen %s failed: %s\n",
              proc_devices, tmp___0);
      }
    }
#line 523
    return;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 525
    cp = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)fp);
    }
#line 525
    if (! cp) {
#line 525
      goto while_break;
    }
    {
#line 526
    tmp___1 = sscanf((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"%s",
                     a);
    }
#line 526
    if (1 == tmp___1) {
      {
#line 526
      tmp___2 = memcmp((void const   *)(a), (void const   *)"Character", (size_t )9);
      }
#line 526
      if (0 == tmp___2) {
#line 528
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 530
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 530
    if (cp) {
      {
#line 530
      cp = fgets((char */* __restrict  */)(b), (int )sizeof(b), (FILE */* __restrict  */)fp);
      }
#line 530
      if (! cp) {
#line 530
        goto while_break___0;
      }
    } else {
#line 530
      goto while_break___0;
    }
    {
#line 531
    tmp___4 = sscanf((char const   */* __restrict  */)(b), (char const   */* __restrict  */)"%d %s",
                     & n, a);
    }
#line 531
    if (2 == tmp___4) {
      {
#line 532
      tmp___3 = strcmp("bsg", (char const   *)(a));
      }
#line 532
      if (0 == tmp___3) {
#line 533
        bsg_major = n;
#line 534
        goto while_break___0;
      }
    } else {
#line 537
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 539
  if (verbose > 3) {
#line 540
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 541
      sg_warnings_strm = stderr;
    }
#line 542
    if (cp) {
      {
#line 543
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"found bsg_major=%d\n",
              bsg_major);
      }
    } else {
      {
#line 545
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"found no bsg char device in %s\n",
              proc_devices);
      }
    }
  }
  {
#line 548
  fclose(fp);
  }
#line 549
  return;
}
}
#line 553 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int scsi_pt_open_device(char const   *device_name , int read_only , int verbose ) 
{ 
  int oflags ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  oflags = 2048;
#line 558
  if (read_only) {
#line 558
    tmp = 0;
  } else {
#line 558
    tmp = 2;
  }
  {
#line 558
  oflags |= tmp;
#line 559
  tmp___0 = scsi_pt_open_flags(device_name, oflags, verbose);
  }
#line 559
  return (tmp___0);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int scsi_pt_open_flags(char const   *device_name , int flags , int verbose ) 
{ 
  int fd ;
  int *tmp ;

  {
#line 570
  if (! bsg_major_checked) {
    {
#line 571
    bsg_major_checked = 1;
#line 572
    find_bsg_major(verbose);
    }
  }
#line 574
  if (verbose > 1) {
#line 575
    if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 576
      sg_warnings_strm = stderr;
    }
    {
#line 577
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"open %s with flags=0x%x\n",
            device_name, flags);
    }
  }
  {
#line 580
  fd = open(device_name, flags);
  }
#line 581
  if (fd < 0) {
    {
#line 582
    tmp = __errno_location();
#line 582
    fd = - *tmp;
    }
  }
#line 583
  return (fd);
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int scsi_pt_close_device(int device_fd ) 
{ 
  int res ;
  int *tmp ;

  {
  {
#line 592
  res = close(device_fd);
  }
#line 593
  if (res < 0) {
    {
#line 594
    tmp = __errno_location();
#line 594
    res = - *tmp;
    }
  }
#line 595
  return (res);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
struct sg_pt_base *construct_scsi_pt_obj(void) 
{ 
  struct sg_pt_linux_scsi *ptp ;
  void *tmp ;

  {
  {
#line 604
  tmp = calloc((size_t )1, sizeof(struct sg_pt_linux_scsi ));
#line 604
  ptp = (struct sg_pt_linux_scsi *)tmp;
  }
#line 606
  if (ptp) {
#line 607
    ptp->io_hdr.guard = 'Q';
#line 609
    ptp->io_hdr.protocol = (__u32 )0;
#line 612
    ptp->io_hdr.subprotocol = (__u32 )0;
  }
#line 615
  return ((struct sg_pt_base *)ptp);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void destruct_scsi_pt_obj(struct sg_pt_base *vp ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 621
  ptp = & vp->impl;
#line 623
  if (ptp) {
    {
#line 624
    free((void *)ptp);
    }
  }
#line 625
  return;
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void clear_scsi_pt_obj(struct sg_pt_base *vp ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 630
  ptp = & vp->impl;
#line 632
  if (ptp) {
    {
#line 633
    memset((void *)ptp, 0, sizeof(struct sg_pt_linux_scsi ));
#line 634
    ptp->io_hdr.guard = 'Q';
#line 636
    ptp->io_hdr.protocol = (__u32 )0;
#line 639
    ptp->io_hdr.subprotocol = (__u32 )0;
    }
  }
#line 642
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_cdb(struct sg_pt_base *vp , unsigned char const   *cdb , int cdb_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 648
  ptp = & vp->impl;
#line 650
  if (ptp->io_hdr.request) {
#line 651
    (ptp->in_err) ++;
  }
#line 653
  ptp->io_hdr.request = (__u64 )((long )cdb);
#line 654
  ptp->io_hdr.request_len = (__u32 )cdb_len;
#line 655
  return;
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_sense(struct sg_pt_base *vp , unsigned char *sense , int max_sense_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 661
  ptp = & vp->impl;
#line 663
  if (ptp->io_hdr.response) {
#line 664
    (ptp->in_err) ++;
  }
  {
#line 665
  memset((void *)sense, 0, (size_t )max_sense_len);
#line 666
  ptp->io_hdr.response = (__u64 )((long )sense);
#line 667
  ptp->io_hdr.max_response_len = (__u32 )max_sense_len;
  }
#line 668
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_data_in(struct sg_pt_base *vp , unsigned char *dxferp , int dxfer_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 675
  ptp = & vp->impl;
#line 677
  if (ptp->io_hdr.din_xferp) {
#line 678
    (ptp->in_err) ++;
  }
#line 679
  if (dxfer_len > 0) {
#line 680
    ptp->io_hdr.din_xferp = (__u64 )((long )dxferp);
#line 681
    ptp->io_hdr.din_xfer_len = (__u32 )dxfer_len;
  }
#line 683
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_data_out(struct sg_pt_base *vp , unsigned char const   *dxferp ,
                          int dxfer_len ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 690
  ptp = & vp->impl;
#line 692
  if (ptp->io_hdr.dout_xferp) {
#line 693
    (ptp->in_err) ++;
  }
#line 694
  if (dxfer_len > 0) {
#line 695
    ptp->io_hdr.dout_xferp = (__u64 )((long )dxferp);
#line 696
    ptp->io_hdr.dout_xfer_len = (__u32 )dxfer_len;
  }
#line 698
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_packet_id(struct sg_pt_base *vp , int pack_id ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 703
  ptp = & vp->impl;
#line 705
  ptp->io_hdr.spare_in = (__u32 )pack_id;
#line 706
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_tag(struct sg_pt_base *vp , uint64_t tag ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 711
  ptp = & vp->impl;
#line 713
  ptp->io_hdr.request_tag = (__u64 )tag;
#line 714
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_task_management(struct sg_pt_base *vp , int tmf_code ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 720
  ptp = & vp->impl;
#line 722
  ptp->io_hdr.subprotocol = (__u32 )1;
#line 723
  ptp->tmf_request[0] = (unsigned char )tmf_code;
#line 724
  ptp->io_hdr.request = (__u64 )((long )(& ptp->tmf_request[0]));
#line 725
  ptp->io_hdr.request_len = (__u32 )1;
#line 726
  return;
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_task_attr(struct sg_pt_base *vp , int attribute , int priority ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 731
  ptp = & vp->impl;
#line 733
  ptp->io_hdr.request_attr = (__u32 )attribute;
#line 734
  ptp->io_hdr.request_priority = (__u32 )priority;
#line 735
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
void set_scsi_pt_flags(struct sg_pt_base *vp , int flags ) 
{ 
  struct sg_pt_linux_scsi *ptp ;

  {
#line 744
  ptp = & vp->impl;
#line 747
  if (16 & flags) {
#line 748
    ptp->io_hdr.flags |= 16U;
  }
#line 749
  if (32 & flags) {
#line 750
    ptp->io_hdr.flags &= 4294967279U;
  }
#line 751
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_resid(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 757
  ptp = & vp->impl;
#line 759
  return ((int )ptp->io_hdr.din_resid);
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_status_response(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 765
  ptp = & vp->impl;
#line 767
  return ((int )ptp->io_hdr.device_status);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_sense_len(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 773
  ptp = & vp->impl;
#line 775
  return ((int )ptp->io_hdr.response_len);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_duration_ms(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 781
  ptp = & vp->impl;
#line 783
  return ((int )ptp->io_hdr.duration);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_transport_err(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 789
  ptp = & vp->impl;
#line 791
  return ((int )ptp->io_hdr.transport_status);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
char *get_scsi_pt_transport_err_str(struct sg_pt_base  const  *vp , int max_b_len ,
                                    char *b ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;
  int ds ;
  int hs ;
  int n ;
  int m ;
  char *cp ;
  int driv ;
  int sugg ;
  char const   *driv_cp ;
  char const   *sugg_cp ;

  {
#line 799
  ptp = & vp->impl;
#line 800
  ds = (int )ptp->io_hdr.driver_status;
#line 801
  hs = (int )ptp->io_hdr.transport_status;
#line 803
  cp = b;
#line 805
  driv_cp = "invalid";
#line 806
  sugg_cp = "invalid";
#line 808
  m = max_b_len;
#line 809
  n = 0;
#line 810
  if (hs) {
#line 811
    if (hs < 0) {
      {
#line 812
      n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Host_status=0x%02x is invalid\n",
                   hs);
      }
    } else
#line 811
    if (hs >= (int )(sizeof(linux_host_bytes) / sizeof(linux_host_bytes[0]))) {
      {
#line 812
      n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Host_status=0x%02x is invalid\n",
                   hs);
      }
    } else {
      {
#line 814
      n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Host_status=0x%02x [%s]\n",
                   hs, linux_host_bytes[hs]);
      }
    }
  }
#line 817
  m -= n;
#line 818
  if (m < 1) {
#line 819
    *(b + (max_b_len - 1)) = (char )'\000';
#line 820
    return (b);
  }
#line 822
  cp += n;
#line 823
  driv = ds & 15;
#line 824
  if (driv < (int )(sizeof(linux_driver_bytes) / sizeof(linux_driver_bytes[0]))) {
#line 825
    driv_cp = linux_driver_bytes[driv];
  }
#line 826
  sugg = (ds & 240) >> 4;
#line 827
  if (sugg < (int )(sizeof(linux_driver_suggests) / sizeof(linux_driver_suggests[0]))) {
#line 828
    sugg_cp = linux_driver_suggests[sugg];
  }
  {
#line 829
  n = snprintf((char */* __restrict  */)cp, (size_t )m, (char const   */* __restrict  */)"Driver_status=0x%02x [%s, %s]\n",
               ds, driv_cp, sugg_cp);
#line 831
  m -= n;
  }
#line 832
  if (m < 1) {
#line 833
    *(b + (max_b_len - 1)) = (char )'\000';
  }
#line 834
  return (b);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_result_category(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;
  int dr_st ;
  int scsi_st ;

  {
#line 840
  ptp = & vp->impl;
#line 841
  dr_st = (int )(ptp->io_hdr.driver_status & 15U);
#line 842
  scsi_st = (int )(ptp->io_hdr.device_status & 126U);
#line 844
  if (ptp->os_err) {
#line 845
    return (4);
  } else
#line 846
  if (ptp->io_hdr.transport_status) {
#line 847
    return (3);
  } else
#line 848
  if (dr_st) {
#line 848
    if (8 != dr_st) {
#line 849
      return (3);
    } else {
#line 848
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 850
  if (8 == dr_st) {
#line 853
    return (2);
  } else
#line 850
  if (2 == scsi_st) {
#line 853
    return (2);
  } else
#line 850
  if (34 == scsi_st) {
#line 853
    return (2);
  } else
#line 854
  if (scsi_st) {
#line 855
    return (1);
  } else {
#line 857
    return (0);
  }
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int get_scsi_pt_os_err(struct sg_pt_base  const  *vp ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;

  {
#line 863
  ptp = & vp->impl;
#line 865
  return ((int )ptp->os_err);
}
}
#line 868 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
char *get_scsi_pt_os_err_str(struct sg_pt_base  const  *vp , int max_b_len , char *b ) 
{ 
  struct sg_pt_linux_scsi  const  *ptp ;
  char const   *cp ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 871
  ptp = & vp->impl;
#line 874
  tmp = safe_strerror((int )ptp->os_err);
#line 874
  cp = (char const   *)tmp;
#line 875
  strncpy((char */* __restrict  */)b, (char const   */* __restrict  */)cp, (size_t )max_b_len);
#line 876
  tmp___0 = strlen(cp);
  }
#line 876
  if ((int )tmp___0 >= max_b_len) {
#line 877
    *(b + (max_b_len - 1)) = (char )'\000';
  }
#line 878
  return (b);
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
static int do_scsi_pt_v3(struct sg_pt_linux_scsi *ptp , int fd , int time_secs , int verbose ) 
{ 
  struct sg_io_hdr v3_hdr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 888
  memset((void *)(& v3_hdr), 0, sizeof(v3_hdr));
#line 890
  v3_hdr.interface_id = 'S';
#line 891
  v3_hdr.dxfer_direction = -1;
#line 892
  v3_hdr.cmdp = (unsigned char *)((void *)((long )ptp->io_hdr.request));
#line 893
  v3_hdr.cmd_len = (unsigned char )ptp->io_hdr.request_len;
  }
#line 894
  if (ptp->io_hdr.din_xfer_len > 0U) {
#line 895
    if (ptp->io_hdr.dout_xfer_len > 0U) {
#line 896
      if (verbose) {
        {
#line 897
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"sgv3 doesn\'t support bidi\n");
        }
      }
#line 898
      return (1);
    }
#line 900
    v3_hdr.dxferp = (void *)((long )ptp->io_hdr.din_xferp);
#line 901
    v3_hdr.dxfer_len = ptp->io_hdr.din_xfer_len;
#line 902
    v3_hdr.dxfer_direction = -3;
  } else
#line 903
  if (ptp->io_hdr.dout_xfer_len > 0U) {
#line 904
    v3_hdr.dxferp = (void *)((long )ptp->io_hdr.dout_xferp);
#line 905
    v3_hdr.dxfer_len = ptp->io_hdr.dout_xfer_len;
#line 906
    v3_hdr.dxfer_direction = -2;
  }
#line 908
  if (ptp->io_hdr.response) {
#line 908
    if (ptp->io_hdr.max_response_len > 0U) {
#line 909
      v3_hdr.sbp = (unsigned char *)((void *)((long )ptp->io_hdr.response));
#line 910
      v3_hdr.mx_sb_len = (unsigned char )ptp->io_hdr.max_response_len;
    }
  }
#line 912
  v3_hdr.pack_id = (int )ptp->io_hdr.spare_in;
#line 914
  if ((unsigned long )((void *)0) == (unsigned long )v3_hdr.cmdp) {
#line 915
    if (verbose) {
      {
#line 916
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"No SCSI command (cdb) given\n");
      }
    }
#line 917
    return (1);
  }
#line 920
  if (time_secs > 0) {
#line 920
    v3_hdr.timeout = (unsigned int )(time_secs * 1000);
  } else {
#line 920
    v3_hdr.timeout = 60000U;
  }
  {
#line 922
  tmp___1 = ioctl(fd, 8837UL, & v3_hdr);
  }
#line 922
  if (tmp___1 < 0) {
    {
#line 923
    tmp = __errno_location();
#line 923
    ptp->os_err = *tmp;
    }
#line 924
    if (verbose > 1) {
      {
#line 925
      tmp___0 = strerror(ptp->os_err);
#line 925
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"ioctl(SG_IO v3) failed: %s (errno=%d)\n",
              tmp___0, ptp->os_err);
      }
    }
#line 927
    return (- ptp->os_err);
  }
#line 929
  ptp->io_hdr.device_status = (__u32 )v3_hdr.status;
#line 930
  ptp->io_hdr.driver_status = (__u32 )v3_hdr.driver_status;
#line 931
  ptp->io_hdr.transport_status = (__u32 )v3_hdr.host_status;
#line 932
  ptp->io_hdr.response_len = (__u32 )v3_hdr.sb_len_wr;
#line 933
  ptp->io_hdr.duration = v3_hdr.duration;
#line 934
  ptp->io_hdr.din_resid = v3_hdr.resid;
#line 936
  return (0);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_pt_linux.c"
int do_scsi_pt(struct sg_pt_base *vp , int fd , int time_secs , int verbose ) 
{ 
  struct sg_pt_linux_scsi *ptp ;
  int tmp ;
  struct stat a_stat ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 945
  ptp = & vp->impl;
#line 947
  if (! bsg_major_checked) {
    {
#line 948
    bsg_major_checked = 1;
#line 949
    find_bsg_major(verbose);
    }
  }
#line 951
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 952
    sg_warnings_strm = stderr;
  }
#line 953
  ptp->os_err = 0;
#line 954
  if (ptp->in_err) {
#line 955
    if (verbose) {
      {
#line 956
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Replicated or unused set_scsi_pt... functions\n");
      }
    }
#line 958
    return (1);
  }
#line 960
  if (bsg_major <= 0) {
    {
#line 961
    tmp = do_scsi_pt_v3(ptp, fd, time_secs, verbose);
    }
#line 961
    return (tmp);
  } else {
    {
#line 965
    tmp___2 = fstat(fd, & a_stat);
    }
#line 965
    if (tmp___2 < 0) {
      {
#line 966
      tmp___0 = __errno_location();
#line 966
      ptp->os_err = *tmp___0;
      }
#line 967
      if (verbose > 1) {
        {
#line 968
        tmp___1 = strerror(ptp->os_err);
#line 968
        fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"fstat() failed: %s (errno=%d)\n",
                tmp___1, ptp->os_err);
        }
      }
#line 970
      return (- ptp->os_err);
    }
#line 973
    if (! ((a_stat.st_mode & 61440U) == 8192U)) {
      {
#line 975
      tmp___3 = do_scsi_pt_v3(ptp, fd, time_secs, verbose);
      }
#line 975
      return (tmp___3);
    } else
#line 973
    if (bsg_major != (int )(a_stat.st_rdev >> 8)) {
      {
#line 975
      tmp___3 = do_scsi_pt_v3(ptp, fd, time_secs, verbose);
      }
#line 975
      return (tmp___3);
    }
  }
#line 983
  if (! ptp->io_hdr.request) {
#line 984
    if (verbose) {
      {
#line 985
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"No SCSI command (cdb) given (v4)\n");
      }
    }
#line 986
    return (1);
  }
#line 989
  if (time_secs > 0) {
#line 989
    ptp->io_hdr.timeout = (__u32 )(time_secs * 1000);
  } else {
#line 989
    ptp->io_hdr.timeout = (__u32 )60000;
  }
  {
#line 1000
  tmp___6 = ioctl(fd, 8837UL, & ptp->io_hdr);
  }
#line 1000
  if (tmp___6 < 0) {
    {
#line 1001
    tmp___4 = __errno_location();
#line 1001
    ptp->os_err = *tmp___4;
    }
#line 1002
    if (verbose > 1) {
      {
#line 1003
      tmp___5 = strerror(ptp->os_err);
#line 1003
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"ioctl(SG_IO v4) failed: %s (errno=%d)\n",
              tmp___5, ptp->os_err);
      }
    }
#line 1005
    return (- ptp->os_err);
  }
#line 1007
  return (0);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm.h"
void sdp_set_big_endian(uint64_t val , unsigned char *to , int start_bit , int num_bits ) ;
#line 323
char *sdp_get_ansi_version_str(int version , int buff_len , char *buff ) ;
#line 327
int sdp_strcase_eq(char const   *s1p , char const   *s2p ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
int sdp_strcase_eq(char const   *s1p , char const   *s2p ) 
{ 
  int c1 ;
  int c2 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    tmp = s1p;
#line 50
    s1p ++;
#line 50
    c1 = (int )*tmp;
#line 51
    tmp___0 = s2p;
#line 51
    s2p ++;
#line 51
    c2 = (int )*tmp___0;
#line 52
    if (c1 != c2) {
#line 53
      if (c2 >= 97) {
        {
#line 54
        c2 = toupper(c2);
        }
      } else
#line 55
      if (c1 >= 97) {
        {
#line 56
        c1 = toupper(c1);
        }
      } else {
#line 58
        return (0);
      }
#line 59
      if (c1 != c2) {
#line 60
        return (0);
      }
    }
#line 49
    if (! c1) {
#line 49
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
int sdp_get_mp_len(unsigned char *mp ) 
{ 
  int tmp ;

  {
#line 69
  if ((int )*(mp + 0) & 64) {
#line 69
    tmp = (((int )*(mp + 2) << 8) + (int )*(mp + 3)) + 4;
  } else {
#line 69
    tmp = (int )*(mp + 1) + 2;
  }
#line 69
  return (tmp);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_mode_page_t  const  *sdp_get_mode_detail(int page_num , int subpage_num ,
                                                       int pdt , int transp_proto ,
                                                       int vendor_num ) 
{ 
  struct sdparm_mode_page_t  const  *mpp ;
  struct sdparm_vendor_pair  const  *vpp ;

  {
#line 78
  if (vendor_num >= 0) {
    {
#line 81
    vpp = sdp_get_vendor_pair(vendor_num);
    }
#line 82
    if (vpp) {
#line 82
      mpp = (struct sdparm_mode_page_t  const  *)vpp->mpage;
    } else {
#line 82
      mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
    }
  } else
#line 83
  if (transp_proto >= 0) {
#line 83
    if (transp_proto < 16) {
#line 84
      mpp = (struct sdparm_mode_page_t  const  *)sdparm_transport_mp[transp_proto].mpage;
    } else {
#line 86
      mpp = (struct sdparm_mode_page_t  const  *)(sdparm_gen_mode_pg);
    }
  } else {
#line 86
    mpp = (struct sdparm_mode_page_t  const  *)(sdparm_gen_mode_pg);
  }
#line 87
  if ((unsigned long )((void *)0) == (unsigned long )mpp) {
#line 88
    return ((struct sdparm_mode_page_t  const  *)((void *)0));
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! mpp->acron) {
#line 90
      goto while_break;
    }
#line 91
    if (page_num == (int )mpp->page) {
#line 91
      if (subpage_num == (int )mpp->subpage) {
#line 92
        if (pdt < 0) {
#line 93
          return (mpp);
        } else
#line 92
        if (mpp->pdt < 0) {
#line 93
          return (mpp);
        } else
#line 92
        if (mpp->pdt == (int const   )pdt) {
#line 93
          return (mpp);
        }
      }
    }
#line 90
    mpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return ((struct sdparm_mode_page_t  const  *)((void *)0));
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_mode_page_t  const  *sdp_get_mpage_name(int page_num , int subpage_num ,
                                                      int pdt , int transp_proto ,
                                                      int vendor_num , int plus_acron ,
                                                      int hex , char *bp , int max_b_len ) 
{ 
  int len ;
  struct sdparm_mode_page_t  const  *mpp ;
  char const   *cp ;

  {
#line 104
  len = max_b_len - 1;
#line 105
  mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
#line 108
  if (len < 0) {
#line 109
    return (mpp);
  }
  {
#line 110
  *(bp + len) = (char )'\000';
#line 111
  mpp = sdp_get_mode_detail(page_num, subpage_num, pdt, transp_proto, vendor_num);
  }
#line 113
  if ((unsigned long )((void *)0) == (unsigned long )mpp) {
    {
#line 114
    mpp = sdp_get_mode_detail(page_num, subpage_num, -1, transp_proto, vendor_num);
    }
  }
#line 116
  if (mpp) {
#line 116
    if (mpp->name) {
#line 117
      cp = (char const   *)mpp->acron;
#line 118
      if ((unsigned long )((void *)0) == (unsigned long )cp) {
#line 119
        cp = "";
      }
#line 120
      if (hex) {
#line 121
        if (0 == subpage_num) {
#line 122
          if (plus_acron) {
            {
#line 123
            snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"%s [%s: 0x%x]",
                     mpp->name, cp, page_num);
            }
          } else {
            {
#line 126
            snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"%s [0x%x]",
                     mpp->name, page_num);
            }
          }
        } else
#line 128
        if (plus_acron) {
          {
#line 129
          snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"%s [%s: 0x%x,0x%x]",
                   mpp->name, cp, page_num, subpage_num);
          }
        } else {
          {
#line 132
          snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"%s [0x%x,0x%x]",
                   mpp->name, page_num, subpage_num);
          }
        }
      } else
#line 136
      if (plus_acron) {
        {
#line 137
        snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"%s [%s]",
                 mpp->name, cp);
        }
      } else {
        {
#line 139
        snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"%s",
                 mpp->name);
        }
      }
    } else {
#line 116
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 142
  if (0 == subpage_num) {
    {
#line 143
    snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"[0x%x]",
             page_num);
    }
  } else {
    {
#line 145
    snprintf((char */* __restrict  */)bp, (size_t )len, (char const   */* __restrict  */)"[0x%x,0x%x]",
             page_num, subpage_num);
    }
  }
#line 147
  return (mpp);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_mode_page_t  const  *sdp_find_mp_by_acron(char const   *ap , int transp_proto ,
                                                        int vendor_num ) 
{ 
  struct sdparm_mode_page_t  const  *mpp ;
  struct sdparm_vendor_pair  const  *vpp ;
  int tmp ;

  {
#line 155
  if (vendor_num >= 0) {
    {
#line 158
    vpp = sdp_get_vendor_pair(vendor_num);
    }
#line 159
    if (vpp) {
#line 159
      mpp = (struct sdparm_mode_page_t  const  *)vpp->mpage;
    } else {
#line 159
      mpp = (struct sdparm_mode_page_t  const  *)((void *)0);
    }
  } else
#line 160
  if (transp_proto >= 0) {
#line 160
    if (transp_proto < 16) {
#line 161
      mpp = (struct sdparm_mode_page_t  const  *)sdparm_transport_mp[transp_proto].mpage;
    } else {
#line 163
      mpp = (struct sdparm_mode_page_t  const  *)(sdparm_gen_mode_pg);
    }
  } else {
#line 163
    mpp = (struct sdparm_mode_page_t  const  *)(sdparm_gen_mode_pg);
  }
#line 164
  if ((unsigned long )((void *)0) == (unsigned long )mpp) {
#line 165
    return ((struct sdparm_mode_page_t  const  *)((void *)0));
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! mpp->acron) {
#line 167
      goto while_break;
    }
    {
#line 168
    tmp = sdp_strcase_eq((char const   *)mpp->acron, ap);
    }
#line 168
    if (tmp) {
#line 169
      return (mpp);
    }
#line 167
    mpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return ((struct sdparm_mode_page_t  const  *)((void *)0));
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_vpd_page_t  const  *sdp_get_vpd_detail(int page_num , int subvalue ,
                                                     int pdt ) 
{ 
  struct sdparm_vpd_page_t  const  *vpp ;
  int sv ;
  int ty ;
  struct sdparm_vpd_page_t  const  *tmp ;
  struct sdparm_vpd_page_t  const  *tmp___0 ;

  {
#line 180
  if (subvalue < 0) {
#line 180
    sv = 1;
  } else {
#line 180
    sv = 0;
  }
#line 181
  if (pdt < 0) {
#line 181
    ty = 1;
  } else {
#line 181
    ty = 0;
  }
#line 182
  vpp = (struct sdparm_vpd_page_t  const  *)(sdparm_vpd_pg);
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! vpp->acron) {
#line 182
      goto while_break;
    }
#line 183
    if (page_num == (int )vpp->vpd_num) {
#line 183
      if (sv) {
#line 183
        goto _L;
      } else
#line 183
      if (subvalue == (int )vpp->subvalue) {
        _L: /* CIL Label */ 
#line 183
        if (ty) {
#line 186
          return (vpp);
        } else
#line 183
        if (pdt == (int )vpp->pdt) {
#line 186
          return (vpp);
        }
      }
    }
#line 182
    vpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (! ty) {
    {
#line 189
    tmp = sdp_get_vpd_detail(page_num, subvalue, -1);
    }
#line 189
    return (tmp);
  }
#line 190
  if (! sv) {
    {
#line 191
    tmp___0 = sdp_get_vpd_detail(page_num, -1, -1);
    }
#line 191
    return (tmp___0);
  }
#line 192
  return ((struct sdparm_vpd_page_t  const  *)((void *)0));
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_vpd_page_t  const  *sdp_find_vpd_by_acron(char const   *ap ) 
{ 
  struct sdparm_vpd_page_t  const  *vpp ;
  int tmp ;

  {
#line 200
  vpp = (struct sdparm_vpd_page_t  const  *)(sdparm_vpd_pg);
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! vpp->acron) {
#line 200
      goto while_break;
    }
    {
#line 201
    tmp = sdp_strcase_eq((char const   *)vpp->acron, ap);
    }
#line 201
    if (tmp) {
#line 202
      return (vpp);
    }
#line 200
    vpp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return ((struct sdparm_vpd_page_t  const  *)((void *)0));
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
char const   *sdp_get_transport_name(int proto_num ) 
{ 
  struct sdparm_transport_id_t  const  *tip ;

  {
#line 212
  tip = (struct sdparm_transport_id_t  const  *)(sdparm_transport_id);
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! tip->acron) {
#line 212
      goto while_break;
    }
#line 213
    if (proto_num == (int )tip->proto_num) {
#line 214
      return ((char const   *)tip->name);
    }
#line 212
    tip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return ((char const   *)((void *)0));
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_transport_id_t  const  *sdp_find_transport_by_acron(char const   *ap ) 
{ 
  struct sdparm_transport_id_t  const  *tip ;
  int tmp ;

  {
#line 224
  tip = (struct sdparm_transport_id_t  const  *)(sdparm_transport_id);
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! tip->acron) {
#line 224
      goto while_break;
    }
    {
#line 225
    tmp = sdp_strcase_eq((char const   *)tip->acron, ap);
    }
#line 225
    if (tmp) {
#line 226
      return (tip);
    }
#line 224
    tip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return ((struct sdparm_transport_id_t  const  *)((void *)0));
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
char const   *sdp_get_vendor_name(int vendor_num ) 
{ 
  struct sdparm_vendor_name_t  const  *vnp ;

  {
#line 236
  vnp = (struct sdparm_vendor_name_t  const  *)(sdparm_vendor_id);
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! vnp->acron) {
#line 236
      goto while_break;
    }
#line 237
    if (vendor_num == (int )vnp->vendor_num) {
#line 238
      return ((char const   *)vnp->name);
    }
#line 236
    vnp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((char const   *)((void *)0));
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_vendor_name_t  const  *sdp_find_vendor_by_acron(char const   *ap ) 
{ 
  struct sdparm_vendor_name_t  const  *vnp ;
  int tmp ;

  {
#line 248
  vnp = (struct sdparm_vendor_name_t  const  *)(sdparm_vendor_id);
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! vnp->acron) {
#line 248
      goto while_break;
    }
    {
#line 249
    tmp = sdp_strcase_eq((char const   *)vnp->acron, ap);
    }
#line 249
    if (tmp) {
#line 250
      return (vnp);
    }
#line 248
    vnp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return ((struct sdparm_vendor_name_t  const  *)((void *)0));
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_vendor_pair  const  *sdp_get_vendor_pair(int vendor_num ) 
{ 
  struct sdparm_vendor_pair *tmp ;

  {
#line 258
  if (vendor_num >= 0) {
#line 258
    if (vendor_num < sdparm_vendor_mp_len) {
#line 258
      tmp = sdparm_vendor_mp + vendor_num;
    } else {
#line 258
      tmp = (struct sdparm_vendor_pair *)((void *)0);
    }
  } else {
#line 258
    tmp = (struct sdparm_vendor_pair *)((void *)0);
  }
#line 258
  return ((struct sdparm_vendor_pair  const  *)tmp);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
struct sdparm_mode_page_item  const  *sdp_find_mitem_by_acron(char const   *ap , int *from ,
                                                              int transp_proto , int vendor_num ) 
{ 
  int k ;
  struct sdparm_mode_page_item  const  *mpi ;
  struct sdparm_vendor_pair  const  *vpp ;
  int tmp ;

  {
#line 266
  k = 0;
#line 269
  if (from) {
#line 270
    k = *from;
#line 271
    if (k < 0) {
#line 272
      k = 0;
    }
  }
#line 274
  if (vendor_num >= 0) {
    {
#line 277
    vpp = sdp_get_vendor_pair(vendor_num);
    }
#line 278
    if (vpp) {
#line 278
      mpi = (struct sdparm_mode_page_item  const  *)vpp->mitem;
    } else {
#line 278
      mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
    }
  } else
#line 279
  if (transp_proto >= 0) {
#line 279
    if (transp_proto < 16) {
#line 280
      mpi = (struct sdparm_mode_page_item  const  *)sdparm_transport_mp[transp_proto].mitem;
    } else {
#line 282
      mpi = (struct sdparm_mode_page_item  const  *)(sdparm_mitem_arr);
    }
  } else {
#line 282
    mpi = (struct sdparm_mode_page_item  const  *)(sdparm_mitem_arr);
  }
#line 283
  if ((unsigned long )((void *)0) == (unsigned long )mpi) {
#line 284
    return ((struct sdparm_mode_page_item  const  *)((void *)0));
  }
#line 286
  mpi += k;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! mpi->acron) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp = sdp_strcase_eq((char const   *)mpi->acron, ap);
    }
#line 287
    if (tmp) {
#line 288
      goto while_break;
    }
#line 286
    k ++;
#line 286
    mpi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  if ((unsigned long )((void *)0) == (unsigned long )mpi->acron) {
#line 291
    mpi = (struct sdparm_mode_page_item  const  *)((void *)0);
  }
#line 292
  if (from) {
#line 293
    if (mpi) {
#line 293
      *from = k + 1;
    } else {
#line 293
      *from = k;
    }
  }
#line 294
  return (mpi);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
uint64_t sdp_get_big_endian(unsigned char const   *from , int start_bit , int num_bits ) 
{ 
  uint64_t res ;
  int sbit_o1 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 301
  sbit_o1 = start_bit + 1;
#line 303
  tmp = from;
#line 303
  from ++;
#line 303
  res = (uint64_t )((int const   )*tmp & (int const   )((1 << sbit_o1) - 1));
#line 304
  num_bits -= sbit_o1;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (num_bits > 0)) {
#line 305
      goto while_break;
    }
#line 306
    res <<= 8;
#line 307
    tmp___0 = from;
#line 307
    from ++;
#line 307
    res |= (unsigned long )*tmp___0;
#line 308
    num_bits -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  if (num_bits < 0) {
#line 311
    res >>= - num_bits;
  }
#line 312
  return (res);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
void sdp_set_big_endian(uint64_t val , unsigned char *to , int start_bit , int num_bits ) 
{ 
  int sbit_o1 ;
  int mask ;
  int num ;
  int k ;
  int x ;
  int tmp ;

  {
#line 319
  sbit_o1 = start_bit + 1;
#line 322
  if (8 != sbit_o1) {
#line 322
    mask = (1 << sbit_o1) - 1;
  } else {
#line 322
    mask = 255;
  }
#line 323
  k = start_bit - (num_bits - 1) % 8;
#line 324
  if (0 != k) {
#line 325
    if (k > 0) {
#line 325
      tmp = k;
    } else {
#line 325
      tmp = 8 + k;
    }
#line 325
    val <<= tmp;
  }
#line 326
  num = ((num_bits + 15) - sbit_o1) / 8;
#line 327
  k = 0;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (k < num)) {
#line 327
      goto while_break;
    }
#line 328
    if (sbit_o1 - num_bits > 0) {
#line 329
      mask &= ~ ((1 << (sbit_o1 - num_bits)) - 1);
    }
#line 330
    if (k < num - 1) {
#line 331
      x = (int )((val >> ((num - k) - 1) * 8) & 255UL);
    } else {
#line 333
      x = (int )(val & 255UL);
    }
#line 334
    *(to + k) = (unsigned char )(((int )*(to + k) & ~ mask) | (x & mask));
#line 335
    mask = 255;
#line 336
    num_bits -= sbit_o1;
#line 337
    sbit_o1 = 8;
#line 327
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return;
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
uint64_t sdp_mp_get_value(struct sdparm_mode_page_item  const  *mpi , unsigned char const   *mp ) 
{ 
  uint64_t tmp ;

  {
  {
#line 345
  tmp = sdp_get_big_endian(mp + mpi->start_byte, (int )mpi->start_bit, (int )mpi->num_bits);
  }
#line 345
  return (tmp);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
uint64_t sdp_mp_get_value_check(struct sdparm_mode_page_item  const  *mpi , unsigned char const   *mp ,
                                int *all_set ) 
{ 
  uint64_t res ;

  {
  {
#line 355
  res = sdp_get_big_endian(mp + mpi->start_byte, (int )mpi->start_bit, (int )mpi->num_bits);
  }
#line 357
  if (all_set) {
#line 358
    if (16 == (int )mpi->num_bits) {
#line 358
      if (65535UL == res) {
#line 359
        *all_set = 1;
      } else {
#line 358
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 360
    if (32 == (int )mpi->num_bits) {
#line 360
      if (4294967295UL == res) {
#line 361
        *all_set = 1;
      } else {
#line 360
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 362
    if (64 == (int )mpi->num_bits) {
#line 362
      if (0xffffffffffffffffULL == (unsigned long long )res) {
#line 363
        *all_set = 1;
      } else {
#line 365
        *all_set = 0;
      }
    } else {
#line 365
      *all_set = 0;
    }
  }
#line 367
  return (res);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
void sdp_mp_set_value(uint64_t val , struct sdparm_mode_page_item  const  *mpi , unsigned char *mp ) 
{ 


  {
  {
#line 374
  sdp_set_big_endian(val, mp + mpi->start_byte, (int )mpi->start_bit, (int )mpi->num_bits);
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
char *sdp_get_ansi_version_str(int version , int buff_len , char *buff ) 
{ 


  {
  {
#line 381
  version &= 7;
#line 382
  *(buff + (buff_len - 1)) = (char )'\000';
#line 383
  strncpy((char */* __restrict  */)buff, (char const   */* __restrict  */)sdparm_ansi_version_arr[version],
          (size_t )(buff_len - 1));
  }
#line 384
  return (buff);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_access.c"
char *sdp_get_pdt_doc_str(int pdt , int buff_len , char *buff ) 
{ 


  {
#line 390
  if (pdt < -1) {
    {
#line 391
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad pdt");
    }
  } else
#line 390
  if (pdt > 31) {
    {
#line 391
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"bad pdt");
    }
  } else
#line 392
  if (-1 == pdt) {
    {
#line 393
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"SPC-4");
    }
  } else {
    {
#line 395
    snprintf((char */* __restrict  */)buff, (size_t )buff_len, (char const   */* __restrict  */)"%s",
             sdparm_pdt_doc_strs[pdt]);
    }
  }
#line 396
  return (buff);
}
}
#line 20 "../include/sg_cmds_mmc.h"
int sg_ll_get_config(int sg_fd , int rt , int starting , void *resp , int mx_resp_len ,
                     int noisy , int verbose ) ;
#line 27
int sg_ll_get_performance(int sg_fd , int data_type , unsigned int starting_lba ,
                          int max_num_desc , int ttype , void *resp , int mx_resp_len ,
                          int noisy , int verbose ) ;
#line 37
int sg_ll_set_cd_speed(int sg_fd , int rot_control , int drv_read_speed , int drv_write_speed ,
                       int noisy , int verbose ) ;
#line 45
int sg_ll_set_streaming(int sg_fd , int type , void *paramp , int param_len , int noisy ,
                        int verbose ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_mmc.c"
int sg_ll_set_cd_speed(int sg_fd , int rot_control , int drv_read_speed , int drv_write_speed ,
                       int noisy , int verbose ) 
{ 
  int res ;
  int ret ;
  int k ;
  int sense_cat ;
  unsigned char scsCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 49
  scsCmdBlk[0] = (unsigned char)187;
#line 49
  scsCmdBlk[1] = (unsigned char)0;
#line 49
  scsCmdBlk[2] = (unsigned char)0;
#line 49
  scsCmdBlk[3] = (unsigned char)0;
#line 49
  scsCmdBlk[4] = (unsigned char)0;
#line 49
  scsCmdBlk[5] = (unsigned char)0;
#line 49
  scsCmdBlk[6] = (unsigned char)0;
#line 49
  scsCmdBlk[7] = (unsigned char)0;
#line 49
  scsCmdBlk[8] = (unsigned char)0;
#line 49
  scsCmdBlk[9] = (unsigned char)0;
#line 49
  scsCmdBlk[10] = (unsigned char)0;
#line 49
  scsCmdBlk[11] = (unsigned char)0;
#line 54
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 55
    sg_warnings_strm = stderr;
  }
#line 56
  scsCmdBlk[1] = (unsigned char )((int )scsCmdBlk[1] | (rot_control & 3));
#line 57
  scsCmdBlk[2] = (unsigned char )((drv_read_speed >> 8) & 255);
#line 58
  scsCmdBlk[3] = (unsigned char )(drv_read_speed & 255);
#line 59
  scsCmdBlk[4] = (unsigned char )((drv_write_speed >> 8) & 255);
#line 60
  scsCmdBlk[5] = (unsigned char )(drv_write_speed & 255);
#line 62
  if (verbose) {
    {
#line 63
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    set cd speed cdb: ");
#line 64
    k = 0;
    }
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! (k < 12)) {
#line 64
        goto while_break;
      }
      {
#line 65
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )scsCmdBlk[k]);
#line 64
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 66
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 68
  ptvp = construct_scsi_pt_obj();
  }
#line 69
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 70
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"set cd speed: out of memory\n");
    }
#line 71
    return (-1);
  }
  {
#line 73
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(scsCmdBlk), (int )sizeof(scsCmdBlk));
#line 74
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 75
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 76
  ret = sg_cmds_process_resp(ptvp, "set cd speed", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 78
  if (! (-1 == ret)) {
#line 80
    if (-2 == ret) {
      {
#line 86
      if (sense_cat == 11) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 5) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 9) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 6) {
#line 86
        goto case_11;
      }
#line 86
      if (sense_cat == 2) {
#line 86
        goto case_11;
      }
#line 90
      if (sense_cat == 20) {
#line 90
        goto case_20;
      }
#line 90
      if (sense_cat == 21) {
#line 90
        goto case_20;
      }
#line 93
      goto switch_default;
      case_11: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 87
      ret = sense_cat;
#line 88
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 91
      ret = 0;
#line 92
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 94
      ret = -1;
#line 95
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 98
      ret = 0;
    }
  }
  {
#line 100
  destruct_scsi_pt_obj(ptvp);
  }
#line 101
  return (ret);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_mmc.c"
int sg_ll_get_config(int sg_fd , int rt , int starting , void *resp , int mx_resp_len ,
                     int noisy , int verbose ) 
{ 
  int res ;
  int k ;
  int ret ;
  int sense_cat ;
  unsigned char gcCmdBlk[10] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  unsigned char *ucp ;
  int len ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 113
  gcCmdBlk[0] = (unsigned char)70;
#line 113
  gcCmdBlk[1] = (unsigned char)0;
#line 113
  gcCmdBlk[2] = (unsigned char)0;
#line 113
  gcCmdBlk[3] = (unsigned char)0;
#line 113
  gcCmdBlk[4] = (unsigned char)0;
#line 113
  gcCmdBlk[5] = (unsigned char)0;
#line 113
  gcCmdBlk[6] = (unsigned char)0;
#line 113
  gcCmdBlk[7] = (unsigned char)0;
#line 113
  gcCmdBlk[8] = (unsigned char)0;
#line 113
  gcCmdBlk[9] = (unsigned char)0;
#line 118
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 119
    sg_warnings_strm = stderr;
  }
#line 120
  if (rt < 0) {
    {
#line 121
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad rt value: %d\n",
            rt);
    }
#line 122
    return (-1);
  } else
#line 120
  if (rt > 3) {
    {
#line 121
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad rt value: %d\n",
            rt);
    }
#line 122
    return (-1);
  }
#line 124
  gcCmdBlk[1] = (unsigned char )(rt & 3);
#line 125
  if (starting < 0) {
    {
#line 126
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad starting field number: 0x%x\n",
            starting);
    }
#line 128
    return (-1);
  } else
#line 125
  if (starting > 65535) {
    {
#line 126
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad starting field number: 0x%x\n",
            starting);
    }
#line 128
    return (-1);
  }
#line 130
  gcCmdBlk[2] = (unsigned char )((starting >> 8) & 255);
#line 131
  gcCmdBlk[3] = (unsigned char )(starting & 255);
#line 132
  if (mx_resp_len < 0) {
    {
#line 133
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad mx_resp_len: 0x%x\n",
            starting);
    }
#line 134
    return (-1);
  } else
#line 132
  if (mx_resp_len > 65535) {
    {
#line 133
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad mx_resp_len: 0x%x\n",
            starting);
    }
#line 134
    return (-1);
  }
#line 136
  gcCmdBlk[7] = (unsigned char )((mx_resp_len >> 8) & 255);
#line 137
  gcCmdBlk[8] = (unsigned char )(mx_resp_len & 255);
#line 139
  if (verbose) {
    {
#line 140
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Get Configuration cdb: ");
#line 141
    k = 0;
    }
    {
#line 141
    while (1) {
      while_continue: /* CIL Label */ ;
#line 141
      if (! (k < 10)) {
#line 141
        goto while_break;
      }
      {
#line 142
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )gcCmdBlk[k]);
#line 141
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 143
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 146
  ptvp = construct_scsi_pt_obj();
  }
#line 147
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 148
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"get configuration: out of memory\n");
    }
#line 149
    return (-1);
  }
  {
#line 151
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(gcCmdBlk), (int )sizeof(gcCmdBlk));
#line 152
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 153
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 154
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 155
  ret = sg_cmds_process_resp(ptvp, "get configuration", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 157
  if (! (-1 == ret)) {
#line 159
    if (-2 == ret) {
      {
#line 164
      if (sense_cat == 11) {
#line 164
        goto case_11;
      }
#line 164
      if (sense_cat == 6) {
#line 164
        goto case_11;
      }
#line 164
      if (sense_cat == 5) {
#line 164
        goto case_11;
      }
#line 164
      if (sense_cat == 9) {
#line 164
        goto case_11;
      }
#line 168
      if (sense_cat == 20) {
#line 168
        goto case_20;
      }
#line 168
      if (sense_cat == 21) {
#line 168
        goto case_20;
      }
#line 171
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 165
      ret = sense_cat;
#line 166
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 169
      ret = 0;
#line 170
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 172
      ret = -1;
#line 173
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 176
      if (verbose > 2) {
#line 176
        if (ret > 3) {
#line 180
          ucp = (unsigned char *)resp;
#line 181
          len = (((((int )*(ucp + 0) << 24) + ((int )*(ucp + 1) << 16)) + ((int )*(ucp + 2) << 8)) + (int )*(ucp + 3)) + 4;
#line 183
          if (len < 0) {
#line 184
            len = 0;
          }
#line 185
          if (ret < len) {
#line 185
            len = ret;
          } else {
#line 185
            len = len;
          }
#line 186
          if (len > 256) {
#line 186
            tmp = ", first 256 bytes";
          } else {
#line 186
            tmp = "";
          }
          {
#line 186
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    get configuration: response%s\n",
                  tmp);
          }
#line 188
          if (len > 256) {
#line 188
            tmp___0 = 256;
          } else {
#line 188
            tmp___0 = len;
          }
          {
#line 188
          dStrHex((char const   *)resp, tmp___0, -1);
          }
        }
      }
#line 190
      ret = 0;
    }
  }
  {
#line 192
  destruct_scsi_pt_obj(ptvp);
  }
#line 193
  return (ret);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_mmc.c"
int sg_ll_get_performance(int sg_fd , int data_type , unsigned int starting_lba ,
                          int max_num_desc , int ttype , void *resp , int mx_resp_len ,
                          int noisy , int verbose ) 
{ 
  int res ;
  int k ;
  int ret ;
  int sense_cat ;
  unsigned char gpCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;
  unsigned char *ucp ;
  int len ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 206
  gpCmdBlk[0] = (unsigned char)172;
#line 206
  gpCmdBlk[1] = (unsigned char)0;
#line 206
  gpCmdBlk[2] = (unsigned char)0;
#line 206
  gpCmdBlk[3] = (unsigned char)0;
#line 206
  gpCmdBlk[4] = (unsigned char)0;
#line 206
  gpCmdBlk[5] = (unsigned char)0;
#line 206
  gpCmdBlk[6] = (unsigned char)0;
#line 206
  gpCmdBlk[7] = (unsigned char)0;
#line 206
  gpCmdBlk[8] = (unsigned char)0;
#line 206
  gpCmdBlk[9] = (unsigned char)0;
#line 206
  gpCmdBlk[10] = (unsigned char)0;
#line 206
  gpCmdBlk[11] = (unsigned char)0;
#line 211
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 212
    sg_warnings_strm = stderr;
  }
#line 213
  if (data_type < 0) {
    {
#line 214
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad data_type value: %d\n",
            data_type);
    }
#line 215
    return (-1);
  } else
#line 213
  if (data_type > 31) {
    {
#line 214
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad data_type value: %d\n",
            data_type);
    }
#line 215
    return (-1);
  }
#line 217
  gpCmdBlk[1] = (unsigned char )(data_type & 31);
#line 218
  gpCmdBlk[2] = (unsigned char )((starting_lba >> 24) & 255U);
#line 219
  gpCmdBlk[3] = (unsigned char )((starting_lba >> 16) & 255U);
#line 220
  gpCmdBlk[4] = (unsigned char )((starting_lba >> 8) & 255U);
#line 221
  gpCmdBlk[3] = (unsigned char )(starting_lba & 255U);
#line 222
  if (max_num_desc < 0) {
    {
#line 223
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad max_num_desc: 0x%x\n",
            max_num_desc);
    }
#line 224
    return (-1);
  } else
#line 222
  if (max_num_desc > 65535) {
    {
#line 223
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad max_num_desc: 0x%x\n",
            max_num_desc);
    }
#line 224
    return (-1);
  }
#line 226
  gpCmdBlk[8] = (unsigned char )((max_num_desc >> 8) & 255);
#line 227
  gpCmdBlk[9] = (unsigned char )(max_num_desc & 255);
#line 228
  if (ttype < 0) {
    {
#line 229
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad type: 0x%x\n",
            ttype);
    }
#line 230
    return (-1);
  } else
#line 228
  if (ttype > 255) {
    {
#line 229
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"Bad type: 0x%x\n",
            ttype);
    }
#line 230
    return (-1);
  }
#line 232
  gpCmdBlk[10] = (unsigned char )ttype;
#line 234
  if (verbose) {
    {
#line 235
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    Get Performance cdb: ");
#line 236
    k = 0;
    }
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (k < 12)) {
#line 236
        goto while_break;
      }
      {
#line 237
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )gpCmdBlk[k]);
#line 236
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 238
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 241
  ptvp = construct_scsi_pt_obj();
  }
#line 242
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 243
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"get performance: out of memory\n");
    }
#line 244
    return (-1);
  }
  {
#line 246
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(gpCmdBlk), (int )sizeof(gpCmdBlk));
#line 247
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 248
  set_scsi_pt_data_in(ptvp, (unsigned char *)resp, mx_resp_len);
#line 249
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 250
  ret = sg_cmds_process_resp(ptvp, "get performance", res, mx_resp_len, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 252
  if (! (-1 == ret)) {
#line 254
    if (-2 == ret) {
      {
#line 259
      if (sense_cat == 11) {
#line 259
        goto case_11;
      }
#line 259
      if (sense_cat == 6) {
#line 259
        goto case_11;
      }
#line 259
      if (sense_cat == 5) {
#line 259
        goto case_11;
      }
#line 259
      if (sense_cat == 9) {
#line 259
        goto case_11;
      }
#line 263
      if (sense_cat == 20) {
#line 263
        goto case_20;
      }
#line 263
      if (sense_cat == 21) {
#line 263
        goto case_20;
      }
#line 266
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
#line 260
      ret = sense_cat;
#line 261
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 264
      ret = 0;
#line 265
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 267
      ret = -1;
#line 268
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 271
      if (verbose > 2) {
#line 271
        if (ret > 3) {
#line 275
          ucp = (unsigned char *)resp;
#line 276
          len = (((((int )*(ucp + 0) << 24) + ((int )*(ucp + 1) << 16)) + ((int )*(ucp + 2) << 8)) + (int )*(ucp + 3)) + 4;
#line 278
          if (len < 0) {
#line 279
            len = 0;
          }
#line 280
          if (ret < len) {
#line 280
            len = ret;
          } else {
#line 280
            len = len;
          }
#line 281
          if (len > 256) {
#line 281
            tmp = ", first 256 bytes";
          } else {
#line 281
            tmp = "";
          }
          {
#line 281
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    get performance:: response%s\n",
                  tmp);
          }
#line 283
          if (len > 256) {
#line 283
            tmp___0 = 256;
          } else {
#line 283
            tmp___0 = len;
          }
          {
#line 283
          dStrHex((char const   *)resp, tmp___0, -1);
          }
        }
      }
#line 285
      ret = 0;
    }
  }
  {
#line 287
  destruct_scsi_pt_obj(ptvp);
  }
#line 288
  return (ret);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/../lib/sg_cmds_mmc.c"
int sg_ll_set_streaming(int sg_fd , int type , void *paramp , int param_len , int noisy ,
                        int verbose ) 
{ 
  int k ;
  int res ;
  int ret ;
  int sense_cat ;
  unsigned char ssCmdBlk[12] ;
  unsigned char sense_b[32] ;
  struct sg_pt_base *ptvp ;

  {
#line 301
  ssCmdBlk[0] = (unsigned char)182;
#line 301
  ssCmdBlk[1] = (unsigned char)0;
#line 301
  ssCmdBlk[2] = (unsigned char)0;
#line 301
  ssCmdBlk[3] = (unsigned char)0;
#line 301
  ssCmdBlk[4] = (unsigned char)0;
#line 301
  ssCmdBlk[5] = (unsigned char)0;
#line 301
  ssCmdBlk[6] = (unsigned char)0;
#line 301
  ssCmdBlk[7] = (unsigned char)0;
#line 301
  ssCmdBlk[8] = (unsigned char)0;
#line 301
  ssCmdBlk[9] = (unsigned char)0;
#line 301
  ssCmdBlk[10] = (unsigned char)0;
#line 301
  ssCmdBlk[11] = (unsigned char)0;
#line 306
  ssCmdBlk[8] = (unsigned char )type;
#line 307
  ssCmdBlk[9] = (unsigned char )((param_len >> 8) & 255);
#line 308
  ssCmdBlk[10] = (unsigned char )(param_len & 255);
#line 309
  if ((unsigned long )((void *)0) == (unsigned long )sg_warnings_strm) {
#line 310
    sg_warnings_strm = stderr;
  }
#line 311
  if (verbose) {
    {
#line 312
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    set streaming cdb: ");
#line 313
    k = 0;
    }
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! (k < 12)) {
#line 313
        goto while_break;
      }
      {
#line 314
      fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"%02x ",
              (int )ssCmdBlk[k]);
#line 313
      k ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 315
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"\n");
    }
#line 316
    if (verbose > 1) {
#line 316
      if (paramp) {
#line 316
        if (param_len) {
          {
#line 317
          fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"    set streaming parameter list:\n");
#line 319
          dStrHex((char const   *)paramp, param_len, -1);
          }
        }
      }
    }
  }
  {
#line 323
  ptvp = construct_scsi_pt_obj();
  }
#line 324
  if ((unsigned long )((void *)0) == (unsigned long )ptvp) {
    {
#line 325
    fprintf((FILE */* __restrict  */)sg_warnings_strm, (char const   */* __restrict  */)"set streaming: out of memory\n");
    }
#line 326
    return (-1);
  }
  {
#line 328
  set_scsi_pt_cdb(ptvp, (unsigned char const   *)(ssCmdBlk), (int )sizeof(ssCmdBlk));
#line 329
  set_scsi_pt_sense(ptvp, sense_b, (int )sizeof(sense_b));
#line 330
  set_scsi_pt_data_out(ptvp, (unsigned char const   *)((unsigned char *)paramp), param_len);
#line 331
  res = do_scsi_pt(ptvp, sg_fd, 60, verbose);
#line 332
  ret = sg_cmds_process_resp(ptvp, "set streaming", res, 0, (unsigned char const   *)(sense_b),
                             noisy, verbose, & sense_cat);
  }
#line 334
  if (! (-1 == ret)) {
#line 336
    if (-2 == ret) {
      {
#line 342
      if (sense_cat == 11) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 6) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 5) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 9) {
#line 342
        goto case_11;
      }
#line 342
      if (sense_cat == 2) {
#line 342
        goto case_11;
      }
#line 346
      if (sense_cat == 20) {
#line 346
        goto case_20;
      }
#line 346
      if (sense_cat == 21) {
#line 346
        goto case_20;
      }
#line 349
      goto switch_default;
      case_11: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 343
      ret = sense_cat;
#line 344
      goto switch_break;
      case_20: /* CIL Label */ 
      case_21: /* CIL Label */ 
#line 347
      ret = 0;
#line 348
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 350
      ret = -1;
#line 351
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 354
      ret = 0;
    }
  }
  {
#line 355
  destruct_scsi_pt_obj(ptvp);
  }
#line 356
  return (ret);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static int do_cmd_read_capacity(int sg_fd , int verbose ) 
{ 
  int res ;
  int k ;
  int do16 ;
  unsigned int last_blk_addr ;
  unsigned int block_size ;
  unsigned char resp_buff[32] ;
  uint64_t llast_blk_addr ;
  double sz_mib ;

  {
  {
#line 60
  do16 = 0;
#line 61
  res = sg_ll_readcap_10(sg_fd, 0, 0U, (void *)(resp_buff), 8, 1, verbose);
  }
#line 63
  if (0 == res) {
#line 64
    last_blk_addr = ((((unsigned int )resp_buff[0] << 24) | (unsigned int )((int )resp_buff[1] << 16)) | (unsigned int )((int )resp_buff[2] << 8)) | (unsigned int )resp_buff[3];
#line 67
    if (4294967295U != last_blk_addr) {
      {
#line 68
      block_size = ((((unsigned int )resp_buff[4] << 24) | (unsigned int )((int )resp_buff[5] << 16)) | (unsigned int )((int )resp_buff[6] << 8)) | (unsigned int )resp_buff[7];
#line 71
      printf((char const   */* __restrict  */)"blocks: %u\n", last_blk_addr + 1U);
#line 72
      printf((char const   */* __restrict  */)"block_length: %u\n", block_size);
#line 73
      sz_mib = ((double )(last_blk_addr + 1U) * (double )block_size) / (double )1048576;
#line 78
      printf((char const   */* __restrict  */)"capacity_mib: %.1f\n", sz_mib);
      }
    } else {
#line 81
      do16 = 1;
    }
  } else {
#line 83
    return (res);
  }
#line 84
  if (do16) {
    {
#line 86
    res = sg_ll_readcap_16(sg_fd, 0, (uint64_t )0, (void *)(resp_buff), 32, 1, verbose);
    }
#line 88
    if (0 == res) {
#line 89
      k = 0;
#line 89
      llast_blk_addr = (uint64_t )0;
      {
#line 89
      while (1) {
        while_continue: /* CIL Label */ ;
#line 89
        if (! (k < 8)) {
#line 89
          goto while_break;
        }
#line 90
        llast_blk_addr <<= 8;
#line 91
        llast_blk_addr |= (unsigned long )resp_buff[k];
#line 89
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 93
      block_size = ((((unsigned int )resp_buff[8] << 24) | (unsigned int )((int )resp_buff[9] << 16)) | (unsigned int )((int )resp_buff[10] << 8)) | (unsigned int )resp_buff[11];
#line 96
      printf((char const   */* __restrict  */)"blocks: %lu\n", llast_blk_addr + 1UL);
#line 97
      printf((char const   */* __restrict  */)"block_length: %u\n", block_size);
#line 98
      sz_mib = ((double )(llast_blk_addr + 1UL) * (double )block_size) / (double )1048576;
#line 103
      printf((char const   */* __restrict  */)"capacity_mib: %.1f\n", sz_mib);
      }
    } else {
#line 106
      return (res);
    }
  }
#line 108
  return (0);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static int do_cmd_sense(int sg_fd , int hex , int quiet , int verbose ) 
{ 
  int res ;
  int resp_len ;
  int sk ;
  int asc ;
  int ascq ;
  int progress ;
  int something ;
  unsigned char buff[32] ;
  char b[128] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 118
  memset((void *)(buff), 0, sizeof(buff));
#line 119
  res = sg_ll_request_sense(sg_fd, 0, (void *)(buff), (int )sizeof(buff), 1, verbose);
  }
#line 121
  if (0 == res) {
#line 122
    resp_len = (int )buff[7] + 8;
#line 123
    if (resp_len > (int )sizeof(buff)) {
#line 124
      resp_len = (int )sizeof(buff);
    }
#line 125
    sk = 15 & (int )buff[2];
#line 126
    if (hex) {
      {
#line 127
      dStrHex((char const   *)(buff), resp_len, 1);
      }
#line 128
      return (0);
    }
#line 130
    something = 0;
#line 131
    if (verbose) {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decode response as sense data:\n");
#line 133
      sg_print_sense((char const   *)((void *)0), (unsigned char const   *)(buff),
                     resp_len, 0);
      }
#line 134
      if (verbose > 1) {
        {
#line 135
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nOutput response in hex\n");
#line 136
        dStrHex((char const   *)(buff), resp_len, 1);
        }
      }
#line 138
      something = 1;
    }
#line 140
    if (resp_len > 12) {
#line 140
      asc = (int )buff[12];
    } else {
#line 140
      asc = 0;
    }
#line 141
    if (resp_len > 13) {
#line 141
      ascq = (int )buff[13];
    } else {
#line 141
      ascq = 0;
    }
    {
#line 142
    tmp = sg_get_sense_progress_fld((unsigned char const   *)(buff), resp_len, & progress);
    }
#line 142
    if (tmp) {
      {
#line 143
      printf((char const   */* __restrict  */)"Operation in progress, %d%% done\n",
             (progress * 100) / 65536);
#line 145
      something = 1;
      }
    }
#line 147
    if (0 == sk) {
#line 149
      if (11 == asc) {
        {
#line 150
        tmp___0 = sg_get_asc_ascq_str(asc, ascq, (int )sizeof(b), b);
#line 150
        printf((char const   */* __restrict  */)"%s\n", tmp___0);
        }
      } else
#line 149
      if (93 == asc) {
        {
#line 150
        tmp___0 = sg_get_asc_ascq_str(asc, ascq, (int )sizeof(b), b);
#line 150
        printf((char const   */* __restrict  */)"%s\n", tmp___0);
        }
      }
#line 153
      if (94 == asc) {
        {
#line 154
        tmp___1 = sg_get_asc_ascq_str(asc, ascq, (int )sizeof(b), b);
#line 154
        printf((char const   */* __restrict  */)"%s\n", tmp___1);
        }
      }
#line 156
      return (0);
    } else {
#line 158
      if (! something) {
#line 158
        if (! verbose) {
#line 158
          if (! quiet) {
            {
#line 159
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Decode response as sense data:\n");
#line 160
            sg_print_sense((char const   *)((void *)0), (unsigned char const   *)(buff),
                           resp_len, 0);
            }
          }
        }
      }
#line 162
      return (0);
    }
  } else
#line 164
  if (9 == res) {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Request Sense command not supported\n");
    }
  } else
#line 166
  if (5 == res) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad field in Request Sense cdb\n");
    }
  } else
#line 168
  if (2 == res) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Request Sense failed, device not ready\n");
    }
  } else
#line 170
  if (11 == res) {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Request Sense failed, aborted command\n");
    }
  } else {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Request Sense command failed\n");
    }
#line 174
    if (0 == verbose) {
      {
#line 175
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    try the \'-v\' option for more information\n");
      }
    }
  }
#line 178
  return (res);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static int do_cmd_speed(int sg_fd , int cmd_arg , struct sdparm_opt_coll  const  *opts ) 
{ 
  int res ;
  unsigned int u ;
  unsigned int last_lba ;
  unsigned int rw_time ;
  unsigned char perf_desc[28] ;
  int max_num_desc ;
  unsigned char buff[264] ;
  unsigned int lba ;

  {
#line 187
  last_lba = 4294967294U;
#line 188
  rw_time = 1000U;
#line 190
  if (cmd_arg >= 0) {
    {
#line 202
    memset((void *)(perf_desc), 0, sizeof(perf_desc));
    }
#line 203
    if (0 == cmd_arg) {
#line 204
      perf_desc[0] = (unsigned char )((int )perf_desc[0] | 4);
    } else {
#line 206
      perf_desc[8] = (unsigned char )((last_lba >> 24) & 255U);
#line 207
      perf_desc[9] = (unsigned char )((last_lba >> 16) & 255U);
#line 208
      perf_desc[10] = (unsigned char )((last_lba >> 8) & 255U);
#line 209
      perf_desc[11] = (unsigned char )(last_lba & 255U);
#line 210
      perf_desc[12] = (unsigned char )((cmd_arg >> 24) & 255);
#line 211
      perf_desc[13] = (unsigned char )((cmd_arg >> 16) & 255);
#line 212
      perf_desc[14] = (unsigned char )((cmd_arg >> 8) & 255);
#line 213
      perf_desc[15] = (unsigned char )(cmd_arg & 255);
#line 214
      perf_desc[16] = (unsigned char )((rw_time >> 24) & 255U);
#line 215
      perf_desc[17] = (unsigned char )((rw_time >> 16) & 255U);
#line 216
      perf_desc[18] = (unsigned char )((rw_time >> 8) & 255U);
#line 217
      perf_desc[19] = (unsigned char )(rw_time & 255U);
#line 218
      perf_desc[20] = (unsigned char )((cmd_arg >> 24) & 255);
#line 219
      perf_desc[21] = (unsigned char )((cmd_arg >> 16) & 255);
#line 220
      perf_desc[22] = (unsigned char )((cmd_arg >> 8) & 255);
#line 221
      perf_desc[23] = (unsigned char )(cmd_arg & 255);
#line 222
      perf_desc[24] = (unsigned char )((rw_time >> 24) & 255U);
#line 223
      perf_desc[25] = (unsigned char )((rw_time >> 16) & 255U);
#line 224
      perf_desc[26] = (unsigned char )((rw_time >> 8) & 255U);
#line 225
      perf_desc[27] = (unsigned char )(rw_time & 255U);
    }
    {
#line 228
    res = sg_ll_set_streaming(sg_fd, 0, (void *)(perf_desc), (int )sizeof(perf_desc),
                              1, (int )opts->verbose);
    }
#line 230
    if (res) {
#line 231
      if (2 == res) {
        {
#line 232
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Set Streaming failed, device not ready\n");
        }
      } else {
        {
#line 234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Set Streaming failed, add \'-v\' for more information\n");
        }
      }
    }
  } else {
    {
#line 238
    max_num_desc = 16;
#line 243
    res = sg_ll_get_performance(sg_fd, 16, 0U, max_num_desc, 0, (void *)(buff), (int )sizeof(buff),
                                1, (int )opts->verbose);
    }
#line 248
    if (0 == res) {
#line 249
      if (opts->verbose) {
        {
#line 250
        lba = ((((unsigned int )buff[8] << 24) + (unsigned int )((int )buff[9] << 16)) + (unsigned int )((int )buff[10] << 8)) + (unsigned int )buff[11];
#line 252
        printf((char const   */* __restrict  */)"starting LBA: %u\n", lba);
        }
      }
#line 254
      u = ((((unsigned int )buff[12] << 24) + (unsigned int )((int )buff[13] << 16)) + (unsigned int )((int )buff[14] << 8)) + (unsigned int )buff[15];
#line 256
      if (opts->quiet) {
        {
#line 257
        printf((char const   */* __restrict  */)"%u\n", u);
        }
      } else {
        {
#line 259
        printf((char const   */* __restrict  */)"Nominal speed at starting LBA: %u kiloBytes/sec\n",
               u);
        }
      }
#line 261
      if (opts->verbose) {
        {
#line 262
        lba = ((((unsigned int )buff[16] << 24) + (unsigned int )((int )buff[17] << 16)) + (unsigned int )((int )buff[18] << 8)) + (unsigned int )buff[19];
#line 264
        printf((char const   */* __restrict  */)"ending LBA: %u\n", lba);
        }
      }
#line 266
      u = ((((unsigned int )buff[20] << 24) + (unsigned int )((int )buff[21] << 16)) + (unsigned int )((int )buff[22] << 8)) + (unsigned int )buff[23];
#line 268
      if (1 == (int )opts->quiet) {
        {
#line 269
        printf((char const   */* __restrict  */)"%u\n", u);
        }
      } else
#line 270
      if (0 == (int )opts->quiet) {
        {
#line 271
        printf((char const   */* __restrict  */)"Nominal speed at ending LBA: %u kiloBytes/sec\n",
               u);
        }
      }
    }
  }
#line 275
  return (res);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static char const   *get_profile_str(int profile_num , char *buff ) 
{ 
  struct sdparm_val_desc_t  const  *pdp ;

  {
#line 284
  pdp = (struct sdparm_val_desc_t  const  *)(sdparm_profile_arr);
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! pdp->desc) {
#line 284
      goto while_break;
    }
#line 285
    if (pdp->val == (int const   )profile_num) {
      {
#line 286
      strcpy((char */* __restrict  */)buff, (char const   */* __restrict  */)pdp->desc);
      }
#line 287
      return ((char const   *)buff);
    }
#line 284
    pdp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 290
  snprintf((char */* __restrict  */)buff, (size_t )64, (char const   */* __restrict  */)"0x%x",
           profile_num);
  }
#line 291
  return ((char const   *)buff);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static void decode_get_config_feature(int feature , unsigned char *ucp , int len ) 
{ 
  int k ;
  int profile ;
  char buff[128] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 301
  if (feature == 0) {
#line 301
    goto case_0;
  }
#line 310
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 302
  printf((char const   */* __restrict  */)"Available profiles, profile of current media marked with * \n");
#line 304
  k = 4;
  }
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (k < len)) {
#line 304
      goto while_break;
    }
#line 305
    profile = ((int )*(ucp + k) << 8) + (int )*(ucp + (k + 1));
#line 306
    if ((int )*(ucp + (k + 2)) & 1) {
#line 306
      tmp = "*";
    } else {
#line 306
      tmp = "";
    }
    {
#line 306
    tmp___0 = get_profile_str(profile, buff);
#line 306
    printf((char const   */* __restrict  */)"    %s   %s\n", tmp___0, tmp);
#line 304
    k += 4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 312
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static void decode_get_config(unsigned char *resp , int max_resp_len , int len ) 
{ 
  int k ;
  int extra ;
  int feature ;
  unsigned char *ucp ;

  {
#line 323
  if (max_resp_len < len) {
    {
#line 324
    printf((char const   */* __restrict  */)"get_config: response to long for buffer, resp_len=%d>>>\n",
           len);
#line 326
    len = max_resp_len;
    }
  }
#line 328
  if (len < 8) {
    {
#line 329
    printf((char const   */* __restrict  */)"get_config: response length too short: %d\n",
           len);
    }
#line 330
    return;
  }
#line 332
  ucp = resp + 8;
#line 333
  len -= 8;
#line 334
  k = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! (k < len)) {
#line 334
      goto while_break;
    }
#line 335
    extra = 4 + (int )*(ucp + 3);
#line 336
    feature = ((int )*(ucp + 0) << 8) + (int )*(ucp + 1);
#line 337
    if (0 != extra % 4) {
      {
#line 338
      printf((char const   */* __restrict  */)"    get_config: additional length [%d] not a multiple of 4, ignore\n",
             extra - 4);
      }
    } else {
      {
#line 341
      decode_get_config_feature(feature, ucp, extra);
      }
    }
#line 334
    k += extra;
#line 334
    ucp += extra;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
static int do_cmd_profile(int sg_fd , struct sdparm_opt_coll  const  *opts ) 
{ 
  int res ;
  int len ;
  unsigned char resp[2048] ;

  {
  {
#line 354
  res = sg_ll_get_config(sg_fd, 0, 0, (void *)(resp), (int )sizeof(resp), 1, (int )opts->verbose);
  }
#line 356
  if (0 == res) {
    {
#line 357
    len = (int )((((((unsigned int )resp[0] << 24) + (unsigned int )((int )resp[1] << 16)) + (unsigned int )((int )resp[2] << 8)) + (unsigned int )resp[3]) + 4U);
#line 359
    decode_get_config(resp, (int )sizeof(resp), len);
    }
  }
#line 361
  return (res);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
struct sdparm_command_t  const  *sdp_build_cmd(char const   *cmd_str , int *rwp ,
                                               int *argp ) 
{ 
  struct sdparm_command_t  const  *scmdp ;
  char const   *eq_cp ;
  char const   *cp ;
  char buff[16] ;
  int len ;
  int arg ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 372
  arg = -1;
#line 374
  tmp = strchr(cmd_str, '=');
#line 374
  eq_cp = (char const   *)tmp;
  }
#line 375
  if (eq_cp) {
#line 376
    len = (int )(eq_cp - cmd_str);
#line 377
    if (len >= (int )sizeof(buff)) {
#line 378
      return ((struct sdparm_command_t  const  *)((void *)0));
    }
    {
#line 379
    strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)cmd_str,
            (size_t )len);
#line 380
    buff[len] = (char )'\000';
#line 381
    tmp___0 = sscanf((char const   */* __restrict  */)(eq_cp + 1), (char const   */* __restrict  */)"%d",
                     & arg);
    }
#line 381
    if (1 != tmp___0) {
#line 382
      return ((struct sdparm_command_t  const  *)((void *)0));
    }
#line 383
    cp = (char const   *)(buff);
  } else {
#line 385
    cp = cmd_str;
  }
#line 386
  if (argp) {
#line 387
    *argp = arg;
  }
#line 389
  scmdp = (struct sdparm_command_t  const  *)(sdparm_command_arr);
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! scmdp->name) {
#line 389
      goto while_break;
    }
    {
#line 390
    tmp___1 = sdp_strcase_eq((char const   *)scmdp->name, cp);
    }
#line 390
    if (tmp___1) {
#line 391
      goto while_break;
    }
#line 389
    scmdp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if ((unsigned long )((void *)0) == (unsigned long )scmdp->name) {
    {
#line 393
    tmp___4 = strlen(cp);
    }
#line 393
    if (tmp___4 >= 2UL) {
#line 394
      scmdp = (struct sdparm_command_t  const  *)(sdparm_command_arr);
      {
#line 394
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 394
        if (! scmdp->name) {
#line 394
          goto while_break___0;
        }
        {
#line 395
        tmp___2 = strlen((char const   *)scmdp->min_abbrev);
#line 395
        len = (int )tmp___2;
#line 396
        tmp___3 = memcmp((void const   *)scmdp->min_abbrev, (void const   *)cp, (size_t )2);
        }
#line 396
        if (0 == tmp___3) {
#line 397
          goto while_break___0;
        }
#line 394
        scmdp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 400
  if (scmdp->name) {
#line 401
    if (rwp) {
#line 402
      if (1 == (int )scmdp->cmd_num) {
#line 405
        *rwp = 0;
      } else
#line 402
      if (7 == (int )scmdp->cmd_num) {
#line 405
        *rwp = 0;
      } else
#line 402
      if (9 == (int )scmdp->cmd_num) {
#line 405
        *rwp = 0;
      } else {
#line 407
        *rwp = 1;
      }
    }
#line 409
    return (scmdp);
  } else {
#line 411
    return ((struct sdparm_command_t  const  *)((void *)0));
  }
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
void sdp_enumerate_commands(void) 
{ 
  struct sdparm_command_t  const  *scmdp ;

  {
#line 419
  scmdp = (struct sdparm_command_t  const  *)(sdparm_command_arr);
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! scmdp->name) {
#line 419
      goto while_break;
    }
#line 420
    if (scmdp->extra_arg) {
      {
#line 421
      printf((char const   */* __restrict  */)"  %s[=%s]\n", scmdp->name, scmdp->extra_arg);
      }
    } else {
      {
#line 423
      printf((char const   */* __restrict  */)"  %s\n", scmdp->name);
      }
    }
#line 419
    scmdp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/sdparm-1.07/src/sdparm_cmd.c"
int sdp_process_cmd(int sg_fd , struct sdparm_command_t  const  *scmdp , int cmd_arg ,
                    int pdt , struct sdparm_opt_coll  const  *opts ) 
{ 
  int res ;
  int progress ;

  {
#line 434
  if (! opts->flexible) {
#line 434
    if (! (1 == (int )scmdp->cmd_num)) {
#line 434
      if (! (7 == (int )scmdp->cmd_num)) {
#line 434
        if (! (0 == pdt)) {
#line 434
          if (! (5 == pdt)) {
            {
#line 438
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"this command only valid on a disk or cd/dvd; use \'--flexible\' to override\n");
            }
#line 440
            return (1);
          }
        }
      }
    }
  }
  {
#line 444
  if (scmdp->cmd_num == 9) {
#line 444
    goto case_9;
  }
#line 447
  if (scmdp->cmd_num == 5) {
#line 447
    goto case_5;
  }
#line 453
  if (scmdp->cmd_num == 4) {
#line 453
    goto case_4;
  }
#line 456
  if (scmdp->cmd_num == 11) {
#line 456
    goto case_11;
  }
#line 459
  if (scmdp->cmd_num == 1) {
#line 459
    goto case_1;
  }
#line 473
  if (scmdp->cmd_num == 7) {
#line 473
    goto case_7;
  }
#line 476
  if (scmdp->cmd_num == 10) {
#line 476
    goto case_10;
  }
#line 479
  if (scmdp->cmd_num == 2) {
#line 479
    goto case_2;
  }
#line 482
  if (scmdp->cmd_num == 3) {
#line 482
    goto case_3;
  }
#line 485
  if (scmdp->cmd_num == 8) {
#line 485
    goto case_8;
  }
#line 488
  if (scmdp->cmd_num == 6) {
#line 488
    goto case_6;
  }
#line 491
  goto switch_default;
  case_9: /* CIL Label */ 
  {
#line 445
  res = do_cmd_read_capacity(sg_fd, (int )opts->verbose);
  }
#line 446
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 448
  res = sg_ll_start_stop_unit(sg_fd, 0, 0, 0, 0, 1, 0, 1, (int )opts->verbose);
  }
#line 452
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 454
  res = sg_ll_start_stop_unit(sg_fd, 0, 0, 0, 0, 1, 1, 1, (int )opts->verbose);
  }
#line 455
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 457
  res = do_cmd_profile(sg_fd, opts);
  }
#line 458
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 460
  progress = -1;
#line 461
  res = sg_ll_test_unit_ready_progress(sg_fd, 0, & progress, 0, (int )opts->verbose);
  }
#line 463
  if (0 == res) {
    {
#line 464
    printf((char const   */* __restrict  */)"Ready\n");
    }
  } else
#line 466
  if (progress >= 0) {
    {
#line 467
    printf((char const   */* __restrict  */)"Not ready, progress indication: %d%% done\n",
           (progress * 100) / 65536);
    }
  } else {
    {
#line 470
    printf((char const   */* __restrict  */)"Not ready\n");
    }
  }
#line 472
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 474
  res = do_cmd_sense(sg_fd, (int )opts->hex, (int )opts->quiet, (int )opts->verbose);
  }
#line 475
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 477
  res = do_cmd_speed(sg_fd, cmd_arg, opts);
  }
#line 478
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 480
  res = sg_ll_start_stop_unit(sg_fd, 0, 0, 0, 0, 0, 1, 1, (int )opts->verbose);
  }
#line 481
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 483
  res = sg_ll_start_stop_unit(sg_fd, 0, 0, 0, 0, 0, 0, 1, (int )opts->verbose);
  }
#line 484
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 486
  res = sg_ll_sync_cache_10(sg_fd, 0, 0, 0, 0U, 0U, 1, (int )opts->verbose);
  }
#line 487
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 489
  res = sg_ll_prevent_allow(sg_fd, 0, 1, (int )opts->verbose);
  }
#line 490
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 492
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown cmd number [%d]\n",
          scmdp->cmd_num);
  }
#line 493
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 495
  return (res);
}
}
