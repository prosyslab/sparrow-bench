/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 5 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.h"
struct comm {
   char *com1 ;
   char *com2 ;
   int bytes ;
   int type ;
   int proc ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.h"
enum referencetype {
    undef = 0,
    jpdest = 1,
    jrdest = 2,
    djdest = 3,
    cldest = 4,
    vrbyte = 5,
    vrword = 6,
    cstadd = 7,
    cstdfw = 8
} ;
#line 29
struct reference;
#line 29 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.h"
struct symbol {
   char *name ;
   int automatic ;
   int val ;
   int label ;
   char *comment ;
   int weight ;
   int range ;
   int included ;
   struct reference *ref ;
   struct symbol *prev ;
   struct symbol *next ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.h"
struct reference {
   int addr ;
   enum referencetype type ;
   struct reference *next ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.h"
enum blocktype {
    code = 0,
    bytedata = 1,
    worddata = 2,
    pointers = 3
} ;
#line 24 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.h"
struct block {
   char *name ;
   int start ;
   int end ;
   enum blocktype type ;
   struct block *prev ;
   struct block *next ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 195
extern FILE *tmpfile(void) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.h"
int a_address ;
#line 14
int a_labels ;
#line 15
int a_source ;
#line 16
int a_org ;
#line 17
int a_zilog ;
#line 19
char *a_input ;
#line 20
char *a_output ;
#line 22
char *a_symoutput ;
#line 23
char *a_syminput ;
#line 25
char *a_blockfile ;
#line 27
int tosymtab(int *ia , unsigned int prc ) ;
#line 29
void cmdline(int argc , char **argv ) ;
#line 30
int msg(int level , char const   *format  , ...) ;
#line 33
char const   *rarg[8] ;
#line 34
struct comm  const  comtab[256] ;
#line 35
char const   *ed40[16] ;
#line 36
char const   *ed50[16] ;
#line 37
char const   *ed60[16] ;
#line 38
char const   *ed70[16] ;
#line 39
char const   *eda0[16] ;
#line 40
char const   *edb0[16] ;
#line 74 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.h"
struct symbol *symbol_find(int val ) ;
#line 75
struct symbol *symbol_find_next(int val , struct symbol *cur ) ;
#line 76
struct symbol *symbol_find_range(int val ) ;
#line 79
struct symbol *symbol_newref(int val , int addr , enum referencetype type ) ;
#line 80
int symbol_setlabel(int val , int range ) ;
#line 82
void symbol_remove_nonlabels(void) ;
#line 84
int symbol_export(FILE *f ) ;
#line 85
int symbol_export_nonlabels(FILE *f ) ;
#line 88
int symbol_load_file(char *filename , int level ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.h"
struct block *blocks ;
#line 38
int block_init(int start , int end ) ;
#line 42
int block_load_file(char *filename ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/utils.h"
size_t file_len(char *path ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int f_smc  =    0;
#line 41 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int f_z80  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
FILE *f1  =    (FILE *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
FILE *f2  =    (FILE *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
FILE *f3  =    (FILE *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
FILE *fx  =    (FILE *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
unsigned int pc  =    0U;
#line 47 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int pass  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int t[6]  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int shiftin_cnt  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
struct block *shiftin_blk  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
void shiftin(void) 
{ 
  int n ;

  {
#line 62
  n = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! (n < 5)) {
#line 62
      goto while_break;
    }
#line 63
    t[n] = t[n + 1];
#line 62
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (shiftin_cnt > 0) {
    {
#line 67
    t[5] = _IO_getc(f1);
    }
#line 68
    if (t[5] == -1) {
      {
#line 69
      msg(0, "Error: Unexpected end of file. File changed while reading.");
#line 71
      t[5] = -1;
      }
    }
#line 74
    shiftin_cnt --;
  } else {
#line 76
    t[5] = -1;
  }
#line 78
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int ckrange(int skip , char *str ) 
{ 
  int val ;
  int off ;
  struct symbol *symb ;

  {
#line 89
  if (t[skip] == -1) {
#line 91
    return (-1);
  } else
#line 89
  if (t[skip + 1] == -1) {
#line 91
    return (-1);
  }
#line 93
  val = t[skip] + 256 * t[skip + 1];
#line 95
  if (pass == 1) {
    {
#line 98
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"0%04xh",
            val);
    }
#line 99
    return (0);
  } else
#line 95
  if (pass == 2) {
    {
#line 98
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"0%04xh",
            val);
    }
#line 99
    return (0);
  } else
#line 95
  if (! a_labels) {
    {
#line 98
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"0%04xh",
            val);
    }
#line 99
    return (0);
  }
  {
#line 112
  symb = symbol_find(val);
  }
#line 113
  if ((unsigned long )symb != (unsigned long )((void *)0)) {
    {
#line 115
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s", symb->name);
    }
#line 116
    return (1);
  }
  {
#line 119
  symb = symbol_find_range(val);
  }
#line 120
  if ((unsigned long )symb != (unsigned long )((void *)0)) {
    {
#line 121
    f_smc = 1;
#line 122
    off = val - symb->val;
#line 123
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s+%d",
            symb->name, off);
    }
#line 124
    return (1);
  }
  {
#line 128
  sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"0%04xh",
          val);
  }
#line 130
  return (0);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int ckrange_rel(int skip , int pc___0 , char *str ) 
{ 
  int val ;
  struct symbol *symb ;

  {
#line 140
  symb = (struct symbol *)((void *)0);
#line 142
  if (t[skip] == -1) {
#line 142
    return (-1);
  }
#line 144
  if (a_labels) {
#line 145
    if (t[skip] < 128) {
#line 146
      val = (pc___0 + 2) + t[skip];
    } else {
#line 148
      val = ((pc___0 + 2) + t[skip]) - 256;
    }
    {
#line 151
    symb = symbol_find(val & 65535);
    }
  }
#line 154
  if (a_labels) {
#line 154
    if ((unsigned long )symb != (unsigned long )((void *)0)) {
      {
#line 156
      sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s",
              symb->name);
      }
#line 157
      return (1);
    } else {
#line 154
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 159
    if (a_zilog) {
#line 161
      if (t[1] < 128) {
        {
#line 162
        sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%d",
                t[1] + 2);
        }
      } else {
        {
#line 164
        sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%d",
                (t[1] + 2) - 256);
        }
      }
    } else
#line 169
    if (t[1] < 128) {
      {
#line 170
      sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"$%+d",
              t[1] + 2);
      }
    } else {
      {
#line 172
      sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"$%+d",
              (t[1] + 2) - 256);
      }
    }
#line 175
    return (0);
  }
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int diz80(void) 
{ 
  char stri[80] ;
  char stro[80] ;
  int a ;
  int r ;
  int i ;
  char bstr[1024] ;
  char rstr[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 189
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t");
  }
#line 191
  if (t[0] == 203) {
#line 192
    a = t[1];
#line 193
    if (a == -1) {
      {
#line 194
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh",
              t[0]);
      }
#line 195
      return (1);
    }
#line 197
    if (a < 8) {
      {
#line 197
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rlc ");
      }
    } else
#line 198
    if (a >= 8) {
#line 198
      if (a < 16) {
        {
#line 198
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rrc ");
        }
      } else {
#line 198
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 199
    if (a >= 16) {
#line 199
      if (a < 24) {
        {
#line 199
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rl ");
        }
      } else {
#line 199
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 200
    if (a >= 24) {
#line 200
      if (a < 32) {
        {
#line 200
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rr ");
        }
      } else {
#line 200
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 201
    if (a >= 32) {
#line 201
      if (a < 40) {
        {
#line 201
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sla ");
        }
      } else {
#line 201
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 202
    if (a >= 40) {
#line 202
      if (a < 48) {
        {
#line 202
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sra ");
        }
      } else {
#line 202
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 204
    if (a >= 48) {
#line 204
      if (a < 56) {
        {
#line 204
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sli ");
        }
      } else {
#line 204
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 205
    if (a >= 56) {
#line 205
      if (a < 64) {
        {
#line 205
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"srl ");
        }
      } else {
#line 205
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 206
    if (a >= 64) {
#line 206
      if (a < 128) {
        {
#line 206
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit %d,",
                (a - 64) / 8);
        }
      } else {
#line 206
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 207
    if (a >= 128) {
#line 207
      if (a < 192) {
        {
#line 207
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res %d,",
                (a - 128) / 8);
        }
      } else {
#line 207
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 208
    if (a >= 192) {
      {
#line 208
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set %d,",
              (a - 192) / 8);
      }
    }
    {
#line 209
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", rarg[a % 8]);
#line 210
    f_z80 = 1;
    }
#line 211
    return (2);
  } else
#line 212
  if (t[0] == 237) {
#line 213
    a = t[1];
#line 214
    if (a == -1) {
      {
#line 215
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh",
              t[0]);
      }
#line 216
      return (1);
    }
#line 226
    if (a >= 64) {
#line 226
      if (a < 80) {
#line 226
        if ((int const   )*(ed40[a - 64] + 0) != 48) {
#line 226
          i = 0;
        } else {
#line 226
          goto _L___17;
        }
      } else {
#line 226
        goto _L___17;
      }
    } else
    _L___17: /* CIL Label */ 
#line 227
    if (a >= 80) {
#line 227
      if (a < 96) {
#line 227
        if ((int const   )*(ed50[a - 80] + 0) != 48) {
#line 227
          i = 1;
        } else {
#line 227
          goto _L___15;
        }
      } else {
#line 227
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 228
    if (a >= 96) {
#line 228
      if (a < 112) {
#line 228
        if ((int const   )*(ed60[a - 96] + 0) != 48) {
#line 228
          i = 2;
        } else {
#line 228
          goto _L___13;
        }
      } else {
#line 228
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 229
    if (a >= 112) {
#line 229
      if (a < 128) {
#line 229
        if ((int const   )*(ed70[a - 112] + 0) != 48) {
#line 229
          i = 3;
        } else {
#line 229
          goto _L___11;
        }
      } else {
#line 229
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 230
    if (a >= 160) {
#line 230
      if (a < 176) {
#line 230
        if ((int const   )*(eda0[a - 160] + 0) != 48) {
#line 230
          i = 4;
        } else {
#line 230
          goto _L___9;
        }
      } else {
#line 230
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 231
    if (a >= 176) {
#line 231
      if (a < 192) {
#line 231
        if ((int const   )*(edb0[a - 176] + 0) != 48) {
#line 231
          i = 5;
        } else {
          {
#line 233
          fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0edh");
#line 234
          fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)";next byte illegal after ed");
          }
#line 235
          return (1);
        }
      } else {
        {
#line 233
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0edh");
#line 234
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)";next byte illegal after ed");
        }
#line 235
        return (1);
      }
    } else {
      {
#line 233
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0edh");
#line 234
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)";next byte illegal after ed");
      }
#line 235
      return (1);
    }
    {
#line 237
    r = ckrange(2, bstr);
    }
#line 238
    if (r == -1) {
      {
#line 239
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 240
      i = 0;
      }
      {
#line 240
      while (1) {
        while_continue: /* CIL Label */ ;
#line 240
        if (! (t[i] != -1)) {
#line 240
          goto while_break;
        }
#line 240
        if (i) {
#line 240
          tmp = ',';
        } else {
#line 240
          tmp = ' ';
        }
        {
#line 240
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
                tmp, t[i]);
#line 240
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 241
      return (i);
    }
#line 243
    f_z80 = 1;
    {
#line 245
    if (i == 0) {
#line 245
      goto case_0;
    }
#line 247
    if (i == 1) {
#line 247
      goto case_1;
    }
#line 249
    if (i == 2) {
#line 249
      goto case_2;
    }
#line 251
    if (i == 3) {
#line 251
      goto case_3;
    }
#line 253
    if (i == 4) {
#line 253
      goto case_4;
    }
#line 255
    if (i == 5) {
#line 255
      goto case_5;
    }
#line 244
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 245
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", ed40[a - 64]);
    }
#line 246
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 247
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", ed50[a - 80]);
    }
#line 248
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 249
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", ed60[a - 96]);
    }
#line 250
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 251
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", ed70[a - 112]);
    }
#line 252
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 253
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", eda0[a - 160]);
    }
#line 254
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 255
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", edb0[a - 176]);
    }
#line 256
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 260
    if (a == 67) {
      {
#line 262
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s),bc",
              bstr);
      }
#line 263
      return (4);
    } else
#line 265
    if (a == 83) {
      {
#line 267
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s),de",
              bstr);
      }
#line 268
      return (4);
    } else
#line 270
    if (a == 115) {
      {
#line 272
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s),sp",
              bstr);
      }
#line 273
      return (4);
    } else
#line 275
    if (a == 75) {
      {
#line 277
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s)",
              bstr);
      }
#line 278
      return (4);
    } else
#line 275
    if (a == 91) {
      {
#line 277
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s)",
              bstr);
      }
#line 278
      return (4);
    } else
#line 275
    if (a == 123) {
      {
#line 277
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s)",
              bstr);
      }
#line 278
      return (4);
    }
#line 280
    return (2);
  } else
#line 281
  if (t[0] == 221) {
#line 281
    goto _L___19;
  } else
#line 281
  if (t[0] == 253) {
    _L___19: /* CIL Label */ 
#line 282
    if (t[0] == 253) {
      {
#line 283
      strcpy((char */* __restrict  */)(stri), (char const   */* __restrict  */)"iy");
      }
    } else {
      {
#line 285
      strcpy((char */* __restrict  */)(stri), (char const   */* __restrict  */)"ix");
      }
    }
#line 287
    if (t[1] == -1) {
      {
#line 288
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh",
              t[0]);
      }
#line 289
      return (1);
    }
    {
#line 291
    r = ckrange(2, bstr);
#line 292
    f_z80 = 1;
    }
    {
#line 295
    if (t[1] == 9) {
#line 295
      goto case_9;
    }
#line 299
    if (t[1] == 25) {
#line 299
      goto case_25;
    }
#line 303
    if (t[1] == 33) {
#line 303
      goto case_33;
    }
#line 312
    if (t[1] == 34) {
#line 312
      goto case_34;
    }
#line 321
    if (t[1] == 35) {
#line 321
      goto case_35;
    }
#line 325
    if (t[1] == 41) {
#line 325
      goto case_41;
    }
#line 329
    if (t[1] == 42) {
#line 329
      goto case_42;
    }
#line 338
    if (t[1] == 43) {
#line 338
      goto case_43;
    }
#line 342
    if (t[1] == 57) {
#line 342
      goto case_57;
    }
#line 346
    if (t[1] == 225) {
#line 346
      goto case_225;
    }
#line 350
    if (t[1] == 227) {
#line 350
      goto case_227;
    }
#line 354
    if (t[1] == 229) {
#line 354
      goto case_229;
    }
#line 358
    if (t[1] == 233) {
#line 358
      goto case_233;
    }
#line 362
    if (t[1] == 249) {
#line 362
      goto case_249;
    }
#line 293
    goto switch_break___0;
    case_9: /* CIL Label */ 
    {
#line 296
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"add %s,bc",
            stri);
    }
#line 297
    return (2);
#line 298
    goto switch_break___0;
    case_25: /* CIL Label */ 
    {
#line 300
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"add %s,de",
            stri);
    }
#line 301
    return (2);
#line 302
    goto switch_break___0;
    case_33: /* CIL Label */ 
#line 304
    if (r == -1) {
      {
#line 305
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 306
      i = 0;
      }
      {
#line 306
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 306
        if (! (t[i] != -1)) {
#line 306
          goto while_break___0;
        }
#line 306
        if (i) {
#line 306
          tmp___0 = ',';
        } else {
#line 306
          tmp___0 = ' ';
        }
        {
#line 306
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
                tmp___0, t[i]);
#line 306
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 307
      return (i);
    }
    {
#line 309
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,%s",
            stri, bstr);
    }
#line 310
    return (4);
#line 311
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 313
    if (r == -1) {
      {
#line 314
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 315
      i = 0;
      }
      {
#line 315
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 315
        if (! (t[i] != -1)) {
#line 315
          goto while_break___1;
        }
#line 315
        if (i) {
#line 315
          tmp___1 = ',';
        } else {
#line 315
          tmp___1 = ' ';
        }
        {
#line 315
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
                tmp___1, t[i]);
#line 315
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      return (i);
    }
    {
#line 318
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld (%s),%s",
            bstr, stri);
    }
#line 319
    return (4);
#line 320
    goto switch_break___0;
    case_35: /* CIL Label */ 
    {
#line 322
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"inc %s",
            stri);
    }
#line 323
    return (2);
#line 324
    goto switch_break___0;
    case_41: /* CIL Label */ 
    {
#line 326
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"add %s,%s",
            stri, stri);
    }
#line 327
    return (2);
#line 328
    goto switch_break___0;
    case_42: /* CIL Label */ 
#line 330
    if (r == -1) {
      {
#line 331
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 332
      i = 0;
      }
      {
#line 332
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 332
        if (! (t[i] != -1)) {
#line 332
          goto while_break___2;
        }
#line 332
        if (i) {
#line 332
          tmp___2 = ',';
        } else {
#line 332
          tmp___2 = ' ';
        }
        {
#line 332
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
                tmp___2, t[i]);
#line 332
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 333
      return (i);
    }
    {
#line 335
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,(%s)",
            stri, bstr);
    }
#line 336
    return (4);
#line 337
    goto switch_break___0;
    case_43: /* CIL Label */ 
    {
#line 339
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"dec %s",
            stri);
    }
#line 340
    return (2);
#line 341
    goto switch_break___0;
    case_57: /* CIL Label */ 
    {
#line 343
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"add %s,sp",
            stri);
    }
#line 344
    return (2);
#line 345
    goto switch_break___0;
    case_225: /* CIL Label */ 
    {
#line 347
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"pop %s",
            stri);
    }
#line 348
    return (2);
#line 349
    goto switch_break___0;
    case_227: /* CIL Label */ 
    {
#line 351
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ex (sp),%s",
            stri);
    }
#line 352
    return (2);
#line 353
    goto switch_break___0;
    case_229: /* CIL Label */ 
    {
#line 355
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"push %s",
            stri);
    }
#line 356
    return (2);
#line 357
    goto switch_break___0;
    case_233: /* CIL Label */ 
    {
#line 359
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"jp (%s)",
            stri);
    }
#line 360
    return (2);
#line 361
    goto switch_break___0;
    case_249: /* CIL Label */ 
    {
#line 363
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld sp,%s",
            stri);
    }
#line 364
    return (2);
#line 365
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 369
    if (t[2] == -1) {
#line 369
      goto _L___18;
    } else
#line 369
    if (t[3] == -1) {
      _L___18: /* CIL Label */ 
      {
#line 370
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 371
      i = 0;
      }
      {
#line 371
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 371
        if (! (t[i] != -1)) {
#line 371
          goto while_break___3;
        }
#line 371
        if (i) {
#line 371
          tmp___3 = ',';
        } else {
#line 371
          tmp___3 = ' ';
        }
        {
#line 371
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
                tmp___3, t[i]);
#line 371
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 372
      return (i);
    }
#line 375
    if (t[2] < 128) {
      {
#line 376
      sprintf((char */* __restrict  */)(stro), (char const   */* __restrict  */)"(%s+0%02xh)",
              stri, t[2]);
      }
    } else {
      {
#line 379
      sprintf((char */* __restrict  */)(stro), (char const   */* __restrict  */)"(%s-0%02xh)",
              stri, 256 - t[2]);
      }
    }
#line 382
    if (t[1] == 203) {
      {
#line 386
      if (t[3] == 6) {
#line 386
        goto case_6;
      }
#line 389
      if (t[3] == 14) {
#line 389
        goto case_14;
      }
#line 392
      if (t[3] == 22) {
#line 392
        goto case_22;
      }
#line 395
      if (t[3] == 30) {
#line 395
        goto case_30;
      }
#line 398
      if (t[3] == 38) {
#line 398
        goto case_38;
      }
#line 401
      if (t[3] == 46) {
#line 401
        goto case_46;
      }
#line 404
      if (t[3] == 62) {
#line 404
        goto case_62;
      }
#line 407
      if (t[3] == 70) {
#line 407
        goto case_70;
      }
#line 410
      if (t[3] == 78) {
#line 410
        goto case_78;
      }
#line 413
      if (t[3] == 86) {
#line 413
        goto case_86;
      }
#line 416
      if (t[3] == 94) {
#line 416
        goto case_94;
      }
#line 419
      if (t[3] == 102) {
#line 419
        goto case_102;
      }
#line 422
      if (t[3] == 110) {
#line 422
        goto case_110;
      }
#line 425
      if (t[3] == 118) {
#line 425
        goto case_118;
      }
#line 428
      if (t[3] == 126) {
#line 428
        goto case_126;
      }
#line 431
      if (t[3] == 134) {
#line 431
        goto case_134;
      }
#line 434
      if (t[3] == 142) {
#line 434
        goto case_142;
      }
#line 437
      if (t[3] == 150) {
#line 437
        goto case_150;
      }
#line 440
      if (t[3] == 158) {
#line 440
        goto case_158;
      }
#line 443
      if (t[3] == 166) {
#line 443
        goto case_166;
      }
#line 446
      if (t[3] == 174) {
#line 446
        goto case_174;
      }
#line 449
      if (t[3] == 182) {
#line 449
        goto case_182;
      }
#line 452
      if (t[3] == 190) {
#line 452
        goto case_190;
      }
#line 455
      if (t[3] == 198) {
#line 455
        goto case_198;
      }
#line 458
      if (t[3] == 206) {
#line 458
        goto case_206;
      }
#line 461
      if (t[3] == 214) {
#line 461
        goto case_214;
      }
#line 464
      if (t[3] == 222) {
#line 464
        goto case_222;
      }
#line 467
      if (t[3] == 230) {
#line 467
        goto case_230;
      }
#line 470
      if (t[3] == 238) {
#line 470
        goto case_238;
      }
#line 473
      if (t[3] == 246) {
#line 473
        goto case_246;
      }
#line 476
      if (t[3] == 254) {
#line 476
        goto case_254;
      }
#line 479
      goto switch_default;
      case_6: /* CIL Label */ 
      {
#line 387
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rlc ");
      }
#line 388
      goto switch_break___1;
      case_14: /* CIL Label */ 
      {
#line 390
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rrc ");
      }
#line 391
      goto switch_break___1;
      case_22: /* CIL Label */ 
      {
#line 393
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rl ");
      }
#line 394
      goto switch_break___1;
      case_30: /* CIL Label */ 
      {
#line 396
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"rr ");
      }
#line 397
      goto switch_break___1;
      case_38: /* CIL Label */ 
      {
#line 399
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sla ");
      }
#line 400
      goto switch_break___1;
      case_46: /* CIL Label */ 
      {
#line 402
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sra ");
      }
#line 403
      goto switch_break___1;
      case_62: /* CIL Label */ 
      {
#line 405
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"srl ");
      }
#line 406
      goto switch_break___1;
      case_70: /* CIL Label */ 
      {
#line 408
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 0,");
      }
#line 409
      goto switch_break___1;
      case_78: /* CIL Label */ 
      {
#line 411
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 1,");
      }
#line 412
      goto switch_break___1;
      case_86: /* CIL Label */ 
      {
#line 414
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 2,");
      }
#line 415
      goto switch_break___1;
      case_94: /* CIL Label */ 
      {
#line 417
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 3,");
      }
#line 418
      goto switch_break___1;
      case_102: /* CIL Label */ 
      {
#line 420
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 4,");
      }
#line 421
      goto switch_break___1;
      case_110: /* CIL Label */ 
      {
#line 423
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 5,");
      }
#line 424
      goto switch_break___1;
      case_118: /* CIL Label */ 
      {
#line 426
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 6,");
      }
#line 427
      goto switch_break___1;
      case_126: /* CIL Label */ 
      {
#line 429
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"bit 7,");
      }
#line 430
      goto switch_break___1;
      case_134: /* CIL Label */ 
      {
#line 432
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 0,");
      }
#line 433
      goto switch_break___1;
      case_142: /* CIL Label */ 
      {
#line 435
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 1,");
      }
#line 436
      goto switch_break___1;
      case_150: /* CIL Label */ 
      {
#line 438
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 2,");
      }
#line 439
      goto switch_break___1;
      case_158: /* CIL Label */ 
      {
#line 441
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 3,");
      }
#line 442
      goto switch_break___1;
      case_166: /* CIL Label */ 
      {
#line 444
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 4,");
      }
#line 445
      goto switch_break___1;
      case_174: /* CIL Label */ 
      {
#line 447
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 5,");
      }
#line 448
      goto switch_break___1;
      case_182: /* CIL Label */ 
      {
#line 450
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 6,");
      }
#line 451
      goto switch_break___1;
      case_190: /* CIL Label */ 
      {
#line 453
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"res 7,");
      }
#line 454
      goto switch_break___1;
      case_198: /* CIL Label */ 
      {
#line 456
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 0,");
      }
#line 457
      goto switch_break___1;
      case_206: /* CIL Label */ 
      {
#line 459
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 1,");
      }
#line 460
      goto switch_break___1;
      case_214: /* CIL Label */ 
      {
#line 462
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 2,");
      }
#line 463
      goto switch_break___1;
      case_222: /* CIL Label */ 
      {
#line 465
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 3,");
      }
#line 466
      goto switch_break___1;
      case_230: /* CIL Label */ 
      {
#line 468
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 4,");
      }
#line 469
      goto switch_break___1;
      case_238: /* CIL Label */ 
      {
#line 471
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 5,");
      }
#line 472
      goto switch_break___1;
      case_246: /* CIL Label */ 
      {
#line 474
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 6,");
      }
#line 475
      goto switch_break___1;
      case_254: /* CIL Label */ 
      {
#line 477
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"set 7,");
      }
#line 478
      goto switch_break___1;
      switch_default: /* CIL Label */ 
      {
#line 480
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh,0%02xh,0%02xh,0%02xh\t;illegal sequence",
              t[0], t[1], t[2], t[3]);
      }
#line 482
      return (4);
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 484
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s",
              stro);
      }
#line 485
      return (4);
    } else {
      {
#line 489
      if (t[1] == 52) {
#line 489
        goto case_52;
      }
#line 492
      if (t[1] == 53) {
#line 492
        goto case_53;
      }
#line 495
      if (t[1] == 54) {
#line 495
        goto case_54;
      }
#line 499
      if (t[1] == 70) {
#line 499
        goto case_70___0;
      }
#line 502
      if (t[1] == 78) {
#line 502
        goto case_78___0;
      }
#line 505
      if (t[1] == 86) {
#line 505
        goto case_86___0;
      }
#line 508
      if (t[1] == 94) {
#line 508
        goto case_94___0;
      }
#line 511
      if (t[1] == 102) {
#line 511
        goto case_102___0;
      }
#line 514
      if (t[1] == 110) {
#line 514
        goto case_110___0;
      }
#line 517
      if (t[1] == 112) {
#line 517
        goto case_112;
      }
#line 520
      if (t[1] == 113) {
#line 520
        goto case_113;
      }
#line 523
      if (t[1] == 114) {
#line 523
        goto case_114;
      }
#line 526
      if (t[1] == 115) {
#line 526
        goto case_115;
      }
#line 529
      if (t[1] == 116) {
#line 529
        goto case_116;
      }
#line 532
      if (t[1] == 117) {
#line 532
        goto case_117;
      }
#line 535
      if (t[1] == 119) {
#line 535
        goto case_119;
      }
#line 538
      if (t[1] == 126) {
#line 538
        goto case_126___0;
      }
#line 541
      if (t[1] == 134) {
#line 541
        goto case_134___0;
      }
#line 544
      if (t[1] == 142) {
#line 544
        goto case_142___0;
      }
#line 547
      if (t[1] == 150) {
#line 547
        goto case_150___0;
      }
#line 550
      if (t[1] == 158) {
#line 550
        goto case_158___0;
      }
#line 553
      if (t[1] == 166) {
#line 553
        goto case_166___0;
      }
#line 556
      if (t[1] == 174) {
#line 556
        goto case_174___0;
      }
#line 559
      if (t[1] == 182) {
#line 559
        goto case_182___0;
      }
#line 562
      if (t[1] == 190) {
#line 562
        goto case_190___0;
      }
#line 565
      goto switch_default___0;
      case_52: /* CIL Label */ 
      {
#line 490
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"inc %s",
              stro);
      }
#line 491
      goto switch_break___2;
      case_53: /* CIL Label */ 
      {
#line 493
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"dec %s",
              stro);
      }
#line 494
      goto switch_break___2;
      case_54: /* CIL Label */ 
      {
#line 496
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,0%02xh",
              stro, t[3]);
      }
#line 497
      return (4);
#line 498
      goto switch_break___2;
      case_70___0: /* CIL Label */ 
      {
#line 500
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld b,%s",
              stro);
      }
#line 501
      goto switch_break___2;
      case_78___0: /* CIL Label */ 
      {
#line 503
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld c,%s",
              stro);
      }
#line 504
      goto switch_break___2;
      case_86___0: /* CIL Label */ 
      {
#line 506
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld d,%s",
              stro);
      }
#line 507
      goto switch_break___2;
      case_94___0: /* CIL Label */ 
      {
#line 509
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld e,%s",
              stro);
      }
#line 510
      goto switch_break___2;
      case_102___0: /* CIL Label */ 
      {
#line 512
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld h,%s",
              stro);
      }
#line 513
      goto switch_break___2;
      case_110___0: /* CIL Label */ 
      {
#line 515
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld l,%s",
              stro);
      }
#line 516
      goto switch_break___2;
      case_112: /* CIL Label */ 
      {
#line 518
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,b",
              stro);
      }
#line 519
      goto switch_break___2;
      case_113: /* CIL Label */ 
      {
#line 521
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,c",
              stro);
      }
#line 522
      goto switch_break___2;
      case_114: /* CIL Label */ 
      {
#line 524
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,d",
              stro);
      }
#line 525
      goto switch_break___2;
      case_115: /* CIL Label */ 
      {
#line 527
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,e",
              stro);
      }
#line 528
      goto switch_break___2;
      case_116: /* CIL Label */ 
      {
#line 530
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,h",
              stro);
      }
#line 531
      goto switch_break___2;
      case_117: /* CIL Label */ 
      {
#line 533
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,l",
              stro);
      }
#line 534
      goto switch_break___2;
      case_119: /* CIL Label */ 
      {
#line 536
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld %s,a",
              stro);
      }
#line 537
      goto switch_break___2;
      case_126___0: /* CIL Label */ 
      {
#line 539
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"ld a,%s",
              stro);
      }
#line 540
      goto switch_break___2;
      case_134___0: /* CIL Label */ 
      {
#line 542
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"add a,%s",
              stro);
      }
#line 543
      goto switch_break___2;
      case_142___0: /* CIL Label */ 
      {
#line 545
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"adc a,%s",
              stro);
      }
#line 546
      goto switch_break___2;
      case_150___0: /* CIL Label */ 
      {
#line 548
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sub %s",
              stro);
      }
#line 549
      goto switch_break___2;
      case_158___0: /* CIL Label */ 
      {
#line 551
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"sbc a,%s",
              stro);
      }
#line 552
      goto switch_break___2;
      case_166___0: /* CIL Label */ 
      {
#line 554
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"and %s",
              stro);
      }
#line 555
      goto switch_break___2;
      case_174___0: /* CIL Label */ 
      {
#line 557
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"xor %s",
              stro);
      }
#line 558
      goto switch_break___2;
      case_182___0: /* CIL Label */ 
      {
#line 560
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"or %s",
              stro);
      }
#line 561
      goto switch_break___2;
      case_190___0: /* CIL Label */ 
      {
#line 563
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"cp %s",
              stro);
      }
#line 564
      goto switch_break___2;
      switch_default___0: /* CIL Label */ 
      {
#line 566
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh,0%02xh,0%02xh\t;illegal sequence",
              t[0], t[1], t[2]);
      }
#line 568
      return (3);
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 570
    return (3);
  }
  {
#line 572
  r = ckrange(1, bstr);
  }
  {
#line 575
  if (comtab[t[0]].type == 0) {
#line 575
    goto case_0___0;
  }
#line 579
  if (comtab[t[0]].type == 1) {
#line 579
    goto case_1___0;
  }
#line 587
  if (comtab[t[0]].type == 2) {
#line 587
    goto case_2___0;
  }
#line 596
  if (comtab[t[0]].type == 3) {
#line 596
    goto case_3___0;
  }
#line 614
  if (comtab[t[0]].type == 11) {
#line 614
    goto case_11;
  }
#line 622
  if (comtab[t[0]].type == 12) {
#line 622
    goto case_12;
  }
#line 573
  goto switch_break___3;
  case_0___0: /* CIL Label */ 
  {
#line 576
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", comtab[t[0]].com1);
#line 577
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t");
  }
#line 578
  goto switch_break___3;
  case_1___0: /* CIL Label */ 
#line 580
  if (t[1] == -1) {
    {
#line 581
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh",
            t[0]);
    }
#line 582
    return (1);
  }
  {
#line 584
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", comtab[t[0]].com1);
#line 585
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"0%02xh",
          t[1]);
  }
#line 586
  goto switch_break___3;
  case_2___0: /* CIL Label */ 
#line 588
  if (r == -1) {
    {
#line 589
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 590
    i = 0;
    }
    {
#line 590
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 590
      if (! (t[i] != -1)) {
#line 590
        goto while_break___4;
      }
#line 590
      if (i) {
#line 590
        tmp___4 = ',';
      } else {
#line 590
        tmp___4 = ' ';
      }
      {
#line 590
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
              tmp___4, t[i]);
#line 590
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 591
    return (i);
  }
  {
#line 593
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", comtab[t[0]].com1);
#line 594
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", bstr);
  }
#line 595
  goto switch_break___3;
  case_3___0: /* CIL Label */ 
#line 597
  if (t[1] == -1) {
    {
#line 598
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh",
            t[0]);
    }
#line 599
    return (1);
  }
  {
#line 601
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", comtab[t[0]].com1);
  }
#line 602
  if (comtab[t[0]].bytes == 2) {
    {
#line 607
    ckrange_rel(1, (int )pc, rstr);
#line 608
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", rstr);
    }
  } else {
    {
#line 611
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"0%02xh",
            t[1]);
    }
  }
#line 613
  goto switch_break___3;
  case_11: /* CIL Label */ 
#line 615
  if (t[1] == -1) {
    {
#line 616
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb 0%02xh",
            t[0]);
    }
#line 617
    return (1);
  }
  {
#line 619
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", comtab[t[0]].com1);
#line 620
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"0%02xh%s",
          t[1], comtab[t[0]].com2);
  }
#line 621
  goto switch_break___3;
  case_12: /* CIL Label */ 
#line 623
  if (r == -1) {
    {
#line 624
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"defb");
#line 625
    i = 0;
    }
    {
#line 625
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 625
      if (! (t[i] != -1)) {
#line 625
        goto while_break___5;
      }
#line 625
      if (i) {
#line 625
        tmp___5 = ',';
      } else {
#line 625
        tmp___5 = ' ';
      }
      {
#line 625
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c0%02xh",
              tmp___5, t[i]);
#line 625
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 626
    return (i);
  }
  {
#line 628
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s", comtab[t[0]].com1);
#line 629
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s%s", bstr,
          comtab[t[0]].com2);
  }
#line 630
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 632
  a = (int )comtab[t[0]].bytes;
#line 633
  if (comtab[t[0]].proc == 1) {
#line 634
    f_z80 = 1;
  }
#line 636
  return (a);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int diz80_bytedata(void) 
{ 


  {
  {
#line 641
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\tdefb 0%02xh",
          t[0]);
  }
#line 642
  return (1);
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int diz80_worddata(void) 
{ 
  int tmp ;

  {
#line 647
  if (t[1] == -1) {
    {
#line 648
    tmp = diz80_bytedata();
    }
#line 648
    return (tmp);
  }
  {
#line 651
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\tdefw 0%04xh",
          t[0] + 256 * t[1]);
  }
#line 652
  return (2);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int diz80_pointers(void) 
{ 
  char bstr[1024] ;
  int tmp ;

  {
#line 659
  if (t[1] == -1) {
    {
#line 660
    tmp = diz80_bytedata();
    }
#line 660
    return (tmp);
  }
  {
#line 663
  ckrange(0, bstr);
#line 664
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\tdefw %s",
          bstr);
  }
#line 666
  if (pass == 1) {
#line 666
    if (a_labels) {
      {
#line 667
      symbol_newref(t[0] + 256 * t[1], (int )pc, (enum referencetype )8);
      }
    }
  }
#line 670
  return (2);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int diz80_code(void) 
{ 
  int r ;

  {
  {
#line 677
  r = diz80();
  }
#line 679
  if (pass == 1) {
#line 679
    if (a_labels) {
#line 679
      if (r > 0) {
        {
#line 680
        tosymtab(t, pc);
        }
      }
    }
  }
#line 683
  return (r);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int disassemble(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 688
  if (t[0] == -1) {
#line 690
    return (0);
  }
  {
#line 694
  if ((unsigned int )shiftin_blk->type == 0U) {
#line 694
    goto case_0;
  }
#line 695
  if ((unsigned int )shiftin_blk->type == 1U) {
#line 695
    goto case_1;
  }
#line 696
  if ((unsigned int )shiftin_blk->type == 2U) {
#line 696
    goto case_2;
  }
#line 697
  if ((unsigned int )shiftin_blk->type == 3U) {
#line 697
    goto case_3;
  }
#line 693
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 694
  tmp = diz80_code();
  }
#line 694
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 695
  tmp___0 = diz80_bytedata();
  }
#line 695
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 696
  tmp___1 = diz80_worddata();
  }
#line 696
  return (tmp___1);
  case_3: /* CIL Label */ 
  {
#line 697
  tmp___2 = diz80_pointers();
  }
#line 697
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
#line 703
  return (0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
void blk_reset(void) 
{ 


  {
  {
#line 708
  shiftin_blk = blocks;
#line 709
  shiftin_cnt = shiftin_blk->end - shiftin_blk->start;
#line 711
  fseek(f1, 0L, 0);
  }
#line 712
  return;
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int blk_iterate(void) 
{ 


  {
  {
#line 716
  msg(2, "Disassembled block %s (0x%04x - 0x%04x)\n", shiftin_blk->name, shiftin_blk->start,
      shiftin_blk->end);
#line 719
  shiftin_blk = shiftin_blk->next;
  }
#line 720
  if ((unsigned long )shiftin_blk == (unsigned long )((void *)0)) {
#line 720
    return (0);
  }
#line 722
  shiftin_cnt = shiftin_blk->end - shiftin_blk->start;
#line 724
  if ((unsigned int )shiftin_blk->start != pc) {
    {
#line 725
    msg(2, "Debug: shiftin_blk->start == 0x%04x\n", shiftin_blk->start);
#line 727
    msg(2, "Debug: pc                 == 0x%04x\n", pc);
    }
  }
#line 730
  return (1);
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80.c"
int main(int argc , char **argv ) 
{ 
  FILE *pass1 ;
  FILE *pass2 ;
  struct symbol *symb ;
  int r ;
  int i ;
  int pci ;
  int sf ;
  unsigned int start ;
  unsigned int end ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 742
  fx = stdout;
#line 744
  cmdline(argc, argv);
  }
#line 746
  if (a_input) {
    {
#line 747
    f1 = fopen((char const   */* __restrict  */)a_input, (char const   */* __restrict  */)"rb");
    }
#line 748
    if ((unsigned long )f1 == (unsigned long )((void *)0)) {
      {
#line 749
      tmp = __errno_location();
#line 749
      tmp___0 = strerror(*tmp);
#line 749
      msg(0, "Error: Cannot open %s: %s\n", a_input, tmp___0);
#line 751
      exit(1);
      }
    }
  } else {
    {
#line 754
    msg(0, "Error: No input file specified\n");
#line 755
    exit(1);
    }
  }
#line 758
  if (a_syminput) {
    {
#line 759
    r = symbol_load_file(a_syminput, 0);
    }
#line 760
    if (r) {
      {
#line 761
      exit(1);
      }
    }
  }
#line 765
  if (a_symoutput) {
    {
#line 766
    f2 = fopen((char const   */* __restrict  */)a_symoutput, (char const   */* __restrict  */)"w");
    }
#line 767
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
      {
#line 768
      tmp___1 = __errno_location();
#line 768
      tmp___2 = strerror(*tmp___1);
#line 768
      msg(0, "Error: Cannot create %s: %s\n", a_symoutput, tmp___2);
#line 770
      exit(1);
      }
    }
  }
#line 774
  if ((unsigned long )a_output == (unsigned long )((void *)0)) {
#line 775
    f3 = stdout;
  } else {
    {
#line 777
    f3 = fopen((char const   */* __restrict  */)a_output, (char const   */* __restrict  */)"w");
    }
#line 778
    if ((unsigned long )f3 == (unsigned long )((void *)0)) {
      {
#line 779
      tmp___3 = __errno_location();
#line 779
      tmp___4 = strerror(*tmp___3);
#line 779
      msg(0, "Error: Cannot create %s: %s\n", a_output, tmp___4);
#line 781
      exit(1);
      }
    }
  }
  {
#line 785
  start = (unsigned int )a_org;
#line 787
  tmp___5 = file_len(a_input);
#line 787
  end = (unsigned int )((size_t )a_org + tmp___5);
  }
#line 789
  if (end == start) {
    {
#line 790
    msg(0, "Error: Empty input file\n");
#line 791
    exit(1);
    }
  }
#line 794
  if (end > 65536U) {
    {
#line 795
    msg(0, "Error: Binary data outside 16-bit address space\n");
#line 796
    exit(1);
    }
  }
  {
#line 799
  msg(1, "Disassembling binary data at 0x%04x - 0x%04x\n", start, end);
#line 801
  block_init((int )start, (int )end);
  }
#line 803
  if (a_blockfile) {
    {
#line 804
    r = block_load_file(a_blockfile);
    }
#line 805
    if (r) {
      {
#line 806
      exit(1);
      }
    }
  }
  {
#line 814
  pass1 = tmpfile();
  }
#line 815
  if ((unsigned long )pass1 == (unsigned long )((void *)0)) {
    {
#line 816
    tmp___6 = __errno_location();
#line 816
    tmp___7 = strerror(*tmp___6);
#line 816
    msg(0, "Error: Cannot create temporary file: %s\n", tmp___7);
#line 818
    exit(1);
    }
  }
  {
#line 820
  pass2 = tmpfile();
  }
#line 821
  if ((unsigned long )pass2 == (unsigned long )((void *)0)) {
    {
#line 822
    tmp___8 = __errno_location();
#line 822
    tmp___9 = strerror(*tmp___8);
#line 822
    msg(0, "Error: Cannot create temporary file: %s\n", tmp___9);
#line 824
    exit(1);
    }
  }
  {
#line 829
  msg(1, "Starting pass 1\n");
#line 831
  pass = 1;
#line 832
  fx = pass1;
#line 834
  pc = start;
#line 835
  blk_reset();
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    i = 0;
    {
#line 837
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 837
      if (! (i < 6)) {
#line 837
        goto while_break___0;
      }
      {
#line 837
      shiftin();
#line 837
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 839
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 840
      pci = disassemble();
      }
#line 841
      if (pci == 0) {
#line 841
        goto while_break___1;
      }
      {
#line 843
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t\t;%04x",
              pc);
#line 844
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n");
#line 846
      i = 0;
      }
      {
#line 846
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 846
        if (! (i < pci)) {
#line 846
          goto while_break___2;
        }
        {
#line 846
        shiftin();
#line 846
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 847
      pc += (unsigned int )pci;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 836
    tmp___10 = blk_iterate();
    }
#line 836
    if (! tmp___10) {
#line 836
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 860
  msg(1, "Starting pass 2\n");
#line 862
  pass = 2;
#line 863
  fx = pass2;
#line 865
  pc = start;
#line 866
  blk_reset();
  }
  {
#line 867
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 868
    i = 0;
    {
#line 868
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 868
      if (! (i < 6)) {
#line 868
        goto while_break___4;
      }
      {
#line 868
      shiftin();
#line 868
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 870
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 871
      pci = disassemble();
      }
#line 872
      if (pci == 0) {
#line 872
        goto while_break___5;
      }
#line 874
      if (a_labels) {
        {
#line 875
        symbol_setlabel((int )pc, pci);
        }
      }
      {
#line 877
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n");
#line 879
      i = 0;
      }
      {
#line 879
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 879
        if (! (i < pci)) {
#line 879
          goto while_break___6;
        }
        {
#line 879
        shiftin();
#line 879
        i ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 880
      pc += (unsigned int )pci;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 867
    tmp___11 = blk_iterate();
    }
#line 867
    if (! tmp___11) {
#line 867
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 887
  if (a_labels) {
    {
#line 888
    symbol_remove_nonlabels();
    }
  }
#line 891
  if (f2) {
    {
#line 892
    msg(2, "Writing symbol file\n");
#line 893
    symbol_export(f2);
#line 894
    fclose(f2);
    }
  }
  {
#line 904
  msg(1, "Starting pass 3\n");
#line 905
  msg(2, "Writing assembly file\n");
#line 907
  pass = 3;
#line 908
  fx = f3;
#line 910
  pc = start;
#line 911
  blk_reset();
#line 913
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"; %s\n",
          "z80dasm 1.1.3");
#line 914
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"; command line:");
#line 915
  i = 0;
  }
  {
#line 915
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 915
    if (! (i < argc)) {
#line 915
      goto while_break___7;
    }
    {
#line 915
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)" %s", *(argv + i));
#line 915
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 916
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n");
#line 917
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n\torg\t0%04xh\n",
          pc);
#line 922
  symbol_export_nonlabels(fx);
#line 924
  fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n");
#line 928
  sf = 1;
  }
  {
#line 930
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 931
    i = 0;
    {
#line 931
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 931
      if (! (i < 6)) {
#line 931
        goto while_break___9;
      }
      {
#line 931
      shiftin();
#line 931
      i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 933
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 935
      if (a_labels) {
#line 935
        if (sf) {
#line 936
          symb = (struct symbol *)((void *)0);
          {
#line 937
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 938
            symb = symbol_find_next((int )pc, symb);
            }
#line 939
            if ((unsigned long )symb == (unsigned long )((void *)0)) {
#line 939
              goto while_break___11;
            }
#line 941
            if ((unsigned long )symb->comment != (unsigned long )((void *)0)) {
              {
#line 942
              fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s",
                      symb->comment);
              }
            }
            {
#line 944
            fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%s:\n",
                    symb->name);
            }
          }
          while_break___11: /* CIL Label */ ;
          }
        }
      }
      {
#line 947
      sf = 1;
#line 950
      pci = disassemble();
      }
#line 951
      if (pci == 0) {
#line 951
        goto while_break___10;
      }
#line 954
      if (a_address) {
        {
#line 955
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t\t;%04x",
                pc);
        }
      } else
#line 954
      if (a_source) {
        {
#line 955
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t\t;%04x",
                pc);
        }
      }
#line 958
      if (a_source) {
        {
#line 960
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t");
#line 961
        i = 0;
        }
        {
#line 961
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 961
          if (! (i < pci)) {
#line 961
            goto while_break___12;
          }
          {
#line 962
          fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%02x ",
                  t[i]);
#line 961
          i ++;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 965
        fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\t");
#line 966
        i = 0;
        }
        {
#line 966
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 966
          if (! (i < pci)) {
#line 966
            goto while_break___13;
          }
#line 967
          if (t[i] >= 32) {
#line 967
            if (t[i] < 128) {
              {
#line 968
              fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"%c ",
                      t[i]);
              }
            } else {
              {
#line 970
              fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)". ");
              }
            }
          } else {
            {
#line 970
            fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)". ");
            }
          }
#line 966
          i ++;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      {
#line 974
      fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n");
#line 976
      i = 0;
      }
      {
#line 976
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 976
        if (! (i < pci)) {
#line 976
          goto while_break___14;
        }
        {
#line 976
        shiftin();
#line 976
        i ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
#line 977
      pc += (unsigned int )pci;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 979
    sf = 0;
#line 930
    tmp___12 = blk_iterate();
    }
#line 930
    if (! tmp___12) {
#line 930
      goto while_break___8;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 982
  fclose(f1);
  }
#line 984
  if (a_zilog) {
    {
#line 985
    fprintf((FILE */* __restrict  */)fx, (char const   */* __restrict  */)"\n\tend\n");
    }
  }
#line 988
  if (f_z80) {
    {
#line 989
    msg(0, "Warning: Code might not be 8080 compatible!\n");
    }
  }
#line 991
  if (f_smc) {
    {
#line 992
    msg(0, "Warning: Self modifying code detected!\n");
    }
  }
#line 994
  if (a_output) {
    {
#line 995
    fclose(f3);
    }
  }
  {
#line 997
  exit(0);
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int a_address  =    0;
#line 26 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int a_labels  =    0;
#line 27 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int a_source  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int a_org  =    256;
#line 29 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int a_zilog  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int a_verbosity  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
char *a_output  =    (char *)((void *)0);
#line 34 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
char *a_input  =    (char *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
char *a_symoutput  =    (char *)((void *)0);
#line 37 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
char *a_syminput  =    (char *)((void *)0);
#line 39 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
char *a_blockfile  =    (char *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int msg(int level , char const   *format  , ...) 
{ 
  va_list ap ;
  int r ;

  {
  {
#line 44
  r = 0;
#line 46
  __builtin_va_start(ap, format);
  }
#line 47
  if (a_verbosity >= level) {
    {
#line 48
    r = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
                 ap);
    }
  }
  {
#line 50
  __builtin_va_end(ap);
  }
#line 52
  return (r);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
void version(void) 
{ 


  {
  {
#line 57
  printf((char const   */* __restrict  */)"%s, Z80 assembly language generating disassembler %s\n",
         "z80dasm", "1.1.3");
#line 59
  printf((char const   */* __restrict  */)"Copyright (C) 1994-2007 Jan Panteltje <panteltje@yahoo.com>\n");
#line 60
  printf((char const   */* __restrict  */)"Copyright (C) 2007-2012 Tomaz Solc <tomaz.solc@tablix.org>\n\n");
#line 61
  printf((char const   */* __restrict  */)"This is free software. You may redistribute copies of it under the terms of\n");
#line 62
  printf((char const   */* __restrict  */)"the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n");
#line 63
  printf((char const   */* __restrict  */)"There is NO WARRANTY, to the extent permitted by law.\n");
#line 64
  exit(0);
  }
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
void syntax(void) 
{ 


  {
  {
#line 69
  printf((char const   */* __restrict  */)"%s, Z80 assembly language generating disassembler %s\n",
         "z80dasm", "1.1.3");
#line 71
  printf((char const   */* __restrict  */)"Usage: [options] file\n\n");
#line 73
  printf((char const   */* __restrict  */)"  -a  --address         Print the memory address of each assembly line in a\n");
#line 74
  printf((char const   */* __restrict  */)"                        comment\n");
#line 75
  printf((char const   */* __restrict  */)"  -l  --labels          Create labels for jump instructions\n");
#line 76
  printf((char const   */* __restrict  */)"  -g  --origin=ORG      Specify the starting address of the code (default 100h)\n");
#line 77
  printf((char const   */* __restrict  */)"  -t  --source          Print the corresponding binary data in hex and ASCII\n");
#line 78
  printf((char const   */* __restrict  */)"                        for each assembly line in a comment.\n");
#line 80
  printf((char const   */* __restrict  */)"  -s  --sym-output=FILE Write symbol information into FILE\n");
#line 81
  printf((char const   */* __restrict  */)"  -S  --sym-input=FILE  Read symbol information from FILE\n");
#line 82
  printf((char const   */* __restrict  */)"  -b  --block-def=FILE  Read information about code and data blocks from FILE\n");
#line 83
  printf((char const   */* __restrict  */)"  -o  --output=FILE     Print output to FILE instead of standard output\n");
#line 84
  printf((char const   */* __restrict  */)"  -h  --help            Display this help text and exit\n");
#line 85
  printf((char const   */* __restrict  */)"  -v \t\t\tIncrease verbosity\n");
#line 86
  printf((char const   */* __restrict  */)"  -V  --version         Display version information and exit\n");
#line 87
  printf((char const   */* __restrict  */)"  -z  --zilog           Use original Zilog syntax for relative jumps\n");
#line 88
  printf((char const   */* __restrict  */)"\nBug reports to <%s>\n", "tomaz.solc@tablix.org");
#line 89
  exit(0);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
int str2int(char *s , int *n ) 
{ 
  int r ;

  {
  {
#line 96
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%i",
             n);
  }
#line 97
  if (r == 1) {
#line 97
    return (0);
  }
#line 99
  return (-1);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/cmdline.c"
void cmdline(int argc , char **argv ) 
{ 
  struct option longopts[13] ;
  char opts[19] ;
  int c ;
  int r ;

  {
#line 104
  longopts[0].name = "address";
#line 104
  longopts[0].has_arg = 0;
#line 104
  longopts[0].flag = (int *)((void *)0);
#line 104
  longopts[0].val = 'a';
#line 104
  longopts[1].name = "labels";
#line 104
  longopts[1].has_arg = 0;
#line 104
  longopts[1].flag = (int *)((void *)0);
#line 104
  longopts[1].val = 'l';
#line 104
  longopts[2].name = "origin";
#line 104
  longopts[2].has_arg = 1;
#line 104
  longopts[2].flag = (int *)((void *)0);
#line 104
  longopts[2].val = 'g';
#line 104
  longopts[3].name = "reduced";
#line 104
  longopts[3].has_arg = 0;
#line 104
  longopts[3].flag = (int *)((void *)0);
#line 104
  longopts[3].val = 'r';
#line 104
  longopts[4].name = "source";
#line 104
  longopts[4].has_arg = 0;
#line 104
  longopts[4].flag = (int *)((void *)0);
#line 104
  longopts[4].val = 't';
#line 104
  longopts[5].name = "sym-output";
#line 104
  longopts[5].has_arg = 1;
#line 104
  longopts[5].flag = (int *)((void *)0);
#line 104
  longopts[5].val = 's';
#line 104
  longopts[6].name = "sym-input";
#line 104
  longopts[6].has_arg = 1;
#line 104
  longopts[6].flag = (int *)((void *)0);
#line 104
  longopts[6].val = 'S';
#line 104
  longopts[7].name = "block-def";
#line 104
  longopts[7].has_arg = 1;
#line 104
  longopts[7].flag = (int *)((void *)0);
#line 104
  longopts[7].val = 'b';
#line 104
  longopts[8].name = "output";
#line 104
  longopts[8].has_arg = 1;
#line 104
  longopts[8].flag = (int *)((void *)0);
#line 104
  longopts[8].val = 'o';
#line 104
  longopts[9].name = "help";
#line 104
  longopts[9].has_arg = 0;
#line 104
  longopts[9].flag = (int *)((void *)0);
#line 104
  longopts[9].val = 'h';
#line 104
  longopts[10].name = "version";
#line 104
  longopts[10].has_arg = 0;
#line 104
  longopts[10].flag = (int *)((void *)0);
#line 104
  longopts[10].val = 'v';
#line 104
  longopts[11].name = "zilog";
#line 104
  longopts[11].has_arg = 0;
#line 104
  longopts[11].flag = (int *)((void *)0);
#line 104
  longopts[11].val = 'z';
#line 104
  longopts[12].name = (char const   *)((void *)0);
#line 104
  longopts[12].has_arg = 0;
#line 104
  longopts[12].flag = (int *)((void *)0);
#line 104
  longopts[12].val = 0;
#line 119
  opts[0] = (char )'a';
#line 119
  opts[1] = (char )'l';
#line 119
  opts[2] = (char )'g';
#line 119
  opts[3] = (char )':';
#line 119
  opts[4] = (char )'r';
#line 119
  opts[5] = (char )'t';
#line 119
  opts[6] = (char )'S';
#line 119
  opts[7] = (char )':';
#line 119
  opts[8] = (char )'s';
#line 119
  opts[9] = (char )':';
#line 119
  opts[10] = (char )'o';
#line 119
  opts[11] = (char )':';
#line 119
  opts[12] = (char )'h';
#line 119
  opts[13] = (char )'V';
#line 119
  opts[14] = (char )'v';
#line 119
  opts[15] = (char )'z';
#line 119
  opts[16] = (char )'b';
#line 119
  opts[17] = (char )':';
#line 119
  opts[18] = (char )'\000';
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    c = getopt_long(argc, (char * const  *)argv, (char const   *)(opts), (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
#line 122
    if (! (c != -1)) {
#line 122
      goto while_break;
    }
    {
#line 124
    if (c == 97) {
#line 124
      goto case_97;
    }
#line 126
    if (c == 108) {
#line 126
      goto case_108;
    }
#line 128
    if (c == 103) {
#line 128
      goto case_103;
    }
#line 136
    if (c == 116) {
#line 136
      goto case_116;
    }
#line 138
    if (c == 115) {
#line 138
      goto case_115;
    }
#line 140
    if (c == 83) {
#line 140
      goto case_83;
    }
#line 142
    if (c == 98) {
#line 142
      goto case_98;
    }
#line 144
    if (c == 122) {
#line 144
      goto case_122;
    }
#line 146
    if (c == 111) {
#line 146
      goto case_111;
    }
#line 148
    if (c == 86) {
#line 148
      goto case_86;
    }
#line 150
    if (c == 118) {
#line 150
      goto case_118;
    }
#line 152
    if (c == 104) {
#line 152
      goto case_104;
    }
#line 154
    goto switch_default;
    case_97: /* CIL Label */ 
#line 124
    a_address = 1;
#line 125
    goto switch_break;
    case_108: /* CIL Label */ 
#line 126
    a_labels = 1;
#line 127
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 128
    r = str2int(optarg, & a_org);
    }
#line 129
    if (r) {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s not an integer\n",
              optarg);
#line 133
      exit(1);
      }
    }
#line 135
    goto switch_break;
    case_116: /* CIL Label */ 
#line 136
    a_source = 1;
#line 137
    goto switch_break;
    case_115: /* CIL Label */ 
#line 138
    a_symoutput = optarg;
#line 139
    goto switch_break;
    case_83: /* CIL Label */ 
#line 140
    a_syminput = optarg;
#line 141
    goto switch_break;
    case_98: /* CIL Label */ 
#line 142
    a_blockfile = optarg;
#line 143
    goto switch_break;
    case_122: /* CIL Label */ 
#line 144
    a_zilog = 1;
#line 145
    goto switch_break;
    case_111: /* CIL Label */ 
#line 146
    a_output = optarg;
#line 147
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 148
    version();
    }
#line 149
    goto switch_break;
    case_118: /* CIL Label */ 
#line 150
    a_verbosity ++;
#line 151
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 152
    syntax();
    }
#line 153
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 154
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if (optind < argc - 1) {
    {
#line 159
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Only one input file supported\n");
    }
  }
#line 162
  if (optind < argc) {
#line 163
    a_input = *(argv + optind);
  }
#line 165
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.h"
struct symbol *symbols ;
#line 78
struct symbol *symbol_new(char *name , int val , int weight , int included ) ;
#line 86
void symbol_export_includes(FILE *f ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbols  =    (struct symbol *)((void *)0);
#line 28 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
void symbol_remove(struct symbol *symb ) 
{ 
  struct reference *ref ;
  struct reference *refn ;

  {
  {
#line 32
  msg(2, "Debug: removing symbol \'%s\' with value 0x%04x\n", symb->name, symb->val);
#line 35
  ref = symb->ref;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )ref != (unsigned long )((void *)0))) {
#line 36
      goto while_break;
    }
    {
#line 37
    refn = ref->next;
#line 38
    free((void *)ref);
#line 39
    ref = refn;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  free((void *)symb->name);
  }
#line 44
  if ((unsigned long )symb->prev != (unsigned long )((void *)0)) {
#line 45
    (symb->prev)->next = symb->next;
  } else {
#line 47
    symbols = symb->next;
  }
#line 50
  if ((unsigned long )symb->next != (unsigned long )((void *)0)) {
#line 51
    (symb->next)->prev = symb->prev;
  }
  {
#line 54
  free((void *)symb);
  }
#line 55
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbol_find(int val ) 
{ 
  struct symbol *cur ;

  {
#line 61
  cur = symbols;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 62
      goto while_break;
    }
#line 63
    if (cur->val == val) {
#line 64
      return (cur);
    }
#line 66
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return ((struct symbol *)((void *)0));
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbol_find_next(int val , struct symbol *cur ) 
{ 


  {
#line 74
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 75
    cur = symbols;
  } else {
#line 77
    cur = cur->next;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 80
      goto while_break;
    }
#line 81
    if (cur->val == val) {
#line 82
      return (cur);
    }
#line 84
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return ((struct symbol *)((void *)0));
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
int symbol_compare(struct symbol *a , struct symbol *b ) 
{ 


  {
#line 92
  if (a->val > b->val) {
#line 93
    return (1);
  } else
#line 94
  if (a->val < b->val) {
#line 95
    return (-1);
  }
#line 98
  if (a->weight > b->weight) {
#line 99
    return (1);
  } else
#line 100
  if (a->weight < b->weight) {
#line 101
    return (-1);
  }
#line 104
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
void symbol_find_place(struct symbol *new , struct symbol **prev , struct symbol **next ) 
{ 
  struct symbol *cur ;
  int tmp ;

  {
#line 114
  *prev = (struct symbol *)((void *)0);
#line 115
  cur = symbols;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 117
    *next = cur;
#line 118
    tmp = symbol_compare(cur, new);
    }
#line 118
    if (tmp > 0) {
#line 119
      return;
    }
#line 121
    *prev = cur;
#line 122
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  *next = (struct symbol *)((void *)0);
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbol_find_inrange(int val , int range ) 
{ 
  struct symbol *cur ;

  {
#line 133
  cur = symbols;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 134
      goto while_break;
    }
#line 135
    if (val <= cur->val) {
#line 135
      if (val + range > cur->val) {
#line 136
        return (cur);
      }
    }
#line 138
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return ((struct symbol *)((void *)0));
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbol_find_range(int val ) 
{ 
  struct symbol *cur ;

  {
#line 148
  cur = symbols;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 149
      goto while_break;
    }
#line 150
    if (cur->val <= val) {
#line 150
      if (cur->val + cur->range > val) {
#line 151
        return (cur);
      }
    }
#line 153
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return ((struct symbol *)((void *)0));
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbol_new(char *name , int val , int weight , int included ) 
{ 
  struct symbol *prev ;
  struct symbol *next ;
  struct symbol *dest ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 164
  msg(2, "Debug: defining new symbol \'%s\' with value 0x%04x\n", name, val);
#line 167
  dest = symbol_find(val);
  }
#line 168
  if ((unsigned long )dest != (unsigned long )((void *)0)) {
    {
#line 169
    tmp = strcmp((char const   *)name, (char const   *)dest->name);
    }
#line 169
    if (! tmp) {
#line 169
      return ((struct symbol *)((void *)0));
    }
  }
  {
#line 176
  tmp___0 = calloc((size_t )1, sizeof(*dest));
#line 176
  dest = (struct symbol *)tmp___0;
  }
#line 177
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 177
    return ((struct symbol *)((void *)0));
  }
  {
#line 179
  dest->name = strdup((char const   *)name);
#line 180
  dest->val = val;
#line 181
  dest->weight = weight;
#line 183
  dest->automatic = 0;
#line 184
  dest->range = 1;
#line 185
  dest->included = included;
#line 186
  dest->label = 0;
#line 188
  symbol_find_place(dest, & prev, & next);
#line 190
  dest->prev = prev;
#line 191
  dest->next = next;
  }
#line 193
  if ((unsigned long )next != (unsigned long )((void *)0)) {
#line 194
    next->prev = dest;
  }
#line 196
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 197
    prev->next = dest;
  } else {
#line 199
    symbols = dest;
  }
#line 202
  dest->ref = (struct reference *)((void *)0);
#line 204
  return (dest);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
struct symbol *symbol_newref(int val , int addr , enum referencetype type ) 
{ 
  struct symbol *dest ;
  struct reference *r ;
  char name[10] ;
  void *tmp ;

  {
  {
#line 215
  dest = symbol_find(val);
  }
#line 217
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 218
    if ((unsigned int )type == 4U) {
      {
#line 219
      sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"sub_%04xh",
              val);
      }
    } else {
      {
#line 221
      sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"l%04xh",
              val);
      }
    }
    {
#line 224
    dest = symbol_new(name, val, 50, 0);
#line 226
    dest->automatic = 1;
    }
  }
  {
#line 229
  tmp = calloc((size_t )1, sizeof(*r));
#line 229
  r = (struct reference *)tmp;
#line 231
  r->addr = addr;
#line 232
  r->type = type;
#line 234
  r->next = dest->ref;
#line 235
  dest->ref = r;
  }
#line 237
  return (dest);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
int symbol_setlabel(int val , int range ) 
{ 
  struct symbol *dest ;

  {
  {
#line 244
  dest = symbol_find(val);
  }
#line 245
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 245
    return (1);
  }
#line 247
  dest->range = range;
#line 248
  dest->label = 1;
#line 250
  return (0);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
void symbol_remove_nonlabels(void) 
{ 
  struct symbol *symb ;
  struct symbol *symbn ;

  {
#line 257
  symb = symbols;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! ((unsigned long )symb != (unsigned long )((void *)0))) {
#line 258
      goto while_break;
    }
#line 259
    symbn = symb->next;
#line 261
    if (! symb->label) {
#line 261
      if (symb->automatic) {
        {
#line 262
        symbol_remove(symb);
        }
      }
    }
#line 265
    symb = symbn;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
int symbol_export_nonlabels(FILE *f ) 
{ 
  struct symbol *cur ;

  {
#line 273
  cur = symbols;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 274
      goto while_break;
    }
#line 275
    if (! cur->label) {
#line 275
      if ((unsigned long )cur->ref != (unsigned long )((void *)0)) {
        {
#line 276
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s:\tequ 0x%04x\n",
                cur->name, cur->val);
        }
      }
    }
#line 278
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (0);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.c"
int symbol_export(FILE *f ) 
{ 
  struct symbol *cur ;
  struct reference *r ;

  {
  {
#line 289
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"; Symbol file\n\n");
#line 291
  symbol_export_includes(f);
#line 293
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 295
  cur = symbols;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 296
      goto while_break;
    }
#line 297
    if (cur->included) {
#line 298
      cur = cur->next;
#line 299
      goto while_continue;
    }
#line 302
    if ((unsigned long )cur->comment != (unsigned long )((void *)0)) {
      {
#line 303
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", cur->comment);
      }
    }
    {
#line 306
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s:\tequ 0x%04x\n",
            cur->name, cur->val);
#line 307
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"; Used at following locations:\n");
#line 309
    r = cur->ref;
    }
    {
#line 310
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 310
      if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 310
        goto while_break___0;
      }
      {
#line 311
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"; 0x%04x\t",
              r->addr);
      }
      {
#line 313
      if ((unsigned int )r->type == 0U) {
#line 313
        goto case_0;
      }
#line 316
      if ((unsigned int )r->type == 1U) {
#line 316
        goto case_1;
      }
#line 319
      if ((unsigned int )r->type == 2U) {
#line 319
        goto case_2;
      }
#line 322
      if ((unsigned int )r->type == 3U) {
#line 322
        goto case_3;
      }
#line 325
      if ((unsigned int )r->type == 4U) {
#line 325
        goto case_4;
      }
#line 328
      if ((unsigned int )r->type == 5U) {
#line 328
        goto case_5;
      }
#line 331
      if ((unsigned int )r->type == 6U) {
#line 331
        goto case_6;
      }
#line 334
      if ((unsigned int )r->type == 7U) {
#line 334
        goto case_7;
      }
#line 337
      if ((unsigned int )r->type == 8U) {
#line 337
        goto case_8;
      }
#line 312
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 314
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(unknown)");
      }
#line 315
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 317
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(jp destination)");
      }
#line 318
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 320
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(jr destination)");
      }
#line 321
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 323
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(djnz destination)");
      }
#line 324
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 326
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(call destination)");
      }
#line 327
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 329
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(byte load pointer)");
      }
#line 330
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 332
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(word load pointer)");
      }
#line 333
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 335
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(immediate value)");
      }
#line 336
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 338
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(defw directive)");
      }
#line 339
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 341
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 342
      r = r->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 344
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 346
    cur = cur->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (1);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symtab.h"
int symbol_load_line(char *line , char **name , int *val , int level ) ;
#line 1 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/utils.h"
int split_line(char *line , char **array , int maxlen , char *delimiters ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
char *include[128]  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
int includenum  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
void symbol_export_includes(FILE *f ) 
{ 
  int n ;

  {
#line 33
  n = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (n < includenum)) {
#line 33
      goto while_break;
    }
    {
#line 34
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"include \"%s\"\n",
            include[n]);
#line 33
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
void symbol_free_includes(void) 
{ 
  int n ;

  {
#line 42
  n = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (n < includenum)) {
#line 42
      goto while_break;
    }
    {
#line 43
    free((void *)include[n]);
#line 42
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  includenum = 0;
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
int symbol_load_file(char *filename , int level ) 
{ 
  FILE *f ;
  char line[1024] ;
  int r ;
  int val ;
  int lineno ;
  char *name ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 58
  if (level == 1) {
#line 59
    if (includenum >= 128) {
      {
#line 60
      msg(0, "Error: Too many include directives\n");
      }
#line 61
      return (-1);
    }
    {
#line 64
    include[includenum] = strdup((char const   *)filename);
#line 65
    includenum ++;
    }
  } else
#line 66
  if (level > 128) {
    {
#line 67
    msg(0, "Error: Too many nested include directives\n");
    }
#line 68
    return (-1);
  }
  {
#line 71
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 72
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 73
    tmp = __errno_location();
#line 73
    tmp___0 = strerror(*tmp);
#line 73
    msg(0, "Error: Cannot open \'%s\': %s\n", filename, tmp___0);
    }
#line 75
    return (-1);
  }
#line 78
  lineno = 1;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___1 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)f);
    }
#line 79
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
    {
#line 80
    r = symbol_load_line(line, & name, & val, level);
    }
#line 81
    if (r < 0) {
      {
#line 82
      msg(0, "       at line %d of \'%s\'\n", lineno, filename);
#line 83
      fclose(f);
      }
#line 84
      return (-1);
    }
#line 87
    if (r == 1) {
      {
#line 88
      symbol_new(name, val, 50, level != 0);
#line 89
      free((void *)name);
      }
    }
#line 92
    lineno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  fclose(f);
  }
#line 96
  return (0);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
int symbol_include_d(char *param , int level ) 
{ 
  char *filename ;
  int error ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 104
  error = 0;
#line 106
  tmp = strlen((char const   *)param);
  }
#line 106
  if (tmp < 3UL) {
#line 107
    error = 1;
  }
#line 110
  if ((int )*(param + 0) != 34) {
#line 111
    error = 1;
  } else {
    {
#line 110
    tmp___0 = strlen((char const   *)param);
    }
#line 110
    if ((int )*(param + (tmp___0 - 1UL)) != 34) {
#line 111
      error = 1;
    }
  }
#line 114
  if (error) {
    {
#line 115
    msg(0, "Error: File name expected after \'include\' directive\n");
    }
#line 117
    return (-1);
  }
  {
#line 120
  tmp___1 = strlen((char const   *)param);
#line 120
  *(param + (tmp___1 - 1UL)) = (char)0;
#line 121
  filename = param + 1;
#line 123
  tmp___2 = symbol_load_file(filename, level + 1);
  }
#line 123
  return (tmp___2);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/symload.c"
int symbol_load_line(char *line , char **name , int *val , int level ) 
{ 
  int r ;
  char *linec ;
  char *named ;
  int vald ;
  char *tokens[3] ;
  int num_tokens ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 148
  if ((int )*(line + 0) == 59) {
#line 149
    return (0);
  } else {
    {
#line 151
    linec = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)";");
    }
  }
#line 154
  if ((unsigned long )linec == (unsigned long )((void *)0)) {
#line 154
    return (0);
  }
  {
#line 156
  num_tokens = split_line(line, tokens, 3, (char *)" \t\r\n");
  }
#line 158
  if (num_tokens == 0) {
#line 158
    return (0);
  }
#line 160
  if (num_tokens == -1) {
    {
#line 162
    msg(0, "Error: Syntax error\n");
    }
#line 163
    return (-1);
  }
  {
#line 166
  tmp___0 = strcmp((char const   *)tokens[0], "include");
  }
#line 166
  if (! tmp___0) {
#line 167
    if (num_tokens < 2) {
      {
#line 168
      msg(0, "Error: File name expected after \'include\' directive\n");
      }
#line 170
      return (-1);
    }
    {
#line 172
    tmp = symbol_include_d(tokens[1], level);
    }
#line 172
    return (tmp);
  }
  {
#line 177
  named = tokens[0];
#line 179
  tmp___1 = strlen((char const   *)named);
  }
#line 179
  if ((int )*(named + (tmp___1 - 1UL)) != 58) {
    {
#line 181
    msg(0, "Error: \':\' expected after symbol name \'%s\'\n", named);
    }
#line 182
    return (-1);
  }
  {
#line 185
  tmp___2 = strlen((char const   *)named);
#line 185
  *(named + (tmp___2 - 1UL)) = (char)0;
  }
#line 187
  if (num_tokens < 3) {
    {
#line 188
    msg(0, "Error: \'equ symbol_value\' expected after label name \'%s\'\n", named);
    }
#line 190
    return (-1);
  }
  {
#line 193
  tmp___3 = strcmp((char const   *)tokens[1], "equ");
  }
#line 193
  if (tmp___3) {
    {
#line 194
    msg(0, "Error: \'equ\' expected after label name \'%s\'\n", named);
    }
#line 195
    return (-1);
  }
  {
#line 198
  r = sscanf((char const   */* __restrict  */)tokens[2], (char const   */* __restrict  */)"%i",
             & vald);
  }
#line 199
  if (r != 1) {
    {
#line 200
    msg(0, "Error: Invalid symbol value \'%s\'\n", tokens[2]);
    }
#line 201
    return (-1);
  }
  {
#line 204
  *name = strdup((char const   *)named);
#line 205
  *val = vald;
  }
#line 207
  return (1);
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/utils.c"
int split_line(char *line , char **array , int maxlen , char *delimiters ) 
{ 
  char *tok ;
  int numtok ;

  {
#line 18
  numtok = 0;
#line 20
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 22
    return (0);
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (numtok == 0) {
      {
#line 27
      tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)delimiters);
      }
    } else {
      {
#line 29
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)delimiters);
      }
    }
#line 32
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 33
      return (numtok);
    }
#line 36
    if (numtok >= maxlen) {
#line 36
      return (-1);
    }
#line 38
    *(array + numtok) = tok;
#line 39
    numtok ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/utils.c"
size_t file_len(char *path ) 
{ 
  struct stat st ;

  {
  {
#line 48
  stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 50
  return ((size_t )st.st_size);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/table.c"
int tosymtab(int *ia , unsigned int prc ) 
{ 
  unsigned int argval ;
  enum referencetype argtyp ;

  {
#line 38
  argtyp = (enum referencetype )0;
#line 39
  if (*(ia + 0) == 50) {
#line 43
    argtyp = (enum referencetype )5;
#line 44
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 39
  if (*(ia + 0) == 58) {
#line 43
    argtyp = (enum referencetype )5;
#line 44
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 46
  if (*(ia + 0) == 34) {
#line 50
    argtyp = (enum referencetype )6;
#line 51
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 46
  if (*(ia + 0) == 42) {
#line 50
    argtyp = (enum referencetype )6;
#line 51
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 53
  if (*(ia + 0) == 237) {
#line 55
    if (*(ia + 1) == 67) {
#line 64
      argtyp = (enum referencetype )6;
#line 65
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    } else
#line 55
    if (*(ia + 1) == 75) {
#line 64
      argtyp = (enum referencetype )6;
#line 65
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    } else
#line 55
    if (*(ia + 1) == 83) {
#line 64
      argtyp = (enum referencetype )6;
#line 65
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    } else
#line 55
    if (*(ia + 1) == 91) {
#line 64
      argtyp = (enum referencetype )6;
#line 65
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    } else
#line 55
    if (*(ia + 1) == 115) {
#line 64
      argtyp = (enum referencetype )6;
#line 65
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    } else
#line 55
    if (*(ia + 1) == 123) {
#line 64
      argtyp = (enum referencetype )6;
#line 65
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    }
  } else
#line 68
  if (*(ia + 0) == 221) {
#line 68
    goto _L___0;
  } else
#line 68
  if (*(ia + 0) == 253) {
    _L___0: /* CIL Label */ 
#line 70
    if (*(ia + 1) == 34) {
#line 76
      argtyp = (enum referencetype )6;
#line 77
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    } else
#line 70
    if (*(ia + 1) == 42) {
#line 76
      argtyp = (enum referencetype )6;
#line 77
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    }
#line 79
    if (*(ia + 1) == 33) {
#line 83
      argtyp = (enum referencetype )7;
#line 84
      argval = (unsigned int )(*(ia + 2) + 256 * *(ia + 3));
    }
  } else
#line 87
  if (*(ia + 0) == 218) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 250) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 210) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 195) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 194) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 242) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 234) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 226) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 87
  if (*(ia + 0) == 202) {
#line 91
    argtyp = (enum referencetype )1;
#line 92
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 95
  if (*(ia + 0) == 56) {
#line 95
    goto _L;
  } else
#line 95
  if (*(ia + 0) == 24) {
#line 95
    goto _L;
  } else
#line 95
  if (*(ia + 0) == 48) {
#line 95
    goto _L;
  } else
#line 95
  if (*(ia + 0) == 32) {
#line 95
    goto _L;
  } else
#line 95
  if (*(ia + 0) == 40) {
    _L: /* CIL Label */ 
#line 98
    argtyp = (enum referencetype )2;
#line 99
    argval = (prc + (unsigned int )*(ia + 1)) + 2U;
#line 100
    if (*(ia + 1) >= 128) {
#line 100
      argval -= 256U;
    }
  } else
#line 102
  if (*(ia + 0) == 220) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 252) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 212) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 205) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 196) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 244) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 244) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 236) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 228) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 102
  if (*(ia + 0) == 204) {
#line 106
    argtyp = (enum referencetype )4;
#line 107
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 109
  if (*(ia + 0) == 49) {
#line 112
    argtyp = (enum referencetype )7;
#line 113
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 109
  if (*(ia + 0) == 1) {
#line 112
    argtyp = (enum referencetype )7;
#line 113
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 109
  if (*(ia + 0) == 17) {
#line 112
    argtyp = (enum referencetype )7;
#line 113
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 109
  if (*(ia + 0) == 33) {
#line 112
    argtyp = (enum referencetype )7;
#line 113
    argval = (unsigned int )(*(ia + 1) + 256 * *(ia + 2));
  } else
#line 115
  if (*(ia + 0) == 16) {
#line 118
    argtyp = (enum referencetype )3;
#line 119
    argval = (prc + (unsigned int )*(ia + 1)) + 2U;
#line 120
    if (*(ia + 1) >= 128) {
#line 120
      argval -= 256U;
    }
  }
#line 123
  if ((unsigned int )argtyp == 0U) {
#line 124
    return (1);
  } else {
    {
#line 126
    symbol_newref((int )(argval & 65535U), (int )prc, argtyp);
    }
  }
#line 129
  return (1);
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.h"
struct block *block_new(char *name , int start , int end , enum blocktype type ) ;
#line 43
int block_load_line(char *line , char **name , int *start , int *end , enum blocktype *type ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
struct block *blocks  =    (struct block *)((void *)0);
#line 31 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
int block_init(int start , int end ) 
{ 
  struct block *dest ;
  void *tmp ;

  {
  {
#line 35
  tmp = calloc((size_t )1, sizeof(*dest));
#line 35
  dest = (struct block *)tmp;
  }
#line 36
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 36
    return (-1);
  }
  {
#line 38
  dest->start = start;
#line 39
  dest->end = end;
#line 41
  dest->type = (enum blocktype )0;
#line 43
  dest->prev = (struct block *)((void *)0);
#line 44
  dest->next = (struct block *)((void *)0);
#line 46
  dest->name = strdup("DEFAULT");
#line 48
  blocks = dest;
  }
#line 50
  return (0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
struct block *block_find(int addr ) 
{ 
  struct block *cur ;

  {
#line 57
  cur = blocks;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 58
      goto while_break;
    }
#line 59
    if (cur->start <= addr) {
#line 59
      if (cur->end > addr) {
#line 60
        return (cur);
      }
    }
#line 62
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return ((struct block *)((void *)0));
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
struct block *block_dup(struct block *src ) 
{ 
  struct block *dest ;
  void *tmp ;

  {
  {
#line 71
  tmp = malloc(sizeof(*dest));
#line 71
  dest = (struct block *)tmp;
  }
#line 72
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 72
    return ((struct block *)((void *)0));
  }
  {
#line 74
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, sizeof(*dest));
#line 76
  dest->name = strdup((char const   *)src->name);
  }
#line 78
  return (dest);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
static struct block *block_new_insert(char *name , int start , int end ) 
{ 
  struct block *parent ;
  struct block *parent2 ;
  struct block *dest ;
  struct block *tmp ;
  void *tmp___0 ;

  {
  {
#line 93
  parent = block_find(start);
  }
#line 95
  if ((unsigned long )parent == (unsigned long )((void *)0)) {
    {
#line 96
    msg(0, "Error: Block defined outside of address space covered by binary data.\n");
    }
#line 98
    return ((struct block *)((void *)0));
  }
  {
#line 101
  tmp = block_find(end - 1);
  }
#line 101
  if ((unsigned long )tmp != (unsigned long )parent) {
    {
#line 102
    msg(0, "Error: New block overlaps with two or more blocks.\n");
#line 103
    msg(0, "       This case isn\'t supported.\n");
    }
#line 104
    return ((struct block *)((void *)0));
  }
#line 109
  if (start == parent->start) {
#line 109
    if (end == parent->end) {
      {
#line 110
      msg(0, "Warning: Block \'%s\' overlaps completely with \'%s\'.\n", name, parent->name);
#line 113
      free((void *)parent->name);
#line 114
      parent->name = strdup((char const   *)name);
      }
#line 115
      return (parent);
    }
  }
  {
#line 118
  tmp___0 = calloc((size_t )1, sizeof(*dest));
#line 118
  dest = (struct block *)tmp___0;
  }
#line 119
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 119
    return ((struct block *)((void *)0));
  }
  {
#line 121
  dest->name = strdup((char const   *)name);
#line 122
  dest->start = start;
#line 123
  dest->end = end;
  }
#line 125
  if (start == parent->start) {
#line 131
    parent->start = dest->end;
#line 133
    dest->prev = parent->prev;
#line 134
    dest->next = parent;
#line 136
    if ((unsigned long )parent->prev != (unsigned long )((void *)0)) {
#line 137
      (parent->prev)->next = dest;
    } else {
#line 139
      blocks = dest;
    }
#line 142
    parent->prev = dest;
  } else
#line 144
  if (end == parent->end) {
#line 150
    parent->end = dest->start;
#line 152
    dest->prev = parent;
#line 153
    dest->next = parent->next;
#line 155
    if ((unsigned long )parent->next != (unsigned long )((void *)0)) {
#line 156
      (parent->next)->prev = dest;
    }
#line 159
    parent->next = dest;
  } else {
    {
#line 163
    parent2 = block_dup(parent);
#line 168
    parent->end = dest->start;
#line 169
    parent2->start = dest->end;
#line 171
    parent->next = dest;
#line 173
    dest->prev = parent;
#line 174
    dest->next = parent2;
#line 176
    parent2->prev = dest;
    }
  }
#line 179
  return (dest);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
struct block *block_new(char *name , int start , int end , enum blocktype type ) 
{ 
  struct block *dest ;
  struct symbol *symb ;
  char tmp[1024] ;

  {
  {
#line 188
  msg(2, "Debug: defining new block \'%s\' (start 0x%04x end 0x%04x)\n", name, start,
      end);
#line 191
  dest = block_new_insert(name, start, end);
  }
#line 192
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
#line 192
    return ((struct block *)((void *)0));
  }
  {
#line 194
  snprintf((char */* __restrict  */)(tmp), (size_t )1024, (char const   */* __restrict  */)"%s_start",
           name);
#line 195
  symb = symbol_new(tmp, start, 100, 0);
#line 197
  snprintf((char */* __restrict  */)(tmp), (size_t )1024, (char const   */* __restrict  */)"\n; BLOCK \'%s\' (start 0x%04x end 0x%04x)\n",
           name, start, end);
#line 200
  symb->comment = strdup((char const   *)(tmp));
#line 202
  snprintf((char */* __restrict  */)(tmp), (size_t )1024, (char const   */* __restrict  */)"%s_end",
           name);
#line 203
  symbol_new(tmp, end, 0, 0);
#line 205
  dest->type = type;
  }
#line 207
  return (dest);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
int block_load_file(char *filename ) 
{ 
  FILE *f ;
  char line[1024] ;
  int r ;
  int start ;
  int end ;
  enum blocktype type ;
  int lineno ;
  char *name ;
  struct block *blk ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 223
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 224
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 225
    tmp = __errno_location();
#line 225
    tmp___0 = strerror(*tmp);
#line 225
    msg(0, "Error: Cannot open \'%s\': %s\n", filename, tmp___0);
    }
#line 227
    return (-1);
  }
#line 230
  lineno = 1;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 231
    tmp___1 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)f);
    }
#line 231
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 231
      goto while_break;
    }
    {
#line 232
    r = block_load_line(line, & name, & start, & end, & type);
    }
#line 233
    if (r < 0) {
      {
#line 234
      msg(0, "       at line %d of \'%s\'\n", lineno, filename);
#line 235
      fclose(f);
      }
#line 236
      return (-1);
    }
#line 239
    if (r == 1) {
      {
#line 240
      blk = block_new(name, start, end, type);
      }
#line 241
      if ((unsigned long )blk == (unsigned long )((void *)0)) {
        {
#line 242
        msg(0, "       at line %d of \'%s\'\n", lineno, filename);
#line 244
        fclose(f);
        }
#line 245
        return (-1);
      }
      {
#line 247
      free((void *)name);
      }
    }
#line 250
    lineno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  fclose(f);
  }
#line 254
  return (0);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/blocks.c"
int block_load_line(char *line , char **name , int *start , int *end , enum blocktype *type ) 
{ 
  int r ;
  char *linec ;
  char *tok ;
  char *named ;
  int startd ;
  int endd ;
  int typed ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 271
  if ((int )*(line + 0) == 59) {
#line 272
    return (0);
  } else {
    {
#line 274
    linec = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)";");
    }
  }
#line 277
  if ((unsigned long )linec == (unsigned long )((void *)0)) {
#line 277
    return (0);
  }
  {
#line 281
  tok = strtok((char */* __restrict  */)linec, (char const   */* __restrict  */)" \t\r\n");
  }
#line 283
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 283
    return (0);
  }
  {
#line 285
  tmp = strlen((char const   *)tok);
  }
#line 285
  if ((int )*(tok + (tmp - 1UL)) != 58) {
    {
#line 286
    msg(0, "Error: \':\' expected after block name \'%s\'\n", tok);
    }
#line 288
    return (-1);
  }
  {
#line 291
  tmp___0 = strlen((char const   *)tok);
#line 291
  *(tok + (tmp___0 - 1UL)) = (char)0;
#line 292
  named = tok;
#line 294
  tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
  }
#line 296
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    {
#line 297
    msg(0, "Error: \'start\' expected\n");
    }
#line 298
    return (-1);
  } else {
    {
#line 296
    tmp___1 = strcasecmp((char const   *)tok, "start");
    }
#line 296
    if (tmp___1) {
      {
#line 297
      msg(0, "Error: \'start\' expected\n");
      }
#line 298
      return (-1);
    }
  }
  {
#line 301
  tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
  }
#line 303
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    {
#line 304
    msg(0, "Error: Start address expected\n");
    }
#line 305
    return (-1);
  }
  {
#line 308
  r = sscanf((char const   */* __restrict  */)tok, (char const   */* __restrict  */)"%i",
             & startd);
  }
#line 309
  if (r != 1) {
    {
#line 310
    msg(0, "Error: Invalid start address \'%s\'\n", tok);
    }
#line 311
    return (-1);
  }
  {
#line 314
  tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
  }
#line 316
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    {
#line 317
    msg(0, "Error: \'end\' expected\n");
    }
#line 318
    return (-1);
  } else {
    {
#line 316
    tmp___2 = strcasecmp((char const   *)tok, "end");
    }
#line 316
    if (tmp___2) {
      {
#line 317
      msg(0, "Error: \'end\' expected\n");
      }
#line 318
      return (-1);
    }
  }
  {
#line 321
  tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
  }
#line 323
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    {
#line 324
    msg(0, "Error: End address expected\n");
    }
#line 325
    return (-1);
  }
  {
#line 328
  r = sscanf((char const   */* __restrict  */)tok, (char const   */* __restrict  */)"%i",
             & endd);
  }
#line 329
  if (r != 1) {
    {
#line 330
    msg(0, "Error: Invalid end address \'%s\'\n", tok);
    }
#line 331
    return (-1);
  } else
#line 329
  if (endd <= startd) {
    {
#line 330
    msg(0, "Error: Invalid end address \'%s\'\n", tok);
    }
#line 331
    return (-1);
  }
  {
#line 334
  tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
  }
#line 336
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    {
#line 337
    msg(0, "Error: \'type\' expected\n");
    }
#line 338
    return (-1);
  } else {
    {
#line 336
    tmp___3 = strcasecmp((char const   *)tok, "type");
    }
#line 336
    if (tmp___3) {
      {
#line 337
      msg(0, "Error: \'type\' expected\n");
      }
#line 338
      return (-1);
    }
  }
  {
#line 341
  tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
  }
#line 343
  if ((unsigned long )tok == (unsigned long )((void *)0)) {
    {
#line 344
    msg(0, "Error: Block type expected\n");
    }
#line 345
    return (-1);
  }
  {
#line 348
  tmp___7 = strcmp((char const   *)tok, "code");
  }
#line 348
  if (tmp___7) {
    {
#line 350
    tmp___6 = strcmp((char const   *)tok, "bytedata");
    }
#line 350
    if (tmp___6) {
      {
#line 352
      tmp___5 = strcmp((char const   *)tok, "worddata");
      }
#line 352
      if (tmp___5) {
        {
#line 354
        tmp___4 = strcmp((char const   *)tok, "pointers");
        }
#line 354
        if (tmp___4) {
          {
#line 357
          msg(0, "Error: Invalid block type \'%s\'\n", tok);
          }
#line 358
          return (-1);
        } else {
#line 355
          typed = 3;
        }
      } else {
#line 353
        typed = 2;
      }
    } else {
#line 351
      typed = 1;
    }
  } else {
#line 349
    typed = 0;
  }
  {
#line 361
  *name = strdup((char const   *)named);
#line 362
  *start = startd;
#line 363
  *end = endd;
#line 364
  *type = (enum blocktype )typed;
  }
#line 366
  return (1);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *rarg[8]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
  {      "b",      "c",      "d",      "e", 
        "h",      "l",      "(hl)",      "a"};
#line 8 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
struct comm  const  comtab[256]  = 
#line 8
  {      {(char *)"nop", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld bc,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ld (bc),a", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc bc", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc b", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rlca", (char *)"vv", 1, 0, 0}, 
        {(char *)"ex af,af\'", (char *)"vv", 1, 0, 1}, 
        {(char *)"add hl,bc", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,(bc)", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec bc", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc c", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rrca", (char *)"vv", 1, 0, 0}, 
        {(char *)"djnz ", (char *)"vv", 2, 3, 1}, 
        {(char *)"ld de,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ld (de),a", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc de", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc d", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rla", (char *)"vv", 1, 0, 0}, 
        {(char *)"jr ", (char *)"vv", 2, 3, 1}, 
        {(char *)"add hl,de", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,(de)", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec de", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc e", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rra", (char *)"vv", 1, 0, 0}, 
        {(char *)"jr nz,", (char *)"vv", 2, 3, 1}, 
        {(char *)"ld hl,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ld (", (char *)"),hl", 3, 12, 0}, 
        {(char *)"inc hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc h", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,", (char *)"vv", 2, 1, 0}, 
        {(char *)"daa", (char *)"vv", 1, 0, 0}, 
        {(char *)"jr z,", (char *)"vv", 2, 3, 1}, 
        {(char *)"add hl,hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld hl,(", (char *)")", 3, 12, 0}, 
        {(char *)"dec hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc l", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,", (char *)"vv", 2, 1, 0}, 
        {(char *)"cpl", (char *)"vv", 1, 0, 0}, 
        {(char *)"jr nc,", (char *)"vv", 2, 3, 1}, 
        {(char *)"ld sp,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ld (", (char *)"),a", 3, 12, 0}, 
        {(char *)"inc sp", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),", (char *)"vv", 2, 1, 0}, 
        {(char *)"scf", (char *)"vv", 1, 0, 0}, 
        {(char *)"jr c,", (char *)"vv", 2, 3, 1}, 
        {(char *)"add hl,sp", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,(", (char *)")", 3, 12, 0}, 
        {(char *)"dec sp", (char *)"vv", 1, 0, 0}, 
        {(char *)"inc a", (char *)"vv", 1, 0, 0}, 
        {(char *)"dec a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,", (char *)"vv", 2, 1, 0}, 
        {(char *)"ccf", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld b,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld c,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld d,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld e,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld h,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld l,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),l", (char *)"vv", 1, 0, 0}, 
        {(char *)"halt", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld (hl),a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld a,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"adc a,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub b", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub c", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub d", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub e", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub h", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub l", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub a", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,b", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,c", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,d", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,e", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,h", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,l", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,(hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"sbc a,a", (char *)"vv", 1, 0, 0}, 
        {(char *)"and b", (char *)"vv", 1, 0, 0}, 
        {(char *)"and c", (char *)"vv", 1, 0, 0}, 
        {(char *)"and d", (char *)"vv", 1, 0, 0}, 
        {(char *)"and e", (char *)"vv", 1, 0, 0}, 
        {(char *)"and h", (char *)"vv", 1, 0, 0}, 
        {(char *)"and l", (char *)"vv", 1, 0, 0}, 
        {(char *)"and (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"and a", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor b", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor c", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor d", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor e", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor h", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor l", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"xor a", (char *)"vv", 1, 0, 0}, 
        {(char *)"or b", (char *)"vv", 1, 0, 0}, 
        {(char *)"or c", (char *)"vv", 1, 0, 0}, 
        {(char *)"or d", (char *)"vv", 1, 0, 0}, 
        {(char *)"or e", (char *)"vv", 1, 0, 0}, 
        {(char *)"or h", (char *)"vv", 1, 0, 0}, 
        {(char *)"or l", (char *)"vv", 1, 0, 0}, 
        {(char *)"or (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"or a", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp b", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp c", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp d", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp e", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp h", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp l", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"cp a", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret nz", (char *)"vv", 1, 0, 0}, 
        {(char *)"pop bc", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp nz,", (char *)"vv", 3, 2, 0}, 
        {(char *)"jp ", (char *)"vv", 3, 2, 0}, 
        {(char *)"call nz,", (char *)"vv", 3, 2, 0}, 
        {(char *)"push bc", (char *)"vv", 1, 0, 0}, 
        {(char *)"add a,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 0", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret z", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp z,", (char *)"vv", 3, 2, 0}, 
        {(char *)"qs", (char *)"vv", 99, 88, 77}, 
        {(char *)"call z,", (char *)"vv", 3, 2, 0}, 
        {(char *)"call ", (char *)"vv", 3, 2, 0}, 
        {(char *)"adc a,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 8", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret nc", (char *)"vv", 1, 0, 0}, 
        {(char *)"pop de", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp nc,", (char *)"vv", 3, 2, 0}, 
        {(char *)"out (", (char *)"),a", 2, 11, 0}, 
        {(char *)"call nc,", (char *)"vv", 3, 2, 0}, 
        {(char *)"push de", (char *)"vv", 1, 0, 0}, 
        {(char *)"sub ", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 10h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret c", (char *)"vv", 1, 0, 0}, 
        {(char *)"exx", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp c,", (char *)"vv", 3, 2, 0}, 
        {(char *)"in a,(", (char *)")", 2, 11, 0}, 
        {(char *)"call c,", (char *)"vv", 3, 2, 0}, 
        {(char *)"qs", (char *)"vv", 99, 88, 77}, 
        {(char *)"sbc a,", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 18h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret po", (char *)"vv", 1, 0, 0}, 
        {(char *)"pop hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp po,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ex (sp),hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"call po,", (char *)"vv", 3, 2, 0}, 
        {(char *)"push hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"and ", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 20h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret pe", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp (hl)", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp pe,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ex de,hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"call pe,", (char *)"vv", 3, 2, 0}, 
        {(char *)"qs", (char *)"vv", 99, 88, 77}, 
        {(char *)"xor ", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 28h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret p", (char *)"vv", 1, 0, 0}, 
        {(char *)"pop af", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp p,", (char *)"vv", 3, 2, 0}, 
        {(char *)"di", (char *)"vv", 1, 0, 0}, 
        {(char *)"call p,", (char *)"vv", 3, 2, 0}, 
        {(char *)"push af", (char *)"vv", 1, 0, 0}, 
        {(char *)"or ", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 30h", (char *)"vv", 1, 0, 0}, 
        {(char *)"ret m", (char *)"vv", 1, 0, 0}, 
        {(char *)"ld sp,hl", (char *)"vv", 1, 0, 0}, 
        {(char *)"jp m,", (char *)"vv", 3, 2, 0}, 
        {(char *)"ei", (char *)"vv", 1, 0, 0}, 
        {(char *)"call m,", (char *)"vv", 3, 2, 0}, 
        {(char *)"qs", (char *)"vv", 99, 88, 77}, 
        {(char *)"cp ", (char *)"vv", 2, 1, 0}, 
        {(char *)"rst 38h", (char *)"vv", 1, 0, 0}};
#line 267 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *ed40[16]  = 
#line 267
  {      "in b,(c)",      "out (c),b",      "sbc hl,bc",      "ld (", 
        "neg",      "retn",      "im 0",      "ld i,a", 
        "in c,(c)",      "out (c),c",      "adc hl,bc",      "ld bc,(", 
        "00",      "reti",      "00",      "ld r,a"};
#line 286 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *ed50[16]  = 
#line 286
  {      "in d,(c)",      "out (c),d",      "sbc hl,de",      "ld (", 
        "00",      "00",      "im 1",      "ld a,i", 
        "in e,(c)",      "out (c),e",      "adc hl,de",      "ld de,(", 
        "00",      "00",      "im 2",      "ld a,r"};
#line 305 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *ed60[16]  = 
#line 305
  {      "in h,(c)",      "out (c),h",      "sbc hl,hl",      "00", 
        "00",      "00",      "00",      "rrd", 
        "in l,(c)",      "out (c),l",      "adc hl,hl",      "00", 
        "00",      "00",      "00",      "rld"};
#line 324 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *ed70[16]  = 
#line 324
  {      "00",      "00",      "sbc hl,sp",      "ld (", 
        "00",      "00",      "00",      "00", 
        "in a,(c)",      "out (c),a",      "adc hl,sp",      "ld sp,(", 
        "00",      "00",      "00",      "00"};
#line 343 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *eda0[16]  = 
#line 343
  {      "ldi",      "cpi",      "ini",      "outi", 
        "00",      "00",      "00",      "00", 
        "ldd",      "cpd",      "ind",      "outd", 
        "00",      "00",      "00",      "00"};
#line 362 "/home/june/repo/benchmarks/collector/temp/z80dasm-1.1.3/src/dz80dat.c"
char const   *edb0[16]  = 
#line 362
  {      "ldir",      "cpir",      "inir",      "otir", 
        "00",      "00",      "00",      "00", 
        "lddr",      "cpdr",      "indr",      "otdr", 
        "00",      "00",      "00",      "00"};
