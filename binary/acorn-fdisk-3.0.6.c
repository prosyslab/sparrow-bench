/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 25 "../util/types.h"
typedef unsigned int bool_t;
#line 27 "../util/types.h"
typedef unsigned int u32;
#line 28 "../util/types.h"
typedef unsigned short u16;
#line 29 "../util/types.h"
typedef unsigned char u8;
#line 15 "../blkio/blkio.h"
typedef u_int64_t blk_t;
#line 17 "../blkio/blkio.h"
struct __anonstruct_geometry_t_21 {
   u_int cylinders ;
   u_int heads ;
   u_int sectors ;
   u_int sector_size ;
   u_int log2secsize ;
};
#line 17 "../blkio/blkio.h"
typedef struct __anonstruct_geometry_t_21 geometry_t;
#line 25 "../blkio/blkio.h"
struct __anonstruct_blkio_t_22 {
   int fd ;
   geometry_t geometry ;
   int blocksize ;
};
#line 25 "../blkio/blkio.h"
typedef struct __anonstruct_blkio_t_22 blkio_t;
#line 12 "../part/part.h"
struct __anonstruct_chs_t_23 {
   u_int cylinder ;
   u_int head ;
   u_int sector ;
};
#line 12 "../part/part.h"
typedef struct __anonstruct_chs_t_23 chs_t;
#line 18
enum __anonenum_ptyp_t_24 {
    ptyp_none = 0,
    ptyp_dos12 = 1,
    ptyp_xenixroot = 2,
    ptyp_xenixusr = 3,
    ptyp_dos16l32 = 4,
    ptyp_dos_extended = 5,
    ptyp_dos16g32 = 6,
    ptyp_hpfs = 7,
    ptyp_aix = 8,
    ptyp_aixboot = 9,
    ptyp_os2 = 10,
    ptyp_win98_extended = 15,
    ptyp_venix = 64,
    ptyp_novell = 81,
    ptyp_dm6_aux1 = 81,
    ptyp_microport = 82,
    ptyp_dm6_aux3 = 83,
    ptyp_dm6 = 84,
    ptyp_ezdrive = 85,
    ptyp_gnuhurd = 99,
    ptyp_novelnet286 = 100,
    ptyp_novelnet386 = 101,
    ptyp_pcix = 117,
    ptyp_old_minix = 128,
    ptyp_linux_parttion = 128,
    ptyp_minix = 129,
    ptyp_linux_swap = 130,
    ptyp_linux_native = 131,
    ptyp_linux_extended = 133,
    ptyp_amoeba = 147,
    ptyp_amoebabbt = 148,
    ptyp_bsd386 = 165,
    ptyp_bsdifs = 183,
    ptyp_bsdiswap = 184,
    ptyp_syrinx = 199,
    ptyp_cpm = 219,
    ptyp_dosaccess = 225,
    ptyp_dosro = 227,
    ptyp_dosscc = 242,
    ptyp_bbt = 255,
    ptyp_filecore = 256,
    ptyp_linux_table = 257,
    ptyp_pc_table = 258,
    ptyp_pt_oldmap = 259,
    ptyp_pt_backup = 260,
    ptyp_pt_empty = 261,
    ptyp_reserved = 65534,
    ptyp_unknown = 65535
} ;
#line 18 "../part/part.h"
typedef enum __anonenum_ptyp_t_24 ptyp_t;
#line 73 "../part/part.h"
struct __anonstruct_partinfo_t_25 {
   bool_t chs_valid ;
   chs_t chs_start ;
   chs_t chs_end ;
   blk_t blk_start ;
   blk_t blk_end ;
   ptyp_t type ;
   u_int kern_part_no ;
};
#line 73 "../part/part.h"
typedef struct __anonstruct_partinfo_t_25 partinfo_t;
#line 11 "../scheme/icside.h"
struct __anonstruct_icside_data_t_26 {
   u_int unused ;
};
#line 11 "../scheme/icside.h"
typedef struct __anonstruct_icside_data_t_26 icside_data_t;
#line 15 "../scheme/icside.h"
struct __anonstruct_icside_part_t_27 {
   u_int idx ;
};
#line 15 "../scheme/icside.h"
typedef struct __anonstruct_icside_part_t_27 icside_part_t;
#line 19
struct scheme;
#line 12 "../blkio/filecore.h"
struct __anonstruct_d_28 {
   u8 log2secsize ;
   u8 secspertrack ;
   u8 heads ;
   u8 density ;
   u8 idlen ;
   u8 log2bpmb ;
   u8 skew ;
   u8 bootoption ;
   u8 lowsector ;
   u8 nzones ;
   u16 zone_spare ;
   u32 root ;
   u32 disc_size ;
   u16 disc_id ;
   u8 disc_name[10] ;
   u32 disctype ;
   u32 disc_size_high ;
   unsigned int share_size : 4 ;
   unsigned int unused : 4 ;
   unsigned int big_flag : 1 ;
   unsigned int unused2 : 23 ;
};
#line 12 "../blkio/filecore.h"
union disc_record {
   struct __anonstruct_d_28 d ;
   u8 packing[64] ;
};
#line 12 "../blkio/filecore.h"
typedef union disc_record disc_record_t;
#line 13 "../scheme/linux.h"
struct __anonstruct_filecore_linux_data_t_29 {
   disc_record_t disc_record ;
   u8 boot_checksum ;
};
#line 13 "../scheme/linux.h"
typedef struct __anonstruct_filecore_linux_data_t_29 filecore_linux_data_t;
#line 18 "../scheme/linux.h"
struct __anonstruct_filecore_linux_part_t_30 {
   u_int part_offset ;
};
#line 18 "../scheme/linux.h"
typedef struct __anonstruct_filecore_linux_part_t_30 filecore_linux_part_t;
#line 11 "../scheme/pcbios.h"
struct __anonstruct_pcbios_data_t_31 {
   u8 *pcboot_sector ;
   u8 *extended_sector ;
};
#line 11 "../scheme/pcbios.h"
typedef struct __anonstruct_pcbios_data_t_31 pcbios_data_t;
#line 16 "../scheme/pcbios.h"
struct __anonstruct_pcbios_part_t_32 {
   u_int part_offset ;
};
#line 16 "../scheme/pcbios.h"
typedef struct __anonstruct_pcbios_part_t_32 pcbios_part_t;
#line 11 "../scheme/powertec.h"
struct __anonstruct_powertec_data_t_33 {
   u_int unused ;
};
#line 11 "../scheme/powertec.h"
typedef struct __anonstruct_powertec_data_t_33 powertec_data_t;
#line 15 "../scheme/powertec.h"
struct __anonstruct_powertec_part_t_34 {
   u_int idx ;
   char *type ;
};
#line 15 "../scheme/powertec.h"
typedef struct __anonstruct_powertec_part_t_34 powertec_part_t;
#line 11 "../scheme/riscix.h"
struct __anonstruct_filecore_riscix_data_t_35 {
   disc_record_t disc_record ;
   u8 boot_checksum ;
};
#line 11 "../scheme/riscix.h"
typedef struct __anonstruct_filecore_riscix_data_t_35 filecore_riscix_data_t;
#line 16 "../scheme/riscix.h"
struct __anonstruct_filecore_riscix_part_t_36 {
   u_int part_offset ;
};
#line 16 "../scheme/riscix.h"
typedef struct __anonstruct_filecore_riscix_part_t_36 filecore_riscix_part_t;
#line 11 "../scheme/eesox.h"
struct __anonstruct_eesox_data_t_37 {
   u_int unused ;
};
#line 11 "../scheme/eesox.h"
typedef struct __anonstruct_eesox_data_t_37 eesox_data_t;
#line 15 "../scheme/eesox.h"
struct __anonstruct_eesox_part_t_38 {
   u_int idx ;
};
#line 15 "../scheme/eesox.h"
typedef struct __anonstruct_eesox_part_t_38 eesox_part_t;
#line 16 "../part/schemedata.h"
union __anonunion_scheme_part_t_39 {
   filecore_linux_part_t filecore_linux ;
   filecore_riscix_part_t filecore_riscix ;
   icside_part_t icside ;
   pcbios_part_t pcbios ;
   powertec_part_t powertec ;
   eesox_part_t eesox ;
   filecore_riscix_part_t riscix ;
};
#line 16 "../part/schemedata.h"
typedef union __anonunion_scheme_part_t_39 scheme_part_t;
#line 40 "../part/schemedata.h"
union __anonunion_scheme_data_t_40 {
   filecore_linux_data_t filecore_linux ;
   filecore_riscix_data_t filecore_riscix ;
   icside_data_t icside ;
   pcbios_data_t pcbios ;
   powertec_data_t powertec ;
   eesox_data_t eesox ;
   filecore_riscix_data_t riscix ;
};
#line 40 "../part/schemedata.h"
typedef union __anonunion_scheme_data_t_40 scheme_data_t;
#line 85 "../part/part.h"
struct __anonstruct_partinfo_i_t_41 {
   bool_t changed ;
   partinfo_t info ;
   scheme_part_t data ;
};
#line 85 "../part/part.h"
typedef struct __anonstruct_partinfo_i_t_41 partinfo_i_t;
#line 94 "../part/part.h"
struct __anonstruct_part_t_42 {
   blkio_t *blkio ;
   struct scheme *scheme ;
   scheme_data_t data ;
   u_int nr_partitions ;
   partinfo_i_t **partinfo ;
};
#line 94 "../part/part.h"
typedef struct __anonstruct_part_t_42 part_t;
#line 11 "../part/scheme.h"
struct scheme {
   char const   *name ;
   u_int (*detect)(part_t * ) ;
   u_int (*readinfo)(part_t * ) ;
   u_int (*writeinfo)(part_t * ) ;
   u_int (*allocate)(part_t * , partinfo_t *pnew ) ;
   u_int (*validate_change)(part_t * , u_int  , partinfo_t const   *pold , partinfo_t const   *pnew ) ;
   u_int (*validate_creation)(part_t * , u_int  , partinfo_t const   *pold , partinfo_t const   *pnew ) ;
   u_int (*validate_deletion)(part_t * , u_int  , partinfo_t const   *pold ) ;
   u_int (*validate_partno)(part_t * , u_int  ) ;
   ptyp_t (*nexttype)(part_t * , u_int  , ptyp_t  , int  ) ;
};
#line 11 "../part/scheme.h"
typedef struct scheme scheme_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 40 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
enum __anonenum_prog_mode_t_53 {
    mode_partition = 0,
    mode_version = 1,
    mode_help = 2,
    mode_list = 3,
    mode_size = 4,
    mode_illegal = 5
} ;
#line 40 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
typedef enum __anonenum_prog_mode_t_53 prog_mode_t;
#line 283 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
struct __anonstruct_region_54 {
   u_int64_t start ;
   u_int64_t end ;
};
#line 283 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
struct regions {
   struct __anonstruct_region_54 region[16] ;
   u_int nr ;
};
#line 469
enum __anonenum_list_t_55 {
    LIST_NORMAL = 0,
    LIST_EXTENDED_NORMAL = 1,
    LIST_EXTENDED_EXTENDED = 2
} ;
#line 469 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
typedef enum __anonenum_list_t_55 list_t;
#line 543
enum __anonenum_pps_ret_t_56 {
    pps_ret_ok = 0,
    pps_ret_open_error = 1,
    pps_ret_not_found = 2
} ;
#line 543 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
typedef enum __anonenum_pps_ret_t_56 pps_ret_t;
#line 14 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
struct __anonstruct_part_types_47 {
   ptyp_t type ;
   char const   *name ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 12 "../util/debug.h"
extern void dbg_level_up(void) ;
#line 17
extern void dbg_level_down(void) ;
#line 23
extern void dbg_printf(char const   *fmt  , ...) ;
#line 15 "../util/error.h"
extern void set_error(char const   *fmt  , ...) ;
#line 49 "../blkio/blkio.h"
extern blkio_t *blkio_close(blkio_t *blkio ) ;
#line 63
extern blkio_t *blkio_open(char const   *dev_name ) ;
#line 19 "../scheme/icside.h"
extern struct scheme icside_scheme ;
#line 22 "../scheme/linux.h"
extern struct scheme filecore_linux_scheme ;
#line 20 "../scheme/pcbios.h"
extern struct scheme pcbios_scheme ;
#line 20 "../scheme/powertec.h"
extern struct scheme powertec_scheme ;
#line 20 "../scheme/riscix.h"
extern struct scheme filecore_riscix_scheme ;
#line 19 "../scheme/eesox.h"
extern struct scheme eesox_scheme ;
#line 192 "../part/part.h"
part_t *part_open(char const   *dev_name , char const   *part_scheme ) ;
#line 14 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/open.c"
static scheme_t *schemes[7]  = {      & eesox_scheme,      & icside_scheme,      & powertec_scheme,      & filecore_linux_scheme, 
        & filecore_riscix_scheme,      & pcbios_scheme,      (scheme_t *)((void *)0)};
#line 31 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/open.c"
part_t *part_open(char const   *dev_name , char const   *part_scheme ) 
{ 
  part_t *part___0 ;
  char const   *tmp ;
  scheme_t *scheme___0 ;
  void *tmp___0 ;
  scheme_t **sp ;
  u_int tmp___1 ;
  scheme_t **sp___0 ;
  u_int scheme_len ;
  size_t tmp___2 ;
  u_int matches ;
  u_int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u_int tmp___6 ;

  {
#line 33
  part___0 = (part_t *)((void *)0);
#line 35
  if (! ((unsigned long )dev_name != (unsigned long )((void *)0))) {
    {
#line 35
    __assert_fail("dev_name != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/open.c",
                  35U, "part_open");
    }
  }
#line 37
  if (part_scheme) {
#line 37
    tmp = part_scheme;
  } else {
#line 37
    tmp = "";
  }
  {
#line 37
  dbg_printf("part_open(dev_name=%s, part_scheme=%s)", dev_name, tmp);
#line 39
  dbg_level_up();
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    tmp___0 = malloc(sizeof(part_t ));
#line 44
    part___0 = (part_t *)tmp___0;
    }
#line 45
    if (! part___0) {
      {
#line 46
      set_error("out of memory");
      }
#line 47
      goto while_break;
    }
    {
#line 50
    memset((void *)part___0, 0, sizeof(part_t ));
#line 55
    part___0->blkio = blkio_open(dev_name);
    }
#line 56
    if (! part___0->blkio) {
      {
#line 57
      free((void *)part___0);
#line 58
      part___0 = (part_t *)((void *)0);
      }
#line 59
      goto while_break;
    }
#line 65
    if (! part_scheme) {
#line 68
      sp = schemes;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        scheme___0 = *sp;
#line 68
        if (! ((unsigned long )scheme___0 != (unsigned long )((void *)0))) {
#line 68
          goto while_break___0;
        }
        {
#line 69
        tmp___1 = (*(scheme___0->detect))(part___0);
        }
#line 69
        if (tmp___1) {
#line 70
          goto while_break___0;
        }
#line 68
        sp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 73
      tmp___2 = strlen(part_scheme);
#line 73
      scheme_len = (u_int )tmp___2;
#line 74
      matches = (u_int )0;
#line 77
      sp___0 = schemes;
      }
      {
#line 77
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 77
        scheme___0 = *sp___0;
#line 77
        if (! ((unsigned long )scheme___0 != (unsigned long )((void *)0))) {
#line 77
          goto while_break___1;
        }
        {
#line 78
        tmp___4 = strncasecmp(scheme___0->name, part_scheme, (size_t )scheme_len);
        }
#line 78
        if (tmp___4 == 0) {
          {
#line 79
          matches ++;
#line 80
          tmp___3 = (*(scheme___0->detect))(part___0);
          }
#line 80
          if (tmp___3) {
#line 81
            goto while_break___1;
          }
        }
#line 77
        sp___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 84
      if (! scheme___0) {
#line 84
        if (matches == 1U) {
#line 85
          sp___0 = schemes;
          {
#line 85
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 85
            scheme___0 = *sp___0;
#line 85
            if (! ((unsigned long )scheme___0 != (unsigned long )((void *)0))) {
#line 85
              goto while_break___2;
            }
            {
#line 86
            tmp___5 = strncasecmp(scheme___0->name, part_scheme, (size_t )scheme_len);
            }
#line 86
            if (tmp___5 == 0) {
#line 87
              goto while_break___2;
            }
#line 85
            sp___0 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 92
    if (! scheme___0) {
      {
#line 93
      blkio_close(part___0->blkio);
#line 94
      free((void *)part___0);
#line 95
      part___0 = (part_t *)((void *)0);
#line 96
      set_error("partitioning scheme not recognised");
      }
#line 97
      goto while_break;
    }
    {
#line 103
    tmp___6 = (*(scheme___0->readinfo))(part___0);
    }
#line 103
    if (! tmp___6) {
      {
#line 104
      blkio_close(part___0->blkio);
#line 105
      free((void *)part___0);
#line 106
      part___0 = (part_t *)((void *)0);
#line 107
      set_error("unable to read partition tables");
      }
#line 108
      goto while_break;
    }
#line 110
    part___0->scheme = scheme___0;
#line 41
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  dbg_level_down();
#line 114
  dbg_printf("ret=%p", part___0);
  }
#line 116
  return (part___0);
}
}
#line 253 "../part/part.h"
u_int part_validops(part_t *part___0 , u_int parn , partinfo_t const   *pinfo ) ;
#line 19 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/validops.c"
u_int part_validops(part_t *part___0 , u_int parn , partinfo_t const   *pinfo ) 
{ 
  u_int ret ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 21
  ret = (u_int )0;
#line 23
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 23
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/validops.c",
                  23U, "part_validops");
    }
  }
#line 24
  if (part___0->nr_partitions) {
#line 24
    if (! (parn < part___0->nr_partitions)) {
      {
#line 24
      __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/validops.c",
                    24U, "part_validops");
      }
    }
  } else {
    {
#line 24
    __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/validops.c",
                  24U, "part_validops");
    }
  }
#line 25
  if (! part___0->scheme) {
    {
#line 25
    __assert_fail("part->scheme", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/validops.c",
                  25U, "part_validops");
    }
  }
  {
#line 27
  dbg_printf("part_validops(parn=%d)", parn);
#line 28
  dbg_level_up();
  }
#line 30
  if (*(part___0->partinfo + parn)) {
    {
#line 31
    tmp = (*((part___0->scheme)->validate_change))(part___0, parn, (partinfo_t const   *)(& (*(part___0->partinfo + parn))->info),
                                                   pinfo);
    }
#line 31
    if (tmp) {
#line 32
      ret |= 1U;
    }
    {
#line 33
    tmp___0 = (*((part___0->scheme)->validate_deletion))(part___0, parn, (partinfo_t const   *)(& (*(part___0->partinfo + parn))->info));
    }
#line 33
    if (tmp___0) {
#line 34
      ret |= (unsigned int )(1 << 1);
    }
  }
  {
#line 37
  dbg_level_down();
#line 38
  dbg_printf("ret %X", ret);
  }
#line 40
  return (ret);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 244 "../part/part.h"
extern u_int part_updatechs(part_t *part , partinfo_t *pinfo ) ;
#line 18 "../part/utils.h"
u_int part_add(part_t *part___0 , u_int parn , partinfo_i_t *pinfo ) ;
#line 20 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/scheme/add.c"
u_int part_add(part_t *part___0 , u_int parn , partinfo_i_t *pinfo ) 
{ 
  u_int ret ;
  partinfo_i_t **p ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 23
  ret = (u_int )1;
#line 24
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 24
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/scheme/add.c",
                  24U, "part_add");
    }
  }
#line 25
  if (! ((unsigned long )pinfo != (unsigned long )((void *)0))) {
    {
#line 25
    __assert_fail("pinfo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/scheme/add.c",
                  25U, "part_add");
    }
  }
  {
#line 27
  dbg_printf("part_add(parn=%d, pinfo=[bs=0x%X, be=0x%X, type=0x%X])", parn, pinfo->info.blk_start,
             pinfo->info.blk_end, (unsigned int )pinfo->info.type);
#line 29
  dbg_level_up();
#line 31
  part_updatechs(part___0, & pinfo->info);
  }
#line 33
  if (part___0->nr_partitions == 0U) {
#line 33
    goto _L;
  } else
#line 33
  if (parn >= part___0->nr_partitions) {
    _L: /* CIL Label */ 
    {
#line 36
    tmp = malloc((unsigned long )(parn + 1U) * sizeof(*p));
#line 36
    p = (partinfo_i_t **)tmp;
    }
#line 37
    if (p) {
      {
#line 38
      memset((void *)p, 0, (unsigned long )(parn + 1U) * sizeof(*p));
      }
#line 39
      if (part___0->partinfo) {
        {
#line 40
        memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)part___0->partinfo,
               (unsigned long )part___0->nr_partitions * sizeof(*p));
#line 41
        free((void *)part___0->partinfo);
        }
      }
#line 43
      part___0->nr_partitions = parn + 1U;
#line 44
      part___0->partinfo = p;
    } else {
#line 46
      ret = (u_int )0;
    }
  }
#line 49
  if (! *(part___0->partinfo + parn)) {
    {
#line 50
    tmp___0 = malloc(sizeof(partinfo_i_t ));
#line 50
    *(part___0->partinfo + parn) = (partinfo_i_t *)tmp___0;
    }
  }
#line 51
  if (*(part___0->partinfo + parn)) {
#line 52
    *(*(part___0->partinfo + parn)) = *pinfo;
#line 53
    (*(part___0->partinfo + parn))->changed = (bool_t )0;
  } else {
#line 55
    ret = (u_int )0;
  }
  {
#line 57
  dbg_level_down();
  }
#line 58
  if (ret) {
#line 58
    tmp___1 = "ok";
  } else {
#line 58
    tmp___1 = "failed";
  }
  {
#line 58
  dbg_printf("ret %s", tmp___1);
  }
#line 60
  return (ret);
}
}
#line 100 "../blkio/blkio.h"
u_int blkio_write(blkio_t *blkio , void const   *data , blk_t block , u_int nr_blocks ) ;
#line 264 "../part/part.h"
u_int part_write(part_t *part___0 , u_int parn , void const   *data , blk_t blk ,
                 u_int nr_blks ) ;
#line 21 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/write.c"
u_int part_write(part_t *part___0 , u_int parn , void const   *data , blk_t blk ,
                 u_int nr_blks ) 
{ 
  partinfo_i_t *pinfo ;
  u_int ret ;

  {
#line 24
  ret = (u_int )0;
#line 26
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 26
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/write.c",
                  26U, "part_write");
    }
  }
#line 27
  if (part___0->nr_partitions) {
#line 27
    if (! (parn < part___0->nr_partitions)) {
      {
#line 27
      __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/write.c",
                    27U, "part_write");
      }
    }
  } else {
    {
#line 27
    __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/write.c",
                  27U, "part_write");
    }
  }
#line 28
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 28
    __assert_fail("data != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/write.c",
                  28U, "part_write");
    }
  }
  {
#line 30
  dbg_printf("part_write(parn=%d, data=%p, blk=0x%X, nr=0x%X)", parn, data, blk, nr_blks);
#line 31
  dbg_level_up();
#line 33
  pinfo = *(part___0->partinfo + parn);
  }
#line 35
  if (pinfo) {
#line 36
    blk += pinfo->info.blk_start;
#line 37
    if ((blk_t )nr_blks <= pinfo->info.blk_end - pinfo->info.blk_start) {
#line 37
      if (blk < pinfo->info.blk_end - (blk_t )nr_blks) {
        {
#line 39
        ret = blkio_write(part___0->blkio, data, blk, nr_blks);
        }
      }
    }
  }
  {
#line 42
  dbg_level_down();
#line 43
  dbg_printf("ret=%d", ret);
  }
#line 45
  return (ret);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 972 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 121 "lib/part/part.h"
u_int part_allocate(part_t *part___0 , partinfo_t *pinfo ) ;
#line 129
part_t *part_close(part_t *part___0 ) ;
#line 139
u_int part_create(part_t *part___0 , u_int parn , partinfo_t const   *pinfo ) ;
#line 148
u_int part_delete(part_t *part___0 , u_int parn ) ;
#line 157
u_int part_getgeometry(part_t *part___0 , geometry_t *geo ) ;
#line 166
u_int part_getpartinfo(part_t *part___0 , u_int parn , partinfo_t *pinfo ) ;
#line 173
char const   *part_getscheme(part_t *part___0 ) ;
#line 183
ptyp_t part_nexttype(part_t *part___0 , u_int parn , ptyp_t current , int dir ) ;
#line 221
u_int part_setpartinfo(part_t *part___0 , u_int parn , partinfo_t const   *pinfo ) ;
#line 228
u_int part_sync(part_t *part___0 ) ;
#line 236
char const   *part_typename(part_t *part___0 , ptyp_t type ) ;
#line 21 "lib/util/error.h"
extern char const   *get_error(void) ;
#line 26 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char const   *part_devs[12]  = 
#line 26 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
  {      "/dev/hda",      "/dev/hdb",      "/dev/hdc",      "/dev/hdd", 
        "/dev/sda",      "/dev/sdb",      "/dev/sdc",      "/dev/sdd", 
        "/dev/sde",      "/dev/sdf",      "/dev/sdg",      "/dev/sdh"};
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 35 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char const   *device  ;
#line 36 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char const   *progname  ;
#line 37 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char const   *dev_part_type  =    "";
#line 38 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static part_t *part  ;
#line 49 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static struct option options[6]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"list", 0, (int *)((void *)0), 'l'}, 
        {"size", 1, (int *)((void *)0), 's'}, 
        {"type", 1, (int *)((void *)0), 't'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 60 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static prog_mode_t parse_args(int argc , char **argv ) 
{ 
  prog_mode_t mode ;
  int opt ;

  {
#line 63
  mode = (prog_mode_t )0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    opt = getopt_long(argc, (char * const  *)argv, "hls:t:v", (struct option  const  *)(options),
                      (int *)((void *)0));
    }
    {
#line 70
    if (opt == 104) {
#line 70
      goto case_104;
    }
#line 75
    if (opt == 118) {
#line 75
      goto case_118;
    }
#line 80
    if (opt == 108) {
#line 80
      goto case_108;
    }
#line 84
    if (opt == 115) {
#line 84
      goto case_115;
    }
#line 89
    if (opt == 116) {
#line 89
      goto case_116;
    }
#line 93
    if (opt == -1) {
#line 93
      goto case_neg_1;
    }
#line 96
    goto switch_default;
    case_104: /* CIL Label */ 
#line 71
    mode = (prog_mode_t )2;
#line 72
    opt = -1;
#line 73
    goto switch_break;
    case_118: /* CIL Label */ 
#line 76
    mode = (prog_mode_t )1;
#line 77
    opt = -1;
#line 78
    goto switch_break;
    case_108: /* CIL Label */ 
#line 81
    mode = (prog_mode_t )3;
#line 82
    goto switch_break;
    case_115: /* CIL Label */ 
#line 85
    mode = (prog_mode_t )4;
#line 86
    device = (char const   *)optarg;
#line 87
    goto switch_break;
    case_116: /* CIL Label */ 
#line 90
    dev_part_type = (char const   *)optarg;
#line 91
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 94
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 97
    mode = (prog_mode_t )5;
#line 98
    opt = -1;
#line 99
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 66
    if (! (opt != -1)) {
#line 66
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (mode);
}
}
#line 106 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char buf[16]  ;
#line 108 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char const   *read_line(char const   *msg  , ...) 
{ 
  va_list ap ;
  char *p ;
  int tmp ;

  {
#line 114
  buf[0] = (char )'\000';
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 117
    __builtin_va_start(ap, msg);
#line 118
    vprintf((char const   */* __restrict  */)msg, ap);
#line 119
    __builtin_va_end(ap);
#line 120
    fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)stdin);
#line 116
    tmp = feof(stdin);
    }
#line 116
    if (tmp) {
#line 116
      goto while_break;
    } else
#line 116
    if (! ((int )buf[0] == 0)) {
#line 116
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  p = strchr((char const   *)(buf), '\n');
  }
#line 124
  if (p) {
#line 125
    *p = (char )'\000';
  }
#line 127
  return ((char const   *)(buf));
}
}
#line 130 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char read_char(char const   *msg ) 
{ 
  char const   *tmp ;

  {
  {
#line 133
  tmp = read_line(msg);
  }
#line 133
  return ((char )*(tmp + 0));
}
}
#line 136 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void list_types(u_int parn , ptyp_t next ) 
{ 
  ptyp_t types___0[256] ;
  ptyp_t cur ;
  u_int idx ;
  u_int last[4] ;
  u_int done ;
  u_int nxt ;
  int i ;
  u_int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 140
  idx = (u_int )0;
#line 140
  done = (u_int )0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    cur = next;
#line 145
    next = part_nexttype(part, parn, cur, -1);
    }
#line 143
    if (! ((unsigned int )cur != (unsigned int )next)) {
#line 143
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 149
    cur = next;
#line 150
    tmp = idx;
#line 150
    idx ++;
#line 150
    types___0[tmp] = cur;
#line 151
    next = part_nexttype(part, parn, cur, 1);
    }
#line 148
    if (! ((unsigned int )cur != (unsigned int )next)) {
#line 148
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  i = 3;
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! (i >= 0)) {
#line 154
      goto while_break___1;
    }
#line 155
    done += ((idx + (u_int )i) - done) / (u_int )(i + 1);
#line 155
    last[3 - i] = done;
#line 154
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 157
  done = (u_int )0;
#line 157
  nxt = done;
#line 157
  i = (int )nxt;
  {
#line 159
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 160
    tmp___0 = part_typename(part, types___0[nxt]);
    }
#line 160
    if (i) {
#line 160
      tmp___1 = ' ';
    } else {
#line 160
      tmp___1 = '\n';
    }
    {
#line 160
    printf((char const   */* __restrict  */)"%c%3x %-15.15s", tmp___1, (unsigned int )types___0[nxt],
           tmp___0);
#line 162
    tmp___2 = i;
#line 162
    i ++;
#line 162
    nxt = last[tmp___2] + done;
    }
#line 163
    if (i > 3) {
#line 164
      i = 0;
#line 165
      done ++;
#line 165
      nxt = done;
    } else
#line 163
    if (nxt >= last[i]) {
#line 164
      i = 0;
#line 165
      done ++;
#line 165
      nxt = done;
    }
#line 159
    if (! (done < last[0])) {
#line 159
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 168
  putchar('\n');
  }
#line 170
  return;
}
}
#line 172 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static ptyp_t read_type(u_int parn , ptyp_t old_type , char const   *prompt ) 
{ 
  int hex ;
  char const   *line ;
  char const   *tmp ;
  unsigned long tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 178
    tmp = read_line(prompt);
#line 178
    line = tmp;
#line 179
    tmp___2 = tolower((int )*(line + 0));
    }
#line 179
    if (tmp___2 == 108) {
      {
#line 180
      list_types(parn, old_type);
      }
    } else {
      {
#line 181
      tmp___1 = __ctype_b_loc();
      }
#line 181
      if ((int const   )*(*tmp___1 + (int )*(line + 0)) & 4096) {
        {
#line 182
        tmp___0 = strtoul((char const   */* __restrict  */)line, (char **/* __restrict  */)((void *)0),
                          16);
#line 182
        hex = (int )tmp___0;
        }
#line 183
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((ptyp_t )hex);
}
}
#line 190 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static u_int get_part_nr(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 193
  buf[0] = (char )'\000';
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    fputs((char const   */* __restrict  */)"Which partition? ", (FILE */* __restrict  */)stdout);
#line 197
    fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)stdin);
#line 195
    tmp = feof(stdin);
    }
#line 195
    if (tmp) {
#line 195
      goto while_break;
    } else
#line 195
    if (! ((int )buf[0] == 0)) {
#line 195
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  tmp___0 = atoi((char const   *)(buf));
  }
#line 200
  return ((u_int )tmp___0);
}
}
#line 203 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static u_int display_factor  =    (u_int )1;
#line 204 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static u_int full_bits  =    (u_int )0;
#line 205 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static bool_t unit_flag  =    (bool_t )1;
#line 207 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void update_units(part_t *part___0 ) 
{ 
  geometry_t geo ;

  {
  {
#line 212
  part_getgeometry(part___0, & geo);
#line 214
  full_bits = (1024U * geo.heads) * geo.sectors;
  }
#line 215
  if (unit_flag) {
#line 215
    if (full_bits) {
#line 216
      display_factor = full_bits >> 10;
    } else {
#line 218
      display_factor = (u_int )1;
    }
  } else {
#line 218
    display_factor = (u_int )1;
  }
#line 219
  return;
}
}
#line 221 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void change_units(part_t *part___0 ) 
{ 
  char const   *tmp ;

  {
#line 224
  unit_flag = (bool_t )(! unit_flag);
#line 225
  if (part___0) {
    {
#line 226
    update_units(part___0);
    }
  }
#line 227
  if (unit_flag) {
#line 227
    tmp = "cylinder";
  } else {
#line 227
    tmp = "sector";
  }
  {
#line 227
  printf((char const   */* __restrict  */)"Changing display/entry units to %ss\n",
         tmp);
  }
#line 229
  return;
}
}
#line 231 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static u_int sectors_to_units(u_int sectors ) 
{ 
  u_int tmp ;

  {
#line 234
  if (unit_flag) {
#line 234
    tmp = display_factor - 1U;
  } else {
#line 234
    tmp = (u_int )0;
  }
#line 234
  return ((sectors + tmp) / display_factor);
}
}
#line 237 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static u_int units_to_sectors(u_int units ) 
{ 


  {
#line 240
  return (units * display_factor);
}
}
#line 243 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
__inline static u_int calculate(part_t *part___0 , u_int head , u_int sect , u_int cyl ) 
{ 
  geometry_t geo ;

  {
  {
#line 248
  part_getgeometry(part___0, & geo);
  }
#line 250
  return ((sect - 1U) + geo.sectors * (head + geo.heads * cyl));
}
}
#line 253 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void delete_partition(void) 
{ 
  partinfo_t info ;
  u_int part_no ;
  u_int found ;
  u_int partition ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  char const   *tmp___2 ;
  u_int tmp___3 ;

  {
  {
#line 257
  found = (u_int )0;
#line 257
  tmp = get_part_nr();
#line 257
  partition = tmp;
#line 259
  part_no = (u_int )0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    tmp___0 = part_getpartinfo(part, part_no, & info);
    }
#line 259
    if (! tmp___0) {
#line 259
      goto while_break;
    }
#line 260
    if (info.kern_part_no == partition) {
#line 261
      found = (u_int )1;
#line 262
      goto while_break;
    }
#line 259
    part_no ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  if (! found) {
    {
#line 266
    printf((char const   */* __restrict  */)"Bad partition number `%d\'\n", partition);
    }
#line 267
    return;
  }
  {
#line 270
  tmp___1 = part_validops(part, part_no, (partinfo_t const   *)(& info));
  }
#line 270
  if (! (tmp___1 & (unsigned int )(1 << 1))) {
    {
#line 271
    printf((char const   */* __restrict  */)"Partition %d cannot be deleted.\n", info.kern_part_no);
    }
#line 273
    return;
  }
  {
#line 276
  tmp___3 = part_delete(part, part_no);
  }
#line 276
  if (tmp___3) {
    {
#line 280
    printf((char const   */* __restrict  */)"Partition `%d\' deleted\n", partition);
    }
  } else {
    {
#line 277
    tmp___2 = get_error();
#line 277
    printf((char const   */* __restrict  */)"Unable to delete partition `%d\': %s\n",
           partition, tmp___2);
    }
  }
#line 281
  return;
}
}
#line 291 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void add_region(struct regions *region , partinfo_t *info ) 
{ 
  u_int i ;

  {
#line 296
  i = (u_int )0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < region->nr)) {
#line 296
      goto while_break;
    }
#line 297
    if (region->region[i].start > info->blk_start) {
      {
#line 298
      memmove((void *)(& region->region[i + 1U]), (void const   *)(& region->region[i]),
              (unsigned long )(region->nr - i) * sizeof(region->region[0]));
#line 301
      region->region[i].start = info->blk_start;
#line 302
      region->region[i].end = info->blk_end + 1UL;
#line 303
      (region->nr) ++;
      }
#line 304
      goto added;
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  region->region[region->nr].start = info->blk_start;
#line 309
  region->region[region->nr].end = info->blk_end + 1UL;
#line 310
  (region->nr) ++;
  added: 
#line 313
  i = (u_int )1;
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 313
    if (! (i < region->nr)) {
#line 313
      goto while_break___0;
    }
#line 314
    if (region->region[i].start == region->region[i - 1U].end) {
      {
#line 315
      region->region[i - 1U].end = region->region[i].end;
#line 316
      memmove((void *)(& region->region[i]), (void const   *)(& region->region[i + 1U]),
              (unsigned long )(region->nr - i) * sizeof(region->region[0]));
#line 319
      (region->nr) --;
      }
    } else {
#line 321
      i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 325 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void get_regions(struct regions *region ) 
{ 
  partinfo_t info ;
  u_int parn ;
  u_int tmp ;
  u_int tmp___0 ;

  {
#line 329
  parn = (u_int )0;
#line 331
  region->nr = (u_int )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 333
    tmp = parn;
#line 333
    parn ++;
#line 333
    tmp___0 = part_getpartinfo(part, tmp, & info);
    }
#line 333
    if (! tmp___0) {
#line 333
      goto while_break;
    }
#line 334
    if (! info.type) {
#line 335
      goto while_continue;
    }
    {
#line 337
    add_region(region, & info);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return;
}
}
#line 341 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void new_partition(void) 
{ 
  partinfo_t info ;
  geometry_t geo ;
  struct regions regions ;
  u_int parn ;
  u_int total ;
  u_int first ;
  u_int i ;
  char *units ;
  u_int tmp ;
  u_int tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;
  char const   *tmp___3 ;
  char const   *l ;
  u_int tmp___4 ;
  char const   *tmp___5 ;
  unsigned long tmp___6 ;
  u_int tmp___7 ;
  unsigned short const   **tmp___8 ;
  u_int tmp___9 ;
  char const   *tmp___10 ;
  unsigned long tmp___11 ;
  u_int tmp___12 ;
  unsigned long tmp___13 ;
  u_int tmp___14 ;
  unsigned short const   **tmp___15 ;
  char const   *tmp___16 ;
  u_int tmp___17 ;

  {
  {
#line 347
  first = (u_int )1;
#line 350
  update_units(part);
#line 352
  part_getgeometry(part, & geo);
#line 353
  total = (geo.sectors * geo.heads) * geo.cylinders;
  }
#line 355
  if (unit_flag) {
#line 356
    units = (char *)"cylinder";
  } else {
#line 358
    units = (char *)"sector";
  }
  {
#line 360
  printf((char const   */* __restrict  */)"\nUnits are %ss of %d * %d bytes\nDisk space used:",
         units, display_factor, 512);
#line 363
  get_regions(& regions);
#line 365
  i = (u_int )0;
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! (i < regions.nr)) {
#line 365
      goto while_break;
    }
    {
#line 366
    tmp = sectors_to_units((u_int )regions.region[i].end);
#line 366
    tmp___0 = sectors_to_units((u_int )regions.region[i].start);
    }
#line 366
    if (i) {
#line 366
      tmp___1 = ",";
    } else {
#line 366
      tmp___1 = "";
    }
    {
#line 366
    printf((char const   */* __restrict  */)"%s %d - %d", tmp___1, tmp___0, tmp);
#line 365
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  tmp___2 = sectors_to_units(total);
#line 371
  printf((char const   */* __restrict  */)"\nTotal disk: %d\n\n", tmp___2);
#line 373
  parn = part_allocate(part, & info);
  }
#line 375
  if (parn == 4294967294U) {
    {
#line 376
    tmp___3 = get_error();
#line 376
    printf((char const   */* __restrict  */)"Unable to allocate a new partition slot: %s\n",
           tmp___3);
    }
#line 377
    return;
  }
  {
#line 380
  printf((char const   */* __restrict  */)"Allocating partition %s%d\n\n", device,
         info.kern_part_no);
  }
  {
#line 382
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 385
    tmp___4 = sectors_to_units((u_int )info.blk_start);
    }
#line 385
    if (first) {
#line 385
      tmp___5 = "Start %s : ";
    } else {
#line 385
      tmp___5 = "Start %s (%u) : ";
    }
    {
#line 385
    l = read_line(tmp___5, units, tmp___4);
#line 388
    tmp___8 = __ctype_b_loc();
    }
#line 388
    if ((int const   )*(*tmp___8 + (int )*(l + 0)) & 2048) {
      {
#line 389
      tmp___6 = strtoul((char const   */* __restrict  */)l, (char **/* __restrict  */)((void *)0),
                        10);
#line 389
      tmp___7 = units_to_sectors((u_int )tmp___6);
#line 389
      info.blk_start = (blk_t )tmp___7;
      }
    } else
#line 390
    if (first) {
      {
#line 391
      printf((char const   */* __restrict  */)"\nPartition not created\n");
      }
#line 392
      return;
    } else
#line 390
    if ((int const   )*(l + 0) == 113) {
      {
#line 391
      printf((char const   */* __restrict  */)"\nPartition not created\n");
      }
#line 392
      return;
    }
    {
#line 395
    tmp___9 = sectors_to_units((u_int )(info.blk_end + 1UL));
    }
#line 395
    if (first) {
#line 395
      tmp___10 = "End %s   : ";
    } else {
#line 395
      tmp___10 = "End %s (%u)   : ";
    }
    {
#line 395
    l = read_line(tmp___10, units, tmp___9);
    }
#line 398
    if ((int const   )*(l + 0) == 43) {
      {
#line 399
      tmp___11 = strtoul((char const   */* __restrict  */)(l + 1), (char **/* __restrict  */)((void *)0),
                         10);
#line 399
      tmp___12 = units_to_sectors((u_int )tmp___11);
#line 399
      info.blk_end = (info.blk_start + (blk_t )tmp___12) - 1UL;
      }
    } else {
      {
#line 401
      tmp___15 = __ctype_b_loc();
      }
#line 401
      if ((int const   )*(*tmp___15 + (int )*(l + 0)) & 2048) {
        {
#line 402
        tmp___13 = strtoul((char const   */* __restrict  */)l, (char **/* __restrict  */)((void *)0),
                           10);
#line 402
        tmp___14 = units_to_sectors((u_int )tmp___13);
#line 402
        info.blk_end = (blk_t )(tmp___14 - 1U);
        }
      } else
#line 403
      if (first) {
        {
#line 404
        printf((char const   */* __restrict  */)"\nPartition not created\n");
        }
#line 405
        return;
      } else
#line 403
      if ((int const   )*(l + 0) == 113) {
        {
#line 404
        printf((char const   */* __restrict  */)"\nPartition not created\n");
        }
#line 405
        return;
      }
    }
#line 408
    info.chs_valid = (bool_t )0;
#line 409
    first = (u_int )0;
#line 411
    if (info.blk_end > info.blk_start) {
#line 411
      if (info.blk_end < (blk_t )total) {
        {
#line 412
        tmp___17 = part_create(part, parn, (partinfo_t const   *)(& info));
        }
#line 412
        if (tmp___17) {
          {
#line 413
          printf((char const   */* __restrict  */)"\nPartition %d created\n", parn);
          }
#line 414
          return;
        } else {
          {
#line 416
          tmp___16 = get_error();
#line 416
          printf((char const   */* __restrict  */)"\nUnable to create partition: %s\n\n",
                 tmp___16);
          }
        }
      } else {
        {
#line 419
        printf((char const   */* __restrict  */)"\nInvalid partition start/end\n\n");
        }
      }
    } else {
      {
#line 419
      printf((char const   */* __restrict  */)"\nInvalid partition start/end\n\n");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 423 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void change_type(void) 
{ 
  partinfo_t info ;
  u_int part_no ;
  u_int found ;
  u_int partition ;
  u_int tmp ;
  ptyp_t old_type ;
  ptyp_t new_type ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  u_int tmp___5 ;

  {
  {
#line 427
  found = (u_int )0;
#line 427
  tmp = get_part_nr();
#line 427
  partition = tmp;
#line 430
  part_no = (u_int )0;
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    tmp___0 = part_getpartinfo(part, part_no, & info);
    }
#line 430
    if (! tmp___0) {
#line 430
      goto while_break;
    }
#line 431
    if (info.kern_part_no == partition) {
#line 432
      found = (u_int )1;
#line 433
      goto while_break;
    }
#line 430
    part_no ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  if (! found) {
    {
#line 437
    printf((char const   */* __restrict  */)"Bad partition number `%d\'\n", partition);
    }
#line 438
    return;
  }
  {
#line 441
  tmp___1 = part_validops(part, part_no, (partinfo_t const   *)(& info));
  }
#line 441
  if (! (tmp___1 & 1U)) {
    {
#line 442
    printf((char const   */* __restrict  */)"Partition %d cannot be altered.\n", info.kern_part_no);
    }
#line 443
    return;
  }
#line 446
  old_type = info.type;
#line 447
  if ((unsigned int )info.type == 5U) {
    {
#line 448
    printf((char const   */* __restrict  */)"Partition %d is extended.  Delete it\n",
           info.kern_part_no);
    }
#line 449
    return;
  } else
#line 447
  if ((unsigned int )info.type == 133U) {
    {
#line 448
    printf((char const   */* __restrict  */)"Partition %d is extended.  Delete it\n",
           info.kern_part_no);
    }
#line 449
    return;
  }
  {
#line 451
  new_type = read_type(part_no, old_type, "Hex code (type L to list codes):");
  }
#line 452
  if ((unsigned int )new_type == 5U) {
    {
#line 453
    printf((char const   */* __restrict  */)"You may not change a partition to be an extended partition\n");
    }
#line 455
    return;
  } else
#line 452
  if ((unsigned int )new_type == 133U) {
    {
#line 453
    printf((char const   */* __restrict  */)"You may not change a partition to be an extended partition\n");
    }
#line 455
    return;
  }
  {
#line 457
  info.type = new_type;
#line 459
  tmp___5 = part_setpartinfo(part, part_no, (partinfo_t const   *)(& info));
  }
#line 459
  if (tmp___5) {
    {
#line 463
    tmp___3 = part_typename(part, new_type);
#line 463
    tmp___4 = part_typename(part, old_type);
#line 463
    printf((char const   */* __restrict  */)"Partition `%d\' type changed from %X (%s) to %X (%s)\n",
           partition, (unsigned int )old_type, tmp___4, (unsigned int )new_type, tmp___3);
    }
  } else {
    {
#line 460
    tmp___2 = get_error();
#line 460
    printf((char const   */* __restrict  */)"Unable to change partition %d type: %s\n",
           partition, tmp___2);
    }
  }
#line 467
  return;
}
}
#line 475 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
__inline static int is_displayable_partition(ptyp_t type ) 
{ 
  int tmp ;

  {
#line 478
  if ((unsigned int )type != 0U) {
#line 478
    if ((unsigned int )type != 258U) {
#line 478
      tmp = 1;
    } else {
#line 478
      tmp = 0;
    }
  } else {
#line 478
    tmp = 0;
  }
#line 478
  return (tmp);
}
}
#line 481 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void list_table(list_t list_type ) 
{ 
  partinfo_t info ;
  geometry_t geo ;
  int i ;
  int w ;
  char const   *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;

  {
  {
#line 486
  w = 0;
#line 488
  update_units(part);
#line 489
  part_getgeometry(part, & geo);
#line 491
  printf((char const   */* __restrict  */)"\nDisk %s: %d heads, %d sectors, %d cylinders\n",
         device, geo.heads, geo.sectors, geo.cylinders);
  }
#line 494
  if ((unsigned int )list_type == 0U) {
#line 495
    if (unit_flag) {
#line 495
      tmp = "cylinder";
    } else {
#line 495
      tmp = "sector";
    }
    {
#line 495
    printf((char const   */* __restrict  */)"Units = %ss of ", tmp);
    }
#line 497
    if (display_factor > 1U) {
      {
#line 498
      printf((char const   */* __restrict  */)"%d * ", display_factor);
      }
    }
    {
#line 499
    printf((char const   */* __restrict  */)"512 bytes\n\n");
#line 501
    tmp___0 = strlen(device);
#line 501
    w = (int )(tmp___0 + 1UL);
    }
#line 502
    if (w < 6) {
#line 503
      w = 6;
    }
    {
#line 505
    printf((char const   */* __restrict  */)"%*s Boot   Begin    Start      End   Blocks     Id   System\n",
           w, "Device");
    }
  } else {
    {
#line 508
    printf((char const   */* __restrict  */)"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl   Start    Size ID\n");
    }
  }
#line 510
  i = 0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 511
    tmp___9 = i;
#line 511
    i ++;
#line 511
    tmp___10 = part_getpartinfo(part, (u_int )tmp___9, & info);
    }
#line 511
    if (! tmp___10) {
#line 511
      goto while_break;
    }
#line 512
    if ((unsigned int )list_type == 0U) {
      {
#line 512
      tmp___1 = is_displayable_partition(info.type);
      }
#line 512
      if (! tmp___1) {
#line 513
        goto while_continue;
      }
    }
#line 515
    if ((unsigned int )list_type == 0U) {
      {
#line 516
      tmp___2 = part_typename(part, info.type);
      }
#line 516
      if (((info.blk_end - info.blk_start) + 1UL) & 1UL) {
#line 516
        tmp___3 = '+';
      } else {
#line 516
        tmp___3 = ' ';
      }
#line 516
      if (info.blk_end & 1UL) {
#line 516
        tmp___4 = 0;
      } else {
#line 516
        tmp___4 = 1;
      }
      {
#line 516
      tmp___5 = sectors_to_units((u_int )(info.blk_end + (blk_t )tmp___4));
#line 516
      tmp___6 = sectors_to_units((u_int )info.blk_start);
#line 516
      tmp___7 = calculate(part, info.chs_start.head, info.chs_start.sector, info.chs_start.cylinder);
#line 516
      tmp___8 = sectors_to_units(tmp___7);
#line 516
      printf((char const   */* __restrict  */)"%*s%-2d  %c%9d%9d%9d%11llu%c  %4x  %s\n",
             w - 1, device, info.kern_part_no, ' ', tmp___8, tmp___6, tmp___5, (unsigned long long )(((info.blk_end - info.blk_start) + 1UL) / 2UL),
             tmp___3, (unsigned int )info.type, tmp___2);
      }
    } else {
      {
#line 529
      printf((char const   */* __restrict  */)"%2d %02x%4d%4d%5d%4d%4d%5d%12llu%12llu %03x\n",
             info.kern_part_no, 0, info.chs_start.head, info.chs_start.sector, info.chs_start.cylinder,
             info.chs_end.head, info.chs_end.sector, info.chs_end.cylinder, (unsigned long long )info.blk_start,
             (unsigned long long )((info.blk_end - info.blk_start) + 1UL), (unsigned int )info.type);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return;
}
}
#line 549 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static pps_ret_t print_part_size(char const   *device___0 ) 
{ 
  pps_ret_t ret ;
  char dev_nam[16] ;
  char *p ;
  part_t *part___0 ;
  int partition ;
  unsigned short const   **tmp ;
  int i ;
  partinfo_t info ;
  u_int tmp___0 ;

  {
  {
#line 552
  ret = (pps_ret_t )2;
#line 557
  strncpy((char */* __restrict  */)(dev_nam), (char const   */* __restrict  */)device___0,
          (size_t )15);
#line 558
  dev_nam[15] = (char )'\000';
#line 560
  p = dev_nam;
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (*p) {
      {
#line 560
      tmp = __ctype_b_loc();
      }
#line 560
      if ((int const   )*(*tmp + (int )*p) & 2048) {
#line 560
        goto while_break;
      }
    } else {
#line 560
      goto while_break;
    }
#line 560
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 562
  partition = atoi((char const   *)p);
#line 563
  *p = (char )'\000';
#line 565
  part___0 = part_open((char const   *)(dev_nam), dev_part_type);
  }
#line 566
  if (part___0) {
#line 567
    i = 0;
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 570
      tmp___0 = part_getpartinfo(part___0, (u_int )i, & info);
      }
#line 570
      if (! tmp___0) {
#line 570
        goto while_break___0;
      }
#line 571
      if (info.kern_part_no == (u_int )partition) {
        {
#line 572
        printf((char const   */* __restrict  */)"%llu\n", (unsigned long long )(((info.blk_end - info.blk_start) + 1UL) / 2UL));
#line 575
        ret = (pps_ret_t )0;
        }
#line 576
        goto while_break___0;
      }
#line 578
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 580
    part___0 = part_close(part___0);
    }
  } else {
#line 582
    ret = (pps_ret_t )2;
  }
#line 584
  return (ret);
}
}
#line 593 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static int print_part_tables(int nr , char const   **parts ) 
{ 
  int i ;
  int ret ;

  {
#line 596
  ret = 1;
#line 598
  i = 0;
  {
#line 598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 598
    if (! (i < nr)) {
#line 598
      goto while_break;
    }
    {
#line 599
    device = *(parts + i);
#line 600
    part = part_open(device, dev_part_type);
    }
#line 601
    if (part) {
      {
#line 602
      list_table((list_t )0);
#line 603
      part = part_close(part);
#line 604
      ret = 0;
      }
    }
#line 598
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  return (ret);
}
}
#line 611 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void write_tables(void) 
{ 
  char const   *l ;
  int i ;
  int error ;
  int tmp ;
  char const   *tmp___0 ;
  u_int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 615
  error = 0;
#line 617
  printf((char const   */* __restrict  */)"\nWriting the partition tables is dangerous and\ncan result in loss of data.  Please confirm\nthat you really want to do this by typing \'YES\'\nexactly as shown\n\n");
#line 622
  l = read_line("Confirm: ");
#line 624
  tmp = strcmp(l, "YES");
  }
#line 624
  if (tmp) {
    {
#line 625
    printf((char const   */* __restrict  */)"\nCONFIRMATION NOT GIVEN - not updating partition table\n");
    }
#line 626
    return;
  }
  {
#line 629
  tmp___1 = part_sync(part);
  }
#line 629
  if (! tmp___1) {
    {
#line 630
    tmp___0 = get_error();
#line 630
    printf((char const   */* __restrict  */)"\nERROR occurred while updating partition tables: %s\n",
           tmp___0);
    }
#line 631
    return;
  }
  {
#line 634
  printf((char const   */* __restrict  */)"The partition table has been altered!\n\n");
#line 636
  printf((char const   */* __restrict  */)"Syncing disks...");
#line 637
  fflush(stdout);
#line 638
  sync();
#line 639
  sleep(2U);
#line 640
  sync();
#line 642
  printf((char const   */* __restrict  */)"OK\nRe-reading the partition table...");
#line 643
  fflush(stdout);
#line 645
  i = ioctl((part->blkio)->fd, (unsigned long )((unsigned int )(18 << 8) | 95U));
  }
#line 646
  if (i != 0) {
    {
#line 647
    tmp___2 = __errno_location();
#line 647
    error = *tmp___2;
    }
  } else {
    {
#line 649
    printf((char const   */* __restrict  */)" resyncing...");
#line 650
    fflush(stdout);
#line 651
    sync();
#line 652
    sleep(2U);
#line 653
    i = ioctl((part->blkio)->fd, (unsigned long )((unsigned int )(18 << 8) | 95U));
    }
#line 654
    if (i != 0) {
      {
#line 655
      tmp___3 = __errno_location();
#line 655
      error = *tmp___3;
      }
    }
  }
#line 658
  if (i < 0) {
    {
#line 659
    printf((char const   */* __restrict  */)"FAILED!\n");
    }
  }
  {
#line 662
  printf((char const   */* __restrict  */)"Syncing disks...");
#line 663
  fflush(stdout);
#line 664
  sync();
#line 665
  sleep(4U);
#line 666
  printf((char const   */* __restrict  */)"OK\n");
  }
#line 674
  if (i < 0) {
    {
#line 675
    tmp___4 = strerror(error);
#line 675
    printf((char const   */* __restrict  */)"\n*** Re-read table failed with error %d: %s ***\n  Reboot your system to ensure the partition table is\n  updated.\n",
           error, tmp___4);
    }
  }
  {
#line 678
  exit(0);
  }
}
}
#line 681 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void show_main_menu(void) 
{ 


  {
  {
#line 684
  printf((char const   */* __restrict  */)"\nCommand action\n   d    delete a partition\n   m    print this menu\n   n    add a new partition\n   p    print the partition table\n   q    quit without saving changes\n   r    reopen partition, specifying type\n   t    change a partition\'s system id\n   u    change display/entry units\n   w    write table to disk and exit\n");
  }
#line 698
  return;
}
}
#line 709 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static char *scheme  ;
#line 703 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static void main_menu(void) 
{ 
  int quit ;
  part_t *new_part ;
  char const   *s ;
  char tmp ;
  int tmp___0 ;

  {
  {
#line 706
  quit = 0;
#line 711
  show_main_menu();
  }
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 714
    putchar('\n');
#line 715
    tmp = read_char("Command (m for help): ");
#line 715
    tmp___0 = tolower((int )tmp);
    }
    {
#line 716
    if (tmp___0 == 100) {
#line 716
      goto case_100;
    }
#line 722
    if (tmp___0 == 101) {
#line 722
      goto case_101;
    }
#line 738
    if (tmp___0 == 110) {
#line 738
      goto case_110;
    }
#line 744
    if (tmp___0 == 112) {
#line 744
      goto case_112;
    }
#line 750
    if (tmp___0 == 113) {
#line 750
      goto case_113;
    }
#line 753
    if (tmp___0 == 114) {
#line 753
      goto case_114;
    }
#line 771
    if (tmp___0 == 116) {
#line 771
      goto case_116;
    }
#line 777
    if (tmp___0 == 117) {
#line 777
      goto case_117;
    }
#line 780
    if (tmp___0 == 119) {
#line 780
      goto case_119;
    }
#line 735
    goto switch_default;
    case_100: /* CIL Label */ 
#line 717
    if (part) {
      {
#line 718
      delete_partition();
      }
    } else {
#line 720
      goto unavailable;
    }
#line 721
    goto switch_break;
    case_101: /* CIL Label */ 
#line 723
    if (part) {
      {
#line 724
      list_table((list_t )1);
      }
    } else {
#line 726
      goto unavailable;
    }
#line 727
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 736
    show_main_menu();
    }
#line 737
    goto switch_break;
    case_110: /* CIL Label */ 
#line 739
    if (part) {
      {
#line 740
      new_partition();
      }
    } else {
#line 742
      goto unavailable;
    }
#line 743
    goto switch_break;
    case_112: /* CIL Label */ 
#line 745
    if (part) {
      {
#line 746
      list_table((list_t )0);
      }
    } else {
#line 748
      goto unavailable;
    }
#line 749
    goto switch_break;
    case_113: /* CIL Label */ 
#line 751
    quit = 1;
#line 752
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 754
    s = read_line("Partitioning scheme: ");
#line 755
    new_part = part_open(device, s);
    }
#line 756
    if (new_part) {
#line 757
      if (scheme) {
        {
#line 758
        free((void *)scheme);
        }
      }
      {
#line 759
      part_close(part);
#line 760
      part = new_part;
#line 761
      scheme = strdup(s);
#line 761
      dev_part_type = (char const   *)scheme;
#line 762
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s successfully reopened using %s scheme\n",
              device, dev_part_type);
      }
    } else
#line 764
    if (part) {
      {
#line 765
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unable to reopen partition as %s,\nusing %s instead.\n",
              progname, device, s, dev_part_type);
      }
    } else {
      {
#line 768
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s; %s: unable to reopen partition as %s\n",
              progname, device, s);
      }
    }
#line 770
    goto switch_break;
    case_116: /* CIL Label */ 
#line 772
    if (part) {
      {
#line 773
      change_type();
      }
    } else {
#line 775
      goto unavailable;
    }
#line 776
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 778
    change_units(part);
    }
#line 779
    goto switch_break;
    case_119: /* CIL Label */ 
#line 781
    if (part) {
      {
#line 782
      write_tables();
      }
#line 783
      goto switch_break;
    }
    unavailable: 
    {
#line 786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: option ignored - please re-open the device\n",
            progname, device);
    }
#line 788
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 713
    if (! (! quit)) {
#line 713
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 791
  return;
}
}
#line 798 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
static u_int edit_device(char const   *dev_nam ) 
{ 
  u_int use_default ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 801
  use_default = (u_int )((unsigned long )dev_nam == (unsigned long )((void *)0));
#line 803
  if (use_default) {
    {
#line 804
    device = "/dev/hda";
#line 805
    part = part_open(device, dev_part_type);
    }
#line 806
    if (! part) {
      {
#line 807
      device = "/dev/sda";
#line 808
      part = part_open("/dev/sda", dev_part_type);
      }
    }
  } else {
    {
#line 811
    device = dev_nam;
#line 812
    part = part_open(device, dev_part_type);
    }
  }
#line 815
  if (use_default) {
    {
#line 816
    printf((char const   */* __restrict  */)"\nUsing %s as default device\n", device);
    }
  }
#line 818
  if (! part) {
    {
#line 819
    tmp = get_error();
#line 819
    printf((char const   */* __restrict  */)"Unable to open device %s: %s\n\n  Please use \'r\' to open the partition as a specific type\n\n",
           device, tmp);
    }
  } else {
    {
#line 823
    tmp___0 = part_getscheme(part);
#line 823
    printf((char const   */* __restrict  */)"\nDevice %s is partitioned using %s scheme\n",
           device, tmp___0);
    }
  }
  {
#line 826
  main_menu();
  }
#line 828
  return ((u_int )0);
}
}
#line 831 "/home/june/collector/temp/acorn-fdisk-3.0.6/fdisk.c"
int main(int argc , char **argv ) 
{ 
  prog_mode_t mode ;
  u_int ret ;
  pps_ret_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 834
  ret = (u_int )1;
#line 836
  progname = (char const   *)*(argv + 0);
#line 837
  mode = parse_args(argc, argv);
  }
  {
#line 840
  if ((unsigned int )mode == 1U) {
#line 840
    goto case_1;
  }
#line 844
  if ((unsigned int )mode == 2U) {
#line 844
    goto case_2;
  }
#line 856
  if ((unsigned int )mode == 4U) {
#line 856
    goto case_4;
  }
#line 872
  if ((unsigned int )mode == 3U) {
#line 872
    goto case_3;
  }
#line 879
  if ((unsigned int )mode == 0U) {
#line 879
    goto case_0___0;
  }
#line 891
  if ((unsigned int )mode == 5U) {
#line 891
    goto bad;
  }
#line 839
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 841
  printf((char const   */* __restrict  */)"arm-fdisk v3.0.6\n");
  }
#line 842
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 845
  printf((char const   */* __restrict  */)"Usage: %s [OPTION] [DEVICE]...\n", progname);
#line 846
  printf((char const   */* __restrict  */)"Display or edit partition tables on block devices.\n\n");
#line 847
  printf((char const   */* __restrict  */)"      --type SCHEME     specify the partitioning scheme to use on the device\n");
#line 848
  printf((char const   */* __restrict  */)"  -l, --list DEVICE...  list partition information on devices\n");
#line 849
  printf((char const   */* __restrict  */)"                        or all devices\n");
#line 850
  printf((char const   */* __restrict  */)"  -s, --size DEVICE     display size of partition\n");
#line 851
  printf((char const   */* __restrict  */)"      --help            display this help and exit\n");
#line 852
  printf((char const   */* __restrict  */)"      --version         output version information and exit\n\n");
#line 853
  printf((char const   */* __restrict  */)"With no DEVICE, partition /dev/hda or /dev/sda\n");
  }
#line 854
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 857
  tmp = print_part_size(device);
  }
  {
#line 858
  if ((unsigned int )tmp == 0U) {
#line 858
    goto case_0;
  }
#line 862
  if ((unsigned int )tmp == 1U) {
#line 862
    goto case_1___0;
  }
#line 866
  if ((unsigned int )tmp == 2U) {
#line 866
    goto case_2___0;
  }
#line 857
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 859
  ret = (u_int )0;
#line 860
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 863
  tmp___0 = get_error();
#line 863
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s: %s\n",
          device, tmp___0);
  }
#line 864
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 867
  ret = (u_int )1;
#line 868
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 870
  goto switch_break;
  case_3: /* CIL Label */ 
#line 873
  if (optind < argc) {
    {
#line 874
    tmp___1 = print_part_tables(argc - optind, (char const   **)argv + optind);
#line 874
    ret = (u_int )tmp___1;
    }
  } else {
    {
#line 876
    tmp___2 = print_part_tables(12, part_devs);
#line 876
    ret = (u_int )tmp___2;
    }
  }
#line 877
  goto switch_break;
  case_0___0: /* CIL Label */ 
#line 880
  if (optind < argc - 1) {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Partitioning is only allowed on a single device\n");
    }
#line 882
    goto bad;
  }
#line 884
  if (optind == argc) {
    {
#line 885
    ret = edit_device((char const   *)((void *)0));
    }
  } else {
    {
#line 887
    ret = edit_device((char const   *)*(argv + optind));
    }
  }
#line 888
  goto switch_break;
  bad: 
  case_5: /* CIL Label */ 
  {
#line 892
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help` for more information.\n",
          progname);
#line 893
  ret = (u_int )1;
  }
#line 894
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 897
  return ((int )ret);
}
}
#line 16 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getscheme.c"
char const   *part_getscheme(part_t *part___0 ) 
{ 
  char const   *tmp ;

  {
#line 18
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 18
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getscheme.c",
                  18U, "part_getscheme");
    }
  }
#line 20
  if (part___0->scheme) {
#line 20
    tmp = (part___0->scheme)->name;
  } else {
#line 20
    tmp = (char const   *)((void *)0);
  }
#line 20
  return (tmp);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 14 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
static struct __anonstruct_part_types_47  const  part_types[46]  = 
#line 14 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
  {      {(ptyp_t )0, "None"}, 
        {(ptyp_t )1, "DOS-12"}, 
        {(ptyp_t )2, "XENIX root"}, 
        {(ptyp_t )3, "XENIX /usr"}, 
        {(ptyp_t )4, "DOS-16 < 32MB"}, 
        {(ptyp_t )5, "DOS Extended"}, 
        {(ptyp_t )6, "DOS-16 >= 32MB"}, 
        {(ptyp_t )7, "HPFS"}, 
        {(ptyp_t )8, "AIX"}, 
        {(ptyp_t )9, "AIX Boot"}, 
        {(ptyp_t )10, "OS/2"}, 
        {(ptyp_t )15, "Win98 Extended"}, 
        {(ptyp_t )64, "VENIX"}, 
        {(ptyp_t )81, "Novel"}, 
        {(ptyp_t )81, "DM6 Aux1"}, 
        {(ptyp_t )82, "MicroPort"}, 
        {(ptyp_t )83, "DM6 Aux3"}, 
        {(ptyp_t )84, "Disk Manager 6"}, 
        {(ptyp_t )85, "EZ-Drive"}, 
        {(ptyp_t )99, "GNU Hurd"}, 
        {(ptyp_t )100, "NovelNet 286"}, 
        {(ptyp_t )101, "NovelNet 386"}, 
        {(ptyp_t )117, "PCiX"}, 
        {(ptyp_t )128, "Old MINIX"}, 
        {(ptyp_t )129, "Minix"}, 
        {(ptyp_t )130, "Linux Swap"}, 
        {(ptyp_t )131, "Linux Native"}, 
        {(ptyp_t )133, "Linux Extended"}, 
        {(ptyp_t )147, "AMOEBA"}, 
        {(ptyp_t )148, "AMOEBA BBT"}, 
        {(ptyp_t )165, "BSD 386"}, 
        {(ptyp_t )183, "BSDi FS"}, 
        {(ptyp_t )184, "BSDi Swap"}, 
        {(ptyp_t )199, "Syrinx"}, 
        {(ptyp_t )219, "CP/M"}, 
        {(ptyp_t )225, "DOS Access"}, 
        {(ptyp_t )227, "DOS R/O"}, 
        {(ptyp_t )242, "DOS SCC"}, 
        {(ptyp_t )255, "Bad Block Table"}, 
        {(ptyp_t )256, "Filecore"}, 
        {(ptyp_t )257, "Linux Table"}, 
        {(ptyp_t )258, "BIOS Table"}, 
        {(ptyp_t )259, "Filecore OldMap"}, 
        {(ptyp_t )260, "PowerTec Backup"}, 
        {(ptyp_t )261, "Empty"}, 
        {(ptyp_t )0, (char const   *)((void *)0)}};
#line 79 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
static char buf___0[32]  ;
#line 77 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
char const   *part_typename(part_t *part___0 , ptyp_t type ) 
{ 
  char const   *name ;
  u_int i ;

  {
#line 83
  if ((unsigned int )type == 65534U) {
#line 84
    return ("Reserved/Free");
  }
#line 85
  if ((unsigned int )type == 65535U) {
#line 86
    return ("Unknown");
  }
#line 88
  i = (u_int )0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! part_types[i].name) {
#line 88
      goto while_break;
    }
#line 89
    if ((unsigned int const   )part_types[i].type == (unsigned int const   )type) {
#line 90
      goto while_break;
    }
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  if (part_types[i].name) {
#line 93
    name = (char const   *)part_types[i].name;
  } else {
    {
#line 95
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Unknown type %d",
            (unsigned int )type);
#line 96
    name = (char const   *)(buf___0);
    }
  }
#line 99
  return (name);
}
}
#line 112 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
static ptyp_t types[3]  = {      (ptyp_t )130,      (ptyp_t )131,      (ptyp_t )256};
#line 110 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/types.c"
ptyp_t part_nexttype(part_t *part___0 , u_int parn , ptyp_t current , int dir ) 
{ 
  ptyp_t ptype ;
  int i ;

  {
#line 117
  if ((part___0->scheme)->nexttype) {
    {
#line 118
    ptype = (*((part___0->scheme)->nexttype))(part___0, parn, current, dir);
    }
  } else {
#line 120
    i = 0;
    {
#line 120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 120
      if (! ((unsigned long )i < sizeof(types) / sizeof(ptyp_t ))) {
#line 120
        goto while_break;
      }
#line 121
      if ((unsigned int )types[i] == (unsigned int )current) {
#line 122
        goto while_break;
      }
#line 120
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 124
    if ((unsigned int )types[i] == (unsigned int )current) {
#line 125
      i += dir;
#line 127
      if (i < 0) {
#line 128
        i = 0;
      }
#line 130
      if ((unsigned long )i >= sizeof(types) / sizeof(ptyp_t )) {
#line 131
        i = (int )(sizeof(types) / sizeof(ptyp_t ) - 1UL);
      }
    }
#line 134
    ptype = types[i];
  }
#line 137
  return (ptype);
}
}
#line 18 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/sync.c"
u_int part_sync(part_t *part___0 ) 
{ 
  u_int ret ;
  char const   *tmp ;

  {
#line 20
  ret = (u_int )0;
#line 21
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 21
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/sync.c",
                  21U, "part_sync");
    }
  }
#line 22
  if (! ((unsigned long )part___0->scheme != (unsigned long )((void *)0))) {
    {
#line 22
    __assert_fail("part->scheme != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/sync.c",
                  22U, "part_sync");
    }
  }
  {
#line 24
  dbg_printf("part_sync()");
#line 25
  dbg_level_up();
  }
#line 27
  if ((part___0->scheme)->writeinfo) {
    {
#line 28
    ret = (*((part___0->scheme)->writeinfo))(part___0);
    }
  } else {
    {
#line 30
    set_error("partition style does not support writing of partition information");
    }
  }
  {
#line 32
  dbg_level_down();
  }
#line 33
  if (ret) {
#line 33
    tmp = "";
  } else {
#line 33
    tmp = "not ";
  }
  {
#line 33
  dbg_printf("ret %sok", tmp);
  }
#line 35
  return (ret);
}
}
#line 17 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/close.c"
part_t *part_close(part_t *part___0 ) 
{ 


  {
  {
#line 19
  dbg_printf("part_close()");
#line 20
  dbg_level_up();
  }
#line 22
  if (part___0) {
    {
#line 23
    blkio_close(part___0->blkio);
    }
#line 24
    if (part___0->partinfo) {
      {
#line 25
      free((void *)part___0->partinfo);
      }
    }
    {
#line 26
    free((void *)part___0);
    }
  }
  {
#line 29
  dbg_level_down();
#line 30
  dbg_printf("ret=NULL");
  }
#line 32
  return ((part_t *)((void *)0));
}
}
#line 27 "../util/error.h"
extern u_int is_error_set(void) ;
#line 32
extern void clear_error(void) ;
#line 22 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/create.c"
u_int part_create(part_t *part___0 , u_int parn , partinfo_t const   *pinfo ) 
{ 
  partinfo_t pnew ;
  u_int ret ;
  u_int tmp ;
  u_int tmp___0 ;
  partinfo_i_t **p ;
  u_int new_nr ;
  void *tmp___1 ;
  void *tmp___2 ;
  partinfo_t *tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
#line 25
  ret = (u_int )0;
#line 27
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 27
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/create.c",
                  27U, "part_create");
    }
  }
#line 28
  if (! ((unsigned long )part___0->scheme != (unsigned long )((void *)0))) {
    {
#line 28
    __assert_fail("part->scheme != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/create.c",
                  28U, "part_create");
    }
  }
#line 29
  if (! ((unsigned long )pinfo != (unsigned long )((void *)0))) {
    {
#line 29
    __assert_fail("pinfo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/create.c",
                  29U, "part_create");
    }
  }
  {
#line 31
  pnew = (partinfo_t )*pinfo;
#line 33
  dbg_printf("part_create(parn=%d, pinfo=[bs=0x%X, be=0x%X, type=0x%X])", parn, pnew.blk_start,
             pnew.blk_end, (unsigned int )pnew.type);
#line 35
  dbg_level_up();
#line 36
  clear_error();
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    tmp = part_updatechs(part___0, & pnew);
    }
#line 39
    if (! tmp) {
#line 40
      goto while_break;
    }
#line 42
    if (parn == 4294967295U) {
      {
#line 43
      parn = (*((part___0->scheme)->allocate))(part___0, & pnew);
      }
    }
#line 44
    if (parn == 4294967294U) {
      {
#line 45
      tmp___0 = is_error_set();
      }
#line 45
      if (! tmp___0) {
        {
#line 46
        set_error("unable to allocate slot for partition");
        }
      }
#line 47
      goto while_break;
    }
    {
#line 50
    tmp___6 = (*((part___0->scheme)->validate_partno))(part___0, parn);
    }
#line 50
    if (tmp___6) {
#line 51
      if (part___0->nr_partitions == 0U) {
#line 51
        goto _L;
      } else
#line 51
      if (parn >= part___0->nr_partitions) {
        _L: /* CIL Label */ 
        {
#line 53
        new_nr = parn + 1U;
#line 55
        tmp___1 = malloc((unsigned long )new_nr * sizeof(*p));
#line 55
        p = (partinfo_i_t **)tmp___1;
        }
#line 56
        if (p) {
          {
#line 57
          memset((void *)p, 0, (unsigned long )new_nr * sizeof(*p));
#line 58
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)part___0->partinfo,
                 (unsigned long )part___0->nr_partitions * sizeof(*p));
#line 59
          free((void *)part___0->partinfo);
#line 60
          part___0->partinfo = p;
#line 61
          part___0->nr_partitions = new_nr;
          }
        } else {
          {
#line 63
          set_error("out of memory");
          }
#line 64
          goto while_break;
        }
      }
#line 68
      if (*(part___0->partinfo + parn)) {
#line 68
        tmp___3 = & (*(part___0->partinfo + parn))->info;
      } else {
#line 68
        tmp___3 = (partinfo_t *)((void *)0);
      }
      {
#line 68
      tmp___4 = (*((part___0->scheme)->validate_creation))(part___0, parn, (partinfo_t const   *)tmp___3,
                                                           (partinfo_t const   *)(& pnew));
      }
#line 68
      if (tmp___4) {
#line 70
        if (! *(part___0->partinfo + parn)) {
          {
#line 71
          tmp___2 = malloc(sizeof(partinfo_i_t ));
#line 71
          *(part___0->partinfo + parn) = (partinfo_i_t *)tmp___2;
          }
        }
#line 72
        if (*(part___0->partinfo + parn)) {
#line 73
          (*(part___0->partinfo + parn))->changed = (bool_t )1;
#line 74
          (*(part___0->partinfo + parn))->info = pnew;
#line 75
          ret = (u_int )1;
        }
      }
    } else {
      {
#line 78
      tmp___5 = is_error_set();
      }
#line 78
      if (! tmp___5) {
        {
#line 79
        set_error("part_create: invalid partition number %d", parn);
        }
      }
    }
#line 38
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  dbg_level_down();
#line 83
  dbg_printf("ret=%d", ret);
  }
#line 85
  return (ret);
}
}
#line 20 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/delete.c"
u_int part_delete(part_t *part___0 , u_int parn ) 
{ 
  u_int ret ;
  u_int tmp ;
  u_int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 22
  ret = (u_int )0;
#line 24
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 24
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/delete.c",
                  24U, "part_delete");
    }
  }
#line 25
  if (part___0->nr_partitions) {
#line 25
    if (! (parn < part___0->nr_partitions)) {
      {
#line 25
      __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/delete.c",
                    25U, "part_delete");
      }
    }
  } else {
    {
#line 25
    __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/delete.c",
                  25U, "part_delete");
    }
  }
  {
#line 27
  dbg_printf("part_delete(%d)", parn);
#line 28
  dbg_level_up();
#line 29
  clear_error();
  }
#line 31
  if (*(part___0->partinfo + parn)) {
    {
#line 31
    tmp = (*((part___0->scheme)->validate_deletion))(part___0, parn, (partinfo_t const   *)(& (*(part___0->partinfo + parn))->info));
    }
#line 31
    if (tmp) {
      {
#line 33
      free((void *)*(part___0->partinfo + parn));
#line 34
      *(part___0->partinfo + parn) = (partinfo_i_t *)((void *)0);
#line 35
      ret = (u_int )1;
      }
    }
  }
#line 38
  if (ret == 0U) {
    {
#line 38
    tmp___0 = is_error_set();
    }
#line 38
    if (! tmp___0) {
      {
#line 39
      set_error("partition cannot be deleted");
      }
    }
  }
  {
#line 41
  dbg_level_down();
  }
#line 42
  if (ret) {
#line 42
    tmp___1 = "ok";
  } else {
#line 42
    tmp___1 = "error";
  }
  {
#line 42
  dbg_printf("ret %s", tmp___1);
  }
#line 44
  return (ret);
}
}
#line 21 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getpinfo.c"
u_int part_getpartinfo(part_t *part___0 , u_int parn , partinfo_t *pinfo ) 
{ 
  u_int ret ;

  {
#line 23
  ret = (u_int )0;
#line 25
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 25
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getpinfo.c",
                  25U, "part_getpartinfo");
    }
  }
#line 26
  if (! ((unsigned long )pinfo != (unsigned long )((void *)0))) {
    {
#line 26
    __assert_fail("pinfo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getpinfo.c",
                  26U, "part_getpartinfo");
    }
  }
  {
#line 28
  dbg_printf("part_getpartinfo(parn=%d)", parn);
#line 29
  dbg_level_up();
  }
#line 31
  if (part___0->nr_partitions) {
#line 31
    if (parn < part___0->nr_partitions) {
#line 32
      if (*(part___0->partinfo + parn)) {
#line 33
        *pinfo = (*(part___0->partinfo + parn))->info;
      } else {
        {
#line 35
        memset((void *)pinfo, 0, sizeof(*pinfo));
        }
      }
#line 36
      ret = (u_int )1;
    } else {
      {
#line 38
      set_error("part_getpinfo: invalid partition number %d", parn);
      }
    }
  } else {
    {
#line 38
    set_error("part_getpinfo: invalid partition number %d", parn);
    }
  }
  {
#line 40
  dbg_level_down();
  }
#line 41
  if (ret) {
    {
#line 42
    dbg_printf("ret ok, pinfo=[bs=0x%X, be=0x%X, type=0x%X]", pinfo->blk_start, pinfo->blk_end,
               (unsigned int )pinfo->type);
    }
  } else {
    {
#line 45
    dbg_printf("ret error");
    }
  }
#line 47
  return (ret);
}
}
#line 89 "../blkio/blkio.h"
extern u_int blkio_read(blkio_t *blkio , void *data , blk_t block , u_int nr_blocks ) ;
#line 203 "../part/part.h"
u_int part_read(part_t *part___0 , u_int parn , void *data , blk_t blk , u_int nr_blks ) ;
#line 21 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/read.c"
u_int part_read(part_t *part___0 , u_int parn , void *data , blk_t blk , u_int nr_blks ) 
{ 
  partinfo_i_t *pinfo ;
  u_int ret ;

  {
#line 24
  ret = (u_int )0;
#line 26
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 26
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/read.c",
                  26U, "part_read");
    }
  }
#line 27
  if (part___0->nr_partitions) {
#line 27
    if (! (parn < part___0->nr_partitions)) {
      {
#line 27
      __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/read.c",
                    27U, "part_read");
      }
    }
  } else {
    {
#line 27
    __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/read.c",
                  27U, "part_read");
    }
  }
#line 28
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    {
#line 28
    __assert_fail("data != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/read.c",
                  28U, "part_read");
    }
  }
  {
#line 30
  dbg_printf("part_read(parn=%d, data=%p, blk=0x%X, nr=0x%X)", parn, data, blk, nr_blks);
#line 31
  dbg_level_up();
#line 33
  pinfo = *(part___0->partinfo + parn);
  }
#line 35
  if (pinfo) {
#line 36
    blk += pinfo->info.blk_start;
#line 37
    if ((blk_t )nr_blks <= pinfo->info.blk_end - pinfo->info.blk_start) {
#line 37
      if (blk < pinfo->info.blk_end - (blk_t )nr_blks) {
        {
#line 39
        ret = blkio_read(part___0->blkio, data, blk, nr_blks);
        }
      }
    }
  }
  {
#line 42
  dbg_level_down();
#line 43
  dbg_printf("ret=%d", ret);
  }
#line 45
  return (ret);
}
}
#line 78 "../blkio/blkio.h"
extern u_int blkio_setgeometry(blkio_t *blkio , geometry_t const   *geo ) ;
#line 212 "../part/part.h"
u_int part_setgeometry(part_t *part___0 , geometry_t const   *geo ) ;
#line 20 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setgeo.c"
u_int part_setgeometry(part_t *part___0 , geometry_t const   *geo ) 
{ 
  u_int ret ;
  u_int i ;

  {
#line 24
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 24
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setgeo.c",
                  24U, "part_setgeometry");
    }
  }
#line 25
  if (! ((unsigned long )geo != (unsigned long )((void *)0))) {
    {
#line 25
    __assert_fail("geo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setgeo.c",
                  25U, "part_setgeometry");
    }
  }
  {
#line 27
  dbg_printf("part_setgeometry()");
#line 28
  dbg_level_up();
#line 30
  ret = blkio_setgeometry(part___0->blkio, geo);
  }
#line 31
  if (ret) {
#line 34
    i = (u_int )0;
    {
#line 34
    while (1) {
      while_continue: /* CIL Label */ ;
#line 34
      if (! (i < part___0->nr_partitions)) {
#line 34
        goto while_break;
      }
#line 35
      if (*(part___0->partinfo + i)) {
        {
#line 36
        (*(part___0->partinfo + i))->info.chs_valid = (bool_t )0;
#line 37
        part_updatechs(part___0, & (*(part___0->partinfo + i))->info);
        }
      }
#line 34
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 41
  dbg_level_down();
#line 42
  dbg_printf("ret=%d", ret);
  }
#line 44
  return (ret);
}
}
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 95 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/blkio/write.c"
static u_int write_block(blkio_t *blkio , void const   *data , blk_t block , u_int nr_blocks ) 
{ 
  u_int len ;
  u_int res ;
  loff_t loff ;
  __off64_t tmp ;
  ssize_t tmp___0 ;

  {
#line 97
  res = (u_int )0;
#line 100
  loff = (loff_t )block * (loff_t )blkio->blocksize;
#line 101
  len = nr_blocks * (u_int )blkio->blocksize;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp = lseek(blkio->fd, loff, 0);
    }
#line 104
    if (tmp != loff) {
#line 105
      goto while_break;
    }
    {
#line 107
    tmp___0 = write(blkio->fd, data, (size_t )len);
    }
#line 107
    if (tmp___0 != (ssize_t )len) {
#line 108
      goto while_break;
    }
#line 110
    res = nr_blocks;
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (res);
}
}
#line 126 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/blkio/write.c"
u_int blkio_write(blkio_t *blkio , void const   *data , blk_t block , u_int nr_blocks ) 
{ 
  u_int res ;

  {
  {
#line 130
  dbg_printf("blkio_write(%p 0x%X +0x%X)", data, block, nr_blocks);
#line 131
  dbg_level_up();
#line 133
  res = write_block(blkio, data, block, nr_blocks);
#line 135
  dbg_level_down();
#line 136
  dbg_printf("ret=%d", res);
  }
#line 138
  return (res);
}
}
#line 20 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setpinfo.c"
u_int part_setpartinfo(part_t *part___0 , u_int parn , partinfo_t const   *pinfo ) 
{ 
  partinfo_t pnew ;
  u_int ret ;
  u_int tmp ;
  char const   *tmp___0 ;

  {
#line 23
  ret = (u_int )0;
#line 25
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 25
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setpinfo.c",
                  25U, "part_setpartinfo");
    }
  }
#line 26
  if (part___0->nr_partitions) {
#line 26
    if (! (parn < part___0->nr_partitions)) {
      {
#line 26
      __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setpinfo.c",
                    26U, "part_setpartinfo");
      }
    }
  } else {
    {
#line 26
    __assert_fail("part->nr_partitions && parn < part->nr_partitions", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setpinfo.c",
                  26U, "part_setpartinfo");
    }
  }
#line 27
  if (! ((unsigned long )pinfo != (unsigned long )((void *)0))) {
    {
#line 27
    __assert_fail("pinfo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setpinfo.c",
                  27U, "part_setpartinfo");
    }
  }
#line 28
  if (! part___0->scheme) {
    {
#line 28
    __assert_fail("part->scheme", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/setpinfo.c",
                  28U, "part_setpartinfo");
    }
  }
  {
#line 30
  pnew = (partinfo_t )*pinfo;
#line 32
  dbg_printf("part_setpartinfo(parn=%d, pinfo=[bs=0x%X, be=0x%X, type=0x%X])", parn,
             pinfo->blk_start, pinfo->blk_end, (unsigned int const   )pinfo->type);
#line 34
  dbg_level_up();
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 37
    tmp = part_updatechs(part___0, & pnew);
    }
#line 37
    if (! tmp) {
#line 38
      goto while_break;
    }
#line 40
    if (*(part___0->partinfo + parn)) {
      {
#line 41
      ret = (*((part___0->scheme)->validate_change))(part___0, parn, (partinfo_t const   *)(& (*(part___0->partinfo + parn))->info),
                                                     (partinfo_t const   *)(& pnew));
      }
#line 42
      if (ret) {
#line 43
        (*(part___0->partinfo + parn))->info = pnew;
#line 44
        (*(part___0->partinfo + parn))->changed = (bool_t )1;
      }
    } else {
      {
#line 47
      set_error("no partition defined for partition %d", parn);
      }
    }
#line 36
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  dbg_level_down();
  }
#line 51
  if (ret) {
#line 51
    tmp___0 = "ok";
  } else {
#line 51
    tmp___0 = "error";
  }
  {
#line 51
  dbg_printf("ret %s", tmp___0);
  }
#line 53
  return (ret);
}
}
#line 56 "../blkio/blkio.h"
extern u_int blkio_getgeometry(blkio_t *blkio , geometry_t *geo ) ;
#line 19 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getgeo.c"
u_int part_getgeometry(part_t *part___0 , geometry_t *geo ) 
{ 
  u_int ret ;
  char const   *tmp ;

  {
#line 23
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 23
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getgeo.c",
                  23U, "part_getgeometry");
    }
  }
#line 24
  if (! ((unsigned long )geo != (unsigned long )((void *)0))) {
    {
#line 24
    __assert_fail("geo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/getgeo.c",
                  24U, "part_getgeometry");
    }
  }
  {
#line 26
  dbg_printf("part_getgeometry()");
#line 27
  dbg_level_up();
#line 29
  ret = blkio_getgeometry(part___0->blkio, geo);
#line 31
  dbg_level_down();
  }
#line 32
  if (ret) {
#line 32
    tmp = "ok";
  } else {
#line 32
    tmp = "error";
  }
  {
#line 32
  dbg_printf("ret %s", tmp);
  }
#line 34
  return (ret);
}
}
#line 22 "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/allocate.c"
u_int part_allocate(part_t *part___0 , partinfo_t *pinfo ) 
{ 
  u_int parn ;
  u_int tmp ;
  partinfo_i_t **p ;
  u_int new_nr ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;

  {
#line 26
  if (! ((unsigned long )part___0 != (unsigned long )((void *)0))) {
    {
#line 26
    __assert_fail("part != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/allocate.c",
                  26U, "part_allocate");
    }
  }
#line 27
  if (! ((unsigned long )part___0->scheme != (unsigned long )((void *)0))) {
    {
#line 27
    __assert_fail("part->scheme != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/allocate.c",
                  27U, "part_allocate");
    }
  }
#line 28
  if (! ((unsigned long )pinfo != (unsigned long )((void *)0))) {
    {
#line 28
    __assert_fail("pinfo != ((void *)0)", "/home/june/collector/temp/acorn-fdisk-3.0.6/lib/part/allocate.c",
                  28U, "part_allocate");
    }
  }
  {
#line 30
  dbg_printf("part_allocate(pinfo=[bs=0x%X, be=0x%X, type=0x%X])", pinfo->blk_start,
             pinfo->blk_end, (unsigned int )pinfo->type);
#line 32
  dbg_level_up();
#line 33
  clear_error();
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 36
    parn = (*((part___0->scheme)->allocate))(part___0, pinfo);
    }
#line 37
    if (parn == 4294967294U) {
      {
#line 38
      tmp = is_error_set();
      }
#line 38
      if (! tmp) {
        {
#line 39
        set_error("unable to allocate slot for partition");
        }
      }
#line 40
      goto while_break;
    }
    {
#line 43
    tmp___2 = (*((part___0->scheme)->validate_partno))(part___0, parn);
    }
#line 43
    if (tmp___2) {
#line 44
      if (part___0->nr_partitions == 0U) {
#line 44
        goto _L;
      } else
#line 44
      if (parn >= part___0->nr_partitions) {
        _L: /* CIL Label */ 
        {
#line 46
        new_nr = parn + 1U;
#line 48
        tmp___0 = malloc((unsigned long )new_nr * sizeof(*p));
#line 48
        p = (partinfo_i_t **)tmp___0;
        }
#line 49
        if (p) {
          {
#line 50
          memset((void *)p, 0, (unsigned long )new_nr * sizeof(*p));
#line 51
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)part___0->partinfo,
                 (unsigned long )part___0->nr_partitions * sizeof(*p));
#line 52
          free((void *)part___0->partinfo);
#line 53
          part___0->partinfo = p;
#line 54
          part___0->nr_partitions = new_nr;
          }
        } else {
          {
#line 56
          set_error("out of memory");
          }
#line 57
          goto while_break;
        }
      }
    } else {
      {
#line 60
      tmp___1 = is_error_set();
      }
#line 60
      if (! tmp___1) {
        {
#line 61
        set_error("part_allocate: invalid partition number %d", parn);
        }
      }
    }
#line 35
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 64
  dbg_level_down();
#line 65
  dbg_printf("ret=%d (kern_part_no=%d)", parn, pinfo->kern_part_no);
  }
#line 67
  return (parn);
}
}
