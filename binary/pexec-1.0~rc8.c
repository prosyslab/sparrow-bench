/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.h"
struct __anonstruct_fifo_26 {
   unsigned char *buffer ;
   size_t size ;
   size_t rpnt ;
   size_t wrts ;
};
#line 27 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.h"
typedef struct __anonstruct_fifo_26 fifo;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 27 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.h"
struct __anonstruct_linebuffer_29 {
   char *buffer ;
   size_t length ;
};
#line 27 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.h"
typedef struct __anonstruct_linebuffer_29 linebuffer;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 33 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.h"
struct __anonstruct_longhelp_entry_29 {
   char *options ;
   char *description ;
};
#line 33 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.h"
typedef struct __anonstruct_longhelp_entry_29 longhelp_entry;
#line 27 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
struct numhashnode;
#line 27 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
typedef struct numhashnode numhashnode;
#line 29 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
union __anonunion_node_26 {
   numhashnode *leaves ;
   void *data ;
};
#line 29 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
struct numhashnode {
   union __anonunion_node_26 node ;
   int nchild ;
};
#line 37 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
struct __anonstruct_numhashtable_27 {
   numhashnode table ;
   int depth ;
   int bitsize ;
};
#line 37 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
typedef struct __anonstruct_numhashtable_27 numhashtable;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 37 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.h"
int fifo_init(fifo *f ) ;
#line 43
int fifo_write(fifo *f , void *vbuffer , size_t size ) ;
#line 47
size_t fifo_available(fifo *f ) ;
#line 54
size_t fifo_read(fifo *f , void *vbuffer , size_t size ) ;
#line 59
size_t fifo_skip(fifo *f , size_t size ) ;
#line 64
size_t fifo_peek(fifo *f , void *vbuffer , size_t size ) ;
#line 71
size_t fifo_flush(fifo *f , void *vbuffer ) ;
#line 82
int fifo_free(fifo *f ) ;
#line 51 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
int fifo_init(fifo *f ) 
{ 


  {
#line 53
  f->buffer = (unsigned char *)((void *)0);
#line 54
  f->size = (size_t )0;
#line 55
  f->rpnt = (size_t )0;
#line 56
  f->wrts = (size_t )0;
#line 57
  return (0);
}
}
#line 60 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
int fifo_free(fifo *f ) 
{ 


  {
#line 62
  if ((unsigned long )f->buffer != (unsigned long )((void *)0)) {
    {
#line 63
    free((void *)f->buffer);
    }
  }
  {
#line 64
  fifo_init(f);
  }
#line 65
  return (0);
}
}
#line 72 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
int fifo_write(fifo *f , void *vbuffer , size_t size ) 
{ 
  unsigned char *buffer ;
  size_t msize ;
  size_t wpnt ;
  size_t osize ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 74
  buffer = (unsigned char *)vbuffer;
#line 77
  if (size > f->size - f->wrts) {
    {
#line 78
    osize = f->size;
#line 79
    f->size = ((f->wrts + size) + 256UL) - 1UL;
#line 80
    f->size = 256UL * (f->size / 256UL);
#line 81
    tmp = realloc((void *)f->buffer, f->size);
#line 81
    f->buffer = (unsigned char *)tmp;
    }
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
#line 82
      if ((unsigned long )f->buffer == (unsigned long )((void *)0)) {
#line 82
        if (f->size > 0UL) {
          {
#line 82
          tmp___0 = gettext("memory exhausted");
#line 82
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fifo.c: %s.\n",
                  tmp___0);
#line 82
          abort();
          }
        }
      }
#line 82
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 84
    if (f->rpnt + f->wrts > osize) {
      {
#line 85
      memmove((void *)((f->buffer + f->rpnt) + (f->size - osize)), (void const   *)(f->buffer + f->rpnt),
              osize - f->rpnt);
#line 86
      f->rpnt += f->size - osize;
      }
    }
  }
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (size > 0UL)) {
#line 90
      goto while_break___0;
    }
#line 91
    wpnt = f->rpnt + f->wrts;
#line 92
    if (wpnt >= f->size) {
#line 92
      wpnt -= f->size;
    }
#line 93
    msize = f->size - wpnt;
#line 94
    if (size < msize) {
#line 94
      msize = size;
    }
#line 95
    if ((unsigned long )buffer != (unsigned long )((void *)0)) {
      {
#line 96
      memcpy((void */* __restrict  */)(f->buffer + wpnt), (void const   */* __restrict  */)buffer,
             msize);
#line 97
      buffer += msize;
      }
    }
#line 99
    f->wrts += msize;
#line 100
    size -= msize;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  return (0);
}
}
#line 160 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
size_t fifo_available(fifo *f ) 
{ 


  {
#line 162
  return (f->wrts);
}
}
#line 165 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
size_t fifo_read(fifo *f , void *vbuffer , size_t size ) 
{ 
  unsigned char *buffer ;
  size_t rsize ;
  size_t rsize0 ;
  size_t msize ;

  {
#line 167
  buffer = (unsigned char *)vbuffer;
#line 170
  if (size < f->wrts) {
#line 170
    rsize = size;
  } else {
#line 171
    rsize = f->wrts;
  }
#line 173
  rsize0 = rsize;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (rsize > 0UL)) {
#line 174
      goto while_break;
    }
#line 175
    msize = f->size - f->rpnt;
#line 176
    if (rsize < msize) {
#line 176
      msize = rsize;
    }
#line 177
    if ((unsigned long )buffer != (unsigned long )((void *)0)) {
      {
#line 178
      memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)(f->buffer + f->rpnt),
             msize);
#line 179
      buffer += msize;
      }
    }
#line 181
    f->rpnt += msize;
#line 182
    f->wrts -= msize;
#line 183
    if (f->rpnt >= f->size) {
#line 184
      f->rpnt = (size_t )0;
    }
#line 185
    rsize -= msize;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return (rsize0);
}
}
#line 190 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
size_t fifo_skip(fifo *f , size_t size ) 
{ 
  size_t tmp ;

  {
  {
#line 192
  tmp = fifo_read(f, (void *)0, size);
  }
#line 192
  return (tmp);
}
}
#line 195 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
size_t fifo_peek(fifo *f , void *vbuffer , size_t size ) 
{ 
  size_t rpnt ;
  size_t wrts ;
  size_t ret ;

  {
  {
#line 198
  rpnt = f->rpnt;
#line 199
  wrts = f->wrts;
#line 200
  ret = fifo_read(f, vbuffer, size);
#line 201
  f->rpnt = rpnt;
#line 202
  f->wrts = wrts;
  }
#line 203
  return (ret);
}
}
#line 206 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/fifo.c"
size_t fifo_flush(fifo *f , void *vbuffer ) 
{ 
  size_t size ;

  {
  {
#line 210
  size = fifo_available(f);
  }
#line 211
  if (size > 0UL) {
    {
#line 211
    fifo_read(f, vbuffer, size);
    }
  }
#line 212
  return (size);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 33 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/format.h"
int format_check_if_formatted(char *format , char *fchars ) ;
#line 36
char *format_replace(char *format , int is_escape  , ...) ;
#line 59 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/format.c"
static int format_int_realloc(char **out , int *len , int *alen , int req ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
#line 61
  if (*len + req > *alen) {
    {
#line 62
    req += *len;
#line 63
    *alen = 256 * (((req + 256) - 1) / 256);
#line 64
    tmp = realloc((void *)*out, (size_t )*alen);
#line 64
    *out = (char *)tmp;
    }
    {
#line 65
    while (1) {
      while_continue: /* CIL Label */ ;
#line 65
      if ((unsigned long )*out == (unsigned long )((void *)0)) {
#line 65
        if (*alen > 0) {
          {
#line 65
          tmp___0 = gettext("memory exhausted");
#line 65
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"format.c: %s.\n",
                  tmp___0);
#line 65
          abort();
          }
        }
      }
#line 65
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 67
  return (0);
}
}
#line 70 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/format.c"
static int format_get_parameters(char *format , int *d1 , int *d2 , int *fmt , char **next ) 
{ 
  int set ;
  char *fstart ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
#line 75
  fstart = format;
#line 77
  set = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp = __ctype_b_loc();
    }
#line 78
    if (! ((int const   )*(*tmp + (int )*format) & 8192)) {
#line 78
      goto while_break;
    }
#line 78
    format ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (*format) {
    {
#line 79
    tmp___2 = sscanf((char const   */* __restrict  */)format, (char const   */* __restrict  */)"%d",
                     d1);
    }
#line 79
    if (tmp___2 == 1) {
#line 80
      set |= 1;
      {
#line 81
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 81
        if (! ((int )*format == 45)) {
          {
#line 81
          tmp___0 = __ctype_b_loc();
          }
#line 81
          if (! ((int const   )*(*tmp___0 + (int )*format) & 2048)) {
#line 81
            goto while_break___0;
          }
        }
#line 81
        format ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 82
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 82
        tmp___1 = __ctype_b_loc();
        }
#line 82
        if (! ((int const   )*(*tmp___1 + (int )*format) & 8192)) {
#line 82
          goto while_break___1;
        }
#line 82
        format ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 84
  if ((int )*format == 46) {
#line 84
    format ++;
  }
  {
#line 85
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 85
    tmp___3 = __ctype_b_loc();
    }
#line 85
    if (! ((int const   )*(*tmp___3 + (int )*format) & 8192)) {
#line 85
      goto while_break___2;
    }
#line 85
    format ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 86
  if (*format) {
    {
#line 86
    tmp___6 = sscanf((char const   */* __restrict  */)format, (char const   */* __restrict  */)"%d",
                     d2);
    }
#line 86
    if (tmp___6 == 1) {
#line 87
      set |= 2;
      {
#line 88
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 88
        if (! ((int )*format == 45)) {
          {
#line 88
          tmp___4 = __ctype_b_loc();
          }
#line 88
          if (! ((int const   )*(*tmp___4 + (int )*format) & 2048)) {
#line 88
            goto while_break___3;
          }
        }
#line 88
        format ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 89
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 89
        tmp___5 = __ctype_b_loc();
        }
#line 89
        if (! ((int const   )*(*tmp___5 + (int )*format) & 8192)) {
#line 89
          goto while_break___4;
        }
#line 89
        format ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 92
  tmp___7 = __ctype_b_loc();
  }
#line 92
  if ((int const   )*(*tmp___7 + (int )*format) & 512) {
#line 93
    *fmt = (int )*format;
#line 94
    format ++;
#line 95
    if ((unsigned long )next != (unsigned long )((void *)0)) {
#line 95
      *next = format;
    }
#line 96
    return (set);
  } else {
#line 99
    if ((unsigned long )next != (unsigned long )((void *)0)) {
#line 99
      *next = format;
    }
#line 100
    return (-1);
  }
}
}
#line 106 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/format.c"
int format_check_if_formatted(char *format , char *fchars ) 
{ 
  int fmt ;
  int d1 ;
  int d2 ;
  int set ;
  char *next ;
  char *tmp ;

  {
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! *format) {
#line 111
      goto while_break;
    }
#line 112
    if ((int )*format == 37) {
#line 112
      if (*(format + 1)) {
        {
#line 113
        format ++;
#line 114
        set = format_get_parameters(format, & d1, & d2, & fmt, & next);
        }
#line 115
        if (set >= 0) {
#line 116
          format = next;
        } else
#line 117
        if ((int )*format == 37) {
#line 118
          format ++;
        }
        {
#line 120
        tmp = strchr((char const   *)fchars, fmt);
        }
#line 120
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 121
          return (1);
        }
      } else {
#line 124
        format ++;
      }
    } else {
#line 124
      format ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (0);
}
}
#line 130 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/format.c"
static int format_int_add_string(char **out , int *len , int *alen , int set , int d1 ,
                                 char *vs ) 
{ 
  int slen ;
  int req ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 134
  tmp = strlen((char const   *)vs);
#line 134
  slen = (int )tmp;
  }
#line 135
  if (set & 1) {
    {
#line 135
    tmp___0 = abs(d1);
    }
#line 135
    if (tmp___0 > slen) {
      {
#line 136
      req = abs(d1);
      }
    } else {
#line 138
      req = slen;
    }
  } else {
#line 138
    req = slen;
  }
  {
#line 140
  format_int_realloc(out, len, alen, req);
  }
#line 142
  if (set & 1) {
#line 142
    if (d1 > slen) {
      {
#line 143
      memset((void *)(*out + *len), 32, (size_t )(d1 - slen));
#line 144
      strcpy((char */* __restrict  */)((*out + *len) + (d1 - slen)), (char const   */* __restrict  */)vs);
#line 145
      *len += req;
      }
    } else {
#line 142
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 147
  if (set & 1) {
#line 147
    if (- d1 > slen) {
      {
#line 148
      strcpy((char */* __restrict  */)(*out + *len), (char const   */* __restrict  */)vs);
#line 149
      memset((void *)((*out + *len) + slen), 32, (size_t )(- d1 - slen));
#line 150
      *(*out + (*len + req)) = (char)0;
#line 151
      *len += req;
      }
    } else {
      {
#line 154
      strcpy((char */* __restrict  */)(*out + *len), (char const   */* __restrict  */)vs);
#line 155
      *len += slen;
      }
    }
  } else {
    {
#line 154
    strcpy((char */* __restrict  */)(*out + *len), (char const   */* __restrict  */)vs);
#line 155
    *len += slen;
    }
  }
#line 158
  return (0);
}
}
#line 162 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/format.c"
char *format_replace(char *format , int is_escape  , ...) 
{ 
  char *out ;
  char *fstart ;
  char *next ;
  int len ;
  int alen ;
  int set ;
  int d1 ;
  int d2 ;
  int fmt ;
  int chr ;
  int type ;
  va_list ap ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  char *tmp___5 ;
  int tmp___6 ;
  int vi ;
  char *vs ;
  char buff[256] ;
  char sbuff[16] ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 168
  alen = 256;
#line 169
  tmp = malloc((size_t )alen);
#line 169
  out = (char *)tmp;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
#line 170
      tmp___0 = gettext("memory exhausted");
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"format.c: %s.\n",
              tmp___0);
#line 170
      abort();
      }
    }
#line 170
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  *(out + 0) = (char)0;
#line 173
  len = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! *format) {
#line 175
      goto while_break___0;
    }
#line 176
    if (is_escape) {
#line 176
      if ((int )*format == 92) {
        {
#line 177
        format ++;
#line 178
        format_int_realloc(& out, & len, & alen, 1);
        }
        {
#line 180
        if ((int )*format == 110) {
#line 180
          goto case_110;
        }
#line 183
        if ((int )*format == 116) {
#line 183
          goto case_116;
        }
#line 186
        if ((int )*format == 114) {
#line 186
          goto case_114;
        }
#line 189
        if ((int )*format == 0) {
#line 189
          goto case_0;
        }
#line 192
        goto switch_default;
        case_110: /* CIL Label */ 
#line 181
        *(out + len) = (char )'\n';
#line 181
        len ++;
#line 182
        goto switch_break;
        case_116: /* CIL Label */ 
#line 184
        *(out + len) = (char )'\t';
#line 184
        len ++;
#line 185
        goto switch_break;
        case_114: /* CIL Label */ 
#line 187
        *(out + len) = (char )'\r';
#line 187
        len ++;
#line 188
        goto switch_break;
        case_0: /* CIL Label */ 
#line 190
        *(out + len) = (char )'\\';
#line 190
        len ++;
#line 191
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 193
        *(out + len) = *format;
#line 193
        len ++;
        switch_break: /* CIL Label */ ;
        }
#line 195
        if (*format) {
#line 195
          format ++;
        }
      } else {
#line 176
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 197
    if ((int )*format == 37) {
#line 197
      if (*(format + 1)) {
        {
#line 198
        fstart = format;
#line 199
        format ++;
#line 200
        set = format_get_parameters(format, & d1, & d2, & fmt, & next);
        }
#line 202
        if (set >= 0) {
          {
#line 203
          __builtin_va_start(ap, is_escape);
          }
          {
#line 204
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 204
            tmp___6 = __builtin_va_arg(ap, int );
#line 204
            chr = tmp___6;
            }
#line 204
            if (! (chr > 0)) {
#line 204
              goto while_break___1;
            }
            {
#line 205
            tmp___1 = __builtin_va_arg(ap, int );
#line 205
            type = tmp___1;
            }
#line 206
            if (chr == fmt) {
#line 207
              goto while_break___1;
            } else {
              {
#line 210
              if (type == 1) {
#line 210
                goto case_1;
              }
#line 213
              if (type == 2) {
#line 213
                goto case_2;
              }
#line 209
              goto switch_break___0;
              case_1: /* CIL Label */ 
              {
#line 211
              tmp___3 = __builtin_va_arg(ap, int );
              }
#line 212
              goto switch_break___0;
              case_2: /* CIL Label */ 
              {
#line 214
              tmp___5 = __builtin_va_arg(ap, char *);
              }
#line 215
              goto switch_break___0;
              switch_break___0: /* CIL Label */ ;
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 220
          if (chr > 0) {
            {
#line 225
            if (type == 1) {
#line 225
              goto case_1___0;
            }
#line 236
            if (type == 2) {
#line 236
              goto case_2___0;
            }
#line 224
            goto switch_break___1;
            case_1___0: /* CIL Label */ 
            {
#line 226
            tmp___7 = __builtin_va_arg(ap, int );
#line 226
            vi = tmp___7;
            }
#line 227
            if (set & 2) {
#line 227
              if (d2 > 0) {
#line 228
                if (d2 > 128) {
#line 228
                  d2 = 128;
                }
                {
#line 229
                sprintf((char */* __restrict  */)(sbuff), (char const   */* __restrict  */)"%%.%dd",
                        d2);
#line 230
                sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(sbuff),
                        vi);
                }
              } else {
                {
#line 233
                sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"%d",
                        vi);
                }
              }
            } else {
              {
#line 233
              sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"%d",
                      vi);
              }
            }
            {
#line 234
            format_int_add_string(& out, & len, & alen, set, d1, buff);
            }
#line 235
            goto switch_break___1;
            case_2___0: /* CIL Label */ 
            {
#line 237
            tmp___8 = __builtin_va_arg(ap, char *);
#line 237
            vs = tmp___8;
            }
#line 238
            if ((unsigned long )vs == (unsigned long )((void *)0)) {
#line 239
              vs = (char *)"(null)";
            }
            {
#line 240
            format_int_add_string(& out, & len, & alen, set, d1, vs);
            }
#line 241
            goto switch_break___1;
            switch_break___1: /* CIL Label */ ;
            }
#line 243
            format = next;
          } else {
            {
#line 247
            format --;
#line 248
            format_int_realloc(& out, & len, & alen, (int )(next - format));
#line 249
            memcpy((void */* __restrict  */)(out + len), (void const   */* __restrict  */)format,
                   (size_t )(next - format));
#line 250
            len = (int )((long )len + (next - format));
#line 251
            format = next;
            }
          }
          {
#line 253
          __builtin_va_end(ap);
          }
        } else
#line 255
        if ((int )*format == 37) {
          {
#line 256
          format ++;
#line 257
          format_int_realloc(& out, & len, & alen, 1);
#line 258
          *(out + len) = (char )'%';
#line 259
          len ++;
          }
        } else {
          {
#line 262
          format_int_realloc(& out, & len, & alen, 2);
#line 263
          *(out + len) = (char )'%';
#line 264
          *(out + (len + 1)) = *format;
#line 265
          format ++;
#line 266
          len += 2;
          }
        }
      } else {
        {
#line 270
        format_int_realloc(& out, & len, & alen, 1);
#line 271
        *(out + len) = *format;
#line 271
        len ++;
#line 272
        format ++;
        }
      }
    } else {
      {
#line 270
      format_int_realloc(& out, & len, & alen, 1);
#line 271
      *(out + len) = *format;
#line 271
      len ++;
#line 272
      format ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 276
  format_int_realloc(& out, & len, & alen, 1);
#line 277
  *(out + len) = (char)0;
  }
#line 279
  return (out);
}
}
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 34 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.h"
int linebuffer_reset(linebuffer *lb ) ;
#line 35
int linebuffer_free(linebuffer *lb ) ;
#line 37
int linebuffer_concatenate(linebuffer *lb , char *buff , size_t size ) ;
#line 39
char *linebuffer_read_line(int fd , linebuffer *lb , int timeout ) ;
#line 41
char *linebuffer_fetch(linebuffer *lb ) ;
#line 42
char *linebuffer_flush(linebuffer *lb ) ;
#line 54 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.c"
int linebuffer_reset(linebuffer *lb ) 
{ 


  {
#line 56
  lb->buffer = (char *)((void *)0);
#line 57
  lb->length = (size_t )0;
#line 58
  return (0);
}
}
#line 60 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.c"
int linebuffer_free(linebuffer *lb ) 
{ 


  {
#line 62
  if ((unsigned long )lb->buffer != (unsigned long )((void *)0)) {
    {
#line 63
    free((void *)lb->buffer);
    }
  }
  {
#line 64
  linebuffer_reset(lb);
  }
#line 65
  return (0);
}
}
#line 67 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.c"
int linebuffer_concatenate(linebuffer *lb , char *buff , size_t size ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
#line 69
  if ((unsigned long )buff == (unsigned long )((void *)0)) {
#line 70
    return (0);
  } else
#line 69
  if (size <= 0UL) {
#line 70
    return (0);
  }
  {
#line 71
  tmp = realloc((void *)lb->buffer, (lb->length + size) + 1UL);
#line 71
  lb->buffer = (char *)tmp;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if ((unsigned long )lb->buffer == (unsigned long )((void *)0)) {
      {
#line 72
      tmp___0 = gettext("memory exhausted");
#line 72
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"linebuffer.c: %s.\n",
              tmp___0);
#line 72
      abort();
      }
    }
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  memcpy((void */* __restrict  */)(lb->buffer + lb->length), (void const   */* __restrict  */)buff,
         size);
#line 74
  lb->length += size;
#line 75
  *(lb->buffer + lb->length) = (char)0;
  }
#line 76
  return (0);
}
}
#line 79 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.c"
char *linebuffer_read_line(int fd , linebuffer *lb , int timeout ) 
{ 
  char *line ;
  char *eoc ;
  char buff[256] ;
  int length ;
  int n ;
  struct timeval tv ;
  struct timeval *ptv ;
  struct timeval tn ;
  fd_set set ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int __d0___0 ;
  int __d1___0 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;

  {
#line 86
  if (timeout > 0) {
#line 87
    tv.tv_sec = (__time_t )timeout;
#line 88
    tv.tv_usec = (__suseconds_t )0;
#line 89
    ptv = & tv;
  } else {
#line 92
    ptv = (struct timeval *)((void *)0);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if ((unsigned long )lb->buffer != (unsigned long )((void *)0)) {
      {
#line 96
      tmp = memchr((void const   *)lb->buffer, 10, lb->length);
#line 96
      eoc = (char *)tmp;
      }
    } else {
#line 98
      eoc = (char *)((void *)0);
    }
#line 100
    if ((unsigned long )eoc != (unsigned long )((void *)0)) {
      {
#line 101
      length = (int )(eoc - lb->buffer);
#line 102
      tmp___0 = malloc((size_t )(1 + length));
#line 102
      line = (char *)tmp___0;
      }
      {
#line 103
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 103
        if ((unsigned long )line == (unsigned long )((void *)0)) {
          {
#line 103
          tmp___1 = gettext("memory exhausted");
#line 103
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"linebuffer.c: %s.\n",
                  tmp___1);
#line 103
          abort();
          }
        }
#line 103
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 104
      memcpy((void */* __restrict  */)line, (void const   */* __restrict  */)lb->buffer,
             (size_t )length);
#line 105
      *(line + length) = (char)0;
#line 106
      length ++;
      }
#line 107
      if ((size_t )length >= lb->length) {
        {
#line 108
        free((void *)lb->buffer);
#line 109
        lb->buffer = (char *)((void *)0);
#line 110
        lb->length = (size_t )0;
        }
      } else {
        {
#line 113
        memmove((void *)lb->buffer, (void const   *)(lb->buffer + length), lb->length - (size_t )length);
#line 114
        lb->length -= (size_t )length;
        }
      }
#line 116
      return (line);
    }
    {
#line 119
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 119
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.fds_bits[0]): "memory");
#line 119
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 120
    set.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 121
    tn.tv_sec = (__time_t )0;
#line 122
    tn.tv_usec = (__suseconds_t )0;
#line 123
    select(fd + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tn));
    }
#line 124
    if ((set.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 125
      tmp___2 = read(fd, (void *)(buff), (size_t )256);
#line 125
      n = (int )tmp___2;
      }
#line 126
      if (n > 0) {
        {
#line 127
        linebuffer_concatenate(lb, buff, (size_t )n);
        }
      } else
#line 128
      if (n < 0) {
        {
#line 128
        tmp___3 = __errno_location();
        }
#line 128
        if (! (*tmp___3 == 4)) {
#line 129
          return ((char *)((void *)0));
        }
      } else {
#line 129
        return ((char *)((void *)0));
      }
    } else {
      {
#line 132
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 132
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& set.fds_bits[0]): "memory");
#line 132
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 133
      set.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 134
      select(fd + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)ptv);
      }
#line 135
      if ((set.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 136
        tmp___4 = read(fd, (void *)(buff), (size_t )256);
#line 136
        n = (int )tmp___4;
        }
#line 137
        if (n > 0) {
          {
#line 138
          linebuffer_concatenate(lb, buff, (size_t )n);
          }
        } else
#line 139
        if (n < 0) {
          {
#line 139
          tmp___5 = __errno_location();
          }
#line 139
          if (! (*tmp___5 == 4)) {
#line 140
            return ((char *)((void *)0));
          }
        } else {
#line 140
          return ((char *)((void *)0));
        }
      } else {
#line 143
        return ((char *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return ((char *)((void *)0));
}
}
#line 149 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.c"
char *linebuffer_fetch(linebuffer *lb ) 
{ 
  char *eoc ;
  char *line ;
  size_t length ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 154
  if ((unsigned long )lb->buffer != (unsigned long )((void *)0)) {
#line 154
    if (lb->length > 0UL) {
      {
#line 155
      tmp = memchr((void const   *)lb->buffer, 10, lb->length);
#line 155
      eoc = (char *)tmp;
      }
    } else {
#line 157
      eoc = (char *)((void *)0);
    }
  } else {
#line 157
    eoc = (char *)((void *)0);
  }
#line 159
  if ((unsigned long )eoc != (unsigned long )((void *)0)) {
    {
#line 160
    length = (size_t )(eoc - lb->buffer);
#line 161
    tmp___0 = malloc(1UL + length);
#line 161
    line = (char *)tmp___0;
    }
    {
#line 162
    while (1) {
      while_continue: /* CIL Label */ ;
#line 162
      if ((unsigned long )line == (unsigned long )((void *)0)) {
        {
#line 162
        tmp___1 = gettext("memory exhausted");
#line 162
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"linebuffer.c: %s.\n",
                tmp___1);
#line 162
        abort();
        }
      }
#line 162
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 163
    memcpy((void */* __restrict  */)line, (void const   */* __restrict  */)lb->buffer,
           length);
#line 164
    *(line + length) = (char)0;
#line 165
    length ++;
    }
#line 166
    if (length >= lb->length) {
      {
#line 167
      free((void *)lb->buffer);
#line 168
      lb->buffer = (char *)((void *)0);
#line 169
      lb->length = (size_t )0;
      }
    } else {
      {
#line 172
      memmove((void *)lb->buffer, (void const   *)(lb->buffer + length), lb->length - length);
#line 173
      lb->length -= length;
      }
    }
#line 175
    return (line);
  } else {
#line 178
    return ((char *)((void *)0));
  }
}
}
#line 182 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/linebuffer.c"
char *linebuffer_flush(linebuffer *lb ) 
{ 
  char *line ;
  size_t length ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 187
  if ((unsigned long )lb->buffer != (unsigned long )((void *)0)) {
#line 187
    if (lb->length > 0UL) {
      {
#line 188
      tmp = malloc(lb->length + 1UL);
#line 188
      line = (char *)tmp;
      }
      {
#line 189
      while (1) {
        while_continue: /* CIL Label */ ;
#line 189
        if ((unsigned long )line == (unsigned long )((void *)0)) {
          {
#line 189
          tmp___0 = gettext("memory exhausted");
#line 189
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"linebuffer.c: %s.\n",
                  tmp___0);
#line 189
          abort();
          }
        }
#line 189
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 190
      length = lb->length;
#line 191
      memcpy((void */* __restrict  */)line, (void const   */* __restrict  */)lb->buffer,
             length);
#line 192
      *(line + length) = (char)0;
#line 193
      free((void *)lb->buffer);
#line 194
      linebuffer_reset(lb);
      }
#line 195
      return (line);
    } else {
#line 187
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 198
    if ((unsigned long )lb->buffer != (unsigned long )((void *)0)) {
      {
#line 199
      free((void *)lb->buffer);
      }
    }
    {
#line 200
    linebuffer_reset(lb);
    }
#line 201
    return ((char *)((void *)0));
  }
}
}
#line 858 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 49 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.h"
int longhelp_fprint(FILE *fw , longhelp_entry *entry , int flags , int width ) ;
#line 58 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.c"
static void remove_quotes___0(char *buff ) 
{ 
  int k ;
  size_t tmp ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! *buff) {
#line 61
      goto while_break;
    }
#line 62
    k = 0;
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! ((int )*(buff + k) == 34)) {
#line 62
        goto while_break___0;
      }
#line 62
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    if (k) {
      {
#line 63
      tmp = strlen((char const   *)buff);
#line 63
      memmove((void *)buff, (void const   *)(buff + k), (tmp + 1UL) - (size_t )k);
      }
    } else {
#line 64
      buff ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 69 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.c"
static int char_is_space___0(int c ) 
{ 


  {
#line 71
  if (c == 32) {
#line 71
    return (1);
  } else
#line 71
  if (c == 13) {
#line 71
    return (1);
  } else
#line 71
  if (c == 10) {
#line 71
    return (1);
  } else
#line 71
  if (c == 9) {
#line 71
    return (1);
  } else {
#line 72
    return (0);
  }
}
}
#line 75 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.c"
static char **tokenize_spaces_dyn___0(char *buff ) 
{ 
  int intoken ;
  int inquota ;
  int i ;
  int n ;
  int nm ;
  char **rtokens ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 80
  nm = 16;
#line 81
  tmp = malloc(sizeof(char *) * (unsigned long )nm);
#line 81
  rtokens = (char **)tmp;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if ((unsigned long )rtokens == (unsigned long )((void *)0)) {
      {
#line 82
      tmp___0 = gettext("memory exhausted");
#line 82
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tokenize.c: %s.\n",
              tmp___0);
#line 82
      abort();
      }
    }
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  if ((unsigned long )rtokens == (unsigned long )((void *)0)) {
#line 84
    return ((char **)((void *)0));
  }
#line 86
  intoken = 0;
#line 86
  inquota = 0;
#line 86
  n = 0;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! *buff) {
#line 87
      goto while_break___0;
    }
    {
#line 88
    tmp___6 = char_is_space___0((int )*buff);
    }
#line 88
    if (tmp___6) {
      _L___2: /* CIL Label */ 
#line 99
      if (intoken) {
        {
#line 99
        tmp___4 = char_is_space___0((int )*buff);
        }
#line 99
        if (tmp___4) {
#line 99
          if (inquota) {
#line 99
            goto _L___0;
          } else {
#line 99
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 99
          tmp___5 = char_is_space___0((int )*buff);
          }
#line 99
          if (tmp___5) {
#line 99
            goto _L;
          } else {
            _L___0: /* CIL Label */ 
#line 100
            if ((int )*buff == 34) {
#line 100
              inquota = ! inquota;
            }
#line 101
            buff ++;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 103
      if (intoken) {
#line 103
        if (! inquota) {
          {
#line 103
          tmp___3 = char_is_space___0((int )*buff);
          }
#line 103
          if (tmp___3) {
#line 104
            *buff = (char)0;
#line 104
            buff ++;
#line 105
            intoken = 0;
          } else {
#line 107
            buff ++;
          }
        } else {
#line 107
          buff ++;
        }
      } else {
#line 107
        buff ++;
      }
    } else
#line 88
    if (! intoken) {
#line 89
      *(rtokens + n) = buff;
#line 90
      intoken = 1;
#line 90
      inquota = 0;
#line 90
      n ++;
#line 91
      if ((int )*buff == 34) {
#line 91
        inquota = 1;
      }
#line 92
      buff ++;
#line 93
      if (n >= nm - 1) {
        {
#line 94
        nm += 16;
#line 95
        tmp___1 = realloc((void *)rtokens, sizeof(char *) * (unsigned long )nm);
#line 95
        rtokens = (char **)tmp___1;
        }
        {
#line 96
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 96
          if ((unsigned long )rtokens == (unsigned long )((void *)0)) {
#line 96
            if (sizeof(char *) * (unsigned long )nm > 0UL) {
              {
#line 96
              tmp___2 = gettext("memory exhausted");
#line 96
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tokenize.c: %s.\n",
                      tmp___2);
#line 96
              abort();
              }
            }
          }
#line 96
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 88
      goto _L___2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  *(rtokens + n) = (char *)((void *)0);
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! (i < n)) {
#line 112
      goto while_break___2;
    }
    {
#line 113
    remove_quotes___0(*(rtokens + i));
#line 112
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 115
  return (rtokens);
}
}
#line 120 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.c"
static int longhelp_fprint_description(FILE *fw , int width , int w , int fpad , int pad ,
                                       char *desc ) 
{ 
  int i ;
  char *dd ;
  char **cmd ;
  int n ;
  int w___0 ;
  int p ;
  int l ;
  size_t tmp ;

  {
#line 124
  i = w;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < pad)) {
#line 124
      goto while_break;
    }
    {
#line 125
    fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)" ");
#line 124
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if (width <= 0) {
    {
#line 128
    fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"%s\n",
            desc);
    }
  } else {
    {
#line 132
    dd = strdup((char const   *)desc);
#line 133
    cmd = tokenize_spaces_dyn___0(dd);
#line 134
    p = pad;
#line 134
    w___0 = 0;
#line 135
    n = 0;
    }
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if ((unsigned long )cmd != (unsigned long )((void *)0)) {
#line 135
        if (! ((unsigned long )*(cmd + n) != (unsigned long )((void *)0))) {
#line 135
          goto while_break___0;
        }
      } else {
#line 135
        goto while_break___0;
      }
      {
#line 136
      tmp = strlen((char const   *)*(cmd + n));
#line 136
      l = (int )tmp;
      }
#line 137
      if (w___0 > 0) {
#line 137
        l ++;
      }
#line 138
      if (l > width - p) {
        {
#line 139
        fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"\n");
#line 140
        i = 0;
        }
        {
#line 140
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 140
          if (! (i < fpad)) {
#line 140
            goto while_break___1;
          }
          {
#line 141
          fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)" ");
#line 140
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 142
        if (w___0 > 0) {
#line 142
          l --;
        }
#line 143
        w___0 = 0;
#line 144
        p = fpad;
      }
#line 146
      if (w___0 > 0) {
        {
#line 147
        fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)" %s",
                *(cmd + n));
        }
      } else {
        {
#line 149
        fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"%s",
                *(cmd + n));
        }
      }
#line 150
      p += l;
#line 151
      w___0 ++;
#line 135
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 153
    fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"\n");
    }
#line 154
    if ((unsigned long )cmd != (unsigned long )((void *)0)) {
      {
#line 154
      free((void *)cmd);
      }
    }
    {
#line 155
    free((void *)dd);
    }
  }
#line 158
  return (0);
}
}
#line 161 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.c"
int longhelp_fprint_entry(FILE *fw , longhelp_entry *entry , int flags , int width ) 
{ 
  int w ;
  int fpad ;
  int pad ;

  {
  {
#line 165
  w = fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)" %s",
              entry->options);
#line 167
  pad = ((w + 4) + 7) & -8;
#line 168
  fpad = 16;
  }
#line 170
  if (width > 0) {
    {
#line 171
    longhelp_fprint_description(fw, width, w, fpad, pad, entry->description);
    }
  } else {
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (w < pad)) {
#line 173
        goto while_break;
      }
      {
#line 174
      fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)" ");
#line 173
      w ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 175
    fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"%s\n",
            entry->description);
    }
  }
#line 178
  return (0);
}
}
#line 181 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/longhelp.c"
int longhelp_fprint(FILE *fw , longhelp_entry *entry , int flags , int width ) 
{ 
  int lcnt ;
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 185
  if (width < 0) {
    {
#line 185
    tmp___1 = fileno(fw);
#line 185
    tmp___2 = isatty(tmp___1);
    }
#line 185
    if (tmp___2) {
      {
#line 187
      tmp = fileno(fw);
#line 187
      tmp___0 = ioctl(tmp, 21523UL, & ws);
      }
#line 187
      if (tmp___0) {
#line 190
        width = 0;
      } else {
#line 188
        width = (int )ws.ws_col - 1;
      }
    }
  }
#line 193
  lcnt = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if ((unsigned long )entry != (unsigned long )((void *)0)) {
#line 194
      if (! ((unsigned long )entry->options != (unsigned long )((void *)0))) {
#line 194
        goto while_break;
      }
    } else {
#line 194
      goto while_break;
    }
#line 195
    if ((unsigned long )entry->description == (unsigned long )((void *)0)) {
#line 196
      if (lcnt > 0) {
        {
#line 197
        fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"\n");
        }
      }
      {
#line 198
      fprintf((FILE */* __restrict  */)fw, (char const   */* __restrict  */)"%s\n",
              entry->options);
#line 199
      lcnt = 0;
      }
    } else {
      {
#line 202
      longhelp_fprint_entry(fw, entry, flags, width);
#line 203
      lcnt ++;
      }
    }
#line 206
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (0);
}
}
#line 30 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.h"
void remove_newlines_and_comments(char *buff ) ;
#line 34
void remove_spaces_and_comments(char *buff ) ;
#line 37
void remove_spaces(char *buff ) ;
#line 41
void remove_quotes(char *buff ) ;
#line 45
int char_is_space(int c ) ;
#line 59
int tokenize_spaces(char *buff , char **tokens , int max ) ;
#line 60
char **tokenize_spaces_dyn(char *buff ) ;
#line 69
int tokenize_char(char *buff , char **tokens , int tchar , int max ) ;
#line 70
char **tokenize_char_dyn_wwt(char *buff , int tchar , int is_terminate ) ;
#line 71
char **tokenize_char_dyn(char *buff , int tchar ) ;
#line 53 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
void remove_newlines_and_comments(char *buff ) 
{ 
  int k ;
  size_t tmp ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! *buff) {
#line 56
      goto while_break;
    }
#line 57
    if ((int )*buff == 35) {
#line 57
      *buff = (char)0;
    } else {
#line 59
      k = 0;
      {
#line 59
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 59
        if (! ((int )*(buff + k) == 10)) {
#line 59
          if (! ((int )*(buff + k) == 13)) {
#line 59
            goto while_break___0;
          }
        }
#line 59
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 60
      if (k) {
        {
#line 60
        tmp = strlen((char const   *)buff);
#line 60
        memmove((void *)buff, (void const   *)(buff + k), (tmp + 1UL) - (size_t )k);
        }
      } else {
#line 61
        buff ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
void remove_spaces_and_comments(char *buff ) 
{ 
  int k ;
  size_t tmp ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *buff) {
#line 70
      goto while_break;
    }
#line 71
    if ((int )*buff == 35) {
#line 71
      *buff = (char)0;
    } else {
#line 73
      k = 0;
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if (! ((int )*(buff + k) == 9)) {
#line 73
          if (! ((int )*(buff + k) == 32)) {
#line 73
            if (! ((int )*(buff + k) == 10)) {
#line 73
              if (! ((int )*(buff + k) == 13)) {
#line 73
                goto while_break___0;
              }
            }
          }
        }
#line 73
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 74
      if (k) {
        {
#line 74
        tmp = strlen((char const   *)buff);
#line 74
        memmove((void *)buff, (void const   *)(buff + k), (tmp + 1UL) - (size_t )k);
        }
      } else {
#line 75
        buff ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
void remove_spaces(char *buff ) 
{ 
  int k ;
  size_t tmp ;

  {
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! *buff) {
#line 84
      goto while_break;
    }
#line 85
    k = 0;
    {
#line 85
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 85
      if (! ((int )*(buff + k) == 9)) {
#line 85
        if (! ((int )*(buff + k) == 32)) {
#line 85
          if (! ((int )*(buff + k) == 10)) {
#line 85
            if (! ((int )*(buff + k) == 13)) {
#line 85
              goto while_break___0;
            }
          }
        }
      }
#line 85
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    if (k) {
      {
#line 86
      tmp = strlen((char const   *)buff);
#line 86
      memmove((void *)buff, (void const   *)(buff + k), (tmp + 1UL) - (size_t )k);
      }
    } else {
#line 87
      buff ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
void remove_quotes(char *buff ) 
{ 
  int k ;
  size_t tmp ;

  {
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! *buff) {
#line 96
      goto while_break;
    }
#line 97
    k = 0;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! ((int )*(buff + k) == 34)) {
#line 97
        goto while_break___0;
      }
#line 97
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 98
    if (k) {
      {
#line 98
      tmp = strlen((char const   *)buff);
#line 98
      memmove((void *)buff, (void const   *)(buff + k), (tmp + 1UL) - (size_t )k);
      }
    } else {
#line 99
      buff ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 106 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
int char_is_space(int c ) 
{ 


  {
#line 108
  if (c == 32) {
#line 108
    return (1);
  } else
#line 108
  if (c == 13) {
#line 108
    return (1);
  } else
#line 108
  if (c == 10) {
#line 108
    return (1);
  } else
#line 108
  if (c == 9) {
#line 108
    return (1);
  } else {
#line 109
    return (0);
  }
}
}
#line 114 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
int tokenize_spaces(char *buff , char **tokens , int max ) 
{ 
  int intoken ;
  int inquota ;
  int n ;
  char **tsave ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 119
  tsave = tokens;
#line 121
  intoken = 0;
#line 121
  inquota = 0;
#line 121
  n = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (*buff) {
#line 122
      if (! (n < max)) {
#line 122
        goto while_break;
      }
    } else {
#line 122
      goto while_break;
    }
    {
#line 123
    tmp___2 = char_is_space((int )*buff);
    }
#line 123
    if (tmp___2) {
      _L___2: /* CIL Label */ 
#line 129
      if (intoken) {
        {
#line 129
        tmp___0 = char_is_space((int )*buff);
        }
#line 129
        if (tmp___0) {
#line 129
          if (inquota) {
#line 129
            goto _L___0;
          } else {
#line 129
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 129
          tmp___1 = char_is_space((int )*buff);
          }
#line 129
          if (tmp___1) {
#line 129
            goto _L;
          } else {
            _L___0: /* CIL Label */ 
#line 130
            if ((int )*buff == 34) {
#line 130
              inquota = ! inquota;
            }
#line 131
            buff ++;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 133
      if (intoken) {
#line 133
        if (! inquota) {
          {
#line 133
          tmp = char_is_space((int )*buff);
          }
#line 133
          if (tmp) {
#line 134
            *buff = (char)0;
#line 134
            buff ++;
#line 135
            intoken = 0;
          } else {
#line 137
            buff ++;
          }
        } else {
#line 137
          buff ++;
        }
      } else {
#line 137
        buff ++;
      }
    } else
#line 123
    if (! intoken) {
#line 124
      *tokens = buff;
#line 125
      intoken = 1;
#line 125
      inquota = 0;
#line 125
      n ++;
#line 126
      if ((int )*buff == 34) {
#line 126
        inquota = 1;
      }
#line 127
      tokens ++;
#line 127
      buff ++;
    } else {
#line 123
      goto _L___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  *tokens = (char *)((void *)0);
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )*tsave != (unsigned long )((void *)0))) {
#line 141
      goto while_break___0;
    }
    {
#line 142
    remove_quotes(*tsave);
#line 143
    tsave ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 146
  return (n);
}
}
#line 149 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
char **tokenize_spaces_dyn(char *buff ) 
{ 
  int intoken ;
  int inquota ;
  int i ;
  int n ;
  int nm ;
  char **rtokens ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 154
  nm = 16;
#line 155
  tmp = malloc(sizeof(char *) * (unsigned long )nm);
#line 155
  rtokens = (char **)tmp;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if ((unsigned long )rtokens == (unsigned long )((void *)0)) {
      {
#line 156
      tmp___0 = gettext("memory exhausted");
#line 156
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tokenize.c: %s.\n",
              tmp___0);
#line 156
      abort();
      }
    }
#line 156
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if ((unsigned long )rtokens == (unsigned long )((void *)0)) {
#line 158
    return ((char **)((void *)0));
  }
#line 160
  intoken = 0;
#line 160
  inquota = 0;
#line 160
  n = 0;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! *buff) {
#line 161
      goto while_break___0;
    }
    {
#line 162
    tmp___6 = char_is_space((int )*buff);
    }
#line 162
    if (tmp___6) {
      _L___2: /* CIL Label */ 
#line 173
      if (intoken) {
        {
#line 173
        tmp___4 = char_is_space((int )*buff);
        }
#line 173
        if (tmp___4) {
#line 173
          if (inquota) {
#line 173
            goto _L___0;
          } else {
#line 173
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 173
          tmp___5 = char_is_space((int )*buff);
          }
#line 173
          if (tmp___5) {
#line 173
            goto _L;
          } else {
            _L___0: /* CIL Label */ 
#line 174
            if ((int )*buff == 34) {
#line 174
              inquota = ! inquota;
            }
#line 175
            buff ++;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 177
      if (intoken) {
#line 177
        if (! inquota) {
          {
#line 177
          tmp___3 = char_is_space((int )*buff);
          }
#line 177
          if (tmp___3) {
#line 178
            *buff = (char)0;
#line 178
            buff ++;
#line 179
            intoken = 0;
          } else {
#line 181
            buff ++;
          }
        } else {
#line 181
          buff ++;
        }
      } else {
#line 181
        buff ++;
      }
    } else
#line 162
    if (! intoken) {
#line 163
      *(rtokens + n) = buff;
#line 164
      intoken = 1;
#line 164
      inquota = 0;
#line 164
      n ++;
#line 165
      if ((int )*buff == 34) {
#line 165
        inquota = 1;
      }
#line 166
      buff ++;
#line 167
      if (n >= nm - 1) {
        {
#line 168
        nm += 16;
#line 169
        tmp___1 = realloc((void *)rtokens, sizeof(char *) * (unsigned long )nm);
#line 169
        rtokens = (char **)tmp___1;
        }
        {
#line 170
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 170
          if ((unsigned long )rtokens == (unsigned long )((void *)0)) {
#line 170
            if (sizeof(char *) * (unsigned long )nm > 0UL) {
              {
#line 170
              tmp___2 = gettext("memory exhausted");
#line 170
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tokenize.c: %s.\n",
                      tmp___2);
#line 170
              abort();
              }
            }
          }
#line 170
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 162
      goto _L___2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 184
  *(rtokens + n) = (char *)((void *)0);
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 186
    if (! (i < n)) {
#line 186
      goto while_break___2;
    }
    {
#line 187
    remove_quotes(*(rtokens + i));
#line 186
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 189
  return (rtokens);
}
}
#line 192 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
int tokenize_char(char *buff , char **tokens , int tchar , int max ) 
{ 
  int n ;

  {
#line 196
  if ((int )*buff == 0) {
#line 197
    *tokens = (char *)((void *)0);
#line 197
    return (0);
  }
#line 199
  n = 1;
#line 199
  *tokens = buff;
#line 199
  tokens ++;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (*buff) {
#line 200
      if (! (n < max)) {
#line 200
        goto while_break;
      }
    } else {
#line 200
      goto while_break;
    }
#line 201
    if ((int )*buff != tchar) {
#line 201
      buff ++;
    } else {
#line 202
      *buff = (char)0;
#line 202
      buff ++;
#line 202
      *tokens = buff;
#line 202
      tokens ++;
#line 202
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  *tokens = (char *)((void *)0);
#line 205
  return (n);
}
}
#line 208 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
char **tokenize_char_dyn_wwt(char *buff , int tchar , int is_terminate ) 
{ 
  int n ;
  char **tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 213
  if ((unsigned long )buff == (unsigned long )((void *)0)) {
#line 214
    return ((char **)((void *)0));
  }
  {
#line 216
  tmp = malloc(sizeof(char *));
#line 216
  tokens = (char **)tmp;
  }
#line 217
  if ((unsigned long )tokens == (unsigned long )((void *)0)) {
#line 218
    return ((char **)((void *)0));
  }
#line 220
  if ((int )*buff == 0) {
#line 221
    *tokens = (char *)((void *)0);
#line 221
    return (tokens);
  }
#line 223
  n = 0;
#line 223
  *(tokens + n) = buff;
#line 223
  n ++;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! *buff) {
#line 224
      goto while_break;
    }
#line 225
    if ((int )*buff != tchar) {
#line 225
      buff ++;
    } else {
#line 227
      if (is_terminate) {
#line 227
        *buff = (char)0;
      }
      {
#line 228
      buff ++;
#line 229
      tmp___0 = realloc((void *)tokens, sizeof(char *) * (unsigned long )(n + 1));
#line 229
      tokens = (char **)tmp___0;
      }
      {
#line 230
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 230
        if ((unsigned long )tokens == (unsigned long )((void *)0)) {
          {
#line 230
          tmp___1 = gettext("memory exhausted");
#line 230
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tokenize.c: %s.\n",
                  tmp___1);
#line 230
          abort();
          }
        }
#line 230
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 231
      *(tokens + n) = buff;
#line 231
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp___2 = realloc((void *)tokens, sizeof(char *) * (unsigned long )(n + 1));
#line 234
  tokens = (char **)tmp___2;
  }
  {
#line 235
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 235
    if ((unsigned long )tokens == (unsigned long )((void *)0)) {
      {
#line 235
      tmp___3 = gettext("memory exhausted");
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tokenize.c: %s.\n",
              tmp___3);
#line 235
      abort();
      }
    }
#line 235
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 236
  *(tokens + n) = (char *)((void *)0);
#line 237
  return (tokens);
}
}
#line 239 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/tokenize.c"
char **tokenize_char_dyn(char *buff , int tchar ) 
{ 
  char **ret ;

  {
  {
#line 242
  ret = tokenize_char_dyn_wwt(buff, tchar, 1);
  }
#line 243
  return (ret);
}
}
#line 49 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.h"
int numhash_init(numhashtable *nt , int bitsize , int depth ) ;
#line 57
int numhash_add(numhashtable *nt , int value , void *data ) ;
#line 64
int numhash_search(numhashtable *nt , int value , void **ret ) ;
#line 71
int numhash_remove(numhashtable *nt , int value ) ;
#line 75
int numhash_total(numhashtable *nt ) ;
#line 83
int numhash_get_smallest_free(numhashtable *nt ) ;
#line 84
int numhash_get_largest_free(numhashtable *nt ) ;
#line 85
int numhash_get_smallest_used(numhashtable *nt ) ;
#line 86
int numhash_get_largest_used(numhashtable *nt ) ;
#line 96
int numhash_walk(numhashtable *nt , int (*callback)(int  , void * , void * ) , void *param ) ;
#line 98
int numhash_walk_asc(numhashtable *nt , int (*callback)(int  , void * , void * ) ,
                     void *param ) ;
#line 100
int numhash_walk_desc(numhashtable *nt , int (*callback)(int  , void * , void * ) ,
                      void *param ) ;
#line 102
int numhash_walk_dir(numhashtable *nt , int (*callback)(int  , void * , void * ) ,
                     void *param , int dir ) ;
#line 108
int numhash_first(numhashtable *nt ) ;
#line 109
int numhash_last(numhashtable *nt ) ;
#line 118
int numhash_next(numhashtable *nt , int value ) ;
#line 119
int numhash_prev(numhashtable *nt , int value ) ;
#line 125
int numhash_first_wdata(numhashtable *nt , void **dret ) ;
#line 126
int numhash_last_wdata(numhashtable *nt , void **dret ) ;
#line 127
int numhash_next_wdata(numhashtable *nt , int value , void **dret ) ;
#line 128
int numhash_prev_wdata(numhashtable *nt , int value , void **dret ) ;
#line 134
int numhash_loop_start(numhashtable *nt , int dir , void **ret ) ;
#line 135
int numhash_loop_next(numhashtable *nt , int dir , int key , void **ret ) ;
#line 139
int numhash_free(numhashtable *nt ) ;
#line 71 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_search(numhashtable *nt , int value , void **ret ) 
{ 
  int off ;
  int bit ;
  numhashnode *nh ;

  {
#line 76
  if ((unsigned long )nt == (unsigned long )((void *)0)) {
#line 76
    return (0);
  }
#line 78
  off = 0;
#line 79
  nh = & nt->table;
#line 81
  if ((unsigned long )nt->bitsize < sizeof(int ) * 8UL) {
#line 82
    value &= (1 << nt->bitsize) - 1;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    bit = (value >> nt->depth * ((nt->bitsize - 1) / nt->depth - off)) & ((1 << nt->depth) - 1);
#line 89
    if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 90
      return (0);
    }
#line 92
    off ++;
#line 93
    nh = nh->node.leaves + bit;
#line 84
    if (! (off * nt->depth < nt->bitsize)) {
#line 84
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 97
    *ret = nh->node.data;
  }
#line 98
  return (nh->nchild);
}
}
#line 103 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_init(numhashtable *nt , int bitsize , int depth ) 
{ 


  {
#line 105
  nt->table.node.leaves = (numhashnode *)((void *)0);
#line 106
  nt->table.node.data = (void *)0;
#line 107
  nt->table.nchild = 0;
#line 109
  nt->depth = depth;
#line 110
  nt->bitsize = bitsize;
#line 112
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_add(numhashtable *nt , int value , void *data ) 
{ 
  int off ;
  int bit ;
  int bitsize ;
  int depth ;
  int shift ;
  int tnode ;
  int nodesize ;
  numhashnode *nh ;
  numhashnode *tree[64] ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 122
  if ((unsigned long )nt == (unsigned long )((void *)0)) {
#line 123
    return (-1);
  }
#line 125
  off = 0;
#line 126
  nh = & nt->table;
#line 127
  depth = nt->depth;
#line 128
  bitsize = nt->bitsize;
#line 130
  tnode = 0;
#line 132
  if ((unsigned long )bitsize < sizeof(int ) * 8UL) {
#line 133
    value &= (1 << bitsize) - 1;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    shift = depth * ((bitsize - 1) / depth - off);
#line 137
    bit = (value >> shift) & ((1 << depth) - 1);
#line 139
    if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
      {
#line 140
      nodesize = 1 << depth;
#line 141
      tmp = malloc(sizeof(numhashnode ) * (unsigned long )nodesize);
#line 141
      nh->node.leaves = (numhashnode *)tmp;
      }
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 142
        if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
          {
#line 142
          tmp___0 = gettext("memory exhausted");
#line 142
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"numhash.c: %s.\n",
                  tmp___0);
#line 142
          abort();
          }
        }
#line 142
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 143
      memset((void *)nh->node.leaves, 0, sizeof(numhashnode ) * (unsigned long )nodesize);
      }
    }
#line 145
    off ++;
#line 146
    tree[tnode] = nh;
#line 147
    tnode ++;
#line 148
    nh = nh->node.leaves + bit;
#line 135
    if (! (off * depth < bitsize)) {
#line 135
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  nh->node.data = data;
#line 154
  if (nh->nchild) {
#line 155
    return (0);
  } else {
#line 157
    nh->nchild = 1;
    {
#line 158
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 158
      if (! (tnode > 0)) {
#line 158
        goto while_break___1;
      }
#line 159
      tnode --;
#line 160
      ((tree[tnode])->nchild) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 162
    return (1);
  }
}
}
#line 169 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_total(numhashtable *nt ) 
{ 


  {
#line 171
  return (nt->table.nchild);
}
}
#line 176 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_remove(numhashtable *nt , int value ) 
{ 
  int off ;
  int bit ;
  int bitsize ;
  int depth ;
  int shift ;
  int tnode ;
  numhashnode *nh ;
  numhashnode *tree[64] ;

  {
#line 181
  if ((unsigned long )nt == (unsigned long )((void *)0)) {
#line 181
    return (0);
  }
#line 183
  off = 0;
#line 184
  nh = & nt->table;
#line 185
  depth = nt->depth;
#line 186
  bitsize = nt->bitsize;
#line 188
  tnode = 0;
#line 190
  if ((unsigned long )bitsize < sizeof(int ) * 8UL) {
#line 191
    value &= (1 << bitsize) - 1;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    shift = depth * ((bitsize - 1) / depth - off);
#line 195
    bit = (value >> shift) & ((1 << depth) - 1);
#line 197
    if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 198
      return (0);
    }
#line 200
    off ++;
#line 201
    tree[tnode] = nh;
#line 202
    tnode ++;
#line 203
    nh = nh->node.leaves + bit;
#line 193
    if (! (off * depth < bitsize)) {
#line 193
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  if (nh->nchild <= 0) {
#line 208
    return (0);
  }
#line 210
  nh->nchild = 0;
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (tnode > 0)) {
#line 212
      goto while_break___0;
    }
#line 213
    tnode --;
#line 214
    nh = tree[tnode];
#line 215
    (nh->nchild) --;
#line 216
    if (nh->nchild <= 0) {
      {
#line 217
      free((void *)nh->node.leaves);
#line 218
      nh->node.leaves = (numhashnode *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  return (1);
}
}
#line 227 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_get_terminal_free(numhashtable *nt , int dir ) 
{ 
  int capacity ;
  int cdepth ;
  int i ;
  int k ;
  int off ;
  int shift ;
  numhashnode *nh ;

  {
#line 232
  if (1 << nt->bitsize <= nt->table.nchild) {
#line 233
    return (-1);
  }
#line 235
  off = 0;
#line 236
  nh = & nt->table;
#line 238
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 239
    return (0);
  }
#line 241
  off = 0;
#line 241
  k = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! ((unsigned long )nh != (unsigned long )((void *)0))) {
#line 241
      goto while_break;
    }
#line 242
    shift = nt->depth * ((nt->bitsize - 1) / nt->depth - off);
#line 243
    if (nt->bitsize - shift < nt->depth) {
#line 243
      cdepth = nt->bitsize - shift;
    } else {
#line 243
      cdepth = nt->depth;
    }
#line 244
    capacity = 1 << shift;
#line 245
    if (dir >= 0) {
#line 246
      i = 0;
      {
#line 246
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 246
        if (! (i < 1 << cdepth)) {
#line 246
          goto while_break___0;
        }
#line 247
        if ((nh->node.leaves + i)->nchild <= 0) {
#line 248
          return (k);
        } else
#line 249
        if ((nh->node.leaves + i)->nchild < capacity) {
#line 250
          goto while_break___0;
        } else {
#line 252
          k += capacity;
        }
#line 246
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 254
      if (i == 1 << cdepth) {
#line 255
        return (-1);
      }
    } else {
#line 258
      i = (1 << cdepth) - 1;
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 258
        if (! (i >= 0)) {
#line 258
          goto while_break___1;
        }
#line 259
        if ((nh->node.leaves + i)->nchild <= 0) {
#line 260
          return (((1 << nt->bitsize) - 1) - k);
        } else
#line 261
        if ((nh->node.leaves + i)->nchild < capacity) {
#line 262
          goto while_break___1;
        } else {
#line 264
          k += capacity;
        }
#line 258
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 266
      if (i < 0) {
#line 267
        return (-1);
      }
    }
#line 269
    nh = nh->node.leaves + i;
#line 270
    off ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (-1);
}
}
#line 277 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_get_smallest_free(numhashtable *nt ) 
{ 
  int tmp ;

  {
  {
#line 279
  tmp = numhash_get_terminal_free(nt, 1);
  }
#line 279
  return (tmp);
}
}
#line 281 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_get_largest_free(numhashtable *nt ) 
{ 
  int tmp ;

  {
  {
#line 283
  tmp = numhash_get_terminal_free(nt, -1);
  }
#line 283
  return (tmp);
}
}
#line 288 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_get_terminal_used(numhashtable *nt , int dir ) 
{ 
  int capacity ;
  int cdepth ;
  int i ;
  int k ;
  int off ;
  int shift ;
  int tnd ;
  numhashnode *nh ;

  {
#line 293
  if (nt->table.nchild <= 0) {
#line 294
    return (-1);
  }
#line 296
  off = 0;
#line 297
  nh = & nt->table;
#line 299
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 300
    return (-1);
  }
#line 302
  tnd = (nt->bitsize - 1) / nt->depth;
#line 304
  off = 0;
#line 304
  k = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! ((unsigned long )nh != (unsigned long )((void *)0))) {
#line 304
      goto while_break;
    }
#line 305
    shift = nt->depth * ((nt->bitsize - 1) / nt->depth - off);
#line 306
    if (nt->bitsize - shift < nt->depth) {
#line 306
      cdepth = nt->bitsize - shift;
    } else {
#line 306
      cdepth = nt->depth;
    }
#line 307
    capacity = 1 << shift;
#line 308
    if (dir >= 0) {
#line 309
      i = 0;
      {
#line 309
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 309
        if (! (i < 1 << cdepth)) {
#line 309
          goto while_break___0;
        }
#line 310
        if ((nh->node.leaves + i)->nchild) {
#line 310
          if (off < tnd) {
#line 311
            goto while_break___0;
          } else {
#line 310
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 312
        if ((nh->node.leaves + i)->nchild) {
#line 313
          return (k);
        } else {
#line 315
          k += capacity;
        }
#line 309
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 317
      if (i == 1 << cdepth) {
#line 318
        return (-1);
      }
    } else {
#line 321
      i = (1 << cdepth) - 1;
      {
#line 321
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 321
        if (! (i >= 0)) {
#line 321
          goto while_break___1;
        }
#line 322
        if ((nh->node.leaves + i)->nchild) {
#line 322
          if (off < tnd) {
#line 323
            goto while_break___1;
          } else {
#line 322
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 324
        if ((nh->node.leaves + i)->nchild) {
#line 325
          return (((1 << nt->bitsize) - 1) - k);
        } else {
#line 327
          k += capacity;
        }
#line 321
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 329
      if (i < 0) {
#line 330
        return (-1);
      }
    }
#line 332
    nh = nh->node.leaves + i;
#line 333
    off ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return (-1);
}
}
#line 340 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_get_smallest_used(numhashtable *nt ) 
{ 
  int tmp ;

  {
  {
#line 342
  tmp = numhash_get_terminal_used(nt, 1);
  }
#line 342
  return (tmp);
}
}
#line 344 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_get_largest_used(numhashtable *nt ) 
{ 
  int tmp ;

  {
  {
#line 346
  tmp = numhash_get_terminal_used(nt, -1);
  }
#line 346
  return (tmp);
}
}
#line 351 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_local_walk(numhashnode *nh , int off , int num , int depth , int bitsize ,
                              int (*callback)(int  , void * , void * ) , void *param ) 
{ 
  int shift ;
  int cdepth ;
  int i ;
  int ret ;
  int tmp ;

  {
#line 356
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 357
    return (0);
  }
#line 359
  shift = depth * ((bitsize - 1) / depth - off);
#line 360
  if (bitsize - shift < depth) {
#line 360
    cdepth = bitsize - shift;
  } else {
#line 360
    cdepth = depth;
  }
#line 362
  ret = 0;
#line 364
  if (shift > 0) {
#line 365
    i = 0;
    {
#line 365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 365
      if (! (i < 1 << cdepth)) {
#line 365
        goto while_break;
      }
#line 366
      if ((unsigned long )(nh->node.leaves + i)->node.leaves != (unsigned long )((void *)0)) {
        {
#line 367
        tmp = numhash_local_walk(nh->node.leaves + i, off + 1, num | (i << shift),
                                 depth, bitsize, callback, param);
#line 367
        ret += tmp;
        }
      }
#line 365
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 371
  if ((unsigned long )callback != (unsigned long )((void *)0)) {
#line 372
    i = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (i < 1 << cdepth)) {
#line 372
        goto while_break___0;
      }
#line 373
      if ((nh->node.leaves + i)->nchild > 0) {
        {
#line 374
        (*callback)(num + i, (nh->node.leaves + i)->node.data, param);
#line 375
        ret ++;
        }
      }
#line 372
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 380
    i = 0;
    {
#line 380
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 380
      if (! (i < 1 << cdepth)) {
#line 380
        goto while_break___1;
      }
#line 381
      if ((nh->node.leaves + i)->nchild > 0) {
#line 381
        ret ++;
      }
#line 380
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 384
  return (ret);
}
}
#line 387 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_local_walk_desc(numhashnode *nh , int off , int num , int depth ,
                                   int bitsize , int (*callback)(int  , void * , void * ) ,
                                   void *param ) 
{ 
  int shift ;
  int cdepth ;
  int i ;
  int ret ;
  int tmp ;

  {
#line 392
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 393
    return (0);
  }
#line 395
  shift = depth * ((bitsize - 1) / depth - off);
#line 396
  if (bitsize - shift < depth) {
#line 396
    cdepth = bitsize - shift;
  } else {
#line 396
    cdepth = depth;
  }
#line 398
  ret = 0;
#line 400
  if (shift > 0) {
#line 401
    i = (1 << cdepth) - 1;
    {
#line 401
    while (1) {
      while_continue: /* CIL Label */ ;
#line 401
      if (! (i >= 0)) {
#line 401
        goto while_break;
      }
#line 402
      if ((unsigned long )(nh->node.leaves + i)->node.leaves != (unsigned long )((void *)0)) {
        {
#line 403
        tmp = numhash_local_walk_desc(nh->node.leaves + i, off + 1, num | (i << shift),
                                      depth, bitsize, callback, param);
#line 403
        ret += tmp;
        }
      }
#line 401
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 407
  if ((unsigned long )callback != (unsigned long )((void *)0)) {
#line 408
    i = (1 << cdepth) - 1;
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 408
      if (! (i >= 0)) {
#line 408
        goto while_break___0;
      }
#line 409
      if ((nh->node.leaves + i)->nchild > 0) {
        {
#line 410
        (*callback)(num + i, (nh->node.leaves + i)->node.data, param);
#line 411
        ret ++;
        }
      }
#line 408
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 416
    i = 0;
    {
#line 416
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 416
      if (! (i < 1 << cdepth)) {
#line 416
        goto while_break___1;
      }
#line 417
      if ((nh->node.leaves + i)->nchild > 0) {
#line 417
        ret ++;
      }
#line 416
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 420
  return (ret);
}
}
#line 423 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_walk(numhashtable *nt , int (*callback)(int  , void * , void * ) , void *param ) 
{ 
  int ret ;

  {
  {
#line 427
  ret = numhash_local_walk(& nt->table, 0, 0, nt->depth, nt->bitsize, callback, param);
  }
#line 428
  return (ret);
}
}
#line 431 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_walk_asc(numhashtable *nt , int (*callback)(int  , void * , void * ) ,
                     void *param ) 
{ 
  int tmp ;

  {
  {
#line 434
  tmp = numhash_walk(nt, callback, param);
  }
#line 434
  return (tmp);
}
}
#line 437 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_walk_desc(numhashtable *nt , int (*callback)(int  , void * , void * ) ,
                      void *param ) 
{ 
  int ret ;

  {
  {
#line 441
  ret = numhash_local_walk_desc(& nt->table, 0, 0, nt->depth, nt->bitsize, callback,
                                param);
  }
#line 442
  return (ret);
}
}
#line 445 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_walk_dir(numhashtable *nt , int (*callback)(int  , void * , void * ) ,
                     void *param , int dir ) 
{ 
  int ret ;

  {
#line 450
  if (dir >= 0) {
    {
#line 451
    ret = numhash_local_walk(& nt->table, 0, 0, nt->depth, nt->bitsize, callback,
                             param);
    }
  } else {
    {
#line 453
    ret = numhash_local_walk_desc(& nt->table, 0, 0, nt->depth, nt->bitsize, callback,
                                  param);
    }
  }
#line 455
  return (ret);
}
}
#line 460 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_first(numhashtable *nt ) 
{ 
  int tmp ;

  {
  {
#line 462
  tmp = numhash_get_terminal_used(nt, 1);
  }
#line 462
  return (tmp);
}
}
#line 464 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_first_wdata(numhashtable *nt , void **dret ) 
{ 
  int c ;

  {
  {
#line 467
  c = numhash_get_terminal_used(nt, 1);
  }
#line 468
  if (c >= 0) {
#line 468
    if ((unsigned long )dret != (unsigned long )((void *)0)) {
      {
#line 468
      numhash_search(nt, c, dret);
      }
    }
  }
#line 469
  return (c);
}
}
#line 471 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_last(numhashtable *nt ) 
{ 
  int tmp ;

  {
  {
#line 473
  tmp = numhash_get_terminal_used(nt, -1);
  }
#line 473
  return (tmp);
}
}
#line 475 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_last_wdata(numhashtable *nt , void **dret ) 
{ 
  int c ;

  {
  {
#line 478
  c = numhash_get_terminal_used(nt, -1);
  }
#line 479
  if (c >= 0) {
#line 479
    if ((unsigned long )dret != (unsigned long )((void *)0)) {
      {
#line 479
      numhash_search(nt, c, dret);
      }
    }
  }
#line 480
  return (c);
}
}
#line 483 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_local_first(numhashtable *nt , numhashnode *nh , int fcc , int off ,
                               void **dret ) 
{ 
  int i ;
  int ntn ;
  int lcb ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 488
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 489
    return (-1);
  }
#line 491
  if (off) {
#line 491
    tmp = nt->depth;
  } else {
#line 491
    tmp = nt->bitsize - nt->depth * ((nt->bitsize - 1) / nt->depth);
  }
#line 491
  ntn = 1 << tmp;
#line 492
  lcb = 1 << nt->depth * ((nt->bitsize - 1) / nt->depth - off);
#line 493
  ret = fcc;
#line 494
  i = 0;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! (i < ntn)) {
#line 494
      goto while_break;
    }
#line 495
    if ((nh->node.leaves + i)->nchild) {
#line 496
      if (off < (nt->bitsize - 1) / nt->depth) {
#line 497
        nh = nh->node.leaves + i;
#line 498
        off ++;
#line 499
        if (off) {
#line 499
          tmp___0 = nt->depth;
        } else {
#line 499
          tmp___0 = nt->bitsize - nt->depth * ((nt->bitsize - 1) / nt->depth);
        }
#line 499
        ntn = 1 << tmp___0;
#line 500
        i = 0;
#line 501
        lcb >>= nt->depth;
      } else {
#line 504
        if ((unsigned long )dret != (unsigned long )((void *)0)) {
#line 505
          *dret = (nh->node.leaves + i)->node.data;
        }
#line 506
        return (ret);
      }
    } else {
#line 510
      i ++;
#line 511
      ret += lcb;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 514
  return (-1);
}
}
#line 517 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_local_last(numhashtable *nt , numhashnode *nh , int fcc , int off ,
                              void **dret ) 
{ 
  int i ;
  int ntn ;
  int lcb ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 522
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 523
    return (-1);
  }
#line 525
  if (off) {
#line 525
    tmp = nt->depth;
  } else {
#line 525
    tmp = nt->bitsize - nt->depth * ((nt->bitsize - 1) / nt->depth);
  }
#line 525
  ntn = 1 << tmp;
#line 526
  lcb = 1 << nt->depth * ((nt->bitsize - 1) / nt->depth - off);
#line 527
  ret = fcc + lcb * (ntn - 1);
#line 528
  i = ntn - 1;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i >= 0)) {
#line 528
      goto while_break;
    }
#line 529
    if ((nh->node.leaves + i)->nchild) {
#line 530
      if (off < (nt->bitsize - 1) / nt->depth) {
#line 531
        nh = nh->node.leaves + i;
#line 532
        off ++;
#line 533
        if (off) {
#line 533
          tmp___0 = nt->depth;
        } else {
#line 533
          tmp___0 = nt->bitsize - nt->depth * ((nt->bitsize - 1) / nt->depth);
        }
#line 533
        ntn = 1 << tmp___0;
#line 534
        i = ntn - 1;
#line 535
        lcb >>= nt->depth;
#line 536
        ret += lcb * (ntn - 1);
      } else {
#line 539
        if ((unsigned long )dret != (unsigned long )((void *)0)) {
#line 540
          *dret = (nh->node.leaves + i)->node.data;
        }
#line 541
        return (ret);
      }
    } else {
#line 545
      i --;
#line 546
      ret -= lcb;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  return (-1);
}
}
#line 552 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_local_nextprev(numhashtable *nt , numhashnode *nh0 , int value ,
                                  int off , int fcc , int *ret , int dir , void **dret ) 
{ 
  numhashnode *nh ;
  int c ;
  int i ;
  int k ;
  int is_real_leaf ;
  int ntn ;
  int lcb ;
  int tmp ;

  {
#line 558
  if ((unsigned long )nh0->node.leaves == (unsigned long )((void *)0)) {
#line 559
    return (0);
  }
#line 561
  k = (value >> nt->depth * ((nt->bitsize - 1) / nt->depth - off)) & ((1 << nt->depth) - 1);
#line 562
  nh = nh0->node.leaves + k;
#line 563
  lcb = 1 << nt->depth * ((nt->bitsize - 1) / nt->depth - off);
#line 565
  is_real_leaf = off < (nt->bitsize - 1) / nt->depth;
#line 566
  if ((unsigned long )nh->node.leaves != (unsigned long )((void *)0)) {
#line 566
    if (is_real_leaf) {
      {
#line 567
      c = numhash_local_nextprev(nt, nh, value, off + 1, fcc + k * lcb, ret, dir,
                                 dret);
      }
#line 568
      if (c) {
#line 568
        return (1);
      }
    }
  }
#line 571
  if (off) {
#line 571
    tmp = nt->depth;
  } else {
#line 571
    tmp = nt->bitsize - nt->depth * ((nt->bitsize - 1) / nt->depth);
  }
#line 571
  ntn = 1 << tmp;
#line 573
  if (dir >= 0) {
#line 574
    i = k + 1;
    {
#line 574
    while (1) {
      while_continue: /* CIL Label */ ;
#line 574
      if (! (i < ntn)) {
#line 574
        goto while_break;
      }
#line 575
      nh = nh0->node.leaves + i;
#line 576
      if (! is_real_leaf) {
#line 576
        if (nh->nchild) {
#line 577
          *ret = fcc + i;
#line 578
          if ((unsigned long )dret != (unsigned long )((void *)0)) {
#line 578
            *dret = nh->node.data;
          }
#line 579
          return (1);
        } else {
#line 576
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 581
      if (is_real_leaf) {
#line 581
        if (nh->nchild) {
          {
#line 582
          *ret = numhash_local_first(nt, nh, fcc + i * lcb, off + 1, dret);
          }
#line 583
          return (1);
        }
      }
#line 574
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 588
    i = k - 1;
    {
#line 588
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 588
      if (! (i >= 0)) {
#line 588
        goto while_break___0;
      }
#line 589
      nh = nh0->node.leaves + i;
#line 590
      if (! is_real_leaf) {
#line 590
        if (nh->nchild) {
#line 591
          *ret = fcc + i;
#line 592
          if ((unsigned long )dret != (unsigned long )((void *)0)) {
#line 592
            *dret = nh->node.data;
          }
#line 593
          return (1);
        } else {
#line 590
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 595
      if (is_real_leaf) {
#line 595
        if (nh->nchild) {
          {
#line 596
          *ret = numhash_local_last(nt, nh, fcc + i * lcb, off + 1, dret);
          }
#line 597
          return (1);
        }
      }
#line 588
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 602
  return (0);
}
}
#line 605 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_next_wdata(numhashtable *nt , int value , void **dret ) 
{ 
  int ret ;
  int c ;

  {
  {
#line 608
  c = numhash_local_nextprev(nt, & nt->table, value, 0, 0, & ret, 1, dret);
  }
#line 609
  if (c) {
#line 609
    return (ret);
  } else {
#line 610
    return (-1);
  }
}
}
#line 613 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_prev_wdata(numhashtable *nt , int value , void **dret ) 
{ 
  int ret ;
  int c ;

  {
  {
#line 616
  c = numhash_local_nextprev(nt, & nt->table, value, 0, 0, & ret, -1, dret);
  }
#line 617
  if (c) {
#line 617
    return (ret);
  } else {
#line 618
    return (-1);
  }
}
}
#line 621 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_next(numhashtable *nt , int value ) 
{ 
  int ret ;
  int c ;

  {
  {
#line 624
  c = numhash_local_nextprev(nt, & nt->table, value, 0, 0, & ret, 1, (void **)((void *)0));
  }
#line 625
  if (c) {
#line 625
    return (ret);
  } else {
#line 626
    return (-1);
  }
}
}
#line 629 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_prev(numhashtable *nt , int value ) 
{ 
  int ret ;
  int c ;

  {
  {
#line 632
  c = numhash_local_nextprev(nt, & nt->table, value, 0, 0, & ret, -1, (void **)((void *)0));
  }
#line 633
  if (c) {
#line 633
    return (ret);
  } else {
#line 634
    return (-1);
  }
}
}
#line 637 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_loop_start(numhashtable *nt , int dir , void **ret ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 639
  if (dir >= 0) {
    {
#line 639
    tmp = numhash_first_wdata(nt, ret);
    }
#line 639
    return (tmp);
  } else {
    {
#line 640
    tmp___0 = numhash_last_wdata(nt, ret);
    }
#line 640
    return (tmp___0);
  }
}
}
#line 642 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_loop_next(numhashtable *nt , int dir , int key , void **ret ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 644
  if (dir >= 0) {
    {
#line 644
    tmp = numhash_next_wdata(nt, key, ret);
    }
#line 644
    return (tmp);
  } else {
    {
#line 645
    tmp___0 = numhash_prev_wdata(nt, key, ret);
    }
#line 645
    return (tmp___0);
  }
}
}
#line 650 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
static int numhash_local_free(numhashnode *nh , int off , int depth , int bitsize ) 
{ 
  int shift ;
  int cdepth ;
  int i ;

  {
#line 654
  if ((unsigned long )nh->node.leaves == (unsigned long )((void *)0)) {
#line 655
    return (0);
  }
#line 657
  shift = depth * ((bitsize - 1) / depth - off);
#line 658
  if (bitsize - shift < depth) {
#line 658
    cdepth = bitsize - shift;
  } else {
#line 658
    cdepth = depth;
  }
#line 660
  if (shift > 0) {
#line 661
    i = 0;
    {
#line 661
    while (1) {
      while_continue: /* CIL Label */ ;
#line 661
      if (! (i < 1 << cdepth)) {
#line 661
        goto while_break;
      }
#line 662
      if ((unsigned long )(nh->node.leaves + i)->node.leaves != (unsigned long )((void *)0)) {
        {
#line 663
        numhash_local_free(nh->node.leaves + i, off + 1, depth, bitsize);
        }
      }
#line 661
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 668
  free((void *)nh->node.leaves);
  }
#line 670
  return (0);
}
}
#line 673 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/numhash.c"
int numhash_free(numhashtable *nt ) 
{ 


  {
  {
#line 675
  numhash_local_free(& nt->table, 0, nt->depth, nt->bitsize);
#line 676
  numhash_init(nt, nt->bitsize, nt->depth);
  }
#line 677
  return (0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 31 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.h"
char *freadline(FILE *fr ) ;
#line 40
char *freadline_bs(FILE *fr ) ;
#line 45
FILE *fopenread(char *name ) ;
#line 46
FILE *fopenwrite(char *name ) ;
#line 51
int fcloseread(FILE *fr ) ;
#line 52
int fclosewrite(FILE *fw ) ;
#line 53 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.c"
char *freadline(FILE *fr ) 
{ 
  char *ret ;
  char buff[256] ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 56
  ret = (char *)((void *)0);
#line 57
  tmp = feof(fr);
  }
#line 57
  if (tmp) {
#line 57
    return ((char *)((void *)0));
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    tmp___0 = fgets((char */* __restrict  */)(buff), 255, (FILE */* __restrict  */)fr);
    }
#line 59
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 59
      goto while_break;
    }
#line 60
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
      {
#line 60
      tmp___1 = strlen((char const   *)(buff));
#line 60
      tmp___2 = malloc(tmp___1 + 1UL);
#line 60
      ret = (char *)tmp___2;
#line 60
      *(ret + 0) = (char)0;
      }
    } else {
      {
#line 61
      tmp___3 = strlen((char const   *)ret);
#line 61
      tmp___4 = strlen((char const   *)(buff));
#line 61
      tmp___5 = realloc((void *)ret, (tmp___3 + tmp___4) + 1UL);
#line 61
      ret = (char *)tmp___5;
      }
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
        {
#line 62
        tmp___6 = gettext("memory exhausted");
#line 62
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iof.c: %s.\n",
                tmp___6);
#line 62
        abort();
        }
      }
#line 62
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 63
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)(buff));
#line 64
    tmp___7 = strlen((char const   *)ret);
    }
#line 64
    if ((int )*(ret + (tmp___7 - 1UL)) == 10) {
#line 64
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (ret);
}
}
#line 69 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.c"
char *freadline_bs(FILE *fr ) 
{ 
  char *ret ;
  char *wr ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 73
  ret = (char *)((void *)0);
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    wr = freadline(fr);
    }
#line 76
    if ((unsigned long )wr == (unsigned long )((void *)0)) {
#line 76
      return (ret);
    } else {
#line 78
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 78
        ret = wr;
      } else {
        {
#line 80
        tmp = strlen((char const   *)ret);
#line 80
        tmp___0 = strlen((char const   *)wr);
#line 80
        tmp___1 = realloc((void *)ret, (tmp + tmp___0) + 1UL);
#line 80
        ret = (char *)tmp___1;
        }
        {
#line 81
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 81
          if ((unsigned long )ret == (unsigned long )((void *)0)) {
            {
#line 81
            tmp___2 = gettext("memory exhausted");
#line 81
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iof.c: %s.\n",
                    tmp___2);
#line 81
            abort();
            }
          }
#line 81
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 82
        strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)wr);
#line 83
        free((void *)wr);
        }
      }
      {
#line 85
      tmp___3 = strlen((char const   *)ret);
#line 85
      n = (int )tmp___3;
      }
#line 86
      if (n >= 2) {
#line 87
        if ((int )*(ret + (n - 1)) == 10) {
#line 87
          if ((int )*(ret + (n - 2)) == 92) {
#line 88
            *(ret + (n - 2)) = (char)0;
          } else {
#line 90
            return (ret);
          }
        } else {
#line 90
          return (ret);
        }
      } else {
#line 92
        return (ret);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return ((char *)((void *)0));
}
}
#line 100 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.c"
FILE *fopenread(char *name ) 
{ 
  FILE *fr ;
  int tmp ;

  {
#line 103
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 103
    fr = stdin;
  } else {
    {
#line 104
    tmp = strcmp((char const   *)name, "-");
    }
#line 104
    if (tmp == 0) {
#line 104
      fr = stdin;
    } else {
      {
#line 105
      fr = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
      }
    }
  }
#line 106
  return (fr);
}
}
#line 108 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.c"
FILE *fopenwrite(char *name ) 
{ 
  FILE *fw ;
  int tmp ;

  {
#line 111
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 111
    fw = stdout;
  } else {
    {
#line 112
    tmp = strcmp((char const   *)name, "-");
    }
#line 112
    if (tmp == 0) {
#line 112
      fw = stdout;
    } else {
      {
#line 113
      fw = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"wb");
      }
    }
  }
#line 114
  return (fw);
}
}
#line 117 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.c"
int fcloseread(FILE *fr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 119
  tmp = fileno(fr);
#line 119
  tmp___0 = fileno(stdin);
  }
#line 119
  if (tmp != tmp___0) {
    {
#line 119
    fclose(fr);
    }
  }
#line 120
  return (0);
}
}
#line 123 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/iof.c"
int fclosewrite(FILE *fw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 125
  tmp = fileno(fw);
#line 125
  tmp___0 = fileno(stdout);
  }
#line 125
  if (tmp != tmp___0) {
    {
#line 125
    fclose(fw);
    }
  }
#line 126
  return (0);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 30 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/str.h"
char *strkcpy(char *out , char *in , int size ) ;
#line 35
int strappend(char **str , char *cat ) ;
#line 42
int strappendf(char **str , char *fmt  , ...) ;
#line 45
int vstrappendf(char **str , char *fmt , va_list ap ) ;
#line 52 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/str.c"
char *strkcpy(char *out , char *in , int size ) 
{ 


  {
  {
#line 54
  strncpy((char */* __restrict  */)out, (char const   */* __restrict  */)in, (size_t )size);
#line 55
  *(out + (size - 1)) = (char)0;
  }
#line 56
  return (out);
}
}
#line 61 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/str.c"
int strappend(char **str , char *cat ) 
{ 
  int l1 ;
  int l2 ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 65
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 66
    return (-1);
  } else
#line 67
  if ((unsigned long )*str == (unsigned long )((void *)0)) {
    {
#line 68
    *str = strdup((char const   *)cat);
    }
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      if ((unsigned long )*str == (unsigned long )((void *)0)) {
        {
#line 69
        tmp = gettext("memory exhausted");
#line 69
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"str.c: %s.\n",
                tmp);
#line 69
        abort();
        }
      }
#line 69
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 70
    return (0);
  } else {
    {
#line 73
    tmp___0 = strlen((char const   *)*str);
#line 73
    l1 = (int )tmp___0;
#line 74
    tmp___1 = strlen((char const   *)cat);
#line 74
    l2 = (int )tmp___1;
#line 75
    tmp___2 = realloc((void *)*str, (size_t )((l1 + l2) + 1));
#line 75
    *str = (char *)tmp___2;
    }
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      if ((unsigned long )*str == (unsigned long )((void *)0)) {
        {
#line 76
        tmp___3 = gettext("memory exhausted");
#line 76
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"str.c: %s.\n",
                tmp___3);
#line 76
        abort();
        }
      }
#line 76
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 77
    strcpy((char */* __restrict  */)(*str + l1), (char const   */* __restrict  */)cat);
    }
#line 78
    return (0);
  }
}
}
#line 84 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/str.c"
int vstrappendf(char **str , char *fmt , va_list ap ) 
{ 
  int n ;
  int l ;
  int size ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 88
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 88
    return (0);
  }
#line 90
  if ((unsigned long )*str == (unsigned long )((void *)0)) {
#line 90
    l = 0;
  } else {
    {
#line 91
    tmp = strlen((char const   *)*str);
#line 91
    l = (int )tmp;
    }
  }
  {
#line 92
  size = 128;
#line 94
  tmp___0 = realloc((void *)*str, (size_t )(l + size));
#line 94
  *str = (char *)tmp___0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if ((unsigned long )*str == (unsigned long )((void *)0)) {
#line 95
      if (l + size > 0) {
        {
#line 95
        tmp___1 = gettext("memory exhausted");
#line 95
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"str.c: %s.\n",
                tmp___1);
#line 95
        abort();
        }
      }
    }
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if ((unsigned long )*str == (unsigned long )((void *)0)) {
#line 96
    return (-1);
  }
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 98
    n = vsnprintf((char */* __restrict  */)(*str + l), (size_t )size, (char const   */* __restrict  */)fmt,
                  ap);
    }
#line 99
    if (n > -1) {
#line 99
      if (n < size) {
#line 100
        return (0);
      } else {
#line 99
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 101
    if (n > -1) {
#line 102
      size = n + 1;
    } else {
#line 104
      size *= 2;
    }
    {
#line 105
    tmp___3 = realloc((void *)*str, (size_t )(l + size));
#line 105
    tmp___2 = (char *)tmp___3;
#line 105
    *str = tmp___2;
    }
#line 105
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 106
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  return (0);
}
}
#line 111 "/home/wheatley/newnew/temp/pexec-1.0~rc8/src/str.c"
int strappendf(char **str , char *fmt  , ...) 
{ 
  int ret ;
  va_list ap ;

  {
  {
#line 116
  __builtin_va_start(ap, fmt);
#line 117
  ret = vstrappendf(str, fmt, ap);
#line 118
  __builtin_va_end(ap);
  }
#line 120
  return (ret);
}
}
