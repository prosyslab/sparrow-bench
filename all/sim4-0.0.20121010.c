/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/types.h"
typedef unsigned char uchar;
#line 11 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.h"
struct seq_file {
   FILE *fp ;
   int flags ;
   int count ;
   long offset ;
   char *maskname ;
   char *fname ;
   int from ;
   char *header ;
   int hlen ;
   uchar *seq ;
   int slen ;
};
#line 11 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.h"
typedef struct seq_file SEQ;
#line 124 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct spliced {
   int xs ;
   int xe ;
   int ys ;
   int ye ;
   int score ;
   char type ;
   struct spliced *next ;
};
#line 124 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct spliced splice_t;
#line 5 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
struct argv_scores {
   double E ;
   int I ;
   int M ;
   int O ;
   int V ;
};
#line 5 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
typedef struct argv_scores argv_scores_t;
#line 7 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/types.h"
typedef int bool;
#line 54 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct msp {
   int len ;
   int pos1 ;
   int pos2 ;
   int score ;
   int Score ;
   int prev ;
   struct msp *next_msp ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct msp *Msp_ptr;
#line 62 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct exon {
   int from1 ;
   int from2 ;
   int to1 ;
   int to2 ;
   int min_diag ;
   int max_diag ;
   int match ;
   char ori ;
   int length ;
   int flag ;
   int ematches ;
   int nmatches ;
   int edist ;
   int alen ;
   Msp_ptr msps ;
   struct exon *next_exon ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct exon *Exon_ptr;
#line 84 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct exon Exon;
#line 86 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct coordinates {
   int pos1 ;
   int pos2 ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct coordinates coords;
#line 92 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct edit_script {
   char op_type ;
   int num ;
   struct edit_script *next ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct edit_script edit_script;
#line 98 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct edit_script_list {
   int offset1 ;
   int offset2 ;
   int len1 ;
   int len2 ;
   int score ;
   struct edit_script *script ;
   struct edit_script_list *next_script ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct edit_script_list edit_script_list;
#line 115 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef void *Pointer;
#line 117 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct ValNode {
   Pointer data ;
   struct ValNode *next ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct ValNode *ValNodePtr;
#line 130 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct sim4_stats {
   int internal ;
   int icoverage ;
   int mult ;
   int nmatches ;
   double fcoverage ;
   double marginals ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct sim4_stats sim4_stats_t;
#line 135 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
struct sim4_args {
   int ali_flag ;
   int poly_flag ;
   int acc_flag ;
   int reverse ;
   int DRANGE ;
   int weight ;
   int cutoff ;
   int set_K ;
   int set_C ;
   int set_H ;
   int W ;
   int K ;
   int C ;
   int X ;
   int B ;
   int CDS_from ;
   int CDS_to ;
   char *S ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.h"
typedef struct sim4_args sim4_args_t;
#line 584 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
struct hash_node {
   int ecode ;
   int pos ;
   struct hash_node *link ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.h"
struct charvec {
   char *a ;
   unsigned int len ;
   unsigned int max ;
   void *(*alloc)(void * , size_t  ) ;
   void (*free)(void * ) ;
};
#line 9 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.h"
typedef struct charvec charvec_t;
#line 8 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/types.h"
typedef int ss_t[128][128];
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.h"
 __attribute__((__noreturn__)) void fatalf(char const   *fmt  , ...) ;
#line 15
 __attribute__((__noreturn__)) void fatalfr(char const   *fmt  , ...) ;
#line 20
void ckpclose(FILE *fp ) ;
#line 22
FILE *ckopen(char const   *name , char const   *mode ) ;
#line 24
void *ckallocz(size_t amount ) ;
#line 27
char *copy_string(char const   *s ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.h"
SEQ *seq_open(char const   *fname , char const   *mode , int flags ) ;
#line 56
SEQ *seq_close(SEQ *s ) ;
#line 57
int seq_read(SEQ *seq ) ;
#line 58
char const   *seq_set_header(SEQ *s , char const   *h ) ;
#line 59
SEQ *seq_copy(SEQ const   *s ) ;
#line 60
SEQ *seq_subseq(SEQ const   *s , int origin , int length ) ;
#line 61
SEQ *seq_revcomp_inplace(SEQ *seq ) ;
#line 62
SEQ *seq_get(char const   *fname , char const   *mode , int flags ) ;
#line 63
SEQ *seq_from_chars(unsigned char *chrs , unsigned int len ) ;
#line 64
uchar dna_cmpl(unsigned char ch ) ;
#line 66
int seq_count(SEQ *s ) ;
#line 67
int seq_revisit(SEQ *s , long offset ) ;
#line 68
long seq_offset(SEQ *s ) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/encoding.h"
unsigned char const   dna_complement[256] ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
static int parse_fname(char const   *arg , char **fname , int *from , int *len , char **maskfile ) 
{ 
  char *p ;
  int flags ;
  size_t tmp ;
  int to ;
  int tmp___0 ;
  char *q ;
  char *tmp___1 ;
  char tmp___2 ;

  {
  {
#line 14
  p = (char *)0;
#line 15
  flags = 0;
#line 18
  *fname = copy_string(arg);
#line 20
  tmp = strlen((char const   *)*fname);
#line 20
  p = (*fname + tmp) - 1;
  }
#line 21
  if ((int )*p == 45) {
#line 22
    *p = (char)0;
#line 23
    flags |= 32;
  }
  {
#line 26
  p = strchr((char const   *)*fname, '[');
  }
#line 26
  if (p) {
    {
#line 29
    tmp___0 = sscanf((char const   */* __restrict  */)(p + 1), (char const   */* __restrict  */)"%d,%d",
                     from, & to);
    }
#line 29
    if (tmp___0 != 2) {
#line 30
      return (-1);
    }
#line 31
    if (*from <= 0) {
#line 32
      return (-1);
    } else
#line 31
    if (*from > to) {
#line 32
      return (-1);
    }
#line 33
    *p = (char )'\000';
#line 34
    *len = (to - *from) + 1;
#line 35
    flags |= 65;
  } else {
#line 37
    *from = 1;
#line 38
    *len = -1;
  }
  {
#line 41
  p = strchr((char const   *)*fname, '{');
  }
#line 41
  if (p) {
    {
#line 42
    tmp___1 = strchr((char const   *)(p + 1), '}');
#line 42
    q = tmp___1;
    }
#line 43
    if (q) {
#line 44
      tmp___2 = (char)0;
#line 44
      *q = tmp___2;
#line 44
      *p = tmp___2;
#line 45
      if (maskfile) {
        {
#line 46
        *maskfile = copy_string((char const   *)(p + 1));
#line 47
        flags |= 128;
        }
      }
    }
  } else {
    {
#line 51
    *maskfile = copy_string("");
    }
  }
#line 53
  return (flags);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
static int check_flags(int flags ) 
{ 


  {
  {
#line 59
  if ((flags & 768) == 0) {
#line 59
    goto case_0;
  }
#line 64
  if ((flags & 768) == 512) {
#line 64
    goto case_512;
  }
#line 64
  if ((flags & 768) == 256) {
#line 64
    goto case_512;
  }
#line 66
  if ((flags & 768) == 768) {
#line 66
    goto case_768;
  }
#line 58
  goto switch_break;
  case_0: /* CIL Label */ 
#line 61
  flags |= 256;
#line 62
  goto switch_break;
  case_512: /* CIL Label */ 
  case_256: /* CIL Label */ 
#line 65
  goto switch_break;
  case_768: /* CIL Label */ 
  {
#line 67
  fatalf("seq_open: contradictory flags: SEQ_DISALLOW_AMB|SEQ_ALLOW_AMB");
  }
  switch_break: /* CIL Label */ ;
  }
#line 69
  return (flags);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_open(char const   *fname , char const   *mode , int flags ) 
{ 
  SEQ *s ;
  void *tmp ;
  int r ;

  {
  {
#line 74
  tmp = ckallocz(sizeof(SEQ ));
#line 74
  s = (SEQ *)tmp;
#line 77
  mode = (char const   *)0;
#line 79
  r = parse_fname(fname, & s->fname, & s->from, & s->slen, & s->maskname);
  }
#line 81
  if (r == -1) {
    {
#line 82
    fatalf("improper positions specification: %s", fname);
    }
  }
  {
#line 84
  s->flags = check_flags(r | flags);
#line 85
  s->fp = ckopen((char const   *)s->fname, "r");
#line 86
  s->count = 0;
#line 87
  s->offset = 0L;
  }
#line 88
  return (s);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_copy(SEQ const   *s ) 
{ 
  SEQ *ss ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 93
  tmp = ckallocz(sizeof(SEQ ));
#line 93
  ss = (SEQ *)tmp;
#line 94
  *ss = (SEQ )*s;
#line 95
  tmp___0 = copy_string((char const   *)s->seq);
#line 95
  ss->seq = (uchar *)tmp___0;
#line 96
  ss->header = copy_string((char const   *)s->header);
#line 97
  ss->fname = copy_string((char const   *)s->fname);
#line 98
  ss->maskname = copy_string((char const   *)s->fname);
#line 99
  ss->fp = (FILE *)0;
#line 100
  ss->offset = 0L;
  }
#line 106
  return (ss);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_subseq(SEQ const   *s , int origin , int length ) 
{ 
  SEQ *ss ;
  void *tmp ;

  {
#line 115
  if (origin < 1) {
#line 116
    return ((SEQ *)0);
  } else
#line 115
  if (length < 0) {
#line 116
    return ((SEQ *)0);
  }
#line 117
  if (s->slen < (int const   )((origin + length) - 1)) {
#line 118
    return ((SEQ *)0);
  }
  {
#line 119
  tmp = ckallocz(sizeof(SEQ ));
#line 119
  ss = (SEQ *)tmp;
#line 120
  *ss = (SEQ )*s;
#line 121
  ss->flags = (int )(s->flags | 4);
#line 122
  ss->fp = (FILE *)0;
#line 123
  ss->offset = 0L;
#line 124
  ss->from = 1;
#line 125
  ss->seq = (uchar *)((s->seq + origin) - 1);
#line 126
  ss->slen = length;
  }
#line 127
  return (ss);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_from_chars(unsigned char *chrs , unsigned int len ) 
{ 
  SEQ *s ;
  void *tmp ;

  {
  {
#line 132
  tmp = ckallocz(sizeof(SEQ ));
#line 132
  s = (SEQ *)tmp;
#line 133
  s->fname = (char *)0;
#line 134
  s->header = (char *)0;
#line 135
  s->hlen = 0;
#line 136
  s->seq = chrs;
#line 137
  s->from = 1;
#line 138
  s->slen = (int )len;
#line 139
  s->maskname = (char *)0;
#line 140
  s->flags = 4;
#line 141
  s->count = 0;
#line 142
  s->fp = (FILE *)0;
#line 143
  s->offset = 0L;
  }
#line 144
  return (s);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
char const   *seq_set_header(SEQ *s , char const   *h ) 
{ 


  {
#line 149
  if (s) {
#line 149
    if (s->header) {
      {
#line 150
      free((void *)s->header);
#line 151
      s->header = copy_string(h);
      }
#line 152
      return ((char const   *)s->header);
    }
  }
#line 154
  return ((char const   *)0);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_close(SEQ *s ) 
{ 


  {
#line 159
  if (s) {
#line 160
    if (! (s->flags & 4)) {
#line 161
      if (s->fp) {
#line 162
        if (s->flags & 16) {
          {
#line 163
          ckpclose(s->fp);
          }
        } else {
          {
#line 165
          fclose(s->fp);
          }
        }
      }
#line 167
      if (s->fname) {
        {
#line 167
        free((void *)s->fname);
        }
      }
#line 168
      if (s->header) {
        {
#line 168
        free((void *)s->header);
        }
      }
#line 169
      if (s->seq) {
        {
#line 169
        free((void *)s->seq);
        }
      }
#line 170
      if (s->maskname) {
        {
#line 170
        free((void *)s->maskname);
        }
      }
    }
    {
#line 172
    memset((void *)s, 0, sizeof(SEQ ));
#line 173
    free((void *)s);
    }
  }
#line 175
  return ((SEQ *)0);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
uchar dna_cmpl(unsigned char ch ) 
{ 


  {
#line 181
  return ((uchar )dna_complement[ch]);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
static SEQ *seq_revcomp_helper(SEQ *seq ) 
{ 
  uchar *s ;
  uchar *p ;
  uchar c ;

  {
#line 191
  s = seq->seq;
#line 192
  p = (s + seq->slen) - 1;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((unsigned long )s <= (unsigned long )p)) {
#line 193
      goto while_break;
    }
    {
#line 196
    c = dna_cmpl(*s);
#line 197
    *s = dna_cmpl(*p);
#line 198
    *p = c;
#line 199
    s ++;
#line 199
    p --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return (seq);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_revcomp_inplace(SEQ *seq ) 
{ 


  {
  {
#line 206
  seq_revcomp_helper(seq);
#line 207
  seq->flags ^= 2;
  }
#line 208
  return (seq);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
SEQ *seq_get(char const   *fname , char const   *mode , int flags ) 
{ 
  SEQ *s ;
  SEQ *tmp ;
  int r ;
  int tmp___0 ;

  {
  {
#line 213
  tmp = seq_open(fname, mode, flags);
#line 213
  s = tmp;
#line 214
  tmp___0 = seq_read(s);
#line 214
  r = tmp___0;
  }
#line 215
  if (r < 0) {
    {
#line 216
    fatalfr("could not read from %s", fname);
    }
  } else
#line 217
  if (r == 0) {
#line 218
    return ((SEQ *)0);
  } else {
#line 220
    return (s);
  }
#line 222
  return ((SEQ *)0);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
int seq_count(SEQ *s ) 
{ 


  {
#line 227
  return (s->count);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
int seq_revisit(SEQ *s , long offset ) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = fseek(s->fp, offset, 0);
  }
#line 232
  return (tmp);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq.c"
long seq_offset(SEQ *s ) 
{ 


  {
#line 237
  return (s->offset);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.h"
 __attribute__((__noreturn__)) void fatal(char const   *msg ) ;
#line 23
void *ckalloc(size_t amount ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.h"
int gt[5][5] ;
#line 7
int ct[5][5] ;
#line 8
int ag[5][5] ;
#line 9
int ac[5][5] ;
#line 12
splice_t *new_splice(char c , int xs , int xe , int ys , int ye , int score , splice_t *next ) ;
#line 13
void splice(uchar *in_seqx , int ls , int us , int le , int ue , uchar *in_seqy ,
            int ys , int ye , splice_t **gcell , splice_t **ccell , int ori ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static int spl_encode[128]  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static int encodeInit  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
int gt[5][5]  = { {        0,        0,        0,        2, 
            0}, 
   {        0,        0,        0,        2, 
            0}, 
   {        2,        3,        2,        5, 
            2}, 
   {        0,        0,        0,        2, 
            0}, 
   {        0,        0,        0,        2, 
            0}};
#line 17 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
int ct[5][5]  = { {        0,        0,        0,        2, 
            0}, 
   {        2,        2,        2,        5, 
            2}, 
   {        0,        0,        0,        2, 
            0}, 
   {        0,        0,        0,        2, 
            0}, 
   {        0,        0,        0,        2, 
            0}};
#line 18 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
int ag[5][5]  = { {        2,        2,        5,        2, 
            2}, 
   {        0,        0,        2,        0, 
            0}, 
   {        0,        0,        2,        0, 
            0}, 
   {        0,        0,        2,        0, 
            0}, 
   {        0,        0,        2,        0, 
            0}};
#line 19 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
int ac[5][5]  = { {        2,        5,        2,        2, 
            2}, 
   {        0,        2,        0,        0, 
            0}, 
   {        0,        3,        0,        0, 
            0}, 
   {        0,        2,        0,        0, 
            0}, 
   {        0,        2,        0,        0, 
            0}};
#line 26
static void splice_donor(uchar *xseq , uchar *yseq , int M___0 , int N___0 , int *gt_score ,
                         int *ct_score , int **max_Gf , int **max_Cf , int **start_Gi ,
                         int **start_Ci ) ;
#line 29
static void splice_donor_uni(uchar *xseq , uchar *yseq , int M___0 , int N___0 , int *It_score ,
                             int **max_If , int **start_Ii ) ;
#line 31
static void splice_acceptor(uchar *xseq , uchar *yseq , int M___0 , int N___0 , int *ag_score ,
                            int *ac_score , int **max_Gb , int **max_Cb , int **end_Gi ,
                            int **end_Ci ) ;
#line 34
static void splice_acceptor_uni(uchar *xseq , uchar *yseq , int M___0 , int N___0 ,
                                int *aI_score , int **max_Ib , int **end_Ii ) ;
#line 36
static int stepct(int n ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
void splice(uchar *in_seqx , int ls , int us , int le , int ue , uchar *in_seqy ,
            int ys , int ye , splice_t **gcell , splice_t **ccell , int ori ) 
{ 
  int p ;
  int q ;
  int *gtscore ;
  int *ctscore ;
  int *agscore ;
  int *acscore ;
  int i ;
  int tmp ;
  int maxCscore ;
  int maxGscore ;
  int Gxs ;
  int Gxe ;
  int Gy ;
  int Cxs ;
  int Cxe ;
  int Cy ;
  int keep_Ci ;
  int keep_Gi ;
  int *max_Cf ;
  int *max_Gf ;
  int *max_Cb ;
  int *max_Gb ;
  int *start_Gi ;
  int *start_Ci ;
  int *end_Gi ;
  int *end_Ci ;
  uchar *s ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 43
  gtscore = (int *)((void *)0);
#line 43
  ctscore = (int *)((void *)0);
#line 43
  agscore = (int *)((void *)0);
#line 43
  acscore = (int *)((void *)0);
#line 46
  max_Cf = (int *)((void *)0);
#line 46
  max_Gf = (int *)((void *)0);
#line 46
  max_Cb = (int *)((void *)0);
#line 46
  max_Gb = (int *)((void *)0);
#line 47
  start_Gi = (int *)((void *)0);
#line 47
  start_Ci = (int *)((void *)0);
#line 47
  end_Gi = (int *)((void *)0);
#line 47
  end_Ci = (int *)((void *)0);
#line 50
  if (! encodeInit) {
#line 51
    i = 0;
    {
#line 51
    while (1) {
      while_continue: /* CIL Label */ ;
#line 51
      if (! (i < 128)) {
#line 51
        goto while_break;
      }
#line 51
      tmp___0 = i;
#line 51
      i ++;
#line 51
      spl_encode[tmp___0] = 4;
    }
    while_break: /* CIL Label */ ;
    }
#line 53
    spl_encode['A'] = 0;
#line 53
    spl_encode['C'] = 1;
#line 54
    spl_encode['G'] = 2;
#line 54
    spl_encode['T'] = 3;
#line 56
    encodeInit = 1;
  }
#line 59
  if (ori == 0) {
#line 59
    goto _L;
  } else
#line 59
  if (ori == 2) {
    _L: /* CIL Label */ 
    {
#line 60
    tmp___1 = ckalloc((unsigned long )(((us - ls) + 2) + ((ue - le) + 2)) * sizeof(int ));
#line 60
    gtscore = (int *)tmp___1;
#line 61
    agscore = gtscore + ((us - ls) + 2);
#line 62
    p = 0;
#line 62
    s = (in_seqx + ls) - 1;
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (p <= (us - ls) + 1)) {
#line 62
        goto while_break___0;
      }
#line 63
      *(gtscore + p) = gt[spl_encode[*s]][spl_encode[*(s + 1)]];
#line 62
      p ++;
#line 62
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 64
    q = (ue - le) + 1;
#line 64
    s = (in_seqx + ue) - 1;
    {
#line 64
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 64
      if (! (q >= 0)) {
#line 64
        goto while_break___1;
      }
#line 65
      *(agscore + q) = ag[spl_encode[*(s - 1)]][spl_encode[*s]];
#line 64
      q --;
#line 64
      s --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 67
  if (ori == 1) {
#line 67
    goto _L___0;
  } else
#line 67
  if (ori == 2) {
    _L___0: /* CIL Label */ 
    {
#line 68
    tmp___2 = ckalloc((unsigned long )(((us - ls) + 2) + ((ue - le) + 2)) * sizeof(int ));
#line 68
    ctscore = (int *)tmp___2;
#line 69
    acscore = ctscore + ((us - ls) + 2);
#line 70
    p = 0;
#line 70
    s = (in_seqx + ls) - 1;
    }
    {
#line 70
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 70
      if (! (p <= (us - ls) + 1)) {
#line 70
        goto while_break___2;
      }
#line 71
      *(ctscore + p) = ct[spl_encode[*s]][spl_encode[*(s + 1)]];
#line 70
      p ++;
#line 70
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 72
    q = (ue - le) + 1;
#line 72
    s = (in_seqx + ue) - 1;
    {
#line 72
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 72
      if (! (q >= 0)) {
#line 72
        goto while_break___3;
      }
#line 73
      *(acscore + q) = ac[spl_encode[*(s - 1)]][spl_encode[*s]];
#line 72
      q --;
#line 72
      s --;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 76
  if (ori == 0) {
    {
#line 77
    splice_donor_uni((in_seqx + ls) - 1, (in_seqy + ys) - 1, (us - ls) + 1, (ye - ys) + 1,
                     gtscore, & max_Gf, & start_Gi);
#line 79
    splice_acceptor_uni((in_seqx + le) - 1, (in_seqy + ys) - 1, (ue - le) + 1, (ye - ys) + 1,
                        agscore, & max_Gb, & end_Gi);
#line 81
    free((void *)gtscore);
    }
  } else
#line 83
  if (ori == 1) {
    {
#line 84
    splice_donor_uni((in_seqx + ls) - 1, (in_seqy + ys) - 1, (us - ls) + 1, (ye - ys) + 1,
                     ctscore, & max_Cf, & start_Ci);
#line 86
    splice_acceptor_uni((in_seqx + le) - 1, (in_seqy + ys) - 1, (ue - le) + 1, (ye - ys) + 1,
                        acscore, & max_Cb, & end_Ci);
#line 88
    free((void *)ctscore);
    }
  } else {
    {
#line 91
    splice_donor((in_seqx + ls) - 1, (in_seqy + ys) - 1, (us - ls) + 1, (ye - ys) + 1,
                 gtscore, ctscore, & max_Gf, & max_Cf, & start_Gi, & start_Ci);
#line 94
    splice_acceptor((in_seqx + le) - 1, (in_seqy + ys) - 1, (ue - le) + 1, (ye - ys) + 1,
                    agscore, acscore, & max_Gb, & max_Cb, & end_Gi, & end_Ci);
#line 97
    free((void *)gtscore);
#line 98
    free((void *)ctscore);
    }
  }
#line 101
  maxCscore = -999999;
#line 101
  maxGscore = -999999;
#line 102
  Cy = -1;
#line 102
  Cxe = Cy;
#line 102
  Cxs = Cxe;
#line 102
  Gy = Cxs;
#line 102
  Gxe = Gy;
#line 102
  Gxs = Gxe;
#line 103
  if (ori == 0) {
#line 103
    goto _L___1;
  } else
#line 103
  if (ori == 2) {
    _L___1: /* CIL Label */ 
#line 104
    i = 0;
    {
#line 104
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 104
      if (! (i <= (ye - ys) + 1)) {
#line 104
        goto while_break___4;
      }
#line 105
      tmp = *(max_Gf + i) + *(max_Gb + i);
#line 105
      if (tmp > maxGscore) {
#line 106
        maxGscore = tmp;
#line 108
        Gxs = (ls + *(start_Gi + i)) - 1;
#line 108
        Gxe = (le + *(end_Gi + i)) - 1;
#line 108
        Gy = (ys + i) - 1;
#line 109
        keep_Gi = i;
      }
#line 104
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 112
    free((void *)max_Gf);
#line 112
    free((void *)max_Gb);
    }
  }
#line 114
  if (ori == 1) {
#line 114
    goto _L___2;
  } else
#line 114
  if (ori == 2) {
    _L___2: /* CIL Label */ 
#line 115
    i = 0;
    {
#line 115
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 115
      if (! (i <= (ye - ys) + 1)) {
#line 115
        goto while_break___5;
      }
#line 116
      tmp = *(max_Cf + i) + *(max_Cb + i);
#line 116
      if (tmp > maxCscore) {
#line 117
        maxCscore = tmp;
#line 119
        Cxs = (ls + *(start_Ci + i)) - 1;
#line 119
        Cxe = (le + *(end_Ci + i)) - 1;
#line 119
        Cy = (ys + i) - 1;
#line 120
        keep_Ci = i;
      }
#line 115
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 123
    free((void *)max_Cf);
#line 123
    free((void *)max_Cb);
    }
  }
  {
#line 126
  *gcell = new_splice((char )'G', Gxs, Gxe, Gy, Gy + 1, maxGscore, (splice_t *)((void *)0));
#line 127
  *ccell = new_splice((char )'C', Cxs, Cxe, Cy, Cy + 1, maxCscore, (splice_t *)((void *)0));
  }
#line 133
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
splice_t *new_splice(char c , int xs , int xe , int ys , int ye , int score , splice_t *next ) 
{ 
  splice_t *sp ;
  void *tmp ;

  {
  {
#line 138
  tmp = ckalloc(sizeof(splice_t ));
#line 138
  sp = (splice_t *)tmp;
#line 140
  sp->type = c;
#line 140
  sp->xs = xs;
#line 140
  sp->xe = xe;
#line 141
  sp->ys = ys;
#line 141
  sp->ye = ye;
#line 141
  sp->score = score;
#line 142
  sp->next = next;
  }
#line 144
  return (sp);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static void splice_donor(uchar *xseq , uchar *yseq , int M___0 , int N___0 , int *gt_score ,
                         int *ct_score , int **max_Gf , int **max_Cf , int **start_Gi ,
                         int **start_Ci ) 
{ 
  int *CCf ;
  int *mG ;
  int *mC ;
  int *sC ;
  int *sG ;
  int *X___0 ;
  int i ;
  int j ;
  int tmp ;
  int ss ;
  int ssx ;
  int cx ;
  int c ;
  uchar *s ;
  uchar *t ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 164
  tmp___0 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 164
  CCf = (int *)tmp___0;
#line 165
  tmp___1 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 165
  X___0 = (int *)tmp___1;
#line 166
  tmp___3 = ckalloc((unsigned long )(2 * N___0 + 2) * sizeof(int ));
#line 166
  tmp___2 = (int *)tmp___3;
#line 166
  *max_Gf = tmp___2;
#line 166
  mG = tmp___2;
#line 167
  tmp___4 = mG + (N___0 + 1);
#line 167
  *start_Gi = tmp___4;
#line 167
  sG = tmp___4;
#line 168
  tmp___6 = ckalloc((unsigned long )(2 * N___0 + 2) * sizeof(int ));
#line 168
  tmp___5 = (int *)tmp___6;
#line 168
  *max_Cf = tmp___5;
#line 168
  mC = tmp___5;
#line 169
  tmp___7 = mC + (N___0 + 1);
#line 169
  *start_Ci = tmp___7;
#line 169
  sC = tmp___7;
#line 171
  t = yseq;
#line 171
  tmp___8 = 0;
#line 171
  *(CCf + 0) = tmp___8;
#line 171
  *(X___0 + 0) = tmp___8;
#line 172
  j = 1;
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (j <= M___0)) {
#line 172
      goto while_break;
    }
#line 172
    *(CCf + j) = j;
#line 172
    *(X___0 + j) = 0;
#line 172
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  tmp___9 = -999999;
#line 174
  *(mC + 0) = tmp___9;
#line 174
  *(mG + 0) = tmp___9;
#line 175
  j = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (j <= M___0)) {
#line 175
      goto while_break___0;
    }
#line 176
    if (100 * *(gt_score + j) > *(mG + 0)) {
#line 176
      *(mG + 0) = 100 * *(gt_score + j);
#line 176
      *(sG + 0) = j;
    }
#line 177
    if (100 * *(ct_score + j) > *(mC + 0)) {
#line 177
      *(mC + 0) = 100 * *(ct_score + j);
#line 177
      *(sC + 0) = j;
    }
#line 175
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  i = 1;
  {
#line 180
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 180
    if (! (i <= N___0)) {
#line 180
      goto while_break___1;
    }
#line 181
    s = xseq;
#line 182
    ss = *(CCf + 0);
#line 182
    ssx = *(X___0 + 0);
#line 183
    (*(CCf + 0)) ++;
#line 183
    c = *(CCf + 0);
#line 183
    cx = *(X___0 + 0);
#line 184
    j = 1;
    {
#line 184
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 184
      if (! (j <= M___0)) {
#line 184
        goto while_break___2;
      }
#line 185
      if (*(CCf + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 185
        tmp___12 = ss + ((int )*t != (int )*s);
      } else {
#line 185
        tmp___12 = *(CCf + j) + 1;
      }
#line 185
      if (tmp___12 > c + 1) {
#line 185
        tmp = c + 1;
      } else {
#line 185
        if (*(CCf + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 185
          tmp___11 = ss + ((int )*t != (int )*s);
        } else {
#line 185
          tmp___11 = *(CCf + j) + 1;
        }
#line 185
        tmp = tmp___11;
      }
#line 186
      if (! (tmp == c + 1)) {
#line 187
        if (tmp == *(CCf + j) + 1) {
#line 187
          cx = *(X___0 + j);
        } else {
#line 188
          cx = ssx + ((int )*t == (int )*s);
        }
      }
#line 189
      c = tmp;
#line 189
      ss = *(CCf + j);
#line 189
      *(CCf + j) = c;
#line 189
      ssx = *(X___0 + j);
#line 189
      *(X___0 + j) = cx;
#line 184
      j ++;
#line 184
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 193
    tmp___13 = -999999;
#line 193
    *(mC + i) = tmp___13;
#line 193
    *(mG + i) = tmp___13;
#line 194
    j = 0;
    {
#line 194
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 194
      if (! (j <= M___0)) {
#line 194
        goto while_break___3;
      }
#line 195
      if (! (*(X___0 + j) + *(CCf + j) != 0)) {
        {
#line 195
        __assert_fail("X[j]+CCf[j]!=0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c",
                      195U, "splice_donor");
        }
      }
      {
#line 196
      tmp___14 = stepct(j);
#line 196
      tmp = (int )(((double )(tmp___14 * *(X___0 + j)) / (double )(*(X___0 + j) + *(CCf + j))) * (double )100);
      }
#line 197
      if (tmp + 100 * *(gt_score + j) > *(mG + i)) {
#line 198
        *(mG + i) = tmp + 100 * *(gt_score + j);
#line 198
        *(sG + i) = j;
      }
#line 200
      if (tmp + 100 * *(ct_score + j) > *(mC + i)) {
#line 201
        *(mC + i) = tmp + 100 * *(ct_score + j);
#line 201
        *(sC + i) = j;
      }
#line 194
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 180
    i ++;
#line 180
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 205
  free((void *)CCf);
#line 205
  free((void *)X___0);
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static void splice_donor_uni(uchar *xseq , uchar *yseq , int M___0 , int N___0 , int *It_score ,
                             int **max_If , int **start_Ii ) 
{ 
  int *CCf ;
  int *mI ;
  int *sI ;
  int *X___0 ;
  int i ;
  int j ;
  int tmp ;
  int ss ;
  int ssx ;
  int cx ;
  int c ;
  uchar *s ;
  uchar *t ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 215
  tmp___0 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 215
  CCf = (int *)tmp___0;
#line 216
  tmp___1 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 216
  X___0 = (int *)tmp___1;
#line 217
  tmp___3 = ckalloc((unsigned long )(2 * N___0 + 2) * sizeof(int ));
#line 217
  tmp___2 = (int *)tmp___3;
#line 217
  *max_If = tmp___2;
#line 217
  mI = tmp___2;
#line 218
  tmp___4 = mI + (N___0 + 1);
#line 218
  *start_Ii = tmp___4;
#line 218
  sI = tmp___4;
#line 220
  t = yseq;
#line 220
  tmp___5 = 0;
#line 220
  *(CCf + 0) = tmp___5;
#line 220
  *(X___0 + 0) = tmp___5;
#line 221
  j = 1;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (j <= M___0)) {
#line 221
      goto while_break;
    }
#line 221
    *(CCf + j) = j;
#line 221
    *(X___0 + j) = 0;
#line 221
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  *(mI + 0) = -999999;
#line 224
  j = 0;
  {
#line 224
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 224
    if (! (j <= M___0)) {
#line 224
      goto while_break___0;
    }
#line 225
    if (100 * *(It_score + j) > *(mI + 0)) {
#line 225
      *(mI + 0) = 100 * *(It_score + j);
#line 225
      *(sI + 0) = j;
    }
#line 224
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 227
  i = 1;
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 227
    if (! (i <= N___0)) {
#line 227
      goto while_break___1;
    }
#line 228
    s = xseq;
#line 229
    ss = *(CCf + 0);
#line 229
    ssx = *(X___0 + 0);
#line 230
    (*(CCf + 0)) ++;
#line 230
    c = *(CCf + 0);
#line 230
    cx = *(X___0 + 0);
#line 231
    j = 1;
    {
#line 231
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 231
      if (! (j <= M___0)) {
#line 231
        goto while_break___2;
      }
#line 232
      if (*(CCf + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 232
        tmp___8 = ss + ((int )*t != (int )*s);
      } else {
#line 232
        tmp___8 = *(CCf + j) + 1;
      }
#line 232
      if (tmp___8 > c + 1) {
#line 232
        tmp = c + 1;
      } else {
#line 232
        if (*(CCf + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 232
          tmp___7 = ss + ((int )*t != (int )*s);
        } else {
#line 232
          tmp___7 = *(CCf + j) + 1;
        }
#line 232
        tmp = tmp___7;
      }
#line 233
      if (! (tmp == c + 1)) {
#line 234
        if (tmp == *(CCf + j) + 1) {
#line 234
          cx = *(X___0 + j);
        } else {
#line 235
          cx = ssx + ((int )*t == (int )*s);
        }
      }
#line 236
      c = tmp;
#line 236
      ss = *(CCf + j);
#line 236
      *(CCf + j) = c;
#line 236
      ssx = *(X___0 + j);
#line 236
      *(X___0 + j) = cx;
#line 231
      j ++;
#line 231
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 240
    *(mI + i) = -999999;
#line 241
    j = 0;
    {
#line 241
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 241
      if (! (j <= M___0)) {
#line 241
        goto while_break___3;
      }
#line 242
      if (! (*(X___0 + j) + *(CCf + j) != 0)) {
        {
#line 242
        __assert_fail("X[j]+CCf[j]!=0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c",
                      242U, "splice_donor_uni");
        }
      }
      {
#line 243
      tmp___9 = stepct(j);
#line 243
      tmp = (int )(((double )(tmp___9 * *(X___0 + j)) / (double )(*(X___0 + j) + *(CCf + j))) * (double )100) + 100 * *(It_score + j);
      }
#line 244
      if (tmp > *(mI + i)) {
#line 245
        *(mI + i) = tmp;
#line 245
        *(sI + i) = j;
      }
#line 241
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 227
    i ++;
#line 227
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 249
  free((void *)CCf);
#line 249
  free((void *)X___0);
  }
#line 250
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static void splice_acceptor(uchar *xseq , uchar *yseq , int M___0 , int N___0 , int *ag_score ,
                            int *ac_score , int **max_Gb , int **max_Cb , int **end_Gi ,
                            int **end_Ci ) 
{ 
  int *CCb ;
  int *X___0 ;
  int *mC ;
  int *mG ;
  int *eC ;
  int *eG ;
  int tmp ;
  int i ;
  int j ;
  int ss ;
  int ssx ;
  int cx ;
  int c ;
  uchar *t ;
  uchar *s ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 261
  tmp___0 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 261
  CCb = (int *)tmp___0;
#line 262
  tmp___1 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 262
  X___0 = (int *)tmp___1;
#line 263
  tmp___3 = ckalloc((unsigned long )(2 * N___0 + 2) * sizeof(int ));
#line 263
  tmp___2 = (int *)tmp___3;
#line 263
  *max_Gb = tmp___2;
#line 263
  mG = tmp___2;
#line 264
  tmp___4 = mG + (N___0 + 1);
#line 264
  *end_Gi = tmp___4;
#line 264
  eG = tmp___4;
#line 265
  tmp___6 = ckalloc((unsigned long )(2 * N___0 + 2) * sizeof(int ));
#line 265
  tmp___5 = (int *)tmp___6;
#line 265
  *max_Cb = tmp___5;
#line 265
  mC = tmp___5;
#line 266
  tmp___7 = mC + (N___0 + 1);
#line 266
  *end_Ci = tmp___7;
#line 266
  eC = tmp___7;
#line 268
  t = (yseq + N___0) - 1;
#line 268
  tmp___8 = 0;
#line 268
  *(X___0 + M___0) = tmp___8;
#line 268
  *(CCb + M___0) = tmp___8;
#line 269
  j = M___0 - 1;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (j >= 0)) {
#line 269
      goto while_break;
    }
#line 269
    *(CCb + j) = M___0 - j;
#line 269
    *(X___0 + j) = 0;
#line 269
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  tmp___9 = -999999;
#line 271
  *(mC + N___0) = tmp___9;
#line 271
  *(mG + N___0) = tmp___9;
#line 272
  j = M___0;
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (! (j >= 0)) {
#line 272
      goto while_break___0;
    }
#line 273
    if (100 * *(ag_score + j) > *(mG + N___0)) {
#line 273
      *(mG + N___0) = 100 * *(ag_score + j);
#line 273
      *(eG + N___0) = j + 1;
    }
#line 274
    if (100 * *(ac_score + j) > *(mC + N___0)) {
#line 274
      *(mC + N___0) = 100 * *(ac_score + j);
#line 274
      *(eC + N___0) = j + 1;
    }
#line 272
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 277
  i = N___0 - 1;
  {
#line 277
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 277
    if (! (i >= 0)) {
#line 277
      goto while_break___1;
    }
#line 278
    s = (xseq + M___0) - 1;
#line 279
    ss = *(CCb + M___0);
#line 279
    ssx = *(X___0 + M___0);
#line 280
    (*(CCb + M___0)) ++;
#line 280
    c = *(CCb + M___0);
#line 280
    cx = *(X___0 + M___0);
#line 281
    j = M___0 - 1;
    {
#line 281
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 281
      if (! (j >= 0)) {
#line 281
        goto while_break___2;
      }
#line 282
      if (*(CCb + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 282
        tmp___12 = ss + ((int )*t != (int )*s);
      } else {
#line 282
        tmp___12 = *(CCb + j) + 1;
      }
#line 282
      if (tmp___12 > c + 1) {
#line 282
        tmp = c + 1;
      } else {
#line 282
        if (*(CCb + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 282
          tmp___11 = ss + ((int )*t != (int )*s);
        } else {
#line 282
          tmp___11 = *(CCb + j) + 1;
        }
#line 282
        tmp = tmp___11;
      }
#line 283
      if (! (tmp == c + 1)) {
#line 284
        if (tmp == *(CCb + j) + 1) {
#line 284
          cx = *(X___0 + j);
        } else {
#line 285
          cx = ssx + ((int )*t == (int )*s);
        }
      }
#line 286
      c = tmp;
#line 286
      ss = *(CCb + j);
#line 286
      *(CCb + j) = c;
#line 286
      ssx = *(X___0 + j);
#line 286
      *(X___0 + j) = cx;
#line 281
      j --;
#line 281
      s --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 290
    *(mG + i) = -999999;
#line 290
    *(mC + i) = -999999;
#line 291
    j = M___0;
    {
#line 291
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 291
      if (! (j >= 0)) {
#line 291
        goto while_break___3;
      }
#line 292
      if (! (*(CCb + j) + *(X___0 + j) != 0)) {
        {
#line 292
        __assert_fail("CCb[j]+X[j]!=0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c",
                      292U, "splice_acceptor");
        }
      }
      {
#line 293
      tmp___13 = stepct(M___0 - j);
#line 293
      tmp = (int )(((double )(tmp___13 * *(X___0 + j)) / (double )(*(CCb + j) + *(X___0 + j))) * (double )100);
      }
#line 294
      if (tmp + 100 * *(ag_score + j) > *(mG + i)) {
#line 295
        *(mG + i) = tmp + 100 * *(ag_score + j);
#line 295
        *(eG + i) = j + 1;
      }
#line 297
      if (tmp + 100 * *(ac_score + j) > *(mC + i)) {
#line 298
        *(mC + i) = tmp + 100 * *(ac_score + j);
#line 298
        *(eC + i) = j + 1;
      }
#line 291
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 277
    i --;
#line 277
    t --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 302
  free((void *)CCb);
#line 302
  free((void *)X___0);
  }
#line 303
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static void splice_acceptor_uni(uchar *xseq , uchar *yseq , int M___0 , int N___0 ,
                                int *aI_score , int **max_Ib , int **end_Ii ) 
{ 
  int *CCb ;
  int *X___0 ;
  int *mI ;
  int *eI ;
  int tmp ;
  int i ;
  int j ;
  int ss ;
  int ssx ;
  int cx ;
  int c ;
  uchar *t ;
  uchar *s ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 313
  tmp___0 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 313
  CCb = (int *)tmp___0;
#line 314
  tmp___1 = ckalloc((unsigned long )(M___0 + 1) * sizeof(int ));
#line 314
  X___0 = (int *)tmp___1;
#line 315
  tmp___3 = ckalloc((unsigned long )(2 * N___0 + 2) * sizeof(int ));
#line 315
  tmp___2 = (int *)tmp___3;
#line 315
  *max_Ib = tmp___2;
#line 315
  mI = tmp___2;
#line 316
  tmp___4 = mI + (N___0 + 1);
#line 316
  *end_Ii = tmp___4;
#line 316
  eI = tmp___4;
#line 318
  t = (yseq + N___0) - 1;
#line 318
  tmp___5 = 0;
#line 318
  *(X___0 + M___0) = tmp___5;
#line 318
  *(CCb + M___0) = tmp___5;
#line 319
  j = M___0 - 1;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (j >= 0)) {
#line 319
      goto while_break;
    }
#line 319
    *(CCb + j) = M___0 - j;
#line 319
    *(X___0 + j) = 0;
#line 319
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  *(mI + N___0) = -999999;
#line 322
  j = M___0;
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 322
    if (! (j >= 0)) {
#line 322
      goto while_break___0;
    }
#line 323
    if (100 * *(aI_score + j) > *(mI + N___0)) {
#line 323
      *(mI + N___0) = 100 * *(aI_score + j);
#line 323
      *(eI + N___0) = j + 1;
    }
#line 322
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  i = N___0 - 1;
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 325
    if (! (i >= 0)) {
#line 325
      goto while_break___1;
    }
#line 326
    s = (xseq + M___0) - 1;
#line 327
    ss = *(CCb + M___0);
#line 327
    ssx = *(X___0 + M___0);
#line 328
    (*(CCb + M___0)) ++;
#line 328
    c = *(CCb + M___0);
#line 328
    cx = *(X___0 + M___0);
#line 329
    j = M___0 - 1;
    {
#line 329
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (j >= 0)) {
#line 329
        goto while_break___2;
      }
#line 330
      if (*(CCb + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 330
        tmp___8 = ss + ((int )*t != (int )*s);
      } else {
#line 330
        tmp___8 = *(CCb + j) + 1;
      }
#line 330
      if (tmp___8 > c + 1) {
#line 330
        tmp = c + 1;
      } else {
#line 330
        if (*(CCb + j) + 1 > ss + ((int )*t != (int )*s)) {
#line 330
          tmp___7 = ss + ((int )*t != (int )*s);
        } else {
#line 330
          tmp___7 = *(CCb + j) + 1;
        }
#line 330
        tmp = tmp___7;
      }
#line 331
      if (! (tmp == c + 1)) {
#line 332
        if (tmp == *(CCb + j) + 1) {
#line 332
          cx = *(X___0 + j);
        } else {
#line 333
          cx = ssx + ((int )*t == (int )*s);
        }
      }
#line 335
      c = tmp;
#line 335
      ss = *(CCb + j);
#line 335
      *(CCb + j) = c;
#line 335
      ssx = *(X___0 + j);
#line 335
      *(X___0 + j) = cx;
#line 329
      j --;
#line 329
      s --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 339
    *(mI + i) = -999999;
#line 340
    j = M___0;
    {
#line 340
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 340
      if (! (j >= 0)) {
#line 340
        goto while_break___3;
      }
#line 341
      if (! (*(CCb + j) + *(X___0 + j) != 0)) {
        {
#line 341
        __assert_fail("CCb[j]+X[j]!=0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c",
                      341U, "splice_acceptor_uni");
        }
      }
      {
#line 342
      tmp___9 = stepct(M___0 - j);
#line 342
      tmp = (int )(((double )(tmp___9 * *(X___0 + j)) / (double )(*(CCb + j) + *(X___0 + j))) * (double )100) + 100 * *(aI_score + j);
      }
#line 343
      if (tmp > *(mI + i)) {
#line 344
        *(mI + i) = tmp;
#line 344
        *(eI + i) = j + 1;
      }
#line 340
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 325
    i --;
#line 325
    t --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 348
  free((void *)CCb);
#line 348
  free((void *)X___0);
  }
#line 349
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/splice.c"
static int stepct(int n ) 
{ 


  {
#line 354
  if (n < 0) {
    {
#line 354
    fatal("splice.c: Negative value in stepct().");
    }
  }
#line 355
  if (n <= 4) {
#line 355
    return (9);
  }
#line 356
  if (n <= 8) {
#line 356
    return (10);
  }
#line 357
  if (n <= 12) {
#line 357
    return (12);
  }
#line 358
  return (12);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
void ck_argc(char const   *proc_name ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/dna.h"
void DNA_scores(argv_scores_t *ds , int (*ss)[128] ) ;
#line 12
void DNA_scores_dflt(argv_scores_t *ds , int (*ss)[128] , argv_scores_t const   *dflt ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/dna.c"
static struct argv_scores  const  EIMOV  =    {(double )1, 1, 0, 0, 1};
#line 21 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/dna.c"
static void set_argv_scores(argv_scores_t *s , argv_scores_t const   * const  dflt ) 
{ 


  {
#line 23
  *s = (argv_scores_t )*dflt;
#line 24
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/dna.c"
void DNA_scores_dflt(argv_scores_t *ds , int (*ss)[128] , argv_scores_t const   *dflt ) 
{ 
  int i ;
  int j ;
  int bad ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 31
  ck_argc("DNA_scores");
#line 32
  set_argv_scores(ds, (argv_scores_t const   */* const  */)dflt);
#line 34
  i = 0;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < 128)) {
#line 34
      goto while_break;
    }
#line 35
    j = 0;
    {
#line 35
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 35
      if (! (j < 128)) {
#line 35
        goto while_break___0;
      }
#line 36
      (*(ss + i))[j] = ds->V;
#line 35
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  bad = -100 * ds->M;
#line 39
  i = 0;
  {
#line 39
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 39
    if (! (i < 128)) {
#line 39
      goto while_break___1;
    }
#line 40
    tmp = bad;
#line 40
    (*(ss + i))['X'] = tmp;
#line 40
    (*(ss + 'X'))[i] = tmp;
#line 39
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 42
  tmp___2 = ds->M;
#line 42
  (*(ss + 't'))['t'] = tmp___2;
#line 42
  tmp___1 = tmp___2;
#line 42
  (*(ss + 'g'))['g'] = tmp___1;
#line 42
  tmp___0 = tmp___1;
#line 42
  (*(ss + 'c'))['c'] = tmp___0;
#line 42
  (*(ss + 'a'))['a'] = tmp___0;
#line 43
  tmp___5 = ds->M;
#line 43
  (*(ss + 't'))['T'] = tmp___5;
#line 43
  tmp___4 = tmp___5;
#line 43
  (*(ss + 'g'))['G'] = tmp___4;
#line 43
  tmp___3 = tmp___4;
#line 43
  (*(ss + 'c'))['C'] = tmp___3;
#line 43
  (*(ss + 'a'))['A'] = tmp___3;
#line 44
  tmp___8 = ds->M;
#line 44
  (*(ss + 'T'))['t'] = tmp___8;
#line 44
  tmp___7 = tmp___8;
#line 44
  (*(ss + 'G'))['g'] = tmp___7;
#line 44
  tmp___6 = tmp___7;
#line 44
  (*(ss + 'C'))['c'] = tmp___6;
#line 44
  (*(ss + 'A'))['a'] = tmp___6;
#line 45
  tmp___11 = ds->M;
#line 45
  (*(ss + 'T'))['T'] = tmp___11;
#line 45
  tmp___10 = tmp___11;
#line 45
  (*(ss + 'G'))['G'] = tmp___10;
#line 45
  tmp___9 = tmp___10;
#line 45
  (*(ss + 'C'))['C'] = tmp___9;
#line 45
  (*(ss + 'A'))['A'] = tmp___9;
#line 47
  tmp___14 = ds->I;
#line 47
  (*(ss + 't'))['c'] = tmp___14;
#line 47
  tmp___13 = tmp___14;
#line 47
  (*(ss + 'c'))['t'] = tmp___13;
#line 47
  tmp___12 = tmp___13;
#line 47
  (*(ss + 'g'))['a'] = tmp___12;
#line 47
  (*(ss + 'a'))['g'] = tmp___12;
#line 48
  tmp___17 = ds->I;
#line 48
  (*(ss + 't'))['C'] = tmp___17;
#line 48
  tmp___16 = tmp___17;
#line 48
  (*(ss + 'c'))['T'] = tmp___16;
#line 48
  tmp___15 = tmp___16;
#line 48
  (*(ss + 'g'))['A'] = tmp___15;
#line 48
  (*(ss + 'a'))['G'] = tmp___15;
#line 49
  tmp___20 = ds->I;
#line 49
  (*(ss + 'T'))['c'] = tmp___20;
#line 49
  tmp___19 = tmp___20;
#line 49
  (*(ss + 'C'))['t'] = tmp___19;
#line 49
  tmp___18 = tmp___19;
#line 49
  (*(ss + 'G'))['a'] = tmp___18;
#line 49
  (*(ss + 'A'))['g'] = tmp___18;
#line 50
  tmp___23 = ds->I;
#line 50
  (*(ss + 'T'))['C'] = tmp___23;
#line 50
  tmp___22 = tmp___23;
#line 50
  (*(ss + 'C'))['T'] = tmp___22;
#line 50
  tmp___21 = tmp___22;
#line 50
  (*(ss + 'G'))['A'] = tmp___21;
#line 50
  (*(ss + 'A'))['G'] = tmp___21;
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/dna.c"
void DNA_scores(argv_scores_t *ds , int (*ss)[128] ) 
{ 


  {
  {
#line 55
  DNA_scores_dflt(ds, ss, & EIMOV);
  }
#line 56
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
bool get_argval(int c , int *val_ptr ) ;
#line 18
void fprintf_argv(FILE *fp ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.h"
void print_align_header(SEQ *seq1___0 , SEQ *seq2___0 , argv_scores_t *ds ) ;
#line 8
void print_align(int score , uchar *seq1___0 , uchar *seq2___0 , int beg1 , int end1 ,
                 int beg2 , int end2 , int *S ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
static int offset1  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
static int offset2  ;
#line 21
static char *subseq_label(char *buf , unsigned int size , int n ) ;
#line 22
static char const   *revflag(SEQ *s ) ;
#line 23
static char const   *revlabel(SEQ *s ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
static void print_align_header_n(SEQ *seq1___0 , SEQ *seq2___0 , argv_scores_t *ds ,
                                 int n ) 
{ 
  int f ;
  int t ;
  int F ;
  int T ;
  char buf[128] ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 30
  printf((char const   */* __restrict  */)"#:lav\n\nd {\n  \"");
#line 31
  ck_argc("print_align_header");
#line 32
  fprintf_argv(stdout);
#line 33
  printf((char const   */* __restrict  */)"\n   M = %d, I = %d, V = %d", ds->M, ds->I,
         ds->V);
#line 34
  printf((char const   */* __restrict  */)", O = %d, E = %g", ds->O, ds->E);
#line 35
  printf((char const   */* __restrict  */)"\"\n}\n");
#line 37
  tmp___2 = get_argval('f', & f);
  }
#line 37
  if (tmp___2) {
    {
#line 38
    tmp = get_argval('t', & t);
    }
#line 38
    if (tmp) {
      {
#line 38
      tmp___0 = get_argval('F', & F);
      }
#line 38
      if (tmp___0) {
        {
#line 38
        tmp___1 = get_argval('T', & T);
        }
#line 38
        if (! tmp___1) {
          {
#line 40
          fatal("Inconsistent use of `f`, `t`, `F\', `T\' args.");
          }
        }
      } else {
        {
#line 40
        fatal("Inconsistent use of `f`, `t`, `F\', `T\' args.");
        }
      }
    } else {
      {
#line 40
      fatal("Inconsistent use of `f`, `t`, `F\', `T\' args.");
      }
    }
#line 41
    offset1 = seq1___0->from - f;
#line 42
    offset2 = seq2___0->from - F;
  } else {
#line 44
    f = seq1___0->from;
#line 44
    t = (seq1___0->slen + seq1___0->from) - 1;
#line 45
    F = seq2___0->from;
#line 45
    T = (seq2___0->slen + seq2___0->from) - 1;
#line 46
    offset2 = 0;
#line 46
    offset1 = offset2;
  }
  {
#line 48
  tmp___3 = revflag(seq2___0);
#line 48
  tmp___4 = revflag(seq1___0);
#line 48
  printf((char const   */* __restrict  */)"s {\n  \"%s%s\" %d %d\n  \"%s%s\" %d %d\n}\n",
         seq1___0->fname, tmp___4, f, t, seq2___0->fname, tmp___3, F, T);
#line 51
  tmp___5 = subseq_label(buf, (unsigned int )sizeof(buf), n);
#line 51
  tmp___6 = revlabel(seq2___0);
#line 51
  tmp___7 = revlabel(seq1___0);
#line 51
  printf((char const   */* __restrict  */)"h {\n   \"%s%s\"\n   \"%s%s%s\"\n}\n",
         seq1___0->header, tmp___7, seq2___0->header, tmp___6, tmp___5);
  }
#line 57
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
void print_align_header(SEQ *seq1___0 , SEQ *seq2___0 , argv_scores_t *ds ) 
{ 


  {
  {
#line 62
  print_align_header_n(seq1___0, seq2___0, ds, 0);
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
static char *subseq_label(char *buf , unsigned int size , int n ) 
{ 


  {
#line 67
  if (! (size > 0U)) {
    {
#line 67
    __assert_fail("size > 0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c",
                  67U, "subseq_label");
    }
  }
#line 68
  *(buf + 0) = (char)0;
#line 69
  if (n > 0) {
    {
#line 69
    snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)" (subsequence #%d)",
             n);
    }
  }
#line 70
  return (buf);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
static char const   *revflag(SEQ *s ) 
{ 
  char const   *tmp ;

  {
#line 75
  if (s->flags & 2) {
#line 75
    tmp = "-";
  } else {
#line 75
    tmp = "";
  }
#line 75
  return (tmp);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
static char const   *revlabel(SEQ *s ) 
{ 
  char const   *tmp ;

  {
#line 80
  if (s->flags & 2) {
#line 80
    tmp = " (reverse complement)";
  } else {
#line 80
    tmp = "";
  }
#line 80
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/prnt.c"
void print_align(int score , uchar *seq1___0 , uchar *seq2___0 , int beg1 , int end1 ,
                 int beg2 , int end2 , int *S ) 
{ 
  int M___0 ;
  int N___0 ;
  int i ;
  int j ;
  int op ;
  int start_i ;
  int start_j ;
  int match ;
  int run ;
  int pct ;
  uchar *P ;
  uchar *p ;
  uchar *q ;
  uchar *tmp ;
  uchar *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 90
  beg1 += offset1;
#line 91
  end1 += offset1;
#line 92
  beg2 += offset2;
#line 93
  end2 += offset2;
#line 95
  M___0 = (end1 - beg1) + 1;
#line 96
  N___0 = (end2 - beg2) + 1;
#line 97
  printf((char const   */* __restrict  */)"a {\n  s %d\n  b %d %d\n  e %d %d\n", score,
         beg1, beg2, end1, end2);
#line 99
  j = 0;
#line 99
  i = j;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < M___0)) {
#line 99
      if (! (j < N___0)) {
#line 99
        goto while_break;
      }
    }
#line 100
    start_i = i;
#line 101
    start_j = j;
#line 102
    match = 0;
#line 103
    p = ((seq1___0 + beg1) + i) - 1;
#line 103
    P = p;
#line 104
    q = ((seq2___0 + beg2) + j) - 1;
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      if (i < M___0) {
#line 105
        if (j < N___0) {
#line 105
          if (! (*S == 0)) {
#line 105
            goto while_break___0;
          }
        } else {
#line 105
          goto while_break___0;
        }
      } else {
#line 105
        goto while_break___0;
      }
#line 106
      tmp = p;
#line 106
      p ++;
#line 106
      tmp___0 = q;
#line 106
      q ++;
#line 106
      if ((int )*tmp == (int )*tmp___0) {
#line 107
        match ++;
      }
#line 108
      i ++;
#line 109
      j ++;
#line 110
      S ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    run = (int )(p - P);
#line 113
    if (run > 0) {
#line 113
      pct = (100 * match + run / 2) / run;
    } else {
#line 113
      pct = 0;
    }
    {
#line 114
    printf((char const   */* __restrict  */)"  l %d %d %d %d %d\n", beg1 + start_i,
           beg2 + start_j, (beg1 + i) - 1, (beg2 + j) - 1, pct);
    }
#line 116
    if (i < M___0) {
#line 116
      goto _L;
    } else
#line 116
    if (j < N___0) {
      _L: /* CIL Label */ 
#line 117
      tmp___1 = S;
#line 117
      S ++;
#line 117
      op = *tmp___1;
#line 117
      if (op > 0) {
#line 117
        j += op;
      } else {
#line 117
        i -= op;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  printf((char const   */* __restrict  */)"}\n");
  }
#line 121
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
uchar *seq1  ;
#line 5 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
uchar *seq2  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
int M  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
int N  ;
#line 6 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
int encoding[128]  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
int file_type  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
coords last_GT  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
coords last_CT  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
coords last_AG  ;
#line 8 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
coords last_AC  ;
#line 9 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.h"
sim4_args_t rs  ;
#line 11
Exon *find_previous(Exon *lblock , Exon *tgt ) ;
#line 12
void script_flip_list(edit_script_list **left ) ;
#line 13
void link_to_data_list(Pointer data , ValNodePtr *head , ValNodePtr *prev ) ;
#line 14
void ValNodeFreeData(ValNodePtr data_list ) ;
#line 15
int good_ratio(int length ) ;
#line 16
void flip_list(Exon **left , Exon **right ) ;
#line 17
void free_list(Exon *left ) ;
#line 18
void free_table(void) ;
#line 19
void free_align(edit_script_list *aligns ) ;
#line 20
void seq_toupper(uchar *seq , int len , char *filename ) ;
#line 21
void complement_exons(Exon **left , int M___0 , int N___0 ) ;
#line 22
void print_exons(Exon *left ) ;
#line 23
void print_pipmaker_exons(Exon *exons , edit_script_list *aligns , char *gene , int from ,
                          int to , int M___0 , int N___0 , uchar *seq1___0 , uchar *seq2___0 ,
                          int match_ori ) ;
#line 24
void bld_table(uchar *s , int len , int in_W , int type ) ;
#line 25
struct edit_script_list *SIM4(uchar *in_seq1 , uchar *in_seq2 , int in_M , int in_N ,
                              int in_W , int in_X , int in_K , int in_C , int in_H ,
                              int *dist_ptr , int *pT , int *pA , Exon **Exons , sim4_stats_t *st ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/Xtend1.h"
int Xextend_bw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
               int *line1 , int *line2 ) ;
#line 6
int Xextend_fw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
               int *line1 , int *line2 ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.h"
void align_path(int i1 , int j1___0 , int i2 , int j2 , int dist , edit_script **head ,
                edit_script **tail ) ;
#line 5
int align_get_dist(int i1 , int j1___0 , int i2 , int j2 , int limit ) ;
#line 7
void Condense_both_Ends(edit_script **head , edit_script **tail , edit_script **prev ) ;
#line 11
void Free_script(edit_script *head ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.h"
void remove_poly(struct edit_script_list **Script , Exon *Exons , uchar *s1 , uchar *s2 ,
                 int len2 , int *pT , int *pA ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int numMSPs  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int K  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int W  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int X  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int G_score  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int C_score  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int *diag_lev  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static Msp_ptr msp_list  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static Msp_ptr *msp  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static Exon_ptr exon_list  ;
#line 46
static void merge(Exon **t0 , Exon **t1 ) ;
#line 47
static bool get_sync_flag(Exon *lblock , Exon *rblock , int w ) ;
#line 48
static void slide_intron(int in_w , Exon **lblock , uchar *seq1___0 , uchar *seq2___0 ) ;
#line 49
static void sync_slide_intron(int in_w , Exon **lblock , uchar *seq1___0 , uchar *seq2___0 ) ;
#line 50
static void wobble(Exon **t0 , Exon **t1 , char const   *donor , char const   *acceptor ,
                   uchar *seq1___0 ) ;
#line 51
static Exon *bmatch(uchar *s1 , uchar *s2 , int len1 , int len2 , int offset1___0 ,
                    int offset2___0 ) ;
#line 52
static Exon *fmatch(uchar *s1 , uchar *s2 , int len1 , int len2 , int offset1___0 ,
                    int offset2___0 ) ;
#line 53
static void compact_list(Exon **Lblock , Exon **Rblock ) ;
#line 54
static int resolve_overlap(Exon *tmp_block , Exon *tmp_block1 , uchar *seq1___0 ) ;
#line 55
static int greedy(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
                  Exon **lblock , Exon **rblock ) ;
#line 56
static int extend_bw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
                     int *line1 , int *line2 ) ;
#line 57
static int extend_fw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
                     int *line1 , int *line2 ) ;
#line 58
static void pluri_align(int *dist_ptr , int *num_matches , Exon *lblock , struct edit_script_list **Aligns ) ;
#line 59
static void get_stats(Exon *lblock , sim4_stats_t *st ) ;
#line 60
static int get_edist(int f1 , int f2 , int t1 , int t2 , uchar *seq1___0 , uchar *seq2___0 ) ;
#line 61
static int get_msp_threshold(int len1 , int len2 ) ;
#line 62
static int find_log_entry(long *log4s , int n , int len , int offset ) ;
#line 63
static Exon *new_exon(int f1 , int f2 , int t1 , int t2 , int len , int edist , int flag ,
                      Exon *next ) ;
#line 64
static void add_word(int ecode , int pos ) ;
#line 65
static void extend_hit(int pos1 , int pos2 , uchar const   * const  s1 , uchar const   * const  s2 ,
                       int len1 , int len2 , int in_W ) ;
#line 66
static void sort_msps(void) ;
#line 67
static void heapify(int i , int last ) ;
#line 68
static int smaller(int i , int j ) ;
#line 69
static void search(uchar *s1 , uchar *s2 , int len1 , int len2 , int in_W ) ;
#line 70
static int link_msps(Msp_ptr *msp___0 , int numMSPs___0 , int H , int flag ) ;
#line 71
static int scale(int n ) ;
#line 72
static void msp2exons(Msp_ptr *msp___0 , int last_msp , uchar *s1 , uchar *s2 ) ;
#line 73
static void free_msps(Msp_ptr **in_msp , int *in_numMSPs ) ;
#line 74
static void exon_cores(uchar *s1 , uchar *s2 , int len1 , int len2 , int offset1___0 ,
                       int offset2___0 , int flag , int in_W , int in_K , int type ) ;
#line 75
static void relink(Msp_ptr *in_msp , int in_numMSPs , int H , int offset1___0 , int offset2___0 ,
                   int flag , uchar *s1 , uchar *s2 ) ;
#line 76
static int dispatch_find_ends(int from , int to , int *From , int *To , edit_script_list *aligns ,
                              int M___0 , int N___0 , int match_ori ) ;
#line 77
static int find_ends(edit_script_list *head , int j0___0 ) ;
#line 78
static bool get_match_quality(Exon *lblock , Exon *rblock , sim4_stats_t *st , int N___0 ) ;
#line 79
static int check_consistency_intron_ori(Exon *exons , int match_ori , char *gene ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
struct edit_script_list *SIM4(uchar *in_seq1 , uchar *in_seq2 , int in_M , int in_N ,
                              int in_W , int in_X , int in_K , int in_C , int in_H ,
                              int *dist_ptr , int *pT , int *pA , Exon **Exons , sim4_stats_t *st ) 
{ 
  int cflag ;
  int diff ;
  int cost ;
  int rollbflag ;
  int sync_flag ;
  int u ;
  int v ;
  int I ;
  int J ;
  bool good_match ;
  Exon *Lblock ;
  Exon *Rblock ;
  Exon *tmp_block ;
  Exon *last ;
  Exon *prev ;
  Exon *tmp_block1 ;
  Exon *tmp_Lblock ;
  Exon *tmp_Rblock ;
  Exon *new ;
  struct edit_script_list *Script_head ;
  uchar tmp[50] ;
  coords *sig ;
  int tmp___0 ;
  int best_u ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int (*tmp___8)(uchar * , uchar * , int  , int  , int  , int  , int * , int * ) ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int (*tmp___14)(uchar * , uchar * , int  , int  , int  , int  , int * , int * ) ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___19 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  int tmp___27 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___33 ;
  char const   *tmp___35 ;
  int tmp___36 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  int tmp___41 ;
  char const   *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  void (*tmp___46)(int w , Exon ** , uchar * , uchar * ) ;
  int tmp___47 ;

  {
#line 106
  Rblock = (Exon *)((void *)0);
#line 106
  tmp_Lblock = (Exon *)((void *)0);
#line 106
  tmp_Rblock = (Exon *)((void *)0);
#line 109
  Script_head = (struct edit_script_list *)((void *)0);
#line 113
  seq1 = in_seq1;
#line 114
  seq2 = in_seq2;
#line 115
  M = in_M;
#line 116
  N = in_N;
#line 117
  W = in_W;
#line 118
  X = in_X;
#line 120
  if (M <= 0) {
#line 121
    *Exons = (Exon *)((void *)0);
#line 121
    return ((struct edit_script_list *)((void *)0));
  } else
#line 120
  if (in_N <= 0) {
#line 121
    *Exons = (Exon *)((void *)0);
#line 121
    return ((struct edit_script_list *)((void *)0));
  }
#line 124
  if (rs.acc_flag) {
#line 125
    last_AC.pos2 = 0;
#line 125
    last_AC.pos1 = last_AC.pos2;
#line 125
    last_AG.pos2 = last_AC.pos1;
#line 125
    last_AG.pos1 = last_AG.pos2;
#line 126
    last_CT.pos2 = 0;
#line 126
    last_CT.pos1 = last_CT.pos2;
#line 126
    last_GT.pos2 = last_CT.pos1;
#line 126
    last_GT.pos1 = last_GT.pos2;
  }
  {
#line 131
  *dist_ptr = 0;
#line 133
  exon_cores(seq1 - 1, seq2 - 1, M, N, 1, 1, 0, W, in_K, 1);
#line 135
  Lblock = exon_list;
#line 135
  tmp_block = Lblock;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! tmp_block) {
#line 136
      goto while_break;
    }
#line 137
    if ((unsigned long )tmp_block->next_exon == (unsigned long )((void *)0)) {
#line 138
      Rblock = tmp_block;
    }
#line 139
    tmp_block = tmp_block->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (Lblock) {
#line 142
    if (Lblock->from1 > 50000) {
#line 142
      if (Lblock->from2 > 100) {
#line 142
        goto _L;
      } else {
#line 142
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 142
    if (M - Rblock->to1 > 50000) {
#line 142
      if (N - Rblock->to2 > 100) {
        _L: /* CIL Label */ 
        {
#line 145
        free_list(exon_list);
        }
#line 146
        if (in_H > 0) {
#line 146
          tmp___0 = in_H;
        } else {
#line 146
          tmp___0 = 500;
        }
        {
#line 146
        relink(msp, numMSPs, tmp___0, 1, 1, 0, seq1, seq2);
#line 147
        Lblock = exon_list;
#line 147
        tmp_block = Lblock;
        }
        {
#line 148
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 148
          if (! tmp_block) {
#line 148
            goto while_break___0;
          }
#line 149
          if ((unsigned long )tmp_block->next_exon == (unsigned long )((void *)0)) {
#line 150
            Rblock = tmp_block;
          }
#line 151
          tmp_block = tmp_block->next_exon;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 154
  free_msps(& msp, & numMSPs);
#line 156
  Lblock = exon_list;
#line 156
  tmp_block = Lblock;
  }
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 157
    if (! tmp_block) {
#line 157
      goto while_break___1;
    }
#line 158
    if ((unsigned long )tmp_block->next_exon == (unsigned long )((void *)0)) {
#line 159
      Rblock = tmp_block;
    }
#line 160
    tmp_block = tmp_block->next_exon;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 165
  Lblock = new_exon(0, 0, 0, 0, 0, 0, 0, Lblock);
  }
#line 166
  if ((unsigned long )Rblock == (unsigned long )((void *)0)) {
#line 167
    Rblock = Lblock;
  }
  {
#line 168
  Rblock->next_exon = new_exon(M + 1, N + 1, 0, 0, 0, 0, 0, (Exon *)((void *)0));
#line 171
  good_match = get_match_quality(Lblock, Rblock, st, N);
#line 177
  tmp_block = Lblock;
  }
  {
#line 178
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 178
    tmp_block1 = tmp_block->next_exon;
#line 178
    if (! ((unsigned long )tmp_block1 != (unsigned long )((void *)0))) {
#line 178
      goto while_break___2;
    }
#line 179
    rollbflag = 0;
#line 180
    diff = (tmp_block1->from2 - tmp_block->to2) - 1;
#line 181
    if (diff) {
#line 182
      if (diff < 0) {
        {
#line 185
        best_u = resolve_overlap(tmp_block, tmp_block1, seq1);
#line 187
        tmp_block1->from1 += (best_u + 1) - tmp_block1->from2;
#line 188
        tmp_block1->from2 = best_u + 1;
#line 189
        u = (tmp_block1->to2 - tmp_block1->from2) + 1;
        }
#line 189
        if (u <= 0) {
          {
#line 192
          tmp_block->next_exon = tmp_block1->next_exon;
#line 193
          tmp_block->flag = tmp_block1->flag;
#line 194
          rollbflag = 1;
#line 195
          free((void *)tmp_block1);
#line 196
          tmp_block1 = (Exon *)((void *)0);
          }
        } else
#line 189
        if (u < 8) {
          {
#line 192
          tmp_block->next_exon = tmp_block1->next_exon;
#line 193
          tmp_block->flag = tmp_block1->flag;
#line 194
          rollbflag = 1;
#line 195
          free((void *)tmp_block1);
#line 196
          tmp_block1 = (Exon *)((void *)0);
          }
        } else {
#line 189
          v = (tmp_block1->to1 - tmp_block1->from1) + 1;
#line 189
          if (v <= 0) {
            {
#line 192
            tmp_block->next_exon = tmp_block1->next_exon;
#line 193
            tmp_block->flag = tmp_block1->flag;
#line 194
            rollbflag = 1;
#line 195
            free((void *)tmp_block1);
#line 196
            tmp_block1 = (Exon *)((void *)0);
            }
          } else
#line 189
          if (v < 8) {
            {
#line 192
            tmp_block->next_exon = tmp_block1->next_exon;
#line 193
            tmp_block->flag = tmp_block1->flag;
#line 194
            rollbflag = 1;
#line 195
            free((void *)tmp_block1);
#line 196
            tmp_block1 = (Exon *)((void *)0);
            }
          }
        }
#line 199
        tmp_block->to1 -= tmp_block->to2 - best_u;
#line 200
        tmp_block->to2 = best_u;
#line 201
        u = (tmp_block->to2 - tmp_block->from2) + 1;
#line 201
        if (u <= 0) {
#line 201
          goto _L___1;
        } else
#line 201
        if (u < 8) {
#line 201
          goto _L___1;
        } else {
#line 201
          v = (tmp_block->to1 - tmp_block->from1) + 1;
#line 201
          if (v <= 0) {
#line 201
            goto _L___1;
          } else
#line 201
          if (v < 8) {
            _L___1: /* CIL Label */ 
            {
#line 205
            prev = find_previous(Lblock, tmp_block);
            }
#line 206
            if (! ((unsigned long )prev != (unsigned long )((void *)0))) {
              {
#line 206
              __assert_fail("prev!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c",
                            206U, "SIM4");
              }
            }
#line 207
            prev->next_exon = tmp_block->next_exon;
#line 208
            prev->flag = tmp_block->flag;
#line 209
            if (u > 0) {
#line 209
              rollbflag = 1;
            }
            {
#line 210
            free((void *)tmp_block);
#line 211
            tmp_block = prev;
            }
          }
        }
#line 214
        if (tmp_block->to1) {
#line 215
          tmp_block->length = (tmp_block->to2 - tmp_block->from2) + 1;
        }
#line 216
        if (tmp_block1) {
#line 216
          if (tmp_block1->to1) {
#line 217
            tmp_block1->length = (tmp_block1->to2 - tmp_block1->from2) + 1;
          }
        }
      } else {
#line 221
        if (tmp_block1->to2) {
#line 221
          if (tmp_block->to2) {
#line 221
            cflag = 0;
          } else {
#line 221
            cflag = 1;
          }
        } else {
#line 221
          cflag = 1;
        }
#line 222
        if (diff) {
#line 222
          if ((tmp_block1->from1 - tmp_block->to1) - 1 > 0) {
#line 223
            if (! cflag) {
#line 224
              if (diff <= 500) {
                {
#line 225
                cost = greedy(seq2 + tmp_block->to2, seq1 + tmp_block->to1, diff,
                              (tmp_block1->from1 - tmp_block->to1) - 1, tmp_block->to2,
                              tmp_block->to1, & tmp_Lblock, & tmp_Rblock);
                }
              } else {
#line 231
                if (W < (int )(.2 * (double )diff + (double )1)) {
#line 231
                  tmp___1 = (int )(.2 * (double )diff + (double )1);
                } else {
#line 231
                  tmp___1 = W;
                }
#line 231
                cost = tmp___1 + 1;
              }
#line 233
              if (W < (int )(.2 * (double )diff + (double )1)) {
#line 233
                tmp___4 = (int )(.2 * (double )diff + (double )1);
              } else {
#line 233
                tmp___4 = W;
              }
#line 233
              if (cost > tmp___4) {
#line 234
                if (! tmp_block->flag) {
#line 234
                  if (! tmp_block1->flag) {
#line 235
                    if (8 > W) {
#line 235
                      tmp___2 = W;
                    } else {
#line 235
                      tmp___2 = 8;
                    }
                    {
#line 235
                    exon_cores((seq1 + tmp_block->to1) - 1, (seq2 + tmp_block->to2) - 1,
                               (tmp_block1->from1 - tmp_block->to1) - 1, diff, tmp_block->to1 + 1,
                               tmp_block->to2 + 1, 1, tmp___2, in_C, 2);
#line 246
                    tmp_Rblock = exon_list;
#line 246
                    tmp_Lblock = tmp_Rblock;
                    }
                    {
#line 247
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 247
                      if ((unsigned long )tmp_Rblock != (unsigned long )((void *)0)) {
#line 247
                        if (! ((unsigned long )tmp_Rblock->next_exon != (unsigned long )((void *)0))) {
#line 247
                          goto while_break___3;
                        }
                      } else {
#line 247
                        goto while_break___3;
                      }
#line 248
                      tmp_Rblock = tmp_Rblock->next_exon;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
#line 250
                    if (! tmp_Lblock) {
#line 250
                      if (tmp_block1->from1 - tmp_block->to1 > 50000) {
#line 250
                        goto _L___2;
                      } else {
#line 250
                        goto _L___5;
                      }
                    } else
                    _L___5: /* CIL Label */ 
#line 250
                    if (tmp_Lblock) {
#line 250
                      if (tmp_Lblock->from2 - tmp_block->to2 > 100) {
#line 250
                        if (tmp_Lblock->from1 - tmp_block->from1 > 50000) {
#line 250
                          goto _L___2;
                        } else {
#line 250
                          goto _L___4;
                        }
                      } else {
#line 250
                        goto _L___4;
                      }
                    } else
                    _L___4: /* CIL Label */ 
#line 250
                    if (tmp_Lblock) {
#line 250
                      if (tmp_block1->from2 - tmp_Rblock->to2 > 100) {
#line 250
                        if (tmp_block1->from1 - tmp_Rblock->from1 > 50000) {
                          _L___2: /* CIL Label */ 
                          {
#line 256
                          free_list(tmp_Lblock);
                          }
#line 257
                          if (in_H > 0) {
#line 257
                            tmp___3 = in_H;
                          } else {
#line 257
                            tmp___3 = 500;
                          }
                          {
#line 257
                          relink(msp, numMSPs, tmp___3, tmp_block->to1 + 1, tmp_block->to2 + 1,
                                 1, seq1, seq2);
#line 262
                          tmp_Rblock = exon_list;
#line 262
                          tmp_Lblock = tmp_Rblock;
                          }
                          {
#line 263
                          while (1) {
                            while_continue___4: /* CIL Label */ ;
#line 263
                            if ((unsigned long )tmp_Rblock != (unsigned long )((void *)0)) {
#line 263
                              if (! ((unsigned long )tmp_Rblock->next_exon != (unsigned long )((void *)0))) {
#line 263
                                goto while_break___4;
                              }
                            } else {
#line 263
                              goto while_break___4;
                            }
#line 264
                            tmp_Rblock = tmp_Rblock->next_exon;
                          }
                          while_break___4: /* CIL Label */ ;
                          }
                        }
                      }
                    }
                    {
#line 266
                    free_msps(& msp, & numMSPs);
                    }
#line 268
                    if (tmp_Lblock) {
#line 268
                      rollbflag = 1;
                    } else {
#line 269
                      rollbflag = 0;
                    }
                  } else {
#line 271
                    tmp_Rblock = (Exon *)((void *)0);
#line 271
                    tmp_Lblock = tmp_Rblock;
                  }
                } else {
#line 271
                  tmp_Rblock = (Exon *)((void *)0);
#line 271
                  tmp_Lblock = tmp_Rblock;
                }
              }
            } else
#line 273
            if (tmp_block1->to1) {
#line 275
              if (rs.acc_flag) {
#line 276
                v = tmp_block1->from1 - 1;
                {
#line 276
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 276
                  if (! (v <= tmp_block1->to1 - 3)) {
#line 276
                    goto while_break___5;
                  }
                  {
#line 277
                  tmp___5 = strncmp((char const   *)((char *)((seq1 + v) - 2)), "AG",
                                    (size_t )2);
                  }
#line 277
                  if (! tmp___5) {
#line 278
                    last_AG.pos1 = v + 1;
#line 279
                    last_AG.pos2 = (tmp_block1->from2 + (v - tmp_block1->from1)) + 1;
#line 281
                    goto while_break___5;
                  }
#line 276
                  v ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 283
                v = tmp_block1->from1 - 1;
                {
#line 283
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 283
                  if (! (v <= tmp_block1->to1 - 3)) {
#line 283
                    goto while_break___6;
                  }
                  {
#line 284
                  tmp___6 = strncmp((char const   *)((char *)((seq1 + v) - 2)), "AC",
                                    (size_t )2);
                  }
#line 284
                  if (! tmp___6) {
#line 285
                    last_AC.pos1 = v + 1;
#line 286
                    last_AC.pos2 = (tmp_block1->from2 + (v - tmp_block1->from1)) + 1;
#line 288
                    goto while_break___6;
                  }
#line 283
                  v ++;
                }
                while_break___6: /* CIL Label */ ;
                }
              }
#line 292
              if (diff > 250) {
#line 292
                tmp___7 = 250;
              } else {
#line 292
                tmp___7 = diff;
              }
#line 292
              diff = tmp___7;
#line 293
              if (4 * diff > (tmp_block1->from1 - tmp_block->to1) - 1) {
#line 293
                u = (tmp_block1->from1 - tmp_block->to1) - 1;
              } else {
#line 293
                u = 4 * diff;
              }
#line 294
              if (rs.acc_flag) {
#line 294
                tmp___8 = & Xextend_bw;
              } else {
#line 294
                tmp___8 = & extend_bw;
              }
              {
#line 294
              cost = (*tmp___8)(((seq2 + tmp_block->to2) + ((tmp_block1->from2 - tmp_block->to2) - 1)) - diff,
                                ((seq1 + tmp_block->to1) + ((tmp_block1->from1 - tmp_block->to1) - 1)) - u,
                                diff, u, (tmp_block->to2 + ((tmp_block1->from2 - tmp_block->to2) - 1)) - diff,
                                (tmp_block->to1 + ((tmp_block1->from1 - tmp_block->to1) - 1)) - u,
                                & I, & J);
              }
#line 304
              if (good_match == 0) {
#line 305
                tmp_block1->from2 = I + 1;
#line 306
                tmp_block1->from1 = J + 1;
#line 307
                tmp_block1->edist += cost;
#line 308
                tmp_block1->length = (tmp_block1->to2 - tmp_block1->from2) + 1;
              } else
#line 304
              if (tmp_block->flag) {
#line 305
                tmp_block1->from2 = I + 1;
#line 306
                tmp_block1->from1 = J + 1;
#line 307
                tmp_block1->edist += cost;
#line 308
                tmp_block1->length = (tmp_block1->to2 - tmp_block1->from2) + 1;
              } else
#line 304
              if (J == 0) {
#line 305
                tmp_block1->from2 = I + 1;
#line 306
                tmp_block1->from1 = J + 1;
#line 307
                tmp_block1->edist += cost;
#line 308
                tmp_block1->length = (tmp_block1->to2 - tmp_block1->from2) + 1;
              } else
#line 304
              if (I == 0) {
#line 305
                tmp_block1->from2 = I + 1;
#line 306
                tmp_block1->from1 = J + 1;
#line 307
                tmp_block1->edist += cost;
#line 308
                tmp_block1->length = (tmp_block1->to2 - tmp_block1->from2) + 1;
              }
#line 312
              diff = (tmp_block1->from2 - tmp_block->to2) - 1;
#line 312
              if (diff) {
#line 312
                if (tmp_block->flag) {
#line 315
                  tmp_Lblock = (Exon *)((void *)0);
#line 315
                  tmp_Rblock = tmp_Lblock;
                } else {
#line 317
                  if (10 > W) {
#line 317
                    tmp___9 = W;
                  } else {
#line 317
                    tmp___9 = 10;
                  }
                  {
#line 317
                  exon_cores((seq1 + tmp_block->to1) - 1, (seq2 + tmp_block->to2) - 1,
                             (tmp_block1->from1 - tmp_block->to1) - 1, diff, tmp_block->to1 + 1,
                             tmp_block->to2 + 1, 1, tmp___9, in_C, 2);
#line 328
                  tmp_block->flag = 1;
#line 329
                  tmp_Rblock = exon_list;
#line 329
                  tmp_Lblock = tmp_Rblock;
                  }
                  {
#line 330
                  while (1) {
                    while_continue___7: /* CIL Label */ ;
#line 330
                    if (tmp_Rblock) {
#line 330
                      if (! tmp_Rblock->next_exon) {
#line 330
                        goto while_break___7;
                      }
                    } else {
#line 330
                      goto while_break___7;
                    }
#line 331
                    tmp_Rblock = tmp_Rblock->next_exon;
                  }
                  while_break___7: /* CIL Label */ ;
                  }
#line 333
                  if (! tmp_Lblock) {
#line 333
                    if (tmp_block1->from1 - tmp_block->to1 > 50000) {
#line 333
                      goto _L___6;
                    } else {
#line 333
                      goto _L___9;
                    }
                  } else
                  _L___9: /* CIL Label */ 
#line 333
                  if (tmp_Lblock) {
#line 333
                    if (tmp_Lblock->from2 - tmp_block->to2 > 100) {
#line 333
                      if (tmp_Lblock->from1 - tmp_block->from1 > 50000) {
#line 333
                        goto _L___6;
                      } else {
#line 333
                        goto _L___8;
                      }
                    } else {
#line 333
                      goto _L___8;
                    }
                  } else
                  _L___8: /* CIL Label */ 
#line 333
                  if (tmp_Lblock) {
#line 333
                    if (tmp_block1->from2 - tmp_Rblock->to2 > 100) {
#line 333
                      if (tmp_block1->from1 - tmp_Rblock->from1 > 50000) {
                        _L___6: /* CIL Label */ 
                        {
#line 339
                        free_list(tmp_Lblock);
                        }
#line 340
                        if (in_H > 0) {
#line 340
                          tmp___10 = in_H;
                        } else {
#line 340
                          tmp___10 = 500;
                        }
                        {
#line 340
                        relink(msp, numMSPs, tmp___10, tmp_block->to1 + 1, tmp_block->to2 + 1,
                               1, seq1, seq2);
#line 345
                        tmp_Rblock = exon_list;
#line 345
                        tmp_Lblock = tmp_Rblock;
                        }
                        {
#line 346
                        while (1) {
                          while_continue___8: /* CIL Label */ ;
#line 346
                          if ((unsigned long )tmp_Rblock != (unsigned long )((void *)0)) {
#line 346
                            if (! ((unsigned long )tmp_Rblock->next_exon != (unsigned long )((void *)0))) {
#line 346
                              goto while_break___8;
                            }
                          } else {
#line 346
                            goto while_break___8;
                          }
#line 347
                          tmp_Rblock = tmp_Rblock->next_exon;
                        }
                        while_break___8: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                  {
#line 349
                  free_msps(& msp, & numMSPs);
                  }
#line 351
                  if (tmp_Lblock) {
#line 351
                    rollbflag = 1;
                  } else {
#line 353
                    tmp_block1->from2 = I + 1;
#line 354
                    tmp_block1->from1 = J + 1;
#line 355
                    tmp_block1->edist += cost;
#line 356
                    tmp_block1->length = (tmp_block1->to2 - tmp_block1->from2) + 1;
                  }
                }
              } else {
#line 315
                tmp_Lblock = (Exon *)((void *)0);
#line 315
                tmp_Rblock = tmp_Lblock;
              }
            } else {
#line 361
              if (rs.acc_flag) {
#line 362
                v = tmp_block->to1;
                {
#line 362
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 362
                  if (! (v >= tmp_block->from1)) {
#line 362
                    goto while_break___9;
                  }
                  {
#line 363
                  tmp___11 = strncmp((char const   *)((char *)(seq1 + v)), "GT", (size_t )2);
                  }
#line 363
                  if (! tmp___11) {
#line 364
                    last_GT.pos1 = v;
#line 365
                    last_GT.pos2 = tmp_block->to2 - (tmp_block->to1 - v);
#line 366
                    goto while_break___9;
                  }
#line 362
                  v --;
                }
                while_break___9: /* CIL Label */ ;
                }
#line 368
                v = tmp_block->to1;
                {
#line 368
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 368
                  if (! (v >= tmp_block->from1)) {
#line 368
                    goto while_break___10;
                  }
                  {
#line 369
                  tmp___12 = strncmp((char const   *)((char *)(seq1 + v)), "CT", (size_t )2);
                  }
#line 369
                  if (! tmp___12) {
#line 370
                    last_CT.pos1 = v;
#line 371
                    last_CT.pos2 = tmp_block->to2 - (tmp_block->to1 - v);
#line 372
                    goto while_break___10;
                  }
#line 368
                  v --;
                }
                while_break___10: /* CIL Label */ ;
                }
              }
#line 376
              if (diff > 250) {
#line 376
                tmp___13 = 250;
              } else {
#line 376
                tmp___13 = diff;
              }
#line 376
              diff = tmp___13;
#line 377
              if (rs.acc_flag) {
#line 377
                tmp___14 = & Xextend_fw;
              } else {
#line 377
                tmp___14 = & extend_fw;
              }
#line 377
              if (4 * diff > (tmp_block1->from1 - tmp_block->to1) - 1) {
#line 377
                tmp___15 = (tmp_block1->from1 - tmp_block->to1) - 1;
              } else {
#line 377
                tmp___15 = 4 * diff;
              }
              {
#line 377
              cost = (*tmp___14)(seq2 + tmp_block->to2, seq1 + tmp_block->to1, diff,
                                 tmp___15, tmp_block->to2, tmp_block->to1, & I, & J);
              }
#line 383
              if (good_match == 0) {
#line 383
                goto _L___10;
              } else
#line 383
              if (tmp_block1->flag) {
#line 383
                goto _L___10;
              } else
#line 383
              if (I == M) {
#line 383
                goto _L___10;
              } else
#line 383
              if (J == N) {
                _L___10: /* CIL Label */ 
#line 384
                if (tmp_block->to1) {
#line 385
                  tmp_block->to2 = I;
#line 386
                  tmp_block->to1 = J;
#line 387
                  tmp_block->edist += cost;
#line 388
                  tmp_block->length = (tmp_block->to2 - tmp_block->from2) + 1;
#line 389
                  tmp_Lblock = (Exon *)((void *)0);
#line 389
                  tmp_Rblock = tmp_Lblock;
                } else {
#line 392
                  tmp_Rblock = (Exon *)((void *)0);
#line 392
                  tmp_Lblock = tmp_Rblock;
                }
              }
#line 395
              diff = (tmp_block1->from2 - tmp_block->to2) - 1;
#line 395
              if (diff) {
#line 395
                if (tmp_block1->flag) {
#line 398
                  tmp_Lblock = (Exon *)((void *)0);
#line 398
                  tmp_Rblock = tmp_Lblock;
                } else {
#line 400
                  if (10 > W) {
#line 400
                    tmp___16 = W;
                  } else {
#line 400
                    tmp___16 = 10;
                  }
                  {
#line 400
                  exon_cores((seq1 + tmp_block->to1) - 1, (seq2 + tmp_block->to2) - 1,
                             (tmp_block1->from1 - tmp_block->to1) - 1, diff, tmp_block->to1 + 1,
                             tmp_block->to2 + 1, 1, tmp___16, in_C, 2);
#line 411
                  tmp_Rblock = exon_list;
#line 411
                  tmp_Lblock = tmp_Rblock;
                  }
                  {
#line 412
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 412
                    if (tmp_Rblock) {
#line 412
                      if (! tmp_Rblock->next_exon) {
#line 412
                        goto while_break___11;
                      }
                    } else {
#line 412
                      goto while_break___11;
                    }
#line 413
                    tmp_Rblock = tmp_Rblock->next_exon;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
#line 415
                  if (! tmp_Lblock) {
#line 415
                    if (tmp_block1->from1 - tmp_block->to1 > 50000) {
#line 415
                      goto _L___11;
                    } else {
#line 415
                      goto _L___14;
                    }
                  } else
                  _L___14: /* CIL Label */ 
#line 415
                  if (tmp_Lblock) {
#line 415
                    if (tmp_Lblock->from2 - tmp_block->to2 > 100) {
#line 415
                      if (tmp_Lblock->from1 - tmp_block->from1 > 50000) {
#line 415
                        goto _L___11;
                      } else {
#line 415
                        goto _L___13;
                      }
                    } else {
#line 415
                      goto _L___13;
                    }
                  } else
                  _L___13: /* CIL Label */ 
#line 415
                  if (tmp_Lblock) {
#line 415
                    if (tmp_block1->from2 - tmp_Rblock->to2 > 100) {
#line 415
                      if (tmp_block1->from1 - tmp_Rblock->from1 > 50000) {
                        _L___11: /* CIL Label */ 
                        {
#line 421
                        free_list(tmp_Lblock);
                        }
#line 422
                        if (in_H > 0) {
#line 422
                          tmp___17 = in_H;
                        } else {
#line 422
                          tmp___17 = 500;
                        }
                        {
#line 422
                        relink(msp, numMSPs, tmp___17, tmp_block->to1 + 1, tmp_block->to2 + 1,
                               1, seq1, seq2);
#line 427
                        tmp_Rblock = exon_list;
#line 427
                        tmp_Lblock = tmp_Rblock;
                        }
                        {
#line 428
                        while (1) {
                          while_continue___12: /* CIL Label */ ;
#line 428
                          if ((unsigned long )tmp_Rblock != (unsigned long )((void *)0)) {
#line 428
                            if (! ((unsigned long )tmp_Rblock->next_exon != (unsigned long )((void *)0))) {
#line 428
                              goto while_break___12;
                            }
                          } else {
#line 428
                            goto while_break___12;
                          }
#line 429
                          tmp_Rblock = tmp_Rblock->next_exon;
                        }
                        while_break___12: /* CIL Label */ ;
                        }
                      }
                    }
                  }
                  {
#line 431
                  free_msps(& msp, & numMSPs);
#line 433
                  tmp_block1->flag = 1;
                  }
#line 434
                  if (tmp_Lblock) {
#line 434
                    rollbflag = 1;
                  } else
#line 436
                  if (tmp_block->to1) {
#line 437
                    tmp_block->to2 = I;
#line 438
                    tmp_block->to1 = J;
#line 439
                    tmp_block->edist += cost;
#line 440
                    tmp_block->length = (tmp_block->to2 - tmp_block->from2) + 1;
#line 441
                    tmp_Lblock = (Exon *)((void *)0);
#line 441
                    tmp_Rblock = tmp_Lblock;
                  } else {
#line 444
                    tmp_Rblock = (Exon *)((void *)0);
#line 444
                    tmp_Lblock = tmp_Rblock;
                  }
                }
              } else {
#line 398
                tmp_Lblock = (Exon *)((void *)0);
#line 398
                tmp_Rblock = tmp_Lblock;
              }
            }
          } else {
#line 222
            goto _L___15;
          }
        } else
        _L___15: /* CIL Label */ 
#line 448
        if (diff) {
#line 449
          tmp_Lblock = (Exon *)((void *)0);
#line 449
          tmp_Rblock = tmp_Lblock;
        }
#line 456
        if (tmp_Lblock) {
          {
#line 457
          tmp_block->next_exon = tmp_Lblock;
#line 458
          tmp_Rblock->next_exon = tmp_block1;
#line 459
          merge(& tmp_block, & tmp_block1);
          }
        }
      }
    }
#line 463
    if (! rollbflag) {
#line 463
      tmp_block = tmp_block1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 474
  compact_list(& Lblock->next_exon, & Rblock);
#line 484
  tmp_block = Lblock->next_exon;
  }
  {
#line 486
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 486
    if ((unsigned long )tmp_block != (unsigned long )((void *)0)) {
#line 486
      if (tmp_block->length < W) {
#line 486
        if (! tmp_block->to1) {
#line 486
          goto while_break___13;
        }
      } else {
#line 486
        goto while_break___13;
      }
    } else {
#line 486
      goto while_break___13;
    }
    {
#line 487
    tmp_block1 = tmp_block;
#line 488
    tmp_block = tmp_block->next_exon;
#line 489
    free((void *)tmp_block1);
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 491
  Lblock->next_exon = tmp_block;
#line 495
  last = Lblock->next_exon;
#line 496
  tmp_block = last;
  {
#line 497
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 497
    if (! ((unsigned long )tmp_block != (unsigned long )((void *)0))) {
#line 497
      goto while_break___14;
    }
#line 498
    if (tmp_block->length >= W) {
#line 499
      last = tmp_block;
    }
#line 500
    tmp_block = tmp_block->next_exon;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 502
  if (last) {
#line 502
    if (last->to1) {
#line 503
      last->next_exon = Rblock->next_exon;
    }
  }
#line 504
  Rblock = last;
#line 507
  if (rs.acc_flag) {
#line 508
    tmp_block = Lblock->next_exon;
#line 511
    if (tmp_block) {
#line 511
      if (tmp_block->to1) {
        {
#line 511
        tmp___30 = abs(C_score);
        }
#line 511
        if (G_score >= tmp___30) {
#line 511
          tmp___29 = "AG";
        } else {
#line 511
          tmp___29 = "AC";
        }
        {
#line 511
        tmp___31 = strncmp((char const   *)((char *)((seq1 + tmp_block->from1) - 3)),
                           tmp___29, (size_t )2);
        }
#line 511
        if (tmp___31) {
#line 511
          goto _L___16;
        } else
#line 511
        if (tmp_block->from2 != 1) {
          _L___16: /* CIL Label */ 
          {
#line 514
          tmp___19 = abs(C_score);
          }
#line 514
          if (G_score >= tmp___19) {
#line 514
            sig = & last_AG;
          } else {
#line 514
            sig = & last_AC;
          }
#line 515
          if (sig->pos1) {
#line 515
            if (sig->pos2 <= 20) {
#line 517
              if (! (sig->pos2 > 1)) {
                {
#line 517
                __assert_fail("sig->pos2 > 1", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c",
                              517U, "SIM4");
                }
              }
              {
#line 518
              tmp___22 = abs(C_score);
              }
#line 518
              if (G_score >= tmp___22) {
#line 518
                tmp___21 = "AG";
              } else {
#line 518
                tmp___21 = "AC";
              }
              {
#line 518
              strcpy((char */* __restrict  */)((char *)(tmp)), (char const   */* __restrict  */)tmp___21);
#line 519
              strncpy((char */* __restrict  */)((char *)(tmp + 2)), (char const   */* __restrict  */)((char *)seq2),
                      (size_t )sig->pos2 - 1UL);
#line 520
              tmp___25 = abs(C_score);
              }
#line 520
              if (G_score >= tmp___25) {
#line 520
                tmp___24 = "GT";
              } else {
#line 520
                tmp___24 = "CT";
              }
              {
#line 520
              strcpy((char */* __restrict  */)((char *)((tmp + sig->pos2) + 1)), (char const   */* __restrict  */)tmp___24);
#line 521
              new = bmatch(seq1, tmp, tmp_block->from1 - 3, sig->pos2 + 3, 1, 1);
              }
#line 522
              if (new) {
                {
#line 523
                (Lblock->next_exon)->from1 = sig->pos1;
#line 524
                (Lblock->next_exon)->from2 = sig->pos2;
#line 525
                (Lblock->next_exon)->length -= sig->pos2 - 1;
#line 526
                new->next_exon = Lblock->next_exon;
#line 527
                tmp___27 = abs(C_score);
                }
#line 527
                if (G_score >= tmp___27) {
#line 527
                  new->ori = (char )'G';
                } else {
#line 527
                  new->ori = (char )'C';
                }
#line 528
                Lblock->next_exon = new;
              }
            }
          }
        }
      }
    }
    {
#line 532
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 532
      if (tmp_block) {
#line 532
        if (tmp_block->next_exon) {
#line 532
          if (! (tmp_block->next_exon)->to1) {
#line 532
            goto while_break___15;
          }
        } else {
#line 532
          goto while_break___15;
        }
      } else {
#line 532
        goto while_break___15;
      }
#line 533
      tmp_block = tmp_block->next_exon;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 534
    if (tmp_block) {
#line 534
      if (tmp_block->to1) {
        {
#line 534
        tmp___44 = abs(C_score);
        }
#line 534
        if (G_score >= tmp___44) {
#line 534
          tmp___43 = "GT";
        } else {
#line 534
          tmp___43 = "CT";
        }
        {
#line 534
        tmp___45 = strncmp((char const   *)((char *)(seq1 + tmp_block->to1)), tmp___43,
                           (size_t )2);
        }
#line 534
        if (tmp___45) {
#line 534
          goto _L___17;
        } else
#line 534
        if (tmp_block->to2 != N) {
          _L___17: /* CIL Label */ 
          {
#line 536
          tmp___33 = abs(C_score);
          }
#line 536
          if (G_score >= tmp___33) {
#line 536
            sig = & last_GT;
          } else {
#line 536
            sig = & last_CT;
          }
#line 537
          if (sig->pos1) {
#line 537
            if (N - sig->pos2 <= 20) {
#line 538
              if (! (N - sig->pos2 >= 0)) {
                {
#line 538
                __assert_fail("N-sig->pos2 >= 0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c",
                              538U, "SIM4");
                }
              }
              {
#line 539
              tmp___36 = abs(C_score);
              }
#line 539
              if (G_score >= tmp___36) {
#line 539
                tmp___35 = "AG";
              } else {
#line 539
                tmp___35 = "AC";
              }
              {
#line 539
              strcpy((char */* __restrict  */)((char *)(tmp)), (char const   */* __restrict  */)tmp___35);
#line 540
              strncpy((char */* __restrict  */)((char *)(tmp + 2)), (char const   */* __restrict  */)((char *)(seq2 + sig->pos2)),
                      (size_t )N - (size_t )sig->pos2);
#line 542
              tmp___39 = abs(C_score);
              }
#line 542
              if (G_score >= tmp___39) {
#line 542
                tmp___38 = "GT";
              } else {
#line 542
                tmp___38 = "CT";
              }
              {
#line 542
              strcpy((char */* __restrict  */)((char *)(((tmp + N) - sig->pos2) + 2)),
                     (char const   */* __restrict  */)tmp___38);
#line 543
              new = fmatch((seq1 + sig->pos1) - 1, tmp, (M - sig->pos1) + 1, (N - sig->pos2) + 4,
                           sig->pos1 - 1, sig->pos2 + 1);
              }
#line 546
              if (new) {
                {
#line 547
                tmp_block->to1 = sig->pos1;
#line 548
                tmp_block->to2 = sig->pos2;
#line 549
                new->next_exon = tmp_block->next_exon;
#line 550
                tmp_block->next_exon = new;
#line 551
                tmp___41 = abs(C_score);
                }
#line 551
                if (G_score >= tmp___41) {
#line 551
                  tmp_block->ori = (char )'G';
                } else {
#line 551
                  tmp_block->ori = (char )'C';
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 558
  sync_flag = get_sync_flag(Lblock, Rblock, 6);
  }
#line 559
  if (sync_flag == 1) {
#line 559
    tmp___46 = & sync_slide_intron;
  } else {
#line 559
    tmp___46 = & slide_intron;
  }
  {
#line 559
  (*tmp___46)(6, & Lblock, seq1, seq2);
#line 562
  flip_list(& Lblock, & Rblock);
#line 563
  pluri_align(dist_ptr, & st->nmatches, Lblock, & Script_head);
#line 564
  flip_list(& Lblock, & Rblock);
  }
#line 566
  if (rs.poly_flag) {
    {
#line 567
    remove_poly(& Script_head, Lblock, seq1, seq2, N, pT, pA);
    }
  } else {
#line 569
    tmp___47 = 0;
#line 569
    *pA = tmp___47;
#line 569
    *pT = tmp___47;
  }
  {
#line 571
  get_stats(Lblock, st);
#line 573
  *Exons = Lblock->next_exon;
#line 574
  free((void *)Lblock);
  }
#line 575
  if (! rs.ali_flag) {
    {
#line 576
    free_align(Script_head);
    }
#line 577
    return ((struct edit_script_list *)((void *)0));
  } else {
#line 579
    return (Script_head);
  }
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static struct hash_node *phashtab[32768]  ;
#line 595 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static struct hash_node **hashtab  ;
#line 596 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int mask  ;
#line 597 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int *next_pos  ;
#line 597 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int *pnext_pos  ;
#line 610 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static long genomic_log4s[45]  = 
#line 610
  {      1L,      2L,      3L,      5L, 
        9L,      15L,      26L,      42L, 
        70L,      114L,      188L,      309L, 
        507L,      832L,      1365L,      1365L, 
        2240L,      2240L,      3675L,      6029L, 
        9892L,      16231L,      26629L,      43690L, 
        71681L,      117606L,      192953L,      316573L, 
        519392L,      852152L,      1398101L,      2293823L, 
        3763409L,      6174516L,      10130347L,      16620564L, 
        27268873L,      44739242L,      73402365L,      120429110L, 
        197584514L,      324171126L,      531858072L,      872603963L, 
        1431655765L};
#line 618 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static long cDNA_log4s[25]  = 
#line 618
  {      1L,      1L,      2L,      4L, 
        7L,      11L,      19L,      32L, 
        52L,      86L,      141L,      231L, 
        380L,      624L,      1024L,      1680L, 
        2756L,      4522L,      7419L,      12173L, 
        19972L,      32768L,      53761L,      88204L, 
        144715L};
#line 624 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int get_msp_threshold(int len1 , int len2 ) 
{ 
  int i ;
  int j ;

  {
  {
#line 628
  i = find_log_entry(genomic_log4s, 45, len1, 0);
#line 629
  j = find_log_entry(cDNA_log4s, 25, len2, 0);
  }
#line 631
  if (! (i % 2)) {
#line 631
    return (i / 2 + j / 2);
  } else
#line 632
  if (! (j % 2)) {
#line 632
    return (i / 2 + j / 2);
  } else {
#line 633
    return ((i / 2 + j / 2) + 1);
  }
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int find_log_entry(long *log4s , int n , int len , int offset ) 
{ 
  int a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 640
  a = n / 2;
#line 641
  if ((long )len < *(log4s + a)) {
#line 641
    if (! a) {
#line 641
      goto _L___2;
    } else
#line 641
    if ((long )len >= *(log4s + (a - 1))) {
      _L___2: /* CIL Label */ 
#line 642
      if (0 < a - 1) {
#line 642
        tmp = a - 1;
      } else {
#line 642
        tmp = 0;
      }
#line 642
      return (tmp + offset);
    } else {
#line 641
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 643
  if ((long )len >= *(log4s + a)) {
#line 643
    if (a == n - 1) {
#line 643
      goto _L___0;
    } else
#line 643
    if ((long )len < *(log4s + (a + 1))) {
      _L___0: /* CIL Label */ 
#line 644
      if (n - 1 > a + 1) {
#line 644
        tmp___0 = a + 1;
      } else {
#line 644
        tmp___0 = n - 1;
      }
#line 644
      return (tmp___0 + offset);
    } else {
#line 643
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 645
  if ((long )len < *(log4s + a)) {
    {
#line 646
    tmp___1 = find_log_entry(log4s, a - 1, len, offset);
    }
#line 646
    return (tmp___1);
  } else
#line 647
  if ((long )len > *(log4s + a)) {
    {
#line 648
    tmp___2 = find_log_entry((log4s + a) + 1, (n - a) - 1, len, (offset + a) + 1);
    }
#line 648
    return (tmp___2);
  }
#line 649
  return (-1);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void exon_cores(uchar *s1 , uchar *s2 , int len1 , int len2 , int offset1___0 ,
                       int offset2___0 , int flag , int in_W , int in_K , int type ) 
{ 
  int i ;
  int W___0 ;
  int last_msp ;
  int lower ;
  int upper ;
  int *allocated ;
  Exon *tmp_block ;
  void *tmp ;
  uchar *aux ;
  int auxi ;
  register int auxi___0 ;
  uchar *aux___0 ;
  Msp_ptr mp ;
  register struct hash_node *hptr ;
  register struct hash_node *tptr ;
  register int hval ;
  void *tmp___0 ;
  Msp_ptr mp___0 ;

  {
#line 661
  if (in_K <= 0) {
    {
#line 667
    K = get_msp_threshold(len1, len2);
    }
#line 668
    if (K >= 0) {
#line 668
      K --;
    }
  } else {
#line 673
    K = in_K;
  }
  {
#line 675
  numMSPs = 0;
#line 676
  exon_list = (Exon_ptr )((void *)0);
#line 678
  tmp = ckalloc((unsigned long )((len1 + len2) + 1) * sizeof(int ));
#line 678
  allocated = (int *)tmp;
  }
#line 679
  if (file_type == 1) {
#line 679
    lower = - len1;
  } else
#line 679
  if (file_type == 2) {
#line 679
    if (type == 2) {
#line 679
      lower = - len1;
    } else {
#line 679
      lower = - len2;
    }
  } else {
#line 679
    lower = - len2;
  }
#line 681
  if (file_type == 1) {
#line 681
    upper = len2;
  } else
#line 681
  if (file_type == 2) {
#line 681
    if (type == 2) {
#line 681
      upper = len2;
    } else {
#line 681
      upper = len1;
    }
  } else {
#line 681
    upper = len1;
  }
#line 683
  diag_lev = allocated - lower;
#line 684
  i = lower;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i <= upper)) {
#line 684
      goto while_break;
    }
#line 684
    *(diag_lev + i) = 0;
#line 684
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (in_W > len2) {
#line 686
    W___0 = len2;
  } else {
#line 686
    W___0 = in_W;
  }
  {
#line 688
  if (file_type == 1) {
#line 688
    goto case_1;
  }
#line 692
  if (file_type == 2) {
#line 692
    goto case_2;
  }
#line 718
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 688
  bld_table(s2, len2, W___0, type);
#line 690
  search(s1, s2, len1, len2, W___0);
  }
#line 691
  goto switch_break;
  case_2: /* CIL Label */ 
#line 692
  if (type != 2) {
#line 695
    aux = s1;
#line 695
    s1 = s2;
#line 695
    s2 = aux;
#line 696
    auxi = len1;
#line 696
    len1 = len2;
#line 696
    len2 = auxi;
  }
  {
#line 698
  bld_table(s2, len2, W___0, type);
#line 700
  search(s1, s2, len1, len2, W___0);
  }
#line 701
  if (type != 2) {
#line 707
    aux___0 = s1;
#line 707
    s1 = s2;
#line 707
    s2 = aux___0;
#line 708
    auxi___0 = len1;
#line 708
    len1 = len2;
#line 708
    len2 = auxi___0;
#line 710
    mp = msp_list;
#line 710
    i = 0;
    {
#line 710
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 710
      if (! (i < numMSPs)) {
#line 710
        goto while_break___0;
      }
#line 711
      auxi___0 = mp->pos1;
#line 712
      mp->pos1 = mp->pos2;
#line 713
      mp->pos2 = auxi___0;
#line 714
      mp = mp->next_msp;
#line 710
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 717
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 718
  fatal("sim4b1.c: Invalid file type code.");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 721
  free((void *)allocated);
  }
#line 722
  if (type == 2) {
    {
#line 726
    free((void *)next_pos);
#line 727
    hval = 0;
    }
    {
#line 727
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 727
      if (! (hval < 32768)) {
#line 727
        goto while_break___1;
      }
#line 728
      hptr = *(hashtab + hval);
      {
#line 729
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 729
        if (! hptr) {
#line 729
          goto while_break___2;
        }
        {
#line 730
        tptr = hptr;
#line 731
        hptr = hptr->link;
#line 732
        free((void *)tptr);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 727
      hval ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 735
    free((void *)hashtab);
    }
  }
  {
#line 738
  tmp___0 = ckalloc((unsigned long )numMSPs * sizeof(Msp_ptr ));
#line 738
  msp = (Msp_ptr *)tmp___0;
#line 739
  mp___0 = msp_list;
#line 740
  i = 0;
  }
  {
#line 740
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 740
    if (! (i < numMSPs)) {
#line 740
      goto while_break___3;
    }
#line 741
    *(msp + i) = mp___0;
#line 742
    mp___0 = mp___0->next_msp;
#line 740
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 746
  sort_msps();
#line 749
  last_msp = link_msps(msp, numMSPs, 100, 0);
#line 756
  msp2exons(msp, last_msp, s1, s2);
#line 765
  tmp_block = exon_list;
  }
  {
#line 766
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 766
    if (! ((unsigned long )tmp_block != (unsigned long )((void *)0))) {
#line 766
      goto while_break___4;
    }
#line 767
    tmp_block->length = (tmp_block->to2 - tmp_block->from2) + 1;
#line 768
    tmp_block->to1 += offset1___0;
#line 769
    tmp_block->from1 += offset1___0;
#line 770
    tmp_block->to2 += offset2___0;
#line 771
    tmp_block->from2 += offset2___0;
#line 772
    tmp_block->flag = flag;
#line 774
    tmp_block = tmp_block->next_exon;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 777
  return;
}
}
#line 780 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void relink(Msp_ptr *in_msp , int in_numMSPs , int H , int offset1___0 , int offset2___0 ,
                   int flag , uchar *s1 , uchar *s2 ) 
{ 
  int last_msp ;
  Exon *tmp_block ;

  {
  {
#line 785
  exon_list = (Exon_ptr )((void *)0);
#line 787
  last_msp = link_msps(in_msp, in_numMSPs, H, 1);
#line 789
  msp2exons(in_msp, last_msp, s1, s2);
#line 791
  tmp_block = exon_list;
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if (! ((unsigned long )tmp_block != (unsigned long )((void *)0))) {
#line 792
      goto while_break;
    }
#line 793
    tmp_block->length = (tmp_block->to2 - tmp_block->from2) + 1;
#line 794
    tmp_block->to1 += offset1___0;
#line 795
    tmp_block->from1 += offset1___0;
#line 796
    tmp_block->to2 += offset2___0;
#line 797
    tmp_block->from2 += offset2___0;
#line 798
    tmp_block->flag = flag;
#line 800
    tmp_block = tmp_block->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 803
  return;
}
}
#line 806 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void free_msps(Msp_ptr **in_msp , int *in_numMSPs ) 
{ 
  int i ;

  {
#line 810
  i = 0;
  {
#line 810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 810
    if (! (i < *in_numMSPs)) {
#line 810
      goto while_break;
    }
    {
#line 810
    free((void *)*(*in_msp + i));
#line 810
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 811
  free((void *)*in_msp);
#line 811
  *in_msp = (Msp_ptr *)((void *)0);
#line 811
  *in_numMSPs = 0;
  }
#line 812
  return;
}
}
#line 814 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int scale(int n ) 
{ 
  double tmp ;
  int tmp___0 ;

  {
#line 816
  if (n <= 100000) {
#line 816
    tmp___0 = n;
  } else {
    {
#line 816
    tmp = log((double )(n - 100000));
#line 816
    tmp___0 = 100000 + (int )((double )10 * tmp);
    }
  }
#line 816
  return (tmp___0);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int link_msps(Msp_ptr *msp___0 , int numMSPs___0 , int H , int flag ) 
{ 
  int i ;
  int j ;
  int f1 ;
  int f2 ;
  int best ;
  int diag ;
  int diff_diag ;
  int best_sc ;
  int try ;
  int var_L ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 824
  best = -1;
#line 824
  best_sc = -99999;
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! (i < numMSPs___0)) {
#line 824
      goto while_break;
    }
#line 825
    f1 = (*(msp___0 + i))->pos1;
#line 826
    f2 = (*(msp___0 + i))->pos2;
#line 827
    diag = f1 - f2;
#line 828
    (*(msp___0 + i))->prev = -1;
#line 829
    (*(msp___0 + i))->Score = 0;
#line 830
    j = 0;
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 830
      if (! (j < i)) {
#line 830
        goto while_break___0;
      }
#line 831
      if ((((*(msp___0 + i))->pos2 + (*(msp___0 + i))->len) - (*(msp___0 + j))->pos2) - (*(msp___0 + j))->len > 2 * W) {
#line 831
        if ((*(msp___0 + i))->pos2 - (*(msp___0 + j))->pos2 > 2 * W) {
#line 831
          tmp = 16;
        } else {
#line 831
          tmp = 8;
        }
      } else {
#line 831
        tmp = 8;
      }
#line 831
      var_L = tmp;
#line 835
      diff_diag = (diag - (*(msp___0 + j))->pos1) + (*(msp___0 + j))->pos2;
#line 836
      if (diff_diag < - rs.DRANGE) {
#line 841
        goto __Cont;
      } else
#line 836
      if (diff_diag > rs.DRANGE) {
#line 836
        if (diff_diag < 30) {
#line 841
          goto __Cont;
        } else {
#line 836
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 836
      if ((((*(msp___0 + j))->pos2 + (*(msp___0 + j))->len) - 1) - f2 > var_L) {
#line 841
        goto __Cont;
      } else
#line 836
      if ((((*(msp___0 + j))->pos1 + (*(msp___0 + j))->len) - 1) - f1 > var_L) {
#line 841
        goto __Cont;
      }
#line 842
      if (flag == 1) {
        {
#line 842
        tmp___0 = abs(diff_diag);
#line 842
        tmp___1 = scale(tmp___0);
#line 842
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 842
        tmp___2 = abs(diff_diag);
#line 842
        tmp___3 = tmp___2;
        }
      }
#line 842
      try = (*(msp___0 + j))->Score - tmp___3;
#line 845
      if (try > (*(msp___0 + i))->Score) {
#line 846
        (*(msp___0 + i))->Score = try;
#line 847
        (*(msp___0 + i))->prev = j;
      }
      __Cont: /* CIL Label */ 
#line 830
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 850
    (*(msp___0 + i))->Score += H * (*(msp___0 + i))->score;
#line 851
    if ((*(msp___0 + i))->Score > best_sc) {
#line 852
      best = i;
#line 853
      best_sc = (*(msp___0 + i))->Score;
    }
#line 824
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  return (best);
}
}
#line 862 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void bld_table(uchar *s , int len , int in_W , int type ) 
{ 
  int ecode ;
  int i ;
  int j ;
  uchar *t ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  uchar *tmp___3 ;
  int tmp___4 ;
  uchar *tmp___5 ;

  {
#line 868
  if (type == 1) {
#line 869
    mask = (1 << ((in_W + in_W) - 2)) - 1;
#line 870
    next_pos = pnext_pos;
#line 871
    hashtab = phashtab;
#line 872
    return;
  }
#line 876
  if (type == 0) {
#line 879
    i = 0;
    {
#line 879
    while (1) {
      while_continue: /* CIL Label */ ;
#line 879
      if (! (i < 128)) {
#line 879
        goto while_break;
      }
#line 879
      encoding[i] = -1;
#line 879
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 881
    encoding['A'] = 0;
#line 882
    encoding['C'] = 1;
#line 883
    encoding['G'] = 2;
#line 884
    encoding['T'] = 3;
#line 885
    mask = (1 << ((in_W + in_W) - 2)) - 1;
#line 887
    tmp = ckalloc((unsigned long )(len + 1) * sizeof(int ));
#line 887
    pnext_pos = (int *)tmp;
#line 887
    next_pos = pnext_pos;
#line 888
    hashtab = phashtab;
    }
  } else {
    {
#line 890
    mask = (1 << ((in_W + in_W) - 2)) - 1;
#line 891
    tmp___0 = ckalloc((unsigned long )(len + 1) * sizeof(int ));
#line 891
    next_pos = (int *)tmp___0;
#line 892
    tmp___1 = ckalloc(32768UL * sizeof(struct hash_node *));
#line 892
    hashtab = (struct hash_node **)tmp___1;
#line 894
    i = 0;
    }
    {
#line 894
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 894
      if (! (i <= 32767)) {
#line 894
        goto while_break___0;
      }
#line 894
      *(hashtab + i) = (struct hash_node *)((void *)0);
#line 894
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 898
  t = s + 1;
#line 899
  i = 1;
  {
#line 899
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 899
    if (i <= len) {
#line 899
      if (! *t) {
#line 899
        goto while_break___1;
      }
    } else {
#line 899
      goto while_break___1;
    }
    restart: 
#line 901
    ecode = 0;
#line 902
    j = 1;
    {
#line 902
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 902
      if (j < in_W) {
#line 902
        if (i <= len) {
#line 902
          if (! *t) {
#line 902
            goto while_break___2;
          }
        } else {
#line 902
          goto while_break___2;
        }
      } else {
#line 902
        goto while_break___2;
      }
#line 903
      tmp___3 = t;
#line 903
      t ++;
#line 903
      tmp___2 = encoding[*tmp___3];
#line 903
      i ++;
#line 904
      if (tmp___2 < 0) {
#line 904
        goto restart;
      }
#line 905
      ecode = (ecode << 2) + tmp___2;
#line 902
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 908
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 908
      if (i <= len) {
#line 908
        if (! *t) {
#line 908
          goto while_break___3;
        }
      } else {
#line 908
        goto while_break___3;
      }
#line 909
      tmp___5 = t;
#line 909
      t ++;
#line 909
      tmp___4 = encoding[*tmp___5];
#line 909
      i ++;
#line 910
      if (tmp___4 < 0) {
#line 910
        goto restart;
      }
      {
#line 911
      ecode = ((ecode & mask) << 2) + tmp___4;
#line 912
      add_word(ecode, (int )((t - s) - 1L));
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 926
  return;
}
}
#line 929 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void add_word(int ecode , int pos ) 
{ 
  struct hash_node *h ;
  int hval ;
  void *tmp ;

  {
#line 934
  hval = ecode & 32767;
#line 935
  h = *(hashtab + hval);
  {
#line 935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 935
    if (! h) {
#line 935
      goto while_break;
    }
#line 936
    if (h->ecode == ecode) {
#line 937
      goto while_break;
    }
#line 935
    h = h->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 939
    tmp = ckalloc(sizeof(struct hash_node ));
#line 939
    h = (struct hash_node *)tmp;
#line 940
    h->link = *(hashtab + hval);
#line 941
    *(hashtab + hval) = h;
#line 942
    h->ecode = ecode;
#line 943
    h->pos = -1;
    }
  }
#line 945
  *(next_pos + pos) = h->pos;
#line 946
  h->pos = pos;
#line 947
  return;
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void search(uchar *s1 , uchar *s2 , int len1 , int len2 , int in_W ) 
{ 
  register struct hash_node *h ;
  register uchar *t ;
  register int ecode ;
  register int hval ;
  int i ;
  int j ;
  int p ;
  int tmp ;
  uchar *tmp___0 ;
  int tmp___1 ;
  uchar *tmp___2 ;

  {
#line 958
  t = s1 + 1;
#line 959
  i = 1;
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (i <= len1) {
#line 959
      if (! *t) {
#line 959
        goto while_break;
      }
    } else {
#line 959
      goto while_break;
    }
    restart: 
#line 961
    ecode = 0;
#line 962
    j = 1;
    {
#line 962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 962
      if (j < in_W) {
#line 962
        if (i <= len1) {
#line 962
          if (! *t) {
#line 962
            goto while_break___0;
          }
        } else {
#line 962
          goto while_break___0;
        }
      } else {
#line 962
        goto while_break___0;
      }
#line 963
      tmp___0 = t;
#line 963
      t ++;
#line 963
      tmp = encoding[*tmp___0];
#line 963
      i ++;
#line 964
      if (tmp < 0) {
#line 964
        goto restart;
      }
#line 965
      ecode = (ecode << 2) + tmp;
#line 962
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 967
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 967
      if (i <= len1) {
#line 967
        if (! *t) {
#line 967
          goto while_break___1;
        }
      } else {
#line 967
        goto while_break___1;
      }
#line 968
      tmp___2 = t;
#line 968
      t ++;
#line 968
      tmp___1 = encoding[*tmp___2];
#line 968
      i ++;
#line 969
      if (tmp___1 < 0) {
#line 969
        goto restart;
      }
#line 970
      ecode = ((ecode & mask) << 2) + tmp___1;
#line 971
      hval = ecode & 32767;
#line 972
      h = *(hashtab + hval);
      {
#line 972
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 972
        if (! h) {
#line 972
          goto while_break___2;
        }
#line 973
        if (h->ecode == ecode) {
#line 974
          p = h->pos;
          {
#line 974
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 974
            if (! (p >= 0)) {
#line 974
              goto while_break___3;
            }
            {
#line 975
            extend_hit((int )((t - s1) - 1L), p, (uchar const   */* const  */)s1,
                       (uchar const   */* const  */)s2, len1, len2, in_W);
#line 974
            p = *(next_pos + p);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 976
          goto while_break___2;
        }
#line 972
        h = h->link;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return;
}
}
#line 1000 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void extend_hit(int pos1 , int pos2 , uchar const   * const  s1 , uchar const   * const  s2 ,
                       int len1 , int len2 , int in_W ) 
{ 
  uchar const   *beg2 ;
  uchar const   *beg1 ;
  uchar const   *end1 ;
  uchar const   *q ;
  uchar const   *s ;
  int right_sum ;
  int left_sum ;
  int sum ;
  int diag ;
  int score ;
  int tmp___1 ;
  uchar const   *tmp___2 ;
  uchar const   *tmp___3 ;
  int tmp___4 ;
  Msp_ptr mp ;
  void *tmp___5 ;

  {
#line 1007
  diag = pos2 - pos1;
#line 1008
  if (*(diag_lev + diag) > pos1) {
#line 1009
    return;
  }
#line 1012
  sum = 0;
#line 1012
  left_sum = sum;
#line 1013
  q = (uchar const   *)((s1 + 1) + pos1);
#line 1014
  s = (uchar const   *)((s2 + 1) + pos2);
#line 1015
  end1 = q;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if ((int const   )*s != 0) {
#line 1016
      if ((int const   )*q != 0) {
#line 1016
        if ((unsigned long )s <= (unsigned long )(s2 + len2)) {
#line 1016
          if ((unsigned long )q <= (unsigned long )(s1 + len1)) {
#line 1016
            if (! (sum >= left_sum - X)) {
#line 1016
              goto while_break;
            }
          } else {
#line 1016
            goto while_break;
          }
        } else {
#line 1016
          goto while_break;
        }
      } else {
#line 1016
        goto while_break;
      }
    } else {
#line 1016
      goto while_break;
    }
#line 1018
    tmp___2 = s;
#line 1018
    s ++;
#line 1018
    tmp___3 = q;
#line 1018
    q ++;
#line 1018
    if ((int const   )*tmp___2 == (int const   )*tmp___3) {
#line 1018
      tmp___1 = 1;
    } else {
#line 1018
      tmp___1 = -5;
    }
#line 1018
    sum += tmp___1;
#line 1019
    if (sum > left_sum) {
#line 1020
      left_sum = sum;
#line 1021
      end1 = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1026
  sum = 0;
#line 1026
  right_sum = sum;
#line 1027
  q = (uchar const   *)(((s1 + 1) + pos1) - in_W);
#line 1027
  beg1 = q;
#line 1028
  s = (uchar const   *)(((s2 + 1) + pos2) - in_W);
#line 1028
  beg2 = s;
  {
#line 1029
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1029
    if ((unsigned long )s > (unsigned long )(s2 + 1)) {
#line 1029
      if ((unsigned long )q > (unsigned long )(s1 + 1)) {
#line 1029
        if (! (sum >= right_sum - X)) {
#line 1029
          goto while_break___0;
        }
      } else {
#line 1029
        goto while_break___0;
      }
    } else {
#line 1029
      goto while_break___0;
    }
#line 1030
    s --;
#line 1030
    q --;
#line 1030
    if ((int const   )*s == (int const   )*q) {
#line 1030
      tmp___4 = 1;
    } else {
#line 1030
      tmp___4 = -5;
    }
#line 1030
    sum += tmp___4;
#line 1031
    if (sum > right_sum) {
#line 1032
      right_sum = sum;
#line 1033
      beg2 = s;
#line 1034
      beg1 = q;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1038
  score = (in_W + left_sum) + right_sum;
#line 1039
  if (score >= K) {
    {
#line 1040
    tmp___5 = ckalloc(sizeof(*mp));
#line 1040
    mp = (Msp_ptr )tmp___5;
#line 1042
    mp->len = (int )(end1 - beg1);
#line 1043
    mp->score = score;
#line 1044
    mp->pos1 = (int )(beg1 - (uchar const   *)(s1 + 1));
#line 1045
    mp->pos2 = (int )(beg2 - (uchar const   *)(s2 + 1));
#line 1046
    mp->next_msp = msp_list;
#line 1047
    msp_list = mp;
#line 1048
    numMSPs ++;
    }
  }
#line 1052
  *(diag_lev + diag) = (int )(((end1 - (uchar const   *)s1) - 1L) + (long )in_W);
#line 1053
  return;
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void sort_msps(void) 
{ 
  int i ;
  Msp_ptr mp ;

  {
#line 1063
  i = numMSPs / 2 - 1;
  {
#line 1063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1063
    if (! (i >= 0)) {
#line 1063
      goto while_break;
    }
    {
#line 1064
    heapify(i, numMSPs - 1);
#line 1063
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  i = numMSPs - 1;
  {
#line 1065
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1065
    if (! (i > 0)) {
#line 1065
      goto while_break___0;
    }
#line 1066
    mp = *(msp + 0);
#line 1067
    *(msp + 0) = *(msp + i);
#line 1068
    *(msp + i) = mp;
#line 1069
    if (i > 1) {
      {
#line 1070
      heapify(0, i - 1);
      }
    }
#line 1065
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1072
  return;
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void heapify(int i , int last ) 
{ 
  int lim ;
  int left_son ;
  int small_son ;
  Msp_ptr mp ;
  int tmp ;

  {
#line 1078
  lim = (last - 1) / 2;
  {
#line 1081
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1081
    if (! (i <= lim)) {
#line 1081
      goto while_break;
    }
#line 1082
    left_son = 2 * i + 1;
#line 1083
    if (left_son == last) {
#line 1084
      small_son = left_son;
    } else {
      {
#line 1086
      small_son = smaller(left_son, left_son + 1);
      }
    }
    {
#line 1087
    tmp = smaller(i, small_son);
    }
#line 1087
    if (tmp == small_son) {
#line 1088
      mp = *(msp + i);
#line 1089
      *(msp + i) = *(msp + small_son);
#line 1090
      *(msp + small_son) = mp;
#line 1091
      i = small_son;
    } else {
#line 1093
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return;
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int smaller(int i , int j ) 
{ 
  Msp_ptr ki ;
  Msp_ptr kj ;
  int tmp ;

  {
#line 1100
  ki = *(msp + i);
#line 1100
  kj = *(msp + j);
#line 1102
  if (ki->pos2 > kj->pos2) {
#line 1102
    return (i);
  }
#line 1103
  if (ki->pos2 < kj->pos2) {
#line 1103
    return (j);
  }
#line 1105
  if (ki->pos1 >= kj->pos1) {
#line 1105
    tmp = i;
  } else {
#line 1105
    tmp = j;
  }
#line 1105
  return (tmp);
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void msp2exons(Msp_ptr *msp___0 , int last_msp , uchar *s1 , uchar *s2 ) 
{ 
  Msp_ptr mp ;
  int diag_dist ;
  int diff ;
  int dist1 ;
  int dist2 ;
  int tmp ;

  {
#line 1115
  exon_list = (Exon_ptr )((void *)0);
#line 1116
  if (last_msp < 0) {
#line 1116
    return;
  }
  {
#line 1119
  mp = *(msp___0 + last_msp);
#line 1120
  exon_list = new_exon(mp->pos1, mp->pos2, (mp->pos1 + mp->len) - 1, (mp->pos2 + mp->len) - 1,
                       -1, (mp->len - mp->score) / 6, 0, exon_list);
#line 1124
  last_msp = mp->prev;
  }
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1126
    if (! (last_msp >= 0)) {
#line 1126
      goto while_break;
    }
    {
#line 1127
    mp = *(msp___0 + last_msp);
#line 1128
    diag_dist = abs((exon_list->from2 - exon_list->from1) - (mp->pos2 - mp->pos1));
    }
#line 1128
    if (diag_dist <= 8) {
#line 1128
      if (exon_list->from2 - ((mp->pos2 + mp->len) - 1) < 50) {
#line 1131
        exon_list->edist += diag_dist;
#line 1132
        exon_list->edist += (mp->len - mp->score) / 6;
#line 1133
        diff = (mp->pos2 + mp->len) - exon_list->from2;
#line 1133
        if (diff > 0) {
          {
#line 1135
          dist1 = get_edist(exon_list->from1, (mp->pos2 + mp->len) - diff, (exon_list->from1 + diff) - 1,
                            (mp->pos2 + mp->len) - 1, s1, s2);
#line 1137
          dist2 = get_edist((mp->pos1 + mp->len) - diff, (mp->pos2 + mp->len) - diff,
                            (mp->pos1 + mp->len) - 1, (mp->pos2 + mp->len) - 1, s1,
                            s2);
          }
#line 1139
          if (dist1 < dist2) {
#line 1139
            tmp = dist2;
          } else {
#line 1139
            tmp = dist1;
          }
#line 1139
          exon_list->edist -= tmp;
        } else
#line 1140
        if (diff < 0) {
#line 1141
          exon_list->edist = (int )((double )exon_list->edist + ((0.5 * .2) * (double )-1) * (double )diff);
        }
#line 1143
        if (exon_list->to1 < (mp->pos1 + mp->len) - 1) {
#line 1143
          exon_list->to1 = (mp->pos1 + mp->len) - 1;
        } else {
#line 1143
          exon_list->to1 = exon_list->to1;
        }
#line 1144
        if (exon_list->to2 < (mp->pos2 + mp->len) - 1) {
#line 1144
          exon_list->to2 = (mp->pos2 + mp->len) - 1;
        } else {
#line 1144
          exon_list->to2 = exon_list->to2;
        }
#line 1145
        if (exon_list->from1 > mp->pos1) {
#line 1145
          exon_list->from1 = mp->pos1;
        } else {
#line 1145
          exon_list->from1 = exon_list->from1;
        }
#line 1146
        if (exon_list->from2 > mp->pos2) {
#line 1146
          exon_list->from2 = mp->pos2;
        } else {
#line 1146
          exon_list->from2 = exon_list->from2;
        }
      } else {
        {
#line 1149
        exon_list = new_exon(mp->pos1, mp->pos2, (mp->pos1 + mp->len) - 1, (mp->pos2 + mp->len) - 1,
                             -1, (mp->len - mp->score) / 6, 0, exon_list);
        }
      }
    } else {
      {
#line 1149
      exon_list = new_exon(mp->pos1, mp->pos2, (mp->pos1 + mp->len) - 1, (mp->pos2 + mp->len) - 1,
                           -1, (mp->len - mp->score) / 6, 0, exon_list);
      }
    }
#line 1154
    last_msp = mp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 1156
  return;
}
}
#line 1158 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int get_edist(int f1 , int f2 , int t1 , int t2 , uchar *seq1___0 , uchar *seq2___0 ) 
{ 
  uchar *s1 ;
  uchar *s2 ;
  uchar *q1 ;
  uchar *q2 ;
  int dist ;

  {
#line 1161
  dist = 0;
#line 1163
  s1 = (seq1___0 + f1) + 1;
#line 1164
  s2 = (seq2___0 + f2) + 1;
#line 1165
  q1 = (seq1___0 + t1) + 1;
#line 1166
  q2 = (seq2___0 + t2) + 1;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if ((unsigned long )s1 <= (unsigned long )q1) {
#line 1168
      if (! ((unsigned long )s2 <= (unsigned long )q2)) {
#line 1168
        goto while_break;
      }
    } else {
#line 1168
      goto while_break;
    }
#line 1168
    dist += (int )*s1 != (int )*s2;
#line 1168
    s1 ++;
#line 1168
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1170
  return (dist);
}
}
#line 1228 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void complement_exons(Exon **left , int M___0 , int N___0 ) 
{ 
  Exon *tmp_block ;
  Exon *right ;
  char prev ;
  char ch ;
  register int aux ;

  {
#line 1233
  prev = (char )'U';
#line 1234
  tmp_block = *left;
  {
#line 1235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1235
    if (! tmp_block) {
#line 1235
      goto while_break;
    }
#line 1236
    if (tmp_block->to1) {
#line 1239
      if (tmp_block->next_exon) {
#line 1239
        if ((tmp_block->next_exon)->to1) {
#line 1240
          ch = tmp_block->ori;
#line 1241
          tmp_block->ori = prev;
          {
#line 1243
          if ((int )ch == 67) {
#line 1243
            goto case_67;
          }
#line 1244
          if ((int )ch == 71) {
#line 1244
            goto case_71;
          }
#line 1245
          if ((int )ch == 78) {
#line 1245
            goto case_78;
          }
#line 1246
          if ((int )ch == 69) {
#line 1246
            goto case_69;
          }
#line 1247
          goto switch_default;
          case_67: /* CIL Label */ 
#line 1243
          prev = (char )'G';
#line 1243
          goto switch_break;
          case_71: /* CIL Label */ 
#line 1244
          prev = (char )'C';
#line 1244
          goto switch_break;
          case_78: /* CIL Label */ 
#line 1245
          prev = (char )'N';
#line 1245
          goto switch_break;
          case_69: /* CIL Label */ 
#line 1246
          prev = (char )'E';
#line 1246
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1247
          fatal("sim4b1.c: Inconsistency. Check exon orientation at complementation.");
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 1250
          tmp_block->ori = prev;
        }
      } else {
#line 1250
        tmp_block->ori = prev;
      }
#line 1251
      aux = tmp_block->from1;
#line 1252
      tmp_block->from1 = (M___0 + 1) - tmp_block->to1;
#line 1253
      tmp_block->to1 = (M___0 + 1) - aux;
#line 1254
      aux = tmp_block->from2;
#line 1255
      tmp_block->from2 = (N___0 + 1) - tmp_block->to2;
#line 1256
      tmp_block->to2 = (N___0 + 1) - aux;
    }
#line 1258
    tmp_block = tmp_block->next_exon;
#line 1259
    if (tmp_block) {
#line 1259
      if (tmp_block->to1) {
#line 1260
        right = tmp_block;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1262
  flip_list(left, & right);
  }
#line 1263
  return;
}
}
#line 1265 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void print_exons(Exon *left ) 
{ 
  Exon *tmp_block ;
  Exon *tmp_block1 ;

  {
#line 1269
  tmp_block = left;
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1270
    if (! ((unsigned long )tmp_block != (unsigned long )((void *)0))) {
#line 1270
      goto while_break;
    }
#line 1271
    if (tmp_block->to1) {
#line 1273
      if (file_type == 1) {
        {
#line 1274
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d-%d  (%d-%d)   %d%%",
                tmp_block->from2, tmp_block->to2, tmp_block->from1, tmp_block->to1,
                tmp_block->match);
        }
      } else {
        {
#line 1280
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d-%d  (%d-%d)   %d%%",
                tmp_block->from1, tmp_block->to1, tmp_block->from2, tmp_block->to2,
                tmp_block->match);
        }
      }
#line 1284
      tmp_block1 = tmp_block->next_exon;
#line 1284
      if ((unsigned long )tmp_block1 != (unsigned long )((void *)0)) {
#line 1284
        if (tmp_block1->to1) {
          {
#line 1286
          if ((int )tmp_block->ori == 67) {
#line 1286
            goto case_67;
          }
#line 1288
          if ((int )tmp_block->ori == 69) {
#line 1288
            goto case_69;
          }
#line 1290
          if ((int )tmp_block->ori == 71) {
#line 1290
            goto case_71;
          }
#line 1292
          if ((int )tmp_block->ori == 78) {
#line 1292
            goto case_78;
          }
#line 1294
          goto switch_default;
          case_67: /* CIL Label */ 
          {
#line 1286
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" <-\n");
          }
#line 1287
          goto switch_break;
          case_69: /* CIL Label */ 
          {
#line 1288
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" ==\n");
          }
#line 1289
          goto switch_break;
          case_71: /* CIL Label */ 
          {
#line 1290
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" ->\n");
          }
#line 1291
          goto switch_break;
          case_78: /* CIL Label */ 
          {
#line 1292
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)" --\n");
          }
#line 1293
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1294
          fatal("sim4b1.c: Inconsistency. Check exon orientations.");
          }
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
#line 1297
    tmp_block = tmp_block->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 1299
  return;
}
}
#line 1302 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void print_pipmaker_exons(Exon *exons , edit_script_list *aligns , char *gene , int from ,
                          int to , int M___0 , int N___0 , uchar *seq1___0 , uchar *seq2___0 ,
                          int match_ori ) 
{ 
  Exon *tmp_block ;
  Exon *left ;
  Exon *right ;
  int From ;
  int To ;
  int cov ;
  int ori ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;

  {
#line 1310
  if ((unsigned long )exons == (unsigned long )((void *)0)) {
#line 1312
    return;
  } else
#line 1310
  if (! exons->to1) {
#line 1310
    if ((unsigned long )exons->next_exon == (unsigned long )((void *)0)) {
#line 1312
      return;
    } else
#line 1310
    if (! exons->next_exon) {
#line 1312
      return;
    }
  }
#line 1314
  if (exons->to1) {
#line 1314
    tmp_block = exons;
  } else {
#line 1314
    tmp_block = exons->next_exon;
  }
#line 1314
  right = tmp_block;
#line 1314
  left = right;
  {
#line 1315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1315
    if (! tmp_block) {
#line 1315
      goto while_break;
    }
#line 1316
    if (tmp_block->to1) {
#line 1316
      right = tmp_block;
    }
#line 1317
    tmp_block = tmp_block->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1321
  ori = check_consistency_intron_ori(exons, match_ori, gene);
  }
#line 1324
  if (from > 0) {
#line 1324
    if (to > 0) {
#line 1324
      if (aligns) {
        {
#line 1325
        cov = dispatch_find_ends(from, to, & From, & To, aligns, M___0, N___0, match_ori);
        }
        {
#line 1327
        if (cov == 0) {
#line 1327
          goto case_0;
        }
#line 1341
        if (cov == 1) {
#line 1341
          goto case_1;
        }
#line 1354
        if (cov == 2) {
#line 1354
          goto case_2;
        }
#line 1363
        if (cov == 3) {
#line 1363
          goto case_3;
        }
#line 1368
        goto switch_default;
        case_0: /* CIL Label */ 
#line 1327
        if (match_ori == 0) {
          {
#line 1327
          tmp___0 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)), "ATG",
                            (size_t )3);
          }
#line 1327
          if (tmp___0) {
            {
#line 1328
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No start codon at location %d in the genomic sequence (%s).\n",
                    From, gene);
            }
          } else {
#line 1327
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1329
        if (match_ori == 1) {
          {
#line 1329
          tmp = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "CAT", (size_t )3);
          }
#line 1329
          if (tmp) {
            {
#line 1330
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No (complement) start codon at location %d in the genomic sequence (%s).\n",
                    To - 2, gene);
            }
          }
        }
#line 1331
        if (match_ori == 0) {
          {
#line 1331
          tmp___4 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "TAA",
                            (size_t )3);
          }
#line 1331
          if (tmp___4) {
            {
#line 1331
            tmp___5 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "TAG",
                              (size_t )3);
            }
#line 1331
            if (tmp___5) {
              {
#line 1331
              tmp___6 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "TGA",
                                (size_t )3);
              }
#line 1331
              if (tmp___6) {
                {
#line 1334
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No stop codon at location %d in the genomic sequence (%s).\n",
                        To - 2, gene);
                }
              } else {
#line 1331
                goto _L___2;
              }
            } else {
#line 1331
              goto _L___2;
            }
          } else {
#line 1331
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1335
        if (match_ori == 1) {
          {
#line 1335
          tmp___1 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)), "TTA",
                            (size_t )3);
          }
#line 1335
          if (tmp___1) {
            {
#line 1335
            tmp___2 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)), "CTA",
                              (size_t )3);
            }
#line 1335
            if (tmp___2) {
              {
#line 1335
              tmp___3 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)),
                                "TCA", (size_t )3);
              }
#line 1335
              if (tmp___3) {
                {
#line 1338
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No (complement) stop codon at location %d in the genomic sequence (%s).\n",
                        From, gene);
                }
              }
            }
          }
        }
#line 1339
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 1342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Start of CDS does not match (%s).\n",
                gene);
        }
#line 1343
        if (match_ori == 0) {
          {
#line 1343
          tmp___10 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "TAA",
                             (size_t )3);
          }
#line 1343
          if (tmp___10) {
            {
#line 1343
            tmp___11 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "TAG",
                               (size_t )3);
            }
#line 1343
            if (tmp___11) {
              {
#line 1343
              tmp___12 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)),
                                 "TGA", (size_t )3);
              }
#line 1343
              if (tmp___12) {
                {
#line 1346
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No stop codon at location %d in the genomic sequence (%s).\n",
                        To - 2, gene);
                }
              } else {
#line 1343
                goto _L___5;
              }
            } else {
#line 1343
              goto _L___5;
            }
          } else {
#line 1343
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 1347
        if (match_ori == 1) {
          {
#line 1347
          tmp___7 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)), "TTA",
                            (size_t )3);
          }
#line 1347
          if (tmp___7) {
            {
#line 1347
            tmp___8 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)), "CTA",
                              (size_t )3);
            }
#line 1347
            if (tmp___8) {
              {
#line 1347
              tmp___9 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)),
                                "TCA", (size_t )3);
              }
#line 1347
              if (tmp___9) {
                {
#line 1350
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No (complement) stop codon at location %d in the genomic sequence (%s).\n",
                        From, gene);
                }
              }
            }
          }
        }
#line 1352
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 1355
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: End of CDS does not match (%s).\n",
                gene);
        }
#line 1356
        if (match_ori == 0) {
          {
#line 1356
          tmp___14 = strncmp((char const   *)((char *)((seq1___0 + From) - 1)), "ATG",
                             (size_t )3);
          }
#line 1356
          if (tmp___14) {
            {
#line 1357
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No start codon at location %d in the genomic sequence (%s).\n",
                    From, gene);
            }
          } else {
#line 1356
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 1358
        if (match_ori == 1) {
          {
#line 1358
          tmp___13 = strncmp((char const   *)((char *)((seq1___0 + To) - 3)), "CAT",
                             (size_t )3);
          }
#line 1358
          if (tmp___13) {
            {
#line 1359
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No (complement) start codon at location %d in the genomic sequence (%s).\n",
                    To - 2, gene);
            }
          }
        }
#line 1361
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 1364
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Start of CDS does not match (%s).\n",
                gene);
#line 1365
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: End of CDS does not match (%s).\n",
                gene);
        }
#line 1366
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1368
        fatal("Unrecognized warning code.");
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1373
  if (to > 0) {
#line 1373
    if (from > 0) {
      {
#line 1374
      tmp___15 = strncmp((char const   *)((char *)((seq2___0 + from) - 1)), "ATG",
                         (size_t )3);
      }
#line 1374
      if (tmp___15) {
        {
#line 1375
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No start codon at location %d in the mRNA (%s).\n",
                from, gene);
        }
      }
      {
#line 1376
      tmp___16 = strncmp((char const   *)((char *)((seq2___0 + to) - 3)), "TAA", (size_t )3);
      }
#line 1376
      if (tmp___16) {
        {
#line 1376
        tmp___17 = strncmp((char const   *)((char *)((seq2___0 + to) - 3)), "TAG",
                           (size_t )3);
        }
#line 1376
        if (tmp___17) {
          {
#line 1376
          tmp___18 = strncmp((char const   *)((char *)((seq2___0 + to) - 3)), "TGA",
                             (size_t )3);
          }
#line 1376
          if (tmp___18) {
            {
#line 1379
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: No end codon at location %d in the mRNA (%s).\n",
                    to - 2, gene);
            }
          }
        }
      }
    }
  }
#line 1382
  if (match_ori == 0) {
#line 1382
    tmp___19 = "";
  } else {
#line 1382
    tmp___19 = " (complement)";
  }
#line 1382
  if (gene) {
#line 1382
    tmp___20 = (char const   *)gene;
  } else {
#line 1382
    tmp___20 = "";
  }
#line 1382
  if (ori == 0) {
#line 1382
    tmp___21 = '>';
  } else {
#line 1382
    tmp___21 = '<';
  }
  {
#line 1382
  printf((char const   */* __restrict  */)"%c %d %d %s%s\n", tmp___21, left->from1,
         right->to1, tmp___20, tmp___19);
  }
#line 1385
  if (from > 0) {
#line 1385
    if (to > 0) {
#line 1385
      if (aligns) {
        {
#line 1386
        printf((char const   */* __restrict  */)"+ %d %d\n", From, To);
        }
      }
    }
  }
#line 1390
  tmp_block = left;
  {
#line 1391
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1391
    if (! ((unsigned long )tmp_block != (unsigned long )((void *)0))) {
#line 1391
      goto while_break___0;
    }
#line 1392
    if (tmp_block->to1) {
      {
#line 1393
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d %d\n",
              tmp_block->from1, tmp_block->to1);
      }
    }
#line 1395
    tmp_block = tmp_block->next_exon;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1397
  if (match_ori == 1) {
    {
#line 1397
    flip_list(& left, & right);
    }
  }
#line 1399
  return;
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int check_consistency_intron_ori(Exon *exons , int match_ori , char *gene ) 
{ 
  Exon *t ;
  int numG ;
  int numC ;
  int numE ;
  int numN ;
  int tmp ;

  {
#line 1404
  t = exons;
#line 1407
  numN = 0;
#line 1407
  numE = numN;
#line 1407
  numC = numE;
#line 1407
  numG = numC;
#line 1409
  if (! t->to1) {
#line 1409
    t = t->next_exon;
  }
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1410
    if (t) {
#line 1410
      if (! t->to1) {
#line 1410
        goto while_break;
      }
    } else {
#line 1410
      goto while_break;
    }
#line 1411
    if (t->next_exon) {
#line 1411
      if ((t->next_exon)->to1) {
        {
#line 1413
        if ((int )t->ori == 71) {
#line 1413
          goto case_71;
        }
#line 1414
        if ((int )t->ori == 67) {
#line 1414
          goto case_67;
        }
#line 1415
        if ((int )t->ori == 78) {
#line 1415
          goto case_78;
        }
#line 1416
        if ((int )t->ori == 69) {
#line 1416
          goto case_69;
        }
#line 1417
        goto switch_default;
        case_71: /* CIL Label */ 
#line 1413
        numG ++;
#line 1413
        goto switch_break;
        case_67: /* CIL Label */ 
#line 1414
        numC ++;
#line 1414
        goto switch_break;
        case_78: /* CIL Label */ 
#line 1415
        numN ++;
#line 1415
        goto switch_break;
        case_69: /* CIL Label */ 
#line 1416
        numE ++;
#line 1416
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1417
        fatal("sim4b1.c: Unrecognized intron orientation.");
        }
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 1420
    t = t->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  if (numG) {
#line 1422
    if (numC) {
      {
#line 1423
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Introns reported on both strands (%s).\n",
              gene);
      }
    }
  }
#line 1434
  if (numN) {
    {
#line 1435
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Ambiguous intron orientation (%s).\n",
            gene);
    }
  }
#line 1436
  if (numE) {
    {
#line 1437
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Internal gap in the mRNA (%s).\n",
            gene);
    }
  }
#line 1439
  if (numG >= numC) {
#line 1439
    tmp = 0;
  } else {
#line 1439
    tmp = 1;
  }
#line 1439
  return (tmp);
}
}
#line 1444 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int dispatch_find_ends(int from , int to , int *From , int *To , edit_script_list *aligns ,
                              int M___0 , int N___0 , int match_ori ) 
{ 
  int f1 ;
  int f2 ;
  int t1 ;
  int t2 ;
  int ot1 ;
  int ot2 ;
  int xto ;
  int xfrom ;
  int free_start ;
  int free_end ;
  int tmp ;
  int aux ;

  {
#line 1449
  free_end = 1;
#line 1449
  free_start = free_end;
#line 1451
  if (aligns->next_script) {
#line 1451
    if (aligns->offset2 > (aligns->next_script)->offset2) {
      {
#line 1452
      script_flip_list(& aligns);
      }
    }
  }
#line 1454
  if (match_ori == 0) {
#line 1455
    xto = to;
#line 1455
    xfrom = from;
  } else
#line 1456
  if (file_type == 1) {
#line 1457
    xto = to;
#line 1457
    xfrom = from;
  } else {
#line 1459
    xto = (N___0 - from) + 1;
#line 1459
    xfrom = (N___0 - to) + 1;
  }
#line 1462
  tmp = 0;
#line 1462
  *To = tmp;
#line 1462
  *From = tmp;
#line 1462
  t2 = 0;
#line 1462
  t1 = t2;
  {
#line 1463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1463
    if (! aligns) {
#line 1463
      goto while_break;
    }
#line 1464
    ot2 = t2;
#line 1464
    ot1 = t1;
#line 1465
    f1 = aligns->offset1;
#line 1465
    f2 = aligns->offset2;
#line 1466
    t1 = (f1 + aligns->len1) - 1;
#line 1466
    t2 = (f2 + aligns->len2) - 1;
#line 1467
    if (ot2 < xfrom) {
#line 1467
      if (xfrom < f2) {
#line 1468
        *From = f1;
#line 1468
        goto while_break;
      }
    }
#line 1470
    if (f2 <= xfrom) {
#line 1470
      if (xfrom <= t2) {
        {
#line 1471
        *From = find_ends(aligns, xfrom);
#line 1471
        free_start = 0;
        }
#line 1471
        goto while_break;
      }
    }
#line 1473
    aligns = aligns->next_script;
  }
  while_break: /* CIL Label */ ;
  }
#line 1475
  if (*From == 0) {
#line 1475
    return (3);
  }
#line 1477
  if (ot2 < xto) {
#line 1477
    if (xto < f2) {
#line 1477
      *To = ot1;
    } else {
#line 1477
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1478
  if (xto <= t2) {
    {
#line 1478
    *To = find_ends(aligns, xto);
#line 1478
    free_end = 0;
    }
  } else {
#line 1480
    *To = 0;
    {
#line 1481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1481
      if (aligns) {
#line 1481
        aligns = aligns->next_script;
#line 1481
        if (! ((unsigned long )aligns != (unsigned long )((void *)0))) {
#line 1481
          goto while_break___0;
        }
      } else {
#line 1481
        goto while_break___0;
      }
#line 1482
      ot2 = t2;
#line 1482
      ot1 = t1;
#line 1483
      f1 = aligns->offset1;
#line 1483
      f2 = aligns->offset2;
#line 1484
      t1 = (f1 + aligns->len1) - 1;
#line 1484
      t2 = (f2 + aligns->len2) - 1;
#line 1485
      if (ot2 < xto) {
#line 1485
        if (xto < f2) {
#line 1485
          *To = ot1;
#line 1485
          goto while_break___0;
        }
      }
#line 1486
      if (t2 < xto) {
#line 1486
        *To = t1;
      } else
#line 1487
      if (f2 <= xto) {
#line 1487
        if (xto <= t2) {
          {
#line 1488
          *To = find_ends(aligns, xto);
#line 1488
          free_end = 0;
          }
#line 1488
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1491
    if (*To == 0) {
#line 1491
      *To = t1;
    }
  }
#line 1494
  if (*To == 0) {
#line 1494
    *From = 0;
#line 1494
    free_start = 1;
  }
#line 1496
  if (*To) {
#line 1496
    if (*From) {
#line 1496
      if (match_ori == 1) {
#line 1496
        if (file_type == 1) {
#line 1497
          aux = (M___0 - *From) + 1;
#line 1497
          *From = (M___0 - *To) + 1;
#line 1497
          *To = aux;
        }
      }
    }
  }
#line 1500
  if (free_start) {
#line 1500
    if (free_end) {
#line 1500
      return (3);
    } else {
#line 1500
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1501
  if (free_start) {
#line 1501
    return (1);
  } else
#line 1502
  if (free_end) {
#line 1502
    return (2);
  }
#line 1504
  return (0);
}
}
#line 1507 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int find_ends(edit_script_list *head , int j0___0 ) 
{ 
  int i ;
  int j ;
  int e1 ;
  int e2 ;
  edit_script *tp ;

  {
#line 1512
  i = head->offset1;
#line 1512
  e1 = (i + head->len1) - 1;
#line 1513
  j = head->offset2;
#line 1513
  e2 = (j + head->len2) - 1;
#line 1515
  tp = head->script;
#line 1516
  i --;
#line 1516
  j --;
  {
#line 1517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1517
    if (i <= e1) {
#line 1517
      if (j <= e2) {
#line 1517
        if (! tp) {
#line 1517
          goto while_break;
        }
      } else {
#line 1517
        goto while_break;
      }
    } else {
#line 1517
      goto while_break;
    }
#line 1518
    if (j == j0___0) {
#line 1518
      return (i);
    }
    {
#line 1520
    if ((int )tp->op_type == 1) {
#line 1520
      goto case_1;
    }
#line 1521
    if ((int )tp->op_type == 2) {
#line 1521
      goto case_2;
    }
#line 1522
    if ((int )tp->op_type == 3) {
#line 1522
      goto case_3;
    }
#line 1524
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1520
    i += tp->num;
#line 1520
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1521
    j += tp->num;
#line 1521
    if (j >= j0___0) {
#line 1521
      return (i);
    }
#line 1521
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1522
    i += tp->num;
#line 1522
    j += tp->num;
#line 1523
    if (j >= j0___0) {
#line 1523
      return (i - (j - j0___0));
    }
#line 1523
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1524
    fatal("Illegal opcode in script.");
    }
    switch_break: /* CIL Label */ ;
    }
#line 1526
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1530
  fatal("Inconsistency in script.");
  }
}
}
#line 1552 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void pluri_align(int *dist_ptr , int *num_matches , Exon *lblock , struct edit_script_list **Aligns ) 
{ 
  int tmpi ;
  int di_count ;
  int i ;
  int end1 ;
  int end2 ;
  int diff ;
  int ali_dist ;
  int nmatches ;
  uchar *a ;
  uchar *b ;
  Exon *tmp_block ;
  Exon *tmp_block1 ;
  struct edit_script_list *enew ;
  struct edit_script *head ;
  struct edit_script *tmp_script ;
  struct edit_script *new ;
  struct edit_script *left ;
  struct edit_script *right ;
  struct edit_script *prev ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 1556
  tmp_block = lblock;
#line 1561
  nmatches = 0;
#line 1563
  head = (struct edit_script *)((void *)0);
#line 1564
  *Aligns = (struct edit_script_list *)((void *)0);
#line 1565
  ali_dist = 0;
#line 1565
  *dist_ptr = ali_dist;
#line 1567
  end1 = M;
#line 1568
  end2 = N;
  {
#line 1570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1570
    tmp_block1 = tmp_block->next_exon;
#line 1570
    if ((unsigned long )tmp_block1 != (unsigned long )((void *)0)) {
#line 1570
      if (! tmp_block1->to1) {
#line 1570
        goto while_break;
      }
    } else {
#line 1570
      goto while_break;
    }
#line 1572
    diff = (tmp_block->from2 - tmp_block1->to2) - 1;
#line 1572
    if (diff != 0) {
#line 1573
      if (tmp_block->to1) {
        {
#line 1574
        tmp = ckalloc(sizeof(edit_script_list ));
#line 1574
        enew = (edit_script_list *)tmp;
#line 1575
        enew->next_script = *Aligns;
#line 1576
        *Aligns = enew;
#line 1577
        (*Aligns)->script = head;
#line 1578
        (*Aligns)->offset1 = tmp_block->from1;
#line 1579
        (*Aligns)->offset2 = tmp_block->from2;
#line 1580
        (*Aligns)->len1 = (end1 - (*Aligns)->offset1) + 1;
#line 1581
        (*Aligns)->len2 = (end2 - (*Aligns)->offset2) + 1;
#line 1582
        (*Aligns)->score = ali_dist;
#line 1583
        ali_dist = 0;
#line 1584
        head = (struct edit_script *)((void *)0);
        }
      }
#line 1586
      end1 = tmp_block1->to1;
#line 1587
      end2 = tmp_block1->to2;
    } else {
#line 1589
      diff = (tmp_block->from1 - tmp_block1->to1) - 1;
#line 1589
      if (diff != 0) {
#line 1589
        if (tmp_block->to1) {
          {
#line 1591
          tmp___0 = ckalloc(sizeof(edit_script ));
#line 1591
          new = (edit_script *)tmp___0;
#line 1592
          new->op_type = (char)1;
#line 1593
          new->num = diff;
#line 1594
          new->next = head;
#line 1595
          head = new;
          }
        } else {
#line 1589
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1596
      if (diff) {
#line 1597
        end1 = tmp_block1->to1;
      }
    }
#line 1599
    if ((double )1000 < .2 * (double )((tmp_block1->to2 - tmp_block1->from2) + 1)) {
#line 1599
      tmp___1 = .2 * (double )((tmp_block1->to2 - tmp_block1->from2) + 1);
    } else {
#line 1599
      tmp___1 = (double )1000;
    }
    {
#line 1599
    diff = align_get_dist(tmp_block1->from1 - 1, tmp_block1->from2 - 1, tmp_block1->to1,
                          tmp_block1->to2, (int )tmp___1);
    }
#line 1603
    if (diff < 0) {
      {
#line 1604
      printf((char const   */* __restrict  */)"The two sequences are not really similar.\n");
#line 1605
      printf((char const   */* __restrict  */)"Please try an exact method.\n");
#line 1606
      exit(1);
      }
    }
    {
#line 1614
    align_path(tmp_block1->from1 - 1, tmp_block1->from2 - 1, tmp_block1->to1, tmp_block1->to2,
               diff, & left, & right);
#line 1617
    Condense_both_Ends(& left, & right, & prev);
    }
#line 1619
    if (! tmp_block->to1) {
#line 1619
      if ((int )right->op_type == 1) {
#line 1621
        diff -= right->num;
#line 1622
        tmp_block1->to1 -= right->num;
#line 1623
        end1 -= right->num;
#line 1624
        if (head) {
#line 1624
          if ((int )head->op_type == 1) {
#line 1625
            head->num += right->num;
          }
        }
        {
#line 1626
        free((void *)right);
#line 1626
        prev->next = (struct edit_script *)((void *)0);
#line 1627
        right = prev;
        }
      }
    }
#line 1629
    if (! tmp_block1->next_exon) {
#line 1629
      goto _L___0;
    } else
#line 1629
    if (! (tmp_block1->next_exon)->to1) {
      _L___0: /* CIL Label */ 
#line 1629
      if (left) {
#line 1629
        if ((int )left->op_type == 1) {
#line 1631
          diff -= left->num;
#line 1632
          tmp_block1->from1 += left->num;
#line 1633
          tmp_script = left->next;
#line 1634
          if ((unsigned long )right == (unsigned long )left) {
#line 1634
            right = tmp_script;
          }
          {
#line 1635
          free((void *)left);
#line 1635
          left = tmp_script;
          }
        }
      }
    }
#line 1638
    *dist_ptr += diff;
#line 1639
    ali_dist += diff;
#line 1641
    a = (seq1 + tmp_block1->from1) - 1;
#line 1642
    b = (seq2 + tmp_block1->from2) - 1;
#line 1643
    di_count = 0;
#line 1643
    tmpi = di_count;
#line 1644
    tmp_script = left;
    {
#line 1645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1645
      if (! tmp_script) {
#line 1645
        goto while_break___0;
      }
      {
#line 1647
      if ((int )tmp_script->op_type == 1) {
#line 1647
        goto case_1;
      }
#line 1652
      if ((int )tmp_script->op_type == 2) {
#line 1652
        goto case_2;
      }
#line 1657
      if ((int )tmp_script->op_type == 3) {
#line 1657
        goto case_3;
      }
#line 1646
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1648
      di_count += tmp_script->num;
#line 1649
      tmpi += tmp_script->num;
#line 1650
      a += tmp_script->num;
#line 1651
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1653
      di_count += tmp_script->num;
#line 1654
      tmpi += tmp_script->num;
#line 1655
      b += tmp_script->num;
#line 1656
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1658
      i = 0;
      {
#line 1658
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1658
        if (! (i < tmp_script->num)) {
#line 1658
          goto while_break___1;
        }
#line 1659
        if ((int )*a != (int )*b) {
#line 1659
          tmpi ++;
        } else {
#line 1659
          nmatches ++;
        }
#line 1658
        i ++;
#line 1658
        a ++;
#line 1658
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1660
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1662
      tmp_script = tmp_script->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1664
    tmp_block1->alen = (int )((double )((((((tmp_block1->to1 - tmp_block1->from1) + 1) + tmp_block1->to2) - tmp_block1->from2) + 1) + di_count) / (double )2);
#line 1666
    tmp_block1->nmatches = tmp_block1->alen - tmpi;
#line 1667
    tmp___2 = floor((double )100 * ((double )1 - (double )tmpi / (double )tmp_block1->alen));
#line 1667
    tmp_block1->match = (int )tmp___2;
#line 1669
    right->next = head;
#line 1670
    head = left;
#line 1671
    tmp_block = tmp_block1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1676
  if ((unsigned long )tmp_block1 != (unsigned long )((void *)0)) {
#line 1678
    diff = (tmp_block->from2 - tmp_block1->to2) - 1;
#line 1678
    if (diff != 0) {
#line 1678
      if (diff != N) {
        {
#line 1679
        tmp___3 = ckalloc(sizeof(edit_script_list ));
#line 1679
        enew = (edit_script_list *)tmp___3;
#line 1680
        enew->next_script = *Aligns;
#line 1681
        *Aligns = enew;
#line 1682
        (*Aligns)->offset1 = tmp_block->from1;
#line 1683
        (*Aligns)->offset2 = tmp_block->from2;
#line 1684
        (*Aligns)->len1 = (end1 - (*Aligns)->offset1) + 1;
#line 1685
        (*Aligns)->len2 = (end2 - (*Aligns)->offset2) + 1;
#line 1686
        (*Aligns)->script = head;
#line 1687
        (*Aligns)->score = ali_dist;
        }
      } else {
#line 1678
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1689
    if (diff != N) {
      {
#line 1692
      tmp___4 = ckalloc(sizeof(edit_script_list ));
#line 1692
      enew = (edit_script_list *)tmp___4;
#line 1693
      enew->next_script = *Aligns;
#line 1694
      *Aligns = enew;
#line 1695
      (*Aligns)->offset1 = tmp_block->from1;
#line 1696
      (*Aligns)->offset2 = 1;
#line 1697
      (*Aligns)->len1 = (end1 - (*Aligns)->offset1) + 1;
#line 1698
      (*Aligns)->len2 = (end2 - (*Aligns)->offset2) + 1;
#line 1699
      (*Aligns)->script = head;
#line 1700
      (*Aligns)->score = ali_dist;
      }
    }
  }
#line 1703
  *num_matches = nmatches;
#line 1704
  return;
}
}
#line 1706 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static Exon *new_exon(int f1 , int f2 , int t1 , int t2 , int len , int edist , int flag ,
                      Exon *next ) 
{ 
  Exon *new ;
  void *tmp ;

  {
  {
#line 1708
  tmp = ckalloc(sizeof(Exon ));
#line 1708
  new = (Exon *)tmp;
#line 1710
  new->from1 = f1;
#line 1711
  new->from2 = f2;
#line 1712
  new->to1 = t1;
#line 1713
  new->to2 = t2;
  }
#line 1714
  if (len < 0) {
#line 1714
    new->length = (t2 - f2) + 1;
  } else {
#line 1714
    new->length = len;
  }
#line 1715
  new->edist = edist;
#line 1716
  new->flag = flag;
#line 1717
  new->next_exon = next;
#line 1719
  return (new);
}
}
#line 1723 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void get_stats(Exon *lblock , sim4_stats_t *st ) 
{ 
  Exon *t ;
  Exon *t1 ;

  {
#line 1748
  st->icoverage = 0;
#line 1748
  st->internal = 1;
#line 1748
  st->mult = 0;
#line 1749
  t = lblock->next_exon;
  {
#line 1750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1750
    if (! t) {
#line 1750
      goto while_break;
    }
#line 1751
    st->icoverage += t->length;
#line 1752
    if (t->length) {
#line 1752
      (st->mult) ++;
    }
#line 1753
    t = t->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 1755
  st->fcoverage = (double )((float )st->icoverage / (float )N);
#line 1757
  t = lblock;
#line 1758
  if ((unsigned long )t->next_exon == (unsigned long )((void *)0)) {
#line 1759
    st->internal = 0;
  } else
#line 1758
  if (! (t->next_exon)->to1) {
#line 1759
    st->internal = 0;
  }
  {
#line 1760
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1760
    if (! t) {
#line 1760
      goto while_break___0;
    }
#line 1761
    if (t->to1) {
#line 1761
      t1 = t->next_exon;
#line 1761
      if ((unsigned long )t1 != (unsigned long )((void *)0)) {
#line 1761
        if ((t1->from2 - t->to2) - 1 > 0) {
#line 1761
          if (t1->to1) {
#line 1763
            st->internal = 0;
          }
        }
      }
    }
#line 1764
    t = t->next_exon;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1766
  return;
}
}
#line 1768 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int resolve_overlap(Exon *tmp_block , Exon *tmp_block1 , uchar *seq1___0 ) 
{ 
  int diff ;
  int best_u ;
  int l0 ;
  int l1 ;
  int u ;
  int cost ;
  int GTAG_score ;
  int CTAC_score ;
  uchar *s1 ;
  uchar *s2 ;
  uchar *e1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1774
  diff = (tmp_block1->from2 - tmp_block->to2) - 1;
#line 1775
  if (diff >= 0) {
#line 1775
    return (tmp_block1->from2 - 1);
  }
#line 1780
  l0 = tmp_block->length - diff;
#line 1781
  l1 = tmp_block1->length;
#line 1783
  u = tmp_block1->from2 - 1;
#line 1783
  best_u = u;
#line 1784
  s1 = (seq1___0 + tmp_block->to1) - (tmp_block->to2 - u);
#line 1785
  s2 = (((seq1___0 - 2) + tmp_block1->from1) + u) - tmp_block1->from2;
#line 1787
  cost = 0;
#line 1788
  e1 = seq1___0 + tmp_block->to1;
  {
#line 1789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1789
    if (! ((unsigned long )s1 <= (unsigned long )e1)) {
#line 1789
      goto while_break;
    }
#line 1790
    CTAC_score = 0;
#line 1790
    GTAG_score = CTAC_score;
#line 1791
    if ((int )((char )*s1) == 71) {
#line 1791
      tmp = 1;
    } else {
#line 1791
      tmp = 0;
    }
#line 1791
    GTAG_score += tmp;
#line 1792
    if ((int )((char )*(s1 + 1)) == 84) {
#line 1792
      tmp___0 = 1;
    } else {
#line 1792
      tmp___0 = 0;
    }
#line 1792
    GTAG_score += tmp___0;
#line 1793
    if ((int )((char )*s2) == 65) {
#line 1793
      tmp___1 = 1;
    } else {
#line 1793
      tmp___1 = 0;
    }
#line 1793
    GTAG_score += tmp___1;
#line 1794
    if ((int )((char )*(s2 + 1)) == 71) {
#line 1794
      tmp___2 = 1;
    } else {
#line 1794
      tmp___2 = 0;
    }
    {
#line 1794
    GTAG_score += tmp___2;
#line 1796
    tmp___3 = abs(cost);
    }
#line 1796
    if (GTAG_score > tmp___3) {
#line 1796
      if (l0 >= 8) {
#line 1796
        goto _L;
      } else
#line 1796
      if (l1 >= 8) {
        _L: /* CIL Label */ 
#line 1797
        cost = GTAG_score;
#line 1798
        best_u = u;
#line 1799
        if (cost == 4) {
#line 1799
          goto while_break;
        }
      }
    }
#line 1802
    if ((int )((char )*s1) == 67) {
#line 1802
      tmp___4 = 1;
    } else {
#line 1802
      tmp___4 = 0;
    }
#line 1802
    CTAC_score += tmp___4;
#line 1803
    if ((int )((char )*(s1 + 1)) == 84) {
#line 1803
      tmp___5 = 1;
    } else {
#line 1803
      tmp___5 = 0;
    }
#line 1803
    CTAC_score += tmp___5;
#line 1804
    if ((int )((char )*s2) == 65) {
#line 1804
      tmp___6 = 1;
    } else {
#line 1804
      tmp___6 = 0;
    }
#line 1804
    CTAC_score += tmp___6;
#line 1805
    if ((int )((char )*(s2 + 1)) == 67) {
#line 1805
      tmp___7 = 1;
    } else {
#line 1805
      tmp___7 = 0;
    }
    {
#line 1805
    CTAC_score += tmp___7;
#line 1807
    tmp___8 = abs(cost);
    }
#line 1807
    if (CTAC_score > tmp___8) {
#line 1808
      cost = - CTAC_score;
#line 1809
      best_u = u;
#line 1810
      if (cost == 4) {
#line 1810
        goto while_break;
      }
    }
#line 1813
    u ++;
#line 1813
    s1 ++;
#line 1813
    s2 ++;
#line 1814
    l0 ++;
#line 1814
    l1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1817
  return (best_u);
}
}
#line 1821 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int greedy(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
                  Exon **lblock , Exon **rblock ) 
{ 
  int col ;
  int d ;
  int k ;
  int max_d ;
  int Cost ;
  int blower ;
  int flower ;
  int bupper ;
  int fupper ;
  int row ;
  int DELTA ;
  int MAX_D ;
  int B_ORIGIN ;
  int F_ORIGIN ;
  int back ;
  int forth ;
  int *blast_d ;
  int *flast_d ;
  int *btemp_d ;
  int *ftemp_d ;
  int *min_row ;
  int *min_diag ;
  int *max_row ;
  int *max_diag ;
  Exon *tmp ;
  Exon *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  Exon *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  Exon *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  Exon *tmp___13 ;

  {
#line 1842
  DELTA = n - m;
#line 1844
  if (W < (int )(.2 * (double )m + (double )1)) {
#line 1844
    MAX_D = (int )(.2 * (double )m + (double )1);
  } else {
#line 1844
    MAX_D = W;
  }
#line 1844
  max_d = MAX_D;
#line 1846
  if (DELTA < 0) {
#line 1847
    if ((double )W > ((double )1 + .2) * (double )n) {
#line 1847
      tmp___2 = ((double )1 + .2) * (double )n;
    } else {
#line 1847
      tmp___2 = (double )W;
    }
#line 1847
    if ((double )m <= tmp___2) {
      {
#line 1848
      tmp = new_exon(offset2___0 + 1, offset1___0 + 1, offset2___0 + n, offset1___0 + m,
                     m, (n - m) + (int )(.2 * (double )m + (double )1), 0, (Exon *)((void *)0));
#line 1848
      *rblock = tmp;
#line 1848
      *lblock = tmp;
      }
#line 1850
      return ((m - n) + (int )(.2 * (double )n + (double )1));
    } else {
#line 1852
      tmp___0 = (Exon *)((void *)0);
#line 1852
      *rblock = tmp___0;
#line 1852
      *lblock = tmp___0;
#line 1853
      if (W < (int )(.2 * (double )m + (double )1)) {
#line 1853
        tmp___1 = (int )(.2 * (double )m + (double )1);
      } else {
#line 1853
        tmp___1 = W;
      }
#line 1853
      return (tmp___1 + 1);
    }
  }
#line 1857
  F_ORIGIN = MAX_D;
#line 1858
  B_ORIGIN = MAX_D - DELTA;
#line 1859
  row = m;
#line 1859
  col = n;
  {
#line 1859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1859
    if (row > 0) {
#line 1859
      if (col > 0) {
#line 1859
        if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 1859
          goto while_break;
        }
      } else {
#line 1859
        goto while_break;
      }
    } else {
#line 1859
      goto while_break;
    }
#line 1859
    row --;
#line 1859
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1862
  if (row == 0) {
    {
#line 1864
    tmp___3 = new_exon(((offset2___0 - m) + n) + 1, offset1___0 + 1, offset2___0 + n,
                       offset1___0 + m, m, 0, 0, (Exon *)((void *)0));
#line 1864
    *rblock = tmp___3;
#line 1864
    *lblock = tmp___3;
    }
#line 1866
    return (0);
  }
  {
#line 1870
  tmp___4 = ckalloc((unsigned long )((MAX_D + n) + 1) * sizeof(int ));
#line 1870
  blast_d = (int *)tmp___4;
#line 1871
  tmp___5 = ckalloc((unsigned long )((MAX_D + n) + 1) * sizeof(int ));
#line 1871
  btemp_d = (int *)tmp___5;
#line 1873
  k = 0;
  }
  {
#line 1873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1873
    if (! (k <= MAX_D + n)) {
#line 1873
      goto while_break___0;
    }
#line 1873
    *(blast_d + k) = m + 1;
#line 1873
    *(btemp_d + k) = m + 1;
#line 1873
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1874
  *(blast_d + (B_ORIGIN + DELTA)) = row;
#line 1876
  blower = (B_ORIGIN + DELTA) - 1;
#line 1877
  bupper = (B_ORIGIN + DELTA) + 1;
#line 1880
  row = 0;
  {
#line 1880
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1880
    if (row < n) {
#line 1880
      if (row < m) {
#line 1880
        if (! ((int )*(s1 + row) == (int )*(s2 + row))) {
#line 1880
          goto while_break___1;
        }
      } else {
#line 1880
        goto while_break___1;
      }
    } else {
#line 1880
      goto while_break___1;
    }
#line 1880
    row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1883
  if (row == m) {
    {
#line 1885
    tmp___6 = new_exon(offset2___0 + 1, offset1___0 + 1, offset2___0 + m, offset1___0 + m,
                       m, 0, 0, (Exon *)((void *)0));
#line 1885
    *rblock = tmp___6;
#line 1885
    *lblock = tmp___6;
#line 1887
    free((void *)blast_d);
#line 1887
    free((void *)btemp_d);
    }
#line 1889
    return (0);
  }
  {
#line 1892
  tmp___7 = ckalloc((unsigned long )((MAX_D + n) + 1) * sizeof(int ));
#line 1892
  flast_d = (int *)tmp___7;
#line 1893
  tmp___8 = ckalloc((unsigned long )((MAX_D + n) + 1) * sizeof(int ));
#line 1893
  ftemp_d = (int *)tmp___8;
#line 1895
  k = 0;
  }
  {
#line 1895
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1895
    if (! (k <= MAX_D + n)) {
#line 1895
      goto while_break___2;
    }
#line 1895
    *(flast_d + k) = -1;
#line 1895
    *(ftemp_d + k) = -1;
#line 1895
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1896
  *(flast_d + F_ORIGIN) = row;
#line 1898
  flower = F_ORIGIN - 1;
#line 1899
  fupper = F_ORIGIN + 1;
#line 1901
  tmp___9 = ckalloc((unsigned long )(MAX_D + 1) * sizeof(int ));
#line 1901
  max_row = (int *)tmp___9;
#line 1902
  tmp___10 = ckalloc((unsigned long )(MAX_D + 1) * sizeof(int ));
#line 1902
  min_row = (int *)tmp___10;
#line 1903
  tmp___11 = ckalloc((unsigned long )(MAX_D + 1) * sizeof(int ));
#line 1903
  max_diag = (int *)tmp___11;
#line 1904
  tmp___12 = ckalloc((unsigned long )(MAX_D + 1) * sizeof(int ));
#line 1904
  min_diag = (int *)tmp___12;
#line 1906
  d = 1;
  }
  {
#line 1906
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1906
    if (! (d <= MAX_D)) {
#line 1906
      goto while_break___3;
    }
#line 1907
    *(min_row + d) = m + 1;
#line 1907
    *(max_row + d) = -1;
#line 1906
    d ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1909
  *(min_row + 0) = *(blast_d + (B_ORIGIN + DELTA));
#line 1910
  *(min_diag + 0) = B_ORIGIN + DELTA;
#line 1911
  *(max_row + 0) = *(flast_d + F_ORIGIN);
#line 1912
  *(max_diag + 0) = F_ORIGIN;
#line 1914
  forth = -1;
#line 1914
  back = forth;
#line 1916
  d = 1;
  {
#line 1917
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1917
    if (! (d <= max_d)) {
#line 1917
      goto while_break___4;
    }
#line 1920
    k = blower;
    {
#line 1920
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1920
      if (! (k <= bupper)) {
#line 1920
        goto while_break___5;
      }
#line 1924
      if (k == (- d + DELTA) + B_ORIGIN) {
#line 1927
        row = *(blast_d + (k + 1));
      } else
#line 1928
      if (k == (d + DELTA) + B_ORIGIN) {
#line 1931
        row = *(blast_d + (k - 1)) - 1;
      } else
#line 1932
      if (*(blast_d + k) <= *(blast_d + (k + 1))) {
#line 1932
        if (*(blast_d + k) - 1 <= *(blast_d + (k - 1))) {
#line 1936
          row = *(blast_d + k) - 1;
        } else {
#line 1932
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1938
      if (*(blast_d + (k - 1)) <= *(blast_d + (k + 1)) - 1) {
#line 1938
        if (*(blast_d + (k - 1)) <= *(blast_d + k) - 1) {
#line 1941
          row = *(blast_d + (k - 1)) - 1;
        } else {
#line 1944
          row = *(blast_d + (k + 1));
        }
      } else {
#line 1944
        row = *(blast_d + (k + 1));
      }
#line 1947
      col = (row + k) - B_ORIGIN;
      {
#line 1950
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1950
        if (row > 0) {
#line 1950
          if (col > 0) {
#line 1950
            if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 1950
              goto while_break___6;
            }
          } else {
#line 1950
            goto while_break___6;
          }
        } else {
#line 1950
          goto while_break___6;
        }
#line 1951
        row --;
#line 1952
        col --;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1954
      *(btemp_d + k) = row;
#line 1920
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1960
    *(min_row + d) = *(btemp_d + (DELTA + B_ORIGIN));
#line 1961
    *(min_diag + d) = DELTA + B_ORIGIN;
#line 1962
    k = blower;
    {
#line 1962
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1962
      if (! (k <= bupper)) {
#line 1962
        goto while_break___7;
      }
#line 1963
      *(blast_d + k) = *(btemp_d + k);
#line 1963
      *(btemp_d + k) = m + 1;
#line 1964
      if (*(blast_d + k) < *(min_row + d)) {
#line 1965
        *(min_row + d) = *(blast_d + k);
#line 1966
        *(min_diag + d) = k;
      }
#line 1962
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1972
    Cost = 0;
    {
#line 1972
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1972
      if (! (Cost < d)) {
#line 1972
        goto while_break___8;
      }
#line 1973
      if (*(min_row + d) <= *(max_row + Cost)) {
#line 1973
        if (max_d > d + Cost) {
#line 1975
          max_d = d + Cost;
#line 1976
          back = d;
#line 1977
          forth = Cost;
#line 1978
          goto while_break___8;
        } else
#line 1973
        if (max_d == d + Cost) {
#line 1973
          if (forth < 0) {
#line 1975
            max_d = d + Cost;
#line 1976
            back = d;
#line 1977
            forth = Cost;
#line 1978
            goto while_break___8;
          }
        }
      }
#line 1972
      Cost ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1982
    blower --;
#line 1982
    bupper ++;
#line 1985
    k = flower;
    {
#line 1985
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1985
      if (! (k <= fupper)) {
#line 1985
        goto while_break___9;
      }
#line 1989
      if (k == - d + F_ORIGIN) {
#line 1991
        row = *(flast_d + (k + 1)) + 1;
      } else
#line 1993
      if (k == d + F_ORIGIN) {
#line 1995
        row = *(flast_d + (k - 1));
      } else
#line 1997
      if (*(flast_d + k) >= *(flast_d + (k + 1))) {
#line 1997
        if (*(flast_d + k) + 1 >= *(flast_d + (k - 1))) {
#line 2001
          row = *(flast_d + k) + 1;
        } else {
#line 1997
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2003
      if (*(flast_d + (k + 1)) + 1 >= *(flast_d + (k - 1))) {
#line 2003
        if (*(flast_d + (k + 1)) >= *(flast_d + k)) {
#line 2007
          row = *(flast_d + (k + 1)) + 1;
        } else {
#line 2010
          row = *(flast_d + (k - 1));
        }
      } else {
#line 2010
        row = *(flast_d + (k - 1));
      }
#line 2013
      col = (row + k) - F_ORIGIN;
#line 2016
      if (row >= 0) {
        {
#line 2017
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2017
          if (row < m) {
#line 2017
            if (col < n) {
#line 2017
              if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 2017
                goto while_break___10;
              }
            } else {
#line 2017
              goto while_break___10;
            }
          } else {
#line 2017
            goto while_break___10;
          }
#line 2018
          row ++;
#line 2019
          col ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 2021
      *(ftemp_d + k) = row;
#line 1985
      k ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2026
    *(max_row + d) = *(ftemp_d + F_ORIGIN);
#line 2027
    *(max_diag + d) = F_ORIGIN;
#line 2028
    k = flower;
    {
#line 2028
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 2028
      if (! (k <= fupper)) {
#line 2028
        goto while_break___11;
      }
#line 2029
      *(flast_d + k) = *(ftemp_d + k);
#line 2029
      *(ftemp_d + k) = -1;
#line 2030
      if (*(flast_d + k) > *(max_row + d)) {
#line 2031
        *(max_row + d) = *(flast_d + k);
#line 2032
        *(max_diag + d) = k;
      }
#line 2028
      k ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 2040
    Cost = 0;
    {
#line 2040
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2040
      if (! (Cost <= d)) {
#line 2040
        goto while_break___12;
      }
#line 2041
      if (*(min_row + Cost) <= *(max_row + d)) {
#line 2041
        if (max_d > d + Cost) {
#line 2043
          max_d = d + Cost;
#line 2044
          back = Cost;
#line 2045
          forth = d;
#line 2046
          goto while_break___12;
        } else
#line 2041
        if (max_d == d + Cost) {
#line 2041
          if (forth < 0) {
#line 2043
            max_d = d + Cost;
#line 2044
            back = Cost;
#line 2045
            forth = d;
#line 2046
            goto while_break___12;
          }
        }
      }
#line 2040
      Cost ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2049
    flower --;
#line 2049
    fupper ++;
#line 2051
    d ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2054
  if (d > MAX_D) {
    {
#line 2055
    tmp___13 = (Exon *)((void *)0);
#line 2055
    *rblock = tmp___13;
#line 2055
    *lblock = tmp___13;
#line 2057
    free((void *)blast_d);
#line 2057
    free((void *)btemp_d);
#line 2058
    free((void *)flast_d);
#line 2058
    free((void *)ftemp_d);
#line 2059
    free((void *)min_row);
#line 2059
    free((void *)min_diag);
#line 2060
    free((void *)max_row);
#line 2060
    free((void *)max_diag);
    }
#line 2062
    return (d);
  }
#line 2065
  if (m - *(min_row + back) >= *(max_row + forth)) {
    {
#line 2066
    *rblock = new_exon((((offset2___0 + 1) + *(min_row + back)) + *(min_diag + back)) - B_ORIGIN,
                       (offset1___0 + 1) + *(min_row + back), offset2___0 + n, offset1___0 + m,
                       m - *(min_row + back), back, 0, (Exon *)((void *)0));
#line 2070
    *lblock = new_exon(offset2___0 + 1, offset1___0 + 1, ((offset2___0 + *(min_row + back)) + *(max_diag + forth)) - F_ORIGIN,
                       offset1___0 + *(min_row + back), *(min_row + back), forth,
                       0, *rblock);
    }
  } else {
    {
#line 2075
    *rblock = new_exon((((offset2___0 + 1) + *(max_row + forth)) + *(min_diag + back)) - B_ORIGIN,
                       (offset1___0 + 1) + *(max_row + forth), offset2___0 + n, offset1___0 + m,
                       m - *(max_row + forth), back, 0, (Exon *)((void *)0));
#line 2078
    *lblock = new_exon(offset2___0 + 1, offset1___0 + 1, ((offset2___0 + *(max_row + forth)) + *(max_diag + forth)) - F_ORIGIN,
                       offset1___0 + *(max_row + forth), *(max_row + forth), forth,
                       0, *rblock);
    }
  }
  {
#line 2083
  free((void *)blast_d);
#line 2083
  free((void *)btemp_d);
#line 2084
  free((void *)flast_d);
#line 2084
  free((void *)ftemp_d);
#line 2085
  free((void *)min_row);
#line 2085
  free((void *)min_diag);
#line 2086
  free((void *)max_row);
#line 2086
  free((void *)max_diag);
  }
#line 2088
  return (back + forth);
}
}
#line 2092 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void flip_list(Exon **left , Exon **right ) 
{ 
  Exon *ep ;
  Exon *ahead ;
  Exon *behind ;

  {
#line 2096
  *right = *left;
#line 2097
  ahead = *left;
#line 2098
  ep = (Exon *)((void *)0);
  {
#line 2099
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2099
    if (! ((unsigned long )ahead != (unsigned long )((void *)0))) {
#line 2099
      goto while_break;
    }
#line 2100
    behind = ep;
#line 2101
    ep = ahead;
#line 2102
    ahead = ahead->next_exon;
#line 2103
    ep->next_exon = behind;
  }
  while_break: /* CIL Label */ ;
  }
#line 2105
  *left = ep;
#line 2106
  return;
}
}
#line 2109 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void script_flip_list(edit_script_list **left ) 
{ 
  edit_script_list *ep ;
  edit_script_list *ahead ;
  edit_script_list *behind ;

  {
#line 2113
  ahead = *left;
#line 2114
  ep = (edit_script_list *)((void *)0);
  {
#line 2115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2115
    if (! ((unsigned long )ahead != (unsigned long )((void *)0))) {
#line 2115
      goto while_break;
    }
#line 2116
    behind = ep;
#line 2116
    ep = ahead;
#line 2117
    ahead = ahead->next_script;
#line 2118
    ep->next_script = behind;
  }
  while_break: /* CIL Label */ ;
  }
#line 2120
  *left = ep;
#line 2121
  return;
}
}
#line 2125 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void compact_list(Exon **Lblock , Exon **Rblock ) 
{ 
  Exon *tmp_block ;
  Exon *tmp_block1 ;
  int diff ;
  int tmp ;

  {
#line 2127
  tmp_block = *Lblock;
  {
#line 2130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2130
    if ((unsigned long )tmp_block != (unsigned long )((void *)0)) {
#line 2130
      tmp_block1 = tmp_block->next_exon;
#line 2130
      if ((unsigned long )tmp_block1 != (unsigned long )((void *)0)) {
#line 2130
        if (! tmp_block1->to1) {
#line 2130
          goto while_break;
        }
      } else {
#line 2130
        goto while_break;
      }
    } else {
#line 2130
      goto while_break;
    }
    {
#line 2133
    tmp = abs((tmp_block1->from2 - tmp_block1->from1) - (tmp_block->to2 - tmp_block->to1));
    }
#line 2133
    if (tmp <= W) {
#line 2133
      diff = (tmp_block1->from2 - tmp_block->to2) - 1;
#line 2133
      if (diff <= 50) {
        {
#line 2137
        tmp_block->to1 = tmp_block1->to1;
#line 2138
        tmp_block->to2 = tmp_block1->to2;
#line 2139
        tmp_block->length = (tmp_block->to2 - tmp_block->from2) + 1;
#line 2140
        tmp_block->edist += tmp_block1->edist;
#line 2141
        tmp_block->edist = (int )((double )tmp_block->edist - .2 * (double )diff);
#line 2142
        tmp_block->next_exon = tmp_block1->next_exon;
#line 2144
        free((void *)tmp_block1);
        }
      } else {
#line 2146
        tmp_block = tmp_block1;
      }
    } else {
#line 2146
      tmp_block = tmp_block1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2149
  *Rblock = tmp_block;
#line 2150
  return;
}
}
#line 2154 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void link_to_data_list(Pointer data , ValNodePtr *head , ValNodePtr *prev ) 
{ 
  ValNodePtr curr ;
  void *tmp ;

  {
  {
#line 2158
  tmp = ckalloc(sizeof(struct ValNode ));
#line 2158
  curr = (ValNodePtr )tmp;
#line 2159
  curr->data = data;
#line 2160
  curr->next = (struct ValNode *)((void *)0);
  }
#line 2162
  if ((unsigned long )*prev == (unsigned long )((void *)0)) {
#line 2163
    *head = curr;
  } else {
#line 2165
    (*prev)->next = curr;
  }
#line 2166
  *prev = curr;
#line 2167
  return;
}
}
#line 2169 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void ValNodeFreeData(ValNodePtr data_list ) 
{ 
  ValNodePtr tmp_node ;

  {
  {
#line 2173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2173
    tmp_node = data_list;
#line 2173
    if (! ((unsigned long )tmp_node != (unsigned long )((void *)0))) {
#line 2173
      goto while_break;
    }
    {
#line 2174
    free(tmp_node->data);
#line 2175
    data_list = data_list->next;
#line 2176
    free((void *)tmp_node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2178
  return;
}
}
#line 2181 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
int good_ratio(int length ) 
{ 


  {
#line 2183
  if (length <= W / 2) {
#line 2183
    return (2);
  } else
#line 2184
  if (length < 2 * W) {
#line 2184
    return (rs.cutoff);
  } else {
#line 2185
    return ((int )((.75 * .2) * (double )length + (double )1));
  }
}
}
#line 2188 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int extend_bw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
                     int *line1 , int *line2 ) 
{ 
  int col ;
  int row ;
  int max_d ;
  int d ;
  int k ;
  int DELTA ;
  int ORIGIN ;
  int lower ;
  int upper ;
  int *last_d ;
  int *temp_d ;
  int *min_row ;
  int *min_diag ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2203
  DELTA = n - m;
#line 2204
  max_d = m + 1;
#line 2206
  ORIGIN = m;
#line 2207
  row = m;
#line 2207
  col = n;
  {
#line 2207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2207
    if (row > 0) {
#line 2207
      if (col > 0) {
#line 2207
        if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 2207
          goto while_break;
        }
      } else {
#line 2207
        goto while_break;
      }
    } else {
#line 2207
      goto while_break;
    }
#line 2207
    row --;
#line 2207
    col --;
  }
  while_break: /* CIL Label */ ;
  }
#line 2210
  if (row == 0) {
#line 2211
    *line1 = row + offset1___0;
#line 2212
    *line2 = col + offset2___0;
#line 2214
    return (0);
  } else
#line 2210
  if (col == 0) {
#line 2211
    *line1 = row + offset1___0;
#line 2212
    *line2 = col + offset2___0;
#line 2214
    return (0);
  }
  {
#line 2217
  tmp = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 2217
  last_d = (int *)tmp;
#line 2218
  tmp___0 = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 2218
  temp_d = (int *)tmp___0;
#line 2220
  k = 0;
  }
  {
#line 2220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2220
    if (! (k <= m + n)) {
#line 2220
      goto while_break___0;
    }
#line 2220
    *(last_d + k) = m + 1;
#line 2220
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2221
  *(last_d + (ORIGIN + DELTA)) = row;
#line 2223
  lower = (ORIGIN + DELTA) - 1;
#line 2224
  upper = (ORIGIN + DELTA) + 1;
#line 2226
  tmp___1 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 2226
  min_row = (int *)tmp___1;
#line 2227
  tmp___2 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 2227
  min_diag = (int *)tmp___2;
#line 2229
  d = 1;
  }
  {
#line 2229
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2229
    if (! (d <= m)) {
#line 2229
      goto while_break___1;
    }
#line 2230
    *(min_row + d) = m + 1;
#line 2229
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2232
  *(min_row + 0) = *(last_d + (ORIGIN + DELTA));
#line 2233
  *(min_diag + 0) = ORIGIN + DELTA;
#line 2235
  d = 0;
  {
#line 2236
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2236
    d ++;
#line 2236
    if (d <= max_d) {
      {
#line 2236
      tmp___3 = good_ratio(m - *(min_row + (d - 1)));
      }
#line 2236
      if (! (d - 1 <= tmp___3)) {
#line 2236
        if (d >= 2) {
          {
#line 2236
          tmp___4 = good_ratio(m - *(min_row + (d - 2)));
          }
#line 2236
          if (! (d - 2 <= tmp___4)) {
#line 2236
            goto while_break___2;
          }
        } else {
#line 2236
          goto while_break___2;
        }
      }
    } else {
#line 2236
      goto while_break___2;
    }
#line 2241
    k = lower;
    {
#line 2241
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2241
      if (! (k <= upper)) {
#line 2241
        goto while_break___3;
      }
#line 2244
      if (k == (- d + DELTA) + ORIGIN) {
#line 2246
        row = *(last_d + (k + 1));
      } else
#line 2249
      if (k == (d + DELTA) + ORIGIN) {
#line 2251
        row = *(last_d + (k - 1)) - 1;
      } else
#line 2254
      if (*(last_d + k) - 1 <= *(last_d + (k + 1))) {
#line 2254
        if (*(last_d + k) - 1 <= *(last_d + (k - 1)) - 1) {
#line 2257
          row = *(last_d + k) - 1;
        } else {
#line 2254
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2260
      if (*(last_d + (k - 1)) - 1 <= *(last_d + (k + 1))) {
#line 2260
        if (*(last_d + (k - 1)) - 1 <= *(last_d + k) - 1) {
#line 2263
          row = *(last_d + (k - 1)) - 1;
        } else {
#line 2268
          row = *(last_d + (k + 1));
        }
      } else {
#line 2268
        row = *(last_d + (k + 1));
      }
#line 2276
      col = (row + k) - ORIGIN;
      {
#line 2278
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2278
        if (row > 0) {
#line 2278
          if (col > 0) {
#line 2278
            if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 2278
              goto while_break___4;
            }
          } else {
#line 2278
            goto while_break___4;
          }
        } else {
#line 2278
          goto while_break___4;
        }
#line 2279
        row --;
#line 2279
        col --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2281
      *(temp_d + k) = row;
#line 2283
      if (row == 0) {
#line 2283
        if (col == 0) {
          {
#line 2286
          free((void *)last_d);
#line 2286
          free((void *)temp_d);
#line 2287
          free((void *)min_row);
#line 2287
          free((void *)min_diag);
#line 2289
          *line1 = row + offset1___0;
#line 2290
          *line2 = col + offset2___0;
          }
#line 2292
          return (d);
        }
      }
#line 2294
      if (row == 0) {
        {
#line 2297
        free((void *)last_d);
#line 2297
        free((void *)temp_d);
#line 2298
        free((void *)min_row);
#line 2298
        free((void *)min_diag);
#line 2300
        *line1 = row + offset1___0;
#line 2301
        *line2 = col + offset2___0;
        }
#line 2303
        return (d);
      }
#line 2306
      if (col == 0) {
        {
#line 2308
        free((void *)last_d);
#line 2308
        free((void *)temp_d);
#line 2309
        free((void *)min_row);
#line 2309
        free((void *)min_diag);
#line 2311
        *line1 = row + offset1___0;
#line 2312
        *line2 = col + offset2___0;
        }
#line 2314
        return (d);
      }
#line 2241
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2318
    *(min_row + d) = *(last_d + (ORIGIN + DELTA));
#line 2319
    *(min_diag + d) = ORIGIN + DELTA;
#line 2320
    k = lower;
    {
#line 2320
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2320
      if (! (k <= upper)) {
#line 2320
        goto while_break___5;
      }
#line 2321
      if (*(temp_d + k) < *(min_row + d)) {
#line 2322
        *(min_row + d) = *(temp_d + k);
#line 2323
        *(min_diag + d) = k;
      }
#line 2320
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2326
    k = lower;
    {
#line 2326
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2326
      if (! (k <= upper)) {
#line 2326
        goto while_break___6;
      }
#line 2327
      *(last_d + k) = *(temp_d + k);
#line 2326
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2330
    lower --;
#line 2331
    upper ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2335
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2335
    if (d > 0) {
#line 2335
      if (! (*(min_row + (d - 1)) - *(min_row + d) < 3)) {
#line 2335
        goto while_break___7;
      }
    } else {
#line 2335
      goto while_break___7;
    }
#line 2336
    d --;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2338
  *line1 = *(min_row + d) + offset1___0;
#line 2339
  *line2 = ((*(min_row + d) + *(min_diag + d)) - ORIGIN) + offset2___0;
#line 2341
  free((void *)min_row);
#line 2342
  free((void *)min_diag);
#line 2343
  free((void *)last_d);
#line 2344
  free((void *)temp_d);
  }
#line 2346
  return (d);
}
}
#line 2350 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static int extend_fw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
                     int *line1 , int *line2 ) 
{ 
  int col ;
  int row ;
  int max_d ;
  int d ;
  int k ;
  int ORIGIN ;
  int lower ;
  int upper ;
  int *last_d ;
  int *temp_d ;
  int *max_row ;
  int *max_diag ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2364
  max_d = m + 1;
#line 2366
  ORIGIN = m;
#line 2367
  row = 0;
#line 2367
  col = 0;
  {
#line 2367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2367
    if (col < n) {
#line 2367
      if (row < m) {
#line 2367
        if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 2367
          goto while_break;
        }
      } else {
#line 2367
        goto while_break;
      }
    } else {
#line 2367
      goto while_break;
    }
#line 2367
    row ++;
#line 2367
    col ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2370
  if (row == m) {
#line 2371
    *line1 = row + offset1___0;
#line 2372
    *line2 = col + offset2___0;
#line 2374
    return (0);
  }
#line 2376
  if (col == n) {
#line 2377
    *line1 = row + offset1___0;
#line 2378
    *line2 = col + offset2___0;
#line 2380
    return (0);
  }
  {
#line 2383
  tmp = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 2383
  last_d = (int *)tmp;
#line 2384
  tmp___0 = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 2384
  temp_d = (int *)tmp___0;
#line 2386
  k = 0;
  }
  {
#line 2386
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2386
    if (! (k <= m + n)) {
#line 2386
      goto while_break___0;
    }
#line 2386
    *(last_d + k) = -1;
#line 2386
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2387
  *(last_d + ORIGIN) = row;
#line 2389
  lower = ORIGIN - 1;
#line 2390
  upper = ORIGIN + 1;
#line 2392
  tmp___1 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 2392
  max_row = (int *)tmp___1;
#line 2393
  tmp___2 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 2393
  max_diag = (int *)tmp___2;
#line 2395
  d = 1;
  }
  {
#line 2395
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2395
    if (! (d <= m)) {
#line 2395
      goto while_break___1;
    }
#line 2396
    *(max_row + d) = -1;
#line 2395
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2398
  *(max_row + 0) = *(last_d + ORIGIN);
#line 2399
  *(max_diag + 0) = ORIGIN;
#line 2402
  d = 0;
  {
#line 2403
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2403
    d ++;
#line 2403
    if (d <= max_d) {
      {
#line 2403
      tmp___3 = good_ratio(*(max_row + (d - 1)));
      }
#line 2403
      if (! (d - 1 <= tmp___3)) {
#line 2403
        if (d >= 2) {
          {
#line 2403
          tmp___4 = good_ratio(*(max_row + (d - 2)));
          }
#line 2403
          if (! (d - 2 <= tmp___4)) {
#line 2403
            goto while_break___2;
          }
        } else {
#line 2403
          goto while_break___2;
        }
      }
    } else {
#line 2403
      goto while_break___2;
    }
#line 2408
    k = lower;
    {
#line 2408
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2408
      if (! (k <= upper)) {
#line 2408
        goto while_break___3;
      }
#line 2411
      if (k == - d + ORIGIN) {
#line 2414
        row = *(last_d + (k + 1)) + 1;
      } else
#line 2416
      if (k == d + ORIGIN) {
#line 2419
        row = *(last_d + (k - 1));
      } else
#line 2421
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 2421
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 2425
          row = *(last_d + k) + 1;
        } else {
#line 2421
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2427
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 2427
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 2431
          row = *(last_d + (k + 1)) + 1;
        } else {
#line 2436
          row = *(last_d + (k - 1));
        }
      } else {
#line 2436
        row = *(last_d + (k - 1));
      }
#line 2443
      col = (row + k) - ORIGIN;
#line 2445
      if (row >= 0) {
        {
#line 2446
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2446
          if (row < m) {
#line 2446
            if (col < n) {
#line 2446
              if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 2446
                goto while_break___4;
              }
            } else {
#line 2446
              goto while_break___4;
            }
          } else {
#line 2446
            goto while_break___4;
          }
#line 2447
          row ++;
#line 2447
          col ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 2449
      *(temp_d + k) = row;
#line 2451
      if (row == m) {
#line 2451
        if (col == n) {
          {
#line 2453
          free((void *)last_d);
#line 2453
          free((void *)temp_d);
#line 2454
          free((void *)max_row);
#line 2454
          free((void *)max_diag);
#line 2455
          *line1 = row + offset1___0;
#line 2456
          *line2 = col + offset2___0;
          }
#line 2458
          return (d);
        }
      }
#line 2460
      if (row == m) {
        {
#line 2462
        free((void *)temp_d);
#line 2462
        free((void *)last_d);
#line 2463
        free((void *)max_row);
#line 2463
        free((void *)max_diag);
#line 2465
        *line1 = row + offset1___0;
#line 2466
        *line2 = col + offset2___0;
        }
#line 2468
        return (d);
      }
#line 2471
      if (col == n) {
        {
#line 2473
        free((void *)temp_d);
#line 2473
        free((void *)last_d);
#line 2474
        free((void *)max_row);
#line 2474
        free((void *)max_diag);
#line 2476
        *line1 = row + offset1___0;
#line 2477
        *line2 = col + offset2___0;
        }
#line 2479
        return (d);
      }
#line 2408
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2482
    *(max_row + d) = *(last_d + ORIGIN);
#line 2483
    *(max_diag + d) = ORIGIN;
#line 2484
    k = lower;
    {
#line 2484
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2484
      if (! (k <= upper)) {
#line 2484
        goto while_break___5;
      }
#line 2485
      if (*(temp_d + k) > *(max_row + d)) {
#line 2486
        *(max_row + d) = *(temp_d + k);
#line 2487
        *(max_diag + d) = k;
      }
#line 2484
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2490
    k = lower;
    {
#line 2490
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2490
      if (! (k <= upper)) {
#line 2490
        goto while_break___6;
      }
#line 2491
      *(last_d + k) = *(temp_d + k);
#line 2490
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2494
    lower --;
#line 2495
    upper ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2500
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2500
    if (d > 0) {
#line 2500
      if (! (*(max_row + d) - *(max_row + (d - 1)) < 3)) {
#line 2500
        goto while_break___7;
      }
    } else {
#line 2500
      goto while_break___7;
    }
#line 2501
    d --;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2503
  *line1 = *(max_row + d) + offset1___0;
#line 2504
  *line2 = ((*(max_row + d) + *(max_diag + d)) - ORIGIN) + offset2___0;
#line 2506
  free((void *)max_row);
#line 2507
  free((void *)max_diag);
#line 2508
  free((void *)last_d);
#line 2509
  free((void *)temp_d);
  }
#line 2511
  return (d);
}
}
#line 2536 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void merge(Exon **t0 , Exon **t1 ) 
{ 
  Exon *tmp0 ;
  Exon *tmp1 ;
  int diff ;
  int tmp ;

  {
#line 2541
  if (*t0) {
#line 2541
    if (! (*t0)->to1) {
#line 2542
      tmp0 = (*t0)->next_exon;
    } else {
#line 2544
      tmp0 = *t0;
    }
  } else {
#line 2544
    tmp0 = *t0;
  }
  {
#line 2546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2546
    if (tmp0) {
#line 2546
      if (! ((unsigned long )tmp0 != (unsigned long )*t1)) {
#line 2546
        goto while_break;
      }
    } else {
#line 2546
      goto while_break;
    }
#line 2547
    tmp1 = tmp0->next_exon;
#line 2548
    if (! ((unsigned long )tmp1 != (unsigned long )((void *)0))) {
      {
#line 2548
      __assert_fail("tmp1!=((void *)0)", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c",
                    2548U, "merge");
      }
    }
#line 2549
    if (tmp1) {
#line 2549
      if (tmp1->to1) {
#line 2549
        if (tmp0->to1) {
          {
#line 2549
          tmp = abs((tmp1->from2 - tmp1->from1) - (tmp0->to2 - tmp0->to1));
          }
#line 2549
          if (tmp <= W) {
#line 2549
            diff = (tmp1->from2 - tmp0->to2) - 1 <= W;
#line 2549
            if (diff) {
#line 2554
              if (tmp0->from1 > tmp1->from1) {
#line 2554
                tmp0->from1 = tmp1->from1;
              } else {
#line 2554
                tmp0->from1 = tmp0->from1;
              }
#line 2555
              if (tmp0->from2 > tmp1->from2) {
#line 2555
                tmp0->from2 = tmp1->from2;
              } else {
#line 2555
                tmp0->from2 = tmp0->from2;
              }
#line 2556
              if (tmp1->to1 < tmp0->to1) {
#line 2556
                tmp0->to1 = tmp0->to1;
              } else {
#line 2556
                tmp0->to1 = tmp1->to1;
              }
#line 2557
              if (tmp1->to2 < tmp0->to2) {
#line 2557
                tmp0->to2 = tmp0->to2;
              } else {
#line 2557
                tmp0->to2 = tmp1->to2;
              }
#line 2558
              tmp0->length = (tmp0->to2 - tmp0->from2) + 1;
#line 2559
              tmp0->flag = tmp1->flag;
#line 2560
              tmp0->edist += tmp1->edist;
#line 2561
              tmp0->edist = (int )((double )tmp0->edist - .2 * (double )diff);
#line 2562
              if ((unsigned long )tmp1 == (unsigned long )*t1) {
#line 2564
                *t1 = tmp0;
              }
              {
#line 2566
              tmp0->next_exon = tmp1->next_exon;
#line 2568
              free((void *)tmp1);
              }
            } else {
#line 2570
              tmp0 = tmp0->next_exon;
            }
          } else {
#line 2570
            tmp0 = tmp0->next_exon;
          }
        } else {
#line 2570
          tmp0 = tmp0->next_exon;
        }
      } else {
#line 2570
        tmp0 = tmp0->next_exon;
      }
    } else {
#line 2570
      tmp0 = tmp0->next_exon;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2572
  return;
}
}
#line 2574 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void free_align(edit_script_list *aligns ) 
{ 
  edit_script_list *head ;

  {
#line 2578
  head = aligns;
  {
#line 2580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2580
    head = aligns;
#line 2580
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 2580
      goto while_break;
    }
    {
#line 2581
    aligns = aligns->next_script;
#line 2582
    Free_script(head->script);
#line 2583
    free((void *)head);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2585
  return;
}
}
#line 2588 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void free_list(Exon *left ) 
{ 
  Exon *tmp_block ;

  {
  {
#line 2592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2592
    tmp_block = left;
#line 2592
    if (! ((unsigned long )tmp_block != (unsigned long )((void *)0))) {
#line 2592
      goto while_break;
    }
    {
#line 2593
    left = left->next_exon;
#line 2594
    free((void *)tmp_block);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2596
  return;
}
}
#line 2598 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void free_table(void) 
{ 
  register struct hash_node *hptr ;
  register struct hash_node *tptr ;
  register int hval ;

  {
  {
#line 2603
  free((void *)pnext_pos);
#line 2604
  hval = 0;
  }
  {
#line 2604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2604
    if (! (hval < 32768)) {
#line 2604
      goto while_break;
    }
#line 2605
    hptr = phashtab[hval];
    {
#line 2606
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2606
      if (! hptr) {
#line 2606
        goto while_break___0;
      }
      {
#line 2607
      tptr = hptr;
#line 2608
      hptr = hptr->link;
#line 2609
      free((void *)tptr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2604
    hval ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2612
  return;
}
}
#line 2614 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static Exon *bmatch(uchar *s1 , uchar *s2 , int len1 , int len2 , int offset1___0 ,
                    int offset2___0 ) 
{ 
  int i ;
  int j ;
  int i1 ;
  int score ;
  Exon *new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;

  {
#line 2617
  new = (Exon *)((void *)0);
#line 2619
  i = len1 - 3;
#line 2619
  i1 = i;
  {
#line 2619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2619
    if (! (i >= len2 - 3)) {
#line 2619
      goto while_break;
    }
#line 2620
    j = len2 - 3;
    {
#line 2620
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2620
      if (! (j >= 2)) {
#line 2620
        goto while_break___0;
      }
#line 2621
      if ((int )*(s1 + i1) != (int )*(s2 + j)) {
#line 2622
        goto while_break___0;
      }
#line 2620
      j --;
#line 2620
      i1 --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2624
    if (j < 2) {
#line 2626
      score = 0;
#line 2627
      tmp = i1;
#line 2627
      i1 --;
#line 2627
      tmp___0 = j;
#line 2627
      j --;
#line 2627
      if ((int )*(s1 + tmp) == (int )*(s2 + tmp___0)) {
#line 2627
        score ++;
      }
#line 2628
      tmp___1 = i1;
#line 2628
      i1 --;
#line 2628
      tmp___2 = j;
#line 2628
      j --;
#line 2628
      if ((int )*(s1 + tmp___1) == (int )*(s2 + tmp___2)) {
#line 2628
        score ++;
      }
#line 2629
      if ((int )*(((s1 + i1) + len2) - 1) == (int )*(((s2 + j) + len2) - 1)) {
#line 2629
        score ++;
      }
#line 2630
      if ((int )*((s1 + i1) + len2) == (int )*((s2 + j) + len2)) {
#line 2630
        score ++;
      }
#line 2631
      if (score >= 3) {
        {
#line 2632
        new = new_exon((i1 + 3) + offset1___0, offset2___0, (((i1 + 3) + offset1___0) + len2) - 5,
                       (offset2___0 + len2) - 5, len2 - 4, 0, 0, (Exon *)((void *)0));
#line 2634
        tmp___4 = abs(C_score);
        }
#line 2634
        if (G_score >= tmp___4) {
#line 2634
          new->ori = (char )'G';
        } else {
#line 2634
          new->ori = (char )'C';
        }
#line 2636
        return (new);
      }
    }
#line 2619
    i --;
#line 2619
    i1 = i;
  }
  while_break: /* CIL Label */ ;
  }
#line 2640
  return ((Exon *)((void *)0));
}
}
#line 2643 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static Exon *fmatch(uchar *s1 , uchar *s2 , int len1 , int len2 , int offset1___0 ,
                    int offset2___0 ) 
{ 
  int i ;
  int j ;
  int i1 ;
  int score ;
  Exon *new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;

  {
#line 2646
  new = (Exon *)((void *)0);
#line 2648
  i = 2;
#line 2648
  i1 = i;
  {
#line 2648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2648
    if (! (i < (len1 - len2) + 3)) {
#line 2648
      goto while_break;
    }
#line 2649
    j = 2;
    {
#line 2649
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2649
      if (! (j < len2 - 2)) {
#line 2649
        goto while_break___0;
      }
#line 2650
      if ((int )*(s1 + i1) != (int )*(s2 + j)) {
#line 2651
        goto while_break___0;
      }
#line 2649
      j ++;
#line 2649
      i1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2653
    if (j >= len2 - 2) {
#line 2655
      score = 0;
#line 2656
      tmp = i1;
#line 2656
      i1 ++;
#line 2656
      tmp___0 = j;
#line 2656
      j ++;
#line 2656
      if ((int )*(s1 + tmp) == (int )*(s2 + tmp___0)) {
#line 2656
        score ++;
      }
#line 2657
      tmp___1 = i1;
#line 2657
      i1 ++;
#line 2657
      tmp___2 = j;
#line 2657
      j ++;
#line 2657
      if ((int )*(s1 + tmp___1) == (int )*(s2 + tmp___2)) {
#line 2657
        score ++;
      }
#line 2658
      if ((int )*((s1 + i1) - len2) == (int )*s2) {
#line 2658
        score ++;
      }
#line 2659
      if ((int )*(((s1 + i1) - len2) + 1) == (int )*(s2 + 1)) {
#line 2659
        score ++;
      }
#line 2660
      if (score >= 3) {
        {
#line 2661
        new = new_exon(i + offset1___0, offset2___0, (i1 + offset1___0) - 2, (offset2___0 + len2) - 5,
                       len2 - 4, 0, 0, (Exon *)((void *)0));
#line 2663
        tmp___4 = abs(C_score);
        }
#line 2663
        if (G_score >= tmp___4) {
#line 2663
          new->ori = (char )'G';
        } else {
#line 2663
          new->ori = (char )'C';
        }
#line 2665
        return (new);
      }
    }
#line 2648
    i ++;
#line 2648
    i1 = i;
  }
  while_break: /* CIL Label */ ;
  }
#line 2669
  return ((Exon *)((void *)0));
}
}
#line 2689 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
void seq_toupper(uchar *seq , int len , char *filename ) 
{ 
  int i ;
  int flag ;
  uchar *s ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2691
  i = 0;
#line 2691
  flag = 0;
#line 2692
  s = seq;
  {
#line 2694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2694
    if (*s) {
#line 2694
      if (100 > len) {
#line 2694
        tmp___0 = len;
      } else {
#line 2694
        tmp___0 = 100;
      }
#line 2694
      if (! (i < tmp___0)) {
#line 2694
        goto while_break;
      }
    } else {
#line 2694
      goto while_break;
    }
    {
#line 2695
    tmp = __ctype_b_loc();
    }
#line 2695
    if ((int const   )*(*tmp + (int )*s) & 512) {
#line 2695
      flag = 1;
#line 2695
      goto while_break;
    }
#line 2694
    i ++;
#line 2694
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2697
  if (flag) {
    {
#line 2698
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: lowercase letter in %s data. Convert sequence to uppercase.\n",
            filename);
#line 2699
    s = seq;
#line 2699
    i = 0;
    }
    {
#line 2699
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2699
      if (*s) {
#line 2699
        if (! (i < len)) {
#line 2699
          goto while_break___0;
        }
      } else {
#line 2699
        goto while_break___0;
      }
      {
#line 2700
      tmp___1 = toupper((int )*s);
#line 2700
      *s = (uchar )tmp___1;
#line 2699
      s ++;
#line 2699
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2702
  return;
}
}
#line 2704 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static bool get_sync_flag(Exon *lblock , Exon *rblock , int w ) 
{ 
  int numx ;
  int e2 ;
  Exon *t ;
  int tmp ;

  {
#line 2706
  numx = 0;
#line 2709
  t = lblock->next_exon;
#line 2709
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 2709
    return (0);
  } else
#line 2709
  if (! t->to1) {
#line 2709
    return (0);
  }
#line 2710
  numx ++;
#line 2710
  e2 = t->to2;
  {
#line 2712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2712
    t = t->next_exon;
#line 2712
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 2712
      if (! t->to1) {
#line 2712
        goto while_break;
      }
    } else {
#line 2712
      goto while_break;
    }
#line 2713
    numx ++;
#line 2714
    if (t->from2 - e2 > 1) {
#line 2716
      return (0);
    } else
#line 2714
    if ((unsigned long )t != (unsigned long )rblock) {
#line 2714
      if ((t->to2 - t->from2) + 1 < 2 * w + 2) {
#line 2716
        return (0);
      } else
#line 2714
      if ((t->to1 - t->from1) + 1 < 2 * w + 2) {
#line 2716
        return (0);
      }
    }
#line 2717
    e2 = t->to2;
  }
  while_break: /* CIL Label */ ;
  }
#line 2719
  if (numx < 3) {
#line 2719
    tmp = 0;
  } else {
#line 2719
    tmp = 1;
  }
#line 2719
  return (tmp);
}
}
#line 2723 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void sync_slide_intron(int in_w , Exon **lblock , uchar *seq1___0 , uchar *seq2___0 ) 
{ 
  Exon *t0 ;
  Exon *t1 ;
  Exon *head ;
  splice_t *g ;
  splice_t *c ;
  splice_t *cell ;
  splice_t *Glist[500] ;
  splice_t *Clist[500] ;
  int Gscore ;
  int Cscore ;
  char oris[500] ;
  int w1 ;
  int w2 ;
  int ni ;
  int i ;
  int numC ;
  int numG ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 2725
  t0 = (Exon *)((void *)0);
#line 2725
  t1 = (Exon *)((void *)0);
#line 2725
  head = *lblock;
#line 2726
  g = (splice_t *)((void *)0);
#line 2726
  c = (splice_t *)((void *)0);
#line 2726
  cell = (splice_t *)((void *)0);
#line 2728
  Gscore = 0;
#line 2728
  Cscore = 0;
#line 2732
  memset((void *)(Glist), 0, 200UL * sizeof(splice_t *));
#line 2733
  memset((void *)(Clist), 0, 200UL * sizeof(splice_t *));
#line 2735
  ni = 0;
#line 2735
  numC = 0;
#line 2735
  numG = numC;
#line 2738
  t0 = head->next_exon;
  }
  {
#line 2739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2739
    if (t0) {
#line 2739
      t1 = t0->next_exon;
#line 2739
      if (t1) {
#line 2739
        if (! t1->to1) {
#line 2739
          goto while_break;
        }
      } else {
#line 2739
        goto while_break;
      }
    } else {
#line 2739
      goto while_break;
    }
#line 2740
    c = (splice_t *)((void *)0);
#line 2740
    g = c;
#line 2741
    if ((t1->from2 - t0->to2) - 1 == 0) {
      {
#line 2742
      tmp___7 = strncmp((char const   *)((char *)(seq1___0 + t0->to1)), "GT", (size_t )2);
      }
#line 2742
      if (tmp___7) {
        _L___0: /* CIL Label */ 
        {
#line 2748
        tmp___5 = strncmp((char const   *)((char *)(seq1___0 + t0->to1)), "CT", (size_t )2);
        }
#line 2748
        if (tmp___5) {
          _L: /* CIL Label */ 
#line 2755
          if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2755
            tmp___1 = t0->to1 - t0->from1;
          } else {
#line 2755
            tmp___1 = t0->length - 1;
          }
#line 2755
          if (in_w > tmp___1) {
#line 2755
            if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2755
              tmp___0 = t0->to1 - t0->from1;
            } else {
#line 2755
              tmp___0 = t0->length - 1;
            }
#line 2755
            w1 = tmp___0;
          } else {
#line 2755
            w1 = in_w;
          }
#line 2756
          if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2756
            tmp___4 = t1->to1 - t1->from1;
          } else {
#line 2756
            tmp___4 = t1->length - 1;
          }
#line 2756
          if (in_w > tmp___4) {
#line 2756
            if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2756
              tmp___3 = t1->to1 - t1->from1;
            } else {
#line 2756
              tmp___3 = t1->length - 1;
            }
#line 2756
            w2 = tmp___3;
          } else {
#line 2756
            w2 = in_w;
          }
          {
#line 2757
          splice(seq1___0, t0->to1 - w1, t0->to1 + w1, t1->from1 - w2, t1->from1 + w2,
                 seq2___0, t0->to2 - w1, t1->from2 + w2, & g, & c, 2);
#line 2760
          Gscore += g->score;
#line 2760
          Cscore += c->score;
#line 2761
          cell = (splice_t *)((void *)0);
#line 2761
          oris[ni] = (char )'*';
          }
#line 2762
          if (g->score > c->score) {
#line 2763
            numG ++;
#line 2763
            cell = g;
#line 2763
            oris[ni] = (char )'G';
          } else
#line 2764
          if (c->score > g->score) {
#line 2765
            numC ++;
#line 2765
            cell = c;
#line 2765
            oris[ni] = (char )'C';
          } else
#line 2766
          if (c->score == g->score) {
#line 2767
            numG ++;
#line 2767
            numC ++;
#line 2767
            cell = g;
#line 2767
            oris[ni] = (char )'G';
          }
#line 2769
          t0->ori = oris[ni];
#line 2770
          t0->to1 = cell->xs;
#line 2770
          t0->to2 = cell->ys;
#line 2771
          t1->from1 = cell->xe;
#line 2771
          t1->from2 = cell->ye;
#line 2772
          t0->length = (t0->to2 - t0->from2) + 1;
#line 2773
          t1->length = (t1->to2 - t1->from2) + 1;
        } else {
          {
#line 2748
          tmp___6 = strncmp((char const   *)((char *)((seq1___0 + t1->from1) - 3)),
                            "AC", (size_t )2);
          }
#line 2748
          if (tmp___6) {
#line 2748
            goto _L;
          } else {
            {
#line 2750
            c = new_splice((char )'C', t0->to1, t1->from1, t0->to2, t1->from2, -1,
                           (splice_t *)((void *)0));
#line 2751
            t0->ori = (char )'C';
#line 2752
            oris[ni] = (char )'C';
#line 2753
            numC ++;
            }
          }
        }
      } else {
        {
#line 2742
        tmp___8 = strncmp((char const   *)((char *)((seq1___0 + t1->from1) - 3)),
                          "AG", (size_t )2);
        }
#line 2742
        if (tmp___8) {
#line 2742
          goto _L___0;
        } else {
          {
#line 2744
          g = new_splice((char )'G', t0->to1, t1->from1, t0->to2, t1->from2, -1, (splice_t *)((void *)0));
#line 2745
          t0->ori = (char )'G';
#line 2746
          oris[ni] = (char )'G';
#line 2747
          numG ++;
          }
        }
      }
#line 2775
      Clist[ni] = c;
#line 2775
      Glist[ni] = g;
    } else {
#line 2777
      t0->ori = (char )'E';
#line 2777
      oris[ni] = (char )'E';
    }
#line 2779
    ni ++;
#line 2780
    t0 = t1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2792
  if (numG == 1) {
#line 2792
    if (numC == 1) {
#line 2792
      if (! Glist[0]) {
#line 2793
        goto free_all;
      } else
#line 2792
      if (! Clist[0]) {
#line 2793
        goto free_all;
      } else
#line 2792
      if (! Glist[1]) {
#line 2793
        goto free_all;
      } else
#line 2792
      if (! Clist[1]) {
#line 2793
        goto free_all;
      }
    }
  }
#line 2795
  if (numG >= numC) {
#line 2797
    i = 0;
#line 2797
    t0 = head->next_exon;
    {
#line 2797
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2797
      if (! (i < ni)) {
#line 2797
        goto while_break___0;
      }
#line 2798
      t1 = t0->next_exon;
      {
#line 2800
      if ((int )oris[i] == 71) {
#line 2800
        goto case_71;
      }
#line 2801
      if ((int )oris[i] == 67) {
#line 2801
        goto case_67;
      }
#line 2817
      if ((int )oris[i] == 69) {
#line 2817
        goto case_69;
      }
#line 2818
      goto switch_default;
      case_71: /* CIL Label */ 
#line 2800
      goto switch_break;
      case_67: /* CIL Label */ 
#line 2801
      if ((unsigned long )Glist[i] == (unsigned long )((void *)0)) {
#line 2803
        if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2803
          tmp___11 = t0->to1 - t0->from1;
        } else {
#line 2803
          tmp___11 = t0->length - 1;
        }
#line 2803
        if (in_w > tmp___11) {
#line 2803
          if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2803
            tmp___10 = t0->to1 - t0->from1;
          } else {
#line 2803
            tmp___10 = t0->length - 1;
          }
#line 2803
          w1 = tmp___10;
        } else {
#line 2803
          w1 = in_w;
        }
#line 2804
        if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2804
          tmp___14 = t1->to1 - t1->from1;
        } else {
#line 2804
          tmp___14 = t1->length - 1;
        }
#line 2804
        if (in_w > tmp___14) {
#line 2804
          if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2804
            tmp___13 = t1->to1 - t1->from1;
          } else {
#line 2804
            tmp___13 = t1->length - 1;
          }
#line 2804
          w2 = tmp___13;
        } else {
#line 2804
          w2 = in_w;
        }
        {
#line 2805
        splice(seq1___0, t0->to1 - w1, t0->to1 + w1, t1->from1 - w2, t1->from1 + w2,
               seq2___0, t0->to2 - w1, t1->from2 + w2, & g, & c, 0);
        }
      } else {
#line 2808
        g = Glist[i];
      }
#line 2810
      t0->ori = (char )'G';
#line 2811
      t0->to1 = g->xs;
#line 2811
      t0->to2 = g->ys;
#line 2812
      t1->from1 = g->xe;
#line 2812
      t1->from2 = g->ye;
#line 2813
      t0->length = (t0->to2 - t0->from2) + 1;
#line 2814
      t1->length = (t1->to2 - t1->from2) + 1;
#line 2816
      goto switch_break;
      case_69: /* CIL Label */ 
#line 2817
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2818
      fatal("sim4b1.c: intron orientation not initialized.");
      }
      switch_break: /* CIL Label */ ;
      }
#line 2820
      if ((int )oris[i] != 69) {
        {
#line 2820
        wobble(& t0, & t1, "GT", "AG", seq1___0);
        }
      }
#line 2797
      i ++;
#line 2797
      t0 = t1;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 2824
    i = 0;
#line 2824
    t0 = head->next_exon;
    {
#line 2824
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2824
      if (! (i < ni)) {
#line 2824
        goto while_break___1;
      }
#line 2825
      t1 = t0->next_exon;
      {
#line 2827
      if ((int )oris[i] == 67) {
#line 2827
        goto case_67___0;
      }
#line 2828
      if ((int )oris[i] == 71) {
#line 2828
        goto case_71___0;
      }
#line 2843
      if ((int )oris[i] == 69) {
#line 2843
        goto case_69___0;
      }
#line 2844
      goto switch_default___0;
      case_67___0: /* CIL Label */ 
#line 2827
      goto switch_break___0;
      case_71___0: /* CIL Label */ 
#line 2828
      if ((unsigned long )Clist[i] == (unsigned long )((void *)0)) {
#line 2830
        if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2830
          tmp___17 = t0->to1 - t0->from1;
        } else {
#line 2830
          tmp___17 = t0->length - 1;
        }
#line 2830
        if (in_w > tmp___17) {
#line 2830
          if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2830
            tmp___16 = t0->to1 - t0->from1;
          } else {
#line 2830
            tmp___16 = t0->length - 1;
          }
#line 2830
          w1 = tmp___16;
        } else {
#line 2830
          w1 = in_w;
        }
#line 2831
        if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2831
          tmp___20 = t1->to1 - t1->from1;
        } else {
#line 2831
          tmp___20 = t1->length - 1;
        }
#line 2831
        if (in_w > tmp___20) {
#line 2831
          if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2831
            tmp___19 = t1->to1 - t1->from1;
          } else {
#line 2831
            tmp___19 = t1->length - 1;
          }
#line 2831
          w2 = tmp___19;
        } else {
#line 2831
          w2 = in_w;
        }
        {
#line 2832
        splice(seq1___0, t0->to1 - w1, t0->to1 + w1, t1->from1 - w2, t1->from1 + w2,
               seq2___0, t0->to2 - w1, t1->from2 + w2, & g, & c, 1);
        }
      } else {
#line 2835
        c = Clist[i];
      }
#line 2837
      t0->ori = (char )'C';
#line 2838
      t0->to1 = c->xs;
#line 2838
      t0->to2 = c->ys;
#line 2839
      t1->from1 = c->xe;
#line 2839
      t1->from2 = c->ye;
#line 2840
      t0->length = (t0->to2 - t0->from2) + 1;
#line 2841
      t1->length = (t1->to2 - t1->from2) + 1;
#line 2842
      goto switch_break___0;
      case_69___0: /* CIL Label */ 
#line 2843
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 2844
      fatal("sim4b1.c: intron orientation not initialized.");
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 2846
      if ((int )oris[i] != 69) {
        {
#line 2846
        wobble(& t0, & t1, "CT", "AC", seq1___0);
        }
      }
#line 2824
      i ++;
#line 2824
      t0 = t1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  free_all: 
#line 2852
  i = 0;
  {
#line 2852
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2852
    if (! (i < ni)) {
#line 2852
      goto while_break___2;
    }
#line 2853
    if (Glist[i]) {
      {
#line 2853
      free((void *)Glist[i]);
      }
    }
#line 2854
    if (Clist[i]) {
      {
#line 2854
      free((void *)Clist[i]);
      }
    }
#line 2852
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2856
  return;
}
}
#line 2859 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void wobble(Exon **t0 , Exon **t1 , char const   *donor , char const   *acceptor ,
                   uchar *seq1___0 ) 
{ 
  uchar *s ;
  uchar *q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 2861
  s = seq1___0 + (*t0)->to1;
#line 2862
  q = (seq1___0 + (*t1)->from1) - 3;
#line 2864
  tmp___12 = strncmp((char const   *)((char *)s), donor, (size_t )2);
  }
#line 2864
  if (tmp___12) {
    {
#line 2874
    tmp___11 = strncmp((char const   *)((char *)(s - 1)), donor, (size_t )2);
    }
#line 2874
    if (tmp___11) {
      {
#line 2887
      tmp___10 = strncmp((char const   *)((char *)(s + 1)), donor, (size_t )2);
      }
#line 2887
      if (tmp___10) {
        {
#line 2899
        tmp___9 = strncmp((char const   *)((char *)(q - 1)), acceptor, (size_t )2);
        }
#line 2899
        if (tmp___9) {
          {
#line 2903
          tmp___8 = strncmp((char const   *)((char *)(q + 1)), acceptor, (size_t )2);
          }
#line 2903
          if (! tmp___8) {
#line 2905
            ((*t1)->from1) ++;
#line 2905
            return;
          }
        } else {
#line 2901
          ((*t1)->from1) --;
#line 2901
          return;
        }
      } else {
        {
#line 2889
        tmp___7 = strncmp((char const   *)((char *)q), acceptor, (size_t )2);
        }
#line 2889
        if (tmp___7) {
          {
#line 2891
          tmp___6 = strncmp((char const   *)((char *)(q - 1)), acceptor, (size_t )2);
          }
#line 2891
          if (tmp___6) {
            {
#line 2893
            tmp___5 = strncmp((char const   *)((char *)(q + 1)), acceptor, (size_t )2);
            }
#line 2893
            if (! tmp___5) {
#line 2894
              ((*t0)->to1) ++;
#line 2894
              ((*t1)->from1) ++;
#line 2895
              ((*t0)->to2) ++;
#line 2895
              ((*t1)->from2) ++;
#line 2896
              ((*t0)->length) --;
#line 2896
              ((*t1)->length) ++;
#line 2897
              return;
            }
          } else {
#line 2892
            ((*t0)->to1) ++;
#line 2892
            ((*t1)->from1) --;
#line 2892
            return;
          }
        } else {
#line 2890
          ((*t0)->to1) ++;
#line 2890
          return;
        }
      }
    } else {
      {
#line 2876
      tmp___4 = strncmp((char const   *)((char *)q), acceptor, (size_t )2);
      }
#line 2876
      if (tmp___4) {
        {
#line 2878
        tmp___3 = strncmp((char const   *)((char *)(q - 1)), acceptor, (size_t )2);
        }
#line 2878
        if (tmp___3) {
          {
#line 2883
          tmp___2 = strncmp((char const   *)((char *)(q + 1)), acceptor, (size_t )2);
          }
#line 2883
          if (! tmp___2) {
#line 2884
            ((*t0)->to1) --;
#line 2884
            ((*t1)->from1) ++;
#line 2884
            return;
          }
        } else {
#line 2879
          ((*t0)->to1) --;
#line 2879
          ((*t1)->from1) --;
#line 2880
          ((*t0)->to2) --;
#line 2880
          ((*t1)->from2) --;
#line 2881
          ((*t0)->length) ++;
#line 2881
          ((*t1)->length) --;
#line 2882
          return;
        }
      } else {
#line 2877
        ((*t0)->to1) --;
#line 2877
        return;
      }
    }
  } else {
    {
#line 2866
    tmp___1 = strncmp((char const   *)((char *)q), acceptor, (size_t )2);
    }
#line 2866
    if (tmp___1) {
      {
#line 2868
      tmp___0 = strncmp((char const   *)((char *)(q - 1)), acceptor, (size_t )2);
      }
#line 2868
      if (tmp___0) {
        {
#line 2870
        tmp = strncmp((char const   *)((char *)(q + 1)), acceptor, (size_t )2);
        }
#line 2870
        if (! tmp) {
#line 2871
          ((*t1)->from1) ++;
#line 2871
          return;
        }
      } else {
#line 2869
        ((*t1)->from1) --;
#line 2869
        return;
      }
    } else {
#line 2867
      return;
    }
  }
#line 2908
  return;
}
}
#line 2911 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static void slide_intron(int in_w , Exon **lblock , uchar *seq1___0 , uchar *seq2___0 ) 
{ 
  Exon *t0 ;
  Exon *t1 ;
  Exon *head ;
  splice_t *g ;
  splice_t *c ;
  splice_t *cell ;
  char type ;
  int w1 ;
  int w2 ;
  int gtag ;
  int ctac ;
  uchar *s ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 2913
  head = *lblock;
#line 2918
  t0 = head->next_exon;
  {
#line 2919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2919
    if (t0) {
#line 2919
      t1 = t0->next_exon;
#line 2919
      if (t1) {
#line 2919
        if (! t1->to1) {
#line 2919
          goto while_break;
        }
      } else {
#line 2919
        goto while_break;
      }
    } else {
#line 2919
      goto while_break;
    }
#line 2920
    c = (splice_t *)((void *)0);
#line 2920
    g = c;
#line 2921
    if ((t1->from2 - t0->to2) - 1 == 0) {
      {
#line 2922
      tmp___9 = strncmp((char const   *)((char *)(seq1___0 + t0->to1)), "GT", (size_t )2);
      }
#line 2922
      if (tmp___9) {
        _L___0: /* CIL Label */ 
        {
#line 2925
        tmp___7 = strncmp((char const   *)((char *)(seq1___0 + t0->to1)), "CT", (size_t )2);
        }
#line 2925
        if (tmp___7) {
          _L: /* CIL Label */ 
#line 2929
          gtag = 0;
#line 2929
          ctac = 0;
#line 2932
          if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2932
            tmp___1 = t0->to1 - t0->from1;
          } else {
#line 2932
            tmp___1 = t0->length - 1;
          }
#line 2932
          if (in_w > tmp___1) {
#line 2932
            if (t0->length - 1 > t0->to1 - t0->from1) {
#line 2932
              tmp___0 = t0->to1 - t0->from1;
            } else {
#line 2932
              tmp___0 = t0->length - 1;
            }
#line 2932
            w1 = tmp___0;
          } else {
#line 2932
            w1 = in_w;
          }
#line 2933
          if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2933
            tmp___4 = t1->to1 - t1->from1;
          } else {
#line 2933
            tmp___4 = t1->length - 1;
          }
#line 2933
          if (in_w > tmp___4) {
#line 2933
            if (t1->length - 1 > t1->to1 - t1->from1) {
#line 2933
              tmp___3 = t1->to1 - t1->from1;
            } else {
#line 2933
              tmp___3 = t1->length - 1;
            }
#line 2933
            w2 = tmp___3;
          } else {
#line 2933
            w2 = in_w;
          }
          {
#line 2934
          splice(seq1___0, t0->to1 - w1, t0->to1 + w1, t1->from1 - w2, t1->from1 + w2,
                 seq2___0, t0->to2 - w1, t1->from2 + w2, & g, & c, 2);
          }
#line 2936
          if (g->score > c->score) {
#line 2936
            cell = g;
#line 2936
            type = (char )'G';
          } else
#line 2937
          if (c->score > g->score) {
#line 2937
            cell = c;
#line 2937
            type = (char )'C';
          } else {
#line 2938
            cell = g;
#line 2938
            type = (char )'G';
          }
#line 2940
          t0->to1 = cell->xs;
#line 2940
          t0->to2 = cell->ys;
#line 2941
          t1->from1 = cell->xe;
#line 2941
          t1->from2 = cell->ye;
#line 2942
          t0->length = (t0->to2 - t0->from2) + 1;
#line 2943
          t1->length = (t1->to2 - t1->from2) + 1;
#line 2945
          if ((int )type == 71) {
#line 2945
            tmp___5 = "AG";
          } else {
#line 2945
            tmp___5 = "AC";
          }
#line 2945
          if ((int )type == 71) {
#line 2945
            tmp___6 = "GT";
          } else {
#line 2945
            tmp___6 = "CT";
          }
          {
#line 2945
          wobble(& t0, & t1, tmp___6, tmp___5, seq1___0);
#line 2947
          free((void *)g);
#line 2947
          free((void *)c);
#line 2950
          s = seq1___0 + t0->to1;
          }
#line 2951
          if ((int )*s == 71) {
#line 2951
            gtag ++;
          } else
#line 2951
          if ((int )*s == 67) {
#line 2951
            ctac ++;
          }
#line 2952
          s ++;
#line 2953
          if ((int )*s == 84) {
#line 2953
            gtag ++;
#line 2953
            ctac ++;
          }
#line 2954
          s = (seq1___0 + t1->from1) - 3;
#line 2955
          if ((int )*s == 65) {
#line 2955
            gtag ++;
#line 2955
            ctac ++;
          }
#line 2956
          s ++;
#line 2957
          if ((int )*s == 71) {
#line 2957
            gtag ++;
          } else
#line 2957
          if ((int )*s == 67) {
#line 2957
            ctac ++;
          }
#line 2958
          if (gtag > ctac) {
#line 2958
            type = (char )'G';
          } else
#line 2959
          if (ctac > gtag) {
#line 2959
            type = (char )'C';
          } else {
#line 2960
            type = (char )'N';
          }
#line 2962
          t0->ori = type;
        } else {
          {
#line 2925
          tmp___8 = strncmp((char const   *)((char *)((seq1___0 + t1->from1) - 3)),
                            "AC", (size_t )2);
          }
#line 2925
          if (tmp___8) {
#line 2925
            goto _L;
          } else {
#line 2927
            t0->ori = (char )'C';
          }
        }
      } else {
        {
#line 2922
        tmp___10 = strncmp((char const   *)((char *)((seq1___0 + t1->from1) - 3)),
                           "AG", (size_t )2);
        }
#line 2922
        if (tmp___10) {
#line 2922
          goto _L___0;
        } else {
#line 2924
          t0->ori = (char )'G';
        }
      }
    } else {
#line 2965
      t0->ori = (char )'E';
    }
#line 2966
    t0 = t1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2969
  return;
}
}
#line 3070 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
Exon *find_previous(Exon *lblock , Exon *tgt ) 
{ 
  Exon *t ;

  {
#line 3072
  t = lblock;
  {
#line 3074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3074
    if (t) {
#line 3074
      if (! ((unsigned long )t->next_exon != (unsigned long )tgt)) {
#line 3074
        goto while_break;
      }
    } else {
#line 3074
      goto while_break;
    }
#line 3074
    t = t->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 3075
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 3076
    fatal("sim4b1.c: Corrupted exon list: could not find previous.");
    }
  }
#line 3078
  return (t);
}
}
#line 3081 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4b1.c"
static bool get_match_quality(Exon *lblock , Exon *rblock , sim4_stats_t *st , int N___0 ) 
{ 
  int tcov ;
  bool good_match ;
  Exon *t ;
  double tmp ;
  double tmp___0 ;

  {
#line 3087
  good_match = 1;
#line 3087
  st->icoverage = 0;
#line 3088
  t = lblock->next_exon;
  {
#line 3089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3089
    if (! t->to1) {
#line 3089
      goto while_break;
    }
#line 3090
    st->icoverage += (t->to2 - t->from2) + 1;
#line 3091
    if (100 * t->edist >= 5 * ((t->to2 - t->from2) + 1)) {
#line 3092
      good_match = 0;
#line 3092
      goto while_break;
    }
#line 3094
    t = t->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 3096
  tcov = (rblock->to2 - (lblock->next_exon)->from2) + 1;
#line 3097
  if ((double )(lblock->next_exon)->from2 >= .5 * (double )N___0) {
#line 3097
    if ((double )tcov >= .8 * (double )(N___0 - (lblock->next_exon)->from2)) {
#line 3097
      if (.95 * (double )tcov < (double )100) {
#line 3097
        tmp___0 = (double )100;
      } else {
#line 3097
        tmp___0 = .95 * (double )tcov;
      }
#line 3097
      if (! ((double )st->icoverage >= tmp___0)) {
#line 3097
        goto _L___2;
      }
    } else {
#line 3097
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3101
  if ((double )rblock->to2 <= .5 * (double )N___0) {
#line 3101
    if ((double )tcov >= .8 * (double )rblock->to2) {
#line 3101
      if (.95 * (double )tcov < (double )100) {
#line 3101
        tmp = (double )100;
      } else {
#line 3101
        tmp = .95 * (double )tcov;
      }
#line 3101
      if (! ((double )st->icoverage >= tmp)) {
#line 3101
        goto _L___0;
      }
    } else {
#line 3101
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3104
  if ((double )tcov < .8 * (double )N___0) {
#line 3105
    good_match = 0;
  } else
#line 3104
  if ((double )st->icoverage < .9 * (double )tcov) {
#line 3105
    good_match = 0;
  }
#line 3107
  return (good_match);
}
}
#line 7 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/encoding.c"
unsigned char const   nfasta_ctype[256] ;
#line 8 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/encoding.c"
unsigned char const   nfasta_ctype[256]  = 
#line 8
  {      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 28 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/encoding.c"
unsigned char const   dna_complement[256]  = 
#line 28
  {      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )'T',      (unsigned char const   )'V',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'M', 
        (unsigned char const   )' ',      (unsigned char const   )'K',      (unsigned char const   )'N',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'Y',      (unsigned char const   )'S', 
        (unsigned char const   )'A',      (unsigned char const   )' ',      (unsigned char const   )'B',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'R',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )'t',      (unsigned char const   )'v',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'m', 
        (unsigned char const   )' ',      (unsigned char const   )'k',      (unsigned char const   )'n',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )'y',      (unsigned char const   )'s', 
        (unsigned char const   )'a',      (unsigned char const   )' ',      (unsigned char const   )'b',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'r',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ', 
        (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' ',      (unsigned char const   )' '};
#line 6 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.h"
void Condense_script(edit_script *head ) ;
#line 8
void S2A(edit_script *head , int *S , int flag ) ;
#line 9
void align_reverse(int *S ) ;
#line 10
void IDISPLAY(uchar *A , uchar *B , int M___0 , int N___0 , int *S , int AP , int BP ,
              int est_strand , Exon *exons ) ;
#line 12
void Flip_script(struct edit_script **script ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
static int snake(int k , int x , int endx , int endy ) ;
#line 18
static int rsnake(int k , int x , int startx , int starty , int M___0 ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void align_path(int i1 , int j1___0 , int i2 , int j2 , int dist , edit_script **head ,
                edit_script **tail ) 
{ 
  int *last_d ;
  int *temp_d ;
  int *rlast_d ;
  int *rtemp_d ;
  edit_script *head1 ;
  edit_script *tail1 ;
  edit_script *head2 ;
  edit_script *tail2 ;
  int midc ;
  int rmidc ;
  int start ;
  int lower ;
  int upper ;
  int rstart ;
  int rlower ;
  int rupper ;
  int c ;
  int k ;
  int row ;
  int mi ;
  int mj ;
  int tmp ;
  int ll ;
  int uu ;
  char flag ;
  edit_script *tmp___0 ;
  void *tmp___1 ;
  edit_script *tmp___2 ;
  void *tmp___3 ;
  edit_script *tmp___4 ;
  void *tmp___5 ;
  edit_script *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;

  {
#line 35
  tmp___0 = (edit_script *)((void *)0);
#line 35
  *tail = tmp___0;
#line 35
  *head = tmp___0;
#line 38
  if (i1 == i2) {
#line 39
    if (j1___0 == j2) {
#line 39
      *head = (edit_script *)((void *)0);
    } else {
      {
#line 41
      tmp___1 = ckalloc(sizeof(edit_script ));
#line 41
      head1 = (edit_script *)tmp___1;
#line 42
      head1->op_type = (char)2;
#line 43
      head1->num = j2 - j1___0;
#line 44
      head1->next = (struct edit_script *)((void *)0);
#line 45
      tmp___2 = head1;
#line 45
      *tail = tmp___2;
#line 45
      *head = tmp___2;
      }
    }
#line 47
    return;
  }
#line 50
  if (j1___0 == j2) {
    {
#line 51
    tmp___3 = ckalloc(sizeof(edit_script ));
#line 51
    head1 = (edit_script *)tmp___3;
#line 52
    head1->op_type = (char)1;
#line 53
    head1->num = i2 - i1;
#line 54
    head1->next = (struct edit_script *)((void *)0);
#line 55
    tmp___4 = head1;
#line 55
    *tail = tmp___4;
#line 55
    *head = tmp___4;
    }
#line 56
    return;
  }
#line 59
  if (dist <= 1) {
#line 60
    start = j1___0 - i1;
#line 61
    if (j2 - i2 == j1___0 - i1) {
      {
#line 62
      tmp___5 = ckalloc(sizeof(edit_script ));
#line 62
      head1 = (edit_script *)tmp___5;
#line 63
      head1->op_type = (char)3;
#line 64
      head1->num = i2 - i1;
#line 65
      head1->next = (struct edit_script *)((void *)0);
#line 66
      tmp___6 = head1;
#line 66
      *tail = tmp___6;
#line 66
      *head = tmp___6;
      }
    } else
#line 67
    if (j2 - j1___0 == (i2 - i1) + 1) {
      {
#line 69
      tmp = snake(start, i1, i2, j2);
      }
#line 70
      if (tmp > i1) {
        {
#line 71
        tmp___7 = ckalloc(sizeof(edit_script ));
#line 71
        head1 = (edit_script *)tmp___7;
#line 72
        head1->op_type = (char)3;
#line 73
        head1->num = tmp - i1;
#line 74
        *head = head1;
        }
      }
      {
#line 76
      tmp___8 = ckalloc(sizeof(edit_script ));
#line 76
      head2 = (edit_script *)tmp___8;
#line 77
      head2->op_type = (char)2;
#line 78
      head2->num = 1;
      }
#line 80
      if (*head) {
#line 80
        head1->next = head2;
      } else {
#line 81
        *head = head2;
      }
#line 82
      *tail = head2;
#line 83
      head2->next = (struct edit_script *)((void *)0);
#line 85
      if (i2 - tmp) {
        {
#line 86
        head1 = head2;
#line 87
        tmp___9 = ckalloc(sizeof(edit_script ));
#line 87
        head2 = (edit_script *)tmp___9;
#line 87
        *tail = head2;
#line 88
        head2->op_type = (char)3;
#line 89
        head2->num = i2 - tmp;
#line 90
        head2->next = (struct edit_script *)((void *)0);
#line 91
        head1->next = head2;
        }
      }
    } else
#line 93
    if ((j2 - j1___0) + 1 == i2 - i1) {
      {
#line 95
      tmp = snake(start, i1, i2, j2);
      }
#line 96
      if (tmp > i1) {
        {
#line 97
        tmp___10 = ckalloc(sizeof(edit_script ));
#line 97
        head1 = (edit_script *)tmp___10;
#line 98
        head1->op_type = (char)3;
#line 99
        head1->num = tmp - i1;
#line 100
        *head = head1;
        }
      }
      {
#line 102
      tmp___11 = ckalloc(sizeof(edit_script ));
#line 102
      head2 = (edit_script *)tmp___11;
#line 103
      head2->op_type = (char)1;
#line 104
      head2->num = 1;
      }
#line 106
      if (*head) {
#line 106
        head1->next = head2;
      } else {
#line 107
        *head = head2;
      }
#line 108
      *tail = head2;
#line 109
      head2->next = (struct edit_script *)((void *)0);
#line 111
      if (i2 > tmp + 1) {
        {
#line 112
        head1 = head2;
#line 113
        tmp___12 = ckalloc(sizeof(edit_script ));
#line 113
        head2 = (edit_script *)tmp___12;
#line 113
        *tail = head2;
#line 114
        head2->op_type = (char)3;
#line 115
        head2->num = (i2 - tmp) - 1;
#line 116
        head2->next = (struct edit_script *)((void *)0);
#line 117
        head1->next = head2;
        }
      }
    } else {
      {
#line 120
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"align.c: warning: something wrong when aligning.");
      }
    }
#line 123
    return;
  }
#line 127
  midc = dist / 2;
#line 128
  rmidc = dist - midc;
#line 131
  start = j1___0 - i1;
#line 132
  if (j1___0 - i2 < start - midc) {
#line 132
    lower = start - midc;
  } else {
#line 132
    lower = j1___0 - i2;
  }
#line 133
  if (j2 - i1 > start + midc) {
#line 133
    upper = start + midc;
  } else {
#line 133
    upper = j2 - i1;
  }
#line 134
  rstart = j2 - i2;
#line 135
  if (j1___0 - i2 < rstart - rmidc) {
#line 135
    rlower = rstart - rmidc;
  } else {
#line 135
    rlower = j1___0 - i2;
  }
#line 136
  if (j2 - i1 > rstart + rmidc) {
#line 136
    rupper = rstart + rmidc;
  } else {
#line 136
    rupper = j2 - i1;
  }
  {
#line 139
  tmp___13 = ckalloc((unsigned long )((upper - lower) + 1) * sizeof(int ));
#line 139
  last_d = (int *)tmp___13 - lower;
#line 140
  tmp___14 = ckalloc((unsigned long )((upper - lower) + 1) * sizeof(int ));
#line 140
  temp_d = (int *)tmp___14 - lower;
#line 142
  k = lower;
  }
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (k <= upper)) {
#line 142
      goto while_break;
    }
#line 142
    *(last_d + k) = -1;
#line 142
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  *(last_d + start) = snake(start, i1, i2, j2);
#line 146
  c = 1;
  }
  {
#line 146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 146
    if (! (c <= midc)) {
#line 146
      goto while_break___0;
    }
#line 147
    if (lower < start - c) {
#line 147
      ll = start - c;
    } else {
#line 147
      ll = lower;
    }
#line 148
    if (upper > start + c) {
#line 148
      uu = start + c;
    } else {
#line 148
      uu = upper;
    }
#line 149
    k = ll;
    {
#line 149
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 149
      if (! (k <= uu)) {
#line 149
        goto while_break___1;
      }
#line 150
      if (k == ll) {
#line 152
        row = *(last_d + (k + 1)) + 1;
      } else
#line 153
      if (k == uu) {
#line 155
        row = *(last_d + (k - 1));
      } else
#line 156
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 156
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 159
          row = *(last_d + k) + 1;
        } else {
#line 156
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 160
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 160
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 163
          row = *(last_d + (k + 1)) + 1;
        } else {
#line 166
          row = *(last_d + (k - 1));
        }
      } else {
#line 166
        row = *(last_d + (k - 1));
      }
      {
#line 169
      *(temp_d + k) = snake(k, row, i2, j2);
#line 149
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    k = ll;
    {
#line 171
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 171
      if (! (k <= uu)) {
#line 171
        goto while_break___2;
      }
#line 172
      *(last_d + k) = *(temp_d + k);
#line 171
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 146
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 176
  tmp___15 = ckalloc((unsigned long )((rupper - rlower) + 1) * sizeof(int ));
#line 176
  rlast_d = (int *)tmp___15 - rlower;
#line 177
  tmp___16 = ckalloc((unsigned long )((rupper - rlower) + 1) * sizeof(int ));
#line 177
  rtemp_d = (int *)tmp___16 - rlower;
#line 179
  k = rlower;
  }
  {
#line 179
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 179
    if (! (k <= rupper)) {
#line 179
      goto while_break___3;
    }
#line 179
    *(rlast_d + k) = i2 + 1;
#line 179
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 180
  *(rlast_d + rstart) = rsnake(rstart, i2, i1, j1___0, M);
#line 183
  c = 1;
  }
  {
#line 183
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 183
    if (! (c <= rmidc)) {
#line 183
      goto while_break___4;
    }
#line 184
    if (rlower < rstart - c) {
#line 184
      ll = rstart - c;
    } else {
#line 184
      ll = rlower;
    }
#line 185
    if (rupper > rstart + c) {
#line 185
      uu = rstart + c;
    } else {
#line 185
      uu = rupper;
    }
#line 186
    k = ll;
    {
#line 186
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 186
      if (! (k <= uu)) {
#line 186
        goto while_break___5;
      }
#line 187
      if (k == ll) {
#line 189
        row = *(rlast_d + (k + 1));
      } else
#line 190
      if (k == uu) {
#line 192
        row = *(rlast_d + (k - 1)) - 1;
      } else
#line 193
      if (*(rlast_d + k) - 1 <= *(rlast_d + (k + 1))) {
#line 193
        if (*(rlast_d + k) - 1 <= *(rlast_d + (k - 1)) - 1) {
#line 196
          row = *(rlast_d + k) - 1;
        } else {
#line 193
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 197
      if (*(rlast_d + (k - 1)) - 1 <= *(rlast_d + (k + 1))) {
#line 197
        if (*(rlast_d + (k - 1)) - 1 <= *(rlast_d + k) - 1) {
#line 200
          row = *(rlast_d + (k - 1)) - 1;
        } else {
#line 203
          row = *(rlast_d + (k + 1));
        }
      } else {
#line 203
        row = *(rlast_d + (k + 1));
      }
      {
#line 206
      *(rtemp_d + k) = rsnake(k, row, i1, j1___0, M);
#line 186
      k ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 208
    k = ll;
    {
#line 208
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 208
      if (! (k <= uu)) {
#line 208
        goto while_break___6;
      }
#line 209
      *(rlast_d + k) = *(rtemp_d + k);
#line 208
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 183
    c ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 216
  flag = (char)0;
#line 217
  mi = i1;
#line 217
  mj = j1___0;
#line 218
  if (lower < rlower) {
#line 218
    ll = rlower;
  } else {
#line 218
    ll = lower;
  }
#line 218
  if (upper > rupper) {
#line 218
    uu = rupper;
  } else {
#line 218
    uu = upper;
  }
#line 219
  k = ll;
  {
#line 219
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 219
    if (! (k <= uu)) {
#line 219
      goto while_break___7;
    }
#line 220
    if (*(last_d + k) >= *(rlast_d + k)) {
#line 221
      if (*(last_d + k) - i1 >= i2 - *(rlast_d + k)) {
#line 222
        mi = *(last_d + k);
#line 222
        mj = k + mi;
      } else {
#line 224
        mi = *(rlast_d + k);
#line 224
        mj = k + mi;
      }
#line 226
      flag = (char)1;
#line 228
      goto while_break___7;
    }
#line 219
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 231
  free((void *)(last_d + lower));
#line 231
  free((void *)(rlast_d + rlower));
#line 232
  free((void *)(temp_d + lower));
#line 232
  free((void *)(rtemp_d + rlower));
  }
#line 234
  if (flag) {
    {
#line 236
    align_path(i1, j1___0, mi, mj, midc, & head1, & tail1);
#line 239
    align_path(mi, mj, i2, j2, rmidc, & head2, & tail2);
    }
#line 242
    if (head1) {
#line 242
      tail1->next = head2;
    } else {
#line 243
      head1 = head2;
    }
  } else {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"align.c: warning: something wrong when dividing\n");
#line 247
    head1 = (edit_script *)((void *)0);
    }
  }
#line 249
  *head = head1;
#line 250
  if (head2) {
#line 250
    *tail = tail2;
  } else {
#line 251
    *tail = tail1;
  }
#line 252
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
int align_get_dist(int i1 , int j1___0 , int i2 , int j2 , int limit ) 
{ 
  int *last_d ;
  int *temp_d ;
  int goal_diag ;
  int ll ;
  int uu ;
  int c ;
  int k ;
  int row ;
  int start ;
  int lower ;
  int upper ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 263
  start = j1___0 - i1;
#line 264
  if (j1___0 - i2 < start - limit) {
#line 264
    lower = start - limit;
  } else {
#line 264
    lower = j1___0 - i2;
  }
#line 265
  if (j2 - i1 > start + limit) {
#line 265
    upper = start + limit;
  } else {
#line 265
    upper = j2 - i1;
  }
#line 266
  goal_diag = j2 - i2;
#line 268
  if (goal_diag > upper) {
    {
#line 269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The two sequences are not really similar.\n");
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please try an exact aligning method.\n");
#line 271
    exit(1);
    }
  } else
#line 268
  if (goal_diag < lower) {
    {
#line 269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The two sequences are not really similar.\n");
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please try an exact aligning method.\n");
#line 271
    exit(1);
    }
  }
  {
#line 275
  tmp = ckalloc((unsigned long )((upper - lower) + 1) * sizeof(int ));
#line 275
  last_d = (int *)tmp - lower;
#line 276
  tmp___0 = ckalloc((unsigned long )((upper - lower) + 1) * sizeof(int ));
#line 276
  temp_d = (int *)tmp___0 - lower;
#line 279
  k = lower;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (k <= upper)) {
#line 279
      goto while_break;
    }
#line 279
    *(last_d + k) = -99999;
#line 279
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  *(last_d + start) = snake(start, i1, i2, j2);
  }
#line 282
  if (*(last_d + goal_diag) >= i2) {
    {
#line 284
    free((void *)(last_d + lower));
#line 285
    free((void *)(temp_d + lower));
    }
#line 286
    return (0);
  }
#line 289
  c = 1;
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! (c <= limit)) {
#line 289
      goto while_break___0;
    }
#line 290
    if (lower < start - c) {
#line 290
      ll = start - c;
    } else {
#line 290
      ll = lower;
    }
#line 290
    if (upper > start + c) {
#line 290
      uu = start + c;
    } else {
#line 290
      uu = upper;
    }
#line 291
    k = ll;
    {
#line 291
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 291
      if (! (k <= uu)) {
#line 291
        goto while_break___1;
      }
#line 292
      if (k == ll) {
#line 293
        row = *(last_d + (k + 1)) + 1;
      } else
#line 294
      if (k == uu) {
#line 295
        row = *(last_d + (k - 1));
      } else
#line 296
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 296
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 298
          row = *(last_d + k) + 1;
        } else {
#line 296
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 299
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 299
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 301
          row = *(last_d + (k + 1)) + 1;
        } else {
#line 303
          row = *(last_d + (k - 1));
        }
      } else {
#line 303
        row = *(last_d + (k - 1));
      }
      {
#line 305
      *(temp_d + k) = snake(k, row, i2, j2);
#line 291
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 308
    k = ll;
    {
#line 308
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 308
      if (! (k <= uu)) {
#line 308
        goto while_break___2;
      }
#line 308
      *(last_d + k) = *(temp_d + k);
#line 308
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 310
    if (*(last_d + goal_diag) >= i2) {
      {
#line 316
      free((void *)(last_d + lower));
#line 317
      free((void *)(temp_d + lower));
      }
#line 318
      return (c);
    }
#line 289
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  return (-1);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void Condense_script(edit_script *head ) 
{ 
  edit_script *tp ;
  edit_script *tp1 ;

  {
#line 331
  tp = head;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 332
      goto while_break;
    }
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      tp1 = tp->next;
#line 333
      if ((unsigned long )tp1 != (unsigned long )((void *)0)) {
#line 333
        if (! ((int )tp->op_type == (int )tp1->op_type)) {
#line 333
          goto while_break___0;
        }
      } else {
#line 333
        goto while_break___0;
      }
      {
#line 334
      tp->num += tp1->num;
#line 335
      tp->next = tp1->next;
#line 336
      free((void *)tp1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 338
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void Condense_both_Ends(edit_script **head , edit_script **tail , edit_script **prev ) 
{ 
  edit_script *tp ;
  edit_script *tp1 ;

  {
#line 348
  tp = *head;
#line 348
  *prev = (edit_script *)((void *)0);
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 349
      goto while_break;
    }
    {
#line 350
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 350
      tp1 = tp->next;
#line 350
      if ((unsigned long )tp1 != (unsigned long )((void *)0)) {
#line 350
        if (! ((int )tp->op_type == (int )tp1->op_type)) {
#line 350
          goto while_break___0;
        }
      } else {
#line 350
        goto while_break___0;
      }
      {
#line 351
      tp->num += tp1->num;
#line 352
      tp->next = tp1->next;
#line 353
      free((void *)tp1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 355
    if (tp->next) {
#line 355
      *prev = tp;
    } else {
#line 356
      *tail = tp;
    }
#line 357
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void Flip_script(struct edit_script **script ) 
{ 
  struct edit_script *ep ;
  struct edit_script *ahead ;
  struct edit_script *behind ;

  {
#line 366
  ahead = *script;
#line 367
  ep = (struct edit_script *)((void *)0);
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((unsigned long )ahead != (unsigned long )((void *)0))) {
#line 368
      goto while_break;
    }
#line 369
    behind = ep;
#line 370
    ep = ahead;
#line 371
    ahead = ahead->next;
#line 372
    ep->next = behind;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  *script = ep;
#line 375
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void S2A(edit_script *head , int *S , int flag ) 
{ 
  edit_script *tp ;
  int *lastS ;
  int i ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 467
  tp = head;
#line 468
  lastS = S;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 469
      goto while_break;
    }
#line 473
    if ((int )tp->op_type == 3) {
#line 474
      i = 0;
      {
#line 474
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 474
        if (! (i < tp->num)) {
#line 474
          goto while_break___0;
        }
#line 474
        tmp = lastS;
#line 474
        lastS ++;
#line 474
        *tmp = 0;
#line 474
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 475
    if ((int )tp->op_type == 2) {
#line 476
      tmp___0 = lastS;
#line 476
      lastS ++;
#line 476
      if (! flag) {
#line 476
        *tmp___0 = tp->num;
      } else {
#line 476
        *tmp___0 = 0 - tp->num;
      }
    } else {
#line 478
      tmp___1 = lastS;
#line 478
      lastS ++;
#line 478
      if (! flag) {
#line 478
        *tmp___1 = 0 - tp->num;
      } else {
#line 478
        *tmp___1 = tp->num;
      }
    }
#line 480
    tp = tp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  *(S - 1) = (int )(lastS - S);
#line 483
  return;
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void align_reverse(int *S ) 
{ 
  int auxi ;
  int *begi ;
  int *endi ;

  {
#line 489
  begi = S;
#line 489
  endi = S + *(S - 1);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! ((unsigned long )begi < (unsigned long )endi)) {
#line 490
      goto while_break;
    }
#line 491
    auxi = *begi;
#line 492
    endi --;
#line 492
    *begi = *endi;
#line 493
    *endi = auxi;
#line 494
    begi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
static uchar ALINE[51]  ;
#line 501 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
static uchar BLINE[51]  ;
#line 501 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
static uchar CLINE[51]  ;
#line 503 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void IDISPLAY(uchar *A , uchar *B , int M___0 , int N___0 , int *S , int AP , int BP ,
              int est_strand , Exon *exons ) 
{ 
  Exon *t0 ;
  register uchar *a ;
  register uchar *b ;
  register uchar *c ;
  register uchar sign ;
  register int i ;
  register int j ;
  register int op ;
  register int index___0 ;
  int lines ;
  int ap ;
  int bp ;
  int starti ;
  int *tmp ;
  uchar *tmp___0 ;
  uchar *tmp___3 ;
  uchar *tmp___4 ;
  int *tmp___5 ;
  uchar *tmp___6 ;
  uchar *tmp___7 ;
  uchar *tmp___8 ;
  uchar *tmp___9 ;
  uchar *tmp___10 ;
  uchar *tmp___11 ;
  uchar *tmp___12 ;
  uchar *tmp___13 ;
  uchar *tmp___14 ;
  uchar *tmp___15 ;
  uchar *tmp___16 ;
  uchar *tmp___17 ;
  uchar *tmp___18 ;
  uchar *tmp___19 ;
  uchar *tmp___20 ;
  uchar *tmp___21 ;
  uchar *tmp___22 ;
  uchar *tmp___23 ;
  uchar *tmp___24 ;
  uchar *tmp___25 ;
  uchar *tmp___26 ;
  uchar *tmp___27 ;
  uchar *tmp___28 ;
  uchar *tmp___29 ;
  uchar *tmp___30 ;
  uchar *tmp___31 ;
  uchar *tmp___32 ;
  uchar *tmp___33 ;
  uchar *tmp___34 ;
  uchar *tmp___35 ;
  uchar *tmp___36 ;
  uchar *tmp___37 ;
  uchar *tmp___38 ;
  uchar *tmp___39 ;
  uchar *tmp___40 ;
  uchar *tmp___41 ;
  uchar *tmp___42 ;
  uchar *tmp___43 ;
  uchar *tmp___44 ;
  uchar *tmp___45 ;
  uchar *tmp___46 ;
  uchar *tmp___47 ;
  uchar *tmp___48 ;
  uchar *tmp___49 ;
  uchar *tmp___50 ;
  uchar *tmp___51 ;
  uchar *tmp___52 ;
  uchar *tmp___53 ;
  uchar tmp___54 ;
  uchar tmp___55 ;
  int tmp___56 ;

  {
#line 511
  if ((unsigned long )exons == (unsigned long )((void *)0)) {
    {
#line 512
    fatal("align.c: Exon list cannot be empty.");
    }
  } else
#line 511
  if (! exons->to1) {
#line 511
    if ((unsigned long )exons->next_exon == (unsigned long )((void *)0)) {
      {
#line 512
      fatal("align.c: Exon list cannot be empty.");
      }
    }
  }
#line 515
  t0 = exons;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (t0) {
#line 516
      if (est_strand == 2) {
#line 516
        if (! (t0->from1 != AP)) {
#line 516
          if (! (t0->from2 != BP)) {
#line 516
            goto _L;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 516
      if (est_strand == 1) {
#line 516
        if (! (t0->from1 != BP)) {
#line 516
          if (! (t0->from2 != AP)) {
#line 516
            goto while_break;
          }
        }
      } else {
#line 516
        goto while_break;
      }
    } else {
#line 516
      goto while_break;
    }
#line 518
    t0 = t0->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if (! t0) {
    {
#line 519
    fatal("align.c: Alignment fragment not found.");
    }
  }
#line 521
  index___0 = 0;
#line 521
  lines = index___0;
#line 521
  op = lines;
#line 521
  j = op;
#line 521
  i = j;
#line 522
  sign = (uchar )'*';
#line 522
  ap = AP;
#line 522
  bp = BP;
#line 522
  a = ALINE;
#line 522
  b = BLINE;
#line 522
  c = CLINE;
#line 523
  if (t0->next_exon) {
#line 523
    if ((t0->next_exon)->to1) {
#line 523
      starti = t0->to1 + 1;
    } else {
#line 523
      starti = -1;
    }
  } else {
#line 523
    starti = -1;
  }
  {
#line 525
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 525
    if (! (i < M___0)) {
#line 525
      if (! (j < N___0)) {
#line 525
        goto while_break___0;
      }
    }
#line 526
    if (op == 0) {
#line 526
      if (*S == 0) {
#line 527
        tmp = S;
#line 527
        S ++;
#line 527
        op = *tmp;
#line 527
        i ++;
#line 527
        *a = *(A + i);
#line 527
        j ++;
#line 527
        *b = *(B + j);
#line 528
        tmp___0 = c;
#line 528
        c ++;
#line 528
        tmp___3 = a;
#line 528
        a ++;
#line 528
        tmp___4 = b;
#line 528
        b ++;
#line 528
        if ((int )*tmp___3 == (int )*tmp___4) {
#line 528
          *tmp___0 = (uchar )'|';
        } else {
#line 528
          *tmp___0 = (uchar )' ';
        }
      } else {
#line 526
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 530
      if (op == 0) {
#line 530
        tmp___5 = S;
#line 530
        S ++;
#line 530
        op = *tmp___5;
      }
#line 531
      if (op > 0) {
#line 532
        if (est_strand == 2) {
#line 533
          tmp___6 = a;
#line 533
          a ++;
#line 533
          *tmp___6 = (uchar )' ';
#line 533
          tmp___7 = b;
#line 533
          b ++;
#line 533
          j ++;
#line 533
          *tmp___7 = *(B + j);
#line 533
          tmp___8 = c;
#line 533
          c ++;
#line 533
          *tmp___8 = (uchar )'-';
#line 533
          op --;
        } else
#line 535
        if (j + BP == starti) {
          {
#line 538
          if ((int )t0->ori == 67) {
#line 538
            goto case_67;
          }
#line 539
          if ((int )t0->ori == 71) {
#line 539
            goto case_71;
          }
#line 540
          if ((int )t0->ori == 78) {
#line 540
            goto case_78;
          }
#line 541
          goto switch_default;
          case_67: /* CIL Label */ 
#line 538
          sign = (uchar )'<';
#line 538
          goto switch_break;
          case_71: /* CIL Label */ 
#line 539
          sign = (uchar )'>';
#line 539
          goto switch_break;
          case_78: /* CIL Label */ 
#line 540
          sign = (uchar )'=';
#line 540
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 541
          fatal("align.c: Unrecognized intron type.");
          }
          switch_break: /* CIL Label */ ;
          }
#line 543
          t0 = t0->next_exon;
#line 544
          if (t0->next_exon) {
#line 544
            if ((t0->next_exon)->to1) {
#line 544
              starti = t0->to1 + 1;
            } else {
#line 544
              starti = -1;
            }
          } else {
#line 544
            starti = -1;
          }
#line 545
          index___0 = 1;
#line 545
          tmp___9 = c;
#line 545
          c ++;
#line 545
          *tmp___9 = sign;
#line 545
          tmp___10 = a;
#line 545
          a ++;
#line 545
          *tmp___10 = (uchar )' ';
#line 545
          tmp___11 = b;
#line 545
          b ++;
#line 545
          j ++;
#line 545
          *tmp___11 = *(B + j);
#line 545
          op --;
        } else
#line 546
        if (! index___0) {
#line 547
          tmp___12 = c;
#line 547
          c ++;
#line 547
          *tmp___12 = (uchar )'-';
#line 547
          tmp___13 = a;
#line 547
          a ++;
#line 547
          *tmp___13 = (uchar )' ';
#line 547
          tmp___14 = b;
#line 547
          b ++;
#line 547
          j ++;
#line 547
          *tmp___14 = *(B + j);
#line 547
          op --;
        } else {
          {
#line 553
          if (index___0 == 2) {
#line 553
            goto case_2;
          }
#line 553
          if (index___0 == 1) {
#line 553
            goto case_2;
          }
#line 553
          if (index___0 == 0) {
#line 553
            goto case_2;
          }
#line 556
          if (index___0 == 4) {
#line 556
            goto case_4;
          }
#line 556
          if (index___0 == 3) {
#line 556
            goto case_4;
          }
#line 558
          if (index___0 == 5) {
#line 558
            goto case_5;
          }
#line 561
          if (index___0 == 7) {
#line 561
            goto case_7;
          }
#line 561
          if (index___0 == 6) {
#line 561
            goto case_7;
          }
#line 563
          if (index___0 == 8) {
#line 563
            goto case_8;
          }
#line 550
          goto switch_break___0;
          case_2: /* CIL Label */ 
          case_1: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 553
          tmp___15 = a;
#line 553
          a ++;
#line 553
          *tmp___15 = (uchar )' ';
#line 553
          tmp___16 = b;
#line 553
          b ++;
#line 553
          j ++;
#line 553
          *tmp___16 = *(B + j);
#line 554
          tmp___17 = c;
#line 554
          c ++;
#line 554
          *tmp___17 = sign;
#line 554
          op --;
#line 554
          index___0 ++;
#line 554
          goto switch_break___0;
          case_4: /* CIL Label */ 
          case_3: /* CIL Label */ 
#line 556
          tmp___18 = a;
#line 556
          a ++;
#line 556
          *tmp___18 = (uchar )' ';
#line 556
          tmp___19 = b;
#line 556
          b ++;
#line 556
          *tmp___19 = (uchar )'.';
#line 556
          tmp___20 = c;
#line 556
          c ++;
#line 556
          *tmp___20 = (uchar )'.';
#line 557
          j ++;
#line 557
          op --;
#line 557
          index___0 ++;
#line 557
          goto switch_break___0;
          case_5: /* CIL Label */ 
#line 558
          tmp___21 = a;
#line 558
          a ++;
#line 558
          *tmp___21 = (uchar )' ';
#line 558
          tmp___22 = b;
#line 558
          b ++;
#line 558
          *tmp___22 = (uchar )'.';
#line 558
          tmp___23 = c;
#line 558
          c ++;
#line 558
          *tmp___23 = (uchar )'.';
#line 559
          j += op - 3;
#line 559
          op = 3;
#line 559
          index___0 ++;
#line 559
          goto switch_break___0;
          case_7: /* CIL Label */ 
          case_6: /* CIL Label */ 
#line 561
          tmp___24 = a;
#line 561
          a ++;
#line 561
          *tmp___24 = (uchar )' ';
#line 561
          tmp___25 = b;
#line 561
          b ++;
#line 561
          j ++;
#line 561
          *tmp___25 = *(B + j);
#line 561
          tmp___26 = c;
#line 561
          c ++;
#line 561
          *tmp___26 = sign;
#line 562
          op --;
#line 562
          index___0 ++;
#line 562
          goto switch_break___0;
          case_8: /* CIL Label */ 
#line 563
          tmp___27 = a;
#line 563
          a ++;
#line 563
          *tmp___27 = (uchar )' ';
#line 563
          tmp___28 = b;
#line 563
          b ++;
#line 563
          j ++;
#line 563
          *tmp___28 = *(B + j);
#line 564
          tmp___29 = c;
#line 564
          c ++;
#line 564
          *tmp___29 = sign;
#line 564
          op --;
#line 564
          index___0 = 0;
#line 564
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else
#line 569
      if (est_strand == 1) {
#line 570
        tmp___30 = a;
#line 570
        a ++;
#line 570
        i ++;
#line 570
        *tmp___30 = *(A + i);
#line 570
        tmp___31 = b;
#line 570
        b ++;
#line 570
        *tmp___31 = (uchar )' ';
#line 570
        tmp___32 = c;
#line 570
        c ++;
#line 570
        *tmp___32 = (uchar )'-';
#line 570
        op ++;
      } else
#line 572
      if (i + AP == starti) {
        {
#line 575
        if ((int )t0->ori == 67) {
#line 575
          goto case_67___0;
        }
#line 576
        if ((int )t0->ori == 71) {
#line 576
          goto case_71___0;
        }
#line 577
        if ((int )t0->ori == 78) {
#line 577
          goto case_78___0;
        }
#line 578
        goto switch_default___0;
        case_67___0: /* CIL Label */ 
#line 575
        sign = (uchar )'<';
#line 575
        goto switch_break___1;
        case_71___0: /* CIL Label */ 
#line 576
        sign = (uchar )'>';
#line 576
        goto switch_break___1;
        case_78___0: /* CIL Label */ 
#line 577
        sign = (uchar )'=';
#line 577
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
#line 578
        fatal("align.c: Unrecognized intron type.");
        }
        switch_break___1: /* CIL Label */ ;
        }
#line 580
        t0 = t0->next_exon;
#line 581
        if (t0->next_exon) {
#line 581
          if ((t0->next_exon)->to1) {
#line 581
            starti = t0->to1 + 1;
          } else {
#line 581
            starti = -1;
          }
        } else {
#line 581
          starti = -1;
        }
#line 583
        index___0 = 1;
#line 583
        tmp___33 = c;
#line 583
        c ++;
#line 583
        *tmp___33 = sign;
#line 583
        tmp___34 = a;
#line 583
        a ++;
#line 583
        i ++;
#line 583
        *tmp___34 = *(A + i);
#line 583
        tmp___35 = b;
#line 583
        b ++;
#line 583
        *tmp___35 = (uchar )' ';
#line 583
        op ++;
      } else
#line 584
      if (! index___0) {
#line 585
        tmp___36 = c;
#line 585
        c ++;
#line 585
        *tmp___36 = (uchar )'-';
#line 585
        tmp___37 = a;
#line 585
        a ++;
#line 585
        i ++;
#line 585
        *tmp___37 = *(A + i);
#line 585
        tmp___38 = b;
#line 585
        b ++;
#line 585
        *tmp___38 = (uchar )' ';
#line 585
        op ++;
      } else {
        {
#line 591
        if (index___0 == 2) {
#line 591
          goto case_2___0;
        }
#line 591
        if (index___0 == 1) {
#line 591
          goto case_2___0;
        }
#line 591
        if (index___0 == 0) {
#line 591
          goto case_2___0;
        }
#line 594
        if (index___0 == 4) {
#line 594
          goto case_4___0;
        }
#line 594
        if (index___0 == 3) {
#line 594
          goto case_4___0;
        }
#line 596
        if (index___0 == 5) {
#line 596
          goto case_5___0;
        }
#line 599
        if (index___0 == 7) {
#line 599
          goto case_7___0;
        }
#line 599
        if (index___0 == 6) {
#line 599
          goto case_7___0;
        }
#line 601
        if (index___0 == 8) {
#line 601
          goto case_8___0;
        }
#line 588
        goto switch_break___2;
        case_2___0: /* CIL Label */ 
        case_1___0: /* CIL Label */ 
        case_0___0: /* CIL Label */ 
#line 591
        tmp___39 = a;
#line 591
        a ++;
#line 591
        i ++;
#line 591
        *tmp___39 = *(A + i);
#line 591
        tmp___40 = b;
#line 591
        b ++;
#line 591
        *tmp___40 = (uchar )' ';
#line 591
        tmp___41 = c;
#line 591
        c ++;
#line 591
        *tmp___41 = sign;
#line 591
        op ++;
#line 592
        index___0 ++;
#line 592
        goto switch_break___2;
        case_4___0: /* CIL Label */ 
        case_3___0: /* CIL Label */ 
#line 594
        tmp___42 = a;
#line 594
        a ++;
#line 594
        *tmp___42 = (uchar )'.';
#line 594
        tmp___43 = b;
#line 594
        b ++;
#line 594
        *tmp___43 = (uchar )' ';
#line 594
        tmp___44 = c;
#line 594
        c ++;
#line 594
        *tmp___44 = (uchar )'.';
#line 595
        i ++;
#line 595
        op ++;
#line 595
        index___0 ++;
#line 595
        goto switch_break___2;
        case_5___0: /* CIL Label */ 
#line 596
        tmp___45 = a;
#line 596
        a ++;
#line 596
        *tmp___45 = (uchar )'.';
#line 596
        tmp___46 = b;
#line 596
        b ++;
#line 596
        *tmp___46 = (uchar )' ';
#line 596
        tmp___47 = c;
#line 596
        c ++;
#line 596
        *tmp___47 = (uchar )'.';
#line 597
        i += - op - 3;
#line 597
        op = -3;
#line 597
        index___0 ++;
#line 597
        goto switch_break___2;
        case_7___0: /* CIL Label */ 
        case_6___0: /* CIL Label */ 
#line 599
        tmp___48 = a;
#line 599
        a ++;
#line 599
        i ++;
#line 599
        *tmp___48 = *(A + i);
#line 599
        tmp___49 = b;
#line 599
        b ++;
#line 599
        *tmp___49 = (uchar )' ';
#line 600
        tmp___50 = c;
#line 600
        c ++;
#line 600
        *tmp___50 = sign;
#line 600
        op ++;
#line 600
        index___0 ++;
#line 600
        goto switch_break___2;
        case_8___0: /* CIL Label */ 
#line 601
        tmp___51 = a;
#line 601
        a ++;
#line 601
        i ++;
#line 601
        *tmp___51 = *(A + i);
#line 601
        tmp___52 = b;
#line 601
        b ++;
#line 601
        *tmp___52 = (uchar )' ';
#line 602
        tmp___53 = c;
#line 602
        c ++;
#line 602
        *tmp___53 = sign;
#line 602
        op ++;
#line 602
        index___0 = 0;
#line 602
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      }
    }
#line 608
    if ((unsigned long )a >= (unsigned long )(ALINE + 50)) {
#line 608
      goto _L___1;
    } else
#line 608
    if (i >= M___0) {
#line 608
      if (j >= N___0) {
        _L___1: /* CIL Label */ 
        {
#line 609
        tmp___55 = (uchar )'\000';
#line 609
        *c = tmp___55;
#line 609
        tmp___54 = tmp___55;
#line 609
        *b = tmp___54;
#line 609
        *a = tmp___54;
#line 610
        tmp___56 = lines;
#line 610
        lines ++;
#line 610
        printf((char const   */* __restrict  */)"\n%7d ", 50 * tmp___56);
#line 611
        b = ALINE + 10;
        }
        {
#line 611
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 611
          if (! ((unsigned long )b <= (unsigned long )a)) {
#line 611
            goto while_break___1;
          }
          {
#line 612
          printf((char const   */* __restrict  */)"    .    :");
#line 611
          b += 10;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 613
        if ((unsigned long )b <= (unsigned long )(a + 5)) {
          {
#line 614
          printf((char const   */* __restrict  */)"    .");
          }
        }
        {
#line 615
        printf((char const   */* __restrict  */)"\n%7d %s\n        %s\n%7d %s\n",
               ap, ALINE, CLINE, bp, BLINE);
#line 616
        ap = AP + i;
#line 617
        bp = BP + j;
#line 618
        a = ALINE;
#line 619
        b = BLINE;
#line 620
        c = CLINE;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 623
  return;
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
void Free_script(edit_script *head ) 
{ 
  edit_script *tp ;
  edit_script *tp1 ;

  {
#line 630
  tp = head;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! ((unsigned long )tp != (unsigned long )((void *)0))) {
#line 631
      goto while_break;
    }
    {
#line 632
    tp1 = tp->next;
#line 633
    free((void *)tp);
#line 634
    tp = tp1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 636
  return;
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
static int snake(int k , int x , int endx , int endy ) 
{ 
  int y ;

  {
#line 643
  if (x < 0) {
#line 643
    return (x);
  }
#line 644
  y = x + k;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (x < endx) {
#line 645
      if (y < endy) {
#line 645
        if (! ((int )*(seq1 + x) == (int )*(seq2 + y))) {
#line 645
          goto while_break;
        }
      } else {
#line 645
        goto while_break;
      }
    } else {
#line 645
      goto while_break;
    }
#line 646
    x ++;
#line 646
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  return (x);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/align.c"
static int rsnake(int k , int x , int startx , int starty , int M___0 ) 
{ 
  int y ;

  {
#line 656
  if (x > M___0) {
#line 656
    return (x);
  }
#line 657
  if (startx < 0) {
    {
#line 658
    printf((char const   */* __restrict  */)"TROUBLE!!! startx:  %5d,  starty:  %5d\n",
           startx, starty);
    }
  } else
#line 657
  if (starty < 0) {
    {
#line 658
    printf((char const   */* __restrict  */)"TROUBLE!!! startx:  %5d,  starty:  %5d\n",
           startx, starty);
    }
  }
#line 659
  if (x > M___0) {
    {
#line 660
    printf((char const   */* __restrict  */)"TROUBLE!!! x:  %5d,  y:  %5d\n", x, x + k);
    }
  } else
#line 659
  if (x + k > N) {
    {
#line 660
    printf((char const   */* __restrict  */)"TROUBLE!!! x:  %5d,  y:  %5d\n", x, x + k);
    }
  }
#line 662
  y = x + k;
  {
#line 663
  while (1) {
    while_continue: /* CIL Label */ ;
#line 663
    if (x > startx) {
#line 663
      if (y > starty) {
#line 663
        if (! ((int )*(seq1 + (x - 1)) == (int )*(seq2 + (y - 1)))) {
#line 663
          goto while_break;
        }
      } else {
#line 663
        goto while_break;
      }
    } else {
#line 663
      goto while_break;
    }
#line 664
    x --;
#line 664
    y --;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  return (x);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.h"
charvec_t *charvec_new(void *(*ra)(void * , size_t  ) , void (*fr)(void * ) ) ;
#line 20
charvec_t *charvec_free(charvec_t *t ) ;
#line 21
int charvec_init(charvec_t *t , void *(*a)(void * , size_t  ) , void (*f)(void * ) ) ;
#line 22
int charvec_fini(charvec_t *t ) ;
#line 23
int charvec_need(charvec_t *t , unsigned int n ) ;
#line 24
int charvec_more(charvec_t *t , unsigned int n ) ;
#line 25
int charvec_append(charvec_t *t , char e ) ;
#line 26
int charvec_fit(charvec_t *t ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
charvec_t *charvec_new(void *(*ra)(void * , size_t  ) , void (*fr)(void * ) ) 
{ 
  charvec_t *vec ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 6
  tmp = (*ra)((void *)0, sizeof(*vec));
#line 6
  vec = (charvec_t *)tmp;
  }
#line 7
  if (vec) {
    {
#line 8
    tmp___0 = charvec_init(vec, ra, fr);
    }
#line 8
    if (tmp___0) {
#line 9
      return (vec);
    }
    {
#line 10
    (*fr)((void *)vec);
    }
  }
#line 12
  return ((charvec_t *)0);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
charvec_t *charvec_free(charvec_t *t ) 
{ 


  {
  {
#line 17
  charvec_fini(t);
#line 18
  (*(t->free))((void *)t);
  }
#line 19
  return ((charvec_t *)0);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
int charvec_init(charvec_t *t , void *(*a)(void * , size_t  ) , void (*f)(void * ) ) 
{ 
  int tmp ;

  {
#line 24
  if (! t) {
    {
#line 24
    __assert_fail("t", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  24U, "charvec_init");
    }
  }
  {
#line 25
  t->a = (char *)0;
#line 26
  t->len = 0U;
#line 27
  t->max = 0U;
#line 28
  t->alloc = a;
#line 29
  t->free = f;
#line 30
  tmp = charvec_need(t, 0U);
  }
#line 30
  return (tmp);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
int charvec_fini(charvec_t *t ) 
{ 


  {
#line 35
  if (! t) {
    {
#line 35
    __assert_fail("t", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  35U, "charvec_fini");
    }
  }
#line 37
  if (t->a) {
#line 37
    if (t->free) {
      {
#line 37
      (*(t->free))((void *)t->a);
#line 37
      t->a = (char *)0;
#line 37
      t->max = 0U;
      }
    }
  }
#line 38
  t->len = 0U;
#line 39
  return (1);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
int charvec_need(charvec_t *t , unsigned int n ) 
{ 
  void *tmp ;
  unsigned int i ;
  void *p ;
  void *tmp___0 ;

  {
#line 49
  if (! t) {
    {
#line 49
    __assert_fail("t", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  49U, "charvec_need");
    }
  }
#line 50
  if ((unsigned long )t->a == (unsigned long )((char *)0)) {
#line 51
    if (! t->alloc) {
      {
#line 51
      __assert_fail("t->alloc", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                    51U, "charvec_need");
      }
    }
    {
#line 52
    t->len = 0U;
#line 53
    t->max = n;
#line 54
    tmp = (*(t->alloc))((void *)0, (unsigned long )n * sizeof(char ));
#line 54
    t->a = (char *)tmp;
    }
#line 55
    return ((unsigned long )t->a != (unsigned long )((char *)0));
  }
#line 58
  if (n > t->max) {
    {
#line 59
    i = (30U + n) + (n >> 3);
#line 60
    tmp___0 = (*(t->alloc))((void *)t->a, (unsigned long )i * sizeof(char ));
#line 60
    p = tmp___0;
    }
#line 61
    if (! p) {
#line 62
      return (0);
    }
#line 63
    t->max = i;
#line 64
    t->a = (char *)p;
  }
#line 66
  return (1);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
int charvec_more(charvec_t *t , unsigned int n ) 
{ 
  int tmp ;

  {
#line 71
  if (! t) {
    {
#line 71
    __assert_fail("t", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  71U, "charvec_more");
    }
  }
  {
#line 72
  tmp = charvec_need(t, n + t->len);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
int charvec_append(charvec_t *t , char e ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 77
  if (! t) {
    {
#line 77
    __assert_fail("t", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  77U, "charvec_append");
    }
  }
  {
#line 78
  tmp = charvec_more(t, 1U);
  }
#line 78
  if (! tmp) {
#line 79
    return (0);
  }
#line 80
  tmp___0 = t->len;
#line 80
  (t->len) ++;
#line 80
  *(t->a + tmp___0) = e;
#line 81
  return (1);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c"
int charvec_fit(charvec_t *t ) 
{ 
  unsigned int i ;
  void *p ;
  void *tmp ;

  {
#line 86
  if (! t) {
    {
#line 86
    __assert_fail("t", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  86U, "charvec_fit");
    }
  }
#line 87
  if (! t->alloc) {
    {
#line 87
    __assert_fail("t->alloc", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/charvec.c",
                  87U, "charvec_fit");
    }
  }
  {
#line 90
  i = t->len;
#line 91
  tmp = (*(t->alloc))((void *)t->a, (unsigned long )i * sizeof(char ));
#line 91
  p = tmp;
  }
#line 92
  if (! p) {
#line 93
    return (0);
  }
#line 94
  t->max = i;
#line 95
  t->a = (char *)p;
#line 96
  return (1);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.h"
void get_polyAT(uchar *seq , int len , int *pT , int *pA , int flag ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static void remove_polyT_front(struct edit_script_list **Sptr , Exon *Exons , uchar *s1 ,
                               uchar *s2 , int *lastT ) ;
#line 14
static void remove_polyA_back(struct edit_script_list **Sptr , Exon *Exons , uchar *s1 ,
                              uchar *s2 , int len2 , int *lastA ) ;
#line 15
static void trim_polyT_align(struct edit_script_list **Sptr , Exon **exons , int const   ec ,
                             int *pT , uchar *s1 , uchar *s2 ) ;
#line 16
static void trim_polyA_align(struct edit_script_list **Sptr , Exon *lblock , Exon **exons ,
                             int const   bc , int *pA , uchar *s1 , uchar *s2 ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static char encodingA[128]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static char encodingT[128]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
void get_polyAT(uchar *seq , int len , int *pT , int *pA , int flag ) 
{ 
  register int i ;
  register int sum10 ;
  register int sum20 ;
  register uchar *s ;
  register uchar *t ;
  register uchar *v ;
  int last10 ;
  int MAX10 ;
  int MAX20 ;
  int tmp ;
  int tmp___0 ;

  {
#line 27
  MAX10 = 2;
#line 28
  MAX20 = 5;
#line 31
  if (flag != 1) {
    {
#line 32
    memset((void *)(encodingA), 1, (size_t )128);
#line 33
    encodingA['N'] = (char)0;
#line 33
    encodingA['X'] = encodingA['N'];
#line 33
    encodingA['A'] = encodingA['X'];
#line 35
    i = 0;
#line 35
    s = seq + len;
#line 35
    sum10 = 0;
#line 35
    last10 = len + 1;
    }
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      if (i < 10) {
#line 35
        if ((unsigned long )s > (unsigned long )seq) {
#line 35
          if (! (sum10 <= MAX20)) {
#line 35
            goto while_break;
          }
        } else {
#line 35
          goto while_break;
        }
      } else {
#line 35
        goto while_break;
      }
#line 36
      s --;
#line 36
      sum10 += (int )encodingA[*s];
#line 35
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 40
    v = seq + len;
#line 40
    t = v;
#line 41
    sum20 = sum10;
    {
#line 42
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 42
      if ((unsigned long )s >= (unsigned long )seq) {
#line 42
        if (! (sum10 <= MAX10)) {
#line 42
          if (! (sum20 <= MAX20)) {
#line 42
            goto while_break___0;
          }
        }
      } else {
#line 42
        goto while_break___0;
      }
#line 43
      if (! encodingA[*s]) {
#line 43
        if (sum10 <= MAX10) {
#line 43
          if ((unsigned long )(seq + len) >= (unsigned long )(s + 20)) {
#line 44
            last10 = (int )((s - seq) + 1L);
          } else
#line 43
          if (sum20 < MAX10) {
#line 44
            last10 = (int )((s - seq) + 1L);
          }
        }
      }
#line 45
      s --;
#line 45
      if ((unsigned long )s > (unsigned long )seq) {
#line 46
        t --;
#line 46
        sum10 += (int )encodingA[*s] - (int )encodingA[*t];
#line 47
        if ((seq + len) - s > 20L) {
#line 47
          v --;
#line 47
          tmp = (int )encodingA[*v];
        } else {
#line 47
          tmp = 0;
        }
#line 47
        sum20 += (int )encodingA[*s] - tmp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 51
    if (last10 > len - 10) {
#line 51
      *pA = len + 1;
    } else {
#line 53
      s = (seq + last10) + 8;
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        if (*s) {
#line 54
          if (! (! encodingA[*s])) {
#line 54
            goto while_break___1;
          }
        } else {
#line 54
          goto while_break___1;
        }
#line 54
        s --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 55
      if ((((s - seq) + 1L) - (long )last10) + 1L <= 5L) {
#line 56
        *pA = (int )((s - seq) + 2L);
      } else {
#line 58
        *pA = last10;
      }
    }
  } else {
#line 60
    *pA = len + 1;
  }
#line 61
  *pA = (len - *pA) + 1;
#line 63
  if (flag != 2) {
    {
#line 65
    memset((void *)(encodingT), 1, (size_t )128);
#line 66
    encodingT['N'] = (char)0;
#line 66
    encodingT['X'] = encodingT['N'];
#line 66
    encodingT['T'] = encodingT['X'];
#line 68
    i = 0;
#line 68
    s = seq - 1;
#line 68
    sum10 = 0;
#line 68
    last10 = 0;
    }
    {
#line 68
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 68
      if (i < 10) {
#line 68
        if (i < len - 1) {
#line 68
          if (! (sum10 <= MAX20)) {
#line 68
            goto while_break___2;
          }
        } else {
#line 68
          goto while_break___2;
        }
      } else {
#line 68
        goto while_break___2;
      }
#line 69
      s ++;
#line 69
      sum10 += (int )encodingT[*s];
#line 68
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 73
    v = seq - 1;
#line 73
    t = v;
#line 74
    sum20 = sum10;
    {
#line 75
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 75
      if ((unsigned long )s < (unsigned long )(seq + len)) {
#line 75
        if (! (sum10 <= MAX10)) {
#line 75
          if (! (sum20 <= MAX20)) {
#line 75
            goto while_break___3;
          }
        }
      } else {
#line 75
        goto while_break___3;
      }
#line 76
      if (! encodingT[*s]) {
#line 76
        if (sum10 <= MAX10) {
#line 76
          if (s - seq >= 19L) {
#line 77
            last10 = (int )((s - seq) + 1L);
          } else
#line 76
          if (sum20 < MAX10) {
#line 77
            last10 = (int )((s - seq) + 1L);
          }
        }
      }
#line 78
      s ++;
#line 78
      if ((unsigned long )s < (unsigned long )(seq + len)) {
#line 79
        t ++;
#line 79
        sum10 += (int )encodingT[*s] - (int )encodingT[*t];
#line 80
        if (s - seq >= 20L) {
#line 80
          v ++;
#line 80
          tmp___0 = (int )encodingT[*v];
        } else {
#line 80
          tmp___0 = 0;
        }
#line 80
        sum20 += (int )encodingT[*s] - tmp___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 84
    if (last10 <= 10) {
#line 84
      *pT = 0;
    } else {
#line 86
      s = (seq + last10) - 10;
      {
#line 87
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 87
        if (*s) {
#line 87
          if (! (! encodingT[*s])) {
#line 87
            goto while_break___4;
          }
        } else {
#line 87
          goto while_break___4;
        }
#line 87
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 88
      if (((long )last10 - (s - seq)) + 1L <= 5L) {
#line 89
        *pT = (int )(s - seq);
      } else {
#line 91
        *pT = last10;
      }
    }
  } else {
#line 93
    *pT = 0;
  }
#line 94
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
void remove_poly(struct edit_script_list **Script , Exon *Exons , uchar *s1 , uchar *s2 ,
                 int len2 , int *pT , int *pA ) 
{ 


  {
  {
#line 99
  remove_polyT_front(Script, Exons, s1, s2, pT);
#line 100
  remove_polyA_back(Script, Exons, s1, s2, len2, pA);
#line 101
  *pA = (len2 - *pA) + 1;
  }
#line 104
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static void remove_polyA_back(struct edit_script_list **Sptr , Exon *Exons , uchar *s1 ,
                              uchar *s2 , int len2 , int *lastA ) 
{ 
  Exon *t ;
  Exon *exons_tail ;
  Exon *prev ;
  uchar *b ;
  uchar *end ;
  int numA ;
  int pA ;
  int dummy ;
  int trim_p ;
  int reverse_script ;
  uchar *tmp ;
  int ct_pA ;

  {
#line 110
  reverse_script = 0;
#line 112
  *lastA = len2 + 1;
#line 112
  pA = 0;
#line 113
  if (! Exons) {
#line 113
    return;
  } else
#line 113
  if (! Exons->next_exon) {
#line 113
    return;
  } else
#line 113
  if (! (Exons->next_exon)->to1) {
#line 113
    return;
  }
#line 115
  if ((*Sptr)->next_script) {
#line 115
    if ((*Sptr)->offset1 < ((*Sptr)->next_script)->offset1) {
      {
#line 117
      reverse_script = 1;
#line 118
      script_flip_list(Sptr);
      }
    }
  }
#line 122
  exons_tail = Exons->next_exon;
#line 122
  prev = Exons;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (exons_tail->next_exon) {
#line 123
      if (! (exons_tail->next_exon)->to1) {
#line 123
        goto while_break;
      }
    } else {
#line 123
      goto while_break;
    }
#line 123
    prev = exons_tail;
#line 123
    exons_tail = exons_tail->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  trim_p = 1;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    t = exons_tail;
#line 127
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 127
      if (t->to1) {
#line 127
        if (! trim_p) {
#line 127
          goto while_break___0;
        }
      } else {
#line 127
        goto while_break___0;
      }
    } else {
#line 127
      goto while_break___0;
    }
#line 129
    b = (s2 + t->to2) - 1;
#line 129
    end = (s2 + t->from2) - 1;
#line 129
    numA = 0;
    {
#line 130
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 130
      if ((unsigned long )b >= (unsigned long )end) {
#line 130
        if (! ((double )((long )numA + (b - s2)) >= .60 * (double )t->length)) {
#line 130
          goto while_break___1;
        }
      } else {
#line 130
        goto while_break___1;
      }
#line 131
      tmp = b;
#line 131
      b --;
#line 131
      numA += (int )*tmp == 65;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 133
    if ((double )numA >= .60 * (double )t->length) {
      {
#line 135
      trim_polyA_align(Sptr, Exons, & exons_tail, (int const   )t->from2, lastA, s1,
                       s2);
      }
    } else {
      {
#line 138
      get_polyAT((s2 + (*Sptr)->offset2) - 1, (*Sptr)->len2, & dummy, & pA, 2);
      }
#line 139
      if (pA) {
#line 142
        ct_pA = (t->to2 - pA) + 1;
#line 143
        if (ct_pA - t->from2 >= 12) {
#line 143
          ct_pA = ct_pA;
        } else {
#line 143
          ct_pA = t->from2;
        }
        {
#line 145
        trim_polyA_align(Sptr, Exons, & exons_tail, (int const   )ct_pA, lastA, s1,
                         s2);
        }
      }
#line 147
      if ((unsigned long )t == (unsigned long )exons_tail) {
#line 147
        trim_p = 0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  if (reverse_script) {
    {
#line 151
    script_flip_list(Sptr);
    }
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static void trim_polyA_align(struct edit_script_list **Sptr , Exon *lblock , Exon **exons ,
                             int const   bc , int *pA , uchar *s1 , uchar *s2 ) 
{ 
  edit_script_list *head ;
  edit_script *tp ;
  int tmpi ;
  int num ;
  int idents ;
  uchar *a ;
  uchar *b ;
  Exon *prev ;
  int i ;
  int j ;
  uchar *tmp ;
  uchar *tmp___0 ;
  uchar *tmp___1 ;
  uchar *tmp___2 ;
  double tmp_matches ;

  {
#line 156
  head = *Sptr;
#line 158
  tmpi = 0;
#line 158
  idents = 0;
#line 164
  if (bc > (int const   )((head->offset2 + head->len2) - 1)) {
#line 165
    *pA = (int )bc;
#line 166
    return;
  }
#line 169
  if (bc == (int const   )head->offset2) {
    {
#line 171
    *Sptr = head->next_script;
#line 172
    Free_script(head->script);
#line 173
    free((void *)head);
    }
    {
#line 174
    while (1) {
      while_continue: /* CIL Label */ ;
#line 174
      if (! ((*exons)->from2 >= (int )bc)) {
#line 174
        goto while_break;
      }
      {
#line 175
      prev = find_previous(lblock, *exons);
#line 176
      prev->next_exon = (*exons)->next_exon;
#line 177
      free((void *)*exons);
#line 177
      *exons = prev;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 179
    *pA = (int )bc;
#line 180
    return;
  }
  {
#line 183
  Flip_script(& head->script);
#line 184
  i = (head->offset2 + head->len2) - 1;
#line 185
  j = (head->offset1 + head->len1) - 1;
#line 186
  tp = head->script;
  }
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 188
    if (i >= (int )bc) {
#line 188
      if (! tp) {
#line 188
        goto while_break___0;
      }
    } else {
#line 188
      goto while_break___0;
    }
#line 189
    num = tp->num;
    {
#line 191
    if ((int )tp->op_type == 2) {
#line 191
      goto case_2;
    }
#line 199
    if ((int )tp->op_type == 1) {
#line 199
      goto case_1;
    }
#line 203
    if ((int )tp->op_type == 3) {
#line 203
      goto case_3;
    }
#line 222
    goto switch_default;
    case_2: /* CIL Label */ 
#line 192
    if (i >= (int )bc) {
#line 192
      if (bc > (int const   )((i - num) + 1)) {
#line 193
        tmpi += (i - (int )bc) + 1;
#line 193
        tp->num -= (i - (int )bc) + 1;
#line 193
        i = (int )(bc - 1);
      } else {
        {
#line 195
        i -= num;
#line 195
        tmpi += num;
#line 195
        head->script = tp->next;
#line 196
        free((void *)tp);
#line 196
        tp = head->script;
        }
      }
    } else {
      {
#line 195
      i -= num;
#line 195
      tmpi += num;
#line 195
      head->script = tp->next;
#line 196
      free((void *)tp);
#line 196
      tp = head->script;
      }
    }
#line 198
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 200
    j -= num;
#line 200
    tmpi += num;
#line 200
    head->script = tp->next;
#line 201
    free((void *)tp);
#line 201
    tp = head->script;
    }
#line 202
    goto switch_break;
    case_3: /* CIL Label */ 
#line 204
    if (i >= (int )bc) {
#line 204
      if (bc > (int const   )((i - num) + 1)) {
#line 205
        a = (s2 + i) - 1;
#line 205
        b = (s1 + j) - 1;
        {
#line 206
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 206
          if (! ((unsigned long )a >= (unsigned long )((s2 + bc) - 1))) {
#line 206
            goto while_break___1;
          }
#line 207
          tmp = a;
#line 207
          a --;
#line 207
          tmp___0 = b;
#line 207
          b --;
#line 207
          if ((int )*tmp != (int )*tmp___0) {
#line 207
            tmpi ++;
          } else {
#line 207
            idents ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 209
        j -= (i - (int )bc) + 1;
#line 209
        tp->num -= (i - (int )bc) + 1;
#line 209
        i = (int )(bc - 1);
      } else {
#line 204
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 212
      a = (s2 + i) - 1;
#line 212
      b = (s1 + j) - 1;
      {
#line 213
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 213
        if (! ((unsigned long )a >= (unsigned long )((s2 + i) - num))) {
#line 213
          goto while_break___2;
        }
#line 214
        tmp___1 = a;
#line 214
        a --;
#line 214
        tmp___2 = b;
#line 214
        b --;
#line 214
        if ((int )*tmp___1 != (int )*tmp___2) {
#line 214
          tmpi ++;
        } else {
#line 214
          idents ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 217
      i -= num;
#line 217
      j -= num;
#line 218
      head->script = tp->next;
#line 219
      free((void *)tp);
#line 219
      tp = head->script;
      }
    }
#line 221
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 222
    fatalf("Unrecognized opcode %d.\n", (int )tp->op_type);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 226
  if (! (i == (int )(bc - 1))) {
    {
#line 226
    __assert_fail("i==bc-1", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c",
                  226U, "trim_polyA_align");
    }
  }
  {
#line 228
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 228
    if ((int )tp->op_type != 3) {
#line 228
      if (! (j + 1 >= (*exons)->from1)) {
#line 228
        goto while_break___3;
      }
    } else {
#line 228
      goto while_break___3;
    }
#line 229
    if ((int )tp->op_type == 2) {
#line 230
      i -= tp->num;
#line 230
      tmpi += tp->num;
    } else
#line 231
    if (j < (*exons)->from1) {
#line 231
      if (i < (*exons)->from2) {
#line 232
        j -= tp->num;
      } else {
#line 234
        j -= tp->num;
#line 234
        tmpi += tp->num;
      }
    } else {
#line 234
      j -= tp->num;
#line 234
      tmpi += tp->num;
    }
    {
#line 236
    head->script = tp->next;
#line 237
    free((void *)tp);
#line 237
    tp = head->script;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 240
  if ((unsigned long )head->script == (unsigned long )((void *)0)) {
    {
#line 241
    *Sptr = head->next_script;
#line 242
    free((void *)head);
    }
  } else {
    {
#line 244
    head->len1 = (j - head->offset1) + 1;
#line 245
    head->len2 = (i - head->offset2) + 1;
#line 246
    head->score -= tmpi;
#line 247
    Flip_script(& head->script);
    }
  }
#line 250
  if ((*exons)->from2 > i) {
    {
#line 251
    prev = find_previous(lblock, *exons);
#line 252
    prev->next_exon = (*exons)->next_exon;
#line 253
    free((void *)*exons);
#line 253
    *exons = prev;
    }
  } else {
#line 256
    (*exons)->to2 = i;
#line 257
    (*exons)->to1 = j;
#line 258
    (*exons)->length = ((*exons)->to2 - (*exons)->from2) + 1;
#line 259
    tmp_matches = (double )((*exons)->nmatches - idents);
#line 260
    (*exons)->alen -= tmpi + idents;
#line 261
    (*exons)->match = (int )(((double )100 * tmp_matches) / (double )(*exons)->alen);
  }
#line 263
  *pA = i + 1;
#line 265
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static void remove_polyT_front(struct edit_script_list **Sptr , Exon *Exons , uchar *s1 ,
                               uchar *s2 , int *lastT ) 
{ 
  Exon *t ;
  Exon *exons_head ;
  uchar *b ;
  uchar *end ;
  int numT ;
  int dummy ;
  int trim_p ;
  int reverse_script ;
  int pT ;
  uchar *tmp ;
  int ct_pT ;

  {
#line 273
  reverse_script = 0;
#line 275
  pT = 0;
#line 275
  *lastT = pT;
#line 276
  if (! Exons) {
#line 276
    return;
  } else
#line 276
  if (! Exons->next_exon) {
#line 276
    return;
  } else
#line 276
  if (! (Exons->next_exon)->to1) {
#line 276
    return;
  }
#line 278
  if ((*Sptr)->next_script) {
#line 278
    if ((*Sptr)->offset1 > ((*Sptr)->next_script)->offset1) {
      {
#line 280
      script_flip_list(Sptr);
#line 281
      reverse_script = 1;
      }
    }
  }
#line 284
  exons_head = Exons->next_exon;
#line 284
  trim_p = 1;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    t = exons_head;
#line 285
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 285
      if (t->to1) {
#line 285
        if (! trim_p) {
#line 285
          goto while_break;
        }
      } else {
#line 285
        goto while_break;
      }
    } else {
#line 285
      goto while_break;
    }
#line 287
    b = (s2 + t->from2) - 1;
#line 287
    end = s2 + t->to2;
#line 287
    numT = 0;
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 288
      if ((unsigned long )b < (unsigned long )end) {
#line 288
        if (! ((double )((long )(numT + t->to2) - (((b - s2) - (long )t->from2) + 1L)) >= .60 * (double )t->length)) {
#line 288
          goto while_break___0;
        }
      } else {
#line 288
        goto while_break___0;
      }
#line 289
      tmp = b;
#line 289
      b ++;
#line 289
      numT += (int )*tmp == 84;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 291
    if ((double )numT >= .60 * (double )t->length) {
      {
#line 293
      trim_polyT_align(Sptr, & exons_head, (int const   )t->to2, lastT, s1, s2);
      }
    } else {
      {
#line 296
      get_polyAT((s2 + (*Sptr)->offset2) - 1, (*Sptr)->len2, & pT, & dummy, 1);
      }
#line 297
      if (pT) {
#line 299
        ct_pT = (pT + (*Sptr)->offset2) - 1;
#line 300
        if (t->to2 - ct_pT >= 12) {
#line 300
          ct_pT = ct_pT;
        } else {
#line 300
          ct_pT = t->to2;
        }
        {
#line 301
        trim_polyT_align(Sptr, & exons_head, (int const   )ct_pT, lastT, s1, s2);
        }
      }
#line 303
      if ((unsigned long )t == (unsigned long )exons_head) {
#line 303
        trim_p = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  Exons->next_exon = exons_head;
#line 307
  if (reverse_script) {
    {
#line 307
    script_flip_list(Sptr);
    }
  }
#line 308
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c"
static void trim_polyT_align(struct edit_script_list **Sptr , Exon **exons , int const   ec ,
                             int *pT , uchar *s1 , uchar *s2 ) 
{ 
  edit_script_list *head ;
  edit_script *tp ;
  int tmpi ;
  int num ;
  int idents ;
  uchar *a ;
  uchar *b ;
  Exon *t ;
  int i ;
  int j ;
  uchar *tmp ;
  uchar *tmp___0 ;
  uchar *tmp___1 ;
  uchar *tmp___2 ;
  double tmp_matches ;

  {
#line 313
  head = *Sptr;
#line 315
  tmpi = 0;
#line 315
  idents = 0;
#line 321
  if (ec < (int const   )head->offset2) {
#line 322
    *pT = (int )ec;
#line 323
    return;
  }
#line 326
  if (ec == (int const   )((head->offset2 + head->len2) - 1)) {
    {
#line 328
    *Sptr = head->next_script;
#line 329
    Free_script(head->script);
#line 330
    free((void *)head);
    }
    {
#line 331
    while (1) {
      while_continue: /* CIL Label */ ;
#line 331
      if (! ((*exons)->from2 < (int )ec)) {
#line 331
        goto while_break;
      }
      {
#line 332
      t = *exons;
#line 332
      *exons = t->next_exon;
#line 332
      free((void *)t);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 334
    *pT = (int )ec;
#line 335
    return;
  }
#line 338
  i = head->offset2;
#line 339
  j = head->offset1;
#line 340
  tp = head->script;
  {
#line 342
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 342
    if (i <= (int )ec) {
#line 342
      if (! tp) {
#line 342
        goto while_break___0;
      }
    } else {
#line 342
      goto while_break___0;
    }
#line 343
    num = tp->num;
    {
#line 345
    if ((int )tp->op_type == 2) {
#line 345
      goto case_2;
    }
#line 353
    if ((int )tp->op_type == 1) {
#line 353
      goto case_1;
    }
#line 357
    if ((int )tp->op_type == 3) {
#line 357
      goto case_3;
    }
#line 376
    goto switch_default;
    case_2: /* CIL Label */ 
#line 346
    if (i <= (int )ec) {
#line 346
      if (ec < (int const   )((i + num) - 1)) {
#line 347
        tmpi += (int )((ec - (int const   )i) + 1);
#line 347
        tp->num -= (int )((ec - (int const   )i) + 1);
#line 347
        i = (int )(ec + 1);
      } else {
        {
#line 349
        i += num;
#line 349
        tmpi += num;
#line 349
        head->script = tp->next;
#line 350
        free((void *)tp);
#line 350
        tp = head->script;
        }
      }
    } else {
      {
#line 349
      i += num;
#line 349
      tmpi += num;
#line 349
      head->script = tp->next;
#line 350
      free((void *)tp);
#line 350
      tp = head->script;
      }
    }
#line 352
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 354
    j += num;
#line 354
    tmpi += num;
#line 354
    head->script = tp->next;
#line 355
    free((void *)tp);
#line 355
    tp = head->script;
    }
#line 356
    goto switch_break;
    case_3: /* CIL Label */ 
#line 358
    if (i <= (int )ec) {
#line 358
      if (ec < (int const   )((i + num) - 1)) {
#line 359
        a = (s2 + i) - 1;
#line 359
        b = (s1 + j) - 1;
        {
#line 360
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 360
          if (! ((unsigned long )a < (unsigned long )(s2 + ec))) {
#line 360
            goto while_break___1;
          }
#line 361
          tmp = a;
#line 361
          a ++;
#line 361
          tmp___0 = b;
#line 361
          b ++;
#line 361
          if ((int )*tmp != (int )*tmp___0) {
#line 361
            tmpi ++;
          } else {
#line 361
            idents ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 363
        j += (int )((ec - (int const   )i) + 1);
#line 363
        tp->num -= (int )((ec - (int const   )i) + 1);
#line 363
        i = (int )(ec + 1);
      } else {
#line 358
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 366
      a = (s2 + i) - 1;
#line 366
      b = (s1 + j) - 1;
      {
#line 367
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 367
        if (! ((unsigned long )a < (unsigned long )(((s2 + i) + tp->num) - 1))) {
#line 367
          goto while_break___2;
        }
#line 368
        tmp___1 = a;
#line 368
        a ++;
#line 368
        tmp___2 = b;
#line 368
        b ++;
#line 368
        if ((int )*tmp___1 != (int )*tmp___2) {
#line 368
          tmpi ++;
        } else {
#line 368
          idents ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 371
      i += num;
#line 371
      j += num;
#line 372
      head->script = tp->next;
#line 373
      free((void *)tp);
#line 373
      tp = head->script;
      }
    }
#line 375
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 376
    fatalf("Unrecognized opcode %d.\n", (int )tp->op_type);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 380
  if (! (i == (int )(ec + 1))) {
    {
#line 380
    __assert_fail("i==ec+1", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/poly.c",
                  380U, "trim_polyT_align");
    }
  }
  {
#line 382
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 382
    if ((int )tp->op_type != 3) {
#line 382
      if (! (j - 1 <= (*exons)->to1)) {
#line 382
        goto while_break___3;
      }
    } else {
#line 382
      goto while_break___3;
    }
#line 383
    if ((int )tp->op_type == 2) {
#line 384
      i += tp->num;
#line 384
      tmpi += tp->num;
    } else
#line 385
    if (j >= (*exons)->to1) {
#line 385
      if (i >= (*exons)->to2) {
#line 386
        j += tp->num;
      } else {
#line 388
        j += tp->num;
#line 388
        tmpi += tp->num;
      }
    } else {
#line 388
      j += tp->num;
#line 388
      tmpi += tp->num;
    }
    {
#line 390
    head->script = tp->next;
#line 391
    free((void *)tp);
#line 391
    tp = head->script;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 394
  if ((unsigned long )head->script == (unsigned long )((void *)0)) {
    {
#line 395
    *Sptr = head->next_script;
#line 396
    free((void *)head);
    }
  } else {
#line 398
    head->len1 -= j - head->offset1;
#line 399
    head->len2 -= i - head->offset2;
#line 400
    head->offset2 = i;
#line 401
    head->offset1 = j;
#line 402
    head->score -= tmpi;
  }
#line 405
  if ((*exons)->to2 < i) {
    {
#line 406
    t = *exons;
#line 406
    *exons = t->next_exon;
#line 406
    free((void *)t);
    }
  } else {
#line 409
    (*exons)->from2 = i;
#line 410
    (*exons)->from1 = j;
#line 411
    (*exons)->length = ((*exons)->to2 - (*exons)->from2) + 1;
#line 412
    tmp_matches = (double )((*exons)->nmatches - idents);
#line 413
    (*exons)->alen -= tmpi + idents;
#line 414
    (*exons)->match = (int )(((double )100 * tmp_matches) / (double )(*exons)->alen);
  }
#line 416
  *pT = i - 1;
#line 417
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
bool get_strargval(int c , char **val_ptr ) ;
#line 17
void ckargs(char const   *options , int argcx , char **argvx , int non_options ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/discrim.h"
bool is_DNA(uchar *s , int len ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void init_stats(sim4_stats_t *st ) ;
#line 67
static void sim4_argvals(sim4_args_t *args ) ;
#line 68
static void cds_range(char *line , int *from , int *to ) ;
#line 69
static char *extract_tok(char *h2 ) ;
#line 71
static void add_offset_exons(Exon *exons , int offset ) ;
#line 72
static void add_offset_aligns(edit_script_list *aligns , int offset ) ;
#line 73
static void print_align_blk(uchar *seq1___0 , uchar *seq2___0 , int len1 , int len2 ,
                            edit_script_list **Aligns , int file_type___0 , int match_ori ) ;
#line 74
static void print_align_lat(uchar *seq1___0 , uchar *seq2___0 , int len1 , int len2 ,
                            edit_script_list **Aligns , Exon *Exons , int file_type___0 ,
                            int match_ori ) ;
#line 76 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static char const   Usage[1733]  = 
#line 76
  {      (char const   )'%',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'q',      (char const   )'1',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'q',      (char const   )'2', 
        (char const   )'_',      (char const   )'d',      (char const   )'b',      (char const   )' ', 
        (char const   )'[',      (char const   )'[',      (char const   )'W',      (char const   )'X', 
        (char const   )'K',      (char const   )'C',      (char const   )'R',      (char const   )'D', 
        (char const   )'H',      (char const   )'A',      (char const   )'P',      (char const   )'N', 
        (char const   )'B',      (char const   )'S',      (char const   )']',      (char const   )'=', 
        (char const   )']',      (char const   )'\n',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'W',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )' ', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'d', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )'.',      (char const   )' ',      (char const   )'(', 
        (char const   )'W',      (char const   )'=',      (char const   )'1',      (char const   )'2', 
        (char const   )')',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'X',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )' ',      (char const   )' ',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'u',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'w',      (char const   )'o',      (char const   )'r', 
        (char const   )'d',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )'.',      (char const   )' ',      (char const   )'(',      (char const   )'X', 
        (char const   )'=',      (char const   )'1',      (char const   )'2',      (char const   )')', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'K',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )' ',      (char const   )' ',      (char const   )'M',      (char const   )'S', 
        (char const   )'P',      (char const   )' ',      (char const   )'s',      (char const   )'c', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'h',      (char const   )'o',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'r',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'s',      (char const   )'s', 
        (char const   )'.',      (char const   )' ',      (char const   )'(',      (char const   )'e', 
        (char const   )'.',      (char const   )'g',      (char const   )'.',      (char const   )',', 
        (char const   )' ',      (char const   )'K',      (char const   )'=',      (char const   )'1', 
        (char const   )'6',      (char const   )')',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'C',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )' ', 
        (char const   )'M',      (char const   )'S',      (char const   )'P',      (char const   )' ', 
        (char const   )'s',      (char const   )'c',      (char const   )'o',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'h', 
        (char const   )'o',      (char const   )'l',      (char const   )'d',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )'.', 
        (char const   )' ',      (char const   )'(',      (char const   )'e',      (char const   )'.', 
        (char const   )'g',      (char const   )'.',      (char const   )',',      (char const   )' ', 
        (char const   )'C',      (char const   )'=',      (char const   )'1',      (char const   )'2', 
        (char const   )')',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'R',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )' ',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'a',      (char const   )'r', 
        (char const   )'c',      (char const   )'h',      (char const   )';',      (char const   )' ', 
        (char const   )'0',      (char const   )' ',      (char const   )'-',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'a',      (char const   )'r', 
        (char const   )'c',      (char const   )'h',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'\'', 
        (char const   )'+',      (char const   )'\'',      (char const   )' ',      (char const   )'(', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )')',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'l',      (char const   )'y',      (char const   )';', 
        (char const   )' ',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'1', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'a',      (char const   )'r',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'\'',      (char const   )'-', 
        (char const   )'\'',      (char const   )' ',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )';',      (char const   )' ',      (char const   )'2', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'a',      (char const   )'r',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'b',      (char const   )'o', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'s',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'p', 
        (char const   )'o',      (char const   )'r',      (char const   )'t',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'b',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'.',      (char const   )' ', 
        (char const   )'(',      (char const   )'R',      (char const   )'=',      (char const   )'2', 
        (char const   )')',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'D',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )' ',      (char const   )' ',      (char const   )'b', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'a',      (char const   )'g',      (char const   )'o',      (char const   )'n', 
        (char const   )'a',      (char const   )'l',      (char const   )'s',      (char const   )' ', 
        (char const   )'w',      (char const   )'i',      (char const   )'t',      (char const   )'h', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )'e', 
        (char const   )'c',      (char const   )'u',      (char const   )'t',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'s',      (char const   )'p',      (char const   )'s',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'e', 
        (char const   )'x',      (char const   )'o',      (char const   )'n',      (char const   )'.', 
        (char const   )' ',      (char const   )'(',      (char const   )'D',      (char const   )'=', 
        (char const   )'1',      (char const   )'0',      (char const   )')',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'H', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )' ', 
        (char const   )' ',      (char const   )'w',      (char const   )'e',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'M', 
        (char const   )'S',      (char const   )'P',      (char const   )' ',      (char const   )'s', 
        (char const   )'c',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'k',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )'.',      (char const   )' ', 
        (char const   )'(',      (char const   )'H',      (char const   )'=',      (char const   )'5', 
        (char const   )'0',      (char const   )'0',      (char const   )')',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'A', 
        (char const   )' ',      (char const   )' ',      (char const   )'-',      (char const   )' ', 
        (char const   )' ',      (char const   )'o',      (char const   )'u',      (char const   )'t', 
        (char const   )'p',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )':',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'e',      (char const   )'n',      (char const   )'d', 
        (char const   )'p',      (char const   )'o',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'l',      (char const   )'y',      (char const   )' ', 
        (char const   )'(',      (char const   )'A',      (char const   )'=',      (char const   )'0', 
        (char const   )')',      (char const   )',',      (char const   )' ',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'t',      (char const   )'e',      (char const   )'x', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'A', 
        (char const   )'=',      (char const   )'1',      (char const   )')',      (char const   )',', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'g',      (char const   )'n',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'l', 
        (char const   )'a',      (char const   )'v',      (char const   )' ',      (char const   )'(', 
        (char const   )'b',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'k',      (char const   )')',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'A', 
        (char const   )'=',      (char const   )'2',      (char const   )')',      (char const   )',', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'b',      (char const   )'o',      (char const   )'t',      (char const   )'h', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'p',      (char const   )'o',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'s',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'i', 
        (char const   )'g',      (char const   )'n',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'t', 
        (char const   )'e',      (char const   )'x',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'A',      (char const   )'=',      (char const   )'3', 
        (char const   )',',      (char const   )' ',      (char const   )'A',      (char const   )'=', 
        (char const   )'4',      (char const   )')',      (char const   )'.',      (char const   )' ', 
        (char const   )'I',      (char const   )'f',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )'m',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )',', 
        (char const   )' ',      (char const   )'A',      (char const   )'=',      (char const   )'0', 
        (char const   )',',      (char const   )'1',      (char const   )',',      (char const   )'2', 
        (char const   )',',      (char const   )'3',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'g',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'r', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'s',      (char const   )'i', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'q',      (char const   )'u',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )'m',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'s',      (char const   )'i', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'h',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )'.', 
        (char const   )' ',      (char const   )'A',      (char const   )'=',      (char const   )'4', 
        (char const   )' ',      (char const   )'g',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )' ',      (char const   )'p',      (char const   )'o', 
        (char const   )'s',      (char const   )'i',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'s',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )',', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'l',      (char const   )'a',      (char const   )'t', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'.', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'A',      (char const   )'=', 
        (char const   )'5',      (char const   )' ',      (char const   )'p',      (char const   )'r', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'C',      (char const   )'D', 
        (char const   )'S',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'o',      (char const   )'r',      (char const   )'d',      (char const   )'i', 
        (char const   )'n',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'(',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )',',      (char const   )' ',      (char const   )'i', 
        (char const   )'f',      (char const   )' ',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )')', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'e',      (char const   )'x', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'\'', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'q',      (char const   )'u', 
        (char const   )'i',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )' ', 
        (char const   )'P',      (char const   )'i',      (char const   )'p',      (char const   )'M', 
        (char const   )'a',      (char const   )'k',      (char const   )'e',      (char const   )'r', 
        (char const   )'.',      (char const   )' ',      (char const   )'T',      (char const   )'o', 
        (char const   )' ',      (char const   )'b',      (char const   )'e',      (char const   )' ', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'f', 
        (char const   )'u',      (char const   )'l',      (char const   )'l',      (char const   )'-', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )' ',      (char const   )'m', 
        (char const   )'R',      (char const   )'N',      (char const   )'A',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'q',      (char const   )'u', 
        (char const   )'e',      (char const   )'n',      (char const   )'c',      (char const   )'e', 
        (char const   )'s',      (char const   )'.',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'P',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )' ', 
        (char const   )'i',      (char const   )'f',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'0', 
        (char const   )',',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'v',      (char const   )'e', 
        (char const   )' ',      (char const   )'p',      (char const   )'o',      (char const   )'l', 
        (char const   )'y',      (char const   )'-',      (char const   )'A',      (char const   )' ', 
        (char const   )'t',      (char const   )'a',      (char const   )'i',      (char const   )'l', 
        (char const   )'s',      (char const   )';',      (char const   )' ',      (char const   )'r', 
        (char const   )'e',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'o',      (char const   )'r',      (char const   )'d',      (char const   )'i', 
        (char const   )'n',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'\'', 
        (char const   )'+',      (char const   )'\'',      (char const   )' ',      (char const   )'(', 
        (char const   )'d',      (char const   )'i',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )')',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )'m',      (char const   )'e',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'s',      (char const   )';',      (char const   )' ',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'l', 
        (char const   )'a',      (char const   )'v',      (char const   )' ',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'h', 
        (char const   )'e',      (char const   )'a',      (char const   )'d',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'p',      (char const   )'l',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )'.',      (char const   )' ',      (char const   )'(', 
        (char const   )'P',      (char const   )'=',      (char const   )'0',      (char const   )')', 
        (char const   )' ',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'N',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )' ',      (char const   )' ',      (char const   )'a', 
        (char const   )'c',      (char const   )'c',      (char const   )'u',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'q',      (char const   )'u',      (char const   )'e', 
        (char const   )'n',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'(',      (char const   )'n',      (char const   )'o', 
        (char const   )'n',      (char const   )'-',      (char const   )'z',      (char const   )'e', 
        (char const   )'r',      (char const   )'o',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'h', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'l', 
        (char const   )'y',      (char const   )' ',      (char const   )'a',      (char const   )'c', 
        (char const   )'c',      (char const   )'u',      (char const   )'r',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )')',      (char const   )'.', 
        (char const   )' ',      (char const   )'(',      (char const   )'N',      (char const   )'=', 
        (char const   )'0',      (char const   )')',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'B',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )' ',      (char const   )' ', 
        (char const   )'i',      (char const   )'f',      (char const   )' ',      (char const   )'0', 
        (char const   )',',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'-',      (char const   )'a',      (char const   )'l', 
        (char const   )'l',      (char const   )'o',      (char const   )'w',      (char const   )' ', 
        (char const   )'a',      (char const   )'m',      (char const   )'b',      (char const   )'i', 
        (char const   )'g',      (char const   )'u',      (char const   )'i',      (char const   )'t', 
        (char const   )'y',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'(',      (char const   )'o',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'N',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'X',      (char const   )')', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'q', 
        (char const   )'u',      (char const   )'e',      (char const   )'n',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'a',      (char const   )'.',      (char const   )' ', 
        (char const   )'(',      (char const   )'B',      (char const   )'=',      (char const   )'1', 
        (char const   )')',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'S',      (char const   )' ',      (char const   )' ', 
        (char const   )'-',      (char const   )' ',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'d',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'s',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'c',      (char const   )'a',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'(', 
        (char const   )'a',      (char const   )'v',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'n', 
        (char const   )'l',      (char const   )'y',      (char const   )' ',      (char const   )'w', 
        (char const   )'i',      (char const   )'t',      (char const   )'h',      (char const   )' ', 
        (char const   )'A',      (char const   )'=',      (char const   )'5',      (char const   )')', 
        (char const   )';',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )':',      (char const   )' ',      (char const   )'S', 
        (char const   )'=',      (char const   )'n',      (char const   )'1',      (char const   )'.', 
        (char const   )'.',      (char const   )'n',      (char const   )'2',      (char const   )'\n', 
        (char const   )'\000'};
#line 118 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
int main(int argc___0 , char **argv___0 ) 
{ 
  uchar *revseq1 ;
  int len1 ;
  int len2 ;
  int count ;
  int dist ;
  int match_ori ;
  int in_K ;
  int in_C ;
  int in_H ;
  int pA ;
  int pT ;
  int xpT ;
  int xpA ;
  int rev_xpT ;
  int rev_xpA ;
  int cds_from ;
  int cds_to ;
  uchar *seq1___0 ;
  uchar *seq2___0 ;
  char *h2 ;
  char *h1 ;
  char *cds_gene ;
  char *line ;
  SEQ *sf1 ;
  SEQ *sf2 ;
  SEQ *rf1 ;
  argv_scores_t ds ;
  ss_t ss ;
  Exon *Exons ;
  Exon *rev_Exons ;
  edit_script_list *Aligns ;
  edit_script_list *rev_Aligns ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  sim4_stats_t st ;
  sim4_stats_t rev_st ;
  char *tok ;
  char tmp___5[200] ;
  bool tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  struct edit_script_list *tmp___9 ;
  struct edit_script_list *tmp___10 ;
  struct edit_script_list *tmp___11 ;
  struct edit_script_list *tmp___12 ;
  struct edit_script_list *tmp___13 ;
  struct edit_script_list *tmp___14 ;
  struct edit_script_list *tmp___15 ;
  struct edit_script_list *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  uchar *tmp___19 ;
  uchar *tmp___20 ;
  uchar *tmp___21 ;
  int tmp___22 ;

  {
#line 120
  revseq1 = (uchar *)((void *)0);
#line 125
  cds_gene = (char *)((void *)0);
#line 126
  rf1 = (SEQ *)((void *)0);
#line 130
  Exons = (Exon *)((void *)0);
#line 130
  rev_Exons = (Exon *)((void *)0);
#line 131
  Aligns = (edit_script_list *)((void *)0);
#line 131
  rev_Aligns = (edit_script_list *)((void *)0);
#line 133
  if (argc___0 < 3) {
    {
#line 133
    fatalf(Usage, *(argv___0 + 0));
    }
  }
  {
#line 134
  ckargs("AXWRKCDHEPNBST", argc___0, argv___0, 2);
#line 136
  sim4_argvals(& rs);
#line 137
  DNA_scores(& ds, (int (*)[128])(ss));
  }
#line 140
  if (rs.B) {
#line 140
    tmp = 256;
  } else {
#line 140
    tmp = 0;
  }
  {
#line 140
  sf1 = seq_open((char const   *)*(argv___0 + 1), (char const   *)0, tmp);
#line 141
  tmp___0 = seq_read(sf1);
  }
#line 141
  if (! tmp___0) {
    {
#line 141
    fatalf("Cannot read sequence from %s.", *(argv___0 + 1));
    }
  }
  {
#line 143
  seq1___0 = sf1->seq;
#line 144
  len1 = sf1->slen;
#line 145
  h1 = sf1->header;
#line 146
  tmp___1 = is_DNA(seq1___0, len1);
  }
#line 146
  if (! tmp___1) {
    {
#line 147
    fatal("The first sequence is not a DNA sequence.");
    }
  }
  {
#line 148
  seq_toupper(seq1___0, len1, *(argv___0 + 1));
  }
#line 151
  if (rs.B) {
#line 151
    tmp___2 = 256;
  } else {
#line 151
    tmp___2 = 0;
  }
  {
#line 151
  sf2 = seq_open((char const   *)*(argv___0 + 2), (char const   *)0, tmp___2);
#line 152
  tmp___3 = seq_read(sf2);
  }
#line 152
  if (! tmp___3) {
    {
#line 152
    fatalf("Cannot read sequence from %s.", *(argv___0 + 2));
    }
  }
  {
#line 154
  seq2___0 = sf2->seq;
#line 155
  len2 = sf2->slen;
#line 156
  h2 = sf2->header;
#line 157
  tmp___4 = is_DNA(seq2___0, len2);
  }
#line 157
  if (! tmp___4) {
    {
#line 158
    fatal("The first sequence is not a DNA sequence.");
    }
  }
  {
#line 159
  seq_toupper(seq2___0, len2, *(argv___0 + 2));
  }
#line 162
  if (len2 <= len1) {
#line 162
    file_type = 2;
  } else {
#line 162
    file_type = 1;
  }
#line 163
  if (file_type == 1) {
    {
#line 164
    rf1 = seq_copy((SEQ const   *)sf1);
#line 165
    rf1 = seq_revcomp_inplace(rf1);
#line 166
    revseq1 = rf1->seq;
    }
#line 168
    if (rs.ali_flag == 5) {
#line 169
      if (rs.CDS_to > len1) {
        {
#line 170
        fatal("Command line CDS endpoint exceeds sequence length.");
        }
      }
      {
#line 171
      cds_gene = extract_tok(h1);
      }
#line 172
      if ((unsigned long )cds_gene == (unsigned long )((void *)0)) {
#line 173
        cds_from = rs.CDS_from;
#line 173
        cds_to = rs.CDS_to;
      } else {
        {
#line 175
        line = strstr((char const   *)h1, "CDS=");
        }
#line 176
        if (line) {
#line 176
          if (rs.S) {
            {
#line 177
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Command line CDS specification overrides header CDS specification.");
#line 178
            cds_from = rs.CDS_from;
#line 178
            cds_to = rs.CDS_to;
            }
          } else {
#line 176
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 179
        if (line) {
          {
#line 180
          cds_range(line + 4, & cds_from, & cds_to);
          }
        } else
#line 181
        if (rs.S) {
#line 182
          cds_from = rs.CDS_from;
#line 182
          cds_to = rs.CDS_to;
        } else {
#line 184
          cds_to = 0;
#line 184
          cds_from = cds_to;
        }
      }
#line 187
      if (cds_to > len1) {
        {
#line 188
        fatal("CDS endpoints exceed sequence length.");
        }
      }
    }
  }
#line 192
  if (rs.poly_flag) {
#line 192
    if (file_type == 1) {
      {
#line 193
      get_polyAT(seq1___0, len1, & pT, & pA, 3);
      }
    } else {
#line 194
      pA = 0;
#line 194
      pT = pA;
    }
  } else {
#line 194
    pA = 0;
#line 194
    pT = pA;
  }
  {
#line 196
  bld_table((seq1___0 - 1) + pT, (len1 - pA) - pT, rs.W, 0);
#line 198
  count = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (! count)) {
      {
#line 199
      tmp___22 = seq_read(sf2);
      }
#line 199
      if (! (tmp___22 > 0)) {
#line 199
        goto while_break;
      }
    }
#line 202
    if (count) {
      {
#line 203
      h2 = sf2->header;
#line 204
      seq2___0 = sf2->seq;
#line 205
      len2 = sf2->slen;
#line 206
      tok = extract_tok(h2);
#line 208
      tmp___6 = is_DNA(seq2___0, len2);
      }
#line 208
      if (! tmp___6) {
        {
#line 210
        sprintf((char */* __restrict  */)(tmp___5), (char const   */* __restrict  */)"%s sequence is not a DNA sequence.",
                tok);
#line 211
        perror((char const   *)(tmp___5));
        }
#line 211
        goto while_continue;
      }
      {
#line 213
      seq_toupper(seq2___0, len2, *(argv___0 + 2));
      }
    } else {
      {
#line 215
      tok = extract_tok(h2);
      }
#line 216
      if ((unsigned long )tok == (unsigned long )((void *)0)) {
        {
#line 217
        tmp___7 = strlen("(no header)");
#line 217
        tmp___8 = ckalloc(tmp___7 + 1UL);
#line 217
        tok = (char *)tmp___8;
#line 218
        strcpy((char */* __restrict  */)tok, (char const   */* __restrict  */)"(no header)");
        }
      }
    }
#line 222
    if (rs.ali_flag == 5) {
#line 222
      if (file_type == 2) {
#line 223
        cds_gene = tok;
#line 224
        if (! cds_gene) {
#line 224
          if (! count) {
#line 225
            cds_from = rs.CDS_from;
#line 225
            cds_to = rs.CDS_to;
          } else {
#line 224
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 226
        if (! count) {
          {
#line 227
          line = strstr((char const   *)h2, "CDS=");
          }
#line 228
          if (rs.S) {
#line 229
            if (line) {
              {
#line 229
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Command line CDS specification overrides header CDS specification.");
              }
            }
#line 230
            cds_from = rs.CDS_from;
#line 230
            cds_to = rs.CDS_to;
          } else
#line 231
          if (line) {
            {
#line 232
            cds_range(line + 4, & cds_from, & cds_to);
            }
          }
        } else
#line 234
        if (count) {
          {
#line 235
          line = strstr((char const   *)h2, "CDS=");
          }
#line 236
          if (line) {
            {
#line 237
            cds_range(line + 4, & cds_from, & cds_to);
            }
          } else {
#line 239
            cds_to = 0;
#line 239
            cds_from = cds_to;
          }
        }
#line 242
        if (cds_to > len2) {
          {
#line 242
          fatal("CDS endpoints exceed sequence length.");
          }
        }
      }
    }
#line 245
    if (rs.poly_flag) {
#line 245
      if (file_type == 2) {
        {
#line 246
        get_polyAT(seq2___0, len2, & pT, & pA, 3);
        }
      }
    }
    {
#line 249
    count ++;
#line 250
    init_stats(& st);
#line 250
    init_stats(& rev_st);
    }
#line 251
    if (rs.set_K == 1) {
#line 251
      in_K = rs.K;
    } else {
#line 251
      in_K = -1;
    }
#line 252
    if (rs.set_C == 1) {
#line 252
      in_C = rs.C;
    } else {
#line 252
      in_C = -1;
    }
#line 253
    if (rs.set_H == 1) {
#line 253
      in_H = rs.weight;
    } else {
#line 253
      in_H = -1;
    }
    {
#line 256
    if (rs.reverse == 0) {
#line 256
      goto case_0;
    }
#line 263
    if (rs.reverse == 1) {
#line 263
      goto case_1;
    }
#line 272
    if (rs.reverse == 2) {
#line 272
      goto case_2;
    }
#line 287
    goto switch_default;
    case_0: /* CIL Label */ 
#line 256
    if (file_type == 1) {
      {
#line 256
      tmp___9 = SIM4(seq2___0, seq1___0 + pT, len2, (len1 - pT) - pA, rs.W, rs.X,
                     in_K, in_C, in_H, & dist, & xpT, & xpA, & Exons, & st);
#line 256
      Aligns = tmp___9;
      }
    } else {
      {
#line 256
      tmp___10 = SIM4(seq1___0, seq2___0 + pT, len1, (len2 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & xpT, & xpA, & Exons, & st);
#line 256
      Aligns = tmp___10;
      }
    }
#line 261
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 263
    sf2 = seq_revcomp_inplace(sf2);
#line 264
    seq2___0 = sf2->seq;
    }
#line 265
    if (file_type == 1) {
      {
#line 265
      tmp___11 = SIM4(seq2___0, seq1___0 + pT, len2, (len1 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & rev_xpT, & rev_xpA, & rev_Exons,
                      & rev_st);
#line 265
      rev_Aligns = tmp___11;
      }
    } else {
      {
#line 265
      tmp___12 = SIM4(seq1___0, seq2___0 + pA, len1, (len2 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & rev_xpT, & rev_xpA, & rev_Exons,
                      & rev_st);
#line 265
      rev_Aligns = tmp___12;
      }
    }
#line 270
    goto switch_break;
    case_2: /* CIL Label */ 
#line 272
    if (file_type == 1) {
      {
#line 272
      tmp___13 = SIM4(seq2___0, seq1___0 + pT, len2, (len1 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & xpT, & xpA, & Exons, & st);
#line 272
      Aligns = tmp___13;
      }
    } else {
      {
#line 272
      tmp___14 = SIM4(seq1___0, seq2___0 + pT, len1, (len2 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & xpT, & xpA, & Exons, & st);
#line 272
      Aligns = tmp___14;
      }
    }
    {
#line 278
    sf2 = seq_revcomp_inplace(sf2);
#line 279
    seq2___0 = sf2->seq;
    }
#line 280
    if (file_type == 1) {
      {
#line 280
      tmp___15 = SIM4(seq2___0, seq1___0 + pT, len2, (len1 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & rev_xpT, & rev_xpA, & rev_Exons,
                      & rev_st);
#line 280
      rev_Aligns = tmp___15;
      }
    } else {
      {
#line 280
      tmp___16 = SIM4(seq1___0, seq2___0 + pA, len1, (len2 - pT) - pA, rs.W, rs.X,
                      in_K, in_C, in_H, & dist, & rev_xpT, & rev_xpA, & rev_Exons,
                      & rev_st);
#line 280
      rev_Aligns = tmp___16;
      }
    }
#line 285
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 287
    fatal("Unrecognized request for EST orientation.");
    }
    switch_break: /* CIL Label */ ;
    }
#line 290
    if (st.nmatches >= rev_st.nmatches) {
#line 292
      match_ori = 0;
#line 293
      if (rs.reverse) {
#line 293
        if (rs.ali_flag) {
          {
#line 295
          sf2 = seq_revcomp_inplace(sf2);
#line 295
          seq2___0 = sf2->seq;
          }
        }
      }
#line 297
      if (rev_Exons) {
        {
#line 297
        free_list(rev_Exons);
#line 297
        rev_Exons = (Exon *)((void *)0);
        }
      }
#line 298
      if (rev_Aligns) {
        {
#line 298
        free_align(rev_Aligns);
#line 298
        rev_Aligns = (edit_script_list *)((void *)0);
        }
      }
    } else {
#line 300
      match_ori = 1;
#line 301
      if (Exons) {
        {
#line 301
        free_list(Exons);
#line 301
        Exons = (Exon *)((void *)0);
        }
      }
#line 302
      if (Aligns) {
        {
#line 302
        free_align(Aligns);
#line 302
        Aligns = (edit_script_list *)((void *)0);
        }
      }
    }
#line 305
    if (rs.poly_flag) {
#line 306
      if (match_ori == 0) {
        {
#line 307
        add_offset_exons(Exons, pT);
#line 308
        add_offset_aligns(Aligns, pT);
        }
      } else {
#line 310
        if (file_type == 1) {
#line 310
          tmp___17 = pT;
        } else {
#line 310
          tmp___17 = pA;
        }
        {
#line 310
        add_offset_exons(rev_Exons, tmp___17);
        }
#line 311
        if (file_type == 1) {
#line 311
          tmp___18 = pT;
        } else {
#line 311
          tmp___18 = pA;
        }
        {
#line 311
        add_offset_aligns(rev_Aligns, tmp___18);
        }
      }
    }
    {
#line 320
    if (rs.ali_flag == 0) {
#line 320
      goto case_0___0;
    }
#line 334
    if (rs.ali_flag == 1) {
#line 334
      goto case_1___0;
    }
#line 354
    if (rs.ali_flag == 2) {
#line 354
      goto case_2___0;
    }
#line 371
    if (rs.ali_flag == 3) {
#line 371
      goto case_3;
    }
#line 393
    if (rs.ali_flag == 4) {
#line 393
      goto case_4;
    }
#line 414
    if (rs.ali_flag == 5) {
#line 414
      goto case_5;
    }
#line 439
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 320
    printf((char const   */* __restrict  */)"\nseq1 = %s, %d bp\n", *(argv___0 + 1),
           len1);
#line 321
    printf((char const   */* __restrict  */)"seq2 = %s (%s), %d bp\n", *(argv___0 + 2),
           tok, len2);
    }
#line 322
    if (match_ori == 0) {
#line 323
      if (Exons) {
        {
#line 323
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 324
      print_exons(Exons);
      }
    } else {
      {
#line 326
      printf((char const   */* __restrict  */)"\n(complement)");
      }
#line 327
      if (file_type == 1) {
        {
#line 328
        complement_exons(& rev_Exons, len2, len1);
        }
      }
#line 329
      if (rev_Exons) {
        {
#line 329
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 330
      print_exons(rev_Exons);
      }
    }
#line 332
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 334
    printf((char const   */* __restrict  */)"\nseq1 = %s, %d bp\n", *(argv___0 + 1),
           len1);
#line 335
    printf((char const   */* __restrict  */)"seq2 = %s (%s), %d bp\n", *(argv___0 + 2),
           tok, len2);
#line 336
    printf((char const   */* __restrict  */)"\n");
    }
#line 337
    if (match_ori == 0) {
      {
#line 338
      printf((char const   */* __restrict  */)"\n");
#line 339
      print_align_lat(seq1___0, seq2___0, len1, len2, & Aligns, Exons, file_type,
                      0);
      }
    } else {
      {
#line 342
      printf((char const   */* __restrict  */)"\n(complement)\n");
      }
#line 344
      if (file_type == 1) {
        {
#line 345
        complement_exons(& rev_Exons, len2, len1);
#line 346
        sf2 = seq_revcomp_inplace(sf2);
#line 347
        seq2___0 = sf2->seq;
        }
      }
#line 349
      if (file_type == 1) {
#line 349
        tmp___19 = revseq1;
      } else {
#line 349
        tmp___19 = seq1___0;
      }
      {
#line 349
      print_align_lat(tmp___19, seq2___0, len1, len2, & rev_Aligns, rev_Exons, file_type,
                      1);
      }
    }
#line 352
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 354
    print_align_header(sf1, sf2, & ds);
    }
#line 355
    if (match_ori == 0) {
      {
#line 356
      printf((char const   */* __restrict  */)"\n");
#line 357
      print_align_blk(seq1___0, seq2___0, len1, len2, & Aligns, file_type, 0);
      }
    } else {
#line 360
      if (file_type == 1) {
        {
#line 361
        complement_exons(& rev_Exons, len2, len1);
#line 362
        sf2 = seq_revcomp_inplace(sf2);
#line 363
        seq2___0 = sf2->seq;
        }
      }
      {
#line 365
      printf((char const   */* __restrict  */)"\n(complement)\n");
      }
#line 366
      if (file_type == 1) {
#line 366
        tmp___20 = revseq1;
      } else {
#line 366
        tmp___20 = seq1___0;
      }
      {
#line 366
      print_align_blk(tmp___20, seq2___0, len1, len2, & rev_Aligns, file_type, 1);
      }
    }
#line 369
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 371
    printf((char const   */* __restrict  */)"\nseq1 = %s, %d bp\n", *(argv___0 + 1),
           len1);
#line 372
    printf((char const   */* __restrict  */)"seq2 = %s (%s), %d bp\n", *(argv___0 + 2),
           tok, len2);
#line 373
    printf((char const   */* __restrict  */)"\n");
    }
#line 374
    if (match_ori == 0) {
#line 375
      if (Exons) {
        {
#line 375
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 376
      print_exons(Exons);
#line 376
      printf((char const   */* __restrict  */)"\n");
#line 377
      print_align_lat(seq1___0, seq2___0, len1, len2, & Aligns, Exons, file_type,
                      0);
      }
    } else {
#line 380
      if (file_type == 1) {
        {
#line 381
        complement_exons(& rev_Exons, len2, len1);
#line 382
        sf2 = seq_revcomp_inplace(sf2);
#line 383
        seq2___0 = sf2->seq;
        }
      }
      {
#line 385
      printf((char const   */* __restrict  */)"\n(complement)");
      }
#line 386
      if (rev_Exons) {
        {
#line 386
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 387
      print_exons(rev_Exons);
#line 387
      printf((char const   */* __restrict  */)"\n");
      }
#line 388
      if (file_type == 1) {
#line 388
        tmp___21 = revseq1;
      } else {
#line 388
        tmp___21 = seq1___0;
      }
      {
#line 388
      print_align_lat(tmp___21, seq2___0, len1, len2, & rev_Aligns, rev_Exons, file_type,
                      1);
      }
    }
#line 391
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 393
    printf((char const   */* __restrict  */)"\nseq1 = %s, %d bp\n", *(argv___0 + 1),
           len1);
#line 394
    printf((char const   */* __restrict  */)"seq2 = %s (%s), %d bp\n", *(argv___0 + 2),
           tok, len2);
#line 395
    printf((char const   */* __restrict  */)"\n%s\n", sf1->header);
#line 396
    printf((char const   */* __restrict  */)"%s", sf2->header);
#line 397
    printf((char const   */* __restrict  */)"\n");
    }
#line 398
    if (match_ori == 0) {
#line 399
      if (Exons) {
        {
#line 399
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 400
      print_exons(Exons);
#line 400
      printf((char const   */* __restrict  */)"\n");
#line 401
      print_align_lat(seq1___0, seq2___0, len1, len2, & Aligns, Exons, file_type,
                      0);
      }
    } else {
      {
#line 406
      printf((char const   */* __restrict  */)"\n(complement)\n");
      }
#line 407
      if (rev_Exons) {
        {
#line 407
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 408
      print_exons(rev_Exons);
#line 408
      printf((char const   */* __restrict  */)"\n");
#line 409
      print_align_lat(seq1___0, seq2___0, len1, len2, & rev_Aligns, rev_Exons, file_type,
                      0);
      }
    }
#line 412
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 414
    if (match_ori == 0) {
      {
#line 415
      printf((char const   */* __restrict  */)"\n");
      }
#line 416
      if (file_type == 1) {
        {
#line 417
        print_pipmaker_exons(Exons, Aligns, cds_gene, cds_from, cds_to, len2, len1,
                             seq2___0, seq1___0, 0);
        }
      } else {
        {
#line 420
        print_pipmaker_exons(Exons, Aligns, cds_gene, cds_from, cds_to, len1, len2,
                             seq1___0, seq2___0, 0);
        }
      }
    } else {
      {
#line 424
      printf((char const   */* __restrict  */)"\n");
#line 426
      sf2 = seq_revcomp_inplace(sf2);
#line 427
      seq2___0 = sf2->seq;
      }
#line 428
      if (file_type == 1) {
        {
#line 429
        complement_exons(& rev_Exons, len2, len1);
#line 430
        print_pipmaker_exons(rev_Exons, rev_Aligns, cds_gene, cds_from, cds_to, len2,
                             len1, seq2___0, seq1___0, 1);
        }
      } else {
        {
#line 433
        print_pipmaker_exons(rev_Exons, rev_Aligns, cds_gene, cds_from, cds_to, len1,
                             len2, seq1___0, seq2___0, 1);
        }
      }
    }
#line 437
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 439
    fatal("Unrecognized option for alignment output.");
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 450
    printf((char const   */* __restrict  */)"\n");
    }
#line 451
    if (Aligns) {
      {
#line 451
      free_align(Aligns);
#line 451
      Aligns = (edit_script_list *)((void *)0);
      }
    }
#line 452
    if (rev_Aligns) {
      {
#line 452
      free_align(rev_Aligns);
#line 452
      rev_Aligns = (edit_script_list *)((void *)0);
      }
    }
#line 453
    if (Exons) {
      {
#line 453
      free_list(Exons);
#line 453
      Exons = (Exon *)((void *)0);
      }
    }
#line 454
    if (rev_Exons) {
      {
#line 454
      free_list(rev_Exons);
#line 454
      rev_Exons = (Exon *)((void *)0);
      }
    }
#line 455
    if (tok) {
      {
#line 455
      free((void *)tok);
#line 455
      tok = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  if (count == 1) {
#line 458
    if (file_type == 2) {
      {
#line 459
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try shorter sequence first for better performance.\n");
      }
    }
  }
  {
#line 461
  free_table();
  }
#line 462
  if (file_type == 1) {
    {
#line 462
    seq_close(rf1);
    }
  }
  {
#line 463
  seq_close(sf1);
#line 464
  seq_close(sf2);
  }
#line 466
  return (0);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void print_align_blk(uchar *seq1___0 , uchar *seq2___0 , int len1 , int len2 ,
                            edit_script_list **Aligns , int file_type___0 , int match_ori ) 
{ 
  int *S ;
  edit_script_list *head ;
  edit_script_list *aligns ;
  void *tmp ;
  int tmp___0 ;

  {
#line 476
  if ((unsigned long )*Aligns == (unsigned long )((void *)0)) {
#line 476
    return;
  }
#line 478
  aligns = *Aligns;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! ((unsigned long )aligns != (unsigned long )((void *)0))) {
#line 479
      goto while_break;
    }
    {
#line 480
    head = aligns;
#line 481
    aligns = aligns->next_script;
#line 483
    tmp = ckalloc((unsigned long )((2 * head->len2 + 1) + 1) * sizeof(int ));
#line 483
    S = (int *)tmp;
#line 484
    S ++;
    }
#line 485
    if (file_type___0 == 1) {
#line 485
      tmp___0 = 1;
    } else {
#line 485
      tmp___0 = 0;
    }
    {
#line 485
    S2A(head->script, S, tmp___0);
#line 486
    Free_script(head->script);
    }
#line 488
    if (file_type___0 == 1) {
#line 489
      if (match_ori == 0) {
        {
#line 490
        print_align(head->score, seq1___0, seq2___0, head->offset2, (head->offset2 + head->len2) - 1,
                    head->offset1, (head->offset1 + head->len1) - 1, S);
        }
      } else {
        {
#line 496
        align_reverse(S);
#line 497
        print_align(head->score, seq1___0, seq2___0, (len1 + 1) - ((head->offset2 + head->len2) - 1),
                    (len1 + 1) - head->offset2, (len2 + 1) - ((head->offset1 + head->len1) - 1),
                    (len2 + 1) - head->offset1, S);
        }
      }
    } else {
      {
#line 504
      print_align(head->score, seq1___0, seq2___0, head->offset1, (head->offset1 + head->len1) - 1,
                  head->offset2, (head->offset2 + head->len2) - 1, S);
      }
    }
    {
#line 510
    free((void *)(S - 1));
#line 511
    free((void *)head);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  *Aligns = (edit_script_list *)((void *)0);
#line 514
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void print_align_lat(uchar *seq1___0 , uchar *seq2___0 , int len1 , int len2 ,
                            edit_script_list **Aligns , Exon *Exons , int file_type___0 ,
                            int match_ori ) 
{ 
  int *S ;
  edit_script_list *head ;
  edit_script_list *aligns ;
  void *tmp ;
  int tmp___0 ;

  {
#line 524
  if ((unsigned long )*Aligns == (unsigned long )((void *)0)) {
#line 524
    return;
  }
#line 526
  aligns = *Aligns;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! ((unsigned long )aligns != (unsigned long )((void *)0))) {
#line 527
      goto while_break;
    }
    {
#line 528
    head = aligns;
#line 529
    aligns = aligns->next_script;
#line 531
    tmp = ckalloc((unsigned long )((2 * head->len2 + 1) + 1) * sizeof(int ));
#line 531
    S = (int *)tmp;
#line 532
    S ++;
    }
#line 533
    if (file_type___0 == 1) {
#line 533
      tmp___0 = 1;
    } else {
#line 533
      tmp___0 = 0;
    }
    {
#line 533
    S2A(head->script, S, tmp___0);
#line 534
    Free_script(head->script);
    }
#line 536
    if (file_type___0 == 1) {
#line 537
      if (match_ori == 0) {
        {
#line 538
        IDISPLAY(((seq1___0 + head->offset2) - 1) - 1, ((seq2___0 + head->offset1) - 1) - 1,
                 head->len2, head->len1, S, head->offset2, head->offset1, 1, Exons);
        }
      } else {
        {
#line 542
        align_reverse(S);
#line 543
        IDISPLAY(((((seq1___0 + len1) + 1) - ((head->offset2 + head->len2) - 1)) - 1) - 1,
                 ((((seq2___0 + len2) + 1) - ((head->offset1 + head->len1) - 1)) - 1) - 1,
                 head->len2, head->len1, S, (len1 + 1) - ((head->offset2 + head->len2) - 1),
                 (len2 + 1) - ((head->offset1 + head->len1) - 1), 1, Exons);
        }
      }
    } else {
      {
#line 550
      IDISPLAY(((seq1___0 + head->offset1) - 1) - 1, ((seq2___0 + head->offset2) - 1) - 1,
               head->len1, head->len2, S, head->offset1, head->offset2, 2, Exons);
      }
    }
    {
#line 554
    free((void *)(S - 1));
#line 555
    free((void *)head);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  *Aligns = (edit_script_list *)((void *)0);
#line 558
  return;
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void sim4_argvals(sim4_args_t *args ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;

  {
  {
#line 565
  tmp = get_argval('A', & args->ali_flag);
  }
#line 565
  if (! tmp) {
#line 566
    args->ali_flag = 0;
  }
#line 567
  if (args->ali_flag > 5) {
    {
#line 568
    fatal("A options: 0, 1, 2, 3, 4, 5.");
    }
  } else
#line 567
  if (args->ali_flag < 0) {
    {
#line 568
    fatal("A options: 0, 1, 2, 3, 4, 5.");
    }
  }
  {
#line 570
  tmp___0 = get_argval('P', & args->poly_flag);
  }
#line 570
  if (! tmp___0) {
#line 571
    args->poly_flag = 0;
  }
  {
#line 573
  tmp___1 = get_argval('R', & args->reverse);
  }
#line 573
  if (tmp___1) {
#line 574
    if (args->reverse < 0) {
      {
#line 575
      fatal("Direction R must be 0, 1, or 2.");
      }
    } else
#line 574
    if (args->reverse > 2) {
      {
#line 575
      fatal("Direction R must be 0, 1, or 2.");
      }
    }
  } else {
#line 577
    args->reverse = 2;
  }
  {
#line 579
  tmp___2 = get_argval('E', & args->cutoff);
  }
#line 579
  if (tmp___2) {
#line 580
    if (args->cutoff < 3) {
      {
#line 581
      fatal("Cutoff must be within [3,10].");
      }
    } else
#line 580
    if (args->cutoff > 10) {
      {
#line 581
      fatal("Cutoff must be within [3,10].");
      }
    }
  } else {
#line 583
    args->cutoff = 3;
  }
  {
#line 585
  tmp___3 = get_argval('D', & args->DRANGE);
  }
#line 585
  if (tmp___3) {
#line 586
    if (args->DRANGE < 0) {
      {
#line 587
      fatal("Positive number required for D.");
      }
    }
  } else {
#line 589
    args->DRANGE = 10;
  }
  {
#line 591
  tmp___4 = get_argval('H', & args->weight);
  }
#line 591
  if (tmp___4) {
#line 592
    if (args->weight < 0) {
      {
#line 593
      fatal("Positive number required for H.");
      }
    }
#line 594
    args->set_H = 1;
  } else {
#line 597
    args->set_H = 0;
  }
  {
#line 609
  tmp___5 = get_argval('W', & args->W);
  }
#line 609
  if (tmp___5) {
#line 610
    if (args->W < 1) {
      {
#line 611
      fatal("W must be positive.");
      }
    }
#line 612
    if (args->W > 15) {
      {
#line 613
      fatal("W must be <= 15.");
      }
    }
  } else {
#line 615
    args->W = 12;
  }
  {
#line 617
  tmp___6 = get_argval('X', & args->X);
  }
#line 617
  if (tmp___6) {
#line 618
    if (args->X < 1) {
      {
#line 619
      fatal("X must be positive.");
      }
    }
  } else {
#line 621
    args->X = 12;
  }
  {
#line 623
  tmp___7 = get_argval('K', & args->K);
  }
#line 623
  if (tmp___7) {
#line 624
    if (args->K < 0) {
      {
#line 624
      fatal("K must be positive.");
      }
    }
#line 625
    args->set_K = 1;
  } else {
#line 627
    args->K = 16;
#line 628
    args->set_K = 0;
  }
  {
#line 631
  tmp___8 = get_argval('C', & args->C);
  }
#line 631
  if (tmp___8) {
#line 632
    if (args->C < 0) {
      {
#line 632
      fatal("C must be positive.");
      }
    }
#line 633
    args->set_C = 1;
  } else {
#line 635
    args->C = 12;
#line 636
    args->set_C = 0;
  }
  {
#line 639
  tmp___9 = get_argval('N', & args->acc_flag);
  }
#line 639
  if (! tmp___9) {
#line 640
    args->acc_flag = 0;
  }
  {
#line 642
  tmp___10 = get_argval('B', & args->B);
  }
#line 642
  if (tmp___10) {
#line 643
    if (args->B) {
#line 643
      if (args->B != 1) {
        {
#line 644
        fatal("B must be either 0 or 1.");
        }
      }
    }
  } else {
#line 646
    args->B = 1;
  }
  {
#line 648
  tmp___11 = get_strargval('S', & args->S);
  }
#line 648
  if (tmp___11) {
    {
#line 649
    cds_range(args->S, & args->CDS_from, & args->CDS_to);
    }
#line 650
    if (args->CDS_from <= 0) {
      {
#line 652
      fatal("Illegal endpoints for the CDS region.");
      }
    } else
#line 650
    if (args->CDS_to <= 0) {
      {
#line 652
      fatal("Illegal endpoints for the CDS region.");
      }
    } else
#line 650
    if (args->CDS_from > args->CDS_to) {
      {
#line 652
      fatal("Illegal endpoints for the CDS region.");
      }
    }
  } else {
#line 654
    args->S = (char *)((void *)0);
  }
#line 656
  if (args->S) {
#line 656
    if (args->ali_flag != 5) {
      {
#line 657
      fatal("A=5 must accompany CDS specification.");
      }
    }
  }
#line 659
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void cds_range(char *line , int *from , int *to ) 
{ 
  char *s ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
#line 665
  s = line;
#line 667
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    {
#line 667
    fatal("NULL CDS specification.");
    }
  }
  {
#line 669
  tmp = __ctype_b_loc();
  }
#line 669
  if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
    {
#line 670
    fatal("Non-numerical value in the CDS specification.");
    }
  }
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (*s) {
      {
#line 671
      tmp___0 = __ctype_b_loc();
      }
#line 671
      if (! ((int const   )*(*tmp___0 + (int )*s) & 2048)) {
#line 671
        goto while_break;
      }
    } else {
#line 671
      goto while_break;
    }
#line 671
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  if ((int )*s != 46) {
    {
#line 672
    fatal("Illegal CDS specification.");
    }
  }
#line 672
  s ++;
#line 673
  if ((int )*s != 46) {
    {
#line 673
    fatal("Illegal CDS specification.");
    }
  }
  {
#line 673
  s ++;
#line 674
  tmp___1 = __ctype_b_loc();
  }
#line 674
  if (! ((int const   )*(*tmp___1 + (int )*s) & 2048)) {
    {
#line 675
    fatal("Non-numerical value in the CDS specification.");
    }
  }
  {
#line 676
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 676
    if (*s) {
      {
#line 676
      tmp___2 = __ctype_b_loc();
      }
#line 676
      if (! ((int const   )*(*tmp___2 + (int )*s) & 2048)) {
#line 676
        goto while_break___0;
      }
    } else {
#line 676
      goto while_break___0;
    }
#line 676
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 677
  if (*s) {
    {
#line 677
    tmp___3 = __ctype_b_loc();
    }
#line 677
    if (! ((int const   )*(*tmp___3 + (int )*s) & 8192)) {
      {
#line 678
      fatal("Garbage at the end of the CDS numerical specification.");
      }
    }
  }
  {
#line 681
  tmp___4 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%d..%d",
                   from, to);
  }
#line 681
  if (tmp___4 != 2) {
    {
#line 682
    fatal("Error when reading the CDS endpoints.");
    }
  }
#line 684
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void add_offset_exons(Exon *exons , int offset ) 
{ 
  Exon *t ;

  {
#line 691
  if (! offset) {
#line 691
    return;
  } else
#line 691
  if (! exons) {
#line 691
    return;
  }
#line 693
  t = exons;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! t) {
#line 694
      goto while_break;
    }
#line 695
    if (t->to1) {
#line 695
      t->from2 += offset;
#line 695
      t->to2 += offset;
    }
#line 696
    t = t->next_exon;
  }
  while_break: /* CIL Label */ ;
  }
#line 698
  return;
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void add_offset_aligns(edit_script_list *aligns , int offset ) 
{ 
  edit_script_list *head ;

  {
#line 704
  if (! offset) {
#line 704
    return;
  } else
#line 704
  if (! aligns) {
#line 704
    return;
  }
#line 706
  head = aligns;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! head) {
#line 707
      goto while_break;
    }
#line 707
    head->offset2 += offset;
#line 707
    head = head->next_script;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static char *extract_tok(char *h2 ) 
{ 
  char *s ;
  char *tmp ;
  char *q ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;

  {
#line 716
  if ((unsigned long )h2 == (unsigned long )((void *)0)) {
#line 716
    return ((char *)((void *)0));
  } else
#line 716
  if ((int )*h2 == 0) {
#line 716
    return ((char *)((void *)0));
  }
#line 718
  if ((int )*h2 != 62) {
    {
#line 718
    fatal("Not a FASTA header.");
    }
  }
#line 719
  s = h2 + 1;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 719
    tmp___0 = __ctype_b_loc();
    }
#line 719
    if ((int const   )*(*tmp___0 + (int )*s) & 8192) {
#line 719
      if (! ((int )*s != 10)) {
#line 719
        goto while_break;
      }
    } else {
#line 719
      goto while_break;
    }
#line 719
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  if ((int )*s == 10) {
#line 720
    return ((char *)((void *)0));
  }
#line 721
  q = s;
  {
#line 721
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 721
    if (*s) {
      {
#line 721
      tmp___1 = __ctype_b_loc();
      }
#line 721
      if ((int const   )*(*tmp___1 + (int )*s) & 8192) {
#line 721
        goto while_break___0;
      }
    } else {
#line 721
      goto while_break___0;
    }
#line 721
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 722
  tmp___2 = ckalloc((size_t )((unsigned int )((s - q) + 1L)));
#line 722
  tmp = (char *)tmp___2;
#line 723
  strncpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)q, (size_t )((int )(s - q)));
#line 724
  *(tmp + (s - q)) = (char )'\000';
  }
#line 726
  return (tmp);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/sim4.init.c"
static void init_stats(sim4_stats_t *st ) 
{ 


  {
  {
#line 734
  memset((void *)st, 0, sizeof(sim4_stats_t ));
  }
#line 735
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.h"
void *ckrealloc(void *p , size_t size ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static SEQ *seq_mask_inplace(SEQ *seq ) ;
#line 14
static int getpair(FILE *fp , int *a , int *b ) ;
#line 15
static char *byte_fill_range(uchar *p , int l , int c , int a , int b ) ;
#line 16
static int ws(int c ) ;
#line 17
static int getnwc(FILE *fp ) ;
#line 18
static void un_getc(int c , FILE *fp ) ;
#line 19
static void char_append(charvec_t *s , int c ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static int ws(int c ) 
{ 
  int tmp ;

  {
#line 23
  if (c == 32) {
#line 23
    tmp = 1;
  } else
#line 23
  if (c == 9) {
#line 23
    tmp = 1;
  } else
#line 23
  if (c == 10) {
#line 23
    tmp = 1;
  } else
#line 23
  if (c == 12) {
#line 23
    tmp = 1;
  } else
#line 23
  if (c == 13) {
#line 23
    tmp = 1;
  } else {
#line 23
    tmp = 0;
  }
#line 23
  return (tmp);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static int getnwc(FILE *fp ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 28
  c = -1;
#line 29
  tmp___0 = feof(fp);
  }
#line 29
  if (! tmp___0) {
    {
#line 29
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 29
      c = _IO_getc(fp);
      }
#line 29
      if (c != -1) {
        {
#line 29
        tmp = ws(c);
        }
#line 29
        if (! tmp) {
#line 29
          goto while_break;
        }
      } else {
#line 29
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 30
  return (c);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static void un_getc(int c , FILE *fp ) 
{ 
  int tmp ;

  {
#line 35
  if (c != -1) {
    {
#line 36
    tmp = ungetc(c, fp);
    }
#line 36
    if (tmp == -1) {
      {
#line 37
      fatalf("cannot ungetc \'%c\'", c);
      }
    }
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static void char_append(charvec_t *s , int c ) 
{ 
  int tmp ;

  {
  {
#line 42
  tmp = charvec_append(s, (char )c);
  }
#line 42
  if (! tmp) {
    {
#line 43
    fatal("cannot append");
    }
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
int seq_read(SEQ *seq ) 
{ 
  int b ;
  int c ;
  charvec_t shdr ;
  charvec_t sseq ;
  int tmp ;
  charvec_t ssub ;
  int i ;

  {
  {
#line 49
  shdr.a = (char *)0;
#line 49
  shdr.len = 0U;
#line 49
  shdr.max = 0U;
#line 49
  shdr.alloc = & ckrealloc;
#line 49
  shdr.free = (void (*)(void * ))(& free);
#line 50
  sseq.a = (char *)0;
#line 50
  sseq.len = 0U;
#line 50
  sseq.max = 0U;
#line 50
  sseq.alloc = & ckrealloc;
#line 50
  sseq.free = (void (*)(void * ))(& free);
#line 52
  tmp = feof(seq->fp);
  }
#line 52
  if (tmp) {
#line 53
    return (0);
  }
#line 55
  if (seq->count > 0) {
#line 56
    if (seq->flags & 1) {
#line 57
      return (0);
    } else {
#line 59
      seq->from = 1;
#line 60
      seq->slen = -1;
    }
  }
#line 64
  if (seq->header) {
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 64
      free((void *)seq->header);
#line 64
      seq->header = (char *)0;
      }
#line 64
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 65
  if (seq->seq) {
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 65
      free((void *)seq->seq);
#line 65
      seq->seq = (uchar *)0;
      }
#line 65
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 67
  seq->offset = ftell(seq->fp);
#line 70
  c = getnwc(seq->fp);
  }
#line 71
  if (c == 62) {
    {
#line 72
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 72
      if (c != 10) {
#line 72
        if (! (c != -1)) {
#line 72
          goto while_break___1;
        }
      } else {
#line 72
        goto while_break___1;
      }
      {
#line 73
      char_append(& shdr, c);
#line 74
      c = _IO_getc(seq->fp);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 77
    un_getc(c, seq->fp);
    }
  }
  {
#line 79
  char_append(& shdr, 0);
#line 80
  seq->header = shdr.a;
#line 81
  seq->hlen = (int )shdr.len;
#line 84
  b = '\n';
#line 85
  c = getnwc(seq->fp);
  }
  {
#line 86
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 86
    if (c != -1) {
#line 86
      if (b == 10) {
#line 86
        if (c == 62) {
#line 86
          goto while_break___2;
        }
      }
    } else {
#line 86
      goto while_break___2;
    }
    {
#line 88
    if ((int const   )nfasta_ctype[c] == 1) {
#line 88
      goto case_1;
    }
#line 91
    if ((int const   )nfasta_ctype[c] == 2) {
#line 91
      goto case_2;
    }
#line 94
    if ((int const   )nfasta_ctype[c] == 3) {
#line 94
      goto case_3;
    }
#line 100
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 89
    char_append(& sseq, c);
    }
#line 90
    goto switch_break;
    case_2: /* CIL Label */ 
#line 93
    goto switch_break;
    case_3: /* CIL Label */ 
#line 95
    if (seq->flags & 256) {
      {
#line 96
      char_append(& sseq, c);
      }
#line 97
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 101
    fatalf("non-DNA character \'%c\' in sequence \'%s\'", c, seq->fname);
    }
#line 102
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 104
    b = c;
#line 105
    c = _IO_getc(seq->fp);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 107
  un_getc(c, seq->fp);
  }
#line 110
  if (seq->slen == -1) {
    {
#line 111
    char_append(& sseq, 0);
#line 112
    charvec_fit(& sseq);
#line 113
    seq->seq = (uchar *)sseq.a;
#line 114
    seq->slen = (int )sseq.len;
    }
#line 115
    if (seq->slen > 0) {
#line 115
      (seq->slen) --;
    }
  } else {
#line 117
    ssub.a = (char *)0;
#line 117
    ssub.len = 0U;
#line 117
    ssub.max = 0U;
#line 117
    ssub.alloc = & ckrealloc;
#line 117
    ssub.free = (void (*)(void * ))(& free);
#line 120
    if (seq->from < 1) {
      {
#line 125
      fatalf("range [%d,%d] incommensurate with sequence [%d,%d]", seq->from, (seq->slen + seq->from) - 1,
             1, sseq.len);
      }
    } else
#line 120
    if ((int )sseq.len < seq->from) {
      {
#line 125
      fatalf("range [%d,%d] incommensurate with sequence [%d,%d]", seq->from, (seq->slen + seq->from) - 1,
             1, sseq.len);
      }
    } else
#line 120
    if ((seq->slen + seq->from) - 1 < 1) {
      {
#line 125
      fatalf("range [%d,%d] incommensurate with sequence [%d,%d]", seq->from, (seq->slen + seq->from) - 1,
             1, sseq.len);
      }
    } else
#line 120
    if ((int )sseq.len < (seq->slen + seq->from) - 1) {
      {
#line 125
      fatalf("range [%d,%d] incommensurate with sequence [%d,%d]", seq->from, (seq->slen + seq->from) - 1,
             1, sseq.len);
      }
    } else
#line 120
    if ((seq->slen + seq->from) - 1 < seq->from) {
      {
#line 125
      fatalf("range [%d,%d] incommensurate with sequence [%d,%d]", seq->from, (seq->slen + seq->from) - 1,
             1, sseq.len);
      }
    }
#line 128
    i = seq->from;
    {
#line 128
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 128
      if (! (i <= (seq->slen + seq->from) - 1)) {
#line 128
        goto while_break___3;
      }
      {
#line 129
      char_append(& ssub, (int )*(sseq.a + (i - 1)));
#line 128
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 130
    char_append(& ssub, 0);
#line 131
    charvec_fini(& sseq);
#line 132
    seq->seq = (uchar *)ssub.a;
    }
  }
#line 135
  seq->flags &= -3;
#line 136
  if (seq->flags & 32) {
    {
#line 137
    seq_revcomp_inplace(seq);
    }
  }
#line 139
  if (seq->flags & 8) {
    {
#line 140
    seq_mask_inplace(seq);
    }
  }
#line 143
  (seq->count) ++;
#line 144
  return (1);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static SEQ *seq_mask_inplace(SEQ *seq ) 
{ 
  int a ;
  int b ;
  FILE *fp ;
  FILE *tmp ;
  int tmp___0 ;

  {
  {
#line 151
  tmp = fopen((char const   */* __restrict  */)seq->maskname, (char const   */* __restrict  */)"r");
#line 151
  fp = tmp;
  }
#line 153
  if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
    {
#line 154
    fatalfr("cannot open \'%s\'", seq->maskname);
    }
#line 155
    return ((SEQ *)0);
  } else {
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 157
      tmp___0 = getpair(fp, & a, & b);
      }
#line 157
      if (! tmp___0) {
#line 157
        goto while_break;
      }
      {
#line 158
      byte_fill_range(seq->seq, seq->slen, 'X', a, b);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 159
    fclose(fp);
#line 160
    seq->flags |= 8;
    }
#line 161
    return (seq);
  }
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static int getpair(FILE *fp , int *a , int *b ) 
{ 
  char buf[128] ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 171
  tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
  }
#line 171
  if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 172
    return (0);
  }
  {
#line 173
  tmp___0 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d%d",
                   a, b);
  }
#line 173
  if (tmp___0 != 2) {
#line 174
    return (0);
  }
#line 175
  return (1);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/seq_read.c"
static char *byte_fill_range(uchar *p , int l , int c , int a , int b ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 182
  a --;
#line 182
  b -= a;
#line 183
  if (b < 0) {
#line 183
    tmp___0 = (void *)0;
  } else
#line 183
  if (l < b) {
#line 183
    tmp___0 = (void *)0;
  } else {
    {
#line 183
    tmp = memset((void *)(p + a), c, (size_t )b);
#line 183
    tmp___0 = tmp;
    }
  }
#line 183
  return ((char *)tmp___0);
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
bool get_fargval(int c , double *val_ptr ) ;
#line 16
bool get_cargval(int c , char **valp ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.h"
char *argv0  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
static int argc  ;
#line 12 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
static char **argv  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
void ckargs(char const   *options , int argcx , char **argvx , int non_options ) 
{ 
  int i ;
  char *tmp ;

  {
#line 20
  argc = argcx;
#line 21
  argv = argvx;
#line 22
  if (argv0) {
#line 22
    argv0 = argv0;
  } else {
#line 22
    argv0 = *(argv + 0);
  }
#line 23
  i = non_options + 1;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (i < argc)) {
#line 23
      goto while_break;
    }
#line 24
    if ((int )*(*(argv + i) + 1) != 61) {
      {
#line 25
      fatalf("Improper command option: \'%s\'.", *(argv + i));
      }
    } else {
      {
#line 26
      tmp = strchr(options, (int )*(*(argv + i) + 0));
      }
#line 26
      if (! tmp) {
        {
#line 27
        fatalf("Available options: %s\n", options);
        }
      }
    }
#line 23
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
bool get_argval(int c , int *val_ptr ) 
{ 
  int i ;

  {
  {
#line 35
  ck_argc("get_argval");
#line 36
  i = 0;
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < argc)) {
#line 36
      goto while_break;
    }
#line 37
    if ((int )*(*(argv + i) + 0) == c) {
#line 37
      if ((int )*(*(argv + i) + 1) == 61) {
        {
#line 38
        *val_ptr = atoi((char const   *)(*(argv + i) + 2));
        }
#line 39
        return (1);
      }
    }
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return (0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
bool get_fargval(int c , double *val_ptr ) 
{ 
  int i ;

  {
  {
#line 49
  ck_argc("get_fargval");
#line 50
  i = 0;
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (i < argc)) {
#line 50
      goto while_break;
    }
#line 51
    if ((int )*(*(argv + i) + 0) == c) {
#line 51
      if ((int )*(*(argv + i) + 1) == 61) {
        {
#line 52
        *val_ptr = atof((char const   *)(*(argv + i) + 2));
        }
#line 53
        return (1);
      }
    }
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (0);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
bool get_strargval(int c , char **val_ptr ) 
{ 
  int i ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 63
  ck_argc("get_strargval");
#line 64
  i = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < argc)) {
#line 64
      goto while_break;
    }
#line 65
    if ((int )*(*(argv + i) + 0) == c) {
#line 65
      if ((int )*(*(argv + i) + 1) == 61) {
        {
#line 66
        tmp = strlen((char const   *)(*(argv + i) + 2));
#line 66
        tmp___0 = ckalloc(tmp + 1UL);
#line 66
        *val_ptr = (char *)tmp___0;
#line 67
        strcpy((char */* __restrict  */)*val_ptr, (char const   */* __restrict  */)(*(argv + i) + 2));
        }
#line 68
        return (1);
      }
    }
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (0);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
bool get_cargval(int c , char **valp ) 
{ 
  int i ;

  {
  {
#line 77
  ck_argc("get_cargval");
#line 78
  i = 0;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < argc)) {
#line 78
      goto while_break;
    }
#line 79
    if ((int )*(*(argv + i) + 0) == c) {
#line 79
      if ((int )*(*(argv + i) + 1) == 61) {
#line 80
        *valp = *(argv + i) + 2;
#line 81
        return (1);
      }
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (0);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
void fprintf_argv(FILE *fp ) 
{ 
  int i ;

  {
  {
#line 89
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", argv0);
#line 90
  i = 1;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < argc)) {
#line 90
      goto while_break;
    }
    {
#line 91
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" %s", *(argv + i));
#line 90
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/args.c"
void ck_argc(char const   *proc_name ) 
{ 


  {
#line 97
  if (argc == 0) {
    {
#line 98
    fatalf("Call ckargs() before %s.\n", proc_name);
    }
  }
#line 99
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/Xtend1.c"
static void free_coords(coords ***val , int size ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/Xtend1.c"
int Xextend_bw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
               int *line1 , int *line2 ) 
{ 
  int col ;
  int row ;
  int max_d ;
  int d ;
  int k ;
  int DELTA ;
  int ORIGIN ;
  int lower ;
  int upper ;
  int *last_d ;
  int *temp_d ;
  int *min_row ;
  int *min_diag ;
  coords ***trace_AG ;
  coords ***trace_AC ;
  coords *AG_cell ;
  coords *AC_cell ;
  coords *new ;
  ValNodePtr data_list ;
  ValNodePtr prev ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 36
  data_list = (ValNodePtr )((void *)0);
#line 36
  prev = (ValNodePtr )((void *)0);
#line 38
  DELTA = n - m;
#line 39
  max_d = m + 1;
#line 41
  tmp = ckalloc((unsigned long )(max_d + 1) * sizeof(coords **));
#line 41
  trace_AG = (coords ***)tmp;
#line 42
  tmp___0 = ckalloc((unsigned long )(max_d + 1) * sizeof(coords **));
#line 42
  trace_AC = (coords ***)tmp___0;
#line 43
  d = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (d <= max_d)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp___1 = ckalloc((unsigned long )((m + n) + 1) * sizeof(coords *));
#line 44
    *(trace_AG + d) = (coords **)tmp___1;
#line 45
    tmp___2 = ckalloc((unsigned long )((m + n) + 1) * sizeof(coords *));
#line 45
    *(trace_AC + d) = (coords **)tmp___2;
#line 43
    d ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  ORIGIN = m;
#line 50
  *(*(trace_AG + 0) + (ORIGIN + DELTA)) = & last_AG;
#line 51
  *(*(trace_AC + 0) + (ORIGIN + DELTA)) = & last_AC;
#line 53
  row = m;
#line 53
  col = n;
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 53
    if (row > 0) {
#line 53
      if (col > 0) {
#line 53
        if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 53
          goto while_break___0;
        }
      } else {
#line 53
        goto while_break___0;
      }
    } else {
#line 53
      goto while_break___0;
    }
#line 53
    row --;
#line 53
    col --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  k = n;
  {
#line 55
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 55
    if (k >= 2) {
#line 55
      if (! (k >= col)) {
#line 55
        goto while_break___1;
      }
    } else {
#line 55
      goto while_break___1;
    }
    {
#line 56
    tmp___6 = strncmp((char const   *)((char *)((s2 + k) - 2)), "AG", (size_t )2);
    }
#line 56
    if (tmp___6) {
      {
#line 63
      tmp___5 = strncmp((char const   *)((char *)((s2 + k) - 2)), "AC", (size_t )2);
      }
#line 63
      if (! tmp___5) {
        {
#line 64
        tmp___4 = ckalloc(sizeof(coords ));
#line 64
        new = (coords *)tmp___4;
#line 65
        link_to_data_list((Pointer )new, & data_list, & prev);
#line 67
        new->pos2 = ((k - DELTA) + offset1___0) + 1;
#line 68
        new->pos1 = (k + offset2___0) + 1;
#line 69
        *(*(trace_AC + 0) + (ORIGIN + DELTA)) = new;
        }
      }
    } else {
      {
#line 57
      tmp___3 = ckalloc(sizeof(coords ));
#line 57
      new = (coords *)tmp___3;
#line 58
      link_to_data_list((Pointer )new, & data_list, & prev);
#line 60
      new->pos2 = ((k - DELTA) + offset1___0) + 1;
#line 61
      new->pos1 = (k + offset2___0) + 1;
#line 62
      *(*(trace_AG + 0) + (ORIGIN + DELTA)) = new;
      }
    }
#line 55
    k --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 72
  if (row == 0) {
#line 72
    goto _L;
  } else
#line 72
  if (col == 0) {
    _L: /* CIL Label */ 
    {
#line 73
    *line1 = row + offset1___0;
#line 74
    *line2 = col + offset2___0;
#line 75
    memcpy((void */* __restrict  */)(& last_AG), (void const   */* __restrict  */)*(*(trace_AG + 0) + (ORIGIN + DELTA)),
           sizeof(coords ));
#line 76
    memcpy((void */* __restrict  */)(& last_AC), (void const   */* __restrict  */)*(*(trace_AC + 0) + (ORIGIN + DELTA)),
           sizeof(coords ));
#line 77
    ValNodeFreeData(data_list);
#line 78
    free_coords(trace_AG, max_d + 1);
#line 79
    free_coords(trace_AC, max_d + 1);
    }
#line 81
    return (0);
  }
  {
#line 84
  tmp___7 = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 84
  last_d = (int *)tmp___7;
#line 85
  tmp___8 = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 85
  temp_d = (int *)tmp___8;
#line 87
  k = 0;
  }
  {
#line 87
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 87
    if (! (k <= m + n)) {
#line 87
      goto while_break___2;
    }
#line 87
    *(last_d + k) = m + 1;
#line 87
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 88
  *(last_d + (ORIGIN + DELTA)) = row;
#line 90
  lower = (ORIGIN + DELTA) - 1;
#line 91
  upper = (ORIGIN + DELTA) + 1;
#line 93
  tmp___9 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 93
  min_row = (int *)tmp___9;
#line 94
  tmp___10 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 94
  min_diag = (int *)tmp___10;
#line 96
  d = 1;
  }
  {
#line 96
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 96
    if (! (d <= m)) {
#line 96
      goto while_break___3;
    }
#line 97
    *(min_row + d) = m + 1;
#line 96
    d ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 99
  *(min_row + 0) = *(last_d + (ORIGIN + DELTA));
#line 100
  *(min_diag + 0) = ORIGIN + DELTA;
#line 102
  d = 0;
  {
#line 103
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 103
    d ++;
#line 103
    if (d <= max_d) {
      {
#line 103
      tmp___19 = good_ratio(m - *(min_row + (d - 1)));
      }
#line 103
      if (! (d - 1 <= tmp___19)) {
#line 103
        if (d >= 2) {
          {
#line 103
          tmp___20 = good_ratio(m - *(min_row + (d - 2)));
          }
#line 103
          if (! (d - 2 <= tmp___20)) {
#line 103
            goto while_break___4;
          }
        } else {
#line 103
          goto while_break___4;
        }
      }
    } else {
#line 103
      goto while_break___4;
    }
#line 108
    k = lower;
    {
#line 108
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 108
      if (! (k <= upper)) {
#line 108
        goto while_break___5;
      }
#line 111
      if (k == (- d + DELTA) + ORIGIN) {
#line 113
        row = *(last_d + (k + 1));
#line 115
        AG_cell = *(*(trace_AG + (d - 1)) + (k + 1));
#line 116
        AC_cell = *(*(trace_AC + (d - 1)) + (k + 1));
      } else
#line 117
      if (k == (d + DELTA) + ORIGIN) {
#line 119
        row = *(last_d + (k - 1)) - 1;
#line 121
        AG_cell = *(*(trace_AG + (d - 1)) + (k - 1));
#line 122
        AC_cell = *(*(trace_AC + (d - 1)) + (k - 1));
      } else
#line 123
      if (*(last_d + k) - 1 <= *(last_d + (k + 1))) {
#line 123
        if (*(last_d + k) - 1 <= *(last_d + (k - 1)) - 1) {
#line 126
          row = *(last_d + k) - 1;
#line 128
          AG_cell = *(*(trace_AG + (d - 1)) + k);
#line 129
          AC_cell = *(*(trace_AC + (d - 1)) + k);
        } else {
#line 123
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 130
      if (*(last_d + (k - 1)) - 1 <= *(last_d + (k + 1))) {
#line 130
        if (*(last_d + (k - 1)) - 1 <= *(last_d + k) - 1) {
#line 133
          row = *(last_d + (k - 1)) - 1;
#line 135
          AG_cell = *(*(trace_AG + (d - 1)) + (k - 1));
#line 136
          AC_cell = *(*(trace_AC + (d - 1)) + (k - 1));
        } else {
#line 139
          row = *(last_d + (k + 1));
#line 141
          AG_cell = *(*(trace_AG + (d - 1)) + (k + 1));
#line 142
          AC_cell = *(*(trace_AC + (d - 1)) + (k + 1));
        }
      } else {
#line 139
        row = *(last_d + (k + 1));
#line 141
        AG_cell = *(*(trace_AG + (d - 1)) + (k + 1));
#line 142
        AC_cell = *(*(trace_AC + (d - 1)) + (k + 1));
      }
#line 148
      col = (row + k) - ORIGIN;
#line 150
      *(*(trace_AG + d) + k) = AG_cell;
#line 151
      *(*(trace_AC + d) + k) = AC_cell;
      {
#line 153
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 153
        if (row > 0) {
#line 153
          if (col > 0) {
#line 153
            if (! ((int )*(s1 + (row - 1)) == (int )*(s2 + (col - 1)))) {
#line 153
              goto while_break___6;
            }
          } else {
#line 153
            goto while_break___6;
          }
        } else {
#line 153
          goto while_break___6;
        }
#line 154
        if (col > 1) {
          {
#line 154
          tmp___14 = strncmp((char const   *)((char *)((s2 + col) - 2)), "AG", (size_t )2);
          }
#line 154
          if (tmp___14) {
#line 154
            goto _L___1;
          } else {
            {
#line 155
            tmp___11 = ckalloc(sizeof(coords ));
#line 155
            new = (coords *)tmp___11;
#line 156
            link_to_data_list((Pointer )new, & data_list, & prev);
#line 158
            new->pos1 = (((row + k) - ORIGIN) + offset2___0) + 1;
#line 159
            new->pos2 = (row + offset1___0) + 1;
#line 160
            *(*(trace_AG + d) + k) = new;
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 161
        if (col > 1) {
          {
#line 161
          tmp___13 = strncmp((char const   *)((char *)((s2 + col) - 2)), "AC", (size_t )2);
          }
#line 161
          if (! tmp___13) {
            {
#line 162
            tmp___12 = ckalloc(sizeof(coords ));
#line 162
            new = (coords *)tmp___12;
#line 163
            link_to_data_list((Pointer )new, & data_list, & prev);
#line 165
            new->pos1 = (((row + k) - ORIGIN) + offset2___0) + 1;
#line 166
            new->pos2 = (row + offset1___0) + 1;
#line 167
            *(*(trace_AC + d) + k) = new;
            }
          }
        }
#line 169
        row --;
#line 169
        col --;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 172
      if (col > 1) {
        {
#line 172
        tmp___18 = strncmp((char const   *)((char *)((s2 + col) - 2)), "AG", (size_t )2);
        }
#line 172
        if (tmp___18) {
#line 172
          goto _L___2;
        } else {
          {
#line 173
          tmp___15 = ckalloc(sizeof(coords ));
#line 173
          new = (coords *)tmp___15;
#line 174
          link_to_data_list((Pointer )new, & data_list, & prev);
#line 176
          new->pos1 = (((row + k) - ORIGIN) + offset2___0) + 1;
#line 177
          new->pos2 = (row + offset1___0) + 1;
#line 178
          *(*(trace_AG + d) + k) = new;
          }
        }
      } else
      _L___2: /* CIL Label */ 
#line 179
      if (col > 1) {
        {
#line 179
        tmp___17 = strncmp((char const   *)((char *)((s2 + col) - 2)), "AC", (size_t )2);
        }
#line 179
        if (! tmp___17) {
          {
#line 180
          tmp___16 = ckalloc(sizeof(coords ));
#line 180
          new = (coords *)tmp___16;
#line 181
          link_to_data_list((Pointer )new, & data_list, & prev);
#line 183
          new->pos1 = (((row + k) - ORIGIN) + offset2___0) + 1;
#line 184
          new->pos2 = (row + offset1___0) + 1;
#line 185
          *(*(trace_AC + d) + k) = new;
          }
        }
      }
#line 188
      *(temp_d + k) = row;
#line 190
      if (row == 0) {
#line 190
        if (col == 0) {
          {
#line 193
          memcpy((void */* __restrict  */)(& last_AG), (void const   */* __restrict  */)*(*(trace_AG + d) + k),
                 sizeof(coords ));
#line 194
          memcpy((void */* __restrict  */)(& last_AC), (void const   */* __restrict  */)*(*(trace_AC + d) + k),
                 sizeof(coords ));
#line 196
          free((void *)last_d);
#line 196
          free((void *)temp_d);
#line 197
          free((void *)min_row);
#line 197
          free((void *)min_diag);
#line 198
          ValNodeFreeData(data_list);
#line 199
          free_coords(trace_AG, max_d + 1);
#line 200
          free_coords(trace_AC, max_d + 1);
#line 202
          *line1 = row + offset1___0;
#line 203
          *line2 = col + offset2___0;
          }
#line 205
          return (d);
        }
      }
#line 207
      if (row == 0) {
        {
#line 210
        memcpy((void */* __restrict  */)(& last_AG), (void const   */* __restrict  */)*(*(trace_AG + d) + k),
               sizeof(coords ));
#line 211
        memcpy((void */* __restrict  */)(& last_AC), (void const   */* __restrict  */)*(*(trace_AC + d) + k),
               sizeof(coords ));
#line 213
        free((void *)last_d);
#line 213
        free((void *)temp_d);
#line 214
        free((void *)min_row);
#line 214
        free((void *)min_diag);
#line 215
        ValNodeFreeData(data_list);
#line 216
        free_coords(trace_AG, max_d + 1);
#line 217
        free_coords(trace_AC, max_d + 1);
#line 219
        *line1 = row + offset1___0;
#line 220
        *line2 = col + offset2___0;
        }
#line 222
        return (d);
      }
#line 225
      if (col == 0) {
        {
#line 227
        memcpy((void */* __restrict  */)(& last_AG), (void const   */* __restrict  */)*(*(trace_AG + d) + k),
               sizeof(coords ));
#line 228
        memcpy((void */* __restrict  */)(& last_AC), (void const   */* __restrict  */)*(*(trace_AC + d) + k),
               sizeof(coords ));
#line 230
        free((void *)last_d);
#line 230
        free((void *)temp_d);
#line 231
        free((void *)min_row);
#line 231
        free((void *)min_diag);
#line 232
        ValNodeFreeData(data_list);
#line 233
        free_coords(trace_AG, max_d + 1);
#line 234
        free_coords(trace_AC, max_d + 1);
#line 236
        *line1 = row + offset1___0;
#line 237
        *line2 = col + offset2___0;
        }
#line 239
        return (d);
      }
#line 108
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 243
    *(min_row + d) = *(last_d + (ORIGIN + DELTA));
#line 244
    *(min_diag + d) = ORIGIN + DELTA;
#line 245
    k = lower;
    {
#line 245
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 245
      if (! (k <= upper)) {
#line 245
        goto while_break___7;
      }
#line 246
      if (*(temp_d + k) < *(min_row + d)) {
#line 247
        *(min_row + d) = *(temp_d + k);
#line 248
        *(min_diag + d) = k;
      }
#line 245
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 251
    k = lower;
    {
#line 251
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 251
      if (! (k <= upper)) {
#line 251
        goto while_break___8;
      }
#line 252
      *(last_d + k) = *(temp_d + k);
#line 251
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 255
    lower --;
#line 256
    upper ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 260
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 260
    if (d > 0) {
#line 260
      if (! (*(min_row + (d - 1)) - *(min_row + d) < 3)) {
#line 260
        goto while_break___9;
      }
    } else {
#line 260
      goto while_break___9;
    }
#line 261
    d --;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 263
  *line1 = *(min_row + d) + offset1___0;
#line 264
  *line2 = ((*(min_row + d) + *(min_diag + d)) - ORIGIN) + offset2___0;
#line 266
  memcpy((void */* __restrict  */)(& last_AG), (void const   */* __restrict  */)*(*(trace_AG + d) + *(min_diag + d)),
         sizeof(coords ));
#line 267
  memcpy((void */* __restrict  */)(& last_AC), (void const   */* __restrict  */)*(*(trace_AC + d) + *(min_diag + d)),
         sizeof(coords ));
#line 269
  free((void *)min_row);
#line 270
  free((void *)min_diag);
#line 271
  free((void *)last_d);
#line 272
  free((void *)temp_d);
#line 273
  ValNodeFreeData(data_list);
#line 274
  free_coords(trace_AG, max_d + 1);
#line 275
  free_coords(trace_AC, max_d + 1);
  }
#line 277
  return (d);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/Xtend1.c"
int Xextend_fw(uchar *s1 , uchar *s2 , int m , int n , int offset1___0 , int offset2___0 ,
               int *line1 , int *line2 ) 
{ 
  int col ;
  int row ;
  int max_d ;
  int d ;
  int k ;
  int ORIGIN ;
  int lower ;
  int upper ;
  int *last_d ;
  int *temp_d ;
  int *max_row ;
  int *max_diag ;
  coords ***trace_GT ;
  coords ***trace_CT ;
  coords *GT_cell ;
  coords *CT_cell ;
  coords *new ;
  ValNodePtr data_list ;
  ValNodePtr prev ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 297
  data_list = (ValNodePtr )((void *)0);
#line 297
  prev = (ValNodePtr )((void *)0);
#line 299
  max_d = m + 1;
#line 301
  tmp = ckalloc((unsigned long )(max_d + 1) * sizeof(coords **));
#line 301
  trace_GT = (coords ***)tmp;
#line 302
  tmp___0 = ckalloc((unsigned long )(max_d + 1) * sizeof(coords **));
#line 302
  trace_CT = (coords ***)tmp___0;
#line 303
  d = 0;
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (d <= max_d)) {
#line 303
      goto while_break;
    }
    {
#line 304
    tmp___1 = ckalloc((unsigned long )((m + n) + 1) * sizeof(coords *));
#line 304
    *(trace_GT + d) = (coords **)tmp___1;
#line 305
    tmp___2 = ckalloc((unsigned long )((m + n) + 1) * sizeof(coords *));
#line 305
    *(trace_CT + d) = (coords **)tmp___2;
#line 303
    d ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  ORIGIN = m;
#line 309
  *(*(trace_GT + 0) + ORIGIN) = & last_GT;
#line 310
  *(*(trace_CT + 0) + ORIGIN) = & last_CT;
#line 312
  row = 0;
#line 312
  col = 0;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (col < n) {
#line 312
      if (row < m) {
#line 312
        if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 312
          goto while_break___0;
        }
      } else {
#line 312
        goto while_break___0;
      }
    } else {
#line 312
      goto while_break___0;
    }
#line 312
    row ++;
#line 312
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 314
  k = 0;
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 314
    if (k <= n - 2) {
#line 314
      if (! (k <= row)) {
#line 314
        goto while_break___1;
      }
    } else {
#line 314
      goto while_break___1;
    }
    {
#line 315
    tmp___6 = strncmp((char const   *)((char *)(s2 + k)), "GT", (size_t )2);
    }
#line 315
    if (tmp___6) {
      {
#line 321
      tmp___5 = strncmp((char const   *)((char *)(s2 + k)), "CT", (size_t )2);
      }
#line 321
      if (! tmp___5) {
        {
#line 322
        tmp___4 = ckalloc(sizeof(coords ));
#line 322
        new = (coords *)tmp___4;
#line 323
        link_to_data_list((Pointer )new, & data_list, & prev);
#line 324
        new->pos2 = k + offset1___0;
#line 325
        new->pos1 = k + offset2___0;
#line 326
        *(*(trace_CT + 0) + ORIGIN) = new;
        }
      }
    } else {
      {
#line 316
      tmp___3 = ckalloc(sizeof(coords ));
#line 316
      new = (coords *)tmp___3;
#line 317
      link_to_data_list((Pointer )new, & data_list, & prev);
#line 318
      new->pos2 = k + offset1___0;
#line 319
      new->pos1 = k + offset2___0;
#line 320
      *(*(trace_GT + 0) + ORIGIN) = new;
      }
    }
#line 314
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 329
  if (row == m) {
#line 329
    goto _L;
  } else
#line 329
  if (col == n) {
    _L: /* CIL Label */ 
    {
#line 330
    *line1 = row + offset1___0;
#line 331
    *line2 = col + offset2___0;
#line 332
    memcpy((void */* __restrict  */)(& last_GT), (void const   */* __restrict  */)*(*(trace_GT + 0) + ORIGIN),
           sizeof(coords ));
#line 333
    memcpy((void */* __restrict  */)(& last_CT), (void const   */* __restrict  */)*(*(trace_CT + 0) + ORIGIN),
           sizeof(coords ));
#line 334
    ValNodeFreeData(data_list);
#line 335
    free_coords(trace_GT, max_d + 1);
#line 336
    free_coords(trace_CT, max_d + 1);
    }
#line 338
    return (0);
  }
  {
#line 341
  tmp___7 = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 341
  last_d = (int *)tmp___7;
#line 342
  tmp___8 = ckalloc((unsigned long )((m + n) + 1) * sizeof(int ));
#line 342
  temp_d = (int *)tmp___8;
#line 344
  k = 0;
  }
  {
#line 344
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 344
    if (! (k <= m + n)) {
#line 344
      goto while_break___2;
    }
#line 344
    *(last_d + k) = -1;
#line 344
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 345
  *(last_d + ORIGIN) = row;
#line 347
  lower = ORIGIN - 1;
#line 348
  upper = ORIGIN + 1;
#line 350
  tmp___9 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 350
  max_row = (int *)tmp___9;
#line 351
  tmp___10 = ckalloc((unsigned long )(m + 1) * sizeof(int ));
#line 351
  max_diag = (int *)tmp___10;
#line 353
  d = 1;
  }
  {
#line 353
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 353
    if (! (d <= m)) {
#line 353
      goto while_break___3;
    }
#line 354
    *(max_row + d) = -1;
#line 353
    d ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 356
  *(max_row + 0) = *(last_d + ORIGIN);
#line 357
  *(max_diag + 0) = ORIGIN;
#line 360
  d = 0;
  {
#line 361
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 361
    d ++;
#line 361
    if (d <= max_d) {
      {
#line 361
      tmp___19 = good_ratio(*(max_row + (d - 1)));
      }
#line 361
      if (! (d - 1 <= tmp___19)) {
#line 361
        if (d >= 2) {
          {
#line 361
          tmp___20 = good_ratio(*(max_row + (d - 2)));
          }
#line 361
          if (! (d - 2 <= tmp___20)) {
#line 361
            goto while_break___4;
          }
        } else {
#line 361
          goto while_break___4;
        }
      }
    } else {
#line 361
      goto while_break___4;
    }
#line 366
    k = lower;
    {
#line 366
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 366
      if (! (k <= upper)) {
#line 366
        goto while_break___5;
      }
#line 369
      if (k == - d + ORIGIN) {
#line 371
        row = *(last_d + (k + 1)) + 1;
#line 373
        GT_cell = *(*(trace_GT + (d - 1)) + (k + 1));
#line 374
        CT_cell = *(*(trace_CT + (d - 1)) + (k + 1));
      } else
#line 375
      if (k == d + ORIGIN) {
#line 377
        row = *(last_d + (k - 1));
#line 379
        GT_cell = *(*(trace_GT + (d - 1)) + (k - 1));
#line 380
        CT_cell = *(*(trace_CT + (d - 1)) + (k - 1));
      } else
#line 381
      if (*(last_d + k) >= *(last_d + (k + 1))) {
#line 381
        if (*(last_d + k) + 1 >= *(last_d + (k - 1))) {
#line 384
          row = *(last_d + k) + 1;
#line 386
          GT_cell = *(*(trace_GT + (d - 1)) + k);
#line 387
          CT_cell = *(*(trace_CT + (d - 1)) + k);
        } else {
#line 381
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 388
      if (*(last_d + (k + 1)) + 1 >= *(last_d + (k - 1))) {
#line 388
        if (*(last_d + (k + 1)) >= *(last_d + k)) {
#line 391
          row = *(last_d + (k + 1)) + 1;
#line 393
          GT_cell = *(*(trace_GT + (d - 1)) + (k + 1));
#line 394
          CT_cell = *(*(trace_CT + (d - 1)) + (k + 1));
        } else {
#line 398
          row = *(last_d + (k - 1));
#line 400
          GT_cell = *(*(trace_GT + (d - 1)) + (k - 1));
#line 401
          CT_cell = *(*(trace_CT + (d - 1)) + (k - 1));
        }
      } else {
#line 398
        row = *(last_d + (k - 1));
#line 400
        GT_cell = *(*(trace_GT + (d - 1)) + (k - 1));
#line 401
        CT_cell = *(*(trace_CT + (d - 1)) + (k - 1));
      }
#line 407
      col = (row + k) - ORIGIN;
#line 409
      *(*(trace_GT + d) + k) = GT_cell;
#line 410
      *(*(trace_CT + d) + k) = CT_cell;
#line 412
      if (row >= 0) {
        {
#line 413
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 413
          if (row < m) {
#line 413
            if (col < n) {
#line 413
              if (! ((int )*(s1 + row) == (int )*(s2 + col))) {
#line 413
                goto while_break___6;
              }
            } else {
#line 413
              goto while_break___6;
            }
          } else {
#line 413
            goto while_break___6;
          }
#line 414
          if (col < n - 1) {
            {
#line 414
            tmp___14 = strncmp((char const   *)((char *)(s2 + col)), "GT", (size_t )2);
            }
#line 414
            if (tmp___14) {
#line 414
              goto _L___1;
            } else {
              {
#line 415
              tmp___11 = ckalloc(sizeof(coords ));
#line 415
              new = (coords *)tmp___11;
#line 416
              link_to_data_list((Pointer )new, & data_list, & prev);
#line 418
              new->pos1 = ((row + k) - ORIGIN) + offset2___0;
#line 419
              new->pos2 = row + offset1___0;
#line 420
              *(*(trace_GT + d) + k) = new;
              }
            }
          } else
          _L___1: /* CIL Label */ 
#line 421
          if (col < n - 1) {
            {
#line 421
            tmp___13 = strncmp((char const   *)((char *)(s2 + col)), "CT", (size_t )2);
            }
#line 421
            if (! tmp___13) {
              {
#line 422
              tmp___12 = ckalloc(sizeof(coords ));
#line 422
              new = (coords *)tmp___12;
#line 423
              link_to_data_list((Pointer )new, & data_list, & prev);
#line 425
              new->pos1 = ((row + k) - ORIGIN) + offset2___0;
#line 426
              new->pos2 = row + offset1___0;
#line 427
              *(*(trace_CT + d) + k) = new;
              }
            }
          }
#line 430
          row ++;
#line 430
          col ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 433
      if (col < n - 1) {
        {
#line 433
        tmp___18 = strncmp((char const   *)((char *)(s2 + col)), "GT", (size_t )2);
        }
#line 433
        if (tmp___18) {
#line 433
          goto _L___2;
        } else {
          {
#line 434
          tmp___15 = ckalloc(sizeof(coords ));
#line 434
          new = (coords *)tmp___15;
#line 435
          link_to_data_list((Pointer )new, & data_list, & prev);
#line 437
          new->pos1 = ((row + k) - ORIGIN) + offset2___0;
#line 438
          new->pos2 = row + offset1___0;
#line 439
          *(*(trace_GT + d) + k) = new;
          }
        }
      } else
      _L___2: /* CIL Label */ 
#line 440
      if (col < n - 1) {
        {
#line 440
        tmp___17 = strncmp((char const   *)((char *)(s2 + col)), "CT", (size_t )2);
        }
#line 440
        if (! tmp___17) {
          {
#line 441
          tmp___16 = ckalloc(sizeof(coords ));
#line 441
          new = (coords *)tmp___16;
#line 442
          link_to_data_list((Pointer )new, & data_list, & prev);
#line 444
          new->pos1 = ((row + k) - ORIGIN) + offset2___0;
#line 445
          new->pos2 = row + offset1___0;
#line 446
          *(*(trace_CT + d) + k) = new;
          }
        }
      }
#line 449
      *(temp_d + k) = row;
#line 451
      if (row == m) {
#line 451
        if (col == n) {
          {
#line 453
          memcpy((void */* __restrict  */)(& last_GT), (void const   */* __restrict  */)*(*(trace_GT + d) + k),
                 sizeof(coords ));
#line 454
          memcpy((void */* __restrict  */)(& last_CT), (void const   */* __restrict  */)*(*(trace_CT + d) + k),
                 sizeof(coords ));
#line 456
          ValNodeFreeData(data_list);
#line 457
          free_coords(trace_GT, max_d + 1);
#line 458
          free_coords(trace_CT, max_d + 1);
#line 459
          free((void *)last_d);
#line 459
          free((void *)temp_d);
#line 460
          free((void *)max_row);
#line 460
          free((void *)max_diag);
#line 461
          *line1 = row + offset1___0;
#line 462
          *line2 = col + offset2___0;
          }
#line 464
          return (d);
        }
      }
#line 466
      if (row == m) {
        {
#line 468
        memcpy((void */* __restrict  */)(& last_GT), (void const   */* __restrict  */)*(*(trace_GT + d) + k),
               sizeof(coords ));
#line 469
        memcpy((void */* __restrict  */)(& last_CT), (void const   */* __restrict  */)*(*(trace_CT + d) + k),
               sizeof(coords ));
#line 471
        ValNodeFreeData(data_list);
#line 472
        free_coords(trace_GT, max_d + 1);
#line 473
        free_coords(trace_CT, max_d + 1);
#line 474
        free((void *)temp_d);
#line 474
        free((void *)last_d);
#line 475
        free((void *)max_row);
#line 475
        free((void *)max_diag);
#line 477
        *line1 = row + offset1___0;
#line 478
        *line2 = col + offset2___0;
        }
#line 480
        return (d);
      }
#line 483
      if (col == n) {
        {
#line 485
        memcpy((void */* __restrict  */)(& last_GT), (void const   */* __restrict  */)*(*(trace_GT + d) + k),
               sizeof(coords ));
#line 486
        memcpy((void */* __restrict  */)(& last_CT), (void const   */* __restrict  */)*(*(trace_CT + d) + k),
               sizeof(coords ));
#line 488
        ValNodeFreeData(data_list);
#line 489
        free_coords(trace_GT, max_d + 1);
#line 490
        free_coords(trace_CT, max_d + 1);
#line 492
        free((void *)temp_d);
#line 492
        free((void *)last_d);
#line 493
        free((void *)max_row);
#line 493
        free((void *)max_diag);
#line 495
        *line1 = row + offset1___0;
#line 496
        *line2 = col + offset2___0;
        }
#line 498
        return (d);
      }
#line 366
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 501
    *(max_row + d) = *(last_d + ORIGIN);
#line 502
    *(max_diag + d) = ORIGIN;
#line 503
    k = lower;
    {
#line 503
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 503
      if (! (k <= upper)) {
#line 503
        goto while_break___7;
      }
#line 504
      if (*(temp_d + k) > *(max_row + d)) {
#line 505
        *(max_row + d) = *(temp_d + k);
#line 506
        *(max_diag + d) = k;
      }
#line 503
      k ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 509
    k = lower;
    {
#line 509
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 509
      if (! (k <= upper)) {
#line 509
        goto while_break___8;
      }
#line 510
      *(last_d + k) = *(temp_d + k);
#line 509
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 513
    lower --;
#line 514
    upper ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 519
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 519
    if (d > 0) {
#line 519
      if (! (*(max_row + d) - *(max_row + (d - 1)) < 3)) {
#line 519
        goto while_break___9;
      }
    } else {
#line 519
      goto while_break___9;
    }
#line 520
    d --;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 522
  *line1 = *(max_row + d) + offset1___0;
#line 523
  *line2 = ((*(max_row + d) + *(max_diag + d)) - ORIGIN) + offset2___0;
#line 525
  memcpy((void */* __restrict  */)(& last_GT), (void const   */* __restrict  */)*(*(trace_GT + d) + *(max_diag + d)),
         sizeof(coords ));
#line 526
  memcpy((void */* __restrict  */)(& last_CT), (void const   */* __restrict  */)*(*(trace_CT + d) + *(max_diag + d)),
         sizeof(coords ));
#line 528
  free((void *)max_row);
#line 529
  free((void *)max_diag);
#line 530
  free((void *)last_d);
#line 531
  free((void *)temp_d);
#line 532
  ValNodeFreeData(data_list);
#line 533
  free_coords(trace_GT, max_d + 1);
#line 534
  free_coords(trace_CT, max_d + 1);
  }
#line 537
  return (d);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/Xtend1.c"
static void free_coords(coords ***val , int size ) 
{ 
  int i ;

  {
#line 545
  i = 0;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < size)) {
#line 545
      goto while_break;
    }
    {
#line 546
    free((void *)*(val + i));
#line 545
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 547
  free((void *)val);
  }
#line 548
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/discrim.c"
uchar const   dchars[17]  = 
#line 15 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/discrim.c"
  {      (uchar const   )'A',      (uchar const   )'B',      (uchar const   )'C',      (uchar const   )'D', 
        (uchar const   )'G',      (uchar const   )'H',      (uchar const   )'K',      (uchar const   )'M', 
        (uchar const   )'N',      (uchar const   )'R',      (uchar const   )'S',      (uchar const   )'T', 
        (uchar const   )'V',      (uchar const   )'W',      (uchar const   )'X',      (uchar const   )'Y', 
        (uchar const   )'\000'};
#line 17
static int is_dchar(int ch ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/discrim.c"
bool is_DNA(uchar *s , int len ) 
{ 
  int ACGT ;
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 23
  i = 0;
#line 23
  ACGT = i;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (i < len)) {
#line 23
      goto while_break;
    }
    {
#line 24
    tmp = strchr("ACGTNXacgtnx", (int )*(s + i));
    }
#line 24
    if (tmp) {
#line 25
      ACGT ++;
    }
#line 23
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  if (10 * ACGT < 9 * len) {
#line 27
    return (0);
  }
#line 29
  i = 0;
  {
#line 29
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 29
    if (! (i < len)) {
#line 29
      goto while_break___0;
    }
    {
#line 30
    tmp___0 = is_dchar((int )*(s + i));
    }
#line 30
    if (! tmp___0) {
      {
#line 31
      fatalf("Illegal character \'%c\' in sequence file.\n", (int )*(s + i));
#line 32
      exit(1);
      }
    }
#line 29
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 34
  return (1);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/discrim.c"
static int is_dchar(int ch ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = toupper(ch);
#line 39
  tmp___0 = strchr((char const   *)(dchars), tmp);
  }
#line 39
  if (tmp___0) {
#line 39
    tmp___1 = 1;
  } else {
#line 39
    tmp___1 = 0;
  }
#line 39
  return (tmp___1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.h"
void debugf(char const   *fmt  , ...) ;
#line 17
void debugff(char const   *fmt  , ...) ;
#line 19
FILE *ckpopen(char const   *name , char const   *mode ) ;
#line 25
void *ckfree(void *p ) ;
#line 26
bool same_string(char const   *s , char const   *t ) ;
#line 28
char *copy_substring(char const   *s , int n ) ;
#line 29
long ckftell(FILE *f ) ;
#line 30
int ckfseek(FILE *f , long i , int m ) ;
#line 46
int psublast_debug ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
 __attribute__((__noreturn__)) void fatal(char const   *msg ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void fatal(char const   *msg ) 
{ 


  {
  {
#line 15
  fflush(stdout);
#line 16
  fatalf("%s", msg);
#line 17
  exit(1);
  }
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
static void print_argv0(void) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 24
  if (argv0) {
    {
#line 25
    tmp = strrchr((char const   *)argv0, '/');
#line 25
    p = tmp;
    }
#line 26
    if (p) {
#line 26
      tmp___0 = p + 1;
    } else {
#line 26
      tmp___0 = argv0;
    }
    {
#line 26
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            tmp___0);
    }
  }
#line 28
  return;
}
}
#line 30
 __attribute__((__noreturn__)) void fatalf(char const   *fmt  , ...) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void fatalf(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 33
  __builtin_va_start(ap, fmt);
#line 34
  fflush(stdout);
#line 35
  print_argv0();
#line 36
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 37
  fputc('\n', stderr);
#line 38
  __builtin_va_end(ap);
#line 39
  exit(1);
  }
}
}
#line 42
 __attribute__((__noreturn__)) void fatalfr(char const   *fmt  , ...) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void fatalfr(char const   *fmt  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 45
  __builtin_va_start(ap, fmt);
#line 46
  fflush(stdout);
#line 47
  print_argv0();
#line 48
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 49
  tmp = __errno_location();
#line 49
  tmp___0 = strerror(*tmp);
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
          tmp___0);
#line 50
  __builtin_va_end(ap);
#line 51
  exit(1);
  }
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
int psublast_debug  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void debugf(char const   *fmt  , ...) 
{ 
  va_list ap ;
  int tmp ;

  {
  {
#line 59
  __builtin_va_start(ap, fmt);
  }
#line 60
  if (psublast_debug) {
    {
#line 61
    fflush(stdout);
#line 62
    print_argv0();
#line 63
    tmp = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
                   ap);
    }
#line 63
    if (tmp < 0) {
      {
#line 64
      exit(1);
      }
    }
  }
  {
#line 66
  __builtin_va_end(ap);
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void debugff(char const   *fmt  , ...) 
{ 
  va_list ap ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 72
  __builtin_va_start(ap, fmt);
  }
#line 73
  if (psublast_debug) {
    {
#line 74
    fflush(stdout);
#line 75
    print_argv0();
#line 76
    tmp = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
                   ap);
    }
#line 76
    if (tmp < 0) {
      {
#line 77
      exit(1);
      }
    }
    {
#line 78
    tmp___0 = fflush(stderr);
    }
#line 78
    if (tmp___0 != 0) {
      {
#line 79
      exit(1);
      }
    }
  }
  {
#line 81
  __builtin_va_end(ap);
  }
#line 82
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
FILE *ckopen(char const   *name , char const   *mode ) 
{ 
  FILE *fp ;

  {
  {
#line 89
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
#line 89
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 90
    fatalfr("Cannot open %s.", name);
    }
  }
#line 91
  return (fp);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void *ckalloc(size_t amount ) 
{ 
  void *p ;

  {
#line 99
  if (! ((long )amount >= 0L)) {
    {
#line 99
    __assert_fail("(long)amount >= 0", "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c",
                  99U, "ckalloc");
    }
  }
#line 100
  if (amount == 0UL) {
#line 101
    amount = (size_t )1;
  }
  {
#line 102
  p = malloc(amount);
  }
#line 102
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 103
    fatalf("Ran out of memory trying to allocate %lu.", amount);
    }
  }
#line 108
  return (p);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void *ckallocz(size_t amount ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 114
  tmp = ckalloc(amount);
#line 114
  p = tmp;
#line 115
  memset(p, 0, amount);
  }
#line 116
  return (p);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void *ckfree(void *p ) 
{ 


  {
  {
#line 121
  free(p);
  }
#line 122
  return ((void *)0);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
bool same_string(char const   *s , char const   *t ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = strcmp(s, t);
  }
#line 128
  return (tmp == 0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
char *copy_string(char const   *s ) 
{ 
  char *p ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 136
  tmp = strlen(s);
#line 136
  tmp___0 = ckalloc(tmp + 1UL);
#line 136
  p = (char *)tmp___0;
#line 137
  tmp___1 = strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)s);
  }
#line 137
  return (tmp___1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
char *copy_substring(char const   *s , int n ) 
{ 
  char *p ;
  void *tmp ;

  {
  {
#line 142
  tmp = ckalloc((size_t )n + 1UL);
#line 142
  p = (char *)tmp;
#line 143
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)s, (size_t )n);
#line 144
  *(p + n) = (char)0;
  }
#line 145
  return (p);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
long ckftell(FILE *f ) 
{ 
  long r ;
  long tmp ;

  {
  {
#line 150
  tmp = ftell(f);
#line 150
  r = tmp;
  }
#line 151
  if (r < 0L) {
    {
#line 152
    fatalfr("bad ftell: %s");
    }
  }
#line 153
  return (r);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
int ckfseek(FILE *f , long i , int m ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 158
  tmp = fseek(f, i, m);
#line 158
  r = tmp;
  }
#line 159
  if (r < 0) {
    {
#line 160
    fatalfr("bad fseek: %s");
    }
  }
#line 161
  return (r);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void *ckrealloc(void *p , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 166
  if (p) {
    {
#line 166
    tmp = realloc(p, size);
#line 166
    p = tmp;
    }
  } else {
    {
#line 166
    tmp___0 = malloc(size);
#line 166
    p = tmp___0;
    }
  }
#line 167
  if (! p) {
    {
#line 168
    fatal("ckrealloc failed");
    }
  }
#line 169
  return (p);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
FILE *ckpopen(char const   *name , char const   *mode ) 
{ 
  FILE *fp ;

  {
  {
#line 176
  fp = popen(name, mode);
  }
#line 176
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 177
    fatalfr("Cannot open %s.", name);
    }
  }
#line 178
  return (fp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/sim4-0.0.20121010/misc.c"
void ckpclose(FILE *fp ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 183
  tmp = pclose(fp);
#line 183
  r = tmp;
  }
#line 184
  if (r != 0) {
    {
#line 185
    fatalfr("pclose failed (status %d)", r);
    }
  }
#line 186
  return;
}
}
