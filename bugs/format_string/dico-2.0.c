/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 55 "libltdl/slist.h"
struct slist {
   struct slist *next ;
   void const   *userdata ;
};
#line 55 "libltdl/slist.h"
typedef struct slist SList;
#line 60 "libltdl/slist.h"
typedef void *SListCallback(SList *item , void *userdata );
#line 61 "libltdl/slist.h"
typedef int SListCompare(SList const   *item1 , SList const   *item2 , void *userdata );
#line 39 "./libltdl/lt_dlloader.h"
typedef void *lt_module;
#line 40 "./libltdl/lt_dlloader.h"
typedef void *lt_user_data;
#line 41
struct lt__advise;
#line 41 "./libltdl/lt_dlloader.h"
typedef struct lt__advise *lt_dladvise;
#line 44 "./libltdl/lt_dlloader.h"
typedef lt_module lt_module_open(lt_user_data data , char const   *filename , lt_dladvise advise );
#line 47 "./libltdl/lt_dlloader.h"
typedef int lt_module_close(lt_user_data data , lt_module module );
#line 49 "./libltdl/lt_dlloader.h"
typedef void *lt_find_sym(lt_user_data data , lt_module module , char const   *symbolname );
#line 51 "./libltdl/lt_dlloader.h"
typedef int lt_dlloader_init(lt_user_data data );
#line 52 "./libltdl/lt_dlloader.h"
typedef int lt_dlloader_exit(lt_user_data data );
#line 55
enum __anonenum_lt_dlloader_priority_33 {
    LT_DLLOADER_PREPEND = 0,
    LT_DLLOADER_APPEND = 1
} ;
#line 55 "./libltdl/lt_dlloader.h"
typedef enum __anonenum_lt_dlloader_priority_33 lt_dlloader_priority;
#line 61 "./libltdl/lt_dlloader.h"
struct __anonstruct_lt_dlvtable_34 {
   char const   *name ;
   char const   *sym_prefix ;
   lt_module_open *module_open ;
   lt_module_close *module_close ;
   lt_find_sym *find_sym ;
   lt_dlloader_init *dlloader_init ;
   lt_dlloader_exit *dlloader_exit ;
   lt_user_data dlloader_data ;
   lt_dlloader_priority priority ;
};
#line 61 "./libltdl/lt_dlloader.h"
typedef struct __anonstruct_lt_dlvtable_34 lt_dlvtable;
#line 50 "./ltdl.h"
struct lt__handle;
#line 50 "./ltdl.h"
typedef struct lt__handle *lt_dlhandle;
#line 91 "./ltdl.h"
struct __anonstruct_lt_dlsymlist_35 {
   char const   *name ;
   void *address ;
};
#line 91 "./ltdl.h"
typedef struct __anonstruct_lt_dlsymlist_35 lt_dlsymlist;
#line 96 "./ltdl.h"
typedef int lt_dlpreload_callback_func(lt_dlhandle handle );
#line 116 "./ltdl.h"
typedef void *lt_dlinterface_id;
#line 129 "./ltdl.h"
struct __anonstruct_lt_dlinfo_36 {
   char *filename ;
   char *name ;
   int ref_count ;
   unsigned int is_resident : 1 ;
   unsigned int is_symglobal : 1 ;
   unsigned int is_symlocal : 1 ;
};
#line 129 "./ltdl.h"
typedef struct __anonstruct_lt_dlinfo_36 lt_dlinfo;
#line 105 "libltdl/lt__private.h"
struct __anonstruct_lt_interface_data_37 {
   lt_dlinterface_id key ;
   void *data ;
};
#line 105 "libltdl/lt__private.h"
typedef struct __anonstruct_lt_interface_data_37 lt_interface_data;
#line 110 "libltdl/lt__private.h"
struct lt__handle {
   lt_dlhandle next ;
   lt_dlvtable const   *vtable ;
   lt_dlinfo info ;
   int depcount ;
   lt_dlhandle *deplibs ;
   lt_module module ;
   void *system ;
   lt_interface_data *interface_data ;
   int flags ;
};
#line 122 "libltdl/lt__private.h"
struct lt__advise {
   unsigned int try_ext : 1 ;
   unsigned int is_resident : 1 ;
   unsigned int is_symglobal : 1 ;
   unsigned int is_symlocal : 1 ;
};
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
struct symlist_chain {
   struct symlist_chain *next ;
   lt_dlsymlist const   *symlist ;
};
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
typedef struct symlist_chain symlist_chain;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 69 "/usr/include/errno.h"
typedef int error_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 38 "./libltdl/lt_dlloader.h"
typedef void *lt_dlloader;
#line 82 "./libltdl/lt_dlloader.h"
typedef lt_dlvtable const   *lt_get_vtable(lt_user_data data );
#line 117 "./ltdl.h"
typedef int lt_dlhandle_interface(lt_dlhandle handle , char const   *id_string );
#line 84 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
typedef int foreach_callback_func(char *filename , void *data1 , void *data2 );
#line 87 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
typedef int file_worker_func(char const   *filename , void *data );
#line 2211 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
struct __anonstruct_lt__interface_id_38 {
   char const   *id_string ;
   lt_dlhandle_interface *iface ;
};
#line 2211 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
typedef struct __anonstruct_lt__interface_id_38 lt__interface_id;
#line 44 "../include/dico/types.h"
struct dico_list;
#line 44 "../include/dico/types.h"
typedef struct dico_list *dico_list_t;
#line 26 "../include/dico/utf8.h"
struct utf8_iterator {
   char *string ;
   char *curptr ;
   unsigned int curwidth ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
struct unicase_info_st {
   unsigned int toupper ;
   unsigned int tolower ;
   unsigned int sort ;
};
#line 32 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
typedef struct unicase_info_st MY_UNICASE_INFO;
#line 1694 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
struct tstring {
   unsigned char *ptr ;
   size_t len ;
};
#line 45 "../include/dico/types.h"
struct dico_assoc_list;
#line 45 "../include/dico/types.h"
typedef struct dico_assoc_list *dico_assoc_list_t;
#line 25 "../include/dico/url.h"
struct dico_request {
   int type ;
   char *word ;
   char *database ;
   char *strategy ;
   unsigned long n ;
};
#line 33 "../include/dico/url.h"
struct dico_url {
   char *string ;
   char *proto ;
   char *host ;
   int port ;
   char *path ;
   char *user ;
   char *passwd ;
   dico_assoc_list_t args ;
   struct dico_request req ;
};
#line 45 "../include/dico/url.h"
typedef struct dico_url *dico_url_t;
#line 21 "../include/dico/xlat.h"
struct xlat_tab {
   char *string ;
   int num ;
};
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 43 "../include/dico/types.h"
struct dico_stream;
#line 43 "../include/dico/types.h"
typedef struct dico_stream *dico_stream_t;
#line 23 "../include/dico/stream.h"
enum dico_buffer_type {
    dico_buffer_none = 0,
    dico_buffer_line = 1,
    dico_buffer_full = 2
} ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
struct dico_stream {
   enum dico_buffer_type buftype ;
   size_t bufsize ;
   char *buffer ;
   size_t level ;
   char *cur ;
   int flags ;
   off_t bytes_in ;
   off_t bytes_out ;
   int last_err ;
   int (*read)(void * , char * , size_t  , size_t * ) ;
   int (*write)(void * , char const   * , size_t  , size_t * ) ;
   int (*flush)(void * ) ;
   int (*open)(void * , int  ) ;
   int (*close)(void * ) ;
   int (*destroy)(void * ) ;
   int (*seek)(void * , off_t  , int  , off_t * ) ;
   int (*size)(void * , off_t * ) ;
   int (*ctl)(void * , int  , void * ) ;
   char const   *(*error_string)(void * , int  ) ;
   void *data ;
};
#line 46 "../include/dico/types.h"
struct iterator;
#line 46 "../include/dico/types.h"
typedef struct iterator *dico_iterator_t;
#line 54
struct dico_strategy;
#line 54 "../include/dico/types.h"
typedef struct dico_strategy *dico_strategy_t;
#line 26 "../include/dico/list.h"
typedef int (*dico_list_comp_t)(void const   * , void * );
#line 23 "../include/dico/strat.h"
struct dico_strategy {
   char *name ;
   char *descr ;
   int (*sel)(int  , char const   * , char const   * , void * ) ;
   void *closure ;
   int is_default ;
   dico_list_t stratcl ;
};
#line 22 "../include/dico/parseopt.h"
enum dico_opt_type {
    dico_opt_null = 0,
    dico_opt_bool = 1,
    dico_opt_bitmask = 2,
    dico_opt_bitmask_rev = 3,
    dico_opt_long = 4,
    dico_opt_string = 5,
    dico_opt_enum = 6,
    dico_opt_const = 7,
    dico_opt_const_string = 8
} ;
#line 34 "../include/dico/parseopt.h"
union __anonunion_v_28 {
   long value ;
   char const   **enumstr ;
};
#line 34 "../include/dico/parseopt.h"
struct dico_option {
   char const   *name ;
   size_t len ;
   enum dico_opt_type type ;
   void *data ;
   union __anonunion_v_28 v ;
   int (*func)(struct dico_option * , char const   * ) ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
struct _mapfile_stream {
   char *filename ;
   int fd ;
   int flags ;
   char *start ;
   size_t size ;
   off_t offset ;
};
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
struct log_stream {
   int level ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct list_entry {
   struct list_entry *next ;
   void *data ;
};
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct dico_list {
   size_t count ;
   struct list_entry *head ;
   struct list_entry *tail ;
   struct iterator *itr ;
   int (*comp)(void const   * , void * ) ;
   int (*free_item)(void *item , void *data ) ;
   void *free_data ;
};
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct iterator {
   struct iterator *next ;
   dico_list_t list ;
   struct list_entry *cur ;
   int advanced ;
};
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
struct _iostr {
   dico_stream_t in ;
   dico_stream_t out ;
   dico_stream_t last_err ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
struct hdr_buf {
   char *base ;
   size_t size ;
   size_t level ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
struct filter_stream {
   dico_stream_t transport ;
   char buf[2048] ;
   size_t level ;
   size_t min_level ;
   size_t max_line_length ;
   size_t line_length ;
   int (*xcode)(char const   * , size_t  , char * , size_t  , size_t * ) ;
   char *inbuf ;
   size_t inlevel ;
};
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
struct _stream {
   int fd ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
struct dbg_stream {
   dico_stream_t transport ;
   char const   *file ;
   unsigned int line ;
   int ts ;
};
#line 24 "../include/dico/assoc.h"
struct dico_assoc {
   char const   *key ;
   char *value ;
};
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
struct dico_assoc_list {
   int flags ;
   dico_list_t list ;
};
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
struct find_closure {
   size_t count ;
   char const   *str ;
};
#line 32 "../include/dico/argcv.h"
enum dico_argcv_quoting_style {
    dico_argcv_quoting_octal = 0,
    dico_argcv_quoting_hex = 1
} ;
#line 59 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
struct argcv_info {
   int len ;
   char const   *command ;
   char const   *delim ;
   char const   *comment ;
   int flags ;
   int start ;
   int end ;
   int save ;
   int finish_pos ;
};
#line 323 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 352 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int wint_t;
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
enum __anonenum_arg_type_28 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
typedef enum __anonenum_arg_type_28 arg_type;
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
union __anonunion_a_30 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
struct __anonstruct_argument_29 {
   arg_type type ;
   union __anonunion_a_30 a ;
};
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
typedef struct __anonstruct_argument_29 argument;
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
struct __anonstruct_arguments_31 {
   size_t count ;
   argument *arg ;
};
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
typedef struct __anonstruct_arguments_31 arguments;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
struct __anonstruct_char_directive_32 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
typedef struct __anonstruct_char_directive_32 char_directive;
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
struct __anonstruct_char_directives_33 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
typedef struct __anonstruct_char_directives_33 char_directives;
#line 141 "/usr/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 149 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef int ptrdiff_t;
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7
} ;
#line 194
struct quoting_options;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_25 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_24 {
   int __count ;
   union __anonunion___value_25 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_24 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
};
#line 627 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 139 "/usr/include/stdint.h"
typedef long long intmax_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.h"
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 254 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
struct __anonstruct_28 {
   char c ;
   uint32_t x ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 56
struct hash_table;
#line 58 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
typedef struct hash_table Hash_table;
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
struct __anonstruct_gl_des_ctx_1 {
   uint32_t encrypt_subkeys[32] ;
   uint32_t decrypt_subkeys[32] ;
};
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
typedef struct __anonstruct_gl_des_ctx_1 gl_des_ctx;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
struct __anonstruct_gl_3des_ctx_2 {
   uint32_t encrypt_subkeys[96] ;
   uint32_t decrypt_subkeys[96] ;
};
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
typedef struct __anonstruct_gl_3des_ctx_2 gl_3des_ctx;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
struct transcript_stream {
   int flags ;
   dico_stream_t transport ;
   dico_stream_t logstr ;
   char *prefix[2] ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 869 "/usr/include/stdio.h"
struct obstack;
#line 88 "../include/xdico.h"
struct xdico_input;
#line 88 "../include/xdico.h"
typedef struct xdico_input *xdico_input_t;
#line 144 "../gnu/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 151 "../gnu/obstack.h"
union __anonunion_temp_30 {
   int tempint ;
   void *tempptr ;
};
#line 151 "../gnu/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_30 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
struct xdico_input {
   struct obstack stk ;
   char *rootptr ;
   int argc ;
   char **argv ;
};
#line 66 "../include/xdico.h"
struct timer_slot;
#line 66 "../include/xdico.h"
typedef struct timer_slot *xdico_timer_t;
#line 154 "/usr/include/bits/resource.h"
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
#line 178 "/usr/include/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 40 "/usr/include/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
struct timer_slot {
   char *name ;
   double real ;
   double self_user ;
   double self_system ;
   double children_user ;
   double children_system ;
   struct timeval real_mark ;
   struct rusage self_mark ;
   struct rusage children_mark ;
};
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
typedef unsigned char uchar;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
struct cvt_tab {
   uchar in1 ;
   uchar in2_range[2] ;
   uchar out1 ;
   uchar out2 ;
};
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 92
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 25 "../include/xdico.h"
typedef unsigned long UINT4;
#line 26 "../include/xdico.h"
typedef UINT4 IPADDR;
#line 125 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct funtab {
   char *name ;
   int argmin ;
   int argmax ;
   char *argdoc ;
   char *docstring ;
   void (*fun)(int argc , char **argv ) ;
   char **(*compl)(int argc , char **argv , int ws ) ;
};
#line 374 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
struct init_script {
   FILE *fp ;
   char *buf ;
   size_t size ;
};
#line 66 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct match_result {
   char *database ;
   char *word ;
};
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct define_result {
   char *word ;
   char *database ;
   char *descr ;
   char *defn ;
   size_t nlines ;
};
#line 79
enum dict_result_type {
    dict_result_define = 0,
    dict_result_match = 1,
    dict_result_text = 2
} ;
#line 85
struct dict_connection;
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
union __anonunion_set_70 {
   struct define_result *def ;
   struct match_result *mat ;
};
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct dict_result {
   struct dict_result *prev ;
   struct dict_connection *conn ;
   enum dict_result_type type ;
   size_t count ;
   char *base ;
   union __anonunion_set_70 set ;
};
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct dict_connection {
   int fd ;
   dico_stream_t str ;
   int transcript ;
   int capac ;
   char **capav ;
   char *msgid ;
   char *buf ;
   size_t size ;
   size_t level ;
   size_t levdist ;
   struct obstack stk ;
   struct dict_result *last_result ;
   struct dict_result *db_result ;
   struct dict_result *strat_result ;
   struct dict_result *match_result ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
struct pfile_stream {
   FILE *fp ;
};
#line 104 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
struct result_display {
   struct result_display *next ;
   char *database ;
   int count ;
   char **matches ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
enum dico_client_mode {
    mode_define = 0,
    mode_match = 1,
    mode_dbs = 2,
    mode_strats = 3,
    mode_help = 4,
    mode_info = 5,
    mode_server = 6
} ;
#line 115 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct auth_cred {
   char *user ;
   char *pass ;
   int sasl ;
   dico_list_t mech ;
   char *service ;
   char *realm ;
   char *hostname ;
};
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 188 "cmdline.opt"
struct opthelp {
   char const   *opt ;
   char const   *arg ;
   int is_optional ;
   char const   *descr ;
};
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
enum kw_tok {
    kw_login = 0,
    kw_password = 1,
    kw_noauth = 2,
    kw_nosasl = 3,
    kw_sasl = 4,
    kw_mechanism = 5,
    kw_realm = 6,
    kw_service = 7,
    kw_host = 8
} ;
#line 101 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
struct keyword {
   char *name ;
   int arg ;
   enum kw_tok tok ;
};
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 45 "libltdl/lt__strl.h"
size_t lt_strlcat(char *dst , char const   *src , size_t const   dstsize ) ;
#line 50
size_t lt_strlcpy(char *dst , char const   *src , size_t const   dstsize ) ;
#line 50 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c"
size_t lt_strlcat(char *dst , char const   *src , size_t const   dstsize ) 
{ 
  size_t length ;
  char *p ;
  char const   *q ;
  char const   *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 57
  if (! ((unsigned long )dst != (unsigned long )((void *)0))) {
    {
#line 57
    __assert_fail("dst != ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  57U, "lt_strlcat");
    }
  }
#line 58
  if (! ((unsigned long )src != (unsigned long )((char const   *)((void *)0)))) {
    {
#line 58
    __assert_fail("src != (const char *) ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  58U, "lt_strlcat");
    }
  }
#line 59
  if (! (dstsize >= 1U)) {
    {
#line 59
    __assert_fail("dstsize >= 1", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  59U, "lt_strlcat");
    }
  }
  {
#line 61
  length = strlen((char const   *)dst);
#line 67
  p = dst + length;
#line 67
  q = src;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if ((int const   )*q != 0) {
#line 67
      if (! (length < (size_t )(dstsize - 1U))) {
#line 67
        goto while_break;
      }
    } else {
#line 67
      goto while_break;
    }
#line 70
    *p = (char )*q;
#line 67
    length ++;
#line 67
    p ++;
#line 67
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  *(dst + length) = (char )'\000';
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    tmp = q;
#line 77
    q ++;
#line 77
    if (! *tmp) {
#line 77
      goto while_break___0;
    }
#line 78
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 80
  return (length);
}
}
#line 98 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c"
size_t lt_strlcpy(char *dst , char const   *src , size_t const   dstsize ) 
{ 
  size_t length ;
  char *p ;
  char const   *q ;
  char const   *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 101
  length = (size_t )0;
#line 105
  if (! ((unsigned long )dst != (unsigned long )((void *)0))) {
    {
#line 105
    __assert_fail("dst != ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  105U, "lt_strlcpy");
    }
  }
#line 106
  if (! ((unsigned long )src != (unsigned long )((char const   *)((void *)0)))) {
    {
#line 106
    __assert_fail("src != (const char *) ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  106U, "lt_strlcpy");
    }
  }
#line 107
  if (! (dstsize >= 1U)) {
    {
#line 107
    __assert_fail("dstsize >= 1", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  107U, "lt_strlcpy");
    }
  }
#line 112
  p = dst;
#line 112
  q = src;
#line 112
  length = (size_t )0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if ((int const   )*q != 0) {
#line 112
      if (! (length < (size_t )(dstsize - 1U))) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 115
    *p = (char )*q;
#line 112
    length ++;
#line 112
    p ++;
#line 112
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *(dst + length) = (char )'\000';
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    tmp = q;
#line 122
    q ++;
#line 122
    if (! *tmp) {
#line 122
      goto while_break___0;
    }
#line 123
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return (length);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 64 "libltdl/slist.h"
SList *lt__slist_concat(SList *head , SList *tail ) ;
#line 65
SList *lt__slist_cons(SList *item , SList *slist ) ;
#line 67
SList *lt__slist_delete(SList *head , void (*delete_fct)(void *item ) ) ;
#line 68
void *lt__slist_remove(SList **phead , SListCallback *find , void *matchdata ) ;
#line 70
SList *lt__slist_reverse(SList *slist ) ;
#line 71
SList *lt__slist_sort(SList *slist , SListCompare *compare , void *userdata ) ;
#line 74
SList *lt__slist_tail(SList *slist ) ;
#line 75
SList *lt__slist_nth(SList *slist , size_t n ) ;
#line 76
void *lt__slist_find(SList *slist , SListCallback *find , void *matchdata ) ;
#line 78
size_t lt__slist_length(SList *slist ) ;
#line 80
void *lt__slist_foreach(SList *slist , SListCallback *foreach , void *userdata ) ;
#line 83
SList *lt__slist_box(void const   *userdata ) ;
#line 84
void *lt__slist_unbox(SList *item ) ;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
static SList *slist_sort_merge(SList *left , SList *right , SListCompare *compare ,
                               void *userdata ) ;
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_delete(SList *head , void (*delete_fct)(void *item ) ) 
{ 
  SList *next ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 55
  if (! delete_fct) {
    {
#line 55
    __assert_fail("delete_fct", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  55U, "lt__slist_delete");
    }
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! head) {
#line 57
      goto while_break;
    }
    {
#line 59
    next = head->next;
#line 60
    (*delete_fct)((void *)head);
#line 61
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return ((SList *)0);
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_remove(SList **phead , SListCallback *find , void *matchdata ) 
{ 
  SList *stale ;
  void *result ;
  SList *head ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 79
  stale = (SList *)0;
#line 80
  result = (void *)0;
#line 82
  if (! find) {
    {
#line 82
    __assert_fail("find", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  82U, "lt__slist_remove");
    }
  }
#line 84
  if (! phead) {
#line 85
    return ((void *)0);
  } else
#line 84
  if (! *phead) {
#line 85
    return ((void *)0);
  }
  {
#line 88
  result = (*find)(*phead, matchdata);
  }
#line 89
  if (result) {
#line 91
    stale = *phead;
#line 92
    *phead = stale->next;
  } else {
#line 98
    head = *phead;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! head->next) {
#line 98
        goto while_break;
      }
      {
#line 100
      result = (*find)(head->next, matchdata);
      }
#line 101
      if (result) {
#line 103
        stale = head->next;
#line 104
        head->next = stale->next;
#line 105
        goto while_break;
      }
#line 98
      head = head->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 110
  return (result);
}
}
#line 116 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_find(SList *slist , SListCallback *find , void *matchdata ) 
{ 
  void *result ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 119
  result = (void *)0;
#line 121
  if (! find) {
    {
#line 121
    __assert_fail("find", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  121U, "lt__slist_find");
    }
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! slist) {
#line 123
      goto while_break;
    }
    {
#line 125
    result = (*find)(slist, matchdata);
    }
#line 126
    if (result) {
#line 127
      goto while_break;
    }
#line 123
    slist = slist->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (result);
}
}
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_concat(SList *head , SList *tail ) 
{ 
  SList *last ;

  {
#line 145
  if (! head) {
#line 147
    return (tail);
  }
#line 150
  last = head;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! last->next) {
#line 151
      goto while_break;
    }
#line 152
    last = last->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  last->next = tail;
#line 156
  return (head);
}
}
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_cons(SList *item , SList *slist ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 169
  if (! item) {
#line 171
    return (slist);
  }
#line 174
  if (! (! item->next)) {
    {
#line 174
    __assert_fail("!item->next", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  174U, "lt__slist_cons");
    }
  }
#line 176
  item->next = slist;
#line 177
  return (item);
}
}
#line 181 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_tail(SList *slist ) 
{ 
  struct slist *tmp ;

  {
#line 184
  if (slist) {
#line 184
    tmp = slist->next;
  } else {
#line 184
    tmp = (struct slist *)((void *)0);
  }
#line 184
  return (tmp);
}
}
#line 192 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_nth(SList *slist , size_t n ) 
{ 


  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (n > 1U) {
#line 195
      if (! slist) {
#line 195
        goto while_break;
      }
    } else {
#line 195
      goto while_break;
    }
#line 196
    slist = slist->next;
#line 195
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (slist);
}
}
#line 203 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
size_t lt__slist_length(SList *slist ) 
{ 
  size_t n ;

  {
#line 208
  n = (size_t )0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! slist) {
#line 208
      goto while_break;
    }
#line 209
    slist = slist->next;
#line 208
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (n);
}
}
#line 221 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_reverse(SList *slist ) 
{ 
  SList *result ;
  SList *next ;

  {
#line 224
  result = (SList *)0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! slist) {
#line 227
      goto while_break;
    }
#line 229
    next = slist->next;
#line 230
    slist->next = result;
#line 231
    result = slist;
#line 232
    slist = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (result);
}
}
#line 240 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_foreach(SList *slist , SListCallback *foreach , void *userdata ) 
{ 
  void *result ;
  SList *next ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 243
  result = (void *)0;
#line 245
  if (! foreach) {
    {
#line 245
    __assert_fail("foreach", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  245U, "lt__slist_foreach");
    }
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! slist) {
#line 247
      goto while_break;
    }
    {
#line 249
    next = slist->next;
#line 250
    result = (*foreach)(slist, userdata);
    }
#line 252
    if (result) {
#line 253
      goto while_break;
    }
#line 255
    slist = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return (result);
}
}
#line 271 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
static SList *slist_sort_merge(SList *left , SList *right , SListCompare *compare ,
                               void *userdata ) 
{ 
  SList merged ;
  SList *insert ;
  struct slist *tmp ;
  struct slist *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;

  {
#line 277
  insert = & merged;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (left) {
#line 279
      if (! right) {
#line 279
        goto while_break;
      }
    } else {
#line 279
      goto while_break;
    }
    {
#line 281
    tmp___1 = (*compare)((SList const   *)left, (SList const   *)right, userdata);
    }
#line 281
    if (tmp___1 <= 0) {
#line 283
      tmp = left;
#line 283
      insert->next = tmp;
#line 283
      insert = tmp;
#line 284
      left = left->next;
    } else {
#line 288
      tmp___0 = right;
#line 288
      insert->next = tmp___0;
#line 288
      insert = tmp___0;
#line 289
      right = right->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  if (left) {
#line 293
    insert->next = left;
  } else {
#line 293
    insert->next = right;
  }
#line 295
  return (merged.next);
}
}
#line 305 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_sort(SList *slist , SListCompare *compare , void *userdata ) 
{ 
  SList *left ;
  SList *right ;
  SList *tmp ;
  SList *tmp___0 ;
  SList *tmp___1 ;

  {
#line 310
  if (! slist) {
#line 311
    return (slist);
  }
#line 314
  left = slist;
#line 315
  right = slist->next;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (right) {
#line 319
      right = right->next;
#line 319
      if (! right) {
#line 319
        goto while_break;
      }
    } else {
#line 319
      goto while_break;
    }
#line 321
    if (! right) {
#line 322
      goto while_break;
    } else {
#line 321
      right = right->next;
#line 321
      if (! right) {
#line 322
        goto while_break;
      }
    }
#line 323
    slist = slist->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  right = slist->next;
#line 326
  slist->next = (struct slist *)0;
#line 329
  tmp = lt__slist_sort(right, compare, userdata);
#line 329
  tmp___0 = lt__slist_sort(left, compare, userdata);
#line 329
  tmp___1 = slist_sort_merge(tmp___0, tmp, compare, userdata);
  }
#line 329
  return (tmp___1);
}
}
#line 346 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_box(void const   *userdata ) 
{ 
  SList *item ;
  void *tmp ;

  {
  {
#line 349
  tmp = malloc((size_t )sizeof(*item));
#line 349
  item = (SList *)tmp;
  }
#line 351
  if (item) {
#line 353
    item->next = (struct slist *)0;
#line 354
    item->userdata = userdata;
  }
#line 357
  return (item);
}
}
#line 361 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_unbox(SList *item ) 
{ 
  void *userdata ;

  {
#line 364
  userdata = (void *)0;
#line 366
  if (item) {
    {
#line 370
    userdata = (void *)item->userdata;
#line 371
    free((void *)item);
    }
  }
#line 374
  return (userdata);
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "libltdl/lt__alloc.h"
void *lt__zalloc(size_t n ) ;
#line 76 "./ltdl.h"
lt_dlhandle lt_dlopen(char const   *filename___0 ) ;
#line 98
int lt_dlpreload(lt_dlsymlist const   *preloaded ) ;
#line 99
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) ;
#line 100
int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) ;
#line 142 "libltdl/lt__private.h"
char const   *lt__error_string(int errorcode ) ;
#line 144
char const   *lt__set_last_error(char const   *errormsg ) ;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
lt_dlvtable const   *preopen_LTX_get_vtable(lt_user_data loader_data ) ;
#line 48
static int vl_init(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 49
static int vl_exit(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 50
static lt_module vm_open(lt_user_data loader_data  __attribute__((__unused__)) , char const   *filename___0 ,
                         lt_dladvise advise  __attribute__((__unused__)) ) ;
#line 52
static int vm_close(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module  __attribute__((__unused__)) ) ;
#line 53
static void *vm_sym(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                    char const   *name ) ;
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static lt_dlvtable *vtable  =    (lt_dlvtable *)0;
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
lt_dlvtable const   *preopen_LTX_get_vtable(lt_user_data loader_data ) 
{ 
  void *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 64
  if (! vtable) {
    {
#line 66
    tmp = lt__zalloc((size_t )sizeof(*vtable));
#line 66
    vtable = (lt_dlvtable *)tmp;
    }
  }
#line 69
  if (vtable) {
#line 69
    if (! vtable->name) {
#line 71
      vtable->name = "lt_preopen";
#line 72
      vtable->sym_prefix = (char const   *)0;
#line 73
      vtable->module_open = & vm_open;
#line 74
      vtable->module_close = & vm_close;
#line 75
      vtable->find_sym = & vm_sym;
#line 76
      vtable->dlloader_init = & vl_init;
#line 77
      vtable->dlloader_exit = & vl_exit;
#line 78
      vtable->dlloader_data = loader_data;
#line 79
      vtable->priority = (lt_dlloader_priority )0;
    }
  }
#line 82
  if (vtable) {
#line 82
    if ((unsigned long )vtable->dlloader_data != (unsigned long )loader_data) {
      {
#line 84
      tmp___0 = lt__error_string(3);
#line 84
      lt__set_last_error(tmp___0);
      }
#line 85
      return ((lt_dlvtable *)0);
    }
  }
#line 88
  return (vtable);
}
}
#line 104
static int add_symlist(lt_dlsymlist const   *symlist ) ;
#line 105
static int free_symlists(void) ;
#line 108 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static symlist_chain *preloaded_symlists  =    (symlist_chain *)0;
#line 111 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static lt_dlsymlist const   *default_preloaded_symbols  =    (lt_dlsymlist const   *)0;
#line 115 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int vl_init(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 
  int errors ;

  {
#line 118
  errors = 0;
#line 120
  preloaded_symlists = (symlist_chain *)0;
#line 121
  if (default_preloaded_symbols) {
    {
#line 123
    errors = lt_dlpreload(default_preloaded_symbols);
    }
  }
#line 126
  return (errors);
}
}
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int vl_exit(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 135
  vtable = (lt_dlvtable *)((void *)0);
#line 136
  free_symlists();
  }
#line 137
  return (0);
}
}
#line 144 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static lt_module vm_open(lt_user_data loader_data  __attribute__((__unused__)) , char const   *filename___0 ,
                         lt_dladvise advise  __attribute__((__unused__)) ) 
{ 
  symlist_chain *lists ;
  lt_module module ;
  char const   *tmp ;
  lt_dlsymlist const   *symbol ;
  lt_dlsymlist const   *next_symbol ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp11 ;

  {
#line 149
  module = (lt_module )0;
#line 151
  if (! preloaded_symlists) {
    {
#line 153
    tmp = lt__error_string(7);
#line 153
    lt__set_last_error(tmp);
    }
#line 154
    goto done;
  }
#line 161
  if (! filename___0) {
#line 163
    filename___0 = "@PROGRAM@";
  }
#line 166
  lists = preloaded_symlists;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! lists) {
#line 166
      goto while_break;
    }
#line 169
    symbol = lists->symlist;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! symbol->name) {
#line 169
        goto while_break___0;
      }
#line 171
      if (! symbol->address) {
        {
#line 171
        tmp___0 = strcmp((char const   *)symbol->name, filename___0);
        }
#line 171
        if (! tmp___0) {
#line 178
          next_symbol = symbol + 1;
#line 179
          if (next_symbol->address) {
#line 179
            if (next_symbol->name) {
#line 181
              module = (lt_module )lists->symlist;
#line 182
              goto done;
            }
          }
        }
      }
#line 169
      symbol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp___1 = lt__error_string(5);
#line 188
  lt__set_last_error(tmp___1);
  }
  done: 
#line 191
  return (module);
}
}
#line 197 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int vm_close(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module  __attribute__((__unused__)) ) 
{ 


  {
#line 201
  module = (lt_module )0;
#line 202
  return (0);
}
}
#line 208 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static void *vm_sym(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                    char const   *name ) 
{ 
  lt_dlsymlist *symbol ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 211
  symbol = (lt_dlsymlist *)module;
#line 213
  symbol += 2;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! symbol->name) {
#line 215
      goto while_break;
    }
    {
#line 217
    tmp = strcmp(symbol->name, name);
    }
#line 217
    if (! tmp) {
#line 219
      return (symbol->address);
    }
#line 222
    symbol ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  tmp___0 = lt__error_string(10);
#line 225
  lt__set_last_error(tmp___0);
  }
#line 227
  return ((void *)0);
}
}
#line 237 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int free_symlists(void) 
{ 
  symlist_chain *lists ;
  symlist_chain *next ;

  {
#line 242
  lists = preloaded_symlists;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! lists) {
#line 243
      goto while_break;
    }
#line 245
    next = lists->next;
#line 246
    if (lists) {
      {
#line 246
      free((void *)lists);
#line 246
      lists = (symlist_chain *)((void *)0);
      }
    }
#line 247
    lists = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  preloaded_symlists = (symlist_chain *)0;
#line 251
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int add_symlist(lt_dlsymlist const   *symlist ) 
{ 
  symlist_chain *lists ;
  int errors ;
  symlist_chain *tmp ;
  void *tmp___0 ;

  {
#line 259
  errors = 0;
#line 262
  lists = preloaded_symlists;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (lists) {
#line 262
      if (! ((unsigned long )lists->symlist != (unsigned long )symlist)) {
#line 262
        goto while_break;
      }
    } else {
#line 262
      goto while_break;
    }
#line 262
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (! lists) {
    {
#line 269
    tmp___0 = lt__zalloc((size_t )sizeof(*tmp));
#line 269
    tmp = (symlist_chain *)tmp___0;
    }
#line 271
    if (tmp) {
#line 273
      tmp->symlist = symlist;
#line 274
      tmp->next = preloaded_symlists;
#line 275
      preloaded_symlists = tmp;
    } else {
#line 279
      errors ++;
    }
  }
#line 283
  return (errors);
}
}
#line 292 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) 
{ 


  {
#line 295
  default_preloaded_symbols = preloaded;
#line 296
  return (0);
}
}
#line 302 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
int lt_dlpreload(lt_dlsymlist const   *preloaded ) 
{ 
  int errors ;

  {
#line 305
  errors = 0;
#line 307
  if (preloaded) {
    {
#line 309
    errors = add_symlist(preloaded);
    }
  } else {
    {
#line 313
    free_symlists();
    }
#line 315
    if (default_preloaded_symbols) {
      {
#line 317
      errors = lt_dlpreload(default_preloaded_symbols);
      }
    }
  }
#line 321
  return (errors);
}
}
#line 328 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) 
{ 
  symlist_chain *list ;
  int errors ;
  int found ;
  lt_dlsymlist const   *symbol ;
  unsigned int idx ;
  lt_dlhandle handle ;
  lt_dlhandle tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 332
  errors = 0;
#line 333
  found = 0;
#line 336
  list = preloaded_symlists;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! list) {
#line 336
      goto while_break;
    }
#line 339
    if (originator) {
      {
#line 339
      tmp___2 = strcmp((char const   *)(list->symlist)->name, originator);
      }
#line 339
      if (tmp___2) {
#line 339
        goto _L___0;
      } else {
#line 339
        goto _L;
      }
    } else
    _L___0: /* CIL Label */ 
#line 339
    if (! originator) {
      {
#line 339
      tmp___3 = strcmp((char const   *)(list->symlist)->name, "@PROGRAM@");
      }
#line 339
      if (! tmp___3) {
        _L: /* CIL Label */ 
#line 343
        idx = 0U;
#line 345
        found ++;
        {
#line 349
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 349
          idx ++;
#line 349
          symbol = list->symlist + idx;
#line 349
          if (! ((unsigned long )symbol->name != (unsigned long )((char const   */* const  */)0))) {
#line 349
            goto while_break___0;
          }
#line 351
          if ((unsigned long )symbol->address == (unsigned long )((void */* const  */)0)) {
            {
#line 351
            tmp___1 = strcmp((char const   *)symbol->name, "@PROGRAM@");
            }
#line 351
            if (tmp___1 != 0) {
              {
#line 354
              tmp = lt_dlopen((char const   *)symbol->name);
#line 354
              handle = tmp;
              }
#line 355
              if ((unsigned long )handle == (unsigned long )((lt_dlhandle )0)) {
#line 357
                errors ++;
              } else {
                {
#line 361
                tmp___0 = (*func)(handle);
#line 361
                errors += tmp___0;
                }
              }
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 336
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (! found) {
    {
#line 370
    tmp___4 = lt__error_string(8);
#line 370
    lt__set_last_error(tmp___4);
#line 371
    errors ++;
    }
  }
#line 374
  return (errors);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 47 "libltdl/lt__alloc.h"
void (*lt__alloc_die)(void) ;
#line 49
void *lt__malloc(size_t n ) ;
#line 51
void *lt__realloc(void *mem , size_t n ) ;
#line 54
char *lt__strdup(char const   *string ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 55 "/usr/include/argz.h"
extern  __attribute__((__nothrow__)) error_t argz_create_sep(char const   * __restrict  __string ,
                                                             int __sep , char ** __restrict  __argz ,
                                                             size_t * __restrict  __len ) ;
#line 75
extern  __attribute__((__nothrow__)) void argz_stringify(char *__argz , size_t __len ,
                                                         int __sep ) ;
#line 82
extern  __attribute__((__nothrow__)) error_t argz_append(char ** __restrict  __argz ,
                                                         size_t * __restrict  __argz_len ,
                                                         char const   * __restrict  __buf ,
                                                         size_t __buf_len ) ;
#line 124
extern  __attribute__((__nothrow__)) error_t argz_insert(char ** __restrict  __argz ,
                                                         size_t * __restrict  __argz_len ,
                                                         char * __restrict  __before ,
                                                         char const   * __restrict  __entry ) ;
#line 159
extern  __attribute__((__nothrow__)) char *argz_next(char const   * __restrict  __argz ,
                                                     size_t __argz_len , char const   * __restrict  __entry ) ;
#line 73 "./libltdl/lt_dlloader.h"
int lt_dlloader_add(lt_dlvtable const   *vtable___1 ) ;
#line 74
lt_dlloader lt_dlloader_next(lt_dlloader const   loader ) ;
#line 76
lt_dlvtable *lt_dlloader_remove(char *name ) ;
#line 77
lt_dlvtable const   *lt_dlloader_find(char *name ) ;
#line 78
lt_dlvtable const   *lt_dlloader_get(lt_dlloader loader ) ;
#line 53 "./ltdl.h"
int lt_dlinit(void) ;
#line 54
int lt_dlexit(void) ;
#line 57
int lt_dladdsearchdir(char const   *search_dir ) ;
#line 58
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) ;
#line 60
int lt_dlsetsearchpath(char const   *search_path ) ;
#line 61
char const   *lt_dlgetsearchpath(void) ;
#line 62
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) ;
#line 68
int lt_dladvise_init(lt_dladvise *padvise ) ;
#line 69
int lt_dladvise_destroy(lt_dladvise *padvise ) ;
#line 70
int lt_dladvise_ext(lt_dladvise *padvise ) ;
#line 71
int lt_dladvise_resident(lt_dladvise *padvise ) ;
#line 72
int lt_dladvise_local(lt_dladvise *padvise ) ;
#line 73
int lt_dladvise_global(lt_dladvise *padvise ) ;
#line 77
lt_dlhandle lt_dlopenext(char const   *filename___0 ) ;
#line 78
lt_dlhandle lt_dlopenadvise(char const   *filename___0 , lt_dladvise advise ) ;
#line 80
void *lt_dlsym(lt_dlhandle place , char const   *symbol ) ;
#line 81
char const   *lt_dlerror(void) ;
#line 82
int lt_dlclose(lt_dlhandle handle ) ;
#line 119
lt_dlinterface_id lt_dlinterface_register(char const   *id_string___0 , lt_dlhandle_interface *iface ) ;
#line 121
void lt_dlinterface_free(lt_dlinterface_id key ) ;
#line 122
void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) ;
#line 124
void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) ;
#line 141
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) ;
#line 143
lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) ;
#line 145
lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) ;
#line 147
int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle handle , void *data ) ,
                    void *data ) ;
#line 154
int lt_dlmakeresident(lt_dlhandle handle ) ;
#line 155
int lt_dlisresident(lt_dlhandle handle ) ;
#line 93 "libltdl/lt__private.h"
void lt__alloc_die_callback(void) ;
#line 143
char const   *lt__get_last_error(void) ;
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   objdir[7]  = {      (char const   )'.',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'s',      (char const   )'/',      (char const   )'\000'};
#line 69 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   archive_ext[4]  = {      (char const   )'.',      (char const   )'l',      (char const   )'a',      (char const   )'\000'};
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   shlib_ext[4]  = {      (char const   )'.',      (char const   )'s',      (char const   )'o',      (char const   )'\000'};
#line 74 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   sys_dlsearch_path[105]  = 
#line 74
  {      (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )':',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'/',      (char const   )'m', 
        (char const   )'e',      (char const   )'s',      (char const   )'a',      (char const   )':', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'i',      (char const   )'4',      (char const   )'8', 
        (char const   )'6',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'i',      (char const   )'4',      (char const   )'8', 
        (char const   )'6',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'a',      (char const   )'l',      (char const   )'s', 
        (char const   )'a',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'\000'};
#line 90
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) ;
#line 94
static int find_file_callback(char *filename___0 , void *data1 , void *data2 ) ;
#line 96
static int find_handle_callback(char *filename___0 , void *data , void *data2 ) ;
#line 98
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) ;
#line 102
static int canonicalize_path(char const   *path , char **pcanonical ) ;
#line 103
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) ;
#line 105
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) ;
#line 107
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *phandle , lt_dladvise advise ) ;
#line 111
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ,
                       lt_dladvise advise ) ;
#line 115
static int has_library_ext(char const   *filename___0 ) ;
#line 116
static int load_deplibs(lt_dlhandle handle , char *deplibs  __attribute__((__unused__)) ) ;
#line 117
static int trim(char **dest , char const   *str ) ;
#line 118
static int try_dlopen(lt_dlhandle *phandle , char const   *filename___0 , char const   *ext ,
                      lt_dladvise advise ) ;
#line 121
static int tryall_dlopen(lt_dlhandle *phandle , char const   *filename___0 , lt_dladvise advise ,
                         lt_dlvtable const   *vtable___1 ) ;
#line 125
static int unload_deplibs(lt_dlhandle handle ) ;
#line 126
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) ;
#line 128
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) ;
#line 130
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) ;
#line 132
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) ;
#line 134
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) ;
#line 136
static int file_not_found(void) ;
#line 139
static int loader_init_callback(lt_dlhandle handle ) ;
#line 142
static int loader_init(lt_get_vtable *vtable_func , lt_user_data data ) ;
#line 145 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char *user_search_path  =    (char *)0;
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static lt_dlhandle handles  =    (lt_dlhandle )0;
#line 147 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int initialized  =    0;
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void lt__alloc_die_callback(void) 
{ 
  char const   *tmp ;

  {
  {
#line 155
  tmp = lt__error_string(11);
#line 155
  lt__set_last_error(tmp);
  }
#line 156
  return;
}
}
#line 162 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int loader_init_callback(lt_dlhandle handle ) 
{ 
  lt_get_vtable *vtable_func ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 165
  tmp = lt_dlsym(handle, "get_vtable");
#line 165
  vtable_func = (lt_get_vtable *)tmp;
#line 166
  tmp___0 = loader_init(vtable_func, (lt_user_data )0);
  }
#line 166
  return (tmp___0);
}
}
#line 170 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int loader_init(lt_get_vtable *vtable_func , lt_user_data data ) 
{ 
  lt_dlvtable const   *vtable___1 ;
  int errors ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 173
  vtable___1 = (lt_dlvtable const   *)0;
#line 174
  errors = 0;
#line 176
  if (vtable_func) {
    {
#line 178
    vtable___1 = (*vtable_func)(data);
    }
  }
  {
#line 182
  tmp = lt_dlloader_add(vtable___1);
#line 182
  errors += tmp;
  }
#line 184
  if (! errors) {
#line 184
    if (! vtable___1) {
      {
#line 184
      __assert_fail("errors || vtable", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    184U, "loader_init");
      }
    }
  }
#line 186
  if (! errors) {
#line 186
    if (vtable___1->dlloader_init) {
      {
#line 188
      tmp___1 = (*(vtable___1->dlloader_init))((lt_user_data )vtable___1->dlloader_data);
      }
#line 188
      if (tmp___1) {
        {
#line 190
        tmp___0 = lt__error_string(3);
#line 190
        lt__set_last_error(tmp___0);
#line 191
        errors ++;
        }
      }
    }
  }
#line 195
  return (errors);
}
}
#line 206
extern lt_dlsymlist lt_libltdlc_LTX_preloaded_symbols ;
#line 210 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlinit(void) 
{ 
  int errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
#line 213
  errors = 0;
#line 216
  initialized ++;
#line 216
  if (initialized == 1) {
    {
#line 218
    lt__alloc_die = & lt__alloc_die_callback;
#line 219
    handles = (lt_dlhandle )0;
#line 220
    user_search_path = (char *)0;
#line 225
    tmp = loader_init(& preopen_LTX_get_vtable, (lt_user_data )0);
#line 225
    errors += tmp;
    }
#line 230
    if (! errors) {
      {
#line 232
      tmp___0 = lt_dlpreload((lt_dlsymlist const   *)(& lt_libltdlc_LTX_preloaded_symbols));
#line 232
      errors += tmp___0;
      }
    }
#line 235
    if (! errors) {
      {
#line 237
      tmp___1 = lt_dlpreload_open("libltdlc", & loader_init_callback);
#line 237
      errors += tmp___1;
      }
    }
  }
#line 246
  return (errors);
}
}
#line 249 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlexit(void) 
{ 
  lt_dlloader *loader ;
  lt_dlhandle handle ;
  int errors ;
  char const   *tmp ;
  int level ;
  lt_dlhandle cur ;
  int saw_nonresident ;
  lt_dlhandle tmp___0 ;
  int tmp___1 ;
  lt_dlloader tmp___2 ;
  lt_dlloader *next ;
  lt_dlloader tmp___3 ;
  lt_dlvtable *vtable___1 ;
  lt_dlvtable const   *tmp___4 ;
  char const   *err ;

  {
#line 253
  loader = (lt_dlloader *)0;
#line 254
  handle = handles;
#line 255
  errors = 0;
#line 257
  if (! initialized) {
    {
#line 259
    tmp = lt__error_string(15);
#line 259
    lt__set_last_error(tmp);
#line 260
    errors ++;
    }
#line 261
    goto done;
  }
#line 265
  initialized --;
#line 265
  if (initialized == 0) {
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (handles) {
#line 269
        if (! handles->info.is_resident) {
#line 269
          goto while_break;
        }
      } else {
#line 269
        goto while_break;
      }
#line 271
      handles = handles->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 275
    level = 1;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! handle) {
#line 275
        goto while_break___0;
      }
#line 277
      cur = handles;
#line 278
      saw_nonresident = 0;
      {
#line 280
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 280
        if (! cur) {
#line 280
          goto while_break___1;
        }
#line 282
        tmp___0 = cur;
#line 283
        cur = cur->next;
#line 284
        if (! tmp___0->info.is_resident) {
#line 286
          saw_nonresident = 1;
#line 287
          if (tmp___0->info.ref_count <= level) {
            {
#line 289
            tmp___1 = lt_dlclose(tmp___0);
            }
#line 289
            if (tmp___1) {
#line 291
              errors ++;
            }
#line 297
            if (cur) {
#line 299
              tmp___0 = handles;
              {
#line 299
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 299
                if (! tmp___0) {
#line 299
                  goto while_break___2;
                }
#line 300
                if ((unsigned long )tmp___0 == (unsigned long )cur) {
#line 301
                  goto while_break___2;
                }
#line 299
                tmp___0 = tmp___0->next;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 302
              if (! tmp___0) {
#line 303
                cur = handles;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 309
      if (! saw_nonresident) {
#line 310
        goto while_break___0;
      }
#line 275
      level ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    if (! errors) {
      {
#line 317
      lt__set_last_error((char const   *)0);
      }
    }
    {
#line 320
    tmp___2 = lt_dlloader_next((lt_dlloader const   )((void *)0));
#line 320
    loader = (lt_dlloader *)tmp___2;
    }
    {
#line 320
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 320
      if (! loader) {
#line 320
        goto while_break___3;
      }
      {
#line 322
      tmp___3 = lt_dlloader_next((lt_dlloader const   )loader);
#line 322
      next = (lt_dlloader *)tmp___3;
#line 323
      tmp___4 = lt_dlloader_get((lt_dlloader )loader);
#line 323
      vtable___1 = (lt_dlvtable *)tmp___4;
#line 325
      vtable___1 = lt_dlloader_remove((char *)vtable___1->name);
      }
#line 325
      if (vtable___1) {
#line 327
        if (vtable___1) {
          {
#line 327
          free((void *)vtable___1);
#line 327
          vtable___1 = (lt_dlvtable *)((void *)0);
          }
        }
      } else {
        {
#line 333
        err = lt__get_last_error();
        }
#line 334
        if (err) {
#line 335
          errors ++;
        }
      }
#line 338
      loader = next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 341
    if (user_search_path) {
      {
#line 341
      free((void *)user_search_path);
#line 341
      user_search_path = (char *)((void *)0);
      }
    }
  }
  done: 
#line 345
  return (errors);
}
}
#line 352 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int tryall_dlopen(lt_dlhandle *phandle , char const   *filename___0 , lt_dladvise advise ,
                         lt_dlvtable const   *vtable___1 ) 
{ 
  lt_dlhandle handle ;
  char const   *saved_error ;
  int errors ;
  int tmp ;
  lt_dlloader loader ;
  lt_dlloader tmp___0 ;
  lt_dlvtable const   *loader_vtable ;

  {
  {
#line 356
  handle = handles;
#line 357
  saved_error = (char const   *)0;
#line 358
  errors = 0;
#line 366
  saved_error = lt__get_last_error();
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! handle) {
#line 369
      goto while_break;
    }
#line 371
    if ((unsigned long )handle->info.filename == (unsigned long )filename___0) {
#line 375
      goto while_break;
    } else
#line 371
    if (handle->info.filename) {
#line 371
      if (filename___0) {
        {
#line 371
        tmp = strcmp((char const   *)handle->info.filename, filename___0);
        }
#line 371
        if (! tmp) {
#line 375
          goto while_break;
        }
      }
    }
#line 369
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  if (handle) {
#line 381
    (handle->info.ref_count) ++;
#line 382
    *phandle = handle;
#line 383
    goto done;
  }
#line 386
  handle = *phandle;
#line 387
  if (filename___0) {
    {
#line 401
    handle->info.filename = lt__strdup(filename___0);
    }
#line 402
    if (! handle->info.filename) {
#line 404
      errors ++;
#line 405
      goto done;
    }
  } else {
#line 410
    handle->info.filename = (char *)0;
  }
  {
#line 414
  tmp___0 = lt_dlloader_next((lt_dlloader const   )0);
#line 414
  loader = tmp___0;
  }
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (vtable___1) {
#line 420
      loader_vtable = vtable___1;
    } else {
      {
#line 422
      loader_vtable = lt_dlloader_get(loader);
      }
    }
    {
#line 429
    handle->module = (*(loader_vtable->module_open))((lt_user_data )loader_vtable->dlloader_data,
                                                     filename___0, advise);
    }
#line 436
    if ((unsigned long )handle->module != (unsigned long )((lt_module )0)) {
#line 438
      if (advise) {
#line 440
        handle->info.is_resident = advise->is_resident;
#line 441
        handle->info.is_symglobal = advise->is_symglobal;
#line 442
        handle->info.is_symlocal = advise->is_symlocal;
      }
#line 444
      goto while_break___0;
    }
#line 417
    if (! vtable___1) {
      {
#line 417
      loader = lt_dlloader_next((lt_dlloader const   )loader);
      }
#line 417
      if (! loader) {
#line 417
        goto while_break___0;
      }
    } else {
#line 417
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 452
  if (vtable___1) {
#line 452
    if (! handle->module) {
#line 452
      goto _L;
    } else {
#line 452
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 452
  if (! vtable___1) {
#line 452
    if (! loader) {
      _L: /* CIL Label */ 
#line 455
      if (handle->info.filename) {
        {
#line 455
        free((void *)handle->info.filename);
#line 455
        handle->info.filename = (char *)((void *)0);
        }
      }
#line 456
      errors ++;
#line 457
      goto done;
    }
  }
  {
#line 460
  handle->vtable = loader_vtable;
#line 463
  lt__set_last_error(saved_error);
  }
  done: 
#line 466
  return (errors);
}
}
#line 470 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int tryall_dlopen_module(lt_dlhandle *handle , char const   *prefix___0 , char const   *dirname ,
                                char const   *dlname , lt_dladvise advise ) 
{ 
  int error ;
  char *filename___0 ;
  size_t filename_len ;
  size_t dirname_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 475
  error = 0;
#line 476
  filename___0 = (char *)0;
#line 477
  filename_len = (size_t )0;
#line 478
  if (dirname) {
#line 478
    if (*(dirname + 0)) {
      {
#line 478
      tmp = strlen(dirname);
#line 478
      tmp___0 = tmp;
      }
    } else {
#line 478
      tmp___0 = (size_t )0;
    }
  } else {
#line 478
    tmp___0 = (size_t )0;
  }
#line 478
  dirname_len = tmp___0;
#line 480
  if (! handle) {
    {
#line 480
    __assert_fail("handle", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  480U, "tryall_dlopen_module");
    }
  }
#line 481
  if (! dirname) {
    {
#line 481
    __assert_fail("dirname", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  481U, "tryall_dlopen_module");
    }
  }
#line 482
  if (! dlname) {
    {
#line 482
    __assert_fail("dlname", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  482U, "tryall_dlopen_module");
    }
  }
#line 489
  if (dirname_len > 0U) {
#line 490
    if ((int const   )*(dirname + (dirname_len - 1U)) == 47) {
#line 491
      dirname_len --;
    }
  }
#line 492
  if (dlname) {
#line 492
    if (*(dlname + 0)) {
      {
#line 492
      tmp___1 = strlen(dlname);
#line 492
      tmp___2 = tmp___1;
      }
    } else {
#line 492
      tmp___2 = (size_t )0;
    }
  } else {
#line 492
    tmp___2 = (size_t )0;
  }
  {
#line 492
  filename_len = (dirname_len + 1U) + tmp___2;
#line 496
  tmp___3 = lt__malloc((size_t )((unsigned long )(filename_len + 1U) * sizeof(char )));
#line 496
  filename___0 = (char *)tmp___3;
  }
#line 497
  if (! filename___0) {
#line 498
    return (1);
  }
  {
#line 500
  sprintf((char */* __restrict  */)filename___0, (char const   */* __restrict  */)"%.*s/%s",
          (int )dirname_len, dirname, dlname);
  }
#line 505
  if (prefix___0) {
    {
#line 507
    tmp___4 = tryall_dlopen_module(handle, (char const   *)0, prefix___0, (char const   *)filename___0,
                                   advise);
#line 507
    error += tmp___4;
    }
  } else {
    {
#line 510
    tmp___5 = tryall_dlopen(handle, (char const   *)filename___0, advise, (lt_dlvtable const   *)0);
    }
#line 510
    if (tmp___5 != 0) {
#line 512
      error ++;
    }
  }
#line 515
  if (filename___0) {
    {
#line 515
    free((void *)filename___0);
#line 515
    filename___0 = (char *)((void *)0);
    }
  }
#line 516
  return (error);
}
}
#line 519 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ,
                       lt_dladvise advise ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 527
  if (old_name) {
    {
#line 527
    tmp = tryall_dlopen(handle, old_name, advise, (lt_dlvtable const   *)0);
    }
#line 527
    if (tmp == 0) {
#line 529
      return (0);
    }
  }
#line 533
  if (dlname) {
#line 536
    if (installed) {
#line 536
      if (libdir) {
        {
#line 538
        tmp___0 = tryall_dlopen_module(handle, (char const   *)0, libdir, dlname,
                                       advise);
        }
#line 538
        if (tmp___0 == 0) {
#line 540
          return (0);
        }
      }
    }
#line 544
    if (! installed) {
      {
#line 546
      tmp___1 = tryall_dlopen_module(handle, dir, objdir, dlname, advise);
      }
#line 546
      if (tmp___1 == 0) {
#line 548
        return (0);
      }
    }
#line 553
    if (dir) {
      {
#line 553
      tmp___2 = tryall_dlopen_module(handle, (char const   *)0, dir, dlname, advise);
      }
#line 553
      if (tmp___2 == 0) {
#line 555
        return (0);
      }
    }
  }
#line 559
  return (1);
}
}
#line 563 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int canonicalize_path(char const   *path , char **pcanonical ) 
{ 
  char *canonical ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t dest ;
  size_t src ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 566
  canonical = (char *)0;
#line 568
  if (path) {
#line 568
    if (! *path) {
      {
#line 568
      __assert_fail("path && *path", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    568U, "canonicalize_path");
      }
    }
  } else {
    {
#line 568
    __assert_fail("path && *path", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  568U, "canonicalize_path");
    }
  }
#line 569
  if (! pcanonical) {
    {
#line 569
    __assert_fail("pcanonical", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  569U, "canonicalize_path");
    }
  }
#line 571
  if (path) {
#line 571
    if (*(path + 0)) {
      {
#line 571
      tmp = strlen(path);
#line 571
      tmp___0 = tmp;
      }
    } else {
#line 571
      tmp___0 = (size_t )0;
    }
  } else {
#line 571
    tmp___0 = (size_t )0;
  }
  {
#line 571
  tmp___1 = lt__malloc((size_t )((unsigned long )(1U + tmp___0) * sizeof(char )));
#line 571
  canonical = (char *)tmp___1;
  }
#line 572
  if (! canonical) {
#line 573
    return (1);
  }
#line 576
  dest = (size_t )0;
#line 578
  src = (size_t )0;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! ((int const   )*(path + src) != 0)) {
#line 578
      goto while_break;
    }
#line 583
    if ((int const   )*(path + src) == 58) {
#line 585
      if (dest == 0U) {
#line 588
        goto __Cont;
      } else
#line 585
      if ((int const   )*(path + (1U + src)) == 58) {
#line 588
        goto __Cont;
      } else
#line 585
      if ((int const   )*(path + (1U + src)) == 0) {
#line 588
        goto __Cont;
      }
    }
#line 592
    if ((int const   )*(path + src) != 47) {
#line 598
      tmp___2 = dest;
#line 598
      dest ++;
#line 598
      *(canonical + tmp___2) = (char )*(path + src);
    } else
#line 603
    if ((int const   )*(path + (1U + src)) != 58) {
#line 603
      if ((int const   )*(path + (1U + src)) != 0) {
#line 603
        if ((int const   )*(path + (1U + src)) != 47) {
#line 610
          tmp___3 = dest;
#line 610
          dest ++;
#line 610
          *(canonical + tmp___3) = (char )'/';
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 578
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  *(canonical + dest) = (char )'\000';
#line 619
  *pcanonical = canonical;
#line 621
  return (0);
}
}
#line 624 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) 
{ 
  error_t error ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 629
  if (! path) {
    {
#line 629
    __assert_fail("path", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  629U, "argzize_path");
    }
  }
#line 630
  if (! pargz) {
    {
#line 630
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  630U, "argzize_path");
    }
  }
#line 631
  if (! pargz_len) {
    {
#line 631
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  631U, "argzize_path");
    }
  }
  {
#line 633
  error = argz_create_sep((char const   */* __restrict  */)path, ':', (char **/* __restrict  */)pargz,
                          (size_t */* __restrict  */)pargz_len);
  }
#line 633
  if (error) {
    {
#line 637
    if (error == 12) {
#line 637
      goto case_12;
    }
#line 640
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 638
    tmp = lt__error_string(11);
#line 638
    lt__set_last_error(tmp);
    }
#line 639
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 641
    tmp___0 = lt__error_string(0);
#line 641
    lt__set_last_error(tmp___0);
    }
#line 642
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 645
    return (1);
  }
#line 648
  return (0);
}
}
#line 655 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) 
{ 
  int result ;
  size_t filenamesize ;
  size_t lenbase ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t argz_len ;
  char *argz ;
  char *filename___0 ;
  char *canonical ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *dir_name ;
  size_t lendir ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 659
  result = 0;
#line 660
  filenamesize = (size_t )0;
#line 661
  if (base_name) {
#line 661
    if (*(base_name + 0)) {
      {
#line 661
      tmp = strlen(base_name);
#line 661
      tmp___0 = tmp;
      }
    } else {
#line 661
      tmp___0 = (size_t )0;
    }
  } else {
#line 661
    tmp___0 = (size_t )0;
  }
#line 661
  lenbase = tmp___0;
#line 662
  argz_len = (size_t )0;
#line 663
  argz = (char *)0;
#line 664
  filename___0 = (char *)0;
#line 665
  canonical = (char *)0;
#line 667
  if (! search_path) {
    {
#line 669
    tmp___1 = lt__error_string(5);
#line 669
    lt__set_last_error(tmp___1);
    }
#line 670
    goto cleanup;
  } else
#line 667
  if (! *search_path) {
    {
#line 669
    tmp___1 = lt__error_string(5);
#line 669
    lt__set_last_error(tmp___1);
    }
#line 670
    goto cleanup;
  }
  {
#line 673
  tmp___2 = canonicalize_path(search_path, & canonical);
  }
#line 673
  if (tmp___2 != 0) {
#line 674
    goto cleanup;
  }
  {
#line 676
  tmp___3 = argzize_path((char const   *)canonical, & argz, & argz_len);
  }
#line 676
  if (tmp___3 != 0) {
#line 677
    goto cleanup;
  }
#line 680
  dir_name = (char *)0;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 681
    dir_name = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)dir_name);
    }
#line 681
    if (! dir_name) {
#line 681
      goto while_break;
    }
#line 683
    if (dir_name) {
#line 683
      if (*(dir_name + 0)) {
        {
#line 683
        tmp___4 = strlen((char const   *)dir_name);
#line 683
        tmp___5 = tmp___4;
        }
      } else {
#line 683
        tmp___5 = (size_t )0;
      }
    } else {
#line 683
      tmp___5 = (size_t )0;
    }
#line 683
    lendir = tmp___5;
#line 685
    if ((1U + lendir) + lenbase >= filenamesize) {
#line 687
      if (filename___0) {
        {
#line 687
        free((void *)filename___0);
#line 687
        filename___0 = (char *)((void *)0);
        }
      }
      {
#line 688
      filenamesize = ((1U + lendir) + 1U) + lenbase;
#line 689
      tmp___6 = lt__malloc((size_t )((unsigned long )filenamesize * sizeof(char )));
#line 689
      filename___0 = (char *)tmp___6;
      }
#line 690
      if (! filename___0) {
#line 691
        goto cleanup;
      }
    }
#line 694
    if (! (filenamesize > lendir)) {
      {
#line 694
      __assert_fail("filenamesize > lendir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    694U, "foreach_dirinpath");
      }
    }
    {
#line 695
    strcpy((char */* __restrict  */)filename___0, (char const   */* __restrict  */)dir_name);
    }
#line 697
    if (base_name) {
#line 697
      if (*base_name) {
#line 699
        if ((int )*(filename___0 + (lendir - 1U)) != 47) {
#line 700
          tmp___7 = lendir;
#line 700
          lendir ++;
#line 700
          *(filename___0 + tmp___7) = (char )'/';
        }
        {
#line 701
        strcpy((char */* __restrict  */)(filename___0 + lendir), (char const   */* __restrict  */)base_name);
        }
      }
    }
    {
#line 704
    result = (*func)(filename___0, data1, data2);
    }
#line 704
    if (result) {
#line 706
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 712
  if (argz) {
    {
#line 712
    free((void *)argz);
#line 712
    argz = (char *)((void *)0);
    }
  }
#line 713
  if (canonical) {
    {
#line 713
    free((void *)canonical);
#line 713
    canonical = (char *)((void *)0);
    }
  }
#line 714
  if (filename___0) {
    {
#line 714
    free((void *)filename___0);
#line 714
    filename___0 = (char *)((void *)0);
    }
  }
#line 716
  return (result);
}
}
#line 722 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int find_file_callback(char *filename___0 , void *data1 , void *data2 ) 
{ 
  char **pdir ;
  FILE **pfile ;
  int is_done ;
  char *dirend ;
  char *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 725
  pdir = (char **)data1;
#line 726
  pfile = (FILE **)data2;
#line 727
  is_done = 0;
#line 729
  if (filename___0) {
#line 729
    if (! *filename___0) {
      {
#line 729
      __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    729U, "find_file_callback");
      }
    }
  } else {
    {
#line 729
    __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  729U, "find_file_callback");
    }
  }
#line 730
  if (! pdir) {
    {
#line 730
    __assert_fail("pdir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  730U, "find_file_callback");
    }
  }
#line 731
  if (! pfile) {
    {
#line 731
    __assert_fail("pfile", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  731U, "find_file_callback");
    }
  }
  {
#line 733
  tmp___0 = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r");
#line 733
  *pfile = tmp___0;
  }
#line 733
  if (tmp___0) {
    {
#line 735
    tmp = strrchr((char const   *)filename___0, '/');
#line 735
    dirend = tmp;
    }
#line 737
    if ((unsigned long )dirend > (unsigned long )filename___0) {
#line 738
      *dirend = (char )'\000';
    }
#line 740
    if (*pdir) {
      {
#line 740
      free((void *)*pdir);
#line 740
      *pdir = (char *)((void *)0);
      }
    }
    {
#line 741
    *pdir = lt__strdup((char const   *)filename___0);
    }
#line 742
    if ((unsigned long )*pdir == (unsigned long )((char *)0)) {
#line 742
      is_done = -1;
    } else {
#line 742
      is_done = 1;
    }
  }
#line 745
  return (is_done);
}
}
#line 748 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) 
{ 
  FILE *file ;

  {
  {
#line 751
  file = (FILE *)0;
#line 753
  foreach_dirinpath(search_path, base_name, & find_file_callback, (void *)pdir, (void *)(& file));
  }
#line 755
  return (file);
}
}
#line 758 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int find_handle_callback(char *filename___0 , void *data , void *data2 ) 
{ 
  lt_dlhandle *phandle ;
  int notfound ;
  int tmp ;
  lt_dladvise advise ;
  int tmp___0 ;

  {
  {
#line 761
  phandle = (lt_dlhandle *)data;
#line 762
  tmp = access((char const   *)filename___0, 4);
#line 762
  notfound = tmp;
#line 763
  advise = (lt_dladvise )data2;
  }
#line 766
  if (notfound) {
#line 767
    return (0);
  }
  {
#line 771
  tmp___0 = tryall_dlopen(phandle, (char const   *)filename___0, advise, (lt_dlvtable const   *)0);
  }
#line 771
  if (tmp___0 != 0) {
#line 772
    *phandle = (lt_dlhandle )0;
  }
#line 774
  return (1);
}
}
#line 779 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *phandle , lt_dladvise advise ) 
{ 
  int tmp ;

  {
#line 783
  if (! search_path) {
#line 784
    return ((lt_dlhandle *)0);
  }
  {
#line 786
  tmp = foreach_dirinpath(search_path, base_name, & find_handle_callback, (void *)phandle,
                          (void *)advise);
  }
#line 786
  if (! tmp) {
#line 788
    return ((lt_dlhandle *)0);
  }
#line 790
  return (phandle);
}
}
#line 794 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int load_deplibs(lt_dlhandle handle , char *deplibs  __attribute__((__unused__)) ) 
{ 


  {
#line 797
  handle->depcount = 0;
#line 798
  return (0);
}
}
#line 958 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int unload_deplibs(lt_dlhandle handle ) 
{ 
  int i___0 ;
  int errors ;
  lt_dlhandle cur ;
  int tmp ;

  {
#line 962
  errors = 0;
#line 963
  cur = handle;
#line 965
  if (cur->depcount) {
#line 967
    i___0 = 0;
    {
#line 967
    while (1) {
      while_continue: /* CIL Label */ ;
#line 967
      if (! (i___0 < cur->depcount)) {
#line 967
        goto while_break;
      }
#line 969
      if (! (*(cur->deplibs + i___0))->info.is_resident) {
        {
#line 971
        tmp = lt_dlclose(*(cur->deplibs + i___0));
#line 971
        errors += tmp;
        }
      }
#line 967
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 974
    if (cur->deplibs) {
      {
#line 974
      free((void *)cur->deplibs);
#line 974
      cur->deplibs = (lt_dlhandle *)((void *)0);
      }
    }
  }
#line 977
  return (errors);
}
}
#line 980 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int trim(char **dest , char const   *str ) 
{ 
  char const   *end ;
  char *tmp ;
  size_t len___0 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 985
  tmp = strrchr(str, '\'');
#line 985
  end = (char const   *)tmp;
  }
#line 986
  if (str) {
#line 986
    if (*(str + 0)) {
      {
#line 986
      tmp___0 = strlen(str);
#line 986
      tmp___1 = tmp___0;
      }
    } else {
#line 986
      tmp___1 = (size_t )0;
    }
  } else {
#line 986
    tmp___1 = (size_t )0;
  }
#line 986
  len___0 = tmp___1;
#line 989
  if (*dest) {
    {
#line 989
    free((void *)*dest);
#line 989
    *dest = (char *)((void *)0);
    }
  }
#line 991
  if (! end) {
#line 992
    return (1);
  }
#line 994
  if (len___0 > 3U) {
#line 994
    if ((int const   )*(str + 0) == 39) {
      {
#line 996
      tmp___3 = lt__malloc((size_t )((unsigned long )(end - str) * sizeof(char )));
#line 996
      tmp___2 = (char *)tmp___3;
      }
#line 997
      if (! tmp___2) {
#line 998
        return (1);
      }
      {
#line 1000
      memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)(str + 1),
             (size_t )((end - str) - 1L));
#line 1001
      *(tmp___2 + ((end - str) - 1L)) = (char )'\000';
#line 1002
      *dest = tmp___2;
      }
    } else {
#line 1006
      *dest = (char *)0;
    }
  } else {
#line 1006
    *dest = (char *)0;
  }
#line 1009
  return (0);
}
}
#line 1013 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int parse_dotla_file(FILE *file , char **dlname , char **libdir , char **deplibs ,
                            char **old_name , int *installed ) 
{ 
  int errors ;
  size_t line_len ;
  char *line___0 ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *last_libname ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 1017
  errors = 0;
#line 1018
  line_len = (size_t )2048;
#line 1019
  tmp = lt__malloc((size_t )((unsigned long )line_len * sizeof(char )));
#line 1019
  line___0 = (char *)tmp;
  }
#line 1021
  if (! line___0) {
    {
#line 1023
    tmp___0 = lt__error_string(5);
#line 1023
    lt__set_last_error(tmp___0);
    }
#line 1024
    return (1);
  }
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1027
    tmp___17 = feof(file);
    }
#line 1027
    if (tmp___17) {
#line 1027
      goto while_break;
    }
    {
#line 1029
    *(line___0 + (line_len - 2U)) = (char )'\000';
#line 1030
    tmp___1 = fgets((char */* __restrict  */)line___0, (int )line_len, (FILE */* __restrict  */)file);
    }
#line 1030
    if (! tmp___1) {
#line 1032
      goto while_break;
    }
    {
#line 1038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1038
      if ((int )*(line___0 + (line_len - 2U)) != 0) {
#line 1038
        if ((int )*(line___0 + (line_len - 2U)) != 10) {
          {
#line 1038
          tmp___4 = feof(file);
          }
#line 1038
          if (tmp___4) {
#line 1038
            goto while_break___0;
          }
        } else {
#line 1038
          goto while_break___0;
        }
      } else {
#line 1038
        goto while_break___0;
      }
      {
#line 1040
      tmp___2 = lt__realloc((void *)line___0, (size_t )((unsigned long )(line_len * 2U) * sizeof(char )));
#line 1040
      line___0 = (char *)tmp___2;
      }
#line 1041
      if (! line___0) {
#line 1043
        errors ++;
#line 1044
        goto cleanup;
      }
      {
#line 1046
      *(line___0 + (line_len * 2U - 2U)) = (char )'\000';
#line 1047
      tmp___3 = fgets((char */* __restrict  */)(line___0 + (line_len - 1U)), (int )line_len + 1,
                      (FILE */* __restrict  */)file);
      }
#line 1047
      if (! tmp___3) {
#line 1049
        goto while_break___0;
      }
#line 1051
      line_len *= 2U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1054
    if ((int )*(line___0 + 0) == 10) {
#line 1056
      goto while_continue;
    } else
#line 1054
    if ((int )*(line___0 + 0) == 35) {
#line 1056
      goto while_continue;
    }
    {
#line 1061
    tmp___16 = strncmp((char const   *)line___0, "dlname=", (size_t )(sizeof("dlname=") - 1UL));
    }
#line 1061
    if (tmp___16 == 0) {
      {
#line 1063
      tmp___5 = trim(dlname, (char const   *)(line___0 + (sizeof("dlname=") - 1UL)));
#line 1063
      errors += tmp___5;
      }
    } else {
      {
#line 1068
      tmp___15 = strncmp((char const   *)line___0, "old_library=", (size_t )(sizeof("old_library=") - 1UL));
      }
#line 1068
      if (tmp___15 == 0) {
        {
#line 1071
        tmp___6 = trim(old_name, (char const   *)(line___0 + (sizeof("old_library=") - 1UL)));
#line 1071
        errors += tmp___6;
        }
      } else {
        {
#line 1075
        tmp___14 = strncmp((char const   *)line___0, "libdir=", (size_t )(sizeof("libdir=") - 1UL));
        }
#line 1075
        if (tmp___14 == 0) {
          {
#line 1077
          tmp___7 = trim(libdir, (char const   *)(line___0 + (sizeof("libdir=") - 1UL)));
#line 1077
          errors += tmp___7;
          }
        } else {
          {
#line 1082
          tmp___13 = strncmp((char const   *)line___0, "dependency_libs=", (size_t )(sizeof("dependency_libs=") - 1UL));
          }
#line 1082
          if (tmp___13 == 0) {
            {
#line 1085
            tmp___8 = trim(deplibs, (char const   *)(line___0 + (sizeof("dependency_libs=") - 1UL)));
#line 1085
            errors += tmp___8;
            }
          } else {
            {
#line 1087
            tmp___12 = strcmp((char const   *)line___0, "installed=yes\n");
            }
#line 1087
            if (tmp___12) {
              {
#line 1091
              tmp___11 = strcmp((char const   *)line___0, "installed=no\n");
              }
#line 1091
              if (tmp___11) {
#line 1098
                if (! *dlname) {
                  {
#line 1098
                  tmp___10 = strncmp((char const   *)line___0, "library_names=", (size_t )(sizeof("library_names=") - 1UL));
                  }
#line 1098
                  if (tmp___10 == 0) {
                    {
#line 1102
                    tmp___9 = trim(dlname, (char const   *)(line___0 + (sizeof("library_names=") - 1UL)));
#line 1102
                    errors += tmp___9;
                    }
#line 1103
                    if (! errors) {
#line 1103
                      if (*dlname) {
                        {
#line 1103
                        last_libname = strrchr((char const   *)*dlname, ' ');
                        }
#line 1103
                        if ((unsigned long )last_libname != (unsigned long )((char *)0)) {
                          {
#line 1107
                          last_libname = lt__strdup((char const   *)(last_libname + 1));
                          }
#line 1108
                          if (! last_libname) {
#line 1110
                            errors ++;
#line 1111
                            goto cleanup;
                          }
#line 1113
                          if ((unsigned long )*dlname != (unsigned long )last_libname) {
#line 1113
                            if (*dlname) {
                              {
#line 1113
                              free((void *)*dlname);
                              }
                            }
#line 1113
                            *dlname = last_libname;
#line 1113
                            last_libname = (char *)0;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
#line 1093
                *installed = 0;
              }
            } else {
#line 1089
              *installed = 1;
            }
          }
        }
      }
    }
#line 1117
    if (errors) {
#line 1118
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1121
  if (line___0) {
    {
#line 1121
    free((void *)line___0);
#line 1121
    line___0 = (char *)((void *)0);
    }
  }
#line 1122
  return (errors);
}
}
#line 1127 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int try_dlopen(lt_dlhandle *phandle , char const   *filename___0 , char const   *ext ,
                      lt_dladvise advise ) 
{ 
  char const   *saved_error ;
  char *canonical ;
  char *base_name ;
  char *dir ;
  char *name ;
  char *attempt ;
  int errors ;
  lt_dlhandle newhandle ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  size_t dirlen ;
  void *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  int i___0 ;
  unsigned short const   **tmp___12 ;
  lt_dlvtable const   *vtable___1 ;
  lt_dlvtable const   *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  FILE *file ;
  char *dlname ;
  char *old_name ;
  char *libdir ;
  char *deplibs ;
  int installed ;
  char const   *search_path ;
  char *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  lt_dlhandle *tmp___25 ;
  char *tmp___26 ;
  lt_dlhandle *tmp___27 ;
  char *tmp___28 ;
  lt_dlhandle *tmp___29 ;
  lt_dlhandle *tmp___30 ;
  int tmp___31 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
#line 1131
  saved_error = (char const   *)0;
#line 1132
  canonical = (char *)0;
#line 1133
  base_name = (char *)0;
#line 1134
  dir = (char *)0;
#line 1135
  name = (char *)0;
#line 1136
  attempt = (char *)0;
#line 1137
  errors = 0;
#line 1140
  if (! phandle) {
    {
#line 1140
    __assert_fail("phandle", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1140U, "try_dlopen");
    }
  }
#line 1141
  if (! ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0))) {
    {
#line 1141
    __assert_fail("*phandle == 0", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1141U, "try_dlopen");
    }
  }
  {
#line 1149
  saved_error = lt__get_last_error();
  }
#line 1152
  if (! filename___0) {
    {
#line 1154
    tmp = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1154
    *phandle = (lt_dlhandle )tmp;
    }
#line 1155
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1156
      return (1);
    }
    {
#line 1158
    newhandle = *phandle;
#line 1161
    newhandle->info.is_resident = 1U;
#line 1163
    tmp___0 = tryall_dlopen(& newhandle, (char const   *)0, advise, (lt_dlvtable const   *)0);
    }
#line 1163
    if (tmp___0 != 0) {
#line 1165
      if (*phandle) {
        {
#line 1165
        free((void *)*phandle);
#line 1165
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1166
      return (1);
    }
#line 1169
    goto register_handle;
  }
#line 1172
  if (filename___0) {
#line 1172
    if (! *filename___0) {
      {
#line 1172
      __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1172U, "try_dlopen");
      }
    }
  } else {
    {
#line 1172
    __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1172U, "try_dlopen");
    }
  }
#line 1174
  if (ext) {
#line 1176
    if (filename___0) {
#line 1176
      if (*(filename___0 + 0)) {
        {
#line 1176
        tmp___1 = strlen(filename___0);
#line 1176
        tmp___2 = tmp___1;
        }
      } else {
#line 1176
        tmp___2 = (size_t )0;
      }
    } else {
#line 1176
      tmp___2 = (size_t )0;
    }
#line 1176
    if (ext) {
#line 1176
      if (*(ext + 0)) {
        {
#line 1176
        tmp___3 = strlen(ext);
#line 1176
        tmp___4 = tmp___3;
        }
      } else {
#line 1176
        tmp___4 = (size_t )0;
      }
    } else {
#line 1176
      tmp___4 = (size_t )0;
    }
    {
#line 1176
    tmp___5 = lt__malloc((size_t )((unsigned long )((tmp___2 + tmp___4) + 1U) * sizeof(char )));
#line 1176
    attempt = (char *)tmp___5;
    }
#line 1177
    if (! attempt) {
#line 1178
      return (1);
    }
    {
#line 1180
    sprintf((char */* __restrict  */)attempt, (char const   */* __restrict  */)"%s%s",
            filename___0, ext);
    }
  } else {
    {
#line 1184
    attempt = lt__strdup(filename___0);
    }
#line 1185
    if (! attempt) {
#line 1186
      return (1);
    }
  }
  {
#line 1191
  tmp___6 = canonicalize_path((char const   *)attempt, & canonical);
  }
#line 1191
  if (tmp___6 != 0) {
#line 1193
    errors ++;
#line 1194
    goto cleanup;
  }
  {
#line 1199
  base_name = strrchr((char const   *)canonical, '/');
  }
#line 1200
  if (base_name) {
    {
#line 1202
    dirlen = (size_t )((base_name + 1) - canonical);
#line 1204
    tmp___7 = lt__malloc((size_t )((unsigned long )(1U + dirlen) * sizeof(char )));
#line 1204
    dir = (char *)tmp___7;
    }
#line 1205
    if (! dir) {
#line 1207
      errors ++;
#line 1208
      goto cleanup;
    }
    {
#line 1211
    strncpy((char */* __restrict  */)dir, (char const   */* __restrict  */)canonical,
            dirlen);
#line 1212
    *(dir + dirlen) = (char )'\000';
#line 1214
    base_name ++;
    }
  } else
#line 1217
  if ((unsigned long )base_name != (unsigned long )canonical) {
#line 1217
    if (base_name) {
      {
#line 1217
      free((void *)base_name);
      }
    }
#line 1217
    base_name = canonical;
#line 1217
    canonical = (char *)0;
  }
#line 1219
  if (base_name) {
#line 1219
    if (! *base_name) {
      {
#line 1219
      __assert_fail("base_name && *base_name", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1219U, "try_dlopen");
      }
    }
  } else {
    {
#line 1219
    __assert_fail("base_name && *base_name", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1219U, "try_dlopen");
    }
  }
  {
#line 1221
  tmp___8 = strrchr((char const   *)base_name, '.');
#line 1221
  ext = (char const   *)tmp___8;
  }
#line 1222
  if (! ext) {
#line 1224
    if (base_name) {
#line 1224
      if (*(base_name + 0)) {
        {
#line 1224
        tmp___9 = strlen((char const   *)base_name);
#line 1224
        tmp___10 = tmp___9;
        }
      } else {
#line 1224
        tmp___10 = (size_t )0;
      }
    } else {
#line 1224
      tmp___10 = (size_t )0;
    }
#line 1224
    ext = (char const   *)(base_name + tmp___10);
  }
  {
#line 1228
  tmp___11 = lt__malloc((size_t )((unsigned long )((ext - (char const   *)base_name) + 1L) * sizeof(char )));
#line 1228
  name = (char *)tmp___11;
  }
#line 1229
  if (! name) {
#line 1231
    errors ++;
#line 1232
    goto cleanup;
  }
#line 1238
  i___0 = 0;
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1238
    if (! ((long )i___0 < ext - (char const   *)base_name)) {
#line 1238
      goto while_break;
    }
    {
#line 1240
    tmp___12 = __ctype_b_loc();
    }
#line 1240
    if ((int const   )*(*tmp___12 + (int )((unsigned char )*(base_name + i___0))) & 8) {
#line 1242
      *(name + i___0) = *(base_name + i___0);
    } else {
#line 1246
      *(name + i___0) = (char )'_';
    }
#line 1238
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1249
  *(name + (ext - (char const   *)base_name)) = (char )'\000';
#line 1254
  if (! dir) {
    {
#line 1256
    tmp___13 = lt_dlloader_find((char *)"lt_preopen");
#line 1256
    vtable___1 = tmp___13;
    }
#line 1258
    if (vtable___1) {
      {
#line 1260
      tmp___14 = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1260
      *phandle = (lt_dlhandle )tmp___14;
      }
#line 1262
      if ((unsigned long )*phandle == (unsigned long )((void *)0)) {
#line 1264
        errors ++;
#line 1265
        goto cleanup;
      }
      {
#line 1267
      newhandle = *phandle;
#line 1269
      tmp___15 = tryall_dlopen(& newhandle, (char const   *)attempt, advise, vtable___1);
      }
#line 1269
      if (tmp___15 == 0) {
#line 1271
        goto register_handle;
      }
#line 1276
      if (*phandle) {
        {
#line 1276
        free((void *)*phandle);
#line 1276
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1277
      newhandle = (lt_dlhandle )((void *)0);
    }
  }
#line 1282
  if (ext) {
    {
#line 1282
    tmp___31 = strcmp(ext, archive_ext);
    }
#line 1282
    if (tmp___31) {
#line 1282
      goto _L___0;
    } else {
#line 1285
      file = (FILE *)0;
#line 1286
      dlname = (char *)0;
#line 1287
      old_name = (char *)0;
#line 1288
      libdir = (char *)0;
#line 1289
      deplibs = (char *)0;
#line 1294
      installed = 1;
#line 1300
      if (! dir) {
#line 1302
        search_path = (char const   *)user_search_path;
#line 1304
        if (search_path) {
          {
#line 1305
          file = find_file((char const   *)user_search_path, (char const   *)base_name,
                           & dir);
          }
        }
#line 1307
        if (! file) {
          {
#line 1309
          tmp___16 = getenv("LTDL_LIBRARY_PATH");
#line 1309
          search_path = (char const   *)tmp___16;
          }
#line 1310
          if (search_path) {
            {
#line 1311
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 1315
        if (! file) {
          {
#line 1317
          tmp___17 = getenv("LD_LIBRARY_PATH");
#line 1317
          search_path = (char const   *)tmp___17;
          }
#line 1318
          if (search_path) {
            {
#line 1319
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 1323
        if (! file) {
#line 1323
          if (sys_dlsearch_path[0]) {
            {
#line 1325
            file = find_file(sys_dlsearch_path, (char const   *)base_name, & dir);
            }
          }
        }
      }
#line 1329
      if (! file) {
        {
#line 1331
        file = fopen((char const   */* __restrict  */)attempt, (char const   */* __restrict  */)"r");
        }
      }
#line 1336
      if (! file) {
        {
#line 1338
        tmp___18 = lt__error_string(5);
#line 1338
        lt__set_last_error(tmp___18);
#line 1339
        errors ++;
        }
#line 1340
        goto cleanup;
      }
      {
#line 1344
      tmp___19 = parse_dotla_file(file, & dlname, & libdir, & deplibs, & old_name,
                                  & installed);
      }
#line 1344
      if (tmp___19 != 0) {
#line 1346
        errors ++;
      }
      {
#line 1348
      fclose(file);
#line 1351
      tmp___20 = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1351
      *phandle = (lt_dlhandle )tmp___20;
      }
#line 1352
      if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1353
        errors ++;
      }
#line 1355
      if (errors) {
#line 1357
        if (dlname) {
          {
#line 1357
          free((void *)dlname);
#line 1357
          dlname = (char *)((void *)0);
          }
        }
#line 1358
        if (old_name) {
          {
#line 1358
          free((void *)old_name);
#line 1358
          old_name = (char *)((void *)0);
          }
        }
#line 1359
        if (libdir) {
          {
#line 1359
          free((void *)libdir);
#line 1359
          libdir = (char *)((void *)0);
          }
        }
#line 1360
        if (deplibs) {
          {
#line 1360
          free((void *)deplibs);
#line 1360
          deplibs = (char *)((void *)0);
          }
        }
#line 1361
        if (*phandle) {
          {
#line 1361
          free((void *)*phandle);
#line 1361
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 1362
        goto cleanup;
      }
#line 1365
      if (! *phandle) {
        {
#line 1365
        __assert_fail("*phandle", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                      1365U, "try_dlopen");
        }
      }
      {
#line 1367
      tmp___22 = load_deplibs(*phandle, deplibs);
      }
#line 1367
      if (tmp___22 == 0) {
        {
#line 1369
        newhandle = *phandle;
#line 1371
        tmp___21 = find_module(& newhandle, (char const   *)dir, (char const   *)libdir,
                               (char const   *)dlname, (char const   *)old_name, installed,
                               advise);
        }
#line 1371
        if (tmp___21) {
          {
#line 1374
          unload_deplibs(*phandle);
#line 1375
          errors ++;
          }
        }
      } else {
#line 1380
        errors ++;
      }
#line 1383
      if (dlname) {
        {
#line 1383
        free((void *)dlname);
#line 1383
        dlname = (char *)((void *)0);
        }
      }
#line 1384
      if (old_name) {
        {
#line 1384
        free((void *)old_name);
#line 1384
        old_name = (char *)((void *)0);
        }
      }
#line 1385
      if (libdir) {
        {
#line 1385
        free((void *)libdir);
#line 1385
        libdir = (char *)((void *)0);
        }
      }
#line 1386
      if (deplibs) {
        {
#line 1386
        free((void *)deplibs);
#line 1386
        deplibs = (char *)((void *)0);
        }
      }
#line 1388
      if (errors) {
#line 1390
        if (*phandle) {
          {
#line 1390
          free((void *)*phandle);
#line 1390
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 1391
        goto cleanup;
      }
#line 1394
      if ((unsigned long )*phandle != (unsigned long )newhandle) {
        {
#line 1396
        unload_deplibs(*phandle);
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1402
    tmp___23 = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1402
    *phandle = (lt_dlhandle )tmp___23;
    }
#line 1403
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1405
      errors ++;
#line 1406
      goto cleanup;
    }
#line 1409
    newhandle = *phandle;
#line 1415
    if (dir) {
#line 1415
      goto _L;
    } else {
      {
#line 1415
      tmp___25 = find_handle((char const   *)user_search_path, (char const   *)base_name,
                             & newhandle, advise);
      }
#line 1415
      if (! tmp___25) {
        {
#line 1415
        tmp___26 = getenv("LTDL_LIBRARY_PATH");
#line 1415
        tmp___27 = find_handle((char const   *)tmp___26, (char const   *)base_name,
                               & newhandle, advise);
        }
#line 1415
        if (! tmp___27) {
          {
#line 1415
          tmp___28 = getenv("LD_LIBRARY_PATH");
#line 1415
          tmp___29 = find_handle((char const   *)tmp___28, (char const   *)base_name,
                                 & newhandle, advise);
          }
#line 1415
          if (! tmp___29) {
            {
#line 1415
            tmp___30 = find_handle(sys_dlsearch_path, (char const   *)base_name, & newhandle,
                                   advise);
            }
#line 1415
            if (! tmp___30) {
              _L: /* CIL Label */ 
              {
#line 1429
              tmp___24 = tryall_dlopen(& newhandle, (char const   *)attempt, advise,
                                       (lt_dlvtable const   *)0);
              }
#line 1429
              if (tmp___24 != 0) {
#line 1431
                newhandle = (lt_dlhandle )((void *)0);
              }
            }
          }
        }
      }
    }
#line 1435
    if (! newhandle) {
#line 1437
      if (*phandle) {
        {
#line 1437
        free((void *)*phandle);
#line 1437
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1438
      errors ++;
#line 1439
      goto cleanup;
    }
  }
  register_handle: 
#line 1444
  if ((unsigned long )*phandle != (unsigned long )newhandle) {
#line 1444
    if (*phandle) {
      {
#line 1444
      free((void *)*phandle);
      }
    }
#line 1444
    *phandle = newhandle;
#line 1444
    newhandle = (lt_dlhandle )0;
  }
#line 1446
  if ((*phandle)->info.ref_count == 0) {
#line 1448
    (*phandle)->info.ref_count = 1;
#line 1449
    if ((unsigned long )(*phandle)->info.name != (unsigned long )name) {
#line 1449
      if ((*phandle)->info.name) {
        {
#line 1449
        free((void *)(*phandle)->info.name);
        }
      }
#line 1449
      (*phandle)->info.name = name;
#line 1449
      name = (char *)0;
    }
#line 1451
    (*phandle)->next = handles;
#line 1452
    handles = *phandle;
  }
  {
#line 1455
  lt__set_last_error(saved_error);
  }
  cleanup: 
#line 1458
  if (dir) {
    {
#line 1458
    free((void *)dir);
#line 1458
    dir = (char *)((void *)0);
    }
  }
#line 1459
  if (attempt) {
    {
#line 1459
    free((void *)attempt);
#line 1459
    attempt = (char *)((void *)0);
    }
  }
#line 1460
  if (name) {
    {
#line 1460
    free((void *)name);
#line 1460
    name = (char *)((void *)0);
    }
  }
#line 1461
  if (! canonical) {
#line 1462
    if (base_name) {
      {
#line 1462
      free((void *)base_name);
#line 1462
      base_name = (char *)((void *)0);
      }
    }
  }
#line 1463
  if (canonical) {
    {
#line 1463
    free((void *)canonical);
#line 1463
    canonical = (char *)((void *)0);
    }
  }
#line 1465
  return (errors);
}
}
#line 1471 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int file_not_found(void) 
{ 
  char const   *error ;
  char const   *tmp ;

  {
  {
#line 1474
  error = (char const   *)0;
#line 1476
  error = lt__get_last_error();
#line 1477
  tmp = lt__error_string(5);
  }
#line 1477
  if ((unsigned long )error == (unsigned long )tmp) {
#line 1478
    return (1);
  }
#line 1480
  return (0);
}
}
#line 1486 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int has_library_ext(char const   *filename___0 ) 
{ 
  char *ext ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1489
  ext = (char *)0;
#line 1491
  if (! filename___0) {
    {
#line 1491
    __assert_fail("filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1491U, "has_library_ext");
    }
  }
  {
#line 1493
  ext = strrchr(filename___0, '.');
  }
#line 1495
  if (ext) {
    {
#line 1495
    tmp = strcmp((char const   *)ext, archive_ext);
    }
#line 1495
    if (tmp) {
      {
#line 1495
      tmp___0 = strcmp((char const   *)ext, shlib_ext);
      }
#line 1495
      if (! tmp___0) {
#line 1501
        return (1);
      }
    } else {
#line 1501
      return (1);
    }
  }
#line 1504
  return (0);
}
}
#line 1510 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_init(lt_dladvise *padvise ) 
{ 
  lt_dladvise advise ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1513
  tmp = lt__zalloc((size_t )sizeof(struct lt__advise ));
#line 1513
  advise = (lt_dladvise )tmp;
#line 1514
  *padvise = advise;
  }
#line 1515
  if (advise) {
#line 1515
    tmp___0 = 0;
  } else {
#line 1515
    tmp___0 = 1;
  }
#line 1515
  return (tmp___0);
}
}
#line 1518 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_destroy(lt_dladvise *padvise ) 
{ 


  {
#line 1521
  if (padvise) {
#line 1522
    if (*padvise) {
      {
#line 1522
      free((void *)*padvise);
#line 1522
      *padvise = (lt_dladvise )((void *)0);
      }
    }
  }
#line 1523
  return (0);
}
}
#line 1526 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_ext(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1529
  if (padvise) {
#line 1529
    if (! *padvise) {
      {
#line 1529
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1529U, "lt_dladvise_ext");
      }
    }
  } else {
    {
#line 1529
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1529U, "lt_dladvise_ext");
    }
  }
#line 1530
  (*padvise)->try_ext = 1U;
#line 1531
  return (0);
}
}
#line 1534 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_resident(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1537
  if (padvise) {
#line 1537
    if (! *padvise) {
      {
#line 1537
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1537U, "lt_dladvise_resident");
      }
    }
  } else {
    {
#line 1537
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1537U, "lt_dladvise_resident");
    }
  }
#line 1538
  (*padvise)->is_resident = 1U;
#line 1539
  return (0);
}
}
#line 1542 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_local(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1545
  if (padvise) {
#line 1545
    if (! *padvise) {
      {
#line 1545
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1545U, "lt_dladvise_local");
      }
    }
  } else {
    {
#line 1545
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1545U, "lt_dladvise_local");
    }
  }
#line 1546
  (*padvise)->is_symlocal = 1U;
#line 1547
  return (0);
}
}
#line 1550 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_global(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1553
  if (padvise) {
#line 1553
    if (! *padvise) {
      {
#line 1553
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1553U, "lt_dladvise_global");
      }
    }
  } else {
    {
#line 1553
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1553U, "lt_dladvise_global");
    }
  }
#line 1554
  (*padvise)->is_symglobal = 1U;
#line 1555
  return (0);
}
}
#line 1559 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlopen(char const   *filename___0 ) 
{ 
  lt_dlhandle tmp ;

  {
  {
#line 1562
  tmp = lt_dlopenadvise(filename___0, (lt_dladvise )((void *)0));
  }
#line 1562
  return (tmp);
}
}
#line 1570 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlopenext(char const   *filename___0 ) 
{ 
  lt_dlhandle handle ;
  lt_dladvise advise ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1573
  handle = (lt_dlhandle )0;
#line 1576
  tmp = lt_dladvise_init(& advise);
  }
#line 1576
  if (! tmp) {
    {
#line 1576
    tmp___0 = lt_dladvise_ext(& advise);
    }
#line 1576
    if (! tmp___0) {
      {
#line 1577
      handle = lt_dlopenadvise(filename___0, advise);
      }
    }
  }
  {
#line 1579
  lt_dladvise_destroy(& advise);
  }
#line 1580
  return (handle);
}
}
#line 1584 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlopenadvise(char const   *filename___0 , lt_dladvise advise ) 
{ 
  lt_dlhandle handle ;
  int errors ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1587
  handle = (lt_dlhandle )0;
#line 1588
  errors = 0;
#line 1591
  if (advise) {
#line 1591
    if (advise->is_symlocal) {
#line 1591
      if (advise->is_symglobal) {
        {
#line 1593
        tmp = lt__error_string(19);
#line 1593
        lt__set_last_error(tmp);
        }
#line 1594
        return ((lt_dlhandle )0);
      }
    }
  }
#line 1597
  if (! filename___0) {
#line 1597
    goto _L;
  } else
#line 1597
  if (! advise) {
#line 1597
    goto _L;
  } else
#line 1597
  if (! advise->try_ext) {
#line 1597
    goto _L;
  } else {
    {
#line 1597
    tmp___4 = has_library_ext(filename___0);
    }
#line 1597
    if (tmp___4) {
      _L: /* CIL Label */ 
      {
#line 1604
      tmp___0 = try_dlopen(& handle, filename___0, (char const   *)((void *)0), advise);
      }
#line 1604
      if (tmp___0 != 0) {
#line 1605
        return ((lt_dlhandle )0);
      }
#line 1607
      return (handle);
    } else
#line 1609
    if (filename___0) {
#line 1609
      if (*filename___0) {
        {
#line 1613
        tmp___1 = try_dlopen(& handle, filename___0, archive_ext, advise);
#line 1613
        errors += tmp___1;
        }
#line 1620
        if (handle) {
#line 1621
          return (handle);
        } else
#line 1620
        if (errors > 0) {
          {
#line 1620
          tmp___2 = file_not_found();
          }
#line 1620
          if (! tmp___2) {
#line 1621
            return (handle);
          }
        }
        {
#line 1625
        errors = try_dlopen(& handle, filename___0, shlib_ext, advise);
        }
#line 1629
        if (handle) {
#line 1630
          return (handle);
        } else
#line 1629
        if (errors > 0) {
          {
#line 1629
          tmp___3 = file_not_found();
          }
#line 1629
          if (! tmp___3) {
#line 1630
            return (handle);
          }
        }
      }
    }
  }
  {
#line 1636
  tmp___5 = lt__error_string(5);
#line 1636
  lt__set_last_error(tmp___5);
  }
#line 1637
  return ((lt_dlhandle )0);
}
}
#line 1641 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) 
{ 
  error_t error ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1649
  if (before) {
    {
#line 1650
    error = argz_insert((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char */* __restrict  */)before, (char const   */* __restrict  */)entry);
    }
  } else {
    {
#line 1652
    tmp = strlen(entry);
#line 1652
    error = argz_append((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char const   */* __restrict  */)entry, 1U + tmp);
    }
  }
#line 1654
  if (error) {
    {
#line 1658
    if (error == 12) {
#line 1658
      goto case_12;
    }
#line 1661
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 1659
    tmp___0 = lt__error_string(11);
#line 1659
    lt__set_last_error(tmp___0);
    }
#line 1660
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1662
    tmp___1 = lt__error_string(0);
#line 1662
    lt__set_last_error(tmp___1);
    }
#line 1663
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1665
    return (1);
  }
#line 1668
  return (0);
}
}
#line 1671 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) 
{ 
  char *before ;
  int cmp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1674
  before = (char *)0;
#line 1676
  if (! pargz) {
    {
#line 1676
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1676U, "lt_argz_insertinorder");
    }
  }
#line 1677
  if (! pargz_len) {
    {
#line 1677
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1677U, "lt_argz_insertinorder");
    }
  }
#line 1678
  if (entry) {
#line 1678
    if (! *entry) {
      {
#line 1678
      __assert_fail("entry && *entry", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1678U, "lt_argz_insertinorder");
      }
    }
  } else {
    {
#line 1678
    __assert_fail("entry && *entry", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1678U, "lt_argz_insertinorder");
    }
  }
#line 1680
  if (*pargz) {
    {
#line 1681
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1681
      before = argz_next((char const   */* __restrict  */)*pargz, *pargz_len, (char const   */* __restrict  */)before);
      }
#line 1681
      if (! before) {
#line 1681
        goto while_break;
      }
      {
#line 1683
      tmp = strcmp(entry, (char const   *)before);
#line 1683
      cmp = tmp;
      }
#line 1685
      if (cmp < 0) {
#line 1685
        goto while_break;
      }
#line 1686
      if (cmp == 0) {
#line 1686
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1689
  tmp___0 = lt_argz_insert(pargz, pargz_len, before, entry);
  }
#line 1689
  return (tmp___0);
}
}
#line 1692 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) 
{ 
  char *buf___1 ;
  size_t buf_len ;
  char *end ;
  size_t end_offset ;
  size_t dir_len ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  char *p ;
  char *tmp___1 ;
  char *p___0 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1696
  buf___1 = (char *)0;
#line 1697
  buf_len = (size_t )0;
#line 1698
  end = (char *)0;
#line 1699
  end_offset = (size_t )0;
#line 1700
  dir_len = (size_t )0;
#line 1701
  errors = 0;
#line 1703
  if (! pargz) {
    {
#line 1703
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1703U, "lt_argz_insertdir");
    }
  }
#line 1704
  if (! pargz_len) {
    {
#line 1704
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1704U, "lt_argz_insertdir");
    }
  }
#line 1705
  if (! dp) {
    {
#line 1705
    __assert_fail("dp", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1705U, "lt_argz_insertdir");
    }
  }
#line 1707
  if (dirnam) {
#line 1707
    if (*(dirnam + 0)) {
      {
#line 1707
      tmp = strlen(dirnam);
#line 1707
      dir_len = tmp;
      }
    } else {
#line 1707
      dir_len = (size_t )0;
    }
  } else {
#line 1707
    dir_len = (size_t )0;
  }
  {
#line 1708
  tmp___0 = strlen((char const   *)(dp->d_name));
#line 1708
  end = dp->d_name + tmp___0;
#line 1713
  p = end;
  }
  {
#line 1713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1713
    if (! ((unsigned long )(p - 1) > (unsigned long )(dp->d_name))) {
#line 1713
      goto while_break;
    }
    {
#line 1714
    tmp___1 = strchr(".0123456789", (int )*(p + -1));
    }
#line 1714
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
#line 1715
      goto while_break;
    }
#line 1713
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1717
  if ((int )*p == 46) {
#line 1718
    end = p;
  }
#line 1724
  p___0 = end - 1;
  {
#line 1724
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1724
    if (! ((unsigned long )p___0 > (unsigned long )(dp->d_name))) {
#line 1724
      goto while_break___0;
    }
#line 1725
    if ((int )*p___0 == 46) {
#line 1727
      end = p___0;
#line 1728
      goto while_break___0;
    }
#line 1724
    p___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1733
  end_offset = (size_t )(end - dp->d_name);
#line 1734
  buf_len = (dir_len + 1U) + end_offset;
#line 1735
  tmp___2 = lt__malloc((size_t )((unsigned long )(1U + buf_len) * sizeof(char )));
#line 1735
  buf___1 = (char *)tmp___2;
  }
#line 1736
  if (! buf___1) {
#line 1737
    errors ++;
#line 1737
    return (errors);
  }
#line 1739
  if (! buf___1) {
    {
#line 1739
    __assert_fail("buf", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1739U, "lt_argz_insertdir");
    }
  }
  {
#line 1741
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dirnam);
#line 1742
  strcat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"/");
#line 1743
  strncat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)(dp->d_name),
          end_offset);
#line 1744
  *(buf___1 + buf_len) = (char )'\000';
#line 1747
  tmp___3 = lt_argz_insertinorder(pargz, pargz_len, (char const   *)buf___1);
  }
#line 1747
  if (tmp___3 != 0) {
#line 1748
    errors ++;
  }
#line 1750
  if (buf___1) {
    {
#line 1750
    free((void *)buf___1);
#line 1750
    buf___1 = (char *)((void *)0);
    }
  }
#line 1752
  return (errors);
}
}
#line 1755 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) 
{ 
  DIR *dirp ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  struct dirent *dp ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1758
  dirp = (DIR *)0;
#line 1759
  errors = 0;
#line 1761
  if (dirnam) {
#line 1761
    if (! *dirnam) {
      {
#line 1761
      __assert_fail("dirnam && *dirnam", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1761U, "list_files_by_dir");
      }
    }
  } else {
    {
#line 1761
    __assert_fail("dirnam && *dirnam", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1761U, "list_files_by_dir");
    }
  }
#line 1762
  if (! pargz) {
    {
#line 1762
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1762U, "list_files_by_dir");
    }
  }
#line 1763
  if (! pargz_len) {
    {
#line 1763
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1763U, "list_files_by_dir");
    }
  }
#line 1764
  if (dirnam) {
#line 1764
    if (*(dirnam + 0)) {
      {
#line 1764
      tmp = strlen(dirnam);
#line 1764
      tmp___0 = tmp;
      }
    } else {
#line 1764
      tmp___0 = (size_t )0;
    }
  } else {
#line 1764
    tmp___0 = (size_t )0;
  }
#line 1764
  if (! ((int const   )*(dirnam + (tmp___0 - 1U)) != 47)) {
    {
#line 1764
    __assert_fail("dirnam[(((dirnam) && (dirnam)[0]) ? strlen (dirnam) : 0) -1] != \'/\'",
                  "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c", 1764U,
                  "list_files_by_dir");
    }
  }
  {
#line 1766
  dirp = opendir(dirnam);
  }
#line 1767
  if (dirp) {
#line 1769
    dp = (struct dirent *)0;
    {
#line 1771
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1771
      dp = readdir(dirp);
      }
#line 1771
      if (! dp) {
#line 1771
        goto while_break;
      }
#line 1772
      if ((int )dp->d_name[0] != 46) {
        {
#line 1773
        tmp___1 = lt_argz_insertdir(pargz, pargz_len, dirnam, dp);
        }
#line 1773
        if (tmp___1) {
#line 1775
          errors ++;
#line 1776
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1779
    closedir(dirp);
    }
  } else {
#line 1782
    errors ++;
  }
#line 1784
  return (errors);
}
}
#line 1790 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) 
{ 
  file_worker_func *func ;
  int is_done ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  char *filename___0 ;

  {
  {
#line 1793
  func = *((file_worker_func **)data1);
#line 1795
  is_done = 0;
#line 1796
  argz = (char *)0;
#line 1797
  argz_len = (size_t )0;
#line 1799
  tmp = list_files_by_dir((char const   *)dirname, & argz, & argz_len);
  }
#line 1799
  if (tmp != 0) {
#line 1800
    goto cleanup;
  }
#line 1801
  if (! argz) {
#line 1802
    goto cleanup;
  }
#line 1805
  filename___0 = (char *)0;
  {
#line 1806
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1806
    filename___0 = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)filename___0);
    }
#line 1806
    if (! filename___0) {
#line 1806
      goto while_break;
    }
    {
#line 1807
    is_done = (*func)((char const   *)filename___0, data2);
    }
#line 1807
    if (is_done) {
#line 1808
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1812
  if (argz) {
    {
#line 1812
    free((void *)argz);
#line 1812
    argz = (char *)((void *)0);
    }
  }
#line 1814
  return (is_done);
}
}
#line 1824 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) 
{ 
  int is_done ;
  file_worker_func **fpptr ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1829
  is_done = 0;
#line 1830
  fpptr = & func;
#line 1832
  if (search_path) {
    {
#line 1836
    is_done = foreach_dirinpath(search_path, (char const   *)0, & foreachfile_callback,
                                (void *)fpptr, data);
    }
  } else {
    {
#line 1842
    is_done = foreach_dirinpath((char const   *)user_search_path, (char const   *)0,
                                & foreachfile_callback, (void *)fpptr, data);
    }
#line 1844
    if (! is_done) {
      {
#line 1846
      tmp = getenv("LTDL_LIBRARY_PATH");
#line 1846
      is_done = foreach_dirinpath((char const   *)tmp, (char const   *)0, & foreachfile_callback,
                                  (void *)fpptr, data);
      }
    }
#line 1851
    if (! is_done) {
      {
#line 1853
      tmp___0 = getenv("LD_LIBRARY_PATH");
#line 1853
      is_done = foreach_dirinpath((char const   *)tmp___0, (char const   *)0, & foreachfile_callback,
                                  (void *)fpptr, data);
      }
    }
#line 1858
    if (! is_done) {
#line 1858
      if (sys_dlsearch_path[0]) {
        {
#line 1860
        is_done = foreach_dirinpath(sys_dlsearch_path, (char const   *)0, & foreachfile_callback,
                                    (void *)fpptr, data);
        }
      }
    }
  }
#line 1866
  return (is_done);
}
}
#line 1869 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlclose(lt_dlhandle handle ) 
{ 
  lt_dlhandle cur ;
  lt_dlhandle last ;
  int errors ;
  char const   *tmp ;
  lt_user_data data ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1873
  errors = 0;
#line 1876
  cur = handles;
#line 1876
  last = cur;
  {
#line 1877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1877
    if (cur) {
#line 1877
      if (! ((unsigned long )handle != (unsigned long )cur)) {
#line 1877
        goto while_break;
      }
    } else {
#line 1877
      goto while_break;
    }
#line 1879
    last = cur;
#line 1880
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1883
  if (! cur) {
    {
#line 1885
    tmp = lt__error_string(12);
#line 1885
    lt__set_last_error(tmp);
#line 1886
    errors ++;
    }
#line 1887
    goto done;
  }
#line 1890
  cur = handle;
#line 1891
  (cur->info.ref_count) --;
#line 1897
  if (cur->info.ref_count <= 0) {
#line 1897
    if (! cur->info.is_resident) {
#line 1899
      data = (lt_user_data )(cur->vtable)->dlloader_data;
#line 1901
      if ((unsigned long )cur != (unsigned long )handles) {
#line 1903
        last->next = cur->next;
      } else {
#line 1907
        handles = cur->next;
      }
      {
#line 1910
      tmp___0 = (*((cur->vtable)->module_close))(data, cur->module);
#line 1910
      errors += tmp___0;
#line 1911
      tmp___1 = unload_deplibs(handle);
#line 1911
      errors += tmp___1;
      }
#line 1914
      if (cur->interface_data) {
        {
#line 1914
        free((void *)cur->interface_data);
#line 1914
        cur->interface_data = (lt_interface_data *)((void *)0);
        }
      }
#line 1916
      if (cur->info.filename) {
        {
#line 1916
        free((void *)cur->info.filename);
#line 1916
        cur->info.filename = (char *)((void *)0);
        }
      }
#line 1917
      if (cur->info.name) {
        {
#line 1917
        free((void *)cur->info.name);
#line 1917
        cur->info.name = (char *)((void *)0);
        }
      }
#line 1918
      if (cur) {
        {
#line 1918
        free((void *)cur);
#line 1918
        cur = (lt_dlhandle )((void *)0);
        }
      }
#line 1920
      goto done;
    }
  }
#line 1923
  if (handle->info.is_resident) {
    {
#line 1925
    tmp___2 = lt__error_string(16);
#line 1925
    lt__set_last_error(tmp___2);
#line 1926
    errors ++;
    }
  }
  done: 
#line 1930
  return (errors);
}
}
#line 1933 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void *lt_dlsym(lt_dlhandle place , char const   *symbol ) 
{ 
  size_t lensym ;
  char lsym[128] ;
  char *sym ;
  void *address ;
  lt_user_data data ;
  lt_dlhandle handle ;
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  char const   *saved_error ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1943
  if (! place) {
    {
#line 1945
    tmp = lt__error_string(12);
#line 1945
    lt__set_last_error(tmp);
    }
#line 1946
    return ((void *)0);
  }
#line 1949
  handle = place;
#line 1951
  if (! symbol) {
    {
#line 1953
    tmp___0 = lt__error_string(10);
#line 1953
    lt__set_last_error(tmp___0);
    }
#line 1954
    return ((void *)0);
  }
#line 1957
  if (symbol) {
#line 1957
    if (*(symbol + 0)) {
      {
#line 1957
      tmp___1 = strlen(symbol);
#line 1957
      tmp___2 = tmp___1;
      }
    } else {
#line 1957
      tmp___2 = (size_t )0;
    }
  } else {
#line 1957
    tmp___2 = (size_t )0;
  }
#line 1957
  if ((handle->vtable)->sym_prefix) {
#line 1957
    if (*((handle->vtable)->sym_prefix + 0)) {
      {
#line 1957
      tmp___3 = strlen((char const   *)(handle->vtable)->sym_prefix);
#line 1957
      tmp___4 = tmp___3;
      }
    } else {
#line 1957
      tmp___4 = (size_t )0;
    }
  } else {
#line 1957
    tmp___4 = (size_t )0;
  }
#line 1957
  if (handle->info.name) {
#line 1957
    if (*(handle->info.name + 0)) {
      {
#line 1957
      tmp___5 = strlen((char const   *)handle->info.name);
#line 1957
      tmp___6 = tmp___5;
      }
    } else {
#line 1957
      tmp___6 = (size_t )0;
    }
  } else {
#line 1957
    tmp___6 = (size_t )0;
  }
#line 1957
  lensym = (tmp___2 + tmp___4) + tmp___6;
#line 1960
  if (lensym + 5U < 128U) {
#line 1962
    sym = lsym;
  } else {
    {
#line 1966
    tmp___7 = lt__malloc((size_t )((unsigned long )((lensym + 5U) + 1U) * sizeof(char )));
#line 1966
    sym = (char *)tmp___7;
    }
#line 1967
    if (! sym) {
      {
#line 1969
      tmp___8 = lt__error_string(13);
#line 1969
      lt__set_last_error(tmp___8);
      }
#line 1970
      return ((void *)0);
    }
  }
#line 1974
  data = (lt_user_data )(handle->vtable)->dlloader_data;
#line 1975
  if (handle->info.name) {
    {
#line 1979
    saved_error = lt__get_last_error();
    }
#line 1982
    if ((handle->vtable)->sym_prefix) {
      {
#line 1984
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->vtable)->sym_prefix);
#line 1985
      strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    } else {
      {
#line 1989
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    }
    {
#line 1992
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)"_LTX_");
#line 1993
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
#line 1996
    address = (*((handle->vtable)->find_sym))(data, handle->module, (char const   *)sym);
    }
#line 1997
    if (address) {
#line 1999
      if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 2001
        if (sym) {
          {
#line 2001
          free((void *)sym);
#line 2001
          sym = (char *)((void *)0);
          }
        }
      }
#line 2003
      return (address);
    }
    {
#line 2005
    lt__set_last_error(saved_error);
    }
  }
#line 2009
  if ((handle->vtable)->sym_prefix) {
    {
#line 2011
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->vtable)->sym_prefix);
#line 2012
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  } else {
    {
#line 2016
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  }
  {
#line 2019
  address = (*((handle->vtable)->find_sym))(data, handle->module, (char const   *)sym);
  }
#line 2020
  if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 2022
    if (sym) {
      {
#line 2022
      free((void *)sym);
#line 2022
      sym = (char *)((void *)0);
      }
    }
  }
#line 2025
  return (address);
}
}
#line 2028 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
char const   *lt_dlerror(void) 
{ 
  char const   *error ;
  char const   *tmp ;

  {
  {
#line 2033
  error = lt__get_last_error();
#line 2034
  lt__set_last_error((char const   *)0);
  }
#line 2036
  if (error) {
#line 2036
    tmp = error;
  } else {
#line 2036
    tmp = (char const   *)((void *)0);
  }
#line 2036
  return (tmp);
}
}
#line 2039 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) 
{ 
  int errors ;
  char *canonical ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 2042
  errors = 0;
#line 2043
  canonical = (char *)0;
#line 2044
  argz = (char *)0;
#line 2045
  argz_len = (size_t )0;
#line 2047
  if (! ppath) {
    {
#line 2047
    __assert_fail("ppath", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2047U, "lt_dlpath_insertdir");
    }
  }
#line 2048
  if (dir) {
#line 2048
    if (! *dir) {
      {
#line 2048
      __assert_fail("dir && *dir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2048U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2048
    __assert_fail("dir && *dir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2048U, "lt_dlpath_insertdir");
    }
  }
  {
#line 2050
  tmp = canonicalize_path(dir, & canonical);
  }
#line 2050
  if (tmp != 0) {
#line 2052
    errors ++;
#line 2053
    goto cleanup;
  }
#line 2056
  if (canonical) {
#line 2056
    if (! *canonical) {
      {
#line 2056
      __assert_fail("canonical && *canonical", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2056U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2056
    __assert_fail("canonical && *canonical", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2056U, "lt_dlpath_insertdir");
    }
  }
#line 2059
  if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 2061
    if (! (! before)) {
      {
#line 2061
      __assert_fail("!before", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2061U, "lt_dlpath_insertdir");
      }
    }
#line 2062
    if (! dir) {
      {
#line 2062
      __assert_fail("dir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2062U, "lt_dlpath_insertdir");
      }
    }
    {
#line 2064
    *ppath = lt__strdup(dir);
    }
#line 2065
    if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 2066
      errors ++;
    }
#line 2068
    goto cleanup;
  }
#line 2071
  if (ppath) {
#line 2071
    if (! *ppath) {
      {
#line 2071
      __assert_fail("ppath && *ppath", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2071U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2071
    __assert_fail("ppath && *ppath", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2071U, "lt_dlpath_insertdir");
    }
  }
  {
#line 2073
  tmp___0 = argzize_path((char const   *)*ppath, & argz, & argz_len);
  }
#line 2073
  if (tmp___0 != 0) {
#line 2075
    errors ++;
#line 2076
    goto cleanup;
  }
#line 2084
  if (before) {
#line 2086
    if (! ((unsigned long )*ppath <= (unsigned long )before)) {
      {
#line 2086
      __assert_fail("*ppath <= before", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2086U, "lt_dlpath_insertdir");
      }
    }
    {
#line 2087
    tmp___1 = strlen((char const   *)*ppath);
    }
#line 2087
    if (! ((int )(before - *ppath) <= (int )tmp___1)) {
      {
#line 2087
      __assert_fail("(int) (before - *ppath) <= (int) strlen (*ppath)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2087U, "lt_dlpath_insertdir");
      }
    }
#line 2089
    before = argz + (before - *ppath);
  }
  {
#line 2092
  tmp___2 = lt_argz_insert(& argz, & argz_len, before, dir);
  }
#line 2092
  if (tmp___2 != 0) {
#line 2094
    errors ++;
#line 2095
    goto cleanup;
  }
  {
#line 2098
  argz_stringify(argz, argz_len, ':');
  }
#line 2099
  if ((unsigned long )*ppath != (unsigned long )argz) {
#line 2099
    if (*ppath) {
      {
#line 2099
      free((void *)*ppath);
      }
    }
#line 2099
    *ppath = argz;
#line 2099
    argz = (char *)0;
  }
  cleanup: 
#line 2102
  if (argz) {
    {
#line 2102
    free((void *)argz);
#line 2102
    argz = (char *)((void *)0);
    }
  }
#line 2103
  if (canonical) {
    {
#line 2103
    free((void *)canonical);
#line 2103
    canonical = (char *)((void *)0);
    }
  }
#line 2105
  return (errors);
}
}
#line 2108 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladdsearchdir(char const   *search_dir ) 
{ 
  int errors ;
  int tmp ;

  {
#line 2111
  errors = 0;
#line 2113
  if (search_dir) {
#line 2113
    if (*search_dir) {
      {
#line 2115
      tmp = lt_dlpath_insertdir(& user_search_path, (char *)0, search_dir);
      }
#line 2115
      if (tmp != 0) {
#line 2116
        errors ++;
      }
    }
  }
#line 2119
  return (errors);
}
}
#line 2122 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) 
{ 
  int errors ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 2125
  errors = 0;
#line 2127
  if (before) {
#line 2129
    if ((unsigned long )before < (unsigned long )user_search_path) {
      {
#line 2132
      tmp = lt__error_string(18);
#line 2132
      lt__set_last_error(tmp);
      }
#line 2133
      return (1);
    } else {
#line 2129
      if (user_search_path) {
#line 2129
        if (*(user_search_path + 0)) {
          {
#line 2129
          tmp___0 = strlen((char const   *)user_search_path);
#line 2129
          tmp___1 = tmp___0;
          }
        } else {
#line 2129
          tmp___1 = (size_t )0;
        }
      } else {
#line 2129
        tmp___1 = (size_t )0;
      }
#line 2129
      if ((unsigned long )before >= (unsigned long )(user_search_path + tmp___1)) {
        {
#line 2132
        tmp = lt__error_string(18);
#line 2132
        lt__set_last_error(tmp);
        }
#line 2133
        return (1);
      }
    }
  }
#line 2137
  if (search_dir) {
#line 2137
    if (*search_dir) {
      {
#line 2139
      tmp___2 = lt_dlpath_insertdir(& user_search_path, (char *)before, search_dir);
      }
#line 2139
      if (tmp___2 != 0) {
#line 2142
        errors ++;
      }
    }
  }
#line 2146
  return (errors);
}
}
#line 2149 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlsetsearchpath(char const   *search_path ) 
{ 
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 2152
  errors = 0;
#line 2154
  if (user_search_path) {
    {
#line 2154
    free((void *)user_search_path);
#line 2154
    user_search_path = (char *)((void *)0);
    }
  }
#line 2156
  if (! search_path) {
#line 2158
    return (errors);
  } else {
#line 2156
    if (search_path) {
#line 2156
      if (*(search_path + 0)) {
        {
#line 2156
        tmp = strlen(search_path);
#line 2156
        tmp___0 = tmp;
        }
      } else {
#line 2156
        tmp___0 = (size_t )0;
      }
    } else {
#line 2156
      tmp___0 = (size_t )0;
    }
#line 2156
    if (! tmp___0) {
#line 2158
      return (errors);
    }
  }
  {
#line 2161
  tmp___1 = canonicalize_path(search_path, & user_search_path);
  }
#line 2161
  if (tmp___1 != 0) {
#line 2162
    errors ++;
  }
#line 2164
  return (errors);
}
}
#line 2167 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
char const   *lt_dlgetsearchpath(void) 
{ 
  char const   *saved_path ;

  {
#line 2172
  saved_path = (char const   *)user_search_path;
#line 2174
  return (saved_path);
}
}
#line 2177 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlmakeresident(lt_dlhandle handle ) 
{ 
  int errors ;
  char const   *tmp ;

  {
#line 2180
  errors = 0;
#line 2182
  if (! handle) {
    {
#line 2184
    tmp = lt__error_string(12);
#line 2184
    lt__set_last_error(tmp);
#line 2185
    errors ++;
    }
  } else {
#line 2189
    handle->info.is_resident = 1U;
  }
#line 2192
  return (errors);
}
}
#line 2195 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlisresident(lt_dlhandle handle ) 
{ 
  char const   *tmp ;

  {
#line 2198
  if (! handle) {
    {
#line 2200
    tmp = lt__error_string(12);
#line 2200
    lt__set_last_error(tmp);
    }
#line 2201
    return (-1);
  }
#line 2204
  return ((int )handle->info.is_resident);
}
}
#line 2216 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlinterface_id lt_dlinterface_register(char const   *id_string___0 , lt_dlhandle_interface *iface ) 
{ 
  lt__interface_id *interface_id ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 2219
  tmp = lt__malloc((size_t )sizeof(*interface_id));
#line 2219
  interface_id = (lt__interface_id *)tmp;
  }
#line 2223
  if (interface_id) {
    {
#line 2225
    tmp___0 = lt__strdup(id_string___0);
#line 2225
    interface_id->id_string = (char const   *)tmp___0;
    }
#line 2226
    if (! interface_id->id_string) {
#line 2227
      if (interface_id) {
        {
#line 2227
        free((void *)interface_id);
#line 2227
        interface_id = (lt__interface_id *)((void *)0);
        }
      }
    } else {
#line 2229
      interface_id->iface = iface;
    }
  }
#line 2232
  return ((lt_dlinterface_id )interface_id);
}
}
#line 2235 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void lt_dlinterface_free(lt_dlinterface_id key ) 
{ 
  lt__interface_id *interface_id ;

  {
#line 2237
  interface_id = (lt__interface_id *)key;
#line 2238
  if (interface_id->id_string) {
    {
#line 2238
    free((void *)interface_id->id_string);
#line 2238
    interface_id->id_string = (char const   *)((void *)0);
    }
  }
#line 2239
  if (interface_id) {
    {
#line 2239
    free((void *)interface_id);
#line 2239
    interface_id = (lt__interface_id *)((void *)0);
    }
  }
#line 2240
  return;
}
}
#line 2242 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) 
{ 
  int n_elements ;
  void *stale ;
  lt_dlhandle cur ;
  int i___0 ;
  lt_interface_data *temp ;
  void *tmp ;

  {
#line 2245
  n_elements = 0;
#line 2246
  stale = (void *)0;
#line 2247
  cur = handle;
#line 2250
  if (cur->interface_data) {
    {
#line 2251
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2251
      if (! (cur->interface_data + n_elements)->key) {
#line 2251
        goto while_break;
      }
#line 2252
      n_elements ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2254
  i___0 = 0;
  {
#line 2254
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2254
    if (! (i___0 < n_elements)) {
#line 2254
      goto while_break___0;
    }
#line 2256
    if ((unsigned long )(cur->interface_data + i___0)->key == (unsigned long )key) {
#line 2258
      stale = (cur->interface_data + i___0)->data;
#line 2259
      goto while_break___0;
    }
#line 2254
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2265
  if (i___0 == n_elements) {
    {
#line 2267
    tmp = lt__realloc((void *)cur->interface_data, (size_t )((unsigned long )(2 + n_elements) * sizeof(lt_interface_data )));
#line 2267
    temp = (lt_interface_data *)tmp;
    }
#line 2270
    if (! temp) {
#line 2272
      stale = (void *)0;
#line 2273
      goto done;
    }
#line 2276
    cur->interface_data = temp;
#line 2279
    (cur->interface_data + i___0)->key = key;
#line 2280
    (cur->interface_data + (1 + i___0))->key = (lt_dlinterface_id )0;
  }
#line 2283
  (cur->interface_data + i___0)->data = data;
  done: 
#line 2286
  return (stale);
}
}
#line 2289 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) 
{ 
  void *result ;
  lt_dlhandle cur ;
  int i___0 ;

  {
#line 2292
  result = (void *)0;
#line 2293
  cur = handle;
#line 2296
  if (cur->interface_data) {
#line 2299
    i___0 = 0;
    {
#line 2299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2299
      if (! (cur->interface_data + i___0)->key) {
#line 2299
        goto while_break;
      }
#line 2301
      if ((unsigned long )(cur->interface_data + i___0)->key == (unsigned long )key) {
#line 2303
        result = (cur->interface_data + i___0)->data;
#line 2304
        goto while_break;
      }
#line 2299
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2309
  return (result);
}
}
#line 2312 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) 
{ 
  char const   *tmp ;

  {
#line 2315
  if (! handle) {
    {
#line 2317
    tmp = lt__error_string(12);
#line 2317
    lt__set_last_error(tmp);
    }
#line 2318
    return ((lt_dlinfo const   *)0);
  }
#line 2321
  return ((lt_dlinfo const   *)(& handle->info));
}
}
#line 2325 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) 
{ 
  lt_dlhandle handle ;
  lt__interface_id *iterator ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2328
  handle = place;
#line 2329
  iterator = (lt__interface_id *)iface;
#line 2331
  if (! iface) {
    {
#line 2331
    __assert_fail("iface", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2331U, "lt_dlhandle_iterate");
    }
  }
#line 2333
  if (! handle) {
#line 2334
    handle = handles;
  } else {
#line 2336
    handle = handle->next;
  }
  {
#line 2339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2339
    if (handle) {
#line 2339
      if (iterator->iface) {
        {
#line 2339
        tmp = (*(iterator->iface))(handle, iterator->id_string);
        }
#line 2339
        if (! (tmp != 0)) {
#line 2339
          goto while_break;
        }
      } else {
#line 2339
        goto while_break;
      }
    } else {
#line 2339
      goto while_break;
    }
#line 2342
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2345
  return (handle);
}
}
#line 2349 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) 
{ 
  lt_dlhandle handle ;
  lt_dlhandle cur ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2352
  handle = (lt_dlhandle )0;
#line 2354
  if (! iface) {
    {
#line 2354
    __assert_fail("iface", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2354U, "lt_dlhandle_fetch");
    }
  }
  {
#line 2356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2356
    handle = lt_dlhandle_iterate(iface, handle);
    }
#line 2356
    if (! handle) {
#line 2356
      goto while_break;
    }
#line 2358
    cur = handle;
#line 2359
    if (cur) {
#line 2359
      if (cur->info.name) {
        {
#line 2359
        tmp = strcmp((char const   *)cur->info.name, module_name);
        }
#line 2359
        if (! tmp) {
#line 2360
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2363
  return (handle);
}
}
#line 2367 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle handle , void *data ) ,
                    void *data ) 
{ 
  lt__interface_id *iterator ;
  lt_dlhandle cur ;
  int errorcode ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2371
  iterator = (lt__interface_id *)iface;
#line 2372
  cur = handles;
#line 2374
  if (! iface) {
    {
#line 2374
    __assert_fail("iface", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2374U, "lt_dlhandle_map");
    }
  }
  {
#line 2376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2376
    if (! cur) {
#line 2376
      goto while_break;
    }
#line 2378
    errorcode = 0;
    {
#line 2381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2381
      if (cur) {
#line 2381
        if (iterator->iface) {
          {
#line 2381
          tmp = (*(iterator->iface))(cur, iterator->id_string);
          }
#line 2381
          if (! (tmp != 0)) {
#line 2381
            goto while_break___0;
          }
        } else {
#line 2381
          goto while_break___0;
        }
      } else {
#line 2381
        goto while_break___0;
      }
#line 2384
      cur = cur->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2387
    errorcode = (*func)(cur, data);
    }
#line 2387
    if (errorcode != 0) {
#line 2388
      return (errorcode);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2391
  return (0);
}
}
#line 79 "./libltdl/lt_error.h"
int lt_dladderror(char const   *diagnostic ) ;
#line 80
int lt_dlseterror(int errindex ) ;
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static char const   *last_error  =    (char const   *)0;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static char const   error_strings[20][42]  = 
#line 35
  { {        (char const   )'u',        (char const   )'n',        (char const   )'k',        (char const   )'n', 
            (char const   )'o',        (char const   )'w',        (char const   )'n',        (char const   )' ', 
            (char const   )'e',        (char const   )'r',        (char const   )'r',        (char const   )'o', 
            (char const   )'r',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'l',        (char const   )'o',        (char const   )'p', 
            (char const   )'e',        (char const   )'n',        (char const   )' ',        (char const   )'s', 
            (char const   )'u',        (char const   )'p',        (char const   )'p',        (char const   )'o', 
            (char const   )'r',        (char const   )'t',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'a', 
            (char const   )'v',        (char const   )'a',        (char const   )'i',        (char const   )'l', 
            (char const   )'a',        (char const   )'b',        (char const   )'l',        (char const   )'e', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'i', 
            (char const   )'n',        (char const   )'i',        (char const   )'t',        (char const   )'i', 
            (char const   )'a',        (char const   )'l',        (char const   )'i',        (char const   )'z', 
            (char const   )'a',        (char const   )'t',        (char const   )'i',        (char const   )'o', 
            (char const   )'n',        (char const   )' ',        (char const   )'f',        (char const   )'a', 
            (char const   )'i',        (char const   )'l',        (char const   )'e',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'r', 
            (char const   )'e',        (char const   )'m',        (char const   )'o',        (char const   )'v', 
            (char const   )'a',        (char const   )'l',        (char const   )' ',        (char const   )'f', 
            (char const   )'a',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'f',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )' ',        (char const   )'n',        (char const   )'o',        (char const   )'t', 
            (char const   )' ',        (char const   )'f',        (char const   )'o',        (char const   )'u', 
            (char const   )'n',        (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'e',        (char const   )'p',        (char const   )'e', 
            (char const   )'n',        (char const   )'d',        (char const   )'e',        (char const   )'n', 
            (char const   )'c',        (char const   )'y',        (char const   )' ',        (char const   )'l', 
            (char const   )'i',        (char const   )'b',        (char const   )'r',        (char const   )'a', 
            (char const   )'r',        (char const   )'y',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'f', 
            (char const   )'o',        (char const   )'u',        (char const   )'n',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'o',        (char const   )' ',        (char const   )'s', 
            (char const   )'y',        (char const   )'m',        (char const   )'b',        (char const   )'o', 
            (char const   )'l',        (char const   )'s',        (char const   )' ',        (char const   )'d', 
            (char const   )'e',        (char const   )'f',        (char const   )'i',        (char const   )'n', 
            (char const   )'e',        (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'o',        (char const   )'p', 
            (char const   )'e',        (char const   )'n',        (char const   )' ',        (char const   )'t', 
            (char const   )'h',        (char const   )'e',        (char const   )' ',        (char const   )'m', 
            (char const   )'o',        (char const   )'d',        (char const   )'u',        (char const   )'l', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'c',        (char const   )'l', 
            (char const   )'o',        (char const   )'s',        (char const   )'e',        (char const   )' ', 
            (char const   )'t',        (char const   )'h',        (char const   )'e',        (char const   )' ', 
            (char const   )'m',        (char const   )'o',        (char const   )'d',        (char const   )'u', 
            (char const   )'l',        (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'y',        (char const   )'m',        (char const   )'b', 
            (char const   )'o',        (char const   )'l',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'f', 
            (char const   )'o',        (char const   )'u',        (char const   )'n',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'o',        (char const   )'t',        (char const   )' ', 
            (char const   )'e',        (char const   )'n',        (char const   )'o',        (char const   )'u', 
            (char const   )'g',        (char const   )'h',        (char const   )' ',        (char const   )'m', 
            (char const   )'e',        (char const   )'m',        (char const   )'o',        (char const   )'r', 
            (char const   )'y',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'m',        (char const   )'o',        (char const   )'d',        (char const   )'u', 
            (char const   )'l',        (char const   )'e',        (char const   )' ',        (char const   )'h', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )'l', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )'n',        (char const   )'a',        (char const   )'l', 
            (char const   )' ',        (char const   )'b',        (char const   )'u',        (char const   )'f', 
            (char const   )'f',        (char const   )'e',        (char const   )'r',        (char const   )' ', 
            (char const   )'o',        (char const   )'v',        (char const   )'e',        (char const   )'r', 
            (char const   )'f',        (char const   )'l',        (char const   )'o',        (char const   )'w', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'e',        (char const   )'r',        (char const   )'r',        (char const   )'o', 
            (char const   )'r',        (char const   )'c',        (char const   )'o',        (char const   )'d', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'b',        (char const   )'r', 
            (char const   )'a',        (char const   )'r',        (char const   )'y',        (char const   )' ', 
            (char const   )'a',        (char const   )'l',        (char const   )'r',        (char const   )'e', 
            (char const   )'a',        (char const   )'d',        (char const   )'y',        (char const   )' ', 
            (char const   )'s',        (char const   )'h',        (char const   )'u',        (char const   )'t', 
            (char const   )'d',        (char const   )'o',        (char const   )'w',        (char const   )'n', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'c',        (char const   )'l', 
            (char const   )'o',        (char const   )'s',        (char const   )'e',        (char const   )' ', 
            (char const   )'r',        (char const   )'e',        (char const   )'s',        (char const   )'i', 
            (char const   )'d',        (char const   )'e',        (char const   )'n',        (char const   )'t', 
            (char const   )' ',        (char const   )'m',        (char const   )'o',        (char const   )'d', 
            (char const   )'u',        (char const   )'l',        (char const   )'e',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )'n',        (char const   )'a',        (char const   )'l', 
            (char const   )' ',        (char const   )'e',        (char const   )'r',        (char const   )'r', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'(', 
            (char const   )'c',        (char const   )'o',        (char const   )'d',        (char const   )'e', 
            (char const   )' ',        (char const   )'w',        (char const   )'i',        (char const   )'t', 
            (char const   )'h',        (char const   )'d',        (char const   )'r',        (char const   )'a', 
            (char const   )'w',        (char const   )'n',        (char const   )')',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'s',        (char const   )'e',        (char const   )'a',        (char const   )'r', 
            (char const   )'c',        (char const   )'h',        (char const   )' ',        (char const   )'p', 
            (char const   )'a',        (char const   )'t',        (char const   )'h',        (char const   )' ', 
            (char const   )'i',        (char const   )'n',        (char const   )'s',        (char const   )'e', 
            (char const   )'r',        (char const   )'t',        (char const   )' ',        (char const   )'p', 
            (char const   )'o',        (char const   )'s',        (char const   )'i',        (char const   )'t', 
            (char const   )'i',        (char const   )'o',        (char const   )'n',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'y',        (char const   )'m',        (char const   )'b', 
            (char const   )'o',        (char const   )'l',        (char const   )' ',        (char const   )'v', 
            (char const   )'i',        (char const   )'s',        (char const   )'i',        (char const   )'b', 
            (char const   )'i',        (char const   )'l',        (char const   )'i',        (char const   )'t', 
            (char const   )'y',        (char const   )' ',        (char const   )'c',        (char const   )'a', 
            (char const   )'n',        (char const   )' ',        (char const   )'b',        (char const   )'e', 
            (char const   )' ',        (char const   )'g',        (char const   )'l',        (char const   )'o', 
            (char const   )'b',        (char const   )'a',        (char const   )'l',        (char const   )' ', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'l', 
            (char const   )'o',        (char const   )'c',        (char const   )'a',        (char const   )'l', 
            (char const   )'\000',        (char const   )'\000'}};
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static char const   **user_error_strings  =    (char const   **)0;
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static int errorcount  =    20;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
int lt_dladderror(char const   *diagnostic ) 
{ 
  int errindex ;
  int result ;
  char const   **temp ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 48
  errindex = 0;
#line 49
  result = -1;
#line 50
  temp = (char const   **)0;
#line 52
  if (! diagnostic) {
    {
#line 52
    __assert_fail("diagnostic", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c",
                  52U, "lt_dladderror");
    }
  }
  {
#line 54
  errindex = errorcount - 20;
#line 55
  tmp = lt__realloc((void *)user_error_strings, (size_t )((unsigned long )(1 + errindex) * sizeof(char const   *)));
#line 55
  temp = (char const   **)tmp;
  }
#line 56
  if (temp) {
#line 58
    user_error_strings = temp;
#line 59
    *(user_error_strings + errindex) = diagnostic;
#line 60
    tmp___0 = errorcount;
#line 60
    errorcount ++;
#line 60
    result = tmp___0;
  }
#line 63
  return (result);
}
}
#line 66 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
int lt_dlseterror(int errindex ) 
{ 
  int errors ;
  char const   *tmp ;

  {
#line 69
  errors = 0;
#line 71
  if (errindex >= errorcount) {
    {
#line 74
    tmp = lt__error_string(14);
#line 74
    lt__set_last_error(tmp);
#line 75
    errors ++;
    }
  } else
#line 71
  if (errindex < 0) {
    {
#line 74
    tmp = lt__error_string(14);
#line 74
    lt__set_last_error(tmp);
#line 75
    errors ++;
    }
  } else
#line 77
  if (errindex < 20) {
    {
#line 80
    lt__set_last_error(error_strings[errindex]);
    }
  } else {
    {
#line 85
    lt__set_last_error(*(user_error_strings + (errindex - 20)));
    }
  }
#line 88
  return (errors);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
char const   *lt__error_string(int errorcode ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 94
  if (! (errorcode >= 0)) {
    {
#line 94
    __assert_fail("errorcode >= 0", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c",
                  94U, "lt__error_string");
    }
  }
#line 95
  if (! (errorcode < 20)) {
    {
#line 95
    __assert_fail("errorcode < LT_ERROR_MAX", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c",
                  95U, "lt__error_string");
    }
  }
#line 97
  return (error_strings[errorcode]);
}
}
#line 100 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
char const   *lt__get_last_error(void) 
{ 


  {
#line 103
  return (last_error);
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
char const   *lt__set_last_error(char const   *errormsg ) 
{ 


  {
#line 109
  last_error = errormsg;
#line 109
  return (last_error);
}
}
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static void *loader_callback(SList *item , void *userdata ) ;
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static SList *loaders  =    (SList *)0;
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static void *loader_callback(SList *item , void *userdata ) 
{ 
  lt_dlvtable const   *vtable___1 ;
  char const   *name ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 50
  vtable___1 = (lt_dlvtable const   *)item->userdata;
#line 51
  name = (char const   *)userdata;
#line 53
  if (! vtable___1) {
    {
#line 53
    __assert_fail("vtable", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c",
                  53U, "loader_callback");
    }
  }
  {
#line 55
  tmp___1 = strcmp((char const   *)vtable___1->name, name);
  }
#line 55
  if (tmp___1) {
#line 55
    tmp___0 = (void *)0;
  } else {
#line 55
    tmp___0 = (void *)item;
  }
#line 55
  return (tmp___0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
int lt_dlloader_add(lt_dlvtable const   *vtable___1 ) 
{ 
  SList *item ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 66
  if ((unsigned long )vtable___1 == (unsigned long )((lt_dlvtable const   *)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___1->module_open == (unsigned long )((lt_module_open */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___1->module_close == (unsigned long )((lt_module_close */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___1->find_sym == (unsigned long )((lt_find_sym */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned int const   )vtable___1->priority != 0U) {
#line 66
    if ((unsigned int const   )vtable___1->priority != 1U) {
      {
#line 73
      tmp = lt__error_string(2);
#line 73
      lt__set_last_error(tmp);
      }
#line 74
      return (1);
    }
  }
  {
#line 77
  item = lt__slist_box((void const   *)vtable___1);
  }
#line 78
  if (! item) {
    {
#line 80
    (*lt__alloc_die)();
    }
#line 84
    return (1);
  }
#line 87
  if ((unsigned int const   )vtable___1->priority == 0U) {
    {
#line 89
    loaders = lt__slist_cons(item, loaders);
    }
  } else {
#line 93
    if (! ((unsigned int const   )vtable___1->priority == 1U)) {
      {
#line 93
      __assert_fail("vtable->priority == LT_DLLOADER_APPEND", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c",
                    93U, "lt_dlloader_add");
      }
    }
    {
#line 94
    loaders = lt__slist_concat(loaders, item);
    }
  }
#line 97
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlloader lt_dlloader_next(lt_dlloader const   loader ) 
{ 
  SList *item ;
  struct slist *tmp ;

  {
#line 133
  item = (SList *)loader;
#line 134
  if (item) {
#line 134
    tmp = item->next;
  } else {
#line 134
    tmp = loaders;
  }
#line 134
  return ((lt_dlloader )tmp);
}
}
#line 139 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlvtable const   *lt_dlloader_get(lt_dlloader loader ) 
{ 
  void const   *tmp ;

  {
#line 142
  if (loader) {
#line 142
    tmp = ((SList *)loader)->userdata;
  } else {
#line 142
    tmp = (void const   *)((void *)0);
  }
#line 142
  return ((lt_dlvtable const   *)tmp);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static char const   id_string[19]  = 
#line 156
  {      (char const   )'l',      (char const   )'t',      (char const   )'_',      (char const   )'d', 
        (char const   )'l',      (char const   )'l',      (char const   )'o',      (char const   )'a', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'\000'};
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlvtable *lt_dlloader_remove(char *name ) 
{ 
  lt_dlvtable const   *vtable___1 ;
  lt_dlvtable const   *tmp ;
  lt_dlinterface_id iface ;
  lt_dlhandle handle ;
  int in_use ;
  int in_use_by_resident ;
  char const   *tmp___0 ;
  lt_dlhandle cur ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 155
  tmp = lt_dlloader_find(name);
#line 155
  vtable___1 = tmp;
#line 158
  handle = (lt_dlhandle )0;
#line 159
  in_use = 0;
#line 160
  in_use_by_resident = 0;
  }
#line 162
  if (! vtable___1) {
    {
#line 164
    tmp___0 = lt__error_string(2);
#line 164
    lt__set_last_error(tmp___0);
    }
#line 165
    return ((lt_dlvtable *)0);
  }
  {
#line 169
  iface = lt_dlinterface_register(id_string, (lt_dlhandle_interface *)((void *)0));
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    handle = lt_dlhandle_iterate(iface, handle);
    }
#line 170
    if (! handle) {
#line 170
      goto while_break;
    }
#line 172
    cur = handle;
#line 173
    if ((unsigned long )cur->vtable == (unsigned long )vtable___1) {
      {
#line 175
      in_use = 1;
#line 176
      tmp___1 = lt_dlisresident(handle);
      }
#line 176
      if (tmp___1) {
#line 177
        in_use_by_resident = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  lt_dlinterface_free(iface);
  }
#line 181
  if (in_use) {
#line 183
    if (! in_use_by_resident) {
      {
#line 184
      tmp___2 = lt__error_string(4);
#line 184
      lt__set_last_error(tmp___2);
      }
    }
#line 185
    return ((lt_dlvtable *)0);
  }
#line 189
  if (vtable___1) {
#line 189
    if (vtable___1->dlloader_exit) {
      {
#line 191
      tmp___3 = (*(vtable___1->dlloader_exit))((lt_user_data )vtable___1->dlloader_data);
      }
#line 191
      if (tmp___3 != 0) {
#line 196
        return ((lt_dlvtable *)0);
      }
    }
  }
  {
#line 201
  tmp___4 = lt__slist_remove(& loaders, & loader_callback, (void *)name);
#line 201
  tmp___5 = lt__slist_unbox((SList *)tmp___4);
  }
#line 201
  return ((lt_dlvtable *)tmp___5);
}
}
#line 206 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlvtable const   *lt_dlloader_find(char *name ) 
{ 
  void *tmp ;
  lt_dlvtable const   *tmp___0 ;

  {
  {
#line 209
  tmp = lt__slist_find(loaders, & loader_callback, (void *)name);
#line 209
  tmp___0 = lt_dlloader_get(tmp);
  }
#line 209
  return (tmp___0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 52 "libltdl/lt__alloc.h"
void *lt__memdup(void const   *mem , size_t n ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
static void alloc_die_default(void) ;
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void (*lt__alloc_die)(void)  =    & alloc_die_default;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
static void alloc_die_default(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 46
  exit(1);
  }
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__malloc(size_t n ) 
{ 
  void *mem ;

  {
  {
#line 54
  mem = malloc(n);
  }
#line 54
  if (! mem) {
    {
#line 55
    (*lt__alloc_die)();
    }
  }
#line 57
  return (mem);
}
}
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__zalloc(size_t n ) 
{ 
  void *mem ;

  {
  {
#line 65
  mem = lt__malloc(n);
  }
#line 65
  if (mem) {
    {
#line 66
    memset(mem, 0, n);
    }
  }
#line 68
  return (mem);
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__realloc(void *mem , size_t n ) 
{ 


  {
  {
#line 74
  mem = realloc(mem, n);
  }
#line 74
  if (! mem) {
    {
#line 75
    (*lt__alloc_die)();
    }
  }
#line 77
  return (mem);
}
}
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__memdup(void const   *mem , size_t n ) 
{ 
  void *newmem ;
  void *tmp ;

  {
  {
#line 85
  newmem = lt__malloc(n);
  }
#line 85
  if (newmem) {
    {
#line 86
    tmp = memcpy((void */* __restrict  */)newmem, (void const   */* __restrict  */)mem,
                 n);
    }
#line 86
    return (tmp);
  }
#line 88
  return ((void *)0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
char *lt__strdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 94
  tmp = strlen(string);
#line 94
  tmp___0 = lt__memdup((void const   *)string, tmp + 1U);
  }
#line 94
  return ((char *)tmp___0);
}
}
#line 9 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/.libs/libltdlcS.c"
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/.libs/libltdlcS.c"
#line 20 "../include/dico/util.h"
char *dico_full_file_name(char const   *dir , char const   *file ) ;
#line 21
size_t dico_trim_nl(char *buf___1 ) ;
#line 22
size_t dico_trim_ws(char *buf___1 ) ;
#line 22 "../include/dico/markup.h"
char const   *dico_markup_type  ;
#line 23 "../include/dico/markup.h"
dico_list_t dico_markup_list  ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
size_t dico_string_trim(char *buf___1 , size_t len___0 , int (*pred)(int c ) ) 
{ 
  int tmp ;

  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (len___0 > 0U) {
      {
#line 29
      tmp = (*pred)((int )*(buf___1 + (len___0 - 1U)));
      }
#line 29
      if (! tmp) {
#line 29
        goto while_break;
      }
    } else {
#line 29
      goto while_break;
    }
#line 30
    len___0 --;
#line 30
    *(buf___1 + len___0) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  return (len___0);
}
}
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
static int _is_nl(int c ) 
{ 
  int tmp ;

  {
#line 37
  if (c == 13) {
#line 37
    tmp = 1;
  } else
#line 37
  if (c == 10) {
#line 37
    tmp = 1;
  } else {
#line 37
    tmp = 0;
  }
#line 37
  return (tmp);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
size_t dico_trim_nl(char *buf___1 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 43
  tmp = strlen((char const   *)buf___1);
#line 43
  tmp___0 = dico_string_trim(buf___1, tmp, & _is_nl);
  }
#line 43
  return (tmp___0);
}
}
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
static int _is_ws(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 49
  tmp = __ctype_b_loc();
  }
#line 49
  return ((int )((int const   )*(*tmp + c) & 8192));
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
size_t dico_trim_ws(char *buf___1 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 55
  tmp = strlen((char const   *)buf___1);
#line 55
  tmp___0 = dico_string_trim(buf___1, tmp, & _is_ws);
  }
#line 55
  return (tmp___0);
}
}
#line 58 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
char *dico_full_file_name(char const   *dir , char const   *file ) 
{ 
  size_t dirlen ;
  size_t tmp ;
  int need_slash ;
  int tmp___0 ;
  size_t size ;
  size_t tmp___1 ;
  char *buf___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp12 ;

  {
  {
#line 61
  tmp = strlen(dir);
#line 61
  dirlen = tmp;
  }
#line 62
  if (dirlen) {
#line 62
    if ((int const   )*(dir + (dirlen - 1U)) == 47) {
#line 62
      tmp___0 = 0;
    } else {
#line 62
      tmp___0 = 1;
    }
  } else {
#line 62
    tmp___0 = 1;
  }
  {
#line 62
  need_slash = tmp___0;
#line 63
  tmp___1 = strlen(file);
#line 63
  size = (((dirlen + (size_t )need_slash) + 1U) + tmp___1) + 1U;
#line 64
  tmp___2 = malloc(size);
#line 64
  buf___1 = (char *)tmp___2;
  }
#line 66
  if (! buf___1) {
#line 67
    return ((char *)((void *)0));
  }
  {
#line 69
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dir);
  }
#line 70
  if (need_slash) {
    {
#line 71
    tmp___3 = dirlen;
#line 71
    dirlen ++;
#line 71
    strcpy((char */* __restrict  */)(buf___1 + tmp___3), (char const   */* __restrict  */)"/");
    }
  } else {
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (dirlen > 0U) {
#line 73
        if (! ((int )*(buf___1 + (dirlen - 1U)) == 47)) {
#line 73
          goto while_break;
        }
      } else {
#line 73
        goto while_break;
      }
#line 74
      dirlen --;
    }
    while_break: /* CIL Label */ ;
    }
#line 75
    dirlen ++;
  }
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    if (! ((int const   )*file == 47)) {
#line 77
      goto while_break___0;
    }
#line 78
    file ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 79
  strcpy((char */* __restrict  */)(buf___1 + dirlen), (char const   */* __restrict  */)file);
  }
#line 80
  return (buf___1);
}
}
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 22 "../include/dico/utf8.h"
size_t utf8_char_width(unsigned char const   *p ) ;
#line 23
size_t utf8_strlen(char const   *s ) ;
#line 35
int utf8_iter_end_p(struct utf8_iterator *itr ) ;
#line 36
int utf8_iter_first(struct utf8_iterator *itr , unsigned char *ptr ) ;
#line 37
int utf8_iter_next(struct utf8_iterator *itr ) ;
#line 39
int utf8_mbtowc_internal(void *data , int (*read___0)(void * ) , unsigned int *pwc ) ;
#line 40
int utf8_wctomb(unsigned char *r , unsigned int wc ) ;
#line 42
int utf8_symcmp(unsigned char *a , unsigned char *b ) ;
#line 44
int utf8_strcasecmp(unsigned char *a , unsigned char *b ) ;
#line 45
int utf8_strncasecmp(unsigned char *a , unsigned char *b , size_t maxlen ) ;
#line 47
unsigned int utf8_wc_toupper(unsigned int wc ) ;
#line 48
int utf8_toupper(char *s , size_t len___0 ) ;
#line 49
unsigned int utf8_wc_tolower(unsigned int wc ) ;
#line 50
int utf8_tolower(char *s , size_t len___0 ) ;
#line 51
size_t utf8_wc_strlen(unsigned int const   *s ) ;
#line 52
unsigned int *utf8_wc_strdup(unsigned int const   *s ) ;
#line 53
size_t utf8_wc_hash_string(unsigned int const   *ws , size_t n_buckets ) ;
#line 54
int utf8_wc_strcmp(unsigned int const   *a , unsigned int const   *b ) ;
#line 55
int utf8_wc_to_mbstr(unsigned int const   *wordbuf , size_t wordlen , char **sptr ) ;
#line 57
int utf8_mbstr_to_wc(char const   *str , unsigned int **wptr ) ;
#line 58
int utf8_mbstr_to_norm_wc(char const   *str , unsigned int **nptr ) ;
#line 60
int utf8_quote(char const   *str , char **sptr ) ;
#line 61
unsigned int *utf8_wc_quote(unsigned int const   *s ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane00[256]  = 
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
  {      {0U, 0U, 0U}, 
        {1U, 1U, 1U}, 
        {2U, 2U, 2U}, 
        {3U, 3U, 3U}, 
        {4U, 4U, 4U}, 
        {5U, 5U, 5U}, 
        {6U, 6U, 6U}, 
        {7U, 7U, 7U}, 
        {8U, 8U, 8U}, 
        {9U, 9U, 9U}, 
        {10U, 10U, 10U}, 
        {11U, 11U, 11U}, 
        {12U, 12U, 12U}, 
        {13U, 13U, 13U}, 
        {14U, 14U, 14U}, 
        {15U, 15U, 15U}, 
        {16U, 16U, 16U}, 
        {17U, 17U, 17U}, 
        {18U, 18U, 18U}, 
        {19U, 19U, 19U}, 
        {20U, 20U, 20U}, 
        {21U, 21U, 21U}, 
        {22U, 22U, 22U}, 
        {23U, 23U, 23U}, 
        {24U, 24U, 24U}, 
        {25U, 25U, 25U}, 
        {26U, 26U, 26U}, 
        {27U, 27U, 27U}, 
        {28U, 28U, 28U}, 
        {29U, 29U, 29U}, 
        {30U, 30U, 30U}, 
        {31U, 31U, 31U}, 
        {32U, 32U, 32U}, 
        {33U, 33U, 33U}, 
        {34U, 34U, 34U}, 
        {35U, 35U, 35U}, 
        {36U, 36U, 36U}, 
        {37U, 37U, 37U}, 
        {38U, 38U, 38U}, 
        {39U, 39U, 39U}, 
        {40U, 40U, 40U}, 
        {41U, 41U, 41U}, 
        {42U, 42U, 42U}, 
        {43U, 43U, 43U}, 
        {44U, 44U, 44U}, 
        {45U, 45U, 45U}, 
        {46U, 46U, 46U}, 
        {47U, 47U, 47U}, 
        {48U, 48U, 48U}, 
        {49U, 49U, 49U}, 
        {50U, 50U, 50U}, 
        {51U, 51U, 51U}, 
        {52U, 52U, 52U}, 
        {53U, 53U, 53U}, 
        {54U, 54U, 54U}, 
        {55U, 55U, 55U}, 
        {56U, 56U, 56U}, 
        {57U, 57U, 57U}, 
        {58U, 58U, 58U}, 
        {59U, 59U, 59U}, 
        {60U, 60U, 60U}, 
        {61U, 61U, 61U}, 
        {62U, 62U, 62U}, 
        {63U, 63U, 63U}, 
        {64U, 64U, 64U}, 
        {65U, 97U, 65U}, 
        {66U, 98U, 66U}, 
        {67U, 99U, 67U}, 
        {68U, 100U, 68U}, 
        {69U, 101U, 69U}, 
        {70U, 102U, 70U}, 
        {71U, 103U, 71U}, 
        {72U, 104U, 72U}, 
        {73U, 105U, 73U}, 
        {74U, 106U, 74U}, 
        {75U, 107U, 75U}, 
        {76U, 108U, 76U}, 
        {77U, 109U, 77U}, 
        {78U, 110U, 78U}, 
        {79U, 111U, 79U}, 
        {80U, 112U, 80U}, 
        {81U, 113U, 81U}, 
        {82U, 114U, 82U}, 
        {83U, 115U, 83U}, 
        {84U, 116U, 84U}, 
        {85U, 117U, 85U}, 
        {86U, 118U, 86U}, 
        {87U, 119U, 87U}, 
        {88U, 120U, 88U}, 
        {89U, 121U, 89U}, 
        {90U, 122U, 90U}, 
        {91U, 91U, 91U}, 
        {92U, 92U, 92U}, 
        {93U, 93U, 93U}, 
        {94U, 94U, 94U}, 
        {95U, 95U, 95U}, 
        {96U, 96U, 96U}, 
        {65U, 97U, 65U}, 
        {66U, 98U, 66U}, 
        {67U, 99U, 67U}, 
        {68U, 100U, 68U}, 
        {69U, 101U, 69U}, 
        {70U, 102U, 70U}, 
        {71U, 103U, 71U}, 
        {72U, 104U, 72U}, 
        {73U, 105U, 73U}, 
        {74U, 106U, 74U}, 
        {75U, 107U, 75U}, 
        {76U, 108U, 76U}, 
        {77U, 109U, 77U}, 
        {78U, 110U, 78U}, 
        {79U, 111U, 79U}, 
        {80U, 112U, 80U}, 
        {81U, 113U, 81U}, 
        {82U, 114U, 82U}, 
        {83U, 115U, 83U}, 
        {84U, 116U, 84U}, 
        {85U, 117U, 85U}, 
        {86U, 118U, 86U}, 
        {87U, 119U, 87U}, 
        {88U, 120U, 88U}, 
        {89U, 121U, 89U}, 
        {90U, 122U, 90U}, 
        {123U, 123U, 123U}, 
        {124U, 124U, 124U}, 
        {125U, 125U, 125U}, 
        {126U, 126U, 126U}, 
        {127U, 127U, 127U}, 
        {128U, 128U, 128U}, 
        {129U, 129U, 129U}, 
        {130U, 130U, 130U}, 
        {131U, 131U, 131U}, 
        {132U, 132U, 132U}, 
        {133U, 133U, 133U}, 
        {134U, 134U, 134U}, 
        {135U, 135U, 135U}, 
        {136U, 136U, 136U}, 
        {137U, 137U, 137U}, 
        {138U, 138U, 138U}, 
        {139U, 139U, 139U}, 
        {140U, 140U, 140U}, 
        {141U, 141U, 141U}, 
        {142U, 142U, 142U}, 
        {143U, 143U, 143U}, 
        {144U, 144U, 144U}, 
        {145U, 145U, 145U}, 
        {146U, 146U, 146U}, 
        {147U, 147U, 147U}, 
        {148U, 148U, 148U}, 
        {149U, 149U, 149U}, 
        {150U, 150U, 150U}, 
        {151U, 151U, 151U}, 
        {152U, 152U, 152U}, 
        {153U, 153U, 153U}, 
        {154U, 154U, 154U}, 
        {155U, 155U, 155U}, 
        {156U, 156U, 156U}, 
        {157U, 157U, 157U}, 
        {158U, 158U, 158U}, 
        {159U, 159U, 159U}, 
        {160U, 160U, 160U}, 
        {161U, 161U, 161U}, 
        {162U, 162U, 162U}, 
        {163U, 163U, 163U}, 
        {164U, 164U, 164U}, 
        {165U, 165U, 165U}, 
        {166U, 166U, 166U}, 
        {167U, 167U, 167U}, 
        {168U, 168U, 168U}, 
        {169U, 169U, 169U}, 
        {170U, 170U, 170U}, 
        {171U, 171U, 171U}, 
        {172U, 172U, 172U}, 
        {173U, 173U, 173U}, 
        {174U, 174U, 174U}, 
        {175U, 175U, 175U}, 
        {176U, 176U, 176U}, 
        {177U, 177U, 177U}, 
        {178U, 178U, 178U}, 
        {179U, 179U, 179U}, 
        {180U, 180U, 180U}, 
        {924U, 181U, 924U}, 
        {182U, 182U, 182U}, 
        {183U, 183U, 183U}, 
        {184U, 184U, 184U}, 
        {185U, 185U, 185U}, 
        {186U, 186U, 186U}, 
        {187U, 187U, 187U}, 
        {188U, 188U, 188U}, 
        {189U, 189U, 189U}, 
        {190U, 190U, 190U}, 
        {191U, 191U, 191U}, 
        {192U, 224U, 65U}, 
        {193U, 225U, 65U}, 
        {194U, 226U, 65U}, 
        {195U, 227U, 65U}, 
        {196U, 228U, 65U}, 
        {197U, 229U, 65U}, 
        {198U, 230U, 198U}, 
        {199U, 231U, 67U}, 
        {200U, 232U, 69U}, 
        {201U, 233U, 69U}, 
        {202U, 234U, 69U}, 
        {203U, 235U, 69U}, 
        {204U, 236U, 73U}, 
        {205U, 237U, 73U}, 
        {206U, 238U, 73U}, 
        {207U, 239U, 73U}, 
        {208U, 240U, 208U}, 
        {209U, 241U, 78U}, 
        {210U, 242U, 79U}, 
        {211U, 243U, 79U}, 
        {212U, 244U, 79U}, 
        {213U, 245U, 79U}, 
        {214U, 246U, 79U}, 
        {215U, 215U, 215U}, 
        {216U, 248U, 216U}, 
        {217U, 249U, 85U}, 
        {218U, 250U, 85U}, 
        {219U, 251U, 85U}, 
        {220U, 252U, 85U}, 
        {221U, 253U, 89U}, 
        {222U, 254U, 222U}, 
        {223U, 223U, 223U}, 
        {192U, 224U, 65U}, 
        {193U, 225U, 65U}, 
        {194U, 226U, 65U}, 
        {195U, 227U, 65U}, 
        {196U, 228U, 65U}, 
        {197U, 229U, 65U}, 
        {198U, 230U, 198U}, 
        {199U, 231U, 67U}, 
        {200U, 232U, 69U}, 
        {201U, 233U, 69U}, 
        {202U, 234U, 69U}, 
        {203U, 235U, 69U}, 
        {204U, 236U, 73U}, 
        {205U, 237U, 73U}, 
        {206U, 238U, 73U}, 
        {207U, 239U, 73U}, 
        {208U, 240U, 208U}, 
        {209U, 241U, 78U}, 
        {210U, 242U, 79U}, 
        {211U, 243U, 79U}, 
        {212U, 244U, 79U}, 
        {213U, 245U, 79U}, 
        {214U, 246U, 79U}, 
        {247U, 247U, 247U}, 
        {216U, 248U, 216U}, 
        {217U, 249U, 85U}, 
        {218U, 250U, 85U}, 
        {219U, 251U, 85U}, 
        {220U, 252U, 85U}, 
        {221U, 253U, 89U}, 
        {222U, 254U, 222U}, 
        {376U, 255U, 89U}};
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane01[256]  = 
#line 166
  {      {256U, 257U, 65U}, 
        {256U, 257U, 65U}, 
        {258U, 259U, 65U}, 
        {258U, 259U, 65U}, 
        {260U, 261U, 65U}, 
        {260U, 261U, 65U}, 
        {262U, 263U, 67U}, 
        {262U, 263U, 67U}, 
        {264U, 265U, 67U}, 
        {264U, 265U, 67U}, 
        {266U, 267U, 67U}, 
        {266U, 267U, 67U}, 
        {268U, 269U, 67U}, 
        {268U, 269U, 67U}, 
        {270U, 271U, 68U}, 
        {270U, 271U, 68U}, 
        {272U, 273U, 272U}, 
        {272U, 273U, 272U}, 
        {274U, 275U, 69U}, 
        {274U, 275U, 69U}, 
        {276U, 277U, 69U}, 
        {276U, 277U, 69U}, 
        {278U, 279U, 69U}, 
        {278U, 279U, 69U}, 
        {280U, 281U, 69U}, 
        {280U, 281U, 69U}, 
        {282U, 283U, 69U}, 
        {282U, 283U, 69U}, 
        {284U, 285U, 71U}, 
        {284U, 285U, 71U}, 
        {286U, 287U, 71U}, 
        {286U, 287U, 71U}, 
        {288U, 289U, 71U}, 
        {288U, 289U, 71U}, 
        {290U, 291U, 71U}, 
        {290U, 291U, 71U}, 
        {292U, 293U, 72U}, 
        {292U, 293U, 72U}, 
        {294U, 295U, 294U}, 
        {294U, 295U, 294U}, 
        {296U, 297U, 73U}, 
        {296U, 297U, 73U}, 
        {298U, 299U, 73U}, 
        {298U, 299U, 73U}, 
        {300U, 301U, 73U}, 
        {300U, 301U, 73U}, 
        {302U, 303U, 73U}, 
        {302U, 303U, 73U}, 
        {304U, 105U, 73U}, 
        {73U, 305U, 73U}, 
        {306U, 307U, 306U}, 
        {306U, 307U, 306U}, 
        {308U, 309U, 74U}, 
        {308U, 309U, 74U}, 
        {310U, 311U, 75U}, 
        {310U, 311U, 75U}, 
        {312U, 312U, 312U}, 
        {313U, 314U, 76U}, 
        {313U, 314U, 76U}, 
        {315U, 316U, 76U}, 
        {315U, 316U, 76U}, 
        {317U, 318U, 76U}, 
        {317U, 318U, 76U}, 
        {319U, 320U, 319U}, 
        {319U, 320U, 319U}, 
        {321U, 322U, 321U}, 
        {321U, 322U, 321U}, 
        {323U, 324U, 78U}, 
        {323U, 324U, 78U}, 
        {325U, 326U, 78U}, 
        {325U, 326U, 78U}, 
        {327U, 328U, 78U}, 
        {327U, 328U, 78U}, 
        {329U, 329U, 329U}, 
        {330U, 331U, 330U}, 
        {330U, 331U, 330U}, 
        {332U, 333U, 79U}, 
        {332U, 333U, 79U}, 
        {334U, 335U, 79U}, 
        {334U, 335U, 79U}, 
        {336U, 337U, 79U}, 
        {336U, 337U, 79U}, 
        {338U, 339U, 338U}, 
        {338U, 339U, 338U}, 
        {340U, 341U, 82U}, 
        {340U, 341U, 82U}, 
        {342U, 343U, 82U}, 
        {342U, 343U, 82U}, 
        {344U, 345U, 82U}, 
        {344U, 345U, 82U}, 
        {346U, 347U, 83U}, 
        {346U, 347U, 83U}, 
        {348U, 349U, 83U}, 
        {348U, 349U, 83U}, 
        {350U, 351U, 83U}, 
        {350U, 351U, 83U}, 
        {352U, 353U, 83U}, 
        {352U, 353U, 83U}, 
        {354U, 355U, 84U}, 
        {354U, 355U, 84U}, 
        {356U, 357U, 84U}, 
        {356U, 357U, 84U}, 
        {358U, 359U, 358U}, 
        {358U, 359U, 358U}, 
        {360U, 361U, 85U}, 
        {360U, 361U, 85U}, 
        {362U, 363U, 85U}, 
        {362U, 363U, 85U}, 
        {364U, 365U, 85U}, 
        {364U, 365U, 85U}, 
        {366U, 367U, 85U}, 
        {366U, 367U, 85U}, 
        {368U, 369U, 85U}, 
        {368U, 369U, 85U}, 
        {370U, 371U, 85U}, 
        {370U, 371U, 85U}, 
        {372U, 373U, 87U}, 
        {372U, 373U, 87U}, 
        {374U, 375U, 89U}, 
        {374U, 375U, 89U}, 
        {376U, 255U, 89U}, 
        {377U, 378U, 90U}, 
        {377U, 378U, 90U}, 
        {379U, 380U, 90U}, 
        {379U, 380U, 90U}, 
        {381U, 382U, 90U}, 
        {381U, 382U, 90U}, 
        {83U, 383U, 83U}, 
        {384U, 384U, 384U}, 
        {385U, 595U, 385U}, 
        {386U, 387U, 386U}, 
        {386U, 387U, 386U}, 
        {388U, 389U, 388U}, 
        {388U, 389U, 388U}, 
        {390U, 596U, 390U}, 
        {391U, 392U, 391U}, 
        {391U, 392U, 391U}, 
        {393U, 598U, 393U}, 
        {394U, 599U, 394U}, 
        {395U, 396U, 395U}, 
        {395U, 396U, 395U}, 
        {397U, 397U, 397U}, 
        {398U, 477U, 398U}, 
        {399U, 601U, 399U}, 
        {400U, 603U, 400U}, 
        {401U, 402U, 401U}, 
        {401U, 402U, 401U}, 
        {403U, 608U, 403U}, 
        {404U, 611U, 404U}, 
        {502U, 405U, 502U}, 
        {406U, 617U, 406U}, 
        {407U, 616U, 407U}, 
        {408U, 409U, 408U}, 
        {408U, 409U, 408U}, 
        {410U, 410U, 410U}, 
        {411U, 411U, 411U}, 
        {412U, 623U, 412U}, 
        {413U, 626U, 413U}, 
        {414U, 414U, 414U}, 
        {415U, 629U, 415U}, 
        {416U, 417U, 79U}, 
        {416U, 417U, 79U}, 
        {418U, 419U, 418U}, 
        {418U, 419U, 418U}, 
        {420U, 421U, 420U}, 
        {420U, 421U, 420U}, 
        {422U, 640U, 422U}, 
        {423U, 424U, 423U}, 
        {423U, 424U, 423U}, 
        {425U, 643U, 425U}, 
        {426U, 426U, 426U}, 
        {427U, 427U, 427U}, 
        {428U, 429U, 428U}, 
        {428U, 429U, 428U}, 
        {430U, 648U, 430U}, 
        {431U, 432U, 85U}, 
        {431U, 432U, 85U}, 
        {433U, 650U, 433U}, 
        {434U, 651U, 434U}, 
        {435U, 436U, 435U}, 
        {435U, 436U, 435U}, 
        {437U, 438U, 437U}, 
        {437U, 438U, 437U}, 
        {439U, 658U, 439U}, 
        {440U, 441U, 440U}, 
        {440U, 441U, 440U}, 
        {442U, 442U, 442U}, 
        {443U, 443U, 443U}, 
        {444U, 445U, 444U}, 
        {444U, 445U, 444U}, 
        {446U, 446U, 446U}, 
        {503U, 447U, 503U}, 
        {448U, 448U, 448U}, 
        {449U, 449U, 449U}, 
        {450U, 450U, 450U}, 
        {451U, 451U, 451U}, 
        {452U, 454U, 452U}, 
        {452U, 454U, 452U}, 
        {452U, 454U, 452U}, 
        {455U, 457U, 455U}, 
        {455U, 457U, 455U}, 
        {455U, 457U, 455U}, 
        {458U, 460U, 458U}, 
        {458U, 460U, 458U}, 
        {458U, 460U, 458U}, 
        {461U, 462U, 65U}, 
        {461U, 462U, 65U}, 
        {463U, 464U, 73U}, 
        {463U, 464U, 73U}, 
        {465U, 466U, 79U}, 
        {465U, 466U, 79U}, 
        {467U, 468U, 85U}, 
        {467U, 468U, 85U}, 
        {469U, 470U, 85U}, 
        {469U, 470U, 85U}, 
        {471U, 472U, 85U}, 
        {471U, 472U, 85U}, 
        {473U, 474U, 85U}, 
        {473U, 474U, 85U}, 
        {475U, 476U, 85U}, 
        {475U, 476U, 85U}, 
        {398U, 477U, 398U}, 
        {478U, 479U, 65U}, 
        {478U, 479U, 65U}, 
        {480U, 481U, 65U}, 
        {480U, 481U, 65U}, 
        {482U, 483U, 198U}, 
        {482U, 483U, 198U}, 
        {484U, 485U, 484U}, 
        {484U, 485U, 484U}, 
        {486U, 487U, 71U}, 
        {486U, 487U, 71U}, 
        {488U, 489U, 75U}, 
        {488U, 489U, 75U}, 
        {490U, 491U, 79U}, 
        {490U, 491U, 79U}, 
        {492U, 493U, 79U}, 
        {492U, 493U, 79U}, 
        {494U, 495U, 439U}, 
        {494U, 495U, 439U}, 
        {496U, 496U, 74U}, 
        {497U, 499U, 497U}, 
        {497U, 499U, 497U}, 
        {497U, 499U, 497U}, 
        {500U, 501U, 71U}, 
        {500U, 501U, 71U}, 
        {502U, 405U, 502U}, 
        {503U, 447U, 503U}, 
        {504U, 505U, 78U}, 
        {504U, 505U, 78U}, 
        {506U, 507U, 65U}, 
        {506U, 507U, 65U}, 
        {508U, 509U, 198U}, 
        {508U, 509U, 198U}, 
        {510U, 511U, 216U}, 
        {510U, 511U, 216U}};
#line 297 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane02[256]  = 
#line 297
  {      {512U, 513U, 65U}, 
        {512U, 513U, 65U}, 
        {514U, 515U, 65U}, 
        {514U, 515U, 65U}, 
        {516U, 517U, 69U}, 
        {516U, 517U, 69U}, 
        {518U, 519U, 69U}, 
        {518U, 519U, 69U}, 
        {520U, 521U, 73U}, 
        {520U, 521U, 73U}, 
        {522U, 523U, 73U}, 
        {522U, 523U, 73U}, 
        {524U, 525U, 79U}, 
        {524U, 525U, 79U}, 
        {526U, 527U, 79U}, 
        {526U, 527U, 79U}, 
        {528U, 529U, 82U}, 
        {528U, 529U, 82U}, 
        {530U, 531U, 82U}, 
        {530U, 531U, 82U}, 
        {532U, 533U, 85U}, 
        {532U, 533U, 85U}, 
        {534U, 535U, 85U}, 
        {534U, 535U, 85U}, 
        {536U, 537U, 83U}, 
        {536U, 537U, 83U}, 
        {538U, 539U, 84U}, 
        {538U, 539U, 84U}, 
        {540U, 541U, 540U}, 
        {540U, 541U, 540U}, 
        {542U, 543U, 72U}, 
        {542U, 543U, 72U}, 
        {544U, 544U, 544U}, 
        {545U, 545U, 545U}, 
        {546U, 547U, 546U}, 
        {546U, 547U, 546U}, 
        {548U, 549U, 548U}, 
        {548U, 549U, 548U}, 
        {550U, 551U, 65U}, 
        {550U, 551U, 65U}, 
        {552U, 553U, 69U}, 
        {552U, 553U, 69U}, 
        {554U, 555U, 79U}, 
        {554U, 555U, 79U}, 
        {556U, 557U, 79U}, 
        {556U, 557U, 79U}, 
        {558U, 559U, 79U}, 
        {558U, 559U, 79U}, 
        {560U, 561U, 79U}, 
        {560U, 561U, 79U}, 
        {562U, 563U, 89U}, 
        {562U, 563U, 89U}, 
        {564U, 564U, 564U}, 
        {565U, 565U, 565U}, 
        {566U, 566U, 566U}, 
        {567U, 567U, 567U}, 
        {568U, 568U, 568U}, 
        {569U, 569U, 569U}, 
        {570U, 570U, 570U}, 
        {571U, 571U, 571U}, 
        {572U, 572U, 572U}, 
        {573U, 573U, 573U}, 
        {574U, 574U, 574U}, 
        {575U, 575U, 575U}, 
        {576U, 576U, 576U}, 
        {577U, 577U, 577U}, 
        {578U, 578U, 578U}, 
        {579U, 579U, 579U}, 
        {580U, 580U, 580U}, 
        {581U, 581U, 581U}, 
        {582U, 582U, 582U}, 
        {583U, 583U, 583U}, 
        {584U, 584U, 584U}, 
        {585U, 585U, 585U}, 
        {586U, 586U, 586U}, 
        {587U, 587U, 587U}, 
        {588U, 588U, 588U}, 
        {589U, 589U, 589U}, 
        {590U, 590U, 590U}, 
        {591U, 591U, 591U}, 
        {592U, 592U, 592U}, 
        {593U, 593U, 593U}, 
        {594U, 594U, 594U}, 
        {385U, 595U, 385U}, 
        {390U, 596U, 390U}, 
        {597U, 597U, 597U}, 
        {393U, 598U, 393U}, 
        {394U, 599U, 394U}, 
        {600U, 600U, 600U}, 
        {399U, 601U, 399U}, 
        {602U, 602U, 602U}, 
        {400U, 603U, 400U}, 
        {604U, 604U, 604U}, 
        {605U, 605U, 605U}, 
        {606U, 606U, 606U}, 
        {607U, 607U, 607U}, 
        {403U, 608U, 403U}, 
        {609U, 609U, 609U}, 
        {610U, 610U, 610U}, 
        {404U, 611U, 404U}, 
        {612U, 612U, 612U}, 
        {613U, 613U, 613U}, 
        {614U, 614U, 614U}, 
        {615U, 615U, 615U}, 
        {407U, 616U, 407U}, 
        {406U, 617U, 406U}, 
        {618U, 618U, 618U}, 
        {619U, 619U, 619U}, 
        {620U, 620U, 620U}, 
        {621U, 621U, 621U}, 
        {622U, 622U, 622U}, 
        {412U, 623U, 412U}, 
        {624U, 624U, 624U}, 
        {625U, 625U, 625U}, 
        {413U, 626U, 413U}, 
        {627U, 627U, 627U}, 
        {628U, 628U, 628U}, 
        {415U, 629U, 415U}, 
        {630U, 630U, 630U}, 
        {631U, 631U, 631U}, 
        {632U, 632U, 632U}, 
        {633U, 633U, 633U}, 
        {634U, 634U, 634U}, 
        {635U, 635U, 635U}, 
        {636U, 636U, 636U}, 
        {637U, 637U, 637U}, 
        {638U, 638U, 638U}, 
        {639U, 639U, 639U}, 
        {422U, 640U, 422U}, 
        {641U, 641U, 641U}, 
        {642U, 642U, 642U}, 
        {425U, 643U, 425U}, 
        {644U, 644U, 644U}, 
        {645U, 645U, 645U}, 
        {646U, 646U, 646U}, 
        {647U, 647U, 647U}, 
        {430U, 648U, 430U}, 
        {649U, 649U, 649U}, 
        {433U, 650U, 433U}, 
        {434U, 651U, 434U}, 
        {652U, 652U, 652U}, 
        {653U, 653U, 653U}, 
        {654U, 654U, 654U}, 
        {655U, 655U, 655U}, 
        {656U, 656U, 656U}, 
        {657U, 657U, 657U}, 
        {439U, 658U, 439U}, 
        {659U, 659U, 659U}, 
        {660U, 660U, 660U}, 
        {661U, 661U, 661U}, 
        {662U, 662U, 662U}, 
        {663U, 663U, 663U}, 
        {664U, 664U, 664U}, 
        {665U, 665U, 665U}, 
        {666U, 666U, 666U}, 
        {667U, 667U, 667U}, 
        {668U, 668U, 668U}, 
        {669U, 669U, 669U}, 
        {670U, 670U, 670U}, 
        {671U, 671U, 671U}, 
        {672U, 672U, 672U}, 
        {673U, 673U, 673U}, 
        {674U, 674U, 674U}, 
        {675U, 675U, 675U}, 
        {676U, 676U, 676U}, 
        {677U, 677U, 677U}, 
        {678U, 678U, 678U}, 
        {679U, 679U, 679U}, 
        {680U, 680U, 680U}, 
        {681U, 681U, 681U}, 
        {682U, 682U, 682U}, 
        {683U, 683U, 683U}, 
        {684U, 684U, 684U}, 
        {685U, 685U, 685U}, 
        {686U, 686U, 686U}, 
        {687U, 687U, 687U}, 
        {688U, 688U, 688U}, 
        {689U, 689U, 689U}, 
        {690U, 690U, 690U}, 
        {691U, 691U, 691U}, 
        {692U, 692U, 692U}, 
        {693U, 693U, 693U}, 
        {694U, 694U, 694U}, 
        {695U, 695U, 695U}, 
        {696U, 696U, 696U}, 
        {697U, 697U, 697U}, 
        {698U, 698U, 698U}, 
        {699U, 699U, 699U}, 
        {700U, 700U, 700U}, 
        {701U, 701U, 701U}, 
        {702U, 702U, 702U}, 
        {703U, 703U, 703U}, 
        {704U, 704U, 704U}, 
        {705U, 705U, 705U}, 
        {706U, 706U, 706U}, 
        {707U, 707U, 707U}, 
        {708U, 708U, 708U}, 
        {709U, 709U, 709U}, 
        {710U, 710U, 710U}, 
        {711U, 711U, 711U}, 
        {712U, 712U, 712U}, 
        {713U, 713U, 713U}, 
        {714U, 714U, 714U}, 
        {715U, 715U, 715U}, 
        {716U, 716U, 716U}, 
        {717U, 717U, 717U}, 
        {718U, 718U, 718U}, 
        {719U, 719U, 719U}, 
        {720U, 720U, 720U}, 
        {721U, 721U, 721U}, 
        {722U, 722U, 722U}, 
        {723U, 723U, 723U}, 
        {724U, 724U, 724U}, 
        {725U, 725U, 725U}, 
        {726U, 726U, 726U}, 
        {727U, 727U, 727U}, 
        {728U, 728U, 728U}, 
        {729U, 729U, 729U}, 
        {730U, 730U, 730U}, 
        {731U, 731U, 731U}, 
        {732U, 732U, 732U}, 
        {733U, 733U, 733U}, 
        {734U, 734U, 734U}, 
        {735U, 735U, 735U}, 
        {736U, 736U, 736U}, 
        {737U, 737U, 737U}, 
        {738U, 738U, 738U}, 
        {739U, 739U, 739U}, 
        {740U, 740U, 740U}, 
        {741U, 741U, 741U}, 
        {742U, 742U, 742U}, 
        {743U, 743U, 743U}, 
        {744U, 744U, 744U}, 
        {745U, 745U, 745U}, 
        {746U, 746U, 746U}, 
        {747U, 747U, 747U}, 
        {748U, 748U, 748U}, 
        {749U, 749U, 749U}, 
        {750U, 750U, 750U}, 
        {751U, 751U, 751U}, 
        {752U, 752U, 752U}, 
        {753U, 753U, 753U}, 
        {754U, 754U, 754U}, 
        {755U, 755U, 755U}, 
        {756U, 756U, 756U}, 
        {757U, 757U, 757U}, 
        {758U, 758U, 758U}, 
        {759U, 759U, 759U}, 
        {760U, 760U, 760U}, 
        {761U, 761U, 761U}, 
        {762U, 762U, 762U}, 
        {763U, 763U, 763U}, 
        {764U, 764U, 764U}, 
        {765U, 765U, 765U}, 
        {766U, 766U, 766U}, 
        {767U, 767U, 767U}};
#line 428 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane03[256]  = 
#line 428
  {      {768U, 768U, 768U}, 
        {769U, 769U, 769U}, 
        {770U, 770U, 770U}, 
        {771U, 771U, 771U}, 
        {772U, 772U, 772U}, 
        {773U, 773U, 773U}, 
        {774U, 774U, 774U}, 
        {775U, 775U, 775U}, 
        {776U, 776U, 776U}, 
        {777U, 777U, 777U}, 
        {778U, 778U, 778U}, 
        {779U, 779U, 779U}, 
        {780U, 780U, 780U}, 
        {781U, 781U, 781U}, 
        {782U, 782U, 782U}, 
        {783U, 783U, 783U}, 
        {784U, 784U, 784U}, 
        {785U, 785U, 785U}, 
        {786U, 786U, 786U}, 
        {787U, 787U, 787U}, 
        {788U, 788U, 788U}, 
        {789U, 789U, 789U}, 
        {790U, 790U, 790U}, 
        {791U, 791U, 791U}, 
        {792U, 792U, 792U}, 
        {793U, 793U, 793U}, 
        {794U, 794U, 794U}, 
        {795U, 795U, 795U}, 
        {796U, 796U, 796U}, 
        {797U, 797U, 797U}, 
        {798U, 798U, 798U}, 
        {799U, 799U, 799U}, 
        {800U, 800U, 800U}, 
        {801U, 801U, 801U}, 
        {802U, 802U, 802U}, 
        {803U, 803U, 803U}, 
        {804U, 804U, 804U}, 
        {805U, 805U, 805U}, 
        {806U, 806U, 806U}, 
        {807U, 807U, 807U}, 
        {808U, 808U, 808U}, 
        {809U, 809U, 809U}, 
        {810U, 810U, 810U}, 
        {811U, 811U, 811U}, 
        {812U, 812U, 812U}, 
        {813U, 813U, 813U}, 
        {814U, 814U, 814U}, 
        {815U, 815U, 815U}, 
        {816U, 816U, 816U}, 
        {817U, 817U, 817U}, 
        {818U, 818U, 818U}, 
        {819U, 819U, 819U}, 
        {820U, 820U, 820U}, 
        {821U, 821U, 821U}, 
        {822U, 822U, 822U}, 
        {823U, 823U, 823U}, 
        {824U, 824U, 824U}, 
        {825U, 825U, 825U}, 
        {826U, 826U, 826U}, 
        {827U, 827U, 827U}, 
        {828U, 828U, 828U}, 
        {829U, 829U, 829U}, 
        {830U, 830U, 830U}, 
        {831U, 831U, 831U}, 
        {832U, 832U, 832U}, 
        {833U, 833U, 833U}, 
        {834U, 834U, 834U}, 
        {835U, 835U, 835U}, 
        {836U, 836U, 836U}, 
        {921U, 837U, 921U}, 
        {838U, 838U, 838U}, 
        {839U, 839U, 839U}, 
        {840U, 840U, 840U}, 
        {841U, 841U, 841U}, 
        {842U, 842U, 842U}, 
        {843U, 843U, 843U}, 
        {844U, 844U, 844U}, 
        {845U, 845U, 845U}, 
        {846U, 846U, 846U}, 
        {847U, 847U, 847U}, 
        {848U, 848U, 848U}, 
        {849U, 849U, 849U}, 
        {850U, 850U, 850U}, 
        {851U, 851U, 851U}, 
        {852U, 852U, 852U}, 
        {853U, 853U, 853U}, 
        {854U, 854U, 854U}, 
        {855U, 855U, 855U}, 
        {856U, 856U, 856U}, 
        {857U, 857U, 857U}, 
        {858U, 858U, 858U}, 
        {859U, 859U, 859U}, 
        {860U, 860U, 860U}, 
        {861U, 861U, 861U}, 
        {862U, 862U, 862U}, 
        {863U, 863U, 863U}, 
        {864U, 864U, 864U}, 
        {865U, 865U, 865U}, 
        {866U, 866U, 866U}, 
        {867U, 867U, 867U}, 
        {868U, 868U, 868U}, 
        {869U, 869U, 869U}, 
        {870U, 870U, 870U}, 
        {871U, 871U, 871U}, 
        {872U, 872U, 872U}, 
        {873U, 873U, 873U}, 
        {874U, 874U, 874U}, 
        {875U, 875U, 875U}, 
        {876U, 876U, 876U}, 
        {877U, 877U, 877U}, 
        {878U, 878U, 878U}, 
        {879U, 879U, 879U}, 
        {880U, 880U, 880U}, 
        {881U, 881U, 881U}, 
        {882U, 882U, 882U}, 
        {883U, 883U, 883U}, 
        {884U, 884U, 884U}, 
        {885U, 885U, 885U}, 
        {886U, 886U, 886U}, 
        {887U, 887U, 887U}, 
        {888U, 888U, 888U}, 
        {889U, 889U, 889U}, 
        {890U, 890U, 890U}, 
        {891U, 891U, 891U}, 
        {892U, 892U, 892U}, 
        {893U, 893U, 893U}, 
        {894U, 894U, 894U}, 
        {895U, 895U, 895U}, 
        {896U, 896U, 896U}, 
        {897U, 897U, 897U}, 
        {898U, 898U, 898U}, 
        {899U, 899U, 899U}, 
        {900U, 900U, 900U}, 
        {901U, 901U, 901U}, 
        {902U, 940U, 913U}, 
        {903U, 903U, 903U}, 
        {904U, 941U, 917U}, 
        {905U, 942U, 919U}, 
        {906U, 943U, 921U}, 
        {907U, 907U, 907U}, 
        {908U, 972U, 927U}, 
        {909U, 909U, 909U}, 
        {910U, 973U, 933U}, 
        {911U, 974U, 937U}, 
        {912U, 912U, 921U}, 
        {913U, 945U, 913U}, 
        {914U, 946U, 914U}, 
        {915U, 947U, 915U}, 
        {916U, 948U, 916U}, 
        {917U, 949U, 917U}, 
        {918U, 950U, 918U}, 
        {919U, 951U, 919U}, 
        {920U, 952U, 920U}, 
        {921U, 953U, 921U}, 
        {922U, 954U, 922U}, 
        {923U, 955U, 923U}, 
        {924U, 956U, 924U}, 
        {925U, 957U, 925U}, 
        {926U, 958U, 926U}, 
        {927U, 959U, 927U}, 
        {928U, 960U, 928U}, 
        {929U, 961U, 929U}, 
        {930U, 930U, 930U}, 
        {931U, 963U, 931U}, 
        {932U, 964U, 932U}, 
        {933U, 965U, 933U}, 
        {934U, 966U, 934U}, 
        {935U, 967U, 935U}, 
        {936U, 968U, 936U}, 
        {937U, 969U, 937U}, 
        {938U, 970U, 921U}, 
        {939U, 971U, 933U}, 
        {902U, 940U, 913U}, 
        {904U, 941U, 917U}, 
        {905U, 942U, 919U}, 
        {906U, 943U, 921U}, 
        {944U, 944U, 933U}, 
        {913U, 945U, 913U}, 
        {914U, 946U, 914U}, 
        {915U, 947U, 915U}, 
        {916U, 948U, 916U}, 
        {917U, 949U, 917U}, 
        {918U, 950U, 918U}, 
        {919U, 951U, 919U}, 
        {920U, 952U, 920U}, 
        {921U, 953U, 921U}, 
        {922U, 954U, 922U}, 
        {923U, 955U, 923U}, 
        {924U, 956U, 924U}, 
        {925U, 957U, 925U}, 
        {926U, 958U, 926U}, 
        {927U, 959U, 927U}, 
        {928U, 960U, 928U}, 
        {929U, 961U, 929U}, 
        {931U, 962U, 931U}, 
        {931U, 963U, 931U}, 
        {932U, 964U, 932U}, 
        {933U, 965U, 933U}, 
        {934U, 966U, 934U}, 
        {935U, 967U, 935U}, 
        {936U, 968U, 936U}, 
        {937U, 969U, 937U}, 
        {938U, 970U, 921U}, 
        {939U, 971U, 933U}, 
        {908U, 972U, 927U}, 
        {910U, 973U, 933U}, 
        {911U, 974U, 937U}, 
        {975U, 975U, 975U}, 
        {914U, 976U, 914U}, 
        {920U, 977U, 920U}, 
        {978U, 978U, 978U}, 
        {979U, 979U, 978U}, 
        {980U, 980U, 978U}, 
        {934U, 981U, 934U}, 
        {928U, 982U, 928U}, 
        {983U, 983U, 983U}, 
        {984U, 984U, 984U}, 
        {985U, 985U, 985U}, 
        {986U, 987U, 986U}, 
        {986U, 987U, 986U}, 
        {988U, 989U, 988U}, 
        {988U, 989U, 988U}, 
        {990U, 991U, 990U}, 
        {990U, 991U, 990U}, 
        {992U, 993U, 992U}, 
        {992U, 993U, 992U}, 
        {994U, 995U, 994U}, 
        {994U, 995U, 994U}, 
        {996U, 997U, 996U}, 
        {996U, 997U, 996U}, 
        {998U, 999U, 998U}, 
        {998U, 999U, 998U}, 
        {1000U, 1001U, 1000U}, 
        {1000U, 1001U, 1000U}, 
        {1002U, 1003U, 1002U}, 
        {1002U, 1003U, 1002U}, 
        {1004U, 1005U, 1004U}, 
        {1004U, 1005U, 1004U}, 
        {1006U, 1007U, 1006U}, 
        {1006U, 1007U, 1006U}, 
        {922U, 1008U, 922U}, 
        {929U, 1009U, 929U}, 
        {931U, 1010U, 931U}, 
        {1011U, 1011U, 1011U}, 
        {1012U, 1012U, 1012U}, 
        {1013U, 1013U, 1013U}, 
        {1014U, 1014U, 1014U}, 
        {1015U, 1015U, 1015U}, 
        {1016U, 1016U, 1016U}, 
        {1017U, 1017U, 1017U}, 
        {1018U, 1018U, 1018U}, 
        {1019U, 1019U, 1019U}, 
        {1020U, 1020U, 1020U}, 
        {1021U, 1021U, 1021U}, 
        {1022U, 1022U, 1022U}, 
        {1023U, 1023U, 1023U}};
#line 559 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane04[256]  = 
#line 559
  {      {1024U, 1104U, 1045U}, 
        {1025U, 1105U, 1045U}, 
        {1026U, 1106U, 1026U}, 
        {1027U, 1107U, 1043U}, 
        {1028U, 1108U, 1028U}, 
        {1029U, 1109U, 1029U}, 
        {1030U, 1110U, 1030U}, 
        {1031U, 1111U, 1030U}, 
        {1032U, 1112U, 1032U}, 
        {1033U, 1113U, 1033U}, 
        {1034U, 1114U, 1034U}, 
        {1035U, 1115U, 1035U}, 
        {1036U, 1116U, 1050U}, 
        {1037U, 1117U, 1048U}, 
        {1038U, 1118U, 1059U}, 
        {1039U, 1119U, 1039U}, 
        {1040U, 1072U, 1040U}, 
        {1041U, 1073U, 1041U}, 
        {1042U, 1074U, 1042U}, 
        {1043U, 1075U, 1043U}, 
        {1044U, 1076U, 1044U}, 
        {1045U, 1077U, 1045U}, 
        {1046U, 1078U, 1046U}, 
        {1047U, 1079U, 1047U}, 
        {1048U, 1080U, 1048U}, 
        {1049U, 1081U, 1048U}, 
        {1050U, 1082U, 1050U}, 
        {1051U, 1083U, 1051U}, 
        {1052U, 1084U, 1052U}, 
        {1053U, 1085U, 1053U}, 
        {1054U, 1086U, 1054U}, 
        {1055U, 1087U, 1055U}, 
        {1056U, 1088U, 1056U}, 
        {1057U, 1089U, 1057U}, 
        {1058U, 1090U, 1058U}, 
        {1059U, 1091U, 1059U}, 
        {1060U, 1092U, 1060U}, 
        {1061U, 1093U, 1061U}, 
        {1062U, 1094U, 1062U}, 
        {1063U, 1095U, 1063U}, 
        {1064U, 1096U, 1064U}, 
        {1065U, 1097U, 1065U}, 
        {1066U, 1098U, 1066U}, 
        {1067U, 1099U, 1067U}, 
        {1068U, 1100U, 1068U}, 
        {1069U, 1101U, 1069U}, 
        {1070U, 1102U, 1070U}, 
        {1071U, 1103U, 1071U}, 
        {1040U, 1072U, 1040U}, 
        {1041U, 1073U, 1041U}, 
        {1042U, 1074U, 1042U}, 
        {1043U, 1075U, 1043U}, 
        {1044U, 1076U, 1044U}, 
        {1045U, 1077U, 1045U}, 
        {1046U, 1078U, 1046U}, 
        {1047U, 1079U, 1047U}, 
        {1048U, 1080U, 1048U}, 
        {1049U, 1081U, 1048U}, 
        {1050U, 1082U, 1050U}, 
        {1051U, 1083U, 1051U}, 
        {1052U, 1084U, 1052U}, 
        {1053U, 1085U, 1053U}, 
        {1054U, 1086U, 1054U}, 
        {1055U, 1087U, 1055U}, 
        {1056U, 1088U, 1056U}, 
        {1057U, 1089U, 1057U}, 
        {1058U, 1090U, 1058U}, 
        {1059U, 1091U, 1059U}, 
        {1060U, 1092U, 1060U}, 
        {1061U, 1093U, 1061U}, 
        {1062U, 1094U, 1062U}, 
        {1063U, 1095U, 1063U}, 
        {1064U, 1096U, 1064U}, 
        {1065U, 1097U, 1065U}, 
        {1066U, 1098U, 1066U}, 
        {1067U, 1099U, 1067U}, 
        {1068U, 1100U, 1068U}, 
        {1069U, 1101U, 1069U}, 
        {1070U, 1102U, 1070U}, 
        {1071U, 1103U, 1071U}, 
        {1024U, 1104U, 1045U}, 
        {1025U, 1105U, 1045U}, 
        {1026U, 1106U, 1026U}, 
        {1027U, 1107U, 1043U}, 
        {1028U, 1108U, 1028U}, 
        {1029U, 1109U, 1029U}, 
        {1030U, 1110U, 1030U}, 
        {1031U, 1111U, 1030U}, 
        {1032U, 1112U, 1032U}, 
        {1033U, 1113U, 1033U}, 
        {1034U, 1114U, 1034U}, 
        {1035U, 1115U, 1035U}, 
        {1036U, 1116U, 1050U}, 
        {1037U, 1117U, 1048U}, 
        {1038U, 1118U, 1059U}, 
        {1039U, 1119U, 1039U}, 
        {1120U, 1121U, 1120U}, 
        {1120U, 1121U, 1120U}, 
        {1122U, 1123U, 1122U}, 
        {1122U, 1123U, 1122U}, 
        {1124U, 1125U, 1124U}, 
        {1124U, 1125U, 1124U}, 
        {1126U, 1127U, 1126U}, 
        {1126U, 1127U, 1126U}, 
        {1128U, 1129U, 1128U}, 
        {1128U, 1129U, 1128U}, 
        {1130U, 1131U, 1130U}, 
        {1130U, 1131U, 1130U}, 
        {1132U, 1133U, 1132U}, 
        {1132U, 1133U, 1132U}, 
        {1134U, 1135U, 1134U}, 
        {1134U, 1135U, 1134U}, 
        {1136U, 1137U, 1136U}, 
        {1136U, 1137U, 1136U}, 
        {1138U, 1139U, 1138U}, 
        {1138U, 1139U, 1138U}, 
        {1140U, 1141U, 1140U}, 
        {1140U, 1141U, 1140U}, 
        {1142U, 1143U, 1140U}, 
        {1142U, 1143U, 1140U}, 
        {1144U, 1145U, 1144U}, 
        {1144U, 1145U, 1144U}, 
        {1146U, 1147U, 1146U}, 
        {1146U, 1147U, 1146U}, 
        {1148U, 1149U, 1148U}, 
        {1148U, 1149U, 1148U}, 
        {1150U, 1151U, 1150U}, 
        {1150U, 1151U, 1150U}, 
        {1152U, 1153U, 1152U}, 
        {1152U, 1153U, 1152U}, 
        {1154U, 1154U, 1154U}, 
        {1155U, 1155U, 1155U}, 
        {1156U, 1156U, 1156U}, 
        {1157U, 1157U, 1157U}, 
        {1158U, 1158U, 1158U}, 
        {1159U, 1159U, 1159U}, 
        {1160U, 1160U, 1160U}, 
        {1161U, 1161U, 1161U}, 
        {1162U, 1162U, 1162U}, 
        {1163U, 1163U, 1163U}, 
        {1164U, 1165U, 1164U}, 
        {1164U, 1165U, 1164U}, 
        {1166U, 1167U, 1166U}, 
        {1166U, 1167U, 1166U}, 
        {1168U, 1169U, 1168U}, 
        {1168U, 1169U, 1168U}, 
        {1170U, 1171U, 1170U}, 
        {1170U, 1171U, 1170U}, 
        {1172U, 1173U, 1172U}, 
        {1172U, 1173U, 1172U}, 
        {1174U, 1175U, 1174U}, 
        {1174U, 1175U, 1174U}, 
        {1176U, 1177U, 1176U}, 
        {1176U, 1177U, 1176U}, 
        {1178U, 1179U, 1178U}, 
        {1178U, 1179U, 1178U}, 
        {1180U, 1181U, 1180U}, 
        {1180U, 1181U, 1180U}, 
        {1182U, 1183U, 1182U}, 
        {1182U, 1183U, 1182U}, 
        {1184U, 1185U, 1184U}, 
        {1184U, 1185U, 1184U}, 
        {1186U, 1187U, 1186U}, 
        {1186U, 1187U, 1186U}, 
        {1188U, 1189U, 1188U}, 
        {1188U, 1189U, 1188U}, 
        {1190U, 1191U, 1190U}, 
        {1190U, 1191U, 1190U}, 
        {1192U, 1193U, 1192U}, 
        {1192U, 1193U, 1192U}, 
        {1194U, 1195U, 1194U}, 
        {1194U, 1195U, 1194U}, 
        {1196U, 1197U, 1196U}, 
        {1196U, 1197U, 1196U}, 
        {1198U, 1199U, 1198U}, 
        {1198U, 1199U, 1198U}, 
        {1200U, 1201U, 1200U}, 
        {1200U, 1201U, 1200U}, 
        {1202U, 1203U, 1202U}, 
        {1202U, 1203U, 1202U}, 
        {1204U, 1205U, 1204U}, 
        {1204U, 1205U, 1204U}, 
        {1206U, 1207U, 1206U}, 
        {1206U, 1207U, 1206U}, 
        {1208U, 1209U, 1208U}, 
        {1208U, 1209U, 1208U}, 
        {1210U, 1211U, 1210U}, 
        {1210U, 1211U, 1210U}, 
        {1212U, 1213U, 1212U}, 
        {1212U, 1213U, 1212U}, 
        {1214U, 1215U, 1214U}, 
        {1214U, 1215U, 1214U}, 
        {1216U, 1216U, 1216U}, 
        {1217U, 1218U, 1046U}, 
        {1217U, 1218U, 1046U}, 
        {1219U, 1220U, 1219U}, 
        {1219U, 1220U, 1219U}, 
        {1221U, 1221U, 1221U}, 
        {1222U, 1222U, 1222U}, 
        {1223U, 1224U, 1223U}, 
        {1223U, 1224U, 1223U}, 
        {1225U, 1225U, 1225U}, 
        {1226U, 1226U, 1226U}, 
        {1227U, 1228U, 1227U}, 
        {1227U, 1228U, 1227U}, 
        {1229U, 1229U, 1229U}, 
        {1230U, 1230U, 1230U}, 
        {1231U, 1231U, 1231U}, 
        {1232U, 1233U, 1040U}, 
        {1232U, 1233U, 1040U}, 
        {1234U, 1235U, 1040U}, 
        {1234U, 1235U, 1040U}, 
        {1236U, 1237U, 1236U}, 
        {1236U, 1237U, 1236U}, 
        {1238U, 1239U, 1045U}, 
        {1238U, 1239U, 1045U}, 
        {1240U, 1241U, 1240U}, 
        {1240U, 1241U, 1240U}, 
        {1242U, 1243U, 1240U}, 
        {1242U, 1243U, 1240U}, 
        {1244U, 1245U, 1046U}, 
        {1244U, 1245U, 1046U}, 
        {1246U, 1247U, 1047U}, 
        {1246U, 1247U, 1047U}, 
        {1248U, 1249U, 1248U}, 
        {1248U, 1249U, 1248U}, 
        {1250U, 1251U, 1048U}, 
        {1250U, 1251U, 1048U}, 
        {1252U, 1253U, 1048U}, 
        {1252U, 1253U, 1048U}, 
        {1254U, 1255U, 1054U}, 
        {1254U, 1255U, 1054U}, 
        {1256U, 1257U, 1256U}, 
        {1256U, 1257U, 1256U}, 
        {1258U, 1259U, 1256U}, 
        {1258U, 1259U, 1256U}, 
        {1260U, 1261U, 1069U}, 
        {1260U, 1261U, 1069U}, 
        {1262U, 1263U, 1059U}, 
        {1262U, 1263U, 1059U}, 
        {1264U, 1265U, 1059U}, 
        {1264U, 1265U, 1059U}, 
        {1266U, 1267U, 1059U}, 
        {1266U, 1267U, 1059U}, 
        {1268U, 1269U, 1063U}, 
        {1268U, 1269U, 1063U}, 
        {1270U, 1270U, 1270U}, 
        {1271U, 1271U, 1271U}, 
        {1272U, 1273U, 1067U}, 
        {1272U, 1273U, 1067U}, 
        {1274U, 1274U, 1274U}, 
        {1275U, 1275U, 1275U}, 
        {1276U, 1276U, 1276U}, 
        {1277U, 1277U, 1277U}, 
        {1278U, 1278U, 1278U}, 
        {1279U, 1279U, 1279U}};
#line 690 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane05[256]  = 
#line 690
  {      {1280U, 1280U, 1280U}, 
        {1281U, 1281U, 1281U}, 
        {1282U, 1282U, 1282U}, 
        {1283U, 1283U, 1283U}, 
        {1284U, 1284U, 1284U}, 
        {1285U, 1285U, 1285U}, 
        {1286U, 1286U, 1286U}, 
        {1287U, 1287U, 1287U}, 
        {1288U, 1288U, 1288U}, 
        {1289U, 1289U, 1289U}, 
        {1290U, 1290U, 1290U}, 
        {1291U, 1291U, 1291U}, 
        {1292U, 1292U, 1292U}, 
        {1293U, 1293U, 1293U}, 
        {1294U, 1294U, 1294U}, 
        {1295U, 1295U, 1295U}, 
        {1296U, 1296U, 1296U}, 
        {1297U, 1297U, 1297U}, 
        {1298U, 1298U, 1298U}, 
        {1299U, 1299U, 1299U}, 
        {1300U, 1300U, 1300U}, 
        {1301U, 1301U, 1301U}, 
        {1302U, 1302U, 1302U}, 
        {1303U, 1303U, 1303U}, 
        {1304U, 1304U, 1304U}, 
        {1305U, 1305U, 1305U}, 
        {1306U, 1306U, 1306U}, 
        {1307U, 1307U, 1307U}, 
        {1308U, 1308U, 1308U}, 
        {1309U, 1309U, 1309U}, 
        {1310U, 1310U, 1310U}, 
        {1311U, 1311U, 1311U}, 
        {1312U, 1312U, 1312U}, 
        {1313U, 1313U, 1313U}, 
        {1314U, 1314U, 1314U}, 
        {1315U, 1315U, 1315U}, 
        {1316U, 1316U, 1316U}, 
        {1317U, 1317U, 1317U}, 
        {1318U, 1318U, 1318U}, 
        {1319U, 1319U, 1319U}, 
        {1320U, 1320U, 1320U}, 
        {1321U, 1321U, 1321U}, 
        {1322U, 1322U, 1322U}, 
        {1323U, 1323U, 1323U}, 
        {1324U, 1324U, 1324U}, 
        {1325U, 1325U, 1325U}, 
        {1326U, 1326U, 1326U}, 
        {1327U, 1327U, 1327U}, 
        {1328U, 1328U, 1328U}, 
        {1329U, 1377U, 1329U}, 
        {1330U, 1378U, 1330U}, 
        {1331U, 1379U, 1331U}, 
        {1332U, 1380U, 1332U}, 
        {1333U, 1381U, 1333U}, 
        {1334U, 1382U, 1334U}, 
        {1335U, 1383U, 1335U}, 
        {1336U, 1384U, 1336U}, 
        {1337U, 1385U, 1337U}, 
        {1338U, 1386U, 1338U}, 
        {1339U, 1387U, 1339U}, 
        {1340U, 1388U, 1340U}, 
        {1341U, 1389U, 1341U}, 
        {1342U, 1390U, 1342U}, 
        {1343U, 1391U, 1343U}, 
        {1344U, 1392U, 1344U}, 
        {1345U, 1393U, 1345U}, 
        {1346U, 1394U, 1346U}, 
        {1347U, 1395U, 1347U}, 
        {1348U, 1396U, 1348U}, 
        {1349U, 1397U, 1349U}, 
        {1350U, 1398U, 1350U}, 
        {1351U, 1399U, 1351U}, 
        {1352U, 1400U, 1352U}, 
        {1353U, 1401U, 1353U}, 
        {1354U, 1402U, 1354U}, 
        {1355U, 1403U, 1355U}, 
        {1356U, 1404U, 1356U}, 
        {1357U, 1405U, 1357U}, 
        {1358U, 1406U, 1358U}, 
        {1359U, 1407U, 1359U}, 
        {1360U, 1408U, 1360U}, 
        {1361U, 1409U, 1361U}, 
        {1362U, 1410U, 1362U}, 
        {1363U, 1411U, 1363U}, 
        {1364U, 1412U, 1364U}, 
        {1365U, 1413U, 1365U}, 
        {1366U, 1414U, 1366U}, 
        {1367U, 1367U, 1367U}, 
        {1368U, 1368U, 1368U}, 
        {1369U, 1369U, 1369U}, 
        {1370U, 1370U, 1370U}, 
        {1371U, 1371U, 1371U}, 
        {1372U, 1372U, 1372U}, 
        {1373U, 1373U, 1373U}, 
        {1374U, 1374U, 1374U}, 
        {1375U, 1375U, 1375U}, 
        {1376U, 1376U, 1376U}, 
        {1329U, 1377U, 1329U}, 
        {1330U, 1378U, 1330U}, 
        {1331U, 1379U, 1331U}, 
        {1332U, 1380U, 1332U}, 
        {1333U, 1381U, 1333U}, 
        {1334U, 1382U, 1334U}, 
        {1335U, 1383U, 1335U}, 
        {1336U, 1384U, 1336U}, 
        {1337U, 1385U, 1337U}, 
        {1338U, 1386U, 1338U}, 
        {1339U, 1387U, 1339U}, 
        {1340U, 1388U, 1340U}, 
        {1341U, 1389U, 1341U}, 
        {1342U, 1390U, 1342U}, 
        {1343U, 1391U, 1343U}, 
        {1344U, 1392U, 1344U}, 
        {1345U, 1393U, 1345U}, 
        {1346U, 1394U, 1346U}, 
        {1347U, 1395U, 1347U}, 
        {1348U, 1396U, 1348U}, 
        {1349U, 1397U, 1349U}, 
        {1350U, 1398U, 1350U}, 
        {1351U, 1399U, 1351U}, 
        {1352U, 1400U, 1352U}, 
        {1353U, 1401U, 1353U}, 
        {1354U, 1402U, 1354U}, 
        {1355U, 1403U, 1355U}, 
        {1356U, 1404U, 1356U}, 
        {1357U, 1405U, 1357U}, 
        {1358U, 1406U, 1358U}, 
        {1359U, 1407U, 1359U}, 
        {1360U, 1408U, 1360U}, 
        {1361U, 1409U, 1361U}, 
        {1362U, 1410U, 1362U}, 
        {1363U, 1411U, 1363U}, 
        {1364U, 1412U, 1364U}, 
        {1365U, 1413U, 1365U}, 
        {1366U, 1414U, 1366U}, 
        {1415U, 1415U, 1415U}, 
        {1416U, 1416U, 1416U}, 
        {1417U, 1417U, 1417U}, 
        {1418U, 1418U, 1418U}, 
        {1419U, 1419U, 1419U}, 
        {1420U, 1420U, 1420U}, 
        {1421U, 1421U, 1421U}, 
        {1422U, 1422U, 1422U}, 
        {1423U, 1423U, 1423U}, 
        {1424U, 1424U, 1424U}, 
        {1425U, 1425U, 1425U}, 
        {1426U, 1426U, 1426U}, 
        {1427U, 1427U, 1427U}, 
        {1428U, 1428U, 1428U}, 
        {1429U, 1429U, 1429U}, 
        {1430U, 1430U, 1430U}, 
        {1431U, 1431U, 1431U}, 
        {1432U, 1432U, 1432U}, 
        {1433U, 1433U, 1433U}, 
        {1434U, 1434U, 1434U}, 
        {1435U, 1435U, 1435U}, 
        {1436U, 1436U, 1436U}, 
        {1437U, 1437U, 1437U}, 
        {1438U, 1438U, 1438U}, 
        {1439U, 1439U, 1439U}, 
        {1440U, 1440U, 1440U}, 
        {1441U, 1441U, 1441U}, 
        {1442U, 1442U, 1442U}, 
        {1443U, 1443U, 1443U}, 
        {1444U, 1444U, 1444U}, 
        {1445U, 1445U, 1445U}, 
        {1446U, 1446U, 1446U}, 
        {1447U, 1447U, 1447U}, 
        {1448U, 1448U, 1448U}, 
        {1449U, 1449U, 1449U}, 
        {1450U, 1450U, 1450U}, 
        {1451U, 1451U, 1451U}, 
        {1452U, 1452U, 1452U}, 
        {1453U, 1453U, 1453U}, 
        {1454U, 1454U, 1454U}, 
        {1455U, 1455U, 1455U}, 
        {1456U, 1456U, 1456U}, 
        {1457U, 1457U, 1457U}, 
        {1458U, 1458U, 1458U}, 
        {1459U, 1459U, 1459U}, 
        {1460U, 1460U, 1460U}, 
        {1461U, 1461U, 1461U}, 
        {1462U, 1462U, 1462U}, 
        {1463U, 1463U, 1463U}, 
        {1464U, 1464U, 1464U}, 
        {1465U, 1465U, 1465U}, 
        {1466U, 1466U, 1466U}, 
        {1467U, 1467U, 1467U}, 
        {1468U, 1468U, 1468U}, 
        {1469U, 1469U, 1469U}, 
        {1470U, 1470U, 1470U}, 
        {1471U, 1471U, 1471U}, 
        {1472U, 1472U, 1472U}, 
        {1473U, 1473U, 1473U}, 
        {1474U, 1474U, 1474U}, 
        {1475U, 1475U, 1475U}, 
        {1476U, 1476U, 1476U}, 
        {1477U, 1477U, 1477U}, 
        {1478U, 1478U, 1478U}, 
        {1479U, 1479U, 1479U}, 
        {1480U, 1480U, 1480U}, 
        {1481U, 1481U, 1481U}, 
        {1482U, 1482U, 1482U}, 
        {1483U, 1483U, 1483U}, 
        {1484U, 1484U, 1484U}, 
        {1485U, 1485U, 1485U}, 
        {1486U, 1486U, 1486U}, 
        {1487U, 1487U, 1487U}, 
        {1488U, 1488U, 1488U}, 
        {1489U, 1489U, 1489U}, 
        {1490U, 1490U, 1490U}, 
        {1491U, 1491U, 1491U}, 
        {1492U, 1492U, 1492U}, 
        {1493U, 1493U, 1493U}, 
        {1494U, 1494U, 1494U}, 
        {1495U, 1495U, 1495U}, 
        {1496U, 1496U, 1496U}, 
        {1497U, 1497U, 1497U}, 
        {1498U, 1498U, 1498U}, 
        {1499U, 1499U, 1499U}, 
        {1500U, 1500U, 1500U}, 
        {1501U, 1501U, 1501U}, 
        {1502U, 1502U, 1502U}, 
        {1503U, 1503U, 1503U}, 
        {1504U, 1504U, 1504U}, 
        {1505U, 1505U, 1505U}, 
        {1506U, 1506U, 1506U}, 
        {1507U, 1507U, 1507U}, 
        {1508U, 1508U, 1508U}, 
        {1509U, 1509U, 1509U}, 
        {1510U, 1510U, 1510U}, 
        {1511U, 1511U, 1511U}, 
        {1512U, 1512U, 1512U}, 
        {1513U, 1513U, 1513U}, 
        {1514U, 1514U, 1514U}, 
        {1515U, 1515U, 1515U}, 
        {1516U, 1516U, 1516U}, 
        {1517U, 1517U, 1517U}, 
        {1518U, 1518U, 1518U}, 
        {1519U, 1519U, 1519U}, 
        {1520U, 1520U, 1520U}, 
        {1521U, 1521U, 1521U}, 
        {1522U, 1522U, 1522U}, 
        {1523U, 1523U, 1523U}, 
        {1524U, 1524U, 1524U}, 
        {1525U, 1525U, 1525U}, 
        {1526U, 1526U, 1526U}, 
        {1527U, 1527U, 1527U}, 
        {1528U, 1528U, 1528U}, 
        {1529U, 1529U, 1529U}, 
        {1530U, 1530U, 1530U}, 
        {1531U, 1531U, 1531U}, 
        {1532U, 1532U, 1532U}, 
        {1533U, 1533U, 1533U}, 
        {1534U, 1534U, 1534U}, 
        {1535U, 1535U, 1535U}};
#line 821 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane1E[256]  = 
#line 821
  {      {7680U, 7681U, 65U}, 
        {7680U, 7681U, 65U}, 
        {7682U, 7683U, 66U}, 
        {7682U, 7683U, 66U}, 
        {7684U, 7685U, 66U}, 
        {7684U, 7685U, 66U}, 
        {7686U, 7687U, 66U}, 
        {7686U, 7687U, 66U}, 
        {7688U, 7689U, 67U}, 
        {7688U, 7689U, 67U}, 
        {7690U, 7691U, 68U}, 
        {7690U, 7691U, 68U}, 
        {7692U, 7693U, 68U}, 
        {7692U, 7693U, 68U}, 
        {7694U, 7695U, 68U}, 
        {7694U, 7695U, 68U}, 
        {7696U, 7697U, 68U}, 
        {7696U, 7697U, 68U}, 
        {7698U, 7699U, 68U}, 
        {7698U, 7699U, 68U}, 
        {7700U, 7701U, 69U}, 
        {7700U, 7701U, 69U}, 
        {7702U, 7703U, 69U}, 
        {7702U, 7703U, 69U}, 
        {7704U, 7705U, 69U}, 
        {7704U, 7705U, 69U}, 
        {7706U, 7707U, 69U}, 
        {7706U, 7707U, 69U}, 
        {7708U, 7709U, 69U}, 
        {7708U, 7709U, 69U}, 
        {7710U, 7711U, 70U}, 
        {7710U, 7711U, 70U}, 
        {7712U, 7713U, 71U}, 
        {7712U, 7713U, 71U}, 
        {7714U, 7715U, 72U}, 
        {7714U, 7715U, 72U}, 
        {7716U, 7717U, 72U}, 
        {7716U, 7717U, 72U}, 
        {7718U, 7719U, 72U}, 
        {7718U, 7719U, 72U}, 
        {7720U, 7721U, 72U}, 
        {7720U, 7721U, 72U}, 
        {7722U, 7723U, 72U}, 
        {7722U, 7723U, 72U}, 
        {7724U, 7725U, 73U}, 
        {7724U, 7725U, 73U}, 
        {7726U, 7727U, 73U}, 
        {7726U, 7727U, 73U}, 
        {7728U, 7729U, 75U}, 
        {7728U, 7729U, 75U}, 
        {7730U, 7731U, 75U}, 
        {7730U, 7731U, 75U}, 
        {7732U, 7733U, 75U}, 
        {7732U, 7733U, 75U}, 
        {7734U, 7735U, 76U}, 
        {7734U, 7735U, 76U}, 
        {7736U, 7737U, 76U}, 
        {7736U, 7737U, 76U}, 
        {7738U, 7739U, 76U}, 
        {7738U, 7739U, 76U}, 
        {7740U, 7741U, 76U}, 
        {7740U, 7741U, 76U}, 
        {7742U, 7743U, 77U}, 
        {7742U, 7743U, 77U}, 
        {7744U, 7745U, 77U}, 
        {7744U, 7745U, 77U}, 
        {7746U, 7747U, 77U}, 
        {7746U, 7747U, 77U}, 
        {7748U, 7749U, 78U}, 
        {7748U, 7749U, 78U}, 
        {7750U, 7751U, 78U}, 
        {7750U, 7751U, 78U}, 
        {7752U, 7753U, 78U}, 
        {7752U, 7753U, 78U}, 
        {7754U, 7755U, 78U}, 
        {7754U, 7755U, 78U}, 
        {7756U, 7757U, 79U}, 
        {7756U, 7757U, 79U}, 
        {7758U, 7759U, 79U}, 
        {7758U, 7759U, 79U}, 
        {7760U, 7761U, 79U}, 
        {7760U, 7761U, 79U}, 
        {7762U, 7763U, 79U}, 
        {7762U, 7763U, 79U}, 
        {7764U, 7765U, 80U}, 
        {7764U, 7765U, 80U}, 
        {7766U, 7767U, 80U}, 
        {7766U, 7767U, 80U}, 
        {7768U, 7769U, 82U}, 
        {7768U, 7769U, 82U}, 
        {7770U, 7771U, 82U}, 
        {7770U, 7771U, 82U}, 
        {7772U, 7773U, 82U}, 
        {7772U, 7773U, 82U}, 
        {7774U, 7775U, 82U}, 
        {7774U, 7775U, 82U}, 
        {7776U, 7777U, 83U}, 
        {7776U, 7777U, 83U}, 
        {7778U, 7779U, 83U}, 
        {7778U, 7779U, 83U}, 
        {7780U, 7781U, 83U}, 
        {7780U, 7781U, 83U}, 
        {7782U, 7783U, 83U}, 
        {7782U, 7783U, 83U}, 
        {7784U, 7785U, 83U}, 
        {7784U, 7785U, 83U}, 
        {7786U, 7787U, 84U}, 
        {7786U, 7787U, 84U}, 
        {7788U, 7789U, 84U}, 
        {7788U, 7789U, 84U}, 
        {7790U, 7791U, 84U}, 
        {7790U, 7791U, 84U}, 
        {7792U, 7793U, 84U}, 
        {7792U, 7793U, 84U}, 
        {7794U, 7795U, 85U}, 
        {7794U, 7795U, 85U}, 
        {7796U, 7797U, 85U}, 
        {7796U, 7797U, 85U}, 
        {7798U, 7799U, 85U}, 
        {7798U, 7799U, 85U}, 
        {7800U, 7801U, 85U}, 
        {7800U, 7801U, 85U}, 
        {7802U, 7803U, 85U}, 
        {7802U, 7803U, 85U}, 
        {7804U, 7805U, 86U}, 
        {7804U, 7805U, 86U}, 
        {7806U, 7807U, 86U}, 
        {7806U, 7807U, 86U}, 
        {7808U, 7809U, 87U}, 
        {7808U, 7809U, 87U}, 
        {7810U, 7811U, 87U}, 
        {7810U, 7811U, 87U}, 
        {7812U, 7813U, 87U}, 
        {7812U, 7813U, 87U}, 
        {7814U, 7815U, 87U}, 
        {7814U, 7815U, 87U}, 
        {7816U, 7817U, 87U}, 
        {7816U, 7817U, 87U}, 
        {7818U, 7819U, 88U}, 
        {7818U, 7819U, 88U}, 
        {7820U, 7821U, 88U}, 
        {7820U, 7821U, 88U}, 
        {7822U, 7823U, 89U}, 
        {7822U, 7823U, 89U}, 
        {7824U, 7825U, 90U}, 
        {7824U, 7825U, 90U}, 
        {7826U, 7827U, 90U}, 
        {7826U, 7827U, 90U}, 
        {7828U, 7829U, 90U}, 
        {7828U, 7829U, 90U}, 
        {7830U, 7830U, 72U}, 
        {7831U, 7831U, 84U}, 
        {7832U, 7832U, 87U}, 
        {7833U, 7833U, 89U}, 
        {7834U, 7834U, 7834U}, 
        {7776U, 7835U, 83U}, 
        {7836U, 7836U, 7836U}, 
        {7837U, 7837U, 7837U}, 
        {7838U, 7838U, 7838U}, 
        {7839U, 7839U, 7839U}, 
        {7840U, 7841U, 65U}, 
        {7840U, 7841U, 65U}, 
        {7842U, 7843U, 65U}, 
        {7842U, 7843U, 65U}, 
        {7844U, 7845U, 65U}, 
        {7844U, 7845U, 65U}, 
        {7846U, 7847U, 65U}, 
        {7846U, 7847U, 65U}, 
        {7848U, 7849U, 65U}, 
        {7848U, 7849U, 65U}, 
        {7850U, 7851U, 65U}, 
        {7850U, 7851U, 65U}, 
        {7852U, 7853U, 65U}, 
        {7852U, 7853U, 65U}, 
        {7854U, 7855U, 65U}, 
        {7854U, 7855U, 65U}, 
        {7856U, 7857U, 65U}, 
        {7856U, 7857U, 65U}, 
        {7858U, 7859U, 65U}, 
        {7858U, 7859U, 65U}, 
        {7860U, 7861U, 65U}, 
        {7860U, 7861U, 65U}, 
        {7862U, 7863U, 65U}, 
        {7862U, 7863U, 65U}, 
        {7864U, 7865U, 69U}, 
        {7864U, 7865U, 69U}, 
        {7866U, 7867U, 69U}, 
        {7866U, 7867U, 69U}, 
        {7868U, 7869U, 69U}, 
        {7868U, 7869U, 69U}, 
        {7870U, 7871U, 69U}, 
        {7870U, 7871U, 69U}, 
        {7872U, 7873U, 69U}, 
        {7872U, 7873U, 69U}, 
        {7874U, 7875U, 69U}, 
        {7874U, 7875U, 69U}, 
        {7876U, 7877U, 69U}, 
        {7876U, 7877U, 69U}, 
        {7878U, 7879U, 69U}, 
        {7878U, 7879U, 69U}, 
        {7880U, 7881U, 73U}, 
        {7880U, 7881U, 73U}, 
        {7882U, 7883U, 73U}, 
        {7882U, 7883U, 73U}, 
        {7884U, 7885U, 79U}, 
        {7884U, 7885U, 79U}, 
        {7886U, 7887U, 79U}, 
        {7886U, 7887U, 79U}, 
        {7888U, 7889U, 79U}, 
        {7888U, 7889U, 79U}, 
        {7890U, 7891U, 79U}, 
        {7890U, 7891U, 79U}, 
        {7892U, 7893U, 79U}, 
        {7892U, 7893U, 79U}, 
        {7894U, 7895U, 79U}, 
        {7894U, 7895U, 79U}, 
        {7896U, 7897U, 79U}, 
        {7896U, 7897U, 79U}, 
        {7898U, 7899U, 79U}, 
        {7898U, 7899U, 79U}, 
        {7900U, 7901U, 79U}, 
        {7900U, 7901U, 79U}, 
        {7902U, 7903U, 79U}, 
        {7902U, 7903U, 79U}, 
        {7904U, 7905U, 79U}, 
        {7904U, 7905U, 79U}, 
        {7906U, 7907U, 79U}, 
        {7906U, 7907U, 79U}, 
        {7908U, 7909U, 85U}, 
        {7908U, 7909U, 85U}, 
        {7910U, 7911U, 85U}, 
        {7910U, 7911U, 85U}, 
        {7912U, 7913U, 85U}, 
        {7912U, 7913U, 85U}, 
        {7914U, 7915U, 85U}, 
        {7914U, 7915U, 85U}, 
        {7916U, 7917U, 85U}, 
        {7916U, 7917U, 85U}, 
        {7918U, 7919U, 85U}, 
        {7918U, 7919U, 85U}, 
        {7920U, 7921U, 85U}, 
        {7920U, 7921U, 85U}, 
        {7922U, 7923U, 89U}, 
        {7922U, 7923U, 89U}, 
        {7924U, 7925U, 89U}, 
        {7924U, 7925U, 89U}, 
        {7926U, 7927U, 89U}, 
        {7926U, 7927U, 89U}, 
        {7928U, 7929U, 89U}, 
        {7928U, 7929U, 89U}, 
        {7930U, 7930U, 7930U}, 
        {7931U, 7931U, 7931U}, 
        {7932U, 7932U, 7932U}, 
        {7933U, 7933U, 7933U}, 
        {7934U, 7934U, 7934U}, 
        {7935U, 7935U, 7935U}};
#line 952 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane1F[256]  = 
#line 952
  {      {7944U, 7936U, 913U}, 
        {7945U, 7937U, 913U}, 
        {7946U, 7938U, 913U}, 
        {7947U, 7939U, 913U}, 
        {7948U, 7940U, 913U}, 
        {7949U, 7941U, 913U}, 
        {7950U, 7942U, 913U}, 
        {7951U, 7943U, 913U}, 
        {7944U, 7936U, 913U}, 
        {7945U, 7937U, 913U}, 
        {7946U, 7938U, 913U}, 
        {7947U, 7939U, 913U}, 
        {7948U, 7940U, 913U}, 
        {7949U, 7941U, 913U}, 
        {7950U, 7942U, 913U}, 
        {7951U, 7943U, 913U}, 
        {7960U, 7952U, 917U}, 
        {7961U, 7953U, 917U}, 
        {7962U, 7954U, 917U}, 
        {7963U, 7955U, 917U}, 
        {7964U, 7956U, 917U}, 
        {7965U, 7957U, 917U}, 
        {7958U, 7958U, 7958U}, 
        {7959U, 7959U, 7959U}, 
        {7960U, 7952U, 917U}, 
        {7961U, 7953U, 917U}, 
        {7962U, 7954U, 917U}, 
        {7963U, 7955U, 917U}, 
        {7964U, 7956U, 917U}, 
        {7965U, 7957U, 917U}, 
        {7966U, 7966U, 7966U}, 
        {7967U, 7967U, 7967U}, 
        {7976U, 7968U, 919U}, 
        {7977U, 7969U, 919U}, 
        {7978U, 7970U, 919U}, 
        {7979U, 7971U, 919U}, 
        {7980U, 7972U, 919U}, 
        {7981U, 7973U, 919U}, 
        {7982U, 7974U, 919U}, 
        {7983U, 7975U, 919U}, 
        {7976U, 7968U, 919U}, 
        {7977U, 7969U, 919U}, 
        {7978U, 7970U, 919U}, 
        {7979U, 7971U, 919U}, 
        {7980U, 7972U, 919U}, 
        {7981U, 7973U, 919U}, 
        {7982U, 7974U, 919U}, 
        {7983U, 7975U, 919U}, 
        {7992U, 7984U, 921U}, 
        {7993U, 7985U, 921U}, 
        {7994U, 7986U, 921U}, 
        {7995U, 7987U, 921U}, 
        {7996U, 7988U, 921U}, 
        {7997U, 7989U, 921U}, 
        {7998U, 7990U, 921U}, 
        {7999U, 7991U, 921U}, 
        {7992U, 7984U, 921U}, 
        {7993U, 7985U, 921U}, 
        {7994U, 7986U, 921U}, 
        {7995U, 7987U, 921U}, 
        {7996U, 7988U, 921U}, 
        {7997U, 7989U, 921U}, 
        {7998U, 7990U, 921U}, 
        {7999U, 7991U, 921U}, 
        {8008U, 8000U, 927U}, 
        {8009U, 8001U, 927U}, 
        {8010U, 8002U, 927U}, 
        {8011U, 8003U, 927U}, 
        {8012U, 8004U, 927U}, 
        {8013U, 8005U, 927U}, 
        {8006U, 8006U, 8006U}, 
        {8007U, 8007U, 8007U}, 
        {8008U, 8000U, 927U}, 
        {8009U, 8001U, 927U}, 
        {8010U, 8002U, 927U}, 
        {8011U, 8003U, 927U}, 
        {8012U, 8004U, 927U}, 
        {8013U, 8005U, 927U}, 
        {8014U, 8014U, 8014U}, 
        {8015U, 8015U, 8015U}, 
        {8016U, 8016U, 933U}, 
        {8025U, 8017U, 933U}, 
        {8018U, 8018U, 933U}, 
        {8027U, 8019U, 933U}, 
        {8020U, 8020U, 933U}, 
        {8029U, 8021U, 933U}, 
        {8022U, 8022U, 933U}, 
        {8031U, 8023U, 933U}, 
        {8024U, 8024U, 8024U}, 
        {8025U, 8017U, 933U}, 
        {8026U, 8026U, 8026U}, 
        {8027U, 8019U, 933U}, 
        {8028U, 8028U, 8028U}, 
        {8029U, 8021U, 933U}, 
        {8030U, 8030U, 8030U}, 
        {8031U, 8023U, 933U}, 
        {8040U, 8032U, 937U}, 
        {8041U, 8033U, 937U}, 
        {8042U, 8034U, 937U}, 
        {8043U, 8035U, 937U}, 
        {8044U, 8036U, 937U}, 
        {8045U, 8037U, 937U}, 
        {8046U, 8038U, 937U}, 
        {8047U, 8039U, 937U}, 
        {8040U, 8032U, 937U}, 
        {8041U, 8033U, 937U}, 
        {8042U, 8034U, 937U}, 
        {8043U, 8035U, 937U}, 
        {8044U, 8036U, 937U}, 
        {8045U, 8037U, 937U}, 
        {8046U, 8038U, 937U}, 
        {8047U, 8039U, 937U}, 
        {8122U, 8048U, 913U}, 
        {8123U, 8049U, 8123U}, 
        {8136U, 8050U, 917U}, 
        {8137U, 8051U, 8137U}, 
        {8138U, 8052U, 919U}, 
        {8139U, 8053U, 8139U}, 
        {8154U, 8054U, 921U}, 
        {8155U, 8055U, 8155U}, 
        {8184U, 8056U, 927U}, 
        {8185U, 8057U, 8185U}, 
        {8170U, 8058U, 933U}, 
        {8171U, 8059U, 8171U}, 
        {8186U, 8060U, 937U}, 
        {8187U, 8061U, 8187U}, 
        {8062U, 8062U, 8062U}, 
        {8063U, 8063U, 8063U}, 
        {8072U, 8064U, 913U}, 
        {8073U, 8065U, 913U}, 
        {8074U, 8066U, 913U}, 
        {8075U, 8067U, 913U}, 
        {8076U, 8068U, 913U}, 
        {8077U, 8069U, 913U}, 
        {8078U, 8070U, 913U}, 
        {8079U, 8071U, 913U}, 
        {8072U, 8064U, 913U}, 
        {8073U, 8065U, 913U}, 
        {8074U, 8066U, 913U}, 
        {8075U, 8067U, 913U}, 
        {8076U, 8068U, 913U}, 
        {8077U, 8069U, 913U}, 
        {8078U, 8070U, 913U}, 
        {8079U, 8071U, 913U}, 
        {8088U, 8080U, 919U}, 
        {8089U, 8081U, 919U}, 
        {8090U, 8082U, 919U}, 
        {8091U, 8083U, 919U}, 
        {8092U, 8084U, 919U}, 
        {8093U, 8085U, 919U}, 
        {8094U, 8086U, 919U}, 
        {8095U, 8087U, 919U}, 
        {8088U, 8080U, 919U}, 
        {8089U, 8081U, 919U}, 
        {8090U, 8082U, 919U}, 
        {8091U, 8083U, 919U}, 
        {8092U, 8084U, 919U}, 
        {8093U, 8085U, 919U}, 
        {8094U, 8086U, 919U}, 
        {8095U, 8087U, 919U}, 
        {8104U, 8096U, 937U}, 
        {8105U, 8097U, 937U}, 
        {8106U, 8098U, 937U}, 
        {8107U, 8099U, 937U}, 
        {8108U, 8100U, 937U}, 
        {8109U, 8101U, 937U}, 
        {8110U, 8102U, 937U}, 
        {8111U, 8103U, 937U}, 
        {8104U, 8096U, 937U}, 
        {8105U, 8097U, 937U}, 
        {8106U, 8098U, 937U}, 
        {8107U, 8099U, 937U}, 
        {8108U, 8100U, 937U}, 
        {8109U, 8101U, 937U}, 
        {8110U, 8102U, 937U}, 
        {8111U, 8103U, 937U}, 
        {8120U, 8112U, 913U}, 
        {8121U, 8113U, 913U}, 
        {8114U, 8114U, 913U}, 
        {8124U, 8115U, 913U}, 
        {8116U, 8116U, 913U}, 
        {8117U, 8117U, 8117U}, 
        {8118U, 8118U, 913U}, 
        {8119U, 8119U, 913U}, 
        {8120U, 8112U, 913U}, 
        {8121U, 8113U, 913U}, 
        {8122U, 8048U, 913U}, 
        {8123U, 8049U, 8123U}, 
        {8124U, 8115U, 913U}, 
        {8125U, 8125U, 8125U}, 
        {921U, 8126U, 921U}, 
        {8127U, 8127U, 8127U}, 
        {8128U, 8128U, 8128U}, 
        {8129U, 8129U, 8129U}, 
        {8130U, 8130U, 919U}, 
        {8140U, 8131U, 919U}, 
        {8132U, 8132U, 919U}, 
        {8133U, 8133U, 8133U}, 
        {8134U, 8134U, 919U}, 
        {8135U, 8135U, 919U}, 
        {8136U, 8050U, 917U}, 
        {8137U, 8051U, 8137U}, 
        {8138U, 8052U, 919U}, 
        {8139U, 8053U, 8139U}, 
        {8140U, 8131U, 919U}, 
        {8141U, 8141U, 8141U}, 
        {8142U, 8142U, 8142U}, 
        {8143U, 8143U, 8143U}, 
        {8152U, 8144U, 921U}, 
        {8153U, 8145U, 921U}, 
        {8146U, 8146U, 921U}, 
        {8147U, 8147U, 8147U}, 
        {8148U, 8148U, 8148U}, 
        {8149U, 8149U, 8149U}, 
        {8150U, 8150U, 921U}, 
        {8151U, 8151U, 921U}, 
        {8152U, 8144U, 921U}, 
        {8153U, 8145U, 921U}, 
        {8154U, 8054U, 921U}, 
        {8155U, 8055U, 8155U}, 
        {8156U, 8156U, 8156U}, 
        {8157U, 8157U, 8157U}, 
        {8158U, 8158U, 8158U}, 
        {8159U, 8159U, 8159U}, 
        {8168U, 8160U, 933U}, 
        {8169U, 8161U, 933U}, 
        {8162U, 8162U, 933U}, 
        {8163U, 8163U, 8163U}, 
        {8164U, 8164U, 929U}, 
        {8172U, 8165U, 929U}, 
        {8166U, 8166U, 933U}, 
        {8167U, 8167U, 933U}, 
        {8168U, 8160U, 933U}, 
        {8169U, 8161U, 933U}, 
        {8170U, 8058U, 933U}, 
        {8171U, 8059U, 8171U}, 
        {8172U, 8165U, 929U}, 
        {8173U, 8173U, 8173U}, 
        {8174U, 8174U, 8174U}, 
        {8175U, 8175U, 8175U}, 
        {8176U, 8176U, 8176U}, 
        {8177U, 8177U, 8177U}, 
        {8178U, 8178U, 937U}, 
        {8188U, 8179U, 937U}, 
        {8180U, 8180U, 937U}, 
        {8181U, 8181U, 8181U}, 
        {8182U, 8182U, 937U}, 
        {8183U, 8183U, 937U}, 
        {8184U, 8056U, 927U}, 
        {8185U, 8057U, 8185U}, 
        {8186U, 8060U, 937U}, 
        {8187U, 8061U, 8187U}, 
        {8188U, 8179U, 937U}, 
        {8189U, 8189U, 8189U}, 
        {8190U, 8190U, 8190U}, 
        {8191U, 8191U, 8191U}};
#line 1083 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane21[256]  = 
#line 1083
  {      {8448U, 8448U, 8448U}, 
        {8449U, 8449U, 8449U}, 
        {8450U, 8450U, 8450U}, 
        {8451U, 8451U, 8451U}, 
        {8452U, 8452U, 8452U}, 
        {8453U, 8453U, 8453U}, 
        {8454U, 8454U, 8454U}, 
        {8455U, 8455U, 8455U}, 
        {8456U, 8456U, 8456U}, 
        {8457U, 8457U, 8457U}, 
        {8458U, 8458U, 8458U}, 
        {8459U, 8459U, 8459U}, 
        {8460U, 8460U, 8460U}, 
        {8461U, 8461U, 8461U}, 
        {8462U, 8462U, 8462U}, 
        {8463U, 8463U, 8463U}, 
        {8464U, 8464U, 8464U}, 
        {8465U, 8465U, 8465U}, 
        {8466U, 8466U, 8466U}, 
        {8467U, 8467U, 8467U}, 
        {8468U, 8468U, 8468U}, 
        {8469U, 8469U, 8469U}, 
        {8470U, 8470U, 8470U}, 
        {8471U, 8471U, 8471U}, 
        {8472U, 8472U, 8472U}, 
        {8473U, 8473U, 8473U}, 
        {8474U, 8474U, 8474U}, 
        {8475U, 8475U, 8475U}, 
        {8476U, 8476U, 8476U}, 
        {8477U, 8477U, 8477U}, 
        {8478U, 8478U, 8478U}, 
        {8479U, 8479U, 8479U}, 
        {8480U, 8480U, 8480U}, 
        {8481U, 8481U, 8481U}, 
        {8482U, 8482U, 8482U}, 
        {8483U, 8483U, 8483U}, 
        {8484U, 8484U, 8484U}, 
        {8485U, 8485U, 8485U}, 
        {8486U, 969U, 8486U}, 
        {8487U, 8487U, 8487U}, 
        {8488U, 8488U, 8488U}, 
        {8489U, 8489U, 8489U}, 
        {8490U, 107U, 8490U}, 
        {8491U, 229U, 8491U}, 
        {8492U, 8492U, 8492U}, 
        {8493U, 8493U, 8493U}, 
        {8494U, 8494U, 8494U}, 
        {8495U, 8495U, 8495U}, 
        {8496U, 8496U, 8496U}, 
        {8497U, 8497U, 8497U}, 
        {8498U, 8498U, 8498U}, 
        {8499U, 8499U, 8499U}, 
        {8500U, 8500U, 8500U}, 
        {8501U, 8501U, 8501U}, 
        {8502U, 8502U, 8502U}, 
        {8503U, 8503U, 8503U}, 
        {8504U, 8504U, 8504U}, 
        {8505U, 8505U, 8505U}, 
        {8506U, 8506U, 8506U}, 
        {8507U, 8507U, 8507U}, 
        {8508U, 8508U, 8508U}, 
        {8509U, 8509U, 8509U}, 
        {8510U, 8510U, 8510U}, 
        {8511U, 8511U, 8511U}, 
        {8512U, 8512U, 8512U}, 
        {8513U, 8513U, 8513U}, 
        {8514U, 8514U, 8514U}, 
        {8515U, 8515U, 8515U}, 
        {8516U, 8516U, 8516U}, 
        {8517U, 8517U, 8517U}, 
        {8518U, 8518U, 8518U}, 
        {8519U, 8519U, 8519U}, 
        {8520U, 8520U, 8520U}, 
        {8521U, 8521U, 8521U}, 
        {8522U, 8522U, 8522U}, 
        {8523U, 8523U, 8523U}, 
        {8524U, 8524U, 8524U}, 
        {8525U, 8525U, 8525U}, 
        {8526U, 8526U, 8526U}, 
        {8527U, 8527U, 8527U}, 
        {8528U, 8528U, 8528U}, 
        {8529U, 8529U, 8529U}, 
        {8530U, 8530U, 8530U}, 
        {8531U, 8531U, 8531U}, 
        {8532U, 8532U, 8532U}, 
        {8533U, 8533U, 8533U}, 
        {8534U, 8534U, 8534U}, 
        {8535U, 8535U, 8535U}, 
        {8536U, 8536U, 8536U}, 
        {8537U, 8537U, 8537U}, 
        {8538U, 8538U, 8538U}, 
        {8539U, 8539U, 8539U}, 
        {8540U, 8540U, 8540U}, 
        {8541U, 8541U, 8541U}, 
        {8542U, 8542U, 8542U}, 
        {8543U, 8543U, 8543U}, 
        {8544U, 8560U, 8544U}, 
        {8545U, 8561U, 8545U}, 
        {8546U, 8562U, 8546U}, 
        {8547U, 8563U, 8547U}, 
        {8548U, 8564U, 8548U}, 
        {8549U, 8565U, 8549U}, 
        {8550U, 8566U, 8550U}, 
        {8551U, 8567U, 8551U}, 
        {8552U, 8568U, 8552U}, 
        {8553U, 8569U, 8553U}, 
        {8554U, 8570U, 8554U}, 
        {8555U, 8571U, 8555U}, 
        {8556U, 8572U, 8556U}, 
        {8557U, 8573U, 8557U}, 
        {8558U, 8574U, 8558U}, 
        {8559U, 8575U, 8559U}, 
        {8544U, 8560U, 8544U}, 
        {8545U, 8561U, 8545U}, 
        {8546U, 8562U, 8546U}, 
        {8547U, 8563U, 8547U}, 
        {8548U, 8564U, 8548U}, 
        {8549U, 8565U, 8549U}, 
        {8550U, 8566U, 8550U}, 
        {8551U, 8567U, 8551U}, 
        {8552U, 8568U, 8552U}, 
        {8553U, 8569U, 8553U}, 
        {8554U, 8570U, 8554U}, 
        {8555U, 8571U, 8555U}, 
        {8556U, 8572U, 8556U}, 
        {8557U, 8573U, 8557U}, 
        {8558U, 8574U, 8558U}, 
        {8559U, 8575U, 8559U}, 
        {8576U, 8576U, 8576U}, 
        {8577U, 8577U, 8577U}, 
        {8578U, 8578U, 8578U}, 
        {8579U, 8579U, 8579U}, 
        {8580U, 8580U, 8580U}, 
        {8581U, 8581U, 8581U}, 
        {8582U, 8582U, 8582U}, 
        {8583U, 8583U, 8583U}, 
        {8584U, 8584U, 8584U}, 
        {8585U, 8585U, 8585U}, 
        {8586U, 8586U, 8586U}, 
        {8587U, 8587U, 8587U}, 
        {8588U, 8588U, 8588U}, 
        {8589U, 8589U, 8589U}, 
        {8590U, 8590U, 8590U}, 
        {8591U, 8591U, 8591U}, 
        {8592U, 8592U, 8592U}, 
        {8593U, 8593U, 8593U}, 
        {8594U, 8594U, 8594U}, 
        {8595U, 8595U, 8595U}, 
        {8596U, 8596U, 8596U}, 
        {8597U, 8597U, 8597U}, 
        {8598U, 8598U, 8598U}, 
        {8599U, 8599U, 8599U}, 
        {8600U, 8600U, 8600U}, 
        {8601U, 8601U, 8601U}, 
        {8602U, 8602U, 8602U}, 
        {8603U, 8603U, 8603U}, 
        {8604U, 8604U, 8604U}, 
        {8605U, 8605U, 8605U}, 
        {8606U, 8606U, 8606U}, 
        {8607U, 8607U, 8607U}, 
        {8608U, 8608U, 8608U}, 
        {8609U, 8609U, 8609U}, 
        {8610U, 8610U, 8610U}, 
        {8611U, 8611U, 8611U}, 
        {8612U, 8612U, 8612U}, 
        {8613U, 8613U, 8613U}, 
        {8614U, 8614U, 8614U}, 
        {8615U, 8615U, 8615U}, 
        {8616U, 8616U, 8616U}, 
        {8617U, 8617U, 8617U}, 
        {8618U, 8618U, 8618U}, 
        {8619U, 8619U, 8619U}, 
        {8620U, 8620U, 8620U}, 
        {8621U, 8621U, 8621U}, 
        {8622U, 8622U, 8622U}, 
        {8623U, 8623U, 8623U}, 
        {8624U, 8624U, 8624U}, 
        {8625U, 8625U, 8625U}, 
        {8626U, 8626U, 8626U}, 
        {8627U, 8627U, 8627U}, 
        {8628U, 8628U, 8628U}, 
        {8629U, 8629U, 8629U}, 
        {8630U, 8630U, 8630U}, 
        {8631U, 8631U, 8631U}, 
        {8632U, 8632U, 8632U}, 
        {8633U, 8633U, 8633U}, 
        {8634U, 8634U, 8634U}, 
        {8635U, 8635U, 8635U}, 
        {8636U, 8636U, 8636U}, 
        {8637U, 8637U, 8637U}, 
        {8638U, 8638U, 8638U}, 
        {8639U, 8639U, 8639U}, 
        {8640U, 8640U, 8640U}, 
        {8641U, 8641U, 8641U}, 
        {8642U, 8642U, 8642U}, 
        {8643U, 8643U, 8643U}, 
        {8644U, 8644U, 8644U}, 
        {8645U, 8645U, 8645U}, 
        {8646U, 8646U, 8646U}, 
        {8647U, 8647U, 8647U}, 
        {8648U, 8648U, 8648U}, 
        {8649U, 8649U, 8649U}, 
        {8650U, 8650U, 8650U}, 
        {8651U, 8651U, 8651U}, 
        {8652U, 8652U, 8652U}, 
        {8653U, 8653U, 8653U}, 
        {8654U, 8654U, 8654U}, 
        {8655U, 8655U, 8655U}, 
        {8656U, 8656U, 8656U}, 
        {8657U, 8657U, 8657U}, 
        {8658U, 8658U, 8658U}, 
        {8659U, 8659U, 8659U}, 
        {8660U, 8660U, 8660U}, 
        {8661U, 8661U, 8661U}, 
        {8662U, 8662U, 8662U}, 
        {8663U, 8663U, 8663U}, 
        {8664U, 8664U, 8664U}, 
        {8665U, 8665U, 8665U}, 
        {8666U, 8666U, 8666U}, 
        {8667U, 8667U, 8667U}, 
        {8668U, 8668U, 8668U}, 
        {8669U, 8669U, 8669U}, 
        {8670U, 8670U, 8670U}, 
        {8671U, 8671U, 8671U}, 
        {8672U, 8672U, 8672U}, 
        {8673U, 8673U, 8673U}, 
        {8674U, 8674U, 8674U}, 
        {8675U, 8675U, 8675U}, 
        {8676U, 8676U, 8676U}, 
        {8677U, 8677U, 8677U}, 
        {8678U, 8678U, 8678U}, 
        {8679U, 8679U, 8679U}, 
        {8680U, 8680U, 8680U}, 
        {8681U, 8681U, 8681U}, 
        {8682U, 8682U, 8682U}, 
        {8683U, 8683U, 8683U}, 
        {8684U, 8684U, 8684U}, 
        {8685U, 8685U, 8685U}, 
        {8686U, 8686U, 8686U}, 
        {8687U, 8687U, 8687U}, 
        {8688U, 8688U, 8688U}, 
        {8689U, 8689U, 8689U}, 
        {8690U, 8690U, 8690U}, 
        {8691U, 8691U, 8691U}, 
        {8692U, 8692U, 8692U}, 
        {8693U, 8693U, 8693U}, 
        {8694U, 8694U, 8694U}, 
        {8695U, 8695U, 8695U}, 
        {8696U, 8696U, 8696U}, 
        {8697U, 8697U, 8697U}, 
        {8698U, 8698U, 8698U}, 
        {8699U, 8699U, 8699U}, 
        {8700U, 8700U, 8700U}, 
        {8701U, 8701U, 8701U}, 
        {8702U, 8702U, 8702U}, 
        {8703U, 8703U, 8703U}};
#line 1214 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane24[256]  = 
#line 1214
  {      {9216U, 9216U, 9216U}, 
        {9217U, 9217U, 9217U}, 
        {9218U, 9218U, 9218U}, 
        {9219U, 9219U, 9219U}, 
        {9220U, 9220U, 9220U}, 
        {9221U, 9221U, 9221U}, 
        {9222U, 9222U, 9222U}, 
        {9223U, 9223U, 9223U}, 
        {9224U, 9224U, 9224U}, 
        {9225U, 9225U, 9225U}, 
        {9226U, 9226U, 9226U}, 
        {9227U, 9227U, 9227U}, 
        {9228U, 9228U, 9228U}, 
        {9229U, 9229U, 9229U}, 
        {9230U, 9230U, 9230U}, 
        {9231U, 9231U, 9231U}, 
        {9232U, 9232U, 9232U}, 
        {9233U, 9233U, 9233U}, 
        {9234U, 9234U, 9234U}, 
        {9235U, 9235U, 9235U}, 
        {9236U, 9236U, 9236U}, 
        {9237U, 9237U, 9237U}, 
        {9238U, 9238U, 9238U}, 
        {9239U, 9239U, 9239U}, 
        {9240U, 9240U, 9240U}, 
        {9241U, 9241U, 9241U}, 
        {9242U, 9242U, 9242U}, 
        {9243U, 9243U, 9243U}, 
        {9244U, 9244U, 9244U}, 
        {9245U, 9245U, 9245U}, 
        {9246U, 9246U, 9246U}, 
        {9247U, 9247U, 9247U}, 
        {9248U, 9248U, 9248U}, 
        {9249U, 9249U, 9249U}, 
        {9250U, 9250U, 9250U}, 
        {9251U, 9251U, 9251U}, 
        {9252U, 9252U, 9252U}, 
        {9253U, 9253U, 9253U}, 
        {9254U, 9254U, 9254U}, 
        {9255U, 9255U, 9255U}, 
        {9256U, 9256U, 9256U}, 
        {9257U, 9257U, 9257U}, 
        {9258U, 9258U, 9258U}, 
        {9259U, 9259U, 9259U}, 
        {9260U, 9260U, 9260U}, 
        {9261U, 9261U, 9261U}, 
        {9262U, 9262U, 9262U}, 
        {9263U, 9263U, 9263U}, 
        {9264U, 9264U, 9264U}, 
        {9265U, 9265U, 9265U}, 
        {9266U, 9266U, 9266U}, 
        {9267U, 9267U, 9267U}, 
        {9268U, 9268U, 9268U}, 
        {9269U, 9269U, 9269U}, 
        {9270U, 9270U, 9270U}, 
        {9271U, 9271U, 9271U}, 
        {9272U, 9272U, 9272U}, 
        {9273U, 9273U, 9273U}, 
        {9274U, 9274U, 9274U}, 
        {9275U, 9275U, 9275U}, 
        {9276U, 9276U, 9276U}, 
        {9277U, 9277U, 9277U}, 
        {9278U, 9278U, 9278U}, 
        {9279U, 9279U, 9279U}, 
        {9280U, 9280U, 9280U}, 
        {9281U, 9281U, 9281U}, 
        {9282U, 9282U, 9282U}, 
        {9283U, 9283U, 9283U}, 
        {9284U, 9284U, 9284U}, 
        {9285U, 9285U, 9285U}, 
        {9286U, 9286U, 9286U}, 
        {9287U, 9287U, 9287U}, 
        {9288U, 9288U, 9288U}, 
        {9289U, 9289U, 9289U}, 
        {9290U, 9290U, 9290U}, 
        {9291U, 9291U, 9291U}, 
        {9292U, 9292U, 9292U}, 
        {9293U, 9293U, 9293U}, 
        {9294U, 9294U, 9294U}, 
        {9295U, 9295U, 9295U}, 
        {9296U, 9296U, 9296U}, 
        {9297U, 9297U, 9297U}, 
        {9298U, 9298U, 9298U}, 
        {9299U, 9299U, 9299U}, 
        {9300U, 9300U, 9300U}, 
        {9301U, 9301U, 9301U}, 
        {9302U, 9302U, 9302U}, 
        {9303U, 9303U, 9303U}, 
        {9304U, 9304U, 9304U}, 
        {9305U, 9305U, 9305U}, 
        {9306U, 9306U, 9306U}, 
        {9307U, 9307U, 9307U}, 
        {9308U, 9308U, 9308U}, 
        {9309U, 9309U, 9309U}, 
        {9310U, 9310U, 9310U}, 
        {9311U, 9311U, 9311U}, 
        {9312U, 9312U, 9312U}, 
        {9313U, 9313U, 9313U}, 
        {9314U, 9314U, 9314U}, 
        {9315U, 9315U, 9315U}, 
        {9316U, 9316U, 9316U}, 
        {9317U, 9317U, 9317U}, 
        {9318U, 9318U, 9318U}, 
        {9319U, 9319U, 9319U}, 
        {9320U, 9320U, 9320U}, 
        {9321U, 9321U, 9321U}, 
        {9322U, 9322U, 9322U}, 
        {9323U, 9323U, 9323U}, 
        {9324U, 9324U, 9324U}, 
        {9325U, 9325U, 9325U}, 
        {9326U, 9326U, 9326U}, 
        {9327U, 9327U, 9327U}, 
        {9328U, 9328U, 9328U}, 
        {9329U, 9329U, 9329U}, 
        {9330U, 9330U, 9330U}, 
        {9331U, 9331U, 9331U}, 
        {9332U, 9332U, 9332U}, 
        {9333U, 9333U, 9333U}, 
        {9334U, 9334U, 9334U}, 
        {9335U, 9335U, 9335U}, 
        {9336U, 9336U, 9336U}, 
        {9337U, 9337U, 9337U}, 
        {9338U, 9338U, 9338U}, 
        {9339U, 9339U, 9339U}, 
        {9340U, 9340U, 9340U}, 
        {9341U, 9341U, 9341U}, 
        {9342U, 9342U, 9342U}, 
        {9343U, 9343U, 9343U}, 
        {9344U, 9344U, 9344U}, 
        {9345U, 9345U, 9345U}, 
        {9346U, 9346U, 9346U}, 
        {9347U, 9347U, 9347U}, 
        {9348U, 9348U, 9348U}, 
        {9349U, 9349U, 9349U}, 
        {9350U, 9350U, 9350U}, 
        {9351U, 9351U, 9351U}, 
        {9352U, 9352U, 9352U}, 
        {9353U, 9353U, 9353U}, 
        {9354U, 9354U, 9354U}, 
        {9355U, 9355U, 9355U}, 
        {9356U, 9356U, 9356U}, 
        {9357U, 9357U, 9357U}, 
        {9358U, 9358U, 9358U}, 
        {9359U, 9359U, 9359U}, 
        {9360U, 9360U, 9360U}, 
        {9361U, 9361U, 9361U}, 
        {9362U, 9362U, 9362U}, 
        {9363U, 9363U, 9363U}, 
        {9364U, 9364U, 9364U}, 
        {9365U, 9365U, 9365U}, 
        {9366U, 9366U, 9366U}, 
        {9367U, 9367U, 9367U}, 
        {9368U, 9368U, 9368U}, 
        {9369U, 9369U, 9369U}, 
        {9370U, 9370U, 9370U}, 
        {9371U, 9371U, 9371U}, 
        {9372U, 9372U, 9372U}, 
        {9373U, 9373U, 9373U}, 
        {9374U, 9374U, 9374U}, 
        {9375U, 9375U, 9375U}, 
        {9376U, 9376U, 9376U}, 
        {9377U, 9377U, 9377U}, 
        {9378U, 9378U, 9378U}, 
        {9379U, 9379U, 9379U}, 
        {9380U, 9380U, 9380U}, 
        {9381U, 9381U, 9381U}, 
        {9382U, 9382U, 9382U}, 
        {9383U, 9383U, 9383U}, 
        {9384U, 9384U, 9384U}, 
        {9385U, 9385U, 9385U}, 
        {9386U, 9386U, 9386U}, 
        {9387U, 9387U, 9387U}, 
        {9388U, 9388U, 9388U}, 
        {9389U, 9389U, 9389U}, 
        {9390U, 9390U, 9390U}, 
        {9391U, 9391U, 9391U}, 
        {9392U, 9392U, 9392U}, 
        {9393U, 9393U, 9393U}, 
        {9394U, 9394U, 9394U}, 
        {9395U, 9395U, 9395U}, 
        {9396U, 9396U, 9396U}, 
        {9397U, 9397U, 9397U}, 
        {9398U, 9424U, 9398U}, 
        {9399U, 9425U, 9399U}, 
        {9400U, 9426U, 9400U}, 
        {9401U, 9427U, 9401U}, 
        {9402U, 9428U, 9402U}, 
        {9403U, 9429U, 9403U}, 
        {9404U, 9430U, 9404U}, 
        {9405U, 9431U, 9405U}, 
        {9406U, 9432U, 9406U}, 
        {9407U, 9433U, 9407U}, 
        {9408U, 9434U, 9408U}, 
        {9409U, 9435U, 9409U}, 
        {9410U, 9436U, 9410U}, 
        {9411U, 9437U, 9411U}, 
        {9412U, 9438U, 9412U}, 
        {9413U, 9439U, 9413U}, 
        {9414U, 9440U, 9414U}, 
        {9415U, 9441U, 9415U}, 
        {9416U, 9442U, 9416U}, 
        {9417U, 9443U, 9417U}, 
        {9418U, 9444U, 9418U}, 
        {9419U, 9445U, 9419U}, 
        {9420U, 9446U, 9420U}, 
        {9421U, 9447U, 9421U}, 
        {9422U, 9448U, 9422U}, 
        {9423U, 9449U, 9423U}, 
        {9398U, 9424U, 9398U}, 
        {9399U, 9425U, 9399U}, 
        {9400U, 9426U, 9400U}, 
        {9401U, 9427U, 9401U}, 
        {9402U, 9428U, 9402U}, 
        {9403U, 9429U, 9403U}, 
        {9404U, 9430U, 9404U}, 
        {9405U, 9431U, 9405U}, 
        {9406U, 9432U, 9406U}, 
        {9407U, 9433U, 9407U}, 
        {9408U, 9434U, 9408U}, 
        {9409U, 9435U, 9409U}, 
        {9410U, 9436U, 9410U}, 
        {9411U, 9437U, 9411U}, 
        {9412U, 9438U, 9412U}, 
        {9413U, 9439U, 9413U}, 
        {9414U, 9440U, 9414U}, 
        {9415U, 9441U, 9415U}, 
        {9416U, 9442U, 9416U}, 
        {9417U, 9443U, 9417U}, 
        {9418U, 9444U, 9418U}, 
        {9419U, 9445U, 9419U}, 
        {9420U, 9446U, 9420U}, 
        {9421U, 9447U, 9421U}, 
        {9422U, 9448U, 9422U}, 
        {9423U, 9449U, 9423U}, 
        {9450U, 9450U, 9450U}, 
        {9451U, 9451U, 9451U}, 
        {9452U, 9452U, 9452U}, 
        {9453U, 9453U, 9453U}, 
        {9454U, 9454U, 9454U}, 
        {9455U, 9455U, 9455U}, 
        {9456U, 9456U, 9456U}, 
        {9457U, 9457U, 9457U}, 
        {9458U, 9458U, 9458U}, 
        {9459U, 9459U, 9459U}, 
        {9460U, 9460U, 9460U}, 
        {9461U, 9461U, 9461U}, 
        {9462U, 9462U, 9462U}, 
        {9463U, 9463U, 9463U}, 
        {9464U, 9464U, 9464U}, 
        {9465U, 9465U, 9465U}, 
        {9466U, 9466U, 9466U}, 
        {9467U, 9467U, 9467U}, 
        {9468U, 9468U, 9468U}, 
        {9469U, 9469U, 9469U}, 
        {9470U, 9470U, 9470U}, 
        {9471U, 9471U, 9471U}};
#line 1345 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO planeFF[256]  = 
#line 1345
  {      {65280U, 65280U, 65280U}, 
        {65281U, 65281U, 65281U}, 
        {65282U, 65282U, 65282U}, 
        {65283U, 65283U, 65283U}, 
        {65284U, 65284U, 65284U}, 
        {65285U, 65285U, 65285U}, 
        {65286U, 65286U, 65286U}, 
        {65287U, 65287U, 65287U}, 
        {65288U, 65288U, 65288U}, 
        {65289U, 65289U, 65289U}, 
        {65290U, 65290U, 65290U}, 
        {65291U, 65291U, 65291U}, 
        {65292U, 65292U, 65292U}, 
        {65293U, 65293U, 65293U}, 
        {65294U, 65294U, 65294U}, 
        {65295U, 65295U, 65295U}, 
        {65296U, 65296U, 65296U}, 
        {65297U, 65297U, 65297U}, 
        {65298U, 65298U, 65298U}, 
        {65299U, 65299U, 65299U}, 
        {65300U, 65300U, 65300U}, 
        {65301U, 65301U, 65301U}, 
        {65302U, 65302U, 65302U}, 
        {65303U, 65303U, 65303U}, 
        {65304U, 65304U, 65304U}, 
        {65305U, 65305U, 65305U}, 
        {65306U, 65306U, 65306U}, 
        {65307U, 65307U, 65307U}, 
        {65308U, 65308U, 65308U}, 
        {65309U, 65309U, 65309U}, 
        {65310U, 65310U, 65310U}, 
        {65311U, 65311U, 65311U}, 
        {65312U, 65312U, 65312U}, 
        {65313U, 65345U, 65313U}, 
        {65314U, 65346U, 65314U}, 
        {65315U, 65347U, 65315U}, 
        {65316U, 65348U, 65316U}, 
        {65317U, 65349U, 65317U}, 
        {65318U, 65350U, 65318U}, 
        {65319U, 65351U, 65319U}, 
        {65320U, 65352U, 65320U}, 
        {65321U, 65353U, 65321U}, 
        {65322U, 65354U, 65322U}, 
        {65323U, 65355U, 65323U}, 
        {65324U, 65356U, 65324U}, 
        {65325U, 65357U, 65325U}, 
        {65326U, 65358U, 65326U}, 
        {65327U, 65359U, 65327U}, 
        {65328U, 65360U, 65328U}, 
        {65329U, 65361U, 65329U}, 
        {65330U, 65362U, 65330U}, 
        {65331U, 65363U, 65331U}, 
        {65332U, 65364U, 65332U}, 
        {65333U, 65365U, 65333U}, 
        {65334U, 65366U, 65334U}, 
        {65335U, 65367U, 65335U}, 
        {65336U, 65368U, 65336U}, 
        {65337U, 65369U, 65337U}, 
        {65338U, 65370U, 65338U}, 
        {65339U, 65339U, 65339U}, 
        {65340U, 65340U, 65340U}, 
        {65341U, 65341U, 65341U}, 
        {65342U, 65342U, 65342U}, 
        {65343U, 65343U, 65343U}, 
        {65344U, 65344U, 65344U}, 
        {65313U, 65345U, 65313U}, 
        {65314U, 65346U, 65314U}, 
        {65315U, 65347U, 65315U}, 
        {65316U, 65348U, 65316U}, 
        {65317U, 65349U, 65317U}, 
        {65318U, 65350U, 65318U}, 
        {65319U, 65351U, 65319U}, 
        {65320U, 65352U, 65320U}, 
        {65321U, 65353U, 65321U}, 
        {65322U, 65354U, 65322U}, 
        {65323U, 65355U, 65323U}, 
        {65324U, 65356U, 65324U}, 
        {65325U, 65357U, 65325U}, 
        {65326U, 65358U, 65326U}, 
        {65327U, 65359U, 65327U}, 
        {65328U, 65360U, 65328U}, 
        {65329U, 65361U, 65329U}, 
        {65330U, 65362U, 65330U}, 
        {65331U, 65363U, 65331U}, 
        {65332U, 65364U, 65332U}, 
        {65333U, 65365U, 65333U}, 
        {65334U, 65366U, 65334U}, 
        {65335U, 65367U, 65335U}, 
        {65336U, 65368U, 65336U}, 
        {65337U, 65369U, 65337U}, 
        {65338U, 65370U, 65338U}, 
        {65371U, 65371U, 65371U}, 
        {65372U, 65372U, 65372U}, 
        {65373U, 65373U, 65373U}, 
        {65374U, 65374U, 65374U}, 
        {65375U, 65375U, 65375U}, 
        {65376U, 65376U, 65376U}, 
        {65377U, 65377U, 65377U}, 
        {65378U, 65378U, 65378U}, 
        {65379U, 65379U, 65379U}, 
        {65380U, 65380U, 65380U}, 
        {65381U, 65381U, 65381U}, 
        {65382U, 65382U, 65382U}, 
        {65383U, 65383U, 65383U}, 
        {65384U, 65384U, 65384U}, 
        {65385U, 65385U, 65385U}, 
        {65386U, 65386U, 65386U}, 
        {65387U, 65387U, 65387U}, 
        {65388U, 65388U, 65388U}, 
        {65389U, 65389U, 65389U}, 
        {65390U, 65390U, 65390U}, 
        {65391U, 65391U, 65391U}, 
        {65392U, 65392U, 65392U}, 
        {65393U, 65393U, 65393U}, 
        {65394U, 65394U, 65394U}, 
        {65395U, 65395U, 65395U}, 
        {65396U, 65396U, 65396U}, 
        {65397U, 65397U, 65397U}, 
        {65398U, 65398U, 65398U}, 
        {65399U, 65399U, 65399U}, 
        {65400U, 65400U, 65400U}, 
        {65401U, 65401U, 65401U}, 
        {65402U, 65402U, 65402U}, 
        {65403U, 65403U, 65403U}, 
        {65404U, 65404U, 65404U}, 
        {65405U, 65405U, 65405U}, 
        {65406U, 65406U, 65406U}, 
        {65407U, 65407U, 65407U}, 
        {65408U, 65408U, 65408U}, 
        {65409U, 65409U, 65409U}, 
        {65410U, 65410U, 65410U}, 
        {65411U, 65411U, 65411U}, 
        {65412U, 65412U, 65412U}, 
        {65413U, 65413U, 65413U}, 
        {65414U, 65414U, 65414U}, 
        {65415U, 65415U, 65415U}, 
        {65416U, 65416U, 65416U}, 
        {65417U, 65417U, 65417U}, 
        {65418U, 65418U, 65418U}, 
        {65419U, 65419U, 65419U}, 
        {65420U, 65420U, 65420U}, 
        {65421U, 65421U, 65421U}, 
        {65422U, 65422U, 65422U}, 
        {65423U, 65423U, 65423U}, 
        {65424U, 65424U, 65424U}, 
        {65425U, 65425U, 65425U}, 
        {65426U, 65426U, 65426U}, 
        {65427U, 65427U, 65427U}, 
        {65428U, 65428U, 65428U}, 
        {65429U, 65429U, 65429U}, 
        {65430U, 65430U, 65430U}, 
        {65431U, 65431U, 65431U}, 
        {65432U, 65432U, 65432U}, 
        {65433U, 65433U, 65433U}, 
        {65434U, 65434U, 65434U}, 
        {65435U, 65435U, 65435U}, 
        {65436U, 65436U, 65436U}, 
        {65437U, 65437U, 65437U}, 
        {65438U, 65438U, 65438U}, 
        {65439U, 65439U, 65439U}, 
        {65440U, 65440U, 65440U}, 
        {65441U, 65441U, 65441U}, 
        {65442U, 65442U, 65442U}, 
        {65443U, 65443U, 65443U}, 
        {65444U, 65444U, 65444U}, 
        {65445U, 65445U, 65445U}, 
        {65446U, 65446U, 65446U}, 
        {65447U, 65447U, 65447U}, 
        {65448U, 65448U, 65448U}, 
        {65449U, 65449U, 65449U}, 
        {65450U, 65450U, 65450U}, 
        {65451U, 65451U, 65451U}, 
        {65452U, 65452U, 65452U}, 
        {65453U, 65453U, 65453U}, 
        {65454U, 65454U, 65454U}, 
        {65455U, 65455U, 65455U}, 
        {65456U, 65456U, 65456U}, 
        {65457U, 65457U, 65457U}, 
        {65458U, 65458U, 65458U}, 
        {65459U, 65459U, 65459U}, 
        {65460U, 65460U, 65460U}, 
        {65461U, 65461U, 65461U}, 
        {65462U, 65462U, 65462U}, 
        {65463U, 65463U, 65463U}, 
        {65464U, 65464U, 65464U}, 
        {65465U, 65465U, 65465U}, 
        {65466U, 65466U, 65466U}, 
        {65467U, 65467U, 65467U}, 
        {65468U, 65468U, 65468U}, 
        {65469U, 65469U, 65469U}, 
        {65470U, 65470U, 65470U}, 
        {65471U, 65471U, 65471U}, 
        {65472U, 65472U, 65472U}, 
        {65473U, 65473U, 65473U}, 
        {65474U, 65474U, 65474U}, 
        {65475U, 65475U, 65475U}, 
        {65476U, 65476U, 65476U}, 
        {65477U, 65477U, 65477U}, 
        {65478U, 65478U, 65478U}, 
        {65479U, 65479U, 65479U}, 
        {65480U, 65480U, 65480U}, 
        {65481U, 65481U, 65481U}, 
        {65482U, 65482U, 65482U}, 
        {65483U, 65483U, 65483U}, 
        {65484U, 65484U, 65484U}, 
        {65485U, 65485U, 65485U}, 
        {65486U, 65486U, 65486U}, 
        {65487U, 65487U, 65487U}, 
        {65488U, 65488U, 65488U}, 
        {65489U, 65489U, 65489U}, 
        {65490U, 65490U, 65490U}, 
        {65491U, 65491U, 65491U}, 
        {65492U, 65492U, 65492U}, 
        {65493U, 65493U, 65493U}, 
        {65494U, 65494U, 65494U}, 
        {65495U, 65495U, 65495U}, 
        {65496U, 65496U, 65496U}, 
        {65497U, 65497U, 65497U}, 
        {65498U, 65498U, 65498U}, 
        {65499U, 65499U, 65499U}, 
        {65500U, 65500U, 65500U}, 
        {65501U, 65501U, 65501U}, 
        {65502U, 65502U, 65502U}, 
        {65503U, 65503U, 65503U}, 
        {65504U, 65504U, 65504U}, 
        {65505U, 65505U, 65505U}, 
        {65506U, 65506U, 65506U}, 
        {65507U, 65507U, 65507U}, 
        {65508U, 65508U, 65508U}, 
        {65509U, 65509U, 65509U}, 
        {65510U, 65510U, 65510U}, 
        {65511U, 65511U, 65511U}, 
        {65512U, 65512U, 65512U}, 
        {65513U, 65513U, 65513U}, 
        {65514U, 65514U, 65514U}, 
        {65515U, 65515U, 65515U}, 
        {65516U, 65516U, 65516U}, 
        {65517U, 65517U, 65517U}, 
        {65518U, 65518U, 65518U}, 
        {65519U, 65519U, 65519U}, 
        {65520U, 65520U, 65520U}, 
        {65521U, 65521U, 65521U}, 
        {65522U, 65522U, 65522U}, 
        {65523U, 65523U, 65523U}, 
        {65524U, 65524U, 65524U}, 
        {65525U, 65525U, 65525U}, 
        {65526U, 65526U, 65526U}, 
        {65527U, 65527U, 65527U}, 
        {65528U, 65528U, 65528U}, 
        {65529U, 65529U, 65529U}, 
        {65530U, 65530U, 65530U}, 
        {65531U, 65531U, 65531U}, 
        {65532U, 65532U, 65532U}, 
        {65533U, 65533U, 65533U}, 
        {65534U, 65534U, 65534U}, 
        {65535U, 65535U, 65535U}};
#line 1476 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
MY_UNICASE_INFO *uni_plane[256]  = 
#line 1476
  {      plane00,      plane01,      plane02,      plane03, 
        plane04,      plane05,      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      plane1E,      plane1F, 
        (MY_UNICASE_INFO *)((void *)0),      plane21,      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        plane24,      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      planeFF};
#line 1512 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_char_width(unsigned char const   *p ) 
{ 


  {
#line 1515
  if ((int const   )*p <= 127) {
#line 1516
    return ((size_t )1);
  }
#line 1517
  if (194 <= (int )*p) {
#line 1517
    if ((int const   )*p <= 223) {
#line 1518
      return ((size_t )2);
    }
  }
#line 1519
  if (224 <= (int )*p) {
#line 1519
    if ((int const   )*p <= 239) {
#line 1520
      return ((size_t )3);
    }
  }
#line 1521
  if (240 <= (int )*p) {
#line 1521
    if ((int const   )*p <= 244) {
#line 1522
      return ((size_t )4);
    }
  }
#line 1523
  return ((size_t )0);
}
}
#line 1526 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_strlen(char const   *s ) 
{ 
  size_t len___0 ;
  size_t n ;

  {
#line 1529
  len___0 = (size_t )0;
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (*s) {
      {
#line 1532
      n = utf8_char_width((unsigned char const   *)s);
      }
#line 1532
      if (! (n != 0U)) {
#line 1532
        goto while_break;
      }
    } else {
#line 1532
      goto while_break;
    }
#line 1534
    len___0 ++;
#line 1535
    s += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  return (len___0);
}
}
#line 1541 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static int utf8_iter0(struct utf8_iterator *itr ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 1544
  tmp = utf8_char_width((unsigned char const   *)itr->curptr);
#line 1544
  n = tmp;
  }
#line 1545
  if (n == 0U) {
#line 1546
    return (1);
  }
#line 1547
  itr->curwidth = n;
#line 1548
  return (0);
}
}
#line 1551 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_iter_end_p(struct utf8_iterator *itr ) 
{ 


  {
#line 1554
  return ((int )*(itr->curptr) == 0);
}
}
#line 1557 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_iter_first(struct utf8_iterator *itr , unsigned char *ptr ) 
{ 
  int tmp ;

  {
  {
#line 1560
  itr->string = (char *)ptr;
#line 1561
  itr->curptr = (char *)ptr;
#line 1562
  tmp = utf8_iter0(itr);
  }
#line 1562
  return (tmp);
}
}
#line 1565 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_iter_next(struct utf8_iterator *itr ) 
{ 
  int tmp ;

  {
#line 1568
  if ((int )*(itr->curptr) == 0) {
#line 1569
    return (-1);
  }
  {
#line 1570
  itr->curptr += itr->curwidth;
#line 1571
  tmp = utf8_iter0(itr);
  }
#line 1571
  return (tmp);
}
}
#line 1577 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wctomb(unsigned char *r , unsigned int wc ) 
{ 
  int count ;

  {
#line 1582
  if (wc < 128U) {
#line 1583
    count = 1;
  } else
#line 1584
  if (wc < 2048U) {
#line 1585
    count = 2;
  } else
#line 1586
  if (wc < 65536U) {
#line 1587
    count = 3;
  } else
#line 1588
  if (wc < 2097152U) {
#line 1589
    count = 4;
  } else
#line 1590
  if (wc < 67108864U) {
#line 1591
    count = 5;
  } else
#line 1592
  if (wc <= 2147483647U) {
#line 1593
    count = 6;
  } else {
#line 1595
    return (-1);
  }
  {
#line 1600
  if (count == 6) {
#line 1600
    goto case_6;
  }
#line 1601
  if (count == 5) {
#line 1601
    goto case_5;
  }
#line 1602
  if (count == 4) {
#line 1602
    goto case_4;
  }
#line 1603
  if (count == 3) {
#line 1603
    goto case_3;
  }
#line 1604
  if (count == 2) {
#line 1604
    goto case_2;
  }
#line 1605
  if (count == 1) {
#line 1605
    goto case_1;
  }
#line 1597
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1600
  *(r + 5) = (unsigned char )(128U | (wc & 63U));
#line 1600
  wc >>= 6;
#line 1600
  wc |= 67108864U;
  case_5: /* CIL Label */ 
#line 1601
  *(r + 4) = (unsigned char )(128U | (wc & 63U));
#line 1601
  wc >>= 6;
#line 1601
  wc |= 2097152U;
  case_4: /* CIL Label */ 
#line 1602
  *(r + 3) = (unsigned char )(128U | (wc & 63U));
#line 1602
  wc >>= 6;
#line 1602
  wc |= 65536U;
  case_3: /* CIL Label */ 
#line 1603
  *(r + 2) = (unsigned char )(128U | (wc & 63U));
#line 1603
  wc >>= 6;
#line 1603
  wc |= 2048U;
  case_2: /* CIL Label */ 
#line 1604
  *(r + 1) = (unsigned char )(128U | (wc & 63U));
#line 1604
  wc >>= 6;
#line 1604
  wc |= 192U;
  case_1: /* CIL Label */ 
#line 1605
  *(r + 0) = (unsigned char )wc;
  switch_break: /* CIL Label */ ;
  }
#line 1608
  return (count);
}
}
#line 1616 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbtowc_internal(void *data , int (*read___0)(void * ) , unsigned int *pwc ) 
{ 
  int s[4] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  void *__cil_tmp17 ;

  {
  {
#line 1622
  s[0] = (*read___0)(data);
  }
#line 1622
  if (s[0] <= 0) {
    {
#line 1622
    tmp = __errno_location();
#line 1622
    *tmp = 61;
    }
#line 1622
    return (-1);
  }
#line 1623
  if (s[0] < 128) {
#line 1625
    *pwc = (unsigned int )s[0];
#line 1626
    return (1);
  }
#line 1629
  if (s[0] < 194) {
    {
#line 1631
    tmp___0 = __errno_location();
#line 1631
    *tmp___0 = 84;
    }
#line 1632
    return (-1);
  } else
#line 1634
  if (s[0] < 224) {
    {
#line 1636
    s[1] = (*read___0)(data);
    }
#line 1636
    if (s[1] <= 0) {
      {
#line 1636
      tmp___1 = __errno_location();
#line 1636
      *tmp___1 = 61;
      }
#line 1636
      return (-1);
    }
#line 1637
    if (! ((s[1] ^ 128) < 64)) {
      {
#line 1639
      tmp___2 = __errno_location();
#line 1639
      *tmp___2 = 84;
      }
#line 1640
      return (-1);
    }
#line 1642
    *pwc = ((unsigned int )(s[0] & 31) << 6) | (unsigned int )(s[1] ^ 128);
#line 1644
    return (2);
  }
#line 1647
  if (s[0] < 240) {
    {
#line 1649
    s[1] = (*read___0)(data);
    }
#line 1649
    if (s[1] <= 0) {
      {
#line 1649
      tmp___3 = __errno_location();
#line 1649
      *tmp___3 = 61;
      }
#line 1649
      return (-1);
    }
    {
#line 1650
    s[2] = (*read___0)(data);
    }
#line 1650
    if (s[2] <= 0) {
      {
#line 1650
      tmp___4 = __errno_location();
#line 1650
      *tmp___4 = 61;
      }
#line 1650
      return (-1);
    }
#line 1652
    if ((s[1] ^ 128) < 64) {
#line 1652
      if ((s[2] ^ 128) < 64) {
#line 1652
        if (! (s[0] >= 225)) {
#line 1652
          if (! (s[1] >= 160)) {
            {
#line 1656
            tmp___5 = __errno_location();
#line 1656
            *tmp___5 = 84;
            }
#line 1657
            return (-1);
          }
        }
      } else {
        {
#line 1656
        tmp___5 = __errno_location();
#line 1656
        *tmp___5 = 84;
        }
#line 1657
        return (-1);
      }
    } else {
      {
#line 1656
      tmp___5 = __errno_location();
#line 1656
      *tmp___5 = 84;
      }
#line 1657
      return (-1);
    }
#line 1660
    *pwc = (unsigned int )((((unsigned long )(s[0] & 15) << 12) | ((unsigned long )(s[1] ^ 128) << 6)) | (unsigned long )(s[2] ^ 128));
#line 1664
    return (3);
  }
#line 1667
  if (s[0] < 248) {
    {
#line 1669
    s[1] = (*read___0)(data);
    }
#line 1669
    if (s[1] <= 0) {
      {
#line 1669
      tmp___6 = __errno_location();
#line 1669
      *tmp___6 = 61;
      }
#line 1669
      return (-1);
    }
    {
#line 1670
    s[2] = (*read___0)(data);
    }
#line 1670
    if (s[2] <= 0) {
      {
#line 1670
      tmp___7 = __errno_location();
#line 1670
      *tmp___7 = 61;
      }
#line 1670
      return (-1);
    }
    {
#line 1671
    s[3] = (*read___0)(data);
    }
#line 1671
    if (s[3] <= 0) {
      {
#line 1671
      tmp___8 = __errno_location();
#line 1671
      *tmp___8 = 61;
      }
#line 1671
      return (-1);
    }
#line 1673
    if ((s[1] ^ 128) < 64) {
#line 1673
      if ((s[2] ^ 128) < 64) {
#line 1673
        if ((s[3] ^ 128) < 64) {
#line 1673
          if (! (s[0] >= 241)) {
#line 1673
            if (! (s[1] >= 144)) {
              {
#line 1678
              tmp___9 = __errno_location();
#line 1678
              *tmp___9 = 84;
              }
#line 1679
              return (-1);
            }
          }
        } else {
          {
#line 1678
          tmp___9 = __errno_location();
#line 1678
          *tmp___9 = 84;
          }
#line 1679
          return (-1);
        }
      } else {
        {
#line 1678
        tmp___9 = __errno_location();
#line 1678
        *tmp___9 = 84;
        }
#line 1679
        return (-1);
      }
    } else {
      {
#line 1678
      tmp___9 = __errno_location();
#line 1678
      *tmp___9 = 84;
      }
#line 1679
      return (-1);
    }
#line 1682
    *pwc = (unsigned int )(((((unsigned long )(s[0] & 7) << 18) | ((unsigned long )(s[1] ^ 128) << 12)) | ((unsigned long )(s[2] ^ 128) << 6)) | (unsigned long )(s[3] ^ 128));
#line 1687
    return (4);
  }
  {
#line 1689
  tmp___10 = __errno_location();
#line 1689
  *tmp___10 = 84;
  }
#line 1690
  return (-1);
}
}
#line 1700 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static int _next_char_from_string(void *data ) 
{ 
  struct tstring *p ;
  unsigned char *tmp ;

  {
#line 1703
  p = (struct tstring *)data;
#line 1704
  if (p->len == 0U) {
#line 1705
    return (0);
  }
#line 1706
  (p->len) --;
#line 1707
  tmp = p->ptr;
#line 1707
  (p->ptr) ++;
#line 1707
  return ((int )*tmp);
}
}
#line 1710 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbtowc(unsigned int *pwc , unsigned char *r , size_t len___0 ) 
{ 
  struct tstring ts ;
  size_t tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;

  {
#line 1714
  ts.ptr = r;
#line 1715
  if (len___0) {
#line 1715
    ts.len = len___0;
  } else {
    {
#line 1715
    tmp = utf8_char_width((unsigned char const   *)r);
#line 1715
    ts.len = tmp;
    }
  }
  {
#line 1716
  tmp___0 = utf8_mbtowc_internal((void *)(& ts), & _next_char_from_string, pwc);
  }
#line 1716
  return (tmp___0);
}
}
#line 1720 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_symcmp(unsigned char *a , unsigned char *b ) 
{ 
  unsigned int wa ;
  unsigned int wb ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1725
  tmp = utf8_char_width((unsigned char const   *)a);
#line 1725
  utf8_mbtowc(& wa, a, tmp);
#line 1726
  tmp___0 = utf8_char_width((unsigned char const   *)b);
#line 1726
  utf8_mbtowc(& wb, b, tmp___0);
  }
#line 1727
  if (wa < wb) {
#line 1728
    return (-1);
  }
#line 1729
  if (wa > wb) {
#line 1730
    return (1);
  }
#line 1731
  return (0);
}
}
#line 1734 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int urf8_symcasecmp(unsigned char *a , unsigned char *b ) 
{ 
  unsigned int wa ;
  unsigned int wb ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1739
  tmp = utf8_char_width((unsigned char const   *)a);
#line 1739
  utf8_mbtowc(& wa, a, tmp);
#line 1740
  tmp___0 = utf8_char_width((unsigned char const   *)b);
#line 1740
  utf8_mbtowc(& wb, b, tmp___0);
#line 1741
  wa = utf8_wc_toupper(wa);
#line 1742
  wb = utf8_wc_toupper(wb);
  }
#line 1743
  if (wa < wb) {
#line 1744
    return (-1);
  }
#line 1745
  if (wa > wb) {
#line 1746
    return (1);
  }
#line 1747
  return (0);
}
}
#line 1750 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_strcasecmp(unsigned char *a , unsigned char *b ) 
{ 
  int alen ;
  int blen ;
  unsigned int wa ;
  unsigned int wb ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1755
    if (! *a) {
#line 1755
      goto while_break;
    }
#line 1759
    if ((int )*b == 0) {
#line 1760
      return (1);
    }
    {
#line 1762
    tmp = utf8_char_width((unsigned char const   *)a);
#line 1762
    alen = (int )tmp;
#line 1763
    utf8_mbtowc(& wa, a, (size_t )alen);
#line 1764
    tmp___0 = utf8_char_width((unsigned char const   *)b);
#line 1764
    blen = (int )tmp___0;
#line 1765
    utf8_mbtowc(& wb, b, (size_t )blen);
#line 1766
    wa = utf8_wc_toupper(wa);
#line 1767
    wb = utf8_wc_toupper(wb);
    }
#line 1768
    if (wa < wb) {
#line 1769
      return (-1);
    }
#line 1770
    if (wa > wb) {
#line 1771
      return (1);
    }
#line 1755
    a += alen;
#line 1755
    b += blen;
  }
  while_break: /* CIL Label */ ;
  }
#line 1774
  if (*b) {
#line 1775
    return (-1);
  }
#line 1776
  return (0);
}
}
#line 1779 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_strncasecmp(unsigned char *a , unsigned char *b , size_t maxlen ) 
{ 
  int alen ;
  int blen ;
  unsigned char *aend ;
  unsigned char *bend ;
  unsigned int wa ;
  unsigned int wb ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1783
  aend = a + maxlen;
#line 1783
  bend = b + maxlen;
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    if (! ((unsigned long )a < (unsigned long )aend)) {
#line 1785
      goto while_break;
    }
#line 1789
    if ((int )*a == 0) {
#line 1790
      if ((int )*b == 0) {
#line 1790
        tmp = 0;
      } else {
#line 1790
        tmp = -1;
      }
#line 1790
      return (tmp);
    }
#line 1792
    if ((int )*b == 0) {
#line 1793
      return (1);
    } else
#line 1792
    if ((unsigned long )b >= (unsigned long )bend) {
#line 1793
      return (1);
    }
    {
#line 1795
    tmp___0 = utf8_char_width((unsigned char const   *)a);
#line 1795
    alen = (int )tmp___0;
#line 1796
    utf8_mbtowc(& wa, a, (size_t )alen);
#line 1797
    tmp___1 = utf8_char_width((unsigned char const   *)b);
#line 1797
    blen = (int )tmp___1;
#line 1798
    utf8_mbtowc(& wb, b, (size_t )blen);
#line 1799
    wa = utf8_wc_toupper(wa);
#line 1800
    wb = utf8_wc_toupper(wb);
    }
#line 1801
    if (wa < wb) {
#line 1802
      return (-1);
    }
#line 1803
    if (wa > wb) {
#line 1804
      return (1);
    }
#line 1785
    a += alen;
#line 1785
    b += blen;
  }
  while_break: /* CIL Label */ ;
  }
#line 1807
  return (0);
}
}
#line 1812 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int utf8_wc_toupper(unsigned int wc ) 
{ 
  int plane ;
  unsigned int tmp ;

  {
#line 1815
  plane = (int )((wc >> 8) & 255U);
#line 1816
  if (uni_plane[plane]) {
#line 1816
    tmp = (uni_plane[plane] + (wc & 255U))->toupper;
  } else {
#line 1816
    tmp = wc;
  }
#line 1816
  return (tmp);
}
}
#line 1819 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_toupper(char *s , size_t len___0 ) 
{ 
  unsigned int wc ;
  int rc ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1822
    if (! (len___0 > 0U)) {
#line 1822
      goto while_break;
    }
    {
#line 1825
    tmp = utf8_mbtowc(& wc, (unsigned char *)s, len___0);
#line 1825
    rc = tmp;
    }
#line 1826
    if (rc <= 0) {
#line 1827
      return (1);
    }
    {
#line 1828
    tmp___0 = utf8_wc_toupper(wc);
#line 1828
    tmp___1 = utf8_wctomb((unsigned char *)s, tmp___0);
    }
#line 1828
    if (rc != tmp___1) {
#line 1829
      return (1);
    }
#line 1830
    s += rc;
#line 1831
    len___0 -= (size_t )rc;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  return (0);
}
}
#line 1836 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int utf8_wc_tolower(unsigned int wc ) 
{ 
  int plane ;
  unsigned int tmp ;

  {
#line 1839
  plane = (int )((wc >> 8) & 255U);
#line 1840
  if (uni_plane[plane]) {
#line 1840
    tmp = (uni_plane[plane] + (wc & 255U))->tolower;
  } else {
#line 1840
    tmp = wc;
  }
#line 1840
  return (tmp);
}
}
#line 1843 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_tolower(char *s , size_t len___0 ) 
{ 
  unsigned int wc ;
  int rc ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1846
    if (! (len___0 > 0U)) {
#line 1846
      goto while_break;
    }
    {
#line 1849
    tmp = utf8_mbtowc(& wc, (unsigned char *)s, len___0);
#line 1849
    rc = tmp;
    }
#line 1850
    if (rc <= 0) {
#line 1851
      return (1);
    }
    {
#line 1852
    tmp___0 = utf8_wc_tolower(wc);
#line 1852
    tmp___1 = utf8_wctomb((unsigned char *)s, tmp___0);
    }
#line 1852
    if (rc != tmp___1) {
#line 1853
      return (1);
    }
#line 1854
    s += rc;
#line 1855
    len___0 -= (size_t )rc;
  }
  while_break: /* CIL Label */ ;
  }
#line 1857
  return (0);
}
}
#line 1861 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_wc_strlen(unsigned int const   *s ) 
{ 
  size_t len___0 ;
  unsigned int const   *tmp ;

  {
#line 1864
  len___0 = (size_t )0;
  {
#line 1865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1865
    tmp = s;
#line 1865
    s ++;
#line 1865
    if (! *tmp) {
#line 1865
      goto while_break;
    }
#line 1866
    len___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1867
  return (len___0);
}
}
#line 1870 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int *utf8_wc_strdup(unsigned int const   *s ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  unsigned int *clone ;
  void *tmp___0 ;

  {
  {
#line 1873
  tmp = utf8_wc_strlen(s);
#line 1873
  len___0 = tmp + 1U;
#line 1874
  tmp___0 = calloc(len___0, (size_t )sizeof(*(s + 0)));
#line 1874
  clone = (unsigned int *)tmp___0;
  }
#line 1875
  if (clone) {
    {
#line 1876
    memcpy((void */* __restrict  */)clone, (void const   */* __restrict  */)s, len___0);
    }
  }
#line 1877
  return (clone);
}
}
#line 1880 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_wc_hash_string(unsigned int const   *ws , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned int wc ;
  unsigned int const   *tmp ;

  {
#line 1883
  value = (size_t )0;
  {
#line 1890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1890
    tmp = ws;
#line 1890
    ws ++;
#line 1890
    wc = (unsigned int )*tmp;
#line 1890
    if (! wc) {
#line 1890
      goto while_break;
    }
#line 1891
    value = wc + ((value << 16) | (value >> (sizeof(size_t ) * 8UL - 16UL)));
  }
  while_break: /* CIL Label */ ;
  }
#line 1892
  return (value % n_buckets);
}
}
#line 1895 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wc_strcmp(unsigned int const   *a , unsigned int const   *b ) 
{ 


  {
  {
#line 1898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1898
    if (! (*a == *b)) {
#line 1898
      goto while_break;
    }
#line 1900
    if (*a == 0U) {
#line 1901
      return (0);
    }
#line 1902
    a ++;
#line 1903
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1905
  if (*a < *b) {
#line 1906
    return (-1);
  }
#line 1907
  if (*a > *b) {
#line 1908
    return (1);
  }
#line 1909
  return (0);
}
}
#line 1912 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wc_strcasecmp(unsigned int const   *a , unsigned int const   *b ) 
{ 
  unsigned int wa ;
  unsigned int wb ;

  {
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! (*a == *b)) {
#line 1917
      goto while_break;
    }
#line 1919
    if (*a == 0U) {
#line 1920
      return (0);
    }
#line 1921
    a ++;
#line 1922
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1924
  wa = utf8_wc_toupper((unsigned int )*a);
#line 1925
  wb = utf8_wc_toupper((unsigned int )*b);
  }
#line 1927
  if (wa < wb) {
#line 1928
    return (-1);
  }
#line 1929
  if (wa > wb) {
#line 1930
    return (1);
  }
#line 1931
  return (0);
}
}
#line 1934 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int *utf8_wc_quote(unsigned int const   *s ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  unsigned int *clone ;
  void *tmp___0 ;
  size_t i___0 ;
  size_t j ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1937
  tmp = utf8_wc_strlen(s);
#line 1937
  len___0 = tmp;
#line 1938
  tmp___0 = calloc(2U * len___0 + 1U, (size_t )sizeof(*(s + 0)));
#line 1938
  clone = (unsigned int *)tmp___0;
  }
#line 1939
  if (clone) {
#line 1942
    j = (size_t )0;
#line 1942
    i___0 = j;
    {
#line 1942
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1942
      if (! (i___0 < len___0)) {
#line 1942
        goto while_break;
      }
      {
#line 1947
      if (*(s + i___0) == 34U) {
#line 1947
        goto case_34;
      }
#line 1947
      if (*(s + i___0) == 92U) {
#line 1947
        goto case_34;
      }
#line 1950
      goto switch_default;
      case_34: /* CIL Label */ 
      case_92: /* CIL Label */ 
#line 1948
      tmp___1 = j;
#line 1948
      j ++;
#line 1948
      *(clone + tmp___1) = (unsigned int )'\\';
      switch_default: /* CIL Label */ 
#line 1951
      tmp___2 = j;
#line 1951
      j ++;
#line 1951
      *(clone + tmp___2) = (unsigned int )*(s + i___0);
      switch_break: /* CIL Label */ ;
      }
#line 1942
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1954
    *(clone + j) = 0U;
#line 1955
    tmp___3 = realloc((void *)clone, (size_t )((unsigned long )(j + 1U) * sizeof(*(clone + 0))));
#line 1955
    clone = (unsigned int *)tmp___3;
    }
  }
#line 1957
  return (clone);
}
}
#line 1960 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wc_to_mbstr(unsigned int const   *wordbuf , size_t wordlen , char **sptr ) 
{ 
  size_t i___0 ;
  size_t wbc ;
  char *s ;
  char r[4] ;
  int rc ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char r___0[4] ;
  int rc___0 ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 1967
  wbc = (size_t )0;
#line 1968
  i___0 = (size_t )0;
  {
#line 1968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1968
    if (! (i___0 < wordlen)) {
#line 1968
      goto while_break;
    }
    {
#line 1971
    tmp = utf8_wctomb((unsigned char *)(r), (unsigned int )*(wordbuf + i___0));
#line 1971
    rc = tmp;
    }
#line 1972
    if (rc <= 0) {
#line 1973
      return (rc);
    }
#line 1974
    wbc += (size_t )rc;
#line 1968
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1977
  tmp___0 = malloc(wbc + 1U);
#line 1977
  s = (char *)tmp___0;
  }
#line 1978
  if (! s) {
    {
#line 1980
    tmp___1 = __errno_location();
#line 1980
    *tmp___1 = 12;
    }
#line 1981
    return (-1);
  }
#line 1984
  wbc = (size_t )0;
#line 1985
  i___0 = (size_t )0;
  {
#line 1985
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1985
    if (! (i___0 < wordlen)) {
#line 1985
      goto while_break___0;
    }
    {
#line 1988
    tmp___2 = utf8_wctomb((unsigned char *)(r___0), (unsigned int )*(wordbuf + i___0));
#line 1988
    rc___0 = tmp___2;
    }
#line 1989
    if (rc___0 <= 0) {
#line 1990
      return (rc___0);
    }
    {
#line 1991
    memcpy((void */* __restrict  */)(s + wbc), (void const   */* __restrict  */)(r___0),
           (size_t )rc___0);
#line 1992
    wbc += (size_t )rc___0;
#line 1985
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1994
  *(s + wbc) = (char)0;
#line 1995
  *sptr = s;
#line 1996
  return (0);
}
}
#line 1999 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbstr_to_wc(char const   *str , unsigned int **wptr ) 
{ 
  size_t sc ;
  size_t tmp ;
  size_t len___0 ;
  size_t i___0 ;
  unsigned int *w ;
  void *tmp___0 ;
  int rc ;
  int tmp___1 ;

  {
  {
#line 2002
  tmp = strlen(str);
#line 2002
  sc = tmp;
#line 2004
  tmp___0 = calloc((size_t )sizeof(*(w + 0)), sc + 1U);
#line 2004
  w = (unsigned int *)tmp___0;
  }
#line 2006
  if (! w) {
#line 2007
    return (-1);
  }
  {
#line 2008
  i___0 = (size_t )0;
#line 2008
  len___0 = strlen(str);
  }
  {
#line 2008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2008
    if (! len___0) {
#line 2008
      goto while_break;
    }
    {
#line 2010
    tmp___1 = utf8_mbtowc(w + i___0, (unsigned char *)str, len___0);
#line 2010
    rc = tmp___1;
    }
#line 2011
    if (rc <= 0) {
      {
#line 2013
      free((void *)w);
      }
#line 2014
      return (-1);
    }
#line 2016
    str += rc;
#line 2017
    len___0 -= (size_t )rc;
#line 2008
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2019
  *wptr = w;
#line 2020
  return ((int )sc);
}
}
#line 2025 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbstr_to_norm_wc(char const   *str , unsigned int **nptr ) 
{ 
  int inws ;
  size_t len___0 ;
  size_t tmp ;
  unsigned int *base ;
  void *tmp___0 ;
  size_t i___0 ;
  unsigned int wc ;
  int rc ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 2028
  inws = 0;
#line 2029
  tmp = strlen(str);
#line 2029
  len___0 = tmp;
#line 2030
  tmp___0 = calloc(len___0 + 1U, (size_t )sizeof(*(base + 0)));
#line 2030
  base = (unsigned int *)tmp___0;
#line 2031
  i___0 = (size_t )0;
  }
#line 2033
  if (! base) {
#line 2034
    return (-1);
  }
  {
#line 2036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2036
    if (! (len___0 > 0U)) {
#line 2036
      goto while_break;
    }
    {
#line 2038
    tmp___1 = utf8_mbtowc(& wc, (unsigned char *)str, len___0);
#line 2038
    rc = tmp___1;
    }
#line 2039
    if (rc <= 0) {
#line 2040
      return (1);
    }
#line 2041
    str += rc;
#line 2042
    len___0 -= (size_t )rc;
#line 2043
    if (rc == 1) {
#line 2043
      if (wc == 32U) {
#line 2043
        goto _L;
      } else
#line 2043
      if (wc == 9U) {
#line 2043
        goto _L;
      } else
#line 2043
      if (wc == 10U) {
        _L: /* CIL Label */ 
#line 2044
        if (! inws) {
#line 2045
          wc = (unsigned int )' ';
#line 2046
          inws = 1;
        } else {
#line 2048
          goto while_continue;
        }
      } else {
#line 2050
        inws = 0;
      }
    } else {
#line 2050
      inws = 0;
    }
#line 2051
    tmp___2 = i___0;
#line 2051
    i___0 ++;
#line 2051
    *(base + tmp___2) = wc;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2053
  tmp___3 = i___0;
#line 2053
  i___0 ++;
#line 2053
  *(base + tmp___3) = 0U;
#line 2054
  tmp___4 = realloc((void *)base, (size_t )((unsigned long )i___0 * sizeof(*(base + 0))));
#line 2054
  *nptr = (unsigned int *)tmp___4;
  }
#line 2055
  return (0);
}
}
#line 2058 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_quote(char const   *str , char **sptr ) 
{ 
  int rc ;
  unsigned int *ws ;
  unsigned int *ret ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 2064
  rc = utf8_mbstr_to_wc(str, & ws);
  }
#line 2065
  if (rc < 0) {
#line 2066
    return (rc);
  }
  {
#line 2067
  ret = utf8_wc_quote((unsigned int const   *)ws);
  }
#line 2068
  if (ret) {
    {
#line 2070
    tmp = utf8_wc_strlen((unsigned int const   *)ret);
#line 2070
    rc = utf8_wc_to_mbstr((unsigned int const   *)ret, tmp, sptr);
#line 2071
    free((void *)ret);
    }
  } else {
    {
#line 2075
    tmp___0 = __errno_location();
#line 2075
    *tmp___0 = 12;
#line 2076
    rc = -1;
    }
  }
#line 2078
  return (rc);
}
}
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 32 "../include/dico/assoc.h"
dico_assoc_list_t dico_assoc_create(int flags ) ;
#line 34
void dico_assoc_destroy(dico_assoc_list_t *passoc ) ;
#line 39
int dico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) ;
#line 43
char const   *dico_assoc_find(dico_assoc_list_t assoc , char const   *key ) ;
#line 46 "../include/dico/url.h"
int dico_url_parse(dico_url_t *purl , char const   *str ) ;
#line 47
void dico_url_destroy(dico_url_t *purl ) ;
#line 48
char const   *dico_url_get_arg(dico_url_t url , char const   *argname ) ;
#line 49
char *dico_url_full_path(dico_url_t url ) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int alloc_string_len(char **sptr , char const   *start , size_t len___0 ) 
{ 
  void *tmp ;

  {
  {
#line 32
  tmp = malloc(len___0 + 1U);
#line 32
  *sptr = (char *)tmp;
  }
#line 33
  if (! *sptr) {
#line 34
    return (1);
  }
  {
#line 35
  memcpy((void */* __restrict  */)*sptr, (void const   */* __restrict  */)start, len___0);
#line 36
  *(*sptr + len___0) = (char)0;
  }
#line 37
  return (0);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int alloc_string(char **sptr , char const   *start , char const   *end ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 43
  if (end) {
#line 43
    tmp___0 = end - start;
  } else {
    {
#line 43
    tmp = strlen(start);
#line 43
    tmp___0 = (long )tmp;
    }
  }
  {
#line 43
  len___0 = (size_t )tmp___0;
#line 44
  tmp___1 = alloc_string_len(sptr, start, len___0);
  }
#line 44
  return (tmp___1);
}
}
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int alloc_string_def(char **sptr , char const   *start , char const   *end ,
                            char const   *def ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 51
  if ((unsigned long )end == (unsigned long )start) {
    {
#line 52
    tmp = alloc_string(sptr, def, (char const   *)((void *)0));
    }
#line 52
    return (tmp);
  } else {
    {
#line 54
    tmp___0 = alloc_string(sptr, start, end);
    }
#line 54
    return (tmp___0);
  }
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_parse_arg(dico_url_t url , char *p , char *q ) 
{ 
  char *s ;
  char *key ;
  char *value ;
  int tmp ;
  int tmp___0 ;

  {
#line 61
  value = (char *)((void *)0);
#line 63
  s = p;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if ((unsigned long )s < (unsigned long )q) {
#line 63
      if (! ((int )*s != 61)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 63
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  tmp = alloc_string(& key, (char const   *)p, (char const   *)s);
  }
#line 66
  if (tmp) {
#line 67
    return (1);
  }
#line 68
  if ((unsigned long )s != (unsigned long )q) {
    {
#line 69
    tmp___0 = alloc_string(& value, (char const   *)(s + 1), (char const   *)q);
    }
#line 69
    if (tmp___0) {
#line 70
      return (1);
    }
  }
  {
#line 72
  dico_assoc_append(url->args, (char const   *)key, (char const   *)value);
#line 73
  free((void *)key);
#line 74
  free((void *)value);
  }
#line 75
  return (0);
}
}
#line 78 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_args(dico_url_t url , char **str ) 
{ 
  int rc ;
  char *p ;
  char *q ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 84
  if (! *(*str)) {
#line 85
    return (0);
  }
  {
#line 87
  url->args = dico_assoc_create(2);
  }
#line 88
  if (! url->args) {
#line 89
    return (1);
  }
#line 90
  p = *str;
#line 90
  rc = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (! rc)) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp = strchr((char const   *)p, ';');
#line 91
    q = tmp;
    }
#line 92
    if (q) {
      {
#line 93
      rc = url_parse_arg(url, p, q);
#line 94
      p = q + 1;
      }
    } else {
      {
#line 96
      tmp___0 = strlen((char const   *)p);
#line 96
      rc = url_parse_arg(url, p, p + tmp___0);
      }
#line 97
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (rc);
}
}
#line 103 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_path(dico_url_t url , char **str ) 
{ 
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 108
  p = strchr((char const   *)*str, ';');
  }
#line 109
  if (! p) {
    {
#line 110
    tmp = strlen((char const   *)*str);
#line 110
    p = *str + tmp;
    }
  }
  {
#line 111
  tmp___0 = alloc_string(& url->path, (char const   *)*str, (char const   *)p);
  }
#line 111
  if (tmp___0) {
#line 112
    return (1);
  }
#line 113
  *str = p;
#line 114
  if (*p) {
#line 115
    (*str) ++;
  }
  {
#line 116
  tmp___1 = url_get_args(url, str);
  }
#line 116
  return (tmp___1);
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_host(dico_url_t url , char **str ) 
{ 
  char *s ;
  size_t len___0 ;
  size_t tmp ;
  char *q ;
  unsigned long n ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 124
  s = *str;
#line 125
  tmp = strcspn((char const   *)s, "/:");
#line 125
  len___0 = tmp;
  }
#line 127
  if ((int )*(s + len___0) == 58) {
    {
#line 129
    tmp___0 = strtoul((char const   */* __restrict  */)((s + len___0) + 1), (char **/* __restrict  */)(& q),
                      10);
#line 129
    n = tmp___0;
    }
#line 130
    if (*q) {
      {
#line 130
      tmp___1 = strchr("/;:", (int )*q);
      }
#line 130
      if (tmp___1) {
#line 130
        goto _L;
      } else {
#line 131
        return (1);
      }
    } else
    _L: /* CIL Label */ 
#line 130
    if (n > 65535UL) {
#line 131
      return (1);
    }
    {
#line 132
    url->port = (int )n;
#line 133
    tmp___2 = strcspn((char const   *)q, "/");
#line 133
    *str = q + tmp___2;
    }
  } else {
#line 135
    *str = s + len___0;
  }
  {
#line 136
  tmp___3 = alloc_string_len(& url->host, (char const   *)s, len___0);
  }
#line 136
  if (tmp___3) {
#line 137
    return (1);
  }
#line 138
  if (*(*str)) {
    {
#line 139
    (*str) ++;
#line 140
    tmp___4 = url_get_path(url, str);
    }
#line 140
    return (tmp___4);
  }
#line 142
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_user(dico_url_t url , char **str ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  char *p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 149
  tmp = strcspn((char const   *)*str, ":;@/");
#line 149
  len___0 = tmp;
#line 150
  p = *str + len___0;
  }
  {
#line 153
  if ((int )*p == 59) {
#line 153
    goto case_59;
  }
#line 157
  if ((int )*p == 58) {
#line 157
    goto case_58;
  }
#line 168
  if ((int )*p == 64) {
#line 168
    goto case_64;
  }
#line 152
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 154
  tmp___0 = strcmp((char const   *)url->proto, "dict");
  }
#line 154
  if (tmp___0) {
#line 155
    goto switch_break;
  }
  case_58: /* CIL Label */ 
  {
#line 158
  len___0 = strcspn((char const   *)(p + 1), "@/:");
  }
#line 159
  if ((int )*(p + (len___0 + 1U)) == 64) {
    {
#line 160
    tmp___1 = alloc_string_len(& url->passwd, (char const   *)(p + 1), len___0);
    }
#line 160
    if (tmp___1) {
#line 161
      return (1);
    }
    {
#line 162
    tmp___2 = alloc_string(& url->user, (char const   *)*str, (char const   *)p);
    }
#line 162
    if (tmp___2) {
#line 163
      return (1);
    }
#line 164
    *str = (p + len___0) + 2;
  }
#line 166
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 169
  tmp___3 = alloc_string(& url->user, (char const   *)*str, (char const   *)p);
  }
#line 169
  if (tmp___3) {
#line 170
    return (1);
  }
#line 171
  url->passwd = (char *)((void *)0);
#line 172
  *str = p + 1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 174
  tmp___4 = url_get_host(url, str);
  }
#line 174
  return (tmp___4);
}
}
#line 177 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_proto(dico_url_t url , char const   *str ) 
{ 
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 182
  if (! str) {
    {
#line 183
    tmp = __errno_location();
#line 183
    *tmp = 22;
    }
#line 184
    return (1);
  }
  {
#line 187
  p = strchr(str, ':');
  }
#line 188
  if (! p) {
    {
#line 189
    tmp___0 = __errno_location();
#line 189
    *tmp___0 = 22;
    }
#line 190
    return (1);
  }
  {
#line 193
  alloc_string(& url->proto, str, (char const   *)p);
#line 196
  p ++;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((int )*p == 47)) {
#line 196
      goto while_break;
    }
#line 196
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  tmp___1 = url_get_user(url, & p);
  }
#line 198
  return (tmp___1);
}
}
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_parse_dico_request(dico_url_t url ) 
{ 
  char *p ;
  char *q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 206
  if (! url->path) {
#line 207
    return (0);
  }
#line 208
  p = url->path;
#line 209
  if ((int )*(p + 1) != 58) {
#line 210
    return (1);
  }
  {
#line 212
  if ((int )*p == 109) {
#line 212
    goto case_109;
  }
#line 216
  if ((int )*p == 100) {
#line 216
    goto case_100;
  }
#line 220
  goto switch_default;
  case_109: /* CIL Label */ 
#line 213
  url->req.type = 1;
#line 214
  goto switch_break;
  case_100: /* CIL Label */ 
#line 217
  url->req.type = 0;
#line 218
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 221
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 224
  p += 2;
#line 225
  q = strchr((char const   *)p, ':');
#line 226
  tmp = alloc_string(& url->req.word, (char const   *)p, (char const   *)q);
  }
#line 226
  if (tmp) {
#line 227
    return (1);
  }
#line 228
  if (! q) {
    {
#line 229
    tmp___0 = alloc_string_len(& url->req.database, "!", (size_t )1);
    }
#line 229
    if (tmp___0) {
#line 229
      tmp___2 = 1;
    } else {
      {
#line 229
      tmp___1 = alloc_string_len(& url->req.strategy, ".", (size_t )1);
      }
#line 229
      if (tmp___1) {
#line 229
        tmp___2 = 1;
      } else {
#line 229
        tmp___2 = 0;
      }
    }
#line 229
    return (tmp___2);
  }
  {
#line 232
  p = q + 1;
#line 233
  q = strchr((char const   *)p, ':');
#line 234
  tmp___3 = alloc_string_def(& url->req.database, (char const   *)p, (char const   *)q,
                             "*");
  }
#line 234
  if (tmp___3) {
#line 235
    return (1);
  }
#line 237
  if (url->req.type == 1) {
#line 238
    if (! q) {
      {
#line 239
      tmp___4 = alloc_string_len(& url->req.strategy, ".", (size_t )1);
      }
#line 239
      return (tmp___4);
    }
    {
#line 241
    p = q + 1;
#line 242
    q = strchr((char const   *)p, ':');
#line 243
    tmp___5 = alloc_string_def(& url->req.strategy, (char const   *)p, (char const   *)q,
                               ".");
    }
#line 243
    if (tmp___5) {
#line 244
      return (1);
    }
  }
#line 247
  if (q) {
    {
#line 248
    p = q + 1;
#line 249
    url->req.n = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                         10);
    }
#line 250
    if (*q) {
#line 251
      return (1);
    }
  }
#line 254
  return (0);
}
}
#line 257 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
void dico_url_destroy(dico_url_t *purl ) 
{ 
  dico_url_t url ;

  {
  {
#line 260
  url = *purl;
#line 262
  free((void *)url->string);
#line 263
  free((void *)url->proto);
#line 264
  free((void *)url->host);
#line 265
  free((void *)url->path);
#line 266
  free((void *)url->user);
#line 267
  free((void *)url->passwd);
#line 268
  dico_assoc_destroy(& url->args);
#line 269
  free((void *)url->req.word);
#line 270
  free((void *)url->req.database);
#line 271
  free((void *)url->req.strategy);
#line 272
  free((void *)url);
#line 273
  *purl = (dico_url_t )((void *)0);
  }
#line 274
  return;
}
}
#line 276 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
int dico_url_parse(dico_url_t *purl , char const   *str ) 
{ 
  int rc ;
  dico_url_t url ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 282
  tmp = malloc((size_t )sizeof(*url));
#line 282
  url = (dico_url_t )tmp;
  }
#line 283
  if (! url) {
#line 284
    return (1);
  }
  {
#line 285
  memset((void *)url, 0, (size_t )sizeof(*url));
#line 286
  rc = url_get_proto(url, str);
  }
#line 287
  if (rc) {
    {
#line 288
    dico_url_destroy(& url);
    }
  } else {
    {
#line 290
    url->string = strdup(str);
#line 292
    tmp___0 = memcmp((void const   *)url->proto, (void const   *)"dict", (size_t )4);
    }
#line 292
    if (tmp___0 == 0) {
      {
#line 292
      tmp___1 = url_parse_dico_request(url);
      }
#line 292
      if (tmp___1) {
        {
#line 294
        dico_url_destroy(& url);
        }
#line 295
        return (1);
      }
    }
#line 298
    *purl = url;
  }
#line 300
  return (rc);
}
}
#line 303 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
char *dico_url_full_path(dico_url_t url ) 
{ 
  char *path ;
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 307
  size = (size_t )1;
#line 309
  if (url->host) {
    {
#line 310
    tmp = strlen((char const   *)url->host);
#line 310
    size += tmp;
    }
  }
#line 311
  if (url->path) {
    {
#line 312
    tmp___0 = strlen((char const   *)url->path);
#line 312
    size += tmp___0 + 1U;
    }
  }
  {
#line 313
  tmp___1 = malloc(size + 1U);
#line 313
  path = (char *)tmp___1;
  }
#line 314
  if (path) {
#line 315
    if (url->host) {
      {
#line 316
      strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
#line 317
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)url->host);
      }
    }
#line 319
    if (url->path) {
#line 320
      if (*(path + 0)) {
        {
#line 321
        strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
        }
      }
      {
#line 322
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)url->path);
      }
    }
  }
#line 325
  return (path);
}
}
#line 328 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
char const   *dico_url_get_arg(dico_url_t url , char const   *argname ) 
{ 
  char const   *tmp ;

  {
  {
#line 331
  tmp = dico_assoc_find(url->args, argname);
  }
#line 331
  return (tmp);
}
}
#line 28 "../include/dico/xlat.h"
int xlat_string(struct xlat_tab *tab , char const   *string , size_t len___0 , int flags ,
                int *result ) ;
#line 30
int xlat_c_string(struct xlat_tab *tab , char const   *string , int flags , int *result ) ;
#line 113 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xlat.c"
int xlat_string(struct xlat_tab *tab , char const   *string , size_t len___0 , int flags ,
                int *result ) 
{ 
  int (*cmp)(char const   * , char const   * , size_t  ) ;
  int ( __attribute__((__nonnull__(1,2))) (*tmp))(char const   *__s1 , char const   *__s2 ,
                                                  size_t __n ) ;
  int tmp___0 ;

  {
#line 29
  if (flags & 1) {
#line 29
    tmp = & strncasecmp;
  } else {
#line 29
    tmp = & strncmp;
  }
#line 29
  cmp = (int (*)(char const   * , char const   * , size_t  ))tmp;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! tab->string) {
#line 31
      goto while_break;
    }
    {
#line 32
    tmp___0 = (*cmp)((char const   *)tab->string, string, len___0);
    }
#line 32
    if (tmp___0 == 0) {
#line 33
      *result = tab->num;
#line 34
      return (0);
    }
#line 31
    tab ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (1);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xlat.c"
int xlat_c_string(struct xlat_tab *tab , char const   *string , int flags , int *result ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 44
  tmp = strlen(string);
#line 44
  tmp___0 = xlat_string(tab, string, tmp, flags, result);
  }
#line 44
  return (tmp___0);
}
}
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 37 "../include/dico/stream.h"
int dico_stream_create(dico_stream_t *pstream , int flags , void *data ) ;
#line 38
int dico_stream_open(dico_stream_t stream ) ;
#line 39
void dico_stream_set_open(dico_stream_t stream , int (*openfn)(void * , int  ) ) ;
#line 40
void dico_stream_set_seek(dico_stream_t stream , int (*fun_seek)(void * , off_t  ,
                                                                 int  , off_t * ) ) ;
#line 42
void dico_stream_set_size(dico_stream_t stream , int (*sizefn)(void * , off_t * ) ) ;
#line 44
void dico_stream_set_read(dico_stream_t stream , int (*readfn)(void * , char * , size_t  ,
                                                               size_t * ) ) ;
#line 46
void dico_stream_set_write(dico_stream_t stream , int (*writefn)(void * , char const   * ,
                                                                 size_t  , size_t * ) ) ;
#line 49
void dico_stream_set_flush(dico_stream_t stream , int (*flushfn)(void * ) ) ;
#line 50
void dico_stream_set_close(dico_stream_t stream , int (*closefn)(void * ) ) ;
#line 51
void dico_stream_set_destroy(dico_stream_t stream , int (*destroyfn)(void * ) ) ;
#line 53
void dico_stream_set_error_string(dico_stream_t stream , char const   *(*error_string)(void * ,
                                                                                       int  ) ) ;
#line 56
int dico_stream_set_buffer(dico_stream_t stream , enum dico_buffer_type type , size_t size ) ;
#line 60
off_t dico_stream_seek(dico_stream_t stream , off_t offset , int whence ) ;
#line 61
int dico_stream_size(dico_stream_t stream , off_t *psize ) ;
#line 64
int dico_stream_read_unbuffered(dico_stream_t stream , void *buf___1 , size_t size ,
                                size_t *pread ) ;
#line 66
int dico_stream_write_unbuffered(dico_stream_t stream , void const   *buf___1 , size_t size ,
                                 size_t *pwrite ) ;
#line 70
int dico_stream_read(dico_stream_t stream , void *buf___1 , size_t size , size_t *pread ) ;
#line 72
int dico_stream_readln(dico_stream_t stream , char *buf___1 , size_t size , size_t *pread ) ;
#line 74
int dico_stream_getdelim(dico_stream_t stream , char **pbuf , size_t *psize , int delim ,
                         size_t *pread ) ;
#line 76
int dico_stream_getline(dico_stream_t stream , char **pbuf , size_t *psize , size_t *pread ) ;
#line 78
int dico_stream_write(dico_stream_t stream , void const   *buf___1 , size_t size ) ;
#line 79
int dico_stream_writeln(dico_stream_t stream , char const   *buf___1 , size_t size ) ;
#line 81
char const   *dico_stream_strerror(dico_stream_t stream , int rc ) ;
#line 82
int dico_stream_last_error(dico_stream_t stream ) ;
#line 83
void dico_stream_clearerr(dico_stream_t stream ) ;
#line 84
int dico_stream_eof(dico_stream_t stream ) ;
#line 86
int dico_stream_flush(dico_stream_t stream ) ;
#line 87
int dico_stream_close(dico_stream_t stream ) ;
#line 88
void dico_stream_destroy(dico_stream_t *stream ) ;
#line 90
off_t dico_stream_bytes_in(dico_stream_t stream ) ;
#line 91
off_t dico_stream_bytes_out(dico_stream_t stream ) ;
#line 93
void dico_stream_set_ioctl(dico_stream_t stream , int (*ctl)(void * , int  , void * ) ) ;
#line 95
int dico_stream_ioctl(dico_stream_t stream , int code , void *ptr ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 94
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_seterror(dico_stream_t stream , int code , int perm ) 
{ 


  {
#line 57
  stream->last_err = code;
#line 58
  if (perm) {
#line 59
    stream->flags |= 8192;
  }
#line 60
  return (code);
}
}
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_create(dico_stream_t *pstream , int flags , void *data ) 
{ 
  dico_stream_t stream ;
  void *tmp ;

  {
  {
#line 66
  tmp = malloc((size_t )sizeof(*stream));
#line 66
  stream = (dico_stream_t )tmp;
  }
#line 67
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 68
    return (12);
  }
  {
#line 69
  memset((void *)stream, 0, (size_t )sizeof(*stream));
#line 70
  stream->flags = flags;
#line 71
  stream->data = data;
#line 72
  *pstream = stream;
  }
#line 73
  return (0);
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_open(dico_stream_t stream ) 
{ 
  int rc ;
  int tmp ;
  off_t tmp___0 ;

  {
#line 80
  if (stream->open) {
    {
#line 80
    rc = (*(stream->open))(stream->data, stream->flags);
    }
#line 80
    if (rc) {
      {
#line 81
      tmp = _stream_seterror(stream, rc, 1);
      }
#line 81
      return (tmp);
    }
  }
#line 82
  tmp___0 = (off_t )0;
#line 82
  stream->bytes_out = tmp___0;
#line 82
  stream->bytes_in = tmp___0;
#line 83
  return (0);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_error_string(dico_stream_t stream , char const   *(*error_string)(void * ,
                                                                                       int  ) ) 
{ 


  {
#line 90
  stream->error_string = error_string;
#line 91
  return;
}
}
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_open(dico_stream_t stream , int (*openfn)(void * , int  ) ) 
{ 


  {
#line 96
  stream->open = openfn;
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_seek(dico_stream_t stream , int (*fun_seek)(void * , off_t  ,
                                                                 int  , off_t * ) ) 
{ 


  {
#line 103
  stream->seek = fun_seek;
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_read(dico_stream_t stream , int (*readfn)(void * , char * , size_t  ,
                                                               size_t * ) ) 
{ 


  {
#line 110
  stream->read = readfn;
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_write(dico_stream_t stream , int (*writefn)(void * , char const   * ,
                                                                 size_t  , size_t * ) ) 
{ 


  {
#line 117
  stream->write = writefn;
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_flush(dico_stream_t stream , int (*flushfn)(void * ) ) 
{ 


  {
#line 123
  stream->flush = flushfn;
#line 124
  return;
}
}
#line 126 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_close(dico_stream_t stream , int (*closefn)(void * ) ) 
{ 


  {
#line 129
  stream->close = closefn;
#line 130
  return;
}
}
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_destroy(dico_stream_t stream , int (*destroyfn)(void * ) ) 
{ 


  {
#line 135
  stream->destroy = destroyfn;
#line 136
  return;
}
}
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_size(dico_stream_t stream , int (*sizefn)(void * , off_t * ) ) 
{ 


  {
#line 141
  stream->size = sizefn;
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_ioctl(dico_stream_t stream , int (*ctl)(void * , int  , void * ) ) 
{ 


  {
#line 147
  stream->ctl = ctl;
#line 148
  return;
}
}
#line 151 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
char const   *dico_stream_strerror(dico_stream_t stream , int rc ) 
{ 
  char const   *str ;
  char *tmp ;

  {
#line 155
  if (stream->error_string) {
    {
#line 156
    str = (*(stream->error_string))(stream->data, rc);
    }
  } else {
    {
#line 158
    tmp = strerror(rc);
#line 158
    str = (char const   *)tmp;
    }
  }
#line 159
  return (str);
}
}
#line 162 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_last_error(dico_stream_t stream ) 
{ 


  {
#line 165
  return (stream->last_err);
}
}
#line 168 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_clearerr(dico_stream_t stream ) 
{ 


  {
#line 171
  stream->last_err = 0;
#line 172
  return;
}
}
#line 174 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_eof(dico_stream_t stream ) 
{ 


  {
#line 177
  return (stream->flags & 16384);
}
}
#line 185 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
off_t dico_stream_seek(dico_stream_t stream , off_t offset , int whence ) 
{ 
  int rc ;
  off_t res ;
  size_t bpos ;
  int tmp ;

  {
#line 192
  if (! stream->seek) {
    {
#line 193
    _stream_seterror(stream, 38, 0);
    }
#line 194
    return ((off_t )-1);
  }
#line 196
  if (! (stream->flags & 4)) {
    {
#line 197
    _stream_seterror(stream, 13, 1);
    }
#line 198
    return ((off_t )-1);
  }
  {
#line 202
  if (whence == 0) {
#line 202
    goto case_0;
  }
#line 205
  if (whence == 1) {
#line 205
    goto case_1;
  }
#line 208
  if (whence == 2) {
#line 208
    goto case_2;
  }
#line 222
  goto switch_default;
  case_0: /* CIL Label */ 
#line 203
  goto switch_break;
  case_1: /* CIL Label */ 
#line 206
  goto switch_break;
  case_2: /* CIL Label */ 
#line 209
  bpos = (size_t )(stream->cur - stream->buffer);
#line 210
  if ((off_t )bpos + offset >= 0L) {
#line 210
    if ((off_t )bpos + offset < (long )stream->level + (stream->cur - stream->buffer)) {
      {
#line 211
      rc = (*(stream->seek))(stream->data, offset, whence, & res);
      }
#line 211
      if (rc) {
        {
#line 212
        _stream_seterror(stream, rc, 1);
        }
#line 213
        return ((off_t )-1);
      }
#line 215
      offset -= (off_t )bpos;
#line 216
      stream->cur += offset;
#line 216
      stream->level = (size_t )((off_t )stream->level - offset);
#line 217
      stream->flags &= -16385;
#line 218
      return (res - (off_t )stream->level);
    }
  }
#line 220
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 223
  _stream_seterror(stream, 22, 1);
  }
#line 224
  return ((off_t )-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 227
  tmp = dico_stream_flush(stream);
  }
#line 227
  if (tmp) {
#line 228
    return ((off_t )-1);
  }
  {
#line 229
  rc = (*(stream->seek))(stream->data, offset, whence, & res);
  }
#line 230
  if (rc) {
    {
#line 231
    _stream_seterror(stream, rc, 1);
    }
#line 232
    return ((off_t )-1);
  }
#line 234
  stream->flags &= -16385;
#line 235
  return (res);
}
}
#line 238 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_set_buffer(dico_stream_t stream , enum dico_buffer_type type , size_t size ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 242
  if (size == 0U) {
#line 243
    type = (enum dico_buffer_type )0;
  }
#line 245
  if (stream->buffer) {
    {
#line 246
    dico_stream_flush(stream);
#line 247
    free((void *)stream->buffer);
    }
  }
#line 250
  stream->buftype = type;
#line 251
  if ((unsigned int )type == 0U) {
#line 252
    stream->buffer = (char *)((void *)0);
#line 253
    return (0);
  }
  {
#line 256
  tmp = malloc(size);
#line 256
  stream->buffer = (char *)tmp;
  }
#line 257
  if ((unsigned long )stream->buffer == (unsigned long )((void *)0)) {
    {
#line 258
    stream->buftype = (enum dico_buffer_type )0;
#line 259
    tmp___0 = _stream_seterror(stream, 12, 1);
    }
#line 259
    return (tmp___0);
  }
#line 261
  stream->bufsize = size;
#line 262
  stream->cur = stream->buffer;
#line 263
  stream->level = (size_t )0;
#line 265
  return (0);
}
}
#line 268 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_read_unbuffered(dico_stream_t stream , void *buf___1 , size_t size ,
                                size_t *pread ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  size_t rdbytes ;

  {
#line 274
  if (! stream->read) {
    {
#line 275
    tmp = _stream_seterror(stream, 38, 0);
    }
#line 275
    return (tmp);
  }
#line 277
  if (! (stream->flags & 1)) {
    {
#line 278
    tmp___0 = _stream_seterror(stream, 13, 1);
    }
#line 278
    return (tmp___0);
  }
#line 280
  if (stream->flags & 8192) {
#line 281
    return (stream->last_err);
  }
#line 283
  if (stream->flags & 16384) {
#line 283
    goto _L;
  } else
#line 283
  if (size == 0U) {
    _L: /* CIL Label */ 
#line 284
    if (pread) {
#line 285
      *pread = (size_t )0;
#line 286
      return (0);
    } else {
      {
#line 288
      _stream_seterror(stream, 5, 0);
      }
#line 289
      return (5);
    }
  }
#line 293
  if ((unsigned long )pread == (unsigned long )((void *)0)) {
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      if (size > 0U) {
        {
#line 296
        rc = (*(stream->read))(stream->data, (char *)buf___1, size, & rdbytes);
        }
#line 296
        if (! (rc == 0)) {
#line 296
          goto while_break;
        }
      } else {
#line 296
        goto while_break;
      }
#line 298
      if (rdbytes == 0U) {
#line 299
        stream->flags |= 16384;
#line 300
        goto while_break;
      }
#line 302
      buf___1 += rdbytes;
#line 303
      size -= rdbytes;
#line 304
      stream->bytes_in += (off_t )rdbytes;
    }
    while_break: /* CIL Label */ ;
    }
#line 306
    if (size) {
      {
#line 307
      _stream_seterror(stream, 5, 0);
      }
#line 308
      return (5);
    }
  } else {
    {
#line 311
    rc = (*(stream->read))(stream->data, (char *)buf___1, size, pread);
    }
#line 312
    if (rc == 0) {
#line 313
      if (*pread == 0U) {
#line 314
        stream->flags |= 16384;
      }
#line 315
      stream->bytes_in += (off_t )*pread;
    }
  }
  {
#line 318
  _stream_seterror(stream, rc, rc != 0);
  }
#line 319
  return (rc);
}
}
#line 322 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_write_unbuffered(dico_stream_t stream , void const   *buf___1 , size_t size ,
                                 size_t *pwrite ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  size_t wrbytes ;
  char const   *bufp ;

  {
#line 329
  if (! stream->write) {
    {
#line 330
    tmp = _stream_seterror(stream, 38, 0);
    }
#line 330
    return (tmp);
  }
#line 332
  if (! (stream->flags & 2)) {
    {
#line 333
    tmp___0 = _stream_seterror(stream, 13, 1);
    }
#line 333
    return (tmp___0);
  }
#line 335
  if (stream->flags & 8192) {
#line 336
    return (stream->last_err);
  }
#line 338
  if (size == 0U) {
#line 339
    if (pwrite) {
#line 340
      *pwrite = (size_t )0;
    }
#line 341
    return (0);
  }
#line 344
  if ((unsigned long )pwrite == (unsigned long )((void *)0)) {
#line 346
    bufp = (char const   *)buf___1;
    {
#line 348
    while (1) {
      while_continue: /* CIL Label */ ;
#line 348
      if (size > 0U) {
        {
#line 348
        rc = (*(stream->write))(stream->data, bufp, size, & wrbytes);
        }
#line 348
        if (! (rc == 0)) {
#line 348
          goto while_break;
        }
      } else {
#line 348
        goto while_break;
      }
#line 351
      if (wrbytes == 0U) {
#line 352
        rc = 5;
#line 353
        goto while_break;
      }
#line 355
      bufp += wrbytes;
#line 356
      size -= wrbytes;
#line 357
      stream->bytes_out += (off_t )wrbytes;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 360
    rc = (*(stream->write))(stream->data, (char const   *)buf___1, size, pwrite);
    }
#line 361
    if (rc == 0) {
#line 362
      stream->bytes_out += (off_t )*pwrite;
    }
  }
  {
#line 364
  _stream_seterror(stream, rc, rc != 0);
  }
#line 365
  return (rc);
}
}
#line 368 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_fill_buffer(dico_stream_t stream ) 
{ 
  size_t n ;
  int rc ;
  char c ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 372
  rc = 0;
  {
#line 376
  if ((unsigned int )stream->buftype == 0U) {
#line 376
    goto case_0;
  }
#line 379
  if ((unsigned int )stream->buftype == 2U) {
#line 379
    goto case_2;
  }
#line 386
  if ((unsigned int )stream->buftype == 1U) {
#line 386
    goto case_1;
  }
#line 375
  goto switch_break;
  case_0: /* CIL Label */ 
#line 377
  return (0);
  case_2: /* CIL Label */ 
  {
#line 380
  tmp = dico_stream_read_unbuffered(stream, (void *)stream->buffer, stream->bufsize,
                                    & stream->level);
  }
#line 380
  if (tmp) {
#line 383
    return (1);
  }
#line 384
  goto switch_break;
  case_1: /* CIL Label */ 
#line 387
  n = (size_t )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (n < stream->bufsize) {
      {
#line 387
      rc = dico_stream_read_unbuffered(stream, (void *)(& c), (size_t )1, (size_t *)((void *)0));
      }
#line 387
      if (! (rc == 0)) {
#line 387
        goto while_break;
      }
    } else {
#line 387
      goto while_break;
    }
#line 391
    tmp___0 = n;
#line 391
    n ++;
#line 391
    *(stream->buffer + tmp___0) = c;
#line 392
    if ((int )c == 10) {
#line 393
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  stream->level = n;
#line 396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 398
  stream->cur = stream->buffer;
#line 399
  return (rc);
}
}
#line 405 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_buffer_full_p(dico_stream_t stream ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 409
  if ((unsigned int )stream->buftype == 0U) {
#line 409
    goto case_0;
  }
#line 412
  if ((unsigned int )stream->buftype == 1U) {
#line 412
    goto case_1;
  }
#line 416
  if ((unsigned int )stream->buftype == 2U) {
#line 416
    goto case_2;
  }
#line 408
  goto switch_break;
  case_0: /* CIL Label */ 
#line 410
  goto switch_break;
  case_1: /* CIL Label */ 
#line 413
  if ((unsigned long )(stream->cur + stream->level) == (unsigned long )(stream->buffer + stream->bufsize)) {
#line 413
    tmp___0 = 1;
  } else {
    {
#line 413
    tmp = memchr((void const   *)stream->cur, '\n', stream->level);
    }
#line 413
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 413
      tmp___0 = 1;
    } else {
#line 413
      tmp___0 = 0;
    }
  }
#line 413
  return (tmp___0);
  case_2: /* CIL Label */ 
#line 417
  return ((unsigned long )(stream->cur + stream->level) == (unsigned long )(stream->buffer + stream->bufsize));
  switch_break: /* CIL Label */ ;
  }
#line 419
  return (0);
}
}
#line 422 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_flush_buffer(dico_stream_t stream , int all ) 
{ 
  char *end ;
  off_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  int rc ;
  int tmp___3 ;
  int rc___0 ;
  int tmp___4 ;

  {
#line 427
  if (stream->flags & 4096) {
#line 428
    if (stream->flags & 4) {
      {
#line 428
      tmp = dico_stream_seek(stream, - ((long )stream->level + (stream->cur - stream->buffer)),
                             1);
      }
#line 428
      if (tmp < 0L) {
#line 432
        return (1);
      }
    }
    {
#line 435
    if ((unsigned int )stream->buftype == 0U) {
#line 435
      goto case_0;
    }
#line 438
    if ((unsigned int )stream->buftype == 2U) {
#line 438
      goto case_2;
    }
#line 444
    if ((unsigned int )stream->buftype == 1U) {
#line 444
      goto case_1;
    }
#line 434
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 436
    abort();
    }
    case_2: /* CIL Label */ 
    {
#line 439
    tmp___0 = dico_stream_write_unbuffered(stream, (void const   *)stream->cur, stream->level,
                                           (size_t *)((void *)0));
    }
#line 439
    if (tmp___0) {
#line 441
      return (1);
    }
#line 442
    goto switch_break;
    case_1: /* CIL Label */ 
#line 445
    if (stream->level == 0U) {
#line 446
      goto switch_break;
    }
    {
#line 447
    tmp___1 = memchr((void const   *)stream->cur, '\n', stream->level);
#line 447
    end = (char *)tmp___1;
    }
    {
#line 447
    while (1) {
      while_continue: /* CIL Label */ ;
#line 447
      if (! end) {
#line 447
        goto while_break;
      }
      {
#line 450
      size = (size_t )((end - stream->cur) + 1L);
#line 451
      tmp___3 = dico_stream_write_unbuffered(stream, (void const   *)stream->cur,
                                             size, (size_t *)((void *)0));
#line 451
      rc = tmp___3;
      }
#line 453
      if (rc) {
#line 454
        return (rc);
      }
      {
#line 455
      stream->cur += size;
#line 455
      stream->level -= size;
#line 447
      tmp___2 = memchr((void const   *)stream->cur, '\n', stream->level);
#line 447
      end = (char *)tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 457
    if (all) {
#line 457
      if (stream->level) {
#line 457
        goto _L;
      } else {
#line 457
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 457
    if ((unsigned long )(stream->cur + stream->level) == (unsigned long )(stream->buffer + stream->bufsize)) {
      _L: /* CIL Label */ 
      {
#line 458
      tmp___4 = dico_stream_write_unbuffered(stream, (void const   *)stream->cur,
                                             stream->level, (size_t *)((void *)0));
#line 458
      rc___0 = tmp___4;
      }
#line 460
      if (rc___0) {
#line 461
        return (rc___0);
      }
#line 462
      stream->cur += stream->level;
#line 462
      stream->level -= stream->level;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 466
  if (stream->level) {
#line 467
    if ((unsigned long )stream->cur > (unsigned long )stream->buffer) {
      {
#line 468
      memmove((void *)stream->buffer, (void const   *)stream->cur, stream->level);
      }
    }
  } else {
#line 470
    stream->flags &= -4097;
#line 471
    stream->level = (size_t )0;
  }
#line 473
  stream->cur = stream->buffer;
#line 474
  return (0);
}
}
#line 477 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_read(dico_stream_t stream , void *buf___1 , size_t size , size_t *pread ) 
{ 
  int tmp ;
  char *bufp ;
  size_t nbytes ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 480
  if ((unsigned int )stream->buftype == 0U) {
    {
#line 481
    tmp = dico_stream_read_unbuffered(stream, buf___1, size, pread);
    }
#line 481
    return (tmp);
  } else {
#line 483
    bufp = (char *)buf___1;
#line 484
    nbytes = (size_t )0;
    {
#line 485
    while (1) {
      while_continue: /* CIL Label */ ;
#line 485
      if (! size) {
#line 485
        goto while_break;
      }
#line 488
      if (stream->level == 0U) {
        {
#line 488
        tmp___0 = _stream_fill_buffer(stream);
        }
#line 488
        if (tmp___0) {
#line 489
          if (nbytes) {
#line 490
            goto while_break;
          }
#line 491
          return (1);
        }
      }
#line 494
      n = size;
#line 495
      if (n > stream->level) {
#line 496
        n = stream->level;
      }
      {
#line 497
      memcpy((void */* __restrict  */)bufp, (void const   */* __restrict  */)stream->cur,
             n);
#line 498
      stream->cur += n;
#line 498
      stream->level -= n;
#line 499
      nbytes += n;
#line 500
      bufp += n;
#line 501
      size -= n;
      }
#line 502
      if ((unsigned int )stream->buftype == 1U) {
#line 502
        if ((int )*(bufp + -1) == 10) {
#line 503
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 506
    if (pread) {
#line 507
      *pread = nbytes;
    } else
#line 508
    if (size) {
      {
#line 509
      tmp___1 = _stream_seterror(stream, 5, 1);
      }
#line 509
      return (tmp___1);
    }
  }
#line 511
  return (0);
}
}
#line 514 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_readln(dico_stream_t stream , char *buf___1 , size_t size , size_t *pread ) 
{ 
  int rc ;
  char c ;
  size_t n ;
  char *tmp ;

  {
#line 519
  n = (size_t )0;
#line 521
  if (size == 0U) {
#line 522
    return (5);
  }
#line 524
  size --;
#line 525
  n = (size_t )0;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (n < size) {
      {
#line 525
      rc = dico_stream_read(stream, (void *)(& c), (size_t )1, (size_t *)((void *)0));
      }
#line 525
      if (! (rc == 0)) {
#line 525
        goto while_break;
      }
    } else {
#line 525
      goto while_break;
    }
#line 527
    tmp = buf___1;
#line 527
    buf___1 ++;
#line 527
    *tmp = c;
#line 528
    if ((int )c == 10) {
#line 529
      goto while_break;
    }
#line 525
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  *buf___1 = (char)0;
#line 532
  if (pread) {
#line 533
    *pread = n;
  }
#line 534
  return (rc);
}
}
#line 537 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_getdelim(dico_stream_t stream , char **pbuf , size_t *psize , int delim ,
                         size_t *pread ) 
{ 
  int rc ;
  char *lineptr ;
  size_t n ;
  size_t cur_len ;
  char *new_lineptr ;
  void *tmp ;
  char c ;
  size_t needed_max ;
  size_t needed ;
  char *new_lineptr___0 ;
  void *tmp___0 ;

  {
#line 542
  lineptr = *pbuf;
#line 543
  n = *psize;
#line 544
  cur_len = (size_t )0;
#line 546
  if ((unsigned long )lineptr == (unsigned long )((void *)0)) {
#line 546
    goto _L;
  } else
#line 546
  if (n == 0U) {
    _L: /* CIL Label */ 
    {
#line 548
    n = (size_t )120;
#line 549
    tmp = realloc((void *)lineptr, n);
#line 549
    new_lineptr = (char *)tmp;
    }
#line 550
    if ((unsigned long )new_lineptr == (unsigned long )((void *)0)) {
#line 551
      return (12);
    }
#line 552
    lineptr = new_lineptr;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 558
    rc = dico_stream_read(stream, (void *)(& c), (size_t )1, (size_t *)((void *)0));
    }
#line 559
    if (rc) {
#line 560
      goto while_break;
    }
#line 563
    if (cur_len + 1U >= n) {
#line 564
      needed_max = 2147483648U;
#line 566
      needed = 2U * n + 1U;
#line 569
      if (needed_max < needed) {
#line 570
        needed = needed_max;
      }
#line 571
      if (cur_len + 1U >= needed) {
#line 572
        rc = 75;
#line 573
        goto while_break;
      }
      {
#line 576
      tmp___0 = realloc((void *)lineptr, needed);
#line 576
      new_lineptr___0 = (char *)tmp___0;
      }
#line 577
      if ((unsigned long )new_lineptr___0 == (unsigned long )((void *)0)) {
#line 578
        rc = 12;
#line 579
        goto while_break;
      }
#line 582
      lineptr = new_lineptr___0;
#line 583
      n = needed;
    }
#line 586
    *(lineptr + cur_len) = c;
#line 587
    cur_len ++;
#line 589
    if ((int )c == delim) {
#line 590
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  *(lineptr + cur_len) = (char )'\000';
#line 594
  *pbuf = lineptr;
#line 595
  *psize = n;
#line 597
  if (pread) {
#line 598
    *pread = cur_len;
  }
#line 599
  return (rc);
}
}
#line 602 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_getline(dico_stream_t stream , char **pbuf , size_t *psize , size_t *pread ) 
{ 
  int tmp ;

  {
  {
#line 606
  tmp = dico_stream_getdelim(stream, pbuf, psize, '\n', pread);
  }
#line 606
  return (tmp);
}
}
#line 609 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_write(dico_stream_t stream , void const   *buf___1 , size_t size ) 
{ 
  int tmp ;
  size_t nbytes ;
  char const   *bufp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 612
  if ((unsigned int )stream->buftype == 0U) {
    {
#line 613
    tmp = dico_stream_write_unbuffered(stream, buf___1, size, (size_t *)((void *)0));
    }
#line 613
    return (tmp);
  } else {
#line 615
    nbytes = (size_t )0;
#line 616
    bufp = (char const   *)buf___1;
    {
#line 618
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 621
      tmp___0 = _stream_buffer_full_p(stream);
      }
#line 621
      if (tmp___0) {
        {
#line 621
        tmp___1 = _stream_flush_buffer(stream, 0);
        }
#line 621
        if (tmp___1) {
#line 623
          return (1);
        }
      }
#line 625
      if (size == 0U) {
#line 626
        goto while_break;
      }
#line 628
      n = stream->bufsize - stream->level;
#line 629
      if (n > size) {
#line 630
        n = size;
      }
      {
#line 631
      memcpy((void */* __restrict  */)(stream->cur + stream->level), (void const   */* __restrict  */)bufp,
             n);
#line 632
      stream->level += n;
#line 633
      nbytes += n;
#line 634
      bufp += n;
#line 635
      size -= n;
#line 636
      stream->flags |= 4096;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 639
  return (0);
}
}
#line 642 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_writeln(dico_stream_t stream , char const   *buf___1 , size_t size ) 
{ 
  int rc ;
  char *__cil_tmp5 ;

  {
  {
#line 646
  rc = dico_stream_write(stream, (void const   *)buf___1, size);
  }
#line 646
  if (rc == 0) {
    {
#line 647
    rc = dico_stream_write(stream, (void const   *)"\r\n", (size_t )2);
    }
  }
#line 648
  return (rc);
}
}
#line 651 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_flush(dico_stream_t stream ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 654
  if (! stream) {
    {
#line 655
    tmp = __errno_location();
#line 655
    *tmp = 22;
    }
#line 656
    return (1);
  }
  {
#line 658
  tmp___0 = _stream_flush_buffer(stream, 1);
  }
#line 658
  if (tmp___0) {
#line 659
    return (1);
  }
#line 660
  if (stream->flush) {
    {
#line 661
    tmp___1 = (*(stream->flush))(stream->data);
    }
#line 661
    return (tmp___1);
  }
#line 662
  return (0);
}
}
#line 665 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_close(dico_stream_t stream ) 
{ 
  int rc ;

  {
#line 668
  rc = 0;
#line 669
  if (! stream) {
#line 670
    return (22);
  }
  {
#line 671
  dico_stream_flush(stream);
  }
#line 672
  if (stream->close) {
    {
#line 673
    rc = (*(stream->close))(stream->data);
    }
  }
#line 674
  return (rc);
}
}
#line 677 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_size(dico_stream_t stream , off_t *psize ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
#line 681
  if (! stream->size) {
    {
#line 682
    tmp = _stream_seterror(stream, 38, 0);
    }
#line 682
    return (tmp);
  }
  {
#line 683
  rc = (*(stream->size))(stream->data, psize);
#line 684
  tmp___0 = _stream_seterror(stream, rc, rc != 0);
  }
#line 684
  return (tmp___0);
}
}
#line 687 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_destroy(dico_stream_t *stream ) 
{ 


  {
#line 690
  if (! stream) {
#line 691
    return;
  } else
#line 690
  if (! *stream) {
#line 691
    return;
  }
#line 692
  if ((*stream)->destroy) {
    {
#line 693
    (*((*stream)->destroy))((*stream)->data);
    }
  }
  {
#line 694
  free((void *)*stream);
#line 695
  *stream = (dico_stream_t )((void *)0);
  }
#line 696
  return;
}
}
#line 698 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
off_t dico_stream_bytes_in(dico_stream_t stream ) 
{ 


  {
#line 701
  return (stream->bytes_in);
}
}
#line 704 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
off_t dico_stream_bytes_out(dico_stream_t stream ) 
{ 


  {
#line 707
  return (stream->bytes_out);
}
}
#line 710 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_ioctl(dico_stream_t stream , int code , void *ptr ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 713
  if ((unsigned long )stream->ctl == (unsigned long )((void *)0)) {
    {
#line 714
    tmp = __errno_location();
#line 714
    *tmp = 38;
    }
#line 715
    return (-1);
  }
  {
#line 717
  tmp___0 = (*(stream->ctl))(stream->data, code, ptr);
  }
#line 717
  return (tmp___0);
}
}
#line 28 "../include/dico/list.h"
struct dico_list *dico_list_create(void) ;
#line 29
void dico_list_destroy(struct dico_list **plist ) ;
#line 31
int dico_list_set_free_item(struct dico_list *list , int (*free_item)(void *item ,
                                                                      void *data ) ,
                            void *data ) ;
#line 33
dico_list_comp_t dico_list_set_comparator(struct dico_list *list , int (*comp)(void const   * ,
                                                                               void * ) ) ;
#line 37
void dico_list_iterate(struct dico_list *list , int (*func)(void *item , void *data ) ,
                       void *data ) ;
#line 39
size_t dico_list_count(struct dico_list *list ) ;
#line 40
int dico_list_append(struct dico_list *list , void *data ) ;
#line 53
void *dico_list_locate(struct dico_list *list , void *data ) ;
#line 57
dico_iterator_t dico_list_iterator(dico_list_t list ) ;
#line 32 "../include/dico/strat.h"
int dico_strat_name_cmp(void const   *item , void *data ) ;
#line 33
int dico_strat_free(void *item , void *data ) ;
#line 35
dico_strategy_t dico_strategy_create(char const   *name , char const   *descr ) ;
#line 36
dico_strategy_t dico_strategy_dup(dico_strategy_t const   strat ) ;
#line 37
dico_strategy_t dico_strategy_find(char const   *name ) ;
#line 38
int dico_strategy_add(dico_strategy_t const   strat ) ;
#line 39
dico_iterator_t dico_strategy_iterator(void) ;
#line 40
void dico_strategy_iterate(int (*itr)(void *item , void *data ) , void *data ) ;
#line 41
size_t dico_strategy_count(void) ;
#line 43
int dico_set_default_strategy(char const   *name ) ;
#line 44
dico_strategy_t const   dico_get_default_strategy(void) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
static dico_list_t strategy_list  ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
static dico_strategy_t default_strategy  ;
#line 31 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_strat_name_cmp(void const   *item , void *data ) 
{ 
  dico_strategy_t strat ;
  char const   *name ;
  int tmp ;

  {
  {
#line 34
  strat = (dico_strategy_t )item;
#line 35
  name = (char const   *)data;
#line 36
  tmp = strcmp((char const   *)strat->name, name);
  }
#line 36
  return (tmp);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t dico_strategy_create(char const   *name , char const   *descr ) 
{ 
  dico_strategy_t np ;
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 43
  tmp = strlen(name);
#line 43
  tmp___0 = strlen(descr);
#line 43
  size = (size_t )(((sizeof(*np) + (unsigned long )tmp) + (unsigned long )tmp___0) + 2UL);
#line 44
  tmp___1 = malloc(size);
#line 44
  np = (dico_strategy_t )tmp___1;
  }
#line 45
  if (np) {
    {
#line 46
    memset((void *)np, 0, size);
#line 47
    np->name = (char *)(np + 1);
#line 48
    strcpy((char */* __restrict  */)np->name, (char const   */* __restrict  */)name);
#line 49
    tmp___2 = strlen((char const   *)np->name);
#line 49
    np->descr = (np->name + tmp___2) + 1;
#line 50
    strcpy((char */* __restrict  */)np->descr, (char const   */* __restrict  */)descr);
    }
  }
#line 52
  return (np);
}
}
#line 55 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_strat_free(void *item , void *data ) 
{ 
  dico_strategy_t strat ;

  {
  {
#line 58
  strat = (dico_strategy_t )item;
#line 59
  dico_list_destroy(& strat->stratcl);
#line 60
  free((void *)strat);
  }
#line 61
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t dico_strategy_dup(dico_strategy_t const   strat ) 
{ 
  dico_strategy_t np ;
  dico_strategy_t tmp ;

  {
  {
#line 67
  tmp = dico_strategy_create((char const   *)strat->name, (char const   *)strat->descr);
#line 67
  np = tmp;
  }
#line 68
  if (np) {
#line 69
    np->sel = strat->sel;
#line 70
    np->closure = strat->closure;
  }
#line 72
  return (np);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t dico_strategy_find(char const   *name ) 
{ 
  void *tmp ;

  {
#line 78
  if ((int const   )*(name + 0) == 46) {
#line 78
    if ((int const   )*(name + 1) == 0) {
#line 79
      return (default_strategy);
    }
  }
  {
#line 80
  tmp = dico_list_locate(strategy_list, (void *)name);
  }
#line 80
  return ((dico_strategy_t )tmp);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_strategy_add(dico_strategy_t const   strat ) 
{ 
  dico_strategy_t new_strat ;
  dico_strategy_t tmp ;
  dico_strategy_t tmp___0 ;

  {
#line 86
  if (! strategy_list) {
    {
#line 87
    strategy_list = dico_list_create();
    }
#line 88
    if (! strategy_list) {
#line 89
      return (1);
    }
    {
#line 90
    dico_list_set_comparator(strategy_list, & dico_strat_name_cmp);
#line 91
    dico_list_set_free_item(strategy_list, & dico_strat_free, (void *)0);
    }
  }
  {
#line 93
  tmp___0 = dico_strategy_find((char const   *)strat->name);
  }
#line 93
  if (! tmp___0) {
    {
#line 94
    tmp = dico_strategy_dup(strat);
#line 94
    new_strat = tmp;
    }
#line 95
    if (! new_strat) {
#line 96
      return (1);
    }
    {
#line 97
    dico_list_append(strategy_list, (void *)new_strat);
    }
  }
#line 99
  return (0);
}
}
#line 102 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_iterator_t dico_strategy_iterator(void) 
{ 
  dico_iterator_t tmp ;

  {
  {
#line 105
  tmp = dico_list_iterator(strategy_list);
  }
#line 105
  return (tmp);
}
}
#line 108 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
size_t dico_strategy_count(void) 
{ 
  size_t tmp ;

  {
  {
#line 111
  tmp = dico_list_count(strategy_list);
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
void dico_strategy_iterate(int (*itr)(void *item , void *data ) , void *data ) 
{ 


  {
  {
#line 117
  dico_list_iterate(strategy_list, itr, data);
  }
#line 117
  return;
}
}
#line 120 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_set_default_strategy(char const   *name ) 
{ 
  dico_strategy_t sp ;
  int *tmp ;

  {
#line 125
  if ((int const   )*(name + 0) == 46) {
#line 125
    if ((int const   )*(name + 1) == 0) {
      {
#line 126
      tmp = __errno_location();
#line 126
      *tmp = 22;
      }
#line 127
      return (1);
    } else {
#line 125
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 125
    sp = dico_strategy_find(name);
    }
#line 125
    if ((unsigned long )sp == (unsigned long )((void *)0)) {
      {
#line 126
      tmp = __errno_location();
#line 126
      *tmp = 22;
      }
#line 127
      return (1);
    }
  }
#line 129
  if (default_strategy) {
#line 130
    default_strategy->is_default = 0;
  }
#line 131
  sp->is_default = 1;
#line 132
  default_strategy = sp;
#line 133
  return (0);
}
}
#line 136 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t const   dico_get_default_strategy(void) 
{ 


  {
#line 139
  return ((dico_strategy_t const   )default_strategy);
}
}
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 68 "../include/dico/utf8.h"
int dico_soundex(char const   *s , char *codestr ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/soundex.c"
static unsigned char soundextbl[26]  = 
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/soundex.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)2,      (unsigned char)2,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)0,      (unsigned char)1, 
        (unsigned char)2,      (unsigned char)6,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)0,      (unsigned char)2};
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/lib/soundex.c"
int dico_soundex(char const   *s , char *codestr ) 
{ 
  int i___0 ;
  int prev ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 57
  prev = 0;
#line 59
  tmp = toupper((int )*s);
#line 59
  *(codestr + 0) = (char )tmp;
#line 60
  i___0 = 1;
#line 60
  s ++;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (i___0 < 4) {
#line 60
      if (! *s) {
#line 60
        goto while_break;
      }
    } else {
#line 60
      goto while_break;
    }
    {
#line 61
    tmp___0 = toupper((int )*s);
#line 61
    n = (int )soundextbl[tmp___0 - 65];
    }
#line 62
    if (n) {
#line 63
      if (n == prev) {
#line 64
        goto __Cont;
      }
#line 65
      tmp___1 = i___0;
#line 65
      i___0 ++;
#line 65
      *(codestr + tmp___1) = (char )(n + 48);
#line 66
      prev = n;
    }
    __Cont: /* CIL Label */ 
#line 60
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i___0 < 4)) {
#line 69
      goto while_break___0;
    }
#line 70
    *(codestr + i___0) = (char )'0';
#line 69
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  *(codestr + i___0) = (char)0;
#line 72
  return (0);
}
}
#line 27 "../include/dico/filter.h"
dico_stream_t filter_stream_create(dico_stream_t str , size_t min_level , size_t max_line_length ,
                                   int (*xcode)(char const   * , size_t  , char * ,
                                                size_t  , size_t * ) , int mode___0 ) ;
#line 36
dico_stream_t dico_qp_stream_create(dico_stream_t str , int mode___0 ) ;
#line 46
int dico_qp_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) ;
#line 49
int dico_qp_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
int dico_qp_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) 
{ 
  char c ;
  int last_char ;
  size_t consumed ;
  size_t wscount ;
  size_t nbytes ;
  char const   *tmp ;
  size_t sz ;
  char chr[3] ;
  int new_c ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp21 ;

  {
#line 31
  last_char = 0;
#line 32
  consumed = (size_t )0;
#line 33
  wscount = (size_t )0;
#line 34
  nbytes = (size_t )0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (consumed < isize) {
#line 36
      if (! (nbytes < osize)) {
#line 36
        goto while_break;
      }
    } else {
#line 36
      goto while_break;
    }
#line 37
    tmp = iptr;
#line 37
    iptr ++;
#line 37
    c = (char )*tmp;
#line 39
    if ((int )c == 32) {
#line 40
      wscount ++;
#line 41
      consumed ++;
    } else
#line 39
    if ((int )c == 9) {
#line 40
      wscount ++;
#line 41
      consumed ++;
    } else {
#line 51
      if (wscount) {
#line 52
        if ((int )c != 13) {
#line 52
          if ((int )c != 10) {
#line 55
            if (consumed >= isize) {
#line 56
              goto while_break;
            }
#line 58
            if (nbytes + wscount > osize) {
#line 59
              sz = osize - nbytes;
            } else {
#line 61
              sz = wscount;
            }
            {
#line 62
            memcpy((void */* __restrict  */)optr, (void const   */* __restrict  */)((iptr - wscount) - 1),
                   sz);
#line 63
            optr += sz;
#line 64
            nbytes += sz;
            }
#line 65
            if (wscount > sz) {
#line 66
              wscount -= sz;
#line 67
              goto while_break;
            }
          }
        }
#line 70
        wscount = (size_t )0;
#line 71
        if (nbytes == osize) {
#line 72
          goto while_break;
        }
      }
#line 75
      if ((int )c == 61) {
#line 77
        if (consumed + 2U >= isize) {
#line 78
          goto while_break;
        } else {
#line 84
          chr[2] = (char)0;
#line 85
          tmp___0 = iptr;
#line 85
          iptr ++;
#line 85
          chr[0] = (char )*tmp___0;
#line 87
          if ((int )chr[0] != 10) {
            {
#line 88
            tmp___1 = iptr;
#line 88
            iptr ++;
#line 88
            chr[1] = (char )*tmp___1;
#line 89
            tmp___2 = strtoul((char const   */* __restrict  */)(chr), (char **/* __restrict  */)((void *)0),
                              16);
#line 89
            new_c = (int )tmp___2;
#line 90
            tmp___3 = optr;
#line 90
            optr ++;
#line 90
            *tmp___3 = (char )new_c;
#line 91
            nbytes ++;
#line 92
            consumed += 3U;
            }
          } else {
#line 94
            consumed += 2U;
          }
        }
      } else
#line 98
      if ((int )c == 13) {
#line 101
        if (consumed + 1U >= isize) {
#line 102
          goto while_break;
        } else {
#line 104
          iptr ++;
#line 105
          tmp___4 = optr;
#line 105
          optr ++;
#line 105
          *tmp___4 = (char )'\n';
#line 106
          nbytes ++;
#line 107
          consumed += 2U;
        }
      } else {
#line 110
        tmp___5 = optr;
#line 110
        optr ++;
#line 110
        *tmp___5 = c;
#line 111
        nbytes ++;
#line 112
        consumed ++;
      }
    }
#line 115
    last_char = (int )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *pnbytes = nbytes;
#line 118
  return ((int )(consumed - wscount));
}
}
#line 128 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
static char const   _hexdigits[17]  = 
#line 128
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
int dico_qp_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) 
{ 
  unsigned int c ;
  size_t consumed ;
  size_t nbytes ;
  int simple_char ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 126
  consumed = (size_t )0;
#line 127
  nbytes = (size_t )0;
#line 130
  nbytes = (size_t )0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (consumed < isize)) {
#line 137
      goto while_break;
    }
#line 141
    c = (unsigned int )*((unsigned char *)iptr);
#line 142
    if (c >= 32U) {
#line 142
      if (c <= 60U) {
#line 142
        tmp = 1;
      } else {
#line 142
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 142
    if (c >= 62U) {
#line 142
      if (c <= 126U) {
#line 142
        tmp = 1;
      } else {
#line 142
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 142
    if (c == 9U) {
#line 142
      tmp = 1;
    } else
#line 142
    if (c == 10U) {
#line 142
      tmp = 1;
    } else {
#line 142
      tmp = 0;
    }
#line 142
    simple_char = tmp;
#line 147
    if (simple_char) {
#line 149
      if (nbytes + 1U > osize) {
#line 150
        goto while_break;
      }
#line 152
      tmp___0 = optr;
#line 152
      optr ++;
#line 152
      *tmp___0 = (char )c;
#line 153
      nbytes ++;
#line 155
      iptr ++;
#line 156
      consumed ++;
    } else {
#line 160
      if (nbytes + 3U > osize) {
#line 161
        goto while_break;
      }
#line 163
      tmp___1 = optr;
#line 163
      optr ++;
#line 163
      *tmp___1 = (char )'=';
#line 164
      tmp___2 = optr;
#line 164
      optr ++;
#line 164
      *tmp___2 = (char )_hexdigits[(c >> 4) & 15U];
#line 165
      tmp___3 = optr;
#line 165
      optr ++;
#line 165
      *tmp___3 = (char )_hexdigits[c & 15U];
#line 167
      nbytes += 3U;
#line 170
      iptr ++;
#line 171
      consumed ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  *pnbytes = nbytes;
#line 175
  return ((int )consumed);
}
}
#line 179 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
dico_stream_t dico_qp_stream_create(dico_stream_t str , int mode___0 ) 
{ 
  int (*tmp)(char const   *iptr , size_t isize , char *optr , size_t osize , size_t *pnbytes ) ;
  dico_stream_t tmp___0 ;

  {
#line 182
  if (mode___0 == 0) {
#line 182
    tmp = & dico_qp_encode;
  } else {
#line 182
    tmp = & dico_qp_decode;
  }
  {
#line 182
  tmp___0 = filter_stream_create(str, (size_t )4, (size_t )0, tmp, mode___0);
  }
#line 182
  return (tmp___0);
}
}
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 48 "../include/dico/diag.h"
void ( /* format attribute */  dico_log)(int lvl , int errcode , char const   *fmt 
                                         , ...) ;
#line 51 "../include/dico/parseopt.h"
int dico_parseopt(struct dico_option *opt , int argc , char **argv , int flags , int *pindex ) ;
#line 45 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 21 "../include/libi18n.h"
void _dico_libi18n_init(void) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/parseopt.c"
static struct dico_option *find_opt(struct dico_option *opt , char const   *str ,
                                    char const   **value ) 
{ 
  size_t len___0 ;
  size_t tmp ;
  int isbool ;
  int tmp___0 ;
  int eq ;
  int tmp___1 ;
  char *__cil_tmp10 ;

  {
  {
#line 27
  tmp = strlen(str);
#line 27
  len___0 = tmp;
  }
#line 30
  if (len___0 > 2U) {
    {
#line 30
    tmp___0 = memcmp((void const   *)str, (void const   *)"no", (size_t )2);
    }
#line 30
    if (tmp___0 == 0) {
#line 31
      *value = (char const   *)((void *)0);
#line 32
      str += 2;
#line 33
      isbool = 1;
    } else {
#line 35
      isbool = 0;
#line 36
      *value = str;
    }
  } else {
#line 35
    isbool = 0;
#line 36
    *value = str;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! opt->name) {
#line 39
      goto while_break;
    }
#line 40
    if (len___0 >= opt->len) {
      {
#line 40
      tmp___1 = memcmp((void const   *)opt->name, (void const   *)str, opt->len);
      }
#line 40
      if (tmp___1 == 0) {
#line 40
        if (! isbool) {
#line 40
          goto _L;
        } else
#line 40
        if ((unsigned int )opt->type == 1U) {
          _L: /* CIL Label */ 
#line 43
          eq = (int const   )*(str + opt->len) == 61;
          {
#line 49
          if ((unsigned int )opt->type == 6U) {
#line 49
            goto case_6;
          }
#line 49
          if ((unsigned int )opt->type == 8U) {
#line 49
            goto case_6;
          }
#line 49
          if ((unsigned int )opt->type == 5U) {
#line 49
            goto case_6;
          }
#line 49
          if ((unsigned int )opt->type == 4U) {
#line 49
            goto case_6;
          }
#line 55
          if ((unsigned int )opt->type == 0U) {
#line 55
            goto case_0;
          }
#line 62
          goto switch_default;
          case_6: /* CIL Label */ 
          case_8: /* CIL Label */ 
          case_5: /* CIL Label */ 
          case_4: /* CIL Label */ 
#line 50
          if (! eq) {
#line 51
            goto __Cont;
          }
#line 52
          *value = (str + opt->len) + 1;
#line 53
          goto switch_break;
          case_0: /* CIL Label */ 
#line 56
          if (eq) {
#line 57
            *value = (str + opt->len) + 1;
          } else {
#line 59
            *value = (char const   *)((void *)0);
          }
#line 60
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 63
          if (eq) {
#line 64
            goto __Cont;
          }
#line 65
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 67
          return (opt);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 39
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((struct dico_option *)((void *)0));
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/parseopt.c"
int find_value(char const   **enumstr , char const   *value ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 77
  i___0 = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! *enumstr) {
#line 77
      goto while_break;
    }
    {
#line 78
    tmp = strcmp(*enumstr, value);
    }
#line 78
    if (tmp == 0) {
#line 79
      return (i___0);
    }
#line 77
    enumstr ++;
#line 77
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (-1);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/lib/parseopt.c"
int dico_parseopt(struct dico_option *opt , int argc , char **argv , int flags , int *pindex ) 
{ 
  int i___0 ;
  long n ;
  char *s ;
  int rc ;
  char const   *modname ;
  char const   *value ;
  struct dico_option *p ;
  struct dico_option *tmp ;
  int j ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 90
  rc = 0;
#line 91
  modname = (char const   *)*(argv + 0);
#line 93
  _dico_libi18n_init();
  }
#line 95
  if (flags & 1) {
#line 95
    i___0 = 0;
  } else {
#line 95
    i___0 = 1;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i___0 < argc)) {
#line 95
      goto while_break;
    }
    {
#line 98
    tmp = find_opt(opt, (char const   *)*(argv + i___0), & value);
#line 98
    p = tmp;
    }
#line 100
    if (! p) {
#line 101
      if (pindex) {
#line 102
        if (flags & 2) {
#line 105
          j = i___0 + 1;
          {
#line 105
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 105
            if (! (j < argc)) {
#line 105
              goto while_break___0;
            }
            {
#line 106
            p = find_opt(opt, (char const   *)*(argv + j), & value);
            }
#line 106
            if (p) {
#line 107
              goto while_break___0;
            }
#line 105
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 109
          if (p) {
#line 110
            tmp___0 = *(argv + j);
#line 111
            *(argv + j) = *(argv + i___0);
#line 112
            *(argv + i___0) = tmp___0;
          } else {
#line 114
            goto while_break;
          }
        } else {
#line 116
          goto while_break;
        }
      } else {
        {
#line 118
        tmp___1 = dgettext("dico", "%s: %s: unknown option");
#line 118
        dico_log(4, 0, (char const   *)tmp___1, modname, *(argv + i___0));
#line 120
        rc = 1;
        }
#line 121
        goto __Cont;
      }
    }
    {
#line 126
    if ((unsigned int )p->type == 4U) {
#line 126
      goto case_4;
    }
#line 137
    if ((unsigned int )p->type == 7U) {
#line 137
      goto case_7;
    }
#line 141
    if ((unsigned int )p->type == 8U) {
#line 141
      goto case_8;
    }
#line 145
    if ((unsigned int )p->type == 5U) {
#line 145
      goto case_5;
    }
#line 149
    if ((unsigned int )p->type == 1U) {
#line 149
      goto case_1;
    }
#line 159
    if ((unsigned int )p->type == 2U) {
#line 159
      goto case_2;
    }
#line 163
    if ((unsigned int )p->type == 3U) {
#line 163
      goto case_3;
    }
#line 167
    if ((unsigned int )p->type == 6U) {
#line 167
      goto case_6;
    }
#line 178
    if ((unsigned int )p->type == 0U) {
#line 178
      goto case_0;
    }
#line 125
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 127
    n = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& s),
               0);
    }
#line 128
    if (*s) {
      {
#line 129
      tmp___2 = dgettext("dico", "%s: %s: %s is not a valid number");
#line 129
      dico_log(4, 0, (char const   *)tmp___2, modname, p->name, value);
#line 131
      rc = 1;
      }
#line 132
      goto __Cont;
    }
#line 134
    *((long *)p->data) = n;
#line 135
    goto switch_break;
    case_7: /* CIL Label */ 
#line 138
    *((long *)p->data) = p->v.value;
#line 139
    goto switch_break;
    case_8: /* CIL Label */ 
#line 142
    *((char const   **)p->data) = value;
#line 143
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 146
    tmp___3 = strdup(value);
#line 146
    *((char const   **)p->data) = (char const   *)tmp___3;
    }
#line 147
    goto switch_break;
    case_1: /* CIL Label */ 
#line 150
    if (p->v.value) {
#line 151
      if (value) {
#line 152
        *((int *)p->data) = (int )((long )*((int *)p->data) | p->v.value);
      } else {
#line 154
        *((int *)p->data) = (int )((long )*((int *)p->data) & ~ p->v.value);
      }
    } else {
#line 156
      *((int *)p->data) = (unsigned long )value != (unsigned long )((void *)0);
    }
#line 157
    goto switch_break;
    case_2: /* CIL Label */ 
#line 160
    *((int *)p->data) = (int )((long )*((int *)p->data) | p->v.value);
#line 161
    goto switch_break;
    case_3: /* CIL Label */ 
#line 164
    *((int *)p->data) = (int )((long )*((int *)p->data) & ~ p->v.value);
#line 165
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 168
    tmp___4 = find_value(p->v.enumstr, value);
#line 168
    n = (long )tmp___4;
    }
#line 169
    if (n == -1L) {
      {
#line 170
      tmp___5 = dgettext("dico", "%s: %s: invalid value %s");
#line 170
      dico_log(4, 0, (char const   *)tmp___5, modname, p->name, value);
#line 172
      rc = 1;
      }
#line 173
      goto __Cont;
    }
#line 175
    *((int *)p->data) = (int )n;
#line 176
    goto switch_break;
    case_0: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 182
    if (p->func) {
      {
#line 182
      tmp___6 = (*(p->func))(p, value);
      }
#line 182
      if (tmp___6) {
#line 183
        rc = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 95
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if (pindex) {
#line 186
    *pindex = i___0;
  }
#line 187
  return (rc);
}
}
#line 24 "../include/dico/markup.h"
char const   *dico_markup_lookup(char const   *name ) ;
#line 25
int dico_markup_register(char const   *name ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
char const   *dico_markup_type  =    "none";
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
static int cmp_markup_name(void const   *item , void *data ) 
{ 
  int tmp ;

  {
  {
#line 30
  tmp = strcasecmp((char const   *)((char *)item), (char const   *)((char *)data));
  }
#line 30
  return (tmp);
}
}
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
char const   *dico_markup_lookup(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 36
  tmp = dico_list_locate(dico_markup_list, (void *)name);
  }
#line 36
  return ((char const   *)tmp);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
int dico_markup_valid_name_p(char const   *name ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! *name) {
#line 42
      goto while_break;
    }
#line 43
    if (((int const   )*name & -128) == 0) {
      {
#line 43
      tmp = __ctype_b_loc();
      }
#line 43
      if (! ((int const   )*(*tmp + (int )*name) & 8)) {
#line 43
        if (! ((int const   )*name == 95)) {
#line 44
          return (0);
        }
      }
    } else {
#line 44
      return (0);
    }
#line 42
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (1);
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
int dico_markup_register(char const   *name ) 
{ 
  int tmp ;
  char *s ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 51
  tmp = dico_markup_valid_name_p(name);
  }
#line 51
  if (! tmp) {
#line 52
    return (22);
  }
#line 54
  if (! dico_markup_list) {
    {
#line 55
    dico_markup_list = dico_list_create();
    }
#line 56
    if (! dico_markup_list) {
#line 57
      return (12);
    }
    {
#line 58
    dico_list_set_comparator(dico_markup_list, & cmp_markup_name);
    }
  }
  {
#line 61
  tmp___2 = dico_markup_lookup(name);
  }
#line 61
  if (! tmp___2) {
    {
#line 62
    tmp___0 = strdup(name);
#line 62
    s = tmp___0;
    }
#line 63
    if (! s) {
#line 64
      return (12);
    }
    {
#line 65
    tmp___1 = dico_list_append(dico_markup_list, (void *)s);
    }
#line 65
    return (tmp___1);
  }
#line 67
  return (0);
}
}
#line 111 "../include/dico/stream.h"
dico_stream_t dico_mapfile_stream_create(char const   *filename___0 , int flags ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 58 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_close(void *data ) 
{ 
  struct _mapfile_stream *mfs ;

  {
#line 50
  mfs = (struct _mapfile_stream *)data;
#line 51
  if (mfs->start) {
    {
#line 52
    munmap((void *)mfs->start, mfs->size);
#line 53
    mfs->start = (char *)((void *)0);
#line 54
    mfs->size = (size_t )0;
    }
  }
  {
#line 56
  close(mfs->fd);
#line 57
  mfs->fd = -1;
  }
#line 58
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
int _mapfile_destroy(void *data ) 
{ 
  struct _mapfile_stream *str ;

  {
  {
#line 64
  str = (struct _mapfile_stream *)data;
#line 65
  free((void *)str->filename);
#line 66
  free((void *)str);
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
int _mapfile_open(void *data , int flags ) 
{ 
  struct _mapfile_stream *mfs ;
  struct stat st ;
  int mflags ;
  int oflags ;
  int *tmp ;
  int err ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int err___0 ;
  int *tmp___3 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 73
  mfs = (struct _mapfile_stream *)data;
#line 75
  mflags = 0;
#line 75
  oflags = 0;
#line 78
  _mapfile_close(data);
  }
#line 81
  if (flags & 1) {
#line 82
    mflags |= 1;
  }
#line 83
  if (flags & 2) {
#line 84
    mflags |= 2;
  }
#line 86
  if ((flags & 3) == 3) {
#line 88
    oflags = 2;
  } else
#line 89
  if (flags & 1) {
#line 90
    oflags = 0;
  } else {
#line 92
    oflags = 1;
  }
  {
#line 94
  mfs->fd = open((char const   *)mfs->filename, oflags);
  }
#line 95
  if (mfs->fd < 0) {
    {
#line 96
    tmp = __errno_location();
    }
#line 96
    return (*tmp);
  }
  {
#line 97
  tmp___1 = fstat(mfs->fd, & st);
  }
#line 97
  if (tmp___1) {
    {
#line 98
    tmp___0 = __errno_location();
#line 98
    err = *tmp___0;
#line 99
    close(mfs->fd);
    }
#line 100
    return (err);
  }
#line 102
  mfs->size = (size_t )st.st_size;
#line 103
  if (mfs->size) {
    {
#line 104
    tmp___2 = mmap((void *)0, mfs->size, mflags, 1, mfs->fd, (__off_t )0);
#line 104
    mfs->start = (char *)tmp___2;
    }
#line 105
    if ((unsigned long )mfs->start == (unsigned long )((void *)-1)) {
      {
#line 106
      tmp___3 = __errno_location();
#line 106
      err___0 = *tmp___3;
#line 107
      close(mfs->fd);
#line 108
      mfs->start = (char *)((void *)0);
      }
#line 109
      return (err___0);
    }
  } else {
#line 112
    mfs->start = (char *)((void *)0);
  }
#line 113
  mfs->flags = mflags;
#line 114
  return (0);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_seek(void *data , off_t needle , int whence , off_t *presult ) 
{ 
  struct _mapfile_stream *str ;
  off_t offset ;

  {
#line 120
  str = (struct _mapfile_stream *)data;
  {
#line 124
  if (whence == 0) {
#line 124
    goto case_0;
  }
#line 128
  if (whence == 1) {
#line 128
    goto case_1;
  }
#line 132
  if (whence == 2) {
#line 132
    goto case_2;
  }
#line 136
  goto switch_default;
  case_0: /* CIL Label */ 
#line 125
  offset = needle;
#line 126
  goto switch_break;
  case_1: /* CIL Label */ 
#line 129
  offset = str->offset + needle;
#line 130
  goto switch_break;
  case_2: /* CIL Label */ 
#line 133
  offset = (off_t )str->size + needle;
#line 134
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 137
  return (22);
  switch_break: /* CIL Label */ ;
  }
#line 140
  if (offset < 0L) {
#line 141
    return (22);
  } else
#line 140
  if (offset > (off_t )str->size) {
#line 141
    return (22);
  }
#line 142
  str->offset = offset;
#line 143
  *presult = offset;
#line 144
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_size(void *data , off_t *presult ) 
{ 
  struct _mapfile_stream *mfs ;

  {
#line 150
  mfs = (struct _mapfile_stream *)data;
#line 152
  if ((unsigned long )mfs->start == (unsigned long )((void *)0)) {
#line 153
    return (22);
  }
#line 154
  *presult = (off_t )mfs->size;
#line 155
  return (0);
}
}
#line 158 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _mapfile_stream *mfs ;
  size_t n ;

  {
#line 161
  mfs = (struct _mapfile_stream *)data;
#line 164
  if ((unsigned long )mfs->start == (unsigned long )((void *)0)) {
#line 165
    return (22);
  }
#line 167
  if (mfs->offset + (off_t )size > (off_t )mfs->size) {
#line 167
    n = (size_t )((off_t )mfs->size - mfs->offset);
  } else {
#line 167
    n = size;
  }
  {
#line 168
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)(mfs->start + mfs->offset),
         n);
#line 169
  mfs->offset += (off_t )n;
#line 171
  *pret = n;
  }
#line 172
  return (0);
}
}
#line 175 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
dico_stream_t dico_mapfile_stream_create(char const   *filename___0 , int flags ) 
{ 
  int rc ;
  dico_stream_t str ;
  struct _mapfile_stream *s ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  tmp = malloc((size_t )sizeof(*s));
#line 180
  s = (struct _mapfile_stream *)tmp;
  }
#line 183
  if (flags & 2) {
    {
#line 184
    tmp___0 = __errno_location();
#line 184
    *tmp___0 = 22;
    }
#line 185
    return ((dico_stream_t )((void *)0));
  }
#line 188
  if (! s) {
#line 189
    return ((dico_stream_t )((void *)0));
  }
  {
#line 190
  memset((void *)s, 0, (size_t )sizeof(*s));
#line 191
  s->fd = -1;
#line 192
  s->filename = strdup(filename___0);
  }
#line 193
  if (! s->filename) {
    {
#line 194
    free((void *)s);
    }
#line 195
    return ((dico_stream_t )((void *)0));
  }
  {
#line 198
  rc = dico_stream_create(& str, flags, (void *)s);
  }
#line 199
  if (rc) {
    {
#line 200
    free((void *)s->filename);
#line 201
    free((void *)s);
    }
#line 202
    return ((dico_stream_t )((void *)0));
  }
  {
#line 204
  dico_stream_set_open(str, & _mapfile_open);
#line 205
  dico_stream_set_seek(str, & _mapfile_seek);
#line 206
  dico_stream_set_size(str, & _mapfile_size);
#line 207
  dico_stream_set_read(str, & _mapfile_read);
#line 208
  dico_stream_set_close(str, & _mapfile_close);
#line 209
  dico_stream_set_destroy(str, & _mapfile_destroy);
  }
#line 210
  return (str);
}
}
#line 54 "../include/dico/diag.h"
dico_stream_t dico_log_stream_create(int level ) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
static int log_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct log_stream *p ;
  char *__cil_tmp6 ;

  {
#line 29
  p = (struct log_stream *)data;
#line 30
  if (pret) {
#line 31
    *pret = size;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (size > 0U) {
#line 32
      if (! ((int const   )*(buf___1 + (size - 1U)) == 10)) {
#line 32
        if (! ((int const   )*(buf___1 + (size - 1U)) == 13)) {
#line 32
          goto while_break;
        }
      }
    } else {
#line 32
      goto while_break;
    }
#line 33
    size --;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (size) {
    {
#line 35
    dico_log(p->level, 0, "%.*s", size, buf___1);
    }
  }
#line 36
  return (0);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
static int log_destroy(void *data ) 
{ 


  {
  {
#line 42
  free(data);
  }
#line 43
  return (0);
}
}
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
dico_stream_t dico_log_stream_create(int level ) 
{ 
  struct log_stream *p ;
  void *tmp ;
  dico_stream_t stream ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = malloc((size_t )sizeof(*p));
#line 49
  p = (struct log_stream *)tmp;
  }
#line 52
  if (! p) {
#line 53
    return ((dico_stream_t )((void *)0));
  } else {
    {
#line 52
    tmp___0 = dico_stream_create(& stream, 2, (void *)p);
    }
#line 52
    if (tmp___0) {
#line 53
      return ((dico_stream_t )((void *)0));
    }
  }
  {
#line 54
  dico_stream_set_write(stream, & log_write);
#line 55
  dico_stream_set_destroy(stream, & log_destroy);
#line 56
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
#line 57
  p->level = level;
  }
#line 58
  return (stream);
}
}
#line 30 "../include/dico/list.h"
int dico_list_clear(struct dico_list *list ) ;
#line 35
dico_list_comp_t dico_list_get_comparator(struct dico_list *list ) ;
#line 38
void *dico_list_item(struct dico_list *list , size_t n ) ;
#line 41
int dico_list_prepend(struct dico_list *list , void *data ) ;
#line 42
int dico_list_insert_sorted(struct dico_list *list , void *data ) ;
#line 43
dico_list_t dico_list_intersect(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                           void * ) ) ;
#line 45
int dico_list_intersect_p(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                     void * ) ) ;
#line 48
void *dico_list_pop(struct dico_list *list ) ;
#line 50
void *_dico_list_locate(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                         void * ) ) ;
#line 51
int _dico_list_remove(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                       void * ) ,
                      void **pptr ) ;
#line 54
int dico_list_remove(struct dico_list *list , void *data , void **pret ) ;
#line 56
void *dico_iterator_current(dico_iterator_t ip ) ;
#line 58
void dico_iterator_destroy(dico_iterator_t *ip ) ;
#line 59
void *dico_iterator_first(dico_iterator_t ip ) ;
#line 60
void *dico_iterator_next(dico_iterator_t ip ) ;
#line 62
int dico_iterator_remove_current(dico_iterator_t ip , void **pptr ) ;
#line 63
void dico_iterator_set_data(dico_iterator_t ip , void *data ) ;
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static int cmp_ptr(void const   *a , void *b ) 
{ 


  {
#line 49
  return ((unsigned long )a != (unsigned long )b);
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct dico_list *dico_list_create(void) 
{ 
  struct dico_list *p ;
  void *tmp ;
  struct list_entry *tmp___0 ;

  {
  {
#line 55
  tmp = malloc((size_t )sizeof(*p));
#line 55
  p = (struct dico_list *)tmp;
  }
#line 56
  if (p) {
#line 57
    p->count = (size_t )0;
#line 58
    tmp___0 = (struct list_entry *)((void *)0);
#line 58
    p->tail = tmp___0;
#line 58
    p->head = tmp___0;
#line 59
    p->itr = (struct iterator *)((void *)0);
#line 60
    p->comp = & cmp_ptr;
#line 61
    p->free_item = (int (*)(void *item , void *data ))((void *)0);
#line 62
    p->free_data = (void *)0;
  }
#line 64
  return (p);
}
}
#line 67 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_clear(struct dico_list *list ) 
{ 
  struct list_entry *p ;
  int *tmp ;
  struct list_entry *tmp___0 ;
  struct list_entry *next ;

  {
#line 72
  if (! list) {
    {
#line 73
    tmp = __errno_location();
#line 73
    *tmp = 22;
    }
#line 74
    return (1);
  }
#line 77
  p = list->head;
#line 78
  tmp___0 = (struct list_entry *)((void *)0);
#line 78
  list->tail = tmp___0;
#line 78
  list->head = tmp___0;
#line 79
  list->count = (size_t )0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! p) {
#line 81
      goto while_break;
    }
#line 82
    next = p->next;
#line 83
    if (list->free_item) {
      {
#line 84
      (*(list->free_item))(p->data, list->free_data);
      }
    }
    {
#line 85
    free((void *)p);
#line 86
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_list_destroy(struct dico_list **plist ) 
{ 
  struct dico_list *list ;

  {
#line 96
  if (! plist) {
#line 97
    return;
  } else
#line 96
  if (! *plist) {
#line 97
    return;
  }
  {
#line 99
  list = *plist;
#line 100
  *plist = (struct dico_list *)((void *)0);
#line 102
  dico_list_clear(list);
#line 103
  free((void *)list);
  }
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_list_free_item(struct dico_list *list , void *item ) 
{ 


  {
#line 109
  if (list->free_item) {
    {
#line 110
    (*(list->free_item))(item, list->free_data);
    }
  }
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_iterator_current(dico_iterator_t ip ) 
{ 
  void *tmp ;

  {
#line 116
  if (! ip) {
#line 117
    return ((void *)0);
  }
#line 118
  if (ip->cur) {
#line 118
    tmp = (ip->cur)->data;
  } else {
#line 118
    tmp = (void *)0;
  }
#line 118
  return (tmp);
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static void dico_iterator_attach(dico_iterator_t itr , dico_list_t list ) 
{ 


  {
#line 124
  itr->list = list;
#line 125
  itr->cur = (struct list_entry *)((void *)0);
#line 126
  itr->next = list->itr;
#line 127
  itr->advanced = 0;
#line 128
  list->itr = itr;
#line 129
  return;
}
}
#line 131 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static dico_iterator_t dico_iterator_detach(dico_iterator_t iter ) 
{ 
  dico_iterator_t cur ;
  dico_iterator_t prev ;

  {
#line 136
  cur = (iter->list)->itr;
#line 136
  prev = (dico_iterator_t )((void *)0);
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! cur) {
#line 136
      goto while_break;
    }
#line 139
    if ((unsigned long )cur == (unsigned long )iter) {
#line 140
      goto while_break;
    }
#line 136
    prev = cur;
#line 136
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (cur) {
#line 143
    if (prev) {
#line 144
      prev->next = cur->next;
    } else {
#line 146
      (cur->list)->itr = cur->next;
    }
  }
#line 148
  return (cur);
}
}
#line 151 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_iterator_t dico_list_iterator(dico_list_t list ) 
{ 
  dico_iterator_t itr ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 156
  if (! list) {
    {
#line 157
    tmp = __errno_location();
#line 157
    *tmp = 22;
    }
#line 158
    return ((dico_iterator_t )((void *)0));
  }
  {
#line 160
  tmp___0 = malloc((size_t )sizeof(*itr));
#line 160
  itr = (dico_iterator_t )tmp___0;
  }
#line 161
  if (itr) {
    {
#line 162
    dico_iterator_attach(itr, list);
    }
  }
#line 163
  return (itr);
}
}
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_iterator_destroy(dico_iterator_t *ip ) 
{ 
  dico_iterator_t itr ;

  {
#line 171
  if (! ip) {
#line 172
    return;
  } else
#line 171
  if (! *ip) {
#line 172
    return;
  }
  {
#line 173
  itr = dico_iterator_detach(*ip);
  }
#line 174
  if (itr) {
    {
#line 175
    free((void *)itr);
    }
  }
#line 176
  *ip = (dico_iterator_t )((void *)0);
#line 177
  return;
}
}
#line 179 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_iterator_first(dico_iterator_t ip ) 
{ 
  void *tmp ;

  {
#line 182
  if (! ip) {
#line 183
    return ((void *)0);
  }
  {
#line 184
  ip->cur = (ip->list)->head;
#line 185
  ip->advanced = 0;
#line 186
  tmp = dico_iterator_current(ip);
  }
#line 186
  return (tmp);
}
}
#line 189 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_iterator_next(dico_iterator_t ip ) 
{ 
  void *tmp ;

  {
#line 192
  if (! ip) {
#line 193
    return ((void *)0);
  } else
#line 192
  if (! ip->cur) {
#line 193
    return ((void *)0);
  }
#line 194
  if (! ip->advanced) {
#line 195
    ip->cur = (ip->cur)->next;
  }
  {
#line 196
  ip->advanced = 0;
#line 197
  tmp = dico_iterator_current(ip);
  }
#line 197
  return (tmp);
}
}
#line 200 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_iterator_remove_current(dico_iterator_t ip , void **pptr ) 
{ 
  int tmp ;

  {
  {
#line 203
  tmp = _dico_list_remove(ip->list, (ip->cur)->data, (int (*)(void const   * , void * ))((void *)0),
                          pptr);
  }
#line 203
  return (tmp);
}
}
#line 206 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_iterator_set_data(dico_iterator_t ip , void *data ) 
{ 


  {
#line 209
  (ip->cur)->data = data;
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static void _iterator_advance(dico_iterator_t ip , struct list_entry *e ) 
{ 


  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ip) {
#line 215
      goto while_break;
    }
#line 216
    if ((unsigned long )ip->cur == (unsigned long )e) {
#line 217
      ip->cur = e->next;
#line 218
      (ip->advanced) ++;
    }
#line 215
    ip = ip->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_list_item(struct dico_list *list , size_t n ) 
{ 
  struct list_entry *p ;

  {
#line 227
  if (! list) {
#line 228
    return ((void *)0);
  } else
#line 227
  if (n >= list->count) {
#line 228
    return ((void *)0);
  }
#line 229
  p = list->head;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (n > 0U) {
#line 229
      if (! p) {
#line 229
        goto while_break;
      }
    } else {
#line 229
      goto while_break;
    }
#line 229
    p = p->next;
#line 229
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (p->data);
}
}
#line 234 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
size_t dico_list_count(struct dico_list *list ) 
{ 


  {
#line 237
  if (! list) {
#line 238
    return ((size_t )0);
  }
#line 239
  return (list->count);
}
}
#line 242 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_set_free_item(struct dico_list *list , int (*free_item)(void *item ,
                                                                      void *data ) ,
                            void *data ) 
{ 
  int *tmp ;

  {
#line 246
  if (! list) {
    {
#line 247
    tmp = __errno_location();
#line 247
    *tmp = 22;
    }
#line 248
    return (1);
  }
#line 250
  list->free_item = free_item;
#line 251
  list->free_data = data;
#line 252
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_list_comp_t dico_list_set_comparator(struct dico_list *list , int (*comp)(void const   * ,
                                                                               void * ) ) 
{ 
  int (*prev)(void const   * , void * ) ;
  int *tmp ;

  {
#line 260
  if (! list) {
    {
#line 261
    tmp = __errno_location();
#line 261
    *tmp = 22;
    }
#line 262
    return ((dico_list_comp_t )((void *)0));
  }
#line 264
  prev = list->comp;
#line 265
  list->comp = comp;
#line 266
  return (prev);
}
}
#line 269 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_list_comp_t dico_list_get_comparator(struct dico_list *list ) 
{ 
  int *tmp ;

  {
#line 272
  if (! list) {
    {
#line 273
    tmp = __errno_location();
#line 273
    *tmp = 22;
    }
#line 274
    return ((dico_list_comp_t )((void *)0));
  }
#line 276
  return (list->comp);
}
}
#line 279 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_append(struct dico_list *list , void *data ) 
{ 
  struct list_entry *ep ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 284
  if (! list) {
    {
#line 285
    tmp = __errno_location();
#line 285
    *tmp = 22;
    }
#line 286
    return (1);
  }
  {
#line 288
  tmp___0 = malloc((size_t )sizeof(*ep));
#line 288
  ep = (struct list_entry *)tmp___0;
  }
#line 289
  if (! ep) {
#line 290
    return (1);
  }
#line 291
  ep->next = (struct list_entry *)((void *)0);
#line 292
  ep->data = data;
#line 293
  if (list->tail) {
#line 294
    (list->tail)->next = ep;
  } else {
#line 296
    list->head = ep;
  }
#line 297
  list->tail = ep;
#line 298
  (list->count) ++;
#line 299
  return (0);
}
}
#line 302 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_prepend(struct dico_list *list , void *data ) 
{ 
  struct list_entry *ep ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 307
  if (! list) {
    {
#line 308
    tmp = __errno_location();
#line 308
    *tmp = 22;
    }
#line 309
    return (1);
  }
  {
#line 311
  tmp___0 = malloc((size_t )sizeof(*ep));
#line 311
  ep = (struct list_entry *)tmp___0;
  }
#line 312
  if (! ep) {
#line 313
    return (1);
  }
#line 314
  ep->data = data;
#line 315
  ep->next = list->head;
#line 316
  list->head = ep;
#line 317
  if (! list->tail) {
#line 318
    list->tail = list->head;
  }
#line 319
  (list->count) ++;
#line 320
  return (0);
}
}
#line 323 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int _dico_list_remove(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                       void * ) ,
                      void **pptr ) 
{ 
  struct list_entry *p ;
  struct list_entry *prev ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 329
  if (! list) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 2;
    }
#line 331
    return (1);
  } else
#line 329
  if (! list->head) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 2;
    }
#line 331
    return (1);
  }
#line 334
  if (! cmp) {
#line 335
    cmp = & cmp_ptr;
  }
#line 336
  p = list->head;
#line 336
  prev = (struct list_entry *)((void *)0);
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! p) {
#line 336
      goto while_break;
    }
    {
#line 337
    tmp___0 = (*cmp)((void const   *)p->data, data);
    }
#line 337
    if (tmp___0 == 0) {
#line 338
      goto while_break;
    }
#line 336
    prev = p;
#line 336
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (! p) {
    {
#line 341
    tmp___1 = __errno_location();
#line 341
    *tmp___1 = 2;
    }
#line 342
    return (1);
  }
  {
#line 345
  _iterator_advance(list->itr, p);
  }
#line 346
  if ((unsigned long )p == (unsigned long )list->head) {
#line 347
    list->head = (list->head)->next;
#line 348
    if (! list->head) {
#line 349
      list->tail = (struct list_entry *)((void *)0);
    }
  } else {
#line 351
    prev->next = p->next;
  }
#line 353
  if ((unsigned long )p == (unsigned long )list->tail) {
#line 354
    list->tail = prev;
  }
  {
#line 356
  free((void *)p);
#line 357
  (list->count) --;
  }
#line 359
  if (pptr) {
#line 360
    *pptr = data;
  } else
#line 361
  if (list->free_item) {
    {
#line 362
    (*(list->free_item))(data, list->free_data);
    }
  }
#line 363
  return (0);
}
}
#line 366 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_remove(struct dico_list *list , void *data , void **pret ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 369
  if (! list) {
    {
#line 370
    tmp = __errno_location();
#line 370
    *tmp = 22;
    }
#line 371
    return (1);
  }
  {
#line 373
  tmp___0 = _dico_list_remove(list, data, list->comp, pret);
  }
#line 373
  return (tmp___0);
}
}
#line 376 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_list_pop(struct dico_list *list ) 
{ 
  void *p ;

  {
  {
#line 380
  dico_list_remove(list, (list->head)->data, & p);
  }
#line 381
  return (p);
}
}
#line 386 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_list_iterate(struct dico_list *list , int (*func)(void *item , void *data ) ,
                       void *data ) 
{ 
  struct iterator itr ;
  void *p ;
  int tmp ;
  void *__cil_tmp7 ;

  {
#line 393
  if (! list) {
#line 394
    return;
  }
  {
#line 395
  dico_iterator_attach(& itr, list);
#line 396
  p = dico_iterator_first(& itr);
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! p) {
#line 396
      goto while_break;
    }
    {
#line 397
    tmp = (*func)(p, data);
    }
#line 397
    if (tmp) {
#line 398
      goto while_break;
    }
    {
#line 396
    p = dico_iterator_next(& itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  dico_iterator_detach(& itr);
  }
#line 401
  return;
}
}
#line 403 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *_dico_list_locate(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                         void * ) ) 
{ 
  struct list_entry *cur ;
  int tmp ;
  void *tmp___0 ;

  {
#line 407
  if (! list) {
#line 408
    return ((void *)0);
  }
#line 409
  if (! cmp) {
#line 410
    cmp = & cmp_ptr;
  }
#line 411
  cur = list->head;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! cur) {
#line 411
      goto while_break;
    }
    {
#line 412
    tmp = (*cmp)((void const   *)cur->data, data);
    }
#line 412
    if (tmp == 0) {
#line 413
      goto while_break;
    }
#line 411
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  if (cur) {
#line 414
    tmp___0 = cur->data;
  } else {
#line 414
    tmp___0 = (void *)0;
  }
#line 414
  return (tmp___0);
}
}
#line 417 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_list_locate(struct dico_list *list , void *data ) 
{ 
  void *tmp ;

  {
#line 420
  if (! list) {
#line 421
    return ((void *)0);
  }
  {
#line 422
  tmp = _dico_list_locate(list, data, list->comp);
  }
#line 422
  return (tmp);
}
}
#line 425 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int _dico_list_insert_sorted(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                              void * ) ) 
{ 
  int rc ;
  struct list_entry *cur ;
  struct list_entry *prev ;
  int *tmp ;
  int tmp___0 ;
  struct list_entry *ep ;
  void *tmp___1 ;

  {
#line 432
  if (! list) {
    {
#line 433
    tmp = __errno_location();
#line 433
    *tmp = 22;
    }
#line 434
    return (1);
  }
#line 437
  if (! cmp) {
#line 438
    cmp = & cmp_ptr;
  }
#line 440
  cur = list->head;
#line 440
  prev = (struct list_entry *)((void *)0);
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! cur) {
#line 440
      goto while_break;
    }
    {
#line 441
    tmp___0 = (*cmp)((void const   *)cur->data, data);
    }
#line 441
    if (tmp___0 > 0) {
#line 442
      goto while_break;
    }
#line 440
    prev = cur;
#line 440
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  if (! prev) {
    {
#line 445
    rc = dico_list_prepend(list, data);
    }
  } else
#line 446
  if (! cur) {
    {
#line 447
    rc = dico_list_append(list, data);
    }
  } else {
    {
#line 449
    tmp___1 = malloc((size_t )sizeof(*ep));
#line 449
    ep = (struct list_entry *)tmp___1;
    }
#line 450
    if (ep) {
#line 451
      rc = 0;
#line 452
      ep->data = data;
#line 453
      ep->next = cur;
#line 454
      prev->next = ep;
#line 455
      (list->count) ++;
    } else {
#line 457
      rc = 1;
    }
  }
#line 459
  return (rc);
}
}
#line 462 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_insert_sorted(struct dico_list *list , void *data ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 465
  if (! list) {
    {
#line 466
    tmp = __errno_location();
#line 466
    *tmp = 22;
    }
#line 467
    return (1);
  }
  {
#line 469
  tmp___0 = _dico_list_insert_sorted(list, data, list->comp);
  }
#line 469
  return (tmp___0);
}
}
#line 476 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_list_t dico_list_intersect(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                           void * ) ) 
{ 
  dico_list_t res ;
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  void *p ;
  void *tmp___0 ;

  {
  {
#line 480
  tmp = dico_list_iterator(a);
#line 480
  itr = tmp;
  }
#line 483
  if (! itr) {
#line 484
    return ((dico_list_t )((void *)0));
  }
  {
#line 485
  res = dico_list_create();
  }
#line 486
  if (! res) {
#line 487
    return ((dico_list_t )((void *)0));
  }
  {
#line 488
  p = dico_iterator_first(itr);
  }
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! p) {
#line 488
      goto while_break;
    }
    {
#line 489
    tmp___0 = _dico_list_locate(b, p, cmp);
    }
#line 489
    if (tmp___0) {
      {
#line 490
      dico_list_append(res, p);
      }
    }
    {
#line 488
    p = dico_iterator_next(itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 492
  dico_iterator_destroy(& itr);
  }
#line 493
  return (res);
}
}
#line 497 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_intersect_p(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                     void * ) ) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  void *p ;
  int rc ;
  void *tmp___0 ;

  {
  {
#line 500
  tmp = dico_list_iterator(a);
#line 500
  itr = tmp;
#line 502
  rc = 0;
#line 504
  p = dico_iterator_first(itr);
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! p) {
#line 504
      goto while_break;
    }
    {
#line 505
    tmp___0 = _dico_list_locate(b, p, cmp);
    }
#line 505
    if (tmp___0) {
#line 506
      rc = 1;
#line 507
      goto while_break;
    }
    {
#line 504
    p = dico_iterator_next(itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  dico_iterator_destroy(& itr);
  }
#line 511
  return (rc);
}
}
#line 87 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/libi18n.c"
static int libdico_initialized  ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/libi18n.c"
void _dico_libi18n_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
#line 29
  if (! libdico_initialized) {
    {
#line 30
    bindtextdomain("dico", "/usr/local/share/locale");
#line 31
    libdico_initialized = 1;
    }
  }
#line 33
  return;
}
}
#line 66 "../include/dico/utf8.h"
int dico_levenshtein_distance(char const   *astr , char const   *bstr , int flags ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/lib/levenshtein.c"
int dico_levenshtein_distance(char const   *astr , char const   *bstr , int flags ) 
{ 
  unsigned int *a ;
  unsigned int *b ;
  int alen ;
  int blen ;
  unsigned int *rowptr ;
  unsigned int *row[3] ;
  int i___0 ;
  int j ;
  int idx ;
  int nrows ;
  int dist ;
  int (*conv)(char const   * , unsigned int ** ) ;
  int (*tmp)(char const   *str , unsigned int **nptr ) ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  unsigned int n ;
  unsigned int cost ;
  int prev ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  void *__cil_tmp32 ;

  {
#line 45
  if (flags & 1) {
#line 45
    tmp = & utf8_mbstr_to_norm_wc;
  } else {
#line 45
    tmp = & utf8_mbstr_to_wc;
  }
  {
#line 45
  conv = tmp;
#line 48
  tmp___0 = (*conv)(astr, & a);
  }
#line 48
  if (tmp___0 < 0) {
#line 49
    return (-1);
  }
  {
#line 50
  tmp___1 = (*conv)(bstr, & b);
  }
#line 50
  if (tmp___1 < 0) {
    {
#line 51
    free((void *)a);
    }
#line 52
    return (-1);
  }
  {
#line 54
  tmp___2 = utf8_wc_strlen((unsigned int const   *)a);
#line 54
  alen = (int )tmp___2;
#line 55
  tmp___3 = utf8_wc_strlen((unsigned int const   *)b);
#line 55
  blen = (int )tmp___3;
#line 57
  tmp___4 = calloc((size_t )sizeof(*(rowptr + 0)), (size_t )((2 + ! (! (flags & 2))) * (blen + 1)));
#line 57
  rowptr = (unsigned int *)tmp___4;
#line 59
  row[0] = rowptr;
#line 60
  row[1] = (rowptr + blen) + 1;
  }
#line 61
  if (flags & 2) {
#line 62
    nrows = 3;
#line 63
    row[2] = (row[1] + blen) + 1;
  } else {
#line 65
    nrows = 2;
  }
#line 67
  i___0 = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i___0 < blen + 1)) {
#line 67
      goto while_break;
    }
#line 68
    *(row[0] + i___0) = (unsigned int )i___0;
#line 67
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  idx = 1;
#line 74
  i___0 = 0;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i___0 < alen)) {
#line 74
      goto while_break___0;
    }
#line 75
    *(row[idx] + 0) = (unsigned int )(i___0 + 1);
#line 77
    j = 0;
    {
#line 77
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 77
      if (! (j < blen)) {
#line 77
        goto while_break___1;
      }
      {
#line 79
      prev = ((idx + nrows) - 1) % nrows;
#line 81
      tmp___5 = utf8_wc_toupper(*(a + i___0));
#line 81
      tmp___6 = utf8_wc_toupper(*(b + j));
      }
#line 81
      if (tmp___5 == tmp___6) {
#line 81
        tmp___7 = 0;
      } else {
#line 81
        tmp___7 = 1;
      }
#line 81
      cost = (unsigned int )tmp___7;
#line 82
      if (*(row[prev] + (j + 1)) + 1U < *(row[idx] + j) + 1U) {
#line 82
        n = *(row[prev] + (j + 1)) + 1U;
      } else {
#line 82
        n = *(row[idx] + j) + 1U;
      }
#line 84
      if (n < *(row[prev] + j) + cost) {
#line 84
        n = n;
      } else {
#line 84
        n = *(row[prev] + j) + cost;
      }
#line 85
      if (flags & 2) {
#line 86
        if (i___0 > 0) {
#line 86
          if (j > 0) {
            {
#line 86
            tmp___8 = utf8_wc_toupper(*(a + i___0));
#line 86
            tmp___9 = utf8_wc_toupper(*(b + (j - 1)));
            }
#line 86
            if (tmp___8 == tmp___9) {
              {
#line 86
              tmp___10 = utf8_wc_toupper(*(a + (i___0 - 1)));
#line 86
              tmp___11 = utf8_wc_toupper(*(b + j));
              }
#line 86
              if (tmp___10 == tmp___11) {
#line 90
                if (n < *(row[(idx + 1) % nrows] + (j - 1)) + cost) {
#line 90
                  n = n;
                } else {
#line 90
                  n = *(row[(idx + 1) % nrows] + (j - 1)) + cost;
                }
              }
            }
          }
        }
      }
#line 92
      *(row[idx] + (j + 1)) = n;
#line 77
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 95
    dist = (int )*(row[idx] + blen);
#line 74
    i___0 ++;
#line 74
    idx = (idx + 1) % nrows;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 99
  free((void *)rowptr);
#line 100
  free((void *)a);
#line 101
  free((void *)b);
  }
#line 102
  return (dist);
}
}
#line 110 "../include/dico/stream.h"
dico_stream_t dico_io_stream(dico_stream_t in , dico_stream_t out ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _iostr *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 33
  p = (struct _iostr *)data;
#line 34
  tmp___0 = dico_stream_read(p->in, (void *)buf___1, size, pret);
  }
#line 34
  if (tmp___0) {
    {
#line 35
    p->last_err = p->in;
#line 36
    tmp = dico_stream_last_error(p->in);
    }
#line 36
    return (tmp);
  }
#line 38
  return (0);
}
}
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _iostr *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 44
  p = (struct _iostr *)data;
#line 45
  tmp___0 = dico_stream_write(p->out, (void const   *)buf___1, size);
  }
#line 45
  if (tmp___0) {
    {
#line 46
    p->last_err = p->out;
#line 47
    tmp = dico_stream_last_error(p->out);
    }
#line 47
    return (tmp);
  }
#line 49
  *pret = size;
#line 50
  return (0);
}
}
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_flush(void *data ) 
{ 
  struct _iostr *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 56
  p = (struct _iostr *)data;
#line 57
  tmp___0 = dico_stream_flush(p->in);
  }
#line 57
  if (tmp___0) {
    {
#line 58
    p->last_err = p->in;
#line 59
    tmp = dico_stream_last_error(p->in);
    }
#line 59
    return (tmp);
  }
  {
#line 61
  tmp___2 = dico_stream_flush(p->out);
  }
#line 61
  if (tmp___2) {
    {
#line 62
    p->last_err = p->out;
#line 63
    tmp___1 = dico_stream_last_error(p->out);
    }
#line 63
    return (tmp___1);
  }
#line 65
  return (0);
}
}
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_close(void *data ) 
{ 
  struct _iostr *p ;

  {
  {
#line 71
  p = (struct _iostr *)data;
#line 73
  dico_stream_close(p->in);
#line 74
  dico_stream_close(p->out);
  }
#line 75
  return (0);
}
}
#line 78 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_destroy(void *data ) 
{ 
  struct _iostr *p ;

  {
  {
#line 81
  p = (struct _iostr *)data;
#line 82
  dico_stream_destroy(& p->in);
#line 83
  dico_stream_destroy(& p->out);
#line 84
  free((void *)p);
  }
#line 85
  return (0);
}
}
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static char const   *io_error_string(void *data , int code ) 
{ 
  struct _iostr *p ;
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 91
  p = (struct _iostr *)data;
#line 92
  if (! p->last_err) {
    {
#line 93
    tmp = dgettext("dico", "No error");
    }
#line 93
    return ((char const   *)tmp);
  }
  {
#line 94
  tmp___0 = dico_stream_strerror(p->last_err, code);
  }
#line 94
  return (tmp___0);
}
}
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
dico_stream_t dico_io_stream(dico_stream_t in , dico_stream_t out ) 
{ 
  int rc ;
  dico_stream_t str ;
  struct _iostr *s ;
  void *tmp ;

  {
  {
#line 104
  _dico_libi18n_init();
#line 105
  tmp = malloc((size_t )sizeof(*s));
#line 105
  s = (struct _iostr *)tmp;
  }
#line 106
  if (! s) {
#line 107
    return ((dico_stream_t )((void *)0));
  }
  {
#line 108
  rc = dico_stream_create(& str, 3, (void *)s);
  }
#line 109
  if (rc) {
    {
#line 110
    free((void *)s);
    }
#line 111
    return ((dico_stream_t )((void *)0));
  }
  {
#line 113
  s->in = in;
#line 114
  s->out = out;
#line 115
  s->last_err = (dico_stream_t )((void *)0);
#line 116
  dico_stream_set_write(str, & io_write);
#line 117
  dico_stream_set_read(str, & io_read);
#line 118
  dico_stream_set_flush(str, & io_flush);
#line 119
  dico_stream_set_close(str, & io_close);
#line 120
  dico_stream_set_destroy(str, & io_destroy);
#line 121
  dico_stream_set_error_string(str, & io_error_string);
  }
#line 122
  return (str);
}
}
#line 49 "../include/dico/assoc.h"
int dico_header_parse(dico_assoc_list_t *pasc , char const   *text ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
static int hdr_buf_append(struct hdr_buf *buf___1 , char const   *str , size_t len___0 ) 
{ 
  size_t size ;
  void *tmp ;
  char *p ;
  size_t diff ;
  size_t size___0 ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 40
  if (len___0 == 0U) {
#line 41
    return (0);
  }
#line 43
  if (buf___1->size == 0U) {
    {
#line 44
    size = 128U * (((len___0 + 128U) - 1U) / 128U);
#line 45
    tmp = malloc(size);
#line 45
    buf___1->base = (char *)tmp;
    }
#line 46
    if (! buf___1->base) {
#line 47
      return (1);
    }
#line 48
    buf___1->size = size;
  } else
#line 49
  if (buf___1->level + len___0 > buf___1->size) {
#line 51
    diff = (buf___1->level + len___0) - buf___1->size;
#line 52
    size___0 = buf___1->size * (((diff + buf___1->size) - 1U) / buf___1->size + 1U);
#line 53
    if (size___0 < buf___1->size) {
      {
#line 54
      tmp___0 = __errno_location();
#line 54
      *tmp___0 = 12;
      }
#line 55
      return (1);
    }
    {
#line 57
    tmp___1 = realloc((void *)buf___1->base, size___0);
#line 57
    p = (char *)tmp___1;
    }
#line 58
    if (! p) {
#line 59
      return (1);
    }
#line 60
    buf___1->base = p;
#line 61
    buf___1->size = size___0;
  }
  {
#line 63
  memcpy((void */* __restrict  */)(buf___1->base + buf___1->level), (void const   */* __restrict  */)str,
         len___0);
#line 64
  buf___1->level += len___0;
  }
#line 65
  return (0);
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
static int collect_line(char const   **ptext , dico_assoc_list_t asc , struct hdr_buf *hbuf ) 
{ 
  char const   *text ;
  char c ;
  char *p ;
  size_t n ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp14 ;

  {
#line 74
  text = *ptext;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    hbuf->level = (size_t )0;
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if ((int const   )*text == 32) {
#line 80
      goto _L;
    } else
#line 80
    if ((int const   )*text == 9) {
      _L: /* CIL Label */ 
      {
#line 81
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 81
        if (*text) {
#line 81
          if (! ((int const   )*text == 32)) {
#line 81
            if (! ((int const   )*text == 9)) {
#line 81
              goto while_break___1;
            }
          }
        } else {
#line 81
          goto while_break___1;
        }
#line 82
        text ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 83
      text --;
    }
    {
#line 85
    n = strcspn(text, "\n");
    }
#line 87
    if (n == 0U) {
      {
#line 88
      tmp = strlen(text);
#line 88
      text += tmp;
      }
#line 89
      goto while_break___0;
    }
    {
#line 92
    tmp___0 = hdr_buf_append(hbuf, text, n);
    }
#line 92
    if (tmp___0) {
#line 93
      return (1);
    }
#line 95
    text += n;
#line 96
    if (! *text) {
#line 97
      goto while_break___0;
    }
#line 98
    text ++;
#line 79
    if (! ((int const   )*text == 32)) {
#line 79
      if (! ((int const   )*text == 9)) {
#line 79
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 101
  c = (char)0;
#line 102
  tmp___1 = hdr_buf_append(hbuf, (char const   *)(& c), (size_t )1);
  }
#line 102
  if (tmp___1) {
#line 103
    return (1);
  }
  {
#line 104
  p = strchr((char const   *)hbuf->base, ':');
  }
#line 105
  if (! p) {
    {
#line 106
    tmp___2 = __errno_location();
#line 106
    *tmp___2 = 22;
    }
#line 107
    return (1);
  }
#line 109
  tmp___3 = p;
#line 109
  p ++;
#line 109
  *tmp___3 = (char)0;
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 110
    if (*p) {
#line 110
      if (! ((int )*p == 32)) {
#line 110
        if (! ((int )*p == 9)) {
#line 110
          goto while_break___2;
        }
      }
    } else {
#line 110
      goto while_break___2;
    }
#line 111
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 112
  tmp___4 = dico_assoc_append(asc, (char const   *)hbuf->base, (char const   *)p);
  }
#line 112
  if (tmp___4) {
#line 113
    return (1);
  }
#line 114
  *ptext = text;
#line 115
  return (0);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
int dico_header_parse(dico_assoc_list_t *pasc , char const   *text ) 
{ 
  int rc ;
  struct hdr_buf hbuf ;
  dico_assoc_list_t asc ;
  dico_assoc_list_t tmp ;
  int ec ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp10 ;

  {
  {
#line 121
  rc = 0;
#line 122
  hbuf.base = (char *)((void *)0);
#line 122
  hbuf.size = (size_t )0;
#line 122
  hbuf.level = (size_t )0;
#line 123
  tmp = dico_assoc_create(3);
#line 123
  asc = tmp;
  }
#line 125
  if (! asc) {
#line 126
    return (1);
  }
#line 128
  if (text) {
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (*text) {
#line 129
        if ((int const   )*text != 10) {
          {
#line 129
          rc = collect_line(& text, asc, & hbuf);
          }
#line 129
          if (! (rc == 0)) {
#line 129
            goto while_break;
          }
        } else {
#line 129
          goto while_break;
        }
      } else {
#line 129
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 132
      free((void *)hbuf.base);
      }
#line 132
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 135
  if (rc) {
    {
#line 136
    tmp___0 = __errno_location();
#line 136
    ec = *tmp___0;
#line 137
    dico_assoc_destroy(& asc);
#line 138
    tmp___1 = __errno_location();
#line 138
    *tmp___1 = ec;
    }
  } else {
#line 140
    *pasc = asc;
  }
#line 141
  return (rc);
}
}
#line 32 "../include/dico/filter.h"
dico_stream_t dico_codec_stream_create(char const   *encoding , int mode___0 , dico_stream_t transport ) ;
#line 35
dico_stream_t dico_base64_stream_create(dico_stream_t str , int mode___0 ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct filter_stream *fs ;
  size_t rdsize ;
  int rc ;

  {
#line 40
  fs = (struct filter_stream *)data;
#line 44
  if (fs->level < fs->min_level) {
    {
#line 45
    rc = dico_stream_read(fs->transport, (void *)(fs->buf + fs->level), (size_t )(sizeof(fs->buf) - (unsigned long )fs->level),
                          & rdsize);
    }
#line 48
    if (rc) {
#line 49
      return (rc);
    }
#line 50
    fs->level = rdsize;
  }
#line 53
  if (fs->level) {
    {
#line 54
    rc = (*(fs->xcode))((char const   *)(fs->buf), fs->level, buf___1, size, & rdsize);
#line 56
    memmove((void *)(fs->buf), (void const   *)(fs->buf + rc), fs->level - (size_t )rc);
#line 57
    fs->level = (size_t )rc;
#line 58
    *pret = rdsize;
#line 59
    rc = 0;
    }
  } else {
#line 61
    *pret = (size_t )0;
#line 62
    rc = 0;
  }
#line 64
  return (rc);
}
}
#line 67 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_flush(struct filter_stream *fs ) 
{ 
  int tmp ;
  char *buf___1 ;
  size_t level ;
  int rc ;
  size_t rest ;
  size_t len___0 ;
  int skip ;
  char *p ;
  void *tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 70
  if (fs->level == 0U) {
#line 71
    return (0);
  } else
#line 72
  if (fs->max_line_length == 0U) {
    {
#line 73
    tmp = dico_stream_write(fs->transport, (void const   *)(fs->buf), fs->level);
    }
#line 73
    return (tmp);
  } else {
#line 75
    buf___1 = fs->buf;
#line 76
    level = fs->level;
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! level) {
#line 77
        goto while_break;
      }
      {
#line 79
      rest = fs->max_line_length - fs->line_length;
#line 81
      skip = 0;
#line 82
      tmp___0 = memchr((void const   *)buf___1, '\n', level);
#line 82
      p = (char *)tmp___0;
      }
#line 84
      if (rest > level) {
#line 85
        rest = level;
      }
#line 87
      if (p) {
#line 88
        len___0 = (size_t )(p - buf___1);
#line 89
        if (len___0 > rest) {
#line 90
          len___0 = rest;
        } else {
#line 92
          skip = 1;
        }
      } else {
#line 94
        len___0 = rest;
      }
      {
#line 96
      rc = dico_stream_write(fs->transport, (void const   *)buf___1, len___0);
      }
#line 97
      if (rc) {
#line 98
        return (1);
      }
#line 99
      fs->line_length += len___0;
#line 100
      if (fs->line_length == fs->max_line_length) {
        {
#line 101
        fs->line_length = (size_t )0;
#line 102
        rc = dico_stream_write(fs->transport, (void const   *)"\r\n", (size_t )2);
        }
#line 103
        if (rc) {
#line 104
          return (1);
        }
      }
#line 107
      if (skip) {
#line 108
        len___0 ++;
      }
#line 109
      buf___1 += len___0;
#line 110
      level -= len___0;
    }
    while_break: /* CIL Label */ ;
    }
#line 112
    fs->level = (size_t )0;
  }
#line 114
  return (0);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_write0(struct filter_stream *fs , char const   *buf___1 , size_t size ,
                         size_t *pret ) 
{ 
  size_t wrsize ;
  int rc ;

  {
#line 124
  if ((unsigned long )fs->level >= sizeof(fs->buf) - (unsigned long )fs->min_level) {
    {
#line 125
    rc = filter_flush(fs);
    }
#line 126
    if (rc) {
#line 127
      return (rc);
    }
#line 128
    fs->level = (size_t )0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    rc = (*(fs->xcode))(buf___1, size, fs->buf + fs->level, (size_t )(sizeof(fs->buf) - (unsigned long )fs->level),
                        & wrsize);
    }
#line 134
    if (rc == 0) {
      {
#line 135
      rc = filter_flush(fs);
      }
#line 136
      if (rc) {
#line 137
        return (rc);
      }
#line 138
      fs->level = (size_t )0;
    } else {
#line 140
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  fs->level += wrsize;
#line 143
  *pret = (size_t )rc;
#line 144
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct filter_stream *fs ;
  size_t ret ;
  size_t wrs ;
  int rc ;
  size_t rest ;

  {
#line 150
  fs = (struct filter_stream *)data;
#line 151
  ret = (size_t )0;
#line 155
  if (size < fs->min_level) {
#line 155
    goto _L;
  } else
#line 155
  if (fs->inlevel) {
#line 155
    if (fs->inlevel < fs->min_level) {
      _L: /* CIL Label */ 
#line 157
      rest = fs->min_level - fs->inlevel;
#line 158
      if (rest > size) {
#line 159
        rest = size;
      }
      {
#line 160
      memcpy((void */* __restrict  */)(fs->inbuf + fs->inlevel), (void const   */* __restrict  */)buf___1,
             rest);
#line 161
      fs->inlevel += rest;
      }
#line 162
      if (fs->inlevel < fs->min_level) {
#line 163
        *pret = rest;
#line 164
        return (0);
      }
      {
#line 166
      buf___1 += rest;
#line 167
      size -= rest;
#line 169
      rc = filter_write0(fs, (char const   *)fs->inbuf, fs->inlevel, & wrs);
      }
#line 170
      if (rc) {
#line 171
        return (rc);
      }
#line 172
      if (wrs != fs->inlevel) {
#line 174
        return (1);
      }
#line 176
      fs->inlevel = (size_t )0;
#line 177
      ret = rest;
    }
  }
#line 179
  if (size) {
    {
#line 180
    rc = filter_write0(fs, buf___1, size, & wrs);
    }
  } else {
#line 182
    rc = 0;
#line 183
    wrs = (size_t )0;
  }
#line 185
  if (rc == 0) {
#line 186
    ret += wrs;
#line 187
    *pret = ret;
  }
#line 189
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_wr_flush(void *data ) 
{ 
  struct filter_stream *fs ;
  int rc ;
  int nl ;
  size_t wrs ;
  char *__cil_tmp6 ;

  {
#line 196
  fs = (struct filter_stream *)data;
#line 197
  rc = 0;
#line 199
  if (fs->level) {
    {
#line 200
    nl = (int )fs->buf[fs->level - 1U] == 10;
#line 202
    rc = filter_flush(fs);
    }
#line 203
    if (rc == 0) {
#line 204
      if (fs->inlevel) {
        {
#line 206
        filter_write0(fs, (char const   *)fs->inbuf, fs->inlevel, & wrs);
#line 207
        nl = (int )fs->buf[fs->level - 1U] == 10;
#line 208
        rc = filter_flush(fs);
        }
      }
#line 210
      if (! nl) {
        {
#line 211
        rc = dico_stream_write(fs->transport, (void const   *)"\r\n", (size_t )2);
        }
      }
    }
  }
#line 214
  return (rc);
}
}
#line 217 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_stream_destroy(void *data ) 
{ 
  struct filter_stream *fs ;

  {
  {
#line 220
  fs = (struct filter_stream *)data;
#line 221
  free((void *)fs->inbuf);
  }
#line 222
  return (0);
}
}
#line 225 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
dico_stream_t filter_stream_create(dico_stream_t str , size_t min_level , size_t max_line_length ,
                                   int (*xcode)(char const   * , size_t  , char * ,
                                                size_t  , size_t * ) , int mode___0 ) 
{ 
  struct filter_stream *fs ;
  void *tmp ;
  dico_stream_t stream ;
  int rc ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 232
  tmp = malloc((size_t )sizeof(*fs));
#line 232
  fs = (struct filter_stream *)tmp;
  }
#line 236
  if (! fs) {
#line 237
    return ((dico_stream_t )((void *)0));
  }
#line 239
  if (mode___0 == 0) {
#line 239
    tmp___0 = 2;
  } else {
#line 239
    tmp___0 = 1;
  }
  {
#line 239
  rc = dico_stream_create(& stream, tmp___0, (void *)fs);
  }
#line 243
  if (rc) {
    {
#line 244
    free((void *)fs);
    }
#line 245
    return ((dico_stream_t )((void *)0));
  }
#line 248
  if (mode___0 == 0) {
    {
#line 249
    tmp___1 = malloc(min_level);
#line 249
    fs->inbuf = (char *)tmp___1;
    }
#line 250
    if (! fs->inbuf) {
      {
#line 251
      dico_stream_destroy(& stream);
      }
#line 252
      return ((dico_stream_t )((void *)0));
    }
    {
#line 254
    fs->inlevel = (size_t )0;
#line 255
    dico_stream_set_write(stream, & filter_write);
#line 256
    dico_stream_set_flush(stream, & filter_wr_flush);
#line 257
    dico_stream_set_destroy(stream, & filter_stream_destroy);
    }
  } else {
    {
#line 259
    dico_stream_set_read(stream, & filter_read);
    }
  }
#line 262
  fs->transport = str;
#line 263
  fs->level = (size_t )0;
#line 264
  fs->min_level = min_level;
#line 265
  fs->line_length = (size_t )0;
#line 266
  fs->max_line_length = max_line_length;
#line 267
  fs->xcode = xcode;
#line 269
  return (stream);
}
}
#line 272 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
dico_stream_t dico_codec_stream_create(char const   *encoding , int mode___0 , dico_stream_t transport ) 
{ 
  dico_stream_t str ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 276
  str = (dico_stream_t )((void *)0);
#line 277
  tmp___0 = strcmp(encoding, "base64");
  }
#line 277
  if (tmp___0 == 0) {
    {
#line 278
    str = dico_base64_stream_create(transport, mode___0);
    }
  } else {
    {
#line 279
    tmp = strcmp(encoding, "quoted-printable");
    }
#line 279
    if (tmp == 0) {
      {
#line 280
      str = dico_qp_stream_create(transport, mode___0);
      }
    }
  }
#line 281
  return (str);
}
}
#line 107 "../include/dico/stream.h"
dico_stream_t dico_fd_stream_create(int fd , int flags , int noclose ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
static int fd_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _stream *p ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 33
  p = (struct _stream *)data;
#line 34
  tmp = read(p->fd, (void *)buf___1, size);
#line 34
  n = tmp;
  }
#line 35
  if (n == -1) {
    {
#line 36
    tmp___0 = __errno_location();
    }
#line 36
    return (*tmp___0);
  }
#line 37
  *pret = (size_t )n;
#line 38
  return (0);
}
}
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
static int fd_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _stream *p ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 44
  p = (struct _stream *)data;
#line 45
  tmp = write(p->fd, (void const   *)((char *)buf___1), size);
#line 45
  n = tmp;
  }
#line 46
  if (n == -1) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    return (*tmp___0);
  }
#line 48
  *pret = (size_t )n;
#line 49
  return (0);
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
static int fd_close(void *data ) 
{ 
  struct _stream *p ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 55
  p = (struct _stream *)data;
#line 56
  tmp___0 = close(p->fd);
  }
#line 56
  if (tmp___0) {
    {
#line 57
    tmp = __errno_location();
    }
#line 57
    return (*tmp);
  }
#line 58
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
int fd_seek(void *data , off_t off , int whence , off_t *presult ) 
{ 
  struct _stream *p ;
  int *tmp ;

  {
  {
#line 64
  p = (struct _stream *)data;
#line 65
  off = lseek(p->fd, off, whence);
  }
#line 66
  if (off <= 0L) {
    {
#line 67
    tmp = __errno_location();
    }
#line 67
    return (*tmp);
  }
#line 68
  *presult = off;
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
int fd_size(void *data , off_t *psize ) 
{ 
  struct _stream *p ;
  off_t size ;
  __off_t tmp ;
  int *tmp___0 ;

  {
  {
#line 75
  p = (struct _stream *)data;
#line 76
  tmp = lseek(p->fd, (__off_t )0, 2);
#line 76
  size = tmp;
  }
#line 77
  if (size < 0L) {
    {
#line 78
    tmp___0 = __errno_location();
    }
#line 78
    return (*tmp___0);
  }
#line 79
  *psize = size;
#line 80
  return (0);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
int fd_destroy(void *data ) 
{ 


  {
  {
#line 86
  free(data);
  }
#line 87
  return (0);
}
}
#line 90 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
dico_stream_t dico_fd_stream_create(int fd , int flags , int noclose ) 
{ 
  int rc ;
  dico_stream_t str ;
  struct _stream *s ;
  void *tmp ;

  {
  {
#line 95
  tmp = malloc((size_t )sizeof(*s));
#line 95
  s = (struct _stream *)tmp;
  }
#line 97
  if (! s) {
#line 98
    return ((dico_stream_t )((void *)0));
  }
  {
#line 99
  rc = dico_stream_create(& str, flags, (void *)s);
  }
#line 100
  if (rc) {
    {
#line 101
    free((void *)s);
    }
#line 102
    return ((dico_stream_t )((void *)0));
  }
  {
#line 104
  s->fd = fd;
#line 105
  dico_stream_set_seek(str, & fd_seek);
#line 106
  dico_stream_set_size(str, & fd_size);
#line 107
  dico_stream_set_write(str, & fd_write);
#line 108
  dico_stream_set_read(str, & fd_read);
  }
#line 109
  if (! noclose) {
    {
#line 110
    dico_stream_set_close(str, & fd_close);
    }
  }
  {
#line 111
  dico_stream_set_destroy(str, & fd_destroy);
  }
#line 112
  return (str);
}
}
#line 108 "../include/dico/stream.h"
dico_stream_t dico_fd_io_stream_create(int ifd , int ofd ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdiostr.c"
dico_stream_t dico_fd_io_stream_create(int ifd , int ofd ) 
{ 
  dico_stream_t in ;
  dico_stream_t out ;
  dico_stream_t str ;

  {
  {
#line 29
  in = dico_fd_stream_create(ifd, 1, 0);
  }
#line 30
  if (! in) {
#line 31
    return ((dico_stream_t )((void *)0));
  }
  {
#line 32
  out = dico_fd_stream_create(ofd, 2, 0);
  }
#line 33
  if (! out) {
    {
#line 34
    dico_stream_destroy(& in);
    }
#line 35
    return ((dico_stream_t )((void *)0));
  }
  {
#line 38
  str = dico_io_stream(in, out);
  }
#line 39
  if (! str) {
    {
#line 40
    dico_stream_destroy(& in);
#line 41
    dico_stream_destroy(& out);
    }
  }
#line 43
  return (str);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 35 "../include/dico/diag.h"
char const   *dico_program_name  ;
#line 36 "../include/dico/diag.h"
char const   *dico_invocation_name  ;
#line 37
void dico_set_program_name(char *name ) ;
#line 44
void _dico_stderr_log_printer(int lvl , int exitcode , int errcode , char const   *fmt ,
                              va_list ap ) ;
#line 46
void dico_set_log_printer(void (*prt)(int  , int  , int  , char const   * , va_list  ) ) ;
#line 47
void dico_vlog(int lvl , int errcode , char const   *fmt , va_list ap ) ;
#line 50
void ( /* format attribute */  dico_die)(int exitcode , int lvl , int errcode , char const   *fmt 
                                         , ...) ;
#line 52
int dico_str_to_diag_level(char const   *str ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void dico_set_program_name(char *name ) 
{ 
  char const   *progname ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 35
  dico_invocation_name = (char const   *)name;
#line 36
  if (! name) {
#line 37
    progname = (char const   *)name;
  } else {
    {
#line 39
    tmp = strrchr((char const   *)name, '/');
#line 39
    progname = (char const   *)tmp;
    }
#line 40
    if (progname) {
#line 41
      progname ++;
    } else {
#line 43
      progname = (char const   *)name;
    }
    {
#line 45
    tmp___0 = strlen(progname);
    }
#line 45
    if (tmp___0 > 3U) {
      {
#line 45
      tmp___1 = memcmp((void const   *)progname, (void const   *)"lt-", (size_t )3);
      }
#line 45
      if (tmp___1 == 0) {
#line 46
        progname += 3;
      }
    }
  }
#line 49
  dico_program_name = progname;
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
static char *prefix[8]  = 
#line 52
  {      (char *)"Debug",      (char *)"Info",      (char *)"Notice",      (char *)"Warning", 
        (char *)"Error",      (char *)"CRIT",      (char *)"ALERT",      (char *)"EMERG"};
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
int dico_str_to_diag_level(char const   *str ) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 67
  if ((int const   )*(str + 1) == 0) {
    {
#line 67
    tmp = __ctype_b_loc();
    }
#line 67
    if ((int const   )*(*tmp + (int )*str) & 2048) {
#line 68
      return ((int )((int const   )*str - 48));
    }
  }
#line 69
  i___0 = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )i___0 < sizeof(prefix) / sizeof(prefix[0]))) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp___0 = strcasecmp((char const   *)prefix[i___0], str);
    }
#line 70
    if (tmp___0 == 0) {
#line 71
      return (i___0);
    }
#line 69
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (-1);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void _dico_stderr_log_printer(int lvl , int exitcode , int errcode , char const   *fmt ,
                              va_list ap ) 
{ 
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
          dico_program_name, prefix[lvl & 255]);
#line 80
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
  }
#line 81
  if (errcode) {
    {
#line 82
    tmp = strerror(errcode);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
static void (*_log_printer)(int  , int  , int  , char const   * , va_list  )  =    & _dico_stderr_log_printer;
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void dico_set_log_printer(void (*prt)(int  , int  , int  , char const   * , va_list  ) ) 
{ 


  {
#line 91
  _log_printer = prt;
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void dico_vlog(int lvl , int errcode , char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 97
  (*_log_printer)(lvl, 0, errcode, fmt, ap);
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void ( /* format attribute */  dico_log)(int lvl , int errcode , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;

  {
  {
#line 105
  __builtin_va_start(ap, fmt);
#line 106
  (*_log_printer)(lvl, 0, errcode, fmt, ap);
#line 107
  __builtin_va_end(ap);
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void ( /* format attribute */  dico_die)(int exitcode , int lvl , int errcode , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;

  {
  {
#line 115
  __builtin_va_start(ap, fmt);
#line 116
  (*_log_printer)(lvl, exitcode, errcode, fmt, ap);
#line 117
  __builtin_va_end(ap);
#line 118
  exit(exitcode);
  }
}
}
#line 55 "../include/dico/diag.h"
dico_stream_t dico_dbg_stream_create(void) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static char *fmtline(unsigned int num , char *buf___1 , size_t bufsize___0 ) 
{ 
  char *p ;
  unsigned int x ;

  {
#line 39
  p = buf___1 + bufsize___0;
#line 40
  p --;
#line 40
  *p = (char)0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((unsigned long )p > (unsigned long )buf___1)) {
#line 41
      goto while_break;
    }
#line 42
    x = num % 10U;
#line 43
    p --;
#line 43
    *p = (char )(x + 48U);
#line 44
    num /= 10U;
#line 45
    if (num == 0U) {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return (p);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static int dbg_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct dbg_stream *p ;
  char nbuf[128] ;
  char *s ;
  struct timeval tv ;
  size_t tmp ;
  size_t tmp___0 ;
  char *s___0 ;
  char nbuf___0[128] ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 54
  p = (struct dbg_stream *)data;
#line 56
  if (p->ts) {
    {
#line 59
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 60
    dico_stream_write(p->transport, (void const   *)"[", (size_t )1);
#line 61
    s = fmtline((unsigned int )tv.tv_sec, nbuf, (size_t )sizeof(nbuf));
#line 62
    tmp = strlen((char const   *)s);
#line 62
    dico_stream_write(p->transport, (void const   *)s, tmp);
#line 63
    dico_stream_write(p->transport, (void const   *)".", (size_t )1);
#line 64
    s = fmtline((unsigned int )tv.tv_usec, nbuf, (size_t )sizeof(nbuf));
#line 65
    tmp___0 = strlen((char const   *)s);
#line 65
    dico_stream_write(p->transport, (void const   *)s, tmp___0);
#line 66
    dico_stream_write(p->transport, (void const   *)"] ", (size_t )2);
    }
  }
#line 69
  if (p->file) {
    {
#line 73
    tmp___1 = strlen(p->file);
#line 73
    dico_stream_write(p->transport, (void const   *)p->file, tmp___1);
#line 74
    dico_stream_write(p->transport, (void const   *)":", (size_t )1);
#line 75
    s___0 = fmtline(p->line, nbuf___0, (size_t )sizeof(nbuf___0));
#line 76
    tmp___2 = strlen((char const   *)s___0);
#line 76
    dico_stream_write(p->transport, (void const   *)s___0, tmp___2);
#line 77
    dico_stream_write(p->transport, (void const   *)": ", (size_t )2);
    }
  }
  {
#line 79
  dico_stream_write(p->transport, (void const   *)buf___1, size);
  }
#line 81
  if (pret) {
#line 82
    *pret = size;
  }
#line 83
  return (0);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static int dbg_destroy(void *data ) 
{ 
  struct dbg_stream *p ;

  {
  {
#line 89
  p = (struct dbg_stream *)data;
#line 90
  dico_stream_destroy(& p->transport);
#line 91
  free(data);
  }
#line 92
  return (0);
}
}
#line 95 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static int dbg_ioctl(void *data , int code , void *call_data ) 
{ 
  struct dbg_stream *p ;
  int *tmp ;

  {
#line 98
  p = (struct dbg_stream *)data;
  {
#line 100
  if (code == 2) {
#line 100
    goto case_2;
  }
#line 104
  if (code == 3) {
#line 104
    goto case_3;
  }
#line 108
  if (code == 4) {
#line 108
    goto case_4;
  }
#line 112
  goto switch_default;
  case_2: /* CIL Label */ 
#line 101
  p->file = (char const   *)call_data;
#line 102
  goto switch_break;
  case_3: /* CIL Label */ 
#line 105
  p->line = *((unsigned int *)call_data);
#line 106
  goto switch_break;
  case_4: /* CIL Label */ 
#line 109
  p->ts = *((int *)call_data);
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 113
  tmp = __errno_location();
#line 113
  *tmp = 22;
  }
#line 114
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 116
  return (0);
}
}
#line 119 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
dico_stream_t dico_dbg_stream_create(void) 
{ 
  struct dbg_stream *p ;
  void *tmp ;
  dico_stream_t stream ;
  int tmp___0 ;

  {
  {
#line 122
  tmp = malloc((size_t )sizeof(*p));
#line 122
  p = (struct dbg_stream *)tmp;
  }
#line 125
  if (! p) {
#line 126
    return ((dico_stream_t )((void *)0));
  } else {
    {
#line 125
    tmp___0 = dico_stream_create(& stream, 2, (void *)p);
    }
#line 125
    if (tmp___0) {
#line 126
      return ((dico_stream_t )((void *)0));
    }
  }
  {
#line 127
  dico_stream_set_write(stream, & dbg_write);
#line 128
  dico_stream_set_destroy(stream, & dbg_destroy);
#line 129
  dico_stream_set_ioctl(stream, & dbg_ioctl);
#line 130
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
#line 131
  p->transport = dico_log_stream_create(0);
#line 132
  p->file = (char const   *)((void *)0);
#line 133
  p->line = 0U;
  }
#line 134
  return (stream);
}
}
#line 38 "../include/dico/filter.h"
int dico_base64_input(char c ) ;
#line 40
int dico_base64_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) ;
#line 43
int dico_base64_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
char const   b64_table[64]  = 
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
int dico_base64_input(char c ) 
{ 
  int i___0 ;

  {
#line 31
  i___0 = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i___0 < 64)) {
#line 31
      goto while_break;
    }
#line 32
    if ((int const   )b64_table[i___0] == (int const   )c) {
#line 33
      return (i___0);
    }
#line 31
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return (-1);
}
}
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
int dico_base64_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) 
{ 
  int i___0 ;
  int tmp ;
  int pad ;
  size_t consumed ;
  unsigned char data[4] ;
  size_t nbytes ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp18 ;

  {
#line 42
  i___0 = 0;
#line 42
  tmp = 0;
#line 42
  pad = 0;
#line 43
  consumed = (size_t )0;
#line 45
  nbytes = (size_t )0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (consumed < isize) {
#line 47
      if (! (nbytes + 3U < osize)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      if (i___0 < 4) {
#line 48
        if (! (consumed < isize)) {
#line 48
          goto while_break___0;
        }
      } else {
#line 48
        goto while_break___0;
      }
      {
#line 49
      tmp___0 = iptr;
#line 49
      iptr ++;
#line 49
      tmp = dico_base64_input((char )*tmp___0);
#line 50
      consumed ++;
      }
#line 51
      if (tmp != -1) {
#line 52
        tmp___1 = i___0;
#line 52
        i___0 ++;
#line 52
        data[tmp___1] = (unsigned char )tmp;
      } else
#line 53
      if ((int const   )*(iptr - 1) == 61) {
#line 54
        tmp___2 = i___0;
#line 54
        i___0 ++;
#line 54
        data[tmp___2] = (unsigned char)0;
#line 55
        pad ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 60
    if (i___0 == 4) {
#line 61
      tmp___3 = optr;
#line 61
      optr ++;
#line 61
      *tmp___3 = (char )(((int )data[0] << 2) | (((int )data[1] & 48) >> 4));
#line 62
      tmp___4 = optr;
#line 62
      optr ++;
#line 62
      *tmp___4 = (char )((((int )data[1] & 15) << 4) | (((int )data[2] & 60) >> 2));
#line 63
      tmp___5 = optr;
#line 63
      optr ++;
#line 63
      *tmp___5 = (char )((((int )data[2] & 3) << 6) | (int )data[3]);
#line 64
      nbytes += (size_t )(3 - pad);
    } else {
#line 67
      consumed -= (size_t )i___0;
#line 68
      goto while_break;
    }
#line 70
    i___0 = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  *pnbytes = nbytes;
#line 73
  return ((int )consumed);
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
int dico_base64_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) 
{ 
  size_t consumed ;
  int pad ;
  unsigned char const   *ptr ;
  size_t nbytes ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char x ;
  unsigned char y ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 81
  consumed = (size_t )0;
#line 82
  pad = 0;
#line 83
  ptr = (unsigned char const   *)iptr;
#line 84
  nbytes = (size_t )0;
#line 86
  if (isize <= 3U) {
#line 87
    pad = 1;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (consumed + 3U <= isize) {
#line 88
      if (! (nbytes + 4U <= osize)) {
#line 88
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 88
    if (! pad) {
#line 88
      goto while_break;
    }
#line 89
    c1 = (unsigned char)0;
#line 89
    c2 = (unsigned char)0;
#line 89
    x = (unsigned char )'=';
#line 89
    y = (unsigned char )'=';
#line 91
    tmp = optr;
#line 91
    optr ++;
#line 91
    *tmp = (char )b64_table[(int const   )*(ptr + 0) >> 2];
#line 92
    consumed ++;
    {
#line 98
    if (isize - consumed == 1U) {
#line 98
      goto case_1;
    }
#line 102
    if (isize - consumed == 0U) {
#line 102
      goto case_0;
    }
#line 94
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 95
    consumed ++;
#line 96
    y = (unsigned char )b64_table[(int const   )*(ptr + 2) & 63];
#line 97
    c2 = (unsigned char )((int const   )*(ptr + 2) >> 6);
    case_1: /* CIL Label */ 
#line 99
    consumed ++;
#line 100
    x = (unsigned char )b64_table[(((int const   )*(ptr + 1) << 2) + (int const   )c2) & 63];
#line 101
    c1 = (unsigned char )((int const   )*(ptr + 1) >> 4);
    case_0: /* CIL Label */ 
#line 103
    tmp___0 = optr;
#line 103
    optr ++;
#line 103
    *tmp___0 = (char )b64_table[(((int const   )*(ptr + 0) << 4) + (int const   )c1) & 63];
#line 104
    tmp___1 = optr;
#line 104
    optr ++;
#line 104
    *tmp___1 = (char )x;
#line 105
    tmp___2 = optr;
#line 105
    optr ++;
#line 105
    *tmp___2 = (char )y;
    switch_break: /* CIL Label */ ;
    }
#line 108
    ptr += 3;
#line 109
    nbytes += 4U;
#line 110
    pad = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  *pnbytes = nbytes;
#line 114
  return ((int )consumed);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
dico_stream_t dico_base64_stream_create(dico_stream_t str , int mode___0 ) 
{ 
  int (*tmp)(char const   *iptr , size_t isize , char *optr , size_t osize , size_t *pnbytes ) ;
  dico_stream_t tmp___0 ;

  {
#line 120
  if (mode___0 == 0) {
#line 120
    tmp = & dico_base64_encode;
  } else {
#line 120
    tmp = & dico_base64_decode;
  }
  {
#line 120
  tmp___0 = filter_stream_create(str, (size_t )3, (size_t )76, tmp, mode___0);
  }
#line 120
  return (tmp___0);
}
}
#line 33 "../include/dico/assoc.h"
dico_assoc_list_t dico_assoc_dup(dico_assoc_list_t src ) ;
#line 35
int dico_assoc_clear(dico_assoc_list_t assoc ) ;
#line 36
int dico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                   size_t count , int replace ) ;
#line 41
char const   *dico_assoc_find_n(dico_assoc_list_t assoc , char const   *key , size_t n ) ;
#line 44
void dico_assoc_remove_n(dico_assoc_list_t assoc , char const   *key , size_t n ) ;
#line 45
void dico_assoc_remove(dico_assoc_list_t assoc , char const   *key ) ;
#line 47
dico_iterator_t dico_assoc_iterator(dico_assoc_list_t assoc ) ;
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
static int assoc_key_cmp(void const   *item , void *data ) 
{ 
  struct dico_assoc  const  *aptr ;
  struct find_closure *clos ;
  int tmp ;

  {
  {
#line 37
  aptr = (struct dico_assoc  const  *)item;
#line 38
  clos = (struct find_closure *)data;
#line 39
  tmp = strcmp((char const   *)aptr->key, clos->str);
  }
#line 39
  if (tmp == 0) {
#line 39
    (clos->count) --;
#line 39
    if (clos->count == 0U) {
#line 40
      return (0);
    }
  }
#line 41
  return (1);
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
static int assoc_key_cmp_ci(void const   *item , void *data ) 
{ 
  struct dico_assoc  const  *aptr ;
  struct find_closure *clos ;
  int tmp ;

  {
  {
#line 47
  aptr = (struct dico_assoc  const  *)item;
#line 48
  clos = (struct find_closure *)data;
#line 49
  tmp = strcasecmp((char const   *)aptr->key, clos->str);
  }
#line 49
  if (tmp == 0) {
#line 49
    (clos->count) --;
#line 49
    if (clos->count == 0U) {
#line 50
      return (0);
    }
  }
#line 51
  return (1);
}
}
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
static int assoc_free(void *item , void *data ) 
{ 
  struct dico_assoc *a ;

  {
  {
#line 57
  a = (struct dico_assoc *)item;
#line 58
  free((void *)a->value);
#line 59
  free((void *)a);
  }
#line 60
  return (0);
}
}
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
dico_assoc_list_t dico_assoc_create(int flags ) 
{ 
  struct dico_assoc_list *assoc ;
  void *tmp ;
  int ec ;
  int *tmp___0 ;
  int *tmp___1 ;
  int (*tmp___2)(void const   *item , void *data ) ;

  {
  {
#line 66
  tmp = malloc((size_t )sizeof(*assoc));
#line 66
  assoc = (struct dico_assoc_list *)tmp;
  }
#line 67
  if (assoc) {
    {
#line 68
    assoc->flags = flags;
#line 69
    assoc->list = dico_list_create();
    }
#line 70
    if (! assoc->list) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      ec = *tmp___0;
#line 72
      free((void *)assoc);
#line 73
      assoc = (struct dico_assoc_list *)((void *)0);
#line 74
      tmp___1 = __errno_location();
#line 74
      *tmp___1 = ec;
      }
    } else {
#line 76
      if (flags & 1) {
#line 76
        tmp___2 = & assoc_key_cmp_ci;
      } else {
#line 76
        tmp___2 = & assoc_key_cmp;
      }
      {
#line 76
      dico_list_set_comparator(assoc->list, tmp___2);
#line 79
      dico_list_set_free_item(assoc->list, & assoc_free, (void *)0);
      }
    }
  }
#line 82
  return (assoc);
}
}
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
dico_assoc_list_t dico_assoc_dup(dico_assoc_list_t src ) 
{ 
  dico_iterator_t itr ;
  struct dico_assoc *p ;
  dico_assoc_list_t dst ;
  int ec ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int ec___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 93
  dst = dico_assoc_create(src->flags);
  }
#line 94
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 95
    return ((dico_assoc_list_t )((void *)0));
  }
  {
#line 97
  itr = dico_assoc_iterator(src);
  }
#line 98
  if (! itr) {
    {
#line 99
    tmp = __errno_location();
#line 99
    ec = *tmp;
#line 100
    dico_assoc_destroy(& dst);
#line 101
    tmp___0 = __errno_location();
#line 101
    *tmp___0 = ec;
    }
#line 102
    return ((dico_assoc_list_t )((void *)0));
  }
  {
#line 105
  tmp___1 = dico_iterator_first(itr);
#line 105
  p = (struct dico_assoc *)tmp___1;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break;
    }
    {
#line 106
    tmp___5 = dico_assoc_append(dst, p->key, (char const   *)p->value);
    }
#line 106
    if (tmp___5) {
      {
#line 107
      tmp___3 = __errno_location();
#line 107
      ec___0 = *tmp___3;
#line 108
      dico_assoc_destroy(& dst);
#line 109
      tmp___4 = __errno_location();
#line 109
      *tmp___4 = ec___0;
      }
#line 110
      goto while_break;
    }
    {
#line 105
    tmp___2 = dico_iterator_next(itr);
#line 105
    p = (struct dico_assoc *)tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  dico_iterator_destroy(& itr);
  }
#line 114
  return (dst);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
struct dico_assoc *_dico_assoc_find_n(dico_assoc_list_t assoc , char const   *key ,
                                      size_t n ) 
{ 
  struct find_closure clos ;
  void *tmp ;
  void *__cil_tmp6 ;

  {
#line 122
  if (! assoc) {
#line 123
    return ((struct dico_assoc *)((void *)0));
  } else
#line 122
  if (n == 0U) {
#line 123
    return ((struct dico_assoc *)((void *)0));
  }
  {
#line 124
  clos.count = n;
#line 125
  clos.str = key;
#line 126
  tmp = dico_list_locate(assoc->list, (void *)(& clos));
  }
#line 126
  return ((struct dico_assoc *)tmp);
}
}
#line 129 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
char const   *dico_assoc_find_n(dico_assoc_list_t assoc , char const   *key , size_t n ) 
{ 
  struct dico_assoc *kvp ;
  struct dico_assoc *tmp ;
  char *tmp___0 ;

  {
  {
#line 132
  tmp = _dico_assoc_find_n(assoc, key, n);
#line 132
  kvp = tmp;
  }
#line 133
  if (kvp) {
#line 133
    tmp___0 = kvp->value;
  } else {
#line 133
    tmp___0 = (char *)((void *)0);
  }
#line 133
  return ((char const   *)tmp___0);
}
}
#line 136 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
char const   *dico_assoc_find(dico_assoc_list_t assoc , char const   *key ) 
{ 
  char const   *tmp ;

  {
  {
#line 139
  tmp = dico_assoc_find_n(assoc, key, (size_t )1);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
void dico_assoc_remove_n(dico_assoc_list_t assoc , char const   *key , size_t n ) 
{ 
  struct find_closure clos ;
  void *__cil_tmp5 ;

  {
#line 146
  if (n == 0U) {
#line 147
    return;
  }
  {
#line 148
  clos.count = n;
#line 149
  clos.str = key;
#line 150
  dico_list_remove(assoc->list, (void *)(& clos), (void **)((void *)0));
  }
#line 151
  return;
}
}
#line 153 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
void dico_assoc_remove(dico_assoc_list_t assoc , char const   *key ) 
{ 


  {
  {
#line 156
  dico_assoc_remove_n(assoc, key, (size_t )1);
  }
#line 156
  return;
}
}
#line 159 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
int dico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                   size_t count , int replace ) 
{ 
  struct dico_assoc *a ;
  size_t size ;
  char *s ;
  char *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int ec ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 166
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 167
    dico_assoc_remove_n(assoc, key, count);
    }
#line 168
    return (0);
  }
#line 171
  if (! (assoc->flags & 2)) {
    {
#line 172
    a = _dico_assoc_find_n(assoc, key, count);
    }
#line 173
    if (a) {
#line 174
      if (replace) {
        {
#line 175
        tmp = strdup(value);
#line 175
        s = tmp;
        }
#line 176
        if (! s) {
#line 177
          return (1);
        }
        {
#line 178
        free((void *)a->value);
#line 179
        a->value = s;
        }
#line 180
        return (0);
      }
      {
#line 182
      tmp___0 = __errno_location();
#line 182
      *tmp___0 = 17;
      }
#line 183
      return (1);
    }
  }
  {
#line 187
  tmp___1 = strlen(key);
#line 187
  size = (size_t )((sizeof(*a) + (unsigned long )tmp___1) + 1UL);
#line 188
  tmp___2 = malloc(size);
#line 188
  a = (struct dico_assoc *)tmp___2;
  }
#line 189
  if (! a) {
#line 190
    return (1);
  }
  {
#line 191
  a->key = (char const   *)((char *)(a + 1));
#line 192
  strcpy((char */* __restrict  */)((char *)a->key), (char const   */* __restrict  */)key);
#line 193
  a->value = strdup(value);
  }
#line 194
  if (! a->value) {
    {
#line 195
    tmp___3 = __errno_location();
#line 195
    ec = *tmp___3;
#line 196
    free((void *)a);
#line 197
    tmp___4 = __errno_location();
#line 197
    *tmp___4 = ec;
    }
#line 198
    return (1);
  }
  {
#line 200
  tmp___5 = dico_list_append(assoc->list, (void *)a);
  }
#line 200
  return (tmp___5);
}
}
#line 203 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
int dico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) 
{ 
  int tmp ;

  {
  {
#line 206
  tmp = dico_assoc_add(assoc, key, value, (size_t )1, 0);
  }
#line 206
  return (tmp);
}
}
#line 209 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
int dico_assoc_clear(dico_assoc_list_t assoc ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 212
  if (! assoc) {
    {
#line 213
    tmp = __errno_location();
#line 213
    *tmp = 22;
    }
#line 214
    return (1);
  }
  {
#line 216
  tmp___0 = dico_list_clear(assoc->list);
  }
#line 216
  return (tmp___0);
}
}
#line 219 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
void dico_assoc_destroy(dico_assoc_list_t *passoc ) 
{ 
  dico_assoc_list_t assoc ;

  {
#line 222
  if (passoc) {
#line 222
    if (*passoc) {
      {
#line 223
      assoc = *passoc;
#line 224
      dico_list_destroy(& assoc->list);
#line 225
      free((void *)assoc);
      }
    }
  }
#line 227
  return;
}
}
#line 229 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
dico_iterator_t dico_assoc_iterator(dico_assoc_list_t assoc ) 
{ 
  dico_iterator_t tmp ;

  {
#line 232
  if (! assoc) {
#line 233
    return ((dico_iterator_t )((void *)0));
  }
  {
#line 234
  tmp = dico_list_iterator(assoc->list);
  }
#line 234
  return (tmp);
}
}
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 37 "../include/dico/argcv.h"
enum dico_argcv_quoting_style dico_argcv_quoting_style  ;
#line 39
int dico_argcv_get(char const   *command , char const   *delim , char const   *cmnt ,
                   int *argc , char ***argv ) ;
#line 42
int dico_argcv_get_n(char const   *command , int len___0 , char const   *delim , char const   *cmnt ,
                     int *pargc , char ***pargv ) ;
#line 45
int dico_argcv_get_np(char const   *command , int len___0 , char const   *delim ,
                      char const   *cmnt , int flags , int *pargc , char ***pargv ,
                      char **endp ) ;
#line 50
int dico_argcv_string(int argc , char const   **argv , char **pstring ) ;
#line 51
void dico_argcv_free(int argc , char **argv ) ;
#line 52
void dico_argv_free(char **argv ) ;
#line 54
int dico_argcv_unquote_char(int c ) ;
#line 55
int dico_argcv_quote_char(int c ) ;
#line 56
size_t dico_argcv_quoted_length(char const   *str , int *quote___0 ) ;
#line 57
void dico_argcv_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 58
void dico_argcv_quote_copy(char *dst , char const   *src ) ;
#line 59
void dico_argcv_remove(int *pargc , char ***pargv , int (*sel)(char const   * , void * ) ,
                       void *data ) ;
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static void init_argcv_info(struct argcv_info *ap , int flags , int len___0 , char const   *command ,
                            char const   *delim , char const   *comment ) 
{ 


  {
  {
#line 78
  memset((void *)ap, 0, (size_t )sizeof(*ap));
#line 79
  ap->len = len___0;
#line 80
  ap->command = command;
#line 81
  ap->delim = delim;
#line 82
  ap->comment = comment;
#line 83
  ap->flags = flags;
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static int argcv_scan(struct argcv_info *ap ) 
{ 
  int i___0 ;
  int len___0 ;
  char const   *command ;
  char const   *delim ;
  char const   *comment ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 89
  i___0 = 0;
#line 90
  len___0 = ap->len;
#line 91
  command = ap->command;
#line 92
  delim = ap->delim;
#line 93
  comment = ap->comment;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    i___0 = ap->save;
#line 99
    if (i___0 >= len___0) {
#line 100
      return (i___0 + 1);
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (i___0 < len___0) {
#line 103
        if (! ((int const   )*(command + i___0) == 32)) {
#line 103
          if (! ((int const   )*(command + i___0) == 9)) {
#line 103
            if (! ((int const   )*(command + i___0) == 10)) {
#line 103
              goto while_break___0;
            }
          }
        }
      } else {
#line 103
        goto while_break___0;
      }
#line 104
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 105
    ap->start = i___0;
#line 107
    tmp___1 = strchr(delim, (int )*(command + i___0));
    }
#line 107
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 137
      if (! (ap->flags & 1)) {
        {
#line 139
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 139
          if (i___0 < len___0) {
            {
#line 139
            tmp___0 = strchr(delim, (int )*(command + i___0));
            }
#line 139
            if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 139
              goto while_break___1;
            }
          } else {
#line 139
            goto while_break___1;
          }
#line 140
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 141
        ap->save = i___0;
#line 142
        goto __Cont;
      }
    } else {
      {
#line 109
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 109
        if (! (i___0 < len___0)) {
#line 109
          goto while_break___2;
        }
#line 111
        if ((int const   )*(command + i___0) == 92) {
#line 113
          i___0 ++;
#line 113
          if (i___0 == len___0) {
#line 114
            goto while_break___2;
          }
#line 115
          i___0 ++;
#line 116
          goto while_continue___2;
        }
#line 119
        if ((int const   )*(command + i___0) == 39) {
#line 119
          goto _L;
        } else
#line 119
        if ((int const   )*(command + i___0) == 34) {
          _L: /* CIL Label */ 
#line 122
          j = i___0 + 1;
          {
#line 122
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 122
            if (j < len___0) {
#line 122
              if (! ((int const   )*(command + j) != (int const   )*(command + i___0))) {
#line 122
                goto while_break___3;
              }
            } else {
#line 122
              goto while_break___3;
            }
#line 123
            if ((int const   )*(command + j) == 92) {
#line 124
              j ++;
            }
#line 122
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 125
          if (j < len___0) {
#line 126
            i___0 = j + 1;
          } else {
#line 128
            i___0 ++;
          }
        } else
#line 130
        if ((int const   )*(command + i___0) == 32) {
#line 131
          goto while_break___2;
        } else
#line 130
        if ((int const   )*(command + i___0) == 9) {
#line 131
          goto while_break___2;
        } else
#line 130
        if ((int const   )*(command + i___0) == 10) {
#line 131
          goto while_break___2;
        } else {
          {
#line 130
          tmp = strchr(delim, (int )*(command + i___0));
          }
#line 130
          if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 131
            goto while_break___2;
          } else {
#line 133
            i___0 ++;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 135
      i___0 --;
    }
#line 146
    ap->end = i___0;
#line 147
    tmp___2 = i___0 + 1;
#line 147
    ap->finish_pos = tmp___2;
#line 147
    ap->save = tmp___2;
#line 151
    if (ap->save <= len___0) {
      {
#line 153
      tmp___3 = strchr(comment, (int )*(command + ap->start));
      }
#line 153
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 155
        ap->finish_pos = ap->start;
#line 156
        i___0 = ap->save;
        {
#line 157
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 157
          if (i___0 < len___0) {
#line 157
            if (! ((int const   )*(command + i___0) != 10)) {
#line 157
              goto while_break___4;
            }
          } else {
#line 157
            goto while_break___4;
          }
#line 158
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 160
        ap->save = i___0;
#line 161
        goto __Cont;
      }
    }
#line 164
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (ap->save);
}
}
#line 169 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static char quote_transtab[15]  = 
#line 169
  {      (char )'\\',      (char )'\\',      (char )'a',      (char )'\a', 
        (char )'b',      (char )'\b',      (char )'f',      (char )'\f', 
        (char )'n',      (char )'\n',      (char )'r',      (char )'\r', 
        (char )'t',      (char )'\t',      (char )'\000'};
#line 171 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 176
  p = quote_transtab;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! *p) {
#line 176
      goto while_break;
    }
#line 178
    if ((int )*p == c) {
#line 179
      return ((int )*(p + 1));
    }
#line 176
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (c);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_quote_char(int c ) 
{ 
  char *p ;

  {
#line 189
  p = (quote_transtab + sizeof(quote_transtab)) - 2;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((unsigned long )p > (unsigned long )(quote_transtab))) {
#line 189
      goto while_break;
    }
#line 192
    if ((int )*p == c) {
#line 193
      return ((int )*(p + -1));
    }
#line 189
    p -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (-1);
}
}
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static int xtonum(int *pval , char const   *src , int base , int cnt ) 
{ 
  int i___0 ;
  int val ;
  int n ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 206
  i___0 = 0;
#line 206
  val = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i___0 < cnt)) {
#line 206
      goto while_break;
    }
#line 208
    n = (int )*((unsigned char *)src);
#line 209
    if (n > 127) {
#line 210
      goto while_break;
    } else {
      {
#line 209
      tmp___4 = __ctype_b_loc();
      }
#line 209
      if ((int const   )*(*tmp___4 + n) & 2048) {
#line 209
        n -= 48;
      } else {
        {
#line 209
        tmp___3 = __ctype_b_loc();
        }
#line 209
        if ((int const   )*(*tmp___3 + n) & 4096) {
          {
#line 209
          tmp___1 = toupper(n);
#line 209
          tmp___2 = (tmp___1 - 65) + 10;
          }
        } else {
#line 209
          tmp___2 = 255;
        }
#line 209
        n = tmp___2;
      }
#line 209
      if (n >= base) {
#line 210
        goto while_break;
      }
    }
#line 211
    val = val * base + n;
#line 206
    i___0 ++;
#line 206
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  *pval = val;
#line 214
  return (i___0);
}
}
#line 217 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
size_t dico_argcv_quoted_length(char const   *str , int *quote___0 ) 
{ 
  size_t len___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 220
  len___0 = (size_t )0;
#line 222
  if ((int const   )*str == 0) {
#line 223
    *quote___0 = 1;
#line 224
    return ((size_t )0);
  }
#line 226
  *quote___0 = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! *str) {
#line 227
      goto while_break;
    }
#line 229
    if ((int const   )*str == 32) {
#line 231
      len___0 ++;
#line 232
      *quote___0 = 1;
    } else
#line 234
    if ((int const   )*str == 34) {
#line 236
      len___0 += 2U;
#line 237
      *quote___0 = 1;
    } else
#line 239
    if ((int const   )*str != 9) {
#line 239
      if ((int const   )*str != 92) {
        {
#line 239
        tmp___0 = __ctype_b_loc();
        }
#line 239
        if ((int const   )*(*tmp___0 + (int )*str) & 16384) {
#line 240
          len___0 ++;
        } else {
#line 239
          goto _L___0;
        }
      } else {
#line 239
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 245
      if ((unsigned int )dico_argcv_quoting_style == 0U) {
#line 245
        goto case_0;
      }
#line 252
      if ((unsigned int )dico_argcv_quoting_style == 1U) {
#line 252
        goto case_1;
      }
#line 243
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 246
      tmp = dico_argcv_quote_char((int )*str);
      }
#line 246
      if (tmp != -1) {
#line 247
        len___0 += 2U;
      } else {
#line 249
        len___0 += 4U;
      }
#line 250
      goto switch_break;
      case_1: /* CIL Label */ 
#line 253
      len___0 += 3U;
#line 254
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 227
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return (len___0);
}
}
#line 261 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i___0 ;
  int c ;
  int expect_delim ;
  char const   *p ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int off ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int off___0 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 264
  i___0 = 0;
#line 266
  expect_delim = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((size_t )i___0 < n)) {
#line 268
      goto while_break;
    }
    {
#line 273
    if ((int const   )*(src + i___0) == 34) {
#line 273
      goto case_34;
    }
#line 273
    if ((int const   )*(src + i___0) == 39) {
#line 273
      goto case_34;
    }
#line 292
    if ((int const   )*(src + i___0) == 92) {
#line 292
      goto case_92;
    }
#line 342
    goto switch_default;
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 274
    if (! expect_delim) {
#line 278
      p = (src + i___0) + 1;
      {
#line 278
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 278
        if (*p) {
#line 278
          if (! ((int const   )*p != (int const   )*(src + i___0))) {
#line 278
            goto while_break___0;
          }
        } else {
#line 278
          goto while_break___0;
        }
#line 279
        if ((int const   )*p == 92) {
#line 280
          p ++;
        }
#line 278
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 281
      if (*p) {
#line 282
        tmp = i___0;
#line 282
        i___0 ++;
#line 282
        expect_delim = (int )*(src + tmp);
      } else {
#line 284
        tmp___0 = dst;
#line 284
        dst ++;
#line 284
        tmp___1 = i___0;
#line 284
        i___0 ++;
#line 284
        *tmp___0 = (char )*(src + tmp___1);
      }
    } else
#line 286
    if (expect_delim == (int )*(src + i___0)) {
#line 287
      i___0 ++;
    } else {
#line 289
      tmp___2 = dst;
#line 289
      dst ++;
#line 289
      tmp___3 = i___0;
#line 289
      i___0 ++;
#line 289
      *tmp___2 = (char )*(src + tmp___3);
    }
#line 290
    goto switch_break;
    case_92: /* CIL Label */ 
#line 293
    i___0 ++;
#line 294
    if ((int const   )*(src + i___0) == 120) {
#line 294
      goto _L___0;
    } else
#line 294
    if ((int const   )*(src + i___0) == 88) {
      _L___0: /* CIL Label */ 
#line 296
      if (n - (size_t )i___0 < 2U) {
#line 298
        tmp___4 = dst;
#line 298
        dst ++;
#line 298
        *tmp___4 = (char )'\\';
#line 299
        tmp___5 = dst;
#line 299
        dst ++;
#line 299
        tmp___6 = i___0;
#line 299
        i___0 ++;
#line 299
        *tmp___5 = (char )*(src + tmp___6);
      } else {
        {
#line 303
        tmp___7 = xtonum(& c, (src + i___0) + 1, 16, 2);
#line 303
        off = tmp___7;
        }
#line 304
        if (off == 0) {
#line 306
          tmp___8 = dst;
#line 306
          dst ++;
#line 306
          *tmp___8 = (char )'\\';
#line 307
          tmp___9 = dst;
#line 307
          dst ++;
#line 307
          tmp___10 = i___0;
#line 307
          i___0 ++;
#line 307
          *tmp___9 = (char )*(src + tmp___10);
        } else {
#line 311
          tmp___11 = dst;
#line 311
          dst ++;
#line 311
          *tmp___11 = (char )c;
#line 312
          i___0 += off + 1;
        }
      }
    } else
#line 316
    if ((int )((unsigned char )*(src + i___0)) < 128) {
      {
#line 316
      tmp___23 = __ctype_b_loc();
      }
#line 316
      if ((int const   )*(*tmp___23 + (int )*(src + i___0)) & 2048) {
#line 318
        if (n - (size_t )i___0 < 1U) {
#line 320
          tmp___12 = dst;
#line 320
          dst ++;
#line 320
          *tmp___12 = (char )'\\';
#line 321
          tmp___13 = dst;
#line 321
          dst ++;
#line 321
          tmp___14 = i___0;
#line 321
          i___0 ++;
#line 321
          *tmp___13 = (char )*(src + tmp___14);
        } else {
          {
#line 325
          tmp___15 = xtonum(& c, src + i___0, 8, 3);
#line 325
          off___0 = tmp___15;
          }
#line 326
          if (off___0 == 0) {
#line 328
            tmp___16 = dst;
#line 328
            dst ++;
#line 328
            *tmp___16 = (char )'\\';
#line 329
            tmp___17 = dst;
#line 329
            dst ++;
#line 329
            tmp___18 = i___0;
#line 329
            i___0 ++;
#line 329
            *tmp___17 = (char )*(src + tmp___18);
          } else {
#line 333
            tmp___19 = dst;
#line 333
            dst ++;
#line 333
            *tmp___19 = (char )c;
#line 334
            i___0 += off___0;
          }
        }
      } else {
#line 316
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 339
      tmp___20 = dst;
#line 339
      dst ++;
#line 339
      tmp___21 = i___0;
#line 339
      i___0 ++;
#line 339
      tmp___22 = dico_argcv_unquote_char((int )*(src + tmp___21));
#line 339
      *tmp___20 = (char )tmp___22;
      }
    }
#line 340
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 343
    tmp___24 = dst;
#line 343
    dst ++;
#line 343
    tmp___25 = i___0;
#line 343
    i___0 ++;
#line 343
    *tmp___24 = (char )*(src + tmp___25);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *dst = (char)0;
#line 347
  return;
}
}
#line 349 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_quote_copy(char *dst , char const   *src ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2[4] ;
  int c ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! *src) {
#line 352
      goto while_break;
    }
#line 354
    if ((int const   )*src == 34) {
#line 356
      tmp = dst;
#line 356
      dst ++;
#line 356
      *tmp = (char )'\\';
#line 357
      tmp___0 = dst;
#line 357
      dst ++;
#line 357
      *tmp___0 = (char )*src;
    } else
#line 359
    if ((int const   )*src != 9) {
#line 359
      if ((int const   )*src != 92) {
        {
#line 359
        tmp___6 = __ctype_b_loc();
        }
#line 359
        if ((int const   )*(*tmp___6 + (int )*src) & 16384) {
#line 360
          tmp___1 = dst;
#line 360
          dst ++;
#line 360
          *tmp___1 = (char )*src;
        } else {
#line 359
          goto _L___0;
        }
      } else {
#line 359
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 367
      if ((unsigned int )dico_argcv_quoting_style == 0U) {
#line 367
        goto case_0;
      }
#line 382
      if ((unsigned int )dico_argcv_quoting_style == 1U) {
#line 382
        goto case_1;
      }
#line 365
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 369
      tmp___3 = dico_argcv_quote_char((int )*src);
#line 369
      c = tmp___3;
#line 370
      tmp___4 = dst;
#line 370
      dst ++;
#line 370
      *tmp___4 = (char )'\\';
      }
#line 371
      if (c != -1) {
#line 372
        tmp___5 = dst;
#line 372
        dst ++;
#line 372
        *tmp___5 = (char )c;
      } else {
        {
#line 375
        snprintf((char */* __restrict  */)(tmp___2), (size_t )sizeof(tmp___2), (char const   */* __restrict  */)"%03o",
                 (int )*((unsigned char *)src));
#line 376
        memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
               (size_t )3);
#line 377
        dst += 3;
        }
      }
#line 379
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 383
      snprintf((char */* __restrict  */)(tmp___2), (size_t )sizeof(tmp___2), (char const   */* __restrict  */)"%%%02X",
               (int )*((unsigned char *)src));
#line 384
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
             (size_t )3);
#line 385
      dst += 3;
      }
#line 386
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 352
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 392 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_get_np(char const   *command , int len___0 , char const   *delim ,
                      char const   *cmnt , int flags , int *pargc , char ***pargv ,
                      char **endp ) 
{ 
  int i___0 ;
  struct argcv_info info ;
  int argc ;
  char **argv ;
  int tmp ;
  void *tmp___0 ;
  int n ;
  int unquote ;
  void *tmp___1 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 398
  i___0 = 0;
#line 403
  if (! delim) {
#line 404
    delim = "";
  }
#line 405
  if (! cmnt) {
#line 406
    cmnt = "";
  }
  {
#line 408
  init_argcv_info(& info, flags, len___0, command, delim, cmnt);
#line 411
  argc = 0;
  }
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    tmp = argcv_scan(& info);
    }
#line 412
    if (! (tmp <= len___0)) {
#line 412
      goto while_break;
    }
#line 413
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  tmp___0 = calloc((size_t )(argc + 1), (size_t )sizeof(char *));
#line 415
  argv = (char **)tmp___0;
  }
#line 416
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 417
    return (12);
  }
#line 419
  i___0 = 0;
#line 420
  info.save = 0;
#line 421
  i___0 = 0;
  {
#line 421
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 421
    if (! (i___0 < argc)) {
#line 421
      goto while_break___0;
    }
    {
#line 426
    argcv_scan(& info);
    }
#line 428
    if ((int const   )*(command + info.start) == 34) {
#line 428
      goto _L;
    } else
#line 428
    if ((int const   )*(command + info.end) == 39) {
      _L: /* CIL Label */ 
#line 428
      if ((int const   )*(command + info.end) == (int const   )*(command + info.start)) {
#line 431
        if (info.start < info.end) {
#line 433
          (info.start) ++;
#line 434
          (info.end) --;
        }
#line 436
        unquote = 0;
      } else {
#line 439
        unquote = 1;
      }
    } else {
#line 439
      unquote = 1;
    }
    {
#line 441
    n = (info.end - info.start) + 1;
#line 442
    tmp___1 = calloc((size_t )(n + 1), (size_t )sizeof(char ));
#line 442
    *(argv + i___0) = (char *)tmp___1;
    }
#line 443
    if ((unsigned long )*(argv + i___0) == (unsigned long )((void *)0)) {
      {
#line 445
      dico_argcv_free(i___0, argv);
      }
#line 446
      return (12);
    }
#line 448
    if (unquote) {
      {
#line 449
      dico_argcv_unquote_copy(*(argv + i___0), command + info.start, (size_t )n);
      }
    } else {
      {
#line 451
      memcpy((void */* __restrict  */)*(argv + i___0), (void const   */* __restrict  */)(command + info.start),
             (size_t )n);
      }
    }
#line 452
    *(*(argv + i___0) + n) = (char)0;
#line 421
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 454
  *(argv + i___0) = (char *)((void *)0);
#line 456
  *pargc = argc;
#line 457
  *pargv = argv;
#line 458
  if (endp) {
#line 459
    *endp = (char *)(command + info.finish_pos);
  }
#line 460
  return (0);
}
}
#line 463 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_get_n(char const   *command , int len___0 , char const   *delim , char const   *cmnt ,
                     int *pargc , char ***pargv ) 
{ 
  int tmp ;

  {
  {
#line 467
  tmp = dico_argcv_get_np(command, len___0, delim, cmnt, 1, pargc, pargv, (char **)((void *)0));
  }
#line 467
  return (tmp);
}
}
#line 471 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_get(char const   *command , char const   *delim , char const   *cmnt ,
                   int *argc , char ***argv ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 475
  tmp = strlen(command);
#line 475
  tmp___0 = dico_argcv_get_n(command, (int )tmp, delim, cmnt, argc, argv);
  }
#line 475
  return (tmp___0);
}
}
#line 484 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_free(int argc , char **argv ) 
{ 


  {
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    argc --;
#line 487
    if (! (argc >= 0)) {
#line 487
      goto while_break;
    }
#line 488
    if (*(argv + argc)) {
      {
#line 489
      free((void *)*(argv + argc));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 490
  free((void *)argv);
  }
#line 491
  return;
}
}
#line 493 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argv_free(char **argv ) 
{ 
  int i___0 ;

  {
#line 498
  i___0 = 0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! *(argv + i___0)) {
#line 498
      goto while_break;
    }
    {
#line 499
    free((void *)*(argv + i___0));
#line 498
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  free((void *)argv);
  }
#line 501
  return;
}
}
#line 505 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_string(int argc , char const   **argv , char **pstring ) 
{ 
  size_t i___0 ;
  size_t j ;
  size_t len___0 ;
  char *buffer ;
  void *tmp ;
  int quote___0 ;
  int toklen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 512
  if ((unsigned long )pstring == (unsigned long )((void *)0)) {
#line 513
    return (22);
  }
  {
#line 515
  tmp = malloc((size_t )1);
#line 515
  buffer = (char *)tmp;
  }
#line 516
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 517
    return (12);
  }
#line 518
  *buffer = (char )'\000';
#line 520
  j = (size_t )0;
#line 520
  i___0 = j;
#line 520
  len___0 = i___0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i___0 < (size_t )argc)) {
#line 520
      goto while_break;
    }
    {
#line 525
    tmp___0 = dico_argcv_quoted_length(*(argv + i___0), & quote___0);
#line 525
    toklen = (int )tmp___0;
#line 527
    len___0 += (size_t )(toklen + 2);
    }
#line 528
    if (quote___0) {
#line 529
      len___0 += 2U;
    }
    {
#line 531
    tmp___1 = realloc((void *)buffer, len___0);
#line 531
    buffer = (char *)tmp___1;
    }
#line 532
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 533
      return (12);
    }
#line 535
    if (i___0 != 0U) {
#line 536
      tmp___2 = j;
#line 536
      j ++;
#line 536
      *(buffer + tmp___2) = (char )' ';
    }
#line 537
    if (quote___0) {
#line 538
      tmp___3 = j;
#line 538
      j ++;
#line 538
      *(buffer + tmp___3) = (char )'\"';
    }
    {
#line 539
    dico_argcv_quote_copy(buffer + j, *(argv + i___0));
#line 540
    j += (size_t )toklen;
    }
#line 541
    if (quote___0) {
#line 542
      tmp___4 = j;
#line 542
      j ++;
#line 542
      *(buffer + tmp___4) = (char )'\"';
    }
#line 520
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 545
    if (j > 0U) {
      {
#line 545
      tmp___5 = __ctype_b_loc();
      }
#line 545
      if (! ((int const   )*(*tmp___5 + (int )*(buffer + (j - 1U))) & 8192)) {
#line 545
        goto while_break___0;
      }
    } else {
#line 545
      goto while_break___0;
    }
#line 545
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 547
  *(buffer + j) = (char)0;
#line 548
  if (pstring) {
#line 549
    *pstring = buffer;
  }
#line 550
  return (0);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_remove(int *pargc , char ***pargv , int (*sel)(char const   * , void * ) ,
                       void *data ) 
{ 
  int i___0 ;
  int j ;
  int argc ;
  char **argv ;
  int cnt ;
  int tmp ;

  {
#line 558
  argc = *pargc;
#line 559
  argv = *pargv;
#line 560
  cnt = 0;
#line 562
  j = 0;
#line 562
  i___0 = j;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (i___0 < argc)) {
#line 562
      goto while_break;
    }
    {
#line 564
    tmp = (*sel)((char const   *)*(argv + i___0), data);
    }
#line 564
    if (tmp) {
      {
#line 566
      free((void *)*(argv + i___0));
#line 567
      cnt ++;
      }
    } else {
#line 571
      if (i___0 != j) {
#line 572
        *(argv + j) = *(argv + i___0);
      }
#line 573
      j ++;
    }
#line 562
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  if (i___0 != j) {
#line 577
    *(argv + j) = (char *)((void *)0);
  }
#line 578
  argc -= cnt;
#line 580
  *pargc = argc;
#line 581
  *pargv = argv;
#line 582
  return;
}
}
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 25
  dico_die(1, 5, 0, "Not enough memory");
  }
#line 26
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 58
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 59
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 60
void *xrealloc(void *p , size_t n ) ;
#line 61
void *x2realloc(void *p , size_t *pn ) ;
#line 62
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 63
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 196 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 199
  n = *pn;
#line 201
  if (! p) {
#line 203
    if (! n) {
#line 211
      n = 64U / s;
#line 212
      n += (size_t )(! n);
    }
  } else {
#line 221
    if (2863311530U / s <= n) {
      {
#line 222
      xalloc_die();
      }
    }
#line 223
    n += (n + 1U) / 2U;
  }
  {
#line 226
  *pn = n;
#line 227
  tmp = xrealloc(p, n * s);
  }
#line 227
  return (tmp);
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 47
  tmp = malloc(n);
#line 47
  p = tmp;
  }
#line 48
  if (! p) {
#line 48
    if (n != 0U) {
      {
#line 49
      xalloc_die();
      }
    }
  }
#line 50
  return (p);
}
}
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 59
  p = realloc(p, n);
  }
#line 60
  if (! p) {
#line 60
    if (n != 0U) {
      {
#line 61
      xalloc_die();
      }
    }
  }
#line 62
  return (p);
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 74
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 74
  return (tmp);
}
}
#line 81
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 81 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 84
  tmp = xmalloc(s);
#line 84
  tmp___0 = memset(tmp, 0, s);
  }
#line 84
  return (tmp___0);
}
}
#line 90
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 90 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 98
  p = calloc(n, s);
  }
#line 98
  if (! p) {
    {
#line 100
    xalloc_die();
    }
  }
#line 101
  return (p);
}
}
#line 108
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 108 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 111
  tmp = xmalloc(s);
#line 111
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 111
  return (tmp___0);
}
}
#line 116
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 116 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 119
  tmp = strlen(string);
#line 119
  tmp___0 = xmemdup((void const   *)string, tmp + 1U);
  }
#line 119
  return ((char *)tmp___0);
}
}
#line 3 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgethostname.h"
char *xgethostname(void) ;
#line 895 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgethostname.c"
char *xgethostname(void) 
{ 
  char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 48
  hostname = (char *)((void *)0);
#line 49
  size = (size_t )34;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 58
    tmp = x2realloc((void *)hostname, & size);
#line 58
    hostname = (char *)tmp;
#line 59
    size_1 = size - 1U;
#line 60
    *(hostname + (size_1 - 1U)) = (char )'\000';
#line 61
    tmp___0 = __errno_location();
#line 61
    *tmp___0 = 0;
#line 63
    tmp___7 = gethostname(hostname, size_1);
    }
#line 63
    if (tmp___7 == 0) {
#line 65
      if (! *(hostname + (size_1 - 1U))) {
#line 66
        goto while_break;
      }
    } else {
      {
#line 68
      tmp___3 = __errno_location();
      }
#line 68
      if (*tmp___3 != 0) {
        {
#line 68
        tmp___4 = __errno_location();
        }
#line 68
        if (*tmp___4 != 36) {
          {
#line 68
          tmp___5 = __errno_location();
          }
#line 68
          if (*tmp___5 != 22) {
            {
#line 68
            tmp___6 = __errno_location();
            }
#line 68
            if (*tmp___6 != 12) {
              {
#line 72
              tmp___1 = __errno_location();
#line 72
              saved_errno = *tmp___1;
#line 73
              free((void *)hostname);
#line 74
              tmp___2 = __errno_location();
#line 74
              *tmp___2 = saved_errno;
              }
#line 75
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (hostname);
}
}
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgetdomainname.h"
char *xgetdomainname(void) ;
#line 913 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) getdomainname)(char *__name ,
                                                                                          size_t __len ) ;
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgetdomainname.c"
char *xgetdomainname(void) 
{ 
  char *domainname ;
  size_t size ;
  void *tmp ;
  int k ;
  int err ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 55
  size = (size_t )34;
#line 56
  tmp = xmalloc(size);
#line 56
  domainname = (char *)tmp;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    k = (int )(size - 1U);
#line 62
    tmp___0 = __errno_location();
#line 62
    *tmp___0 = 0;
#line 63
    *(domainname + k) = (char )'\000';
#line 64
    err = getdomainname(domainname, size);
    }
#line 65
    if (err >= 0) {
#line 65
      if ((int )*(domainname + k) == 0) {
#line 66
        goto while_break;
      } else {
#line 65
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 67
    if (err < 0) {
      {
#line 67
      tmp___3 = __errno_location();
      }
#line 67
      if (*tmp___3 != 22) {
        {
#line 69
        tmp___1 = __errno_location();
#line 69
        saved_errno = *tmp___1;
#line 70
        free((void *)domainname);
#line 71
        tmp___2 = __errno_location();
#line 71
        *tmp___2 = saved_errno;
        }
#line 72
        return ((char *)((void *)0));
      }
    }
    {
#line 74
    size *= 2U;
#line 75
    tmp___4 = xrealloc((void *)domainname, size);
#line 75
    domainname = (char *)tmp___4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (domainname);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 60
  sum = size1 + size2;
#line 61
  if (sum >= size1) {
#line 61
    tmp = sum;
  } else {
#line 61
    tmp = 4294967295U;
  }
#line 61
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 81
  tmp = xsum(size1, size2);
#line 81
  tmp___0 = xsum((size_t )tmp, size3);
#line 81
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 81
  return (tmp___1);
}
}
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 93
  if (size1 >= size2) {
#line 93
    tmp = size1;
  } else {
#line 93
    tmp = size2;
  }
#line 93
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 1479 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___1 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i___0 ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___32 ;
  size_t __attribute__((__pure__))  tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  size_t __attribute__((__pure__))  tmp___37 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int arg ;
  unsigned int arg___0 ;
  int arg___1 ;
  unsigned int arg___2 ;
  int arg___3 ;
  unsigned int arg___4 ;
  long arg___5 ;
  unsigned long arg___6 ;
  long long arg___7 ;
  unsigned long long arg___8 ;
  double arg___9 ;
  long double arg___10 ;
  int arg___11 ;
  wint_t arg___12 ;
  char const   *arg___13 ;
  wchar_t const   *arg___14 ;
  void *arg___15 ;
  size_t bigger_need ;
  size_t tmp___38 ;
  size_t __attribute__((__pure__))  tmp___39 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  int *tmp___43 ;
  size_t n___2 ;
  size_t tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t __attribute__((__pure__))  tmp___46 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___50 ;
  size_t __attribute__((__pure__))  tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  size_t __attribute__((__pure__))  tmp___55 ;
  char *memory___5 ;
  void *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;

  {
  {
#line 1486
  tmp = printf_parse(format, & d, & a);
  }
#line 1486
  if (tmp < 0) {
#line 1488
    return ((char *)((void *)0));
  }
  {
#line 1495
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1495
  if (tmp___1 < 0) {
    {
#line 1497
    free((void *)d.dir);
    }
#line 1497
    if (a.arg) {
      {
#line 1497
      free((void *)a.arg);
      }
    }
    {
#line 1498
    tmp___0 = __errno_location();
#line 1498
    *tmp___0 = 22;
    }
#line 1499
    return ((char *)((void *)0));
  }
  {
#line 1516
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1516
  buf_neededlength = (size_t )tmp___2;
  }
#line 1519
  if ((unsigned long )buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1521
    tmp___3 = __builtin_alloca((unsigned long )buf_neededlength * sizeof(char ));
#line 1521
    buf___1 = (char *)tmp___3;
#line 1522
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1527
    if ((unsigned long )buf_neededlength <= 4294967295UL / sizeof(char )) {
#line 1527
      tmp___4 = (unsigned long )buf_neededlength * sizeof(char );
    } else {
#line 1527
      tmp___4 = 4294967295UL;
    }
#line 1527
    buf_memsize = (size_t )tmp___4;
#line 1528
    if (buf_memsize == 4294967295U) {
#line 1529
      goto out_of_memory_1;
    }
    {
#line 1530
    tmp___5 = malloc(buf_memsize);
#line 1530
    buf___1 = (char *)tmp___5;
    }
#line 1531
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 1532
      goto out_of_memory_1;
    }
#line 1533
    buf_malloced = buf___1;
  }
#line 1536
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1538
    result = resultbuf;
#line 1539
    allocated = *lengthp;
  } else {
#line 1543
    result = (char *)((void *)0);
#line 1544
    allocated = (size_t )0;
  }
#line 1546
  length = (size_t )0;
#line 1576
  cp = format;
#line 1576
  i___0 = (size_t )0;
#line 1576
  dp = d.dir + 0;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1578
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1580
      n = (size_t )(dp->dir_start - cp);
#line 1581
      tmp___6 = xsum(length, n);
#line 1581
      augmented_length = (size_t )tmp___6;
      }
#line 1583
      if (augmented_length > allocated) {
#line 1583
        if (allocated > 0U) {
#line 1583
          if (allocated <= 2147483647U) {
#line 1583
            tmp___7 = allocated * 2U;
          } else {
#line 1583
            tmp___7 = 4294967295U;
          }
#line 1583
          allocated = tmp___7;
        } else {
#line 1583
          allocated = (size_t )12;
        }
#line 1583
        if (augmented_length > allocated) {
#line 1583
          allocated = augmented_length;
        }
#line 1583
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1583
          memory_size = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1583
          memory_size = 4294967295U;
        }
#line 1583
        if (memory_size == 4294967295U) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else
#line 1583
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1583
          tmp___9 = realloc((void *)result, memory_size);
#line 1583
          memory = (char *)tmp___9;
          }
        }
#line 1583
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1583
          if (length > 0U) {
            {
#line 1583
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1583
        result = memory;
      }
#line 1587
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1589
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1590
        length = augmented_length;
        }
      } else {
        {
#line 1594
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1595
          tmp___10 = length;
#line 1595
          length ++;
#line 1595
          tmp___11 = cp;
#line 1595
          cp ++;
#line 1595
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1594
          n --;
#line 1594
          if (! (n > 0U)) {
#line 1594
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1599
    if (i___0 == d.count) {
#line 1600
      goto while_break;
    }
#line 1603
    if ((int )dp->conversion == 37) {
#line 1607
      if (! (dp->arg_index == 4294967295U)) {
        {
#line 1608
        abort();
        }
      }
      {
#line 1609
      tmp___12 = xsum(length, (size_t )1);
#line 1609
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1610
      if (augmented_length___0 > allocated) {
#line 1610
        if (allocated > 0U) {
#line 1610
          if (allocated <= 2147483647U) {
#line 1610
            tmp___13 = allocated * 2U;
          } else {
#line 1610
            tmp___13 = 4294967295U;
          }
#line 1610
          allocated = tmp___13;
        } else {
#line 1610
          allocated = (size_t )12;
        }
#line 1610
        if (augmented_length___0 > allocated) {
#line 1610
          allocated = augmented_length___0;
        }
#line 1610
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1610
          memory_size___0 = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1610
          memory_size___0 = 4294967295U;
        }
#line 1610
        if (memory_size___0 == 4294967295U) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1610
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1610
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1610
          memory___0 = (char *)tmp___15;
          }
        }
#line 1610
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1610
          if (length > 0U) {
            {
#line 1610
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1610
        result = memory___0;
      }
#line 1611
      *(result + length) = (char )'%';
#line 1612
      length = augmented_length___0;
    } else {
#line 1616
      if (! (dp->arg_index != 4294967295U)) {
        {
#line 1617
        abort();
        }
      }
#line 1619
      if ((int )dp->conversion == 110) {
        {
#line 1623
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1623
          goto case_18;
        }
#line 1626
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1626
          goto case_19;
        }
#line 1629
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1629
          goto case_20;
        }
#line 1632
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1632
          goto case_21;
        }
#line 1636
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1636
          goto case_22;
        }
#line 1640
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1624
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1625
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1627
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1628
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1630
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1631
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1633
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1634
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1637
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1638
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1641
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4305
        type = (a.arg + dp->arg_index)->type;
#line 4306
        flags = dp->flags;
#line 4702
        fbp = buf___1;
#line 4703
        tmp___16 = fbp;
#line 4703
        fbp ++;
#line 4703
        *tmp___16 = (char )'%';
#line 4709
        if (flags & 1) {
#line 4710
          tmp___17 = fbp;
#line 4710
          fbp ++;
#line 4710
          *tmp___17 = (char )'\'';
        }
#line 4712
        if (flags & 2) {
#line 4713
          tmp___18 = fbp;
#line 4713
          fbp ++;
#line 4713
          *tmp___18 = (char )'-';
        }
#line 4714
        if (flags & 4) {
#line 4715
          tmp___19 = fbp;
#line 4715
          fbp ++;
#line 4715
          *tmp___19 = (char )'+';
        }
#line 4716
        if (flags & 8) {
#line 4717
          tmp___20 = fbp;
#line 4717
          fbp ++;
#line 4717
          *tmp___20 = (char )' ';
        }
#line 4718
        if (flags & 16) {
#line 4719
          tmp___21 = fbp;
#line 4719
          fbp ++;
#line 4719
          *tmp___21 = (char )'#';
        }
#line 4722
        if (flags & 32) {
#line 4723
          tmp___22 = fbp;
#line 4723
          fbp ++;
#line 4723
          *tmp___22 = (char )'0';
        }
#line 4724
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4726
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4729
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4731
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   (size_t )((unsigned long )n___0 * sizeof(char )));
#line 4732
            fbp += n___0;
            }
          } else {
#line 4736
            mp = dp->width_start;
            {
#line 4737
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4738
              tmp___23 = fbp;
#line 4738
              fbp ++;
#line 4738
              tmp___24 = mp;
#line 4738
              mp ++;
#line 4738
              *tmp___23 = (char )((unsigned char )*tmp___24);
#line 4737
              n___0 --;
#line 4737
              if (! (n___0 > 0U)) {
#line 4737
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4745
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4747
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4750
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4752
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   (size_t )((unsigned long )n___1 * sizeof(char )));
#line 4753
            fbp += n___1;
            }
          } else {
#line 4757
            mp___0 = dp->precision_start;
            {
#line 4758
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4759
              tmp___25 = fbp;
#line 4759
              fbp ++;
#line 4759
              tmp___26 = mp___0;
#line 4759
              mp___0 ++;
#line 4759
              *tmp___25 = (char )((unsigned char )*tmp___26);
#line 4758
              n___1 --;
#line 4758
              if (! (n___1 > 0U)) {
#line 4758
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4769
        if ((unsigned int )type == 10U) {
#line 4769
          goto case_10;
        }
#line 4769
        if ((unsigned int )type == 9U) {
#line 4769
          goto case_10;
        }
#line 4786
        if ((unsigned int )type == 16U) {
#line 4786
          goto case_16;
        }
#line 4786
        if ((unsigned int )type == 14U) {
#line 4786
          goto case_16;
        }
#line 4786
        if ((unsigned int )type == 8U) {
#line 4786
          goto case_16;
        }
#line 4786
        if ((unsigned int )type == 7U) {
#line 4786
          goto case_16;
        }
#line 4790
        if ((unsigned int )type == 12U) {
#line 4790
          goto case_12;
        }
#line 4793
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4776
        tmp___27 = fbp;
#line 4776
        fbp ++;
#line 4776
        *tmp___27 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4788
        tmp___28 = fbp;
#line 4788
        fbp ++;
#line 4788
        *tmp___28 = (char )'l';
#line 4789
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4791
        tmp___29 = fbp;
#line 4791
        fbp ++;
#line 4791
        *tmp___29 = (char )'L';
#line 4792
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4794
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4801
        *fbp = dp->conversion;
#line 4831
        *(fbp + 1) = (char )'\000';
#line 4838
        prefix_count = 0U;
#line 4839
        if (dp->width_arg_index != 4294967295U) {
#line 4841
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4842
            abort();
            }
          }
#line 4843
          tmp___30 = prefix_count;
#line 4843
          prefix_count ++;
#line 4843
          prefixes[tmp___30] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4845
        if (dp->precision_arg_index != 4294967295U) {
#line 4847
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4848
            abort();
            }
          }
#line 4849
          tmp___31 = prefix_count;
#line 4849
          prefix_count ++;
#line 4849
          prefixes[tmp___31] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4861
        tmp___37 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
        }
#line 4861
        if (tmp___37 > (size_t __attribute__((__pure__))  )allocated) {
#line 4861
          if (allocated > 0U) {
#line 4861
            if (allocated <= 2147483647U) {
#line 4861
              tmp___32 = allocated * 2U;
            } else {
#line 4861
              tmp___32 = 4294967295U;
            }
#line 4861
            allocated = tmp___32;
          } else {
#line 4861
            allocated = (size_t )12;
          }
          {
#line 4861
          tmp___34 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
          }
#line 4861
          if (tmp___34 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4861
            tmp___33 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 4861
            allocated = (size_t )tmp___33;
            }
          }
#line 4861
          if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 4861
            memory_size___1 = (size_t )((unsigned long )allocated * sizeof(char ));
          } else {
#line 4861
            memory_size___1 = 4294967295U;
          }
#line 4861
          if (memory_size___1 == 4294967295U) {
#line 4861
            goto out_of_memory;
          }
#line 4861
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4861
            tmp___35 = malloc(memory_size___1);
#line 4861
            memory___1 = (char *)tmp___35;
            }
          } else
#line 4861
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4861
            tmp___35 = malloc(memory_size___1);
#line 4861
            memory___1 = (char *)tmp___35;
            }
          } else {
            {
#line 4861
            tmp___36 = realloc((void *)result, memory_size___1);
#line 4861
            memory___1 = (char *)tmp___36;
            }
          }
#line 4861
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4861
            goto out_of_memory;
          }
#line 4861
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4861
            if (length > 0U) {
              {
#line 4861
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4861
          result = memory___1;
        }
#line 4866
        *(result + length) = (char )'\000';
        {
#line 4869
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4871
          count = -1;
#line 4874
          retcount = 0;
#line 4875
          maxlen = allocated - length;
#line 4878
          if ((unsigned long )maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4879
            maxlen = (size_t )(2147483647UL / (sizeof(char ) / sizeof(char )));
          }
#line 4880
          maxlen = (size_t )((unsigned long )maxlen * (sizeof(char ) / sizeof(char )));
          {
#line 4924
          if ((unsigned int )type == 1U) {
#line 4924
            goto case_1;
          }
#line 4930
          if ((unsigned int )type == 2U) {
#line 4930
            goto case_2___0;
          }
#line 4936
          if ((unsigned int )type == 3U) {
#line 4936
            goto case_3;
          }
#line 4942
          if ((unsigned int )type == 4U) {
#line 4942
            goto case_4;
          }
#line 4948
          if ((unsigned int )type == 5U) {
#line 4948
            goto case_5;
          }
#line 4954
          if ((unsigned int )type == 6U) {
#line 4954
            goto case_6;
          }
#line 4960
          if ((unsigned int )type == 7U) {
#line 4960
            goto case_7___0;
          }
#line 4966
          if ((unsigned int )type == 8U) {
#line 4966
            goto case_8___0;
          }
#line 4973
          if ((unsigned int )type == 9U) {
#line 4973
            goto case_9___0;
          }
#line 4979
          if ((unsigned int )type == 10U) {
#line 4979
            goto case_10___0;
          }
#line 4986
          if ((unsigned int )type == 11U) {
#line 4986
            goto case_11;
          }
#line 4992
          if ((unsigned int )type == 12U) {
#line 4992
            goto case_12___0;
          }
#line 4998
          if ((unsigned int )type == 13U) {
#line 4998
            goto case_13;
          }
#line 5005
          if ((unsigned int )type == 14U) {
#line 5005
            goto case_14___0;
          }
#line 5012
          if ((unsigned int )type == 15U) {
#line 5012
            goto case_15;
          }
#line 5019
          if ((unsigned int )type == 16U) {
#line 5019
            goto case_16___0;
          }
#line 5026
          if ((unsigned int )type == 17U) {
#line 5026
            goto case_17;
          }
#line 5032
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4926
          arg = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4927
          if (prefix_count == 0U) {
#line 4927
            goto case_0;
          }
#line 4927
          if (prefix_count == 1U) {
#line 4927
            goto case_1___0;
          }
#line 4927
          if (prefix_count == 2U) {
#line 4927
            goto case_2;
          }
#line 4927
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4927
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg, & count);
          }
#line 4927
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4927
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg, & count);
          }
#line 4927
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4927
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg, & count);
          }
#line 4927
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4927
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4929
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4932
          arg___0 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4933
          if (prefix_count == 0U) {
#line 4933
            goto case_0___0;
          }
#line 4933
          if (prefix_count == 1U) {
#line 4933
            goto case_1___1;
          }
#line 4933
          if (prefix_count == 2U) {
#line 4933
            goto case_2___1;
          }
#line 4933
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4933
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___0, & count);
          }
#line 4933
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4933
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___0, & count);
          }
#line 4933
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4933
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___0, & count);
          }
#line 4933
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4933
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4935
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 4938
          arg___1 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 4939
          if (prefix_count == 0U) {
#line 4939
            goto case_0___1;
          }
#line 4939
          if (prefix_count == 1U) {
#line 4939
            goto case_1___2;
          }
#line 4939
          if (prefix_count == 2U) {
#line 4939
            goto case_2___2;
          }
#line 4939
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 4939
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___1, & count);
          }
#line 4939
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 4939
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___1, & count);
          }
#line 4939
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 4939
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___1, & count);
          }
#line 4939
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 4939
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 4941
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 4944
          arg___2 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 4945
          if (prefix_count == 0U) {
#line 4945
            goto case_0___2;
          }
#line 4945
          if (prefix_count == 1U) {
#line 4945
            goto case_1___3;
          }
#line 4945
          if (prefix_count == 2U) {
#line 4945
            goto case_2___3;
          }
#line 4945
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 4945
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___2, & count);
          }
#line 4945
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 4945
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___2, & count);
          }
#line 4945
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 4945
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___2, & count);
          }
#line 4945
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 4945
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 4947
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 4950
          arg___3 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 4951
          if (prefix_count == 0U) {
#line 4951
            goto case_0___3;
          }
#line 4951
          if (prefix_count == 1U) {
#line 4951
            goto case_1___4;
          }
#line 4951
          if (prefix_count == 2U) {
#line 4951
            goto case_2___4;
          }
#line 4951
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 4951
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___3, & count);
          }
#line 4951
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 4951
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___3, & count);
          }
#line 4951
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 4951
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___3, & count);
          }
#line 4951
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 4951
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 4953
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 4956
          arg___4 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 4957
          if (prefix_count == 0U) {
#line 4957
            goto case_0___4;
          }
#line 4957
          if (prefix_count == 1U) {
#line 4957
            goto case_1___5;
          }
#line 4957
          if (prefix_count == 2U) {
#line 4957
            goto case_2___5;
          }
#line 4957
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 4957
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___4, & count);
          }
#line 4957
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 4957
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___4, & count);
          }
#line 4957
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 4957
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___4, & count);
          }
#line 4957
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 4957
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 4959
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 4962
          arg___5 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 4963
          if (prefix_count == 0U) {
#line 4963
            goto case_0___5;
          }
#line 4963
          if (prefix_count == 1U) {
#line 4963
            goto case_1___6;
          }
#line 4963
          if (prefix_count == 2U) {
#line 4963
            goto case_2___6;
          }
#line 4963
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 4963
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___5, & count);
          }
#line 4963
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 4963
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___5, & count);
          }
#line 4963
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 4963
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___5, & count);
          }
#line 4963
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 4963
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 4965
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 4968
          arg___6 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 4969
          if (prefix_count == 0U) {
#line 4969
            goto case_0___6;
          }
#line 4969
          if (prefix_count == 1U) {
#line 4969
            goto case_1___7;
          }
#line 4969
          if (prefix_count == 2U) {
#line 4969
            goto case_2___7;
          }
#line 4969
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 4969
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___6, & count);
          }
#line 4969
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 4969
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___6, & count);
          }
#line 4969
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 4969
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___6, & count);
          }
#line 4969
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 4969
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 4971
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 4975
          arg___7 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 4976
          if (prefix_count == 0U) {
#line 4976
            goto case_0___7;
          }
#line 4976
          if (prefix_count == 1U) {
#line 4976
            goto case_1___8;
          }
#line 4976
          if (prefix_count == 2U) {
#line 4976
            goto case_2___8;
          }
#line 4976
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 4976
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___7, & count);
          }
#line 4976
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 4976
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___7, & count);
          }
#line 4976
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 4976
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___7, & count);
          }
#line 4976
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 4976
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 4978
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 4981
          arg___8 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 4982
          if (prefix_count == 0U) {
#line 4982
            goto case_0___8;
          }
#line 4982
          if (prefix_count == 1U) {
#line 4982
            goto case_1___9;
          }
#line 4982
          if (prefix_count == 2U) {
#line 4982
            goto case_2___9;
          }
#line 4982
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 4982
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___8, & count);
          }
#line 4982
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 4982
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___8, & count);
          }
#line 4982
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 4982
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___8, & count);
          }
#line 4982
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 4982
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 4984
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 4988
          arg___9 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 4989
          if (prefix_count == 0U) {
#line 4989
            goto case_0___9;
          }
#line 4989
          if (prefix_count == 1U) {
#line 4989
            goto case_1___10;
          }
#line 4989
          if (prefix_count == 2U) {
#line 4989
            goto case_2___10;
          }
#line 4989
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___9, & count);
          }
#line 4989
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___9, & count);
          }
#line 4989
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___9, & count);
          }
#line 4989
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 4989
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 4991
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 4994
          arg___10 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 4995
          if (prefix_count == 0U) {
#line 4995
            goto case_0___10;
          }
#line 4995
          if (prefix_count == 1U) {
#line 4995
            goto case_1___11;
          }
#line 4995
          if (prefix_count == 2U) {
#line 4995
            goto case_2___11;
          }
#line 4995
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___10,
                              & count);
          }
#line 4995
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___10, & count);
          }
#line 4995
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___10, & count);
          }
#line 4995
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 4995
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 4997
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5000
          arg___11 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5001
          if (prefix_count == 0U) {
#line 5001
            goto case_0___11;
          }
#line 5001
          if (prefix_count == 1U) {
#line 5001
            goto case_1___12;
          }
#line 5001
          if (prefix_count == 2U) {
#line 5001
            goto case_2___12;
          }
#line 5001
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___11,
                              & count);
          }
#line 5001
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___11, & count);
          }
#line 5001
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___11, & count);
          }
#line 5001
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5001
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5003
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5007
          arg___12 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5008
          if (prefix_count == 0U) {
#line 5008
            goto case_0___12;
          }
#line 5008
          if (prefix_count == 1U) {
#line 5008
            goto case_1___13;
          }
#line 5008
          if (prefix_count == 2U) {
#line 5008
            goto case_2___13;
          }
#line 5008
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___12,
                              & count);
          }
#line 5008
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___12, & count);
          }
#line 5008
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___12, & count);
          }
#line 5008
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5008
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5010
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5014
          arg___13 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5015
          if (prefix_count == 0U) {
#line 5015
            goto case_0___13;
          }
#line 5015
          if (prefix_count == 1U) {
#line 5015
            goto case_1___14;
          }
#line 5015
          if (prefix_count == 2U) {
#line 5015
            goto case_2___14;
          }
#line 5015
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___13,
                              & count);
          }
#line 5015
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___13, & count);
          }
#line 5015
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___13, & count);
          }
#line 5015
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5015
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5017
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5021
          arg___14 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5022
          if (prefix_count == 0U) {
#line 5022
            goto case_0___14;
          }
#line 5022
          if (prefix_count == 1U) {
#line 5022
            goto case_1___15;
          }
#line 5022
          if (prefix_count == 2U) {
#line 5022
            goto case_2___15;
          }
#line 5022
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5022
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___14,
                              & count);
          }
#line 5022
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5022
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___14, & count);
          }
#line 5022
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5022
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___14, & count);
          }
#line 5022
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5022
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5024
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5028
          arg___15 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5029
          if (prefix_count == 0U) {
#line 5029
            goto case_0___15;
          }
#line 5029
          if (prefix_count == 1U) {
#line 5029
            goto case_1___16;
          }
#line 5029
          if (prefix_count == 2U) {
#line 5029
            goto case_2___16;
          }
#line 5029
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5029
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___15,
                              & count);
          }
#line 5029
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5029
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___15, & count);
          }
#line 5029
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5029
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___15, & count);
          }
#line 5029
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5029
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5031
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5033
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5041
          if (count >= 0) {
#line 5045
            if ((size_t )count < maxlen) {
#line 5045
              if ((int )*((result + length) + count) != 0) {
                {
#line 5047
                abort();
                }
              }
            }
#line 5049
            if (retcount > count) {
#line 5050
              count = retcount;
            }
          } else
#line 5056
          if ((int )*(fbp + 1) != 0) {
#line 5060
            *(fbp + 1) = (char )'\000';
#line 5061
            goto __Cont;
          } else
#line 5066
          if (retcount < 0) {
#line 5073
            if (allocated <= 2147483647U) {
#line 5073
              tmp___38 = allocated * 2U;
            } else {
#line 5073
              tmp___38 = 4294967295U;
            }
            {
#line 5073
            tmp___39 = xsum(tmp___38, (size_t )12);
#line 5073
            bigger_need = (size_t )tmp___39;
            }
#line 5075
            if (bigger_need > allocated) {
#line 5075
              if (allocated > 0U) {
#line 5075
                if (allocated <= 2147483647U) {
#line 5075
                  tmp___40 = allocated * 2U;
                } else {
#line 5075
                  tmp___40 = 4294967295U;
                }
#line 5075
                allocated = tmp___40;
              } else {
#line 5075
                allocated = (size_t )12;
              }
#line 5075
              if (bigger_need > allocated) {
#line 5075
                allocated = bigger_need;
              }
#line 5075
              if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5075
                memory_size___2 = (size_t )((unsigned long )allocated * sizeof(char ));
              } else {
#line 5075
                memory_size___2 = 4294967295U;
              }
#line 5075
              if (memory_size___2 == 4294967295U) {
#line 5075
                goto out_of_memory;
              }
#line 5075
              if ((unsigned long )result == (unsigned long )resultbuf) {
                {
#line 5075
                tmp___41 = malloc(memory_size___2);
#line 5075
                memory___2 = (char *)tmp___41;
                }
              } else
#line 5075
              if ((unsigned long )result == (unsigned long )((void *)0)) {
                {
#line 5075
                tmp___41 = malloc(memory_size___2);
#line 5075
                memory___2 = (char *)tmp___41;
                }
              } else {
                {
#line 5075
                tmp___42 = realloc((void *)result, memory_size___2);
#line 5075
                memory___2 = (char *)tmp___42;
                }
              }
#line 5075
              if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5075
                goto out_of_memory;
              }
#line 5075
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5075
                if (length > 0U) {
                  {
#line 5075
                  memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                         length);
                  }
                }
              }
#line 5075
              result = memory___2;
            }
#line 5076
            goto __Cont;
          } else {
#line 5079
            count = retcount;
          }
#line 5085
          if (count < 0) {
#line 5087
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5087
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5088
                free((void *)result);
                }
              }
            }
#line 5089
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5090
              free((void *)buf_malloced);
              }
            }
            {
#line 5091
            free((void *)d.dir);
            }
#line 5091
            if (a.arg) {
              {
#line 5091
              free((void *)a.arg);
              }
            }
            {
#line 5092
            tmp___43 = __errno_location();
#line 5092
            *tmp___43 = 22;
            }
#line 5093
            return ((char *)((void *)0));
          }
#line 5102
          if ((unsigned int )count + 1U >= maxlen) {
#line 5107
            if ((unsigned long )maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5108
              goto overflow;
            } else {
#line 5120
              if (allocated <= 2147483647U) {
#line 5120
                tmp___44 = allocated * 2U;
              } else {
#line 5120
                tmp___44 = 4294967295U;
              }
              {
#line 5120
              tmp___45 = xsum(length, (size_t )((((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 5120
              tmp___46 = xmax((size_t )tmp___45, tmp___44);
#line 5120
              n___2 = (size_t )tmp___46;
              }
#line 5127
              if (n___2 > allocated) {
#line 5127
                if (allocated > 0U) {
#line 5127
                  if (allocated <= 2147483647U) {
#line 5127
                    tmp___47 = allocated * 2U;
                  } else {
#line 5127
                    tmp___47 = 4294967295U;
                  }
#line 5127
                  allocated = tmp___47;
                } else {
#line 5127
                  allocated = (size_t )12;
                }
#line 5127
                if (n___2 > allocated) {
#line 5127
                  allocated = n___2;
                }
#line 5127
                if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5127
                  memory_size___3 = (size_t )((unsigned long )allocated * sizeof(char ));
                } else {
#line 5127
                  memory_size___3 = 4294967295U;
                }
#line 5127
                if (memory_size___3 == 4294967295U) {
#line 5127
                  goto out_of_memory;
                }
#line 5127
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5127
                  tmp___48 = malloc(memory_size___3);
#line 5127
                  memory___3 = (char *)tmp___48;
                  }
                } else
#line 5127
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5127
                  tmp___48 = malloc(memory_size___3);
#line 5127
                  memory___3 = (char *)tmp___48;
                  }
                } else {
                  {
#line 5127
                  tmp___49 = realloc((void *)result, memory_size___3);
#line 5127
                  memory___3 = (char *)tmp___49;
                  }
                }
#line 5127
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5127
                  goto out_of_memory;
                }
#line 5127
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5127
                  if (length > 0U) {
                    {
#line 5127
                    memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5127
                result = memory___3;
              }
#line 5128
              goto __Cont;
            }
          }
#line 5426
          length += (size_t )count;
#line 5427
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 1576
    cp = dp->dir_end;
#line 1576
    i___0 ++;
#line 1576
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5434
  tmp___55 = xsum(length, (size_t )1);
  }
#line 5434
  if (tmp___55 > (size_t __attribute__((__pure__))  )allocated) {
#line 5434
    if (allocated > 0U) {
#line 5434
      if (allocated <= 2147483647U) {
#line 5434
        tmp___50 = allocated * 2U;
      } else {
#line 5434
        tmp___50 = 4294967295U;
      }
#line 5434
      allocated = tmp___50;
    } else {
#line 5434
      allocated = (size_t )12;
    }
    {
#line 5434
    tmp___52 = xsum(length, (size_t )1);
    }
#line 5434
    if (tmp___52 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5434
      tmp___51 = xsum(length, (size_t )1);
#line 5434
      allocated = (size_t )tmp___51;
      }
    }
#line 5434
    if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5434
      memory_size___4 = (size_t )((unsigned long )allocated * sizeof(char ));
    } else {
#line 5434
      memory_size___4 = 4294967295U;
    }
#line 5434
    if (memory_size___4 == 4294967295U) {
#line 5434
      goto out_of_memory;
    }
#line 5434
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5434
      tmp___53 = malloc(memory_size___4);
#line 5434
      memory___4 = (char *)tmp___53;
      }
    } else
#line 5434
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5434
      tmp___53 = malloc(memory_size___4);
#line 5434
      memory___4 = (char *)tmp___53;
      }
    } else {
      {
#line 5434
      tmp___54 = realloc((void *)result, memory_size___4);
#line 5434
      memory___4 = (char *)tmp___54;
      }
    }
#line 5434
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5434
      goto out_of_memory;
    }
#line 5434
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5434
      if (length > 0U) {
        {
#line 5434
        memcpy((void */* __restrict  */)memory___4, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5434
    result = memory___4;
  }
#line 5435
  *(result + length) = (char )'\000';
#line 5437
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5437
    if (length + 1U < allocated) {
      {
#line 5442
      tmp___56 = realloc((void *)result, (size_t )((unsigned long )(length + 1U) * sizeof(char )));
#line 5442
      memory___5 = (char *)tmp___56;
      }
#line 5443
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
#line 5444
        result = memory___5;
      }
    }
  }
#line 5447
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5448
    free((void *)buf_malloced);
    }
  }
  {
#line 5449
  free((void *)d.dir);
  }
#line 5449
  if (a.arg) {
    {
#line 5449
    free((void *)a.arg);
    }
  }
#line 5450
  *lengthp = length;
#line 5455
  return (result);
  overflow: 
#line 5459
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5459
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5460
      free((void *)result);
      }
    }
  }
#line 5461
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5462
    free((void *)buf_malloced);
    }
  }
  {
#line 5463
  free((void *)d.dir);
  }
#line 5463
  if (a.arg) {
    {
#line 5463
    free((void *)a.arg);
    }
  }
  {
#line 5464
  tmp___57 = __errno_location();
#line 5464
  *tmp___57 = 75;
  }
#line 5465
  return ((char *)((void *)0));
  out_of_memory: 
#line 5469
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5469
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5470
      free((void *)result);
      }
    }
  }
#line 5471
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5472
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
  {
#line 5474
  free((void *)d.dir);
  }
#line 5474
  if (a.arg) {
    {
#line 5474
    free((void *)a.arg);
    }
  }
  {
#line 5475
  tmp___58 = __errno_location();
#line 5475
  *tmp___58 = 12;
  }
#line 5476
  return ((char *)((void *)0));
}
}
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i___0 , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i___0 , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i___0 < 0ULL) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48ULL - i___0 % 10ULL);
#line 43
      i___0 /= 10ULL;
#line 43
      if (! (i___0 != 0ULL)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48ULL + i___0 % 10ULL);
#line 51
      i___0 /= 10ULL;
#line 51
      if (! (i___0 != 0ULL)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 24
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i___0 , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i___0 , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + (((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i___0 < 0U) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48U - i___0 % 10U);
#line 43
      i___0 /= 10U;
#line 43
      if (! (i___0 != 0U)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48U + i___0 % 10U);
#line 51
      i___0 /= 10U;
#line 51
      if (! (i___0 != 0U)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 304 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len___0 ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    tmp___0 = len___0;
#line 308
    len___0 --;
#line 308
    if (! (tmp___0 > 0U)) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = tolower((int )((unsigned char )*(src + len___0)));
#line 309
    *(dest + len___0) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (dest);
}
}
#line 313 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len___0 ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    tmp___0 = len___0;
#line 317
    len___0 --;
#line 317
    if (! (tmp___0 > 0U)) {
#line 317
      goto while_break;
    }
    {
#line 318
    tmp = toupper((int )((unsigned char )*(src + len___0)));
#line 318
    *(dest + len___0) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (dest);
}
}
#line 360 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 366
  big_enough_multiple_of_7 = 378;
#line 367
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 408 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static size_t strftime_case_(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                             struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i___0 ;
  char *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t len___0 ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___1 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  int padding ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  int year ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  void *__cil_tmp125 ;
  void *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;

  {
#line 421
  hour12 = (int )tp->tm_hour;
#line 446
  i___0 = (size_t )0;
#line 447
  p = s;
#line 458
  copy = *tp;
#line 459
  tp = (struct tm  const  *)(& copy);
#line 462
  zone = (char const   *)((void *)0);
#line 470
  zone = (char const   *)tp->tm_zone;
#line 488
  if (hour12 > 12) {
#line 489
    hour12 -= 12;
  } else
#line 491
  if (hour12 == 0) {
#line 492
    hour12 = 12;
  }
#line 494
  f = format;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! ((int const   )*f != 0)) {
#line 494
      goto while_break;
    }
#line 496
    pad = 0;
#line 498
    digits = 0;
#line 512
    width = -1;
#line 513
    to_lowcase = (_Bool)0;
#line 514
    to_uppcase = upcase;
#line 516
    change_case = (_Bool)0;
#line 599
    if ((int const   )*f != 37) {
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 601
        _n = 1;
#line 601
        _delta = width - _n;
#line 601
        if (_delta > 0) {
#line 601
          tmp = _delta;
        } else {
#line 601
          tmp = 0;
        }
#line 601
        _incr = _n + tmp;
#line 601
        if ((size_t )_incr >= maxsize - i___0) {
#line 601
          return ((size_t )0);
        }
#line 601
        if (p) {
#line 601
          if (digits == 0) {
#line 601
            if (_delta > 0) {
#line 601
              if (pad == 48) {
                {
#line 601
                memset((void *)p, '0', (size_t )_delta);
#line 601
                p += _delta;
                }
              } else {
                {
#line 601
                memset((void *)p, ' ', (size_t )_delta);
#line 601
                p += _delta;
                }
              }
            }
          }
#line 601
          *p = (char )*f;
#line 601
          p += _n;
        }
#line 601
        i___0 += (size_t )_incr;
#line 601
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 602
      goto __Cont;
    }
    {
#line 608
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 610
      f ++;
      {
#line 615
      if ((int const   )*f == 48) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 45) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 95) {
#line 615
        goto case_48;
      }
#line 620
      if ((int const   )*f == 94) {
#line 620
        goto case_94;
      }
#line 623
      if ((int const   )*f == 35) {
#line 623
        goto case_35;
      }
#line 627
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 616
      pad = (int )*f;
#line 617
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 621
      to_uppcase = (_Bool)1;
#line 622
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 624
      change_case = (_Bool)1;
#line 625
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 628
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 630
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 634
    if ((unsigned int )*f - 48U <= 9U) {
#line 636
      width = 0;
      {
#line 637
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 639
        if (width > 214748364) {
#line 642
          width = 2147483647;
        } else
#line 639
        if (width == 214748364) {
#line 639
          if ((int const   )*f - 48 > 7) {
#line 642
            width = 2147483647;
          } else {
#line 645
            width *= 10;
#line 646
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 645
          width *= 10;
#line 646
          width += (int )((int const   )*f - 48);
        }
#line 648
        f ++;
#line 637
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 637
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 657
    if ((int const   )*f == 79) {
#line 657
      goto case_79;
    }
#line 657
    if ((int const   )*f == 69) {
#line 657
      goto case_79;
    }
#line 661
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 658
    tmp___0 = f;
#line 658
    f ++;
#line 658
    modifier = (int )*tmp___0;
#line 659
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 662
    modifier = 0;
#line 663
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 667
    format_char = (int )*f;
    {
#line 690
    if (format_char == 37) {
#line 690
      goto case_37;
    }
#line 696
    if (format_char == 97) {
#line 696
      goto case_97;
    }
#line 711
    if (format_char == 65) {
#line 711
      goto case_65;
    }
#line 727
    if (format_char == 104) {
#line 727
      goto case_104;
    }
#line 727
    if (format_char == 98) {
#line 727
      goto case_104;
    }
#line 742
    if (format_char == 66) {
#line 742
      goto case_66;
    }
#line 757
    if (format_char == 99) {
#line 757
      goto case_99;
    }
#line 816
    if (format_char == 67) {
#line 816
      goto case_67;
    }
#line 845
    if (format_char == 120) {
#line 845
      goto case_120;
    }
#line 858
    if (format_char == 68) {
#line 858
      goto case_68;
    }
#line 864
    if (format_char == 100) {
#line 864
      goto case_100;
    }
#line 870
    if (format_char == 101) {
#line 870
      goto case_101;
    }
#line 996
    if (format_char == 70) {
#line 996
      goto case_70;
    }
#line 1002
    if (format_char == 72) {
#line 1002
      goto case_72;
    }
#line 1008
    if (format_char == 73) {
#line 1008
      goto case_73;
    }
#line 1014
    if (format_char == 107) {
#line 1014
      goto case_107;
    }
#line 1020
    if (format_char == 108) {
#line 1020
      goto case_108;
    }
#line 1026
    if (format_char == 106) {
#line 1026
      goto case_106;
    }
#line 1032
    if (format_char == 77) {
#line 1032
      goto case_77;
    }
#line 1038
    if (format_char == 109) {
#line 1038
      goto case_109;
    }
#line 1045
    if (format_char == 78) {
#line 1045
      goto case_78;
    }
#line 1063
    if (format_char == 110) {
#line 1063
      goto case_110;
    }
#line 1067
    if (format_char == 80) {
#line 1067
      goto case_80;
    }
#line 1074
    if (format_char == 112) {
#line 1074
      goto case_112;
    }
#line 1087
    if (format_char == 82) {
#line 1087
      goto case_82;
    }
#line 1091
    if (format_char == 114) {
#line 1091
      goto case_114;
    }
#line 1102
    if (format_char == 83) {
#line 1102
      goto case_83;
    }
#line 1108
    if (format_char == 115) {
#line 1108
      goto case_115;
    }
#line 1135
    if (format_char == 88) {
#line 1135
      goto case_88;
    }
#line 1148
    if (format_char == 84) {
#line 1148
      goto case_84;
    }
#line 1152
    if (format_char == 116) {
#line 1152
      goto case_116;
    }
#line 1156
    if (format_char == 117) {
#line 1156
      goto case_117;
    }
#line 1159
    if (format_char == 85) {
#line 1159
      goto case_85;
    }
#line 1167
    if (format_char == 71) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 103) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 86) {
#line 1167
      goto case_71;
    }
#line 1223
    if (format_char == 87) {
#line 1223
      goto case_87;
    }
#line 1229
    if (format_char == 119) {
#line 1229
      goto case_119;
    }
#line 1235
    if (format_char == 89) {
#line 1235
      goto case_89;
    }
#line 1259
    if (format_char == 121) {
#line 1259
      goto case_121;
    }
#line 1282
    if (format_char == 90) {
#line 1282
      goto case_90;
    }
#line 1311
    if (format_char == 58) {
#line 1311
      goto case_58;
    }
#line 1321
    if (format_char == 122) {
#line 1321
      goto case_122;
    }
#line 1399
    if (format_char == 0) {
#line 1399
      goto case_0___0;
    }
#line 1402
    goto bad_format;
    case_37: /* CIL Label */ 
#line 691
    if (modifier != 0) {
#line 692
      goto bad_format;
    }
    {
#line 693
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 693
      _n___0 = 1;
#line 693
      _delta___0 = width - _n___0;
#line 693
      if (_delta___0 > 0) {
#line 693
        tmp___1 = _delta___0;
      } else {
#line 693
        tmp___1 = 0;
      }
#line 693
      _incr___0 = _n___0 + tmp___1;
#line 693
      if ((size_t )_incr___0 >= maxsize - i___0) {
#line 693
        return ((size_t )0);
      }
#line 693
      if (p) {
#line 693
        if (digits == 0) {
#line 693
          if (_delta___0 > 0) {
#line 693
            if (pad == 48) {
              {
#line 693
              memset((void *)p, '0', (size_t )_delta___0);
#line 693
              p += _delta___0;
              }
            } else {
              {
#line 693
              memset((void *)p, ' ', (size_t )_delta___0);
#line 693
              p += _delta___0;
              }
            }
          }
        }
#line 693
        *p = (char )*f;
#line 693
        p += _n___0;
      }
#line 693
      i___0 += (size_t )_incr___0;
#line 693
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 694
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 697
    if (modifier != 0) {
#line 698
      goto bad_format;
    }
#line 699
    if (change_case) {
#line 701
      to_uppcase = (_Bool)1;
#line 702
      to_lowcase = (_Bool)0;
    }
#line 708
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 728
    if (change_case) {
#line 730
      to_uppcase = (_Bool)1;
#line 731
      to_lowcase = (_Bool)0;
    }
#line 733
    if (modifier != 0) {
#line 734
      goto bad_format;
    }
#line 739
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 743
    if (modifier != 0) {
#line 744
      goto bad_format;
    }
#line 745
    if (change_case) {
#line 747
      to_uppcase = (_Bool)1;
#line 748
      to_lowcase = (_Bool)0;
    }
#line 754
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 758
    if (modifier == 79) {
#line 759
      goto bad_format;
    }
#line 768
    goto underlying_strftime;
    subformat: 
    {
#line 773
    tmp___2 = strftime_case_(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                             tp, ut, ns);
#line 773
    len___0 = tmp___2;
    }
    {
#line 777
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 777
      _n___1 = (int )len___0;
#line 777
      _delta___1 = width - _n___1;
#line 777
      if (_delta___1 > 0) {
#line 777
        tmp___3 = _delta___1;
      } else {
#line 777
        tmp___3 = 0;
      }
#line 777
      _incr___1 = _n___1 + tmp___3;
#line 777
      if ((size_t )_incr___1 >= maxsize - i___0) {
#line 777
        return ((size_t )0);
      }
#line 777
      if (p) {
#line 777
        if (digits == 0) {
#line 777
          if (_delta___1 > 0) {
#line 777
            if (pad == 48) {
              {
#line 777
              memset((void *)p, '0', (size_t )_delta___1);
#line 777
              p += _delta___1;
              }
            } else {
              {
#line 777
              memset((void *)p, ' ', (size_t )_delta___1);
#line 777
              p += _delta___1;
              }
            }
          }
        }
        {
#line 777
        strftime_case_(to_uppcase, p, maxsize - i___0, subfmt, tp, ut, ns);
#line 777
        p += _n___1;
        }
      }
#line 777
      i___0 += (size_t )_incr___1;
#line 777
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 782
    goto switch_break___1;
    underlying_strftime: 
#line 790
    u = ufmt;
#line 803
    tmp___4 = u;
#line 803
    u ++;
#line 803
    *tmp___4 = (char )' ';
#line 804
    tmp___5 = u;
#line 804
    u ++;
#line 804
    *tmp___5 = (char )'%';
#line 805
    if (modifier != 0) {
#line 806
      tmp___6 = u;
#line 806
      u ++;
#line 806
      *tmp___6 = (char )modifier;
    }
    {
#line 807
    tmp___7 = u;
#line 807
    u ++;
#line 807
    *tmp___7 = (char )format_char;
#line 808
    *u = (char )'\000';
#line 809
    len___1 = strftime((char */* __restrict  */)(ubuf), (size_t )sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 810
    if (len___1 != 0U) {
      {
#line 811
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 811
        _n___2 = (int )(len___1 - 1U);
#line 811
        _delta___2 = width - _n___2;
#line 811
        if (_delta___2 > 0) {
#line 811
          tmp___8 = _delta___2;
        } else {
#line 811
          tmp___8 = 0;
        }
#line 811
        _incr___2 = _n___2 + tmp___8;
#line 811
        if ((size_t )_incr___2 >= maxsize - i___0) {
#line 811
          return ((size_t )0);
        }
#line 811
        if (p) {
#line 811
          if (digits == 0) {
#line 811
            if (_delta___2 > 0) {
#line 811
              if (pad == 48) {
                {
#line 811
                memset((void *)p, '0', (size_t )_delta___2);
#line 811
                p += _delta___2;
                }
              } else {
                {
#line 811
                memset((void *)p, ' ', (size_t )_delta___2);
#line 811
                p += _delta___2;
                }
              }
            }
          }
#line 811
          if (to_lowcase) {
            {
#line 811
            memcpy_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 811
          if (to_uppcase) {
            {
#line 811
            memcpy_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 811
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   (size_t )_n___2);
            }
          }
#line 811
          p += _n___2;
        }
#line 811
        i___0 += (size_t )_incr___2;
#line 811
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 813
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 817
    if (modifier == 79) {
#line 818
      goto bad_format;
    }
#line 819
    if (modifier == 69) {
#line 835
      goto underlying_strftime;
    }
#line 840
    century = (int )(tp->tm_year / 100 + 19);
#line 841
    if (tp->tm_year % 100 < 0) {
#line 841
      if (0 < century) {
#line 841
        tmp___9 = 1;
      } else {
#line 841
        tmp___9 = 0;
      }
    } else {
#line 841
      tmp___9 = 0;
    }
#line 841
    century -= tmp___9;
#line 842
    digits = 2;
#line 842
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 842
    u_number_value = (unsigned int )century;
#line 842
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 846
    if (modifier == 79) {
#line 847
      goto bad_format;
    }
#line 856
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 859
    if (modifier != 0) {
#line 860
      goto bad_format;
    }
#line 861
    subfmt = "%m/%d/%y";
#line 862
    goto subformat;
    case_100: /* CIL Label */ 
#line 865
    if (modifier == 69) {
#line 866
      goto bad_format;
    }
#line 868
    digits = 2;
#line 868
    number_value = (int )tp->tm_mday;
#line 868
    goto do_number;
    case_101: /* CIL Label */ 
#line 871
    if (modifier == 69) {
#line 872
      goto bad_format;
    }
#line 874
    digits = 2;
#line 874
    number_value = (int )tp->tm_mday;
#line 874
    goto do_number_spacepad;
    do_tz_offset: 
#line 880
    always_output_a_sign = (_Bool)1;
#line 881
    goto do_number_body;
    do_number_spacepad: 
#line 885
    if (pad != 48) {
#line 885
      if (pad != 45) {
#line 886
        pad = '_';
      }
    }
    do_number: 
#line 890
    negative_number = (_Bool )(number_value < 0);
#line 891
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 894
    always_output_a_sign = (_Bool)0;
#line 895
    tz_colon_mask = 0;
    do_number_body: 
#line 903
    if (modifier == 79) {
#line 903
      if (! negative_number) {
#line 921
        goto underlying_strftime;
      }
    }
#line 925
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 927
    if (negative_number) {
#line 928
      u_number_value = - u_number_value;
    }
    {
#line 930
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 932
      if (tz_colon_mask & 1) {
#line 933
        bufp --;
#line 933
        *bufp = (char )':';
      }
#line 934
      tz_colon_mask >>= 1;
#line 935
      bufp --;
#line 935
      *bufp = (char )(u_number_value % 10U + 48U);
#line 936
      u_number_value /= 10U;
#line 930
      if (! (u_number_value != 0U)) {
#line 930
        if (! (tz_colon_mask != 0)) {
#line 930
          goto while_break___6;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 941
    if (digits < width) {
#line 942
      digits = width;
    }
#line 944
    if (negative_number) {
#line 944
      sign_char = (char )'-';
    } else {
#line 944
      if (always_output_a_sign) {
#line 944
        tmp___10 = '+';
      } else {
#line 944
        tmp___10 = 0;
      }
#line 944
      sign_char = (char )tmp___10;
    }
#line 948
    if (pad == 45) {
#line 950
      if (sign_char) {
        {
#line 951
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 951
          _n___3 = 1;
#line 951
          _delta___3 = width - _n___3;
#line 951
          if (_delta___3 > 0) {
#line 951
            tmp___11 = _delta___3;
          } else {
#line 951
            tmp___11 = 0;
          }
#line 951
          _incr___3 = _n___3 + tmp___11;
#line 951
          if ((size_t )_incr___3 >= maxsize - i___0) {
#line 951
            return ((size_t )0);
          }
#line 951
          if (p) {
#line 951
            if (digits == 0) {
#line 951
              if (_delta___3 > 0) {
#line 951
                if (pad == 48) {
                  {
#line 951
                  memset((void *)p, '0', (size_t )_delta___3);
#line 951
                  p += _delta___3;
                  }
                } else {
                  {
#line 951
                  memset((void *)p, ' ', (size_t )_delta___3);
#line 951
                  p += _delta___3;
                  }
                }
              }
            }
#line 951
            *p = sign_char;
#line 951
            p += _n___3;
          }
#line 951
          i___0 += (size_t )_incr___3;
#line 951
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 955
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 958
      if (padding > 0) {
#line 960
        if (pad == 95) {
#line 962
          if ((size_t )padding >= maxsize - i___0) {
#line 963
            return ((size_t )0);
          }
#line 965
          if (p) {
            {
#line 966
            memset((void *)p, ' ', (size_t )padding);
#line 966
            p += padding;
            }
          }
#line 967
          i___0 += (size_t )padding;
#line 968
          if (width > padding) {
#line 968
            width -= padding;
          } else {
#line 968
            width = 0;
          }
#line 969
          if (sign_char) {
            {
#line 970
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 970
              _n___4 = 1;
#line 970
              _delta___4 = width - _n___4;
#line 970
              if (_delta___4 > 0) {
#line 970
                tmp___12 = _delta___4;
              } else {
#line 970
                tmp___12 = 0;
              }
#line 970
              _incr___4 = _n___4 + tmp___12;
#line 970
              if ((size_t )_incr___4 >= maxsize - i___0) {
#line 970
                return ((size_t )0);
              }
#line 970
              if (p) {
#line 970
                if (digits == 0) {
#line 970
                  if (_delta___4 > 0) {
#line 970
                    if (pad == 48) {
                      {
#line 970
                      memset((void *)p, '0', (size_t )_delta___4);
#line 970
                      p += _delta___4;
                      }
                    } else {
                      {
#line 970
                      memset((void *)p, ' ', (size_t )_delta___4);
#line 970
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 970
                *p = sign_char;
#line 970
                p += _n___4;
              }
#line 970
              i___0 += (size_t )_incr___4;
#line 970
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        } else {
#line 974
          if ((size_t )digits >= maxsize - i___0) {
#line 975
            return ((size_t )0);
          }
#line 977
          if (sign_char) {
            {
#line 978
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 978
              _n___5 = 1;
#line 978
              _delta___5 = width - _n___5;
#line 978
              if (_delta___5 > 0) {
#line 978
                tmp___13 = _delta___5;
              } else {
#line 978
                tmp___13 = 0;
              }
#line 978
              _incr___5 = _n___5 + tmp___13;
#line 978
              if ((size_t )_incr___5 >= maxsize - i___0) {
#line 978
                return ((size_t )0);
              }
#line 978
              if (p) {
#line 978
                if (digits == 0) {
#line 978
                  if (_delta___5 > 0) {
#line 978
                    if (pad == 48) {
                      {
#line 978
                      memset((void *)p, '0', (size_t )_delta___5);
#line 978
                      p += _delta___5;
                      }
                    } else {
                      {
#line 978
                      memset((void *)p, ' ', (size_t )_delta___5);
#line 978
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 978
                *p = sign_char;
#line 978
                p += _n___5;
              }
#line 978
              i___0 += (size_t )_incr___5;
#line 978
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 980
          if (p) {
            {
#line 981
            memset((void *)p, '0', (size_t )padding);
#line 981
            p += padding;
            }
          }
#line 982
          i___0 += (size_t )padding;
#line 983
          width = 0;
        }
      } else
#line 988
      if (sign_char) {
        {
#line 989
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 989
          _n___6 = 1;
#line 989
          _delta___6 = width - _n___6;
#line 989
          if (_delta___6 > 0) {
#line 989
            tmp___14 = _delta___6;
          } else {
#line 989
            tmp___14 = 0;
          }
#line 989
          _incr___6 = _n___6 + tmp___14;
#line 989
          if ((size_t )_incr___6 >= maxsize - i___0) {
#line 989
            return ((size_t )0);
          }
#line 989
          if (p) {
#line 989
            if (digits == 0) {
#line 989
              if (_delta___6 > 0) {
#line 989
                if (pad == 48) {
                  {
#line 989
                  memset((void *)p, '0', (size_t )_delta___6);
#line 989
                  p += _delta___6;
                  }
                } else {
                  {
#line 989
                  memset((void *)p, ' ', (size_t )_delta___6);
#line 989
                  p += _delta___6;
                  }
                }
              }
            }
#line 989
            *p = sign_char;
#line 989
            p += _n___6;
          }
#line 989
          i___0 += (size_t )_incr___6;
#line 989
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 993
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 993
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 993
      _delta___7 = width - _n___7;
#line 993
      if (_delta___7 > 0) {
#line 993
        tmp___15 = _delta___7;
      } else {
#line 993
        tmp___15 = 0;
      }
#line 993
      _incr___7 = _n___7 + tmp___15;
#line 993
      if ((size_t )_incr___7 >= maxsize - i___0) {
#line 993
        return ((size_t )0);
      }
#line 993
      if (p) {
#line 993
        if (digits == 0) {
#line 993
          if (_delta___7 > 0) {
#line 993
            if (pad == 48) {
              {
#line 993
              memset((void *)p, '0', (size_t )_delta___7);
#line 993
              p += _delta___7;
              }
            } else {
              {
#line 993
              memset((void *)p, ' ', (size_t )_delta___7);
#line 993
              p += _delta___7;
              }
            }
          }
        }
#line 993
        if (to_lowcase) {
          {
#line 993
          memcpy_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 993
        if (to_uppcase) {
          {
#line 993
          memcpy_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 993
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 (size_t )_n___7);
          }
        }
#line 993
        p += _n___7;
      }
#line 993
      i___0 += (size_t )_incr___7;
#line 993
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 994
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 997
    if (modifier != 0) {
#line 998
      goto bad_format;
    }
#line 999
    subfmt = "%Y-%m-%d";
#line 1000
    goto subformat;
    case_72: /* CIL Label */ 
#line 1003
    if (modifier == 69) {
#line 1004
      goto bad_format;
    }
#line 1006
    digits = 2;
#line 1006
    number_value = (int )tp->tm_hour;
#line 1006
    goto do_number;
    case_73: /* CIL Label */ 
#line 1009
    if (modifier == 69) {
#line 1010
      goto bad_format;
    }
#line 1012
    digits = 2;
#line 1012
    number_value = hour12;
#line 1012
    goto do_number;
    case_107: /* CIL Label */ 
#line 1015
    if (modifier == 69) {
#line 1016
      goto bad_format;
    }
#line 1018
    digits = 2;
#line 1018
    number_value = (int )tp->tm_hour;
#line 1018
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1021
    if (modifier == 69) {
#line 1022
      goto bad_format;
    }
#line 1024
    digits = 2;
#line 1024
    number_value = hour12;
#line 1024
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1027
    if (modifier == 69) {
#line 1028
      goto bad_format;
    }
#line 1030
    digits = 3;
#line 1030
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1030
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1030
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1033
    if (modifier == 69) {
#line 1034
      goto bad_format;
    }
#line 1036
    digits = 2;
#line 1036
    number_value = (int )tp->tm_min;
#line 1036
    goto do_number;
    case_109: /* CIL Label */ 
#line 1039
    if (modifier == 69) {
#line 1040
      goto bad_format;
    }
#line 1042
    digits = 2;
#line 1042
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1042
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1042
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
#line 1049
    number_value = ns;
#line 1050
    if (width == -1) {
#line 1051
      width = 9;
    } else {
#line 1056
      j = width;
      {
#line 1056
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1056
        if (! (j < 9)) {
#line 1056
          goto while_break___12;
        }
#line 1057
        number_value /= 10;
#line 1056
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1060
    digits = width;
#line 1060
    number_value = number_value;
#line 1060
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1064
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1064
      _n___8 = 1;
#line 1064
      _delta___8 = width - _n___8;
#line 1064
      if (_delta___8 > 0) {
#line 1064
        tmp___16 = _delta___8;
      } else {
#line 1064
        tmp___16 = 0;
      }
#line 1064
      _incr___8 = _n___8 + tmp___16;
#line 1064
      if ((size_t )_incr___8 >= maxsize - i___0) {
#line 1064
        return ((size_t )0);
      }
#line 1064
      if (p) {
#line 1064
        if (digits == 0) {
#line 1064
          if (_delta___8 > 0) {
#line 1064
            if (pad == 48) {
              {
#line 1064
              memset((void *)p, '0', (size_t )_delta___8);
#line 1064
              p += _delta___8;
              }
            } else {
              {
#line 1064
              memset((void *)p, ' ', (size_t )_delta___8);
#line 1064
              p += _delta___8;
              }
            }
          }
        }
#line 1064
        *p = (char )'\n';
#line 1064
        p += _n___8;
      }
#line 1064
      i___0 += (size_t )_incr___8;
#line 1064
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1065
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1068
    to_lowcase = (_Bool)1;
#line 1070
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1075
    if (change_case) {
#line 1077
      to_uppcase = (_Bool)0;
#line 1078
      to_lowcase = (_Bool)1;
    }
#line 1084
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1088
    subfmt = "%H:%M";
#line 1089
    goto subformat;
    case_114: /* CIL Label */ 
#line 1099
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1103
    if (modifier == 69) {
#line 1104
      goto bad_format;
    }
#line 1106
    digits = 2;
#line 1106
    number_value = (int )tp->tm_sec;
#line 1106
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1113
    ltm = (struct tm )*tp;
#line 1114
    t = mktime(& ltm);
#line 1119
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1120
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1122
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1124
      d = (int )(t % 10L);
#line 1125
      t /= 10L;
#line 1126
      bufp --;
#line 1126
      if (negative_number) {
#line 1126
        tmp___17 = - d;
      } else {
#line 1126
        tmp___17 = d;
      }
#line 1126
      *bufp = (char )(tmp___17 + 48);
#line 1122
      if (! (t != 0L)) {
#line 1122
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1130
    digits = 1;
#line 1131
    always_output_a_sign = (_Bool)0;
#line 1132
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1136
    if (modifier == 79) {
#line 1137
      goto bad_format;
    }
#line 1146
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1149
    subfmt = "%H:%M:%S";
#line 1150
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1153
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1153
      _n___9 = 1;
#line 1153
      _delta___9 = width - _n___9;
#line 1153
      if (_delta___9 > 0) {
#line 1153
        tmp___18 = _delta___9;
      } else {
#line 1153
        tmp___18 = 0;
      }
#line 1153
      _incr___9 = _n___9 + tmp___18;
#line 1153
      if ((size_t )_incr___9 >= maxsize - i___0) {
#line 1153
        return ((size_t )0);
      }
#line 1153
      if (p) {
#line 1153
        if (digits == 0) {
#line 1153
          if (_delta___9 > 0) {
#line 1153
            if (pad == 48) {
              {
#line 1153
              memset((void *)p, '0', (size_t )_delta___9);
#line 1153
              p += _delta___9;
              }
            } else {
              {
#line 1153
              memset((void *)p, ' ', (size_t )_delta___9);
#line 1153
              p += _delta___9;
              }
            }
          }
        }
#line 1153
        *p = (char )'\t';
#line 1153
        p += _n___9;
      }
#line 1153
      i___0 += (size_t )_incr___9;
#line 1153
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1154
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1157
    digits = 1;
#line 1157
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1157
    goto do_number;
    case_85: /* CIL Label */ 
#line 1160
    if (modifier == 69) {
#line 1161
      goto bad_format;
    }
#line 1163
    digits = 2;
#line 1163
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1163
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1168
    if (modifier == 69) {
#line 1169
      goto bad_format;
    }
#line 1175
    if (tp->tm_year < 0) {
#line 1175
      tmp___19 = 300;
    } else {
#line 1175
      tmp___19 = -100;
    }
    {
#line 1175
    year = (int )(tp->tm_year + (int const   )tmp___19);
#line 1179
    year_adjust = 0;
#line 1180
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1180
    days = tmp___20;
    }
#line 1182
    if (days < 0) {
#line 1185
      year_adjust = -1;
#line 1186
      if ((year - 1) % 4 == 0) {
#line 1186
        if ((year - 1) % 100 != 0) {
#line 1186
          tmp___21 = 1;
        } else
#line 1186
        if ((year - 1) % 400 == 0) {
#line 1186
          tmp___21 = 1;
        } else {
#line 1186
          tmp___21 = 0;
        }
      } else {
#line 1186
        tmp___21 = 0;
      }
      {
#line 1186
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1191
      if (year % 4 == 0) {
#line 1191
        if (year % 100 != 0) {
#line 1191
          tmp___22 = 1;
        } else
#line 1191
        if (year % 400 == 0) {
#line 1191
          tmp___22 = 1;
        } else {
#line 1191
          tmp___22 = 0;
        }
      } else {
#line 1191
        tmp___22 = 0;
      }
      {
#line 1191
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1191
      d___0 = tmp___23;
      }
#line 1193
      if (0 <= d___0) {
#line 1196
        year_adjust = 1;
#line 1197
        days = d___0;
      }
    }
    {
#line 1203
    if ((int const   )*f == 103) {
#line 1203
      goto case_103___0;
    }
#line 1213
    if ((int const   )*f == 71) {
#line 1213
      goto case_71___0;
    }
#line 1218
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1205
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1206
    digits = 2;
#line 1206
    if (0 <= yy) {
#line 1206
      number_value = yy;
    } else {
#line 1206
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1206
        tmp___24 = - yy;
      } else {
#line 1206
        tmp___24 = yy + 100;
      }
#line 1206
      number_value = tmp___24;
    }
#line 1206
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1214
    digits = 4;
#line 1214
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1214
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1214
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1219
    digits = 2;
#line 1219
    number_value = days / 7 + 1;
#line 1219
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1224
    if (modifier == 69) {
#line 1225
      goto bad_format;
    }
#line 1227
    digits = 2;
#line 1227
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1227
    goto do_number;
    case_119: /* CIL Label */ 
#line 1230
    if (modifier == 69) {
#line 1231
      goto bad_format;
    }
#line 1233
    digits = 1;
#line 1233
    number_value = (int )tp->tm_wday;
#line 1233
    goto do_number;
    case_89: /* CIL Label */ 
#line 1236
    if (modifier == 69) {
#line 1250
      goto underlying_strftime;
    }
#line 1253
    if (modifier == 79) {
#line 1254
      goto bad_format;
    } else {
#line 1256
      digits = 4;
    }
#line 1256
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1256
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1256
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1260
    if (modifier == 69) {
#line 1271
      goto underlying_strftime;
    }
#line 1276
    yy___0 = (int )(tp->tm_year % 100);
#line 1277
    if (yy___0 < 0) {
#line 1278
      if (tp->tm_year < -1900) {
#line 1278
        yy___0 = - yy___0;
      } else {
#line 1278
        yy___0 += 100;
      }
    }
#line 1279
    digits = 2;
#line 1279
    number_value = yy___0;
#line 1279
    goto do_number;
    case_90: /* CIL Label */ 
#line 1283
    if (change_case) {
#line 1285
      to_uppcase = (_Bool)0;
#line 1286
      to_lowcase = (_Bool)1;
    }
#line 1294
    if (! zone) {
#line 1295
      zone = "";
    }
    {
#line 1307
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1307
      tmp___25 = strlen(zone);
#line 1307
      _n___10 = (int )tmp___25;
#line 1307
      _delta___10 = width - _n___10;
      }
#line 1307
      if (_delta___10 > 0) {
#line 1307
        tmp___26 = _delta___10;
      } else {
#line 1307
        tmp___26 = 0;
      }
#line 1307
      _incr___10 = _n___10 + tmp___26;
#line 1307
      if ((size_t )_incr___10 >= maxsize - i___0) {
#line 1307
        return ((size_t )0);
      }
#line 1307
      if (p) {
#line 1307
        if (digits == 0) {
#line 1307
          if (_delta___10 > 0) {
#line 1307
            if (pad == 48) {
              {
#line 1307
              memset((void *)p, '0', (size_t )_delta___10);
#line 1307
              p += _delta___10;
              }
            } else {
              {
#line 1307
              memset((void *)p, ' ', (size_t )_delta___10);
#line 1307
              p += _delta___10;
              }
            }
          }
        }
#line 1307
        if (to_lowcase) {
          {
#line 1307
          memcpy_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1307
        if (to_uppcase) {
          {
#line 1307
          memcpy_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1307
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 (size_t )_n___10);
          }
        }
#line 1307
        p += _n___10;
      }
#line 1307
      i___0 += (size_t )_incr___10;
#line 1307
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1309
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1314
    colons = (size_t )1;
    {
#line 1314
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1314
      if (! ((int const   )*(f + colons) == 58)) {
#line 1314
        goto while_break___17;
      }
#line 1315
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1314
      colons ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1316
    if ((int const   )*(f + colons) != 122) {
#line 1317
      goto bad_format;
    }
#line 1318
    f += colons;
#line 1319
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1322
    colons = (size_t )0;
    do_z_conversion: 
#line 1325
    if (tp->tm_isdst < 0) {
#line 1326
      goto switch_break___1;
    }
#line 1334
    diff = (int )tp->tm_gmtoff;
#line 1371
    hour_diff = (diff / 60) / 60;
#line 1372
    min_diff = (diff / 60) % 60;
#line 1373
    sec_diff = diff % 60;
    {
#line 1377
    if (colons == 0U) {
#line 1377
      goto case_0;
    }
#line 1380
    if (colons == 1U) {
#line 1380
      goto tz_hh_mm;
    }
#line 1383
    if (colons == 2U) {
#line 1383
      goto tz_hh_mm_ss;
    }
#line 1387
    if (colons == 3U) {
#line 1387
      goto case_3;
    }
#line 1394
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1378
    digits = 5;
#line 1378
    negative_number = (_Bool )(diff < 0);
#line 1378
    tz_colon_mask = 0;
#line 1378
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1378
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1381
    digits = 6;
#line 1381
    negative_number = (_Bool )(diff < 0);
#line 1381
    tz_colon_mask = 4;
#line 1381
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1381
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1384
    digits = 9;
#line 1384
    negative_number = (_Bool )(diff < 0);
#line 1384
    tz_colon_mask = 20;
#line 1384
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1384
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1388
    if (sec_diff != 0) {
#line 1389
      goto tz_hh_mm_ss;
    }
#line 1390
    if (min_diff != 0) {
#line 1391
      goto tz_hh_mm;
    }
#line 1392
    digits = 3;
#line 1392
    negative_number = (_Bool )(diff < 0);
#line 1392
    tz_colon_mask = 0;
#line 1392
    u_number_value = (unsigned int )hour_diff;
#line 1392
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1395
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1400
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1409
    flen = 1;
    {
#line 1409
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1409
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1409
        goto while_break___18;
      }
#line 1410
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1409
      flen ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1411
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1411
      _n___11 = flen;
#line 1411
      _delta___11 = width - _n___11;
#line 1411
      if (_delta___11 > 0) {
#line 1411
        tmp___27 = _delta___11;
      } else {
#line 1411
        tmp___27 = 0;
      }
#line 1411
      _incr___11 = _n___11 + tmp___27;
#line 1411
      if ((size_t )_incr___11 >= maxsize - i___0) {
#line 1411
        return ((size_t )0);
      }
#line 1411
      if (p) {
#line 1411
        if (digits == 0) {
#line 1411
          if (_delta___11 > 0) {
#line 1411
            if (pad == 48) {
              {
#line 1411
              memset((void *)p, '0', (size_t )_delta___11);
#line 1411
              p += _delta___11;
              }
            } else {
              {
#line 1411
              memset((void *)p, ' ', (size_t )_delta___11);
#line 1411
              p += _delta___11;
              }
            }
          }
        }
#line 1411
        if (to_lowcase) {
          {
#line 1411
          memcpy_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1411
        if (to_uppcase) {
          {
#line 1411
          memcpy_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1411
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 (size_t )_n___11);
          }
        }
#line 1411
        p += _n___11;
      }
#line 1411
      i___0 += (size_t )_incr___11;
#line 1411
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1413
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 494
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1418
  if (p) {
#line 1418
    if (maxsize != 0U) {
#line 1419
      *p = (char )'\000';
    }
  }
#line 1422
  return (i___0);
}
}
#line 1431 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1436
  tmp = strftime_case_((_Bool)0, s, maxsize, format, tp, ut, ns);
  }
#line 1436
  return (tmp);
}
}
#line 191 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 192
enum quoting_style  const  quoting_style_vals[8] ;
#line 202
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 205
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 209
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 216
int set_char_quoting(struct quoting_options *o , char c , int i___0 ) ;
#line 222
int set_quoting_flags(struct quoting_options *o , int i___0 ) ;
#line 235
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 242
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 251
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 261
char *quotearg_n(int n , char const   *arg ) ;
#line 264
char *quotearg(char const   *arg ) ;
#line 269
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 272
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 277
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 282
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 286
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 289
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 293
char *quotearg_char(char const   *arg , char ch ) ;
#line 296
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 299
char *quotearg_colon(char const   *arg ) ;
#line 302
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 305
void quotearg_free(void) ;
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 122
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 122 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 125
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 125
    tmp = -1;
  } else {
#line 125
    tmp = -2;
  }
#line 125
  if ((size_t )tmp / s < n) {
    {
#line 126
    xalloc_die();
    }
  }
  {
#line 127
  tmp___0 = xmalloc(n * s);
  }
#line 127
  return (tmp___0);
}
}
#line 233
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 234
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 234 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 237
  if (sizeof(char ) == 1UL) {
    {
#line 237
    tmp = xmalloc(n);
#line 237
    tmp___1 = tmp;
    }
  } else {
    {
#line 237
    tmp___0 = xnmalloc(n, (size_t )sizeof(char ));
#line 237
    tmp___1 = tmp___0;
    }
  }
#line 237
  return ((char *)tmp___1);
}
}
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 76
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 94 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 97
  tmp = __errno_location();
#line 97
  e = *tmp;
  }
#line 98
  if (o) {
#line 98
    tmp___0 = o;
  } else {
#line 98
    tmp___0 = & default_quoting_options;
  }
  {
#line 98
  tmp___1 = xmemdup((void const   *)tmp___0, (size_t )sizeof(*o));
#line 98
  p = (struct quoting_options *)tmp___1;
#line 100
  tmp___2 = __errno_location();
#line 100
  *tmp___2 = e;
  }
#line 101
  return (p);
}
}
#line 105 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 108
  if (o) {
#line 108
    tmp = o;
  } else {
#line 108
    tmp = & default_quoting_options;
  }
#line 108
  return (tmp->style);
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 116
  if (o) {
#line 116
    tmp = o;
  } else {
#line 116
    tmp = & default_quoting_options;
  }
#line 116
  tmp->style = s;
#line 117
  return;
}
}
#line 124 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i___0 ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 127
  uc = (unsigned char )c;
#line 128
  if (o) {
#line 128
    tmp = o;
  } else {
#line 128
    tmp = & default_quoting_options;
  }
#line 128
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 130
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 131
  r = (int )((*p >> shift) & 1U);
#line 132
  *p ^= (unsigned int )(((i___0 & 1) ^ r) << shift);
#line 133
  return (r);
}
}
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i___0 ) 
{ 
  int r ;

  {
#line 144
  if (! o) {
#line 145
    o = & default_quoting_options;
  }
#line 146
  r = o->flags;
#line 147
  o->flags = i___0;
#line 148
  return (r);
}
}
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 156
  o.style = style;
#line 157
  o.flags = 0;
#line 158
  memset((void *)(o.quote_these_too), 0, (size_t )sizeof(o.quote_these_too));
  }
#line 159
  return (o);
}
}
#line 164 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 167
  tmp = gettext(msgid);
#line 167
  translation = (char const   *)tmp;
  }
#line 168
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 168
    if ((unsigned int )s == 7U) {
#line 169
      translation = "\"";
    }
  }
#line 170
  return (translation);
}
}
#line 186 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ) 
{ 
  size_t i___0 ;
  size_t len___0 ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  char const   *left ;
  char const   *tmp___0 ;
  char const   *right ;
  char const   *tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___2 ;
  int tmp___3 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___4 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___5 ;
  size_t j ;
  int tmp___6 ;
  int tmp___7 ;
  size_t ilim ;
  int tmp___8 ;
  size_t tmp___9 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 193
  len___0 = (size_t )0;
#line 194
  quote_string = (char const   *)0;
#line 195
  quote_string_len = (size_t )0;
#line 196
  backslash_escapes = (_Bool)0;
#line 197
  tmp = __ctype_get_mb_cur_max();
#line 197
  unibyte_locale = (_Bool )(tmp == 1U);
#line 198
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 211
  if ((unsigned int )quoting_style == 4U) {
#line 211
    goto case_4;
  }
#line 215
  if ((unsigned int )quoting_style == 3U) {
#line 215
    goto case_3;
  }
#line 223
  if ((unsigned int )quoting_style == 5U) {
#line 223
    goto case_5;
  }
#line 229
  if ((unsigned int )quoting_style == 7U) {
#line 229
    goto case_7;
  }
#line 229
  if ((unsigned int )quoting_style == 6U) {
#line 229
    goto case_7;
  }
#line 262
  if ((unsigned int )quoting_style == 1U) {
#line 262
    goto case_1;
  }
#line 266
  if ((unsigned int )quoting_style == 2U) {
#line 266
    goto case_2;
  }
#line 273
  if ((unsigned int )quoting_style == 0U) {
#line 273
    goto case_0;
  }
#line 277
  goto switch_default;
  case_4: /* CIL Label */ 
#line 212
  quoting_style = (enum quoting_style )3;
#line 213
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 216
  if (! elide_outer_quotes) {
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
#line 217
      if (len___0 < buffersize) {
#line 217
        *(buffer + len___0) = (char )'\"';
      }
#line 217
      len___0 ++;
#line 217
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 218
  backslash_escapes = (_Bool)1;
#line 219
  quote_string = "\"";
#line 220
  quote_string_len = (size_t )1;
#line 221
  goto switch_break;
  case_5: /* CIL Label */ 
#line 224
  backslash_escapes = (_Bool)1;
#line 225
  elide_outer_quotes = (_Bool)0;
#line 226
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 251
  tmp___0 = gettext_quote("`", quoting_style);
#line 251
  left = tmp___0;
#line 252
  tmp___1 = gettext_quote("\'", quoting_style);
#line 252
  right = tmp___1;
  }
#line 253
  if (! elide_outer_quotes) {
#line 254
    quote_string = left;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! *quote_string) {
#line 254
        goto while_break___0;
      }
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        if (len___0 < buffersize) {
#line 255
          *(buffer + len___0) = (char )*quote_string;
        }
#line 255
        len___0 ++;
#line 255
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 254
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 256
  backslash_escapes = (_Bool)1;
#line 257
  quote_string = right;
#line 258
  quote_string_len = strlen(quote_string);
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  quoting_style = (enum quoting_style )2;
#line 264
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 267
  if (! elide_outer_quotes) {
    {
#line 268
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 268
      if (len___0 < buffersize) {
#line 268
        *(buffer + len___0) = (char )'\'';
      }
#line 268
      len___0 ++;
#line 268
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 269
  quote_string = "\'";
#line 270
  quote_string_len = (size_t )1;
#line 271
  goto switch_break;
  case_0: /* CIL Label */ 
#line 274
  elide_outer_quotes = (_Bool)0;
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 278
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 281
  i___0 = (size_t )0;
  {
#line 281
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 281
    if (argsize == 4294967295U) {
#line 281
      tmp___8 = (int const   )*(arg + i___0) == 0;
    } else {
#line 281
      tmp___8 = i___0 == argsize;
    }
#line 281
    if (tmp___8) {
#line 281
      goto while_break___3;
    }
#line 286
    if (backslash_escapes) {
#line 286
      if (quote_string_len) {
#line 286
        if (i___0 + quote_string_len <= argsize) {
          {
#line 286
          tmp___2 = memcmp((void const   *)(arg + i___0), (void const   *)quote_string,
                           quote_string_len);
          }
#line 286
          if (tmp___2 == 0) {
#line 291
            if (elide_outer_quotes) {
#line 292
              goto force_outer_quoting_style;
            }
            {
#line 293
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 293
              if (len___0 < buffersize) {
#line 293
                *(buffer + len___0) = (char )'\\';
              }
#line 293
              len___0 ++;
#line 293
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 296
    c = (unsigned char )*(arg + i___0);
    {
#line 299
    if ((int )c == 0) {
#line 299
      goto case_0___0;
    }
#line 316
    if ((int )c == 63) {
#line 316
      goto case_63;
    }
#line 354
    if ((int )c == 7) {
#line 354
      goto case_7___0;
    }
#line 355
    if ((int )c == 8) {
#line 355
      goto case_8;
    }
#line 356
    if ((int )c == 12) {
#line 356
      goto case_12;
    }
#line 357
    if ((int )c == 10) {
#line 357
      goto case_10;
    }
#line 358
    if ((int )c == 13) {
#line 358
      goto case_13;
    }
#line 359
    if ((int )c == 9) {
#line 359
      goto case_9;
    }
#line 360
    if ((int )c == 11) {
#line 360
      goto case_11;
    }
#line 361
    if ((int )c == 92) {
#line 361
      goto case_92;
    }
#line 380
    if ((int )c == 125) {
#line 380
      goto case_125;
    }
#line 380
    if ((int )c == 123) {
#line 380
      goto case_125;
    }
#line 384
    if ((int )c == 126) {
#line 384
      goto case_126;
    }
#line 384
    if ((int )c == 35) {
#line 384
      goto case_126;
    }
#line 396
    if ((int )c == 124) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 96) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 94) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 91) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 62) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 61) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 60) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 59) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 42) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 41) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 40) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 38) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 36) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 34) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 33) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 32) {
#line 396
      goto case_124;
    }
#line 406
    if ((int )c == 39) {
#line 406
      goto case_39___0;
    }
#line 428
    if ((int )c == 122) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 121) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 120) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 119) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 118) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 117) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 116) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 115) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 114) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 113) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 112) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 111) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 110) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 109) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 108) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 107) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 106) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 105) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 104) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 103) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 102) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 101) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 100) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 99) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 98) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 97) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 95) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 93) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 90) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 89) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 88) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 87) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 86) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 85) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 84) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 83) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 82) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 81) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 80) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 79) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 78) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 77) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 76) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 75) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 74) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 73) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 72) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 71) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 70) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 69) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 68) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 67) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 66) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 65) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 58) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 57) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 56) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 55) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 54) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 53) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 52) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 51) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 50) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 49) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 48) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 47) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 46) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 45) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 44) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 43) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 37) {
#line 428
      goto case_122;
    }
#line 433
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 300
    if (backslash_escapes) {
#line 302
      if (elide_outer_quotes) {
#line 303
        goto force_outer_quoting_style;
      }
      {
#line 304
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 304
        if (len___0 < buffersize) {
#line 304
          *(buffer + len___0) = (char )'\\';
        }
#line 304
        len___0 ++;
#line 304
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 305
      if (i___0 + 1U < argsize) {
#line 305
        if (48 <= (int )*(arg + (i___0 + 1U))) {
#line 305
          if ((int const   )*(arg + (i___0 + 1U)) <= 57) {
            {
#line 307
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 307
              if (len___0 < buffersize) {
#line 307
                *(buffer + len___0) = (char )'0';
              }
#line 307
              len___0 ++;
#line 307
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 308
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 308
              if (len___0 < buffersize) {
#line 308
                *(buffer + len___0) = (char )'0';
              }
#line 308
              len___0 ++;
#line 308
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 310
      c = (unsigned char )'0';
    } else
#line 312
    if (flags & 1) {
#line 313
      goto __Cont;
    }
#line 314
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 319
    if ((unsigned int )quoting_style == 2U) {
#line 319
      goto case_2___0;
    }
#line 324
    if ((unsigned int )quoting_style == 3U) {
#line 324
      goto case_3___0;
    }
#line 349
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 320
    if (elide_outer_quotes) {
#line 321
      goto force_outer_quoting_style;
    }
#line 322
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 325
    if (flags & 4) {
#line 325
      if (i___0 + 2U < argsize) {
#line 325
        if ((int const   )*(arg + (i___0 + 1U)) == 63) {
          {
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 62) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 61) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 60) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 47) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 45) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 41) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 40) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 39) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i___0 + 2U)) == 33) {
#line 331
            goto case_62;
          }
#line 344
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 334
          if (elide_outer_quotes) {
#line 335
            goto force_outer_quoting_style;
          }
#line 336
          c = (unsigned char )*(arg + (i___0 + 2U));
#line 337
          i___0 += 2U;
          {
#line 338
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 338
            if (len___0 < buffersize) {
#line 338
              *(buffer + len___0) = (char )'?';
            }
#line 338
            len___0 ++;
#line 338
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 339
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 339
            if (len___0 < buffersize) {
#line 339
              *(buffer + len___0) = (char )'\"';
            }
#line 339
            len___0 ++;
#line 339
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 340
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 340
            if (len___0 < buffersize) {
#line 340
              *(buffer + len___0) = (char )'\"';
            }
#line 340
            len___0 ++;
#line 340
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 341
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 341
            if (len___0 < buffersize) {
#line 341
              *(buffer + len___0) = (char )'?';
            }
#line 341
            len___0 ++;
#line 341
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 342
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 345
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 347
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 350
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 352
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 354
    esc = (unsigned char )'a';
#line 354
    goto c_escape;
    case_8: /* CIL Label */ 
#line 355
    esc = (unsigned char )'b';
#line 355
    goto c_escape;
    case_12: /* CIL Label */ 
#line 356
    esc = (unsigned char )'f';
#line 356
    goto c_escape;
    case_10: /* CIL Label */ 
#line 357
    esc = (unsigned char )'n';
#line 357
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 358
    esc = (unsigned char )'r';
#line 358
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 359
    esc = (unsigned char )'t';
#line 359
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 360
    esc = (unsigned char )'v';
#line 360
    goto c_escape;
    case_92: /* CIL Label */ 
#line 361
    esc = c;
#line 364
    if (backslash_escapes) {
#line 364
      if (elide_outer_quotes) {
#line 364
        if (quote_string_len) {
#line 365
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 368
    if ((unsigned int )quoting_style == 2U) {
#line 368
      if (elide_outer_quotes) {
#line 370
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 373
    if (backslash_escapes) {
#line 375
      c = esc;
#line 376
      goto store_escape;
    }
#line 378
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 381
    if (argsize == 4294967295U) {
#line 381
      tmp___3 = (int const   )*(arg + 1) == 0;
    } else {
#line 381
      tmp___3 = argsize == 1U;
    }
#line 381
    if (! tmp___3) {
#line 382
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 385
    if (i___0 != 0U) {
#line 386
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 401
    if ((unsigned int )quoting_style == 2U) {
#line 401
      if (elide_outer_quotes) {
#line 403
        goto force_outer_quoting_style;
      }
    }
#line 404
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 407
    if ((unsigned int )quoting_style == 2U) {
#line 409
      if (elide_outer_quotes) {
#line 410
        goto force_outer_quoting_style;
      }
      {
#line 411
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 411
        if (len___0 < buffersize) {
#line 411
          *(buffer + len___0) = (char )'\'';
        }
#line 411
        len___0 ++;
#line 411
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 412
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 412
        if (len___0 < buffersize) {
#line 412
          *(buffer + len___0) = (char )'\\';
        }
#line 412
        len___0 ++;
#line 412
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 413
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 413
        if (len___0 < buffersize) {
#line 413
          *(buffer + len___0) = (char )'\'';
        }
#line 413
        len___0 ++;
#line 413
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 415
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 431
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 445
    if (unibyte_locale) {
      {
#line 447
      m = (size_t )1;
#line 448
      tmp___4 = __ctype_b_loc();
#line 448
      printable = (_Bool )(((int const   )*(*tmp___4 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 453
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
#line 455
      m = (size_t )0;
#line 456
      printable = (_Bool)1;
      }
#line 457
      if (argsize == 4294967295U) {
        {
#line 458
        argsize = strlen(arg);
        }
      }
      {
#line 460
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 463
        tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i___0 + m)),
                          argsize - (i___0 + m), & mbstate);
#line 463
        bytes = tmp___5;
        }
#line 465
        if (bytes == 0U) {
#line 466
          goto while_break___15;
        } else
#line 467
        if (bytes == 4294967295U) {
#line 469
          printable = (_Bool)0;
#line 470
          goto while_break___15;
        } else
#line 472
        if (bytes == 4294967294U) {
#line 474
          printable = (_Bool)0;
          {
#line 475
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 475
            if (i___0 + m < argsize) {
#line 475
              if (! *(arg + (i___0 + m))) {
#line 475
                goto while_break___16;
              }
            } else {
#line 475
              goto while_break___16;
            }
#line 476
            m ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 477
          goto while_break___15;
        } else {
#line 485
          if (elide_outer_quotes) {
#line 485
            if ((unsigned int )quoting_style == 2U) {
#line 489
              j = (size_t )1;
              {
#line 489
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 489
                if (! (j < bytes)) {
#line 489
                  goto while_break___17;
                }
                {
#line 493
                if ((int const   )*(arg + ((i___0 + m) + j)) == 124) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i___0 + m) + j)) == 96) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i___0 + m) + j)) == 94) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i___0 + m) + j)) == 92) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i___0 + m) + j)) == 91) {
#line 493
                  goto case_124___0;
                }
#line 496
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 494
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 497
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 489
                j ++;
              }
              while_break___17: /* CIL Label */ ;
              }
            }
          }
          {
#line 501
          tmp___6 = iswprint((wint_t )w);
          }
#line 501
          if (! tmp___6) {
#line 502
            printable = (_Bool)0;
          }
#line 503
          m += bytes;
        }
        {
#line 460
        tmp___7 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 460
        if (tmp___7) {
#line 460
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 509
    if (1U < m) {
#line 509
      goto _L;
    } else
#line 509
    if (backslash_escapes) {
#line 509
      if (! printable) {
        _L: /* CIL Label */ 
#line 513
        ilim = i___0 + m;
        {
#line 515
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 517
          if (backslash_escapes) {
#line 517
            if (! printable) {
#line 519
              if (elide_outer_quotes) {
#line 520
                goto force_outer_quoting_style;
              }
              {
#line 521
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 521
                if (len___0 < buffersize) {
#line 521
                  *(buffer + len___0) = (char )'\\';
                }
#line 521
                len___0 ++;
#line 521
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 522
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 522
                if (len___0 < buffersize) {
#line 522
                  *(buffer + len___0) = (char )(48 + ((int )c >> 6));
                }
#line 522
                len___0 ++;
#line 522
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
              {
#line 523
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 523
                if (len___0 < buffersize) {
#line 523
                  *(buffer + len___0) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 523
                len___0 ++;
#line 523
                goto while_break___21;
              }
              while_break___21: /* CIL Label */ ;
              }
#line 524
              c = (unsigned char )(48 + ((int )c & 7));
            }
          }
#line 526
          if (ilim <= i___0 + 1U) {
#line 527
            goto while_break___18;
          }
          {
#line 528
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 528
            if (len___0 < buffersize) {
#line 528
              *(buffer + len___0) = (char )c;
            }
#line 528
            len___0 ++;
#line 528
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 529
          i___0 ++;
#line 529
          c = (unsigned char )*(arg + i___0);
        }
        while_break___18: /* CIL Label */ ;
        }
#line 532
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 537
    if (backslash_escapes) {
#line 537
      goto _L___0;
    } else
#line 537
    if (elide_outer_quotes) {
      _L___0: /* CIL Label */ 
#line 537
      if (quote_these_too) {
#line 537
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 540
          goto store_c;
        }
      } else {
#line 540
        goto store_c;
      }
    } else {
#line 540
      goto store_c;
    }
    store_escape: 
#line 543
    if (elide_outer_quotes) {
#line 544
      goto force_outer_quoting_style;
    }
    {
#line 545
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 545
      if (len___0 < buffersize) {
#line 545
        *(buffer + len___0) = (char )'\\';
      }
#line 545
      len___0 ++;
#line 545
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 548
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 548
      if (len___0 < buffersize) {
#line 548
        *(buffer + len___0) = (char )c;
      }
#line 548
      len___0 ++;
#line 548
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 281
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 551
  if (len___0 == 0U) {
#line 551
    if ((unsigned int )quoting_style == 2U) {
#line 551
      if (elide_outer_quotes) {
#line 553
        goto force_outer_quoting_style;
      }
    }
  }
#line 555
  if (quote_string) {
#line 555
    if (! elide_outer_quotes) {
      {
#line 556
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 556
        if (! *quote_string) {
#line 556
          goto while_break___25;
        }
        {
#line 557
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 557
          if (len___0 < buffersize) {
#line 557
            *(buffer + len___0) = (char )*quote_string;
          }
#line 557
          len___0 ++;
#line 557
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 556
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 559
  if (len___0 < buffersize) {
#line 560
    *(buffer + len___0) = (char )'\000';
  }
#line 561
  return (len___0);
  force_outer_quoting_style: 
  {
#line 566
  tmp___9 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0));
  }
#line 566
  return (tmp___9);
}
}
#line 580 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 585
  if (o) {
#line 585
    tmp = o;
  } else {
#line 585
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 585
  p = tmp;
#line 586
  tmp___0 = __errno_location();
#line 586
  e = *tmp___0;
#line 587
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too));
#line 587
  r = tmp___1;
#line 589
  tmp___2 = __errno_location();
#line 589
  *tmp___2 = e;
  }
#line 590
  return (r);
}
}
#line 594 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 598
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 598
  return (tmp);
}
}
#line 607 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf___1 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 611
  if (o) {
#line 611
    tmp = o;
  } else {
#line 611
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 611
  p = tmp;
#line 612
  tmp___0 = __errno_location();
#line 612
  e = *tmp___0;
  }
#line 614
  if (size) {
#line 614
    tmp___1 = 0;
  } else {
#line 614
    tmp___1 = 1;
  }
  {
#line 614
  flags = (int )(p->flags | (int const   )tmp___1);
#line 615
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too));
#line 615
  bufsize___0 = tmp___2 + 1U;
#line 617
  tmp___3 = xcharalloc(bufsize___0);
#line 617
  buf___1 = tmp___3;
#line 618
  quotearg_buffer_restyled(buf___1, bufsize___0, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too));
#line 620
  tmp___4 = __errno_location();
#line 620
  *tmp___4 = e;
  }
#line 621
  if (size) {
#line 622
    *size = bufsize___0 - 1U;
  }
#line 623
  return (buf___1);
}
}
#line 635 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static char slot0[256]  ;
#line 636 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static unsigned int nslots  =    1U;
#line 637 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct slotvec slotvec0  =    {(size_t )sizeof(slot0), slot0};
#line 638 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 640 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i___0 ;

  {
#line 643
  sv = slotvec;
#line 645
  i___0 = 1U;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! (i___0 < nslots)) {
#line 645
      goto while_break;
    }
    {
#line 646
    free((void *)(sv + i___0)->val);
#line 645
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 649
    free((void *)(sv + 0)->val);
#line 650
    slotvec0.size = (size_t )sizeof(slot0);
#line 651
    slotvec0.val = slot0;
    }
  }
#line 653
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 655
    free((void *)sv);
#line 656
    slotvec = & slotvec0;
    }
  }
#line 658
  nslots = 1U;
#line 659
  return;
}
}
#line 669 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 673
  tmp = __errno_location();
#line 673
  e = *tmp;
#line 675
  n0 = (unsigned int )n;
#line 676
  sv = slotvec;
  }
#line 678
  if (n < 0) {
    {
#line 679
    abort();
    }
  }
#line 681
  if (nslots <= n0) {
#line 688
    n1 = n0 + 1U;
#line 689
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 691
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 691
      tmp___0 = -1;
    } else {
#line 691
      tmp___0 = -2;
    }
#line 691
    if ((unsigned long )((size_t )tmp___0) / sizeof(*sv) < (unsigned long )n1) {
      {
#line 692
      xalloc_die();
      }
    }
#line 694
    if (preallocated) {
#line 694
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 694
      tmp___1 = sv;
    }
    {
#line 694
    tmp___2 = xrealloc((void *)tmp___1, (size_t )((unsigned long )n1 * sizeof(*sv)));
#line 694
    sv = (struct slotvec *)tmp___2;
#line 694
    slotvec = sv;
    }
#line 695
    if (preallocated) {
#line 696
      *sv = slotvec0;
    }
    {
#line 697
    memset((void *)(sv + nslots), 0, (size_t )((unsigned long )(n1 - nslots) * sizeof(*sv)));
#line 698
    nslots = n1;
    }
  }
  {
#line 702
  size = (sv + n)->size;
#line 703
  val = (sv + n)->val;
#line 705
  flags = (int )(options->flags | 1);
#line 706
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too));
#line 706
  qsize = tmp___3;
  }
#line 710
  if (size <= qsize) {
#line 712
    size = qsize + 1U;
#line 712
    (sv + n)->size = size;
#line 713
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 714
      free((void *)val);
      }
    }
    {
#line 715
    val = xcharalloc(size);
#line 715
    (sv + n)->val = val;
#line 716
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too));
    }
  }
  {
#line 720
  tmp___4 = __errno_location();
#line 720
  *tmp___4 = e;
  }
#line 721
  return (val);
}
}
#line 725 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 728
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 728
  return (tmp);
}
}
#line 731 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 734
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 734
  return (tmp);
}
}
#line 737 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 740
  tmp = quotearg_n(0, arg);
  }
#line 740
  return (tmp);
}
}
#line 743 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 746
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 746
  return (tmp);
}
}
#line 749 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 752
  tmp = quoting_options_from_style(s);
#line 752
  o = tmp;
#line 753
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 753
  return (tmp___0);
}
}
#line 756 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 760
  tmp = quoting_options_from_style(s);
#line 760
  o = tmp;
#line 761
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 761
  return (tmp___0);
}
}
#line 764 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 767
  tmp = quotearg_n_style(0, s, arg);
  }
#line 767
  return (tmp);
}
}
#line 770 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 773
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 773
  return (tmp);
}
}
#line 776 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 780
  options = default_quoting_options;
#line 781
  set_char_quoting(& options, ch, 1);
#line 782
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 782
  return (tmp);
}
}
#line 785 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 788
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 788
  return (tmp);
}
}
#line 791 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 794
  tmp = quotearg_char(arg, (char )':');
  }
#line 794
  return (tmp);
}
}
#line 797 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 800
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 800
  return (tmp);
}
}
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 23
char const   *quote(char const   *name ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 33
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 33
  return ((char const   *)tmp);
}
}
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 41
  tmp = quote_n(0, name);
  }
#line 41
  return (tmp);
}
}
#line 82 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *tmp ;
  char c ;
  char const   *tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___3 ;
  size_t __attribute__((__pure__))  tmp___4 ;
  size_t tmp___5 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___11 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t tmp___13 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;

  {
  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )1;
#line 94
  tmp = malloc((size_t )((unsigned long )d_allocated * sizeof(char_directive )));
#line 94
  d->dir = (char_directive *)tmp;
  }
#line 95
  if ((unsigned long )d->dir == (unsigned long )((void *)0)) {
#line 97
    goto out_of_memory_1;
  }
#line 99
  a->count = (size_t )0;
#line 100
  a_allocated = (size_t )0;
#line 101
  a->arg = (argument *)((void *)0);
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int const   )*cp != 0)) {
#line 135
      goto while_break;
    }
#line 137
    tmp___0 = cp;
#line 137
    cp ++;
#line 137
    c = (char )*tmp___0;
#line 138
    if ((int )c == 37) {
#line 140
      arg_index = ~ ((size_t )0);
#line 141
      dp = d->dir + d->count;
#line 144
      dp->dir_start = cp - 1;
#line 145
      dp->flags = 0;
#line 146
      dp->width_start = (char const   *)((void *)0);
#line 147
      dp->width_end = (char const   *)((void *)0);
#line 148
      dp->width_arg_index = ~ ((size_t )0);
#line 149
      dp->precision_start = (char const   *)((void *)0);
#line 150
      dp->precision_end = (char const   *)((void *)0);
#line 151
      dp->precision_arg_index = ~ ((size_t )0);
#line 152
      dp->arg_index = ~ ((size_t )0);
#line 155
      if ((int const   )*cp >= 48) {
#line 155
        if ((int const   )*cp <= 57) {
#line 159
          np = cp;
          {
#line 159
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 159
            if ((int const   )*np >= 48) {
#line 159
              if (! ((int const   )*np <= 57)) {
#line 159
                goto while_break___0;
              }
            } else {
#line 159
              goto while_break___0;
            }
#line 159
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 161
          if ((int const   )*np == 36) {
#line 163
            n = (size_t )0;
#line 165
            np = cp;
            {
#line 165
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 165
              if ((int const   )*np >= 48) {
#line 165
                if (! ((int const   )*np <= 57)) {
#line 165
                  goto while_break___1;
                }
              } else {
#line 165
                goto while_break___1;
              }
#line 166
              if (n <= 429496729U) {
#line 166
                tmp___1 = n * 10U;
              } else {
#line 166
                tmp___1 = 4294967295U;
              }
              {
#line 166
              tmp___2 = xsum(tmp___1, (size_t )((int const   )*np - 48));
#line 166
              n = (size_t )tmp___2;
#line 165
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 167
            if (n == 0U) {
#line 169
              goto error;
            }
#line 170
            if (n == 4294967295U) {
#line 172
              goto error;
            }
#line 173
            arg_index = n - 1U;
#line 174
            cp = np + 1;
          }
        }
      }
      {
#line 179
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 181
        if ((int const   )*cp == 39) {
#line 183
          dp->flags |= 1;
#line 184
          cp ++;
        } else
#line 186
        if ((int const   )*cp == 45) {
#line 188
          dp->flags |= 2;
#line 189
          cp ++;
        } else
#line 191
        if ((int const   )*cp == 43) {
#line 193
          dp->flags |= 4;
#line 194
          cp ++;
        } else
#line 196
        if ((int const   )*cp == 32) {
#line 198
          dp->flags |= 8;
#line 199
          cp ++;
        } else
#line 201
        if ((int const   )*cp == 35) {
#line 203
          dp->flags |= 16;
#line 204
          cp ++;
        } else
#line 206
        if ((int const   )*cp == 48) {
#line 208
          dp->flags |= 32;
#line 209
          cp ++;
        } else {
#line 212
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      if ((int const   )*cp == 42) {
#line 218
        dp->width_start = cp;
#line 219
        cp ++;
#line 220
        dp->width_end = cp;
#line 221
        if (max_width_length < 1U) {
#line 222
          max_width_length = (size_t )1;
        }
#line 225
        if ((int const   )*cp >= 48) {
#line 225
          if ((int const   )*cp <= 57) {
#line 229
            np___0 = cp;
            {
#line 229
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 229
              if ((int const   )*np___0 >= 48) {
#line 229
                if (! ((int const   )*np___0 <= 57)) {
#line 229
                  goto while_break___3;
                }
              } else {
#line 229
                goto while_break___3;
              }
#line 229
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 231
            if ((int const   )*np___0 == 36) {
#line 233
              n___0 = (size_t )0;
#line 235
              np___0 = cp;
              {
#line 235
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 235
                if ((int const   )*np___0 >= 48) {
#line 235
                  if (! ((int const   )*np___0 <= 57)) {
#line 235
                    goto while_break___4;
                  }
                } else {
#line 235
                  goto while_break___4;
                }
#line 236
                if (n___0 <= 429496729U) {
#line 236
                  tmp___3 = n___0 * 10U;
                } else {
#line 236
                  tmp___3 = 4294967295U;
                }
                {
#line 236
                tmp___4 = xsum(tmp___3, (size_t )((int const   )*np___0 - 48));
#line 236
                n___0 = (size_t )tmp___4;
#line 235
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 237
              if (n___0 == 0U) {
#line 239
                goto error;
              }
#line 240
              if (n___0 == 4294967295U) {
#line 242
                goto error;
              }
#line 243
              dp->width_arg_index = n___0 - 1U;
#line 244
              cp = np___0 + 1;
            }
          }
        }
#line 247
        if (dp->width_arg_index == 4294967295U) {
#line 249
          tmp___5 = arg_posn;
#line 249
          arg_posn ++;
#line 249
          dp->width_arg_index = tmp___5;
#line 250
          if (dp->width_arg_index == 4294967295U) {
#line 252
            goto error;
          }
        }
#line 254
        n___1 = dp->width_arg_index;
#line 254
        if (n___1 >= a_allocated) {
#line 254
          if (a_allocated <= 2147483647U) {
#line 254
            a_allocated *= 2U;
          } else {
#line 254
            a_allocated = 4294967295U;
          }
#line 254
          if (a_allocated <= n___1) {
            {
#line 254
            tmp___6 = xsum(n___1, (size_t )1);
#line 254
            a_allocated = (size_t )tmp___6;
            }
          }
#line 254
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 254
            memory_size = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 254
            memory_size = 4294967295U;
          }
#line 254
          if (memory_size == 4294967295U) {
#line 254
            goto out_of_memory;
          }
#line 254
          if (a->arg) {
            {
#line 254
            tmp___7 = realloc((void *)a->arg, memory_size);
#line 254
            tmp___9 = tmp___7;
            }
          } else {
            {
#line 254
            tmp___8 = malloc(memory_size);
#line 254
            tmp___9 = tmp___8;
            }
          }
#line 254
          memory = (argument *)tmp___9;
#line 254
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 254
            goto out_of_memory;
          }
#line 254
          a->arg = memory;
        }
        {
#line 254
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 254
          if (! (a->count <= n___1)) {
#line 254
            goto while_break___5;
          }
#line 254
          tmp___10 = a->count;
#line 254
          (a->count) ++;
#line 254
          (a->arg + tmp___10)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 254
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 254
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 254
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 254
          goto error;
        }
      } else
#line 256
      if ((int const   )*cp >= 48) {
#line 256
        if ((int const   )*cp <= 57) {
#line 260
          dp->width_start = cp;
          {
#line 261
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 261
            if ((int const   )*cp >= 48) {
#line 261
              if (! ((int const   )*cp <= 57)) {
#line 261
                goto while_break___6;
              }
            } else {
#line 261
              goto while_break___6;
            }
#line 261
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 263
          dp->width_end = cp;
#line 264
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 265
          if (max_width_length < width_length) {
#line 266
            max_width_length = width_length;
          }
        }
      }
#line 270
      if ((int const   )*cp == 46) {
#line 272
        cp ++;
#line 273
        if ((int const   )*cp == 42) {
#line 275
          dp->precision_start = cp - 1;
#line 276
          cp ++;
#line 277
          dp->precision_end = cp;
#line 278
          if (max_precision_length < 2U) {
#line 279
            max_precision_length = (size_t )2;
          }
#line 282
          if ((int const   )*cp >= 48) {
#line 282
            if ((int const   )*cp <= 57) {
#line 286
              np___1 = cp;
              {
#line 286
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 286
                if ((int const   )*np___1 >= 48) {
#line 286
                  if (! ((int const   )*np___1 <= 57)) {
#line 286
                    goto while_break___7;
                  }
                } else {
#line 286
                  goto while_break___7;
                }
#line 286
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 288
              if ((int const   )*np___1 == 36) {
#line 290
                n___2 = (size_t )0;
#line 292
                np___1 = cp;
                {
#line 292
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 292
                  if ((int const   )*np___1 >= 48) {
#line 292
                    if (! ((int const   )*np___1 <= 57)) {
#line 292
                      goto while_break___8;
                    }
                  } else {
#line 292
                    goto while_break___8;
                  }
#line 293
                  if (n___2 <= 429496729U) {
#line 293
                    tmp___11 = n___2 * 10U;
                  } else {
#line 293
                    tmp___11 = 4294967295U;
                  }
                  {
#line 293
                  tmp___12 = xsum(tmp___11, (size_t )((int const   )*np___1 - 48));
#line 293
                  n___2 = (size_t )tmp___12;
#line 292
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 294
                if (n___2 == 0U) {
#line 296
                  goto error;
                }
#line 297
                if (n___2 == 4294967295U) {
#line 300
                  goto error;
                }
#line 301
                dp->precision_arg_index = n___2 - 1U;
#line 302
                cp = np___1 + 1;
              }
            }
          }
#line 305
          if (dp->precision_arg_index == 4294967295U) {
#line 307
            tmp___13 = arg_posn;
#line 307
            arg_posn ++;
#line 307
            dp->precision_arg_index = tmp___13;
#line 308
            if (dp->precision_arg_index == 4294967295U) {
#line 310
              goto error;
            }
          }
#line 312
          n___3 = dp->precision_arg_index;
#line 312
          if (n___3 >= a_allocated) {
#line 312
            if (a_allocated <= 2147483647U) {
#line 312
              a_allocated *= 2U;
            } else {
#line 312
              a_allocated = 4294967295U;
            }
#line 312
            if (a_allocated <= n___3) {
              {
#line 312
              tmp___14 = xsum(n___3, (size_t )1);
#line 312
              a_allocated = (size_t )tmp___14;
              }
            }
#line 312
            if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 312
              memory_size___0 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
            } else {
#line 312
              memory_size___0 = 4294967295U;
            }
#line 312
            if (memory_size___0 == 4294967295U) {
#line 312
              goto out_of_memory;
            }
#line 312
            if (a->arg) {
              {
#line 312
              tmp___15 = realloc((void *)a->arg, memory_size___0);
#line 312
              tmp___17 = tmp___15;
              }
            } else {
              {
#line 312
              tmp___16 = malloc(memory_size___0);
#line 312
              tmp___17 = tmp___16;
              }
            }
#line 312
            memory___0 = (argument *)tmp___17;
#line 312
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 312
              goto out_of_memory;
            }
#line 312
            a->arg = memory___0;
          }
          {
#line 312
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 312
            if (! (a->count <= n___3)) {
#line 312
              goto while_break___9;
            }
#line 312
            tmp___18 = a->count;
#line 312
            (a->count) ++;
#line 312
            (a->arg + tmp___18)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 312
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 312
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 312
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 312
            goto error;
          }
        } else {
#line 318
          dp->precision_start = cp - 1;
          {
#line 319
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 319
            if ((int const   )*cp >= 48) {
#line 319
              if (! ((int const   )*cp <= 57)) {
#line 319
                goto while_break___10;
              }
            } else {
#line 319
              goto while_break___10;
            }
#line 319
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 321
          dp->precision_end = cp;
#line 322
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 323
          if (max_precision_length < precision_length) {
#line 324
            max_precision_length = precision_length;
          }
        }
      }
#line 333
      flags = 0;
      {
#line 335
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 337
        if ((int const   )*cp == 104) {
#line 339
          flags |= 1 << (flags & 1);
#line 340
          cp ++;
        } else
#line 342
        if ((int const   )*cp == 76) {
#line 344
          flags |= 4;
#line 345
          cp ++;
        } else
#line 347
        if ((int const   )*cp == 108) {
#line 349
          flags += 8;
#line 350
          cp ++;
        } else
#line 352
        if ((int const   )*cp == 106) {
#line 354
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 357
            flags += 16;
          } else
#line 359
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 362
            flags += 8;
          }
#line 364
          cp ++;
        } else
#line 366
        if ((int const   )*cp == 122) {
#line 366
          goto _L;
        } else
#line 366
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 371
          if (sizeof(size_t ) > sizeof(long )) {
#line 374
            flags += 16;
          } else
#line 376
          if (sizeof(size_t ) > sizeof(int )) {
#line 379
            flags += 8;
          }
#line 381
          cp ++;
        } else
#line 383
        if ((int const   )*cp == 116) {
#line 385
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 388
            flags += 16;
          } else
#line 390
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 393
            flags += 8;
          }
#line 395
          cp ++;
        } else {
#line 436
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 440
      tmp___19 = cp;
#line 440
      cp ++;
#line 440
      c = (char )*tmp___19;
      {
#line 443
      if ((int )c == 105) {
#line 443
        goto case_105;
      }
#line 443
      if ((int )c == 100) {
#line 443
        goto case_105;
      }
#line 461
      if ((int )c == 88) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 120) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 117) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 111) {
#line 461
        goto case_88;
      }
#line 480
      if ((int )c == 65) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 97) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 71) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 103) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 69) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 101) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 70) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 102) {
#line 480
        goto case_65;
      }
#line 486
      if ((int )c == 99) {
#line 486
        goto case_99;
      }
#line 497
      if ((int )c == 67) {
#line 497
        goto case_67;
      }
#line 502
      if ((int )c == 115) {
#line 502
        goto case_115;
      }
#line 513
      if ((int )c == 83) {
#line 513
        goto case_83;
      }
#line 518
      if ((int )c == 112) {
#line 518
        goto case_112;
      }
#line 521
      if ((int )c == 110) {
#line 521
        goto case_110;
      }
#line 550
      if ((int )c == 37) {
#line 550
        goto case_37;
      }
#line 553
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 446
      if (flags >= 16) {
#line 447
        type = (arg_type )9;
      } else
#line 446
      if (flags & 4) {
#line 447
        type = (arg_type )9;
      } else
#line 452
      if (flags >= 8) {
#line 453
        type = (arg_type )7;
      } else
#line 454
      if (flags & 2) {
#line 455
        type = (arg_type )1;
      } else
#line 456
      if (flags & 1) {
#line 457
        type = (arg_type )3;
      } else {
#line 459
        type = (arg_type )5;
      }
#line 460
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 464
      if (flags >= 16) {
#line 465
        type = (arg_type )10;
      } else
#line 464
      if (flags & 4) {
#line 465
        type = (arg_type )10;
      } else
#line 470
      if (flags >= 8) {
#line 471
        type = (arg_type )8;
      } else
#line 472
      if (flags & 2) {
#line 473
        type = (arg_type )2;
      } else
#line 474
      if (flags & 1) {
#line 475
        type = (arg_type )4;
      } else {
#line 477
        type = (arg_type )6;
      }
#line 478
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 481
      if (flags >= 16) {
#line 482
        type = (arg_type )12;
      } else
#line 481
      if (flags & 4) {
#line 482
        type = (arg_type )12;
      } else {
#line 484
        type = (arg_type )11;
      }
#line 485
      goto switch_break;
      case_99: /* CIL Label */ 
#line 487
      if (flags >= 8) {
#line 489
        type = (arg_type )14;
      } else {
#line 494
        type = (arg_type )13;
      }
#line 495
      goto switch_break;
      case_67: /* CIL Label */ 
#line 498
      type = (arg_type )14;
#line 499
      c = (char )'c';
#line 500
      goto switch_break;
      case_115: /* CIL Label */ 
#line 503
      if (flags >= 8) {
#line 505
        type = (arg_type )16;
      } else {
#line 510
        type = (arg_type )15;
      }
#line 511
      goto switch_break;
      case_83: /* CIL Label */ 
#line 514
      type = (arg_type )16;
#line 515
      c = (char )'s';
#line 516
      goto switch_break;
      case_112: /* CIL Label */ 
#line 519
      type = (arg_type )17;
#line 520
      goto switch_break;
      case_110: /* CIL Label */ 
#line 524
      if (flags >= 16) {
#line 525
        type = (arg_type )22;
      } else
#line 524
      if (flags & 4) {
#line 525
        type = (arg_type )22;
      } else
#line 530
      if (flags >= 8) {
#line 531
        type = (arg_type )21;
      } else
#line 532
      if (flags & 2) {
#line 533
        type = (arg_type )18;
      } else
#line 534
      if (flags & 1) {
#line 535
        type = (arg_type )19;
      } else {
#line 537
        type = (arg_type )20;
      }
#line 538
      goto switch_break;
      case_37: /* CIL Label */ 
#line 551
      type = (arg_type )0;
#line 552
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 555
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 559
      if ((unsigned int )type != 0U) {
#line 561
        dp->arg_index = arg_index;
#line 562
        if (dp->arg_index == 4294967295U) {
#line 564
          tmp___20 = arg_posn;
#line 564
          arg_posn ++;
#line 564
          dp->arg_index = tmp___20;
#line 565
          if (dp->arg_index == 4294967295U) {
#line 567
            goto error;
          }
        }
#line 569
        n___4 = dp->arg_index;
#line 569
        if (n___4 >= a_allocated) {
#line 569
          if (a_allocated <= 2147483647U) {
#line 569
            a_allocated *= 2U;
          } else {
#line 569
            a_allocated = 4294967295U;
          }
#line 569
          if (a_allocated <= n___4) {
            {
#line 569
            tmp___21 = xsum(n___4, (size_t )1);
#line 569
            a_allocated = (size_t )tmp___21;
            }
          }
#line 569
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 569
            memory_size___1 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 569
            memory_size___1 = 4294967295U;
          }
#line 569
          if (memory_size___1 == 4294967295U) {
#line 569
            goto out_of_memory;
          }
#line 569
          if (a->arg) {
            {
#line 569
            tmp___22 = realloc((void *)a->arg, memory_size___1);
#line 569
            tmp___24 = tmp___22;
            }
          } else {
            {
#line 569
            tmp___23 = malloc(memory_size___1);
#line 569
            tmp___24 = tmp___23;
            }
          }
#line 569
          memory___1 = (argument *)tmp___24;
#line 569
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 569
            goto out_of_memory;
          }
#line 569
          a->arg = memory___1;
        }
        {
#line 569
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 569
          if (! (a->count <= n___4)) {
#line 569
            goto while_break___12;
          }
#line 569
          tmp___25 = a->count;
#line 569
          (a->count) ++;
#line 569
          (a->arg + tmp___25)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 569
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 569
          (a->arg + n___4)->type = type;
        } else
#line 569
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 569
          goto error;
        }
      }
#line 571
      dp->conversion = c;
#line 572
      dp->dir_end = cp;
#line 575
      (d->count) ++;
#line 576
      if (d->count >= d_allocated) {
#line 581
        if (d_allocated <= 2147483647U) {
#line 581
          d_allocated *= 2U;
        } else {
#line 581
          d_allocated = 4294967295U;
        }
#line 582
        if ((unsigned long )d_allocated <= 4294967295UL / sizeof(char_directive )) {
#line 582
          memory_size___2 = (size_t )((unsigned long )d_allocated * sizeof(char_directive ));
        } else {
#line 582
          memory_size___2 = 4294967295U;
        }
#line 583
        if (memory_size___2 == 4294967295U) {
#line 585
          goto out_of_memory;
        }
        {
#line 586
        tmp___26 = realloc((void *)d->dir, memory_size___2);
#line 586
        memory___2 = (char_directive *)tmp___26;
        }
#line 587
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 589
          goto out_of_memory;
        }
#line 590
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  (d->dir + d->count)->dir_start = cp;
#line 603
  d->max_width_length = max_width_length;
#line 604
  d->max_precision_length = max_precision_length;
#line 605
  return (0);
  error: 
#line 608
  if (a->arg) {
    {
#line 609
    free((void *)a->arg);
    }
  }
#line 610
  if (d->dir) {
    {
#line 611
    free((void *)d->dir);
    }
  }
  {
#line 612
  tmp___27 = __errno_location();
#line 612
  *tmp___27 = 22;
  }
#line 613
  return (-1);
  out_of_memory: 
#line 616
  if (a->arg) {
    {
#line 617
    free((void *)a->arg);
    }
  }
#line 618
  if (d->dir) {
    {
#line 619
    free((void *)d->dir);
    }
  }
  out_of_memory_1: 
  {
#line 621
  tmp___28 = __errno_location();
#line 621
  *tmp___28 = 12;
  }
#line 622
  return (-1);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i___0 ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  char *__cil_tmp30 ;

  {
#line 43
  i___0 = (size_t )0;
#line 43
  ap = a->arg + 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i___0 < a->count)) {
#line 43
      goto while_break;
    }
    {
#line 46
    if ((unsigned int )ap->type == 1U) {
#line 46
      goto case_1;
    }
#line 49
    if ((unsigned int )ap->type == 2U) {
#line 49
      goto case_2;
    }
#line 52
    if ((unsigned int )ap->type == 3U) {
#line 52
      goto case_3;
    }
#line 55
    if ((unsigned int )ap->type == 4U) {
#line 55
      goto case_4;
    }
#line 58
    if ((unsigned int )ap->type == 5U) {
#line 58
      goto case_5;
    }
#line 61
    if ((unsigned int )ap->type == 6U) {
#line 61
      goto case_6;
    }
#line 64
    if ((unsigned int )ap->type == 7U) {
#line 64
      goto case_7;
    }
#line 67
    if ((unsigned int )ap->type == 8U) {
#line 67
      goto case_8;
    }
#line 71
    if ((unsigned int )ap->type == 9U) {
#line 71
      goto case_9;
    }
#line 74
    if ((unsigned int )ap->type == 10U) {
#line 74
      goto case_10;
    }
#line 78
    if ((unsigned int )ap->type == 11U) {
#line 78
      goto case_11;
    }
#line 81
    if ((unsigned int )ap->type == 12U) {
#line 81
      goto case_12;
    }
#line 84
    if ((unsigned int )ap->type == 13U) {
#line 84
      goto case_13;
    }
#line 88
    if ((unsigned int )ap->type == 14U) {
#line 88
      goto case_14;
    }
#line 98
    if ((unsigned int )ap->type == 15U) {
#line 98
      goto case_15;
    }
#line 107
    if ((unsigned int )ap->type == 16U) {
#line 107
      goto case_16;
    }
#line 125
    if ((unsigned int )ap->type == 17U) {
#line 125
      goto case_17;
    }
#line 128
    if ((unsigned int )ap->type == 18U) {
#line 128
      goto case_18;
    }
#line 131
    if ((unsigned int )ap->type == 19U) {
#line 131
      goto case_19;
    }
#line 134
    if ((unsigned int )ap->type == 20U) {
#line 134
      goto case_20;
    }
#line 137
    if ((unsigned int )ap->type == 21U) {
#line 137
      goto case_21;
    }
#line 141
    if ((unsigned int )ap->type == 22U) {
#line 141
      goto case_22;
    }
#line 184
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 47
    tmp = __builtin_va_arg(args, int );
#line 47
    ap->a.a_schar = tmp;
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 50
    tmp___0 = __builtin_va_arg(args, int );
#line 50
    ap->a.a_uchar = tmp___0;
    }
#line 51
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 53
    tmp___1 = __builtin_va_arg(args, int );
#line 53
    ap->a.a_short = tmp___1;
    }
#line 54
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 56
    tmp___2 = __builtin_va_arg(args, int );
#line 56
    ap->a.a_ushort = tmp___2;
    }
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 59
    tmp___3 = __builtin_va_arg(args, int );
#line 59
    ap->a.a_int = tmp___3;
    }
#line 60
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 62
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 62
    ap->a.a_uint = tmp___4;
    }
#line 63
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 65
    tmp___5 = __builtin_va_arg(args, long );
#line 65
    ap->a.a_longint = tmp___5;
    }
#line 66
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 68
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 68
    ap->a.a_ulongint = tmp___6;
    }
#line 69
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 72
    tmp___7 = __builtin_va_arg(args, long long );
#line 72
    ap->a.a_longlongint = tmp___7;
    }
#line 73
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 75
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 75
    ap->a.a_ulonglongint = tmp___8;
    }
#line 76
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 79
    tmp___9 = __builtin_va_arg(args, double );
#line 79
    ap->a.a_double = tmp___9;
    }
#line 80
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 82
    tmp___10 = __builtin_va_arg(args, long double );
#line 82
    ap->a.a_longdouble = tmp___10;
    }
#line 83
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 85
    tmp___11 = __builtin_va_arg(args, int );
#line 85
    ap->a.a_char = tmp___11;
    }
#line 86
    goto switch_break;
    case_14: /* CIL Label */ 
#line 92
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 92
      tmp___13 = __builtin_va_arg(args, int );
#line 92
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 92
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 92
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 96
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 99
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 99
    ap->a.a_string = tmp___16;
    }
#line 103
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 104
      ap->a.a_string = "(NULL)";
    }
#line 105
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 108
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 108
    ap->a.a_wide_string = tmp___17;
    }
#line 112
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 121
      ap->a.a_wide_string = wide_null_string;
    }
#line 123
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 126
    tmp___18 = __builtin_va_arg(args, void *);
#line 126
    ap->a.a_pointer = tmp___18;
    }
#line 127
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 129
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 129
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 130
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 132
    tmp___20 = __builtin_va_arg(args, short *);
#line 132
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 133
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 135
    tmp___21 = __builtin_va_arg(args, int *);
#line 135
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 136
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 138
    tmp___22 = __builtin_va_arg(args, long *);
#line 138
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 139
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 142
    tmp___23 = __builtin_va_arg(args, long long *);
#line 142
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 143
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 186
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 43
    i___0 ++;
#line 43
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i___0 , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i___0 , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + ((((sizeof(off_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i___0 < 0L) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48L - i___0 % 10L);
#line 43
      i___0 /= 10L;
#line 43
      if (! (i___0 != 0L)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48L + i___0 % 10L);
#line 51
      i___0 /= 10L;
#line 51
      if (! (i___0 != 0L)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 79 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.h"
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 85
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len___0 ,
                                                     struct md5_ctx *ctx ) ;
#line 92
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len___0 ,
                                                     struct md5_ctx *ctx ) ;
#line 99
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 105
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 111
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
#line 117
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len___0 ,
                                               void *resblock ) ;
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 73
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 76
  ctx->A = (uint32_t )1732584193;
#line 77
  ctx->B = 4023233417U;
#line 78
  ctx->C = 2562383102U;
#line 79
  ctx->D = (uint32_t )271733878;
#line 81
  tmp = (uint32_t )0;
#line 81
  ctx->total[1] = tmp;
#line 81
  ctx->total[0] = tmp;
#line 82
  ctx->buflen = (uint32_t )0;
#line 83
  return;
}
}
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
__inline static void set_uint32(char *cp , uint32_t v ) 
{ 


  {
  {
#line 91
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(& v), (size_t )sizeof(v));
  }
#line 92
  return;
}
}
#line 96
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 96 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  char *r ;

  {
  {
#line 99
  r = (char *)resbuf;
#line 100
  set_uint32(r + 0UL, (uint32_t )ctx->A);
#line 101
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
#line 102
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
#line 103
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
  }
#line 105
  return (resbuf);
}
}
#line 110
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 114
  bytes = ctx->buflen;
#line 115
  if (bytes < 56U) {
#line 115
    tmp = 16;
  } else {
#line 115
    tmp = 32;
  }
#line 115
  size = (size_t )tmp;
#line 118
  ctx->total[0] += bytes;
#line 119
  if (ctx->total[0] < bytes) {
#line 120
    (ctx->total[1]) ++;
  }
  {
#line 123
  ctx->buffer[size - 2U] = ctx->total[0] << 3;
#line 124
  ctx->buffer[size - 1U] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 126
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         (size - 2U) * 4U - bytes);
#line 129
  md5_process_block((void const   *)(ctx->buffer), size * 4U, ctx);
#line 131
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 131
  return (tmp___0);
}
}
#line 137
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
#line 137 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
  {
#line 145
  md5_init_ctx(& ctx);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    sum = (size_t )0;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 159
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096U - sum,
                (FILE */* __restrict  */)stream);
#line 161
      sum += n;
      }
#line 163
      if (sum == 4096U) {
#line 164
        goto while_break___0;
      }
#line 166
      if (n == 0U) {
        {
#line 171
        tmp = ferror(stream);
        }
#line 171
        if (tmp) {
#line 172
          return (1);
        }
#line 173
        goto process_partial_block;
      }
      {
#line 179
      tmp___0 = feof(stream);
      }
#line 179
      if (tmp___0) {
#line 180
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: 
#line 192
  if (sum > 0U) {
    {
#line 193
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 196
  md5_finish_ctx(& ctx, resblock);
  }
#line 197
  return (0);
}
}
#line 204
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len___0 ,
                                               void *resblock ) ;
#line 204 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void *md5_buffer(char const   *buffer , size_t len___0 , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 210
  md5_init_ctx(& ctx);
#line 213
  md5_process_bytes((void const   *)buffer, len___0, & ctx);
#line 216
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 216
  return (tmp);
}
}
#line 220
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len___0 ,
                                                     struct md5_ctx *ctx ) ;
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void md5_process_bytes(void const   *buffer , size_t len___0 , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 225
  if (ctx->buflen != 0U) {
#line 227
    left_over = ctx->buflen;
#line 228
    if (128U - left_over > len___0) {
#line 228
      tmp = len___0;
    } else {
#line 228
      tmp = 128U - left_over;
    }
    {
#line 228
    add = tmp;
#line 230
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 231
    ctx->buflen += add;
    }
#line 233
    if (ctx->buflen > 64U) {
      {
#line 235
      md5_process_block((void const   *)(ctx->buffer), ctx->buflen & 4294967232U,
                        ctx);
#line 237
      ctx->buflen &= 63U;
#line 239
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 4294967232U)),
             ctx->buflen);
      }
    }
#line 244
    buffer = (void const   *)((char const   *)buffer + add);
#line 245
    len___0 -= add;
  }
#line 249
  if (len___0 >= 64U) {
#line 254
    if ((unsigned long )((size_t )buffer) % (unsigned long )(& ((struct __anonstruct_28 *)0)->x) != 0UL) {
      {
#line 255
      while (1) {
        while_continue: /* CIL Label */ ;
#line 255
        if (! (len___0 > 64U)) {
#line 255
          goto while_break;
        }
        {
#line 257
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 257
        md5_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 258
        buffer = (void const   *)((char const   *)buffer + 64);
#line 259
        len___0 -= 64U;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 264
      md5_process_block(buffer, len___0 & 4294967232U, ctx);
#line 265
      buffer = (void const   *)((char const   *)buffer + (len___0 & 4294967232U));
#line 266
      len___0 &= 63U;
      }
    }
  }
#line 271
  if (len___0 > 0U) {
    {
#line 273
    left_over___0 = ctx->buflen;
#line 275
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len___0);
#line 276
    left_over___0 += len___0;
    }
#line 277
    if (left_over___0 >= 64U) {
      {
#line 279
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 280
      left_over___0 -= 64U;
#line 281
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 283
    ctx->buflen = left_over___0;
  }
#line 285
  return;
}
}
#line 300
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len___0 ,
                                                     struct md5_ctx *ctx ) ;
#line 300 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void md5_process_block(void const   *buffer , size_t len___0 , struct md5_ctx *ctx ) 
{ 
  uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;
  void *__cil_tmp49 ;

  {
#line 304
  words = (uint32_t const   *)buffer;
#line 305
  nwords = (size_t )((unsigned long )len___0 / sizeof(uint32_t ));
#line 306
  endp = words + nwords;
#line 307
  A = ctx->A;
#line 308
  B = ctx->B;
#line 309
  C = ctx->C;
#line 310
  D = ctx->D;
#line 315
  ctx->total[0] += len___0;
#line 316
  if (ctx->total[0] < len___0) {
#line 317
    (ctx->total[1]) ++;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 321
      goto while_break;
    }
#line 323
    cwp = correct_words;
#line 324
    A_save = A;
#line 325
    B_save = B;
#line 326
    C_save = C;
#line 327
    D_save = D;
    {
#line 361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 361
      tmp = cwp;
#line 361
      cwp ++;
#line 361
      tmp___0 = (uint32_t )*words;
#line 361
      *tmp = tmp___0;
#line 361
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 361
      words ++;
#line 361
      A = (A << 7) | (A >> 25);
#line 361
      A += B;
#line 361
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 362
      tmp___1 = cwp;
#line 362
      cwp ++;
#line 362
      tmp___2 = (uint32_t )*words;
#line 362
      *tmp___1 = tmp___2;
#line 362
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 362
      words ++;
#line 362
      D = (D << 12) | (D >> 20);
#line 362
      D += A;
#line 362
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 363
      tmp___3 = cwp;
#line 363
      cwp ++;
#line 363
      tmp___4 = (uint32_t )*words;
#line 363
      *tmp___3 = tmp___4;
#line 363
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 363
      words ++;
#line 363
      C = (C << 17) | (C >> 15);
#line 363
      C += D;
#line 363
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 364
      tmp___5 = cwp;
#line 364
      cwp ++;
#line 364
      tmp___6 = (uint32_t )*words;
#line 364
      *tmp___5 = tmp___6;
#line 364
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 364
      words ++;
#line 364
      B = (B << 22) | (B >> 10);
#line 364
      B += C;
#line 364
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 365
      tmp___7 = cwp;
#line 365
      cwp ++;
#line 365
      tmp___8 = (uint32_t )*words;
#line 365
      *tmp___7 = tmp___8;
#line 365
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 365
      words ++;
#line 365
      A = (A << 7) | (A >> 25);
#line 365
      A += B;
#line 365
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 366
      tmp___9 = cwp;
#line 366
      cwp ++;
#line 366
      tmp___10 = (uint32_t )*words;
#line 366
      *tmp___9 = tmp___10;
#line 366
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 366
      words ++;
#line 366
      D = (D << 12) | (D >> 20);
#line 366
      D += A;
#line 366
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 367
      tmp___11 = cwp;
#line 367
      cwp ++;
#line 367
      tmp___12 = (uint32_t )*words;
#line 367
      *tmp___11 = tmp___12;
#line 367
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 367
      words ++;
#line 367
      C = (C << 17) | (C >> 15);
#line 367
      C += D;
#line 367
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 368
      tmp___13 = cwp;
#line 368
      cwp ++;
#line 368
      tmp___14 = (uint32_t )*words;
#line 368
      *tmp___13 = tmp___14;
#line 368
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 368
      words ++;
#line 368
      B = (B << 22) | (B >> 10);
#line 368
      B += C;
#line 368
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 369
      tmp___15 = cwp;
#line 369
      cwp ++;
#line 369
      tmp___16 = (uint32_t )*words;
#line 369
      *tmp___15 = tmp___16;
#line 369
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 369
      words ++;
#line 369
      A = (A << 7) | (A >> 25);
#line 369
      A += B;
#line 369
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 370
      tmp___17 = cwp;
#line 370
      cwp ++;
#line 370
      tmp___18 = (uint32_t )*words;
#line 370
      *tmp___17 = tmp___18;
#line 370
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 370
      words ++;
#line 370
      D = (D << 12) | (D >> 20);
#line 370
      D += A;
#line 370
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 371
      tmp___19 = cwp;
#line 371
      cwp ++;
#line 371
      tmp___20 = (uint32_t )*words;
#line 371
      *tmp___19 = tmp___20;
#line 371
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 371
      words ++;
#line 371
      C = (C << 17) | (C >> 15);
#line 371
      C += D;
#line 371
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 372
      tmp___21 = cwp;
#line 372
      cwp ++;
#line 372
      tmp___22 = (uint32_t )*words;
#line 372
      *tmp___21 = tmp___22;
#line 372
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 372
      words ++;
#line 372
      B = (B << 22) | (B >> 10);
#line 372
      B += C;
#line 372
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 373
      tmp___23 = cwp;
#line 373
      cwp ++;
#line 373
      tmp___24 = (uint32_t )*words;
#line 373
      *tmp___23 = tmp___24;
#line 373
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 373
      words ++;
#line 373
      A = (A << 7) | (A >> 25);
#line 373
      A += B;
#line 373
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 374
      tmp___25 = cwp;
#line 374
      cwp ++;
#line 374
      tmp___26 = (uint32_t )*words;
#line 374
      *tmp___25 = tmp___26;
#line 374
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 374
      words ++;
#line 374
      D = (D << 12) | (D >> 20);
#line 374
      D += A;
#line 374
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 375
      tmp___27 = cwp;
#line 375
      cwp ++;
#line 375
      tmp___28 = (uint32_t )*words;
#line 375
      *tmp___27 = tmp___28;
#line 375
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 375
      words ++;
#line 375
      C = (C << 17) | (C >> 15);
#line 375
      C += D;
#line 375
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 376
      tmp___29 = cwp;
#line 376
      cwp ++;
#line 376
      tmp___30 = (uint32_t )*words;
#line 376
      *tmp___29 = tmp___30;
#line 376
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 376
      words ++;
#line 376
      B = (B << 22) | (B >> 10);
#line 376
      B += C;
#line 376
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 392
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 392
      A = (A << 5) | (A >> 27);
#line 392
      A += B;
#line 392
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 393
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 393
      D = (D << 9) | (D >> 23);
#line 393
      D += A;
#line 393
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 394
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 394
      C = (C << 14) | (C >> 18);
#line 394
      C += D;
#line 394
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 395
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 395
      B = (B << 20) | (B >> 12);
#line 395
      B += C;
#line 395
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 396
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 396
      A = (A << 5) | (A >> 27);
#line 396
      A += B;
#line 396
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 397
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 397
      D = (D << 9) | (D >> 23);
#line 397
      D += A;
#line 397
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 398
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 398
      C = (C << 14) | (C >> 18);
#line 398
      C += D;
#line 398
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 399
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 399
      B = (B << 20) | (B >> 12);
#line 399
      B += C;
#line 399
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 400
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 400
      A = (A << 5) | (A >> 27);
#line 400
      A += B;
#line 400
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 401
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 401
      D = (D << 9) | (D >> 23);
#line 401
      D += A;
#line 401
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 402
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 402
      C = (C << 14) | (C >> 18);
#line 402
      C += D;
#line 402
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 403
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 403
      B = (B << 20) | (B >> 12);
#line 403
      B += C;
#line 403
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 404
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 404
      A = (A << 5) | (A >> 27);
#line 404
      A += B;
#line 404
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 405
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 405
      D = (D << 9) | (D >> 23);
#line 405
      D += A;
#line 405
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 406
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 406
      C = (C << 14) | (C >> 18);
#line 406
      C += D;
#line 406
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 407
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 407
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 407
      B = (B << 20) | (B >> 12);
#line 407
      B += C;
#line 407
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 410
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 410
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 410
      A = (A << 4) | (A >> 28);
#line 410
      A += B;
#line 410
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 411
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 411
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 411
      D = (D << 11) | (D >> 21);
#line 411
      D += A;
#line 411
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 412
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 412
      C = (C << 16) | (C >> 16);
#line 412
      C += D;
#line 412
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 413
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 413
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 413
      B = (B << 23) | (B >> 9);
#line 413
      B += C;
#line 413
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 414
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 414
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 414
      A = (A << 4) | (A >> 28);
#line 414
      A += B;
#line 414
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 415
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 415
      D = (D << 11) | (D >> 21);
#line 415
      D += A;
#line 415
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 416
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 416
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 416
      C = (C << 16) | (C >> 16);
#line 416
      C += D;
#line 416
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 417
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 417
      B = (B << 23) | (B >> 9);
#line 417
      B += C;
#line 417
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 418
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 418
      A = (A << 4) | (A >> 28);
#line 418
      A += B;
#line 418
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 419
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 419
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 419
      D = (D << 11) | (D >> 21);
#line 419
      D += A;
#line 419
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 420
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 420
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 420
      C = (C << 16) | (C >> 16);
#line 420
      C += D;
#line 420
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 421
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 421
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 421
      B = (B << 23) | (B >> 9);
#line 421
      B += C;
#line 421
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 422
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 422
      A = (A << 4) | (A >> 28);
#line 422
      A += B;
#line 422
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 423
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 423
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 423
      D = (D << 11) | (D >> 21);
#line 423
      D += A;
#line 423
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 424
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 424
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 424
      C = (C << 16) | (C >> 16);
#line 424
      C += D;
#line 424
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 425
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 425
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 425
      B = (B << 23) | (B >> 9);
#line 425
      B += C;
#line 425
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 428
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 428
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 428
      A = (A << 6) | (A >> 26);
#line 428
      A += B;
#line 428
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 429
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 429
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 429
      D = (D << 10) | (D >> 22);
#line 429
      D += A;
#line 429
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 430
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 430
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 430
      C = (C << 15) | (C >> 17);
#line 430
      C += D;
#line 430
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 431
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 431
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 431
      B = (B << 21) | (B >> 11);
#line 431
      B += C;
#line 431
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 432
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 432
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 432
      A = (A << 6) | (A >> 26);
#line 432
      A += B;
#line 432
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 433
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 433
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 433
      D = (D << 10) | (D >> 22);
#line 433
      D += A;
#line 433
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 434
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 434
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 434
      C = (C << 15) | (C >> 17);
#line 434
      C += D;
#line 434
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 435
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 435
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 435
      B = (B << 21) | (B >> 11);
#line 435
      B += C;
#line 435
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 436
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 436
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 436
      A = (A << 6) | (A >> 26);
#line 436
      A += B;
#line 436
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 437
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 437
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 437
      D = (D << 10) | (D >> 22);
#line 437
      D += A;
#line 437
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 438
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 438
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 438
      C = (C << 15) | (C >> 17);
#line 438
      C += D;
#line 438
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 439
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 439
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 439
      B = (B << 21) | (B >> 11);
#line 439
      B += C;
#line 439
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 440
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 440
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 440
      A = (A << 6) | (A >> 26);
#line 440
      A += B;
#line 440
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 441
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 441
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 441
      D = (D << 10) | (D >> 22);
#line 441
      D += A;
#line 441
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 442
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 442
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 442
      C = (C << 15) | (C >> 17);
#line 442
      C += D;
#line 442
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 443
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 443
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 443
      B = (B << 21) | (B >> 11);
#line 443
      B += C;
#line 443
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 446
    A += A_save;
#line 447
    B += B_save;
#line 448
    C += C_save;
#line 449
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  ctx->A = A;
#line 454
  ctx->B = B;
#line 455
  ctx->C = C;
#line 456
  ctx->D = D;
#line 457
  return;
}
}
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.h"
char const   *locale_charset(void) ;
#line 407 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int getc_unlocked(FILE *__stream ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  FILE *fp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *tmp ;
  size_t dir_len ;
  size_t tmp___0 ;
  size_t base_len ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 118
  cp = (char const   *)charset_aliases;
#line 119
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 124
    base = "charset.alias";
#line 129
    tmp = getenv("CHARSETALIASDIR");
#line 129
    dir = (char const   *)tmp;
    }
#line 130
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 131
      dir = "/usr/local/lib";
    } else
#line 130
    if ((int const   )*(dir + 0) == 0) {
#line 131
      dir = "/usr/local/lib";
    }
    {
#line 135
    tmp___0 = strlen(dir);
#line 135
    dir_len = tmp___0;
#line 136
    tmp___1 = strlen(base);
#line 136
    base_len = tmp___1;
    }
#line 137
    if (dir_len > 0U) {
#line 137
      if (! ((int const   )*(dir + (dir_len - 1U)) == 47)) {
#line 137
        tmp___2 = 1;
      } else {
#line 137
        tmp___2 = 0;
      }
    } else {
#line 137
      tmp___2 = 0;
    }
    {
#line 137
    add_slash = tmp___2;
#line 138
    tmp___3 = malloc(((dir_len + (size_t )add_slash) + base_len) + 1U);
#line 138
    file_name = (char *)tmp___3;
    }
#line 139
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 141
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len);
      }
#line 142
      if (add_slash) {
#line 143
        *(file_name + dir_len) = (char )'/';
      }
      {
#line 144
      memcpy((void */* __restrict  */)((file_name + dir_len) + add_slash), (void const   */* __restrict  */)base,
             base_len + 1U);
      }
    }
#line 148
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 150
      cp = "";
    } else {
      {
#line 148
      fp = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
      }
#line 148
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 150
        cp = "";
      } else {
#line 154
        res_ptr = (char *)((void *)0);
#line 155
        res_size = (size_t )0;
        {
#line 157
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 165
          c = getc_unlocked(fp);
          }
#line 166
          if (c == -1) {
#line 167
            goto while_break;
          }
#line 168
          if (c == 10) {
#line 169
            goto __Cont;
          } else
#line 168
          if (c == 32) {
#line 169
            goto __Cont;
          } else
#line 168
          if (c == 9) {
#line 169
            goto __Cont;
          }
#line 170
          if (c == 35) {
            {
#line 173
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 174
              c = getc_unlocked(fp);
              }
#line 173
              if (c == -1) {
#line 173
                goto while_break___0;
              } else
#line 173
              if (c == 10) {
#line 173
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 176
            if (c == -1) {
#line 177
              goto while_break;
            }
#line 178
            goto __Cont;
          }
          {
#line 180
          ungetc(c, fp);
#line 181
          tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                           buf1, buf2);
          }
#line 181
          if (tmp___4 < 2) {
#line 182
            goto while_break;
          }
          {
#line 183
          l1 = strlen((char const   *)(buf1));
#line 184
          l2 = strlen((char const   *)(buf2));
#line 185
          old_res_ptr = res_ptr;
          }
#line 186
          if (res_size == 0U) {
            {
#line 188
            res_size = ((l1 + 1U) + l2) + 1U;
#line 189
            tmp___5 = malloc(res_size + 1U);
#line 189
            res_ptr = (char *)tmp___5;
            }
          } else {
            {
#line 193
            res_size += ((l1 + 1U) + l2) + 1U;
#line 194
            tmp___6 = realloc((void *)res_ptr, res_size + 1U);
#line 194
            res_ptr = (char *)tmp___6;
            }
          }
#line 196
          if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 199
            res_size = (size_t )0;
#line 200
            if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
              {
#line 201
              free((void *)old_res_ptr);
              }
            }
#line 202
            goto while_break;
          }
          {
#line 204
          strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1U)) - (l1 + 1U)),
                 (char const   */* __restrict  */)(buf1));
#line 205
          strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1U)), (char const   */* __restrict  */)(buf2));
          }
          __Cont: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 207
        fclose(fp);
        }
#line 208
        if (res_size == 0U) {
#line 209
          cp = "";
        } else {
#line 212
          *(res_ptr + res_size) = (char )'\000';
#line 213
          cp = (char const   *)res_ptr;
        }
      }
    }
#line 217
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 218
      free((void *)file_name);
      }
    }
#line 311
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 314
  return (cp);
}
}
#line 326 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 337
  tmp = nl_langinfo(14);
#line 337
  codeset = (char const   *)tmp;
  }
#line 479
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 481
    codeset = "";
  }
  {
#line 484
  aliases = get_charset_aliases();
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! ((int const   )*aliases != 0)) {
#line 484
      goto while_break;
    }
    {
#line 487
    tmp___3 = strcmp(codeset, aliases);
    }
#line 487
    if (tmp___3 == 0) {
      {
#line 490
      tmp___2 = strlen(aliases);
#line 490
      codeset = (aliases + tmp___2) + 1;
      }
#line 491
      goto while_break;
    } else
#line 487
    if ((int const   )*(aliases + 0) == 42) {
#line 487
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 490
        tmp___2 = strlen(aliases);
#line 490
        codeset = (aliases + tmp___2) + 1;
        }
#line 491
        goto while_break;
      }
    }
    {
#line 484
    tmp___0 = strlen(aliases);
#line 484
    aliases += tmp___0 + 1U;
#line 484
    tmp___1 = strlen(aliases);
#line 484
    aliases += tmp___1 + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  if ((int const   )*(codeset + 0) == 0) {
#line 498
    codeset = "ASCII";
  }
#line 500
  return (codeset);
}
}
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i___0 , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i___0 , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + ((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i___0 < 0LL) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48LL - i___0 % 10LL);
#line 43
      i___0 /= 10LL;
#line 43
      if (! (i___0 != 0LL)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48LL + i___0 % 10LL);
#line 51
      i___0 /= 10LL;
#line 51
      if (! (i___0 != 0LL)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 62
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 63
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 64
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 65
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 66
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 67
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 70
void *hash_get_first(Hash_table const   *table ) ;
#line 71
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 72
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 73
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 76
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 77
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 78
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) ;
#line 81
void hash_clear(Hash_table *table ) ;
#line 82
void hash_free(Hash_table *table ) ;
#line 85
_Bool hash_rehash(Hash_table *table , size_t candidate ) ;
#line 86
void *hash_insert(Hash_table *table , void const   *entry ) ;
#line 87
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 129 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 148 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 151
  return ((size_t )table->n_buckets);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 159
  return ((size_t )table->n_buckets_used);
}
}
#line 164 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 167
  return ((size_t )table->n_entries);
}
}
#line 172 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 176
  max_bucket_length = (size_t )0;
#line 178
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 178
      goto while_break;
    }
#line 180
    if (bucket->data) {
#line 182
      cursor = bucket;
#line 183
      bucket_length = (size_t )1;
      {
#line 185
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 185
        cursor = (struct hash_entry  const  *)cursor->next;
#line 185
        if (! cursor) {
#line 185
          goto while_break___0;
        }
#line 186
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 188
      if (bucket_length > max_bucket_length) {
#line 189
        max_bucket_length = bucket_length;
      }
    }
#line 178
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return (max_bucket_length);
}
}
#line 199 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 203
  n_buckets_used = (size_t )0;
#line 204
  n_entries = (size_t )0;
#line 206
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 206
      goto while_break;
    }
#line 208
    if (bucket->data) {
#line 210
      cursor = bucket;
#line 213
      n_buckets_used ++;
#line 214
      n_entries ++;
      {
#line 217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        cursor = (struct hash_entry  const  *)cursor->next;
#line 217
        if (! cursor) {
#line 217
          goto while_break___0;
        }
#line 218
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 206
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 222
    if (n_entries == (size_t )table->n_entries) {
#line 223
      return ((_Bool)1);
    }
  }
#line 225
  return ((_Bool)0);
}
}
#line 228 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 231
  tmp = hash_get_n_entries(table);
#line 231
  n_entries = tmp;
#line 232
  tmp___0 = hash_get_n_buckets(table);
#line 232
  n_buckets = tmp___0;
#line 233
  tmp___1 = hash_get_n_buckets_used(table);
#line 233
  n_buckets_used = tmp___1;
#line 234
  tmp___2 = hash_get_max_bucket_length(table);
#line 234
  max_bucket_length = tmp___2;
#line 236
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          (unsigned long )n_entries);
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          (unsigned long )n_buckets);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          (unsigned long )n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 241
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          (unsigned long )max_bucket_length);
  }
#line 243
  return;
}
}
#line 248 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 251
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 251
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 255
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 256
    abort();
    }
  }
#line 258
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 259
    return ((void *)0);
  }
#line 261
  cursor = bucket;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! cursor) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
    }
#line 262
    if (tmp___0) {
#line 263
      return ((void *)cursor->data);
    }
#line 261
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return ((void *)0);
}
}
#line 277 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 282
  if (table->n_entries == 0U) {
#line 283
    return ((void *)0);
  }
#line 285
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 287
      abort();
      }
    } else
#line 288
    if (bucket->data) {
#line 289
      return ((void *)bucket->data);
    }
#line 285
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 296 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 299
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 299
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 303
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 304
    abort();
    }
  }
#line 307
  cursor = bucket;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! cursor) {
#line 307
      goto while_break;
    }
#line 308
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 308
      if (cursor->next) {
#line 309
        return ((cursor->next)->data);
      }
    }
#line 307
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    bucket ++;
#line 312
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 312
      goto while_break___0;
    }
#line 313
    if (bucket->data) {
#line 314
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 317
  return ((void *)0);
}
}
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 328
  counter = (size_t )0;
#line 332
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 332
      goto while_break;
    }
#line 334
    if (bucket->data) {
#line 336
      cursor = bucket;
      {
#line 336
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 336
        if (! cursor) {
#line 336
          goto while_break___0;
        }
#line 338
        if (counter >= buffer_size) {
#line 339
          return (counter);
        }
#line 340
        tmp = counter;
#line 340
        counter ++;
#line 340
        *(buffer + tmp) = (void *)cursor->data;
#line 336
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 332
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return (counter);
}
}
#line 356 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 360
  counter = (size_t )0;
#line 364
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 364
      goto while_break;
    }
#line 366
    if (bucket->data) {
#line 368
      cursor = bucket;
      {
#line 368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 368
        if (! cursor) {
#line 368
          goto while_break___0;
        }
        {
#line 370
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 370
        if (! tmp) {
#line 371
          return (counter);
        }
#line 372
        counter ++;
#line 368
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 364
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return (counter);
}
}
#line 419 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 422
  value = (size_t )0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    ch = (unsigned char )*string;
#line 425
    if (! ch) {
#line 425
      goto while_break;
    }
#line 426
    value = (value * 31U + (size_t )ch) % n_buckets;
#line 425
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  return (value);
}
}
#line 435 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 438
  divisor = (size_t )3;
#line 439
  square = divisor * divisor;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (square < candidate) {
#line 441
      if (! (candidate % divisor)) {
#line 441
        goto while_break;
      }
    } else {
#line 441
      goto while_break;
    }
#line 443
    divisor ++;
#line 444
    square += 4U * divisor;
#line 445
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  if (candidate % divisor) {
#line 448
    tmp = 1;
  } else {
#line 448
    tmp = 0;
  }
#line 448
  return ((_Bool )tmp);
}
}
#line 454 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 458
  if (candidate < 10U) {
#line 459
    candidate = (size_t )10;
  }
#line 462
  candidate |= 1U;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 464
    tmp = is_prime(candidate);
    }
#line 464
    if (tmp) {
#line 464
      goto while_break;
    }
#line 465
    candidate += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  return (candidate);
}
}
#line 470 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 473
  *tuning = (Hash_tuning )default_tuning;
#line 474
  return;
}
}
#line 482 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 485
  tuning = table->tuning;
#line 492
  epsilon = 0.1f;
#line 494
  if (epsilon < (float )tuning->growth_threshold) {
#line 494
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 494
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 494
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 494
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 494
            if (tuning->shrink_factor <= (float const   )1) {
#line 494
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 501
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 503
  table->tuning = & default_tuning;
#line 504
  return ((_Bool)0);
}
}
#line 538 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  float new_candidate ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 545
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 546
    return ((Hash_table *)((void *)0));
  } else
#line 545
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 546
    return ((Hash_table *)((void *)0));
  }
  {
#line 548
  tmp = malloc((size_t )sizeof(*table));
#line 548
  table = (Hash_table *)tmp;
  }
#line 549
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 550
    return ((Hash_table *)((void *)0));
  }
#line 552
  if (! tuning) {
#line 553
    tuning = & default_tuning;
  }
  {
#line 554
  table->tuning = tuning;
#line 555
  tmp___0 = check_tuning(table);
  }
#line 555
  if (! tmp___0) {
#line 562
    goto fail;
  }
#line 565
  if (! tuning->is_n_buckets) {
#line 567
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 568
    if ((float )4294967295U <= new_candidate) {
#line 569
      goto fail;
    }
#line 570
    candidate = (size_t )new_candidate;
  }
#line 573
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 573
    tmp___1 = -1;
  } else {
#line 573
    tmp___1 = -2;
  }
#line 573
  if ((unsigned long )((size_t )tmp___1) / sizeof(*(table->bucket)) < (unsigned long )candidate) {
#line 574
    goto fail;
  }
  {
#line 575
  table->n_buckets = next_prime(candidate);
  }
#line 576
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 576
    tmp___2 = -1;
  } else {
#line 576
    tmp___2 = -2;
  }
#line 576
  if ((unsigned long )((size_t )tmp___2) / sizeof(*(table->bucket)) < (unsigned long )table->n_buckets) {
#line 577
    goto fail;
  }
  {
#line 579
  tmp___3 = calloc(table->n_buckets, (size_t )sizeof(*(table->bucket)));
#line 579
  table->bucket = (struct hash_entry *)tmp___3;
  }
#line 580
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 581
    goto fail;
  }
#line 582
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 583
  table->n_buckets_used = (size_t )0;
#line 584
  table->n_entries = (size_t )0;
#line 586
  table->hasher = hasher;
#line 587
  table->comparator = comparator;
#line 588
  table->data_freer = data_freer;
#line 590
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 594
  return (table);
  fail: 
  {
#line 597
  free((void *)table);
  }
#line 598
  return ((Hash_table *)((void *)0));
}
}
#line 605 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 610
  bucket = table->bucket;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 610
      goto while_break;
    }
#line 612
    if (bucket->data) {
#line 618
      cursor = bucket->next;
      {
#line 618
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 618
        if (! cursor) {
#line 618
          goto while_break___0;
        }
#line 620
        if (table->data_freer) {
          {
#line 621
          (*(table->data_freer))(cursor->data);
          }
        }
#line 622
        cursor->data = (void *)0;
#line 624
        next = cursor->next;
#line 627
        cursor->next = table->free_entry_list;
#line 628
        table->free_entry_list = cursor;
#line 618
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 632
      if (table->data_freer) {
        {
#line 633
        (*(table->data_freer))(bucket->data);
        }
      }
#line 634
      bucket->data = (void *)0;
#line 635
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 610
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  table->n_buckets_used = (size_t )0;
#line 640
  table->n_entries = (size_t )0;
#line 641
  return;
}
}
#line 648 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 656
  if (table->data_freer) {
#line 656
    if (table->n_entries) {
#line 658
      bucket = table->bucket;
      {
#line 658
      while (1) {
        while_continue: /* CIL Label */ ;
#line 658
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 658
          goto while_break;
        }
#line 660
        if (bucket->data) {
#line 662
          cursor = bucket;
          {
#line 662
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 662
            if (! cursor) {
#line 662
              goto while_break___0;
            }
            {
#line 664
            (*(table->data_freer))(cursor->data);
#line 662
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 658
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 677
  bucket = table->bucket;
  {
#line 677
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 677
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 677
      goto while_break___1;
    }
#line 679
    cursor = bucket->next;
    {
#line 679
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 679
      if (! cursor) {
#line 679
        goto while_break___2;
      }
      {
#line 681
      next = cursor->next;
#line 682
      free((void *)cursor);
#line 679
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 677
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 687
  cursor = table->free_entry_list;
  {
#line 687
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 687
    if (! cursor) {
#line 687
      goto while_break___3;
    }
    {
#line 689
    next = cursor->next;
#line 690
    free((void *)cursor);
#line 687
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 696
  free((void *)table->bucket);
#line 697
  free((void *)table);
  }
#line 698
  return;
}
}
#line 705 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 710
  if (table->free_entry_list) {
#line 712
    new = table->free_entry_list;
#line 713
    table->free_entry_list = new->next;
  } else {
    {
#line 720
    tmp = malloc((size_t )sizeof(*new));
#line 720
    new = (struct hash_entry *)tmp;
    }
  }
#line 724
  return (new);
}
}
#line 730 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 733
  entry->data = (void *)0;
#line 734
  entry->next = table->free_entry_list;
#line 735
  table->free_entry_list = entry;
#line 736
  return;
}
}
#line 744 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 748
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 748
  bucket = table->bucket + tmp;
  }
#line 752
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 753
    abort();
    }
  }
#line 755
  *bucket_head = bucket;
#line 758
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 759
    return ((void *)0);
  }
  {
#line 762
  tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
  }
#line 762
  if (tmp___0) {
#line 764
    data = bucket->data;
#line 766
    if (delete) {
#line 768
      if (bucket->next) {
        {
#line 770
        next = bucket->next;
#line 774
        *bucket = *next;
#line 775
        free_entry(table, next);
        }
      } else {
#line 779
        bucket->data = (void *)0;
      }
    }
#line 783
    return (data);
  }
#line 787
  cursor = bucket;
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! cursor->next) {
#line 787
      goto while_break;
    }
    {
#line 789
    tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
    }
#line 789
    if (tmp___1) {
#line 791
      data___0 = (cursor->next)->data;
#line 793
      if (delete) {
        {
#line 795
        next___0 = cursor->next;
#line 799
        cursor->next = next___0->next;
#line 800
        free_entry(table, next___0);
        }
      }
#line 803
      return (data___0);
    }
#line 787
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return ((void *)0);
}
}
#line 819 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
_Bool hash_rehash(Hash_table *table , size_t candidate ) 
{ 
  Hash_table *new_table ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___0 ;

  {
  {
#line 827
  new_table = hash_initialize(candidate, table->tuning, table->hasher, table->comparator,
                              table->data_freer);
  }
#line 829
  if ((unsigned long )new_table == (unsigned long )((void *)0)) {
#line 830
    return ((_Bool)0);
  }
#line 837
  new_table->free_entry_list = table->free_entry_list;
#line 839
  bucket = table->bucket;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 839
      goto while_break;
    }
#line 840
    if (bucket->data) {
#line 841
      cursor = bucket;
      {
#line 841
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 841
        if (! cursor) {
#line 841
          goto while_break___0;
        }
        {
#line 843
        data = cursor->data;
#line 844
        tmp = (*(new_table->hasher))((void const   *)data, new_table->n_buckets);
#line 844
        new_bucket = new_table->bucket + tmp;
        }
#line 848
        if (! ((unsigned long )new_bucket < (unsigned long )new_table->bucket_limit)) {
          {
#line 849
          abort();
          }
        }
#line 851
        next = cursor->next;
#line 853
        if (new_bucket->data) {
#line 855
          if ((unsigned long )cursor == (unsigned long )bucket) {
            {
#line 859
            tmp___0 = allocate_entry(new_table);
#line 859
            new_entry = tmp___0;
            }
#line 861
            if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 862
              return ((_Bool)0);
            }
#line 864
            new_entry->data = data;
#line 865
            new_entry->next = new_bucket->next;
#line 866
            new_bucket->next = new_entry;
          } else {
#line 872
            cursor->next = new_bucket->next;
#line 873
            new_bucket->next = cursor;
          }
        } else {
#line 882
          new_bucket->data = data;
#line 883
          (new_table->n_buckets_used) ++;
#line 884
          if ((unsigned long )cursor != (unsigned long )bucket) {
            {
#line 885
            free_entry(new_table, cursor);
            }
          }
        }
#line 841
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 839
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 889
  free((void *)table->bucket);
#line 890
  table->bucket = new_table->bucket;
#line 891
  table->bucket_limit = new_table->bucket_limit;
#line 892
  table->n_buckets = new_table->n_buckets;
#line 893
  table->n_buckets_used = new_table->n_buckets_used;
#line 894
  table->free_entry_list = new_table->free_entry_list;
#line 899
  free((void *)new_table);
  }
#line 901
  return ((_Bool)1);
}
}
#line 908 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_insert(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp___0 ;
  _Bool tmp___1 ;

  {
#line 915
  if (! entry) {
    {
#line 916
    abort();
    }
  }
  {
#line 919
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 919
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 920
    return (data);
  }
#line 924
  if (bucket->data) {
    {
#line 926
    tmp = allocate_entry(table);
#line 926
    new_entry = tmp;
    }
#line 928
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 929
      return ((void *)0);
    }
#line 933
    new_entry->data = (void *)entry;
#line 934
    new_entry->next = bucket->next;
#line 935
    bucket->next = new_entry;
#line 936
    (table->n_entries) ++;
#line 937
    return ((void *)entry);
  }
#line 942
  bucket->data = (void *)entry;
#line 943
  (table->n_entries) ++;
#line 944
  (table->n_buckets_used) ++;
#line 951
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 956
    check_tuning(table);
    }
#line 957
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 960
      tuning = table->tuning;
#line 961
      if (tuning->is_n_buckets) {
#line 961
        tmp___0 = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 961
        tmp___0 = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 961
      candidate = (float )tmp___0;
#line 967
      if ((float )4294967295U <= candidate) {
#line 968
        return ((void *)0);
      }
      {
#line 971
      tmp___1 = hash_rehash(table, (size_t )candidate);
      }
#line 971
      if (! tmp___1) {
#line 972
        entry = (void const   *)((void *)0);
      }
    }
  }
#line 976
  return ((void *)entry);
}
}
#line 983 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;

  {
  {
#line 989
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 990
  if (! data) {
#line 991
    return ((void *)0);
  }
#line 993
  (table->n_entries) --;
#line 994
  if (! bucket->data) {
#line 996
    (table->n_buckets_used) --;
#line 1001
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1006
      check_tuning(table);
      }
#line 1007
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1010
        tuning = table->tuning;
#line 1011
        if (tuning->is_n_buckets) {
#line 1011
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1011
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1011
        candidate = (size_t )tmp;
#line 1017
        hash_rehash(table, candidate);
        }
      }
    }
  }
#line 1022
  return (data);
}
}
#line 964 "/usr/include/unistd.h"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt___0 ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 229
extern int fflush_unlocked(FILE *__stream ) ;
#line 584
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 651
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 699
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 746
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 886
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 893
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 83 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int __fsetlocking(FILE *__fp , int __type ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
static void call_fclose(void *arg ) 
{ 


  {
#line 83
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
#line 84
    fclose((FILE *)arg);
    }
  }
#line 85
  return;
}
}
#line 94 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
static char *buf  ;
#line 95 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
static size_t bufsize  ;
#line 87 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt___0 ) 
{ 
  FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 93
  tty_changed = (_Bool)0;
#line 101
  tty = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w+");
  }
#line 102
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 104
    in = stdin;
#line 105
    out = stderr;
  } else {
    {
#line 110
    __fsetlocking(tty, 2);
#line 112
    in = tty;
#line 112
    out = in;
    }
  }
  {
#line 115
  flockfile(out);
#line 119
  tmp___1 = fileno(in);
#line 119
  tmp___2 = tcgetattr(tmp___1, & t);
  }
#line 119
  if (tmp___2 == 0) {
    {
#line 122
    s = t;
#line 124
    t.c_lflag &= 4294967286U;
#line 125
    tmp = fileno(in);
#line 125
    tmp___0 = tcsetattr(tmp, 2, (struct termios  const  *)(& t));
#line 125
    tty_changed = (_Bool )(tmp___0 == 0);
    }
  }
  {
#line 130
  fputs_unlocked((char const   */* __restrict  */)prompt___0, (FILE */* __restrict  */)out);
#line 131
  fflush_unlocked(out);
#line 134
  nread = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                  (FILE */* __restrict  */)in);
#line 145
  fseeko(out, (__off_t )0, 1);
  }
#line 147
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 149
    if (nread < 0) {
#line 150
      *(buf + 0) = (char )'\000';
    } else
#line 151
    if ((int )*(buf + (nread - 1)) == 10) {
#line 154
      *(buf + (nread - 1)) = (char )'\000';
#line 155
      if (tty_changed) {
        {
#line 158
        putc_unlocked('\n', out);
        }
      }
    }
  }
#line 165
  if (tty_changed) {
    {
#line 166
    tmp___3 = fileno(in);
#line 166
    tcsetattr(tmp___3, 2, (struct termios  const  *)(& s));
    }
  }
  {
#line 169
  funlockfile(out);
#line 171
  call_fclose((void *)tty);
  }
#line 173
  return (buf);
}
}
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 284 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len___0 ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    tmp___0 = len___0;
#line 287
    len___0 --;
#line 287
    if (! (tmp___0 > 0U)) {
#line 287
      goto while_break;
    }
    {
#line 289
    tmp = tolower((int )((unsigned char )*src));
#line 289
    fputc(tmp, fp);
#line 290
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 294 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len___0 ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    tmp___0 = len___0;
#line 297
    len___0 --;
#line 297
    if (! (tmp___0 > 0U)) {
#line 297
      goto while_break;
    }
    {
#line 299
    tmp = toupper((int )((unsigned char )*src));
#line 299
    fputc(tmp, fp);
#line 300
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 408 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static size_t strftime_case____0(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                                 int ut , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i___0 ;
  FILE *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len___0 ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___1 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  size_t _i___5 ;
  size_t _i___6 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  size_t _i___10 ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  size_t _i___17 ;
  size_t _i___18 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  size_t _i___23 ;
  size_t _i___24 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  size_t _i___25 ;
  size_t _i___26 ;
  void *__cil_tmp150 ;
  void *__cil_tmp151 ;
  void *__cil_tmp152 ;
  void *__cil_tmp153 ;
  void *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;

  {
#line 418
  maxsize = (size_t )-1;
#line 421
  hour12 = (int )tp->tm_hour;
#line 446
  i___0 = (size_t )0;
#line 447
  p = s;
#line 458
  copy = *tp;
#line 459
  tp = (struct tm  const  *)(& copy);
#line 462
  zone = (char const   *)((void *)0);
#line 470
  zone = (char const   *)tp->tm_zone;
#line 488
  if (hour12 > 12) {
#line 489
    hour12 -= 12;
  } else
#line 491
  if (hour12 == 0) {
#line 492
    hour12 = 12;
  }
#line 494
  f = format;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! ((int const   )*f != 0)) {
#line 494
      goto while_break;
    }
#line 496
    pad = 0;
#line 498
    digits = 0;
#line 512
    width = -1;
#line 513
    to_lowcase = (_Bool)0;
#line 514
    to_uppcase = upcase;
#line 516
    change_case = (_Bool)0;
#line 599
    if ((int const   )*f != 37) {
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 601
        _n = 1;
#line 601
        _delta = width - _n;
#line 601
        if (_delta > 0) {
#line 601
          tmp = _delta;
        } else {
#line 601
          tmp = 0;
        }
#line 601
        _incr = _n + tmp;
#line 601
        if ((size_t )_incr >= maxsize - i___0) {
#line 601
          return ((size_t )0);
        }
#line 601
        if (p) {
#line 601
          if (digits == 0) {
#line 601
            if (_delta > 0) {
#line 601
              if (pad == 48) {
                {
#line 601
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 601
                  _i = (size_t )0;
                  {
#line 601
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 601
                    if (! (_i < (size_t )_delta)) {
#line 601
                      goto while_break___2;
                    }
                    {
#line 601
                    fputc('0', p);
#line 601
                    _i ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 601
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 601
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 601
                  _i___0 = (size_t )0;
                  {
#line 601
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 601
                    if (! (_i___0 < (size_t )_delta)) {
#line 601
                      goto while_break___4;
                    }
                    {
#line 601
                    fputc(' ', p);
#line 601
                    _i___0 ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 601
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 601
          fputc((int )*f, p);
          }
        }
#line 601
        i___0 += (size_t )_incr;
#line 601
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 602
      goto __Cont;
    }
    {
#line 608
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 610
      f ++;
      {
#line 615
      if ((int const   )*f == 48) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 45) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 95) {
#line 615
        goto case_48;
      }
#line 620
      if ((int const   )*f == 94) {
#line 620
        goto case_94;
      }
#line 623
      if ((int const   )*f == 35) {
#line 623
        goto case_35;
      }
#line 627
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 616
      pad = (int )*f;
#line 617
      goto while_continue___5;
      case_94: /* CIL Label */ 
#line 621
      to_uppcase = (_Bool)1;
#line 622
      goto while_continue___5;
      case_35: /* CIL Label */ 
#line 624
      change_case = (_Bool)1;
#line 625
      goto while_continue___5;
      switch_default: /* CIL Label */ 
#line 628
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 630
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 634
    if ((unsigned int )*f - 48U <= 9U) {
#line 636
      width = 0;
      {
#line 637
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 639
        if (width > 214748364) {
#line 642
          width = 2147483647;
        } else
#line 639
        if (width == 214748364) {
#line 639
          if ((int const   )*f - 48 > 7) {
#line 642
            width = 2147483647;
          } else {
#line 645
            width *= 10;
#line 646
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 645
          width *= 10;
#line 646
          width += (int )((int const   )*f - 48);
        }
#line 648
        f ++;
#line 637
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 637
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 657
    if ((int const   )*f == 79) {
#line 657
      goto case_79;
    }
#line 657
    if ((int const   )*f == 69) {
#line 657
      goto case_79;
    }
#line 661
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 658
    tmp___0 = f;
#line 658
    f ++;
#line 658
    modifier = (int )*tmp___0;
#line 659
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 662
    modifier = 0;
#line 663
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 667
    format_char = (int )*f;
    {
#line 690
    if (format_char == 37) {
#line 690
      goto case_37;
    }
#line 696
    if (format_char == 97) {
#line 696
      goto case_97;
    }
#line 711
    if (format_char == 65) {
#line 711
      goto case_65;
    }
#line 727
    if (format_char == 104) {
#line 727
      goto case_104;
    }
#line 727
    if (format_char == 98) {
#line 727
      goto case_104;
    }
#line 742
    if (format_char == 66) {
#line 742
      goto case_66;
    }
#line 757
    if (format_char == 99) {
#line 757
      goto case_99;
    }
#line 816
    if (format_char == 67) {
#line 816
      goto case_67;
    }
#line 845
    if (format_char == 120) {
#line 845
      goto case_120;
    }
#line 858
    if (format_char == 68) {
#line 858
      goto case_68;
    }
#line 864
    if (format_char == 100) {
#line 864
      goto case_100;
    }
#line 870
    if (format_char == 101) {
#line 870
      goto case_101;
    }
#line 996
    if (format_char == 70) {
#line 996
      goto case_70;
    }
#line 1002
    if (format_char == 72) {
#line 1002
      goto case_72;
    }
#line 1008
    if (format_char == 73) {
#line 1008
      goto case_73;
    }
#line 1014
    if (format_char == 107) {
#line 1014
      goto case_107;
    }
#line 1020
    if (format_char == 108) {
#line 1020
      goto case_108;
    }
#line 1026
    if (format_char == 106) {
#line 1026
      goto case_106;
    }
#line 1032
    if (format_char == 77) {
#line 1032
      goto case_77;
    }
#line 1038
    if (format_char == 109) {
#line 1038
      goto case_109;
    }
#line 1045
    if (format_char == 78) {
#line 1045
      goto case_78;
    }
#line 1063
    if (format_char == 110) {
#line 1063
      goto case_110;
    }
#line 1067
    if (format_char == 80) {
#line 1067
      goto case_80;
    }
#line 1074
    if (format_char == 112) {
#line 1074
      goto case_112;
    }
#line 1087
    if (format_char == 82) {
#line 1087
      goto case_82;
    }
#line 1091
    if (format_char == 114) {
#line 1091
      goto case_114;
    }
#line 1102
    if (format_char == 83) {
#line 1102
      goto case_83;
    }
#line 1108
    if (format_char == 115) {
#line 1108
      goto case_115;
    }
#line 1135
    if (format_char == 88) {
#line 1135
      goto case_88;
    }
#line 1148
    if (format_char == 84) {
#line 1148
      goto case_84;
    }
#line 1152
    if (format_char == 116) {
#line 1152
      goto case_116;
    }
#line 1156
    if (format_char == 117) {
#line 1156
      goto case_117;
    }
#line 1159
    if (format_char == 85) {
#line 1159
      goto case_85;
    }
#line 1167
    if (format_char == 71) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 103) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 86) {
#line 1167
      goto case_71;
    }
#line 1223
    if (format_char == 87) {
#line 1223
      goto case_87;
    }
#line 1229
    if (format_char == 119) {
#line 1229
      goto case_119;
    }
#line 1235
    if (format_char == 89) {
#line 1235
      goto case_89;
    }
#line 1259
    if (format_char == 121) {
#line 1259
      goto case_121;
    }
#line 1282
    if (format_char == 90) {
#line 1282
      goto case_90;
    }
#line 1311
    if (format_char == 58) {
#line 1311
      goto case_58;
    }
#line 1321
    if (format_char == 122) {
#line 1321
      goto case_122;
    }
#line 1399
    if (format_char == 0) {
#line 1399
      goto case_0___0;
    }
#line 1402
    goto bad_format;
    case_37: /* CIL Label */ 
#line 691
    if (modifier != 0) {
#line 692
      goto bad_format;
    }
    {
#line 693
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 693
      _n___0 = 1;
#line 693
      _delta___0 = width - _n___0;
#line 693
      if (_delta___0 > 0) {
#line 693
        tmp___1 = _delta___0;
      } else {
#line 693
        tmp___1 = 0;
      }
#line 693
      _incr___0 = _n___0 + tmp___1;
#line 693
      if ((size_t )_incr___0 >= maxsize - i___0) {
#line 693
        return ((size_t )0);
      }
#line 693
      if (p) {
#line 693
        if (digits == 0) {
#line 693
          if (_delta___0 > 0) {
#line 693
            if (pad == 48) {
              {
#line 693
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 693
                _i___1 = (size_t )0;
                {
#line 693
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 693
                  if (! (_i___1 < (size_t )_delta___0)) {
#line 693
                    goto while_break___9;
                  }
                  {
#line 693
                  fputc('0', p);
#line 693
                  _i___1 ++;
                  }
                }
                while_break___9: /* CIL Label */ ;
                }
#line 693
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
              {
#line 693
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 693
                _i___2 = (size_t )0;
                {
#line 693
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 693
                  if (! (_i___2 < (size_t )_delta___0)) {
#line 693
                    goto while_break___11;
                  }
                  {
#line 693
                  fputc(' ', p);
#line 693
                  _i___2 ++;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 693
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 693
        fputc((int )*f, p);
        }
      }
#line 693
      i___0 += (size_t )_incr___0;
#line 693
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 694
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 697
    if (modifier != 0) {
#line 698
      goto bad_format;
    }
#line 699
    if (change_case) {
#line 701
      to_uppcase = (_Bool)1;
#line 702
      to_lowcase = (_Bool)0;
    }
#line 708
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 728
    if (change_case) {
#line 730
      to_uppcase = (_Bool)1;
#line 731
      to_lowcase = (_Bool)0;
    }
#line 733
    if (modifier != 0) {
#line 734
      goto bad_format;
    }
#line 739
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 743
    if (modifier != 0) {
#line 744
      goto bad_format;
    }
#line 745
    if (change_case) {
#line 747
      to_uppcase = (_Bool)1;
#line 748
      to_lowcase = (_Bool)0;
    }
#line 754
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 758
    if (modifier == 79) {
#line 759
      goto bad_format;
    }
#line 768
    goto underlying_strftime;
    subformat: 
    {
#line 773
    tmp___2 = strftime_case____0(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut,
                                 ns);
#line 773
    len___0 = tmp___2;
    }
    {
#line 777
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 777
      _n___1 = (int )len___0;
#line 777
      _delta___1 = width - _n___1;
#line 777
      if (_delta___1 > 0) {
#line 777
        tmp___3 = _delta___1;
      } else {
#line 777
        tmp___3 = 0;
      }
#line 777
      _incr___1 = _n___1 + tmp___3;
#line 777
      if ((size_t )_incr___1 >= maxsize - i___0) {
#line 777
        return ((size_t )0);
      }
#line 777
      if (p) {
#line 777
        if (digits == 0) {
#line 777
          if (_delta___1 > 0) {
#line 777
            if (pad == 48) {
              {
#line 777
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 777
                _i___3 = (size_t )0;
                {
#line 777
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 777
                  if (! (_i___3 < (size_t )_delta___1)) {
#line 777
                    goto while_break___14;
                  }
                  {
#line 777
                  fputc('0', p);
#line 777
                  _i___3 ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 777
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
              {
#line 777
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 777
                _i___4 = (size_t )0;
                {
#line 777
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 777
                  if (! (_i___4 < (size_t )_delta___1)) {
#line 777
                    goto while_break___16;
                  }
                  {
#line 777
                  fputc(' ', p);
#line 777
                  _i___4 ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
#line 777
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 777
        strftime_case____0(to_uppcase, p, subfmt, tp, ut, ns);
        }
      }
#line 777
      i___0 += (size_t )_incr___1;
#line 777
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 782
    goto switch_break___1;
    underlying_strftime: 
#line 790
    u = ufmt;
#line 803
    tmp___4 = u;
#line 803
    u ++;
#line 803
    *tmp___4 = (char )' ';
#line 804
    tmp___5 = u;
#line 804
    u ++;
#line 804
    *tmp___5 = (char )'%';
#line 805
    if (modifier != 0) {
#line 806
      tmp___6 = u;
#line 806
      u ++;
#line 806
      *tmp___6 = (char )modifier;
    }
    {
#line 807
    tmp___7 = u;
#line 807
    u ++;
#line 807
    *tmp___7 = (char )format_char;
#line 808
    *u = (char )'\000';
#line 809
    len___1 = strftime((char */* __restrict  */)(ubuf), (size_t )sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 810
    if (len___1 != 0U) {
      {
#line 811
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 811
        _n___2 = (int )(len___1 - 1U);
#line 811
        _delta___2 = width - _n___2;
#line 811
        if (_delta___2 > 0) {
#line 811
          tmp___8 = _delta___2;
        } else {
#line 811
          tmp___8 = 0;
        }
#line 811
        _incr___2 = _n___2 + tmp___8;
#line 811
        if ((size_t )_incr___2 >= maxsize - i___0) {
#line 811
          return ((size_t )0);
        }
#line 811
        if (p) {
#line 811
          if (digits == 0) {
#line 811
            if (_delta___2 > 0) {
#line 811
              if (pad == 48) {
                {
#line 811
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 811
                  _i___5 = (size_t )0;
                  {
#line 811
                  while (1) {
                    while_continue___19: /* CIL Label */ ;
#line 811
                    if (! (_i___5 < (size_t )_delta___2)) {
#line 811
                      goto while_break___19;
                    }
                    {
#line 811
                    fputc('0', p);
#line 811
                    _i___5 ++;
                    }
                  }
                  while_break___19: /* CIL Label */ ;
                  }
#line 811
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              } else {
                {
#line 811
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 811
                  _i___6 = (size_t )0;
                  {
#line 811
                  while (1) {
                    while_continue___21: /* CIL Label */ ;
#line 811
                    if (! (_i___6 < (size_t )_delta___2)) {
#line 811
                      goto while_break___21;
                    }
                    {
#line 811
                    fputc(' ', p);
#line 811
                    _i___6 ++;
                    }
                  }
                  while_break___21: /* CIL Label */ ;
                  }
#line 811
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
#line 811
          if (to_lowcase) {
            {
#line 811
            fwrite_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 811
          if (to_uppcase) {
            {
#line 811
            fwrite_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 811
            fwrite((void const   */* __restrict  */)(ubuf + 1), (size_t )_n___2, (size_t )1,
                   (FILE */* __restrict  */)p);
            }
          }
        }
#line 811
        i___0 += (size_t )_incr___2;
#line 811
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 813
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 817
    if (modifier == 79) {
#line 818
      goto bad_format;
    }
#line 819
    if (modifier == 69) {
#line 835
      goto underlying_strftime;
    }
#line 840
    century = (int )(tp->tm_year / 100 + 19);
#line 841
    if (tp->tm_year % 100 < 0) {
#line 841
      if (0 < century) {
#line 841
        tmp___9 = 1;
      } else {
#line 841
        tmp___9 = 0;
      }
    } else {
#line 841
      tmp___9 = 0;
    }
#line 841
    century -= tmp___9;
#line 842
    digits = 2;
#line 842
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 842
    u_number_value = (unsigned int )century;
#line 842
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 846
    if (modifier == 79) {
#line 847
      goto bad_format;
    }
#line 856
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 859
    if (modifier != 0) {
#line 860
      goto bad_format;
    }
#line 861
    subfmt = "%m/%d/%y";
#line 862
    goto subformat;
    case_100: /* CIL Label */ 
#line 865
    if (modifier == 69) {
#line 866
      goto bad_format;
    }
#line 868
    digits = 2;
#line 868
    number_value = (int )tp->tm_mday;
#line 868
    goto do_number;
    case_101: /* CIL Label */ 
#line 871
    if (modifier == 69) {
#line 872
      goto bad_format;
    }
#line 874
    digits = 2;
#line 874
    number_value = (int )tp->tm_mday;
#line 874
    goto do_number_spacepad;
    do_tz_offset: 
#line 880
    always_output_a_sign = (_Bool)1;
#line 881
    goto do_number_body;
    do_number_spacepad: 
#line 885
    if (pad != 48) {
#line 885
      if (pad != 45) {
#line 886
        pad = '_';
      }
    }
    do_number: 
#line 890
    negative_number = (_Bool )(number_value < 0);
#line 891
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 894
    always_output_a_sign = (_Bool)0;
#line 895
    tz_colon_mask = 0;
    do_number_body: 
#line 903
    if (modifier == 79) {
#line 903
      if (! negative_number) {
#line 921
        goto underlying_strftime;
      }
    }
#line 925
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 927
    if (negative_number) {
#line 928
      u_number_value = - u_number_value;
    }
    {
#line 930
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 932
      if (tz_colon_mask & 1) {
#line 933
        bufp --;
#line 933
        *bufp = (char )':';
      }
#line 934
      tz_colon_mask >>= 1;
#line 935
      bufp --;
#line 935
      *bufp = (char )(u_number_value % 10U + 48U);
#line 936
      u_number_value /= 10U;
#line 930
      if (! (u_number_value != 0U)) {
#line 930
        if (! (tz_colon_mask != 0)) {
#line 930
          goto while_break___22;
        }
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 941
    if (digits < width) {
#line 942
      digits = width;
    }
#line 944
    if (negative_number) {
#line 944
      sign_char = (char )'-';
    } else {
#line 944
      if (always_output_a_sign) {
#line 944
        tmp___10 = '+';
      } else {
#line 944
        tmp___10 = 0;
      }
#line 944
      sign_char = (char )tmp___10;
    }
#line 948
    if (pad == 45) {
#line 950
      if (sign_char) {
        {
#line 951
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 951
          _n___3 = 1;
#line 951
          _delta___3 = width - _n___3;
#line 951
          if (_delta___3 > 0) {
#line 951
            tmp___11 = _delta___3;
          } else {
#line 951
            tmp___11 = 0;
          }
#line 951
          _incr___3 = _n___3 + tmp___11;
#line 951
          if ((size_t )_incr___3 >= maxsize - i___0) {
#line 951
            return ((size_t )0);
          }
#line 951
          if (p) {
#line 951
            if (digits == 0) {
#line 951
              if (_delta___3 > 0) {
#line 951
                if (pad == 48) {
                  {
#line 951
                  while (1) {
                    while_continue___24: /* CIL Label */ ;
#line 951
                    _i___7 = (size_t )0;
                    {
#line 951
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 951
                      if (! (_i___7 < (size_t )_delta___3)) {
#line 951
                        goto while_break___25;
                      }
                      {
#line 951
                      fputc('0', p);
#line 951
                      _i___7 ++;
                      }
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 951
                    goto while_break___24;
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                } else {
                  {
#line 951
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 951
                    _i___8 = (size_t )0;
                    {
#line 951
                    while (1) {
                      while_continue___27: /* CIL Label */ ;
#line 951
                      if (! (_i___8 < (size_t )_delta___3)) {
#line 951
                        goto while_break___27;
                      }
                      {
#line 951
                      fputc(' ', p);
#line 951
                      _i___8 ++;
                      }
                    }
                    while_break___27: /* CIL Label */ ;
                    }
#line 951
                    goto while_break___26;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 951
            fputc((int )sign_char, p);
            }
          }
#line 951
          i___0 += (size_t )_incr___3;
#line 951
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    } else {
#line 955
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 958
      if (padding > 0) {
#line 960
        if (pad == 95) {
#line 962
          if ((size_t )padding >= maxsize - i___0) {
#line 963
            return ((size_t )0);
          }
#line 965
          if (p) {
            {
#line 966
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 966
              _i___9 = (size_t )0;
              {
#line 966
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 966
                if (! (_i___9 < (size_t )padding)) {
#line 966
                  goto while_break___29;
                }
                {
#line 966
                fputc(' ', p);
#line 966
                _i___9 ++;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
#line 966
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 967
          i___0 += (size_t )padding;
#line 968
          if (width > padding) {
#line 968
            width -= padding;
          } else {
#line 968
            width = 0;
          }
#line 969
          if (sign_char) {
            {
#line 970
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 970
              _n___4 = 1;
#line 970
              _delta___4 = width - _n___4;
#line 970
              if (_delta___4 > 0) {
#line 970
                tmp___12 = _delta___4;
              } else {
#line 970
                tmp___12 = 0;
              }
#line 970
              _incr___4 = _n___4 + tmp___12;
#line 970
              if ((size_t )_incr___4 >= maxsize - i___0) {
#line 970
                return ((size_t )0);
              }
#line 970
              if (p) {
#line 970
                if (digits == 0) {
#line 970
                  if (_delta___4 > 0) {
#line 970
                    if (pad == 48) {
                      {
#line 970
                      while (1) {
                        while_continue___31: /* CIL Label */ ;
#line 970
                        _i___10 = (size_t )0;
                        {
#line 970
                        while (1) {
                          while_continue___32: /* CIL Label */ ;
#line 970
                          if (! (_i___10 < (size_t )_delta___4)) {
#line 970
                            goto while_break___32;
                          }
                          {
#line 970
                          fputc('0', p);
#line 970
                          _i___10 ++;
                          }
                        }
                        while_break___32: /* CIL Label */ ;
                        }
#line 970
                        goto while_break___31;
                      }
                      while_break___31: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 970
                      while (1) {
                        while_continue___33: /* CIL Label */ ;
#line 970
                        _i___11 = (size_t )0;
                        {
#line 970
                        while (1) {
                          while_continue___34: /* CIL Label */ ;
#line 970
                          if (! (_i___11 < (size_t )_delta___4)) {
#line 970
                            goto while_break___34;
                          }
                          {
#line 970
                          fputc(' ', p);
#line 970
                          _i___11 ++;
                          }
                        }
                        while_break___34: /* CIL Label */ ;
                        }
#line 970
                        goto while_break___33;
                      }
                      while_break___33: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 970
                fputc((int )sign_char, p);
                }
              }
#line 970
              i___0 += (size_t )_incr___4;
#line 970
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
        } else {
#line 974
          if ((size_t )digits >= maxsize - i___0) {
#line 975
            return ((size_t )0);
          }
#line 977
          if (sign_char) {
            {
#line 978
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 978
              _n___5 = 1;
#line 978
              _delta___5 = width - _n___5;
#line 978
              if (_delta___5 > 0) {
#line 978
                tmp___13 = _delta___5;
              } else {
#line 978
                tmp___13 = 0;
              }
#line 978
              _incr___5 = _n___5 + tmp___13;
#line 978
              if ((size_t )_incr___5 >= maxsize - i___0) {
#line 978
                return ((size_t )0);
              }
#line 978
              if (p) {
#line 978
                if (digits == 0) {
#line 978
                  if (_delta___5 > 0) {
#line 978
                    if (pad == 48) {
                      {
#line 978
                      while (1) {
                        while_continue___36: /* CIL Label */ ;
#line 978
                        _i___12 = (size_t )0;
                        {
#line 978
                        while (1) {
                          while_continue___37: /* CIL Label */ ;
#line 978
                          if (! (_i___12 < (size_t )_delta___5)) {
#line 978
                            goto while_break___37;
                          }
                          {
#line 978
                          fputc('0', p);
#line 978
                          _i___12 ++;
                          }
                        }
                        while_break___37: /* CIL Label */ ;
                        }
#line 978
                        goto while_break___36;
                      }
                      while_break___36: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 978
                      while (1) {
                        while_continue___38: /* CIL Label */ ;
#line 978
                        _i___13 = (size_t )0;
                        {
#line 978
                        while (1) {
                          while_continue___39: /* CIL Label */ ;
#line 978
                          if (! (_i___13 < (size_t )_delta___5)) {
#line 978
                            goto while_break___39;
                          }
                          {
#line 978
                          fputc(' ', p);
#line 978
                          _i___13 ++;
                          }
                        }
                        while_break___39: /* CIL Label */ ;
                        }
#line 978
                        goto while_break___38;
                      }
                      while_break___38: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 978
                fputc((int )sign_char, p);
                }
              }
#line 978
              i___0 += (size_t )_incr___5;
#line 978
              goto while_break___35;
            }
            while_break___35: /* CIL Label */ ;
            }
          }
#line 980
          if (p) {
            {
#line 981
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 981
              _i___14 = (size_t )0;
              {
#line 981
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 981
                if (! (_i___14 < (size_t )padding)) {
#line 981
                  goto while_break___41;
                }
                {
#line 981
                fputc('0', p);
#line 981
                _i___14 ++;
                }
              }
              while_break___41: /* CIL Label */ ;
              }
#line 981
              goto while_break___40;
            }
            while_break___40: /* CIL Label */ ;
            }
          }
#line 982
          i___0 += (size_t )padding;
#line 983
          width = 0;
        }
      } else
#line 988
      if (sign_char) {
        {
#line 989
        while (1) {
          while_continue___42: /* CIL Label */ ;
#line 989
          _n___6 = 1;
#line 989
          _delta___6 = width - _n___6;
#line 989
          if (_delta___6 > 0) {
#line 989
            tmp___14 = _delta___6;
          } else {
#line 989
            tmp___14 = 0;
          }
#line 989
          _incr___6 = _n___6 + tmp___14;
#line 989
          if ((size_t )_incr___6 >= maxsize - i___0) {
#line 989
            return ((size_t )0);
          }
#line 989
          if (p) {
#line 989
            if (digits == 0) {
#line 989
              if (_delta___6 > 0) {
#line 989
                if (pad == 48) {
                  {
#line 989
                  while (1) {
                    while_continue___43: /* CIL Label */ ;
#line 989
                    _i___15 = (size_t )0;
                    {
#line 989
                    while (1) {
                      while_continue___44: /* CIL Label */ ;
#line 989
                      if (! (_i___15 < (size_t )_delta___6)) {
#line 989
                        goto while_break___44;
                      }
                      {
#line 989
                      fputc('0', p);
#line 989
                      _i___15 ++;
                      }
                    }
                    while_break___44: /* CIL Label */ ;
                    }
#line 989
                    goto while_break___43;
                  }
                  while_break___43: /* CIL Label */ ;
                  }
                } else {
                  {
#line 989
                  while (1) {
                    while_continue___45: /* CIL Label */ ;
#line 989
                    _i___16 = (size_t )0;
                    {
#line 989
                    while (1) {
                      while_continue___46: /* CIL Label */ ;
#line 989
                      if (! (_i___16 < (size_t )_delta___6)) {
#line 989
                        goto while_break___46;
                      }
                      {
#line 989
                      fputc(' ', p);
#line 989
                      _i___16 ++;
                      }
                    }
                    while_break___46: /* CIL Label */ ;
                    }
#line 989
                    goto while_break___45;
                  }
                  while_break___45: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 989
            fputc((int )sign_char, p);
            }
          }
#line 989
          i___0 += (size_t )_incr___6;
#line 989
          goto while_break___42;
        }
        while_break___42: /* CIL Label */ ;
        }
      }
    }
    {
#line 993
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 993
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 993
      _delta___7 = width - _n___7;
#line 993
      if (_delta___7 > 0) {
#line 993
        tmp___15 = _delta___7;
      } else {
#line 993
        tmp___15 = 0;
      }
#line 993
      _incr___7 = _n___7 + tmp___15;
#line 993
      if ((size_t )_incr___7 >= maxsize - i___0) {
#line 993
        return ((size_t )0);
      }
#line 993
      if (p) {
#line 993
        if (digits == 0) {
#line 993
          if (_delta___7 > 0) {
#line 993
            if (pad == 48) {
              {
#line 993
              while (1) {
                while_continue___48: /* CIL Label */ ;
#line 993
                _i___17 = (size_t )0;
                {
#line 993
                while (1) {
                  while_continue___49: /* CIL Label */ ;
#line 993
                  if (! (_i___17 < (size_t )_delta___7)) {
#line 993
                    goto while_break___49;
                  }
                  {
#line 993
                  fputc('0', p);
#line 993
                  _i___17 ++;
                  }
                }
                while_break___49: /* CIL Label */ ;
                }
#line 993
                goto while_break___48;
              }
              while_break___48: /* CIL Label */ ;
              }
            } else {
              {
#line 993
              while (1) {
                while_continue___50: /* CIL Label */ ;
#line 993
                _i___18 = (size_t )0;
                {
#line 993
                while (1) {
                  while_continue___51: /* CIL Label */ ;
#line 993
                  if (! (_i___18 < (size_t )_delta___7)) {
#line 993
                    goto while_break___51;
                  }
                  {
#line 993
                  fputc(' ', p);
#line 993
                  _i___18 ++;
                  }
                }
                while_break___51: /* CIL Label */ ;
                }
#line 993
                goto while_break___50;
              }
              while_break___50: /* CIL Label */ ;
              }
            }
          }
        }
#line 993
        if (to_lowcase) {
          {
#line 993
          fwrite_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 993
        if (to_uppcase) {
          {
#line 993
          fwrite_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 993
          fwrite((void const   */* __restrict  */)bufp, (size_t )_n___7, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 993
      i___0 += (size_t )_incr___7;
#line 993
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
#line 994
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 997
    if (modifier != 0) {
#line 998
      goto bad_format;
    }
#line 999
    subfmt = "%Y-%m-%d";
#line 1000
    goto subformat;
    case_72: /* CIL Label */ 
#line 1003
    if (modifier == 69) {
#line 1004
      goto bad_format;
    }
#line 1006
    digits = 2;
#line 1006
    number_value = (int )tp->tm_hour;
#line 1006
    goto do_number;
    case_73: /* CIL Label */ 
#line 1009
    if (modifier == 69) {
#line 1010
      goto bad_format;
    }
#line 1012
    digits = 2;
#line 1012
    number_value = hour12;
#line 1012
    goto do_number;
    case_107: /* CIL Label */ 
#line 1015
    if (modifier == 69) {
#line 1016
      goto bad_format;
    }
#line 1018
    digits = 2;
#line 1018
    number_value = (int )tp->tm_hour;
#line 1018
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1021
    if (modifier == 69) {
#line 1022
      goto bad_format;
    }
#line 1024
    digits = 2;
#line 1024
    number_value = hour12;
#line 1024
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1027
    if (modifier == 69) {
#line 1028
      goto bad_format;
    }
#line 1030
    digits = 3;
#line 1030
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1030
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1030
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1033
    if (modifier == 69) {
#line 1034
      goto bad_format;
    }
#line 1036
    digits = 2;
#line 1036
    number_value = (int )tp->tm_min;
#line 1036
    goto do_number;
    case_109: /* CIL Label */ 
#line 1039
    if (modifier == 69) {
#line 1040
      goto bad_format;
    }
#line 1042
    digits = 2;
#line 1042
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1042
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1042
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
#line 1049
    number_value = ns;
#line 1050
    if (width == -1) {
#line 1051
      width = 9;
    } else {
#line 1056
      j = width;
      {
#line 1056
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 1056
        if (! (j < 9)) {
#line 1056
          goto while_break___52;
        }
#line 1057
        number_value /= 10;
#line 1056
        j ++;
      }
      while_break___52: /* CIL Label */ ;
      }
    }
#line 1060
    digits = width;
#line 1060
    number_value = number_value;
#line 1060
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1064
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 1064
      _n___8 = 1;
#line 1064
      _delta___8 = width - _n___8;
#line 1064
      if (_delta___8 > 0) {
#line 1064
        tmp___16 = _delta___8;
      } else {
#line 1064
        tmp___16 = 0;
      }
#line 1064
      _incr___8 = _n___8 + tmp___16;
#line 1064
      if ((size_t )_incr___8 >= maxsize - i___0) {
#line 1064
        return ((size_t )0);
      }
#line 1064
      if (p) {
#line 1064
        if (digits == 0) {
#line 1064
          if (_delta___8 > 0) {
#line 1064
            if (pad == 48) {
              {
#line 1064
              while (1) {
                while_continue___54: /* CIL Label */ ;
#line 1064
                _i___19 = (size_t )0;
                {
#line 1064
                while (1) {
                  while_continue___55: /* CIL Label */ ;
#line 1064
                  if (! (_i___19 < (size_t )_delta___8)) {
#line 1064
                    goto while_break___55;
                  }
                  {
#line 1064
                  fputc('0', p);
#line 1064
                  _i___19 ++;
                  }
                }
                while_break___55: /* CIL Label */ ;
                }
#line 1064
                goto while_break___54;
              }
              while_break___54: /* CIL Label */ ;
              }
            } else {
              {
#line 1064
              while (1) {
                while_continue___56: /* CIL Label */ ;
#line 1064
                _i___20 = (size_t )0;
                {
#line 1064
                while (1) {
                  while_continue___57: /* CIL Label */ ;
#line 1064
                  if (! (_i___20 < (size_t )_delta___8)) {
#line 1064
                    goto while_break___57;
                  }
                  {
#line 1064
                  fputc(' ', p);
#line 1064
                  _i___20 ++;
                  }
                }
                while_break___57: /* CIL Label */ ;
                }
#line 1064
                goto while_break___56;
              }
              while_break___56: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1064
        fputc('\n', p);
        }
      }
#line 1064
      i___0 += (size_t )_incr___8;
#line 1064
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 1065
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1068
    to_lowcase = (_Bool)1;
#line 1070
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1075
    if (change_case) {
#line 1077
      to_uppcase = (_Bool)0;
#line 1078
      to_lowcase = (_Bool)1;
    }
#line 1084
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1088
    subfmt = "%H:%M";
#line 1089
    goto subformat;
    case_114: /* CIL Label */ 
#line 1099
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1103
    if (modifier == 69) {
#line 1104
      goto bad_format;
    }
#line 1106
    digits = 2;
#line 1106
    number_value = (int )tp->tm_sec;
#line 1106
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1113
    ltm = (struct tm )*tp;
#line 1114
    t = mktime(& ltm);
#line 1119
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1120
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1122
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1124
      d = (int )(t % 10L);
#line 1125
      t /= 10L;
#line 1126
      bufp --;
#line 1126
      if (negative_number) {
#line 1126
        tmp___17 = - d;
      } else {
#line 1126
        tmp___17 = d;
      }
#line 1126
      *bufp = (char )(tmp___17 + 48);
#line 1122
      if (! (t != 0L)) {
#line 1122
        goto while_break___58;
      }
    }
    while_break___58: /* CIL Label */ ;
    }
#line 1130
    digits = 1;
#line 1131
    always_output_a_sign = (_Bool)0;
#line 1132
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1136
    if (modifier == 79) {
#line 1137
      goto bad_format;
    }
#line 1146
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1149
    subfmt = "%H:%M:%S";
#line 1150
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1153
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1153
      _n___9 = 1;
#line 1153
      _delta___9 = width - _n___9;
#line 1153
      if (_delta___9 > 0) {
#line 1153
        tmp___18 = _delta___9;
      } else {
#line 1153
        tmp___18 = 0;
      }
#line 1153
      _incr___9 = _n___9 + tmp___18;
#line 1153
      if ((size_t )_incr___9 >= maxsize - i___0) {
#line 1153
        return ((size_t )0);
      }
#line 1153
      if (p) {
#line 1153
        if (digits == 0) {
#line 1153
          if (_delta___9 > 0) {
#line 1153
            if (pad == 48) {
              {
#line 1153
              while (1) {
                while_continue___60: /* CIL Label */ ;
#line 1153
                _i___21 = (size_t )0;
                {
#line 1153
                while (1) {
                  while_continue___61: /* CIL Label */ ;
#line 1153
                  if (! (_i___21 < (size_t )_delta___9)) {
#line 1153
                    goto while_break___61;
                  }
                  {
#line 1153
                  fputc('0', p);
#line 1153
                  _i___21 ++;
                  }
                }
                while_break___61: /* CIL Label */ ;
                }
#line 1153
                goto while_break___60;
              }
              while_break___60: /* CIL Label */ ;
              }
            } else {
              {
#line 1153
              while (1) {
                while_continue___62: /* CIL Label */ ;
#line 1153
                _i___22 = (size_t )0;
                {
#line 1153
                while (1) {
                  while_continue___63: /* CIL Label */ ;
#line 1153
                  if (! (_i___22 < (size_t )_delta___9)) {
#line 1153
                    goto while_break___63;
                  }
                  {
#line 1153
                  fputc(' ', p);
#line 1153
                  _i___22 ++;
                  }
                }
                while_break___63: /* CIL Label */ ;
                }
#line 1153
                goto while_break___62;
              }
              while_break___62: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1153
        fputc('\t', p);
        }
      }
#line 1153
      i___0 += (size_t )_incr___9;
#line 1153
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 1154
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1157
    digits = 1;
#line 1157
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1157
    goto do_number;
    case_85: /* CIL Label */ 
#line 1160
    if (modifier == 69) {
#line 1161
      goto bad_format;
    }
#line 1163
    digits = 2;
#line 1163
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1163
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1168
    if (modifier == 69) {
#line 1169
      goto bad_format;
    }
#line 1175
    if (tp->tm_year < 0) {
#line 1175
      tmp___19 = 300;
    } else {
#line 1175
      tmp___19 = -100;
    }
    {
#line 1175
    year = (int )(tp->tm_year + (int const   )tmp___19);
#line 1179
    year_adjust = 0;
#line 1180
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1180
    days = tmp___20;
    }
#line 1182
    if (days < 0) {
#line 1185
      year_adjust = -1;
#line 1186
      if ((year - 1) % 4 == 0) {
#line 1186
        if ((year - 1) % 100 != 0) {
#line 1186
          tmp___21 = 1;
        } else
#line 1186
        if ((year - 1) % 400 == 0) {
#line 1186
          tmp___21 = 1;
        } else {
#line 1186
          tmp___21 = 0;
        }
      } else {
#line 1186
        tmp___21 = 0;
      }
      {
#line 1186
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1191
      if (year % 4 == 0) {
#line 1191
        if (year % 100 != 0) {
#line 1191
          tmp___22 = 1;
        } else
#line 1191
        if (year % 400 == 0) {
#line 1191
          tmp___22 = 1;
        } else {
#line 1191
          tmp___22 = 0;
        }
      } else {
#line 1191
        tmp___22 = 0;
      }
      {
#line 1191
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1191
      d___0 = tmp___23;
      }
#line 1193
      if (0 <= d___0) {
#line 1196
        year_adjust = 1;
#line 1197
        days = d___0;
      }
    }
    {
#line 1203
    if ((int const   )*f == 103) {
#line 1203
      goto case_103___0;
    }
#line 1213
    if ((int const   )*f == 71) {
#line 1213
      goto case_71___0;
    }
#line 1218
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1205
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1206
    digits = 2;
#line 1206
    if (0 <= yy) {
#line 1206
      number_value = yy;
    } else {
#line 1206
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1206
        tmp___24 = - yy;
      } else {
#line 1206
        tmp___24 = yy + 100;
      }
#line 1206
      number_value = tmp___24;
    }
#line 1206
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1214
    digits = 4;
#line 1214
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1214
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1214
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1219
    digits = 2;
#line 1219
    number_value = days / 7 + 1;
#line 1219
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1224
    if (modifier == 69) {
#line 1225
      goto bad_format;
    }
#line 1227
    digits = 2;
#line 1227
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1227
    goto do_number;
    case_119: /* CIL Label */ 
#line 1230
    if (modifier == 69) {
#line 1231
      goto bad_format;
    }
#line 1233
    digits = 1;
#line 1233
    number_value = (int )tp->tm_wday;
#line 1233
    goto do_number;
    case_89: /* CIL Label */ 
#line 1236
    if (modifier == 69) {
#line 1250
      goto underlying_strftime;
    }
#line 1253
    if (modifier == 79) {
#line 1254
      goto bad_format;
    } else {
#line 1256
      digits = 4;
    }
#line 1256
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1256
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1256
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1260
    if (modifier == 69) {
#line 1271
      goto underlying_strftime;
    }
#line 1276
    yy___0 = (int )(tp->tm_year % 100);
#line 1277
    if (yy___0 < 0) {
#line 1278
      if (tp->tm_year < -1900) {
#line 1278
        yy___0 = - yy___0;
      } else {
#line 1278
        yy___0 += 100;
      }
    }
#line 1279
    digits = 2;
#line 1279
    number_value = yy___0;
#line 1279
    goto do_number;
    case_90: /* CIL Label */ 
#line 1283
    if (change_case) {
#line 1285
      to_uppcase = (_Bool)0;
#line 1286
      to_lowcase = (_Bool)1;
    }
#line 1294
    if (! zone) {
#line 1295
      zone = "";
    }
    {
#line 1307
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
#line 1307
      tmp___25 = strlen(zone);
#line 1307
      _n___10 = (int )tmp___25;
#line 1307
      _delta___10 = width - _n___10;
      }
#line 1307
      if (_delta___10 > 0) {
#line 1307
        tmp___26 = _delta___10;
      } else {
#line 1307
        tmp___26 = 0;
      }
#line 1307
      _incr___10 = _n___10 + tmp___26;
#line 1307
      if ((size_t )_incr___10 >= maxsize - i___0) {
#line 1307
        return ((size_t )0);
      }
#line 1307
      if (p) {
#line 1307
        if (digits == 0) {
#line 1307
          if (_delta___10 > 0) {
#line 1307
            if (pad == 48) {
              {
#line 1307
              while (1) {
                while_continue___65: /* CIL Label */ ;
#line 1307
                _i___23 = (size_t )0;
                {
#line 1307
                while (1) {
                  while_continue___66: /* CIL Label */ ;
#line 1307
                  if (! (_i___23 < (size_t )_delta___10)) {
#line 1307
                    goto while_break___66;
                  }
                  {
#line 1307
                  fputc('0', p);
#line 1307
                  _i___23 ++;
                  }
                }
                while_break___66: /* CIL Label */ ;
                }
#line 1307
                goto while_break___65;
              }
              while_break___65: /* CIL Label */ ;
              }
            } else {
              {
#line 1307
              while (1) {
                while_continue___67: /* CIL Label */ ;
#line 1307
                _i___24 = (size_t )0;
                {
#line 1307
                while (1) {
                  while_continue___68: /* CIL Label */ ;
#line 1307
                  if (! (_i___24 < (size_t )_delta___10)) {
#line 1307
                    goto while_break___68;
                  }
                  {
#line 1307
                  fputc(' ', p);
#line 1307
                  _i___24 ++;
                  }
                }
                while_break___68: /* CIL Label */ ;
                }
#line 1307
                goto while_break___67;
              }
              while_break___67: /* CIL Label */ ;
              }
            }
          }
        }
#line 1307
        if (to_lowcase) {
          {
#line 1307
          fwrite_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1307
        if (to_uppcase) {
          {
#line 1307
          fwrite_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1307
          fwrite((void const   */* __restrict  */)zone, (size_t )_n___10, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 1307
      i___0 += (size_t )_incr___10;
#line 1307
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 1309
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1314
    colons = (size_t )1;
    {
#line 1314
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1314
      if (! ((int const   )*(f + colons) == 58)) {
#line 1314
        goto while_break___69;
      }
#line 1315
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1314
      colons ++;
    }
    while_break___69: /* CIL Label */ ;
    }
#line 1316
    if ((int const   )*(f + colons) != 122) {
#line 1317
      goto bad_format;
    }
#line 1318
    f += colons;
#line 1319
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1322
    colons = (size_t )0;
    do_z_conversion: 
#line 1325
    if (tp->tm_isdst < 0) {
#line 1326
      goto switch_break___1;
    }
#line 1334
    diff = (int )tp->tm_gmtoff;
#line 1371
    hour_diff = (diff / 60) / 60;
#line 1372
    min_diff = (diff / 60) % 60;
#line 1373
    sec_diff = diff % 60;
    {
#line 1377
    if (colons == 0U) {
#line 1377
      goto case_0;
    }
#line 1380
    if (colons == 1U) {
#line 1380
      goto tz_hh_mm;
    }
#line 1383
    if (colons == 2U) {
#line 1383
      goto tz_hh_mm_ss;
    }
#line 1387
    if (colons == 3U) {
#line 1387
      goto case_3;
    }
#line 1394
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1378
    digits = 5;
#line 1378
    negative_number = (_Bool )(diff < 0);
#line 1378
    tz_colon_mask = 0;
#line 1378
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1378
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1381
    digits = 6;
#line 1381
    negative_number = (_Bool )(diff < 0);
#line 1381
    tz_colon_mask = 4;
#line 1381
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1381
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1384
    digits = 9;
#line 1384
    negative_number = (_Bool )(diff < 0);
#line 1384
    tz_colon_mask = 20;
#line 1384
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1384
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1388
    if (sec_diff != 0) {
#line 1389
      goto tz_hh_mm_ss;
    }
#line 1390
    if (min_diff != 0) {
#line 1391
      goto tz_hh_mm;
    }
#line 1392
    digits = 3;
#line 1392
    negative_number = (_Bool )(diff < 0);
#line 1392
    tz_colon_mask = 0;
#line 1392
    u_number_value = (unsigned int )hour_diff;
#line 1392
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1395
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1400
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1409
    flen = 1;
    {
#line 1409
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 1409
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1409
        goto while_break___70;
      }
#line 1410
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1409
      flen ++;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 1411
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 1411
      _n___11 = flen;
#line 1411
      _delta___11 = width - _n___11;
#line 1411
      if (_delta___11 > 0) {
#line 1411
        tmp___27 = _delta___11;
      } else {
#line 1411
        tmp___27 = 0;
      }
#line 1411
      _incr___11 = _n___11 + tmp___27;
#line 1411
      if ((size_t )_incr___11 >= maxsize - i___0) {
#line 1411
        return ((size_t )0);
      }
#line 1411
      if (p) {
#line 1411
        if (digits == 0) {
#line 1411
          if (_delta___11 > 0) {
#line 1411
            if (pad == 48) {
              {
#line 1411
              while (1) {
                while_continue___72: /* CIL Label */ ;
#line 1411
                _i___25 = (size_t )0;
                {
#line 1411
                while (1) {
                  while_continue___73: /* CIL Label */ ;
#line 1411
                  if (! (_i___25 < (size_t )_delta___11)) {
#line 1411
                    goto while_break___73;
                  }
                  {
#line 1411
                  fputc('0', p);
#line 1411
                  _i___25 ++;
                  }
                }
                while_break___73: /* CIL Label */ ;
                }
#line 1411
                goto while_break___72;
              }
              while_break___72: /* CIL Label */ ;
              }
            } else {
              {
#line 1411
              while (1) {
                while_continue___74: /* CIL Label */ ;
#line 1411
                _i___26 = (size_t )0;
                {
#line 1411
                while (1) {
                  while_continue___75: /* CIL Label */ ;
#line 1411
                  if (! (_i___26 < (size_t )_delta___11)) {
#line 1411
                    goto while_break___75;
                  }
                  {
#line 1411
                  fputc(' ', p);
#line 1411
                  _i___26 ++;
                  }
                }
                while_break___75: /* CIL Label */ ;
                }
#line 1411
                goto while_break___74;
              }
              while_break___74: /* CIL Label */ ;
              }
            }
          }
        }
#line 1411
        if (to_lowcase) {
          {
#line 1411
          fwrite_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1411
        if (to_uppcase) {
          {
#line 1411
          fwrite_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1411
          fwrite((void const   */* __restrict  */)(f + (1 - flen)), (size_t )_n___11,
                 (size_t )1, (FILE */* __restrict  */)p);
          }
        }
      }
#line 1411
      i___0 += (size_t )_incr___11;
#line 1411
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 1413
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 494
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (i___0);
}
}
#line 1431 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1436
  tmp = strftime_case____0((_Bool)0, s, format, tp, ut, ns);
  }
#line 1436
  return (tmp);
}
}
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/exitfail.h"
int volatile   exit_failure ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
_Bool gl_des_is_weak_key(char const   *key ) ;
#line 63
void gl_des_setkey(gl_des_ctx *ctx , char const   *key ) ;
#line 69
_Bool gl_des_makekey(gl_des_ctx *ctx , char const   *key , size_t keylen ) ;
#line 74
void gl_des_ecb_crypt(gl_des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) ;
#line 87
void gl_3des_set2keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ) ;
#line 97
void gl_3des_set3keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ,
                      char const   *key3 ) ;
#line 106
_Bool gl_3des_makekey(gl_3des_ctx *ctx , char const   *key , size_t keylen ) ;
#line 114
void gl_3des_ecb_crypt(gl_3des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) ;
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox1[64]  = 
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
  {      (uint32_t const   )16843776,      (uint32_t const   )0,      (uint32_t const   )65536,      (uint32_t const   )16843780, 
        (uint32_t const   )16842756,      (uint32_t const   )66564,      (uint32_t const   )4,      (uint32_t const   )65536, 
        (uint32_t const   )1024,      (uint32_t const   )16843776,      (uint32_t const   )16843780,      (uint32_t const   )1024, 
        (uint32_t const   )16778244,      (uint32_t const   )16842756,      (uint32_t const   )16777216,      (uint32_t const   )4, 
        (uint32_t const   )1028,      (uint32_t const   )16778240,      (uint32_t const   )16778240,      (uint32_t const   )66560, 
        (uint32_t const   )66560,      (uint32_t const   )16842752,      (uint32_t const   )16842752,      (uint32_t const   )16778244, 
        (uint32_t const   )65540,      (uint32_t const   )16777220,      (uint32_t const   )16777220,      (uint32_t const   )65540, 
        (uint32_t const   )0,      (uint32_t const   )1028,      (uint32_t const   )66564,      (uint32_t const   )16777216, 
        (uint32_t const   )65536,      (uint32_t const   )16843780,      (uint32_t const   )4,      (uint32_t const   )16842752, 
        (uint32_t const   )16843776,      (uint32_t const   )16777216,      (uint32_t const   )16777216,      (uint32_t const   )1024, 
        (uint32_t const   )16842756,      (uint32_t const   )65536,      (uint32_t const   )66560,      (uint32_t const   )16777220, 
        (uint32_t const   )1024,      (uint32_t const   )4,      (uint32_t const   )16778244,      (uint32_t const   )66564, 
        (uint32_t const   )16843780,      (uint32_t const   )65540,      (uint32_t const   )16842752,      (uint32_t const   )16778244, 
        (uint32_t const   )16777220,      (uint32_t const   )1028,      (uint32_t const   )66564,      (uint32_t const   )16843776, 
        (uint32_t const   )1028,      (uint32_t const   )16778240,      (uint32_t const   )16778240,      (uint32_t const   )0, 
        (uint32_t const   )65540,      (uint32_t const   )66560,      (uint32_t const   )0,      (uint32_t const   )16842756};
#line 124 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox2[64]  = 
#line 124
  {      (uint32_t const   )2148565024U,      (uint32_t const   )2147516416U,      (uint32_t const   )32768,      (uint32_t const   )1081376, 
        (uint32_t const   )1048576,      (uint32_t const   )32,      (uint32_t const   )2148532256U,      (uint32_t const   )2147516448U, 
        (uint32_t const   )2147483680U,      (uint32_t const   )2148565024U,      (uint32_t const   )2148564992U,      (uint32_t const   )2147483648U, 
        (uint32_t const   )2147516416U,      (uint32_t const   )1048576,      (uint32_t const   )32,      (uint32_t const   )2148532256U, 
        (uint32_t const   )1081344,      (uint32_t const   )1048608,      (uint32_t const   )2147516448U,      (uint32_t const   )0, 
        (uint32_t const   )2147483648U,      (uint32_t const   )32768,      (uint32_t const   )1081376,      (uint32_t const   )2148532224U, 
        (uint32_t const   )1048608,      (uint32_t const   )2147483680U,      (uint32_t const   )0,      (uint32_t const   )1081344, 
        (uint32_t const   )32800,      (uint32_t const   )2148564992U,      (uint32_t const   )2148532224U,      (uint32_t const   )32800, 
        (uint32_t const   )0,      (uint32_t const   )1081376,      (uint32_t const   )2148532256U,      (uint32_t const   )1048576, 
        (uint32_t const   )2147516448U,      (uint32_t const   )2148532224U,      (uint32_t const   )2148564992U,      (uint32_t const   )32768, 
        (uint32_t const   )2148532224U,      (uint32_t const   )2147516416U,      (uint32_t const   )32,      (uint32_t const   )2148565024U, 
        (uint32_t const   )1081376,      (uint32_t const   )32,      (uint32_t const   )32768,      (uint32_t const   )2147483648U, 
        (uint32_t const   )32800,      (uint32_t const   )2148564992U,      (uint32_t const   )1048576,      (uint32_t const   )2147483680U, 
        (uint32_t const   )1048608,      (uint32_t const   )2147516448U,      (uint32_t const   )2147483680U,      (uint32_t const   )1048608, 
        (uint32_t const   )1081344,      (uint32_t const   )0,      (uint32_t const   )2147516416U,      (uint32_t const   )32800, 
        (uint32_t const   )2147483648U,      (uint32_t const   )2148532256U,      (uint32_t const   )2148565024U,      (uint32_t const   )1081344};
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox3[64]  = 
#line 138
  {      (uint32_t const   )520,      (uint32_t const   )134349312,      (uint32_t const   )0,      (uint32_t const   )134348808, 
        (uint32_t const   )134218240,      (uint32_t const   )0,      (uint32_t const   )131592,      (uint32_t const   )134218240, 
        (uint32_t const   )131080,      (uint32_t const   )134217736,      (uint32_t const   )134217736,      (uint32_t const   )131072, 
        (uint32_t const   )134349320,      (uint32_t const   )131080,      (uint32_t const   )134348800,      (uint32_t const   )520, 
        (uint32_t const   )134217728,      (uint32_t const   )8,      (uint32_t const   )134349312,      (uint32_t const   )512, 
        (uint32_t const   )131584,      (uint32_t const   )134348800,      (uint32_t const   )134348808,      (uint32_t const   )131592, 
        (uint32_t const   )134218248,      (uint32_t const   )131584,      (uint32_t const   )131072,      (uint32_t const   )134218248, 
        (uint32_t const   )8,      (uint32_t const   )134349320,      (uint32_t const   )512,      (uint32_t const   )134217728, 
        (uint32_t const   )134349312,      (uint32_t const   )134217728,      (uint32_t const   )131080,      (uint32_t const   )520, 
        (uint32_t const   )131072,      (uint32_t const   )134349312,      (uint32_t const   )134218240,      (uint32_t const   )0, 
        (uint32_t const   )512,      (uint32_t const   )131080,      (uint32_t const   )134349320,      (uint32_t const   )134218240, 
        (uint32_t const   )134217736,      (uint32_t const   )512,      (uint32_t const   )0,      (uint32_t const   )134348808, 
        (uint32_t const   )134218248,      (uint32_t const   )131072,      (uint32_t const   )134217728,      (uint32_t const   )134349320, 
        (uint32_t const   )8,      (uint32_t const   )131592,      (uint32_t const   )131584,      (uint32_t const   )134217736, 
        (uint32_t const   )134348800,      (uint32_t const   )134218248,      (uint32_t const   )520,      (uint32_t const   )134348800, 
        (uint32_t const   )131592,      (uint32_t const   )8,      (uint32_t const   )134348808,      (uint32_t const   )131584};
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox4[64]  = 
#line 152
  {      (uint32_t const   )8396801,      (uint32_t const   )8321,      (uint32_t const   )8321,      (uint32_t const   )128, 
        (uint32_t const   )8396928,      (uint32_t const   )8388737,      (uint32_t const   )8388609,      (uint32_t const   )8193, 
        (uint32_t const   )0,      (uint32_t const   )8396800,      (uint32_t const   )8396800,      (uint32_t const   )8396929, 
        (uint32_t const   )129,      (uint32_t const   )0,      (uint32_t const   )8388736,      (uint32_t const   )8388609, 
        (uint32_t const   )1,      (uint32_t const   )8192,      (uint32_t const   )8388608,      (uint32_t const   )8396801, 
        (uint32_t const   )128,      (uint32_t const   )8388608,      (uint32_t const   )8193,      (uint32_t const   )8320, 
        (uint32_t const   )8388737,      (uint32_t const   )1,      (uint32_t const   )8320,      (uint32_t const   )8388736, 
        (uint32_t const   )8192,      (uint32_t const   )8396928,      (uint32_t const   )8396929,      (uint32_t const   )129, 
        (uint32_t const   )8388736,      (uint32_t const   )8388609,      (uint32_t const   )8396800,      (uint32_t const   )8396929, 
        (uint32_t const   )129,      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )8396800, 
        (uint32_t const   )8320,      (uint32_t const   )8388736,      (uint32_t const   )8388737,      (uint32_t const   )1, 
        (uint32_t const   )8396801,      (uint32_t const   )8321,      (uint32_t const   )8321,      (uint32_t const   )128, 
        (uint32_t const   )8396929,      (uint32_t const   )129,      (uint32_t const   )1,      (uint32_t const   )8192, 
        (uint32_t const   )8388609,      (uint32_t const   )8193,      (uint32_t const   )8396928,      (uint32_t const   )8388737, 
        (uint32_t const   )8193,      (uint32_t const   )8320,      (uint32_t const   )8388608,      (uint32_t const   )8396801, 
        (uint32_t const   )128,      (uint32_t const   )8388608,      (uint32_t const   )8192,      (uint32_t const   )8396928};
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox5[64]  = 
#line 166
  {      (uint32_t const   )256,      (uint32_t const   )34078976,      (uint32_t const   )34078720,      (uint32_t const   )1107296512, 
        (uint32_t const   )524288,      (uint32_t const   )256,      (uint32_t const   )1073741824,      (uint32_t const   )34078720, 
        (uint32_t const   )1074266368,      (uint32_t const   )524288,      (uint32_t const   )33554688,      (uint32_t const   )1074266368, 
        (uint32_t const   )1107296512,      (uint32_t const   )1107820544,      (uint32_t const   )524544,      (uint32_t const   )1073741824, 
        (uint32_t const   )33554432,      (uint32_t const   )1074266112,      (uint32_t const   )1074266112,      (uint32_t const   )0, 
        (uint32_t const   )1073742080,      (uint32_t const   )1107820800,      (uint32_t const   )1107820800,      (uint32_t const   )33554688, 
        (uint32_t const   )1107820544,      (uint32_t const   )1073742080,      (uint32_t const   )0,      (uint32_t const   )1107296256, 
        (uint32_t const   )34078976,      (uint32_t const   )33554432,      (uint32_t const   )1107296256,      (uint32_t const   )524544, 
        (uint32_t const   )524288,      (uint32_t const   )1107296512,      (uint32_t const   )256,      (uint32_t const   )33554432, 
        (uint32_t const   )1073741824,      (uint32_t const   )34078720,      (uint32_t const   )1107296512,      (uint32_t const   )1074266368, 
        (uint32_t const   )33554688,      (uint32_t const   )1073741824,      (uint32_t const   )1107820544,      (uint32_t const   )34078976, 
        (uint32_t const   )1074266368,      (uint32_t const   )256,      (uint32_t const   )33554432,      (uint32_t const   )1107820544, 
        (uint32_t const   )1107820800,      (uint32_t const   )524544,      (uint32_t const   )1107296256,      (uint32_t const   )1107820800, 
        (uint32_t const   )34078720,      (uint32_t const   )0,      (uint32_t const   )1074266112,      (uint32_t const   )1107296256, 
        (uint32_t const   )524544,      (uint32_t const   )33554688,      (uint32_t const   )1073742080,      (uint32_t const   )524288, 
        (uint32_t const   )0,      (uint32_t const   )1074266112,      (uint32_t const   )34078976,      (uint32_t const   )1073742080};
#line 180 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox6[64]  = 
#line 180
  {      (uint32_t const   )536870928,      (uint32_t const   )541065216,      (uint32_t const   )16384,      (uint32_t const   )541081616, 
        (uint32_t const   )541065216,      (uint32_t const   )16,      (uint32_t const   )541081616,      (uint32_t const   )4194304, 
        (uint32_t const   )536887296,      (uint32_t const   )4210704,      (uint32_t const   )4194304,      (uint32_t const   )536870928, 
        (uint32_t const   )4194320,      (uint32_t const   )536887296,      (uint32_t const   )536870912,      (uint32_t const   )16400, 
        (uint32_t const   )0,      (uint32_t const   )4194320,      (uint32_t const   )536887312,      (uint32_t const   )16384, 
        (uint32_t const   )4210688,      (uint32_t const   )536887312,      (uint32_t const   )16,      (uint32_t const   )541065232, 
        (uint32_t const   )541065232,      (uint32_t const   )0,      (uint32_t const   )4210704,      (uint32_t const   )541081600, 
        (uint32_t const   )16400,      (uint32_t const   )4210688,      (uint32_t const   )541081600,      (uint32_t const   )536870912, 
        (uint32_t const   )536887296,      (uint32_t const   )16,      (uint32_t const   )541065232,      (uint32_t const   )4210688, 
        (uint32_t const   )541081616,      (uint32_t const   )4194304,      (uint32_t const   )16400,      (uint32_t const   )536870928, 
        (uint32_t const   )4194304,      (uint32_t const   )536887296,      (uint32_t const   )536870912,      (uint32_t const   )16400, 
        (uint32_t const   )536870928,      (uint32_t const   )541081616,      (uint32_t const   )4210688,      (uint32_t const   )541065216, 
        (uint32_t const   )4210704,      (uint32_t const   )541081600,      (uint32_t const   )0,      (uint32_t const   )541065232, 
        (uint32_t const   )16,      (uint32_t const   )16384,      (uint32_t const   )541065216,      (uint32_t const   )4210704, 
        (uint32_t const   )16384,      (uint32_t const   )4194320,      (uint32_t const   )536887312,      (uint32_t const   )0, 
        (uint32_t const   )541081600,      (uint32_t const   )536870912,      (uint32_t const   )4194320,      (uint32_t const   )536887312};
#line 194 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox7[64]  = 
#line 194
  {      (uint32_t const   )2097152,      (uint32_t const   )69206018,      (uint32_t const   )67110914,      (uint32_t const   )0, 
        (uint32_t const   )2048,      (uint32_t const   )67110914,      (uint32_t const   )2099202,      (uint32_t const   )69208064, 
        (uint32_t const   )69208066,      (uint32_t const   )2097152,      (uint32_t const   )0,      (uint32_t const   )67108866, 
        (uint32_t const   )2,      (uint32_t const   )67108864,      (uint32_t const   )69206018,      (uint32_t const   )2050, 
        (uint32_t const   )67110912,      (uint32_t const   )2099202,      (uint32_t const   )2097154,      (uint32_t const   )67110912, 
        (uint32_t const   )67108866,      (uint32_t const   )69206016,      (uint32_t const   )69208064,      (uint32_t const   )2097154, 
        (uint32_t const   )69206016,      (uint32_t const   )2048,      (uint32_t const   )2050,      (uint32_t const   )69208066, 
        (uint32_t const   )2099200,      (uint32_t const   )2,      (uint32_t const   )67108864,      (uint32_t const   )2099200, 
        (uint32_t const   )67108864,      (uint32_t const   )2099200,      (uint32_t const   )2097152,      (uint32_t const   )67110914, 
        (uint32_t const   )67110914,      (uint32_t const   )69206018,      (uint32_t const   )69206018,      (uint32_t const   )2, 
        (uint32_t const   )2097154,      (uint32_t const   )67108864,      (uint32_t const   )67110912,      (uint32_t const   )2097152, 
        (uint32_t const   )69208064,      (uint32_t const   )2050,      (uint32_t const   )2099202,      (uint32_t const   )69208064, 
        (uint32_t const   )2050,      (uint32_t const   )67108866,      (uint32_t const   )69208066,      (uint32_t const   )69206016, 
        (uint32_t const   )2099200,      (uint32_t const   )0,      (uint32_t const   )2,      (uint32_t const   )69208066, 
        (uint32_t const   )0,      (uint32_t const   )2099202,      (uint32_t const   )69206016,      (uint32_t const   )2048, 
        (uint32_t const   )67108866,      (uint32_t const   )67110912,      (uint32_t const   )2048,      (uint32_t const   )2097154};
#line 208 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox8[64]  = 
#line 208
  {      (uint32_t const   )268439616,      (uint32_t const   )4096,      (uint32_t const   )262144,      (uint32_t const   )268701760, 
        (uint32_t const   )268435456,      (uint32_t const   )268439616,      (uint32_t const   )64,      (uint32_t const   )268435456, 
        (uint32_t const   )262208,      (uint32_t const   )268697600,      (uint32_t const   )268701760,      (uint32_t const   )266240, 
        (uint32_t const   )268701696,      (uint32_t const   )266304,      (uint32_t const   )4096,      (uint32_t const   )64, 
        (uint32_t const   )268697600,      (uint32_t const   )268435520,      (uint32_t const   )268439552,      (uint32_t const   )4160, 
        (uint32_t const   )266240,      (uint32_t const   )262208,      (uint32_t const   )268697664,      (uint32_t const   )268701696, 
        (uint32_t const   )4160,      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )268697664, 
        (uint32_t const   )268435520,      (uint32_t const   )268439552,      (uint32_t const   )266304,      (uint32_t const   )262144, 
        (uint32_t const   )266304,      (uint32_t const   )262144,      (uint32_t const   )268701696,      (uint32_t const   )4096, 
        (uint32_t const   )64,      (uint32_t const   )268697664,      (uint32_t const   )4096,      (uint32_t const   )266304, 
        (uint32_t const   )268439552,      (uint32_t const   )64,      (uint32_t const   )268435520,      (uint32_t const   )268697600, 
        (uint32_t const   )268697664,      (uint32_t const   )268435456,      (uint32_t const   )262144,      (uint32_t const   )268439616, 
        (uint32_t const   )0,      (uint32_t const   )268701760,      (uint32_t const   )262208,      (uint32_t const   )268435520, 
        (uint32_t const   )268697600,      (uint32_t const   )268439552,      (uint32_t const   )268439616,      (uint32_t const   )0, 
        (uint32_t const   )268701760,      (uint32_t const   )266240,      (uint32_t const   )266240,      (uint32_t const   )4160, 
        (uint32_t const   )4160,      (uint32_t const   )262208,      (uint32_t const   )268435456,      (uint32_t const   )268701696};
#line 226 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   leftkey_swap[16]  = 
#line 226
  {      (uint32_t const   )0,      (uint32_t const   )1,      (uint32_t const   )256,      (uint32_t const   )257, 
        (uint32_t const   )65536,      (uint32_t const   )65537,      (uint32_t const   )65792,      (uint32_t const   )65793, 
        (uint32_t const   )16777216,      (uint32_t const   )16777217,      (uint32_t const   )16777472,      (uint32_t const   )16777473, 
        (uint32_t const   )16842752,      (uint32_t const   )16842753,      (uint32_t const   )16843008,      (uint32_t const   )16843009};
#line 233 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   rightkey_swap[16]  = 
#line 233
  {      (uint32_t const   )0,      (uint32_t const   )16777216,      (uint32_t const   )65536,      (uint32_t const   )16842752, 
        (uint32_t const   )256,      (uint32_t const   )16777472,      (uint32_t const   )65792,      (uint32_t const   )16843008, 
        (uint32_t const   )1,      (uint32_t const   )16777217,      (uint32_t const   )65537,      (uint32_t const   )16842753, 
        (uint32_t const   )257,      (uint32_t const   )16777473,      (uint32_t const   )65793,      (uint32_t const   )16843009};
#line 246 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static unsigned char const   encrypt_rotate_tab[16]  = 
#line 246
  {      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )1};
#line 257 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static unsigned char const   weak_keys[64][8]  = 
#line 257
  { {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254}};
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
_Bool gl_des_is_weak_key(char const   *key ) 
{ 
  char work[8] ;
  int i___0 ;
  int left ;
  int right ;
  int middle ;
  int cmp_result ;
  void *__cil_tmp8 ;

  {
#line 331
  i___0 = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i___0 < 8)) {
#line 331
      goto while_break;
    }
#line 332
    work[i___0] = (char )((int )((unsigned char )*(key + i___0)) & 254);
#line 331
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  left = 0;
#line 336
  right = 63;
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 337
    if (! (left <= right)) {
#line 337
      goto while_break___0;
    }
    {
#line 339
    middle = (left + right) / 2;
#line 341
    cmp_result = memcmp((void const   *)(work), (void const   *)(weak_keys[middle]),
                        (size_t )8);
    }
#line 341
    if (! cmp_result) {
#line 342
      return ((_Bool)1);
    }
#line 344
    if (cmp_result > 0) {
#line 345
      left = middle + 1;
    } else {
#line 347
      right = middle - 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 350
  return ((_Bool)0);
}
}
#line 435 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static void des_key_schedule(char const   *_rawkey , uint32_t *subkey ) 
{ 
  unsigned char const   *rawkey ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  int round ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 438
  rawkey = (unsigned char const   *)_rawkey;
#line 442
  left = (uint32_t )(((((int const   )*(rawkey + 0) << 24) | ((int const   )*(rawkey + 1) << 16)) | ((int const   )*(rawkey + 2) << 8)) | (int const   )*(rawkey + 3));
#line 442
  right = (uint32_t )(((((int const   )*(rawkey + 4) << 24) | ((int const   )*(rawkey + 5) << 16)) | ((int const   )*(rawkey + 6) << 8)) | (int const   )*(rawkey + 7));
#line 443
  work = ((right >> 4) ^ left) & 252645135U;
#line 443
  left ^= work;
#line 443
  right ^= work << 4;
#line 444
  work = (right ^ left) & 269488144U;
#line 444
  left ^= work;
#line 444
  right ^= work;
#line 445
  left = (uint32_t )((((((((leftkey_swap[left & 15U] << 3) | (leftkey_swap[(left >> 8) & 15U] << 2)) | (leftkey_swap[(left >> 16) & 15U] << 1)) | leftkey_swap[(left >> 24) & 15U]) | (leftkey_swap[(left >> 5) & 15U] << 7)) | (leftkey_swap[(left >> 13) & 15U] << 6)) | (leftkey_swap[(left >> 21) & 15U] << 5)) | (leftkey_swap[(left >> 29) & 15U] << 4));
#line 454
  left &= 268435455U;
#line 456
  right = (uint32_t )((((((((rightkey_swap[(right >> 1) & 15U] << 3) | (rightkey_swap[(right >> 9) & 15U] << 2)) | (rightkey_swap[(right >> 17) & 15U] << 1)) | rightkey_swap[(right >> 25) & 15U]) | (rightkey_swap[(right >> 4) & 15U] << 7)) | (rightkey_swap[(right >> 12) & 15U] << 6)) | (rightkey_swap[(right >> 20) & 15U] << 5)) | (rightkey_swap[(right >> 28) & 15U] << 4));
#line 465
  right &= 268435455U;
#line 467
  round = 0;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (round < 16)) {
#line 467
      goto while_break;
    }
#line 469
    left = ((left << (int const   )encrypt_rotate_tab[round]) | (left >> (28 - (int )encrypt_rotate_tab[round]))) & 268435455U;
#line 471
    right = ((right << (int const   )encrypt_rotate_tab[round]) | (right >> (28 - (int )encrypt_rotate_tab[round]))) & 268435455U;
#line 474
    tmp = subkey;
#line 474
    subkey ++;
#line 474
    *tmp = ((((((((((((((((((((((left << 4) & 603979776U) | ((left << 28) & 268435456U)) | ((left << 14) & 134217728U)) | ((left << 18) & 34078720U)) | ((left << 6) & 16777216U)) | ((left << 9) & 2097152U)) | ((left >> 1) & 1048576U)) | ((left << 10) & 262144U)) | ((left << 2) & 131072U)) | ((left >> 10) & 65536U)) | ((right >> 13) & 8192U)) | ((right >> 4) & 4096U)) | ((right << 6) & 2048U)) | ((right >> 1) & 1024U)) | ((right >> 14) & 512U)) | (right & 256U)) | ((right >> 5) & 32U)) | ((right >> 10) & 16U)) | ((right >> 3) & 8U)) | ((right >> 18) & 4U)) | ((right >> 26) & 2U)) | ((right >> 24) & 1U);
#line 497
    tmp___0 = subkey;
#line 497
    subkey ++;
#line 497
    *tmp___0 = ((((((((((((((((((((((left << 15) & 536870912U) | ((left << 17) & 268435456U)) | ((left << 10) & 134217728U)) | ((left << 22) & 67108864U)) | ((left >> 2) & 33554432U)) | ((left << 1) & 16777216U)) | ((left << 16) & 2097152U)) | ((left << 11) & 1048576U)) | ((left << 3) & 524288U)) | ((left >> 6) & 262144U)) | ((left << 15) & 131072U)) | ((left >> 4) & 65536U)) | ((right >> 2) & 8192U)) | ((right << 8) & 4096U)) | ((right >> 14) & 2056U)) | ((right >> 9) & 1024U)) | (right & 512U)) | ((right << 7) & 256U)) | ((right >> 7) & 32U)) | ((right >> 3) & 17U)) | ((right << 2) & 4U)) | ((right >> 21) & 2U);
#line 467
    round ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return;
}
}
#line 522 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_des_setkey(gl_des_ctx *ctx , char const   *key ) 
{ 
  int i___0 ;

  {
  {
#line 527
  des_key_schedule(key, ctx->encrypt_subkeys);
#line 529
  i___0 = 0;
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (i___0 < 32)) {
#line 529
      goto while_break;
    }
#line 531
    ctx->decrypt_subkeys[i___0] = ctx->encrypt_subkeys[30 - i___0];
#line 532
    ctx->decrypt_subkeys[i___0 + 1] = ctx->encrypt_subkeys[31 - i___0];
#line 529
    i___0 += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return;
}
}
#line 536 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
_Bool gl_des_makekey(gl_des_ctx *ctx , char const   *key , size_t keylen ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 539
  if (keylen != 8U) {
#line 540
    return ((_Bool)0);
  }
  {
#line 542
  gl_des_setkey(ctx, key);
#line 544
  tmp = gl_des_is_weak_key(key);
  }
#line 544
  if (tmp) {
#line 544
    tmp___0 = 0;
  } else {
#line 544
    tmp___0 = 1;
  }
#line 544
  return ((_Bool )tmp___0);
}
}
#line 547 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_des_ecb_crypt(gl_des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) 
{ 
  unsigned char const   *from ;
  unsigned char *to ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  uint32_t *keys ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t *tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t *tmp___30 ;

  {
#line 550
  from = (unsigned char const   *)_from;
#line 551
  to = (unsigned char *)_to;
#line 555
  if (mode___0) {
#line 555
    keys = ctx->decrypt_subkeys;
  } else {
#line 555
    keys = ctx->encrypt_subkeys;
  }
#line 557
  left = (uint32_t )(((((int const   )*(from + 0) << 24) | ((int const   )*(from + 1) << 16)) | ((int const   )*(from + 2) << 8)) | (int const   )*(from + 3));
#line 557
  right = (uint32_t )(((((int const   )*(from + 4) << 24) | ((int const   )*(from + 5) << 16)) | ((int const   )*(from + 6) << 8)) | (int const   )*(from + 7));
#line 558
  work = ((left >> 4) ^ right) & 252645135U;
#line 558
  right ^= work;
#line 558
  left ^= work << 4;
#line 558
  work = ((left >> 16) ^ right) & 65535U;
#line 558
  right ^= work;
#line 558
  left ^= work << 16;
#line 558
  work = ((right >> 2) ^ left) & 858993459U;
#line 558
  left ^= work;
#line 558
  right ^= work << 2;
#line 558
  work = ((right >> 8) ^ left) & 16711935U;
#line 558
  left ^= work;
#line 558
  right ^= work << 8;
#line 558
  right = (right << 1) | (right >> 31);
#line 558
  work = (left ^ right) & 2863311530U;
#line 558
  right ^= work;
#line 558
  left ^= work;
#line 558
  left = (left << 1) | (left >> 31);
#line 559
  tmp = keys;
#line 559
  keys ++;
#line 559
  work = right ^ *tmp;
#line 559
  left ^= (unsigned int )sbox8[work & 63U];
#line 559
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 559
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 559
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 559
  tmp___0 = keys;
#line 559
  keys ++;
#line 559
  work = ((right << 28) | (right >> 4)) ^ *tmp___0;
#line 559
  left ^= (unsigned int )sbox7[work & 63U];
#line 559
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 559
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 559
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 559
  tmp___1 = keys;
#line 559
  keys ++;
#line 559
  work = left ^ *tmp___1;
#line 559
  right ^= (unsigned int )sbox8[work & 63U];
#line 559
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 559
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 559
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 559
  tmp___2 = keys;
#line 559
  keys ++;
#line 559
  work = ((left << 28) | (left >> 4)) ^ *tmp___2;
#line 559
  right ^= (unsigned int )sbox7[work & 63U];
#line 559
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 559
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 559
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 560
  tmp___3 = keys;
#line 560
  keys ++;
#line 560
  work = right ^ *tmp___3;
#line 560
  left ^= (unsigned int )sbox8[work & 63U];
#line 560
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 560
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 560
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 560
  tmp___4 = keys;
#line 560
  keys ++;
#line 560
  work = ((right << 28) | (right >> 4)) ^ *tmp___4;
#line 560
  left ^= (unsigned int )sbox7[work & 63U];
#line 560
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 560
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 560
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 560
  tmp___5 = keys;
#line 560
  keys ++;
#line 560
  work = left ^ *tmp___5;
#line 560
  right ^= (unsigned int )sbox8[work & 63U];
#line 560
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 560
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 560
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 560
  tmp___6 = keys;
#line 560
  keys ++;
#line 560
  work = ((left << 28) | (left >> 4)) ^ *tmp___6;
#line 560
  right ^= (unsigned int )sbox7[work & 63U];
#line 560
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 560
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 560
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 561
  tmp___7 = keys;
#line 561
  keys ++;
#line 561
  work = right ^ *tmp___7;
#line 561
  left ^= (unsigned int )sbox8[work & 63U];
#line 561
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 561
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 561
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 561
  tmp___8 = keys;
#line 561
  keys ++;
#line 561
  work = ((right << 28) | (right >> 4)) ^ *tmp___8;
#line 561
  left ^= (unsigned int )sbox7[work & 63U];
#line 561
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 561
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 561
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 561
  tmp___9 = keys;
#line 561
  keys ++;
#line 561
  work = left ^ *tmp___9;
#line 561
  right ^= (unsigned int )sbox8[work & 63U];
#line 561
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 561
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 561
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 561
  tmp___10 = keys;
#line 561
  keys ++;
#line 561
  work = ((left << 28) | (left >> 4)) ^ *tmp___10;
#line 561
  right ^= (unsigned int )sbox7[work & 63U];
#line 561
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 561
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 561
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 562
  tmp___11 = keys;
#line 562
  keys ++;
#line 562
  work = right ^ *tmp___11;
#line 562
  left ^= (unsigned int )sbox8[work & 63U];
#line 562
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 562
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 562
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 562
  tmp___12 = keys;
#line 562
  keys ++;
#line 562
  work = ((right << 28) | (right >> 4)) ^ *tmp___12;
#line 562
  left ^= (unsigned int )sbox7[work & 63U];
#line 562
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 562
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 562
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 562
  tmp___13 = keys;
#line 562
  keys ++;
#line 562
  work = left ^ *tmp___13;
#line 562
  right ^= (unsigned int )sbox8[work & 63U];
#line 562
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 562
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 562
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 562
  tmp___14 = keys;
#line 562
  keys ++;
#line 562
  work = ((left << 28) | (left >> 4)) ^ *tmp___14;
#line 562
  right ^= (unsigned int )sbox7[work & 63U];
#line 562
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 562
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 562
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 563
  tmp___15 = keys;
#line 563
  keys ++;
#line 563
  work = right ^ *tmp___15;
#line 563
  left ^= (unsigned int )sbox8[work & 63U];
#line 563
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 563
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 563
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 563
  tmp___16 = keys;
#line 563
  keys ++;
#line 563
  work = ((right << 28) | (right >> 4)) ^ *tmp___16;
#line 563
  left ^= (unsigned int )sbox7[work & 63U];
#line 563
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 563
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 563
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 563
  tmp___17 = keys;
#line 563
  keys ++;
#line 563
  work = left ^ *tmp___17;
#line 563
  right ^= (unsigned int )sbox8[work & 63U];
#line 563
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 563
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 563
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 563
  tmp___18 = keys;
#line 563
  keys ++;
#line 563
  work = ((left << 28) | (left >> 4)) ^ *tmp___18;
#line 563
  right ^= (unsigned int )sbox7[work & 63U];
#line 563
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 563
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 563
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 564
  tmp___19 = keys;
#line 564
  keys ++;
#line 564
  work = right ^ *tmp___19;
#line 564
  left ^= (unsigned int )sbox8[work & 63U];
#line 564
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 564
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 564
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 564
  tmp___20 = keys;
#line 564
  keys ++;
#line 564
  work = ((right << 28) | (right >> 4)) ^ *tmp___20;
#line 564
  left ^= (unsigned int )sbox7[work & 63U];
#line 564
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 564
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 564
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 564
  tmp___21 = keys;
#line 564
  keys ++;
#line 564
  work = left ^ *tmp___21;
#line 564
  right ^= (unsigned int )sbox8[work & 63U];
#line 564
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 564
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 564
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 564
  tmp___22 = keys;
#line 564
  keys ++;
#line 564
  work = ((left << 28) | (left >> 4)) ^ *tmp___22;
#line 564
  right ^= (unsigned int )sbox7[work & 63U];
#line 564
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 564
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 564
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 565
  tmp___23 = keys;
#line 565
  keys ++;
#line 565
  work = right ^ *tmp___23;
#line 565
  left ^= (unsigned int )sbox8[work & 63U];
#line 565
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 565
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 565
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 565
  tmp___24 = keys;
#line 565
  keys ++;
#line 565
  work = ((right << 28) | (right >> 4)) ^ *tmp___24;
#line 565
  left ^= (unsigned int )sbox7[work & 63U];
#line 565
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 565
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 565
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 565
  tmp___25 = keys;
#line 565
  keys ++;
#line 565
  work = left ^ *tmp___25;
#line 565
  right ^= (unsigned int )sbox8[work & 63U];
#line 565
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 565
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 565
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 565
  tmp___26 = keys;
#line 565
  keys ++;
#line 565
  work = ((left << 28) | (left >> 4)) ^ *tmp___26;
#line 565
  right ^= (unsigned int )sbox7[work & 63U];
#line 565
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 565
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 565
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 566
  tmp___27 = keys;
#line 566
  keys ++;
#line 566
  work = right ^ *tmp___27;
#line 566
  left ^= (unsigned int )sbox8[work & 63U];
#line 566
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 566
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 566
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 566
  tmp___28 = keys;
#line 566
  keys ++;
#line 566
  work = ((right << 28) | (right >> 4)) ^ *tmp___28;
#line 566
  left ^= (unsigned int )sbox7[work & 63U];
#line 566
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 566
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 566
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 566
  tmp___29 = keys;
#line 566
  keys ++;
#line 566
  work = left ^ *tmp___29;
#line 566
  right ^= (unsigned int )sbox8[work & 63U];
#line 566
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 566
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 566
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 566
  tmp___30 = keys;
#line 566
  keys ++;
#line 566
  work = ((left << 28) | (left >> 4)) ^ *tmp___30;
#line 566
  right ^= (unsigned int )sbox7[work & 63U];
#line 566
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 566
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 566
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 567
  right = (right << 31) | (right >> 1);
#line 567
  work = (right ^ left) & 2863311530U;
#line 567
  right ^= work;
#line 567
  left ^= work;
#line 567
  left = (left << 31) | (left >> 1);
#line 567
  work = ((left >> 8) ^ right) & 16711935U;
#line 567
  right ^= work;
#line 567
  left ^= work << 8;
#line 567
  work = ((left >> 2) ^ right) & 858993459U;
#line 567
  right ^= work;
#line 567
  left ^= work << 2;
#line 567
  work = ((right >> 16) ^ left) & 65535U;
#line 567
  left ^= work;
#line 567
  right ^= work << 16;
#line 567
  work = ((right >> 4) ^ left) & 252645135U;
#line 567
  left ^= work;
#line 567
  right ^= work << 4;
#line 568
  *(to + 0) = (unsigned char )((right >> 24) & 255U);
#line 568
  *(to + 1) = (unsigned char )((right >> 16) & 255U);
#line 568
  *(to + 2) = (unsigned char )((right >> 8) & 255U);
#line 568
  *(to + 3) = (unsigned char )(right & 255U);
#line 568
  *(to + 4) = (unsigned char )((left >> 24) & 255U);
#line 568
  *(to + 5) = (unsigned char )((left >> 16) & 255U);
#line 568
  *(to + 6) = (unsigned char )((left >> 8) & 255U);
#line 568
  *(to + 7) = (unsigned char )(left & 255U);
#line 569
  return;
}
}
#line 571 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_3des_set2keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ) 
{ 
  int i___0 ;

  {
  {
#line 576
  des_key_schedule(key1, ctx->encrypt_subkeys);
#line 577
  des_key_schedule(key2, & ctx->decrypt_subkeys[32]);
#line 579
  i___0 = 0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! (i___0 < 32)) {
#line 579
      goto while_break;
    }
#line 581
    ctx->decrypt_subkeys[i___0] = ctx->encrypt_subkeys[30 - i___0];
#line 582
    ctx->decrypt_subkeys[i___0 + 1] = ctx->encrypt_subkeys[31 - i___0];
#line 584
    ctx->encrypt_subkeys[i___0 + 32] = ctx->decrypt_subkeys[62 - i___0];
#line 585
    ctx->encrypt_subkeys[i___0 + 33] = ctx->decrypt_subkeys[63 - i___0];
#line 587
    ctx->encrypt_subkeys[i___0 + 64] = ctx->encrypt_subkeys[i___0];
#line 588
    ctx->encrypt_subkeys[i___0 + 65] = ctx->encrypt_subkeys[i___0 + 1];
#line 590
    ctx->decrypt_subkeys[i___0 + 64] = ctx->decrypt_subkeys[i___0];
#line 591
    ctx->decrypt_subkeys[i___0 + 65] = ctx->decrypt_subkeys[i___0 + 1];
#line 579
    i___0 += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 593
  return;
}
}
#line 595 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_3des_set3keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ,
                      char const   *key3 ) 
{ 
  int i___0 ;

  {
  {
#line 601
  des_key_schedule(key1, ctx->encrypt_subkeys);
#line 602
  des_key_schedule(key2, & ctx->decrypt_subkeys[32]);
#line 603
  des_key_schedule(key3, & ctx->encrypt_subkeys[64]);
#line 605
  i___0 = 0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i___0 < 32)) {
#line 605
      goto while_break;
    }
#line 607
    ctx->decrypt_subkeys[i___0] = ctx->encrypt_subkeys[94 - i___0];
#line 608
    ctx->decrypt_subkeys[i___0 + 1] = ctx->encrypt_subkeys[95 - i___0];
#line 610
    ctx->encrypt_subkeys[i___0 + 32] = ctx->decrypt_subkeys[62 - i___0];
#line 611
    ctx->encrypt_subkeys[i___0 + 33] = ctx->decrypt_subkeys[63 - i___0];
#line 613
    ctx->decrypt_subkeys[i___0 + 64] = ctx->encrypt_subkeys[30 - i___0];
#line 614
    ctx->decrypt_subkeys[i___0 + 65] = ctx->encrypt_subkeys[31 - i___0];
#line 605
    i___0 += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return;
}
}
#line 618 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_3des_ecb_crypt(gl_3des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) 
{ 
  unsigned char const   *from ;
  unsigned char *to ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  uint32_t *keys ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t *tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t *tmp___30 ;
  uint32_t *tmp___31 ;
  uint32_t *tmp___32 ;
  uint32_t *tmp___33 ;
  uint32_t *tmp___34 ;
  uint32_t *tmp___35 ;
  uint32_t *tmp___36 ;
  uint32_t *tmp___37 ;
  uint32_t *tmp___38 ;
  uint32_t *tmp___39 ;
  uint32_t *tmp___40 ;
  uint32_t *tmp___41 ;
  uint32_t *tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  uint32_t *tmp___45 ;
  uint32_t *tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  uint32_t *tmp___49 ;
  uint32_t *tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  uint32_t *tmp___53 ;
  uint32_t *tmp___54 ;
  uint32_t *tmp___55 ;
  uint32_t *tmp___56 ;
  uint32_t *tmp___57 ;
  uint32_t *tmp___58 ;
  uint32_t *tmp___59 ;
  uint32_t *tmp___60 ;
  uint32_t *tmp___61 ;
  uint32_t *tmp___62 ;
  uint32_t *tmp___63 ;
  uint32_t *tmp___64 ;
  uint32_t *tmp___65 ;
  uint32_t *tmp___66 ;
  uint32_t *tmp___67 ;
  uint32_t *tmp___68 ;
  uint32_t *tmp___69 ;
  uint32_t *tmp___70 ;
  uint32_t *tmp___71 ;
  uint32_t *tmp___72 ;
  uint32_t *tmp___73 ;
  uint32_t *tmp___74 ;
  uint32_t *tmp___75 ;
  uint32_t *tmp___76 ;
  uint32_t *tmp___77 ;
  uint32_t *tmp___78 ;
  uint32_t *tmp___79 ;
  uint32_t *tmp___80 ;
  uint32_t *tmp___81 ;
  uint32_t *tmp___82 ;
  uint32_t *tmp___83 ;
  uint32_t *tmp___84 ;
  uint32_t *tmp___85 ;
  uint32_t *tmp___86 ;
  uint32_t *tmp___87 ;
  uint32_t *tmp___88 ;
  uint32_t *tmp___89 ;
  uint32_t *tmp___90 ;
  uint32_t *tmp___91 ;
  uint32_t *tmp___92 ;
  uint32_t *tmp___93 ;
  uint32_t *tmp___94 ;

  {
#line 623
  from = (unsigned char const   *)_from;
#line 624
  to = (unsigned char *)_to;
#line 628
  if (mode___0) {
#line 628
    keys = ctx->decrypt_subkeys;
  } else {
#line 628
    keys = ctx->encrypt_subkeys;
  }
#line 630
  left = (uint32_t )(((((int const   )*(from + 0) << 24) | ((int const   )*(from + 1) << 16)) | ((int const   )*(from + 2) << 8)) | (int const   )*(from + 3));
#line 630
  right = (uint32_t )(((((int const   )*(from + 4) << 24) | ((int const   )*(from + 5) << 16)) | ((int const   )*(from + 6) << 8)) | (int const   )*(from + 7));
#line 631
  work = ((left >> 4) ^ right) & 252645135U;
#line 631
  right ^= work;
#line 631
  left ^= work << 4;
#line 631
  work = ((left >> 16) ^ right) & 65535U;
#line 631
  right ^= work;
#line 631
  left ^= work << 16;
#line 631
  work = ((right >> 2) ^ left) & 858993459U;
#line 631
  left ^= work;
#line 631
  right ^= work << 2;
#line 631
  work = ((right >> 8) ^ left) & 16711935U;
#line 631
  left ^= work;
#line 631
  right ^= work << 8;
#line 631
  right = (right << 1) | (right >> 31);
#line 631
  work = (left ^ right) & 2863311530U;
#line 631
  right ^= work;
#line 631
  left ^= work;
#line 631
  left = (left << 1) | (left >> 31);
#line 632
  tmp = keys;
#line 632
  keys ++;
#line 632
  work = right ^ *tmp;
#line 632
  left ^= (unsigned int )sbox8[work & 63U];
#line 632
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 632
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 632
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 632
  tmp___0 = keys;
#line 632
  keys ++;
#line 632
  work = ((right << 28) | (right >> 4)) ^ *tmp___0;
#line 632
  left ^= (unsigned int )sbox7[work & 63U];
#line 632
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 632
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 632
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 632
  tmp___1 = keys;
#line 632
  keys ++;
#line 632
  work = left ^ *tmp___1;
#line 632
  right ^= (unsigned int )sbox8[work & 63U];
#line 632
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 632
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 632
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 632
  tmp___2 = keys;
#line 632
  keys ++;
#line 632
  work = ((left << 28) | (left >> 4)) ^ *tmp___2;
#line 632
  right ^= (unsigned int )sbox7[work & 63U];
#line 632
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 632
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 632
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 633
  tmp___3 = keys;
#line 633
  keys ++;
#line 633
  work = right ^ *tmp___3;
#line 633
  left ^= (unsigned int )sbox8[work & 63U];
#line 633
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 633
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 633
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 633
  tmp___4 = keys;
#line 633
  keys ++;
#line 633
  work = ((right << 28) | (right >> 4)) ^ *tmp___4;
#line 633
  left ^= (unsigned int )sbox7[work & 63U];
#line 633
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 633
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 633
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 633
  tmp___5 = keys;
#line 633
  keys ++;
#line 633
  work = left ^ *tmp___5;
#line 633
  right ^= (unsigned int )sbox8[work & 63U];
#line 633
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 633
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 633
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 633
  tmp___6 = keys;
#line 633
  keys ++;
#line 633
  work = ((left << 28) | (left >> 4)) ^ *tmp___6;
#line 633
  right ^= (unsigned int )sbox7[work & 63U];
#line 633
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 633
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 633
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 634
  tmp___7 = keys;
#line 634
  keys ++;
#line 634
  work = right ^ *tmp___7;
#line 634
  left ^= (unsigned int )sbox8[work & 63U];
#line 634
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 634
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 634
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 634
  tmp___8 = keys;
#line 634
  keys ++;
#line 634
  work = ((right << 28) | (right >> 4)) ^ *tmp___8;
#line 634
  left ^= (unsigned int )sbox7[work & 63U];
#line 634
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 634
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 634
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 634
  tmp___9 = keys;
#line 634
  keys ++;
#line 634
  work = left ^ *tmp___9;
#line 634
  right ^= (unsigned int )sbox8[work & 63U];
#line 634
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 634
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 634
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 634
  tmp___10 = keys;
#line 634
  keys ++;
#line 634
  work = ((left << 28) | (left >> 4)) ^ *tmp___10;
#line 634
  right ^= (unsigned int )sbox7[work & 63U];
#line 634
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 634
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 634
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 635
  tmp___11 = keys;
#line 635
  keys ++;
#line 635
  work = right ^ *tmp___11;
#line 635
  left ^= (unsigned int )sbox8[work & 63U];
#line 635
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 635
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 635
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 635
  tmp___12 = keys;
#line 635
  keys ++;
#line 635
  work = ((right << 28) | (right >> 4)) ^ *tmp___12;
#line 635
  left ^= (unsigned int )sbox7[work & 63U];
#line 635
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 635
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 635
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 635
  tmp___13 = keys;
#line 635
  keys ++;
#line 635
  work = left ^ *tmp___13;
#line 635
  right ^= (unsigned int )sbox8[work & 63U];
#line 635
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 635
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 635
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 635
  tmp___14 = keys;
#line 635
  keys ++;
#line 635
  work = ((left << 28) | (left >> 4)) ^ *tmp___14;
#line 635
  right ^= (unsigned int )sbox7[work & 63U];
#line 635
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 635
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 635
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 636
  tmp___15 = keys;
#line 636
  keys ++;
#line 636
  work = right ^ *tmp___15;
#line 636
  left ^= (unsigned int )sbox8[work & 63U];
#line 636
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 636
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 636
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 636
  tmp___16 = keys;
#line 636
  keys ++;
#line 636
  work = ((right << 28) | (right >> 4)) ^ *tmp___16;
#line 636
  left ^= (unsigned int )sbox7[work & 63U];
#line 636
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 636
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 636
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 636
  tmp___17 = keys;
#line 636
  keys ++;
#line 636
  work = left ^ *tmp___17;
#line 636
  right ^= (unsigned int )sbox8[work & 63U];
#line 636
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 636
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 636
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 636
  tmp___18 = keys;
#line 636
  keys ++;
#line 636
  work = ((left << 28) | (left >> 4)) ^ *tmp___18;
#line 636
  right ^= (unsigned int )sbox7[work & 63U];
#line 636
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 636
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 636
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 637
  tmp___19 = keys;
#line 637
  keys ++;
#line 637
  work = right ^ *tmp___19;
#line 637
  left ^= (unsigned int )sbox8[work & 63U];
#line 637
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 637
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 637
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 637
  tmp___20 = keys;
#line 637
  keys ++;
#line 637
  work = ((right << 28) | (right >> 4)) ^ *tmp___20;
#line 637
  left ^= (unsigned int )sbox7[work & 63U];
#line 637
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 637
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 637
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 637
  tmp___21 = keys;
#line 637
  keys ++;
#line 637
  work = left ^ *tmp___21;
#line 637
  right ^= (unsigned int )sbox8[work & 63U];
#line 637
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 637
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 637
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 637
  tmp___22 = keys;
#line 637
  keys ++;
#line 637
  work = ((left << 28) | (left >> 4)) ^ *tmp___22;
#line 637
  right ^= (unsigned int )sbox7[work & 63U];
#line 637
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 637
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 637
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 638
  tmp___23 = keys;
#line 638
  keys ++;
#line 638
  work = right ^ *tmp___23;
#line 638
  left ^= (unsigned int )sbox8[work & 63U];
#line 638
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 638
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 638
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 638
  tmp___24 = keys;
#line 638
  keys ++;
#line 638
  work = ((right << 28) | (right >> 4)) ^ *tmp___24;
#line 638
  left ^= (unsigned int )sbox7[work & 63U];
#line 638
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 638
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 638
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 638
  tmp___25 = keys;
#line 638
  keys ++;
#line 638
  work = left ^ *tmp___25;
#line 638
  right ^= (unsigned int )sbox8[work & 63U];
#line 638
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 638
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 638
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 638
  tmp___26 = keys;
#line 638
  keys ++;
#line 638
  work = ((left << 28) | (left >> 4)) ^ *tmp___26;
#line 638
  right ^= (unsigned int )sbox7[work & 63U];
#line 638
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 638
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 638
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 639
  tmp___27 = keys;
#line 639
  keys ++;
#line 639
  work = right ^ *tmp___27;
#line 639
  left ^= (unsigned int )sbox8[work & 63U];
#line 639
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 639
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 639
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 639
  tmp___28 = keys;
#line 639
  keys ++;
#line 639
  work = ((right << 28) | (right >> 4)) ^ *tmp___28;
#line 639
  left ^= (unsigned int )sbox7[work & 63U];
#line 639
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 639
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 639
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 639
  tmp___29 = keys;
#line 639
  keys ++;
#line 639
  work = left ^ *tmp___29;
#line 639
  right ^= (unsigned int )sbox8[work & 63U];
#line 639
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 639
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 639
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 639
  tmp___30 = keys;
#line 639
  keys ++;
#line 639
  work = ((left << 28) | (left >> 4)) ^ *tmp___30;
#line 639
  right ^= (unsigned int )sbox7[work & 63U];
#line 639
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 639
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 639
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 640
  tmp___31 = keys;
#line 640
  keys ++;
#line 640
  work = left ^ *tmp___31;
#line 640
  right ^= (unsigned int )sbox8[work & 63U];
#line 640
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 640
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 640
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 640
  tmp___32 = keys;
#line 640
  keys ++;
#line 640
  work = ((left << 28) | (left >> 4)) ^ *tmp___32;
#line 640
  right ^= (unsigned int )sbox7[work & 63U];
#line 640
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 640
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 640
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 640
  tmp___33 = keys;
#line 640
  keys ++;
#line 640
  work = right ^ *tmp___33;
#line 640
  left ^= (unsigned int )sbox8[work & 63U];
#line 640
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 640
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 640
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 640
  tmp___34 = keys;
#line 640
  keys ++;
#line 640
  work = ((right << 28) | (right >> 4)) ^ *tmp___34;
#line 640
  left ^= (unsigned int )sbox7[work & 63U];
#line 640
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 640
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 640
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 641
  tmp___35 = keys;
#line 641
  keys ++;
#line 641
  work = left ^ *tmp___35;
#line 641
  right ^= (unsigned int )sbox8[work & 63U];
#line 641
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 641
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 641
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 641
  tmp___36 = keys;
#line 641
  keys ++;
#line 641
  work = ((left << 28) | (left >> 4)) ^ *tmp___36;
#line 641
  right ^= (unsigned int )sbox7[work & 63U];
#line 641
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 641
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 641
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 641
  tmp___37 = keys;
#line 641
  keys ++;
#line 641
  work = right ^ *tmp___37;
#line 641
  left ^= (unsigned int )sbox8[work & 63U];
#line 641
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 641
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 641
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 641
  tmp___38 = keys;
#line 641
  keys ++;
#line 641
  work = ((right << 28) | (right >> 4)) ^ *tmp___38;
#line 641
  left ^= (unsigned int )sbox7[work & 63U];
#line 641
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 641
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 641
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 642
  tmp___39 = keys;
#line 642
  keys ++;
#line 642
  work = left ^ *tmp___39;
#line 642
  right ^= (unsigned int )sbox8[work & 63U];
#line 642
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 642
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 642
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 642
  tmp___40 = keys;
#line 642
  keys ++;
#line 642
  work = ((left << 28) | (left >> 4)) ^ *tmp___40;
#line 642
  right ^= (unsigned int )sbox7[work & 63U];
#line 642
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 642
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 642
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 642
  tmp___41 = keys;
#line 642
  keys ++;
#line 642
  work = right ^ *tmp___41;
#line 642
  left ^= (unsigned int )sbox8[work & 63U];
#line 642
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 642
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 642
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 642
  tmp___42 = keys;
#line 642
  keys ++;
#line 642
  work = ((right << 28) | (right >> 4)) ^ *tmp___42;
#line 642
  left ^= (unsigned int )sbox7[work & 63U];
#line 642
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 642
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 642
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 643
  tmp___43 = keys;
#line 643
  keys ++;
#line 643
  work = left ^ *tmp___43;
#line 643
  right ^= (unsigned int )sbox8[work & 63U];
#line 643
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 643
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 643
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 643
  tmp___44 = keys;
#line 643
  keys ++;
#line 643
  work = ((left << 28) | (left >> 4)) ^ *tmp___44;
#line 643
  right ^= (unsigned int )sbox7[work & 63U];
#line 643
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 643
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 643
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 643
  tmp___45 = keys;
#line 643
  keys ++;
#line 643
  work = right ^ *tmp___45;
#line 643
  left ^= (unsigned int )sbox8[work & 63U];
#line 643
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 643
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 643
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 643
  tmp___46 = keys;
#line 643
  keys ++;
#line 643
  work = ((right << 28) | (right >> 4)) ^ *tmp___46;
#line 643
  left ^= (unsigned int )sbox7[work & 63U];
#line 643
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 643
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 643
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 644
  tmp___47 = keys;
#line 644
  keys ++;
#line 644
  work = left ^ *tmp___47;
#line 644
  right ^= (unsigned int )sbox8[work & 63U];
#line 644
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 644
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 644
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 644
  tmp___48 = keys;
#line 644
  keys ++;
#line 644
  work = ((left << 28) | (left >> 4)) ^ *tmp___48;
#line 644
  right ^= (unsigned int )sbox7[work & 63U];
#line 644
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 644
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 644
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 644
  tmp___49 = keys;
#line 644
  keys ++;
#line 644
  work = right ^ *tmp___49;
#line 644
  left ^= (unsigned int )sbox8[work & 63U];
#line 644
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 644
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 644
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 644
  tmp___50 = keys;
#line 644
  keys ++;
#line 644
  work = ((right << 28) | (right >> 4)) ^ *tmp___50;
#line 644
  left ^= (unsigned int )sbox7[work & 63U];
#line 644
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 644
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 644
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 645
  tmp___51 = keys;
#line 645
  keys ++;
#line 645
  work = left ^ *tmp___51;
#line 645
  right ^= (unsigned int )sbox8[work & 63U];
#line 645
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 645
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 645
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 645
  tmp___52 = keys;
#line 645
  keys ++;
#line 645
  work = ((left << 28) | (left >> 4)) ^ *tmp___52;
#line 645
  right ^= (unsigned int )sbox7[work & 63U];
#line 645
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 645
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 645
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 645
  tmp___53 = keys;
#line 645
  keys ++;
#line 645
  work = right ^ *tmp___53;
#line 645
  left ^= (unsigned int )sbox8[work & 63U];
#line 645
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 645
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 645
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 645
  tmp___54 = keys;
#line 645
  keys ++;
#line 645
  work = ((right << 28) | (right >> 4)) ^ *tmp___54;
#line 645
  left ^= (unsigned int )sbox7[work & 63U];
#line 645
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 645
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 645
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 646
  tmp___55 = keys;
#line 646
  keys ++;
#line 646
  work = left ^ *tmp___55;
#line 646
  right ^= (unsigned int )sbox8[work & 63U];
#line 646
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 646
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 646
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 646
  tmp___56 = keys;
#line 646
  keys ++;
#line 646
  work = ((left << 28) | (left >> 4)) ^ *tmp___56;
#line 646
  right ^= (unsigned int )sbox7[work & 63U];
#line 646
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 646
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 646
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 646
  tmp___57 = keys;
#line 646
  keys ++;
#line 646
  work = right ^ *tmp___57;
#line 646
  left ^= (unsigned int )sbox8[work & 63U];
#line 646
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 646
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 646
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 646
  tmp___58 = keys;
#line 646
  keys ++;
#line 646
  work = ((right << 28) | (right >> 4)) ^ *tmp___58;
#line 646
  left ^= (unsigned int )sbox7[work & 63U];
#line 646
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 646
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 646
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 647
  tmp___59 = keys;
#line 647
  keys ++;
#line 647
  work = left ^ *tmp___59;
#line 647
  right ^= (unsigned int )sbox8[work & 63U];
#line 647
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 647
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 647
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 647
  tmp___60 = keys;
#line 647
  keys ++;
#line 647
  work = ((left << 28) | (left >> 4)) ^ *tmp___60;
#line 647
  right ^= (unsigned int )sbox7[work & 63U];
#line 647
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 647
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 647
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 647
  tmp___61 = keys;
#line 647
  keys ++;
#line 647
  work = right ^ *tmp___61;
#line 647
  left ^= (unsigned int )sbox8[work & 63U];
#line 647
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 647
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 647
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 647
  tmp___62 = keys;
#line 647
  keys ++;
#line 647
  work = ((right << 28) | (right >> 4)) ^ *tmp___62;
#line 647
  left ^= (unsigned int )sbox7[work & 63U];
#line 647
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 647
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 647
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 648
  tmp___63 = keys;
#line 648
  keys ++;
#line 648
  work = right ^ *tmp___63;
#line 648
  left ^= (unsigned int )sbox8[work & 63U];
#line 648
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 648
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 648
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 648
  tmp___64 = keys;
#line 648
  keys ++;
#line 648
  work = ((right << 28) | (right >> 4)) ^ *tmp___64;
#line 648
  left ^= (unsigned int )sbox7[work & 63U];
#line 648
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 648
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 648
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 648
  tmp___65 = keys;
#line 648
  keys ++;
#line 648
  work = left ^ *tmp___65;
#line 648
  right ^= (unsigned int )sbox8[work & 63U];
#line 648
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 648
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 648
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 648
  tmp___66 = keys;
#line 648
  keys ++;
#line 648
  work = ((left << 28) | (left >> 4)) ^ *tmp___66;
#line 648
  right ^= (unsigned int )sbox7[work & 63U];
#line 648
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 648
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 648
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 649
  tmp___67 = keys;
#line 649
  keys ++;
#line 649
  work = right ^ *tmp___67;
#line 649
  left ^= (unsigned int )sbox8[work & 63U];
#line 649
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 649
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 649
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 649
  tmp___68 = keys;
#line 649
  keys ++;
#line 649
  work = ((right << 28) | (right >> 4)) ^ *tmp___68;
#line 649
  left ^= (unsigned int )sbox7[work & 63U];
#line 649
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 649
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 649
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 649
  tmp___69 = keys;
#line 649
  keys ++;
#line 649
  work = left ^ *tmp___69;
#line 649
  right ^= (unsigned int )sbox8[work & 63U];
#line 649
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 649
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 649
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 649
  tmp___70 = keys;
#line 649
  keys ++;
#line 649
  work = ((left << 28) | (left >> 4)) ^ *tmp___70;
#line 649
  right ^= (unsigned int )sbox7[work & 63U];
#line 649
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 649
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 649
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 650
  tmp___71 = keys;
#line 650
  keys ++;
#line 650
  work = right ^ *tmp___71;
#line 650
  left ^= (unsigned int )sbox8[work & 63U];
#line 650
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 650
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 650
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 650
  tmp___72 = keys;
#line 650
  keys ++;
#line 650
  work = ((right << 28) | (right >> 4)) ^ *tmp___72;
#line 650
  left ^= (unsigned int )sbox7[work & 63U];
#line 650
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 650
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 650
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 650
  tmp___73 = keys;
#line 650
  keys ++;
#line 650
  work = left ^ *tmp___73;
#line 650
  right ^= (unsigned int )sbox8[work & 63U];
#line 650
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 650
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 650
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 650
  tmp___74 = keys;
#line 650
  keys ++;
#line 650
  work = ((left << 28) | (left >> 4)) ^ *tmp___74;
#line 650
  right ^= (unsigned int )sbox7[work & 63U];
#line 650
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 650
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 650
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 651
  tmp___75 = keys;
#line 651
  keys ++;
#line 651
  work = right ^ *tmp___75;
#line 651
  left ^= (unsigned int )sbox8[work & 63U];
#line 651
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 651
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 651
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 651
  tmp___76 = keys;
#line 651
  keys ++;
#line 651
  work = ((right << 28) | (right >> 4)) ^ *tmp___76;
#line 651
  left ^= (unsigned int )sbox7[work & 63U];
#line 651
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 651
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 651
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 651
  tmp___77 = keys;
#line 651
  keys ++;
#line 651
  work = left ^ *tmp___77;
#line 651
  right ^= (unsigned int )sbox8[work & 63U];
#line 651
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 651
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 651
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 651
  tmp___78 = keys;
#line 651
  keys ++;
#line 651
  work = ((left << 28) | (left >> 4)) ^ *tmp___78;
#line 651
  right ^= (unsigned int )sbox7[work & 63U];
#line 651
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 651
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 651
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 652
  tmp___79 = keys;
#line 652
  keys ++;
#line 652
  work = right ^ *tmp___79;
#line 652
  left ^= (unsigned int )sbox8[work & 63U];
#line 652
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 652
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 652
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 652
  tmp___80 = keys;
#line 652
  keys ++;
#line 652
  work = ((right << 28) | (right >> 4)) ^ *tmp___80;
#line 652
  left ^= (unsigned int )sbox7[work & 63U];
#line 652
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 652
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 652
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 652
  tmp___81 = keys;
#line 652
  keys ++;
#line 652
  work = left ^ *tmp___81;
#line 652
  right ^= (unsigned int )sbox8[work & 63U];
#line 652
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 652
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 652
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 652
  tmp___82 = keys;
#line 652
  keys ++;
#line 652
  work = ((left << 28) | (left >> 4)) ^ *tmp___82;
#line 652
  right ^= (unsigned int )sbox7[work & 63U];
#line 652
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 652
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 652
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 653
  tmp___83 = keys;
#line 653
  keys ++;
#line 653
  work = right ^ *tmp___83;
#line 653
  left ^= (unsigned int )sbox8[work & 63U];
#line 653
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 653
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 653
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 653
  tmp___84 = keys;
#line 653
  keys ++;
#line 653
  work = ((right << 28) | (right >> 4)) ^ *tmp___84;
#line 653
  left ^= (unsigned int )sbox7[work & 63U];
#line 653
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 653
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 653
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 653
  tmp___85 = keys;
#line 653
  keys ++;
#line 653
  work = left ^ *tmp___85;
#line 653
  right ^= (unsigned int )sbox8[work & 63U];
#line 653
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 653
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 653
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 653
  tmp___86 = keys;
#line 653
  keys ++;
#line 653
  work = ((left << 28) | (left >> 4)) ^ *tmp___86;
#line 653
  right ^= (unsigned int )sbox7[work & 63U];
#line 653
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 653
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 653
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 654
  tmp___87 = keys;
#line 654
  keys ++;
#line 654
  work = right ^ *tmp___87;
#line 654
  left ^= (unsigned int )sbox8[work & 63U];
#line 654
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 654
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 654
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 654
  tmp___88 = keys;
#line 654
  keys ++;
#line 654
  work = ((right << 28) | (right >> 4)) ^ *tmp___88;
#line 654
  left ^= (unsigned int )sbox7[work & 63U];
#line 654
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 654
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 654
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 654
  tmp___89 = keys;
#line 654
  keys ++;
#line 654
  work = left ^ *tmp___89;
#line 654
  right ^= (unsigned int )sbox8[work & 63U];
#line 654
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 654
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 654
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 654
  tmp___90 = keys;
#line 654
  keys ++;
#line 654
  work = ((left << 28) | (left >> 4)) ^ *tmp___90;
#line 654
  right ^= (unsigned int )sbox7[work & 63U];
#line 654
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 654
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 654
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 655
  tmp___91 = keys;
#line 655
  keys ++;
#line 655
  work = right ^ *tmp___91;
#line 655
  left ^= (unsigned int )sbox8[work & 63U];
#line 655
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 655
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 655
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 655
  tmp___92 = keys;
#line 655
  keys ++;
#line 655
  work = ((right << 28) | (right >> 4)) ^ *tmp___92;
#line 655
  left ^= (unsigned int )sbox7[work & 63U];
#line 655
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 655
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 655
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 655
  tmp___93 = keys;
#line 655
  keys ++;
#line 655
  work = left ^ *tmp___93;
#line 655
  right ^= (unsigned int )sbox8[work & 63U];
#line 655
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 655
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 655
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 655
  tmp___94 = keys;
#line 655
  keys ++;
#line 655
  work = ((left << 28) | (left >> 4)) ^ *tmp___94;
#line 655
  right ^= (unsigned int )sbox7[work & 63U];
#line 655
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 655
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 655
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 656
  right = (right << 31) | (right >> 1);
#line 656
  work = (right ^ left) & 2863311530U;
#line 656
  right ^= work;
#line 656
  left ^= work;
#line 656
  left = (left << 31) | (left >> 1);
#line 656
  work = ((left >> 8) ^ right) & 16711935U;
#line 656
  right ^= work;
#line 656
  left ^= work << 8;
#line 656
  work = ((left >> 2) ^ right) & 858993459U;
#line 656
  right ^= work;
#line 656
  left ^= work << 2;
#line 656
  work = ((right >> 16) ^ left) & 65535U;
#line 656
  left ^= work;
#line 656
  right ^= work << 16;
#line 656
  work = ((right >> 4) ^ left) & 252645135U;
#line 656
  left ^= work;
#line 656
  right ^= work << 4;
#line 657
  *(to + 0) = (unsigned char )((right >> 24) & 255U);
#line 657
  *(to + 1) = (unsigned char )((right >> 16) & 255U);
#line 657
  *(to + 2) = (unsigned char )((right >> 8) & 255U);
#line 657
  *(to + 3) = (unsigned char )(right & 255U);
#line 657
  *(to + 4) = (unsigned char )((left >> 24) & 255U);
#line 657
  *(to + 5) = (unsigned char )((left >> 16) & 255U);
#line 657
  *(to + 6) = (unsigned char )((left >> 8) & 255U);
#line 657
  *(to + 7) = (unsigned char )(left & 255U);
#line 658
  return;
}
}
#line 660 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
_Bool gl_3des_makekey(gl_3des_ctx *ctx , char const   *key , size_t keylen ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 663
  if (keylen != 24U) {
#line 664
    return ((_Bool)0);
  }
  {
#line 666
  gl_3des_set3keys(ctx, key, key + 8, key + 16);
#line 668
  tmp = gl_des_is_weak_key(key);
  }
#line 668
  if (tmp) {
#line 668
    tmp___2 = 0;
  } else {
    {
#line 668
    tmp___0 = gl_des_is_weak_key(key + 8);
    }
#line 668
    if (tmp___0) {
#line 668
      tmp___2 = 0;
    } else {
      {
#line 668
      tmp___1 = gl_des_is_weak_key(key + 16);
      }
#line 668
      if (tmp___1) {
#line 668
        tmp___2 = 0;
      } else {
#line 668
        tmp___2 = 1;
      }
    }
  }
#line 668
  return ((_Bool )tmp___2);
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.h"
int c_tolower(int c ) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0U) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
    }
#line 44
    if (n == 0U) {
#line 45
      goto while_break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
    }
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 123 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 74 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
  }
#line 36
  return (result);
}
}
#line 45 "../include/xdico.h"
char *make_full_file_name(char const   *dir , char const   *file ) ;
#line 46
void trimnl(char *buf___1 , size_t len___0 ) ;
#line 48
dico_list_t xdico_list_create(void) ;
#line 49
dico_iterator_t xdico_list_iterator(dico_list_t list ) ;
#line 50
void xdico_list_append(struct dico_list *list , void *data ) ;
#line 51
void xdico_list_prepend(struct dico_list *list , void *data ) ;
#line 52
dico_assoc_list_t xdico_assoc_create(int flags ) ;
#line 53
void xdico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) ;
#line 55
int xdico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                    size_t count , int replace ) ;
#line 57
char *xdico_assign_string(char **dest , char *str ) ;
#line 59
char *xdico_sasl_mech_to_capa(char *mech ) ;
#line 60
int xdico_sasl_capa_match_p(char const   *mech , char const   *capa ) ;
#line 62
int dicod_free_item(void *item , void *data  __attribute__((__unused__)) ) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void trimnl(char *buf___1 , size_t len___0 ) 
{ 


  {
#line 29
  if (len___0 > 1U) {
#line 29
    len___0 --;
#line 29
    if ((int )*(buf___1 + len___0) == 10) {
#line 30
      *(buf___1 + len___0) = (char)0;
#line 31
      if (len___0 > 1U) {
#line 31
        len___0 --;
#line 31
        if ((int )*(buf___1 + len___0) == 13) {
#line 32
          *(buf___1 + len___0) = (char)0;
        }
      }
    }
  }
#line 34
  return;
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
char *make_full_file_name(char const   *dir , char const   *file ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 42
  tmp = dico_full_file_name(dir, file);
#line 42
  s = tmp;
  }
#line 43
  if (! s) {
    {
#line 44
    xalloc_die();
    }
  }
#line 45
  return (s);
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
dico_list_t xdico_list_create(void) 
{ 
  dico_list_t p ;
  dico_list_t tmp ;

  {
  {
#line 51
  tmp = dico_list_create();
#line 51
  p = tmp;
  }
#line 52
  if (! p) {
    {
#line 53
    xalloc_die();
    }
  }
#line 54
  return (p);
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
dico_iterator_t xdico_list_iterator(dico_list_t list ) 
{ 
  dico_iterator_t p ;
  dico_iterator_t tmp ;
  int *tmp___0 ;

  {
  {
#line 60
  tmp = dico_list_iterator(list);
#line 60
  p = tmp;
  }
#line 61
  if (! p) {
    {
#line 61
    tmp___0 = __errno_location();
    }
#line 61
    if (*tmp___0 == 12) {
      {
#line 62
      xalloc_die();
      }
    }
  }
#line 63
  return (p);
}
}
#line 66 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void xdico_list_append(struct dico_list *list , void *data ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 69
  tmp = dico_list_append(list, data);
  }
#line 69
  if (tmp) {
    {
#line 69
    tmp___0 = __errno_location();
    }
#line 69
    if (*tmp___0 == 12) {
      {
#line 70
      xalloc_die();
      }
    }
  }
#line 71
  return;
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void xdico_list_prepend(struct dico_list *list , void *data ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 76
  tmp = dico_list_prepend(list, data);
  }
#line 76
  if (tmp) {
    {
#line 76
    tmp___0 = __errno_location();
    }
#line 76
    if (*tmp___0 == 12) {
      {
#line 77
      xalloc_die();
      }
    }
  }
#line 78
  return;
}
}
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
dico_assoc_list_t xdico_assoc_create(int flags ) 
{ 
  dico_assoc_list_t p ;
  dico_assoc_list_t tmp ;

  {
  {
#line 83
  tmp = dico_assoc_create(flags);
#line 83
  p = tmp;
  }
#line 84
  if (! p) {
    {
#line 85
    xalloc_die();
    }
  }
#line 86
  return (p);
}
}
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void xdico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 92
  tmp = dico_assoc_append(assoc, key, value);
  }
#line 92
  if (tmp) {
    {
#line 92
    tmp___0 = __errno_location();
    }
#line 92
    if (*tmp___0 == 12) {
      {
#line 93
      xalloc_die();
      }
    }
  }
#line 94
  return;
}
}
#line 96 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
int xdico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                    size_t count , int replace ) 
{ 
  int rc ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 100
  tmp = dico_assoc_add(assoc, key, value, count, replace);
#line 100
  rc = tmp;
  }
#line 101
  if (rc) {
    {
#line 101
    tmp___0 = __errno_location();
    }
#line 101
    if (*tmp___0 == 12) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (rc);
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
char *xdico_assign_string(char **dest , char *str ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 109
  if (*dest) {
    {
#line 110
    free((void *)*dest);
    }
  }
#line 111
  if (str) {
    {
#line 111
    tmp___0 = xstrdup((char const   *)str);
#line 111
    tmp = tmp___0;
    }
  } else {
#line 111
    tmp = (char *)((void *)0);
  }
#line 111
  *dest = tmp;
#line 111
  return (tmp);
}
}
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
static char *mech_to_capa_table[4][2]  = { {        (char *)"EXTERNAL",        (char *)"external"}, 
   {        (char *)"SKEY",        (char *)"skey"}, 
   {        (char *)"GSSAPI",        (char *)"gssapi"}, 
   {        (char *)"KERBEROS_V4",        (char *)"kerberos_v4"}};
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
char *xdico_sasl_mech_to_capa(char *mech ) 
{ 
  int i___0 ;
  size_t len___0 ;
  char *rets ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 128
  i___0 = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((unsigned long )i___0 < sizeof(mech_to_capa_table) / sizeof(mech_to_capa_table[0]))) {
#line 128
      goto while_break;
    }
    {
#line 129
    tmp___0 = strcmp((char const   *)mech_to_capa_table[i___0][0], (char const   *)mech);
    }
#line 129
    if (tmp___0 == 0) {
      {
#line 130
      tmp = xstrdup((char const   *)mech_to_capa_table[i___0][1]);
      }
#line 130
      return (tmp);
    }
#line 128
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  tmp___1 = strlen((char const   *)mech);
#line 132
  len___0 = tmp___1 + 1U;
#line 133
  tmp___2 = xmalloc(len___0 + 1U);
#line 133
  p = (char *)tmp___2;
#line 133
  rets = p;
#line 134
  tmp___3 = p;
#line 134
  p ++;
#line 134
  *tmp___3 = (char )'x';
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! *mech) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    tmp___4 = p;
#line 136
    p ++;
#line 136
    tmp___5 = tolower((int )*mech);
#line 136
    *tmp___4 = (char )tmp___5;
#line 135
    mech ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  *p = (char)0;
#line 138
  return (rets);
}
}
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
int xdico_sasl_capa_match_p(char const   *mech , char const   *capa ) 
{ 
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 146
  i___0 = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! ((unsigned long )i___0 < sizeof(mech_to_capa_table) / sizeof(mech_to_capa_table[0]))) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp___0 = c_strcasecmp((char const   *)mech_to_capa_table[i___0][0], mech);
    }
#line 147
    if (tmp___0 == 0) {
      {
#line 148
      tmp = c_strcasecmp((char const   *)mech_to_capa_table[i___0][1], capa);
      }
#line 148
      return (tmp == 0);
    }
#line 146
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if ((int const   )*capa == 120) {
    {
#line 151
    tmp___1 = c_strcasecmp(mech, capa + 1);
    }
#line 151
    return (tmp___1 == 0);
  }
#line 152
  return (0);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
int dicod_free_item(void *item , void *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 159
  free(item);
  }
#line 160
  return (0);
}
}
#line 376 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 83 "../include/xdico.h"
int stream_writez(dico_stream_t str , char *buf___1 ) ;
#line 84
int stream_printf(dico_stream_t str , char const   *fmt  , ...) ;
#line 85
void stream_write_multiline(dico_stream_t str , char const   *text ) ;
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xstream.c"
int stream_writez(dico_stream_t str , char *buf___1 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 28
  tmp = strlen((char const   *)buf___1);
#line 28
  tmp___0 = dico_stream_write(str, (void const   *)buf___1, tmp);
  }
#line 28
  return (tmp___0);
}
}
#line 31 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xstream.c"
int stream_printf(dico_stream_t str , char const   *fmt  , ...) 
{ 
  int len___0 ;
  char *buf___1 ;
  va_list ap ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 38
  __builtin_va_start(ap, fmt);
#line 39
  len___0 = vasprintf((char **/* __restrict  */)(& buf___1), (char const   */* __restrict  */)fmt,
                      ap);
#line 40
  __builtin_va_end(ap);
  }
#line 41
  if (len___0 < 0) {
    {
#line 42
    tmp = dgettext("dico", "not enough memory while formatting reply message");
#line 42
    dico_log(5, 0, (char const   *)tmp);
#line 44
    exit(1);
    }
  }
  {
#line 46
  len___0 = dico_stream_write(str, (void const   *)buf___1, (size_t )len___0);
#line 47
  free((void *)buf___1);
  }
#line 48
  return (len___0);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xstream.c"
void stream_write_multiline(dico_stream_t str , char const   *text ) 
{ 
  struct utf8_iterator itr ;
  size_t len___0 ;
  int tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 55
  len___0 = (size_t )0;
#line 57
  utf8_iter_first(& itr, (unsigned char *)text);
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp = utf8_iter_end_p(& itr);
    }
#line 57
    if (tmp) {
#line 57
      goto while_break;
    }
#line 60
    if (itr.curwidth == 1U) {
#line 60
      if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 60
        if ((int )*(itr.curptr) == 10) {
          {
#line 61
          dico_stream_writeln(str, (char const   *)(itr.curptr - len___0), len___0);
#line 62
          len___0 = (size_t )0;
          }
        } else {
#line 64
          len___0 += itr.curwidth;
        }
      } else {
#line 64
        len___0 += itr.curwidth;
      }
    } else {
#line 64
      len___0 += itr.curwidth;
    }
    {
#line 57
    utf8_iter_next(& itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (len___0) {
    {
#line 67
    dico_stream_writeln(str, (char const   *)(itr.curptr - len___0), len___0);
    }
  }
#line 68
  return;
}
}
#line 78 "../include/xdico.h"
dico_stream_t xdico_transcript_stream_create(dico_stream_t transport , dico_stream_t logstr ,
                                             char const   **prefix___0 ) ;
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static void print_transcript(struct transcript_stream *str , int flag , char const   *buf___1 ,
                             size_t size ) 
{ 
  char const   *p ;
  size_t len___0 ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! size) {
#line 47
      goto while_break;
    }
#line 51
    if (str->flags & flag) {
      {
#line 52
      tmp = strlen((char const   *)str->prefix[flag - 1]);
#line 52
      dico_stream_write(str->logstr, (void const   *)str->prefix[flag - 1], tmp);
#line 55
      str->flags &= ~ flag;
      }
    }
    {
#line 57
    tmp___0 = memchr((void const   *)buf___1, '\n', size);
#line 57
    p = (char const   *)tmp___0;
    }
#line 58
    if (p) {
#line 59
      len___0 = (size_t )(p - buf___1);
#line 60
      if ((unsigned long )p > (unsigned long )buf___1) {
#line 60
        if ((int const   )*(p + -1) == 13) {
#line 61
          len___0 --;
        }
      }
      {
#line 62
      dico_stream_write(str->logstr, (void const   *)buf___1, len___0);
#line 63
      dico_stream_write(str->logstr, (void const   *)"\n", (size_t )1);
#line 64
      str->flags |= flag;
#line 66
      len___0 = (size_t )((p - buf___1) + 1L);
#line 67
      buf___1 = p + 1;
#line 68
      size -= len___0;
      }
    } else {
      {
#line 70
      dico_stream_write(str->logstr, (void const   *)buf___1, size);
      }
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct transcript_stream *p ;
  size_t nbytes ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 79
  p = (struct transcript_stream *)data;
#line 82
  tmp___0 = dico_stream_read(p->transport, (void *)buf___1, size, & nbytes);
  }
#line 82
  if (tmp___0 == 0) {
    {
#line 83
    print_transcript(p, 1, (char const   *)buf___1, nbytes);
    }
#line 84
    if (pret) {
#line 85
      *pret = nbytes;
    }
  } else {
    {
#line 87
    tmp = dico_stream_last_error(p->transport);
    }
#line 87
    return (tmp);
  }
#line 88
  return (0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct transcript_stream *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 94
  p = (struct transcript_stream *)data;
#line 95
  tmp___0 = dico_stream_write(p->transport, (void const   *)buf___1, size);
  }
#line 95
  if (tmp___0 == 0) {
    {
#line 96
    print_transcript(p, 2, buf___1, size);
    }
#line 97
    if (pret) {
#line 98
      *pret = size;
    }
  } else {
    {
#line 100
    tmp = dico_stream_last_error(p->transport);
    }
#line 100
    return (tmp);
  }
#line 101
  return (0);
}
}
#line 104 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_flush(void *data ) 
{ 
  struct transcript_stream *p ;
  int tmp ;

  {
#line 107
  p = (struct transcript_stream *)data;
#line 108
  if (! p->transport) {
#line 109
    return (0);
  }
  {
#line 110
  tmp = dico_stream_flush(p->transport);
  }
#line 110
  return (tmp);
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_close(void *data ) 
{ 
  struct transcript_stream *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 116
  p = (struct transcript_stream *)data;
#line 117
  tmp = dico_stream_close(p->logstr);
  }
#line 117
  return (tmp);
  {
#line 118
  tmp___0 = dico_stream_close(p->transport);
  }
#line 118
  return (tmp___0);
}
}
#line 122 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_destroy(void *data ) 
{ 
  struct transcript_stream *p ;

  {
  {
#line 125
  p = (struct transcript_stream *)data;
#line 126
  free((void *)p->prefix[0]);
#line 127
  free((void *)p->prefix[1]);
#line 128
  dico_stream_destroy(& p->transport);
#line 129
  dico_stream_destroy(& p->logstr);
#line 130
  free((void *)p);
  }
#line 131
  return (0);
}
}
#line 134 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static char const   *transcript_strerror(void *data , int rc ) 
{ 
  struct transcript_stream *p ;
  char const   *tmp ;

  {
  {
#line 137
  p = (struct transcript_stream *)data;
#line 138
  tmp = dico_stream_strerror(p->transport, rc);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_ioctl(void *data , int code , void *call_data ) 
{ 
  struct transcript_stream *p ;
  int *tmp ;

  {
#line 144
  p = (struct transcript_stream *)data;
  {
#line 146
  if (code == 0) {
#line 146
    goto case_0;
  }
#line 150
  if (code == 1) {
#line 150
    goto case_1;
  }
#line 154
  goto switch_default;
  case_0: /* CIL Label */ 
#line 147
  *((dico_stream_t *)call_data) = p->transport;
#line 148
  goto switch_break;
  case_1: /* CIL Label */ 
#line 151
  p->transport = (dico_stream_t )call_data;
#line 152
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 155
  tmp = __errno_location();
#line 155
  *tmp = 22;
  }
#line 156
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
char const   *default_prefix[2]  = {      "C: ",      "S: "};
#line 165 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
dico_stream_t xdico_transcript_stream_create(dico_stream_t transport , dico_stream_t logstr ,
                                             char const   **prefix___0 ) 
{ 
  struct transcript_stream *p ;
  void *tmp ;
  dico_stream_t stream ;
  int rc ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 169
  tmp = xmalloc((size_t )sizeof(*p));
#line 169
  p = (struct transcript_stream *)tmp;
#line 171
  tmp___0 = dico_stream_create(& stream, 3, (void *)p);
#line 171
  rc = tmp___0;
  }
#line 173
  if (rc) {
    {
#line 174
    xalloc_die();
    }
  }
#line 175
  p->flags = 3;
#line 176
  if (prefix___0) {
#line 177
    if (*(prefix___0 + 0)) {
#line 177
      tmp___1 = *(prefix___0 + 0);
    } else {
#line 177
      tmp___1 = default_prefix[0];
    }
    {
#line 177
    p->prefix[0] = xstrdup(tmp___1);
    }
#line 178
    if (*(prefix___0 + 1)) {
#line 178
      tmp___2 = *(prefix___0 + 1);
    } else {
#line 178
      tmp___2 = default_prefix[1];
    }
    {
#line 178
    p->prefix[1] = xstrdup(tmp___2);
    }
  } else {
    {
#line 180
    p->prefix[0] = xstrdup(default_prefix[0]);
#line 181
    p->prefix[1] = xstrdup(default_prefix[1]);
    }
  }
  {
#line 183
  p->transport = transport;
#line 184
  p->logstr = logstr;
#line 186
  dico_stream_set_read(stream, & transcript_read);
#line 187
  dico_stream_set_write(stream, & transcript_write);
#line 188
  dico_stream_set_flush(stream, & transcript_flush);
#line 189
  dico_stream_set_close(stream, & transcript_close);
#line 190
  dico_stream_set_destroy(stream, & transcript_destroy);
#line 191
  dico_stream_set_ioctl(stream, & transcript_ioctl);
#line 192
  dico_stream_set_error_string(stream, & transcript_strerror);
#line 193
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
  }
#line 195
  return (stream);
}
}
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 101 "../include/xdico.h"
char *xdico_local_hostname(void) ;
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xhostname.c"
char *xdico_local_hostname(void) 
{ 
  struct hostent *hp ;
  char *hostpart ;
  char *tmp ;
  char *ret ;
  char *domainpart ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 32
  tmp = xgethostname();
#line 32
  hostpart = tmp;
#line 35
  hp = gethostbyname((char const   *)hostpart);
  }
#line 36
  if (hp) {
    {
#line 37
    ret = xstrdup((char const   *)hp->h_name);
    }
  } else {
    {
#line 39
    tmp___0 = xgetdomainname();
#line 39
    domainpart = tmp___0;
    }
#line 41
    if (domainpart) {
#line 41
      if (*(domainpart + 0)) {
        {
#line 41
        tmp___4 = strcmp((char const   *)domainpart, "(none)");
        }
#line 41
        if (tmp___4) {
          {
#line 42
          tmp___1 = strlen((char const   *)hostpart);
#line 42
          tmp___2 = strlen((char const   *)domainpart);
#line 42
          tmp___3 = xmalloc(((tmp___1 + 1U) + tmp___2) + 1U);
#line 42
          ret = (char *)tmp___3;
#line 44
          strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)hostpart);
#line 45
          strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)".");
#line 46
          strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)domainpart);
#line 47
          free((void *)hostpart);
          }
        } else {
#line 49
          ret = hostpart;
        }
      } else {
#line 49
        ret = hostpart;
      }
    } else {
#line 49
      ret = hostpart;
    }
    {
#line 50
    free((void *)domainpart);
    }
  }
#line 52
  return (ret);
}
}
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 717
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 734
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 41 "../include/xdico.h"
int switch_to_privs(uid_t uid , gid_t gid , dico_list_t retain_groups ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/userprivs.c"
int switch_to_privs(uid_t uid , gid_t gid , dico_list_t retain_groups ) 
{ 
  int rc ;
  gid_t *emptygidset ;
  size_t size ;
  size_t j ;
  dico_iterator_t itr ;
  void *gp ;
  char *tmp ;
  void *tmp___0 ;
  __gid_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  __uid_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  __gid_t tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  __gid_t tmp___14 ;
  uid_t euid ;
  char *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  __uid_t tmp___23 ;
  int tmp___24 ;
  __uid_t tmp___25 ;
  __uid_t tmp___26 ;
  __uid_t tmp___27 ;
  __uid_t tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 33
  rc = 0;
#line 35
  size = (size_t )1;
#line 35
  j = (size_t )1;
#line 39
  _dico_libi18n_init();
  }
#line 41
  if (uid == 0U) {
    {
#line 42
    tmp = dgettext("dico", "Refusing to run as root");
#line 42
    dico_log(4, 0, (char const   *)tmp);
    }
#line 43
    return (1);
  }
  {
#line 47
  size = dico_list_count(retain_groups);
#line 48
  size ++;
#line 49
  tmp___0 = xcalloc(size, (size_t )sizeof(*(emptygidset + 0)));
#line 49
  emptygidset = (gid_t *)tmp___0;
  }
#line 50
  if (gid) {
#line 50
    *(emptygidset + 0) = gid;
  } else {
    {
#line 50
    tmp___1 = getegid();
#line 50
    *(emptygidset + 0) = tmp___1;
    }
  }
  {
#line 52
  itr = dico_list_iterator(retain_groups);
#line 53
  gp = dico_iterator_first(itr);
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! gp) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp___2 = j;
#line 55
    j ++;
#line 55
    *(emptygidset + tmp___2) = (gid_t )gp;
#line 53
    gp = dico_iterator_next(itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  dico_iterator_destroy(& itr);
#line 59
  tmp___5 = geteuid();
  }
#line 59
  if (tmp___5 == 0U) {
    {
#line 59
    tmp___6 = setgroups(j, (__gid_t const   *)emptygidset);
    }
#line 59
    if (tmp___6) {
      {
#line 60
      tmp___3 = dgettext("dico", "setgroups(1, %lu) failed");
#line 60
      tmp___4 = __errno_location();
#line 60
      dico_log(4, *tmp___4, (char const   *)tmp___3, (unsigned long )*(emptygidset + 0));
#line 62
      rc = 1;
      }
    }
  }
  {
#line 64
  free((void *)emptygidset);
#line 70
  rc = setegid(gid);
  }
#line 70
  if (rc < 0) {
    {
#line 71
    tmp___7 = dgettext("dico", "setegid(%lu) failed");
#line 71
    tmp___8 = __errno_location();
#line 71
    dico_log(4, *tmp___8, (char const   *)tmp___7, (unsigned long )gid);
    }
  }
#line 85
  if (rc == 0) {
#line 85
    if (gid != 0U) {
      {
#line 86
      rc = setgid(gid);
      }
#line 86
      if (rc < 0) {
        {
#line 86
        tmp___11 = getegid();
        }
#line 86
        if (tmp___11 != gid) {
          {
#line 87
          tmp___9 = dgettext("dico", "setgid(%lu) failed");
#line 87
          tmp___10 = __errno_location();
#line 87
          dico_log(4, *tmp___10, (char const   *)tmp___9, (unsigned long )gid);
          }
        }
      }
#line 89
      if (rc == 0) {
        {
#line 89
        tmp___14 = getegid();
        }
#line 89
        if (tmp___14 != gid) {
          {
#line 90
          tmp___12 = dgettext("dico", "Cannot set effective gid to %lu");
#line 90
          tmp___13 = __errno_location();
#line 90
          dico_log(4, *tmp___13, (char const   *)tmp___12, (unsigned long )gid);
#line 92
          rc = 1;
          }
        }
      }
    }
  }
#line 97
  if (rc == 0) {
#line 97
    if (uid != 0U) {
      {
#line 100
      tmp___24 = setuid(uid);
      }
#line 100
      if (tmp___24) {
#line 100
        goto _L___0;
      } else {
        {
#line 100
        tmp___25 = geteuid();
        }
#line 100
        if (tmp___25 != uid) {
#line 100
          goto _L___0;
        } else {
          {
#line 100
          tmp___26 = getuid();
          }
#line 100
          if (tmp___26 != uid) {
            {
#line 100
            tmp___27 = geteuid();
            }
#line 100
            if (tmp___27 == 0U) {
#line 100
              goto _L___0;
            } else {
              {
#line 100
              tmp___28 = getuid();
              }
#line 100
              if (tmp___28 == 0U) {
                _L___0: /* CIL Label */ 
                {
#line 106
                tmp___23 = geteuid();
                }
#line 106
                if (tmp___23 != uid) {
                  {
#line 107
                  tmp___17 = setreuid(uid, (__uid_t )-1);
                  }
#line 107
                  if (tmp___17 < 0) {
                    {
#line 108
                    tmp___15 = dgettext("dico", "setreuid(%lu,-1) failed");
#line 108
                    tmp___16 = __errno_location();
#line 108
                    dico_log(4, *tmp___16, (char const   *)tmp___15, (unsigned long )uid);
#line 110
                    rc = 1;
                    }
                  }
                  {
#line 112
                  tmp___20 = setuid(uid);
                  }
#line 112
                  if (tmp___20 < 0) {
                    {
#line 113
                    tmp___18 = dgettext("dico", "second setuid(%lu) failed");
#line 113
                    tmp___19 = __errno_location();
#line 113
                    dico_log(4, *tmp___19, (char const   *)tmp___18, (unsigned long )uid);
#line 115
                    rc = 1;
                    }
                  }
                } else {
                  {
#line 120
                  tmp___21 = dgettext("dico", "setuid(%lu) failed");
#line 120
                  tmp___22 = __errno_location();
#line 120
                  dico_log(4, *tmp___22, (char const   *)tmp___21, (unsigned long )uid);
#line 122
                  rc = 1;
                  }
                }
              }
            }
          }
        }
      }
      {
#line 126
      euid = geteuid();
      }
#line 127
      if (uid != 0U) {
        {
#line 127
        tmp___32 = setuid((__uid_t )0);
        }
#line 127
        if (tmp___32 == 0) {
          {
#line 128
          tmp___29 = dgettext("dico", "seteuid(0) succeeded when it should not");
#line 128
          dico_log(4, 0, (char const   *)tmp___29);
#line 129
          rc = 1;
          }
        } else {
#line 127
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 130
      if (uid != euid) {
        {
#line 130
        tmp___31 = setuid(euid);
        }
#line 130
        if (tmp___31 == 0) {
          {
#line 131
          tmp___30 = dgettext("dico", "Cannot drop non-root setuid privileges");
#line 131
          dico_log(4, 0, (char const   *)tmp___30);
#line 132
          rc = 1;
          }
        }
      }
    }
  }
#line 137
  return (rc);
}
}
#line 90 "../include/xdico.h"
int xdico_unquote_char(int c ) ;
#line 91
int xdico_quote_char(int c ) ;
#line 92
xdico_input_t xdico_tokenize_begin(void) ;
#line 93
void xdico_tokenize_end(xdico_input_t *pin ) ;
#line 94
int xdico_tokenize_input(xdico_input_t in , char *str , int *pargc , char ***pargv ) ;
#line 182 "../gnu/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 183
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 195
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
static char quote_transtab___0[17]  = 
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
  {      (char )'\\',      (char )'\\',      (char )'\"',      (char )'\"', 
        (char )'a',      (char )'\a',      (char )'b',      (char )'\b', 
        (char )'f',      (char )'\f',      (char )'n',      (char )'\n', 
        (char )'r',      (char )'\r',      (char )'t',      (char )'\t', 
        (char )'\000'};
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
int xdico_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 43
  p = quote_transtab___0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! *p) {
#line 43
      goto while_break;
    }
#line 44
    if ((int )*p == c) {
#line 45
      return ((int )*(p + 1));
    }
#line 43
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0);
}
}
#line 50 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
int xdico_quote_char(int c ) 
{ 
  char *p ;

  {
#line 55
  p = quote_transtab___0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! *p) {
#line 55
      goto while_break;
    }
#line 56
    if ((int )*(p + 1) == c) {
#line 57
      return ((int )*(p + 0));
    }
#line 55
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (0);
}
}
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
xdico_input_t xdico_tokenize_begin(void) 
{ 
  void *tmp ;

  {
  {
#line 65
  tmp = xzalloc((size_t )sizeof(struct xdico_input ));
  }
#line 65
  return ((xdico_input_t )tmp);
}
}
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
void xdico_tokenize_end(xdico_input_t *pin ) 
{ 
  xdico_input_t in ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 71
  in = *pin;
#line 72
  __o = & in->stk;
#line 72
  __obj = (void *)0;
#line 72
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 72
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 72
      tmp = (char *)__obj;
#line 72
      __o->object_base = tmp;
#line 72
      __o->next_free = tmp;
    } else {
      {
#line 72
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 72
    obstack_free(__o, __obj);
    }
  }
  {
#line 73
  free((void *)in);
#line 74
  *pin = (xdico_input_t )((void *)0);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
int xdico_tokenize_input(xdico_input_t in , char *str , int *pargc , char ***pargv ) 
{ 
  struct utf8_iterator itr ;
  int i___0 ;
  int argc ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  int quote___0 ;
  int tmp___0 ;
  int tmp___1 ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct obstack *__o___1 ;
  char *tmp___4 ;
  struct obstack *__o___2 ;
  int __len ;
  struct obstack *__o___3 ;
  int __len___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct obstack *__h ;
  struct obstack *__o___5 ;
  int __len___1 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  void *__cil_tmp40 ;

  {
#line 81
  argc = 0;
#line 83
  if (! in->rootptr) {
    {
#line 84
    _obstack_begin(& in->stk, 0, 0, (void *(*)(long  ))(& malloc), & free);
    }
  } else {
#line 86
    __o = & in->stk;
#line 86
    __obj = (void *)in->rootptr;
#line 86
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 86
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 86
        tmp = (char *)__obj;
#line 86
        __o->object_base = tmp;
#line 86
        __o->next_free = tmp;
      } else {
        {
#line 86
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 86
      obstack_free(__o, __obj);
      }
    }
  }
  {
#line 88
  utf8_iter_first(& itr, (unsigned char *)str);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 93
      tmp___0 = utf8_iter_end_p(& itr);
      }
#line 93
      if (tmp___0) {
#line 93
        goto while_break___0;
      } else
#line 93
      if (itr.curwidth == 1U) {
#line 93
        if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 93
          if (! ((int )*(itr.curptr) == 32)) {
#line 93
            if (! ((int )*(itr.curptr) == 9)) {
#line 93
              goto while_break___0;
            }
          }
        } else {
#line 93
          goto while_break___0;
        }
      } else {
#line 93
        goto while_break___0;
      }
      {
#line 93
      utf8_iter_next(& itr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    tmp___1 = utf8_iter_end_p(& itr);
    }
#line 98
    if (tmp___1) {
#line 99
      goto while_break;
    }
#line 101
    if (itr.curwidth == 1U) {
#line 101
      if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 101
        if ((int )*(itr.curptr) == 34) {
          {
#line 102
          quote___0 = (int )*(itr.curptr);
#line 103
          utf8_iter_next(& itr);
          }
        } else
#line 101
        if ((int )*(itr.curptr) == 39) {
          {
#line 102
          quote___0 = (int )*(itr.curptr);
#line 103
          utf8_iter_next(& itr);
          }
        } else {
#line 105
          quote___0 = 0;
        }
      } else {
#line 105
        quote___0 = 0;
      }
    } else {
#line 105
      quote___0 = 0;
    }
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 107
      tmp___5 = utf8_iter_end_p(& itr);
      }
#line 107
      if (tmp___5) {
#line 107
        goto while_break___1;
      } else
#line 107
      if (itr.curwidth == 1U) {
#line 107
        if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 107
          if (quote___0) {
#line 107
            tmp___7 = 0;
          } else {
#line 107
            if ((int )*(itr.curptr) == 32) {
#line 107
              tmp___6 = 1;
            } else
#line 107
            if ((int )*(itr.curptr) == 9) {
#line 107
              tmp___6 = 1;
            } else {
#line 107
              tmp___6 = 0;
            }
#line 107
            tmp___7 = tmp___6;
          }
#line 107
          if (tmp___7) {
#line 107
            goto while_break___1;
          }
        }
      }
#line 110
      if (itr.curwidth == 1U) {
#line 110
        if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 111
          if ((int )*(itr.curptr) == quote___0) {
            {
#line 112
            utf8_iter_next(& itr);
            }
#line 113
            goto while_break___1;
          } else
#line 114
          if ((int )*(itr.curptr) == 92) {
            {
#line 115
            utf8_iter_next(& itr);
            }
#line 116
            if (itr.curwidth == 1U) {
#line 116
              if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 117
                __o___0 = & in->stk;
#line 117
                if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
                  {
#line 117
                  _obstack_newchunk(__o___0, 1);
                  }
                }
                {
#line 117
                tmp___2 = __o___0->next_free;
#line 117
                (__o___0->next_free) ++;
#line 117
                tmp___3 = xdico_quote_char((int )*(itr.curptr));
#line 117
                *tmp___2 = (char )tmp___3;
                }
              } else {
#line 116
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 119
              __o___1 = & in->stk;
#line 119
              if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
                {
#line 119
                _obstack_newchunk(__o___1, 1);
                }
              }
#line 119
              tmp___4 = __o___1->next_free;
#line 119
              (__o___1->next_free) ++;
#line 119
              *tmp___4 = (char )'\\';
#line 120
              __o___2 = & in->stk;
#line 120
              __len = (int )itr.curwidth;
#line 120
              if ((unsigned long )(__o___2->next_free + __len) > (unsigned long )__o___2->chunk_limit) {
                {
#line 120
                _obstack_newchunk(__o___2, __len);
                }
              }
              {
#line 120
              memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)itr.curptr,
                     (size_t )__len);
#line 120
              __o___2->next_free += __len;
              }
            }
#line 122
            goto __Cont;
          }
        }
      }
#line 125
      __o___3 = & in->stk;
#line 125
      __len___0 = (int )itr.curwidth;
#line 125
      if ((unsigned long )(__o___3->next_free + __len___0) > (unsigned long )__o___3->chunk_limit) {
        {
#line 125
        _obstack_newchunk(__o___3, __len___0);
        }
      }
      {
#line 125
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)itr.curptr,
             (size_t )__len___0);
#line 125
      __o___3->next_free += __len___0;
      }
      __Cont: /* CIL Label */ 
      {
#line 107
      utf8_iter_next(& itr);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 127
    __o___4 = & in->stk;
#line 127
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 127
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 127
    tmp___8 = __o___4->next_free;
#line 127
    (__o___4->next_free) ++;
#line 127
    *tmp___8 = (char)0;
#line 128
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  __o1 = & in->stk;
#line 131
  __value = (void *)__o1->object_base;
#line 131
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 131
    __o1->maybe_empty_object = 1U;
  }
#line 131
  if (sizeof(int ) < sizeof(void *)) {
#line 131
    tmp___9 = __o1->object_base;
  } else {
#line 131
    tmp___9 = (char *)0;
  }
#line 131
  if (sizeof(int ) < sizeof(void *)) {
#line 131
    tmp___10 = __o1->object_base;
  } else {
#line 131
    tmp___10 = (char *)0;
  }
#line 131
  __o1->next_free = tmp___9 + (((__o1->next_free - tmp___10) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 131
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 131
    __o1->next_free = __o1->chunk_limit;
  }
#line 131
  __o1->object_base = __o1->next_free;
#line 131
  in->rootptr = (char *)__value;
#line 133
  in->argc = argc;
#line 134
  __h = & in->stk;
#line 134
  __o___5 = __h;
#line 134
  __len___1 = (int )((unsigned long )(argc + 1) * sizeof(*(in->argv + 0)));
#line 134
  if (__o___5->chunk_limit - __o___5->next_free < (long )__len___1) {
    {
#line 134
    _obstack_newchunk(__o___5, __len___1);
    }
  }
#line 134
  __o___5->next_free += __len___1;
#line 134
  __o1___0 = __h;
#line 134
  __value___0 = (void *)__o1___0->object_base;
#line 134
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 134
    __o1___0->maybe_empty_object = 1U;
  }
#line 134
  if (sizeof(int ) < sizeof(void *)) {
#line 134
    tmp___11 = __o1___0->object_base;
  } else {
#line 134
    tmp___11 = (char *)0;
  }
#line 134
  if (sizeof(int ) < sizeof(void *)) {
#line 134
    tmp___12 = __o1___0->object_base;
  } else {
#line 134
    tmp___12 = (char *)0;
  }
#line 134
  __o1___0->next_free = tmp___11 + (((__o1___0->next_free - tmp___12) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 134
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 134
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 134
  __o1___0->object_base = __o1___0->next_free;
#line 134
  in->argv = (char **)__value___0;
#line 136
  i___0 = 0;
  {
#line 136
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 136
    if (! (i___0 < argc)) {
#line 136
      goto while_break___2;
    }
    {
#line 137
    *(in->argv + i___0) = in->rootptr;
#line 138
    tmp___13 = strlen((char const   *)in->rootptr);
#line 138
    in->rootptr += tmp___13 + 1U;
#line 136
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 140
  *(in->argv + i___0) = (char *)((void *)0);
#line 141
  *pargc = in->argc;
#line 142
  *pargv = in->argv;
#line 143
  return (argc);
}
}
#line 68 "../include/xdico.h"
xdico_timer_t timer_get(char const   *name ) ;
#line 69
xdico_timer_t timer_start(char const   *name ) ;
#line 70
xdico_timer_t timer_stop(char const   *name ) ;
#line 71
xdico_timer_t timer_reset(char const   *name ) ;
#line 72
double timer_get_real(xdico_timer_t t ) ;
#line 73
double timer_get_user(xdico_timer_t t ) ;
#line 74
double timer_get_system(xdico_timer_t t ) ;
#line 75
void timer_format_time(dico_stream_t stream , double t ) ;
#line 88 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static Hash_table *timer_table  ;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static size_t hash_string_ci(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;
  int tmp ;

  {
#line 47
  value = (size_t )0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    ch = (unsigned char )*string;
#line 50
    if (! ch) {
#line 50
      goto while_break;
    }
    {
#line 51
    tmp = tolower((int )ch);
#line 51
    value = (value * 31U + (size_t )tmp) % n_buckets;
#line 50
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (value);
}
}
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static size_t timer_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  struct timer_slot  const  *t ;
  size_t tmp ;

  {
  {
#line 59
  t = (struct timer_slot  const  *)data;
#line 60
  tmp = hash_string_ci((char const   *)t->name, n_buckets);
  }
#line 60
  return (tmp);
}
}
#line 64 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static _Bool timer_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct timer_slot  const  *t1 ;
  struct timer_slot  const  *t2 ;
  int tmp ;

  {
  {
#line 67
  t1 = (struct timer_slot  const  *)data1;
#line 68
  t2 = (struct timer_slot  const  *)data2;
#line 69
  tmp = strcasecmp((char const   *)t1->name, (char const   *)t2->name);
  }
#line 69
  return ((_Bool )(tmp == 0));
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static xdico_timer_t timer_alloc(char const   *name ) 
{ 
  xdico_timer_t t ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 76
  tmp = strlen(name);
#line 76
  tmp___0 = xmalloc((size_t )((sizeof(*t) + (unsigned long )tmp) + 1UL));
#line 76
  t = (xdico_timer_t )tmp___0;
#line 77
  memset((void *)t, 0, (size_t )sizeof(*t));
#line 78
  t->name = (char *)(t + 1);
#line 79
  strcpy((char */* __restrict  */)t->name, (char const   */* __restrict  */)name);
  }
#line 80
  return (t);
}
}
#line 84 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_get(char const   *name ) 
{ 
  xdico_timer_t tp ;
  xdico_timer_t ret ;
  void *tmp ;

  {
  {
#line 89
  tp = timer_alloc(name);
  }
#line 91
  if (timer_table) {
#line 91
    goto _L;
  } else {
    {
#line 91
    timer_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & timer_hasher,
                                  & timer_compare, (void (*)(void * ))0);
    }
#line 91
    if (timer_table) {
      _L: /* CIL Label */ 
      {
#line 91
      tmp = hash_insert(timer_table, (void const   *)tp);
#line 91
      ret = (xdico_timer_t )tmp;
      }
#line 91
      if (! ret) {
        {
#line 96
        xalloc_die();
        }
      }
    } else {
      {
#line 96
      xalloc_die();
      }
    }
  }
#line 98
  if ((unsigned long )ret != (unsigned long )tp) {
    {
#line 99
    free((void *)tp);
    }
  }
#line 100
  return (ret);
}
}
#line 103 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_start(char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
  {
#line 106
  tmp = timer_get(name);
#line 106
  t = tmp;
#line 108
  gettimeofday((struct timeval */* __restrict  */)(& t->real_mark), (__timezone_ptr_t )((void *)0));
#line 109
  getrusage((__rusage_who_t )0, & t->self_mark);
#line 110
  getrusage((__rusage_who_t )-1, & t->children_mark);
  }
#line 111
  return (t);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static void _timer_compute(xdico_timer_t t ) 
{ 
  struct timeval real ;
  struct rusage rusage ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 124
  gettimeofday((struct timeval */* __restrict  */)(& real), (__timezone_ptr_t )((void *)0));
#line 125
  t->real = (double )(real.tv_sec - t->real_mark.tv_sec) + (double )(real.tv_usec - t->real_mark.tv_usec) / (double )1000000;
#line 126
  getrusage((__rusage_who_t )0, & rusage);
#line 127
  t->self_user = (double )(rusage.ru_utime.tv_sec - t->self_mark.ru_utime.tv_sec) + (double )(rusage.ru_utime.tv_usec - t->self_mark.ru_utime.tv_usec) / (double )1000000;
#line 128
  t->self_system = (double )(rusage.ru_stime.tv_sec - t->self_mark.ru_stime.tv_sec) + (double )(rusage.ru_stime.tv_usec - t->self_mark.ru_stime.tv_usec) / (double )1000000;
#line 130
  getrusage((__rusage_who_t )-1, & rusage);
#line 131
  t->children_user = (double )(rusage.ru_utime.tv_sec - t->children_mark.ru_utime.tv_sec) + (double )(rusage.ru_utime.tv_usec - t->children_mark.ru_utime.tv_usec) / (double )1000000;
#line 132
  t->children_system = (double )(rusage.ru_stime.tv_sec - t->children_mark.ru_stime.tv_sec) + (double )(rusage.ru_stime.tv_usec - t->children_mark.ru_stime.tv_usec) / (double )1000000;
  }
#line 133
  return;
}
}
#line 135 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_stop(char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
  {
#line 138
  tmp = timer_get(name);
#line 138
  t = tmp;
#line 139
  _timer_compute(t);
  }
#line 140
  return (t);
}
}
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_reset(char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
  {
#line 146
  tmp = timer_get(name);
#line 146
  t = tmp;
#line 147
  t->real = 0.0;
#line 148
  t->self_user = 0.0;
#line 149
  t->self_system = 0.0;
#line 150
  t->children_user = 0.0;
#line 151
  t->children_system = 0.0;
  }
#line 152
  return (t);
}
}
#line 155 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
double timer_get_real(xdico_timer_t t ) 
{ 


  {
#line 158
  return (t->real);
}
}
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
double timer_get_user(xdico_timer_t t ) 
{ 


  {
#line 164
  return (t->self_user + t->children_user);
}
}
#line 167 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
double timer_get_system(xdico_timer_t t ) 
{ 


  {
#line 170
  return (t->self_system + t->children_system);
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static char buf___0[128]  ;
#line 173 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
void timer_format_time(dico_stream_t stream , double t ) 
{ 
  long s ;
  long m ;
  long h ;
  long d ;
  size_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 178
  if (t < (double )600) {
    {
#line 179
    snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%0.3f",
             t);
    }
  } else {
#line 183
    s = (long )t;
#line 184
    d = s / 86400L;
#line 185
    s -= (d * 3600L) * 24L;
#line 186
    h = s / 3600L;
#line 187
    s -= h * 3600L;
#line 188
    m = s / 60L;
#line 189
    s -= m * 60L;
#line 191
    if (d) {
      {
#line 192
      snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%ld+%02ld:%02ld:%02ld",
               d, h, m, s);
      }
    } else
#line 193
    if (h) {
      {
#line 194
      snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%02ld:%02ld:%02ld",
               h, m, s);
      }
    } else {
      {
#line 196
      snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%02ld:%02ld",
               m, s);
      }
    }
  }
  {
#line 198
  tmp = strlen((char const   *)(buf___0));
#line 198
  dico_stream_write(stream, (void const   *)(buf___0), tmp);
  }
#line 199
  return;
}
}
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
static struct cvt_tab *tab_lookup(struct cvt_tab *tab , int c ) ;
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
struct cvt_tab shin_to_shift_tab[63]  = 
#line 38
  {      {(uchar )33, {(uchar )33, (uchar )96}, (uchar )129, (uchar )64}, 
        {(uchar )33, {(uchar )96, (uchar )127}, (uchar )129, (uchar )128}, 
        {(uchar )34, {(uchar )33, (uchar )46}, (uchar )129, (uchar )159}, 
        {(uchar )35, {(uchar )48, (uchar )57}, (uchar )130, (uchar )79}, 
        {(uchar )35, {(uchar )65, (uchar )90}, (uchar )130, (uchar )96}, 
        {(uchar )35, {(uchar )97, (uchar )122}, (uchar )130, (uchar )129}, 
        {(uchar )36, {(uchar )33, (uchar )115}, (uchar )130, (uchar )159}, 
        {(uchar )37, {(uchar )33, (uchar )96}, (uchar )131, (uchar )64}, 
        {(uchar )37, {(uchar )96, (uchar )119}, (uchar )131, (uchar )128}, 
        {(uchar )38, {(uchar )33, (uchar )56}, (uchar )131, (uchar )159}, 
        {(uchar )38, {(uchar )65, (uchar )88}, (uchar )129, (uchar )191}, 
        {(uchar )39, {(uchar )33, (uchar )96}, (uchar )132, (uchar )64}, 
        {(uchar )39, {(uchar )96, (uchar )114}, (uchar )132, (uchar )128}, 
        {(uchar )40, {(uchar )33, (uchar )64}, (uchar )132, (uchar )159}, 
        {(uchar )48, {(uchar )33, (uchar )126}, (uchar )136, (uchar )159}, 
        {(uchar )49, {(uchar )33, (uchar )96}, (uchar )137, (uchar )64}, 
        {(uchar )49, {(uchar )96, (uchar )126}, (uchar )137, (uchar )128}, 
        {(uchar )50, {(uchar )33, (uchar )126}, (uchar )137, (uchar )159}, 
        {(uchar )51, {(uchar )33, (uchar )96}, (uchar )138, (uchar )64}, 
        {(uchar )51, {(uchar )96, (uchar )126}, (uchar )138, (uchar )128}, 
        {(uchar )52, {(uchar )33, (uchar )126}, (uchar )138, (uchar )159}, 
        {(uchar )53, {(uchar )33, (uchar )96}, (uchar )139, (uchar )64}, 
        {(uchar )53, {(uchar )96, (uchar )126}, (uchar )139, (uchar )128}, 
        {(uchar )54, {(uchar )33, (uchar )126}, (uchar )139, (uchar )159}, 
        {(uchar )55, {(uchar )33, (uchar )96}, (uchar )140, (uchar )64}, 
        {(uchar )55, {(uchar )96, (uchar )126}, (uchar )140, (uchar )128}, 
        {(uchar )56, {(uchar )33, (uchar )126}, (uchar )140, (uchar )159}, 
        {(uchar )57, {(uchar )33, (uchar )96}, (uchar )141, (uchar )64}, 
        {(uchar )57, {(uchar )96, (uchar )126}, (uchar )141, (uchar )128}, 
        {(uchar )58, {(uchar )33, (uchar )126}, (uchar )141, (uchar )159}, 
        {(uchar )59, {(uchar )33, (uchar )96}, (uchar )142, (uchar )64}, 
        {(uchar )59, {(uchar )96, (uchar )126}, (uchar )142, (uchar )128}, 
        {(uchar )60, {(uchar )33, (uchar )126}, (uchar )142, (uchar )159}, 
        {(uchar )61, {(uchar )33, (uchar )96}, (uchar )143, (uchar )64}, 
        {(uchar )61, {(uchar )96, (uchar )126}, (uchar )143, (uchar )128}, 
        {(uchar )62, {(uchar )33, (uchar )126}, (uchar )143, (uchar )159}, 
        {(uchar )63, {(uchar )33, (uchar )96}, (uchar )144, (uchar )64}, 
        {(uchar )63, {(uchar )96, (uchar )126}, (uchar )144, (uchar )128}, 
        {(uchar )64, {(uchar )33, (uchar )126}, (uchar )144, (uchar )159}, 
        {(uchar )65, {(uchar )33, (uchar )96}, (uchar )145, (uchar )64}, 
        {(uchar )65, {(uchar )96, (uchar )126}, (uchar )145, (uchar )128}, 
        {(uchar )66, {(uchar )33, (uchar )126}, (uchar )145, (uchar )159}, 
        {(uchar )67, {(uchar )33, (uchar )96}, (uchar )146, (uchar )64}, 
        {(uchar )67, {(uchar )96, (uchar )126}, (uchar )146, (uchar )128}, 
        {(uchar )68, {(uchar )33, (uchar )126}, (uchar )146, (uchar )159}, 
        {(uchar )69, {(uchar )33, (uchar )96}, (uchar )147, (uchar )64}, 
        {(uchar )69, {(uchar )96, (uchar )126}, (uchar )147, (uchar )128}, 
        {(uchar )70, {(uchar )33, (uchar )126}, (uchar )147, (uchar )159}, 
        {(uchar )71, {(uchar )33, (uchar )96}, (uchar )148, (uchar )64}, 
        {(uchar )71, {(uchar )96, (uchar )126}, (uchar )148, (uchar )128}, 
        {(uchar )72, {(uchar )33, (uchar )126}, (uchar )148, (uchar )159}, 
        {(uchar )73, {(uchar )33, (uchar )96}, (uchar )149, (uchar )64}, 
        {(uchar )73, {(uchar )96, (uchar )126}, (uchar )149, (uchar )128}, 
        {(uchar )74, {(uchar )33, (uchar )126}, (uchar )149, (uchar )159}, 
        {(uchar )75, {(uchar )33, (uchar )96}, (uchar )150, (uchar )64}, 
        {(uchar )75, {(uchar )96, (uchar )126}, (uchar )150, (uchar )128}, 
        {(uchar )76, {(uchar )33, (uchar )126}, (uchar )150, (uchar )159}, 
        {(uchar )77, {(uchar )33, (uchar )96}, (uchar )151, (uchar )64}, 
        {(uchar )77, {(uchar )96, (uchar )126}, (uchar )151, (uchar )128}, 
        {(uchar )78, {(uchar )33, (uchar )126}, (uchar )151, (uchar )159}, 
        {(uchar )79, {(uchar )33, (uchar )96}, (uchar )152, (uchar )64}, 
        {(uchar )79, {(uchar )96, (uchar )126}, (uchar )152, (uchar )128}, 
        {(uchar )0, {(unsigned char)0, (unsigned char)0}, (unsigned char)0, (unsigned char)0}};
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
struct cvt_tab shift_to_shin_tab[63]  = 
#line 106
  {      {(uchar )129, {(uchar )64, (uchar )127}, (uchar )33, (uchar )33}, 
        {(uchar )129, {(uchar )128, (uchar )158}, (uchar )33, (uchar )96}, 
        {(uchar )129, {(uchar )159, (uchar )172}, (uchar )34, (uchar )33}, 
        {(uchar )130, {(uchar )79, (uchar )88}, (uchar )35, (uchar )48}, 
        {(uchar )130, {(uchar )96, (uchar )121}, (uchar )35, (uchar )65}, 
        {(uchar )130, {(uchar )129, (uchar )154}, (uchar )35, (uchar )97}, 
        {(uchar )130, {(uchar )159, (uchar )241}, (uchar )36, (uchar )33}, 
        {(uchar )131, {(uchar )64, (uchar )127}, (uchar )37, (uchar )33}, 
        {(uchar )131, {(uchar )128, (uchar )150}, (uchar )37, (uchar )96}, 
        {(uchar )131, {(uchar )159, (uchar )182}, (uchar )38, (uchar )33}, 
        {(uchar )129, {(uchar )191, (uchar )214}, (uchar )38, (uchar )65}, 
        {(uchar )132, {(uchar )64, (uchar )127}, (uchar )39, (uchar )33}, 
        {(uchar )132, {(uchar )128, (uchar )145}, (uchar )39, (uchar )96}, 
        {(uchar )132, {(uchar )159, (uchar )190}, (uchar )40, (uchar )33}, 
        {(uchar )136, {(uchar )159, (uchar )252}, (uchar )48, (uchar )33}, 
        {(uchar )137, {(uchar )64, (uchar )127}, (uchar )49, (uchar )33}, 
        {(uchar )137, {(uchar )128, (uchar )158}, (uchar )49, (uchar )96}, 
        {(uchar )137, {(uchar )159, (uchar )252}, (uchar )50, (uchar )33}, 
        {(uchar )138, {(uchar )64, (uchar )127}, (uchar )51, (uchar )33}, 
        {(uchar )138, {(uchar )128, (uchar )158}, (uchar )51, (uchar )96}, 
        {(uchar )138, {(uchar )159, (uchar )252}, (uchar )52, (uchar )33}, 
        {(uchar )139, {(uchar )64, (uchar )127}, (uchar )53, (uchar )33}, 
        {(uchar )139, {(uchar )128, (uchar )158}, (uchar )53, (uchar )96}, 
        {(uchar )139, {(uchar )159, (uchar )252}, (uchar )54, (uchar )33}, 
        {(uchar )140, {(uchar )64, (uchar )127}, (uchar )55, (uchar )33}, 
        {(uchar )140, {(uchar )128, (uchar )158}, (uchar )55, (uchar )96}, 
        {(uchar )140, {(uchar )159, (uchar )252}, (uchar )56, (uchar )33}, 
        {(uchar )141, {(uchar )64, (uchar )127}, (uchar )57, (uchar )33}, 
        {(uchar )141, {(uchar )128, (uchar )158}, (uchar )57, (uchar )96}, 
        {(uchar )141, {(uchar )159, (uchar )252}, (uchar )58, (uchar )33}, 
        {(uchar )142, {(uchar )64, (uchar )127}, (uchar )59, (uchar )33}, 
        {(uchar )142, {(uchar )128, (uchar )158}, (uchar )59, (uchar )96}, 
        {(uchar )142, {(uchar )159, (uchar )252}, (uchar )60, (uchar )33}, 
        {(uchar )143, {(uchar )64, (uchar )127}, (uchar )61, (uchar )33}, 
        {(uchar )143, {(uchar )128, (uchar )158}, (uchar )61, (uchar )96}, 
        {(uchar )143, {(uchar )159, (uchar )252}, (uchar )62, (uchar )33}, 
        {(uchar )144, {(uchar )64, (uchar )127}, (uchar )63, (uchar )33}, 
        {(uchar )144, {(uchar )128, (uchar )158}, (uchar )63, (uchar )96}, 
        {(uchar )144, {(uchar )159, (uchar )252}, (uchar )64, (uchar )33}, 
        {(uchar )145, {(uchar )64, (uchar )127}, (uchar )65, (uchar )33}, 
        {(uchar )145, {(uchar )128, (uchar )158}, (uchar )65, (uchar )96}, 
        {(uchar )145, {(uchar )159, (uchar )252}, (uchar )66, (uchar )33}, 
        {(uchar )146, {(uchar )64, (uchar )127}, (uchar )67, (uchar )33}, 
        {(uchar )146, {(uchar )128, (uchar )158}, (uchar )67, (uchar )96}, 
        {(uchar )146, {(uchar )159, (uchar )252}, (uchar )68, (uchar )33}, 
        {(uchar )147, {(uchar )64, (uchar )127}, (uchar )69, (uchar )33}, 
        {(uchar )147, {(uchar )128, (uchar )158}, (uchar )69, (uchar )96}, 
        {(uchar )147, {(uchar )159, (uchar )252}, (uchar )70, (uchar )33}, 
        {(uchar )148, {(uchar )64, (uchar )127}, (uchar )71, (uchar )33}, 
        {(uchar )148, {(uchar )128, (uchar )158}, (uchar )71, (uchar )96}, 
        {(uchar )148, {(uchar )159, (uchar )252}, (uchar )72, (uchar )33}, 
        {(uchar )149, {(uchar )64, (uchar )127}, (uchar )73, (uchar )33}, 
        {(uchar )149, {(uchar )128, (uchar )158}, (uchar )73, (uchar )96}, 
        {(uchar )149, {(uchar )159, (uchar )252}, (uchar )74, (uchar )33}, 
        {(uchar )150, {(uchar )64, (uchar )127}, (uchar )75, (uchar )33}, 
        {(uchar )150, {(uchar )128, (uchar )158}, (uchar )75, (uchar )96}, 
        {(uchar )150, {(uchar )159, (uchar )252}, (uchar )76, (uchar )33}, 
        {(uchar )151, {(uchar )64, (uchar )127}, (uchar )77, (uchar )33}, 
        {(uchar )151, {(uchar )128, (uchar )158}, (uchar )77, (uchar )96}, 
        {(uchar )151, {(uchar )159, (uchar )252}, (uchar )78, (uchar )33}, 
        {(uchar )152, {(uchar )64, (uchar )127}, (uchar )79, (uchar )33}, 
        {(uchar )152, {(uchar )128, (uchar )158}, (uchar )79, (uchar )96}, 
        {(uchar )0, {(unsigned char)0, (unsigned char)0}, (unsigned char)0, (unsigned char)0}};
#line 175 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
static struct cvt_tab *tab_lookup(struct cvt_tab *tab , int c ) 
{ 


  {
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((int )tab->in1 > 0)) {
#line 178
      goto while_break;
    }
#line 179
    if ((int )tab->in1 == c) {
#line 180
      return (tab);
    }
#line 178
    tab ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return ((struct cvt_tab *)((void *)0));
}
}
#line 184 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int convert(uchar *text , int len___0 , struct cvt_tab *tab ) 
{ 
  int i___0 ;
  int c ;
  int c2 ;
  struct cvt_tab *t ;

  {
#line 190
  i___0 = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i___0 < len___0)) {
#line 190
      goto while_break;
    }
    {
#line 191
    c = (int )*(text + 0);
#line 192
    t = tab_lookup(tab, c);
    }
#line 192
    if (t) {
#line 193
      c2 = (int )*(text + 1);
      {
#line 194
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 194
        if (! ((int )t->in1 == c)) {
#line 194
          goto while_break___0;
        }
#line 195
        if ((int )t->in2_range[0] <= c2) {
#line 195
          if (c2 <= (int )t->in2_range[1]) {
#line 196
            goto while_break___0;
          }
        }
#line 194
        t ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 199
      if ((int )t->in1 == c) {
#line 200
        c2 -= (int )t->in2_range[0] - (int )t->out2;
#line 201
        *(text + 0) = t->out1;
#line 202
        *(text + 1) = (uchar )c2;
      } else {
#line 204
        goto while_break;
      }
    } else {
#line 207
      goto while_break;
    }
#line 190
    i___0 += 2;
#line 190
    text += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (i___0);
}
}
#line 214 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int shift_to_shin(char *text , int len___0 ) 
{ 
  int tmp ;

  {
  {
#line 217
  tmp = convert((uchar *)text, len___0, shift_to_shin_tab);
  }
#line 217
  return (tmp);
}
}
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int euc_to_shin(uchar *text , int len___0 ) 
{ 
  int i___0 ;
  uchar *tmp ;

  {
#line 225
  i___0 = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i___0 < len___0)) {
#line 225
      goto while_break;
    }
#line 226
    tmp = text;
#line 226
    text ++;
#line 226
    *tmp = (uchar )((int )*tmp - 128);
#line 225
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (len___0);
}
}
#line 231 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int shin_to_euc(uchar *text , int len___0 ) 
{ 
  int i___0 ;
  uchar *tmp ;

  {
#line 236
  i___0 = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i___0 < len___0)) {
#line 236
      goto while_break;
    }
#line 237
    tmp = text;
#line 237
    text ++;
#line 237
    *tmp = (uchar )((int )*tmp + 128);
#line 236
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return (len___0);
}
}
#line 365 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 366
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 368
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 74
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 136 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 29 "../include/xdico.h"
char *ip_hostname(IPADDR ipaddr ) ;
#line 30
IPADDR get_ipaddr(char *host ) ;
#line 31
int str2port(char *str ) ;
#line 35
void sockaddr_to_str(struct sockaddr  const  *sa , int salen , char *bufptr , size_t buflen ,
                     size_t *plen ) ;
#line 38
char *sockaddr_to_astr(struct sockaddr  const  *sa , int salen ) ;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
IPADDR get_ipaddr(char *host ) 
{ 
  struct hostent *hp ;
  struct in_addr addr ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;

  {
  {
#line 48
  tmp___1 = inet_aton((char const   *)host, & addr);
  }
#line 48
  if (tmp___1) {
    {
#line 49
    tmp = ntohl(addr.s_addr);
    }
#line 49
    return ((IPADDR )tmp);
  } else {
    {
#line 50
    hp = gethostbyname((char const   *)host);
    }
#line 50
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 51
      return ((IPADDR )0);
    } else {
      {
#line 53
      tmp___0 = ntohl((uint32_t )*((UINT4 *)*(hp->h_addr_list + 0)));
      }
#line 53
      return ((IPADDR )tmp___0);
    }
  }
}
}
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
char *ip_hostname(IPADDR ipaddr ) 
{ 
  struct hostent *hp ;
  UINT4 n_ipaddr ;
  uint32_t tmp ;
  struct in_addr in ;
  char *tmp___0 ;
  void *__cil_tmp7 ;

  {
  {
#line 66
  tmp = htonl((uint32_t )ipaddr);
#line 66
  n_ipaddr = (UINT4 )tmp;
#line 67
  hp = gethostbyaddr((void const   *)((char *)(& n_ipaddr)), (__socklen_t )sizeof(struct in_addr ),
                     2);
  }
#line 69
  if (! hp) {
    {
#line 71
    in.s_addr = htonl((uint32_t )ipaddr);
#line 72
    tmp___0 = inet_ntoa(in);
    }
#line 72
    return (tmp___0);
  }
#line 74
  return (hp->h_name);
}
}
#line 77 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
IPADDR getmyip(void) 
{ 
  char myname[256] ;
  IPADDR tmp ;
  void *__cil_tmp3 ;

  {
  {
#line 82
  gethostname(myname, (size_t )sizeof(myname));
#line 83
  tmp = get_ipaddr(myname);
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
int str2port(char *str ) 
{ 
  struct servent *serv ;
  char *p ;
  int port ;
  uint16_t tmp ;
  long l ;
  char *__cil_tmp7 ;

  {
  {
#line 94
  serv = getservbyname((char const   *)str, "tcp");
  }
#line 96
  if ((unsigned long )serv != (unsigned long )((void *)0)) {
    {
#line 97
    tmp = ntohs((uint16_t )serv->s_port);
#line 97
    port = (int )tmp;
    }
  } else {
    {
#line 101
    l = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
               0);
    }
#line 103
    if (*p) {
#line 104
      return (-1);
    } else
#line 103
    if (l < 0L) {
#line 104
      return (-1);
    } else
#line 103
    if (l > 65535L) {
#line 104
      return (-1);
    }
#line 106
    port = (int )l;
  }
#line 109
  return (port);
}
}
#line 112 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
static size_t mu_stpcpy(char **pbuf , size_t *psize , char const   *src ) 
{ 
  size_t slen ;
  size_t tmp ;
  char *buf___1 ;
  size_t size ;

  {
  {
#line 115
  tmp = strlen(src);
#line 115
  slen = tmp;
  }
#line 116
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 117
    return (slen);
  } else
#line 116
  if ((unsigned long )*pbuf == (unsigned long )((void *)0)) {
#line 117
    return (slen);
  } else {
#line 119
    buf___1 = *pbuf;
#line 120
    size = *psize;
#line 121
    if (size > slen) {
#line 122
      size = slen;
    }
    {
#line 123
    memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)src,
           size);
#line 124
    *psize -= size;
#line 125
    *pbuf += size;
    }
#line 126
    if (*psize) {
#line 127
      *(*pbuf) = (char)0;
    } else {
#line 129
      *(*pbuf + -1) = (char)0;
    }
#line 130
    return (size);
  }
}
}
#line 137 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
void sockaddr_to_str(struct sockaddr  const  *sa , int salen , char *bufptr , size_t buflen ,
                     size_t *plen ) 
{ 
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  size_t len___0 ;
  struct sockaddr_in s_in ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  uint16_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  struct sockaddr_un *s_un ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 143
  len___0 = (size_t )0;
  {
#line 145
  if ((int const   )sa->sa_family == 2) {
#line 145
    goto case_2;
  }
#line 155
  if ((int const   )sa->sa_family == 1) {
#line 155
    goto case_1;
  }
#line 167
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 147
  s_in = *((struct sockaddr_in *)sa);
#line 148
  tmp = inet_ntoa(s_in.sin_addr);
#line 148
  tmp___0 = mu_stpcpy(& bufptr, & buflen, (char const   *)tmp);
#line 148
  len___0 += tmp___0;
#line 149
  tmp___1 = mu_stpcpy(& bufptr, & buflen, ":");
#line 149
  len___0 += tmp___1;
#line 150
  tmp___2 = ntohs(s_in.sin_port);
#line 150
  tmp___3 = umaxtostr((uintmax_t )tmp___2, buf___1);
#line 150
  tmp___4 = mu_stpcpy(& bufptr, & buflen, (char const   *)tmp___3);
#line 150
  len___0 += tmp___4;
  }
#line 152
  goto switch_break;
  case_1: /* CIL Label */ 
#line 157
  s_un = (struct sockaddr_un *)sa;
#line 158
  if ((unsigned long )salen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 158
    tmp___8 = "";
  } else {
#line 158
    tmp___8 = (char const   *)(s_un->sun_path);
  }
#line 158
  if ((int const   )*(tmp___8 + 0) == 0) {
    {
#line 159
    tmp___5 = mu_stpcpy(& bufptr, & buflen, "anonymous socket");
#line 159
    len___0 += tmp___5;
    }
  } else {
    {
#line 161
    tmp___6 = mu_stpcpy(& bufptr, & buflen, "socket ");
#line 161
    len___0 += tmp___6;
#line 162
    tmp___7 = mu_stpcpy(& bufptr, & buflen, (char const   *)(s_un->sun_path));
#line 162
    len___0 += tmp___7;
    }
  }
#line 164
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 168
  tmp___9 = mu_stpcpy(& bufptr, & buflen, "{Unsupported family: ");
#line 168
  len___0 += tmp___9;
#line 169
  tmp___10 = umaxtostr((uintmax_t )sa->sa_family, buf___1);
#line 169
  tmp___11 = mu_stpcpy(& bufptr, & buflen, (char const   *)tmp___10);
#line 169
  len___0 += tmp___11;
#line 170
  tmp___12 = mu_stpcpy(& bufptr, & buflen, "}");
#line 170
  len___0 += tmp___12;
  }
  switch_break: /* CIL Label */ ;
  }
#line 172
  if (plen) {
#line 173
    *plen = len___0 + 1U;
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
char *sockaddr_to_astr(struct sockaddr  const  *sa , int salen ) 
{ 
  size_t size ;
  char *p ;
  void *tmp ;

  {
  {
#line 182
  sockaddr_to_str(sa, salen, (char *)((void *)0), (size_t )0, & size);
#line 183
  tmp = xmalloc(size);
#line 183
  p = (char *)tmp;
#line 184
  sockaddr_to_str(sa, salen, p, size, (size_t *)((void *)0));
  }
#line 185
  return (p);
}
}
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/appi18n.c"
void appi18n_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 27
  setlocale(6, "");
#line 28
  bindtextdomain("dico", "/usr/local/share/locale");
#line 29
  textdomain("dico");
  }
#line 30
  return;
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static int vl_exit___0(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 49
static lt_module vm_open___0(lt_user_data loader_data  __attribute__((__unused__)) ,
                             char const   *filename___0 , lt_dladvise advise ) ;
#line 51
static int vm_close___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ) ;
#line 52
static void *vm_sym___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                        char const   *name ) ;
#line 55 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static lt_dlvtable *vtable___0  =    (lt_dlvtable *)0;
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
lt_dlvtable *dlopen_LTX_get_vtable(lt_user_data loader_data ) 
{ 
  void *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 63
  if (! vtable___0) {
    {
#line 65
    tmp = lt__zalloc((size_t )sizeof(*vtable___0));
#line 65
    vtable___0 = (lt_dlvtable *)tmp;
    }
  }
#line 68
  if (vtable___0) {
#line 68
    if (! vtable___0->name) {
#line 70
      vtable___0->name = "lt_dlopen";
#line 74
      vtable___0->module_open = & vm_open___0;
#line 75
      vtable___0->module_close = & vm_close___0;
#line 76
      vtable___0->find_sym = & vm_sym___0;
#line 77
      vtable___0->dlloader_exit = & vl_exit___0;
#line 78
      vtable___0->dlloader_data = loader_data;
#line 79
      vtable___0->priority = (lt_dlloader_priority )0;
    }
  }
#line 82
  if (vtable___0) {
#line 82
    if ((unsigned long )vtable___0->dlloader_data != (unsigned long )loader_data) {
      {
#line 84
      tmp___0 = lt__error_string(3);
#line 84
      lt__set_last_error(tmp___0);
      }
#line 85
      return ((lt_dlvtable *)0);
    }
  }
#line 88
  return (vtable___0);
}
}
#line 57 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 61
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 65
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
#line 83
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 154 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static int vl_exit___0(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 


  {
#line 157
  vtable___0 = (lt_dlvtable *)((void *)0);
#line 158
  return (0);
}
}
#line 165 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static lt_module vm_open___0(lt_user_data loader_data  __attribute__((__unused__)) ,
                             char const   *filename___0 , lt_dladvise advise ) 
{ 
  int module_flags ;
  lt_module module ;
  char *tmp ;

  {
#line 169
  module_flags = 1;
#line 172
  if (advise) {
#line 177
    if (advise->is_symglobal) {
#line 178
      module_flags |= 256;
    }
#line 187
    if (advise->is_symlocal) {
#line 188
      module_flags = module_flags;
    }
  }
  {
#line 201
  module = dlopen(filename___0, module_flags);
  }
#line 203
  if (! module) {
    {
#line 205
    tmp = dlerror();
#line 205
    lt__set_last_error((char const   *)tmp);
    }
  }
#line 208
  return (module);
}
}
#line 214 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static int vm_close___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ) 
{ 
  int errors ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 217
  errors = 0;
#line 219
  tmp___0 = dlclose(module);
  }
#line 219
  if (tmp___0 != 0) {
    {
#line 221
    tmp = dlerror();
#line 221
    lt__set_last_error((char const   *)tmp);
#line 222
    errors ++;
    }
  }
#line 225
  return (errors);
}
}
#line 231 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static void *vm_sym___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                        char const   *name ) 
{ 
  void *address ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 234
  tmp = dlsym((void */* __restrict  */)module, (char const   */* __restrict  */)name);
#line 234
  address = tmp;
  }
#line 236
  if (! address) {
    {
#line 238
    tmp___0 = dlerror();
#line 238
    lt__set_last_error((char const   *)tmp___0);
    }
  }
#line 241
  return (address);
}
}
#line 795 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 382
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int quiet_option ;
#line 167
char *get_homedir(void) ;
#line 189
char *skipws(char *buf___1 ) ;
#line 198
struct funtab *find_funtab(char const   *name ) ;
#line 199
void parse_init_scripts(void) ;
#line 200
void dico_shell(void) ;
#line 201
void script_warning(char const   *fmt  , ...) ;
#line 202
void script_error(char const   *fmt  , ...) ;
#line 203
char **dict_completion_matches(int argc , char **argv , int ws , char *(*generator)(char const   * ,
                                                                                    int  ) ) ;
#line 208
int set_bool(int *pval , char *str ) ;
#line 209
void ds_silent_close(void) ;
#line 210
void ds_open(int argc , char **argv ) ;
#line 211
void ds_close(int argc , char **argv ) ;
#line 212
void ds_autologin(int argc , char **argv ) ;
#line 213
void ds_database(int argc , char **argv ) ;
#line 214
void ds_define_nth(size_t num ) ;
#line 215
void ds_strategy(int argc , char **argv ) ;
#line 216
void ds_transcript(int argc , char **argv ) ;
#line 217
void ds_define(int argc , char **argv ) ;
#line 218
void ds_match(int argc , char **argv ) ;
#line 219
void ds_distance(int argc , char **argv ) ;
#line 220
void ds_version(int argc , char **argv ) ;
#line 221
void ds_warranty(int argc , char **argv ) ;
#line 222
void ds_show_db(int argc , char **argv ) ;
#line 223
void ds_show_strat(int argc , char **argv ) ;
#line 224
void ds_show_info(int argc , char **argv ) ;
#line 225
void ds_sasl(int argc , char **argv ) ;
#line 226
void ds_verbose(int argc , char **argv ) ;
#line 228
char **ds_compl_database(int argc , char **argv , int ws ) ;
#line 229
char **ds_compl_strategy(int argc , char **argv , int ws ) ;
#line 232
void ds_pager(int argc , char **argv ) ;
#line 233
dico_stream_t create_pager_stream(size_t nlines___0 ) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
int interactive  ;
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
char *prompt  ;
#line 23
static void ds_prefix(int argc , char **argv ) ;
#line 24
static void ds_help(int argc , char **argv ) ;
#line 25
static void ds_quiet(int argc , char **argv ) ;
#line 26
static void ds_prompt(int argc , char **argv ) ;
#line 27
static char **no_compl(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                       int ws  __attribute__((__unused__)) ) ;
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
char *helptext[4][2]  = { {        (char *)"WORD",        (char *)"Define WORD."}, 
   {        (char *)"/WORD",        (char *)"Match WORD."}, 
   {        (char *)"/",        (char *)"Redisplay previous matches."}, 
   {        (char *)"NUMBER",        (char *)"Define NUMBERth match."}};
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
struct funtab funtab[21]  = 
#line 43
  {      {(char *)"open", 1, 3, (char *)"[HOST [PORT]]", (char *)"Connect to a DICT server.",
      & ds_open, & no_compl}, 
        {(char *)"close", 1, 1, (char *)((void *)0), (char *)"Close the connection.",
      & ds_close, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"database", 1, 2, (char *)"[NAME]", (char *)"Set or display current database name.",
      & ds_database, & ds_compl_database}, 
        {(char *)"strategy", 1, 2, (char *)"[NAME]", (char *)"Set or display current strategy.",
      & ds_strategy, & ds_compl_strategy}, 
        {(char *)"distance", 1, 2, (char *)"[NUM]", (char *)"Set or query Levenshtein distance (server-dependent).",
      & ds_distance, & no_compl}, 
        {(char *)"ls", 1, 1, (char *)((void *)0), (char *)"List available matching strategies",
      & ds_show_strat, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"ld", 1, 1, (char *)((void *)0), (char *)"List all accessible databases",
      & ds_show_db, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"info", 1, 2, (char *)"[DB]", (char *)"Display the information about the database.",
      & ds_show_info, & ds_compl_database}, 
        {(char *)"prefix", 1, 2, (char *)"[CHAR]", (char *)"Set or display command prefix.",
      & ds_prefix, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"transcript", 1, 2, (char *)"[BOOL]", (char *)"Set or display session transcript mode.",
      & ds_transcript, & no_compl}, 
        {(char *)"verbose", 1, 2, (char *)"[NUMBER]", (char *)"Set or display verbosity level.",
      & ds_verbose, & no_compl}, 
        {(char *)"prompt", 2, 2, (char *)"STRING", (char *)"Change command line prompt.",
      & ds_prompt, & no_compl}, 
        {(char *)"pager", 1, 2, (char *)"STRING", (char *)"Change or display pager settings.",
      & ds_pager, & no_compl}, 
        {(char *)"autologin", 1, 2, (char *)"[FILE]", (char *)"Set or display autologin file name.",
      & ds_autologin, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"sasl", 1, 2, (char *)"[BOOL]", (char *)"Enable SASL authentication.",
      & ds_sasl, & no_compl}, 
        {(char *)"help", 1, 1, (char *)((void *)0), (char *)"Display this help text.",
      & ds_help, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"version", 1, 1, (char *)((void *)0), (char *)"Print program version.",
      & ds_version, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"warranty", 1, 1, (char *)((void *)0), (char *)"Print copyright statement.",
      & ds_warranty, (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"quiet", 2, 2, (char *)((void *)0), (char *)((void *)0), & ds_quiet,
      (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)"quit", 1, 1, (char *)((void *)0), (char *)"Quit the shell.", (void (*)(int argc ,
                                                                                      char **argv ))0,
      (char **(*)(int argc , char **argv , int ws ))0}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(int argc , char **argv ))0,
      (char **(*)(int argc , char **argv , int ws ))0}};
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
struct funtab *find_funtab(char const   *name ) 
{ 
  struct funtab *p ;
  int tmp ;

  {
#line 136
  p = funtab;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! p->name) {
#line 136
      goto while_break;
    }
    {
#line 137
    tmp = strcmp((char const   *)p->name, name);
    }
#line 137
    if (tmp == 0) {
#line 138
      return (p);
    }
#line 136
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return ((struct funtab *)((void *)0));
}
}
#line 142 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
int cmdprefix  ;
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
char special_prefixes[2]  ;
#line 145 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static void ds_prefix(int argc , char **argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 148
  if (argc == 1) {
    {
#line 149
    tmp = gettext("Command prefix is %c\n");
#line 149
    printf((char const   */* __restrict  */)tmp, cmdprefix);
    }
  } else
#line 150
  if (! *(*(argv + 1) + 1)) {
#line 150
    if ((int )*(*(argv + 1) + 0) != 35) {
      {
#line 150
      tmp___1 = __ctype_b_loc();
      }
#line 150
      if ((int const   )*(*tmp___1 + (int )*(*(argv + 1) + 0)) & 4) {
        {
#line 153
        cmdprefix = (int )*(*(argv + 1) + 0);
#line 154
        strcpy((char */* __restrict  */)(special_prefixes), (char const   */* __restrict  */)*(argv + 1));
        }
      } else {
        {
#line 151
        tmp___0 = gettext("Expected a single punctuation character");
#line 151
        script_error((char const   *)tmp___0);
        }
      }
    } else {
      {
#line 151
      tmp___0 = gettext("Expected a single punctuation character");
#line 151
      script_error((char const   *)tmp___0);
      }
    }
  } else {
    {
#line 151
    tmp___0 = gettext("Expected a single punctuation character");
#line 151
    script_error((char const   *)tmp___0);
    }
  }
#line 159
  return;
}
}
#line 164 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static size_t nlines  ;
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static void ds_help(int argc , char **argv ) 
{ 
  dico_stream_t str ;
  struct funtab *ft ;
  size_t i___0 ;
  char *tmp ;
  char *tmp___0 ;
  int len___0 ;
  char const   *args ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 169
  if (nlines == 0U) {
#line 170
    nlines = (size_t )(sizeof(helptext) / sizeof(helptext[0]) + 1UL);
#line 171
    ft = funtab;
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! ft->name) {
#line 171
        goto while_break;
      }
#line 172
      if (ft->docstring) {
#line 173
        nlines ++;
      }
#line 171
      ft ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 177
  str = create_pager_stream(nlines);
#line 178
  i___0 = (size_t )0;
  }
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )i___0 < sizeof(helptext) / sizeof(helptext[0]))) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    tmp = gettext((char const   *)helptext[i___0][1]);
#line 179
    tmp___0 = gettext((char const   *)helptext[i___0][0]);
#line 179
    stream_printf(str, "%-24s %s\n", tmp___0, tmp);
#line 178
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  dico_stream_write(str, (void const   *)"\n", (size_t )1);
#line 183
  ft = funtab;
  }
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (! ft->name) {
#line 183
      goto while_break___1;
    }
#line 184
    len___0 = 0;
#line 187
    if ((unsigned long )ft->docstring == (unsigned long )((void *)0)) {
#line 188
      goto __Cont;
    }
#line 189
    if (cmdprefix) {
      {
#line 190
      stream_printf(str, "%c", cmdprefix);
#line 191
      len___0 ++;
      }
    }
    {
#line 193
    stream_printf(str, "%s ", ft->name);
#line 194
    tmp___1 = strlen((char const   *)ft->name);
#line 194
    len___0 = (int )((size_t )len___0 + (tmp___1 + 1U));
    }
#line 195
    if (ft->argdoc) {
      {
#line 196
      tmp___2 = gettext((char const   *)ft->argdoc);
#line 196
      args = (char const   *)tmp___2;
      }
    } else {
#line 198
      args = "";
    }
#line 199
    if (len___0 < 24) {
#line 200
      len___0 = 24 - len___0;
    } else {
#line 202
      len___0 = 0;
    }
    {
#line 203
    tmp___3 = gettext((char const   *)ft->docstring);
#line 203
    stream_printf(str, "%-*s %s\n", len___0, args, tmp___3);
    }
    __Cont: /* CIL Label */ 
#line 183
    ft ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 206
  dico_stream_close(str);
#line 207
  dico_stream_destroy(& str);
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static void ds_quiet(int argc , char **argv ) 
{ 


  {
  {
#line 213
  set_bool(& quiet_option, *(argv + 1));
  }
#line 214
  return;
}
}
#line 219 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
int line  =    0;
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
char const   *filename  ;
#line 222 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void script_diag(int category , int errcode , char const   *fmt , va_list ap ) 
{ 
  char const   *pfx ;
  char *newfmt ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 228
  if (category == 3) {
    {
#line 229
    tmp = gettext("warning: ");
#line 229
    pfx = (char const   *)tmp;
    }
  } else {
#line 231
    pfx = (char const   *)((void *)0);
  }
#line 233
  if (! filename) {
#line 234
    if (pfx) {
#line 234
      tmp___0 = pfx;
    } else {
#line 234
      tmp___0 = "";
    }
    {
#line 234
    asprintf((char **/* __restrict  */)(& newfmt), (char const   */* __restrict  */)"%s%s",
             tmp___0, fmt);
    }
  } else {
#line 236
    if (pfx) {
#line 236
      tmp___1 = pfx;
    } else {
#line 236
      tmp___1 = "";
    }
    {
#line 236
    asprintf((char **/* __restrict  */)(& newfmt), (char const   */* __restrict  */)"%s:%d: %s%s",
             filename, line, tmp___1, fmt);
    }
  }
  {
#line 240
  dico_vlog(category, errcode, (char const   *)newfmt, ap);
#line 241
  free((void *)newfmt);
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void script_warning(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 249
  __builtin_va_start(ap, fmt);
#line 250
  script_diag(3, 0, fmt, ap);
#line 251
  __builtin_va_end(ap);
  }
#line 252
  return;
}
}
#line 254 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void script_error(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 259
  __builtin_va_start(ap, fmt);
#line 260
  script_diag(4, 0, fmt, ap);
#line 261
  __builtin_va_end(ap);
  }
#line 262
  return;
}
}
#line 264 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static int is_command(char **ptr ) 
{ 


  {
#line 267
  if (! cmdprefix) {
#line 268
    return (1);
  }
#line 269
  if ((int )*(*ptr + 0) == cmdprefix) {
#line 270
    (*ptr) ++;
#line 271
    return (1);
  }
#line 273
  return (0);
}
}
#line 277 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void parse_script_file(char const   *fname , int (*getln)(void *data , char **buf ) ,
                       void *data ) 
{ 
  char *buf___1 ;
  xdico_input_t input ;
  int argc ;
  char **argv ;
  char *p ;
  char *start ;
  char *xargv[3] ;
  char *q ;
  size_t num ;
  unsigned long tmp ;
  struct funtab *ft ;
  struct funtab *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 280
  buf___1 = (char *)((void *)0);
#line 285
  filename = fname;
#line 286
  line = 0;
#line 287
  input = xdico_tokenize_begin();
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 288
    tmp___6 = (*getln)(data, & buf___1);
    }
#line 288
    if (! tmp___6) {
#line 288
      goto while_break;
    }
    {
#line 292
    line ++;
#line 294
    start = skipws(buf___1);
#line 295
    dico_trim_nl(start);
    }
#line 296
    if ((int )*start == 0) {
#line 297
      goto while_continue;
    } else
#line 296
    if ((int )*start == 35) {
#line 297
      goto while_continue;
    }
    {
#line 299
    xdico_tokenize_input(input, start, & argc, & argv);
    }
#line 300
    if (argc == 0) {
#line 301
      goto while_continue;
    }
#line 303
    p = *(argv + 0);
    {
#line 314
    if ((int )*(p + 0) == 47) {
#line 314
      goto case_47;
    }
#line 321
    if ((int )*(p + 0) == 63) {
#line 321
      goto case_63;
    }
#line 326
    if ((int )*(p + 0) == 57) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 56) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 55) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 54) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 53) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 52) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 51) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 50) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 49) {
#line 326
      goto case_57;
    }
#line 326
    if ((int )*(p + 0) == 48) {
#line 326
      goto case_57;
    }
#line 313
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 315
    xargv[0] = (char *)"match";
#line 316
    xargv[1] = skipws(start + 1);
#line 317
    xargv[2] = (char *)((void *)0);
#line 318
    ds_match(2, xargv);
    }
#line 319
    goto while_continue;
    case_63: /* CIL Label */ 
    {
#line 322
    ds_help(0, (char **)((void *)0));
    }
#line 323
    goto while_continue;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 327
    if (argc == 1) {
      {
#line 329
      tmp = strtoul((char const   */* __restrict  */)*(argv + 0), (char **/* __restrict  */)(& q),
                    10);
#line 329
      num = (size_t )tmp;
      }
#line 330
      if ((int )*q == 0) {
        {
#line 331
        ds_define_nth(num);
        }
#line 332
        goto while_continue;
      }
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 337
    tmp___5 = is_command(& p);
    }
#line 337
    if (tmp___5) {
      {
#line 338
      tmp___0 = find_funtab((char const   *)p);
#line 338
      ft = tmp___0;
      }
#line 339
      if (! ft) {
        {
#line 340
        tmp___1 = gettext("unknown command");
#line 340
        script_error((char const   *)tmp___1);
        }
#line 341
        goto while_continue;
      }
#line 343
      if (ft->argmin == 0) {
        {
#line 344
        argc = 2;
#line 345
        xargv[0] = *(argv + 0);
#line 346
        tmp___2 = strlen((char const   *)xargv[0]);
#line 346
        xargv[1] = skipws(buf___1 + tmp___2);
#line 347
        xargv[2] = (char *)((void *)0);
#line 348
        argv = xargv;
        }
      } else
#line 349
      if (argc < ft->argmin) {
        {
#line 350
        tmp___3 = gettext("not enough arguments");
#line 350
        script_error((char const   *)tmp___3);
        }
#line 351
        goto while_continue;
      } else
#line 352
      if (argc > ft->argmax) {
        {
#line 353
        tmp___4 = gettext("too many arguments");
#line 353
        script_error((char const   *)tmp___4);
        }
#line 354
        goto while_continue;
      }
#line 357
      if (ft->fun) {
        {
#line 358
        (*(ft->fun))(argc, argv);
        }
      } else {
        {
#line 360
        ds_silent_close();
        }
#line 361
        goto while_break;
      }
    } else {
      {
#line 364
      xargv[0] = (char *)"define";
#line 365
      xargv[1] = start;
#line 366
      xargv[2] = (char *)((void *)0);
#line 367
      ds_define(2, xargv);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  xdico_tokenize_end(& input);
  }
#line 371
  return;
}
}
#line 380 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
int script_getline(void *data , char **buf___1 ) 
{ 
  struct init_script *p ;
  int rc ;
  __ssize_t tmp ;

  {
  {
#line 383
  p = (struct init_script *)data;
#line 384
  tmp = getline((char **/* __restrict  */)(& p->buf), (size_t */* __restrict  */)(& p->size),
                (FILE */* __restrict  */)p->fp);
#line 384
  rc = tmp;
#line 385
  *buf___1 = p->buf;
  }
#line 386
  return (rc > 0);
}
}
#line 389 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void parse_init_script(char const   *name ) 
{ 
  struct init_script scr ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 393
  scr.fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 394
  if (! scr.fp) {
    {
#line 395
    tmp___1 = __errno_location();
    }
#line 395
    if (*tmp___1 != 2) {
      {
#line 396
      tmp = gettext("Cannot open init file %s");
#line 396
      tmp___0 = __errno_location();
#line 396
      dico_log(4, *tmp___0, (char const   *)tmp, name);
      }
    }
#line 397
    return;
  }
  {
#line 399
  scr.buf = (char *)((void *)0);
#line 400
  scr.size = (size_t )0;
#line 401
  parse_script_file(name, & script_getline, (void *)(& scr));
#line 402
  fclose(scr.fp);
#line 403
  free((void *)scr.buf);
  }
#line 404
  return;
}
}
#line 406 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void parse_init_scripts(void) 
{ 
  char *name ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 409
  tmp = get_homedir();
#line 409
  tmp___0 = dico_full_file_name((char const   *)tmp, ".dico");
#line 409
  name = tmp___0;
#line 410
  parse_init_script((char const   *)name);
#line 411
  free((void *)name);
#line 412
  parse_init_script(".dico");
  }
#line 413
  return;
}
}
#line 417 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static void ds_prompt(int argc , char **argv ) 
{ 


  {
  {
#line 420
  xdico_assign_string(& prompt, *(argv + 1));
  }
#line 421
  return;
}
}
#line 575 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
char **dict_completion_matches(int argc , char **argv , int ws , char *(*generator)(char const   * ,
                                                                                    int  ) ) 
{ 


  {
#line 585
  return ((char **)0);
}
}
#line 588 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
static char **no_compl(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                       int ws  __attribute__((__unused__)) ) 
{ 


  {
#line 595
  return ((char **)((void *)0));
}
}
#line 598 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void shell_init(struct init_script *p ) 
{ 
  int tmp ;

  {
  {
#line 601
  tmp = fileno(stdin);
#line 601
  interactive = isatty(tmp);
#line 609
  p->fp = stdin;
#line 610
  p->buf = (char *)((void *)0);
#line 611
  p->size = (size_t )0;
  }
#line 612
  return;
}
}
#line 614 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void shell_finish(struct init_script *p ) 
{ 


  {
  {
#line 621
  free((void *)p->buf);
  }
#line 622
  return;
}
}
#line 624 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
int shell_getline(void *data , char **buf___1 ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
#line 627
  if (interactive) {
    {
#line 635
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
            prompt);
#line 636
    fflush(stdout);
    }
  }
  {
#line 639
  tmp = script_getline(data, buf___1);
  }
#line 639
  return (tmp);
}
}
#line 645
void print_version(char const   *program_version___0 , FILE *stream ) ;
#line 642 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void shell_banner(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 645
  print_version("GNU dico 2.0", stdout);
#line 646
  tmp = gettext("Type ? for help summary");
#line 646
  printf((char const   */* __restrict  */)"%s\n\n", tmp);
  }
#line 647
  return;
}
}
#line 649 "/home/wslee/benchmarks/textformat/dico-2.0/dico/shell.c"
void dico_shell(void) 
{ 
  struct init_script dat ;
  void *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 653
  shell_init(& dat);
  }
#line 654
  if (interactive) {
    {
#line 655
    xdico_assign_string(& prompt, (char *)"dico> ");
    }
#line 656
    if (! quiet_option) {
      {
#line 657
      shell_banner();
      }
    }
  }
#line 659
  if (! cmdprefix) {
#line 660
    cmdprefix = '.';
  }
  {
#line 661
  parse_script_file((char const   *)((void *)0), & shell_getline, (void *)(& dat));
#line 662
  shell_finish(& dat);
  }
#line 663
  return;
}
}
#line 240 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int saslauth(struct dict_connection *conn___0 , dico_url_t url ) ;
#line 241
void sasl_enable(int val ) ;
#line 242
int sasl_enabled_p(void) ;
#line 327 "/home/wslee/benchmarks/textformat/dico-2.0/dico/saslauth.c"
int saslauth(struct dict_connection *conn___0 , dico_url_t url ) 
{ 


  {
#line 330
  return (2);
}
}
#line 333 "/home/wslee/benchmarks/textformat/dico-2.0/dico/saslauth.c"
void sasl_enable(int val ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 336
  tmp = gettext("Dico compiled without SASL support");
#line 336
  dico_log(3, 0, (char const   *)tmp);
  }
#line 337
  return;
}
}
#line 339 "/home/wslee/benchmarks/textformat/dico-2.0/dico/saslauth.c"
int sasl_enabled_p(void) 
{ 


  {
#line 342
  return (0);
}
}
#line 846 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
static char *pager  ;
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
static char *get_pager_name(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 25
  if (pager) {
    {
#line 26
    tmp = strcmp((char const   *)pager, "-");
    }
#line 26
    if (tmp == 0) {
#line 27
      return ((char *)((void *)0));
    }
#line 28
    return (pager);
  }
  {
#line 30
  tmp___0 = getenv("PAGER");
  }
#line 30
  return (tmp___0);
}
}
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
void ds_pager(int argc , char **argv ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 36
  if (argc == 1) {
    {
#line 37
    tmp = get_pager_name();
#line 37
    p = tmp;
    }
#line 38
    if (p) {
      {
#line 39
      printf((char const   */* __restrict  */)"%s\n", p);
      }
#line 40
      if (! pager) {
        {
#line 41
        tmp___0 = gettext("(Pager set from environment)");
#line 41
        printf((char const   */* __restrict  */)"%s\n", tmp___0);
        }
      }
    }
  } else {
    {
#line 44
    xdico_assign_string(& pager, *(argv + 1));
    }
  }
#line 45
  return;
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
dico_stream_t create_output_stream(void) 
{ 
  int tmp ;
  dico_stream_t tmp___0 ;

  {
  {
#line 51
  tmp = fileno(stdout);
#line 51
  tmp___0 = dico_fd_stream_create(tmp, 2, 1);
  }
#line 51
  return (tmp___0);
}
}
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
static int get_screen_lines(void) 
{ 
  struct winsize ws ;
  char const   *lines ;
  char *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 59
  ws.ws_row = (unsigned short)0;
#line 59
  ws.ws_col = ws.ws_row;
#line 60
  tmp___1 = ioctl(1, 21523UL, (char *)(& ws));
  }
#line 60
  if (tmp___1 < 0) {
#line 60
    goto _L;
  } else
#line 60
  if ((int )ws.ws_row == 0) {
    _L: /* CIL Label */ 
    {
#line 61
    tmp = getenv("LINES");
#line 61
    lines = (char const   *)tmp;
    }
#line 62
    if (lines) {
      {
#line 63
      tmp___0 = strtol((char const   */* __restrict  */)lines, (char **/* __restrict  */)((void *)0),
                       10);
#line 63
      ws.ws_row = (unsigned short )tmp___0;
      }
    }
  }
#line 65
  return ((int )ws.ws_row);
}
}
#line 72 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
static int fp_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct pfile_stream *p ;
  int tmp ;

  {
  {
#line 75
  p = (struct pfile_stream *)data;
#line 76
  *pret = fwrite((void const   */* __restrict  */)buf___1, (size_t )1, size, (FILE */* __restrict  */)p->fp);
#line 77
  tmp = ferror(p->fp);
  }
#line 77
  return (tmp);
}
}
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
static int fp_close(void *data ) 
{ 
  struct pfile_stream *p ;

  {
  {
#line 83
  p = (struct pfile_stream *)data;
#line 84
  pclose(p->fp);
  }
#line 85
  return (0);
}
}
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
static dico_stream_t create_pfile_stream(FILE *fp ) 
{ 
  dico_stream_t str ;
  struct pfile_stream *s ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 94
  tmp = xmalloc((size_t )sizeof(*s));
#line 94
  s = (struct pfile_stream *)tmp;
#line 95
  s->fp = fp;
#line 96
  tmp___0 = dico_stream_create(& str, 2, (void *)s);
  }
#line 96
  if (tmp___0) {
    {
#line 97
    xalloc_die();
    }
  }
  {
#line 98
  dico_stream_set_write(str, & fp_write);
#line 99
  dico_stream_set_close(str, & fp_close);
  }
#line 100
  return (str);
}
}
#line 103 "/home/wslee/benchmarks/textformat/dico-2.0/dico/pager.c"
dico_stream_t create_pager_stream(size_t nlines___0 ) 
{ 
  char *pager___0 ;
  char *tmp ;
  FILE *fp ;
  dico_stream_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  dico_stream_t tmp___4 ;
  dico_stream_t tmp___5 ;
  char *__cil_tmp11 ;

  {
  {
#line 106
  tmp = get_pager_name();
#line 106
  pager___0 = tmp;
  }
#line 109
  if (! pager___0) {
    {
#line 111
    tmp___0 = create_output_stream();
    }
#line 111
    return (tmp___0);
  } else
#line 109
  if (! *(pager___0 + 0)) {
    {
#line 111
    tmp___0 = create_output_stream();
    }
#line 111
    return (tmp___0);
  } else {
    {
#line 109
    tmp___1 = fileno(stdout);
#line 109
    tmp___2 = isatty(tmp___1);
    }
#line 109
    if (tmp___2) {
      {
#line 109
      tmp___3 = get_screen_lines();
      }
#line 109
      if (nlines___0 < (size_t )tmp___3) {
        {
#line 111
        tmp___0 = create_output_stream();
        }
#line 111
        return (tmp___0);
      }
    } else {
      {
#line 111
      tmp___0 = create_output_stream();
      }
#line 111
      return (tmp___0);
    }
  }
  {
#line 112
  fp = popen((char const   *)pager___0, "w");
  }
#line 113
  if (! fp) {
    {
#line 114
    tmp___4 = create_output_stream();
    }
#line 114
    return (tmp___4);
  }
  {
#line 115
  tmp___5 = create_pfile_stream(fp);
  }
#line 115
  return (tmp___5);
}
}
#line 104 "../include/xdico.h"
int debug_level ;
#line 105
int debug_source_info ;
#line 106
dico_stream_t debug_stream ;
#line 137 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct dico_url dico_url ;
#line 152
int dict_connect(struct dict_connection **pconn , dico_url_t url ) ;
#line 153
void dict_conn_close(struct dict_connection *conn___0 ) ;
#line 154
int dict_read_reply(struct dict_connection *conn___0 ) ;
#line 155
int dict_status_p(struct dict_connection *conn___0 , char *status ) ;
#line 157
int dict_multiline_reply(struct dict_connection *conn___0 ) ;
#line 158
struct dict_result *dict_result_create(struct dict_connection *conn___0 , enum dict_result_type type ,
                                       size_t count , char *base ) ;
#line 161
void dict_result_free(struct dict_result *res ) ;
#line 163
int dict_define(struct dict_connection *conn___0 , char *database , char *word ) ;
#line 164
int dict_match(struct dict_connection *conn___0 , char *database , char *strategy ,
               char *word ) ;
#line 178
int dict_lookup_url(dico_url_t url ) ;
#line 179
int dict_word(char *word ) ;
#line 180
int dict_lookup(struct dict_connection *conn___0 , dico_url_t url ) ;
#line 181
int dict_single_command(char *cmd , char *arg , char *code ) ;
#line 182
void dict_run_single_command(struct dict_connection *conn___0 , char *cmd , char *arg ,
                             char *code ) ;
#line 184
void print_result(struct dict_result *res ) ;
#line 185
void print_match_result(struct dict_result *res ) ;
#line 186
void print_reply(struct dict_connection *conn___0 ) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
void print_reply(struct dict_connection *conn___0 ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 22
  tmp___0 = strncmp((char const   *)conn___0->buf, "552", (size_t )3);
  }
#line 22
  if (tmp___0 == 0) {
    {
#line 23
    tmp = gettext("No match");
#line 23
    printf((char const   */* __restrict  */)"%s\n", tmp);
    }
  } else {
    {
#line 25
    printf((char const   */* __restrict  */)"Error: %s\n", conn___0->buf);
    }
  }
#line 26
  return;
}
}
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
static size_t utf8_count_newlines(char *str ) 
{ 
  size_t count ;
  struct utf8_iterator itr ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 31
  count = (size_t )0;
#line 33
  utf8_iter_first(& itr, (unsigned char *)str);
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 33
    tmp = utf8_iter_end_p(& itr);
    }
#line 33
    if (tmp) {
#line 33
      goto while_break;
    }
#line 35
    if (itr.curwidth == 1U) {
#line 35
      if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 35
        if ((int )*(itr.curptr) == 10) {
#line 36
          count ++;
        }
      }
    }
    {
#line 33
    utf8_iter_next(& itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (count);
}
}
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
size_t result_count_lines(struct dict_result *res ) 
{ 
  size_t i___0 ;
  size_t count ;

  {
#line 44
  count = (size_t )0;
  {
#line 47
  if ((unsigned int )res->type == 0U) {
#line 47
    goto case_0;
  }
#line 52
  if ((unsigned int )res->type == 1U) {
#line 52
    goto case_1;
  }
#line 56
  if ((unsigned int )res->type == 2U) {
#line 56
    goto case_2;
  }
#line 46
  goto switch_break;
  case_0: /* CIL Label */ 
#line 48
  i___0 = (size_t )0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i___0 < res->count)) {
#line 48
      goto while_break;
    }
#line 49
    count += (res->set.def + i___0)->nlines + 3U;
#line 48
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  goto switch_break;
  case_1: /* CIL Label */ 
#line 53
  count = res->count;
#line 54
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 57
  count = utf8_count_newlines(res->base);
  }
  switch_break: /* CIL Label */ ;
  }
#line 59
  return (count);
}
}
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
static void format_defn(dico_stream_t str , struct define_result *def ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 65
  tmp = gettext("From %s, %s:\n");
#line 65
  stream_printf(str, (char const   *)tmp, def->database, def->descr);
#line 67
  stream_writez(str, def->defn);
#line 68
  dico_stream_write(str, (void const   *)"\n", (size_t )1);
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
static void format_match(dico_stream_t str , struct match_result *mat ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 74
  stream_printf(str, "%s \"%s\"\n", mat->database, mat->word);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
void print_result(struct dict_result *res ) 
{ 
  unsigned long i___0 ;
  dico_stream_t str ;
  size_t tmp ;

  {
  {
#line 83
  tmp = result_count_lines(res);
#line 83
  str = create_pager_stream(tmp);
  }
  {
#line 85
  if ((unsigned int )res->type == 0U) {
#line 85
    goto case_0;
  }
#line 90
  if ((unsigned int )res->type == 1U) {
#line 90
    goto case_1;
  }
#line 95
  if ((unsigned int )res->type == 2U) {
#line 95
    goto case_2;
  }
#line 84
  goto switch_break;
  case_0: /* CIL Label */ 
#line 86
  i___0 = 0UL;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i___0 < (unsigned long )res->count)) {
#line 86
      goto while_break;
    }
    {
#line 87
    format_defn(str, res->set.def + i___0);
#line 86
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  goto switch_break;
  case_1: /* CIL Label */ 
#line 91
  i___0 = 0UL;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i___0 < (unsigned long )res->count)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    format_match(str, res->set.mat + i___0);
#line 91
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 93
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 96
  stream_writez(str, res->base);
  }
#line 97
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 99
  dico_stream_close(str);
#line 100
  dico_stream_destroy(& str);
  }
#line 101
  return;
}
}
#line 111 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
struct result_display *alloc_display(struct dict_result *res , size_t from , size_t to ) 
{ 
  struct result_display *disp ;
  void *tmp ;
  size_t i___0 ;
  void *tmp___0 ;

  {
  {
#line 114
  tmp = xmalloc((size_t )sizeof(*disp));
#line 114
  disp = (struct result_display *)tmp;
#line 117
  disp->next = (struct result_display *)((void *)0);
#line 118
  disp->database = (res->set.mat + from)->database;
#line 119
  disp->count = (int )(to - from);
#line 120
  tmp___0 = xcalloc(to - from, (size_t )sizeof(*(disp->matches + 0)));
#line 120
  disp->matches = (char **)tmp___0;
#line 121
  i___0 = (size_t )0;
  }
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (from < to)) {
#line 121
      goto while_break;
    }
#line 122
    *(disp->matches + i___0) = (res->set.mat + from)->word;
#line 121
    i___0 ++;
#line 121
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (disp);
}
}
#line 126 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
static char *find_descr(struct dict_connection *conn___0 , char const   *name ) 
{ 
  size_t i___0 ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 129
  if (conn___0->db_result) {
#line 132
    i___0 = (size_t )0;
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! (i___0 < (conn___0->db_result)->count)) {
#line 132
        goto while_break;
      }
      {
#line 133
      tmp = strcmp((char const   *)((conn___0->db_result)->set.mat + i___0)->database,
                   name);
      }
#line 133
      if (tmp == 0) {
#line 134
        return (((conn___0->db_result)->set.mat + i___0)->word);
      }
#line 132
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 137
  tmp___0 = gettext("(no description available)");
  }
#line 137
  return (tmp___0);
}
}
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
void print_match_result(struct dict_result *res ) 
{ 
  struct result_display *head ;
  struct result_display *tail ;
  char *dbname ;
  size_t i___0 ;
  size_t j ;
  struct dict_connection *conn___0 ;
  size_t ndb ;
  dico_stream_t str ;
  struct result_display *p ;
  struct result_display *p___0 ;
  struct result_display *tmp ;
  int tmp___0 ;
  struct result_display *p___1 ;
  struct result_display *tmp___1 ;
  size_t tmp___2 ;
  struct result_display *next ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 143
  head = (struct result_display *)((void *)0);
#line 143
  tail = (struct result_display *)((void *)0);
#line 144
  dbname = (char *)((void *)0);
#line 145
  j = (size_t )0;
#line 146
  conn___0 = res->conn;
#line 147
  ndb = (size_t )0;
#line 163
  dbname = (res->set.mat + 0)->database;
#line 164
  i___0 = (size_t )1;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i___0 < res->count)) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp___0 = strcmp((char const   *)(res->set.mat + i___0)->database, (char const   *)dbname);
    }
#line 165
    if (tmp___0) {
      {
#line 166
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 166
        tmp = alloc_display(res, j, i___0);
#line 166
        p___0 = tmp;
        }
#line 166
        if (! tail) {
#line 166
          head = p___0;
        } else {
#line 166
          tail->next = p___0;
        }
#line 166
        tail = p___0;
#line 166
        ndb ++;
#line 166
        j = i___0;
#line 166
        dbname = (res->set.mat + i___0)->database;
#line 166
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 164
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 168
    tmp___1 = alloc_display(res, j, i___0);
#line 168
    p___1 = tmp___1;
    }
#line 168
    if (! tail) {
#line 168
      head = p___1;
    } else {
#line 168
      tail->next = p___1;
    }
#line 168
    tail = p___1;
#line 168
    ndb ++;
#line 168
    j = i___0;
#line 168
    dbname = (res->set.mat + i___0)->database;
#line 168
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 170
  tmp___2 = result_count_lines(res);
#line 170
  str = create_pager_stream(ndb + tmp___2);
#line 171
  j = (size_t )0;
#line 172
  p = head;
  }
  {
#line 172
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 172
    if (! p) {
#line 172
      goto while_break___2;
    }
    {
#line 173
    next = p->next;
#line 175
    tmp___3 = find_descr(conn___0, (char const   *)p->database);
#line 175
    tmp___4 = gettext("From %s, %s:\n");
#line 175
    stream_printf(str, (char const   *)tmp___4, p->database, tmp___3);
#line 177
    i___0 = (size_t )0;
    }
    {
#line 177
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 177
      if (! (i___0 < (size_t )p->count)) {
#line 177
        goto while_break___3;
      }
      {
#line 178
      stream_printf(str, "%4d) \"%s\"\n", j, *(p->matches + i___0));
#line 177
      i___0 ++;
#line 177
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 179
    free((void *)p->matches);
#line 180
    free((void *)p);
#line 181
    p = next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 183
  dico_stream_close(str);
#line 184
  dico_stream_destroy(& str);
  }
#line 185
  return;
}
}
#line 189 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
int dict_lookup(struct dict_connection *conn___0 , dico_url_t url ) 
{ 
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct dict_result *res ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 194
  if (url->req.type == 0) {
#line 194
    goto case_0;
  }
#line 200
  if (url->req.type == 1) {
#line 200
    goto case_1;
  }
#line 207
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 195
  tmp = quotearg_n(1, (char const   *)url->req.word);
#line 195
  tmp___0 = quotearg_n(0, (char const   *)url->req.database);
#line 195
  rc = dict_define(conn___0, tmp___0, tmp);
  }
#line 198
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 201
  tmp___1 = quotearg_n(2, (char const   *)url->req.word);
#line 201
  tmp___2 = quotearg_n(1, (char const   *)url->req.strategy);
#line 201
  tmp___3 = quotearg_n(0, (char const   *)url->req.database);
#line 201
  rc = dict_match(conn___0, tmp___3, tmp___2, tmp___1);
  }
#line 205
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 208
  tmp___4 = gettext("%s:%d: INTERNAL ERROR: unexpected request type");
#line 208
  dico_log(5, 0, (char const   *)tmp___4, "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c",
           210);
  }
  switch_break: /* CIL Label */ ;
  }
#line 213
  if (rc == 0) {
    {
#line 214
    res = conn___0->last_result;
#line 215
    print_result(res);
#line 216
    dict_result_free(res);
    }
  } else {
    {
#line 218
    print_reply(conn___0);
    }
  }
#line 220
  return (0);
}
}
#line 223 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
int dict_lookup_url(dico_url_t url ) 
{ 
  struct dict_connection *conn___0 ;
  char *tmp ;
  int tmp___0 ;
  unsigned int n ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 228
  if (! url->host) {
    {
#line 229
    tmp = gettext("Server name or IP not specified");
#line 229
    dico_log(4, 0, (char const   *)tmp);
    }
#line 230
    return (1);
  }
  {
#line 233
  tmp___0 = dict_connect(& conn___0, url);
  }
#line 233
  if (tmp___0) {
#line 234
    return (1);
  }
  {
#line 236
  dict_lookup(conn___0, url);
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (debug_level >= 1) {
#line 238
      if (debug_source_info) {
        {
#line 238
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 238
          n = 238U;
#line 238
          dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c");
#line 238
          dico_stream_ioctl(debug_stream, 3, (void *)(& n));
          }
#line 238
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 238
      tmp___1 = gettext("Quitting\n");
#line 238
      tmp___2 = strlen((char const   *)tmp___1);
#line 238
      tmp___3 = gettext("Quitting\n");
#line 238
      dico_stream_write(debug_stream, (void const   *)tmp___3, tmp___2);
      }
    }
#line 238
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  stream_printf(conn___0->str, "QUIT\r\n");
#line 240
  dict_read_reply(conn___0);
#line 241
  dict_conn_close(conn___0);
  }
#line 243
  return (0);
}
}
#line 246 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
int dict_word(char *word ) 
{ 
  int rc ;
  dico_url_t url ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 252
  tmp___0 = memcmp((void const   *)word, (void const   *)"dict://", (size_t )7);
  }
#line 252
  if (tmp___0 == 0) {
    {
#line 253
    tmp = dico_url_parse(& url, (char const   *)word);
    }
#line 253
    if (tmp) {
#line 254
      return (1);
    }
    {
#line 255
    rc = dict_lookup_url(url);
#line 256
    dico_url_destroy(& url);
    }
  } else {
    {
#line 258
    dico_url.req.word = word;
#line 259
    rc = dict_lookup_url(& dico_url);
    }
  }
#line 262
  return (rc);
}
}
#line 265 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
void dict_run_single_command(struct dict_connection *conn___0 , char *cmd , char *arg ,
                             char *code ) 
{ 
  struct dict_result *res ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 269
  if (arg) {
    {
#line 270
    stream_printf(conn___0->str, "%s \"%s\"\r\n", cmd, arg);
    }
  } else {
    {
#line 272
    stream_printf(conn___0->str, "%s\r\n", cmd);
    }
  }
  {
#line 274
  dict_read_reply(conn___0);
#line 275
  tmp___1 = dict_status_p(conn___0, code);
  }
#line 275
  if (tmp___1) {
    {
#line 280
    dict_multiline_reply(conn___0);
#line 281
    dict_read_reply(conn___0);
#line 283
    __o1 = & conn___0->stk;
#line 283
    __value = (void *)__o1->object_base;
    }
#line 283
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 283
      __o1->maybe_empty_object = 1U;
    }
#line 283
    if (sizeof(int ) < sizeof(void *)) {
#line 283
      tmp = __o1->object_base;
    } else {
#line 283
      tmp = (char *)0;
    }
#line 283
    if (sizeof(int ) < sizeof(void *)) {
#line 283
      tmp___0 = __o1->object_base;
    } else {
#line 283
      tmp___0 = (char *)0;
    }
#line 283
    __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 283
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 283
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 283
    __o1->object_base = __o1->next_free;
#line 283
    dict_result_create(conn___0, (enum dict_result_type )2, (size_t )1, (char *)__value);
#line 284
    res = conn___0->last_result;
#line 285
    print_result(res);
#line 286
    dict_result_free(res);
    }
  } else {
    {
#line 276
    print_reply(conn___0);
    }
  }
#line 288
  return;
}
}
#line 290 "/home/wslee/benchmarks/textformat/dico-2.0/dico/lookup.c"
int dict_single_command(char *cmd , char *arg , char *code ) 
{ 
  struct dict_connection *conn___0 ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 295
  if (! dico_url.host) {
    {
#line 296
    tmp = gettext("Server name or IP not specified");
#line 296
    dico_log(4, 0, (char const   *)tmp);
    }
#line 297
    return (1);
  }
  {
#line 300
  tmp___0 = dict_connect(& conn___0, & dico_url);
  }
#line 300
  if (tmp___0) {
#line 301
    return (1);
  }
  {
#line 303
  dict_run_single_command(conn___0, cmd, arg, code);
#line 304
  dict_conn_close(conn___0);
  }
#line 305
  return (0);
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 562 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int transcript ;
#line 144
unsigned int levenshtein_threshold ;
#line 145
char *autologin_file ;
#line 151
void dict_transcript(struct dict_connection *conn___0 , int state ) ;
#line 156
int dict_capa(struct dict_connection *conn___0 , char *capa ) ;
#line 168
int ds_tilde_expand(char const   *str , char **output ) ;
#line 207
int ensure_connection(void) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static struct dict_connection *conn  ;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
int set_bool(int *pval , char *str ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 24
  tmp___3 = strcmp((char const   *)str, "yes");
  }
#line 24
  if (tmp___3 == 0) {
#line 27
    *pval = 1;
  } else {
    {
#line 24
    tmp___4 = strcmp((char const   *)str, "on");
    }
#line 24
    if (tmp___4 == 0) {
#line 27
      *pval = 1;
    } else {
      {
#line 24
      tmp___5 = strcmp((char const   *)str, "true");
      }
#line 24
      if (tmp___5 == 0) {
#line 27
        *pval = 1;
      } else {
        {
#line 28
        tmp___0 = strcmp((char const   *)str, "no");
        }
#line 28
        if (tmp___0 == 0) {
#line 31
          *pval = 0;
        } else {
          {
#line 28
          tmp___1 = strcmp((char const   *)str, "off");
          }
#line 28
          if (tmp___1 == 0) {
#line 31
            *pval = 0;
          } else {
            {
#line 28
            tmp___2 = strcmp((char const   *)str, "false");
            }
#line 28
            if (tmp___2 == 0) {
#line 31
              *pval = 0;
            } else {
              {
#line 33
              tmp = gettext("Expected boolean value");
#line 33
              script_error((char const   *)tmp);
              }
#line 34
              return (1);
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_silent_close(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 42
  if (conn) {
    {
#line 43
    stream_printf(conn->str, "QUIT\r\n");
#line 44
    dict_read_reply(conn);
#line 45
    dict_conn_close(conn);
#line 46
    conn = (struct dict_connection *)((void *)0);
    }
  }
#line 48
  return;
}
}
#line 50 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static int get_list(struct dict_result **pres , char *cmd , char *code ) 
{ 
  unsigned long count ;
  char *p ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 53
  if (conn) {
#line 53
    if ((unsigned long )*pres == (unsigned long )((void *)0)) {
      {
#line 54
      stream_printf(conn->str, "%s\r\n", cmd);
#line 55
      dict_read_reply(conn);
#line 56
      tmp___2 = dict_status_p(conn, code);
      }
#line 56
      if (tmp___2) {
        {
#line 60
        count = strtoul((char const   */* __restrict  */)(conn->buf + 3), (char **/* __restrict  */)(& p),
                        10);
#line 61
        dict_multiline_reply(conn);
#line 63
        __o1 = & conn->stk;
#line 63
        __value = (void *)__o1->object_base;
        }
#line 63
        if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 63
          __o1->maybe_empty_object = 1U;
        }
#line 63
        if (sizeof(int ) < sizeof(void *)) {
#line 63
          tmp = __o1->object_base;
        } else {
#line 63
          tmp = (char *)0;
        }
#line 63
        if (sizeof(int ) < sizeof(void *)) {
#line 63
          tmp___0 = __o1->object_base;
        } else {
#line 63
          tmp___0 = (char *)0;
        }
#line 63
        __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 63
        if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 63
          __o1->next_free = __o1->chunk_limit;
        }
        {
#line 63
        __o1->object_base = __o1->next_free;
#line 63
        dict_result_create(conn, (enum dict_result_type )1, (size_t )count, (char *)__value);
#line 64
        dict_read_reply(conn);
#line 65
        *pres = conn->last_result;
        }
      } else {
        {
#line 67
        tmp___1 = gettext("Cannot get listing: %s");
#line 67
        script_error((char const   *)tmp___1, conn->buf);
        }
#line 68
        return (1);
      }
    }
  }
#line 71
  return (0);
}
}
#line 74 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void check_disconnect(void) 
{ 
  int rc ;
  fd_set rd ;
  fd_set wr ;
  fd_set ex ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int *tmp ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 77
  if (conn) {
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
#line 81
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rd.fds_bits[0]): "memory");
#line 81
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 82
    rd.fds_bits[conn->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << conn->fd % (8 * (int )sizeof(__fd_mask ));
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wr.fds_bits[0]): "memory");
#line 83
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 84
    wr.fds_bits[conn->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << conn->fd % (8 * (int )sizeof(__fd_mask ));
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& ex.fds_bits[0]): "memory");
#line 85
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 86
    ex.fds_bits[conn->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << conn->fd % (8 * (int )sizeof(__fd_mask ));
    {
#line 88
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 89
      rc = select(conn->fd + 1, (fd_set */* __restrict  */)(& rd), (fd_set */* __restrict  */)(& wr),
                  (fd_set */* __restrict  */)(& ex), (struct timeval */* __restrict  */)((void *)0));
      }
#line 88
      if (rc == -1) {
        {
#line 88
        tmp = __errno_location();
        }
#line 88
        if (! (*tmp == 4)) {
#line 88
          goto while_break___2;
        }
      } else {
#line 88
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 91
    if (rc < 0) {
      {
#line 92
      dict_conn_close(conn);
#line 93
      conn = (struct dict_connection *)((void *)0);
      }
    } else
#line 91
    if ((rd.fds_bits[conn->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << conn->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 92
      dict_conn_close(conn);
#line 93
      conn = (struct dict_connection *)((void *)0);
      }
    }
  }
#line 96
  return;
}
}
#line 98 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
int ensure_connection(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int n ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  unsigned int n___0 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  unsigned int n___1 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 101
  check_disconnect();
  }
#line 102
  if (! conn) {
#line 103
    if (! dico_url.host) {
      {
#line 104
      tmp = gettext("Please specify server name or IP address");
#line 104
      script_error((char const   *)tmp);
      }
#line 105
      return (1);
    }
    {
#line 108
    tmp___1 = dict_connect(& conn, & dico_url);
    }
#line 108
    if (tmp___1) {
      {
#line 109
      tmp___0 = gettext("Cannot connect to the server");
#line 109
      script_error((char const   *)tmp___0);
      }
#line 110
      return (1);
    }
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 112
      if (debug_level >= 1) {
#line 112
        if (debug_source_info) {
          {
#line 112
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 112
            n = 112U;
#line 112
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c");
#line 112
            dico_stream_ioctl(debug_stream, 3, (void *)(& n));
            }
#line 112
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 112
        tmp___2 = gettext("Getting list of databases\n");
#line 112
        tmp___3 = strlen((char const   *)tmp___2);
#line 112
        tmp___4 = gettext("Getting list of databases\n");
#line 112
        dico_stream_write(debug_stream, (void const   *)tmp___4, tmp___3);
        }
      }
#line 112
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 113
    get_list(& conn->db_result, (char *)"SHOW DATABASES", (char *)"110");
    }
    {
#line 114
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 114
      if (debug_level >= 1) {
#line 114
        if (debug_source_info) {
          {
#line 114
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 114
            n___0 = 114U;
#line 114
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c");
#line 114
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___0));
            }
#line 114
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 114
        tmp___5 = gettext("Getting list of strategies\n");
#line 114
        tmp___6 = strlen((char const   *)tmp___5);
#line 114
        tmp___7 = gettext("Getting list of strategies\n");
#line 114
        dico_stream_write(debug_stream, (void const   *)tmp___7, tmp___6);
        }
      }
#line 114
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 115
    get_list(& conn->strat_result, (char *)"SHOW STRATEGIES", (char *)"111");
    }
    {
#line 116
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 116
      if (debug_level >= 1) {
#line 116
        if (debug_source_info) {
          {
#line 116
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 116
            n___1 = 116U;
#line 116
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c");
#line 116
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___1));
            }
#line 116
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 116
        tmp___8 = gettext("Finished getting server information\n");
#line 116
        tmp___9 = strlen((char const   *)tmp___8);
#line 116
        tmp___10 = gettext("Finished getting server information\n");
#line 116
        dico_stream_write(debug_stream, (void const   *)tmp___10, tmp___9);
        }
      }
#line 116
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 118
  return (0);
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_open(int argc , char **argv ) 
{ 
  int n ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 124
  if (argc > 1) {
#line 125
    if (argc == 3) {
      {
#line 126
      tmp = str2port(*(argv + 2));
#line 126
      n = tmp;
      }
#line 127
      if (n == -1) {
        {
#line 128
        tmp___0 = gettext("Invalid port number or service name");
#line 128
        script_error((char const   *)tmp___0);
        }
#line 129
        return;
      }
#line 131
      dico_url.port = n;
    }
    {
#line 133
    xdico_assign_string(& dico_url.host, *(argv + 1));
    }
  }
#line 136
  if (! dico_url.host) {
    {
#line 137
    tmp___1 = gettext("Please specify server name or IP address");
#line 137
    script_error((char const   *)tmp___1);
    }
#line 138
    return;
  }
  {
#line 141
  ds_silent_close();
#line 142
  ensure_connection();
  }
#line 143
  return;
}
}
#line 145 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_close(int argc , char **argv ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 148
  if (! conn) {
    {
#line 149
    tmp = gettext("Nothing to close");
#line 149
    script_error((char const   *)tmp);
    }
  } else {
    {
#line 151
    ds_silent_close();
    }
  }
#line 152
  return;
}
}
#line 154 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_autologin(int argc , char **argv ) 
{ 
  char *tmp ;
  char *str ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 157
  if (argc == 1) {
#line 158
    if (! autologin_file) {
      {
#line 159
      tmp = gettext("No autologin file.");
#line 159
      printf((char const   */* __restrict  */)"%s\n", tmp);
      }
    } else {
      {
#line 161
      printf((char const   */* __restrict  */)"%s\n", autologin_file);
      }
    }
  } else {
    {
#line 164
    tmp___0 = ds_tilde_expand((char const   *)*(argv + 1), & str);
    }
#line 164
    if (tmp___0) {
      {
#line 165
      free((void *)autologin_file);
#line 166
      autologin_file = str;
      }
    } else {
      {
#line 168
      xdico_assign_string(& autologin_file, *(argv + 1));
      }
    }
  }
#line 170
  return;
}
}
#line 172 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_sasl(int argc , char **argv ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int val ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 175
  if (argc == 1) {
    {
#line 176
    tmp___3 = sasl_enabled_p();
    }
#line 176
    if (tmp___3) {
      {
#line 176
      tmp___0 = gettext("on");
#line 176
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 176
      tmp___1 = gettext("off");
#line 176
      tmp___2 = tmp___1;
      }
    }
    {
#line 176
    printf((char const   */* __restrict  */)"%s\n", tmp___2);
    }
  } else {
    {
#line 179
    tmp___4 = set_bool(& val, *(argv + 1));
    }
#line 179
    if (tmp___4 == 0) {
      {
#line 180
      sasl_enable(val);
      }
    }
  }
#line 182
  return;
}
}
#line 184 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_database(int argc , char **argv ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 187
  if (argc == 1) {
#line 188
    if (dico_url.req.database) {
#line 188
      tmp = (char const   *)dico_url.req.database;
    } else {
#line 188
      tmp = "!";
    }
    {
#line 188
    printf((char const   */* __restrict  */)"%s\n", tmp);
    }
  } else {
    {
#line 191
    xdico_assign_string(& dico_url.req.database, *(argv + 1));
    }
  }
#line 192
  return;
}
}
#line 197 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static int i  ;
#line 197 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static int len  ;
#line 194 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static char *result_generator(struct dict_result *res , char const   *text , int state ) 
{ 
  size_t tmp ;
  char *s ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 199
  if (! state) {
    {
#line 200
    i = 0;
#line 201
    tmp = strlen(text);
#line 201
    len = (int )tmp;
    }
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((size_t )i < res->count)) {
#line 203
      goto while_break;
    }
    {
#line 204
    s = (res->set.mat + i)->database;
#line 205
    i ++;
#line 206
    tmp___1 = strncmp((char const   *)s, text, (size_t )len);
    }
#line 206
    if (tmp___1 == 0) {
      {
#line 207
      tmp___0 = strdup((char const   *)s);
      }
#line 207
      return (tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return ((char *)((void *)0));
}
}
#line 212 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static char *db_generator(char const   *text , int state ) 
{ 
  char *tmp ;

  {
  {
#line 215
  tmp = result_generator(conn->db_result, text, state);
  }
#line 215
  return (tmp);
}
}
#line 218 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
char **ds_compl_database(int argc , char **argv , int ws ) 
{ 
  char **tmp ;

  {
  {
#line 221
  tmp = dict_completion_matches(argc, argv, ws, & db_generator);
  }
#line 221
  return (tmp);
}
}
#line 225 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_strategy(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;

  {
#line 228
  if (argc == 1) {
    {
#line 229
    printf((char const   */* __restrict  */)"%s\n", dico_url.req.strategy);
    }
  } else {
    {
#line 232
    xdico_assign_string(& dico_url.req.strategy, *(argv + 1));
    }
  }
#line 233
  return;
}
}
#line 235 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static char *strat_generator(char const   *text , int state ) 
{ 
  char *tmp ;

  {
  {
#line 238
  tmp = result_generator(conn->strat_result, text, state);
  }
#line 238
  return (tmp);
}
}
#line 241 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
char **ds_compl_strategy(int argc , char **argv , int ws ) 
{ 
  char **tmp ;

  {
  {
#line 244
  tmp = dict_completion_matches(argc, argv, ws, & strat_generator);
  }
#line 244
  return (tmp);
}
}
#line 248 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_verbose(int argc , char **argv ) 
{ 
  char *p ;
  int n ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 251
  if (argc == 1) {
    {
#line 252
    printf((char const   */* __restrict  */)"%d\n", debug_level);
    }
  } else {
    {
#line 255
    tmp = strtoul((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)(& p),
                  10);
#line 255
    n = (int )tmp;
    }
#line 256
    if (*p) {
      {
#line 257
      tmp___0 = gettext("invalid number");
#line 257
      script_error((char const   *)tmp___0);
      }
    } else {
#line 259
      debug_level = n;
    }
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_transcript(int argc , char **argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 266
  if (argc == 1) {
#line 267
    if (transcript) {
      {
#line 267
      tmp = gettext("on");
#line 267
      tmp___1 = tmp;
      }
    } else {
      {
#line 267
      tmp___0 = gettext("off");
#line 267
      tmp___1 = tmp___0;
      }
    }
    {
#line 267
    tmp___2 = gettext("transcript is %s\n");
#line 267
    printf((char const   */* __restrict  */)tmp___2, tmp___1);
    }
  } else {
    {
#line 269
    set_bool(& transcript, *(argv + 1));
    }
#line 270
    if (conn) {
      {
#line 271
      dict_transcript(conn, transcript);
      }
    }
  }
#line 273
  return;
}
}
#line 275 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_define(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 278
  tmp = ensure_connection();
  }
#line 278
  if (tmp) {
#line 279
    return;
  }
  {
#line 280
  dico_url.req.type = 0;
#line 281
  xdico_assign_string(& dico_url.req.word, *(argv + 1));
#line 282
  dict_lookup(conn, & dico_url);
  }
#line 283
  return;
}
}
#line 285 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_match(int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 290
  tmp = ensure_connection();
  }
#line 290
  if (tmp) {
#line 291
    return;
  }
#line 292
  if (argc == 2) {
#line 292
    if (*(*(argv + 1) + 0)) {
      {
#line 293
      dict_result_free(conn->match_result);
#line 294
      conn->match_result = (struct dict_result *)((void *)0);
#line 295
      dico_url.req.type = 1;
#line 296
      xdico_assign_string(& dico_url.req.word, *(argv + 1));
#line 297
      tmp___0 = quotearg_n(2, (char const   *)dico_url.req.word);
#line 297
      tmp___1 = quotearg_n(1, (char const   *)dico_url.req.strategy);
#line 297
      tmp___2 = quotearg_n(0, (char const   *)dico_url.req.database);
#line 297
      rc = dict_match(conn, tmp___2, tmp___1, tmp___0);
      }
#line 301
      if (rc == 0) {
#line 302
        conn->match_result = conn->last_result;
      } else {
        {
#line 304
        print_reply(conn);
        }
#line 305
        return;
      }
    } else {
#line 292
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 307
  if (! conn->match_result) {
    {
#line 308
    tmp___3 = gettext("No previous match");
#line 308
    script_error((char const   *)tmp___3);
    }
#line 309
    return;
  }
  {
#line 312
  print_match_result(conn->match_result);
  }
#line 313
  return;
}
}
#line 316 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_define_nth(size_t num ) 
{ 
  struct dico_url url ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 319
  url = dico_url;
#line 321
  tmp = ensure_connection();
  }
#line 321
  if (tmp) {
#line 322
    return;
  }
#line 323
  if (! conn->match_result) {
    {
#line 324
    tmp___0 = gettext("No previous match");
#line 324
    script_error((char const   *)tmp___0);
    }
#line 325
    return;
  }
#line 327
  if (num >= (conn->match_result)->count) {
    {
#line 328
    tmp___1 = gettext("Invalid match number.  Type / to see the matches.");
#line 328
    script_error((char const   *)tmp___1);
    }
#line 329
    return;
  }
  {
#line 331
  url.req.type = 0;
#line 332
  url.req.database = ((conn->match_result)->set.mat + num)->database;
#line 333
  url.req.word = ((conn->match_result)->set.mat + num)->word;
#line 334
  dict_lookup(conn, & url);
  }
#line 335
  return;
}
}
#line 337 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_distance(int argc , char **argv ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *p ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 340
  if (argc == 1) {
#line 341
    if (conn) {
      {
#line 342
      tmp___0 = dict_capa(conn, (char *)"xlev");
      }
#line 342
      if (! tmp___0) {
        {
#line 343
        tmp = gettext("Server does not support XLEV extension");
#line 343
        printf((char const   */* __restrict  */)tmp);
        }
#line 344
        return;
      }
      {
#line 346
      stream_printf(conn->str, "XLEV TELL\r\n");
#line 347
      dict_read_reply(conn);
#line 348
      tmp___3 = dict_status_p(conn, (char *)"280");
      }
#line 348
      if (tmp___3) {
        {
#line 349
        tmp___1 = gettext("Reported Levenshtein distance:%s\n");
#line 349
        printf((char const   */* __restrict  */)tmp___1, conn->buf + 3);
        }
      } else {
        {
#line 351
        tmp___2 = gettext("Cannot query Levenshtein distance.  Server responded:");
#line 351
        printf((char const   */* __restrict  */)"%s\n", tmp___2);
#line 353
        printf((char const   */* __restrict  */)"%s\n", conn->buf);
        }
      }
    }
#line 356
    if (levenshtein_threshold == 0U) {
      {
#line 357
      tmp___4 = gettext("No distance configured\n");
#line 357
      printf((char const   */* __restrict  */)tmp___4);
      }
    } else {
      {
#line 359
      tmp___5 = gettext("Configured Levenshtein distance: %u\n");
#line 359
      printf((char const   */* __restrict  */)tmp___5, levenshtein_threshold);
      }
    }
  } else {
    {
#line 363
    tmp___6 = strtoul((char const   */* __restrict  */)*(argv + 1), (char **/* __restrict  */)(& p),
                      10);
#line 363
    levenshtein_threshold = (unsigned int )tmp___6;
    }
#line 364
    if (*p) {
      {
#line 365
      tmp___7 = gettext("invalid number");
#line 365
      script_error((char const   *)tmp___7);
      }
    }
  }
#line 367
  return;
}
}
#line 369 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_show_db(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = ensure_connection();
  }
#line 372
  if (tmp) {
#line 373
    return;
  }
  {
#line 374
  print_result(conn->db_result);
  }
#line 375
  return;
}
}
#line 377 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_show_strat(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 380
  tmp = ensure_connection();
  }
#line 380
  if (tmp) {
#line 381
    return;
  }
  {
#line 382
  print_result(conn->strat_result);
  }
#line 383
  return;
}
}
#line 385 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_show_info(int argc , char **argv ) 
{ 
  char const   *dbname ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 389
  if (argc == 1) {
#line 390
    if (dico_url.req.database) {
#line 390
      dbname = (char const   *)dico_url.req.database;
    } else {
#line 390
      dbname = "!";
    }
  } else {
#line 392
    dbname = (char const   *)*(argv + 1);
  }
  {
#line 393
  tmp___3 = strcmp(dbname, "!");
  }
#line 393
  if (tmp___3 == 0) {
    {
#line 394
    tmp = gettext("Search all of the databases until a match is found,\nand display all matches in that database.\n");
#line 394
    printf((char const   */* __restrict  */)tmp);
    }
  } else {
    {
#line 396
    tmp___2 = strcmp(dbname, "*");
    }
#line 396
    if (tmp___2 == 0) {
      {
#line 397
      tmp___0 = gettext("Search all of the databases and display all matches.");
#line 397
      printf((char const   */* __restrict  */)tmp___0);
      }
    } else {
      {
#line 399
      tmp___1 = ensure_connection();
      }
#line 399
      if (tmp___1) {
#line 400
        return;
      }
      {
#line 401
      dict_run_single_command(conn, (char *)"SHOW INFO", (char *)dbname, (char *)"112");
      }
    }
  }
#line 403
  return;
}
}
#line 405 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_version(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 408
  printf((char const   */* __restrict  */)"%s\n", "GNU dico 2.0");
  }
#line 409
  return;
}
}
#line 411 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
static char gplv3_text[616]  = 
#line 411
  {      (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'N',      (char )'U',      (char )' ',      (char )'D', 
        (char )'i',      (char )'c',      (char )'o',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'f', 
        (char )'r',      (char )'e',      (char )'e',      (char )' ', 
        (char )'s',      (char )'o',      (char )'f',      (char )'t', 
        (char )'w',      (char )'a',      (char )'r',      (char )'e', 
        (char )';',      (char )' ',      (char )'y',      (char )'o', 
        (char )'u',      (char )' ',      (char )'c',      (char )'a', 
        (char )'n',      (char )' ',      (char )'r',      (char )'e', 
        (char )'d',      (char )'i',      (char )'s',      (char )'t', 
        (char )'r',      (char )'i',      (char )'b',      (char )'u', 
        (char )'t',      (char )'e',      (char )' ',      (char )'i', 
        (char )'t',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )'/',      (char )'o',      (char )'r', 
        (char )' ',      (char )'m',      (char )'o',      (char )'d', 
        (char )'i',      (char )'f',      (char )'y',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'i', 
        (char )'t',      (char )' ',      (char )'u',      (char )'n', 
        (char )'d',      (char )'e',      (char )'r',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'t',      (char )'e',      (char )'r',      (char )'m', 
        (char )'s',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'G',      (char )'N',      (char )'U', 
        (char )' ',      (char )'G',      (char )'e',      (char )'n', 
        (char )'e',      (char )'r',      (char )'a',      (char )'l', 
        (char )' ',      (char )'P',      (char )'u',      (char )'b', 
        (char )'l',      (char )'i',      (char )'c',      (char )' ', 
        (char )'L',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'p', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'s',      (char )'h',      (char )'e',      (char )'d', 
        (char )' ',      (char )'b',      (char )'y',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'F', 
        (char )'r',      (char )'e',      (char )'e',      (char )' ', 
        (char )'S',      (char )'o',      (char )'f',      (char )'t', 
        (char )'w',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'F',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'a',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )';', 
        (char )' ',      (char )'e',      (char )'i',      (char )'t', 
        (char )'h',      (char )'e',      (char )'r',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'3',      (char )',',      (char )' ',      (char )'o', 
        (char )'r',      (char )' ',      (char )'(',      (char )'a', 
        (char )'t',      (char )' ',      (char )'y',      (char )'o', 
        (char )'u',      (char )'r',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )')',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'a',      (char )'n', 
        (char )'y',      (char )' ',      (char )'l',      (char )'a', 
        (char )'t',      (char )'e',      (char )'r',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )'.', 
        (char )'\n',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'G',      (char )'N',      (char )'U', 
        (char )' ',      (char )'D',      (char )'i',      (char )'c', 
        (char )'o',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'d',      (char )'i',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'b', 
        (char )'u',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'h',      (char )'o',      (char )'p',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'a', 
        (char )'t',      (char )' ',      (char )'i',      (char )'t', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )'f',      (char )'u',      (char )'l',      (char )',', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'b',      (char )'u',      (char )'t',      (char )' ', 
        (char )'W',      (char )'I',      (char )'T',      (char )'H', 
        (char )'O',      (char )'U',      (char )'T',      (char )' ', 
        (char )'A',      (char )'N',      (char )'Y',      (char )' ', 
        (char )'W',      (char )'A',      (char )'R',      (char )'R', 
        (char )'A',      (char )'N',      (char )'T',      (char )'Y', 
        (char )';',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )'o',      (char )'u', 
        (char )'t',      (char )' ',      (char )'e',      (char )'v', 
        (char )'e',      (char )'n',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'i', 
        (char )'m',      (char )'p',      (char )'l',      (char )'i', 
        (char )'e',      (char )'d',      (char )' ',      (char )'w', 
        (char )'a',      (char )'r',      (char )'r',      (char )'a', 
        (char )'n',      (char )'t',      (char )'y',      (char )' ', 
        (char )'o',      (char )'f',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'M',      (char )'E', 
        (char )'R',      (char )'C',      (char )'H',      (char )'A', 
        (char )'N',      (char )'T',      (char )'A',      (char )'B', 
        (char )'I',      (char )'L',      (char )'I',      (char )'T', 
        (char )'Y',      (char )' ',      (char )'o',      (char )'r', 
        (char )' ',      (char )'F',      (char )'I',      (char )'T', 
        (char )'N',      (char )'E',      (char )'S',      (char )'S', 
        (char )' ',      (char )'F',      (char )'O',      (char )'R', 
        (char )' ',      (char )'A',      (char )' ',      (char )'P', 
        (char )'A',      (char )'R',      (char )'T',      (char )'I', 
        (char )'C',      (char )'U',      (char )'L',      (char )'A', 
        (char )'R',      (char )' ',      (char )'P',      (char )'U', 
        (char )'R',      (char )'P',      (char )'O',      (char )'S', 
        (char )'E',      (char )'.',      (char )' ',      (char )' ', 
        (char )'S',      (char )'e',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'G', 
        (char )'N',      (char )'U',      (char )' ',      (char )'G', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'l',      (char )' ',      (char )'P', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'c',      (char )' ',      (char )'L',      (char )'i', 
        (char )'c',      (char )'e',      (char )'n',      (char )'s', 
        (char )'e',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'m',      (char )'o', 
        (char )'r',      (char )'e',      (char )' ',      (char )'d', 
        (char )'e',      (char )'t',      (char )'a',      (char )'i', 
        (char )'l',      (char )'s',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'Y',      (char )'o',      (char )'u',      (char )' ', 
        (char )'s',      (char )'h',      (char )'o',      (char )'u', 
        (char )'l',      (char )'d',      (char )' ',      (char )'h', 
        (char )'a',      (char )'v',      (char )'e',      (char )' ', 
        (char )'r',      (char )'e',      (char )'c',      (char )'e', 
        (char )'i',      (char )'v',      (char )'e',      (char )'d', 
        (char )' ',      (char )'a',      (char )' ',      (char )'c', 
        (char )'o',      (char )'p',      (char )'y',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'G', 
        (char )'N',      (char )'U',      (char )' ',      (char )'G', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'l',      (char )' ',      (char )'P', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'c',      (char )' ',      (char )'L',      (char )'i', 
        (char )'c',      (char )'e',      (char )'n',      (char )'s', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'a',      (char )'l',      (char )'o', 
        (char )'n',      (char )'g',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'G',      (char )'N',      (char )'U',      (char )' ', 
        (char )'D',      (char )'i',      (char )'c',      (char )'o', 
        (char )'.',      (char )' ',      (char )' ',      (char )'I', 
        (char )'f',      (char )' ',      (char )'n',      (char )'o', 
        (char )'t',      (char )',',      (char )' ',      (char )'s', 
        (char )'e',      (char )'e',      (char )' ',      (char )'<', 
        (char )'h',      (char )'t',      (char )'t',      (char )'p', 
        (char )':',      (char )'/',      (char )'/',      (char )'w', 
        (char )'w',      (char )'w',      (char )'.',      (char )'g', 
        (char )'n',      (char )'u',      (char )'.',      (char )'o', 
        (char )'r',      (char )'g',      (char )'/',      (char )'l', 
        (char )'i',      (char )'c',      (char )'e',      (char )'n', 
        (char )'s',      (char )'e',      (char )'s',      (char )'/', 
        (char )'>',      (char )'.',      (char )'\n',      (char )'\000'};
#line 428
void print_version_only(char const   *program_version___0 , FILE *stream ) ;
#line 425 "/home/wslee/benchmarks/textformat/dico-2.0/dico/func.c"
void ds_warranty(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 428
  print_version_only("GNU dico 2.0", stdout);
#line 429
  putchar('\n');
#line 430
  printf((char const   */* __restrict  */)"%s", gplv3_text);
  }
#line 431
  return;
}
}
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 104 "../include/xdico.h"
int debug_level  ;
#line 105 "../include/xdico.h"
int debug_source_info  ;
#line 106 "../include/xdico.h"
dico_stream_t debug_stream  ;
#line 137 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct dico_url dico_url  ;
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
struct auth_cred default_cred  ;
#line 139
char *client ;
#line 140
enum dico_client_mode mode ;
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int transcript  ;
#line 142
IPADDR source_addr ;
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int noauth_option  ;
#line 144 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
unsigned int levenshtein_threshold  ;
#line 145 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
char *autologin_file  ;
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int quiet_option  ;
#line 148
void get_options(int argc , char **argv , int *index___0 ) ;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico.c"
char *client  =    (char *)"GNU dico 2.0";
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico.c"
enum dico_client_mode mode  =    (enum dico_client_mode )0;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico.c"
IPADDR source_addr  =    (IPADDR )((in_addr_t )0);
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico.c"
void fixup_url(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 38
  xdico_assign_string(& dico_url.proto, (char *)"dict");
  }
#line 39
  if (! dico_url.host) {
    {
#line 40
    xdico_assign_string(& dico_url.host, (char *)"gnu.org.ua");
    }
  }
#line 41
  if (! dico_url.req.database) {
    {
#line 42
    xdico_assign_string(& dico_url.req.database, (char *)"!");
    }
  }
#line 43
  if (! dico_url.req.strategy) {
    {
#line 44
    xdico_assign_string(& dico_url.req.strategy, (char *)".");
    }
  }
#line 45
  if ((unsigned int )mode == 1U) {
#line 46
    dico_url.req.type = 1;
  }
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico.c"
int main(int argc , char **argv ) 
{ 
  int index___0 ;
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 52
  rc = 0;
#line 54
  appi18n_init();
#line 55
  dico_set_program_name(*(argv + 0));
#line 56
  debug_stream = dico_dbg_stream_create();
#line 57
  parse_init_scripts();
#line 58
  get_options(argc, argv, & index___0);
#line 59
  fixup_url();
#line 60
  set_quoting_style((struct quoting_options *)((void *)0), (enum quoting_style )5);
#line 61
  signal(13, (void (*)(int  ))1);
#line 63
  argc -= index___0;
#line 64
  argv += index___0;
  }
  {
#line 68
  if ((unsigned int )mode == 1U) {
#line 68
    goto case_1;
  }
#line 68
  if ((unsigned int )mode == 0U) {
#line 68
    goto case_1;
  }
#line 75
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 69
  if (! argc) {
    {
#line 70
    dico_shell();
#line 71
    exit(0);
    }
  }
#line 73
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 76
  if (argc) {
    {
#line 77
    tmp = gettext("extra command line arguments ignored");
#line 77
    dico_log(3, 0, (char const   *)tmp);
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 83
  if ((unsigned int )mode == 1U) {
#line 83
    goto case_1___0;
  }
#line 83
  if ((unsigned int )mode == 0U) {
#line 83
    goto case_1___0;
  }
#line 91
  if ((unsigned int )mode == 2U) {
#line 91
    goto case_2;
  }
#line 95
  if ((unsigned int )mode == 3U) {
#line 95
    goto case_3;
  }
#line 99
  if ((unsigned int )mode == 4U) {
#line 99
    goto case_4;
  }
#line 103
  if ((unsigned int )mode == 5U) {
#line 103
    goto case_5;
  }
#line 109
  if ((unsigned int )mode == 6U) {
#line 109
    goto case_6;
  }
#line 81
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
#line 84
  if (! argc) {
    {
#line 85
    tmp___0 = gettext("you should give a word to look for or an URL");
#line 85
    dico_die(1, 4, 0, (char const   *)tmp___0);
    }
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    tmp___3 = argc;
#line 87
    argc --;
#line 87
    if (! tmp___3) {
#line 87
      goto while_break;
    }
    {
#line 88
    tmp___1 = *argv;
#line 88
    (*argv) ++;
#line 88
    tmp___2 = dict_word(tmp___1);
#line 88
    rc |= tmp___2 != 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 92
  rc = dict_single_command((char *)"SHOW DATABASES", (char *)((void *)0), (char *)"110");
  }
#line 93
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 96
  rc = dict_single_command((char *)"SHOW STRATEGIES", (char *)((void *)0), (char *)"111");
  }
#line 97
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 100
  rc = dict_single_command((char *)"HELP", (char *)((void *)0), (char *)"113");
  }
#line 101
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 104
  if (! dico_url.req.database) {
    {
#line 105
    tmp___4 = gettext("Database name not specified");
#line 105
    dico_die(1, 4, 0, (char const   *)tmp___4);
    }
  }
  {
#line 106
  rc = dict_single_command((char *)"SHOW INFO", dico_url.req.database, (char *)"112");
  }
#line 107
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 110
  rc = dict_single_command((char *)"SHOW SERVER", (char *)((void *)0), (char *)"114");
  }
#line 111
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 114
  return (rc);
}
}
#line 286 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 346
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 370 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 62 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 174 "/home/wslee/benchmarks/textformat/dico-2.0/dico/dico-priv.h"
int auth_cred_get(char *host , struct auth_cred *cred ) ;
#line 175
void auth_cred_free(struct auth_cred *cred ) ;
#line 194
int parse_autologin(char const   *filename___0 , char *host , struct auth_cred *pcred ,
                    int *pflags ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
char const   *xscript_prefix[2]  = {      "S:",      "C:"};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static int parse_initial_reply(struct dict_connection *conn___0 ) 
{ 
  char *p ;
  size_t n ;
  size_t len___0 ;
  int tmp ;
  char *s ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 29
  n = (size_t )0;
#line 32
  tmp = dict_status_p(conn___0, (char *)"220");
  }
#line 32
  if (! tmp) {
#line 33
    return (1);
  }
  {
#line 34
  p = strchr((char const   *)conn___0->buf, '<');
  }
#line 35
  if (! p) {
#line 36
    return (1);
  }
#line 37
  p ++;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    len___0 = strcspn((char const   *)p, ".>");
    }
#line 39
    if (! len___0) {
#line 39
      goto while_break;
    }
#line 41
    if ((size_t )conn___0->capac == n) {
#line 42
      if (n == 0U) {
#line 43
        n = (size_t )2;
      }
      {
#line 44
      tmp___0 = x2nrealloc((void *)conn___0->capav, & n, (size_t )sizeof(*(conn___0->capav + 0)));
#line 44
      conn___0->capav = (char **)tmp___0;
      }
    }
    {
#line 47
    tmp___1 = xmalloc(len___0 + 1U);
#line 47
    s = (char *)tmp___1;
#line 48
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)p, len___0);
#line 49
    *(s + len___0) = (char)0;
#line 50
    tmp___2 = conn___0->capac;
#line 50
    (conn___0->capac) ++;
#line 50
    *(conn___0->capav + tmp___2) = s;
#line 51
    p += len___0 + 1U;
    }
#line 52
    if ((int )*(p + -1) == 62) {
#line 53
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  p = strchr((char const   *)p, '<');
  }
#line 57
  if (! p) {
#line 58
    return (1);
  }
  {
#line 59
  len___0 = strcspn((char const   *)p, ">");
  }
#line 60
  if ((int )*(p + len___0) != 62) {
#line 61
    return (1);
  }
  {
#line 62
  len___0 ++;
#line 63
  tmp___3 = xmalloc(len___0 + 1U);
#line 63
  conn___0->msgid = (char *)tmp___3;
#line 64
  memcpy((void */* __restrict  */)conn___0->msgid, (void const   */* __restrict  */)p,
         len___0);
#line 65
  *(conn___0->msgid + len___0) = (char)0;
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static int apop_auth(struct dict_connection *conn___0 , struct auth_cred *cred ) 
{ 
  int i___0 ;
  struct md5_ctx md5context ;
  unsigned char md5digest[16] ;
  char buf___1[sizeof(md5digest) * 2UL + 1UL] ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 79
  md5_init_ctx(& md5context);
#line 80
  tmp = strlen((char const   *)conn___0->msgid);
#line 80
  md5_process_bytes((void const   *)conn___0->msgid, tmp, & md5context);
#line 81
  tmp___0 = strlen((char const   *)cred->pass);
#line 81
  md5_process_bytes((void const   *)cred->pass, tmp___0, & md5context);
#line 82
  md5_finish_ctx(& md5context, (void *)(md5digest));
#line 84
  i___0 = 0;
#line 84
  p = buf___1;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i___0 < 16)) {
#line 84
      goto while_break;
    }
    {
#line 85
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02x", (int )md5digest[i___0]);
#line 84
    i___0 ++;
#line 84
    p += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  *p = (char)0;
#line 87
  stream_printf(conn___0->str, "AUTH %s %s\r\n", cred->user, buf___1);
#line 88
  tmp___2 = dict_read_reply(conn___0);
  }
#line 88
  if (tmp___2) {
    {
#line 89
    tmp___1 = gettext("No reply from server");
#line 89
    dico_log(4, 0, (char const   *)tmp___1);
    }
#line 90
    return (1);
  }
  {
#line 92
  tmp___3 = dict_status_p(conn___0, (char *)"230");
  }
#line 92
  return (tmp___3 == 0);
}
}
#line 95 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static int dict_auth(struct dict_connection *conn___0 , dico_url_t url ) 
{ 
  int rc ;
  int tmp ;
  struct auth_cred cred ;
  int tmp___0 ;
  unsigned int n ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned int n___0 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 98
  tmp = saslauth(conn___0, url);
#line 98
  rc = tmp;
  }
  {
#line 101
  if (rc == 0) {
#line 101
    goto case_0;
  }
#line 104
  if (rc == 2) {
#line 104
    goto case_2;
  }
#line 127
  if (rc == 1) {
#line 127
    goto case_1___0;
  }
#line 100
  goto switch_break;
  case_0: /* CIL Label */ 
#line 102
  return (0);
  case_2: /* CIL Label */ 
  {
#line 105
  tmp___8 = dict_capa(conn___0, (char *)"auth");
  }
#line 105
  if (tmp___8) {
    {
#line 108
    tmp___0 = auth_cred_get(url->host, & cred);
    }
    {
#line 109
    if (tmp___0 == 0) {
#line 109
      goto case_0___0;
    }
#line 115
    if (tmp___0 == 1) {
#line 115
      goto case_1;
    }
#line 120
    if (tmp___0 == 2) {
#line 120
      goto case_2___0;
    }
#line 108
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 110
      if (debug_level >= 1) {
#line 110
        if (debug_source_info) {
          {
#line 110
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 110
            n = 110U;
#line 110
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 110
            dico_stream_ioctl(debug_stream, 3, (void *)(& n));
            }
#line 110
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 110
        tmp___1 = gettext("Attempting APOP authentication\n");
#line 110
        tmp___2 = strlen((char const   *)tmp___1);
#line 110
        tmp___3 = gettext("Attempting APOP authentication\n");
#line 110
        dico_stream_write(debug_stream, (void const   *)tmp___3, tmp___2);
        }
      }
#line 110
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 111
    rc = apop_auth(conn___0, & cred);
#line 112
    auth_cred_free(& cred);
    }
#line 113
    return (rc);
    case_1: /* CIL Label */ 
    {
#line 116
    tmp___4 = gettext("Not enough credentials for authentication");
#line 116
    dico_log(3, 0, (char const   *)tmp___4);
    }
#line 118
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 121
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 121
      if (debug_level >= 1) {
#line 121
        if (debug_source_info) {
          {
#line 121
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 121
            n___0 = 121U;
#line 121
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 121
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___0));
            }
#line 121
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 121
        tmp___5 = gettext("Skipping authenitcation\n");
#line 121
        tmp___6 = strlen((char const   *)tmp___5);
#line 121
        tmp___7 = gettext("Skipping authenitcation\n");
#line 121
        dico_stream_write(debug_stream, (void const   *)tmp___7, tmp___6);
        }
      }
#line 121
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 122
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 125
  return (0);
  case_1___0: /* CIL Label */ 
#line 128
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 130
  return (0);
}
}
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
char *get_homedir(void) 
{ 
  char *homedir ;
  char *tmp ;
  struct passwd *pw ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 135
  tmp = getenv("HOME");
#line 135
  homedir = tmp;
  }
#line 136
  if (! homedir) {
    {
#line 137
    tmp___0 = geteuid();
#line 137
    tmp___1 = getpwuid(tmp___0);
#line 137
    pw = tmp___1;
#line 138
    homedir = pw->pw_dir;
    }
  }
#line 140
  return (homedir);
}
}
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int ds_tilde_expand(char const   *str , char **output ) 
{ 
  char *dir ;
  char *p ;
  size_t len___0 ;
  char *name ;
  struct passwd *pw ;
  void *tmp ;

  {
#line 148
  if ((int const   )*(str + 0) != 126) {
#line 149
    return (0);
  }
#line 150
  if ((int const   )*(str + 1) == 47) {
    {
#line 151
    dir = get_homedir();
#line 152
    str += 2;
    }
  } else {
    {
#line 159
    str ++;
#line 160
    p = strchr(str, '/');
    }
#line 161
    if (! p) {
#line 162
      return (0);
    }
    {
#line 163
    len___0 = (size_t )(p - (char *)str);
#line 164
    tmp = xmalloc(len___0 + 1U);
#line 164
    name = (char *)tmp;
#line 165
    memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)str, len___0);
#line 166
    *(name + len___0) = (char)0;
#line 167
    pw = getpwnam((char const   *)name);
#line 168
    free((void *)name);
    }
#line 169
    if (pw) {
#line 170
      dir = pw->pw_dir;
#line 171
      str = (char const   *)(p + 1);
    }
  }
  {
#line 174
  *output = dico_full_file_name((char const   *)dir, str);
  }
#line 175
  return (1);
}
}
#line 178 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static void auth_cred_dup(struct auth_cred *dst , struct auth_cred  const  *src ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 181
  if (src->user) {
    {
#line 181
    tmp = xstrdup((char const   *)src->user);
#line 181
    dst->user = tmp;
    }
  } else {
#line 181
    dst->user = (char *)((void *)0);
  }
#line 182
  if (src->pass) {
    {
#line 182
    tmp___0 = xstrdup((char const   *)src->pass);
#line 182
    dst->pass = tmp___0;
    }
  } else {
#line 182
    dst->pass = (char *)((void *)0);
  }
#line 183
  return;
}
}
#line 185 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
void auth_cred_free(struct auth_cred *cred ) 
{ 


  {
  {
#line 188
  free((void *)cred->user);
#line 189
  free((void *)cred->pass);
#line 190
  dico_list_destroy(& cred->mech);
#line 191
  free((void *)cred->service);
#line 192
  free((void *)cred->realm);
#line 193
  free((void *)cred->hostname);
  }
#line 194
  return;
}
}
#line 196 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int auth_cred_get(char *host , struct auth_cred *cred ) 
{ 
  unsigned int n ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int flags ;
  char *tmp___2 ;
  int tmp___3 ;
  char *home ;
  char *tmp___4 ;
  char *filename___0 ;
  char *tmp___5 ;
  char *p ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 199
  memset((void *)cred, 0, (size_t )sizeof(*(cred + 0)));
#line 200
  auth_cred_dup(cred, (struct auth_cred  const  *)(& default_cred));
  }
#line 201
  if (default_cred.user) {
#line 201
    if (default_cred.pass) {
      {
#line 202
      while (1) {
        while_continue: /* CIL Label */ ;
#line 202
        if (debug_level >= 1) {
#line 202
          if (debug_source_info) {
            {
#line 202
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 202
              n = 203U;
#line 202
              dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 202
              dico_stream_ioctl(debug_stream, 3, (void *)(& n));
              }
#line 202
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          {
#line 202
          tmp = gettext("Obtained authentication credentials from the command line\n");
#line 202
          tmp___0 = strlen((char const   *)tmp);
#line 202
          tmp___1 = gettext("Obtained authentication credentials from the command line\n");
#line 202
          dico_stream_write(debug_stream, (void const   *)tmp___1, tmp___0);
          }
        }
#line 202
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 204
      return (0);
    } else {
#line 201
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 206
    flags = 0;
#line 208
    if (autologin_file) {
      {
#line 209
      tmp___3 = access((char const   *)autologin_file, 0);
      }
#line 209
      if (tmp___3) {
        {
#line 210
        tmp___2 = gettext("File %s does not exist");
#line 210
        dico_log(3, 0, (char const   *)tmp___2, autologin_file);
        }
      } else {
        {
#line 213
        parse_autologin((char const   *)autologin_file, host, cred, & flags);
        }
      }
    }
#line 216
    if (! flags) {
#line 216
      if (".dicologin") {
        {
#line 217
        tmp___4 = get_homedir();
#line 217
        home = tmp___4;
#line 218
        tmp___5 = dico_full_file_name((char const   *)home, ".dicologin");
#line 218
        filename___0 = tmp___5;
#line 220
        parse_autologin((char const   *)filename___0, host, cred, & flags);
#line 221
        free((void *)filename___0);
        }
      }
    }
#line 223
    if (flags & 4) {
#line 224
      return (2);
    }
  }
#line 226
  if (cred->user) {
#line 226
    if (! cred->pass) {
      {
#line 227
      tmp___6 = gettext("Password:");
#line 227
      tmp___7 = gnu_getpass((char const   *)tmp___6);
#line 227
      p = tmp___7;
      }
#line 228
      if (p) {
        {
#line 228
        tmp___8 = xstrdup((char const   *)p);
#line 228
        cred->pass = tmp___8;
        }
      } else {
#line 228
        cred->pass = (char *)((void *)0);
      }
    }
  }
#line 230
  if (cred->user) {
#line 230
    if (cred->pass) {
#line 230
      tmp___9 = 0;
    } else {
#line 230
      tmp___9 = 1;
    }
  } else {
#line 230
    tmp___9 = 1;
  }
#line 230
  return (tmp___9);
}
}
#line 233 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
void dict_transcript(struct dict_connection *conn___0 , int state ) 
{ 
  dico_stream_t transport ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  dico_stream_t logstr ;
  dico_stream_t tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 236
  if (state == conn___0->transcript) {
#line 237
    return;
  }
#line 238
  if (state == 0) {
    {
#line 240
    tmp___1 = dico_stream_ioctl(conn___0->str, 0, (void *)(& transport));
    }
#line 240
    if (tmp___1) {
      {
#line 242
      tmp = gettext("INTERNAL ERROR at %s:%d: cannot get stream transport");
#line 242
      tmp___0 = __errno_location();
#line 242
      dico_log(5, *tmp___0, (char const   *)tmp, "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c",
               245);
      }
#line 246
      return;
    }
    {
#line 249
    tmp___4 = dico_stream_ioctl(conn___0->str, 1, (void *)0);
    }
#line 249
    if (tmp___4) {
      {
#line 250
      tmp___2 = gettext("INTERNAL ERROR at %s:%d: cannot set stream transport");
#line 250
      tmp___3 = __errno_location();
#line 250
      dico_log(5, *tmp___3, (char const   *)tmp___2, "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c",
               253);
      }
#line 254
      return;
    }
    {
#line 257
    dico_stream_close(conn___0->str);
#line 258
    dico_stream_destroy(& conn___0->str);
#line 259
    conn___0->str = transport;
#line 260
    conn___0->transcript = state;
    }
  } else {
    {
#line 262
    tmp___5 = dico_log_stream_create(0);
#line 262
    logstr = tmp___5;
    }
#line 263
    if (! logstr) {
      {
#line 264
      xalloc_die();
      }
    }
    {
#line 265
    conn___0->str = xdico_transcript_stream_create(conn___0->str, logstr, xscript_prefix);
#line 267
    conn___0->transcript = state;
    }
  }
#line 269
  return;
}
}
#line 271 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_connect(struct dict_connection **pconn , dico_url_t url ) 
{ 
  struct sockaddr_in s ;
  int fd ;
  IPADDR ip ;
  dico_stream_t str ;
  struct dict_connection *conn___0 ;
  unsigned int n ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  unsigned int n___0 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (debug_level >= 1) {
#line 280
      if (debug_source_info) {
        {
#line 280
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 280
          n = 281U;
#line 280
          dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 280
          dico_stream_ioctl(debug_stream, 3, (void *)(& n));
          }
#line 280
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 280
      if (url->port) {
#line 280
        tmp = url->port;
      } else {
#line 280
        tmp = 2628;
      }
      {
#line 280
      tmp___0 = gettext("Connecting to %s:%d\n");
#line 280
      stream_printf(debug_stream, (char const   *)tmp___0, url->host, tmp);
      }
    }
#line 280
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 282
  fd = socket(2, 1, 0);
  }
#line 283
  if (fd == -1) {
    {
#line 284
    tmp___1 = gettext("cannot create dict socket");
#line 284
    tmp___2 = __errno_location();
#line 284
    dico_log(4, *tmp___2, (char const   *)tmp___1);
    }
#line 286
    return (1);
  }
  {
#line 289
  s.sin_family = (sa_family_t )2;
#line 290
  s.sin_addr.s_addr = htonl((uint32_t )source_addr);
#line 291
  s.sin_port = (in_port_t )0;
#line 292
  tmp___5 = bind(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& s)),
                 (socklen_t )sizeof(s));
  }
#line 292
  if (tmp___5 < 0) {
    {
#line 293
    tmp___3 = gettext("cannot bind AUTH socket");
#line 293
    tmp___4 = __errno_location();
#line 293
    dico_log(4, *tmp___4, (char const   *)tmp___3);
    }
  }
  {
#line 297
  ip = get_ipaddr(url->host);
  }
#line 298
  if (ip == 0UL) {
    {
#line 299
    tmp___6 = gettext("%s: Invalid IP or unknown host name");
#line 299
    dico_log(4, 0, (char const   *)tmp___6, url->host);
    }
#line 301
    return (1);
  }
  {
#line 303
  s.sin_addr.s_addr = htonl((uint32_t )ip);
  }
#line 304
  if (url->port) {
#line 304
    tmp___7 = url->port;
  } else {
#line 304
    tmp___7 = 2628;
  }
  {
#line 304
  s.sin_port = htons((uint16_t )tmp___7);
#line 305
  tmp___11 = connect(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& s)),
                     (socklen_t )sizeof(s));
  }
#line 305
  if (tmp___11 == -1) {
#line 306
    if (url->port) {
#line 306
      tmp___8 = url->port;
    } else {
#line 306
      tmp___8 = 2628;
    }
    {
#line 306
    tmp___9 = gettext("cannot connect to DICT server %s:%d");
#line 306
    tmp___10 = __errno_location();
#line 306
    dico_log(4, *tmp___10, (char const   *)tmp___9, url->host, tmp___8);
#line 309
    close(fd);
    }
#line 310
    return (1);
  }
  {
#line 313
  str = dico_fd_io_stream_create(fd, fd);
  }
#line 313
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 314
    tmp___12 = __errno_location();
#line 314
    tmp___13 = strerror(*tmp___12);
#line 314
    tmp___14 = gettext("cannot create dict stream: %s");
#line 314
    tmp___15 = __errno_location();
#line 314
    dico_log(4, *tmp___15, (char const   *)tmp___14, tmp___13);
    }
#line 317
    return (1);
  }
  {
#line 320
  tmp___16 = xzalloc((size_t )sizeof(*conn___0));
#line 320
  conn___0 = (struct dict_connection *)tmp___16;
#line 321
  conn___0->str = str;
#line 322
  conn___0->fd = fd;
#line 323
  dict_transcript(conn___0, transcript);
#line 324
  tmp___18 = dict_read_reply(conn___0);
  }
#line 324
  if (tmp___18) {
    {
#line 325
    tmp___17 = gettext("No reply from server");
#line 325
    dico_log(4, 0, (char const   *)tmp___17);
    }
#line 326
    return (1);
  }
  {
#line 328
  tmp___20 = parse_initial_reply(conn___0);
  }
#line 328
  if (tmp___20) {
    {
#line 329
    tmp___19 = gettext("Invalid reply from server");
#line 329
    dico_log(4, 0, (char const   *)tmp___19);
#line 330
    dict_conn_close(conn___0);
    }
#line 331
    return (1);
  }
  {
#line 334
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 334
    if (debug_level >= 1) {
#line 334
      if (debug_source_info) {
        {
#line 334
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 334
          n___0 = 334U;
#line 334
          dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 334
          dico_stream_ioctl(debug_stream, 3, (void *)(& n___0));
          }
#line 334
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 334
      tmp___21 = gettext("Sending client information\n");
#line 334
      tmp___22 = strlen((char const   *)tmp___21);
#line 334
      tmp___23 = gettext("Sending client information\n");
#line 334
      dico_stream_write(debug_stream, (void const   *)tmp___23, tmp___22);
      }
    }
#line 334
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 335
  stream_printf(conn___0->str, "CLIENT \"%s\"\r\n", client);
#line 336
  dict_read_reply(conn___0);
#line 337
  tmp___25 = dict_status_p(conn___0, (char *)"250");
  }
#line 337
  if (! tmp___25) {
    {
#line 338
    tmp___24 = gettext("Unexpected reply to CLIENT command: `%s\'");
#line 338
    dico_log(3, 0, (char const   *)tmp___24, conn___0->buf);
    }
  }
  {
#line 342
  _obstack_begin(& conn___0->stk, 0, 0, (void *(*)(long  ))(& malloc), & free);
  }
#line 344
  if (! noauth_option) {
    {
#line 344
    tmp___27 = dict_auth(conn___0, url);
    }
#line 344
    if (tmp___27) {
      {
#line 345
      tmp___26 = gettext("Authentication failed");
#line 345
      dico_log(4, 0, (char const   *)tmp___26);
#line 346
      dict_conn_close(conn___0);
      }
#line 347
      return (1);
    }
  }
#line 350
  *pconn = conn___0;
#line 352
  return (0);
}
}
#line 355 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_read_reply(struct dict_connection *conn___0 ) 
{ 
  int rc ;

  {
#line 359
  if (conn___0->buf) {
#line 360
    *(conn___0->buf + 0) = (char)0;
  }
  {
#line 361
  rc = dico_stream_getline(conn___0->str, & conn___0->buf, & conn___0->size, & conn___0->level);
  }
#line 363
  if (rc == 0) {
    {
#line 364
    conn___0->level = dico_trim_nl(conn___0->buf);
    }
  }
#line 365
  return (rc);
}
}
#line 368 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_status_p(struct dict_connection *conn___0 , char *status ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;

  {
#line 371
  if (conn___0->level > 3U) {
    {
#line 371
    tmp = memcmp((void const   *)conn___0->buf, (void const   *)status, (size_t )3);
    }
#line 371
    if (tmp == 0) {
      {
#line 371
      tmp___0 = __ctype_b_loc();
      }
#line 371
      if ((int const   )*(*tmp___0 + (int )*(conn___0->buf + 3)) & 8192) {
#line 371
        tmp___2 = 1;
      } else
#line 371
      if (conn___0->level == 5U) {
        {
#line 371
        tmp___1 = memcmp((void const   *)(conn___0->buf + 3), (void const   *)"\r\n",
                         (size_t )2);
        }
#line 371
        if (tmp___1 == 0) {
#line 371
          tmp___2 = 1;
        } else {
#line 371
          tmp___2 = 0;
        }
      } else {
#line 371
        tmp___2 = 0;
      }
    } else {
#line 371
      tmp___2 = 0;
    }
  } else {
#line 371
    tmp___2 = 0;
  }
#line 371
  return (tmp___2);
}
}
#line 377 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_capa(struct dict_connection *conn___0 , char *capa ) 
{ 
  int i___0 ;
  int tmp ;

  {
#line 382
  i___0 = 0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (i___0 < conn___0->capac)) {
#line 382
      goto while_break;
    }
    {
#line 383
    tmp = strcmp((char const   *)*(conn___0->capav + i___0), (char const   *)capa);
    }
#line 383
    if (tmp == 0) {
#line 384
      return (1);
    }
#line 382
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  return (0);
}
}
#line 388 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_multiline_reply(struct dict_connection *conn___0 ) 
{ 
  int rc ;
  size_t nlines___0 ;
  char *ptr ;
  size_t len___0 ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  char *tmp ;
  struct obstack *__o___1 ;
  char *tmp___0 ;

  {
#line 392
  nlines___0 = (size_t )0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 394
    rc = dict_read_reply(conn___0);
    }
#line 394
    if (! (rc == 0)) {
#line 394
      goto while_break;
    }
#line 395
    ptr = conn___0->buf;
#line 396
    len___0 = conn___0->level;
#line 397
    if ((int )*ptr == 46) {
#line 398
      if ((int )*(ptr + 1) == 0) {
#line 399
        goto while_break;
      } else
#line 400
      if ((int )*(ptr + 1) == 46) {
#line 401
        ptr ++;
#line 402
        len___0 --;
      }
    }
#line 405
    __o = & conn___0->stk;
#line 405
    __len = (int )len___0;
#line 405
    if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
      {
#line 405
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 405
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)ptr,
           (size_t )__len);
#line 405
    __o->next_free += __len;
#line 406
    __o___0 = & conn___0->stk;
    }
#line 406
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 406
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 406
    tmp = __o___0->next_free;
#line 406
    (__o___0->next_free) ++;
#line 406
    *tmp = (char )'\n';
#line 407
    nlines___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  __o___1 = & conn___0->stk;
#line 409
  if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
    {
#line 409
    _obstack_newchunk(__o___1, 1);
    }
  }
#line 409
  tmp___0 = __o___1->next_free;
#line 409
  (__o___1->next_free) ++;
#line 409
  *tmp___0 = (char)0;
#line 410
  return (rc);
}
}
#line 413 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_define(struct dict_connection *conn___0 , char *database , char *word ) 
{ 
  int rc ;
  unsigned int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned long i___0 ;
  unsigned long count ;
  char *p ;
  unsigned int n___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o___0 ;
  char *tmp___5 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (debug_level >= 1) {
#line 418
      if (debug_source_info) {
        {
#line 418
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 418
          n = 419U;
#line 418
          dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 418
          dico_stream_ioctl(debug_stream, 3, (void *)(& n));
          }
#line 418
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 418
      tmp = gettext("Sending query for word \"%s\" in database \"%s\"\n");
#line 418
      stream_printf(debug_stream, (char const   *)tmp, word, database);
      }
    }
#line 418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 420
  tmp___0 = quotearg_n(1, (char const   *)word);
#line 420
  tmp___1 = quotearg_n(0, (char const   *)database);
#line 420
  stream_printf(conn___0->str, "DEFINE \"%s\" \"%s\"\r\n", tmp___1, tmp___0);
#line 423
  dict_read_reply(conn___0);
#line 424
  tmp___8 = dict_status_p(conn___0, (char *)"150");
  }
#line 424
  if (tmp___8) {
    {
#line 428
    count = strtoul((char const   */* __restrict  */)(conn___0->buf + 3), (char **/* __restrict  */)(& p),
                    10);
    }
    {
#line 429
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 429
      if (debug_level >= 1) {
#line 429
        if (debug_source_info) {
          {
#line 429
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 429
            n___0 = 431U;
#line 429
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 429
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___0));
            }
#line 429
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 429
        tmp___2 = ngettext("Reading %lu definition\n", "Reading %lu definitions\n",
                           count);
#line 429
        stream_printf(debug_stream, (char const   *)tmp___2, count);
        }
      }
#line 429
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 432
    i___0 = 0UL;
    {
#line 432
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 432
      if (! (i___0 < count)) {
#line 432
        goto while_break___3;
      }
      {
#line 433
      dict_read_reply(conn___0);
#line 434
      tmp___4 = dict_status_p(conn___0, (char *)"151");
      }
#line 434
      if (! tmp___4) {
        {
#line 435
        tmp___3 = gettext("Unexpected reply in place of definition %lu");
#line 435
        dico_log(3, 0, (char const   *)tmp___3, i___0);
        }
#line 437
        goto while_break___3;
      }
#line 439
      __o = & conn___0->stk;
#line 439
      __len = (int )conn___0->level;
#line 439
      if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
        {
#line 439
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 439
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)conn___0->buf,
             (size_t )__len);
#line 439
      __o->next_free += __len;
#line 440
      __o___0 = & conn___0->stk;
      }
#line 440
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 440
        _obstack_newchunk(__o___0, 1);
        }
      }
      {
#line 440
      tmp___5 = __o___0->next_free;
#line 440
      (__o___0->next_free) ++;
#line 440
      *tmp___5 = (char)0;
#line 441
      dict_multiline_reply(conn___0);
#line 432
      i___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 443
    dict_read_reply(conn___0);
#line 445
    __o1 = & conn___0->stk;
#line 445
    __value = (void *)__o1->object_base;
    }
#line 445
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 445
      __o1->maybe_empty_object = 1U;
    }
#line 445
    if (sizeof(int ) < sizeof(void *)) {
#line 445
      tmp___6 = __o1->object_base;
    } else {
#line 445
      tmp___6 = (char *)0;
    }
#line 445
    if (sizeof(int ) < sizeof(void *)) {
#line 445
      tmp___7 = __o1->object_base;
    } else {
#line 445
      tmp___7 = (char *)0;
    }
#line 445
    __o1->next_free = tmp___6 + (((__o1->next_free - tmp___7) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 445
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 445
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 445
    __o1->object_base = __o1->next_free;
#line 445
    dict_result_create(conn___0, (enum dict_result_type )0, (size_t )count, (char *)__value);
#line 446
    rc = 0;
    }
  } else {
#line 448
    rc = 1;
  }
#line 449
  return (rc);
}
}
#line 452 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
int dict_match(struct dict_connection *conn___0 , char *database , char *strategy ,
               char *word ) 
{ 
  int rc ;
  unsigned int n ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int n___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned long count ;
  char *p ;
  unsigned int n___1 ;
  char *tmp___10 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 457
  if (levenshtein_threshold) {
#line 457
    if (conn___0->levdist != levenshtein_threshold) {
      {
#line 457
      tmp___5 = dict_capa(conn___0, (char *)"xlev");
      }
#line 457
      if (tmp___5) {
        {
#line 459
        while (1) {
          while_continue: /* CIL Label */ ;
#line 459
          if (debug_level >= 1) {
#line 459
            if (debug_source_info) {
              {
#line 459
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 459
                n = 459U;
#line 459
                dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 459
                dico_stream_ioctl(debug_stream, 3, (void *)(& n));
                }
#line 459
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
            {
#line 459
            tmp = gettext("Setting Levenshtein threshold\n");
#line 459
            tmp___0 = strlen((char const   *)tmp);
#line 459
            tmp___1 = gettext("Setting Levenshtein threshold\n");
#line 459
            dico_stream_write(debug_stream, (void const   *)tmp___1, tmp___0);
            }
          }
#line 459
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 460
        stream_printf(conn___0->str, "XLEV %u\n", levenshtein_threshold);
#line 461
        dict_read_reply(conn___0);
#line 462
        tmp___4 = dict_status_p(conn___0, (char *)"250");
        }
#line 462
        if (tmp___4) {
          {
#line 465
          tmp___2 = gettext("Server rejected XLEV command");
#line 465
          dico_log(3, 0, (char const   *)tmp___2);
#line 466
          tmp___3 = gettext("Server reply: %s");
#line 466
          dico_log(3, 0, (char const   *)tmp___3, conn___0->buf);
          }
        } else {
#line 463
          conn___0->levdist = levenshtein_threshold;
        }
      }
    }
  }
  {
#line 469
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 469
    if (debug_level >= 1) {
#line 469
      if (debug_source_info) {
        {
#line 469
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 469
          n___0 = 471U;
#line 469
          dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 469
          dico_stream_ioctl(debug_stream, 3, (void *)(& n___0));
          }
#line 469
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 469
      tmp___6 = gettext("Sending query to match word \"%s\" in database \"%s\", using \"%s\"\n");
#line 469
      stream_printf(debug_stream, (char const   *)tmp___6, word, database, strategy);
      }
    }
#line 469
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 472
  tmp___7 = quotearg_n(2, (char const   *)word);
#line 472
  tmp___8 = quotearg_n(1, (char const   *)strategy);
#line 472
  tmp___9 = quotearg_n(0, (char const   *)database);
#line 472
  stream_printf(conn___0->str, "MATCH \"%s\" \"%s\" \"%s\"\r\n", tmp___9, tmp___8,
                tmp___7);
#line 476
  dict_read_reply(conn___0);
#line 477
  tmp___13 = dict_status_p(conn___0, (char *)"152");
  }
#line 477
  if (tmp___13) {
    {
#line 481
    count = strtoul((char const   */* __restrict  */)(conn___0->buf + 3), (char **/* __restrict  */)(& p),
                    10);
    }
    {
#line 482
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 482
      if (debug_level >= 1) {
#line 482
        if (debug_source_info) {
          {
#line 482
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 482
            n___1 = 484U;
#line 482
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c");
#line 482
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___1));
            }
#line 482
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 482
        tmp___10 = ngettext("Reading %lu match\n", "Reading %lu matches\n", count);
#line 482
        stream_printf(debug_stream, (char const   *)tmp___10, count);
        }
      }
#line 482
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 486
    dict_multiline_reply(conn___0);
#line 488
    __o1 = & conn___0->stk;
#line 488
    __value = (void *)__o1->object_base;
    }
#line 488
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 488
      __o1->maybe_empty_object = 1U;
    }
#line 488
    if (sizeof(int ) < sizeof(void *)) {
#line 488
      tmp___11 = __o1->object_base;
    } else {
#line 488
      tmp___11 = (char *)0;
    }
#line 488
    if (sizeof(int ) < sizeof(void *)) {
#line 488
      tmp___12 = __o1->object_base;
    } else {
#line 488
      tmp___12 = (char *)0;
    }
#line 488
    __o1->next_free = tmp___11 + (((__o1->next_free - tmp___12) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 488
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 488
      __o1->next_free = __o1->chunk_limit;
    }
    {
#line 488
    __o1->object_base = __o1->next_free;
#line 488
    dict_result_create(conn___0, (enum dict_result_type )1, (size_t )count, (char *)__value);
#line 489
    dict_read_reply(conn___0);
#line 490
    rc = 0;
    }
  } else {
#line 492
    rc = 1;
  }
#line 493
  return (rc);
}
}
#line 496 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static size_t count_lines(char *p ) 
{ 
  size_t count ;

  {
#line 499
  count = (size_t )0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 500
    p = strchr((char const   *)p, '\n');
    }
#line 500
    if (! p) {
#line 500
      goto while_break;
    }
#line 501
    count ++;
#line 502
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return (count);
}
}
#line 507 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static void _result_parse_def(struct dict_result *res ) 
{ 
  char *p ;
  size_t i___0 ;
  struct define_result *def ;
  void *tmp ;
  xdico_input_t input ;
  xdico_input_t tmp___0 ;
  int argc ;
  char **argv ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 512
  tmp = xcalloc(res->count, (size_t )sizeof(*def));
#line 512
  def = (struct define_result *)tmp;
#line 513
  tmp___0 = xdico_tokenize_begin();
#line 513
  input = tmp___0;
#line 515
  res->set.def = def;
#line 516
  p = res->base;
#line 517
  i___0 = (size_t )0;
  }
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! (i___0 < res->count)) {
#line 517
      goto while_break;
    }
    {
#line 522
    xdico_tokenize_input(input, p, & argc, & argv);
#line 523
    def->word = xstrdup((char const   *)*(argv + 1));
#line 524
    def->database = xstrdup((char const   *)*(argv + 2));
#line 525
    def->descr = xstrdup((char const   *)*(argv + 3));
#line 526
    tmp___1 = strlen((char const   *)p);
#line 526
    p += tmp___1 + 1U;
#line 527
    def->defn = p;
#line 528
    def->nlines = count_lines(p);
#line 529
    tmp___2 = strlen((char const   *)p);
#line 529
    p += tmp___2 + 1U;
#line 517
    i___0 ++;
#line 517
    def ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 531
  xdico_tokenize_end(& input);
  }
#line 532
  return;
}
}
#line 534 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static void _result_free_def(struct dict_result *res ) 
{ 
  size_t i___0 ;
  struct define_result *def ;

  {
#line 538
  def = res->set.def;
#line 540
  i___0 = (size_t )0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! (i___0 < res->count)) {
#line 540
      goto while_break;
    }
    {
#line 541
    free((void *)def->word);
#line 542
    free((void *)def->database);
#line 543
    free((void *)def->descr);
#line 540
    i___0 ++;
#line 540
    def ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  free((void *)res->set.def);
  }
#line 546
  return;
}
}
#line 548 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static void _result_parse_mat(struct dict_result *res ) 
{ 
  char *p ;
  size_t i___0 ;
  struct match_result *mat ;
  void *tmp ;
  size_t len___0 ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 553
  tmp = xcalloc(res->count, (size_t )sizeof(*mat));
#line 553
  mat = (struct match_result *)tmp;
#line 555
  res->set.mat = mat;
#line 556
  i___0 = (size_t )0;
#line 556
  p = strtok((char */* __restrict  */)res->base, (char const   */* __restrict  */)"\n");
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (i___0 < res->count)) {
#line 556
      goto while_break;
    }
#line 560
    if (! p) {
      {
#line 561
      tmp___0 = gettext("Not enough data in the result");
#line 561
      dico_log(2, 0, (char const   *)tmp___0);
#line 562
      res->count = i___0;
      }
#line 563
      goto while_break;
    }
    {
#line 566
    mat->database = p;
#line 567
    len___0 = strcspn((char const   *)p, " \t");
#line 568
    *(p + len___0) = (char)0;
#line 569
    p += len___0 + 1U;
#line 570
    tmp___1 = strspn((char const   *)p, " \t");
#line 570
    p += tmp___1;
#line 571
    len___0 = strlen((char const   *)p);
    }
#line 572
    if ((int )*(p + 0) == 34) {
#line 572
      if ((int )*(p + (len___0 - 1U)) == 34) {
#line 573
        *(p + (len___0 - 1U)) = (char)0;
#line 574
        p ++;
      }
    }
    {
#line 576
    mat->word = p;
#line 556
    p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
#line 556
    i___0 ++;
#line 556
    mat ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 580 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
static void _result_free_mat(struct dict_result *res ) 
{ 


  {
  {
#line 583
  free((void *)res->set.mat);
  }
#line 584
  return;
}
}
#line 586 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
struct dict_result *dict_result_create(struct dict_connection *conn___0 , enum dict_result_type type ,
                                       size_t count , char *base ) 
{ 
  struct dict_result *res ;
  void *tmp ;

  {
  {
#line 590
  tmp = xmalloc((size_t )sizeof(*res));
#line 590
  res = (struct dict_result *)tmp;
#line 591
  res->conn = conn___0;
#line 592
  res->prev = conn___0->last_result;
#line 593
  conn___0->last_result = res;
#line 594
  res->type = type;
#line 595
  res->count = count;
#line 596
  res->base = base;
  }
  {
#line 598
  if ((unsigned int )type == 0U) {
#line 598
    goto case_0;
  }
#line 602
  if ((unsigned int )type == 1U) {
#line 602
    goto case_1;
  }
#line 606
  if ((unsigned int )type == 2U) {
#line 606
    goto case_2;
  }
#line 597
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 599
  _result_parse_def(res);
  }
#line 600
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 603
  _result_parse_mat(res);
  }
#line 604
  goto switch_break;
  case_2: /* CIL Label */ 
#line 607
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 609
  return (res);
}
}
#line 612 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
void dict_result_free(struct dict_result *res ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct dict_result *p ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 615
  if (! res) {
#line 616
    return;
  }
#line 619
  if ((unsigned long )res == (unsigned long )(res->conn)->last_result) {
#line 620
    __o = & (res->conn)->stk;
#line 620
    __obj = (void *)res->base;
#line 620
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 620
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 620
        tmp = (char *)__obj;
#line 620
        __o->object_base = tmp;
#line 620
        __o->next_free = tmp;
      } else {
        {
#line 620
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 620
      obstack_free(__o, __obj);
      }
    }
#line 621
    (res->conn)->last_result = res->prev;
  } else {
#line 625
    p = (res->conn)->last_result;
    {
#line 625
    while (1) {
      while_continue: /* CIL Label */ ;
#line 625
      if (p) {
#line 625
        if (! ((unsigned long )p->prev != (unsigned long )res)) {
#line 625
          goto while_break;
        }
      } else {
#line 625
        goto while_break;
      }
#line 625
      p = p->prev;
    }
    while_break: /* CIL Label */ ;
    }
#line 627
    if (! p) {
      {
#line 628
      tmp___0 = gettext("Freeing unlinked result");
#line 628
      dico_log(5, 0, (char const   *)tmp___0);
#line 629
      abort();
      }
    }
#line 631
    p->prev = res->prev;
  }
  {
#line 635
  if ((unsigned int )res->type == 0U) {
#line 635
    goto case_0;
  }
#line 639
  if ((unsigned int )res->type == 1U) {
#line 639
    goto case_1;
  }
#line 643
  if ((unsigned int )res->type == 2U) {
#line 643
    goto case_2;
  }
#line 634
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 636
  _result_free_def(res);
  }
#line 637
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 640
  _result_free_mat(res);
  }
#line 641
  goto switch_break;
  case_2: /* CIL Label */ 
#line 644
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 646
  free((void *)res);
  }
#line 647
  return;
}
}
#line 650 "/home/wslee/benchmarks/textformat/dico-2.0/dico/connect.c"
void dict_conn_close(struct dict_connection *conn___0 ) 
{ 
  struct dict_result *res ;
  struct dict_result *prev ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
  {
#line 655
  dico_stream_close(conn___0->str);
#line 656
  dico_stream_destroy(& conn___0->str);
#line 657
  free((void *)conn___0->msgid);
#line 658
  free((void *)conn___0->buf);
#line 659
  dico_argcv_free(conn___0->capac, conn___0->capav);
#line 660
  res = conn___0->last_result;
  }
  {
#line 660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 660
    if (! res) {
#line 660
      goto while_break;
    }
    {
#line 661
    prev = res->prev;
#line 662
    dict_result_free(res);
#line 663
    res = prev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  __o = & conn___0->stk;
#line 665
  __obj = (void *)0;
#line 665
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 665
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 665
      tmp = (char *)__obj;
#line 665
      __o->object_base = tmp;
#line 665
      __o->next_free = tmp;
    } else {
      {
#line 665
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 665
    obstack_free(__o, __obj);
    }
  }
  {
#line 666
  free((void *)conn___0);
  }
#line 667
  return;
}
}
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 662 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 20 "cmdline.opt"
void print_help(void) ;
#line 20
void print_usage(void) ;
#line 188 "cmdline.opt"
static struct option long_options[30]  = 
#line 188
  {      {"host", 1, (int *)0, 256}, 
        {"port", 1, (int *)0, 'p'}, 
        {"database", 1, (int *)0, 'd'}, 
        {"source", 1, (int *)0, 257}, 
        {"match", 0, (int *)0, 'm'}, 
        {"strategy", 1, (int *)0, 's'}, 
        {"levdist", 1, (int *)0, 258}, 
        {"levenshtein-distance", 1, (int *)0, 259}, 
        {"dbs", 0, (int *)0, 'D'}, 
        {"strategies", 0, (int *)0, 'S'}, 
        {"serverhelp", 0, (int *)0, 'H'}, 
        {"info", 1, (int *)0, 'i'}, 
        {"serverinfo", 0, (int *)0, 'I'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"noauth", 0, (int *)0, 'a'}, 
        {"sasl", 0, (int *)0, 260}, 
        {"nosasl", 0, (int *)0, 261}, 
        {"user", 1, (int *)0, 'u'}, 
        {"key", 1, (int *)0, 'k'}, 
        {"password", 1, (int *)0, 262}, 
        {"autologin", 1, (int *)0, 263}, 
        {"client", 1, (int *)0, 'c'}, 
        {"transcript", 0, (int *)0, 't'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"time-stamp", 0, (int *)0, 264}, 
        {"source-info", 0, (int *)0, 265}, 
        {"help", 0, (int *)0, 'h'}, 
        {"usage", 0, (int *)0, 266}, 
        {"version", 0, (int *)0, 267}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 188 "cmdline.opt"
static struct opthelp opthelp[32]  = 
#line 188
  {      {(char const   *)((void *)0), (char const   *)((void *)0), 0, "Server selection"}, 
        {"--host",
      "SERVER", 0, "Connect to this server."}, 
        {"-p, --port", "SERVICE", 0, "Specify port to connect to."}, 
        {"-d, --database", "NAME", 0, "Select a database to search."}, 
        {"--source", "ADDR", 0, "Set a source address for TCP connections."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, "Operation modes"}, 
        {"-m, --match",
      (char const   *)((void *)0), 0, "Match instead of define."}, 
        {"-s, --strategy", "NAME", 0, "Select a strategy for matching.  Implies --match."}, 
        {"--levdist, --levenshtein-distance",
      "N", 0, "Set maximum Levenshtein distance to N."}, 
        {"-D, --dbs", (char const   *)((void *)0), 0, "Show available databases."}, 
        {"-S, --strategies", (char const   *)((void *)0), 0, "Show available search strategies."}, 
        {"-H, --serverhelp",
      (char const   *)((void *)0), 0, "show server help."}, 
        {"-i, --info", "DBNAME", 0, "Show information about database DBNAME."}, 
        {"-I, --serverinfo", (char const   *)((void *)0), 0, "Show information about the server."}, 
        {"-q, --quiet",
      (char const   *)((void *)0), 0, "Do not print the normal dico welcome."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, "Authentication"}, 
        {"-a, --noauth",
      (char const   *)((void *)0), 0, "Disable authentication."}, 
        {"--sasl", (char const   *)((void *)0), 0, "Enable SASL authentication (default)."}, 
        {"--nosasl",
      (char const   *)((void *)0), 0, "Disable SASL authentication."}, 
        {"-u, --user", "NAME", 0, "Set user name for authentication."}, 
        {"-k, --key, --password", "STRING", 0, "Set shared secret for authentication."}, 
        {"--autologin",
      "NAME", 0, "Set the name of autologin file to use."}, 
        {"-c, --client", "STRING", 0, "Additional text for client command."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, "Debugging"}, 
        {"-t, --transcript", (char const   *)((void *)0), 0, "Enable session transcript."}, 
        {"-v, --verbose",
      (char const   *)((void *)0), 0, "Increase debugging verbosity level."}, 
        {"--time-stamp", (char const   *)((void *)0), 0, "Include time stamp in the debugging output."}, 
        {"--source-info",
      (char const   *)((void *)0), 0, "Include source line information in the debugging output."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), 0, "Other options"}, 
        {"-h, --help", (char const   *)((void *)0), 0, "Give this help list"}, 
        {"--usage", (char const   *)((void *)0), 0, "Give a short usage message"}, 
        {"--version", (char const   *)((void *)0), 0, "Print program version"}};
#line 20 "cmdline.opt"
char const   *program_version  =    "dico (GNU dico 2.0)";
#line 20 "cmdline.opt"
static char doc[15]  = 
#line 20
  {      (char )'A',      (char )' ',      (char )'D',      (char )'I', 
        (char )'C',      (char )'T',      (char )' ',      (char )'c', 
        (char )'l',      (char )'i',      (char )'e',      (char )'n', 
        (char )'t',      (char )'.',      (char )'\000'};
#line 20 "cmdline.opt"
static char args_doc[14]  = 
#line 20
  {      (char )'[',      (char )'U',      (char )'R',      (char )'L', 
        (char )'-',      (char )'o',      (char )'r',      (char )'-', 
        (char )'W',      (char )'O',      (char )'R',      (char )'D', 
        (char )']',      (char )'\000'};
#line 20 "cmdline.opt"
char const   *program_bug_address  =    "<bug-dico@gnu.org>";
#line 20 "cmdline.opt"
static void indent(size_t start , size_t col ) 
{ 


  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (start < col)) {
#line 20
      goto while_break;
    }
    {
#line 20
    putchar(' ');
#line 20
    start ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 20 "cmdline.opt"
static void print_option_descr(char const   *descr , size_t lmargin , size_t rmargin ) 
{ 
  size_t s ;
  size_t i___0 ;
  size_t width ;
  unsigned short const   **tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! *descr) {
#line 20
      goto while_break;
    }
#line 20
    s = (size_t )0;
#line 20
    width = rmargin - lmargin;
#line 20
    i___0 = (size_t )0;
    {
#line 20
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 20
      if ((int const   )*(descr + i___0) == 0) {
#line 20
        goto _L;
      } else {
        {
#line 20
        tmp = __ctype_b_loc();
        }
#line 20
        if ((int const   )*(*tmp + (int )*(descr + i___0)) & 8192) {
          _L: /* CIL Label */ 
#line 20
          if (i___0 > width) {
#line 20
            goto while_break___0;
          }
#line 20
          s = i___0;
#line 20
          if ((int const   )*(descr + i___0) == 0) {
#line 20
            goto while_break___0;
          }
        }
      }
#line 20
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 20
    printf((char const   */* __restrict  */)"%*.*s\n", s, s, descr);
#line 20
    descr += s;
    }
#line 20
    if (*descr) {
      {
#line 20
      indent((size_t )0, lmargin);
#line 20
      descr ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 20 "cmdline.opt"
void print_help(void) 
{ 
  unsigned int i___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int n ;
  int tmp___3 ;
  char *cb ;
  char *ce ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 20
  tmp = gettext((char const   *)(args_doc));
#line 20
  tmp___0 = gettext("OPTION");
#line 20
  tmp___1 = gettext("Usage:");
#line 20
  printf((char const   */* __restrict  */)"%s %s [%s]... %s\n", tmp___1, "dico", tmp___0,
         tmp);
  }
#line 20
  if (doc) {
#line 20
    if (doc[0]) {
      {
#line 20
      tmp___2 = gettext((char const   *)(doc));
#line 20
      print_option_descr((char const   *)tmp___2, (size_t )0, (size_t )79);
      }
    }
  }
  {
#line 20
  putchar('\n');
#line 20
  i___0 = 0U;
  }
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! ((unsigned long )i___0 < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 20
      goto while_break;
    }
#line 20
    if (opthelp[i___0].opt) {
      {
#line 20
      tmp___3 = printf((char const   */* __restrict  */)"  %s", opthelp[i___0].opt);
#line 20
      n = (unsigned int )tmp___3;
      }
#line 20
      if (opthelp[i___0].arg) {
        {
#line 20
        tmp___4 = strlen(opthelp[i___0].opt);
        }
#line 20
        if (tmp___4 == 2U) {
#line 20
          if (! opthelp[i___0].is_optional) {
            {
#line 20
            putchar(' ');
#line 20
            n ++;
            }
          }
        } else {
          {
#line 20
          putchar('=');
#line 20
          n ++;
          }
        }
#line 20
        if (opthelp[i___0].is_optional) {
#line 20
          cb = (char *)"[";
#line 20
          ce = (char *)"]";
        } else {
#line 20
          ce = (char *)"";
#line 20
          cb = ce;
        }
        {
#line 20
        tmp___5 = gettext(opthelp[i___0].arg);
#line 20
        tmp___6 = printf((char const   */* __restrict  */)"%s%s%s", cb, tmp___5, ce);
#line 20
        n += (unsigned int )tmp___6;
        }
      }
#line 20
      if (n >= 30U) {
        {
#line 20
        putchar('\n');
#line 20
        n = 0U;
        }
      }
      {
#line 20
      indent(n, (size_t )30);
#line 20
      tmp___7 = gettext(opthelp[i___0].descr);
#line 20
      print_option_descr((char const   *)tmp___7, (size_t )30, (size_t )79);
      }
    } else {
#line 20
      if (i___0) {
        {
#line 20
        putchar('\n');
        }
      }
      {
#line 20
      indent((size_t )0, (size_t )2);
#line 20
      tmp___8 = gettext(opthelp[i___0].descr);
#line 20
      print_option_descr((char const   *)tmp___8, (size_t )2, (size_t )79);
#line 20
      putchar('\n');
      }
    }
#line 20
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 20
  putchar('\n');
#line 20
  tmp___9 = gettext("Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.");
#line 20
  print_option_descr((char const   *)tmp___9, (size_t )0, (size_t )79);
#line 20
  putchar('\n');
#line 20
  tmp___10 = gettext("Report bugs to %s.\n");
#line 20
  printf((char const   */* __restrict  */)tmp___10, program_bug_address);
  }
#line 20
  return;
}
}
#line 20 "cmdline.opt"
void print_usage(void) 
{ 
  unsigned int i___0 ;
  int f ;
  unsigned int n ;
  char buf___1[80] ;
  char *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  size_t len___0 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  size_t tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  size_t tmp___15 ;
  unsigned int tmp___16 ;
  size_t len___1 ;
  char const   *longopt ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  size_t tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  size_t tmp___26 ;
  unsigned int tmp___27 ;
  size_t tmp___28 ;
  unsigned int tmp___29 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 20
  f = 0;
#line 20
  tmp = gettext("Usage:");
#line 20
  tmp___0 = snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1),
                     (char const   */* __restrict  */)"%s %s ", tmp, "dico");
#line 20
  n = (unsigned int )tmp___0;
#line 20
  i___0 = 0U;
  }
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! ((unsigned long )i___0 < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 20
      goto while_break;
    }
#line 20
    if (opthelp[i___0].opt) {
#line 20
      if (opthelp[i___0].descr) {
#line 20
        if ((int const   )*(opthelp[i___0].opt + 1) != 45) {
#line 20
          if ((unsigned long )opthelp[i___0].arg == (unsigned long )((void *)0)) {
#line 20
            if (f == 0) {
              {
#line 20
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 20
                if (n == 79U) {
                  {
#line 20
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    {
#line 20
                    buf___1[n] = (char)0;
#line 20
                    printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
                    n = 13U;
#line 20
                    memset((void *)(buf___1), ' ', n);
                    }
#line 20
                    goto while_break___1;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
#line 20
                tmp___1 = n;
#line 20
                n ++;
#line 20
                buf___1[tmp___1] = (char )'[';
#line 20
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 20
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 20
                if (n == 79U) {
                  {
#line 20
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
                    {
#line 20
                    buf___1[n] = (char)0;
#line 20
                    printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
                    n = 13U;
#line 20
                    memset((void *)(buf___1), ' ', n);
                    }
#line 20
                    goto while_break___3;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                }
#line 20
                tmp___2 = n;
#line 20
                n ++;
#line 20
                buf___1[tmp___2] = (char )'-';
#line 20
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 20
              f = 1;
            }
            {
#line 20
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 20
              if (n == 79U) {
                {
#line 20
                while (1) {
                  while_continue___5: /* CIL Label */ ;
                  {
#line 20
                  buf___1[n] = (char)0;
#line 20
                  printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
                  n = 13U;
#line 20
                  memset((void *)(buf___1), ' ', n);
                  }
#line 20
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
#line 20
              tmp___3 = n;
#line 20
              n ++;
#line 20
              buf___1[tmp___3] = (char )*(opthelp[i___0].opt + 1);
#line 20
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 20
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  if (f) {
    {
#line 20
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 20
      if (n == 79U) {
        {
#line 20
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 20
          buf___1[n] = (char)0;
#line 20
          printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
          n = 13U;
#line 20
          memset((void *)(buf___1), ' ', n);
          }
#line 20
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 20
      tmp___4 = n;
#line 20
      n ++;
#line 20
      buf___1[tmp___4] = (char )']';
#line 20
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 20
  i___0 = 0U;
  {
#line 20
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 20
    if (! ((unsigned long )i___0 < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 20
      goto while_break___8;
    }
#line 20
    if (opthelp[i___0].opt) {
#line 20
      if (opthelp[i___0].descr) {
#line 20
        if ((int const   )*(opthelp[i___0].opt + 1) != 45) {
#line 20
          if (opthelp[i___0].arg) {
            {
#line 20
            tmp___5 = strlen(opthelp[i___0].arg);
            }
#line 20
            if (opthelp[i___0].is_optional) {
#line 20
              tmp___6 = 2;
            } else {
#line 20
              tmp___6 = 1;
            }
#line 20
            len___0 = (5U + tmp___5) + (size_t )tmp___6;
#line 20
            if (n + len___0 > 79U) {
              {
#line 20
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 20
                buf___1[n] = (char)0;
#line 20
                printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
                n = 13U;
#line 20
                memset((void *)(buf___1), ' ', n);
                }
#line 20
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
#line 20
            tmp___7 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___7] = (char )' ';
#line 20
            tmp___8 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___8] = (char )'[';
#line 20
            tmp___9 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___9] = (char )'-';
#line 20
            tmp___10 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___10] = (char )*(opthelp[i___0].opt + 1);
#line 20
            if (opthelp[i___0].is_optional) {
              {
#line 20
              tmp___11 = n;
#line 20
              n ++;
#line 20
              buf___1[tmp___11] = (char )'[';
#line 20
              strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i___0].arg);
#line 20
              tmp___12 = strlen(opthelp[i___0].arg);
#line 20
              n += tmp___12;
#line 20
              tmp___13 = n;
#line 20
              n ++;
#line 20
              buf___1[tmp___13] = (char )']';
              }
            } else {
              {
#line 20
              tmp___14 = n;
#line 20
              n ++;
#line 20
              buf___1[tmp___14] = (char )' ';
#line 20
              strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i___0].arg);
#line 20
              tmp___15 = strlen(opthelp[i___0].arg);
#line 20
              n += tmp___15;
              }
            }
#line 20
            tmp___16 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___16] = (char )']';
          }
        }
      }
    }
#line 20
    i___0 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 20
  i___0 = 0U;
  {
#line 20
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 20
    if (! ((unsigned long )i___0 < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 20
      goto while_break___10;
    }
#line 20
    if (opthelp[i___0].opt) {
#line 20
      if (opthelp[i___0].descr) {
#line 20
        if ((int const   )*(opthelp[i___0].opt + 1) == 45) {
#line 20
          longopt = opthelp[i___0].opt;
        } else
#line 20
        if ((int const   )*(opthelp[i___0].opt + 2) == 44) {
#line 20
          longopt = opthelp[i___0].opt + 4;
        } else {
#line 20
          goto __Cont;
        }
        {
#line 20
        tmp___17 = strlen(longopt);
        }
#line 20
        if (opthelp[i___0].arg) {
          {
#line 20
          tmp___18 = strlen(opthelp[i___0].arg);
          }
#line 20
          if (opthelp[i___0].is_optional) {
#line 20
            tmp___19 = 2;
          } else {
#line 20
            tmp___19 = 0;
          }
#line 20
          tmp___20 = (1U + tmp___18) + (size_t )tmp___19;
        } else {
#line 20
          tmp___20 = (size_t )0;
        }
#line 20
        len___1 = (3U + tmp___17) + tmp___20;
#line 20
        if (n + len___1 > 79U) {
          {
#line 20
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 20
            buf___1[n] = (char)0;
#line 20
            printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
            n = 13U;
#line 20
            memset((void *)(buf___1), ' ', n);
            }
#line 20
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
        {
#line 20
        tmp___21 = n;
#line 20
        n ++;
#line 20
        buf___1[tmp___21] = (char )' ';
#line 20
        tmp___22 = n;
#line 20
        n ++;
#line 20
        buf___1[tmp___22] = (char )'[';
#line 20
        strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)longopt);
#line 20
        tmp___23 = strlen(longopt);
#line 20
        n += tmp___23;
        }
#line 20
        if (opthelp[i___0].arg) {
#line 20
          tmp___24 = n;
#line 20
          n ++;
#line 20
          buf___1[tmp___24] = (char )'=';
#line 20
          if (opthelp[i___0].is_optional) {
            {
#line 20
            tmp___25 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___25] = (char )'[';
#line 20
            strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i___0].arg);
#line 20
            tmp___26 = strlen(opthelp[i___0].arg);
#line 20
            n += tmp___26;
#line 20
            tmp___27 = n;
#line 20
            n ++;
#line 20
            buf___1[tmp___27] = (char )']';
            }
          } else {
            {
#line 20
            strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i___0].arg);
#line 20
            tmp___28 = strlen(opthelp[i___0].arg);
#line 20
            n += tmp___28;
            }
          }
        }
#line 20
        tmp___29 = n;
#line 20
        n ++;
#line 20
        buf___1[tmp___29] = (char )']';
      }
    }
    __Cont: /* CIL Label */ 
#line 20
    i___0 ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 20
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 20
    buf___1[n] = (char)0;
#line 20
    printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 20
    n = 13U;
#line 20
    memset((void *)(buf___1), ' ', n);
    }
#line 20
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 20 "cmdline.opt"
char const   version_etc_copyright[54]  = 
#line 20
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'5',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'6',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'7',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'8',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'r',      (char const   )'g', 
        (char const   )'e',      (char const   )'y',      (char const   )' ',      (char const   )'P', 
        (char const   )'o',      (char const   )'z',      (char const   )'n',      (char const   )'y', 
        (char const   )'a',      (char const   )'k',      (char const   )'o',      (char const   )'f', 
        (char const   )'f',      (char const   )'\000'};
#line 20 "cmdline.opt"
void print_version_only(char const   *program_version___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 20
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n",
          program_version___0);
#line 20
  tmp = gettext("(C)");
#line 20
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp);
#line 20
  fputc('\n', stream);
  }
#line 20
  return;
}
}
#line 20 "cmdline.opt"
void print_version(char const   *program_version___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 20
  print_version_only(program_version___0, stream);
#line 20
  tmp = gettext("License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 20
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
  }
#line 20
  return;
}
}
#line 190 "cmdline.opt"
void get_options(int argc , char **argv , int *index___0 ) 
{ 
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *p ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int n ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    c = getopt_long(argc, (char * const  *)argv, "p:d:ms:DSHi:Iqau:k:c:tvh", (struct option  const  *)(long_options),
                    (int *)((void *)0));
    }
#line 193
    if (! (c != -1)) {
#line 193
      goto while_break;
    }
    {
#line 28
    if (c == 256) {
#line 28
      goto case_256;
    }
#line 34
    if (c == 112) {
#line 34
      goto case_112;
    }
#line 42
    if (c == 100) {
#line 42
      goto case_100;
    }
#line 48
    if (c == 257) {
#line 48
      goto case_257;
    }
#line 59
    if (c == 109) {
#line 59
      goto case_109;
    }
#line 65
    if (c == 115) {
#line 65
      goto case_115;
    }
#line 73
    if (c == 259) {
#line 73
      goto case_259;
    }
#line 73
    if (c == 258) {
#line 73
      goto case_259;
    }
#line 82
    if (c == 68) {
#line 82
      goto case_68;
    }
#line 88
    if (c == 83) {
#line 88
      goto case_83;
    }
#line 94
    if (c == 72) {
#line 94
      goto case_72;
    }
#line 100
    if (c == 105) {
#line 100
      goto case_105;
    }
#line 107
    if (c == 73) {
#line 107
      goto case_73;
    }
#line 113
    if (c == 113) {
#line 113
      goto case_113;
    }
#line 121
    if (c == 97) {
#line 121
      goto case_97;
    }
#line 127
    if (c == 260) {
#line 127
      goto case_260;
    }
#line 133
    if (c == 261) {
#line 133
      goto case_261;
    }
#line 139
    if (c == 117) {
#line 139
      goto case_117;
    }
#line 146
    if (c == 262) {
#line 146
      goto case_262;
    }
#line 146
    if (c == 107) {
#line 146
      goto case_262;
    }
#line 152
    if (c == 263) {
#line 152
      goto case_263;
    }
#line 158
    if (c == 99) {
#line 158
      goto case_99;
    }
#line 165
    if (c == 116) {
#line 165
      goto case_116;
    }
#line 171
    if (c == 118) {
#line 171
      goto case_118;
    }
#line 177
    if (c == 264) {
#line 177
      goto case_264;
    }
#line 184
    if (c == 265) {
#line 184
      goto case_265;
    }
#line 188
    if (c == 104) {
#line 188
      goto case_104;
    }
#line 188
    if (c == 266) {
#line 188
      goto case_266;
    }
#line 188
    if (c == 267) {
#line 188
      goto case_267;
    }
#line 193
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 193
    exit(1);
    }
    case_256: /* CIL Label */ 
    {
#line 29
    xdico_assign_string(& dico_url.host, optarg);
    }
#line 30
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 35
    dico_url.port = str2port(optarg);
    }
#line 36
    if (dico_url.port == -1) {
      {
#line 37
      tmp = gettext("Invalid port");
#line 37
      dico_die(1, 4, 0, (char const   *)tmp);
      }
    }
#line 38
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 43
    xdico_assign_string(& dico_url.req.database, optarg);
    }
#line 44
    goto switch_break;
    case_257: /* CIL Label */ 
    {
#line 49
    source_addr = get_ipaddr(optarg);
    }
#line 50
    if (source_addr == 0UL) {
      {
#line 51
      tmp___0 = gettext("%s: Invalid IP or unknown host name");
#line 51
      dico_die(1, 0, 4, (char const   *)tmp___0, optarg);
      }
    }
#line 53
    goto switch_break;
    case_109: /* CIL Label */ 
#line 60
    mode = (enum dico_client_mode )1;
#line 61
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 66
    xdico_assign_string(& dico_url.req.strategy, optarg);
#line 67
    mode = (enum dico_client_mode )1;
    }
#line 68
    goto switch_break;
    case_259: /* CIL Label */ 
    case_258: /* CIL Label */ 
    {
#line 75
    tmp___1 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p),
                      10);
#line 75
    levenshtein_threshold = (unsigned int )tmp___1;
    }
#line 76
    if (*p) {
      {
#line 77
      tmp___2 = gettext("%s: invalid number");
#line 77
      dico_die(1, 4, 0, (char const   *)tmp___2, optarg);
      }
    }
#line 78
    goto switch_break;
    case_68: /* CIL Label */ 
#line 83
    mode = (enum dico_client_mode )2;
#line 84
    goto switch_break;
    case_83: /* CIL Label */ 
#line 89
    mode = (enum dico_client_mode )3;
#line 90
    goto switch_break;
    case_72: /* CIL Label */ 
#line 95
    mode = (enum dico_client_mode )4;
#line 96
    goto switch_break;
    case_105: /* CIL Label */ 
#line 101
    mode = (enum dico_client_mode )5;
#line 102
    dico_url.req.database = optarg;
#line 103
    goto switch_break;
    case_73: /* CIL Label */ 
#line 108
    mode = (enum dico_client_mode )6;
#line 109
    goto switch_break;
    case_113: /* CIL Label */ 
#line 114
    quiet_option = 1;
#line 115
    goto switch_break;
    case_97: /* CIL Label */ 
#line 122
    noauth_option = 1;
#line 123
    goto switch_break;
    case_260: /* CIL Label */ 
    {
#line 128
    sasl_enable(1);
    }
#line 129
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 134
    sasl_enable(0);
    }
#line 135
    goto switch_break;
    case_117: /* CIL Label */ 
#line 140
    default_cred.user = optarg;
#line 141
    goto switch_break;
    case_262: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 147
    default_cred.pass = optarg;
#line 148
    goto switch_break;
    case_263: /* CIL Label */ 
#line 153
    autologin_file = optarg;
#line 154
    goto switch_break;
    case_99: /* CIL Label */ 
#line 159
    client = optarg;
#line 160
    goto switch_break;
    case_116: /* CIL Label */ 
#line 166
    transcript = 1;
#line 167
    goto switch_break;
    case_118: /* CIL Label */ 
#line 172
    debug_level ++;
#line 173
    goto switch_break;
    case_264: /* CIL Label */ 
    {
#line 178
    n = 1;
#line 179
    dico_stream_ioctl(debug_stream, 4, (void *)(& n));
    }
#line 180
    goto switch_break;
    case_265: /* CIL Label */ 
#line 185
    debug_source_info = 1;
#line 186
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 188
    print_help();
#line 188
    exit(0);
    }
#line 188
    goto switch_break;
    case_266: /* CIL Label */ 
    {
#line 188
    print_usage();
#line 188
    exit(0);
    }
#line 188
    goto switch_break;
    case_267: /* CIL Label */ 
    {
#line 188
    print_version(program_version, stdout);
#line 188
    exit(0);
    }
#line 188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  *index___0 = optind;
#line 194
  return;
}
}
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
char *skipws(char *buf___1 ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (*buf___1) {
#line 22
      if (((int )*buf___1 & -128) == 0) {
        {
#line 22
        tmp = __ctype_b_loc();
        }
#line 22
        if (! ((int const   )*(*tmp + (int )*buf___1) & 8192)) {
#line 22
          goto while_break;
        }
      } else {
#line 22
        goto while_break;
      }
    } else {
#line 22
      goto while_break;
    }
#line 23
    buf___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return (buf___1);
}
}
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
int hostcmp(char const   *a , char const   *b ) 
{ 
  struct hostent *hp ;
  struct hostent *tmp ;
  char **addrlist ;
  char *dptr ;
  char **addr ;
  size_t i___0 ;
  size_t count ;
  size_t entry_length ;
  int entry_type ;
  void *tmp___0 ;
  char **p ;
  int tmp___1 ;

  {
  {
#line 33
  tmp = gethostbyname(a);
#line 33
  hp = tmp;
  }
#line 41
  if (! hp) {
#line 42
    return (1);
  }
#line 44
  count = (size_t )1;
#line 44
  addr = hp->h_addr_list;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! *addr) {
#line 44
      goto while_break;
    }
#line 45
    count ++;
#line 44
    addr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  tmp___0 = xmalloc((size_t )((unsigned long )count * (sizeof(*addrlist) + (unsigned long )hp->h_length) - (unsigned long )hp->h_length));
#line 46
  addrlist = (char **)tmp___0;
#line 48
  dptr = (char *)(addrlist + count);
#line 49
  i___0 = (size_t )0;
  }
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 49
    if (! (i___0 < count - 1U)) {
#line 49
      goto while_break___0;
    }
    {
#line 50
    memcpy((void */* __restrict  */)dptr, (void const   */* __restrict  */)*(hp->h_addr_list + i___0),
           (size_t )hp->h_length);
#line 51
    *(addrlist + i___0) = dptr;
#line 52
    dptr += hp->h_length;
#line 49
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 54
  *(addrlist + i___0) = (char *)((void *)0);
#line 55
  entry_length = (size_t )hp->h_length;
#line 56
  entry_type = hp->h_addrtype;
#line 58
  hp = gethostbyname(b);
  }
#line 59
  if (! hp) {
    {
#line 60
    free((void *)addrlist);
    }
#line 61
    return (1);
  } else
#line 59
  if (entry_length != (size_t )hp->h_length) {
    {
#line 60
    free((void *)addrlist);
    }
#line 61
    return (1);
  } else
#line 59
  if (entry_type != hp->h_addrtype) {
    {
#line 60
    free((void *)addrlist);
    }
#line 61
    return (1);
  }
#line 64
  addr = addrlist;
  {
#line 64
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 64
    if (! *addr) {
#line 64
      goto while_break___1;
    }
#line 67
    p = hp->h_addr_list;
    {
#line 67
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 67
      if (! *p) {
#line 67
        goto while_break___2;
      }
      {
#line 68
      tmp___1 = memcmp((void const   *)*addr, (void const   *)*p, entry_length);
      }
#line 68
      if (tmp___1 == 0) {
        {
#line 69
        free((void *)addrlist);
        }
#line 70
        return (0);
      }
#line 67
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 64
    addr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 74
  free((void *)addrlist);
  }
#line 75
  return (1);
}
}
#line 78 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
static void argv_expand(int *pargc , char ***pargv , int xargc , char **xargv ) 
{ 
  size_t nargc ;
  char **nargv ;
  void *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 81
  nargc = (size_t )((*pargc + xargc) + 1);
#line 82
  tmp = xrealloc((void *)*pargv, (size_t )((unsigned long )(nargc + 1U) * sizeof(*(nargv + 0))));
#line 82
  nargv = (char **)tmp;
#line 83
  *(nargv + *pargc) = xstrdup("\n");
#line 84
  memcpy((void */* __restrict  */)((nargv + 1) + *pargc), (void const   */* __restrict  */)xargv,
         (size_t )((unsigned long )(xargc + 1) * sizeof(*(nargv + 0))));
#line 85
  *pargc = (int )nargc;
#line 86
  *pargv = nargv;
  }
#line 87
  return;
}
}
#line 107 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
static struct keyword kwtab[10]  = 
#line 107
  {      {(char *)"login", 1, (enum kw_tok )0}, 
        {(char *)"password", 1, (enum kw_tok )1}, 
        {(char *)"noauth", 0, (enum kw_tok )2}, 
        {(char *)"nosasl", 0, (enum kw_tok )3}, 
        {(char *)"sasl", 0, (enum kw_tok )4}, 
        {(char *)"mechanism", 1, (enum kw_tok )5}, 
        {(char *)"realm", 1, (enum kw_tok )6}, 
        {(char *)"service", 1, (enum kw_tok )7}, 
        {(char *)"host", 1, (enum kw_tok )8}, 
        {(char *)((void *)0), 0, 0U}};
#line 120 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
static struct keyword *findkw(char const   *name ) 
{ 
  struct keyword *p ;
  int tmp ;

  {
#line 124
  p = kwtab;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! p->name) {
#line 124
      goto while_break;
    }
    {
#line 125
    tmp = strcmp((char const   *)p->name, name);
    }
#line 125
    if (tmp == 0) {
#line 126
      return (p);
    }
#line 124
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((struct keyword *)((void *)0));
}
}
#line 130 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
static int _cred_free(void *item , void *data ) 
{ 


  {
  {
#line 133
  free(item);
  }
#line 134
  return (0);
}
}
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c"
int parse_autologin(char const   *filename___0 , char *host , struct auth_cred *pcred ,
                    int *pflags ) 
{ 
  FILE *fp ;
  char *buf___1 ;
  size_t n ;
  int def_argc ;
  char **def_argv ;
  int def_line ;
  char **host_argv ;
  int host_argc ;
  char ***pp_argv ;
  int *pp_argc ;
  char **p_argv ;
  int line___0 ;
  int flags ;
  int stop ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  unsigned int n___0 ;
  char *tmp___2 ;
  int rc ;
  char *p ;
  size_t len___0 ;
  int argc ;
  char **argv ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int n___1 ;
  char *tmp___6 ;
  int tmp___7 ;
  unsigned int n___2 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  __ssize_t tmp___11 ;
  unsigned int n___3 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  struct keyword *kw ;
  struct keyword *tmp___15 ;
  char *arg ;
  char *tmp___16 ;
  char *tmp___17 ;
  int i___0 ;
  int c ;
  char **v ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;

  {
  {
#line 143
  buf___1 = (char *)((void *)0);
#line 144
  n = (size_t )0;
#line 145
  def_argc = 0;
#line 146
  def_argv = (char **)((void *)0);
#line 147
  def_line = 0;
#line 148
  host_argv = (char **)((void *)0);
#line 149
  host_argc = 0;
#line 152
  p_argv = (char **)((void *)0);
#line 153
  line___0 = 0;
#line 154
  flags = 0;
#line 155
  stop = 0;
#line 157
  fp = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r");
  }
#line 158
  if (! fp) {
    {
#line 159
    tmp___1 = __errno_location();
    }
#line 159
    if (*tmp___1 != 2) {
      {
#line 160
      tmp = gettext("Cannot open autologin file %s");
#line 160
      tmp___0 = __errno_location();
#line 160
      dico_log(4, *tmp___0, (char const   *)tmp, filename___0);
      }
    }
#line 163
    return (1);
  } else {
    {
#line 165
    while (1) {
      while_continue: /* CIL Label */ ;
#line 165
      if (debug_level >= 1) {
#line 165
        if (debug_source_info) {
          {
#line 165
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 165
            n___0 = 165U;
#line 165
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c");
#line 165
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___0));
            }
#line 165
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 165
        tmp___2 = gettext("Reading autologin file %s...\n");
#line 165
        stream_printf(debug_stream, (char const   *)tmp___2, filename___0);
        }
      }
#line 165
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 167
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 167
    tmp___11 = getline((char **/* __restrict  */)(& buf___1), (size_t */* __restrict  */)(& n),
                       (FILE */* __restrict  */)fp);
    }
#line 167
    if (tmp___11 > 0) {
#line 167
      if (! (n > 0U)) {
#line 167
        goto while_break___1;
      }
    } else {
#line 167
      goto while_break___1;
    }
    {
#line 174
    line___0 ++;
#line 175
    len___0 = strlen((char const   *)buf___1);
    }
#line 176
    if (len___0 > 1U) {
#line 176
      if ((int )*(buf___1 + (len___0 - 1U)) == 10) {
#line 177
        *(buf___1 + (len___0 - 1U)) = (char)0;
      }
    }
    {
#line 178
    p = skipws(buf___1);
    }
#line 179
    if ((int )*p == 0) {
#line 180
      goto while_continue___1;
    } else
#line 179
    if ((int )*p == 35) {
#line 180
      goto while_continue___1;
    }
    {
#line 182
    rc = dico_argcv_get((char const   *)buf___1, "", "#", & argc, & argv);
    }
#line 182
    if (rc) {
      {
#line 183
      tmp___3 = gettext("dico_argcv_get failed");
#line 183
      dico_log(4, rc, (char const   *)tmp___3);
#line 184
      fclose(fp);
#line 185
      free((void *)buf___1);
      }
#line 186
      return (1);
    }
#line 189
    if (pp_argv) {
      {
#line 190
      tmp___4 = strcmp((char const   *)*(argv + 0), "machine");
      }
#line 190
      if (tmp___4 == 0) {
#line 190
        goto _L;
      } else {
        {
#line 190
        tmp___5 = strcmp((char const   *)*(argv + 0), "default");
        }
#line 190
        if (tmp___5 == 0) {
          _L: /* CIL Label */ 
#line 192
          if (stop) {
            {
#line 193
            dico_argcv_free(argc, argv);
            }
#line 194
            goto while_break___1;
          }
#line 196
          pp_argv = (char ***)((void *)0);
#line 197
          pp_argc = (int *)0;
        } else {
          {
#line 199
          argv_expand(pp_argc, pp_argv, argc, argv);
#line 200
          free((void *)argv);
          }
#line 201
          goto while_continue___1;
        }
      }
    }
    {
#line 204
    tmp___10 = strcmp((char const   *)*(argv + 0), "machine");
    }
#line 204
    if (tmp___10 == 0) {
      {
#line 205
      tmp___7 = hostcmp((char const   *)*(argv + 1), (char const   *)host);
      }
#line 205
      if (tmp___7 == 0) {
        {
#line 206
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 206
          if (debug_level >= 1) {
#line 206
            if (debug_source_info) {
              {
#line 206
              while (1) {
                while_continue___3: /* CIL Label */ ;
                {
#line 206
                n___1 = 206U;
#line 206
                dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c");
#line 206
                dico_stream_ioctl(debug_stream, 3, (void *)(& n___1));
                }
#line 206
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
            {
#line 206
            tmp___6 = gettext("Found matching line %d\n");
#line 206
            stream_printf(debug_stream, (char const   *)tmp___6, line___0);
            }
          }
#line 206
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 207
        stop = 1;
#line 208
        host_argc = argc;
#line 209
        host_argv = argv;
#line 210
        pp_argc = & host_argc;
#line 211
        pp_argv = & host_argv;
#line 212
        def_line = line___0;
#line 213
        goto while_continue___1;
      }
    } else {
      {
#line 215
      tmp___9 = strcmp((char const   *)*(argv + 0), "default");
      }
#line 215
      if (tmp___9 == 0) {
        {
#line 216
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 216
          if (debug_level >= 1) {
#line 216
            if (debug_source_info) {
              {
#line 216
              while (1) {
                while_continue___5: /* CIL Label */ ;
                {
#line 216
                n___2 = 216U;
#line 216
                dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c");
#line 216
                dico_stream_ioctl(debug_stream, 3, (void *)(& n___2));
                }
#line 216
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
            {
#line 216
            tmp___8 = gettext("Found default line %d\n");
#line 216
            stream_printf(debug_stream, (char const   *)tmp___8, line___0);
            }
          }
#line 216
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 217
        def_argc = argc;
#line 218
        def_argv = argv;
#line 219
        pp_argc = & def_argc;
#line 220
        pp_argv = & def_argv;
#line 221
        def_line = line___0;
#line 222
        goto while_continue___1;
      }
    }
    {
#line 224
    dico_argcv_free(argc, argv);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 226
  fclose(fp);
#line 227
  free((void *)buf___1);
  }
#line 229
  if (host_argv) {
#line 230
    p_argv = host_argv + 2;
  } else
#line 231
  if (def_argv) {
#line 232
    p_argv = def_argv + 1;
  } else {
    {
#line 234
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 234
      if (debug_level >= 1) {
#line 234
        if (debug_source_info) {
          {
#line 234
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 234
            n___3 = 234U;
#line 234
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dico/autologin.c");
#line 234
            dico_stream_ioctl(debug_stream, 3, (void *)(& n___3));
            }
#line 234
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
        {
#line 234
        tmp___12 = gettext("No matching line found\n");
#line 234
        tmp___13 = strlen((char const   *)tmp___12);
#line 234
        tmp___14 = gettext("No matching line found\n");
#line 234
        dico_stream_write(debug_stream, (void const   *)tmp___14, tmp___13);
        }
      }
#line 234
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 235
    p_argv = (char **)((void *)0);
  }
#line 238
  if (p_argv) {
    {
#line 239
    line___0 = def_line;
#line 241
    pcred->sasl = sasl_enabled_p();
    }
    {
#line 242
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 242
      if (! *p_argv) {
#line 242
        goto while_break___8;
      }
      {
#line 243
      tmp___20 = strcmp((char const   *)*p_argv, "\n");
      }
#line 243
      if (tmp___20 == 0) {
#line 244
        line___0 ++;
#line 245
        p_argv ++;
      } else {
        {
#line 247
        tmp___15 = findkw((char const   *)*p_argv);
#line 247
        kw = tmp___15;
        }
#line 250
        if (! kw) {
          {
#line 251
          tmp___16 = gettext("%s:%d: unknown keyword");
#line 251
          dico_log(4, 0, (char const   *)tmp___16, filename___0, line___0);
#line 253
          p_argv ++;
          }
#line 254
          goto while_continue___8;
        }
#line 257
        if (kw->arg) {
#line 258
          if (! *(p_argv + 1)) {
            {
#line 259
            tmp___17 = gettext("%s:%d: %s without argument");
#line 259
            dico_log(4, 0, (char const   *)tmp___17, filename___0, line___0, *(p_argv + 0));
            }
#line 262
            goto while_break___8;
          }
#line 264
          arg = *(p_argv + 1);
#line 265
          p_argv += 2;
        } else {
#line 267
          p_argv ++;
        }
        {
#line 270
        if ((unsigned int )kw->tok == 0U) {
#line 270
          goto case_0;
        }
#line 275
        if ((unsigned int )kw->tok == 1U) {
#line 275
          goto case_1;
        }
#line 280
        if ((unsigned int )kw->tok == 7U) {
#line 280
          goto case_7;
        }
#line 284
        if ((unsigned int )kw->tok == 6U) {
#line 284
          goto case_6;
        }
#line 288
        if ((unsigned int )kw->tok == 8U) {
#line 288
          goto case_8;
        }
#line 292
        if ((unsigned int )kw->tok == 2U) {
#line 292
          goto case_2;
        }
#line 296
        if ((unsigned int )kw->tok == 3U) {
#line 296
          goto case_3;
        }
#line 300
        if ((unsigned int )kw->tok == 4U) {
#line 300
          goto case_4;
        }
#line 304
        if ((unsigned int )kw->tok == 5U) {
#line 304
          goto case_5;
        }
#line 269
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 271
        pcred->user = xstrdup((char const   *)arg);
#line 272
        flags |= 1;
        }
#line 273
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 276
        pcred->pass = xstrdup((char const   *)arg);
#line 277
        flags |= 2;
        }
#line 278
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 281
        pcred->service = xstrdup((char const   *)arg);
        }
#line 282
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 285
        pcred->realm = xstrdup((char const   *)arg);
        }
#line 286
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 289
        pcred->hostname = xstrdup((char const   *)arg);
        }
#line 290
        goto switch_break;
        case_2: /* CIL Label */ 
#line 293
        flags |= 4;
#line 294
        goto switch_break;
        case_3: /* CIL Label */ 
#line 297
        pcred->sasl = 0;
#line 298
        goto switch_break;
        case_4: /* CIL Label */ 
#line 301
        pcred->sasl = 1;
#line 302
        goto switch_break;
        case_5: /* CIL Label */ 
#line 308
        if (! (flags & 8)) {
          {
#line 309
          pcred->mech = xdico_list_create();
#line 310
          dico_list_set_free_item(pcred->mech, & _cred_free, (void *)0);
#line 311
          flags |= 8;
          }
        }
        {
#line 313
        tmp___19 = dico_argcv_get((char const   *)arg, ",", (char const   *)((void *)0),
                                  & c, & v);
        }
#line 313
        if (tmp___19) {
          {
#line 314
          tmp___18 = gettext("%s:%d: not enough memory");
#line 314
          dico_log(4, 0, (char const   *)tmp___18, filename___0, line___0);
#line 317
          exit(1);
          }
        }
#line 320
        i___0 = 0;
        {
#line 320
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 320
          if (! (i___0 < c)) {
#line 320
            goto while_break___9;
          }
          {
#line 321
          xdico_list_append(pcred->mech, (void *)*(v + i___0));
#line 320
          i___0 ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 323
        free((void *)v);
        }
#line 324
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 330
  dico_argcv_free(def_argc, def_argv);
#line 331
  dico_argcv_free(host_argc, host_argv);
  }
#line 333
  if (pflags) {
#line 334
    *pflags = flags;
  }
#line 335
  return (0);
}
}
